internal MIConvexHull.ConnectorList : object {
private FaceConnector first
private FaceConnector last
public FaceConnector First
public FaceConnector get_First()
private void AddFirst(FaceConnector connector)
public void Add(FaceConnector element)
public void Remove(FaceConnector connector)
}
public MIConvexHull.ConvexFace`2 : object {
private TFace[] <Adjacency>k__BackingField
private TVertex[] <Vertices>k__BackingField
private Double[] <Normal>k__BackingField
public TFace[] Adjacency
public TVertex[] Vertices
public Double[] Normal
public TFace[] get_Adjacency()
public void set_Adjacency(TFace[] value)
public TVertex[] get_Vertices()
public void set_Vertices(TVertex[] value)
public Double[] get_Normal()
public void set_Normal(Double[] value)
}
internal MIConvexHull.ConvexFaceInternal : object {
public ConvexFaceInternal[] AdjacentFaces
public VertexBuffer VerticesBeyond
public VertexWrap FurthestVertex
public VertexWrap[] Vertices
public Double[] Normal
public bool IsNormalFlipped
public double Offset
public int Tag
public ConvexFaceInternal Previous
public ConvexFaceInternal Next
public bool InList
public void .ctor(int dimension, VertexBuffer beyondList)
}
public MIConvexHull.ConvexHull : object {
private Func`2<Double[], DefaultVertex> <>f__am$cache0
public ConvexHull`2<TVertex, TFace> Create(IEnumerable`1<TVertex> data)
public ConvexHull`2<TVertex, DefaultConvexFace`1<TVertex>> Create(IEnumerable`1<TVertex> data)
public ConvexHull`2<DefaultVertex, DefaultConvexFace`1<DefaultVertex>> Create(IEnumerable`1<Double[]> data)
private DefaultVertex <Create>m__0(Double[] p)
}
public MIConvexHull.ConvexHull`2 : object {
private IEnumerable`1<TVertex> <Points>k__BackingField
private IEnumerable`1<TFace> <Faces>k__BackingField
public IEnumerable`1<TVertex> Points
public IEnumerable`1<TFace> Faces
public IEnumerable`1<TVertex> get_Points()
private void set_Points(IEnumerable`1<TVertex> value)
public IEnumerable`1<TFace> get_Faces()
private void set_Faces(IEnumerable`1<TFace> value)
public ConvexHull`2<TVertex, TFace> Create(IEnumerable`1<TVertex> data)
}
internal MIConvexHull.ConvexHullInternal : object {
private double PlaneDistanceTolerance
private bool Computed
private int Dimension
private List`1<VertexWrap> InputVertices
private List`1<VertexWrap> ConvexHull
private FaceList UnprocessedFaces
private List`1<ConvexFaceInternal> ConvexFaces
private VertexWrap CurrentVertex
private double MaxDistance
private VertexWrap FurthestVertex
private Double[] Center
private ConvexFaceInternal[] UpdateBuffer
private Int32[] UpdateIndices
private Stack`1<ConvexFaceInternal> TraverseStack
private VertexBuffer EmptyBuffer
private VertexBuffer BeyondBuffer
private List`1<ConvexFaceInternal> AffectedFaceBuffer
private List`1<DeferredFace> ConeFaceBuffer
private HashSet`1<VertexWrap> SingularVertices
private int ConnectorTableSize
private ConnectorList[] ConnectorTable
private ObjectManager ObjectManager
private MathHelper MathHelper
private Func`2<int, ConnectorList> <>f__am$cache0
private Func`3<IVertex, int, VertexWrap> <>f__am$cache1
private void .ctor(IEnumerable`1<IVertex> vertices)
private void Initialize()
private int DetermineDimension()
private ConvexFaceInternal[] InitiateFaceDatabase()
private bool CalculateFacePlane(ConvexFaceInternal face)
private void TagAffectedFaces(ConvexFaceInternal currentFace)
private void TraverseAffectedFaces(ConvexFaceInternal currentFace)
private void UpdateAdjacency(ConvexFaceInternal l, ConvexFaceInternal r)
private DeferredFace MakeDeferredFace(ConvexFaceInternal face, int faceIndex, ConvexFaceInternal pivot, int pivotIndex, ConvexFaceInternal oldFace)
private void ConnectFace(FaceConnector connector)
private bool CreateCone()
private void CommitCone()
private void IsBeyond(ConvexFaceInternal face, VertexBuffer beyondVertices, VertexWrap v)
private void FindBeyondVertices(ConvexFaceInternal face)
private void FindBeyondVertices(ConvexFaceInternal face, VertexBuffer beyond, VertexBuffer beyond1)
private void UpdateCenter()
private void RollbackCenter()
private void InitConvexHull()
private List`1<VertexWrap> FindInitialPoints(List`1<VertexWrap> extremes)
private double GetSquaredDistanceSum(VertexWrap pivot, List`1<VertexWrap> initialPoints)
private List`1<VertexWrap> FindExtremes()
private void ThrowSingular()
private void HandleSingular()
private void FindConvexHull()
private IEnumerable`1<TVertex> GetConvexHullInternal(bool onlyCompute)
private IEnumerable`1<TFace> GetConvexFacesInternal()
internal List`1<ConvexFaceInternal> GetConvexFacesInternal(IEnumerable`1<TVertex> data)
internal void GetConvexHullAndFaces(IEnumerable`1<IVertex> data, IEnumerable`1& points, IEnumerable`1& faces)
private ConnectorList <Initialize>m__0(int _)
private VertexWrap <ConvexHullInternal>m__1(IVertex v, int i)
private TVertex <GetConvexHullInternal`1>m__2(VertexWrap v)
private TVertex <GetConvexHullInternal`1>m__3(VertexWrap v)
}
public MIConvexHull.DefaultVertex : object {
private Double[] <Position>k__BackingField
public Double[] Position
public Double[] get_Position()
public void set_Position(Double[] value)
}
internal MIConvexHull.DeferredFace : object {
public ConvexFaceInternal Face
public ConvexFaceInternal Pivot
public ConvexFaceInternal OldFace
public int FaceIndex
public int PivotIndex
}
public MIConvexHull.DelaunayTriangulation`2 : object {
private IEnumerable`1<TCell> <Cells>k__BackingField
public IEnumerable`1<TCell> Cells
public IEnumerable`1<TCell> get_Cells()
private void set_Cells(IEnumerable`1<TCell> value)
public DelaunayTriangulation`2<TVertex, TCell> Create(IEnumerable`1<TVertex> data)
}
internal MIConvexHull.FaceConnector : object {
public ConvexFaceInternal Face
public int EdgeIndex
public Int32[] Vertices
public UInt32 HashCode
public FaceConnector Previous
public FaceConnector Next
public void .ctor(int dimension)
public void Update(ConvexFaceInternal face, int edgeIndex, int dim)
public bool AreConnectable(FaceConnector a, FaceConnector b, int dim)
public void Connect(FaceConnector a, FaceConnector b)
}
internal MIConvexHull.FaceList : object {
private ConvexFaceInternal first
private ConvexFaceInternal last
public ConvexFaceInternal First
public ConvexFaceInternal get_First()
private void AddFirst(ConvexFaceInternal face)
public void Add(ConvexFaceInternal face)
public void Remove(ConvexFaceInternal face)
}
public MIConvexHull.ITriangulation`2 {
public IEnumerable`1<TCell> Cells
public IEnumerable`1<TCell> get_Cells()
}
public MIConvexHull.IVertex {
public Double[] Position
public Double[] get_Position()
public void set_Position(Double[] value)
}
internal MIConvexHull.MathHelper : object {
private int Dimension
private Double[] ntX
private Double[] ntY
private Double[] ntZ
private Double[] nDNormalSolveVector
private Double[0...,0...] nDMatrix
private Double[][] jaggedNDMatrix
public void .ctor(int dimension)
private void GaussElimination(int nDim, Double[][] pfMatr, Double[] pfVect, Double[] pfSolution)
public double LengthSquared(Double[] x)
private void Normalize(Double[] x)
public void SubtractFast(Double[] x, Double[] y, Double[] target)
private void FindNormalVector4D(VertexWrap[] vertices, Double[] normal)
private void FindNormalVector3D(VertexWrap[] vertices, Double[] normal)
private void FindNormalVector2D(VertexWrap[] vertices, Double[] normal)
public void FindNormalVector(VertexWrap[] vertices, Double[] normalData)
public double GetVertexDistance(VertexWrap v, ConvexFaceInternal f)
}
internal MIConvexHull.ObjectManager : object {
private int Dimension
private Stack`1<ConvexFaceInternal> RecycledFaceStack
private Stack`1<FaceConnector> ConnectorStack
private Stack`1<VertexBuffer> EmptyBufferStack
private Stack`1<DeferredFace> DeferredFaceStack
public void .ctor(int dimension)
public void DepositFace(ConvexFaceInternal face)
public ConvexFaceInternal GetFace()
public void DepositConnector(FaceConnector connector)
public FaceConnector GetConnector()
public void DepositVertexBuffer(VertexBuffer buffer)
public VertexBuffer GetVertexBuffer()
public void DepositDeferredFace(DeferredFace face)
public DeferredFace GetDeferredFace()
}
public MIConvexHull.Triangulation : object {
private Func`2<Double[], DefaultVertex> <>f__am$cache0
public ITriangulation`2<TVertex, DefaultTriangulationCell`1<TVertex>> CreateDelaunay(IEnumerable`1<TVertex> data)
public ITriangulation`2<DefaultVertex, DefaultTriangulationCell`1<DefaultVertex>> CreateDelaunay(IEnumerable`1<Double[]> data)
public ITriangulation`2<TVertex, TFace> CreateDelaunay(IEnumerable`1<TVertex> data)
private DefaultVertex <CreateDelaunay>m__0(Double[] p)
}
public MIConvexHull.Vertex2 : object {
private Double[] <Position>k__BackingField
public Double[] Position
public double x
public double y
public void .ctor(double x, double y)
public Double[] get_Position()
public void set_Position(Double[] value)
public double get_x()
public double get_y()
public Vertex2 op_Implicit(Vector2 v)
public Vector2 op_Implicit(Vertex2 v)
}
public MIConvexHull.Vertex3 : object {
private Double[] <Position>k__BackingField
public Double[] Position
public double x
public double y
public double z
public void .ctor(double x, double y, double z)
public Double[] get_Position()
public void set_Position(Double[] value)
public double get_x()
public double get_y()
public double get_z()
public Vertex3 op_Implicit(Vector3 v)
public Vector3 op_Implicit(Vertex3 v)
}
internal MIConvexHull.VertexBuffer : object {
private VertexWrap[] items
private int count
private int capacity
public int Count
public VertexWrap Item
public int get_Count()
public VertexWrap get_Item(int i)
private void EnsureCapacity()
public void Add(VertexWrap item)
public void Clear()
}
internal MIConvexHull.VertexWrap : object {
public IVertex Vertex
public Double[] PositionData
public int Index
public bool Marked
}
internal MIConvexHull.VertexWrapComparer : object {
public VertexWrapComparer Instance
public int Compare(VertexWrap x, VertexWrap y)
}
public MIConvexHull.VoronoiEdge`2 : object {
private TCell <Source>k__BackingField
private TCell <Target>k__BackingField
public TCell Source
public TCell Target
public void .ctor(TCell source, TCell target)
public TCell get_Source()
internal void set_Source(TCell value)
public TCell get_Target()
internal void set_Target(TCell value)
public bool Equals(object obj)
public int GetHashCode()
}
public MIConvexHull.VoronoiMesh : object {
private Func`2<Double[], DefaultVertex> <>f__am$cache0
public VoronoiMesh`3<TVertex, TCell, TEdge> Create(IEnumerable`1<TVertex> data)
public VoronoiMesh`3<TVertex, DefaultTriangulationCell`1<TVertex>, VoronoiEdge`2<TVertex, DefaultTriangulationCell`1<TVertex>>> Create(IEnumerable`1<TVertex> data)
public VoronoiMesh`3<DefaultVertex, DefaultTriangulationCell`1<DefaultVertex>, VoronoiEdge`2<DefaultVertex, DefaultTriangulationCell`1<DefaultVertex>>> Create(IEnumerable`1<Double[]> data)
public VoronoiMesh`3<TVertex, TCell, VoronoiEdge`2<TVertex, TCell>> Create(IEnumerable`1<TVertex> data)
private DefaultVertex <Create>m__0(Double[] p)
}
public MIConvexHull.VoronoiMesh`3 : object {
private IEnumerable`1<TCell> <Vertices>k__BackingField
private IEnumerable`1<TEdge> <Edges>k__BackingField
public IEnumerable`1<TCell> Vertices
public IEnumerable`1<TEdge> Edges
public IEnumerable`1<TCell> get_Vertices()
private void set_Vertices(IEnumerable`1<TCell> value)
public IEnumerable`1<TEdge> get_Edges()
private void set_Edges(IEnumerable`1<TEdge> value)
public VoronoiMesh`3<TVertex, TCell, TEdge> Create(IEnumerable`1<TVertex> data)
}
public UnityEngine.UnityMeshEx : object {
public Mesh ToConvexHull(Mesh mesh)
}
