internal Microsoft.CSharp.CSharpCodeGenerator : object {
private Char[] s_periodArray
private ExposedTabStringIndentedTextWriter _output
private CodeGeneratorOptions _options
private CodeTypeDeclaration _currentClass
private CodeTypeMember _currentMember
private bool _inNestedBinary
private IDictionary`2<string, string> _provOptions
private int ParameterMultilineThreshold
private int MaxLineLength
private GeneratorSupport LanguageSupport
private String[][] s_keywords
private bool _generatingForLoop
private string ErrorRegexPattern
private Regex RelatedSymbolsRegex
private string FileExtension
private string CompilerName
private string CurrentTypeName
private int Indent
private bool IsCurrentInterface
private bool IsCurrentClass
private bool IsCurrentStruct
private bool IsCurrentEnum
private bool IsCurrentDelegate
private string NullToken
private CodeGeneratorOptions Options
private TextWriter Output
internal void .ctor(IDictionary`2<string, string> providerOptions)
private string get_FileExtension()
private string get_CompilerName()
private string get_CurrentTypeName()
private int get_Indent()
private void set_Indent(int value)
private bool get_IsCurrentInterface()
private bool get_IsCurrentClass()
private bool get_IsCurrentStruct()
private bool get_IsCurrentEnum()
private bool get_IsCurrentDelegate()
private string get_NullToken()
private CodeGeneratorOptions get_Options()
private TextWriter get_Output()
private string QuoteSnippetStringCStyle(string value)
private string QuoteSnippetStringVerbatimStyle(string value)
private string QuoteSnippetString(string value)
private void ContinueOnNewLine(string st)
private void OutputIdentifier(string ident)
private void OutputType(CodeTypeReference typeRef)
private void GenerateArrayCreateExpression(CodeArrayCreateExpression e)
private void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e)
private void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
private void GenerateCastExpression(CodeCastExpression e)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
private void GenerateDefaultValueExpression(CodeDefaultValueExpression e)
private void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e)
private void GenerateEvents(CodeTypeDeclaration e)
private void GenerateFields(CodeTypeDeclaration e)
private void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e)
private void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
private void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e)
private void GenerateIndexerExpression(CodeIndexerExpression e)
private void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e)
private void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e)
private void GenerateSnippetExpression(CodeSnippetExpression e)
private void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e)
private void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e)
private bool GetUserData(CodeObject e, string property, bool defaultValue)
private void GenerateNamespace(CodeNamespace e)
private void GenerateStatement(CodeStatement e)
private void GenerateStatements(CodeStatementCollection stmts)
private void GenerateNamespaceImports(CodeNamespace e)
private void GenerateEventReferenceExpression(CodeEventReferenceExpression e)
private void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
private void GenerateObjectCreateExpression(CodeObjectCreateExpression e)
private void GeneratePrimitiveExpression(CodePrimitiveExpression e)
private void GeneratePrimitiveExpressionBase(CodePrimitiveExpression e)
private void GeneratePrimitiveChar(char c)
private void AppendEscapedChar(StringBuilder b, char value)
private void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
private void GenerateThisReferenceExpression(CodeThisReferenceExpression e)
private void GenerateExpressionStatement(CodeExpressionStatement e)
private void GenerateIterationStatement(CodeIterationStatement e)
private void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e)
private void GenerateComment(CodeComment e)
private void GenerateCommentStatement(CodeCommentStatement e)
private void GenerateCommentStatements(CodeCommentStatementCollection e)
private void GenerateMethodReturnStatement(CodeMethodReturnStatement e)
private void GenerateConditionStatement(CodeConditionStatement e)
private void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e)
private void GenerateAssignStatement(CodeAssignStatement e)
private void GenerateAttachEventStatement(CodeAttachEventStatement e)
private void GenerateRemoveEventStatement(CodeRemoveEventStatement e)
private void GenerateSnippetStatement(CodeSnippetStatement e)
private void GenerateGotoStatement(CodeGotoStatement e)
private void GenerateLabeledStatement(CodeLabeledStatement e)
private void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
private void GenerateLinePragmaStart(CodeLinePragma e)
private void GenerateLinePragmaEnd(CodeLinePragma e)
private void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c)
private void GenerateExpression(CodeExpression e)
private void GenerateField(CodeMemberField e)
private void GenerateSnippetMember(CodeSnippetTypeMember e)
private void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
private void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c)
private void GenerateMethods(CodeTypeDeclaration e)
private void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c)
private void GenerateProperties(CodeTypeDeclaration e)
private void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c)
private void GenerateSingleFloatValue(float s)
private void GenerateDoubleValue(double d)
private void GenerateDecimalValue(decimal d)
private void OutputVTableModifier(MemberAttributes attributes)
private void OutputMemberAccessModifier(MemberAttributes attributes)
private void OutputMemberScopeModifier(MemberAttributes attributes)
private void OutputOperator(CodeBinaryOperatorType op)
private void OutputFieldScopeModifier(MemberAttributes attributes)
private void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e)
private void GenerateConstructors(CodeTypeDeclaration e)
private void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c)
private void GenerateTypeConstructor(CodeTypeConstructor e)
private void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e)
private void GenerateTypeOfExpression(CodeTypeOfExpression e)
private void GenerateType(CodeTypeDeclaration e)
private void GenerateTypes(CodeNamespace e)
private void GenerateTypeStart(CodeTypeDeclaration e)
private void GenerateTypeMember(CodeTypeMember member, CodeTypeDeclaration declaredType)
private void GenerateTypeConstructors(CodeTypeDeclaration e)
private void GenerateSnippetMembers(CodeTypeDeclaration e)
private void GenerateNestedTypes(CodeTypeDeclaration e)
private void GenerateNamespaces(CodeCompileUnit e)
private void OutputAttributeArgument(CodeAttributeArgument arg)
private void OutputDirection(FieldDirection dir)
private void OutputExpressionList(CodeExpressionCollection expressions)
private void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems)
private void OutputParameters(CodeParameterDeclarationExpressionCollection parameters)
private void OutputTypeNamePair(CodeTypeReference typeRef, string name)
private void OutputTypeParameters(CodeTypeParameterCollection typeParameters)
private void OutputTypeParameterConstraints(CodeTypeParameterCollection typeParameters)
private void OutputTypeAttributes(CodeTypeDeclaration e)
private void GenerateTypeEnd(CodeTypeDeclaration e)
private void GenerateNamespaceStart(CodeNamespace e)
private void GenerateCompileUnit(CodeCompileUnit e)
private void GenerateCompileUnitStart(CodeCompileUnit e)
private void GenerateCompileUnitEnd(CodeCompileUnit e)
private void GenerateDirectionExpression(CodeDirectionExpression e)
private void GenerateDirectives(CodeDirectiveCollection directives)
private void GenerateChecksumPragma(CodeChecksumPragma checksumPragma)
private void GenerateCodeRegionDirective(CodeRegionDirective regionDirective)
private void GenerateNamespaceEnd(CodeNamespace e)
private void GenerateNamespaceImport(CodeNamespaceImport e)
private void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
private void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
private void GenerateAttributes(CodeAttributeDeclarationCollection attributes)
private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix)
private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix, bool inLine)
public bool Supports(GeneratorSupport support)
public bool IsValidIdentifier(string value)
public void ValidateIdentifier(string value)
public string CreateValidIdentifier(string name)
public string CreateEscapedIdentifier(string name)
private string GetBaseTypeOutput(CodeTypeReference typeRef, bool preferBuiltInTypes)
private string GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments)
private void GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments, int start, int length, StringBuilder sb)
public string GetTypeOutput(CodeTypeReference typeRef)
private void OutputStartingBrace()
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
private CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e)
private CompilerResults FromFile(CompilerParameters options, string fileName)
private CompilerResults FromSource(CompilerParameters options, string source)
private CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
private void ResolveReferencedAssemblies(CompilerParameters options, CodeCompileUnit e)
private CompilerResults FromSourceBatch(CompilerParameters options, String[] sources)
private string JoinStringArray(String[] sa, string separator)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o)
private CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames)
private string BuildArgs(CompilerParameters options, String[] fileNames, IDictionary`2<string, string> providerOptions)
private CompilerError CreateErrorFromString(string error_string)
private string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension, bool keepFile)
}
public Microsoft.CSharp.CSharpCodeProvider : CodeDomProvider {
private CSharpCodeGenerator _generator
public string FileExtension
public void .ctor(IDictionary`2<string, string> providerOptions)
public string get_FileExtension()
public ICodeGenerator CreateGenerator()
public ICodeCompiler CreateCompiler()
public TypeConverter GetConverter(Type type)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
}
internal Microsoft.CSharp.CSharpMemberAttributeConverter : CSharpModifierAttributeConverter {
private CSharpMemberAttributeConverter <Default>k__BackingField
private String[] <Names>k__BackingField
private Object[] <Values>k__BackingField
public CSharpMemberAttributeConverter Default
protected String[] Names
protected Object[] Values
protected object DefaultValue
public CSharpMemberAttributeConverter get_Default()
protected String[] get_Names()
protected Object[] get_Values()
protected object get_DefaultValue()
}
internal Microsoft.CSharp.CSharpModifierAttributeConverter : TypeConverter {
protected Object[] Values
protected String[] Names
protected object DefaultValue
protected Object[] get_Values()
protected String[] get_Names()
protected object get_DefaultValue()
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
}
internal Microsoft.CSharp.CSharpTypeAttributeConverter : CSharpModifierAttributeConverter {
private CSharpTypeAttributeConverter <Default>k__BackingField
private String[] <Names>k__BackingField
private Object[] <Values>k__BackingField
public CSharpTypeAttributeConverter Default
protected String[] Names
protected Object[] Values
protected object DefaultValue
public CSharpTypeAttributeConverter get_Default()
protected String[] get_Names()
protected Object[] get_Values()
protected object get_DefaultValue()
}
internal Microsoft.VisualBasic.VBCodeGenerator : CodeCompiler {
private Char[] s_periodArray
private int MaxLineLength
private GeneratorSupport LanguageSupport
private int _statementDepth
private IDictionary`2<string, string> _provOptions
private String[][] s_keywords
protected string FileExtension
protected string CompilerName
private bool IsCurrentModule
protected string NullToken
internal void .ctor(IDictionary`2<string, string> providerOptions)
protected string get_FileExtension()
protected string get_CompilerName()
private bool get_IsCurrentModule()
protected string get_NullToken()
private void EnsureInDoubleQuotes(Boolean& fInDoubleQuotes, StringBuilder b)
private void EnsureNotInDoubleQuotes(Boolean& fInDoubleQuotes, StringBuilder b)
protected string QuoteSnippetString(string value)
private void AppendEscapedChar(StringBuilder b, char value)
protected void ProcessCompilerOutputLine(CompilerResults results, string line)
protected string CmdArgsFromParameters(CompilerParameters options)
protected void OutputAttributeArgument(CodeAttributeArgument arg)
private void OutputAttributes(CodeAttributeDeclarationCollection attributes, bool inLine)
private void OutputAttributes(CodeAttributeDeclarationCollection attributes, bool inLine, string prefix, bool closingLine)
protected void OutputDirection(FieldDirection dir)
protected void GenerateDefaultValueExpression(CodeDefaultValueExpression e)
protected void GenerateDirectionExpression(CodeDirectionExpression e)
protected void OutputFieldScopeModifier(MemberAttributes attributes)
protected void OutputMemberAccessModifier(MemberAttributes attributes)
private void OutputVTableModifier(MemberAttributes attributes)
protected void OutputMemberScopeModifier(MemberAttributes attributes)
protected void OutputOperator(CodeBinaryOperatorType op)
private void GenerateNotIsNullExpression(CodeExpression e)
protected void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
protected string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs)
protected void OutputIdentifier(string ident)
protected void OutputType(CodeTypeReference typeRef)
private void OutputTypeAttributes(CodeTypeDeclaration e)
protected void OutputTypeNamePair(CodeTypeReference typeRef, string name)
private string GetArrayPostfix(CodeTypeReference typeRef)
private void OutputArrayPostfix(CodeTypeReference typeRef)
protected void GenerateIterationStatement(CodeIterationStatement e)
protected void GeneratePrimitiveExpression(CodePrimitiveExpression e)
protected void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e)
protected void GenerateArrayCreateExpression(CodeArrayCreateExpression e)
protected void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e)
protected void GenerateCastExpression(CodeCastExpression e)
protected void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e)
protected void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e)
protected void GenerateSingleFloatValue(float s)
protected void GenerateDoubleValue(double d)
protected void GenerateDecimalValue(decimal d)
protected void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
protected void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e)
protected void GenerateIndexerExpression(CodeIndexerExpression e)
protected void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e)
protected void GenerateSnippetExpression(CodeSnippetExpression e)
protected void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e)
protected void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e)
protected void GenerateEventReferenceExpression(CodeEventReferenceExpression e)
private void GenerateFormalEventReferenceExpression(CodeEventReferenceExpression e)
protected void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
protected void GenerateObjectCreateExpression(CodeObjectCreateExpression e)
protected void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
protected void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
protected void GenerateThisReferenceExpression(CodeThisReferenceExpression e)
protected void GenerateExpressionStatement(CodeExpressionStatement e)
private bool IsDocComment(CodeCommentStatement comment)
protected void GenerateCommentStatements(CodeCommentStatementCollection e)
protected void GenerateComment(CodeComment e)
protected void GenerateMethodReturnStatement(CodeMethodReturnStatement e)
protected void GenerateConditionStatement(CodeConditionStatement e)
protected void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e)
protected void GenerateAssignStatement(CodeAssignStatement e)
protected void GenerateAttachEventStatement(CodeAttachEventStatement e)
protected void GenerateRemoveEventStatement(CodeRemoveEventStatement e)
protected void GenerateSnippetStatement(CodeSnippetStatement e)
protected void GenerateGotoStatement(CodeGotoStatement e)
protected void GenerateLabeledStatement(CodeLabeledStatement e)
protected void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
protected void GenerateLinePragmaStart(CodeLinePragma e)
protected void GenerateLinePragmaEnd(CodeLinePragma e)
protected void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c)
protected void GenerateField(CodeMemberField e)
private bool MethodIsOverloaded(CodeMemberMethod e, CodeTypeDeclaration c)
protected void GenerateSnippetMember(CodeSnippetTypeMember e)
protected void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c)
protected void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c)
private bool PropertyIsOverloaded(CodeMemberProperty e, CodeTypeDeclaration c)
protected void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c)
protected void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e)
protected void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c)
protected void GenerateTypeConstructor(CodeTypeConstructor e)
protected void GenerateTypeOfExpression(CodeTypeOfExpression e)
protected void GenerateTypeStart(CodeTypeDeclaration e)
private void OutputTypeParameters(CodeTypeParameterCollection typeParameters)
private void OutputTypeParameterConstraints(CodeTypeParameter typeParameter)
protected void GenerateTypeEnd(CodeTypeDeclaration e)
protected void GenerateNamespace(CodeNamespace e)
private bool AllowLateBound(CodeCompileUnit e)
private bool RequireVariableDeclaration(CodeCompileUnit e)
private bool GetUserData(CodeObject e, string property, bool defaultValue)
protected void GenerateCompileUnitStart(CodeCompileUnit e)
protected void GenerateCompileUnit(CodeCompileUnit e)
protected void GenerateDirectives(CodeDirectiveCollection directives)
private void GenerateChecksumPragma(CodeChecksumPragma checksumPragma)
private void GenerateCodeRegionDirective(CodeRegionDirective regionDirective)
protected void GenerateNamespaceStart(CodeNamespace e)
protected void GenerateNamespaceEnd(CodeNamespace e)
protected void GenerateNamespaceImport(CodeNamespaceImport e)
protected void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
protected void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
public bool IsKeyword(string value)
protected bool Supports(GeneratorSupport support)
protected bool IsValidIdentifier(string value)
protected string CreateValidIdentifier(string name)
protected string CreateEscapedIdentifier(string name)
private string GetBaseTypeOutput(CodeTypeReference typeRef, bool preferBuiltInTypes)
private string GetTypeOutputWithoutArrayPostFix(CodeTypeReference typeRef)
private string GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments)
private void GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments, int start, int length, StringBuilder sb)
protected string GetTypeOutput(CodeTypeReference typeRef)
protected void ContinueOnNewLine(string st)
private bool IsGeneratingStatements()
private void GenerateVBStatements(CodeStatementCollection stms)
protected CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames)
private string BuildArgs(CompilerParameters options, String[] fileNames)
private CompilerError CreateErrorFromString(string error_string)
private string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension, bool keepFile)
}
public Microsoft.VisualBasic.VBCodeProvider : CodeDomProvider {
private VBCodeGenerator _generator
public string FileExtension
public LanguageOptions LanguageOptions
public void .ctor(IDictionary`2<string, string> providerOptions)
public string get_FileExtension()
public LanguageOptions get_LanguageOptions()
public ICodeGenerator CreateGenerator()
public ICodeCompiler CreateCompiler()
public TypeConverter GetConverter(Type type)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
}
internal Microsoft.VisualBasic.VBMemberAttributeConverter : VBModifierAttributeConverter {
private VBMemberAttributeConverter <Default>k__BackingField
private String[] <Names>k__BackingField
private Object[] <Values>k__BackingField
public VBMemberAttributeConverter Default
protected String[] Names
protected Object[] Values
protected object DefaultValue
public VBMemberAttributeConverter get_Default()
protected String[] get_Names()
protected Object[] get_Values()
protected object get_DefaultValue()
}
internal Microsoft.VisualBasic.VBModifierAttributeConverter : TypeConverter {
protected Object[] Values
protected String[] Names
protected object DefaultValue
protected Object[] get_Values()
protected String[] get_Names()
protected object get_DefaultValue()
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
}
internal Microsoft.VisualBasic.VBTypeAttributeConverter : VBModifierAttributeConverter {
private VBTypeAttributeConverter <Default>k__BackingField
private String[] <Names>k__BackingField
private Object[] <Values>k__BackingField
public VBTypeAttributeConverter Default
protected String[] Names
protected Object[] Values
protected object DefaultValue
public VBTypeAttributeConverter get_Default()
protected String[] get_Names()
protected Object[] get_Values()
protected object get_DefaultValue()
}
public Microsoft.Win32.IntranetZoneCredentialPolicy : object {
public bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authModule)
}
internal Microsoft.Win32.NativeMethods : object {
public int E_ABORT
public int PROCESS_TERMINATE
public int PROCESS_CREATE_THREAD
public int PROCESS_SET_SESSIONID
public int PROCESS_VM_OPERATION
public int PROCESS_VM_READ
public int PROCESS_VM_WRITE
public int PROCESS_DUP_HANDLE
public int PROCESS_CREATE_PROCESS
public int PROCESS_SET_QUOTA
public int PROCESS_SET_INFORMATION
public int PROCESS_QUERY_INFORMATION
public int PROCESS_QUERY_LIMITED_INFORMATION
public int STANDARD_RIGHTS_REQUIRED
public int SYNCHRONIZE
public int PROCESS_ALL_ACCESS
public int DUPLICATE_CLOSE_SOURCE
public int DUPLICATE_SAME_ACCESS
public int STILL_ACTIVE
public int WAIT_OBJECT_0
public int WAIT_FAILED
public int WAIT_TIMEOUT
public int WAIT_ABANDONED
public int WAIT_ABANDONED_0
public int ERROR_FILE_NOT_FOUND
public int ERROR_PATH_NOT_FOUND
public int ERROR_ACCESS_DENIED
public int ERROR_INVALID_HANDLE
public int ERROR_SHARING_VIOLATION
public int ERROR_INVALID_NAME
public int ERROR_ALREADY_EXISTS
public int ERROR_FILENAME_EXCED_RANGE
public bool DuplicateHandle(HandleRef hSourceProcessHandle, SafeHandle hSourceHandle, HandleRef hTargetProcess, SafeWaitHandle& targetHandle, int dwDesiredAccess, bool bInheritHandle, int dwOptions)
public bool DuplicateHandle(HandleRef hSourceProcessHandle, HandleRef hSourceHandle, HandleRef hTargetProcess, SafeProcessHandle& targetHandle, int dwDesiredAccess, bool bInheritHandle, int dwOptions)
public IntPtr GetCurrentProcess()
public bool GetExitCodeProcess(IntPtr processHandle, Int32& exitCode)
public bool GetExitCodeProcess(SafeProcessHandle processHandle, Int32& exitCode)
public bool TerminateProcess(IntPtr processHandle, int exitCode)
public bool TerminateProcess(SafeProcessHandle processHandle, int exitCode)
public int WaitForInputIdle(IntPtr handle, int milliseconds)
public int WaitForInputIdle(SafeProcessHandle handle, int milliseconds)
public bool GetProcessWorkingSetSize(IntPtr handle, IntPtr& min, IntPtr& max)
public bool GetProcessWorkingSetSize(SafeProcessHandle handle, IntPtr& min, IntPtr& max)
public bool SetProcessWorkingSetSize(IntPtr handle, IntPtr min, IntPtr max)
public bool SetProcessWorkingSetSize(SafeProcessHandle handle, IntPtr min, IntPtr max)
public bool GetProcessTimes(IntPtr handle, Int64& creation, Int64& exit, Int64& kernel, Int64& user)
public bool GetProcessTimes(SafeProcessHandle handle, Int64& creation, Int64& exit, Int64& kernel, Int64& user)
public int GetCurrentProcessId()
public int GetPriorityClass(IntPtr handle)
public int GetPriorityClass(SafeProcessHandle handle)
public bool SetPriorityClass(IntPtr handle, int priorityClass)
public bool SetPriorityClass(SafeProcessHandle handle, int priorityClass)
public bool CloseProcess(IntPtr handle)
}
public Microsoft.Win32.PowerModeChangedEventArgs : EventArgs {
private PowerModes mymode
public PowerModes Mode
public void .ctor(PowerModes mode)
public PowerModes get_Mode()
}
public Microsoft.Win32.PowerModeChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PowerModeChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, PowerModeChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.PowerModes : Enum {
public int value__
public PowerModes Resume
public PowerModes StatusChange
public PowerModes Suspend
}
public Microsoft.Win32.SafeHandles.SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
internal SafeProcessHandle InvalidHandle
internal void .ctor(IntPtr handle)
public void .ctor(IntPtr existingHandle, bool ownsHandle)
internal void InitialSetHandle(IntPtr h)
protected bool ReleaseHandle()
}
public Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
internal void .ctor(IntPtr handle)
protected bool ReleaseHandle()
}
public Microsoft.Win32.SessionEndedEventArgs : EventArgs {
private SessionEndReasons myreason
public SessionEndReasons Reason
public void .ctor(SessionEndReasons reason)
public SessionEndReasons get_Reason()
}
public Microsoft.Win32.SessionEndedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SessionEndedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SessionEndedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.SessionEndingEventArgs : EventArgs {
private SessionEndReasons myreason
private bool mycancel
public SessionEndReasons Reason
public bool Cancel
public void .ctor(SessionEndReasons reason)
public SessionEndReasons get_Reason()
public bool get_Cancel()
public void set_Cancel(bool value)
}
public Microsoft.Win32.SessionEndingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SessionEndingEventArgs e)
public IAsyncResult BeginInvoke(object sender, SessionEndingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.SessionEndReasons : Enum {
public int value__
public SessionEndReasons Logoff
public SessionEndReasons SystemShutdown
}
public Microsoft.Win32.SessionSwitchEventArgs : EventArgs {
private SessionSwitchReason reason
public SessionSwitchReason Reason
public void .ctor(SessionSwitchReason reason)
public SessionSwitchReason get_Reason()
}
public Microsoft.Win32.SessionSwitchEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SessionSwitchEventArgs e)
public IAsyncResult BeginInvoke(object sender, SessionSwitchEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.SessionSwitchReason : Enum {
public int value__
public SessionSwitchReason ConsoleConnect
public SessionSwitchReason ConsoleDisconnect
public SessionSwitchReason RemoteConnect
public SessionSwitchReason RemoteDisconnect
public SessionSwitchReason SessionLogon
public SessionSwitchReason SessionLogoff
public SessionSwitchReason SessionLock
public SessionSwitchReason SessionUnlock
public SessionSwitchReason SessionRemoteControl
}
public Microsoft.Win32.SystemEvents : object {
private Hashtable TimerStore
private TimerElapsedEventHandler TimerElapsed
public IntPtr CreateTimer(int interval)
public void KillTimer(IntPtr timerId)
private void InternalTimerElapsed(object e, ElapsedEventArgs args)
public void InvokeOnEventsThread(Delegate method)
public void add_DisplaySettingsChanged(EventHandler value)
public void remove_DisplaySettingsChanged(EventHandler value)
public void add_DisplaySettingsChanging(EventHandler value)
public void remove_DisplaySettingsChanging(EventHandler value)
public void add_EventsThreadShutdown(EventHandler value)
public void remove_EventsThreadShutdown(EventHandler value)
public void add_InstalledFontsChanged(EventHandler value)
public void remove_InstalledFontsChanged(EventHandler value)
public void add_LowMemory(EventHandler value)
public void remove_LowMemory(EventHandler value)
public void add_PaletteChanged(EventHandler value)
public void remove_PaletteChanged(EventHandler value)
public void add_PowerModeChanged(PowerModeChangedEventHandler value)
public void remove_PowerModeChanged(PowerModeChangedEventHandler value)
public void add_SessionEnded(SessionEndedEventHandler value)
public void remove_SessionEnded(SessionEndedEventHandler value)
public void add_SessionEnding(SessionEndingEventHandler value)
public void remove_SessionEnding(SessionEndingEventHandler value)
public void add_SessionSwitch(SessionSwitchEventHandler value)
public void remove_SessionSwitch(SessionSwitchEventHandler value)
public void add_TimeChanged(EventHandler value)
public void remove_TimeChanged(EventHandler value)
public void add_TimerElapsed(TimerElapsedEventHandler value)
public void remove_TimerElapsed(TimerElapsedEventHandler value)
public void add_UserPreferenceChanged(UserPreferenceChangedEventHandler value)
public void remove_UserPreferenceChanged(UserPreferenceChangedEventHandler value)
public void add_UserPreferenceChanging(UserPreferenceChangingEventHandler value)
public void remove_UserPreferenceChanging(UserPreferenceChangingEventHandler value)
}
public Microsoft.Win32.TimerElapsedEventArgs : EventArgs {
private IntPtr mytimerId
public IntPtr TimerId
public void .ctor(IntPtr timerId)
public IntPtr get_TimerId()
}
public Microsoft.Win32.TimerElapsedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, TimerElapsedEventArgs e)
public IAsyncResult BeginInvoke(object sender, TimerElapsedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.UserPreferenceCategory : Enum {
public int value__
public UserPreferenceCategory Accessibility
public UserPreferenceCategory Color
public UserPreferenceCategory Desktop
public UserPreferenceCategory General
public UserPreferenceCategory Icon
public UserPreferenceCategory Keyboard
public UserPreferenceCategory Menu
public UserPreferenceCategory Mouse
public UserPreferenceCategory Policy
public UserPreferenceCategory Power
public UserPreferenceCategory Screensaver
public UserPreferenceCategory Window
public UserPreferenceCategory Locale
public UserPreferenceCategory VisualStyle
}
public Microsoft.Win32.UserPreferenceChangedEventArgs : EventArgs {
private UserPreferenceCategory mycategory
public UserPreferenceCategory Category
public void .ctor(UserPreferenceCategory category)
public UserPreferenceCategory get_Category()
}
public Microsoft.Win32.UserPreferenceChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UserPreferenceChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UserPreferenceChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.UserPreferenceChangingEventArgs : EventArgs {
private UserPreferenceCategory mycategory
public UserPreferenceCategory Category
public void .ctor(UserPreferenceCategory category)
public UserPreferenceCategory get_Category()
}
public Microsoft.Win32.UserPreferenceChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UserPreferenceChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, UserPreferenceChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal Mono.AppleTls.AppleCertificateHelper : object {
public SecIdentity GetIdentity(X509Certificate certificate)
public SecIdentity GetIdentity(X509Certificate certificate, SecCertificate[]& intermediateCerts)
public bool InvokeSystemCertificateValidator(ICertificateValidator2 validator, string targetHost, bool serverMode, X509CertificateCollection certificates, MonoSslPolicyErrors& errors, Int32& status11)
}
internal Mono.AppleTls.AppleTlsContext : MobileTlsContext {
public string SecurityLibrary
private GCHandle handle
private IntPtr context
private SslReadFunc readFunc
private SslWriteFunc writeFunc
private SecIdentity serverIdentity
private SecIdentity clientIdentity
private X509Certificate remoteCertificate
private X509Certificate localClientCertificate
private MonoTlsConnectionInfo connectionInfo
private bool havePeerTrust
private bool isAuthenticated
private bool handshakeFinished
private int handshakeStarted
private bool closed
private bool disposed
private bool closedGraceful
private int pendingIO
private Exception lastException
public IntPtr Handle
public bool HasContext
public bool IsAuthenticated
public MonoTlsConnectionInfo ConnectionInfo
internal bool IsRemoteCertificateAvailable
internal X509Certificate LocalClientCertificate
public X509Certificate RemoteCertificate
public TlsProtocols NegotiatedProtocol
public SslProtocol MaxProtocol
public SslProtocol MinProtocol
public SslSessionState SessionState
public Byte[] PeerId
public IntPtr BufferedReadSize
public SslCipherSuite NegotiatedCipher
public string PeerDomainName
public SslClientCertificateState ClientCertificateState
public void .ctor(MobileAuthenticatedStream parent, bool serverMode, string targetHost, SslProtocols enabledProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool askForClientCert)
public IntPtr get_Handle()
public bool get_HasContext()
private void CheckStatusAndThrow(SslStatus status, SslStatus[] acceptable)
public bool get_IsAuthenticated()
public void StartHandshake()
public void FinishHandshake()
public void Flush()
public bool ProcessHandshake()
private void RequirePeerTrust()
private void EvaluateTrust()
private void InitializeConnection()
private void InitializeSession()
private TlsProtocols GetProtocol(SslProtocol protocol)
public MonoTlsConnectionInfo get_ConnectionInfo()
internal bool get_IsRemoteCertificateAvailable()
internal X509Certificate get_LocalClientCertificate()
public X509Certificate get_RemoteCertificate()
public TlsProtocols get_NegotiatedProtocol()
private SslStatus SSLGetProtocolVersionMax(IntPtr context, SslProtocol& maxVersion)
private SslStatus SSLSetProtocolVersionMax(IntPtr context, SslProtocol maxVersion)
public SslProtocol get_MaxProtocol()
public void set_MaxProtocol(SslProtocol value)
private SslStatus SSLGetProtocolVersionMin(IntPtr context, SslProtocol& minVersion)
private SslStatus SSLSetProtocolVersionMin(IntPtr context, SslProtocol minVersion)
public SslProtocol get_MinProtocol()
public void set_MinProtocol(SslProtocol value)
private SslStatus SSLGetNegotiatedProtocolVersion(IntPtr context, SslProtocol& protocol)
public SslProtocol GetNegotiatedProtocolVersion()
private SslStatus SSLGetSessionOption(IntPtr context, SslSessionOption option, Boolean& value)
public bool GetSessionOption(SslSessionOption option)
private SslStatus SSLSetSessionOption(IntPtr context, SslSessionOption option, bool value)
public void SetSessionOption(SslSessionOption option, bool value)
private SslStatus SSLSetClientSideAuthenticate(IntPtr context, SslAuthenticate auth)
public void SetClientSideAuthenticate(SslAuthenticate auth)
private SslStatus SSLHandshake(IntPtr context)
private SslStatus SSLGetSessionState(IntPtr context, SslSessionState& state)
public SslSessionState get_SessionState()
private SslStatus SSLGetPeerID(IntPtr context, IntPtr& peerID, IntPtr& peerIDLen)
private SslStatus SSLSetPeerID(IntPtr context, Byte* peerID, IntPtr peerIDLen)
public Byte[] get_PeerId()
public void set_PeerId(Byte[] value)
private SslStatus SSLGetBufferedReadSize(IntPtr context, IntPtr& bufSize)
public IntPtr get_BufferedReadSize()
private SslStatus SSLGetNumberSupportedCiphers(IntPtr context, IntPtr& numCiphers)
private SslStatus SSLGetSupportedCiphers(IntPtr context, SslCipherSuite* ciphers, IntPtr& numCiphers)
public IList`1<SslCipherSuite> GetSupportedCiphers()
private SslStatus SSLGetNumberEnabledCiphers(IntPtr context, IntPtr& numCiphers)
private SslStatus SSLGetEnabledCiphers(IntPtr context, SslCipherSuite* ciphers, IntPtr& numCiphers)
public IList`1<SslCipherSuite> GetEnabledCiphers()
private SslStatus SSLSetEnabledCiphers(IntPtr context, SslCipherSuite* ciphers, IntPtr numCiphers)
public void SetEnabledCiphers(SslCipherSuite[] ciphers)
private SslStatus SSLGetNegotiatedCipher(IntPtr context, SslCipherSuite& cipherSuite)
public SslCipherSuite get_NegotiatedCipher()
private SslStatus SSLGetPeerDomainNameLength(IntPtr context, IntPtr& peerNameLen)
private SslStatus SSLGetPeerDomainName(IntPtr context, Byte[] peerName, IntPtr& peerNameLen)
private SslStatus SSLSetPeerDomainName(IntPtr context, Byte[] peerName, IntPtr peerNameLen)
public string get_PeerDomainName()
public void set_PeerDomainName(string value)
private SslStatus SSLSetCertificate(IntPtr context, IntPtr certRefs)
private CFArray Bundle(SecIdentity identity, IEnumerable`1<SecCertificate> certificates)
public void SetCertificate(SecIdentity identify, IEnumerable`1<SecCertificate> certificates)
private SslStatus SSLGetClientCertificateState(IntPtr context, SslClientCertificateState& clientState)
public SslClientCertificateState get_ClientCertificateState()
private SslStatus SSLCopyPeerTrust(IntPtr context, IntPtr& trust)
public SecTrust GetPeerTrust(bool requireTrust)
private IntPtr SSLCreateContext(IntPtr alloc, SslProtocolSide protocolSide, SslConnectionType connectionType)
private SslStatus SSLSetConnection(IntPtr context, IntPtr connection)
private SslStatus SSLSetIOFuncs(IntPtr context, SslReadFunc readFunc, SslWriteFunc writeFunc)
private SslStatus NativeReadCallback(IntPtr ptr, IntPtr data, IntPtr& dataLength)
private SslStatus NativeWriteCallback(IntPtr ptr, IntPtr data, IntPtr& dataLength)
private SslStatus NativeReadCallback(IntPtr data, IntPtr& dataLength)
private SslStatus NativeWriteCallback(IntPtr data, IntPtr& dataLength)
private SslStatus SSLRead(IntPtr context, Byte* data, IntPtr dataLength, IntPtr& processed)
public ValueTuple`2<int, bool> Read(Byte[] buffer, int offset, int count)
private SslStatus SSLWrite(IntPtr context, Byte* data, IntPtr dataLength, IntPtr& processed)
public ValueTuple`2<int, bool> Write(Byte[] buffer, int offset, int count)
private SslStatus SSLClose(IntPtr context)
public void Shutdown()
protected void Dispose(bool disposing)
}
internal Mono.AppleTls.AppleTlsProvider : MonoTlsProvider {
public string Name
public Guid ID
public bool SupportsSslStream
public bool SupportsMonoExtensions
public bool SupportsConnectionInfo
internal bool SupportsCleanShutdown
public SslProtocols SupportedProtocols
public string get_Name()
public Guid get_ID()
public IMonoSslStream CreateSslStream(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
internal IMonoSslStream CreateSslStreamInternal(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
public bool get_SupportsSslStream()
public bool get_SupportsMonoExtensions()
public bool get_SupportsConnectionInfo()
internal bool get_SupportsCleanShutdown()
public SslProtocols get_SupportedProtocols()
internal bool ValidateCertificate(ICertificateValidator2 validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain& chain, MonoSslPolicyErrors& errors, Int32& status11)
}
internal Mono.AppleTls.AppleTlsStream : MobileAuthenticatedStream {
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MonoTlsProvider provider)
protected MobileTlsContext CreateContext(bool serverMode, string targetHost, SslProtocols enabledProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool askForClientCert)
}
internal Mono.AppleTls.SecAccess : object {
internal IntPtr handle
public IntPtr Handle
public void .ctor(IntPtr handle, bool owns)
protected void Finalize()
public IntPtr get_Handle()
private SecStatusCode SecAccessCreate(IntPtr descriptor, IntPtr trustedList, IntPtr& accessRef)
public SecAccess Create(string descriptor)
public void Dispose()
protected void Dispose(bool disposing)
}
internal Mono.AppleTls.SecCertificate : object {
internal IntPtr handle
public string SubjectSummary
public CFData DerData
public IntPtr Handle
internal void .ctor(IntPtr handle, bool owns)
public IntPtr GetTypeID()
private IntPtr SecCertificateCreateWithData(IntPtr allocator, IntPtr cfData)
public void .ctor(X509Certificate certificate)
internal void .ctor(X509CertificateImpl impl)
private void Initialize(CFData data)
private IntPtr SecCertificateCopySubjectSummary(IntPtr cert)
public string get_SubjectSummary()
private IntPtr SecCertificateCopyData(IntPtr cert)
public CFData get_DerData()
public X509Certificate ToX509Certificate()
internal bool Equals(SecCertificate first, SecCertificate second)
protected void Finalize()
public IntPtr get_Handle()
public void Dispose()
protected void Dispose(bool disposing)
}
internal Mono.AppleTls.SecClass : object {
public IntPtr Identity
public IntPtr Certificate
public IntPtr FromSecKind(SecKind secKind)
}
internal Mono.AppleTls.SecIdentity : object {
private CFString ImportExportPassphase
private CFString ImportItemIdentity
private CFString ImportExportAccess
private CFString ImportExportKeychain
internal IntPtr handle
public SecCertificate Certificate
public IntPtr Handle
internal void .ctor(IntPtr handle, bool owns)
public IntPtr GetTypeID()
private SecStatusCode SecIdentityCopyCertificate(IntPtr identityRef, IntPtr& certificateRef)
public SecCertificate get_Certificate()
private CFDictionary CreateImportOptions(CFString password, ImportOptions options)
public SecIdentity Import(Byte[] data, string password, ImportOptions options)
public SecIdentity Import(X509Certificate2 certificate, ImportOptions options)
protected void Finalize()
public IntPtr get_Handle()
public void Dispose()
protected void Dispose(bool disposing)
}
internal Mono.AppleTls.SecImportExport : object {
private int SEC_KEY_IMPORT_EXPORT_PARAMS_VERSION
private SecStatusCode SecPKCS12Import(IntPtr pkcs12_data, IntPtr options, IntPtr& items)
public SecStatusCode ImportPkcs12(Byte[] buffer, CFDictionary options, CFDictionary[]& array)
public SecStatusCode ImportPkcs12(CFData data, CFDictionary options, CFDictionary[]& array)
private SecStatusCode SecItemImport(IntPtr importedData, IntPtr fileNameOrExtension, SecExternalFormat& inputFormat, SecExternalItemType& itemType, SecItemImportExportFlags flags, IntPtr keyParams, IntPtr importKeychain, IntPtr& outItems)
public CFArray ItemImport(Byte[] buffer, string password)
private CFArray ItemImport(CFData data, SecExternalFormat format, SecExternalItemType itemType, SecItemImportExportFlags flags, Nullable`1<SecItemImportExportKeyParameters> keyParams)
private CFArray ItemImport(CFData data, SecExternalFormat& format, SecExternalItemType& itemType, SecItemImportExportFlags flags, Nullable`1<SecItemImportExportKeyParameters> keyParams)
private IntPtr SecIdentityCreate(IntPtr allocator, IntPtr certificate, IntPtr privateKey)
public SecIdentity ItemImport(X509Certificate2 certificate)
private Byte[] ExportKey(RSA key)
private SecKey ImportPrivateKey(X509Certificate2 certificate)
}
internal Mono.AppleTls.SecItem : object {
public IntPtr ReturnRef
public IntPtr MatchSearchList
internal SecStatusCode SecItemCopyMatching(IntPtr query, IntPtr& result)
}
internal Mono.AppleTls.SecKey : object {
internal IntPtr handle
internal IntPtr owner
public IntPtr Handle
public void .ctor(IntPtr handle, bool owns)
internal void .ctor(IntPtr handle, IntPtr owner)
public IntPtr GetTypeID()
protected void Finalize()
public IntPtr get_Handle()
public void Dispose()
protected void Dispose(bool disposing)
}
internal Mono.AppleTls.SecKeyChain : object {
internal IntPtr MatchLimitAll
internal IntPtr MatchLimitOne
internal IntPtr MatchLimit
private IntPtr handle
public IntPtr Handle
internal void .ctor(IntPtr handle, bool owns)
public SecIdentity FindIdentity(SecCertificate certificate, bool throwOnError)
private SecIdentity FindIdentity(Predicate`1<SecCertificate> filter)
private INativeObject[] QueryAsReference(SecRecord query, int max, SecStatusCode& result)
private INativeObject[] QueryAsReference(CFDictionary query, SecStatusCode& result)
internal CFNumber SetLimit(CFMutableDictionary dict, int max)
private SecStatusCode SecKeychainCreate(IntPtr pathName, UInt32 passwordLength, IntPtr password, bool promptUser, IntPtr initialAccess, IntPtr& keychain)
internal SecKeyChain Create(string pathName, string password)
private SecStatusCode SecKeychainOpen(IntPtr pathName, IntPtr& keychain)
internal SecKeyChain Open(string pathName)
internal SecKeyChain OpenSystemRootCertificates()
protected void Finalize()
public IntPtr get_Handle()
public void Dispose()
protected void Dispose(bool disposing)
}
internal Mono.AppleTls.SecKind : Enum {
public int value__
public SecKind Identity
public SecKind Certificate
}
internal Mono.AppleTls.SecPolicy : object {
private IntPtr handle
public IntPtr Handle
internal void .ctor(IntPtr handle, bool owns)
private IntPtr SecPolicyCreateSSL(bool server, IntPtr hostname)
public SecPolicy CreateSslPolicy(bool server, string hostName)
protected void Finalize()
public void Dispose()
public IntPtr get_Handle()
protected void Dispose(bool disposing)
}
internal Mono.AppleTls.SecRecord : object {
internal IntPtr SecClassKey
private CFMutableDictionary _queryDict
internal CFMutableDictionary QueryDict
internal CFMutableDictionary get_QueryDict()
internal void SetValue(IntPtr key, IntPtr value)
public void .ctor(SecKind secKind)
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
internal Mono.AppleTls.SecStatusCode : Enum {
public int value__
public SecStatusCode Success
public SecStatusCode Unimplemented
public SecStatusCode DiskFull
public SecStatusCode IO
public SecStatusCode OpWr
public SecStatusCode Param
public SecStatusCode WritePermissions
public SecStatusCode Allocate
public SecStatusCode UserCanceled
public SecStatusCode BadReq
public SecStatusCode InternalComponent
public SecStatusCode CoreFoundationUnknown
public SecStatusCode NotAvailable
public SecStatusCode ReadOnly
public SecStatusCode AuthFailed
public SecStatusCode NoSuchKeyChain
public SecStatusCode InvalidKeyChain
public SecStatusCode DuplicateKeyChain
public SecStatusCode DuplicateItem
public SecStatusCode ItemNotFound
public SecStatusCode InteractionNotAllowed
public SecStatusCode Decode
public SecStatusCode DuplicateCallback
public SecStatusCode InvalidCallback
public SecStatusCode BufferTooSmall
public SecStatusCode DataTooLarge
public SecStatusCode NoSuchAttribute
public SecStatusCode InvalidItemRef
public SecStatusCode InvalidSearchRef
public SecStatusCode NoSuchClass
public SecStatusCode NoDefaultKeychain
public SecStatusCode ReadOnlyAttribute
public SecStatusCode WrongSecVersion
public SecStatusCode KeySizeNotAllowed
public SecStatusCode NoStorageModule
public SecStatusCode NoCertificateModule
public SecStatusCode NoPolicyModule
public SecStatusCode InteractionRequired
public SecStatusCode DataNotAvailable
public SecStatusCode DataNotModifiable
public SecStatusCode CreateChainFailed
public SecStatusCode InvalidPrefsDomain
public SecStatusCode InDarkWake
public SecStatusCode ACLNotSimple
public SecStatusCode PolicyNotFound
public SecStatusCode InvalidTrustSetting
public SecStatusCode NoAccessForItem
public SecStatusCode InvalidOwnerEdit
public SecStatusCode TrustNotAvailable
public SecStatusCode UnsupportedFormat
public SecStatusCode UnknownFormat
public SecStatusCode KeyIsSensitive
public SecStatusCode MultiplePrivateKeys
public SecStatusCode PassphraseRequired
public SecStatusCode InvalidPasswordRef
public SecStatusCode InvalidTrustSettings
public SecStatusCode NoTrustSettings
public SecStatusCode Pkcs12VerifyFailure
public SecStatusCode NotSigner
public SecStatusCode ServiceNotAvailable
public SecStatusCode InsufficientClientID
public SecStatusCode DeviceReset
public SecStatusCode DeviceFailed
public SecStatusCode AppleAddAppACLSubject
public SecStatusCode ApplePublicKeyIncomplete
public SecStatusCode AppleSignatureMismatch
public SecStatusCode AppleInvalidKeyStartDate
public SecStatusCode AppleInvalidKeyEndDate
public SecStatusCode ConversionError
public SecStatusCode AppleSSLv2Rollback
public SecStatusCode QuotaExceeded
public SecStatusCode FileTooBig
public SecStatusCode InvalidDatabaseBlob
public SecStatusCode InvalidKeyBlob
public SecStatusCode IncompatibleDatabaseBlob
public SecStatusCode IncompatibleKeyBlob
public SecStatusCode HostNameMismatch
public SecStatusCode UnknownCriticalExtensionFlag
public SecStatusCode NoBasicConstraints
public SecStatusCode NoBasicConstraintsCA
public SecStatusCode InvalidAuthorityKeyID
public SecStatusCode InvalidSubjectKeyID
public SecStatusCode InvalidKeyUsageForPolicy
public SecStatusCode InvalidExtendedKeyUsage
public SecStatusCode InvalidIDLinkage
public SecStatusCode PathLengthConstraintExceeded
public SecStatusCode InvalidRoot
public SecStatusCode CRLExpired
public SecStatusCode CRLNotValidYet
public SecStatusCode CRLNotFound
public SecStatusCode CRLServerDown
public SecStatusCode CRLBadURI
public SecStatusCode UnknownCertExtension
public SecStatusCode UnknownCRLExtension
public SecStatusCode CRLNotTrusted
public SecStatusCode CRLPolicyFailed
public SecStatusCode IDPFailure
public SecStatusCode SMIMEEmailAddressesNotFound
public SecStatusCode SMIMEBadExtendedKeyUsage
public SecStatusCode SMIMEBadKeyUsage
public SecStatusCode SMIMEKeyUsageNotCritical
public SecStatusCode SMIMENoEmailAddress
public SecStatusCode SMIMESubjAltNameNotCritical
public SecStatusCode SSLBadExtendedKeyUsage
public SecStatusCode OCSPBadResponse
public SecStatusCode OCSPBadRequest
public SecStatusCode OCSPUnavailable
public SecStatusCode OCSPStatusUnrecognized
public SecStatusCode EndOfData
public SecStatusCode IncompleteCertRevocationCheck
public SecStatusCode NetworkFailure
public SecStatusCode OCSPNotTrustedToAnchor
public SecStatusCode RecordModified
public SecStatusCode OCSPSignatureError
public SecStatusCode OCSPNoSigner
public SecStatusCode OCSPResponderMalformedReq
public SecStatusCode OCSPResponderInternalError
public SecStatusCode OCSPResponderTryLater
public SecStatusCode OCSPResponderSignatureRequired
public SecStatusCode OCSPResponderUnauthorized
public SecStatusCode OCSPResponseNonceMismatch
public SecStatusCode CodeSigningBadCertChainLength
public SecStatusCode CodeSigningNoBasicConstraints
public SecStatusCode CodeSigningBadPathLengthConstraint
public SecStatusCode CodeSigningNoExtendedKeyUsage
public SecStatusCode CodeSigningDevelopment
public SecStatusCode ResourceSignBadCertChainLength
public SecStatusCode ResourceSignBadExtKeyUsage
public SecStatusCode TrustSettingDeny
public SecStatusCode InvalidSubjectName
public SecStatusCode UnknownQualifiedCertStatement
public SecStatusCode MobileMeRequestQueued
public SecStatusCode MobileMeRequestRedirected
public SecStatusCode MobileMeServerError
public SecStatusCode MobileMeServerNotAvailable
public SecStatusCode MobileMeServerAlreadyExists
public SecStatusCode MobileMeServerServiceErr
public SecStatusCode MobileMeRequestAlreadyPending
public SecStatusCode MobileMeNoRequestPending
public SecStatusCode MobileMeCSRVerifyFailure
public SecStatusCode MobileMeFailedConsistencyCheck
public SecStatusCode NotInitialized
public SecStatusCode InvalidHandleUsage
public SecStatusCode PVCReferentNotFound
public SecStatusCode FunctionIntegrityFail
public SecStatusCode InternalError
public SecStatusCode MemoryError
public SecStatusCode InvalidData
public SecStatusCode MDSError
public SecStatusCode InvalidPointer
public SecStatusCode SelfCheckFailed
public SecStatusCode FunctionFailed
public SecStatusCode ModuleManifestVerifyFailed
public SecStatusCode InvalidGUID
public SecStatusCode InvalidHandle
public SecStatusCode InvalidDBList
public SecStatusCode InvalidPassthroughID
public SecStatusCode InvalidNetworkAddress
public SecStatusCode CRLAlreadySigned
public SecStatusCode InvalidNumberOfFields
public SecStatusCode VerificationFailure
public SecStatusCode UnknownTag
public SecStatusCode InvalidSignature
public SecStatusCode InvalidName
public SecStatusCode InvalidCertificateRef
public SecStatusCode InvalidCertificateGroup
public SecStatusCode TagNotFound
public SecStatusCode InvalidQuery
public SecStatusCode InvalidValue
public SecStatusCode CallbackFailed
public SecStatusCode ACLDeleteFailed
public SecStatusCode ACLReplaceFailed
public SecStatusCode ACLAddFailed
public SecStatusCode ACLChangeFailed
public SecStatusCode InvalidAccessCredentials
public SecStatusCode InvalidRecord
public SecStatusCode InvalidACL
public SecStatusCode InvalidSampleValue
public SecStatusCode IncompatibleVersion
public SecStatusCode PrivilegeNotGranted
public SecStatusCode InvalidScope
public SecStatusCode PVCAlreadyConfigured
public SecStatusCode InvalidPVC
public SecStatusCode EMMLoadFailed
public SecStatusCode EMMUnloadFailed
public SecStatusCode AddinLoadFailed
public SecStatusCode InvalidKeyRef
public SecStatusCode InvalidKeyHierarchy
public SecStatusCode AddinUnloadFailed
public SecStatusCode LibraryReferenceNotFound
public SecStatusCode InvalidAddinFunctionTable
public SecStatusCode InvalidServiceMask
public SecStatusCode ModuleNotLoaded
public SecStatusCode InvalidSubServiceID
public SecStatusCode AttributeNotInContext
public SecStatusCode ModuleManagerInitializeFailed
public SecStatusCode ModuleManagerNotFound
public SecStatusCode EventNotificationCallbackNotFound
public SecStatusCode InputLengthError
public SecStatusCode OutputLengthError
public SecStatusCode PrivilegeNotSupported
public SecStatusCode DeviceError
public SecStatusCode AttachHandleBusy
public SecStatusCode NotLoggedIn
public SecStatusCode AlgorithmMismatch
public SecStatusCode KeyUsageIncorrect
public SecStatusCode KeyBlobTypeIncorrect
public SecStatusCode KeyHeaderInconsistent
public SecStatusCode UnsupportedKeyFormat
public SecStatusCode UnsupportedKeySize
public SecStatusCode InvalidKeyUsageMask
public SecStatusCode UnsupportedKeyUsageMask
public SecStatusCode InvalidKeyAttributeMask
public SecStatusCode UnsupportedKeyAttributeMask
public SecStatusCode InvalidKeyLabel
public SecStatusCode UnsupportedKeyLabel
public SecStatusCode InvalidKeyFormat
public SecStatusCode UnsupportedVectorOfBuffers
public SecStatusCode InvalidInputVector
public SecStatusCode InvalidOutputVector
public SecStatusCode InvalidContext
public SecStatusCode InvalidAlgorithm
public SecStatusCode InvalidAttributeKey
public SecStatusCode MissingAttributeKey
public SecStatusCode InvalidAttributeInitVector
public SecStatusCode MissingAttributeInitVector
public SecStatusCode InvalidAttributeSalt
public SecStatusCode MissingAttributeSalt
public SecStatusCode InvalidAttributePadding
public SecStatusCode MissingAttributePadding
public SecStatusCode InvalidAttributeRandom
public SecStatusCode MissingAttributeRandom
public SecStatusCode InvalidAttributeSeed
public SecStatusCode MissingAttributeSeed
public SecStatusCode InvalidAttributePassphrase
public SecStatusCode MissingAttributePassphrase
public SecStatusCode InvalidAttributeKeyLength
public SecStatusCode MissingAttributeKeyLength
public SecStatusCode InvalidAttributeBlockSize
public SecStatusCode MissingAttributeBlockSize
public SecStatusCode InvalidAttributeOutputSize
public SecStatusCode MissingAttributeOutputSize
public SecStatusCode InvalidAttributeRounds
public SecStatusCode MissingAttributeRounds
public SecStatusCode InvalidAlgorithmParms
public SecStatusCode MissingAlgorithmParms
public SecStatusCode InvalidAttributeLabel
public SecStatusCode MissingAttributeLabel
public SecStatusCode InvalidAttributeKeyType
public SecStatusCode MissingAttributeKeyType
public SecStatusCode InvalidAttributeMode
public SecStatusCode MissingAttributeMode
public SecStatusCode InvalidAttributeEffectiveBits
public SecStatusCode MissingAttributeEffectiveBits
public SecStatusCode InvalidAttributeStartDate
public SecStatusCode MissingAttributeStartDate
public SecStatusCode InvalidAttributeEndDate
public SecStatusCode MissingAttributeEndDate
public SecStatusCode InvalidAttributeVersion
public SecStatusCode MissingAttributeVersion
public SecStatusCode InvalidAttributePrime
public SecStatusCode MissingAttributePrime
public SecStatusCode InvalidAttributeBase
public SecStatusCode MissingAttributeBase
public SecStatusCode InvalidAttributeSubprime
public SecStatusCode MissingAttributeSubprime
public SecStatusCode InvalidAttributeIterationCount
public SecStatusCode MissingAttributeIterationCount
public SecStatusCode InvalidAttributeDLDBHandle
public SecStatusCode MissingAttributeDLDBHandle
public SecStatusCode InvalidAttributeAccessCredentials
public SecStatusCode MissingAttributeAccessCredentials
public SecStatusCode InvalidAttributePublicKeyFormat
public SecStatusCode MissingAttributePublicKeyFormat
public SecStatusCode InvalidAttributePrivateKeyFormat
public SecStatusCode MissingAttributePrivateKeyFormat
public SecStatusCode InvalidAttributeSymmetricKeyFormat
public SecStatusCode MissingAttributeSymmetricKeyFormat
public SecStatusCode InvalidAttributeWrappedKeyFormat
public SecStatusCode MissingAttributeWrappedKeyFormat
public SecStatusCode StagedOperationInProgress
public SecStatusCode StagedOperationNotStarted
public SecStatusCode VerifyFailed
public SecStatusCode QuerySizeUnknown
public SecStatusCode BlockSizeMismatch
public SecStatusCode PublicKeyInconsistent
public SecStatusCode DeviceVerifyFailed
public SecStatusCode InvalidLoginName
public SecStatusCode AlreadyLoggedIn
public SecStatusCode InvalidDigestAlgorithm
public SecStatusCode InvalidCRLGroup
public SecStatusCode CertificateCannotOperate
public SecStatusCode CertificateExpired
public SecStatusCode CertificateNotValidYet
public SecStatusCode CertificateRevoked
public SecStatusCode CertificateSuspended
public SecStatusCode InsufficientCredentials
public SecStatusCode InvalidAction
public SecStatusCode InvalidAuthority
public SecStatusCode VerifyActionFailed
public SecStatusCode InvalidCertAuthority
public SecStatusCode InvalidCRLAuthority
public SecStatusCode InvalidCRLEncoding
public SecStatusCode InvalidCRLType
public SecStatusCode InvalidCRL
public SecStatusCode InvalidFormType
public SecStatusCode InvalidID
public SecStatusCode InvalidIdentifier
public SecStatusCode InvalidIndex
public SecStatusCode InvalidPolicyIdentifiers
public SecStatusCode InvalidTimeString
public SecStatusCode InvalidReason
public SecStatusCode InvalidRequestInputs
public SecStatusCode InvalidResponseVector
public SecStatusCode InvalidStopOnPolicy
public SecStatusCode InvalidTuple
public SecStatusCode MultipleValuesUnsupported
public SecStatusCode NotTrusted
public SecStatusCode NoDefaultAuthority
public SecStatusCode RejectedForm
public SecStatusCode RequestLost
public SecStatusCode RequestRejected
public SecStatusCode UnsupportedAddressType
public SecStatusCode UnsupportedService
public SecStatusCode InvalidTupleGroup
public SecStatusCode InvalidBaseACLs
public SecStatusCode InvalidTupleCredentials
public SecStatusCode InvalidEncoding
public SecStatusCode InvalidValidityPeriod
public SecStatusCode InvalidRequestor
public SecStatusCode RequestDescriptor
public SecStatusCode InvalidBundleInfo
public SecStatusCode InvalidCRLIndex
public SecStatusCode NoFieldValues
public SecStatusCode UnsupportedFieldFormat
public SecStatusCode UnsupportedIndexInfo
public SecStatusCode UnsupportedLocality
public SecStatusCode UnsupportedNumAttributes
public SecStatusCode UnsupportedNumIndexes
public SecStatusCode UnsupportedNumRecordTypes
public SecStatusCode FieldSpecifiedMultiple
public SecStatusCode IncompatibleFieldFormat
public SecStatusCode InvalidParsingModule
public SecStatusCode DatabaseLocked
public SecStatusCode DatastoreIsOpen
public SecStatusCode MissingValue
public SecStatusCode UnsupportedQueryLimits
public SecStatusCode UnsupportedNumSelectionPreds
public SecStatusCode UnsupportedOperator
public SecStatusCode InvalidDBLocation
public SecStatusCode InvalidAccessRequest
public SecStatusCode InvalidIndexInfo
public SecStatusCode InvalidNewOwner
public SecStatusCode InvalidModifyMode
public SecStatusCode MissingRequiredExtension
public SecStatusCode ExtendedKeyUsageNotCritical
public SecStatusCode TimestampMissing
public SecStatusCode TimestampInvalid
public SecStatusCode TimestampNotTrusted
public SecStatusCode TimestampServiceNotAvailable
public SecStatusCode TimestampBadAlg
public SecStatusCode TimestampBadRequest
public SecStatusCode TimestampBadDataFormat
public SecStatusCode TimestampTimeNotAvailable
public SecStatusCode TimestampUnacceptedPolicy
public SecStatusCode TimestampUnacceptedExtension
public SecStatusCode TimestampAddInfoNotAvailable
public SecStatusCode TimestampSystemFailure
public SecStatusCode SigningTimeMissing
public SecStatusCode TimestampRejection
public SecStatusCode TimestampWaiting
public SecStatusCode TimestampRevocationWarning
public SecStatusCode TimestampRevocationNotification
}
internal Mono.AppleTls.SecTrust : object {
private IntPtr handle
public int Count
public SecCertificate Item
public IntPtr Handle
internal void .ctor(IntPtr handle, bool owns)
private SecStatusCode SecTrustCreateWithCertificates(IntPtr certOrCertArray, IntPtr policies, IntPtr& sectrustref)
public void .ctor(X509CertificateCollection certificates, SecPolicy policy)
private void Initialize(SecCertificate[] array, SecPolicy policy)
private void Initialize(IntPtr certHandle, SecPolicy policy)
private SecStatusCode SecTrustEvaluate(IntPtr trust, SecTrustResult& result)
public SecTrustResult Evaluate()
private IntPtr SecTrustGetCertificateCount(IntPtr trust)
public int get_Count()
private IntPtr SecTrustGetCertificateAtIndex(IntPtr trust, IntPtr ix)
public SecCertificate get_Item(IntPtr index)
internal X509Certificate GetCertificate(int index)
private SecStatusCode SecTrustSetAnchorCertificates(IntPtr trust, IntPtr anchorCertificates)
public SecStatusCode SetAnchorCertificates(X509CertificateCollection certificates)
public SecStatusCode SetAnchorCertificates(SecCertificate[] array)
private SecStatusCode SecTrustSetAnchorCertificatesOnly(IntPtr trust, bool anchorCertificatesOnly)
public SecStatusCode SetAnchorCertificatesOnly(bool anchorCertificatesOnly)
private SecStatusCode SecTrustSetVerifyDate(IntPtr trust, IntPtr date)
public SecStatusCode SetVerifyDate(DateTime date)
protected void Finalize()
protected void Dispose(bool disposing)
public void Dispose()
public IntPtr get_Handle()
}
internal Mono.AppleTls.SecTrustResult : Enum {
public int value__
public SecTrustResult Invalid
public SecTrustResult Proceed
public SecTrustResult Confirm
public SecTrustResult Deny
public SecTrustResult Unspecified
public SecTrustResult RecoverableTrustFailure
public SecTrustResult FatalTrustFailure
public SecTrustResult ResultOtherError
}
internal Mono.AppleTls.SslAuthenticate : Enum {
public int value__
public SslAuthenticate Try
}
internal Mono.AppleTls.SslCipherSuite : Enum {
public ushort value__
public SslCipherSuite SSL_NULL_WITH_NULL_NULL
public SslCipherSuite TLS_NULL_WITH_NULL_NULL
public SslCipherSuite SSL_RSA_WITH_NULL_MD5
public SslCipherSuite SSL_RSA_WITH_NULL_SHA
public SslCipherSuite SSL_RSA_EXPORT_WITH_RC4_40_MD5
public SslCipherSuite SSL_RSA_WITH_RC4_128_MD5
public SslCipherSuite SSL_RSA_WITH_RC4_128_SHA
public SslCipherSuite SSL_RSA_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite SSL_DH_anon_EXPORT_WITH_RC4_40_MD5
public SslCipherSuite SSL_DH_anon_WITH_RC4_128_MD5
public SslCipherSuite SSL_DH_anon_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite TLS_RSA_WITH_NULL_MD5
public SslCipherSuite TLS_RSA_WITH_NULL_SHA
public SslCipherSuite TLS_RSA_WITH_RC4_128_MD5
public SslCipherSuite TLS_RSA_WITH_RC4_128_SHA
public SslCipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite TLS_DH_anon_WITH_RC4_128_MD5
public SslCipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite TLS_PSK_WITH_NULL_SHA
public SslCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA
public SslCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA
public SslCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA
public SslCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA
public SslCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA
public SslCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA
public SslCipherSuite TLS_RSA_WITH_NULL_SHA256
public SslCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256
public SslCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256
public SslCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
public SslCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
public SslCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256
public SslCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256
public SslCipherSuite TLS_PSK_WITH_RC4_128_SHA
public SslCipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite TLS_PSK_WITH_AES_128_CBC_SHA
public SslCipherSuite TLS_PSK_WITH_AES_256_CBC_SHA
public SslCipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256
public SslCipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384
public SslCipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
public SslCipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
public SslCipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256
public SslCipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384
public SslCipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256
public SslCipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384
public SslCipherSuite TLS_PSK_WITH_NULL_SHA256
public SslCipherSuite TLS_PSK_WITH_NULL_SHA384
public SslCipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA
public SslCipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA
public SslCipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
public SslCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
public SslCipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA
public SslCipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
public SslCipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
public SslCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
public SslCipherSuite TLS_ECDH_RSA_WITH_NULL_SHA
public SslCipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA
public SslCipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
public SslCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
public SslCipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA
public SslCipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA
public SslCipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
public SslCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
public SslCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
public SslCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
public SslCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
public SslCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
public SslCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
public SslCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
public SslCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
public SslCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
public SslCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
public SslCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
public SslCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
public SslCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
public SslCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
public SslCipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
public SslCipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
public SslCipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
public SslCipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
}
internal Mono.AppleTls.SslClientCertificateState : Enum {
public int value__
public SslClientCertificateState None
public SslClientCertificateState Requested
public SslClientCertificateState Sent
public SslClientCertificateState Rejected
}
internal Mono.AppleTls.SslConnectionType : Enum {
public int value__
public SslConnectionType Stream
}
internal Mono.AppleTls.SslProtocol : Enum {
public int value__
public SslProtocol Unknown
public SslProtocol Tls_1_0
public SslProtocol Tls_1_1
public SslProtocol Tls_1_2
}
internal Mono.AppleTls.SslProtocolSide : Enum {
public int value__
public SslProtocolSide Server
public SslProtocolSide Client
}
internal Mono.AppleTls.SslReadFunc : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public SslStatus Invoke(IntPtr connection, IntPtr data, IntPtr& dataLength)
public IAsyncResult BeginInvoke(IntPtr connection, IntPtr data, IntPtr& dataLength, AsyncCallback callback, object object)
public SslStatus EndInvoke(IntPtr& dataLength, IAsyncResult result)
}
internal Mono.AppleTls.SslSessionOption : Enum {
public int value__
public SslSessionOption BreakOnServerAuth
public SslSessionOption BreakOnCertRequested
public SslSessionOption BreakOnClientAuth
}
internal Mono.AppleTls.SslSessionState : Enum {
public int value__
public SslSessionState Invalid
}
internal Mono.AppleTls.SslStatus : Enum {
public int value__
public SslStatus Success
public SslStatus Protocol
public SslStatus Negotiation
public SslStatus FatalAlert
public SslStatus WouldBlock
public SslStatus SessionNotFound
public SslStatus ClosedGraceful
public SslStatus ClosedAbort
public SslStatus XCertChainInvalid
public SslStatus BadCert
public SslStatus Crypto
public SslStatus Internal
public SslStatus ModuleAttach
public SslStatus UnknownRootCert
public SslStatus NoRootCert
public SslStatus CertExpired
public SslStatus CertNotYetValid
public SslStatus ClosedNotNotified
public SslStatus BufferOverflow
public SslStatus BadCipherSuite
public SslStatus PeerUnexpectedMsg
public SslStatus PeerBadRecordMac
public SslStatus PeerDecryptionFail
public SslStatus PeerRecordOverflow
public SslStatus PeerDecompressFail
public SslStatus PeerHandshakeFail
public SslStatus PeerBadCert
public SslStatus PeerUnsupportedCert
public SslStatus PeerCertRevoked
public SslStatus PeerCertExpired
public SslStatus PeerCertUnknown
public SslStatus IllegalParam
public SslStatus PeerUnknownCA
public SslStatus PeerAccessDenied
public SslStatus PeerDecodeError
public SslStatus PeerDecryptError
public SslStatus PeerExportRestriction
public SslStatus PeerProtocolVersion
public SslStatus PeerInsufficientSecurity
public SslStatus PeerInternalError
public SslStatus PeerUserCancelled
public SslStatus PeerNoRenegotiation
public SslStatus PeerAuthCompleted
public SslStatus PeerClientCertRequested
public SslStatus HostNameMismatch
public SslStatus ConnectionRefused
public SslStatus DecryptionFail
public SslStatus BadRecordMac
public SslStatus RecordOverflow
public SslStatus BadConfiguration
public SslStatus UnexpectedRecord
public SslStatus SSLWeakPeerEphemeralDHKey
public SslStatus SSLClientHelloReceived
}
internal Mono.AppleTls.SslWriteFunc : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public SslStatus Invoke(IntPtr connection, IntPtr data, IntPtr& dataLength)
public IAsyncResult BeginInvoke(IntPtr connection, IntPtr data, IntPtr& dataLength, AsyncCallback callback, object object)
public SslStatus EndInvoke(IntPtr& dataLength, IAsyncResult result)
}
internal Mono.Audio.AlsaDevice : AudioDevice {
private IntPtr handle
private IntPtr hw_param
private IntPtr sw_param
private int snd_pcm_open(IntPtr& handle, string pcm_name, int stream, int mode)
private int snd_pcm_close(IntPtr handle)
private int snd_pcm_drain(IntPtr handle)
private int snd_pcm_writei(IntPtr handle, Byte[] buf, int size)
private int snd_pcm_set_params(IntPtr handle, int format, int access, int channels, int rate, int soft_resample, int latency)
private int snd_pcm_state(IntPtr handle)
private int snd_pcm_prepare(IntPtr handle)
private int snd_pcm_hw_params(IntPtr handle, IntPtr param)
private int snd_pcm_hw_params_malloc(IntPtr& param)
private void snd_pcm_hw_params_free(IntPtr param)
private int snd_pcm_hw_params_any(IntPtr handle, IntPtr param)
private int snd_pcm_hw_params_set_access(IntPtr handle, IntPtr param, int access)
private int snd_pcm_hw_params_set_format(IntPtr handle, IntPtr param, int format)
private int snd_pcm_hw_params_set_channels(IntPtr handle, IntPtr param, UInt32 channel)
private int snd_pcm_hw_params_set_rate_near(IntPtr handle, IntPtr param, UInt32& rate, Int32& dir)
private int snd_pcm_hw_params_set_period_time_near(IntPtr handle, IntPtr param, UInt32& period, Int32& dir)
private int snd_pcm_hw_params_get_period_size(IntPtr param, UInt32& period, Int32& dir)
private int snd_pcm_hw_params_set_buffer_size_near(IntPtr handle, IntPtr param, UInt32& buff_size)
private int snd_pcm_hw_params_get_buffer_time_max(IntPtr param, UInt32& buffer_time, Int32& dir)
private int snd_pcm_hw_params_set_buffer_time_near(IntPtr handle, IntPtr param, UInt32& BufferTime, Int32& dir)
private int snd_pcm_hw_params_get_buffer_size(IntPtr param, UInt32& BufferSize)
private int snd_pcm_sw_params(IntPtr handle, IntPtr param)
private int snd_pcm_sw_params_malloc(IntPtr& param)
private void snd_pcm_sw_params_free(IntPtr param)
private int snd_pcm_sw_params_current(IntPtr handle, IntPtr param)
private int snd_pcm_sw_params_set_avail_min(IntPtr handle, IntPtr param, UInt32 frames)
private int snd_pcm_sw_params_set_start_threshold(IntPtr handle, IntPtr param, UInt32 StartThreshold)
public void .ctor(string name)
protected void Finalize()
public void Dispose()
protected void Dispose(bool disposing)
public bool SetFormat(AudioFormat format, int channels, int rate)
public int PlaySample(Byte[] buffer, int num_frames)
public int XRunRecovery(int err)
public void Wait()
}
internal Mono.Audio.AuData : AudioData {
private Stream stream
private short channels
private ushort frame_divider
private int sample_rate
private int data_len
private AudioFormat format
public int Channels
public int Rate
public AudioFormat Format
public void .ctor(Stream data)
public void Play(AudioDevice dev)
public int get_Channels()
public int get_Rate()
public AudioFormat get_Format()
}
internal Mono.Audio.AudioData : object {
protected int buffer_size
private bool stopped
public int Channels
public int Rate
public AudioFormat Format
public bool IsStopped
public int get_Channels()
public int get_Rate()
public AudioFormat get_Format()
public void Setup(AudioDevice dev)
public void Play(AudioDevice dev)
public bool get_IsStopped()
public void set_IsStopped(bool value)
}
internal Mono.Audio.AudioDevice : object {
protected UInt32 chunk_size
public UInt32 ChunkSize
private AudioDevice TryAlsa(string name)
public AudioDevice CreateDevice(string name)
public bool SetFormat(AudioFormat format, int channels, int rate)
public int PlaySample(Byte[] buffer, int num_frames)
public int XRunRecovery(int err)
public void Wait()
public UInt32 get_ChunkSize()
}
internal Mono.Audio.AudioFormat : Enum {
public int value__
public AudioFormat S8
public AudioFormat U8
public AudioFormat S16_LE
public AudioFormat S16_BE
public AudioFormat U16_LE
public AudioFormat U16_BE
public AudioFormat S24_LE
public AudioFormat S24_BE
public AudioFormat U24_LE
public AudioFormat U24_BE
public AudioFormat S32_LE
public AudioFormat S32_BE
public AudioFormat U32_LE
public AudioFormat U32_BE
public AudioFormat FLOAT_LE
public AudioFormat FLOAT_BE
public AudioFormat FLOAT64_LE
public AudioFormat FLOAT64_BE
public AudioFormat IEC958_SUBFRAME_LE
public AudioFormat IEC958_SUBFRAME_BE
public AudioFormat MU_LAW
public AudioFormat A_LAW
public AudioFormat IMA_ADPCM
public AudioFormat MPEG
public AudioFormat GSM
}
internal Mono.Audio.WavData : AudioData {
private Stream stream
private short channels
private ushort frame_divider
private int sample_rate
private int data_len
private long data_offset
private AudioFormat format
public int Channels
public int Rate
public AudioFormat Format
public void .ctor(Stream data)
public void Play(AudioDevice dev)
public int get_Channels()
public int get_Rate()
public AudioFormat get_Format()
}
internal Mono.Audio.Win32SoundPlayer : object {
private Byte[] _buffer
private bool _disposed
public Stream Stream
public void .ctor(Stream s)
private bool PlaySound(Byte[] ptrToSound, UIntPtr hmod, SoundFlags flags)
public void set_Stream(Stream value)
public void Dispose()
protected void Finalize()
protected void Dispose(bool disposing)
public void Play()
public void PlayLooping()
public void PlaySync()
public void Stop()
}
internal Mono.Http.NtlmClient : object {
private ConditionalWeakTable`2<HttpWebRequest, NtlmSession> cache
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
internal Mono.Http.NtlmSession : object {
private MessageBase message
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
}
internal Mono.Net.CFArray : CFObject {
private IntPtr kCFTypeArrayCallbacks
public int Count
public IntPtr Item
public void .ctor(IntPtr handle, bool own)
private IntPtr CFArrayCreate(IntPtr allocator, IntPtr values, IntPtr numValues, IntPtr callbacks)
public CFArray FromNativeObjects(INativeObject[] values)
public IntPtr Create(IntPtr[] values)
internal CFArray CreateArray(IntPtr[] values)
public CFArray CreateArray(INativeObject[] values)
public IntPtr Create(INativeObject[] values)
private IntPtr CFArrayGetCount(IntPtr handle)
public int get_Count()
private IntPtr CFArrayGetValueAtIndex(IntPtr handle, IntPtr index)
public IntPtr get_Item(int index)
public T[] ArrayFromHandle(IntPtr handle, Func`2<IntPtr, T> creation)
}
internal Mono.Net.CFBoolean : object {
private IntPtr handle
public CFBoolean True
public CFBoolean False
public IntPtr Handle
public bool Value
internal void .ctor(IntPtr handle, bool owns)
protected void Finalize()
public IntPtr get_Handle()
public void Dispose()
protected void Dispose(bool disposing)
public bool op_Implicit(CFBoolean value)
public CFBoolean op_Explicit(bool value)
public CFBoolean FromBoolean(bool value)
private bool CFBooleanGetValue(IntPtr boolean)
public bool get_Value()
public bool GetValue(IntPtr boolean)
}
internal Mono.Net.CFData : CFObject {
public IntPtr Length
public IntPtr Bytes
public byte Item
public void .ctor(IntPtr handle, bool own)
private IntPtr CFDataCreate(IntPtr allocator, IntPtr bytes, IntPtr length)
public CFData FromData(Byte[] buffer)
public CFData FromData(IntPtr buffer, IntPtr length)
public IntPtr get_Length()
private IntPtr CFDataGetLength(IntPtr theData)
private IntPtr CFDataGetBytePtr(IntPtr theData)
public IntPtr get_Bytes()
public byte get_Item(long idx)
public void set_Item(long idx, byte value)
}
internal Mono.Net.CFDate : object {
private IntPtr handle
public IntPtr Handle
internal void .ctor(IntPtr handle, bool owns)
protected void Finalize()
private IntPtr CFDateCreate(IntPtr allocator, double at)
public CFDate Create(DateTime date)
public IntPtr get_Handle()
public void Dispose()
protected void Dispose(bool disposing)
}
internal Mono.Net.CFDictionary : CFObject {
private IntPtr KeyCallbacks
private IntPtr ValueCallbacks
public IntPtr Item
public void .ctor(IntPtr handle, bool own)
public CFDictionary FromObjectAndKey(IntPtr obj, IntPtr key)
public CFDictionary FromKeysAndObjects(IList`1<Tuple`2<IntPtr, IntPtr>> items)
private IntPtr CFDictionaryCreate(IntPtr allocator, IntPtr[] keys, IntPtr[] vals, IntPtr len, IntPtr keyCallbacks, IntPtr valCallbacks)
private IntPtr CFDictionaryGetValue(IntPtr handle, IntPtr key)
private IntPtr CFDictionaryCreateCopy(IntPtr allocator, IntPtr handle)
public CFDictionary Copy()
public CFMutableDictionary MutableCopy()
private IntPtr CFDictionaryCreateMutableCopy(IntPtr allocator, IntPtr capacity, IntPtr theDict)
public IntPtr GetValue(IntPtr key)
public IntPtr get_Item(IntPtr key)
}
internal Mono.Net.CFMutableDictionary : CFDictionary {
public void .ctor(IntPtr handle, bool own)
public void SetValue(IntPtr key, IntPtr val)
public CFMutableDictionary Create()
private void CFDictionarySetValue(IntPtr handle, IntPtr key, IntPtr val)
private IntPtr CFDictionaryCreateMutable(IntPtr allocator, IntPtr capacity, IntPtr keyCallback, IntPtr valueCallbacks)
}
internal Mono.Net.CFNetwork : object {
public string CFNetworkLibrary
private object lock_obj
private Queue`1<GetProxyData> get_proxy_queue
private AutoResetEvent proxy_event
private IntPtr CFNetworkCopyProxiesForAutoConfigurationScriptSequential(IntPtr proxyAutoConfigurationScript, IntPtr targetURL, IntPtr& error)
private IntPtr CFNetworkExecuteProxyAutoConfigurationURL(IntPtr proxyAutoConfigURL, IntPtr targetURL, CFProxyAutoConfigurationResultCallback cb, CFStreamClientContext& clientContext)
private void CFNetworkCopyProxiesForAutoConfigurationScriptThread()
private IntPtr CFNetworkCopyProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, IntPtr targetURL, IntPtr& error)
private CFArray CopyProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, CFUrl targetURL)
public CFProxy[] GetProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, CFUrl targetURL)
public CFProxy[] GetProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, Uri targetUri)
public CFProxy[] ExecuteProxyAutoConfigurationURL(IntPtr proxyAutoConfigURL, Uri targetURL)
private IntPtr CFNetworkCopyProxiesForURL(IntPtr url, IntPtr proxySettings)
private CFArray CopyProxiesForURL(CFUrl url, CFDictionary proxySettings)
public CFProxy[] GetProxiesForURL(CFUrl url, CFProxySettings proxySettings)
public CFProxy[] GetProxiesForUri(Uri uri, CFProxySettings proxySettings)
private IntPtr CFNetworkCopySystemProxySettings()
public CFProxySettings GetSystemProxySettings()
public IWebProxy GetDefaultProxy()
}
internal Mono.Net.CFNumber : CFObject {
public void .ctor(IntPtr handle, bool own)
private bool CFNumberGetValue(IntPtr handle, IntPtr type, Boolean& value)
public bool AsBool(IntPtr handle)
public bool op_Implicit(CFNumber number)
private bool CFNumberGetValue(IntPtr handle, IntPtr type, Int32& value)
public int AsInt32(IntPtr handle)
private IntPtr CFNumberCreate(IntPtr allocator, IntPtr theType, IntPtr valuePtr)
public CFNumber FromInt32(int number)
public int op_Implicit(CFNumber number)
}
internal Mono.Net.CFObject : object {
public string CoreFoundationLibrary
private string SystemLibrary
private IntPtr <Handle>k__BackingField
public IntPtr Handle
public IntPtr dlopen(string path, int mode)
private IntPtr dlsym(IntPtr handle, string symbol)
public void dlclose(IntPtr handle)
public IntPtr GetIndirect(IntPtr handle, string symbol)
public CFString GetStringConstant(IntPtr handle, string symbol)
public IntPtr GetIntPtr(IntPtr handle, string symbol)
public IntPtr GetCFObjectHandle(IntPtr handle, string symbol)
public void .ctor(IntPtr handle, bool own)
protected void Finalize()
public IntPtr get_Handle()
private void set_Handle(IntPtr value)
internal IntPtr CFRetain(IntPtr handle)
private void Retain()
internal void CFRelease(IntPtr handle)
private void Release()
protected void Dispose(bool disposing)
public void Dispose()
}
internal Mono.Net.CFProxy : object {
private IntPtr kCFProxyAutoConfigurationJavaScriptKey
private IntPtr kCFProxyAutoConfigurationURLKey
private IntPtr kCFProxyHostNameKey
private IntPtr kCFProxyPasswordKey
private IntPtr kCFProxyPortNumberKey
private IntPtr kCFProxyTypeKey
private IntPtr kCFProxyUsernameKey
private IntPtr kCFProxyTypeAutoConfigurationURL
private IntPtr kCFProxyTypeAutoConfigurationJavaScript
private IntPtr kCFProxyTypeFTP
private IntPtr kCFProxyTypeHTTP
private IntPtr kCFProxyTypeHTTPS
private IntPtr kCFProxyTypeSOCKS
private CFDictionary settings
public IntPtr AutoConfigurationJavaScript
public IntPtr AutoConfigurationUrl
public string HostName
public string Password
public int Port
public CFProxyType ProxyType
public string Username
internal void .ctor(CFDictionary settings)
private CFProxyType CFProxyTypeToEnum(IntPtr type)
public IntPtr get_AutoConfigurationJavaScript()
public IntPtr get_AutoConfigurationUrl()
public string get_HostName()
public string get_Password()
public int get_Port()
public CFProxyType get_ProxyType()
public string get_Username()
}
internal Mono.Net.CFProxySettings : object {
private IntPtr kCFNetworkProxiesHTTPEnable
private IntPtr kCFNetworkProxiesHTTPPort
private IntPtr kCFNetworkProxiesHTTPProxy
private IntPtr kCFNetworkProxiesProxyAutoConfigEnable
private IntPtr kCFNetworkProxiesProxyAutoConfigJavaScript
private IntPtr kCFNetworkProxiesProxyAutoConfigURLString
private CFDictionary settings
public CFDictionary Dictionary
public bool HTTPEnable
public int HTTPPort
public string HTTPProxy
public bool ProxyAutoConfigEnable
public string ProxyAutoConfigJavaScript
public string ProxyAutoConfigURLString
public void .ctor(CFDictionary settings)
public CFDictionary get_Dictionary()
public bool get_HTTPEnable()
public int get_HTTPPort()
public string get_HTTPProxy()
public bool get_ProxyAutoConfigEnable()
public string get_ProxyAutoConfigJavaScript()
public string get_ProxyAutoConfigURLString()
}
internal Mono.Net.CFProxyType : Enum {
public int value__
public CFProxyType None
public CFProxyType AutoConfigurationUrl
public CFProxyType AutoConfigurationJavaScript
public CFProxyType FTP
public CFProxyType HTTP
public CFProxyType HTTPS
public CFProxyType SOCKS
}
internal Mono.Net.CFRange : ValueType {
public IntPtr Location
public IntPtr Length
public void .ctor(int loc, int len)
}
internal Mono.Net.CFRunLoop : CFObject {
public CFRunLoop CurrentRunLoop
private void CFRunLoopAddSource(IntPtr rl, IntPtr source, IntPtr mode)
private void CFRunLoopRemoveSource(IntPtr rl, IntPtr source, IntPtr mode)
private int CFRunLoopRunInMode(IntPtr mode, double seconds, bool returnAfterSourceHandled)
private IntPtr CFRunLoopGetCurrent()
private void CFRunLoopStop(IntPtr rl)
public void .ctor(IntPtr handle, bool own)
public CFRunLoop get_CurrentRunLoop()
public void AddSource(IntPtr source, CFString mode)
public void RemoveSource(IntPtr source, CFString mode)
public int RunInMode(CFString mode, double seconds, bool returnAfterSourceHandled)
public void Stop()
}
internal Mono.Net.CFStreamClientContext : ValueType {
public IntPtr Version
public IntPtr Info
public IntPtr Retain
public IntPtr Release
public IntPtr CopyDescription
}
internal Mono.Net.CFString : CFObject {
private string str
public int Length
public void .ctor(IntPtr handle, bool own)
private IntPtr CFStringCreateWithCharacters(IntPtr alloc, IntPtr chars, IntPtr length)
public CFString Create(string value)
private IntPtr CFStringGetLength(IntPtr handle)
public int get_Length()
private IntPtr CFStringGetCharactersPtr(IntPtr handle)
private IntPtr CFStringGetCharacters(IntPtr handle, CFRange range, IntPtr buffer)
public string AsString(IntPtr handle)
public string ToString()
public string op_Implicit(CFString str)
public CFString op_Implicit(string str)
}
internal Mono.Net.CFType : object {
public IntPtr GetTypeID(IntPtr typeRef)
}
internal Mono.Net.CFUrl : CFObject {
public void .ctor(IntPtr handle, bool own)
private IntPtr CFURLCreateWithString(IntPtr allocator, IntPtr str, IntPtr baseURL)
public CFUrl Create(string absolute)
}
internal Mono.Net.Dns.DnsClass : Enum {
public ushort value__
public DnsClass Internet
public DnsClass IN
public DnsClass CSNET
public DnsClass CS
public DnsClass CHAOS
public DnsClass CH
public DnsClass Hesiod
public DnsClass HS
}
internal Mono.Net.Dns.DnsHeader : object {
public int DnsHeaderLength
private ArraySegment`1<byte> bytes
public ushort ID
public bool IsQuery
public DnsOpCode OpCode
public bool AuthoritativeAnswer
public bool Truncation
public bool RecursionDesired
public bool RecursionAvailable
public int ZReserved
public DnsRCode RCode
public ushort QuestionCount
public ushort AnswerCount
public ushort AuthorityCount
public ushort AdditionalCount
public void .ctor(Byte[] bytes)
public void .ctor(Byte[] bytes, int offset)
public void .ctor(ArraySegment`1<byte> segment)
public void Clear()
public ushort get_ID()
public void set_ID(ushort value)
public bool get_IsQuery()
public void set_IsQuery(bool value)
public DnsOpCode get_OpCode()
public void set_OpCode(DnsOpCode value)
public bool get_AuthoritativeAnswer()
public void set_AuthoritativeAnswer(bool value)
public bool get_Truncation()
public void set_Truncation(bool value)
public bool get_RecursionDesired()
public void set_RecursionDesired(bool value)
public bool get_RecursionAvailable()
public void set_RecursionAvailable(bool value)
public int get_ZReserved()
public void set_ZReserved(int value)
public DnsRCode get_RCode()
public void set_RCode(DnsRCode value)
private ushort GetUInt16(Byte[] bytes, int offset)
private void SetUInt16(Byte[] bytes, int offset, ushort val)
public ushort get_QuestionCount()
public void set_QuestionCount(ushort value)
public ushort get_AnswerCount()
public void set_AnswerCount(ushort value)
public ushort get_AuthorityCount()
public void set_AuthorityCount(ushort value)
public ushort get_AdditionalCount()
public void set_AdditionalCount(ushort value)
public string ToString()
}
internal Mono.Net.Dns.DnsOpCode : Enum {
public byte value__
public DnsOpCode Query
public DnsOpCode IQuery
public DnsOpCode Status
public DnsOpCode Notify
public DnsOpCode Update
}
internal Mono.Net.Dns.DnsPacket : object {
protected Byte[] packet
protected int position
protected DnsHeader header
public Byte[] Packet
public int Length
public DnsHeader Header
protected void .ctor(int length)
protected void .ctor(Byte[] buffer, int length)
public Byte[] get_Packet()
public int get_Length()
public DnsHeader get_Header()
protected void WriteUInt16(ushort v)
protected void WriteStringBytes(string str, int offset, int count)
protected void WriteLabel(string str, int offset, int count)
protected void WriteDnsName(string name)
protected internal string ReadName(Int32& offset)
protected internal string ReadName(Byte[] buffer, Int32& offset)
protected internal ushort ReadUInt16(Int32& offset)
protected internal int ReadInt32(Int32& offset)
}
internal Mono.Net.Dns.DnsQClass : Enum {
public ushort value__
public DnsQClass Internet
public DnsQClass IN
public DnsQClass CSNET
public DnsQClass CS
public DnsQClass CHAOS
public DnsQClass CH
public DnsQClass Hesiod
public DnsQClass HS
public DnsQClass None
public DnsQClass Any
}
internal Mono.Net.Dns.DnsQType : Enum {
public ushort value__
public DnsQType A
public DnsQType NS
public DnsQType MD
public DnsQType MF
public DnsQType CNAME
public DnsQType SOA
public DnsQType MB
public DnsQType MG
public DnsQType MR
public DnsQType NULL
public DnsQType WKS
public DnsQType PTR
public DnsQType HINFO
public DnsQType MINFO
public DnsQType MX
public DnsQType TXT
public DnsQType RP
public DnsQType AFSDB
public DnsQType X25
public DnsQType ISDN
public DnsQType RT
public DnsQType NSAP
public DnsQType NSAPPTR
public DnsQType SIG
public DnsQType KEY
public DnsQType PX
public DnsQType GPOS
public DnsQType AAAA
public DnsQType LOC
public DnsQType NXT
public DnsQType EID
public DnsQType NIMLOC
public DnsQType SRV
public DnsQType ATMA
public DnsQType NAPTR
public DnsQType KX
public DnsQType CERT
public DnsQType A6
public DnsQType DNAME
public DnsQType SINK
public DnsQType OPT
public DnsQType APL
public DnsQType DS
public DnsQType SSHFP
public DnsQType IPSECKEY
public DnsQType RRSIG
public DnsQType NSEC
public DnsQType DNSKEY
public DnsQType DHCID
public DnsQType NSEC3
public DnsQType NSEC3PARAM
public DnsQType HIP
public DnsQType NINFO
public DnsQType RKEY
public DnsQType TALINK
public DnsQType SPF
public DnsQType UINFO
public DnsQType UID
public DnsQType GID
public DnsQType UNSPEC
public DnsQType TKEY
public DnsQType TSIG
public DnsQType IXFR
public DnsQType AXFR
public DnsQType MAILB
public DnsQType MAILA
public DnsQType ALL
public DnsQType URI
public DnsQType TA
public DnsQType DLV
}
internal Mono.Net.Dns.DnsQuery : DnsPacket {
public void .ctor(string name, DnsQType qtype, DnsQClass qclass)
}
internal Mono.Net.Dns.DnsQuestion : object {
private string name
private DnsQType type
private DnsQClass _class
public string Name
public DnsQType Type
public DnsQClass Class
internal int Init(DnsPacket packet, int offset)
public string get_Name()
public DnsQType get_Type()
public DnsQClass get_Class()
public string ToString()
}
internal Mono.Net.Dns.DnsRCode : Enum {
public ushort value__
public DnsRCode NoError
public DnsRCode FormErr
public DnsRCode ServFail
public DnsRCode NXDomain
public DnsRCode NotImp
public DnsRCode Refused
public DnsRCode YXDomain
public DnsRCode YXRRSet
public DnsRCode NXRRSet
public DnsRCode NotAuth
public DnsRCode NotZone
public DnsRCode BadVers
public DnsRCode BadSig
public DnsRCode BadKey
public DnsRCode BadTime
public DnsRCode BadMode
public DnsRCode BadName
public DnsRCode BadAlg
public DnsRCode BadTrunc
}
internal Mono.Net.Dns.DnsResourceRecord : object {
private string name
private DnsType type
private DnsClass klass
private int ttl
private ushort rdlength
private ArraySegment`1<byte> m_rdata
public string Name
public DnsType Type
public DnsClass Class
public int Ttl
public ArraySegment`1<byte> Data
internal void CopyFrom(DnsResourceRecord rr)
internal DnsResourceRecord CreateFromBuffer(DnsPacket packet, int size, Int32& offset)
public string get_Name()
public DnsType get_Type()
public DnsClass get_Class()
public int get_Ttl()
public ArraySegment`1<byte> get_Data()
public string ToString()
}
internal Mono.Net.Dns.DnsResourceRecordA : DnsResourceRecordIPAddress {
internal void .ctor(DnsResourceRecord rr)
}
internal Mono.Net.Dns.DnsResourceRecordAAAA : DnsResourceRecordIPAddress {
internal void .ctor(DnsResourceRecord rr)
}
internal Mono.Net.Dns.DnsResourceRecordCName : DnsResourceRecord {
private string cname
public string CName
internal void .ctor(DnsResourceRecord rr)
public string get_CName()
public string ToString()
}
internal Mono.Net.Dns.DnsResourceRecordIPAddress : DnsResourceRecord {
private IPAddress address
public IPAddress Address
internal void .ctor(DnsResourceRecord rr, int address_size)
public string ToString()
public IPAddress get_Address()
}
internal Mono.Net.Dns.DnsResourceRecordPTR : DnsResourceRecord {
private string dname
public string DName
internal void .ctor(DnsResourceRecord rr)
public string get_DName()
public string ToString()
}
internal Mono.Net.Dns.DnsResponse : DnsPacket {
private ReadOnlyCollection`1<DnsResourceRecord> EmptyRR
private ReadOnlyCollection`1<DnsQuestion> EmptyQS
private ReadOnlyCollection`1<DnsQuestion> question
private ReadOnlyCollection`1<DnsResourceRecord> answer
private ReadOnlyCollection`1<DnsResourceRecord> authority
private ReadOnlyCollection`1<DnsResourceRecord> additional
private int offset
public void .ctor(Byte[] buffer, int length)
public void Reset()
private ReadOnlyCollection`1<DnsResourceRecord> GetRRs(int count)
private ReadOnlyCollection`1<DnsQuestion> GetQuestions(int count)
public ReadOnlyCollection`1<DnsQuestion> GetQuestions()
public ReadOnlyCollection`1<DnsResourceRecord> GetAnswers()
public ReadOnlyCollection`1<DnsResourceRecord> GetAuthority()
public ReadOnlyCollection`1<DnsResourceRecord> GetAdditional()
public string ToString()
}
internal Mono.Net.Dns.DnsType : Enum {
public ushort value__
public DnsType A
public DnsType NS
public DnsType MD
public DnsType MF
public DnsType CNAME
public DnsType SOA
public DnsType MB
public DnsType MG
public DnsType MR
public DnsType NULL
public DnsType WKS
public DnsType PTR
public DnsType HINFO
public DnsType MINFO
public DnsType MX
public DnsType TXT
public DnsType RP
public DnsType AFSDB
public DnsType X25
public DnsType ISDN
public DnsType RT
public DnsType NSAP
public DnsType NSAPPTR
public DnsType SIG
public DnsType KEY
public DnsType PX
public DnsType GPOS
public DnsType AAAA
public DnsType LOC
public DnsType NXT
public DnsType EID
public DnsType NIMLOC
public DnsType SRV
public DnsType ATMA
public DnsType NAPTR
public DnsType KX
public DnsType CERT
public DnsType A6
public DnsType DNAME
public DnsType SINK
public DnsType OPT
public DnsType APL
public DnsType DS
public DnsType SSHFP
public DnsType IPSECKEY
public DnsType RRSIG
public DnsType NSEC
public DnsType DNSKEY
public DnsType DHCID
public DnsType NSEC3
public DnsType NSEC3PARAM
public DnsType HIP
public DnsType NINFO
public DnsType RKEY
public DnsType TALINK
public DnsType SPF
public DnsType UINFO
public DnsType UID
public DnsType GID
public DnsType UNSPEC
public DnsType TKEY
public DnsType TSIG
public DnsType IXFR
public DnsType AXFR
public DnsType MAILB
public DnsType MAILA
public DnsType URI
public DnsType TA
public DnsType DLV
}
internal Mono.Net.Dns.DnsUtil : object {
public bool IsValidDnsName(string name)
public int GetEncodedLength(string name)
public int GetNameLength(Byte[] buffer)
public int GetNameLength(Byte[] buffer, int offset)
public string ReadName(Byte[] buffer, Int32& offset)
}
internal Mono.Net.Dns.ResolverAsyncOperation : Enum {
public int value__
public ResolverAsyncOperation None
public ResolverAsyncOperation GetHostEntry
public ResolverAsyncOperation GetHostAddresses
}
internal Mono.Net.Dns.ResolverError : Enum {
public int value__
public ResolverError NoError
public ResolverError FormatError
public ResolverError ServerFailure
public ResolverError NameError
public ResolverError NotImplemented
public ResolverError Refused
public ResolverError ResponseHeaderError
public ResolverError ResponseFormatError
public ResolverError Timeout
}
internal Mono.Net.Dns.SimpleResolver : object {
private String[] EmptyStrings
private IPAddress[] EmptyAddresses
private IPEndPoint[] endpoints
private Socket client
private Dictionary`2<int, SimpleResolverEventArgs> queries
private AsyncCallback receive_cb
private TimerCallback timeout_cb
private bool disposed
private void System.IDisposable.Dispose()
public void Close()
private void GetLocalHost(SimpleResolverEventArgs args)
public bool GetHostAddressesAsync(SimpleResolverEventArgs args)
public bool GetHostEntryAsync(SimpleResolverEventArgs args)
private bool AddQuery(DnsQuery query, SimpleResolverEventArgs args)
private DnsQuery GetQuery(string host, DnsQType q, DnsQClass c)
private void SendAQuery(SimpleResolverEventArgs args, bool add_it)
private void SendAQuery(SimpleResolverEventArgs args, string host, bool add_it)
private string GetPTRName(IPAddress address)
private void SendPTRQuery(SimpleResolverEventArgs args, bool add_it)
private void SendQuery(SimpleResolverEventArgs args, DnsQuery query, bool add_it)
private Byte[] GetFreshBuffer()
private void FreeBuffer(Byte[] buffer)
private void InitSocket()
private void BeginReceive()
private void OnTimeout(object obj)
private void OnReceive(IAsyncResult ares)
private void ProcessResponse(SimpleResolverEventArgs args, DnsResponse response, EndPoint server_ep)
private void InitFromSystem()
}
internal Mono.Net.Dns.SimpleResolverEventArgs : EventArgs {
private EventHandler`1<SimpleResolverEventArgs> Completed
private ResolverError <ResolverError>k__BackingField
private string <ErrorMessage>k__BackingField
public ResolverAsyncOperation LastOperation
private string <HostName>k__BackingField
private IPHostEntry <HostEntry>k__BackingField
private object <UserToken>k__BackingField
internal ushort QueryID
internal ushort Retries
internal Timer Timer
internal IPAddress PTRAddress
public ResolverError ResolverError
public string ErrorMessage
public string HostName
public IPHostEntry HostEntry
public object UserToken
public void add_Completed(EventHandler`1<SimpleResolverEventArgs> value)
public void remove_Completed(EventHandler`1<SimpleResolverEventArgs> value)
public ResolverError get_ResolverError()
public void set_ResolverError(ResolverError value)
public string get_ErrorMessage()
public void set_ErrorMessage(string value)
public string get_HostName()
public void set_HostName(string value)
public IPHostEntry get_HostEntry()
internal void set_HostEntry(IPHostEntry value)
public object get_UserToken()
public void set_UserToken(object value)
internal void Reset(ResolverAsyncOperation op)
protected internal void OnCompleted(object sender)
}
internal Mono.Net.Security.AsyncHandshakeRequest : AsyncProtocolRequest {
public void .ctor(MobileAuthenticatedStream parent, bool sync)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
}
internal Mono.Net.Security.AsyncOperationStatus : Enum {
public int value__
public AsyncOperationStatus Initialize
public AsyncOperationStatus Continue
public AsyncOperationStatus ReadDone
public AsyncOperationStatus Complete
}
internal Mono.Net.Security.AsyncProtocolRequest : object {
private MobileAuthenticatedStream <Parent>k__BackingField
private bool <RunSynchronously>k__BackingField
private int <UserResult>k__BackingField
private int Started
private int RequestedSize
private int WriteRequested
private object locker
private int next_id
public MobileAuthenticatedStream Parent
public bool RunSynchronously
public int ID
public string Name
public int UserResult
public MobileAuthenticatedStream get_Parent()
public bool get_RunSynchronously()
public int get_ID()
public string get_Name()
public int get_UserResult()
protected void set_UserResult(int value)
public void .ctor(MobileAuthenticatedStream parent, bool sync)
protected void Debug(string message, Object[] args)
internal void RequestRead(int size)
internal void RequestWrite()
internal Task`1<AsyncProtocolResult> StartOperation(CancellationToken cancellationToken)
private Task ProcessOperation(CancellationToken cancellationToken)
private Task`1<Nullable`1<int>> InnerRead(CancellationToken cancellationToken)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
public string ToString()
}
internal Mono.Net.Security.AsyncProtocolResult : object {
private int <UserResult>k__BackingField
private ExceptionDispatchInfo <Error>k__BackingField
public int UserResult
public ExceptionDispatchInfo Error
public int get_UserResult()
public ExceptionDispatchInfo get_Error()
public void .ctor(int result)
public void .ctor(ExceptionDispatchInfo error)
}
internal Mono.Net.Security.AsyncReadOrWriteRequest : AsyncProtocolRequest {
private BufferOffsetSize <UserBuffer>k__BackingField
private int <CurrentSize>k__BackingField
protected BufferOffsetSize UserBuffer
protected int CurrentSize
protected BufferOffsetSize get_UserBuffer()
protected int get_CurrentSize()
protected void set_CurrentSize(int value)
public void .ctor(MobileAuthenticatedStream parent, bool sync, Byte[] buffer, int offset, int size)
public string ToString()
}
internal Mono.Net.Security.AsyncReadRequest : AsyncReadOrWriteRequest {
public void .ctor(MobileAuthenticatedStream parent, bool sync, Byte[] buffer, int offset, int size)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
}
internal Mono.Net.Security.AsyncShutdownRequest : AsyncProtocolRequest {
public void .ctor(MobileAuthenticatedStream parent)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
}
internal Mono.Net.Security.AsyncWriteRequest : AsyncReadOrWriteRequest {
public void .ctor(MobileAuthenticatedStream parent, bool sync, Byte[] buffer, int offset, int size)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
}
internal Mono.Net.Security.BufferOffsetSize : object {
public Byte[] Buffer
public int Offset
public int Size
public int TotalBytes
public bool Complete
public int EndOffset
public int Remaining
public int get_EndOffset()
public int get_Remaining()
public void .ctor(Byte[] buffer, int offset, int size)
public string ToString()
}
internal Mono.Net.Security.BufferOffsetSize2 : BufferOffsetSize {
public int InitialSize
public void .ctor(int size)
public void Reset()
public void MakeRoom(int size)
public void AppendData(Byte[] buffer, int offset, int size)
}
internal Mono.Net.Security.ChainValidationHelper : object {
private object sender
private MonoTlsSettings settings
private MonoTlsProvider provider
private ServerCertValidationCallback certValidationCallback
private LocalCertSelectionCallback certSelectionCallback
private ServerCertValidationCallbackWrapper callbackWrapper
private MonoTlsStream tlsStream
private HttpWebRequest request
public MonoTlsProvider Provider
public MonoTlsSettings Settings
public bool HasCertificateSelectionCallback
internal ICertificateValidator GetInternalValidator(MonoTlsProvider provider, MonoTlsSettings settings)
internal ICertificateValidator GetDefaultValidator(MonoTlsSettings settings)
internal ChainValidationHelper CloneWithCallbackWrapper(MonoTlsProvider provider, MonoTlsSettings& settings, ServerCertValidationCallbackWrapper wrapper)
internal bool InvokeCallback(ServerCertValidationCallback callback, object sender, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors)
private void .ctor(ChainValidationHelper other, MonoTlsProvider provider, MonoTlsSettings settings, ServerCertValidationCallbackWrapper callbackWrapper)
internal ChainValidationHelper Create(MonoTlsProvider provider, MonoTlsSettings& settings, MonoTlsStream stream)
private void .ctor(MonoTlsProvider provider, MonoTlsSettings settings, bool cloneSettings, MonoTlsStream stream, ServerCertValidationCallbackWrapper callbackWrapper)
private X509Certificate DefaultSelectionCallback(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
public MonoTlsProvider get_Provider()
public MonoTlsSettings get_Settings()
public bool get_HasCertificateSelectionCallback()
public bool SelectClientCertificate(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, X509Certificate& clientCertificate)
internal X509Certificate SelectClientCertificate(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
internal bool ValidateClientCertificate(X509Certificate certificate, MonoSslPolicyErrors errors)
public ValidationResult ValidateCertificate(string host, bool serverMode, X509CertificateCollection certs)
public ValidationResult ValidateCertificate(string host, bool serverMode, X509Certificate leaf, X509Chain chain)
private ValidationResult ValidateChain(string host, bool server, X509Certificate leaf, X509Chain chain, X509CertificateCollection certs, SslPolicyErrors errors)
private ValidationResult ValidateChain(string host, bool server, X509Certificate leaf, X509Chain& chain, X509CertificateCollection certs, SslPolicyErrors errors)
private bool InvokeSystemValidator(string targetHost, bool serverMode, X509CertificateCollection certificates, X509Chain chain, MonoSslPolicyErrors& xerrors, Int32& status11)
}
internal Mono.Net.Security.LegacyTlsProvider : MonoTlsProvider {
public Guid ID
public string Name
public bool SupportsSslStream
public bool SupportsConnectionInfo
public bool SupportsMonoExtensions
internal bool SupportsCleanShutdown
public SslProtocols SupportedProtocols
public Guid get_ID()
public string get_Name()
public bool get_SupportsSslStream()
public bool get_SupportsConnectionInfo()
public bool get_SupportsMonoExtensions()
internal bool get_SupportsCleanShutdown()
public SslProtocols get_SupportedProtocols()
public IMonoSslStream CreateSslStream(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
internal IMonoSslStream CreateSslStreamInternal(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
internal bool ValidateCertificate(ICertificateValidator2 validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain& chain, MonoSslPolicyErrors& errors, Int32& status11)
}
internal Mono.Net.Security.MobileAuthenticatedStream : AuthenticatedStream {
private MobileTlsContext xobileTlsContext
private ExceptionDispatchInfo lastException
private AsyncProtocolRequest asyncHandshakeRequest
private AsyncProtocolRequest asyncReadRequest
private AsyncProtocolRequest asyncWriteRequest
private BufferOffsetSize2 readBuffer
private BufferOffsetSize2 writeBuffer
private object ioLock
private int closeRequested
private bool shutdown
private int uniqueNameInteger
private SslStream <SslStream>k__BackingField
private MonoTlsSettings <Settings>k__BackingField
private MonoTlsProvider <Provider>k__BackingField
private int nextId
internal int ID
public SslStream SslStream
public MonoTlsSettings Settings
public MonoTlsProvider Provider
internal bool HasContext
private SslProtocols DefaultProtocols
public AuthenticatedStream AuthenticatedStream
public bool IsServer
public bool IsAuthenticated
public bool IsMutuallyAuthenticated
public SslProtocols SslProtocol
public X509Certificate RemoteCertificate
public X509Certificate LocalCertificate
public X509Certificate InternalLocalCertificate
public TransportContext TransportContext
public bool CanRead
public bool CanTimeout
public bool CanWrite
public bool CanSeek
public long Length
public long Position
public bool IsEncrypted
public bool IsSigned
public int ReadTimeout
public int WriteTimeout
public CipherAlgorithmType CipherAlgorithm
public HashAlgorithmType HashAlgorithm
public ExchangeAlgorithmType KeyExchangeAlgorithm
public int CipherStrength
public int HashStrength
public int KeyExchangeStrength
public bool CheckCertRevocationStatus
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MonoTlsProvider provider)
public SslStream get_SslStream()
public MonoTlsSettings get_Settings()
public MonoTlsProvider get_Provider()
internal bool get_HasContext()
internal void CheckThrow(bool authSuccessCheck, bool shutdownCheck)
internal Exception GetSSPIException(Exception e)
internal Exception GetIOException(Exception e, string message)
internal ExceptionDispatchInfo SetException(Exception e)
private SslProtocols get_DefaultProtocols()
public void AuthenticateAsClient(string targetHost)
public void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public void AuthenticateAsServer(X509Certificate serverCertificate)
public void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public void EndAuthenticateAsServer(IAsyncResult asyncResult)
public Task AuthenticateAsClientAsync(string targetHost)
public Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task ShutdownAsync()
public AuthenticatedStream get_AuthenticatedStream()
private Task ProcessAuthentication(bool runSynchronously, bool serverMode, string targetHost, SslProtocols enabledProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool clientCertRequired)
protected MobileTlsContext CreateContext(bool serverMode, string targetHost, SslProtocols enabledProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool askForClientCert)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public int EndRead(IAsyncResult asyncResult)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void EndWrite(IAsyncResult asyncResult)
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer)
public void Write(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> StartOperation(OperationType type, AsyncProtocolRequest asyncRequest, CancellationToken cancellationToken)
protected internal void Debug(string message, Object[] args)
internal int InternalRead(Byte[] buffer, int offset, int size, Boolean& outWantMore)
private ValueTuple`2<int, bool> InternalRead(AsyncProtocolRequest asyncRequest, BufferOffsetSize internalBuffer, Byte[] buffer, int offset, int size)
internal bool InternalWrite(Byte[] buffer, int offset, int size)
private bool InternalWrite(AsyncProtocolRequest asyncRequest, BufferOffsetSize2 internalBuffer, Byte[] buffer, int offset, int size)
internal Task`1<int> InnerRead(bool sync, int requestedSize, CancellationToken cancellationToken)
internal Task InnerWrite(bool sync, CancellationToken cancellationToken)
internal AsyncOperationStatus ProcessHandshake(AsyncOperationStatus status)
internal ValueTuple`2<int, bool> ProcessRead(BufferOffsetSize userBuffer)
internal ValueTuple`2<int, bool> ProcessWrite(BufferOffsetSize userBuffer)
internal AsyncOperationStatus ProcessShutdown(AsyncOperationStatus status)
public bool get_IsServer()
public bool get_IsAuthenticated()
public bool get_IsMutuallyAuthenticated()
protected void Dispose(bool disposing)
public void Flush()
public SslProtocols get_SslProtocol()
public X509Certificate get_RemoteCertificate()
public X509Certificate get_LocalCertificate()
public X509Certificate get_InternalLocalCertificate()
public MonoTlsConnectionInfo GetConnectionInfo()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public TransportContext get_TransportContext()
public bool get_CanRead()
public bool get_CanTimeout()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_IsEncrypted()
public bool get_IsSigned()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public CipherAlgorithmType get_CipherAlgorithm()
public HashAlgorithmType get_HashAlgorithm()
public ExchangeAlgorithmType get_KeyExchangeAlgorithm()
public int get_CipherStrength()
public int get_HashStrength()
public int get_KeyExchangeStrength()
public bool get_CheckCertRevocationStatus()
private void <InnerWrite>b__67_0()
}
internal Mono.Net.Security.MobileTlsContext : object {
private MobileAuthenticatedStream parent
private bool serverMode
private string targetHost
private string serverName
private SslProtocols enabledProtocols
private X509Certificate serverCertificate
private X509CertificateCollection clientCertificates
private bool askForClientCert
private ICertificateValidator2 certificateValidator
internal MobileAuthenticatedStream Parent
public MonoTlsSettings Settings
public MonoTlsProvider Provider
public bool HasContext
public bool IsAuthenticated
public bool IsServer
protected string TargetHost
protected string ServerName
protected bool AskForClientCertificate
protected SslProtocols EnabledProtocols
protected X509CertificateCollection ClientCertificates
public MonoTlsConnectionInfo ConnectionInfo
internal X509Certificate LocalServerCertificate
internal bool IsRemoteCertificateAvailable
internal X509Certificate LocalClientCertificate
public X509Certificate RemoteCertificate
public TlsProtocols NegotiatedProtocol
public void .ctor(MobileAuthenticatedStream parent, bool serverMode, string targetHost, SslProtocols enabledProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool askForClientCert)
internal MobileAuthenticatedStream get_Parent()
public MonoTlsSettings get_Settings()
public MonoTlsProvider get_Provider()
protected void Debug(string message, Object[] args)
public bool get_HasContext()
public bool get_IsAuthenticated()
public bool get_IsServer()
protected string get_TargetHost()
protected string get_ServerName()
protected bool get_AskForClientCertificate()
protected SslProtocols get_EnabledProtocols()
protected X509CertificateCollection get_ClientCertificates()
protected void GetProtocolVersions(TlsProtocolCode& min, TlsProtocolCode& max)
public void StartHandshake()
public bool ProcessHandshake()
public void FinishHandshake()
public MonoTlsConnectionInfo get_ConnectionInfo()
internal X509Certificate get_LocalServerCertificate()
internal bool get_IsRemoteCertificateAvailable()
internal X509Certificate get_LocalClientCertificate()
public X509Certificate get_RemoteCertificate()
public TlsProtocols get_NegotiatedProtocol()
public void Flush()
public ValueTuple`2<int, bool> Read(Byte[] buffer, int offset, int count)
public ValueTuple`2<int, bool> Write(Byte[] buffer, int offset, int count)
public void Shutdown()
protected bool ValidateCertificate(X509Certificate leaf, X509Chain chain)
protected bool ValidateCertificate(X509CertificateCollection certificates)
protected X509Certificate SelectClientCertificate(X509Certificate serverCertificate, String[] acceptableIssuers)
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
internal Mono.Net.Security.MonoTlsProviderFactory : object {
private object locker
private bool initialized
private MonoTlsProvider defaultProvider
private Dictionary`2<string, Tuple`2<Guid, string>> providerRegistration
private Dictionary`2<Guid, MonoTlsProvider> providerCache
private bool enableDebug
internal Guid AppleTlsId
internal Guid BtlsId
internal Guid LegacyId
internal bool IsInitialized
internal MonoTlsProvider GetProviderInternal()
internal void InitializeInternal()
internal void InitializeInternal(string provider)
private Type LookupProviderType(string name, bool throwOnError)
private MonoTlsProvider LookupProvider(string name, bool throwOnError)
private void InitializeDebug()
internal void Debug(string message, Object[] args)
private void InitializeProviderRegistration()
private MonoTlsProvider CreateDefaultProviderImpl()
internal MonoTlsProvider GetProvider()
internal bool IsProviderSupported(string name)
internal MonoTlsProvider GetProvider(string name)
internal bool get_IsInitialized()
internal void Initialize()
internal void Initialize(string provider)
}
internal Mono.Net.Security.MonoTlsStream : object {
private MonoTlsProvider provider
private NetworkStream networkStream
private HttpWebRequest request
private MonoTlsSettings settings
private IMonoSslStream sslStream
private WebExceptionStatus status
private bool <CertificateValidationFailed>k__BackingField
internal HttpWebRequest Request
internal IMonoSslStream SslStream
internal WebExceptionStatus ExceptionStatus
internal bool CertificateValidationFailed
internal HttpWebRequest get_Request()
internal IMonoSslStream get_SslStream()
internal WebExceptionStatus get_ExceptionStatus()
internal bool get_CertificateValidationFailed()
internal void set_CertificateValidationFailed(bool value)
public void .ctor(HttpWebRequest request, NetworkStream networkStream)
internal Stream CreateStream(Byte[] buffer)
}
internal Mono.Net.Security.NoReflectionHelper : object {
internal bool IsInitialized
internal object GetInternalValidator(object provider, object settings)
internal object GetDefaultValidator(object settings)
internal object GetProvider()
internal bool get_IsInitialized()
internal void Initialize()
internal void Initialize(string provider)
internal HttpWebRequest CreateHttpsRequest(Uri requestUri, object provider, object settings)
internal object CreateHttpListener(object certificate, object provider, object settings)
internal object GetMonoSslStream(SslStream stream)
internal object GetMonoSslStream(HttpListenerContext context)
internal bool IsProviderSupported(string name)
internal object GetProvider(string name)
}
internal Mono.Net.Security.Private.CallbackHelpers : object {
internal MonoRemoteCertificateValidationCallback PublicToMono(RemoteCertificateValidationCallback callback)
internal MonoLocalCertificateSelectionCallback PublicToMono(LocalCertificateSelectionCallback callback)
internal MonoRemoteCertificateValidationCallback InternalToMono(RemoteCertValidationCallback callback)
internal RemoteCertificateValidationCallback InternalToPublic(string hostname, RemoteCertValidationCallback callback)
internal MonoLocalCertificateSelectionCallback InternalToMono(LocalCertSelectionCallback callback)
internal RemoteCertificateValidationCallback MonoToPublic(MonoRemoteCertificateValidationCallback callback)
internal LocalCertificateSelectionCallback MonoToPublic(MonoLocalCertificateSelectionCallback callback)
internal RemoteCertValidationCallback MonoToInternal(MonoRemoteCertificateValidationCallback callback)
internal LocalCertSelectionCallback MonoToInternal(MonoLocalCertificateSelectionCallback callback)
}
internal Mono.Net.Security.Private.LegacySslStream : AuthenticatedStream {
private SslStreamBase ssl_stream
private ICertificateValidator certificateValidator
private SslStream <SslStream>k__BackingField
private MonoTlsProvider <Provider>k__BackingField
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public long Length
public long Position
public bool IsAuthenticated
public bool IsEncrypted
public bool IsMutuallyAuthenticated
public bool IsServer
public bool IsSigned
public int ReadTimeout
public int WriteTimeout
public bool CheckCertRevocationStatus
public CipherAlgorithmType CipherAlgorithm
public int CipherStrength
public HashAlgorithmType HashAlgorithm
public int HashStrength
public ExchangeAlgorithmType KeyExchangeAlgorithm
public int KeyExchangeStrength
private X509Certificate Mono.Security.Interface.IMonoSslStream.InternalLocalCertificate
public X509Certificate LocalCertificate
public X509Certificate RemoteCertificate
public SslProtocols SslProtocol
private AuthenticatedStream Mono.Security.Interface.IMonoSslStream.AuthenticatedStream
private TransportContext Mono.Security.Interface.IMonoSslStream.TransportContext
public SslStream SslStream
public MonoTlsProvider Provider
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsProvider provider, MonoTlsSettings settings)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_IsAuthenticated()
public bool get_IsEncrypted()
public bool get_IsMutuallyAuthenticated()
public bool get_IsServer()
public bool get_IsSigned()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public bool get_CheckCertRevocationStatus()
public CipherAlgorithmType get_CipherAlgorithm()
public int get_CipherStrength()
public HashAlgorithmType get_HashAlgorithm()
public int get_HashStrength()
public ExchangeAlgorithmType get_KeyExchangeAlgorithm()
public int get_KeyExchangeStrength()
private X509Certificate Mono.Security.Interface.IMonoSslStream.get_InternalLocalCertificate()
public X509Certificate get_LocalCertificate()
public X509Certificate get_RemoteCertificate()
public SslProtocols get_SslProtocol()
private X509Certificate OnCertificateSelection(X509CertificateCollection clientCerts, X509Certificate serverCert, string targetHost, X509CertificateCollection serverRequestedCerts)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
private SecurityProtocolType GetMonoSslProtocol(SslProtocols ms)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void AuthenticateAsClient(string targetHost)
public void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public void AuthenticateAsServer(X509Certificate serverCertificate)
public void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
protected void Dispose(bool disposing)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public void EndAuthenticateAsServer(IAsyncResult asyncResult)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer)
private void CheckConnectionAuthenticated()
public Task AuthenticateAsClientAsync(string targetHost)
public Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
private Task Mono.Security.Interface.IMonoSslStream.ShutdownAsync()
private AuthenticatedStream Mono.Security.Interface.IMonoSslStream.get_AuthenticatedStream()
private TransportContext Mono.Security.Interface.IMonoSslStream.get_TransportContext()
public SslStream get_SslStream()
public MonoTlsProvider get_Provider()
public MonoTlsConnectionInfo GetConnectionInfo()
}
internal Mono.Net.Security.ServerCertValidationCallbackWrapper : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(ServerCertValidationCallback callback, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors)
public IAsyncResult BeginInvoke(ServerCertValidationCallback callback, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors, AsyncCallback __callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal Mono.Net.Security.SystemCertificateValidator : object {
private bool is_macosx
private X509RevocationMode revocation_mode
private X509KeyUsageFlags s_flags
public X509Chain CreateX509Chain(X509CertificateCollection certs)
private bool BuildX509Chain(X509CertificateCollection certs, X509Chain chain, SslPolicyErrors& errors, Int32& status11)
private bool CheckUsage(X509CertificateCollection certs, string host, SslPolicyErrors& errors, Int32& status11)
private bool EvaluateSystem(X509CertificateCollection certs, X509CertificateCollection anchors, string host, X509Chain chain, SslPolicyErrors& errors, Int32& status11)
public bool Evaluate(MonoTlsSettings settings, string host, X509CertificateCollection certs, X509Chain chain, SslPolicyErrors& errors, Int32& status11)
internal bool NeedsChain(MonoTlsSettings settings)
private int GetStatusFromChain(X509Chain chain)
private SslPolicyErrors GetErrorsFromChain(X509Chain chain)
private bool CheckCertificateUsage(X509Certificate2 cert)
private bool CheckServerIdentity(X509Certificate2 cert, string targetHost)
private bool CheckDomainName(string subjectName, string targetHost)
private bool Match(string hostname, string pattern)
}
internal Mono.Util.MonoPInvokeCallbackAttribute : Attribute {
public void .ctor(Type t)
}
internal ObjCRuntimeInternal.INativeObject {
public IntPtr Handle
public IntPtr get_Handle()
}
internal ObjCRuntimeInternal.NativeObjectHelper : object {
public IntPtr GetHandle(INativeObject self)
}
internal SR : object {
public string RTL
public string ContinueButtonText
public string DebugMessageTruncated
public string DebugAssertTitleShort
public string DebugAssertTitle
public string NotSupported
public string DebugLaunchFailed
public string DebugLaunchFailedTitle
public string ObjectDisposed
public string ExceptionOccurred
public string MustAddListener
public string ToStringNull
public string EnumConverterInvalidValue
public string ConvertFromException
public string ConvertToException
public string ConvertInvalidPrimitive
public string ErrorMissingPropertyAccessors
public string ErrorInvalidPropertyType
public string ErrorMissingEventAccessors
public string ErrorInvalidEventHandler
public string ErrorInvalidEventType
public string InvalidMemberName
public string ErrorBadExtenderType
public string NullableConverterBadCtorArg
public string TypeDescriptorExpectedElementType
public string TypeDescriptorSameAssociation
public string TypeDescriptorAlreadyAssociated
public string TypeDescriptorProviderError
public string TypeDescriptorUnsupportedRemoteObject
public string TypeDescriptorArgsCountMismatch
public string ErrorCreateSystemEvents
public string ErrorCreateTimer
public string ErrorKillTimer
public string ErrorSystemEventsNotSupported
public string ErrorGetTempPath
public string CHECKOUTCanceled
public string ErrorInvalidServiceInstance
public string ErrorServiceExists
public string Argument_InvalidNumberStyles
public string Argument_InvalidHexStyle
public string Argument_ByteArrayLengthMustBeAMultipleOf4
public string Argument_InvalidCharactersInString
public string Argument_ParsedStringWasInvalid
public string Argument_MustBeBigInt
public string Format_InvalidFormatSpecifier
public string Format_TooLarge
public string ArgumentOutOfRange_MustBeLessThanUInt32MaxValue
public string ArgumentOutOfRange_MustBeNonNeg
public string NotSupported_NumberStyle
public string Overflow_BigIntInfinity
public string Overflow_NotANumber
public string Overflow_ParseBigInteger
public string Overflow_Int32
public string Overflow_Int64
public string Overflow_UInt32
public string Overflow_UInt64
public string Overflow_Decimal
public string Argument_FrameworkNameTooShort
public string Argument_FrameworkNameInvalid
public string Argument_FrameworkNameInvalidVersion
public string Argument_FrameworkNameMissingVersion
public string ArgumentNull_Key
public string Argument_InvalidValue
public string Arg_MultiRank
public string Barrier_ctor_ArgumentOutOfRange
public string Barrier_AddParticipants_NonPositive_ArgumentOutOfRange
public string Barrier_AddParticipants_Overflow_ArgumentOutOfRange
public string Barrier_InvalidOperation_CalledFromPHA
public string Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange
public string Barrier_RemoveParticipants_ArgumentOutOfRange
public string Barrier_RemoveParticipants_InvalidOperation
public string Barrier_SignalAndWait_ArgumentOutOfRange
public string Barrier_SignalAndWait_InvalidOperation_ZeroTotal
public string Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded
public string Barrier_Dispose
public string BarrierPostPhaseException
public string UriTypeConverter_ConvertFrom_CannotConvert
public string UriTypeConverter_ConvertTo_CannotConvert
public string ISupportInitializeDescr
public string CantModifyListSortDescriptionCollection
public string Argument_NullComment
public string InvalidPrimitiveType
public string Cannot_Specify_Both_Compiler_Path_And_Version
public string CodeGenOutputWriter
public string CodeGenReentrance
public string InvalidLanguageIdentifier
public string InvalidTypeName
public string Empty_attribute
public string Invalid_nonnegative_integer_attribute
public string CodeDomProvider_NotDefined
public string Language_Names_Cannot_Be_Empty
public string Extension_Names_Cannot_Be_Empty_Or_Non_Period_Based
public string Unable_To_Locate_Type
public string NotSupported_CodeDomAPI
public string ArityDoesntMatch
public string PartialTrustErrorTextReplacement
public string PartialTrustIllegalProvider
public string IllegalAssemblyReference
public string NullOrEmpty_Value_in_Property
public string AutoGen_Comment_Line1
public string AutoGen_Comment_Line2
public string AutoGen_Comment_Line3
public string AutoGen_Comment_Line4
public string AutoGen_Comment_Line5
public string CantContainNullEntries
public string InvalidPathCharsInChecksum
public string InvalidRegion
public string Provider_does_not_support_options
public string MetaExtenderName
public string InvalidEnumArgument
public string InvalidArgument
public string InvalidNullArgument
public string LicExceptionTypeOnly
public string LicExceptionTypeAndInstance
public string LicMgrContextCannotBeChanged
public string LicMgrAlreadyLocked
public string LicMgrDifferentUser
public string InvalidElementType
public string InvalidIdentifier
public string ExecFailedToCreate
public string ExecTimeout
public string ExecBadreturn
public string ExecCantGetRetCode
public string ExecCantExec
public string ExecCantRevert
public string CompilerNotFound
public string DuplicateFileName
public string CollectionReadOnly
public string BitVectorFull
public string ArrayConverterText
public string CollectionConverterText
public string MultilineStringConverterText
public string CultureInfoConverterDefaultCultureString
public string CultureInfoConverterInvalidCulture
public string InvalidPrimitive
public string TimerInvalidInterval
public string TraceSwitchLevelTooHigh
public string TraceSwitchLevelTooLow
public string TraceSwitchInvalidLevel
public string TraceListenerIndentSize
public string TraceListenerFail
public string TraceAsTraceSource
public string InvalidLowBoundArgument
public string DuplicateComponentName
public string NotImplemented
public string OutOfMemory
public string EOF
public string IOError
public string BadChar
public string toStringNone
public string toStringUnknown
public string InvalidEnum
public string IndexOutOfRange
public string ErrorPropertyAccessorException
public string InvalidOperation
public string EmptyStack
public string PerformanceCounterDesc
public string PCCategoryName
public string PCCounterName
public string PCInstanceName
public string PCMachineName
public string PCInstanceLifetime
public string PropertyCategoryAction
public string PropertyCategoryAppearance
public string PropertyCategoryAsynchronous
public string PropertyCategoryBehavior
public string PropertyCategoryData
public string PropertyCategoryDDE
public string PropertyCategoryDesign
public string PropertyCategoryDragDrop
public string PropertyCategoryFocus
public string PropertyCategoryFont
public string PropertyCategoryFormat
public string PropertyCategoryKey
public string PropertyCategoryList
public string PropertyCategoryLayout
public string PropertyCategoryDefault
public string PropertyCategoryMouse
public string PropertyCategoryPosition
public string PropertyCategoryText
public string PropertyCategoryScale
public string PropertyCategoryWindowStyle
public string PropertyCategoryConfig
public string ArgumentNull_ArrayWithNullElements
public string OnlyAllowedOnce
public string BeginIndexNotNegative
public string LengthNotNegative
public string UnimplementedState
public string UnexpectedOpcode
public string NoResultOnFailed
public string UnterminatedBracket
public string TooManyParens
public string NestedQuantify
public string QuantifyAfterNothing
public string InternalError
public string IllegalRange
public string NotEnoughParens
public string BadClassInCharRange
public string ReversedCharRange
public string UndefinedReference
public string MalformedReference
public string UnrecognizedGrouping
public string UnterminatedComment
public string IllegalEndEscape
public string MalformedNameRef
public string UndefinedBackref
public string UndefinedNameRef
public string TooFewHex
public string MissingControl
public string UnrecognizedControl
public string UnrecognizedEscape
public string IllegalCondition
public string TooManyAlternates
public string MakeException
public string IncompleteSlashP
public string MalformedSlashP
public string InvalidGroupName
public string CapnumNotZero
public string AlternationCantCapture
public string AlternationCantHaveComment
public string CaptureGroupOutOfRange
public string SubtractionMustBeLast
public string UnknownProperty
public string ReplacementError
public string CountTooSmall
public string EnumNotStarted
public string Arg_InvalidArrayType
public string RegexMatchTimeoutException_Occurred
public string IllegalDefaultRegexMatchTimeoutInAppDomain
public string FileObject_AlreadyOpen
public string FileObject_Closed
public string FileObject_NotWhileWriting
public string FileObject_FileDoesNotExist
public string FileObject_MustBeClosed
public string FileObject_MustBeFileName
public string FileObject_InvalidInternalState
public string FileObject_PathNotSet
public string FileObject_Reading
public string FileObject_Writing
public string FileObject_InvalidEnumeration
public string FileObject_NoReset
public string DirectoryObject_MustBeDirName
public string DirectoryObjectPathDescr
public string FileObjectDetectEncodingDescr
public string FileObjectEncodingDescr
public string FileObjectPathDescr
public string Arg_EnumIllegalVal
public string Arg_OutOfRange_NeedNonNegNum
public string Argument_InvalidPermissionState
public string Argument_InvalidOidValue
public string Argument_WrongType
public string Arg_EmptyOrNullString
public string Arg_EmptyOrNullArray
public string Argument_InvalidClassAttribute
public string Argument_InvalidNameType
public string InvalidOperation_DuplicateItemNotAllowed
public string Cryptography_Asn_MismatchedOidInCollection
public string Cryptography_Cms_Envelope_Empty_Content
public string Cryptography_Cms_Invalid_Recipient_Info_Type
public string Cryptography_Cms_Invalid_Subject_Identifier_Type
public string Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch
public string Cryptography_Cms_Key_Agree_Date_Not_Available
public string Cryptography_Cms_Key_Agree_Other_Key_Attribute_Not_Available
public string Cryptography_Cms_MessageNotSigned
public string Cryptography_Cms_MessageNotSignedByNoSignature
public string Cryptography_Cms_MessageNotEncrypted
public string Cryptography_Cms_Not_Supported
public string Cryptography_Cms_RecipientCertificateNotFound
public string Cryptography_Cms_Sign_Empty_Content
public string Cryptography_Cms_Sign_No_Signature_First_Signer
public string Cryptography_DpApi_InvalidMemoryLength
public string Cryptography_InvalidHandle
public string Cryptography_InvalidContextHandle
public string Cryptography_InvalidStoreHandle
public string Cryptography_Oid_InvalidValue
public string Cryptography_Pkcs9_ExplicitAddNotAllowed
public string Cryptography_Pkcs9_InvalidOid
public string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed
public string Cryptography_Pkcs9_AttributeMismatch
public string Cryptography_X509_AddFailed
public string Cryptography_X509_BadEncoding
public string Cryptography_X509_ExportFailed
public string Cryptography_X509_ExtensionMismatch
public string Cryptography_X509_InvalidFindType
public string Cryptography_X509_InvalidFindValue
public string Cryptography_X509_InvalidEncodingFormat
public string Cryptography_X509_InvalidContentType
public string Cryptography_X509_KeyMismatch
public string Cryptography_X509_RemoveFailed
public string Cryptography_X509_StoreNotOpen
public string Environment_NotInteractive
public string NotSupported_InvalidKeyImpl
public string NotSupported_KeyAlgorithm
public string NotSupported_PlatformRequiresNT
public string NotSupported_UnreadableStream
public string Security_InvalidValue
public string Unknown_Error
public string security_ServiceNameCollection_EmptyServiceName
public string security_ExtendedProtectionPolicy_UseDifferentConstructorForNever
public string security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection
public string security_ExtendedProtection_NoOSSupport
public string net_nonClsCompliantException
public string net_illegalConfigWith
public string net_illegalConfigWithout
public string net_baddate
public string net_writestarted
public string net_reqsubmitted
public string net_ftp_no_http_cmd
public string net_ftp_invalid_method_name
public string net_ftp_invalid_renameto
public string net_ftp_no_defaultcreds
public string net_ftpnoresponse
public string net_ftp_response_invalid_format
public string net_ftp_no_offsetforhttp
public string net_ftp_invalid_uri
public string net_ftp_invalid_status_response
public string net_ftp_server_failed_passive
public string net_ftp_active_address_different
public string net_ftp_proxy_does_not_support_ssl
public string net_ftp_invalid_response_filename
public string net_ftp_unsupported_method
public string net_resubmitcanceled
public string net_redirect_perm
public string net_resubmitprotofailed
public string net_needchunked
public string net_connarg
public string net_no100
public string net_fromto
public string net_rangetoosmall
public string net_invalidversion
public string net_toosmall
public string net_toolong
public string net_connclosed
public string net_servererror
public string net_nouploadonget
public string net_mutualauthfailed
public string net_invasync
public string net_inasync
public string net_mustbeuri
public string net_format_shexp
public string net_cannot_load_proxy_helper
public string net_invalid_host
public string net_repcall
public string net_badmethod
public string net_io_timeout_use_ge_zero
public string net_io_timeout_use_gt_zero
public string net_io_no_0timeouts
public string net_requestaborted
public string net_tooManyRedirections
public string net_authmodulenotregistered
public string net_authschemenotregistered
public string net_proxyschemenotsupported
public string net_maxsrvpoints
public string net_unknown_prefix
public string net_notconnected
public string net_notstream
public string net_timeout
public string net_nocontentlengthonget
public string net_contentlengthmissing
public string net_nonhttpproxynotallowed
public string net_nottoken
public string net_rangetype
public string net_need_writebuffering
public string net_securityprotocolnotsupported
public string net_nodefaultcreds
public string net_stopped
public string net_udpconnected
public string net_no_concurrent_io_allowed
public string net_needmorethreads
public string net_MethodNotSupportedException
public string net_PropertyNotSupportedException
public string net_ProtocolNotSupportedException
public string net_SelectModeNotSupportedException
public string net_InvalidSocketHandle
public string net_InvalidAddressFamily
public string net_InvalidEndPointAddressFamily
public string net_InvalidSocketAddressSize
public string net_invalidAddressList
public string net_invalidPingBufferSize
public string net_cant_perform_during_shutdown
public string net_cant_create_environment
public string net_completed_result
public string net_protocol_invalid_family
public string net_protocol_invalid_multicast_family
public string net_empty_osinstalltype
public string net_unknown_osinstalltype
public string net_cant_determine_osinstalltype
public string net_osinstalltype
public string net_entire_body_not_written
public string net_must_provide_request_body
public string net_sockets_zerolist
public string net_sockets_blocking
public string net_sockets_useblocking
public string net_sockets_select
public string net_sockets_toolarge_select
public string net_sockets_empty_select
public string net_sockets_mustbind
public string net_sockets_mustlisten
public string net_sockets_mustnotlisten
public string net_sockets_mustnotbebound
public string net_sockets_namedmustnotbebound
public string net_sockets_invalid_socketinformation
public string net_sockets_invalid_ipaddress_length
public string net_sockets_invalid_optionValue
public string net_sockets_invalid_optionValue_all
public string net_sockets_invalid_dnsendpoint
public string net_sockets_disconnectedConnect
public string net_sockets_disconnectedAccept
public string net_tcplistener_mustbestopped
public string net_sockets_no_duplicate_async
public string net_socketopinprogress
public string net_buffercounttoosmall
public string net_multibuffernotsupported
public string net_ambiguousbuffers
public string net_sockets_ipv6only
public string net_perfcounter_initialized_success
public string net_perfcounter_initialized_error
public string net_perfcounter_nocategory
public string net_perfcounter_initialization_started
public string net_perfcounter_cant_queue_workitem
public string net_config_proxy
public string net_config_proxy_module_not_public
public string net_config_authenticationmodules
public string net_config_webrequestmodules
public string net_config_requestcaching
public string net_config_section_permission
public string net_config_element_permission
public string net_config_property_permission
public string net_WebResponseParseError_InvalidHeaderName
public string net_WebResponseParseError_InvalidContentLength
public string net_WebResponseParseError_IncompleteHeaderLine
public string net_WebResponseParseError_CrLfError
public string net_WebResponseParseError_InvalidChunkFormat
public string net_WebResponseParseError_UnexpectedServerResponse
public string net_webstatus_Success
public string net_webstatus_NameResolutionFailure
public string net_webstatus_ConnectFailure
public string net_webstatus_ReceiveFailure
public string net_webstatus_SendFailure
public string net_webstatus_PipelineFailure
public string net_webstatus_RequestCanceled
public string net_webstatus_ConnectionClosed
public string net_webstatus_TrustFailure
public string net_webstatus_SecureChannelFailure
public string net_webstatus_ServerProtocolViolation
public string net_webstatus_KeepAliveFailure
public string net_webstatus_ProxyNameResolutionFailure
public string net_webstatus_MessageLengthLimitExceeded
public string net_webstatus_CacheEntryNotFound
public string net_webstatus_RequestProhibitedByCachePolicy
public string net_webstatus_Timeout
public string net_webstatus_RequestProhibitedByProxy
public string net_InvalidStatusCode
public string net_ftpstatuscode_ServiceNotAvailable
public string net_ftpstatuscode_CantOpenData
public string net_ftpstatuscode_ConnectionClosed
public string net_ftpstatuscode_ActionNotTakenFileUnavailableOrBusy
public string net_ftpstatuscode_ActionAbortedLocalProcessingError
public string net_ftpstatuscode_ActionNotTakenInsufficentSpace
public string net_ftpstatuscode_CommandSyntaxError
public string net_ftpstatuscode_ArgumentSyntaxError
public string net_ftpstatuscode_CommandNotImplemented
public string net_ftpstatuscode_BadCommandSequence
public string net_ftpstatuscode_NotLoggedIn
public string net_ftpstatuscode_AccountNeeded
public string net_ftpstatuscode_ActionNotTakenFileUnavailable
public string net_ftpstatuscode_ActionAbortedUnknownPageType
public string net_ftpstatuscode_FileActionAborted
public string net_ftpstatuscode_ActionNotTakenFilenameNotAllowed
public string net_httpstatuscode_NoContent
public string net_httpstatuscode_NonAuthoritativeInformation
public string net_httpstatuscode_ResetContent
public string net_httpstatuscode_PartialContent
public string net_httpstatuscode_MultipleChoices
public string net_httpstatuscode_Ambiguous
public string net_httpstatuscode_MovedPermanently
public string net_httpstatuscode_Moved
public string net_httpstatuscode_Found
public string net_httpstatuscode_Redirect
public string net_httpstatuscode_SeeOther
public string net_httpstatuscode_RedirectMethod
public string net_httpstatuscode_NotModified
public string net_httpstatuscode_UseProxy
public string net_httpstatuscode_TemporaryRedirect
public string net_httpstatuscode_RedirectKeepVerb
public string net_httpstatuscode_BadRequest
public string net_httpstatuscode_Unauthorized
public string net_httpstatuscode_PaymentRequired
public string net_httpstatuscode_Forbidden
public string net_httpstatuscode_NotFound
public string net_httpstatuscode_MethodNotAllowed
public string net_httpstatuscode_NotAcceptable
public string net_httpstatuscode_ProxyAuthenticationRequired
public string net_httpstatuscode_RequestTimeout
public string net_httpstatuscode_Conflict
public string net_httpstatuscode_Gone
public string net_httpstatuscode_LengthRequired
public string net_httpstatuscode_InternalServerError
public string net_httpstatuscode_NotImplemented
public string net_httpstatuscode_BadGateway
public string net_httpstatuscode_ServiceUnavailable
public string net_httpstatuscode_GatewayTimeout
public string net_httpstatuscode_HttpVersionNotSupported
public string net_emptystringset
public string net_emptystringcall
public string net_headers_req
public string net_headers_rsp
public string net_headers_toolong
public string net_WebHeaderInvalidCRLFChars
public string net_WebHeaderInvalidHeaderChars
public string net_WebHeaderInvalidNonAsciiChars
public string net_WebHeaderMissingColon
public string net_headerrestrict
public string net_io_completionportwasbound
public string net_io_writefailure
public string net_io_readfailure
public string net_io_connectionclosed
public string net_io_transportfailure
public string net_io_internal_bind
public string net_io_invalidnestedcall
public string net_io_must_be_rw_stream
public string net_io_header_id
public string net_io_out_range
public string net_io_encrypt
public string net_io_decrypt
public string net_io_read
public string net_io_write
public string net_io_eof
public string net_io_async_result
public string net_tls_version
public string net_perm_target
public string net_perm_both_regex
public string net_perm_none
public string net_perm_attrib_count
public string net_perm_invalid_val
public string net_perm_attrib_multi
public string net_perm_epname
public string net_perm_invalid_val_in_element
public string net_invalid_ip_addr
public string dns_bad_ip_address
public string net_bad_mac_address
public string net_ping
public string net_bad_ip_address_prefix
public string net_max_ip_address_list_length_exceeded
public string net_ipv4_not_installed
public string net_ipv6_not_installed
public string net_webclient
public string net_webclient_ContentType
public string net_webclient_Multipart
public string net_webclient_no_concurrent_io_allowed
public string net_webclient_invalid_baseaddress
public string net_container_add_cookie
public string net_cookie_invalid
public string net_cookie_size
public string net_cookie_parse_header
public string net_cookie_attribute
public string net_cookie_format
public string net_cookie_capacity_range
public string net_set_token
public string net_revert_token
public string net_ssl_io_async_context
public string net_ssl_io_encrypt
public string net_ssl_io_decrypt
public string net_ssl_io_context_expired
public string net_ssl_io_handshake_start
public string net_ssl_io_handshake
public string net_ssl_io_frame
public string net_ssl_io_corrupted
public string net_ssl_io_cert_validation
public string net_ssl_io_invalid_end_call
public string net_ssl_io_invalid_begin_call
public string net_ssl_io_no_server_cert
public string net_auth_bad_client_creds
public string net_auth_bad_client_creds_or_target_mismatch
public string net_auth_context_expectation
public string net_auth_context_expectation_remote
public string net_auth_supported_impl_levels
public string net_auth_no_anonymous_support
public string net_auth_reauth
public string net_auth_noauth
public string net_auth_client_server
public string net_auth_noencryption
public string net_auth_SSPI
public string net_auth_failure
public string net_auth_eof
public string net_auth_alert
public string net_auth_ignored_reauth
public string net_auth_empty_read
public string net_auth_must_specify_extended_protection_scheme
public string net_frame_size
public string net_frame_read_io
public string net_frame_read_size
public string net_frame_max_size
public string net_jscript_load
public string net_proxy_not_gmt
public string net_proxy_invalid_dayofweek
public string net_proxy_invalid_url_format
public string net_param_not_string
public string net_value_cannot_be_negative
public string net_invalid_offset
public string net_offset_plus_count
public string net_cannot_be_false
public string net_cache_shadowstream_not_writable
public string net_cache_validator_fail
public string net_cache_access_denied
public string net_cache_validator_result
public string net_cache_retrieve_failure
public string net_cache_not_supported_body
public string net_cache_not_supported_command
public string net_cache_not_accept_response
public string net_cache_method_failed
public string net_cache_key_failed
public string net_cache_no_stream
public string net_cache_unsupported_partial_stream
public string net_cache_not_configured
public string net_cache_non_seekable_stream_not_supported
public string net_invalid_cast
public string net_collection_readonly
public string net_not_ipermission
public string net_no_classname
public string net_no_typename
public string net_servicePointAddressNotSupportedInHostMode
public string net_Websockets_WebSocketBaseFaulted
public string net_WebSockets_Generic
public string net_WebSockets_NotAWebSocket_Generic
public string net_WebSockets_UnsupportedWebSocketVersion_Generic
public string net_WebSockets_HeaderError_Generic
public string net_WebSockets_UnsupportedProtocol_Generic
public string net_WebSockets_ClientSecWebSocketProtocolsBlank
public string net_WebSockets_InvalidState_Generic
public string net_WebSockets_InvalidMessageType_Generic
public string net_WebSockets_ConnectionClosedPrematurely_Generic
public string net_WebSockets_Scheme
public string net_WebSockets_AlreadyStarted
public string net_WebSockets_Connect101Expected
public string net_WebSockets_InvalidResponseHeader
public string net_WebSockets_NotConnected
public string net_WebSockets_InvalidRegistration
public string net_WebSockets_NoDuplicateProtocol
public string net_log_exception
public string net_log_sspi_enumerating_security_packages
public string net_log_sspi_security_package_not_found
public string net_log_sspi_security_context_input_buffer
public string net_log_sspi_security_context_input_buffers
public string net_log_sspi_selected_cipher_suite
public string net_log_remote_certificate
public string net_log_locating_private_key_for_certificate
public string net_log_cert_is_of_type_2
public string net_log_found_cert_in_store
public string net_log_did_not_find_cert_in_store
public string net_log_open_store_failed
public string net_log_got_certificate_from_delegate
public string net_log_no_delegate_and_have_no_client_cert
public string net_log_no_delegate_but_have_client_cert
public string net_log_attempting_restart_using_cert
public string net_log_no_issuers_try_all_certs
public string net_log_server_issuers_look_for_matching_certs
public string net_log_selected_cert
public string net_log_n_certs_after_filtering
public string net_log_finding_matching_certs
public string net_log_using_cached_credential
public string net_log_remote_cert_user_declared_valid
public string net_log_remote_cert_user_declared_invalid
public string net_log_remote_cert_has_no_errors
public string net_log_remote_cert_has_errors
public string net_log_remote_cert_not_available
public string net_log_remote_cert_name_mismatch
public string net_log_proxy_autodetect_script_location_parse_error
public string net_log_proxy_autodetect_failed
public string net_log_proxy_script_execution_error
public string net_log_proxy_script_download_compile_error
public string net_log_proxy_system_setting_update
public string net_log_proxy_update_due_to_ip_config_change
public string net_log_proxy_called_with_null_parameter
public string net_log_proxy_called_with_invalid_parameter
public string net_log_proxy_ras_supported
public string net_log_proxy_ras_notsupported_exception
public string net_log_proxy_winhttp_cant_open_session
public string net_log_proxy_winhttp_getproxy_failed
public string net_log_proxy_winhttp_timeout_error
public string net_log_cache_validation_failed_resubmit
public string net_log_cache_refused_server_response
public string net_log_cache_ftp_proxy_doesnt_support_partial
public string net_log_cache_ftp_method
public string net_log_cache_ftp_supports_bin_only
public string net_log_cache_replacing_entry_with_HTTP_200
public string net_log_cache_now_time
public string net_log_cache_max_age_absolute
public string net_log_cache_age1
public string net_log_cache_age1_date_header
public string net_log_cache_age1_last_synchronized
public string net_log_cache_age1_last_synchronized_age_header
public string net_log_cache_age2
public string net_log_cache_max_age_cache_s_max_age
public string net_log_cache_max_age_expires_date
public string net_log_cache_max_age_cache_max_age
public string net_log_cache_no_max_age_use_10_percent
public string net_log_cache_no_max_age_use_default
public string net_log_cache_validator_invalid_for_policy
public string net_log_cache_response_last_modified
public string net_log_cache_cache_last_modified
public string net_log_cache_partial_and_non_zero_content_offset
public string net_log_cache_response_valid_based_on_policy
public string net_log_cache_null_response_failure
public string net_log_cache_ftp_response_status
public string net_log_cache_resp_valid_based_on_retry
public string net_log_cache_no_update_based_on_method
public string net_log_cache_removed_existing_invalid_entry
public string net_log_cache_not_updated_based_on_policy
public string net_log_cache_not_updated_because_no_response
public string net_log_cache_removed_existing_based_on_method
public string net_log_cache_existing_not_removed_because_unexpected_response_status
public string net_log_cache_removed_existing_based_on_policy
public string net_log_cache_not_updated_based_on_ftp_response_status
public string net_log_cache_update_not_supported_for_ftp_restart
public string net_log_cache_removed_entry_because_ftp_restart_response_changed
public string net_log_cache_last_synchronized
public string net_log_cache_suppress_update_because_synched_last_minute
public string net_log_cache_updating_last_synchronized
public string net_log_cache_cannot_remove
public string net_log_cache_key_status
public string net_log_cache_key_remove_failed_status
public string net_log_cache_usecount_file
public string net_log_cache_stream
public string net_log_cache_filename
public string net_log_cache_lookup_failed
public string net_log_cache_exception
public string net_log_cache_expected_length
public string net_log_cache_last_modified
public string net_log_cache_expires
public string net_log_cache_max_stale
public string net_log_cache_dumping_metadata
public string net_log_cache_create_failed
public string net_log_cache_set_expires
public string net_log_cache_set_last_modified
public string net_log_cache_set_last_synchronized
public string net_log_cache_enable_max_stale
public string net_log_cache_disable_max_stale
public string net_log_cache_set_new_metadata
public string net_log_cache_dumping
public string net_log_cache_key
public string net_log_cache_no_commit
public string net_log_cache_error_deleting_filename
public string net_log_cache_update_failed
public string net_log_cache_delete_failed
public string net_log_cache_commit_failed
public string net_log_cache_committed_as_partial
public string net_log_cache_max_stale_and_update_status
public string net_log_cache_failing_request_with_exception
public string net_log_cache_request_method
public string net_log_cache_http_status_parse_failure
public string net_log_cache_http_status_line
public string net_log_cache_cache_control
public string net_log_cache_invalid_http_version
public string net_log_cache_no_http_response_header
public string net_log_cache_http_header_parse_error
public string net_log_cache_metadata_name_value_parse_error
public string net_log_cache_content_range_error
public string net_log_cache_cache_control_error
public string net_log_cache_unexpected_status
public string net_log_cache_object_and_exception
public string net_log_cache_revalidation_not_needed
public string net_log_cache_not_updated_based_on_cache_protocol_status
public string net_log_cache_closing_cache_stream
public string net_log_cache_exception_ignored
public string net_log_cache_no_cache_entry
public string net_log_cache_null_cached_stream
public string net_log_cache_requested_combined_but_null_cached_stream
public string net_log_cache_returned_range_cache
public string net_log_cache_entry_not_found_freshness_undefined
public string net_log_cache_dumping_cache_context
public string net_log_cache_result
public string net_log_cache_uri_with_query_has_no_expiration
public string net_log_cache_uri_with_query_and_cached_resp_from_http_10
public string net_log_cache_valid_as_fresh_or_because_policy
public string net_log_cache_accept_based_on_retry_count
public string net_log_cache_date_header_older_than_cache_entry
public string net_log_cache_server_didnt_satisfy_range
public string net_log_cache_304_received_on_unconditional_request
public string net_log_cache_304_received_on_unconditional_request_expected_200_206
public string net_log_cache_last_modified_header_older_than_cache_entry
public string net_log_cache_freshness_outside_policy_limits
public string net_log_cache_need_to_remove_invalid_cache_entry_304
public string net_log_cache_resp_status
public string net_log_cache_resp_304_or_request_head
public string net_log_cache_dont_update_cached_headers
public string net_log_cache_update_cached_headers
public string net_log_cache_partial_resp_not_combined_with_existing_entry
public string net_log_cache_request_contains_conditional_header
public string net_log_cache_not_a_get_head_post
public string net_log_cache_cannot_update_cache_if_304
public string net_log_cache_cannot_update_cache_with_head_resp
public string net_log_cache_http_resp_is_null
public string net_log_cache_resp_cache_control_is_no_store
public string net_log_cache_resp_cache_control_is_public
public string net_log_cache_resp_cache_control_is_private
public string net_log_cache_resp_cache_control_is_private_plus_headers
public string net_log_cache_resp_older_than_cache
public string net_log_cache_revalidation_required
public string net_log_cache_needs_revalidation
public string net_log_cache_resp_allows_caching
public string net_log_cache_auth_header_and_no_s_max_age
public string net_log_cache_post_resp_without_cache_control_or_expires
public string net_log_cache_valid_based_on_status_code
public string net_log_cache_resp_no_cache_control
public string net_log_cache_age
public string net_log_cache_policy_min_fresh
public string net_log_cache_policy_max_age
public string net_log_cache_policy_cache_sync_date
public string net_log_cache_policy_max_stale
public string net_log_cache_control_no_cache
public string net_log_cache_control_no_cache_removing_some_headers
public string net_log_cache_control_must_revalidate
public string net_log_cache_cached_auth_header
public string net_log_cache_cached_auth_header_no_control_directive
public string net_log_cache_after_validation
public string net_log_cache_resp_status_304
public string net_log_cache_head_resp_has_different_content_length
public string net_log_cache_head_resp_has_different_content_md5
public string net_log_cache_head_resp_has_different_etag
public string net_log_cache_304_head_resp_has_different_last_modified
public string net_log_cache_existing_entry_has_to_be_discarded
public string net_log_cache_existing_entry_should_be_discarded
public string net_log_cache_206_resp_non_matching_entry
public string net_log_cache_206_resp_starting_position_not_adjusted
public string net_log_cache_combined_resp_requested
public string net_log_cache_updating_headers_on_304
public string net_log_cache_suppressing_headers_update_on_304
public string net_log_cache_status_code_not_304_206
public string net_log_cache_sxx_resp_cache_only
public string net_log_cache_sxx_resp_can_be_replaced
public string net_log_cache_vary_header_empty
public string net_log_cache_vary_header_contains_asterisks
public string net_log_cache_no_headers_in_metadata
public string net_log_cache_vary_header_mismatched_count
public string net_log_cache_vary_header_mismatched_field
public string net_log_cache_vary_header_match
public string net_log_cache_range
public string net_log_cache_range_invalid_format
public string net_log_cache_range_not_in_cache
public string net_log_cache_range_in_cache
public string net_log_cache_partial_resp
public string net_log_cache_range_request_range
public string net_log_cache_could_be_partial
public string net_log_cache_condition_if_none_match
public string net_log_cache_condition_if_modified_since
public string net_log_cache_cannot_construct_conditional_request
public string net_log_cache_cannot_construct_conditional_range_request
public string net_log_cache_entry_size_too_big
public string net_log_cache_condition_if_range
public string net_log_cache_conditional_range_not_implemented_on_http_10
public string net_log_cache_saving_request_headers
public string net_log_cache_only_byte_range_implemented
public string net_log_cache_multiple_complex_range_not_implemented
public string net_log_digest_hash_algorithm_not_supported
public string net_log_digest_qop_not_supported
public string net_log_digest_requires_nonce
public string net_log_auth_invalid_challenge
public string net_log_unknown
public string net_log_operation_returned_something
public string net_log_buffered_n_bytes
public string net_log_method_equal
public string net_log_releasing_connection
public string net_log_unexpected_exception
public string net_log_server_response_error_code
public string net_log_resubmitting_request
public string net_log_retrieving_localhost_exception
public string net_log_resolved_servicepoint_may_not_be_remote_server
public string net_log_closed_idle
public string net_log_received_status_line
public string net_log_sending_headers
public string net_log_received_headers
public string net_log_shell_expression_pattern_format_warning
public string net_log_exception_in_callback
public string net_log_sending_command
public string net_log_received_response
public string net_log_socket_connected
public string net_log_socket_accepted
public string net_log_socket_not_logged_file
public string net_log_socket_connect_dnsendpoint
public string MailAddressInvalidFormat
public string MailSubjectInvalidFormat
public string MailBase64InvalidCharacter
public string MailCollectionIsReadOnly
public string MailDateInvalidFormat
public string MailHeaderFieldAlreadyExists
public string MailHeaderFieldInvalidCharacter
public string MailHeaderFieldMalformedHeader
public string MailHeaderFieldMismatchedName
public string MailHeaderIndexOutOfBounds
public string MailHeaderItemAccessorOnlySingleton
public string MailHeaderListHasChanged
public string MailHeaderResetCalledBeforeEOF
public string MailHeaderTargetArrayTooSmall
public string MailHeaderInvalidCID
public string MailHostNotFound
public string MailReaderGetContentStreamAlreadyCalled
public string MailReaderTruncated
public string MailWriterIsInContent
public string MailServerDoesNotSupportStartTls
public string MailServerResponse
public string SSPIAuthenticationOrSPNNull
public string SSPIPInvokeError
public string SmtpAlreadyConnected
public string SmtpAuthenticationFailed
public string SmtpAuthenticationFailedNoCreds
public string SmtpDataStreamOpen
public string SmtpDefaultMimePreamble
public string SmtpDefaultSubject
public string SmtpInvalidResponse
public string SmtpNotConnected
public string SmtpSystemStatus
public string SmtpHelpMessage
public string SmtpServiceReady
public string SmtpServiceClosingTransmissionChannel
public string SmtpOK
public string SmtpUserNotLocalWillForward
public string SmtpStartMailInput
public string SmtpServiceNotAvailable
public string SmtpMailboxBusy
public string SmtpLocalErrorInProcessing
public string SmtpInsufficientStorage
public string SmtpPermissionDenied
public string SmtpCommandUnrecognized
public string SmtpSyntaxError
public string SmtpCommandNotImplemented
public string SmtpBadCommandSequence
public string SmtpCommandParameterNotImplemented
public string SmtpMailboxUnavailable
public string SmtpUserNotLocalTryAlternatePath
public string SmtpExceededStorageAllocation
public string SmtpMailboxNameNotAllowed
public string SmtpTransactionFailed
public string SmtpSendMailFailure
public string SmtpRecipientFailed
public string SmtpRecipientRequired
public string SmtpFromRequired
public string SmtpAllRecipientsFailed
public string SmtpClientNotPermitted
public string SmtpMustIssueStartTlsFirst
public string SmtpNeedAbsolutePickupDirectory
public string SmtpGetIisPickupDirectoryFailed
public string SmtpPickupDirectoryDoesnotSupportSsl
public string SmtpOperationInProgress
public string SmtpAuthResponseInvalid
public string SmtpEhloResponseInvalid
public string SmtpNonAsciiUserNotSupported
public string SmtpInvalidHostName
public string MimeTransferEncodingNotSupported
public string SeekNotSupported
public string WriteNotSupported
public string InvalidHexDigit
public string InvalidSSPIContext
public string InvalidSSPIContextKey
public string InvalidSSPINegotiationElement
public string InvalidHeaderName
public string InvalidHeaderValue
public string CannotGetEffectiveTimeOfSSPIContext
public string CannotGetExpiryTimeOfSSPIContext
public string ReadNotSupported
public string InvalidAsyncResult
public string UnspecifiedHost
public string InvalidPort
public string SmtpInvalidOperationDuringSend
public string MimePartCantResetStream
public string MediaTypeInvalid
public string ContentTypeInvalid
public string ContentDispositionInvalid
public string AttributeNotSupported
public string Cannot_remove_with_null
public string Config_base_elements_only
public string Config_base_no_child_nodes
public string Config_base_required_attribute_empty
public string Config_base_required_attribute_missing
public string Config_base_time_overflow
public string Config_base_type_must_be_configurationvalidation
public string Config_base_type_must_be_typeconverter
public string Config_base_unknown_format
public string Config_base_unrecognized_attribute
public string Config_base_unrecognized_element
public string Config_invalid_boolean_attribute
public string Config_invalid_integer_attribute
public string Config_invalid_positive_integer_attribute
public string Config_invalid_type_attribute
public string Config_missing_required_attribute
public string Config_name_value_file_section_file_invalid_root
public string Config_provider_must_implement_type
public string Config_provider_name_null_or_empty
public string Config_provider_not_found
public string Config_property_name_cannot_be_empty
public string Config_section_cannot_clear_locked_section
public string Config_section_record_not_found
public string Config_source_cannot_contain_file
public string Config_system_already_set
public string Config_unable_to_read_security_policy
public string Config_write_xml_returned_null
public string Cannot_clear_sections_within_group
public string Cannot_exit_up_top_directory
public string Could_not_create_listener
public string TL_InitializeData_NotSpecified
public string Could_not_create_type_instance
public string Could_not_find_type
public string Could_not_get_constructor
public string EmptyTypeName_NotAllowed
public string Incorrect_base_type
public string Only_specify_one
public string Provider_Already_Initialized
public string Reference_listener_cant_have_properties
public string Reference_to_nonexistent_listener
public string SettingsPropertyNotFound
public string SettingsPropertyReadOnly
public string SettingsPropertyWrongType
public string Type_isnt_tracelistener
public string Unable_to_convert_type_from_string
public string Unable_to_convert_type_to_string
public string Value_must_be_numeric
public string Could_not_create_from_default_value
public string Could_not_create_from_default_value_2
public string InvalidDirName
public string FSW_IOError
public string PatternInvalidChar
public string BufferSizeTooLarge
public string FSW_ChangedFilter
public string FSW_Enabled
public string FSW_Filter
public string FSW_IncludeSubdirectories
public string FSW_Path
public string FSW_SynchronizingObject
public string FSW_Changed
public string FSW_Created
public string FSW_Deleted
public string FSW_Renamed
public string FSW_BufferOverflow
public string FileSystemWatcherDesc
public string NotSet
public string TimerAutoReset
public string TimerEnabled
public string TimerInterval
public string TimerIntervalElapsed
public string TimerSynchronizingObject
public string MismatchedCounterTypes
public string NoPropertyForAttribute
public string InvalidAttributeType
public string Generic_ArgCantBeEmptyString
public string BadLogName
public string InvalidProperty
public string CantMonitorEventLog
public string InitTwice
public string InvalidParameter
public string MissingParameter
public string ParameterTooLong
public string LocalSourceAlreadyExists
public string SourceAlreadyExists
public string LocalLogAlreadyExistsAsSource
public string LogAlreadyExistsAsSource
public string DuplicateLogName
public string RegKeyMissing
public string LocalRegKeyMissing
public string RegKeyMissingShort
public string InvalidParameterFormat
public string NoLogName
public string RegKeyNoAccess
public string MissingLog
public string SourceNotRegistered
public string LocalSourceNotRegistered
public string CantRetrieveEntries
public string IndexOutOfBounds
public string CantReadLogEntryAt
public string MissingLogProperty
public string CantOpenLog
public string NeedSourceToOpen
public string NeedSourceToWrite
public string CantOpenLogAccess
public string LogEntryTooLong
public string TooManyReplacementStrings
public string LogSourceMismatch
public string NoAccountInfo
public string NoCurrentEntry
public string MessageNotFormatted
public string EventID
public string LogDoesNotExists
public string InvalidCustomerLogName
public string CannotDeleteEqualSource
public string RentionDaysOutOfRange
public string MaximumKilobytesOutOfRange
public string SomeLogsInaccessible
public string SomeLogsInaccessibleToCreate
public string BadConfigSwitchValue
public string ConfigSectionsUnique
public string ConfigSectionsUniquePerSection
public string SourceListenerDoesntExist
public string SourceSwitchDoesntExist
public string CategoryHelpCorrupt
public string CounterNameCorrupt
public string CounterDataCorrupt
public string ReadOnlyCounter
public string ReadOnlyRemoveInstance
public string NotCustomCounter
public string CategoryNameMissing
public string CounterNameMissing
public string InstanceNameProhibited
public string InstanceNameRequired
public string MissingInstance
public string PerformanceCategoryExists
public string InvalidCounterName
public string DuplicateCounterName
public string CantChangeCategoryRegistration
public string CantDeleteCategory
public string MissingCategory
public string MissingCategoryDetail
public string CantReadCategory
public string MissingCounter
public string CategoryNameNotSet
public string CounterExists
public string CantReadCategoryIndex
public string CantReadCounter
public string CantReadInstance
public string RemoteWriting
public string CounterLayout
public string PossibleDeadlock
public string SharedMemoryGhosted
public string HelpNotAvailable
public string PerfInvalidHelp
public string PerfInvalidCounterName
public string PerfInvalidCategoryName
public string MustAddCounterCreationData
public string RemoteCounterAdmin
public string NoInstanceInformation
public string PerfCounterPdhError
public string MultiInstanceOnly
public string SingleInstanceOnly
public string InstanceNameTooLong
public string CategoryNameTooLong
public string InstanceLifetimeProcessonReadOnly
public string InstanceLifetimeProcessforSingleInstance
public string InstanceAlreadyExists
public string CantSetLifetimeAfterInitialized
public string ProcessLifetimeNotValidInGlobal
public string CantConvertProcessToGlobal
public string CantConvertGlobalToProcess
public string PCNotSupportedUnderAppContainer
public string PriorityClassNotSupported
public string WinNTRequired
public string Win2kRequired
public string NoAssociatedProcess
public string ProcessIdRequired
public string NotSupportedRemote
public string NoProcessInfo
public string WaitTillExit
public string NoProcessHandle
public string MissingProccess
public string BadMinWorkset
public string BadMaxWorkset
public string WinNTRequiredForRemote
public string ProcessHasExited
public string ProcessHasExitedNoId
public string ThreadExited
public string Win2000Required
public string ProcessNotFound
public string CantGetProcessId
public string ProcessDisabled
public string WaitReasonUnavailable
public string NotSupportedRemoteThread
public string UseShellExecuteRequiresSTA
public string CantRedirectStreams
public string CantUseEnvVars
public string CantStartAsUser
public string CouldntConnectToRemoteMachine
public string CouldntGetProcessInfos
public string InputIdleUnkownError
public string FileNameMissing
public string EnvironmentBlock
public string EnumProcessModuleFailed
public string EnumProcessModuleFailedDueToWow
public string PendingAsyncOperation
public string NoAsyncOperation
public string InvalidApplication
public string StandardOutputEncodingNotAllowed
public string StandardErrorEncodingNotAllowed
public string CountersOOM
public string MappingCorrupted
public string SetSecurityDescriptorFailed
public string CantCreateFileMapping
public string CantMapFileView
public string CantGetMappingSize
public string CantGetStandardOut
public string CantGetStandardIn
public string CantGetStandardError
public string CantMixSyncAsyncOperation
public string NoFileMappingSize
public string EnvironmentBlockTooLong
public string Arg_SecurityException
public string ArgumentNull_Array
public string ArgumentNull_Buffer
public string IO_UnknownError
public string NotSupported_UnwritableStream
public string ObjectDisposed_WriterClosed
public string NotSupportedOS
public string BaudRate
public string DataBits
public string DiscardNull
public string DtrEnable
public string EncodingMonitoringDescription
public string Handshake
public string NewLine
public string Parity
public string ParityReplace
public string PortName
public string ReadBufferSize
public string ReadTimeout
public string ReceivedBytesThreshold
public string RtsEnable
public string SerialPortDesc
public string StopBits
public string WriteBufferSize
public string WriteTimeout
public string SerialErrorReceived
public string SerialPinChanged
public string SerialDataReceived
public string CounterType
public string CounterName
public string CounterHelp
public string EventLogDesc
public string ErrorDataReceived
public string LogEntries
public string LogLog
public string LogMachineName
public string LogMonitoring
public string LogSynchronizingObject
public string LogSource
public string LogEntryWritten
public string LogEntryMachineName
public string LogEntryData
public string LogEntryIndex
public string LogEntryCategory
public string LogEntryCategoryNumber
public string LogEntryEventID
public string LogEntryEntryType
public string LogEntryMessage
public string LogEntrySource
public string LogEntryReplacementStrings
public string LogEntryResourceId
public string LogEntryTimeGenerated
public string LogEntryTimeWritten
public string LogEntryUserName
public string OutputDataReceived
public string PC_CounterHelp
public string PC_CounterType
public string PC_ReadOnly
public string PC_RawValue
public string ProcessAssociated
public string ProcessDesc
public string ProcessExitCode
public string ProcessTerminated
public string ProcessExitTime
public string ProcessHandle
public string ProcessHandleCount
public string ProcessId
public string ProcessMachineName
public string ProcessMainModule
public string ProcessModules
public string ProcessSynchronizingObject
public string ProcessSessionId
public string ProcessThreads
public string ProcessEnableRaisingEvents
public string ProcessExited
public string ProcessFileName
public string ProcessWorkingDirectory
public string ProcessBasePriority
public string ProcessMainWindowHandle
public string ProcessMainWindowTitle
public string ProcessMaxWorkingSet
public string ProcessMinWorkingSet
public string ProcessNonpagedSystemMemorySize
public string ProcessPagedMemorySize
public string ProcessPagedSystemMemorySize
public string ProcessPeakPagedMemorySize
public string ProcessPeakWorkingSet
public string ProcessPeakVirtualMemorySize
public string ProcessPriorityBoostEnabled
public string ProcessPriorityClass
public string ProcessPrivateMemorySize
public string ProcessPrivilegedProcessorTime
public string ProcessProcessName
public string ProcessProcessorAffinity
public string ProcessResponding
public string ProcessStandardError
public string ProcessStandardInput
public string ProcessStandardOutput
public string ProcessStartInfo
public string ProcessStartTime
public string ProcessTotalProcessorTime
public string ProcessUserProcessorTime
public string ProcessVirtualMemorySize
public string ProcessWorkingSet
public string ProcModModuleName
public string ProcModFileName
public string ProcModBaseAddress
public string ProcModModuleMemorySize
public string ProcModEntryPointAddress
public string ProcessVerb
public string ProcessArguments
public string ProcessErrorDialog
public string ProcessWindowStyle
public string ProcessCreateNoWindow
public string ProcessEnvironmentVariables
public string ProcessRedirectStandardInput
public string ProcessRedirectStandardOutput
public string ProcessRedirectStandardError
public string ProcessUseShellExecute
public string ThreadBasePriority
public string ThreadCurrentPriority
public string ThreadId
public string ThreadPriorityBoostEnabled
public string ThreadPriorityLevel
public string ThreadPrivilegedProcessorTime
public string ThreadStartAddress
public string ThreadStartTime
public string ThreadThreadState
public string ThreadTotalProcessorTime
public string ThreadUserProcessorTime
public string ThreadWaitReason
public string VerbEditorDefault
public string AppSettingsReaderNoKey
public string AppSettingsReaderNoParser
public string AppSettingsReaderCantParse
public string AppSettingsReaderEmptyString
public string InvalidPermissionState
public string PermissionNumberOfElements
public string PermissionItemExists
public string PermissionItemDoesntExist
public string PermissionBadParameterEnum
public string PermissionInvalidLength
public string PermissionTypeMismatch
public string Argument_NotAPermissionElement
public string Argument_InvalidXMLBadVersion
public string InvalidPermissionLevel
public string TargetNotWebBrowserPermissionLevel
public string WebBrowserBadXml
public string KeyedCollNeedNonNegativeNum
public string KeyedCollDuplicateKey
public string KeyedCollReferenceKeyNotFound
public string KeyedCollKeyNotFound
public string KeyedCollInvalidKey
public string KeyedCollCapacityOverflow
public string OrderedDictionary_ReadOnly
public string OrderedDictionary_SerializationMismatch
public string Async_ExceptionOccurred
public string Async_QueueingFailed
public string Async_OperationCancelled
public string Async_OperationAlreadyCompleted
public string Async_NullDelegate
public string BackgroundWorker_AlreadyRunning
public string BackgroundWorker_CancellationNotSupported
public string BackgroundWorker_OperationCompleted
public string BackgroundWorker_ProgressNotSupported
public string BackgroundWorker_WorkerAlreadyRunning
public string BackgroundWorker_WorkerDoesntReportProgress
public string BackgroundWorker_WorkerDoesntSupportCancellation
public string Async_ProgressChangedEventArgs_ProgressPercentage
public string Async_ProgressChangedEventArgs_UserState
public string Async_AsyncEventArgs_Cancelled
public string Async_AsyncEventArgs_Error
public string Async_AsyncEventArgs_UserState
public string BackgroundWorker_CancellationPending
public string BackgroundWorker_DoWork
public string BackgroundWorker_IsBusy
public string BackgroundWorker_ProgressChanged
public string BackgroundWorker_RunWorkerCompleted
public string BackgroundWorker_WorkerReportsProgress
public string BackgroundWorker_WorkerSupportsCancellation
public string BackgroundWorker_DoWorkEventArgs_Argument
public string BackgroundWorker_DoWorkEventArgs_Result
public string BackgroundWorker_Desc
public string InstanceCreationEditorDefaultText
public string PropertyTabAttributeBadPropertyTabScope
public string PropertyTabAttributeTypeLoadException
public string PropertyTabAttributeArrayLengthMismatch
public string PropertyTabAttributeParamsBothNull
public string InstanceDescriptorCannotBeStatic
public string InstanceDescriptorMustBeStatic
public string InstanceDescriptorMustBeReadable
public string InstanceDescriptorLengthMismatch
public string ToolboxItemAttributeFailedGetType
public string PropertyDescriptorCollectionBadValue
public string PropertyDescriptorCollectionBadKey
public string AspNetHostingPermissionBadXml
public string CorruptedGZipHeader
public string UnknownCompressionMode
public string UnknownState
public string InvalidHuffmanData
public string InvalidCRC
public string InvalidStreamSize
public string UnknownBlockType
public string InvalidBlockLength
public string GenericInvalidData
public string CannotReadFromDeflateStream
public string CannotWriteToDeflateStream
public string NotReadableStream
public string NotWriteableStream
public string InvalidArgumentOffsetCount
public string InvalidBeginCall
public string InvalidEndCall
public string StreamSizeOverflow
public string ZLibErrorDLLLoadError
public string ZLibErrorUnexpected
public string ZLibErrorInconsistentStream
public string ZLibErrorSteamFreedPrematurely
public string ZLibErrorNotEnoughMemory
public string ZLibErrorIncorrectInitParameters
public string ZLibErrorVersionMismatch
public string InvalidOperation_HCCountOverflow
public string Argument_InvalidThreshold
public string Argument_SemaphoreInitialMaximum
public string Argument_WaitHandleNameTooLong
public string WaitHandleCannotBeOpenedException_InvalidHandle
public string ArgumentNotAPermissionElement
public string ArgumentWrongType
public string BadXmlVersion
public string BinarySerializationNotSupported
public string BothScopeAttributes
public string NoScopeAttributes
public string PositionOutOfRange
public string ProviderInstantiationFailed
public string ProviderTypeLoadFailed
public string SaveAppScopedNotSupported
public string SettingsResetFailed
public string SettingsSaveFailed
public string SettingsSaveFailedNoSection
public string StringDeserializationFailed
public string StringSerializationFailed
public string UnknownSerializationFormat
public string UnknownSeekOrigin
public string UnknownUserLevel
public string UserSettingsNotSupported
public string XmlDeserializationFailed
public string XmlSerializationFailed
public string MemberRelationshipService_RelationshipNotSupported
public string MaskedTextProviderPasswordAndPromptCharError
public string MaskedTextProviderInvalidCharError
public string MaskedTextProviderMaskNullOrEmpty
public string MaskedTextProviderMaskInvalidChar
public string StandardOleMarshalObjectGetMarshalerFailed
public string SoundAPIBadSoundLocation
public string SoundAPIFileDoesNotExist
public string SoundAPIFormatNotSupported
public string SoundAPIInvalidWaveFile
public string SoundAPIInvalidWaveHeader
public string SoundAPILoadTimedOut
public string SoundAPILoadTimeout
public string SoundAPIReadError
public string WrongActionForCtor
public string MustBeResetAddOrRemoveActionForCtor
public string ResetActionRequiresNullItem
public string ResetActionRequiresIndexMinus1
public string IndexCannotBeNegative
public string ObservableCollectionReentrancyNotAllowed
public string mono_net_io_shutdown
public string mono_net_io_renegotiate
public string net_ssl_io_already_shutdown
public string net_log_set_socketoption_reuseport_default_on
public string net_log_set_socketoption_reuseport_not_supported
public string net_log_set_socketoption_reuseport
public string BlockingCollection_Add_ConcurrentCompleteAdd
public string BlockingCollection_Add_Failed
public string BlockingCollection_CantAddAnyWhenCompleted
public string BlockingCollection_CantTakeAnyWhenAllDone
public string BlockingCollection_CantTakeWhenDone
public string BlockingCollection_Completed
public string BlockingCollection_CopyTo_IncorrectType
public string BlockingCollection_CopyTo_MultiDim
public string BlockingCollection_CopyTo_NonNegative
public string Collection_CopyTo_TooManyElems
public string BlockingCollection_ctor_BoundedCapacityRange
public string BlockingCollection_ctor_CountMoreThanCapacity
public string BlockingCollection_Disposed
public string BlockingCollection_Take_CollectionModified
public string BlockingCollection_TimeoutInvalid
public string BlockingCollection_ValidateCollectionsArray_DispElems
public string BlockingCollection_ValidateCollectionsArray_LargeSize
public string BlockingCollection_ValidateCollectionsArray_NullElems
public string BlockingCollection_ValidateCollectionsArray_ZeroSize
public string Common_OperationCanceled
public string ConcurrentBag_Ctor_ArgumentNullException
public string ConcurrentBag_CopyTo_ArgumentNullException
public string Collection_CopyTo_ArgumentOutOfRangeException
public string ConcurrentCollection_SyncRoot_NotSupported
public string ConcurrentDictionary_ArrayIncorrectType
public string ConcurrentDictionary_SourceContainsDuplicateKeys
public string ConcurrentDictionary_ConcurrencyLevelMustBePositive
public string ConcurrentDictionary_CapacityMustNotBeNegative
public string ConcurrentDictionary_IndexIsNegative
public string ConcurrentDictionary_ArrayNotLargeEnough
public string ConcurrentDictionary_KeyAlreadyExisted
public string ConcurrentDictionary_ItemKeyIsNull
public string ConcurrentDictionary_TypeOfKeyIncorrect
public string ConcurrentDictionary_TypeOfValueIncorrect
public string ConcurrentStack_PushPopRange_CountOutOfRange
public string ConcurrentStack_PushPopRange_InvalidCount
public string ConcurrentStack_PushPopRange_StartOutOfRange
public string Partitioner_DynamicPartitionsNotSupported
public string PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed
public string PartitionerStatic_CurrentCalledBeforeMoveNext
public string ConcurrentBag_Enumerator_EnumerationNotStartedOrAlreadyFinished
public string Arg_NonZeroLowerBound
public string Arg_WrongType
public string Arg_ArrayPlusOffTooSmall
public string ArgumentOutOfRange_NeedNonNegNum
public string ArgumentOutOfRange_SmallCapacity
public string Argument_InvalidOffLen
public string Argument_AddingDuplicate
public string InvalidOperation_EmptyQueue
public string InvalidOperation_EnumOpCantHappen
public string InvalidOperation_EnumFailedVersion
public string InvalidOperation_EmptyStack
public string InvalidOperation_EnumNotStarted
public string InvalidOperation_EnumEnded
public string NotSupported_KeyCollectionSet
public string NotSupported_ValueCollectionSet
public string Arg_ArrayLengthsDiffer
public string Arg_BitArrayTypeUnsupported
public string Arg_HSCapacityOverflow
public string Arg_HTCapacityOverflow
public string Arg_InsufficientSpace
public string Arg_RankMultiDimNotSupported
public string Argument_ArrayTooLarge
public string Argument_InvalidArrayType
public string ArgumentOutOfRange_BiggerThanCollection
public string ArgumentOutOfRange_Index
public string ExternalLinkedListNode
public string LinkedListEmpty
public string LinkedListNodeIsAttached
public string NotSupported_SortedListNestedWrite
public string SortedSet_LowerValueGreaterThanUpperValue
public string Serialization_InvalidOnDeser
public string Serialization_MismatchedCount
public string Serialization_MissingKeys
public string Serialization_MissingValues
public string ArgumentException_BufferNotFromPool
public string ArgumentOutOfRange_IndexCountBuffer
public string Argument_InvalidCharSequenceNoIndex
public string net_uri_BadAuthority
public string net_uri_BadAuthorityTerminator
public string net_uri_BadFormat
public string net_uri_NeedFreshParser
public string net_uri_AlreadyRegistered
public string net_uri_BadHostName
public string net_uri_BadPort
public string net_uri_BadScheme
public string net_uri_BadString
public string net_uri_BadUserPassword
public string net_uri_CannotCreateRelative
public string net_uri_SchemeLimit
public string net_uri_EmptyUri
public string net_uri_InvalidUriKind
public string net_uri_MustRootedPath
public string net_uri_NotAbsolute
public string net_uri_PortOutOfRange
public string net_uri_SizeLimit
public string net_uri_UserDrivenParsing
public string net_uri_NotJustSerialization
public string net_uri_BadUnicodeHostForIdn
public string Argument_ExtraNotValid
public string Argument_InvalidUriSubcomponent
public string IO_EOF_ReadBeyondEOF
public string BaseStream_Invalid_Not_Open
public string PortNameEmpty_String
public string Port_not_open
public string Port_already_open
public string Cant_be_set_when_open
public string Max_Baud
public string In_Break_State
public string Write_timed_out
public string CantSetRtsWithHandshaking
public string NotSupportedEncoding
public string Arg_InvalidSerialPort
public string Arg_InvalidSerialPortExtended
public string ArgumentOutOfRange_Bounds_Lower_Upper
public string ArgumentOutOfRange_Enum
public string ArgumentOutOfRange_NeedNonNegNumRequired
public string ArgumentOutOfRange_NeedPosNum
public string ArgumentOutOfRange_Timeout
public string ArgumentOutOfRange_WriteTimeout
public string IndexOutOfRange_IORaceCondition
public string IO_BindHandleFailed
public string IO_OperationAborted
public string NotSupported_UnseekableStream
public string ObjectDisposed_StreamClosed
public string InvalidNullEmptyArgument
public string Arg_WrongAsyncResult
public string InvalidOperation_EndReadCalledMultiple
public string InvalidOperation_EndWriteCalledMultiple
public string IO_PortNotFound
public string IO_PortNotFoundFileName
public string UnauthorizedAccess_IODenied_NoPathName
public string IO_PathTooLong
public string IO_SharingViolation_NoFileName
public string IO_SharingViolation_File
public string UnauthorizedAccess_IODenied_Path
public string net_log_listener_delegate_exception
public string net_log_listener_unsupported_authentication_scheme
public string net_log_listener_unmatched_authentication_scheme
public string net_io_invalidasyncresult
public string net_io_invalidendcall
public string net_listener_cannot_set_custom_cbt
public string net_listener_detach_error
public string net_listener_scheme
public string net_listener_host
public string net_listener_mustcall
public string net_listener_slash
public string net_listener_already
public string net_log_listener_no_cbt_disabled
public string net_log_listener_no_cbt_http
public string net_log_listener_no_cbt_trustedproxy
public string net_log_listener_cbt
public string net_log_listener_no_spn_kerberos
public string net_log_listener_no_spn_disabled
public string net_log_listener_no_spn_cbt
public string net_log_listener_no_spn_whensupported
public string net_log_listener_no_spn_loopback
public string net_log_listener_spn
public string net_log_listener_spn_passed
public string net_log_listener_spn_failed
public string net_log_listener_spn_failed_always
public string net_log_listener_spn_failed_empty
public string net_log_listener_spn_failed_dump
public string net_log_listener_spn_add
public string net_log_listener_spn_not_add
public string net_log_listener_spn_remove
public string net_log_listener_spn_not_remove
public string net_listener_no_spns
public string net_ssp_dont_support_cbt
public string net_PropertyNotImplementedException
public string net_array_too_small
public string net_listener_mustcompletecall
public string net_listener_invalid_cbt_type
public string net_listener_callinprogress
public string net_log_listener_cant_create_uri
public string net_log_listener_cant_convert_raw_path
public string net_log_listener_cant_convert_percent_value
public string net_log_listener_cant_convert_to_utf8
public string net_log_listener_cant_convert_bytes
public string net_invalidstatus
public string net_WebHeaderInvalidControlChars
public string net_rspsubmitted
public string net_nochunkuploadonhttp10
public string net_cookie_exists
public string net_clsmall
public string net_wrongversion
public string net_noseek
public string net_writeonlystream
public string net_entitytoobig
public string net_io_notenoughbyteswritten
public string net_listener_close_urlgroup_error
public string net_WebSockets_NativeSendResponseHeaders
public string net_WebSockets_ClientAcceptingNoProtocols
public string net_WebSockets_AcceptUnsupportedProtocol
public string net_WebSockets_AcceptNotAWebSocket
public string net_WebSockets_AcceptHeaderNotFound
public string net_WebSockets_AcceptUnsupportedWebSocketVersion
public string net_WebSockets_InvalidEmptySubProtocol
public string net_WebSockets_InvalidCharInProtocolString
public string net_WebSockets_ReasonNotNull
public string net_WebSockets_InvalidCloseStatusCode
public string net_WebSockets_InvalidCloseStatusDescription
public string net_WebSockets_ArgumentOutOfRange_TooSmall
public string net_WebSockets_ArgumentOutOfRange_TooBig
public string net_WebSockets_UnsupportedPlatform
public string net_readonlystream
public string net_WebSockets_InvalidState_ClosedOrAborted
public string net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync
public string net_Websockets_AlreadyOneOutstandingOperation
public string net_WebSockets_InvalidMessageType
public string net_WebSockets_InvalidBufferType
public string net_WebSockets_ArgumentOutOfRange_InternalBuffer
public string net_WebSockets_Argument_InvalidMessageType
public string net_securitypackagesupport
public string net_log_operation_failed_with_error
public string net_MethodNotImplementedException
public string event_OperationReturnedSomething
public string net_invalid_enum
public string net_auth_message_not_encrypted
public string SSPIInvalidHandleType
public string net_cannot_change_after_headers
public string offset_out_of_range
public string net_io_operation_aborted
public string net_invalid_path
public string net_no_client_certificate
public string net_listener_auth_errors
public string net_listener_close
public string net_invalid_port
public string net_WebSockets_InvalidState
internal string GetString(string name, Object[] args)
internal string GetString(CultureInfo culture, string name, Object[] args)
internal string GetString(string name)
internal string GetString(CultureInfo culture, string name)
internal string Format(string resourceFormat, Object[] args)
internal string Format(string resourceFormat, object p1)
internal string Format(string resourceFormat, object p1, object p2)
internal string Format(string resourceFormat, object p1, object p2, object p3)
public object GetObject(string name)
}
internal System.Buffers.ArrayPool`1 : object {
private ArrayPool`1<T> s_sharedInstance
public ArrayPool`1<T> Shared
public ArrayPool`1<T> get_Shared()
private ArrayPool`1<T> EnsureSharedCreated()
public ArrayPool`1<T> Create()
public ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket)
public T[] Rent(int minimumLength)
public void Return(T[] array, bool clearArray)
}
internal System.Buffers.ArrayPoolEventSource : EventSource {
internal ArrayPoolEventSource Log
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId)
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason)
internal void BufferReturned(int bufferId, int bufferSize, int poolId)
}
internal System.Buffers.DefaultArrayPool`1 : ArrayPool`1<T> {
private int DefaultMaxArrayLength
private int DefaultMaxNumberOfArraysPerBucket
private T[] s_emptyArray
private Bucket[] _buckets
private int Id
internal void .ctor(int maxArrayLength, int maxArraysPerBucket)
private int get_Id()
public T[] Rent(int minimumLength)
public void Return(T[] array, bool clearArray)
}
internal System.Buffers.Utilities : object {
internal int SelectBucketIndex(int bufferSize)
internal int GetMaxSizeForBucket(int binIndex)
}
public System.CodeDom.CodeArgumentReferenceExpression : CodeExpression {
private string _parameterName
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
public void set_ParameterName(string value)
}
public System.CodeDom.CodeArrayCreateExpression : CodeExpression {
private CodeExpressionCollection _initializers
private CodeTypeReference _createType
private int <Size>k__BackingField
private CodeExpression <SizeExpression>k__BackingField
public CodeTypeReference CreateType
public CodeExpressionCollection Initializers
public int Size
public CodeExpression SizeExpression
public void .ctor(CodeTypeReference createType, CodeExpression[] initializers)
public void .ctor(string createType, CodeExpression[] initializers)
public void .ctor(Type createType, CodeExpression[] initializers)
public void .ctor(CodeTypeReference createType, int size)
public void .ctor(string createType, int size)
public void .ctor(Type createType, int size)
public void .ctor(CodeTypeReference createType, CodeExpression size)
public void .ctor(string createType, CodeExpression size)
public void .ctor(Type createType, CodeExpression size)
public CodeTypeReference get_CreateType()
public void set_CreateType(CodeTypeReference value)
public CodeExpressionCollection get_Initializers()
public int get_Size()
public void set_Size(int value)
public CodeExpression get_SizeExpression()
public void set_SizeExpression(CodeExpression value)
}
public System.CodeDom.CodeArrayIndexerExpression : CodeExpression {
private CodeExpressionCollection _indices
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public CodeExpressionCollection Indices
public void .ctor(CodeExpression targetObject, CodeExpression[] indices)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public CodeExpressionCollection get_Indices()
}
public System.CodeDom.CodeAssignStatement : CodeStatement {
private CodeExpression <Left>k__BackingField
private CodeExpression <Right>k__BackingField
public CodeExpression Left
public CodeExpression Right
public void .ctor(CodeExpression left, CodeExpression right)
public CodeExpression get_Left()
public void set_Left(CodeExpression value)
public CodeExpression get_Right()
public void set_Right(CodeExpression value)
}
public System.CodeDom.CodeAttachEventStatement : CodeStatement {
private CodeEventReferenceExpression _eventRef
private CodeExpression <Listener>k__BackingField
public CodeEventReferenceExpression Event
public CodeExpression Listener
public void .ctor(CodeEventReferenceExpression eventRef, CodeExpression listener)
public void .ctor(CodeExpression targetObject, string eventName, CodeExpression listener)
public CodeEventReferenceExpression get_Event()
public void set_Event(CodeEventReferenceExpression value)
public CodeExpression get_Listener()
public void set_Listener(CodeExpression value)
}
public System.CodeDom.CodeAttributeArgument : object {
private string _name
private CodeExpression <Value>k__BackingField
public string Name
public CodeExpression Value
public void .ctor(CodeExpression value)
public void .ctor(string name, CodeExpression value)
public string get_Name()
public void set_Name(string value)
public CodeExpression get_Value()
public void set_Value(CodeExpression value)
}
public System.CodeDom.CodeAttributeArgumentCollection : CollectionBase {
public CodeAttributeArgument Item
public void .ctor(CodeAttributeArgumentCollection value)
public void .ctor(CodeAttributeArgument[] value)
public CodeAttributeArgument get_Item(int index)
public void set_Item(int index, CodeAttributeArgument value)
public int Add(CodeAttributeArgument value)
public void AddRange(CodeAttributeArgument[] value)
public void AddRange(CodeAttributeArgumentCollection value)
public bool Contains(CodeAttributeArgument value)
public void CopyTo(CodeAttributeArgument[] array, int index)
public int IndexOf(CodeAttributeArgument value)
public void Insert(int index, CodeAttributeArgument value)
public void Remove(CodeAttributeArgument value)
}
public System.CodeDom.CodeAttributeDeclaration : object {
private string _name
private CodeAttributeArgumentCollection _arguments
private CodeTypeReference _attributeType
public string Name
public CodeAttributeArgumentCollection Arguments
public CodeTypeReference AttributeType
public void .ctor(string name)
public void .ctor(string name, CodeAttributeArgument[] arguments)
public void .ctor(CodeTypeReference attributeType)
public void .ctor(CodeTypeReference attributeType, CodeAttributeArgument[] arguments)
public string get_Name()
public void set_Name(string value)
public CodeAttributeArgumentCollection get_Arguments()
public CodeTypeReference get_AttributeType()
}
public System.CodeDom.CodeAttributeDeclarationCollection : CollectionBase {
public CodeAttributeDeclaration Item
public void .ctor(CodeAttributeDeclarationCollection value)
public void .ctor(CodeAttributeDeclaration[] value)
public CodeAttributeDeclaration get_Item(int index)
public void set_Item(int index, CodeAttributeDeclaration value)
public int Add(CodeAttributeDeclaration value)
public void AddRange(CodeAttributeDeclaration[] value)
public void AddRange(CodeAttributeDeclarationCollection value)
public bool Contains(CodeAttributeDeclaration value)
public void CopyTo(CodeAttributeDeclaration[] array, int index)
public int IndexOf(CodeAttributeDeclaration value)
public void Insert(int index, CodeAttributeDeclaration value)
public void Remove(CodeAttributeDeclaration value)
}
public System.CodeDom.CodeBinaryOperatorExpression : CodeExpression {
private CodeExpression <Right>k__BackingField
private CodeExpression <Left>k__BackingField
private CodeBinaryOperatorType <Operator>k__BackingField
public CodeExpression Right
public CodeExpression Left
public CodeBinaryOperatorType Operator
public void .ctor(CodeExpression left, CodeBinaryOperatorType op, CodeExpression right)
public CodeExpression get_Right()
public void set_Right(CodeExpression value)
public CodeExpression get_Left()
public void set_Left(CodeExpression value)
public CodeBinaryOperatorType get_Operator()
public void set_Operator(CodeBinaryOperatorType value)
}
public System.CodeDom.CodeBinaryOperatorType : Enum {
public int value__
public CodeBinaryOperatorType Add
public CodeBinaryOperatorType Subtract
public CodeBinaryOperatorType Multiply
public CodeBinaryOperatorType Divide
public CodeBinaryOperatorType Modulus
public CodeBinaryOperatorType Assign
public CodeBinaryOperatorType IdentityInequality
public CodeBinaryOperatorType IdentityEquality
public CodeBinaryOperatorType ValueEquality
public CodeBinaryOperatorType BitwiseOr
public CodeBinaryOperatorType BitwiseAnd
public CodeBinaryOperatorType BooleanOr
public CodeBinaryOperatorType BooleanAnd
public CodeBinaryOperatorType LessThan
public CodeBinaryOperatorType LessThanOrEqual
public CodeBinaryOperatorType GreaterThan
public CodeBinaryOperatorType GreaterThanOrEqual
}
public System.CodeDom.CodeCastExpression : CodeExpression {
private CodeTypeReference _targetType
private CodeExpression <Expression>k__BackingField
public CodeTypeReference TargetType
public CodeExpression Expression
public void .ctor(CodeTypeReference targetType, CodeExpression expression)
public void .ctor(string targetType, CodeExpression expression)
public void .ctor(Type targetType, CodeExpression expression)
public CodeTypeReference get_TargetType()
public void set_TargetType(CodeTypeReference value)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
}
public System.CodeDom.CodeCatchClause : object {
private CodeStatementCollection _statements
private CodeTypeReference _catchExceptionType
private string _localName
public string LocalName
public CodeTypeReference CatchExceptionType
public CodeStatementCollection Statements
public void .ctor(string localName)
public void .ctor(string localName, CodeTypeReference catchExceptionType)
public void .ctor(string localName, CodeTypeReference catchExceptionType, CodeStatement[] statements)
public string get_LocalName()
public void set_LocalName(string value)
public CodeTypeReference get_CatchExceptionType()
public void set_CatchExceptionType(CodeTypeReference value)
public CodeStatementCollection get_Statements()
}
public System.CodeDom.CodeCatchClauseCollection : CollectionBase {
public CodeCatchClause Item
public void .ctor(CodeCatchClauseCollection value)
public void .ctor(CodeCatchClause[] value)
public CodeCatchClause get_Item(int index)
public void set_Item(int index, CodeCatchClause value)
public int Add(CodeCatchClause value)
public void AddRange(CodeCatchClause[] value)
public void AddRange(CodeCatchClauseCollection value)
public bool Contains(CodeCatchClause value)
public void CopyTo(CodeCatchClause[] array, int index)
public int IndexOf(CodeCatchClause value)
public void Insert(int index, CodeCatchClause value)
public void Remove(CodeCatchClause value)
}
public System.CodeDom.CodeChecksumPragma : CodeDirective {
private string _fileName
private Guid <ChecksumAlgorithmId>k__BackingField
private Byte[] <ChecksumData>k__BackingField
public string FileName
public Guid ChecksumAlgorithmId
public Byte[] ChecksumData
public void .ctor(string fileName, Guid checksumAlgorithmId, Byte[] checksumData)
public string get_FileName()
public void set_FileName(string value)
public Guid get_ChecksumAlgorithmId()
public void set_ChecksumAlgorithmId(Guid value)
public Byte[] get_ChecksumData()
public void set_ChecksumData(Byte[] value)
}
public System.CodeDom.CodeComment : CodeObject {
private string _text
private bool <DocComment>k__BackingField
public bool DocComment
public string Text
public void .ctor(string text)
public void .ctor(string text, bool docComment)
public bool get_DocComment()
public void set_DocComment(bool value)
public string get_Text()
public void set_Text(string value)
}
public System.CodeDom.CodeCommentStatement : CodeStatement {
private CodeComment <Comment>k__BackingField
public CodeComment Comment
public void .ctor(CodeComment comment)
public void .ctor(string text)
public void .ctor(string text, bool docComment)
public CodeComment get_Comment()
public void set_Comment(CodeComment value)
}
public System.CodeDom.CodeCommentStatementCollection : CollectionBase {
public CodeCommentStatement Item
public void .ctor(CodeCommentStatementCollection value)
public void .ctor(CodeCommentStatement[] value)
public CodeCommentStatement get_Item(int index)
public void set_Item(int index, CodeCommentStatement value)
public int Add(CodeCommentStatement value)
public void AddRange(CodeCommentStatement[] value)
public void AddRange(CodeCommentStatementCollection value)
public bool Contains(CodeCommentStatement value)
public void CopyTo(CodeCommentStatement[] array, int index)
public int IndexOf(CodeCommentStatement value)
public void Insert(int index, CodeCommentStatement value)
public void Remove(CodeCommentStatement value)
}
public System.CodeDom.CodeCompileUnit : CodeObject {
private StringCollection _assemblies
private CodeAttributeDeclarationCollection _attributes
private CodeDirectiveCollection _startDirectives
private CodeDirectiveCollection _endDirectives
private CodeNamespaceCollection <Namespaces>k__BackingField
public CodeNamespaceCollection Namespaces
public StringCollection ReferencedAssemblies
public CodeAttributeDeclarationCollection AssemblyCustomAttributes
public CodeDirectiveCollection StartDirectives
public CodeDirectiveCollection EndDirectives
public CodeNamespaceCollection get_Namespaces()
public StringCollection get_ReferencedAssemblies()
public CodeAttributeDeclarationCollection get_AssemblyCustomAttributes()
public CodeDirectiveCollection get_StartDirectives()
public CodeDirectiveCollection get_EndDirectives()
}
public System.CodeDom.CodeConditionStatement : CodeStatement {
private CodeExpression <Condition>k__BackingField
private CodeStatementCollection <TrueStatements>k__BackingField
private CodeStatementCollection <FalseStatements>k__BackingField
public CodeExpression Condition
public CodeStatementCollection TrueStatements
public CodeStatementCollection FalseStatements
public void .ctor(CodeExpression condition, CodeStatement[] trueStatements)
public void .ctor(CodeExpression condition, CodeStatement[] trueStatements, CodeStatement[] falseStatements)
public CodeExpression get_Condition()
public void set_Condition(CodeExpression value)
public CodeStatementCollection get_TrueStatements()
public CodeStatementCollection get_FalseStatements()
}
public System.CodeDom.CodeConstructor : CodeMemberMethod {
private CodeExpressionCollection <BaseConstructorArgs>k__BackingField
private CodeExpressionCollection <ChainedConstructorArgs>k__BackingField
public CodeExpressionCollection BaseConstructorArgs
public CodeExpressionCollection ChainedConstructorArgs
public CodeExpressionCollection get_BaseConstructorArgs()
public CodeExpressionCollection get_ChainedConstructorArgs()
}
public System.CodeDom.CodeDefaultValueExpression : CodeExpression {
private CodeTypeReference _type
public CodeTypeReference Type
public void .ctor(CodeTypeReference type)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
}
public System.CodeDom.CodeDelegateCreateExpression : CodeExpression {
private CodeTypeReference _delegateType
private string _methodName
private CodeExpression <TargetObject>k__BackingField
public CodeTypeReference DelegateType
public CodeExpression TargetObject
public string MethodName
public void .ctor(CodeTypeReference delegateType, CodeExpression targetObject, string methodName)
public CodeTypeReference get_DelegateType()
public void set_DelegateType(CodeTypeReference value)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_MethodName()
public void set_MethodName(string value)
}
public System.CodeDom.CodeDelegateInvokeExpression : CodeExpression {
private CodeExpression <TargetObject>k__BackingField
private CodeExpressionCollection <Parameters>k__BackingField
public CodeExpression TargetObject
public CodeExpressionCollection Parameters
public void .ctor(CodeExpression targetObject)
public void .ctor(CodeExpression targetObject, CodeExpression[] parameters)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public CodeExpressionCollection get_Parameters()
}
public System.CodeDom.CodeDirectionExpression : CodeExpression {
private CodeExpression <Expression>k__BackingField
private FieldDirection <Direction>k__BackingField
public CodeExpression Expression
public FieldDirection Direction
public void .ctor(FieldDirection direction, CodeExpression expression)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
public FieldDirection get_Direction()
public void set_Direction(FieldDirection value)
}
public System.CodeDom.CodeDirectiveCollection : CollectionBase {
public CodeDirective Item
public void .ctor(CodeDirectiveCollection value)
public void .ctor(CodeDirective[] value)
public CodeDirective get_Item(int index)
public void set_Item(int index, CodeDirective value)
public int Add(CodeDirective value)
public void AddRange(CodeDirective[] value)
public void AddRange(CodeDirectiveCollection value)
public bool Contains(CodeDirective value)
public void CopyTo(CodeDirective[] array, int index)
public int IndexOf(CodeDirective value)
public void Insert(int index, CodeDirective value)
public void Remove(CodeDirective value)
}
public System.CodeDom.CodeEventReferenceExpression : CodeExpression {
private string _eventName
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public string EventName
public void .ctor(CodeExpression targetObject, string eventName)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_EventName()
public void set_EventName(string value)
}
public System.CodeDom.CodeExpressionCollection : CollectionBase {
public CodeExpression Item
public void .ctor(CodeExpressionCollection value)
public void .ctor(CodeExpression[] value)
public CodeExpression get_Item(int index)
public void set_Item(int index, CodeExpression value)
public int Add(CodeExpression value)
public void AddRange(CodeExpression[] value)
public void AddRange(CodeExpressionCollection value)
public bool Contains(CodeExpression value)
public void CopyTo(CodeExpression[] array, int index)
public int IndexOf(CodeExpression value)
public void Insert(int index, CodeExpression value)
public void Remove(CodeExpression value)
}
public System.CodeDom.CodeExpressionStatement : CodeStatement {
private CodeExpression <Expression>k__BackingField
public CodeExpression Expression
public void .ctor(CodeExpression expression)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
}
public System.CodeDom.CodeFieldReferenceExpression : CodeExpression {
private string _fieldName
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public string FieldName
public void .ctor(CodeExpression targetObject, string fieldName)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_FieldName()
public void set_FieldName(string value)
}
public System.CodeDom.CodeGotoStatement : CodeStatement {
private string _label
public string Label
public void .ctor(string label)
public string get_Label()
public void set_Label(string value)
}
public System.CodeDom.CodeIndexerExpression : CodeExpression {
private CodeExpressionCollection _indices
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public CodeExpressionCollection Indices
public void .ctor(CodeExpression targetObject, CodeExpression[] indices)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public CodeExpressionCollection get_Indices()
}
public System.CodeDom.CodeIterationStatement : CodeStatement {
private CodeStatement <InitStatement>k__BackingField
private CodeExpression <TestExpression>k__BackingField
private CodeStatement <IncrementStatement>k__BackingField
private CodeStatementCollection <Statements>k__BackingField
public CodeStatement InitStatement
public CodeExpression TestExpression
public CodeStatement IncrementStatement
public CodeStatementCollection Statements
public void .ctor(CodeStatement initStatement, CodeExpression testExpression, CodeStatement incrementStatement, CodeStatement[] statements)
public CodeStatement get_InitStatement()
public void set_InitStatement(CodeStatement value)
public CodeExpression get_TestExpression()
public void set_TestExpression(CodeExpression value)
public CodeStatement get_IncrementStatement()
public void set_IncrementStatement(CodeStatement value)
public CodeStatementCollection get_Statements()
}
public System.CodeDom.CodeLabeledStatement : CodeStatement {
private string _label
private CodeStatement <Statement>k__BackingField
public string Label
public CodeStatement Statement
public void .ctor(string label)
public void .ctor(string label, CodeStatement statement)
public string get_Label()
public void set_Label(string value)
public CodeStatement get_Statement()
public void set_Statement(CodeStatement value)
}
public System.CodeDom.CodeLinePragma : object {
private string _fileName
private int <LineNumber>k__BackingField
public string FileName
public int LineNumber
public void .ctor(string fileName, int lineNumber)
public string get_FileName()
public void set_FileName(string value)
public int get_LineNumber()
public void set_LineNumber(int value)
}
public System.CodeDom.CodeMemberEvent : CodeTypeMember {
private CodeTypeReference _type
private CodeTypeReferenceCollection _implementationTypes
private CodeTypeReference <PrivateImplementationType>k__BackingField
public CodeTypeReference Type
public CodeTypeReference PrivateImplementationType
public CodeTypeReferenceCollection ImplementationTypes
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
public CodeTypeReference get_PrivateImplementationType()
public void set_PrivateImplementationType(CodeTypeReference value)
public CodeTypeReferenceCollection get_ImplementationTypes()
}
public System.CodeDom.CodeMemberField : CodeTypeMember {
private CodeTypeReference _type
private CodeExpression <InitExpression>k__BackingField
public CodeTypeReference Type
public CodeExpression InitExpression
public void .ctor(CodeTypeReference type, string name)
public void .ctor(string type, string name)
public void .ctor(Type type, string name)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
public CodeExpression get_InitExpression()
public void set_InitExpression(CodeExpression value)
}
public System.CodeDom.CodeMemberMethod : CodeTypeMember {
private CodeParameterDeclarationExpressionCollection _parameters
private CodeStatementCollection _statements
private CodeTypeReference _returnType
private CodeTypeReferenceCollection _implementationTypes
private CodeAttributeDeclarationCollection _returnAttributes
private CodeTypeParameterCollection _typeParameters
private int _populated
private int ParametersCollection
private int StatementsCollection
private int ImplTypesCollection
private EventHandler PopulateParameters
private EventHandler PopulateStatements
private EventHandler PopulateImplementationTypes
private CodeTypeReference <PrivateImplementationType>k__BackingField
public CodeTypeReference ReturnType
public CodeStatementCollection Statements
public CodeParameterDeclarationExpressionCollection Parameters
public CodeTypeReference PrivateImplementationType
public CodeTypeReferenceCollection ImplementationTypes
public CodeAttributeDeclarationCollection ReturnTypeCustomAttributes
public CodeTypeParameterCollection TypeParameters
public void add_PopulateParameters(EventHandler value)
public void remove_PopulateParameters(EventHandler value)
public void add_PopulateStatements(EventHandler value)
public void remove_PopulateStatements(EventHandler value)
public void add_PopulateImplementationTypes(EventHandler value)
public void remove_PopulateImplementationTypes(EventHandler value)
public CodeTypeReference get_ReturnType()
public void set_ReturnType(CodeTypeReference value)
public CodeStatementCollection get_Statements()
public CodeParameterDeclarationExpressionCollection get_Parameters()
public CodeTypeReference get_PrivateImplementationType()
public void set_PrivateImplementationType(CodeTypeReference value)
public CodeTypeReferenceCollection get_ImplementationTypes()
public CodeAttributeDeclarationCollection get_ReturnTypeCustomAttributes()
public CodeTypeParameterCollection get_TypeParameters()
}
public System.CodeDom.CodeMemberProperty : CodeTypeMember {
private CodeTypeReference _type
private bool _hasGet
private bool _hasSet
private CodeTypeReferenceCollection _implementationTypes
private CodeTypeReference <PrivateImplementationType>k__BackingField
private CodeStatementCollection <GetStatements>k__BackingField
private CodeStatementCollection <SetStatements>k__BackingField
private CodeParameterDeclarationExpressionCollection <Parameters>k__BackingField
public CodeTypeReference PrivateImplementationType
public CodeTypeReferenceCollection ImplementationTypes
public CodeTypeReference Type
public bool HasGet
public bool HasSet
public CodeStatementCollection GetStatements
public CodeStatementCollection SetStatements
public CodeParameterDeclarationExpressionCollection Parameters
public CodeTypeReference get_PrivateImplementationType()
public void set_PrivateImplementationType(CodeTypeReference value)
public CodeTypeReferenceCollection get_ImplementationTypes()
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
public bool get_HasGet()
public void set_HasGet(bool value)
public bool get_HasSet()
public void set_HasSet(bool value)
public CodeStatementCollection get_GetStatements()
public CodeStatementCollection get_SetStatements()
public CodeParameterDeclarationExpressionCollection get_Parameters()
}
public System.CodeDom.CodeMethodInvokeExpression : CodeExpression {
private CodeMethodReferenceExpression _method
private CodeExpressionCollection <Parameters>k__BackingField
public CodeMethodReferenceExpression Method
public CodeExpressionCollection Parameters
public void .ctor(CodeMethodReferenceExpression method, CodeExpression[] parameters)
public void .ctor(CodeExpression targetObject, string methodName, CodeExpression[] parameters)
public CodeMethodReferenceExpression get_Method()
public void set_Method(CodeMethodReferenceExpression value)
public CodeExpressionCollection get_Parameters()
}
public System.CodeDom.CodeMethodReferenceExpression : CodeExpression {
private string _methodName
private CodeTypeReferenceCollection _typeArguments
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public string MethodName
public CodeTypeReferenceCollection TypeArguments
public void .ctor(CodeExpression targetObject, string methodName)
public void .ctor(CodeExpression targetObject, string methodName, CodeTypeReference[] typeParameters)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_MethodName()
public void set_MethodName(string value)
public CodeTypeReferenceCollection get_TypeArguments()
}
public System.CodeDom.CodeMethodReturnStatement : CodeStatement {
private CodeExpression <Expression>k__BackingField
public CodeExpression Expression
public void .ctor(CodeExpression expression)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
}
public System.CodeDom.CodeNamespace : CodeObject {
private string _name
private CodeNamespaceImportCollection _imports
private CodeCommentStatementCollection _comments
private CodeTypeDeclarationCollection _classes
private int _populated
private int ImportsCollection
private int CommentsCollection
private int TypesCollection
private EventHandler PopulateComments
private EventHandler PopulateImports
private EventHandler PopulateTypes
public CodeTypeDeclarationCollection Types
public CodeNamespaceImportCollection Imports
public string Name
public CodeCommentStatementCollection Comments
public void add_PopulateComments(EventHandler value)
public void remove_PopulateComments(EventHandler value)
public void add_PopulateImports(EventHandler value)
public void remove_PopulateImports(EventHandler value)
public void add_PopulateTypes(EventHandler value)
public void remove_PopulateTypes(EventHandler value)
public void .ctor(string name)
public CodeTypeDeclarationCollection get_Types()
public CodeNamespaceImportCollection get_Imports()
public string get_Name()
public void set_Name(string value)
public CodeCommentStatementCollection get_Comments()
}
public System.CodeDom.CodeNamespaceCollection : CollectionBase {
public CodeNamespace Item
public void .ctor(CodeNamespaceCollection value)
public void .ctor(CodeNamespace[] value)
public CodeNamespace get_Item(int index)
public void set_Item(int index, CodeNamespace value)
public int Add(CodeNamespace value)
public void AddRange(CodeNamespace[] value)
public void AddRange(CodeNamespaceCollection value)
public bool Contains(CodeNamespace value)
public void CopyTo(CodeNamespace[] array, int index)
public int IndexOf(CodeNamespace value)
public void Insert(int index, CodeNamespace value)
public void Remove(CodeNamespace value)
}
public System.CodeDom.CodeNamespaceImport : CodeObject {
private string _nameSpace
private CodeLinePragma <LinePragma>k__BackingField
public CodeLinePragma LinePragma
public string Namespace
public void .ctor(string nameSpace)
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public string get_Namespace()
public void set_Namespace(string value)
}
public System.CodeDom.CodeNamespaceImportCollection : object {
private ArrayList _data
private Dictionary`2<string, CodeNamespaceImport> _keys
public CodeNamespaceImport Item
public int Count
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public CodeNamespaceImport get_Item(int index)
public void set_Item(int index, CodeNamespaceImport value)
public int get_Count()
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
public void Add(CodeNamespaceImport value)
public void AddRange(CodeNamespaceImport[] value)
public void Clear()
private void SyncKeys()
public IEnumerator GetEnumerator()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
}
public System.CodeDom.CodeObject : object {
private IDictionary _userData
public IDictionary UserData
public IDictionary get_UserData()
}
public System.CodeDom.CodeObjectCreateExpression : CodeExpression {
private CodeTypeReference _createType
private CodeExpressionCollection <Parameters>k__BackingField
public CodeTypeReference CreateType
public CodeExpressionCollection Parameters
public void .ctor(CodeTypeReference createType, CodeExpression[] parameters)
public void .ctor(string createType, CodeExpression[] parameters)
public void .ctor(Type createType, CodeExpression[] parameters)
public CodeTypeReference get_CreateType()
public void set_CreateType(CodeTypeReference value)
public CodeExpressionCollection get_Parameters()
}
public System.CodeDom.CodeParameterDeclarationExpression : CodeExpression {
private CodeTypeReference _type
private string _name
private CodeAttributeDeclarationCollection _customAttributes
private FieldDirection <Direction>k__BackingField
public CodeAttributeDeclarationCollection CustomAttributes
public FieldDirection Direction
public CodeTypeReference Type
public string Name
public void .ctor(CodeTypeReference type, string name)
public void .ctor(string type, string name)
public void .ctor(Type type, string name)
public CodeAttributeDeclarationCollection get_CustomAttributes()
public void set_CustomAttributes(CodeAttributeDeclarationCollection value)
public FieldDirection get_Direction()
public void set_Direction(FieldDirection value)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
public string get_Name()
public void set_Name(string value)
}
public System.CodeDom.CodeParameterDeclarationExpressionCollection : CollectionBase {
public CodeParameterDeclarationExpression Item
public void .ctor(CodeParameterDeclarationExpressionCollection value)
public void .ctor(CodeParameterDeclarationExpression[] value)
public CodeParameterDeclarationExpression get_Item(int index)
public void set_Item(int index, CodeParameterDeclarationExpression value)
public int Add(CodeParameterDeclarationExpression value)
public void AddRange(CodeParameterDeclarationExpression[] value)
public void AddRange(CodeParameterDeclarationExpressionCollection value)
public bool Contains(CodeParameterDeclarationExpression value)
public void CopyTo(CodeParameterDeclarationExpression[] array, int index)
public int IndexOf(CodeParameterDeclarationExpression value)
public void Insert(int index, CodeParameterDeclarationExpression value)
public void Remove(CodeParameterDeclarationExpression value)
}
public System.CodeDom.CodePrimitiveExpression : CodeExpression {
private object <Value>k__BackingField
public object Value
public void .ctor(object value)
public object get_Value()
public void set_Value(object value)
}
public System.CodeDom.CodePropertyReferenceExpression : CodeExpression {
private string _propertyName
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public string PropertyName
public void .ctor(CodeExpression targetObject, string propertyName)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_PropertyName()
public void set_PropertyName(string value)
}
public System.CodeDom.CodeRegionDirective : CodeDirective {
private string _regionText
private CodeRegionMode <RegionMode>k__BackingField
public string RegionText
public CodeRegionMode RegionMode
public void .ctor(CodeRegionMode regionMode, string regionText)
public string get_RegionText()
public void set_RegionText(string value)
public CodeRegionMode get_RegionMode()
public void set_RegionMode(CodeRegionMode value)
}
public System.CodeDom.CodeRegionMode : Enum {
public int value__
public CodeRegionMode None
public CodeRegionMode Start
public CodeRegionMode End
}
public System.CodeDom.CodeRemoveEventStatement : CodeStatement {
private CodeEventReferenceExpression _eventRef
private CodeExpression <Listener>k__BackingField
public CodeEventReferenceExpression Event
public CodeExpression Listener
public void .ctor(CodeEventReferenceExpression eventRef, CodeExpression listener)
public void .ctor(CodeExpression targetObject, string eventName, CodeExpression listener)
public CodeEventReferenceExpression get_Event()
public void set_Event(CodeEventReferenceExpression value)
public CodeExpression get_Listener()
public void set_Listener(CodeExpression value)
}
public System.CodeDom.CodeSnippetCompileUnit : CodeCompileUnit {
private string _value
private CodeLinePragma <LinePragma>k__BackingField
public string Value
public CodeLinePragma LinePragma
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
}
public System.CodeDom.CodeSnippetExpression : CodeExpression {
private string _value
public string Value
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
}
public System.CodeDom.CodeSnippetStatement : CodeStatement {
private string _value
public string Value
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
}
public System.CodeDom.CodeSnippetTypeMember : CodeTypeMember {
private string _text
public string Text
public void .ctor(string text)
public string get_Text()
public void set_Text(string value)
}
public System.CodeDom.CodeStatement : CodeObject {
private CodeDirectiveCollection _startDirectives
private CodeDirectiveCollection _endDirectives
private CodeLinePragma <LinePragma>k__BackingField
public CodeLinePragma LinePragma
public CodeDirectiveCollection StartDirectives
public CodeDirectiveCollection EndDirectives
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public CodeDirectiveCollection get_StartDirectives()
public CodeDirectiveCollection get_EndDirectives()
}
public System.CodeDom.CodeStatementCollection : CollectionBase {
public CodeStatement Item
public void .ctor(CodeStatementCollection value)
public void .ctor(CodeStatement[] value)
public CodeStatement get_Item(int index)
public void set_Item(int index, CodeStatement value)
public int Add(CodeStatement value)
public int Add(CodeExpression value)
public void AddRange(CodeStatement[] value)
public void AddRange(CodeStatementCollection value)
public bool Contains(CodeStatement value)
public void CopyTo(CodeStatement[] array, int index)
public int IndexOf(CodeStatement value)
public void Insert(int index, CodeStatement value)
public void Remove(CodeStatement value)
}
public System.CodeDom.CodeThrowExceptionStatement : CodeStatement {
private CodeExpression <ToThrow>k__BackingField
public CodeExpression ToThrow
public void .ctor(CodeExpression toThrow)
public CodeExpression get_ToThrow()
public void set_ToThrow(CodeExpression value)
}
public System.CodeDom.CodeTryCatchFinallyStatement : CodeStatement {
private CodeStatementCollection <TryStatements>k__BackingField
private CodeCatchClauseCollection <CatchClauses>k__BackingField
private CodeStatementCollection <FinallyStatements>k__BackingField
public CodeStatementCollection TryStatements
public CodeCatchClauseCollection CatchClauses
public CodeStatementCollection FinallyStatements
public void .ctor(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses)
public void .ctor(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses, CodeStatement[] finallyStatements)
public CodeStatementCollection get_TryStatements()
public CodeCatchClauseCollection get_CatchClauses()
public CodeStatementCollection get_FinallyStatements()
}
public System.CodeDom.CodeTypeDeclaration : CodeTypeMember {
private CodeTypeReferenceCollection _baseTypes
private CodeTypeMemberCollection _members
private bool _isEnum
private bool _isStruct
private int _populated
private int BaseTypesCollection
private int MembersCollection
private CodeTypeParameterCollection _typeParameters
private EventHandler PopulateBaseTypes
private EventHandler PopulateMembers
private TypeAttributes <TypeAttributes>k__BackingField
private bool <IsPartial>k__BackingField
public TypeAttributes TypeAttributes
public CodeTypeReferenceCollection BaseTypes
public bool IsClass
public bool IsStruct
public bool IsEnum
public bool IsInterface
public bool IsPartial
public CodeTypeMemberCollection Members
public CodeTypeParameterCollection TypeParameters
public void add_PopulateBaseTypes(EventHandler value)
public void remove_PopulateBaseTypes(EventHandler value)
public void add_PopulateMembers(EventHandler value)
public void remove_PopulateMembers(EventHandler value)
public void .ctor(string name)
public TypeAttributes get_TypeAttributes()
public void set_TypeAttributes(TypeAttributes value)
public CodeTypeReferenceCollection get_BaseTypes()
public bool get_IsClass()
public void set_IsClass(bool value)
public bool get_IsStruct()
public void set_IsStruct(bool value)
public bool get_IsEnum()
public void set_IsEnum(bool value)
public bool get_IsInterface()
public void set_IsInterface(bool value)
public bool get_IsPartial()
public void set_IsPartial(bool value)
public CodeTypeMemberCollection get_Members()
public CodeTypeParameterCollection get_TypeParameters()
}
public System.CodeDom.CodeTypeDeclarationCollection : CollectionBase {
public CodeTypeDeclaration Item
public void .ctor(CodeTypeDeclarationCollection value)
public void .ctor(CodeTypeDeclaration[] value)
public CodeTypeDeclaration get_Item(int index)
public void set_Item(int index, CodeTypeDeclaration value)
public int Add(CodeTypeDeclaration value)
public void AddRange(CodeTypeDeclaration[] value)
public void AddRange(CodeTypeDeclarationCollection value)
public bool Contains(CodeTypeDeclaration value)
public void CopyTo(CodeTypeDeclaration[] array, int index)
public int IndexOf(CodeTypeDeclaration value)
public void Insert(int index, CodeTypeDeclaration value)
public void Remove(CodeTypeDeclaration value)
}
public System.CodeDom.CodeTypeDelegate : CodeTypeDeclaration {
private CodeTypeReference _returnType
private CodeParameterDeclarationExpressionCollection <Parameters>k__BackingField
public CodeTypeReference ReturnType
public CodeParameterDeclarationExpressionCollection Parameters
public void .ctor(string name)
public CodeTypeReference get_ReturnType()
public void set_ReturnType(CodeTypeReference value)
public CodeParameterDeclarationExpressionCollection get_Parameters()
}
public System.CodeDom.CodeTypeMember : CodeObject {
private string _name
private CodeAttributeDeclarationCollection _customAttributes
private CodeDirectiveCollection _startDirectives
private CodeDirectiveCollection _endDirectives
private MemberAttributes <Attributes>k__BackingField
private CodeLinePragma <LinePragma>k__BackingField
private CodeCommentStatementCollection <Comments>k__BackingField
public string Name
public MemberAttributes Attributes
public CodeAttributeDeclarationCollection CustomAttributes
public CodeLinePragma LinePragma
public CodeCommentStatementCollection Comments
public CodeDirectiveCollection StartDirectives
public CodeDirectiveCollection EndDirectives
public string get_Name()
public void set_Name(string value)
public MemberAttributes get_Attributes()
public void set_Attributes(MemberAttributes value)
public CodeAttributeDeclarationCollection get_CustomAttributes()
public void set_CustomAttributes(CodeAttributeDeclarationCollection value)
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public CodeCommentStatementCollection get_Comments()
public CodeDirectiveCollection get_StartDirectives()
public CodeDirectiveCollection get_EndDirectives()
}
public System.CodeDom.CodeTypeMemberCollection : CollectionBase {
public CodeTypeMember Item
public void .ctor(CodeTypeMemberCollection value)
public void .ctor(CodeTypeMember[] value)
public CodeTypeMember get_Item(int index)
public void set_Item(int index, CodeTypeMember value)
public int Add(CodeTypeMember value)
public void AddRange(CodeTypeMember[] value)
public void AddRange(CodeTypeMemberCollection value)
public bool Contains(CodeTypeMember value)
public void CopyTo(CodeTypeMember[] array, int index)
public int IndexOf(CodeTypeMember value)
public void Insert(int index, CodeTypeMember value)
public void Remove(CodeTypeMember value)
}
public System.CodeDom.CodeTypeOfExpression : CodeExpression {
private CodeTypeReference _type
public CodeTypeReference Type
public void .ctor(CodeTypeReference type)
public void .ctor(string type)
public void .ctor(Type type)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
}
public System.CodeDom.CodeTypeParameter : CodeObject {
private string _name
private CodeAttributeDeclarationCollection _customAttributes
private CodeTypeReferenceCollection _constraints
private bool <HasConstructorConstraint>k__BackingField
public string Name
public CodeTypeReferenceCollection Constraints
public CodeAttributeDeclarationCollection CustomAttributes
public bool HasConstructorConstraint
public void .ctor(string name)
public string get_Name()
public void set_Name(string value)
public CodeTypeReferenceCollection get_Constraints()
public CodeAttributeDeclarationCollection get_CustomAttributes()
public bool get_HasConstructorConstraint()
public void set_HasConstructorConstraint(bool value)
}
public System.CodeDom.CodeTypeParameterCollection : CollectionBase {
public CodeTypeParameter Item
public void .ctor(CodeTypeParameterCollection value)
public void .ctor(CodeTypeParameter[] value)
public CodeTypeParameter get_Item(int index)
public void set_Item(int index, CodeTypeParameter value)
public int Add(CodeTypeParameter value)
public void Add(string value)
public void AddRange(CodeTypeParameter[] value)
public void AddRange(CodeTypeParameterCollection value)
public bool Contains(CodeTypeParameter value)
public void CopyTo(CodeTypeParameter[] array, int index)
public int IndexOf(CodeTypeParameter value)
public void Insert(int index, CodeTypeParameter value)
public void Remove(CodeTypeParameter value)
}
public System.CodeDom.CodeTypeReference : CodeObject {
private string _baseType
private bool _isInterface
private CodeTypeReferenceCollection _typeArguments
private bool _needsFixup
private CodeTypeReference <ArrayElementType>k__BackingField
private int <ArrayRank>k__BackingField
private CodeTypeReferenceOptions <Options>k__BackingField
public CodeTypeReference ArrayElementType
public int ArrayRank
internal int NestedArrayDepth
public string BaseType
public CodeTypeReferenceOptions Options
public CodeTypeReferenceCollection TypeArguments
internal bool IsInterface
public void .ctor(Type type)
public void .ctor(Type type, CodeTypeReferenceOptions codeTypeReferenceOption)
public void .ctor(string typeName, CodeTypeReferenceOptions codeTypeReferenceOption)
public void .ctor(string typeName)
private void InitializeFromType(Type type)
private void Initialize(string typeName)
private void Initialize(string typeName, CodeTypeReferenceOptions options)
public void .ctor(string typeName, CodeTypeReference[] typeArguments)
public void .ctor(CodeTypeParameter typeParameter)
public void .ctor(string baseType, int rank)
public void .ctor(CodeTypeReference arrayType, int rank)
public CodeTypeReference get_ArrayElementType()
public void set_ArrayElementType(CodeTypeReference value)
public int get_ArrayRank()
public void set_ArrayRank(int value)
internal int get_NestedArrayDepth()
public string get_BaseType()
public void set_BaseType(string value)
public CodeTypeReferenceOptions get_Options()
public void set_Options(CodeTypeReferenceOptions value)
public CodeTypeReferenceCollection get_TypeArguments()
internal bool get_IsInterface()
private string RipOffAssemblyInformationFromTypeName(string typeName)
}
public System.CodeDom.CodeTypeReferenceCollection : CollectionBase {
public CodeTypeReference Item
public void .ctor(CodeTypeReferenceCollection value)
public void .ctor(CodeTypeReference[] value)
public CodeTypeReference get_Item(int index)
public void set_Item(int index, CodeTypeReference value)
public int Add(CodeTypeReference value)
public void Add(string value)
public void Add(Type value)
public void AddRange(CodeTypeReference[] value)
public void AddRange(CodeTypeReferenceCollection value)
public bool Contains(CodeTypeReference value)
public void CopyTo(CodeTypeReference[] array, int index)
public int IndexOf(CodeTypeReference value)
public void Insert(int index, CodeTypeReference value)
public void Remove(CodeTypeReference value)
}
public System.CodeDom.CodeTypeReferenceExpression : CodeExpression {
private CodeTypeReference _type
public CodeTypeReference Type
public void .ctor(CodeTypeReference type)
public void .ctor(string type)
public void .ctor(Type type)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
}
public System.CodeDom.CodeTypeReferenceOptions : Enum {
public int value__
public CodeTypeReferenceOptions GlobalReference
public CodeTypeReferenceOptions GenericTypeParameter
}
public System.CodeDom.CodeVariableDeclarationStatement : CodeStatement {
private CodeTypeReference _type
private string _name
private CodeExpression <InitExpression>k__BackingField
public CodeExpression InitExpression
public string Name
public CodeTypeReference Type
public void .ctor(CodeTypeReference type, string name)
public void .ctor(string type, string name)
public void .ctor(Type type, string name)
public void .ctor(CodeTypeReference type, string name, CodeExpression initExpression)
public void .ctor(string type, string name, CodeExpression initExpression)
public void .ctor(Type type, string name, CodeExpression initExpression)
public CodeExpression get_InitExpression()
public void set_InitExpression(CodeExpression value)
public string get_Name()
public void set_Name(string value)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
}
public System.CodeDom.CodeVariableReferenceExpression : CodeExpression {
private string _variableName
public string VariableName
public void .ctor(string variableName)
public string get_VariableName()
public void set_VariableName(string value)
}
public System.CodeDom.Compiler.CodeCompiler : CodeGenerator {
protected string FileExtension
protected string CompilerName
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
protected string get_FileExtension()
protected string get_CompilerName()
protected CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e)
protected CompilerResults FromFile(CompilerParameters options, string fileName)
protected CompilerResults FromSource(CompilerParameters options, string source)
protected CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
private void ResolveReferencedAssemblies(CompilerParameters options, CodeCompileUnit e)
protected CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames)
protected void ProcessCompilerOutputLine(CompilerResults results, string line)
protected string CmdArgsFromParameters(CompilerParameters options)
protected string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs)
protected CompilerResults FromSourceBatch(CompilerParameters options, String[] sources)
protected string JoinStringArray(String[] sa, string separator)
}
internal System.CodeDom.Compiler.CodeDomConfigurationHandler : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty compilersProp
private CompilerCollection default_compilers
public CompilerCollection Compilers
public CompilerInfo[] CompilerInfos
protected ConfigurationPropertyCollection Properties
protected void InitializeDefault()
protected void PostDeserialize()
protected object GetRuntimeObject()
public CompilerCollection get_Compilers()
public CompilerInfo[] get_CompilerInfos()
protected ConfigurationPropertyCollection get_Properties()
}
public System.CodeDom.Compiler.CodeDomProvider : Component {
private Dictionary`2<string, CompilerInfo> s_compilerLanguages
private Dictionary`2<string, CompilerInfo> s_compilerExtensions
private List`1<CompilerInfo> s_allCompilerInfo
public string FileExtension
public LanguageOptions LanguageOptions
private void AddCompilerInfo(CompilerInfo compilerInfo)
public CodeDomProvider CreateProvider(string language, IDictionary`2<string, string> providerOptions)
public CodeDomProvider CreateProvider(string language)
public string GetLanguageFromExtension(string extension)
public bool IsDefinedLanguage(string language)
public bool IsDefinedExtension(string extension)
public CompilerInfo GetCompilerInfo(string language)
private CompilerInfo GetCompilerInfoForLanguageNoThrow(string language)
private CompilerInfo GetCompilerInfoForExtensionNoThrow(string extension)
public CompilerInfo[] GetAllCompilerInfo()
public string get_FileExtension()
public LanguageOptions get_LanguageOptions()
public ICodeGenerator CreateGenerator()
public ICodeGenerator CreateGenerator(TextWriter output)
public ICodeGenerator CreateGenerator(string fileName)
public ICodeCompiler CreateCompiler()
public ICodeParser CreateParser()
public TypeConverter GetConverter(Type type)
public CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit[] compilationUnits)
public CompilerResults CompileAssemblyFromFile(CompilerParameters options, String[] fileNames)
public CompilerResults CompileAssemblyFromSource(CompilerParameters options, String[] sources)
public bool IsValidIdentifier(string value)
public string CreateEscapedIdentifier(string value)
public string CreateValidIdentifier(string value)
public string GetTypeOutput(CodeTypeReference type)
public bool Supports(GeneratorSupport generatorSupport)
public void GenerateCodeFromExpression(CodeExpression expression, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromStatement(CodeStatement statement, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromNamespace(CodeNamespace codeNamespace, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromCompileUnit(CodeCompileUnit compileUnit, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromType(CodeTypeDeclaration codeType, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
public CodeCompileUnit Parse(TextReader codeStream)
private ICodeCompiler CreateCompilerHelper()
private ICodeGenerator CreateGeneratorHelper()
private ICodeParser CreateParserHelper()
}
public System.CodeDom.Compiler.CodeGenerator : object {
private int ParameterMultilineThreshold
private ExposedTabStringIndentedTextWriter _output
private CodeGeneratorOptions _options
private CodeTypeDeclaration _currentClass
private CodeTypeMember _currentMember
private bool _inNestedBinary
protected CodeTypeDeclaration CurrentClass
protected string CurrentTypeName
protected CodeTypeMember CurrentMember
protected string CurrentMemberName
protected bool IsCurrentInterface
protected bool IsCurrentClass
protected bool IsCurrentStruct
protected bool IsCurrentEnum
protected bool IsCurrentDelegate
protected int Indent
protected string NullToken
protected TextWriter Output
protected CodeGeneratorOptions Options
protected CodeTypeDeclaration get_CurrentClass()
protected string get_CurrentTypeName()
protected CodeTypeMember get_CurrentMember()
protected string get_CurrentMemberName()
protected bool get_IsCurrentInterface()
protected bool get_IsCurrentClass()
protected bool get_IsCurrentStruct()
protected bool get_IsCurrentEnum()
protected bool get_IsCurrentDelegate()
protected int get_Indent()
protected void set_Indent(int value)
protected string get_NullToken()
protected TextWriter get_Output()
protected CodeGeneratorOptions get_Options()
private void GenerateType(CodeTypeDeclaration e)
protected void GenerateDirectives(CodeDirectiveCollection directives)
private void GenerateTypeMember(CodeTypeMember member, CodeTypeDeclaration declaredType)
private void GenerateTypeConstructors(CodeTypeDeclaration e)
protected void GenerateNamespaces(CodeCompileUnit e)
protected void GenerateTypes(CodeNamespace e)
private bool System.CodeDom.Compiler.ICodeGenerator.Supports(GeneratorSupport support)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
private bool System.CodeDom.Compiler.ICodeGenerator.IsValidIdentifier(string value)
private void System.CodeDom.Compiler.ICodeGenerator.ValidateIdentifier(string value)
private string System.CodeDom.Compiler.ICodeGenerator.CreateEscapedIdentifier(string value)
private string System.CodeDom.Compiler.ICodeGenerator.CreateValidIdentifier(string value)
private string System.CodeDom.Compiler.ICodeGenerator.GetTypeOutput(CodeTypeReference type)
private void GenerateConstructors(CodeTypeDeclaration e)
private void GenerateEvents(CodeTypeDeclaration e)
protected void GenerateExpression(CodeExpression e)
private void GenerateFields(CodeTypeDeclaration e)
private void GenerateSnippetMembers(CodeTypeDeclaration e)
protected void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e)
private void GenerateMethods(CodeTypeDeclaration e)
private void GenerateNestedTypes(CodeTypeDeclaration e)
protected void GenerateCompileUnit(CodeCompileUnit e)
protected void GenerateNamespace(CodeNamespace e)
protected void GenerateNamespaceImports(CodeNamespace e)
private void GenerateProperties(CodeTypeDeclaration e)
protected void GenerateStatement(CodeStatement e)
protected void GenerateStatements(CodeStatementCollection stmts)
protected void OutputAttributeDeclarations(CodeAttributeDeclarationCollection attributes)
protected void OutputAttributeArgument(CodeAttributeArgument arg)
protected void OutputDirection(FieldDirection dir)
protected void OutputFieldScopeModifier(MemberAttributes attributes)
protected void OutputMemberAccessModifier(MemberAttributes attributes)
protected void OutputMemberScopeModifier(MemberAttributes attributes)
protected void OutputType(CodeTypeReference typeRef)
protected void OutputTypeAttributes(TypeAttributes attributes, bool isStruct, bool isEnum)
protected void OutputTypeNamePair(CodeTypeReference typeRef, string name)
protected void OutputIdentifier(string ident)
protected void OutputExpressionList(CodeExpressionCollection expressions)
protected void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems)
protected void OutputOperator(CodeBinaryOperatorType op)
protected void OutputParameters(CodeParameterDeclarationExpressionCollection parameters)
protected void GenerateArrayCreateExpression(CodeArrayCreateExpression e)
protected void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e)
protected void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
protected void ContinueOnNewLine(string st)
protected void GenerateCastExpression(CodeCastExpression e)
protected void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e)
protected void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e)
protected void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
protected void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e)
protected void GenerateIndexerExpression(CodeIndexerExpression e)
protected void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e)
protected void GenerateSnippetExpression(CodeSnippetExpression e)
protected void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e)
protected void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e)
protected void GenerateEventReferenceExpression(CodeEventReferenceExpression e)
protected void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
protected void GenerateObjectCreateExpression(CodeObjectCreateExpression e)
protected void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
protected void GenerateDirectionExpression(CodeDirectionExpression e)
protected void GeneratePrimitiveExpression(CodePrimitiveExpression e)
protected void GenerateSingleFloatValue(float s)
protected void GenerateDoubleValue(double d)
protected void GenerateDecimalValue(decimal d)
protected void GenerateDefaultValueExpression(CodeDefaultValueExpression e)
protected void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e)
protected void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
protected void GenerateThisReferenceExpression(CodeThisReferenceExpression e)
protected void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e)
protected void GenerateTypeOfExpression(CodeTypeOfExpression e)
protected void GenerateExpressionStatement(CodeExpressionStatement e)
protected void GenerateIterationStatement(CodeIterationStatement e)
protected void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e)
protected void GenerateCommentStatement(CodeCommentStatement e)
protected void GenerateCommentStatements(CodeCommentStatementCollection e)
protected void GenerateComment(CodeComment e)
protected void GenerateMethodReturnStatement(CodeMethodReturnStatement e)
protected void GenerateConditionStatement(CodeConditionStatement e)
protected void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e)
protected void GenerateAssignStatement(CodeAssignStatement e)
protected void GenerateAttachEventStatement(CodeAttachEventStatement e)
protected void GenerateRemoveEventStatement(CodeRemoveEventStatement e)
protected void GenerateGotoStatement(CodeGotoStatement e)
protected void GenerateLabeledStatement(CodeLabeledStatement e)
protected void GenerateSnippetStatement(CodeSnippetStatement e)
protected void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
protected void GenerateLinePragmaStart(CodeLinePragma e)
protected void GenerateLinePragmaEnd(CodeLinePragma e)
protected void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c)
protected void GenerateField(CodeMemberField e)
protected void GenerateSnippetMember(CodeSnippetTypeMember e)
protected void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c)
protected void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c)
protected void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c)
protected void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c)
protected void GenerateTypeConstructor(CodeTypeConstructor e)
protected void GenerateTypeStart(CodeTypeDeclaration e)
protected void GenerateTypeEnd(CodeTypeDeclaration e)
protected void GenerateCompileUnitStart(CodeCompileUnit e)
protected void GenerateCompileUnitEnd(CodeCompileUnit e)
protected void GenerateNamespaceStart(CodeNamespace e)
protected void GenerateNamespaceEnd(CodeNamespace e)
protected void GenerateNamespaceImport(CodeNamespaceImport e)
protected void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
protected void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
protected bool Supports(GeneratorSupport support)
protected bool IsValidIdentifier(string value)
protected void ValidateIdentifier(string value)
protected string CreateEscapedIdentifier(string value)
protected string CreateValidIdentifier(string value)
protected string GetTypeOutput(CodeTypeReference value)
protected string QuoteSnippetString(string value)
public bool IsValidLanguageIndependentIdentifier(string value)
internal bool IsValidLanguageIndependentTypeName(string value)
public void ValidateIdentifiers(CodeObject e)
}
public System.CodeDom.Compiler.CodeGeneratorOptions : object {
private IDictionary _options
public object Item
public string IndentString
public string BracingStyle
public bool ElseOnClosing
public bool BlankLinesBetweenMembers
public bool VerbatimOrder
public object get_Item(string index)
public void set_Item(string index, object value)
public string get_IndentString()
public void set_IndentString(string value)
public string get_BracingStyle()
public void set_BracingStyle(string value)
public bool get_ElseOnClosing()
public void set_ElseOnClosing(bool value)
public bool get_BlankLinesBetweenMembers()
public void set_BlankLinesBetweenMembers(bool value)
public bool get_VerbatimOrder()
public void set_VerbatimOrder(bool value)
}
public System.CodeDom.Compiler.CodeParser : object {
public CodeCompileUnit Parse(TextReader codeStream)
}
internal System.CodeDom.Compiler.CodeValidator : object {
private Char[] s_newLineChars
private CodeTypeDeclaration _currentClass
private bool IsCurrentInterface
private bool IsCurrentEnum
private bool IsCurrentDelegate
internal void ValidateIdentifiers(CodeObject e)
private void ValidateTypeMember(CodeTypeMember e)
private void ValidateCodeCompileUnit(CodeCompileUnit e)
private void ValidateSnippetCompileUnit(CodeSnippetCompileUnit e)
private void ValidateCompileUnitStart(CodeCompileUnit e)
private void ValidateCompileUnitEnd(CodeCompileUnit e)
private void ValidateNamespaces(CodeCompileUnit e)
private void ValidateNamespace(CodeNamespace e)
private void ValidateNamespaceStart(CodeNamespace e)
private void ValidateNamespaceImports(CodeNamespace e)
private void ValidateNamespaceImport(CodeNamespaceImport e)
private void ValidateAttributes(CodeAttributeDeclarationCollection attributes)
private void ValidateAttributeArgument(CodeAttributeArgument arg)
private void ValidateTypes(CodeNamespace e)
private void ValidateTypeDeclaration(CodeTypeDeclaration e)
private void ValidateTypeMembers(CodeTypeDeclaration e)
private void ValidateTypeParameters(CodeTypeParameterCollection parameters)
private void ValidateTypeParameter(CodeTypeParameter e)
private void ValidateField(CodeMemberField e)
private void ValidateConstructor(CodeConstructor e)
private void ValidateProperty(CodeMemberProperty e)
private void ValidateMemberMethod(CodeMemberMethod e)
private void ValidateTypeConstructor(CodeTypeConstructor e)
private void ValidateMethod(CodeMemberMethod e)
private void ValidateSnippetMember(CodeSnippetTypeMember e)
private void ValidateTypeStart(CodeTypeDeclaration e)
private void ValidateCommentStatements(CodeCommentStatementCollection e)
private void ValidateCommentStatement(CodeCommentStatement e)
private void ValidateComment(CodeComment e)
private void ValidateStatement(CodeStatement e)
private void ValidateStatements(CodeStatementCollection stmts)
private void ValidateExpressionStatement(CodeExpressionStatement e)
private void ValidateIterationStatement(CodeIterationStatement e)
private void ValidateThrowExceptionStatement(CodeThrowExceptionStatement e)
private void ValidateMethodReturnStatement(CodeMethodReturnStatement e)
private void ValidateConditionStatement(CodeConditionStatement e)
private void ValidateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e)
private void ValidateAssignStatement(CodeAssignStatement e)
private void ValidateAttachEventStatement(CodeAttachEventStatement e)
private void ValidateRemoveEventStatement(CodeRemoveEventStatement e)
private void ValidateGotoStatement(CodeGotoStatement e)
private void ValidateLabeledStatement(CodeLabeledStatement e)
private void ValidateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
private void ValidateLinePragmaStart(CodeLinePragma e)
private void ValidateEvent(CodeMemberEvent e)
private void ValidateParameters(CodeParameterDeclarationExpressionCollection parameters)
private void ValidateSnippetStatement(CodeSnippetStatement e)
private void ValidateExpressionList(CodeExpressionCollection expressions)
private void ValidateTypeReference(CodeTypeReference e)
private void ValidateTypeReferences(CodeTypeReferenceCollection refs)
private void ValidateArity(CodeTypeReference e)
private void ValidateTypeName(object e, string propertyName, string typeName)
private void ValidateIdentifier(object e, string propertyName, string identifier)
private void ValidateExpression(CodeExpression e)
private void ValidateArrayCreateExpression(CodeArrayCreateExpression e)
private void ValidateBaseReferenceExpression(CodeBaseReferenceExpression e)
private void ValidateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
private void ValidateCastExpression(CodeCastExpression e)
private void ValidateDefaultValueExpression(CodeDefaultValueExpression e)
private void ValidateDelegateCreateExpression(CodeDelegateCreateExpression e)
private void ValidateFieldReferenceExpression(CodeFieldReferenceExpression e)
private void ValidateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
private void ValidateVariableReferenceExpression(CodeVariableReferenceExpression e)
private void ValidateIndexerExpression(CodeIndexerExpression e)
private void ValidateArrayIndexerExpression(CodeArrayIndexerExpression e)
private void ValidateSnippetExpression(CodeSnippetExpression e)
private void ValidateMethodInvokeExpression(CodeMethodInvokeExpression e)
private void ValidateMethodReferenceExpression(CodeMethodReferenceExpression e)
private void ValidateEventReferenceExpression(CodeEventReferenceExpression e)
private void ValidateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
private void ValidateObjectCreateExpression(CodeObjectCreateExpression e)
private void ValidateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
private void ValidateDirectionExpression(CodeDirectionExpression e)
private void ValidatePrimitiveExpression(CodePrimitiveExpression e)
private void ValidatePropertyReferenceExpression(CodePropertyReferenceExpression e)
private void ValidatePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
private void ValidateThisReferenceExpression(CodeThisReferenceExpression e)
private void ValidateTypeOfExpression(CodeTypeOfExpression e)
private void ValidateCodeDirectives(CodeDirectiveCollection e)
private void ValidateCodeDirective(CodeDirective e)
private void ValidateChecksumPragma(CodeChecksumPragma e)
private void ValidateRegionDirective(CodeRegionDirective e)
private bool get_IsCurrentInterface()
private bool get_IsCurrentEnum()
private bool get_IsCurrentDelegate()
}
internal System.CodeDom.Compiler.Compiler : ConfigurationElement {
private ConfigurationProperty compilerOptionsProp
private ConfigurationProperty extensionProp
private ConfigurationProperty languageProp
private ConfigurationProperty typeProp
private ConfigurationProperty warningLevelProp
private ConfigurationProperty providerOptionsProp
private ConfigurationPropertyCollection properties
public string CompilerOptions
public string Extension
public string Language
public string Type
public int WarningLevel
public CompilerProviderOptionsCollection ProviderOptions
public Dictionary`2<string, string> ProviderOptionsDictionary
protected ConfigurationPropertyCollection Properties
public void .ctor(string compilerOptions, string extension, string language, string type, int warningLevel)
public string get_CompilerOptions()
internal void set_CompilerOptions(string value)
public string get_Extension()
internal void set_Extension(string value)
public string get_Language()
internal void set_Language(string value)
public string get_Type()
internal void set_Type(string value)
public int get_WarningLevel()
internal void set_WarningLevel(int value)
public CompilerProviderOptionsCollection get_ProviderOptions()
internal void set_ProviderOptions(CompilerProviderOptionsCollection value)
public Dictionary`2<string, string> get_ProviderOptionsDictionary()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.CodeDom.Compiler.CompilerCollection : ConfigurationElementCollection {
private string defaultCompilerVersion
private ConfigurationPropertyCollection properties
private List`1<CompilerInfo> compiler_infos
private Dictionary`2<string, CompilerInfo> compiler_languages
private Dictionary`2<string, CompilerInfo> compiler_extensions
protected bool ThrowOnDuplicate
public String[] AllKeys
public ConfigurationElementCollectionType CollectionType
protected string ElementName
protected ConfigurationPropertyCollection Properties
public Compiler Item
public CompilerInfo Item
public CompilerInfo[] CompilerInfos
private void AddCompilerInfo(CompilerInfo ci)
private void AddCompilerInfo(Compiler compiler)
protected void BaseAdd(ConfigurationElement element)
protected bool get_ThrowOnDuplicate()
protected ConfigurationElement CreateNewElement()
public CompilerInfo GetCompilerInfoForLanguage(string language)
public CompilerInfo GetCompilerInfoForExtension(string extension)
public string GetLanguageFromExtension(string extension)
public Compiler Get(int index)
public Compiler Get(string language)
protected object GetElementKey(ConfigurationElement element)
public string GetKey(int index)
public String[] get_AllKeys()
public ConfigurationElementCollectionType get_CollectionType()
protected string get_ElementName()
protected ConfigurationPropertyCollection get_Properties()
public Compiler get_Item(int index)
public CompilerInfo get_Item(string language)
public CompilerInfo[] get_CompilerInfos()
}
public System.CodeDom.Compiler.CompilerError : object {
private int <Line>k__BackingField
private int <Column>k__BackingField
private string <ErrorNumber>k__BackingField
private string <ErrorText>k__BackingField
private bool <IsWarning>k__BackingField
private string <FileName>k__BackingField
public int Line
public int Column
public string ErrorNumber
public string ErrorText
public bool IsWarning
public string FileName
private string WarningString
public void .ctor(string fileName, int line, int column, string errorNumber, string errorText)
public int get_Line()
public void set_Line(int value)
public int get_Column()
public void set_Column(int value)
public string get_ErrorNumber()
public void set_ErrorNumber(string value)
public string get_ErrorText()
public void set_ErrorText(string value)
public bool get_IsWarning()
public void set_IsWarning(bool value)
public string get_FileName()
public void set_FileName(string value)
public string ToString()
private string get_WarningString()
}
public System.CodeDom.Compiler.CompilerErrorCollection : CollectionBase {
public CompilerError Item
public bool HasErrors
public bool HasWarnings
public void .ctor(CompilerErrorCollection value)
public void .ctor(CompilerError[] value)
public CompilerError get_Item(int index)
public void set_Item(int index, CompilerError value)
public int Add(CompilerError value)
public void AddRange(CompilerError[] value)
public void AddRange(CompilerErrorCollection value)
public bool Contains(CompilerError value)
public void CopyTo(CompilerError[] array, int index)
public bool get_HasErrors()
public bool get_HasWarnings()
public int IndexOf(CompilerError value)
public void Insert(int index, CompilerError value)
public void Remove(CompilerError value)
}
public System.CodeDom.Compiler.CompilerInfo : object {
internal IDictionary`2<string, string> _providerOptions
internal string _codeDomProviderTypeName
internal CompilerParameters _compilerParams
internal String[] _compilerLanguages
internal String[] _compilerExtensions
private Type _type
public Type CodeDomProviderType
public bool IsCodeDomProviderTypeValid
internal CompilerParameters CompilerParams
internal IDictionary`2<string, string> ProviderOptions
public String[] GetLanguages()
public String[] GetExtensions()
public Type get_CodeDomProviderType()
public bool get_IsCodeDomProviderTypeValid()
public CodeDomProvider CreateProvider()
public CodeDomProvider CreateProvider(IDictionary`2<string, string> providerOptions)
public CompilerParameters CreateDefaultCompilerParameters()
internal void .ctor(CompilerParameters compilerParams, string codeDomProviderTypeName, String[] compilerLanguages, String[] compilerExtensions)
internal void .ctor(CompilerParameters compilerParams, string codeDomProviderTypeName)
public int GetHashCode()
public bool Equals(object o)
private CompilerParameters CloneCompilerParameters()
private String[] CloneCompilerLanguages()
private String[] CloneCompilerExtensions()
internal CompilerParameters get_CompilerParams()
internal IDictionary`2<string, string> get_ProviderOptions()
}
public System.CodeDom.Compiler.CompilerParameters : object {
private Evidence _evidence
private StringCollection _assemblyNames
private StringCollection _embeddedResources
private StringCollection _linkedResources
private TempFileCollection _tempFiles
private string <CoreAssemblyFileName>k__BackingField
private bool <GenerateExecutable>k__BackingField
private bool <GenerateInMemory>k__BackingField
private string <MainClass>k__BackingField
private string <OutputAssembly>k__BackingField
private bool <IncludeDebugInformation>k__BackingField
private bool <TreatWarningsAsErrors>k__BackingField
private int <WarningLevel>k__BackingField
private string <CompilerOptions>k__BackingField
private string <Win32Resource>k__BackingField
private IntPtr <UserToken>k__BackingField
public Evidence Evidence
public string CoreAssemblyFileName
public bool GenerateExecutable
public bool GenerateInMemory
public StringCollection ReferencedAssemblies
public string MainClass
public string OutputAssembly
public TempFileCollection TempFiles
public bool IncludeDebugInformation
public bool TreatWarningsAsErrors
public int WarningLevel
public string CompilerOptions
public string Win32Resource
public StringCollection EmbeddedResources
public StringCollection LinkedResources
public IntPtr UserToken
public Evidence get_Evidence()
public void set_Evidence(Evidence value)
public void .ctor(String[] assemblyNames)
public void .ctor(String[] assemblyNames, string outputName)
public void .ctor(String[] assemblyNames, string outputName, bool includeDebugInformation)
public string get_CoreAssemblyFileName()
public void set_CoreAssemblyFileName(string value)
public bool get_GenerateExecutable()
public void set_GenerateExecutable(bool value)
public bool get_GenerateInMemory()
public void set_GenerateInMemory(bool value)
public StringCollection get_ReferencedAssemblies()
public string get_MainClass()
public void set_MainClass(string value)
public string get_OutputAssembly()
public void set_OutputAssembly(string value)
public TempFileCollection get_TempFiles()
public void set_TempFiles(TempFileCollection value)
public bool get_IncludeDebugInformation()
public void set_IncludeDebugInformation(bool value)
public bool get_TreatWarningsAsErrors()
public void set_TreatWarningsAsErrors(bool value)
public int get_WarningLevel()
public void set_WarningLevel(int value)
public string get_CompilerOptions()
public void set_CompilerOptions(string value)
public string get_Win32Resource()
public void set_Win32Resource(string value)
public StringCollection get_EmbeddedResources()
public StringCollection get_LinkedResources()
public IntPtr get_UserToken()
public void set_UserToken(IntPtr value)
}
internal System.CodeDom.Compiler.CompilerProviderOption : ConfigurationElement {
private ConfigurationProperty nameProp
private ConfigurationProperty valueProp
private ConfigurationPropertyCollection properties
public string Name
public string Value
protected ConfigurationPropertyCollection Properties
public string get_Name()
public void set_Name(string value)
public string get_Value()
public void set_Value(string value)
protected ConfigurationPropertyCollection get_Properties()
}
internal System.CodeDom.Compiler.CompilerProviderOptionsCollection : ConfigurationElementCollection {
private ConfigurationPropertyCollection properties
public String[] AllKeys
protected string ElementName
protected ConfigurationPropertyCollection Properties
public Dictionary`2<string, string> ProviderOptions
public CompilerProviderOption Item
public CompilerProviderOption Item
protected ConfigurationElement CreateNewElement()
public CompilerProviderOption Get(int index)
public CompilerProviderOption Get(string name)
protected object GetElementKey(ConfigurationElement element)
public string GetKey(int index)
public String[] get_AllKeys()
protected string get_ElementName()
protected ConfigurationPropertyCollection get_Properties()
public Dictionary`2<string, string> get_ProviderOptions()
public CompilerProviderOption get_Item(int index)
public CompilerProviderOption get_Item(string name)
}
public System.CodeDom.Compiler.CompilerResults : object {
private Evidence _evidence
private CompilerErrorCollection _errors
private StringCollection _output
private Assembly _compiledAssembly
private TempFileCollection _tempFiles
private string <PathToAssembly>k__BackingField
private int <NativeCompilerReturnValue>k__BackingField
public Evidence Evidence
public TempFileCollection TempFiles
public Assembly CompiledAssembly
public CompilerErrorCollection Errors
public StringCollection Output
public string PathToAssembly
public int NativeCompilerReturnValue
public Evidence get_Evidence()
public void set_Evidence(Evidence value)
public void .ctor(TempFileCollection tempFiles)
public TempFileCollection get_TempFiles()
public void set_TempFiles(TempFileCollection value)
public Assembly get_CompiledAssembly()
public void set_CompiledAssembly(Assembly value)
public CompilerErrorCollection get_Errors()
public StringCollection get_Output()
public string get_PathToAssembly()
public void set_PathToAssembly(string value)
public int get_NativeCompilerReturnValue()
public void set_NativeCompilerReturnValue(int value)
}
public System.CodeDom.Compiler.Executor : object {
public void ExecWait(string cmd, TempFileCollection tempFiles)
public int ExecWaitWithCapture(IntPtr userToken, string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName)
public int ExecWaitWithCapture(IntPtr userToken, string cmd, TempFileCollection tempFiles, String& outputName, String& errorName)
public int ExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName)
public int ExecWaitWithCapture(string cmd, TempFileCollection tempFiles, String& outputName, String& errorName)
private int InternalExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName)
}
internal System.CodeDom.Compiler.ExposedTabStringIndentedTextWriter : IndentedTextWriter {
private string <TabString>k__BackingField
internal string TabString
public void .ctor(TextWriter writer, string tabString)
internal void InternalOutputTabs()
internal string get_TabString()
}
public System.CodeDom.Compiler.GeneratedCodeAttribute : Attribute {
private string tool
private string version
public string Tool
public string Version
public void .ctor(string tool, string version)
public string get_Tool()
public string get_Version()
}
public System.CodeDom.Compiler.GeneratorSupport : Enum {
public int value__
public GeneratorSupport ArraysOfArrays
public GeneratorSupport EntryPointMethod
public GeneratorSupport GotoStatements
public GeneratorSupport MultidimensionalArrays
public GeneratorSupport StaticConstructors
public GeneratorSupport TryCatchStatements
public GeneratorSupport ReturnTypeAttributes
public GeneratorSupport DeclareValueTypes
public GeneratorSupport DeclareEnums
public GeneratorSupport DeclareDelegates
public GeneratorSupport DeclareInterfaces
public GeneratorSupport DeclareEvents
public GeneratorSupport AssemblyAttributes
public GeneratorSupport ParameterAttributes
public GeneratorSupport ReferenceParameters
public GeneratorSupport ChainedConstructorArguments
public GeneratorSupport NestedTypes
public GeneratorSupport MultipleInterfaceMembers
public GeneratorSupport PublicStaticMembers
public GeneratorSupport ComplexExpressions
public GeneratorSupport Win32Resources
public GeneratorSupport Resources
public GeneratorSupport PartialTypes
public GeneratorSupport GenericTypeReference
public GeneratorSupport GenericTypeDeclaration
public GeneratorSupport DeclareIndexerProperties
}
public System.CodeDom.Compiler.ICodeCompiler {
public CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit compilationUnit)
public CompilerResults CompileAssemblyFromFile(CompilerParameters options, string fileName)
public CompilerResults CompileAssemblyFromSource(CompilerParameters options, string source)
public CompilerResults CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] compilationUnits)
public CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames)
public CompilerResults CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources)
}
public System.CodeDom.Compiler.ICodeGenerator {
public bool IsValidIdentifier(string value)
public void ValidateIdentifier(string value)
public string CreateEscapedIdentifier(string value)
public string CreateValidIdentifier(string value)
public string GetTypeOutput(CodeTypeReference type)
public bool Supports(GeneratorSupport supports)
public void GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o)
}
public System.CodeDom.Compiler.ICodeParser {
public CodeCompileUnit Parse(TextReader codeStream)
}
internal System.CodeDom.Compiler.Indentation : object {
private ExposedTabStringIndentedTextWriter _writer
private int _indent
private string _s
internal string IndentationString
internal void .ctor(ExposedTabStringIndentedTextWriter writer, int indent)
internal string get_IndentationString()
}
public System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
private TextWriter _writer
private string _tabString
private int _indentLevel
private bool _tabsPending
public string DefaultTabString
public Encoding Encoding
public string NewLine
public int Indent
public TextWriter InnerWriter
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string tabString)
public Encoding get_Encoding()
public string get_NewLine()
public void set_NewLine(string value)
public int get_Indent()
public void set_Indent(int value)
public TextWriter get_InnerWriter()
public void Close()
public void Flush()
protected void OutputTabs()
public void Write(string s)
public void Write(bool value)
public void Write(char value)
public void Write(Char[] buffer)
public void Write(Char[] buffer, int index, int count)
public void Write(double value)
public void Write(float value)
public void Write(int value)
public void Write(long value)
public void Write(object value)
public void Write(string format, object arg0)
public void Write(string format, object arg0, object arg1)
public void Write(string format, Object[] arg)
public void WriteLineNoTabs(string s)
public void WriteLine(string s)
public void WriteLine()
public void WriteLine(bool value)
public void WriteLine(char value)
public void WriteLine(Char[] buffer)
public void WriteLine(Char[] buffer, int index, int count)
public void WriteLine(double value)
public void WriteLine(float value)
public void WriteLine(int value)
public void WriteLine(long value)
public void WriteLine(object value)
public void WriteLine(string format, object arg0)
public void WriteLine(string format, object arg0, object arg1)
public void WriteLine(string format, Object[] arg)
public void WriteLine(UInt32 value)
}
public System.CodeDom.Compiler.LanguageOptions : Enum {
public int value__
public LanguageOptions None
public LanguageOptions CaseInsensitive
}
public System.CodeDom.Compiler.TempFileCollection : object {
private string _basePath
private string _tempDir
private Hashtable _files
private bool <KeepFiles>k__BackingField
public int Count
private int System.Collections.ICollection.Count
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
public string TempDir
public string BasePath
public bool KeepFiles
public void .ctor(string tempDir)
public void .ctor(string tempDir, bool keepFiles)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
public string AddExtension(string fileExtension)
public string AddExtension(string fileExtension, bool keepFile)
public void AddFile(string fileName, bool keepFile)
public IEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int start)
public void CopyTo(String[] fileNames, int start)
public int get_Count()
private int System.Collections.ICollection.get_Count()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
public string get_TempDir()
public string get_BasePath()
private void EnsureTempNameCreated()
public bool get_KeepFiles()
public void set_KeepFiles(bool value)
private bool KeepFile(string fileName)
public void Delete()
internal void Delete(string fileName)
internal void SafeDelete()
}
public System.CodeDom.FieldDirection : Enum {
public int value__
public FieldDirection In
public FieldDirection Out
public FieldDirection Ref
}
public System.CodeDom.MemberAttributes : Enum {
public int value__
public MemberAttributes Abstract
public MemberAttributes Final
public MemberAttributes Static
public MemberAttributes Override
public MemberAttributes Const
public MemberAttributes New
public MemberAttributes Overloaded
public MemberAttributes Assembly
public MemberAttributes FamilyAndAssembly
public MemberAttributes Family
public MemberAttributes FamilyOrAssembly
public MemberAttributes Private
public MemberAttributes Public
public MemberAttributes AccessMask
public MemberAttributes ScopeMask
public MemberAttributes VTableMask
}
public System.Collections.Concurrent.BlockingCollection`1 : object {
private IProducerConsumerCollection`1<T> _collection
private int _boundedCapacity
private int NON_BOUNDED
private SemaphoreSlim _freeNodes
private SemaphoreSlim _occupiedNodes
private bool _isDisposed
private CancellationTokenSource _consumersCancellationTokenSource
private CancellationTokenSource _producersCancellationTokenSource
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _currentAdders
private int COMPLETE_ADDING_ON_MASK
public int BoundedCapacity
public bool IsAddingCompleted
public bool IsCompleted
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool IsSTAThread
public int get_BoundedCapacity()
public bool get_IsAddingCompleted()
public bool get_IsCompleted()
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void .ctor(int boundedCapacity)
public void .ctor(IProducerConsumerCollection`1<T> collection, int boundedCapacity)
public void .ctor(IProducerConsumerCollection`1<T> collection)
private void Initialize(IProducerConsumerCollection`1<T> collection, int boundedCapacity, int collectionCount)
public void Add(T item)
public void Add(T item, CancellationToken cancellationToken)
public bool TryAdd(T item)
public bool TryAdd(T item, TimeSpan timeout)
public bool TryAdd(T item, int millisecondsTimeout)
public bool TryAdd(T item, int millisecondsTimeout, CancellationToken cancellationToken)
private bool TryAddWithNoTimeValidation(T item, int millisecondsTimeout, CancellationToken cancellationToken)
public T Take()
public T Take(CancellationToken cancellationToken)
public bool TryTake(T& item)
public bool TryTake(T& item, TimeSpan timeout)
public bool TryTake(T& item, int millisecondsTimeout)
public bool TryTake(T& item, int millisecondsTimeout, CancellationToken cancellationToken)
private bool TryTakeWithNoTimeValidation(T& item, int millisecondsTimeout, CancellationToken cancellationToken, CancellationTokenSource combinedTokenSource)
public int AddToAny(BlockingCollection`1[] collections, T item)
public int AddToAny(BlockingCollection`1[] collections, T item, CancellationToken cancellationToken)
public int TryAddToAny(BlockingCollection`1[] collections, T item)
public int TryAddToAny(BlockingCollection`1[] collections, T item, TimeSpan timeout)
public int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout)
public int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout, CancellationToken cancellationToken)
private int TryAddToAnyCore(BlockingCollection`1[] collections, T item, int millisecondsTimeout, CancellationToken externalCancellationToken)
private int TryAddToAnyFast(BlockingCollection`1[] collections, T item)
private List`1<WaitHandle> GetHandles(BlockingCollection`1[] collections, CancellationToken externalCancellationToken, bool isAddOperation, CancellationToken[]& cancellationTokens)
private int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout)
public int TakeFromAny(BlockingCollection`1[] collections, T& item)
public int TakeFromAny(BlockingCollection`1[] collections, T& item, CancellationToken cancellationToken)
public int TryTakeFromAny(BlockingCollection`1[] collections, T& item)
public int TryTakeFromAny(BlockingCollection`1[] collections, T& item, TimeSpan timeout)
public int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout)
public int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, CancellationToken cancellationToken)
private int TryTakeFromAnyCore(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, bool isTakeOperation, CancellationToken externalCancellationToken)
private int TryTakeFromAnyCoreSlow(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, bool isTakeOperation, CancellationToken externalCancellationToken)
public void CompleteAdding()
private void CancelWaitingConsumers()
private void CancelWaitingProducers()
public void Dispose()
protected void Dispose(bool disposing)
public T[] ToArray()
public void CopyTo(T[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public IEnumerable`1<T> GetConsumingEnumerable()
public IEnumerable`1<T> GetConsumingEnumerable(CancellationToken cancellationToken)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void ValidateCollectionsArray(BlockingCollection`1[] collections, bool isAddOperation)
private bool get_IsSTAThread()
private void ValidateTimeout(TimeSpan timeout)
private void ValidateMillisecondsTimeout(int millisecondsTimeout)
private void CheckDisposed()
}
internal System.Collections.Concurrent.BlockingCollectionDebugView`1 : object {
private BlockingCollection`1<T> _blockingCollection
public T[] Items
public void .ctor(BlockingCollection`1<T> collection)
public T[] get_Items()
}
internal System.Collections.Concurrent.CDSCollectionETWBCLProvider : EventSource {
public CDSCollectionETWBCLProvider Log
private EventKeywords ALL_KEYWORDS
private int CONCURRENTSTACK_FASTPUSHFAILED_ID
private int CONCURRENTSTACK_FASTPOPFAILED_ID
private int CONCURRENTDICTIONARY_ACQUIRINGALLLOCKS_ID
private int CONCURRENTBAG_TRYTAKESTEALS_ID
private int CONCURRENTBAG_TRYPEEKSTEALS_ID
public void ConcurrentStack_FastPushFailed(int spinCount)
public void ConcurrentStack_FastPopFailed(int spinCount)
public void ConcurrentDictionary_AcquiringAllLocks(int numOfBuckets)
public void ConcurrentBag_TryTakeSteals()
public void ConcurrentBag_TryPeekSteals()
}
public System.Collections.Concurrent.ConcurrentBag`1 : object {
private ThreadLocal`1<WorkStealingQueue<T>> _locals
private WorkStealingQueue modreq(System.Runtime.CompilerServices.IsVolatile) _workStealingQueues
public int Count
private int DangerousCount
public bool IsEmpty
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private object GlobalQueuesLock
public void .ctor(IEnumerable`1<T> collection)
public void Add(T item)
private bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item)
public bool TryTake(T& result)
public bool TryPeek(T& result)
private WorkStealingQueue<T> GetCurrentThreadWorkStealingQueue(bool forceCreate)
private WorkStealingQueue<T> CreateWorkStealingQueueForCurrentThread()
private WorkStealingQueue<T> GetUnownedWorkStealingQueue()
private bool TrySteal(T& result, bool take)
private bool TryStealFromTo(WorkStealingQueue<T> startInclusive, WorkStealingQueue<T> endExclusive, T& result, bool take)
public void CopyTo(T[] array, int index)
private int CopyFromEachQueueToArray(T[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public T[] ToArray()
public void Clear()
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
private int get_DangerousCount()
public bool get_IsEmpty()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private object get_GlobalQueuesLock()
private void FreezeBag(Boolean& lockTaken)
private void UnfreezeBag(bool lockTaken)
}
internal System.Collections.Generic.ArrayBuilder`1 : ValueType {
private int DefaultCapacity
private int MaxCoreClrArrayLength
private T[] _array
private int _count
public int Capacity
public int Count
public T Item
public void .ctor(int capacity)
public int get_Capacity()
public int get_Count()
public T get_Item(int index)
public void set_Item(int index, T value)
public void Add(T item)
public T First()
public T Last()
public T[] ToArray()
public void UncheckedAdd(T item)
private void EnsureCapacity(int minimum)
}
internal System.Collections.Generic.BitHelper : object {
private byte MarkedBitFlag
private byte IntSize
private int _length
private Int32* _arrayPtr
private Int32[] _array
private bool _useStackAlloc
internal void .ctor(Int32* bitArrayPtr, int length)
internal void .ctor(Int32[] bitArray, int length)
internal void MarkBit(int bitPosition)
internal bool IsMarked(int bitPosition)
internal int ToIntArrayLength(int n)
}
internal System.Collections.Generic.CopyPosition : ValueType {
private int <Row>k__BackingField
private int <Column>k__BackingField
public CopyPosition Start
internal int Row
internal int Column
private string DebuggerDisplay
internal void .ctor(int row, int column)
public CopyPosition get_Start()
internal int get_Row()
internal int get_Column()
public CopyPosition Normalize(int endColumn)
private string get_DebuggerDisplay()
}
internal System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
private ICollection`1<TKey> _collection
public TKey[] Items
public void .ctor(ICollection`1<TKey> collection)
public TKey[] get_Items()
}
internal System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
private ICollection`1<TValue> _collection
public TValue[] Items
public void .ctor(ICollection`1<TValue> collection)
public TValue[] get_Items()
}
internal System.Collections.Generic.EnumerableHelpers : object {
internal void Copy(IEnumerable`1<T> source, T[] array, int arrayIndex, int count)
internal void IterativeCopy(IEnumerable`1<T> source, T[] array, int arrayIndex, int count)
internal T[] ToArray(IEnumerable`1<T> source)
internal T[] ToArray(IEnumerable`1<T> source, Int32& length)
}
internal System.Collections.Generic.ICollectionDebugView`1 : object {
private ICollection`1<T> _collection
public T[] Items
public void .ctor(ICollection`1<T> collection)
public T[] get_Items()
}
internal System.Collections.Generic.IDictionaryDebugView`2 : object {
private IDictionary`2<K, V> _dict
public KeyValuePair`2[] Items
public void .ctor(IDictionary`2<K, V> dictionary)
public KeyValuePair`2[] get_Items()
}
public System.Collections.Generic.ISet`1 {
public bool Add(T item)
public void UnionWith(IEnumerable`1<T> other)
public void IntersectWith(IEnumerable`1<T> other)
public void ExceptWith(IEnumerable`1<T> other)
public void SymmetricExceptWith(IEnumerable`1<T> other)
public bool IsSubsetOf(IEnumerable`1<T> other)
public bool IsSupersetOf(IEnumerable`1<T> other)
public bool IsProperSupersetOf(IEnumerable`1<T> other)
public bool IsProperSubsetOf(IEnumerable`1<T> other)
public bool Overlaps(IEnumerable`1<T> other)
public bool SetEquals(IEnumerable`1<T> other)
}
internal System.Collections.Generic.LargeArrayBuilder`1 : ValueType {
private int StartingCapacity
private int ResizeLimit
private int _maxCapacity
private T[] _first
private ArrayBuilder`1<T[]> _buffers
private T[] _current
private int _index
private int _count
public int Count
public void .ctor(bool initialize)
public void .ctor(int maxCapacity)
public int get_Count()
public void Add(T item)
public void AddRange(IEnumerable`1<T> items)
public void CopyTo(T[] array, int arrayIndex, int count)
public CopyPosition CopyTo(CopyPosition position, T[] array, int arrayIndex, int count)
public T[] GetBuffer(int index)
public void SlowAdd(T item)
public T[] ToArray()
public bool TryMove(T[]& array)
private void AllocateBuffer()
internal int <CopyTo>g__CopyToCore|15_0(T[] sourceBuffer, int sourceIndex, <>c__DisplayClass15_0& )
}
public System.Collections.Generic.LinkedList`1 : object {
internal LinkedListNode`1<T> head
internal int count
internal int version
private object _syncRoot
private SerializationInfo _siInfo
private string VersionName
private string CountName
private string ValuesName
public int Count
public LinkedListNode`1<T> First
public LinkedListNode`1<T> Last
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(IEnumerable`1<T> collection)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_Count()
public LinkedListNode`1<T> get_First()
public LinkedListNode`1<T> get_Last()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<T>.Add(T value)
public LinkedListNode`1<T> AddAfter(LinkedListNode`1<T> node, T value)
public void AddAfter(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode)
public LinkedListNode`1<T> AddBefore(LinkedListNode`1<T> node, T value)
public void AddBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode)
public LinkedListNode`1<T> AddFirst(T value)
public void AddFirst(LinkedListNode`1<T> node)
public LinkedListNode`1<T> AddLast(T value)
public void AddLast(LinkedListNode`1<T> node)
public void Clear()
public bool Contains(T value)
public void CopyTo(T[] array, int index)
public LinkedListNode`1<T> Find(T value)
public LinkedListNode`1<T> FindLast(T value)
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
public bool Remove(T value)
public void Remove(LinkedListNode`1<T> node)
public void RemoveFirst()
public void RemoveLast()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
private void InternalInsertNodeBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode)
private void InternalInsertNodeToEmptyList(LinkedListNode`1<T> newNode)
internal void InternalRemoveNode(LinkedListNode`1<T> node)
internal void ValidateNewNode(LinkedListNode`1<T> node)
internal void ValidateNode(LinkedListNode`1<T> node)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Collections.Generic.LinkedListNode`1 : object {
internal LinkedList`1<T> list
internal LinkedListNode`1<T> next
internal LinkedListNode`1<T> prev
internal T item
public LinkedList`1<T> List
public LinkedListNode`1<T> Next
public LinkedListNode`1<T> Previous
public T Value
public void .ctor(T value)
internal void .ctor(LinkedList`1<T> list, T value)
public LinkedList`1<T> get_List()
public LinkedListNode`1<T> get_Next()
public LinkedListNode`1<T> get_Previous()
public T get_Value()
public void set_Value(T value)
internal void Invalidate()
}
internal System.Collections.Generic.NodeColor : Enum {
public byte value__
public NodeColor Black
public NodeColor Red
}
public System.Collections.Generic.Queue`1 : object {
private T[] _array
private int _head
private int _tail
private int _size
private int _version
private object _syncRoot
private int MinimumGrow
private int GrowFactor
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(int capacity)
public void .ctor(IEnumerable`1<T> collection)
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void Clear()
public void CopyTo(T[] array, int arrayIndex)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public void Enqueue(T item)
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public T Dequeue()
public bool TryDequeue(T& result)
public T Peek()
public bool TryPeek(T& result)
public bool Contains(T item)
public T[] ToArray()
private void SetCapacity(int capacity)
private void MoveNext(Int32& index)
private void ThrowForEmptyQueue()
public void TrimExcess()
}
internal System.Collections.Generic.QueueDebugView`1 : object {
private Queue`1<T> _queue
public T[] Items
public void .ctor(Queue`1<T> queue)
public T[] get_Items()
}
public System.Collections.Generic.SortedDictionary`2 : object {
private KeyCollection<TKey, TValue> _keys
private ValueCollection<TKey, TValue> _values
private TreeSet`1<KeyValuePair`2<TKey, TValue>> _set
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
public TValue Item
public int Count
public IComparer`1<TKey> Comparer
public KeyCollection<TKey, TValue> Keys
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys
public ValueCollection<TKey, TValue> Values
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private object System.Collections.IDictionary.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public void .ctor(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer)
public void .ctor(IComparer`1<TKey> comparer)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public int get_Count()
public IComparer`1<TKey> get_Comparer()
public KeyCollection<TKey, TValue> get_Keys()
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys()
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys()
public ValueCollection<TKey, TValue> get_Values()
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values()
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values()
public void Add(TKey key, TValue value)
public void Clear()
public bool ContainsKey(TKey key)
public bool ContainsValue(TValue value)
public void CopyTo(KeyValuePair`2[] array, int index)
public Enumerator<TKey, TValue> GetEnumerator()
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator()
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private ICollection System.Collections.IDictionary.get_Keys()
private ICollection System.Collections.IDictionary.get_Values()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private void System.Collections.IDictionary.Add(object key, object value)
private bool System.Collections.IDictionary.Contains(object key)
private bool IsCompatibleKey(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private void System.Collections.IDictionary.Remove(object key)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Collections.Generic.SortedList`2 : object {
private TKey[] keys
private TValue[] values
private int _size
private int version
private IComparer`1<TKey> comparer
private KeyList<TKey, TValue> keyList
private ValueList<TKey, TValue> valueList
private object _syncRoot
private int DefaultCapacity
private int MaxArrayLength
public int Capacity
public IComparer`1<TKey> Comparer
public int Count
public IList`1<TKey> Keys
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys
private ICollection System.Collections.IDictionary.Keys
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys
public IList`1<TValue> Values
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values
private ICollection System.Collections.IDictionary.Values
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
private bool System.Collections.IDictionary.IsReadOnly
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public TValue Item
private object System.Collections.IDictionary.Item
public void .ctor(int capacity)
public void .ctor(IComparer`1<TKey> comparer)
public void .ctor(int capacity, IComparer`1<TKey> comparer)
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public void .ctor(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer)
public void Add(TKey key, TValue value)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair)
public int get_Capacity()
public void set_Capacity(int value)
public IComparer`1<TKey> get_Comparer()
private void System.Collections.IDictionary.Add(object key, object value)
public int get_Count()
public IList`1<TKey> get_Keys()
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys()
private ICollection System.Collections.IDictionary.get_Keys()
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys()
public IList`1<TValue> get_Values()
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values()
private ICollection System.Collections.IDictionary.get_Values()
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values()
private KeyList<TKey, TValue> GetKeyListHelper()
private ValueList<TKey, TValue> GetValueListHelper()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
private bool System.Collections.IDictionary.get_IsReadOnly()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void Clear()
private bool System.Collections.IDictionary.Contains(object key)
public bool ContainsKey(TKey key)
public bool ContainsValue(TValue value)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private void EnsureCapacity(int min)
private TValue GetByIndex(int index)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator()
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private TKey GetKey(int index)
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
public int IndexOfKey(TKey key)
public int IndexOfValue(TValue value)
private void Insert(int index, TKey key, TValue value)
public bool TryGetValue(TKey key, TValue& value)
public void RemoveAt(int index)
public bool Remove(TKey key)
private void System.Collections.IDictionary.Remove(object key)
public void TrimExcess()
private bool IsCompatibleKey(object key)
}
public System.Collections.Generic.SortedSet`1 : object {
private Node<T> root
private IComparer`1<T> comparer
private int count
private int version
private object _syncRoot
private SerializationInfo siInfo
private string ComparerName
private string CountName
private string ItemsName
private string VersionName
private string TreeName
private string NodeValueName
private string EnumStartName
private string ReverseName
private string EnumVersionName
private string MinName
private string MaxName
private string LowerBoundActiveName
private string UpperBoundActiveName
internal int StackAllocThreshold
public int Count
public IComparer`1<T> Comparer
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public T Min
internal T MinInternal
public T Max
internal T MaxInternal
public void .ctor(IComparer`1<T> comparer)
public void .ctor(IEnumerable`1<T> collection)
public void .ctor(IEnumerable`1<T> collection, IComparer`1<T> comparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void AddAllElements(IEnumerable`1<T> collection)
private void RemoveAllElements(IEnumerable`1<T> collection)
private bool ContainsAllElements(IEnumerable`1<T> collection)
internal bool InOrderTreeWalk(TreeWalkPredicate`1<T> action)
internal bool BreadthFirstTreeWalk(TreeWalkPredicate`1<T> action)
public int get_Count()
public IComparer`1<T> get_Comparer()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
internal void VersionCheck()
internal bool IsWithinRange(T item)
public bool Add(T item)
private void System.Collections.Generic.ICollection<T>.Add(T item)
internal bool AddIfNotPresent(T item)
public bool Remove(T item)
internal bool DoRemove(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array)
public void CopyTo(T[] array, int index)
public void CopyTo(T[] array, int index, int count)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void InsertionBalance(Node<T> current, Node& parent, Node<T> grandParent, Node<T> greatGrandParent)
private void ReplaceChildOrRoot(Node<T> parent, Node<T> child, Node<T> newChild)
private void ReplaceNode(Node<T> match, Node<T> parentOfMatch, Node<T> successor, Node<T> parentOfSuccessor)
internal Node<T> FindNode(T item)
internal int InternalIndexOf(T item)
internal Node<T> FindRange(T from, T to)
internal Node<T> FindRange(T from, T to, bool lowerBoundActive, bool upperBoundActive)
internal void UpdateVersion()
public IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer()
public IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer(IEqualityComparer`1<T> memberEqualityComparer)
internal bool SortedSetEquals(SortedSet`1<T> set1, SortedSet`1<T> set2, IComparer`1<T> comparer)
private bool HasEqualComparer(SortedSet`1<T> other)
public void UnionWith(IEnumerable`1<T> other)
private Node<T> ConstructRootFromSortedArray(T[] arr, int startIndex, int endIndex, Node<T> redNode)
public void IntersectWith(IEnumerable`1<T> other)
internal void IntersectWithEnumerable(IEnumerable`1<T> other)
public void ExceptWith(IEnumerable`1<T> other)
public void SymmetricExceptWith(IEnumerable`1<T> other)
private void SymmetricExceptWithSameComparer(SortedSet`1<T> other)
private void SymmetricExceptWithSameComparer(T[] other, int count)
public bool IsSubsetOf(IEnumerable`1<T> other)
private bool IsSubsetOfSortedSetWithSameComparer(SortedSet`1<T> asSorted)
public bool IsProperSubsetOf(IEnumerable`1<T> other)
public bool IsSupersetOf(IEnumerable`1<T> other)
public bool IsProperSupersetOf(IEnumerable`1<T> other)
public bool SetEquals(IEnumerable`1<T> other)
public bool Overlaps(IEnumerable`1<T> other)
private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound)
public int RemoveWhere(Predicate`1<T> match)
public T get_Min()
internal T get_MinInternal()
public T get_Max()
internal T get_MaxInternal()
public IEnumerable`1<T> Reverse()
public SortedSet`1<T> GetViewBetween(T lowerValue, T upperValue)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
protected void GetObjectData(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
protected void OnDeserialization(object sender)
public bool TryGetValue(T equalValue, T& actualValue)
private int Log2(int value)
}
internal System.Collections.Generic.SortedSetEqualityComparer`1 : object {
private IComparer`1<T> _comparer
private IEqualityComparer`1<T> _memberEqualityComparer
public void .ctor(IEqualityComparer`1<T> memberEqualityComparer)
private void .ctor(IComparer`1<T> comparer, IEqualityComparer`1<T> memberEqualityComparer)
public bool Equals(SortedSet`1<T> x, SortedSet`1<T> y)
public int GetHashCode(SortedSet`1<T> obj)
public bool Equals(object obj)
public int GetHashCode()
}
public System.Collections.Generic.Stack`1 : object {
private T[] _array
private int _size
private int _version
private object _syncRoot
private int DefaultCapacity
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(int capacity)
public void .ctor(IEnumerable`1<T> collection)
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
private void System.Collections.ICollection.CopyTo(Array array, int arrayIndex)
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void TrimExcess()
public T Peek()
public bool TryPeek(T& result)
public T Pop()
public bool TryPop(T& result)
public void Push(T item)
public T[] ToArray()
private void ThrowForEmptyStack()
}
internal System.Collections.Generic.StackDebugView`1 : object {
private Stack`1<T> _stack
public T[] Items
public void .ctor(Stack`1<T> stack)
public T[] get_Items()
}
internal System.Collections.Generic.TreeRotation : Enum {
public byte value__
public TreeRotation Left
public TreeRotation LeftRight
public TreeRotation Right
public TreeRotation RightLeft
}
internal System.Collections.Generic.TreeSet`1 : SortedSet`1<T> {
public void .ctor(IComparer`1<T> comparer)
public void .ctor(SerializationInfo siInfo, StreamingContext context)
internal bool AddIfNotPresent(T item)
}
internal System.Collections.Generic.TreeWalkPredicate`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(Node<T> node)
public IAsyncResult BeginInvoke(Node<T> node, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Collections.ObjectModel.ObservableCollection`1 : Collection`1<T> {
private NotifyCollectionChangedEventHandler CollectionChanged
private PropertyChangedEventHandler PropertyChanged
private string CountString
private string IndexerName
private SimpleMonitor<T> _monitor
public void .ctor(List`1<T> list)
public void .ctor(IEnumerable`1<T> collection)
private void CopyFrom(IEnumerable`1<T> collection)
public void Move(int oldIndex, int newIndex)
private void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value)
private void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value)
public void add_CollectionChanged(NotifyCollectionChangedEventHandler value)
public void remove_CollectionChanged(NotifyCollectionChangedEventHandler value)
protected void ClearItems()
protected void RemoveItem(int index)
protected void InsertItem(int index, T item)
protected void SetItem(int index, T item)
protected void MoveItem(int oldIndex, int newIndex)
protected void OnPropertyChanged(PropertyChangedEventArgs e)
protected void add_PropertyChanged(PropertyChangedEventHandler value)
protected void remove_PropertyChanged(PropertyChangedEventHandler value)
protected void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
protected IDisposable BlockReentrancy()
protected void CheckReentrancy()
private void OnPropertyChanged(string propertyName)
private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index)
private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index, int oldIndex)
private void OnCollectionChanged(NotifyCollectionChangedAction action, object oldItem, object newItem, int index)
private void OnCollectionReset()
}
public System.Collections.ObjectModel.ReadOnlyObservableCollection`1 : ReadOnlyCollection`1<T> {
private NotifyCollectionChangedEventHandler CollectionChanged
private PropertyChangedEventHandler PropertyChanged
public void .ctor(ObservableCollection`1<T> list)
private void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value)
private void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value)
protected void add_CollectionChanged(NotifyCollectionChangedEventHandler value)
protected void remove_CollectionChanged(NotifyCollectionChangedEventHandler value)
protected void OnCollectionChanged(NotifyCollectionChangedEventArgs args)
private void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value)
private void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value)
protected void add_PropertyChanged(PropertyChangedEventHandler value)
protected void remove_PropertyChanged(PropertyChangedEventHandler value)
protected void OnPropertyChanged(PropertyChangedEventArgs args)
private void HandleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
private void HandlePropertyChanged(object sender, PropertyChangedEventArgs e)
}
public System.Collections.Specialized.BitVector32 : ValueType {
private UInt32 data
public bool Item
public int Item
public int Data
public void .ctor(int data)
public void .ctor(BitVector32 value)
public bool get_Item(int bit)
public void set_Item(int bit, bool value)
public int get_Item(Section section)
public void set_Item(Section section, int value)
public int get_Data()
private short CountBitsSet(short mask)
public int CreateMask()
public int CreateMask(int previous)
private short CreateMaskFromHighValue(short highValue)
public Section CreateSection(short maxValue)
public Section CreateSection(short maxValue, Section previous)
private Section CreateSectionHelper(short maxValue, short priorMask, short priorOffset)
public bool Equals(object o)
public int GetHashCode()
public string ToString(BitVector32 value)
public string ToString()
}
internal System.Collections.Specialized.CaseSensitiveStringDictionary : StringDictionary {
public string Item
public string get_Item(string key)
public void set_Item(string key, string value)
public void Add(string key, string value)
public bool ContainsKey(string key)
public void Remove(string key)
}
public System.Collections.Specialized.CollectionsUtil : object {
public Hashtable CreateCaseInsensitiveHashtable()
public Hashtable CreateCaseInsensitiveHashtable(int capacity)
public Hashtable CreateCaseInsensitiveHashtable(IDictionary d)
public SortedList CreateCaseInsensitiveSortedList()
}
internal System.Collections.Specialized.CompatibleComparer : object {
private IComparer _comparer
private IComparer modreq(System.Runtime.CompilerServices.IsVolatile) defaultComparer
private IHashCodeProvider _hcp
private IHashCodeProvider modreq(System.Runtime.CompilerServices.IsVolatile) defaultHashProvider
public IComparer Comparer
public IHashCodeProvider HashCodeProvider
public IComparer DefaultComparer
public IHashCodeProvider DefaultHashCodeProvider
internal void .ctor(IComparer comparer, IHashCodeProvider hashCodeProvider)
public bool Equals(object a, object b)
public int GetHashCode(object obj)
public IComparer get_Comparer()
public IHashCodeProvider get_HashCodeProvider()
public IComparer get_DefaultComparer()
public IHashCodeProvider get_DefaultHashCodeProvider()
}
internal System.Collections.Specialized.FixedStringLookup : object {
internal bool Contains(String[][] lookupTable, string value, bool ignoreCase)
private bool Contains(String[] array, string value, bool ignoreCase)
private bool FindCharacter(String[] array, char value, int pos, Int32& min, Int32& max)
}
public System.Collections.Specialized.HybridDictionary : object {
private int CutoverPoint
private int InitialHashtableSize
private int FixedSizeCutoverPoint
private ListDictionary list
private Hashtable hashtable
private bool caseInsensitive
public object Item
private ListDictionary List
public int Count
public ICollection Keys
public bool IsReadOnly
public bool IsFixedSize
public bool IsSynchronized
public object SyncRoot
public ICollection Values
public void .ctor(int initialSize)
public void .ctor(bool caseInsensitive)
public void .ctor(int initialSize, bool caseInsensitive)
public object get_Item(object key)
public void set_Item(object key, object value)
private ListDictionary get_List()
private void ChangeOver()
public int get_Count()
public ICollection get_Keys()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public bool get_IsSynchronized()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void CopyTo(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Remove(object key)
}
public System.Collections.Specialized.INotifyCollectionChanged {
public void add_CollectionChanged(NotifyCollectionChangedEventHandler value)
public void remove_CollectionChanged(NotifyCollectionChangedEventHandler value)
}
public System.Collections.Specialized.IOrderedDictionary {
public object Item
public object get_Item(int index)
public void set_Item(int index, object value)
public IDictionaryEnumerator GetEnumerator()
public void Insert(int index, object key, object value)
public void RemoveAt(int index)
}
public System.Collections.Specialized.ListDictionary : object {
private DictionaryNode head
private int version
private int count
private IComparer comparer
private object _syncRoot
public object Item
public int Count
public ICollection Keys
public bool IsReadOnly
public bool IsFixedSize
public bool IsSynchronized
public object SyncRoot
public ICollection Values
public void .ctor(IComparer comparer)
public object get_Item(object key)
public void set_Item(object key, object value)
public int get_Count()
public ICollection get_Keys()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public bool get_IsSynchronized()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void CopyTo(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Remove(object key)
}
public System.Collections.Specialized.NameObjectCollectionBase : object {
private string ReadOnlyName
private string CountName
private string ComparerName
private string HashCodeProviderName
private string KeysName
private string ValuesName
private string KeyComparerName
private string VersionName
private bool _readOnly
private ArrayList _entriesArray
private IEqualityComparer _keyComparer
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _entriesTable
private NameObjectEntry modreq(System.Runtime.CompilerServices.IsVolatile) _nullKeyEntry
private KeysCollection _keys
private SerializationInfo _serializationInfo
private int _version
private object _syncRoot
private StringComparer defaultComparer
internal IEqualityComparer Comparer
protected bool IsReadOnly
public int Count
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
public KeysCollection Keys
protected void .ctor(IEqualityComparer equalityComparer)
protected void .ctor(int capacity, IEqualityComparer equalityComparer)
protected void .ctor(IHashCodeProvider hashProvider, IComparer comparer)
protected void .ctor(int capacity, IHashCodeProvider hashProvider, IComparer comparer)
protected void .ctor(int capacity)
internal void .ctor(DBNull dummy)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
private void Reset()
private void Reset(int capacity)
private NameObjectEntry FindEntry(string key)
internal IEqualityComparer get_Comparer()
internal void set_Comparer(IEqualityComparer value)
protected bool get_IsReadOnly()
protected void set_IsReadOnly(bool value)
protected bool BaseHasKeys()
protected void BaseAdd(string name, object value)
protected void BaseRemove(string name)
protected void BaseRemoveAt(int index)
protected void BaseClear()
protected object BaseGet(string name)
protected void BaseSet(string name, object value)
protected object BaseGet(int index)
protected string BaseGetKey(int index)
protected void BaseSet(int index, object value)
public IEnumerator GetEnumerator()
public int get_Count()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
protected String[] BaseGetAllKeys()
protected Object[] BaseGetAllValues()
protected Object[] BaseGetAllValues(Type type)
public KeysCollection get_Keys()
}
public System.Collections.Specialized.NameValueCollection : NameObjectCollectionBase {
private String[] _all
private String[] _allKeys
public string Item
public string Item
public String[] AllKeys
public void .ctor(NameValueCollection col)
public void .ctor(IHashCodeProvider hashProvider, IComparer comparer)
public void .ctor(int capacity)
public void .ctor(IEqualityComparer equalityComparer)
public void .ctor(int capacity, IEqualityComparer equalityComparer)
public void .ctor(int capacity, NameValueCollection col)
public void .ctor(int capacity, IHashCodeProvider hashProvider, IComparer comparer)
internal void .ctor(DBNull dummy)
protected void .ctor(SerializationInfo info, StreamingContext context)
protected void InvalidateCachedArrays()
private string GetAsOneString(ArrayList list)
private String[] GetAsStringArray(ArrayList list)
public void Add(NameValueCollection c)
public void Clear()
public void CopyTo(Array dest, int index)
public bool HasKeys()
internal bool InternalHasKeys()
public void Add(string name, string value)
public string Get(string name)
public String[] GetValues(string name)
public void Set(string name, string value)
public void Remove(string name)
public string get_Item(string name)
public void set_Item(string name, string value)
public string Get(int index)
public String[] GetValues(int index)
public string GetKey(int index)
public string get_Item(int index)
public String[] get_AllKeys()
}
public System.Collections.Specialized.NotifyCollectionChangedAction : Enum {
public int value__
public NotifyCollectionChangedAction Add
public NotifyCollectionChangedAction Remove
public NotifyCollectionChangedAction Replace
public NotifyCollectionChangedAction Move
public NotifyCollectionChangedAction Reset
}
public System.Collections.Specialized.NotifyCollectionChangedEventArgs : EventArgs {
private NotifyCollectionChangedAction _action
private IList _newItems
private IList _oldItems
private int _newStartingIndex
private int _oldStartingIndex
public NotifyCollectionChangedAction Action
public IList NewItems
public IList OldItems
public int NewStartingIndex
public int OldStartingIndex
public void .ctor(NotifyCollectionChangedAction action)
public void .ctor(NotifyCollectionChangedAction action, object changedItem)
public void .ctor(NotifyCollectionChangedAction action, object changedItem, int index)
public void .ctor(NotifyCollectionChangedAction action, IList changedItems)
public void .ctor(NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
public void .ctor(NotifyCollectionChangedAction action, object newItem, object oldItem)
public void .ctor(NotifyCollectionChangedAction action, object newItem, object oldItem, int index)
public void .ctor(NotifyCollectionChangedAction action, IList newItems, IList oldItems)
public void .ctor(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex)
public void .ctor(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex)
public void .ctor(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex)
internal void .ctor(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex)
private void InitializeAddOrRemove(NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
private void InitializeAdd(NotifyCollectionChangedAction action, IList newItems, int newStartingIndex)
private void InitializeRemove(NotifyCollectionChangedAction action, IList oldItems, int oldStartingIndex)
private void InitializeMoveOrReplace(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex, int oldStartingIndex)
public NotifyCollectionChangedAction get_Action()
public IList get_NewItems()
public IList get_OldItems()
public int get_NewStartingIndex()
public int get_OldStartingIndex()
}
public System.Collections.Specialized.NotifyCollectionChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, NotifyCollectionChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Collections.Specialized.OrderedDictionary : object {
private ArrayList _objectsArray
private Hashtable _objectsTable
private int _initialCapacity
private IEqualityComparer _comparer
private bool _readOnly
private object _syncRoot
private SerializationInfo _siInfo
private string KeyComparerName
private string ArrayListName
private string ReadOnlyName
private string InitCapacityName
public int Count
private bool System.Collections.IDictionary.IsFixedSize
public bool IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
public ICollection Keys
private ArrayList objectsArray
private Hashtable objectsTable
private object System.Collections.ICollection.SyncRoot
public object Item
public object Item
public ICollection Values
public void .ctor(int capacity)
public void .ctor(IEqualityComparer comparer)
public void .ctor(int capacity, IEqualityComparer comparer)
private void .ctor(OrderedDictionary dictionary)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_Count()
private bool System.Collections.IDictionary.get_IsFixedSize()
public bool get_IsReadOnly()
private bool System.Collections.ICollection.get_IsSynchronized()
public ICollection get_Keys()
private ArrayList get_objectsArray()
private Hashtable get_objectsTable()
private object System.Collections.ICollection.get_SyncRoot()
public object get_Item(int index)
public void set_Item(int index, object value)
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public OrderedDictionary AsReadOnly()
public bool Contains(object key)
public void CopyTo(Array array, int index)
private int IndexOfKey(object key)
public void Insert(int index, object key, object value)
protected void OnDeserialization(object sender)
public void RemoveAt(int index)
public void Remove(object key)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void GetObjectData(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
}
public System.Collections.Specialized.StringCollection : object {
private ArrayList data
public string Item
public int Count
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
public bool IsReadOnly
public bool IsSynchronized
public object SyncRoot
private object System.Collections.IList.Item
public string get_Item(int index)
public void set_Item(int index, string value)
public int get_Count()
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
public int Add(string value)
public void AddRange(String[] value)
public void Clear()
public bool Contains(string value)
public void CopyTo(String[] array, int index)
public StringEnumerator GetEnumerator()
public int IndexOf(string value)
public void Insert(int index, string value)
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public void Remove(string value)
public void RemoveAt(int index)
public object get_SyncRoot()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Collections.Specialized.StringDictionary : object {
internal Hashtable contents
public int Count
public bool IsSynchronized
public string Item
public ICollection Keys
public object SyncRoot
public ICollection Values
public int get_Count()
public bool get_IsSynchronized()
public string get_Item(string key)
public void set_Item(string key, string value)
public ICollection get_Keys()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(string key, string value)
public void Clear()
public bool ContainsKey(string key)
public bool ContainsValue(string value)
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string key)
internal void ReplaceHashtable(Hashtable useThisHashtableInstead)
internal IDictionary`2<string, string> AsGenericDictionary()
}
internal System.Collections.Specialized.StringDictionaryWithComparer : StringDictionary {
public string Item
public void .ctor(IEqualityComparer comparer)
public string get_Item(string key)
public void set_Item(string key, string value)
public void Add(string key, string value)
public bool ContainsKey(string key)
public void Remove(string key)
}
public System.Collections.Specialized.StringEnumerator : object {
private IEnumerator baseEnumerator
private IEnumerable temp
public string Current
internal void .ctor(StringCollection mappings)
public string get_Current()
public bool MoveNext()
public void Reset()
}
public System.ComponentModel.AddingNewEventArgs : EventArgs {
private object newObject
public object NewObject
public void .ctor(object newObject)
public object get_NewObject()
public void set_NewObject(object value)
}
public System.ComponentModel.AddingNewEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AddingNewEventArgs e)
public IAsyncResult BeginInvoke(object sender, AddingNewEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.AmbientValueAttribute : Attribute {
private object value
public object Value
public void .ctor(Type type, string value)
public void .ctor(char value)
public void .ctor(byte value)
public void .ctor(short value)
public void .ctor(int value)
public void .ctor(long value)
public void .ctor(float value)
public void .ctor(double value)
public void .ctor(bool value)
public void .ctor(string value)
public void .ctor(object value)
public object get_Value()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.ArrayConverter : CollectionConverter {
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
internal System.ComponentModel.ArraySubsetEnumerator : object {
private Array array
private int total
private int current
public object Current
public void .ctor(Array array, int count)
public bool MoveNext()
public void Reset()
public object get_Current()
}
public System.ComponentModel.AsyncCompletedEventArgs : EventArgs {
private Exception error
private bool cancelled
private object userState
public bool Cancelled
public Exception Error
public object UserState
public void .ctor(Exception error, bool cancelled, object userState)
public bool get_Cancelled()
public Exception get_Error()
public object get_UserState()
protected void RaiseExceptionIfNecessary()
}
public System.ComponentModel.AsyncCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AsyncCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.AsyncOperation : object {
private SynchronizationContext syncContext
private object userSuppliedState
private bool alreadyCompleted
public object UserSuppliedState
public SynchronizationContext SynchronizationContext
private void .ctor(object userSuppliedState, SynchronizationContext syncContext)
protected void Finalize()
public object get_UserSuppliedState()
public SynchronizationContext get_SynchronizationContext()
public void Post(SendOrPostCallback d, object arg)
public void PostOperationCompleted(SendOrPostCallback d, object arg)
public void OperationCompleted()
private void OperationCompletedCore()
private void VerifyNotCompleted()
private void VerifyDelegateNotNull(SendOrPostCallback d)
internal AsyncOperation CreateOperation(object userSuppliedState, SynchronizationContext syncContext)
}
public System.ComponentModel.AsyncOperationManager : object {
public SynchronizationContext SynchronizationContext
public AsyncOperation CreateOperation(object userSuppliedState)
public SynchronizationContext get_SynchronizationContext()
public void set_SynchronizationContext(SynchronizationContext value)
}
public System.ComponentModel.AttributeCollection : object {
public AttributeCollection Empty
private Hashtable _defaultAttributes
private Attribute[] _attributes
private object internalSyncObject
private int FOUND_TYPES_LIMIT
private AttributeEntry[] _foundAttributeTypes
private int _index
protected Attribute[] Attributes
public int Count
public Attribute Item
public Attribute Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(Attribute[] attributes)
public AttributeCollection FromExisting(AttributeCollection existing, Attribute[] newAttributes)
protected Attribute[] get_Attributes()
public int get_Count()
public Attribute get_Item(int index)
public Attribute get_Item(Type attributeType)
public bool Contains(Attribute attribute)
public bool Contains(Attribute[] attributes)
protected Attribute GetDefaultAttribute(Type attributeType)
public IEnumerator GetEnumerator()
public bool Matches(Attribute attribute)
public bool Matches(Attribute[] attributes)
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.ComponentModel.AttributeProviderAttribute : Attribute {
private string _typeName
private string _propertyName
public string TypeName
public string PropertyName
public void .ctor(string typeName)
public void .ctor(string typeName, string propertyName)
public void .ctor(Type type)
public string get_TypeName()
public string get_PropertyName()
}
public System.ComponentModel.BackgroundWorker : Component {
private object doWorkKey
private object runWorkerCompletedKey
private object progressChangedKey
private bool canCancelWorker
private bool workerReportsProgress
private bool cancellationPending
private bool isRunning
private AsyncOperation asyncOperation
private WorkerThreadStartDelegate threadStart
private SendOrPostCallback operationCompleted
private SendOrPostCallback progressReporter
public bool CancellationPending
public bool IsBusy
public bool WorkerReportsProgress
public bool WorkerSupportsCancellation
private void AsyncOperationCompleted(object arg)
public bool get_CancellationPending()
public void CancelAsync()
public void add_DoWork(DoWorkEventHandler value)
public void remove_DoWork(DoWorkEventHandler value)
public bool get_IsBusy()
protected void OnDoWork(DoWorkEventArgs e)
protected void OnRunWorkerCompleted(RunWorkerCompletedEventArgs e)
protected void OnProgressChanged(ProgressChangedEventArgs e)
public void add_ProgressChanged(ProgressChangedEventHandler value)
public void remove_ProgressChanged(ProgressChangedEventHandler value)
private void ProgressReporter(object arg)
public void ReportProgress(int percentProgress)
public void ReportProgress(int percentProgress, object userState)
public void RunWorkerAsync()
public void RunWorkerAsync(object argument)
public void add_RunWorkerCompleted(RunWorkerCompletedEventHandler value)
public void remove_RunWorkerCompleted(RunWorkerCompletedEventHandler value)
public bool get_WorkerReportsProgress()
public void set_WorkerReportsProgress(bool value)
public bool get_WorkerSupportsCancellation()
public void set_WorkerSupportsCancellation(bool value)
private void WorkerThreadStart(object argument)
}
public System.ComponentModel.BaseNumberConverter : TypeConverter {
internal bool AllowHex
internal Type TargetType
internal bool get_AllowHex()
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal Exception FromStringError(string failedText, Exception innerException)
internal string ToString(object value, NumberFormatInfo formatInfo)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool CanConvertTo(ITypeDescriptorContext context, Type t)
}
public System.ComponentModel.BindableAttribute : Attribute {
public BindableAttribute Yes
public BindableAttribute No
public BindableAttribute Default
private bool bindable
private bool isDefault
private BindingDirection direction
public bool Bindable
public BindingDirection Direction
public void .ctor(bool bindable)
public void .ctor(bool bindable, BindingDirection direction)
public void .ctor(BindableSupport flags)
public void .ctor(BindableSupport flags, BindingDirection direction)
public bool get_Bindable()
public BindingDirection get_Direction()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.BindableSupport : Enum {
public int value__
public BindableSupport No
public BindableSupport Yes
public BindableSupport Default
}
public System.ComponentModel.BindingDirection : Enum {
public int value__
public BindingDirection OneWay
public BindingDirection TwoWay
}
public System.ComponentModel.BindingList`1 : Collection`1<T> {
private int addNewPos
private bool raiseListChangedEvents
private bool raiseItemChangedEvents
private PropertyDescriptorCollection itemTypeProperties
private PropertyChangedEventHandler propertyChangedEventHandler
private AddingNewEventHandler onAddingNew
private ListChangedEventHandler onListChanged
private int lastChangeIndex
private bool allowNew
private bool allowEdit
private bool allowRemove
private bool userSetAllowNew
private bool ItemTypeHasDefaultConstructor
public bool RaiseListChangedEvents
private bool AddingNewHandled
public bool AllowNew
private bool System.ComponentModel.IBindingList.AllowNew
public bool AllowEdit
private bool System.ComponentModel.IBindingList.AllowEdit
public bool AllowRemove
private bool System.ComponentModel.IBindingList.AllowRemove
private bool System.ComponentModel.IBindingList.SupportsChangeNotification
protected bool SupportsChangeNotificationCore
private bool System.ComponentModel.IBindingList.SupportsSearching
protected bool SupportsSearchingCore
private bool System.ComponentModel.IBindingList.SupportsSorting
protected bool SupportsSortingCore
private bool System.ComponentModel.IBindingList.IsSorted
protected bool IsSortedCore
private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty
protected PropertyDescriptor SortPropertyCore
private ListSortDirection System.ComponentModel.IBindingList.SortDirection
protected ListSortDirection SortDirectionCore
private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents
public void .ctor(IList`1<T> list)
private void Initialize()
private bool get_ItemTypeHasDefaultConstructor()
public void add_AddingNew(AddingNewEventHandler value)
public void remove_AddingNew(AddingNewEventHandler value)
protected void OnAddingNew(AddingNewEventArgs e)
private object FireAddingNew()
public void add_ListChanged(ListChangedEventHandler value)
public void remove_ListChanged(ListChangedEventHandler value)
protected void OnListChanged(ListChangedEventArgs e)
public bool get_RaiseListChangedEvents()
public void set_RaiseListChangedEvents(bool value)
public void ResetBindings()
public void ResetItem(int position)
private void FireListChanged(ListChangedType type, int index)
protected void ClearItems()
protected void InsertItem(int index, T item)
protected void RemoveItem(int index)
protected void SetItem(int index, T item)
public void CancelNew(int itemIndex)
public void EndNew(int itemIndex)
public T AddNew()
private object System.ComponentModel.IBindingList.AddNew()
private bool get_AddingNewHandled()
protected object AddNewCore()
public bool get_AllowNew()
public void set_AllowNew(bool value)
private bool System.ComponentModel.IBindingList.get_AllowNew()
public bool get_AllowEdit()
public void set_AllowEdit(bool value)
private bool System.ComponentModel.IBindingList.get_AllowEdit()
public bool get_AllowRemove()
public void set_AllowRemove(bool value)
private bool System.ComponentModel.IBindingList.get_AllowRemove()
private bool System.ComponentModel.IBindingList.get_SupportsChangeNotification()
protected bool get_SupportsChangeNotificationCore()
private bool System.ComponentModel.IBindingList.get_SupportsSearching()
protected bool get_SupportsSearchingCore()
private bool System.ComponentModel.IBindingList.get_SupportsSorting()
protected bool get_SupportsSortingCore()
private bool System.ComponentModel.IBindingList.get_IsSorted()
protected bool get_IsSortedCore()
private PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty()
protected PropertyDescriptor get_SortPropertyCore()
private ListSortDirection System.ComponentModel.IBindingList.get_SortDirection()
protected ListSortDirection get_SortDirectionCore()
private void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor prop, ListSortDirection direction)
protected void ApplySortCore(PropertyDescriptor prop, ListSortDirection direction)
private void System.ComponentModel.IBindingList.RemoveSort()
protected void RemoveSortCore()
private int System.ComponentModel.IBindingList.Find(PropertyDescriptor prop, object key)
protected int FindCore(PropertyDescriptor prop, object key)
private void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor prop)
private void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor prop)
private void HookPropertyChanged(T item)
private void UnhookPropertyChanged(T item)
private void Child_PropertyChanged(object sender, PropertyChangedEventArgs e)
private bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents()
}
public System.ComponentModel.BooleanConverter : TypeConverter {
private StandardValuesCollection modreq(System.Runtime.CompilerServices.IsVolatile) values
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.BrowsableAttribute : Attribute {
public BrowsableAttribute Yes
public BrowsableAttribute No
public BrowsableAttribute Default
private bool browsable
public bool Browsable
public void .ctor(bool browsable)
public bool get_Browsable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ByteConverter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.CancelEventArgs : EventArgs {
private bool cancel
public bool Cancel
public void .ctor(bool cancel)
public bool get_Cancel()
public void set_Cancel(bool value)
}
public System.ComponentModel.CancelEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, CancelEventArgs e)
public IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.CategoryAttribute : Attribute {
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) appearance
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) asynchronous
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) behavior
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) data
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) design
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) action
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) format
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) layout
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) mouse
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) key
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) focus
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) windowStyle
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) dragDrop
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) defAttr
private bool localized
private string categoryValue
public CategoryAttribute Action
public CategoryAttribute Appearance
public CategoryAttribute Asynchronous
public CategoryAttribute Behavior
public CategoryAttribute Data
public CategoryAttribute Default
public CategoryAttribute Design
public CategoryAttribute DragDrop
public CategoryAttribute Focus
public CategoryAttribute Format
public CategoryAttribute Key
public CategoryAttribute Layout
public CategoryAttribute Mouse
public CategoryAttribute WindowStyle
public string Category
public CategoryAttribute get_Action()
public CategoryAttribute get_Appearance()
public CategoryAttribute get_Asynchronous()
public CategoryAttribute get_Behavior()
public CategoryAttribute get_Data()
public CategoryAttribute get_Default()
public CategoryAttribute get_Design()
public CategoryAttribute get_DragDrop()
public CategoryAttribute get_Focus()
public CategoryAttribute get_Format()
public CategoryAttribute get_Key()
public CategoryAttribute get_Layout()
public CategoryAttribute get_Mouse()
public CategoryAttribute get_WindowStyle()
public void .ctor(string category)
public string get_Category()
public bool Equals(object obj)
public int GetHashCode()
protected string GetLocalizedString(string value)
public bool IsDefaultAttribute()
}
public System.ComponentModel.CharConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
}
public System.ComponentModel.CollectionChangeAction : Enum {
public int value__
public CollectionChangeAction Add
public CollectionChangeAction Remove
public CollectionChangeAction Refresh
}
public System.ComponentModel.CollectionChangeEventArgs : EventArgs {
private CollectionChangeAction action
private object element
public CollectionChangeAction Action
public object Element
public void .ctor(CollectionChangeAction action, object element)
public CollectionChangeAction get_Action()
public object get_Element()
}
public System.ComponentModel.CollectionChangeEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, CollectionChangeEventArgs e)
public IAsyncResult BeginInvoke(object sender, CollectionChangeEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.CollectionConverter : TypeConverter {
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.ComplexBindingPropertiesAttribute : Attribute {
private string dataSource
private string dataMember
public ComplexBindingPropertiesAttribute Default
public string DataSource
public string DataMember
public void .ctor(string dataSource)
public void .ctor(string dataSource, string dataMember)
public string get_DataSource()
public string get_DataMember()
public bool Equals(object obj)
public int GetHashCode()
}
internal System.ComponentModel.CompModSwitches : object {
private BooleanSwitch modreq(System.Runtime.CompilerServices.IsVolatile) commonDesignerServices
private TraceSwitch modreq(System.Runtime.CompilerServices.IsVolatile) eventLog
public BooleanSwitch CommonDesignerServices
public TraceSwitch EventLog
public BooleanSwitch get_CommonDesignerServices()
public TraceSwitch get_EventLog()
}
public System.ComponentModel.Component : MarshalByRefObject {
private object EventDisposed
private ISite site
private EventHandlerList events
protected bool CanRaiseEvents
internal bool CanRaiseEventsInternal
protected EventHandlerList Events
public ISite Site
public IContainer Container
protected bool DesignMode
protected void Finalize()
protected bool get_CanRaiseEvents()
internal bool get_CanRaiseEventsInternal()
public void add_Disposed(EventHandler value)
public void remove_Disposed(EventHandler value)
protected EventHandlerList get_Events()
public ISite get_Site()
public void set_Site(ISite value)
public void Dispose()
protected void Dispose(bool disposing)
public IContainer get_Container()
protected object GetService(Type service)
protected bool get_DesignMode()
public string ToString()
}
public System.ComponentModel.ComponentCollection : ReadOnlyCollectionBase {
public IComponent Item
public IComponent Item
public void .ctor(IComponent[] components)
public IComponent get_Item(string name)
public IComponent get_Item(int index)
public void CopyTo(IComponent[] array, int index)
}
public System.ComponentModel.ComponentConverter : ReferenceConverter {
public void .ctor(Type type)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.ComponentEditor : object {
public bool EditComponent(object component)
public bool EditComponent(ITypeDescriptorContext context, object component)
}
public System.ComponentModel.ComponentResourceManager : ResourceManager {
private Hashtable _resourceSets
private CultureInfo _neutralResourcesCulture
private CultureInfo NeutralResourcesCulture
public void .ctor(Type t)
private CultureInfo get_NeutralResourcesCulture()
public void ApplyResources(object value, string objectName)
public void ApplyResources(object value, string objectName, CultureInfo culture)
private SortedList`2<string, object> FillResources(CultureInfo culture, ResourceSet& resourceSet)
}
public System.ComponentModel.Container : object {
private ISite[] sites
private int siteCount
private ComponentCollection components
private ContainerFilterService filter
private bool checkedFilter
private object syncObj
public ComponentCollection Components
protected void Finalize()
public void Add(IComponent component)
public void Add(IComponent component, string name)
protected ISite CreateSite(IComponent component, string name)
public void Dispose()
protected void Dispose(bool disposing)
protected object GetService(Type service)
public ComponentCollection get_Components()
public void Remove(IComponent component)
private void Remove(IComponent component, bool preserveSite)
protected void RemoveWithoutUnsiting(IComponent component)
protected void ValidateName(IComponent component, string name)
}
public System.ComponentModel.ContainerFilterService : object {
public ComponentCollection FilterComponents(ComponentCollection components)
}
public System.ComponentModel.CultureInfoConverter : TypeConverter {
private StandardValuesCollection values
private string DefaultCultureString
private string get_DefaultCultureString()
protected string GetCultureName(CultureInfo culture)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.CustomTypeDescriptor : object {
private ICustomTypeDescriptor _parent
protected void .ctor(ICustomTypeDescriptor parent)
public AttributeCollection GetAttributes()
public string GetClassName()
public string GetComponentName()
public TypeConverter GetConverter()
public EventDescriptor GetDefaultEvent()
public PropertyDescriptor GetDefaultProperty()
public object GetEditor(Type editorBaseType)
public EventDescriptorCollection GetEvents()
public EventDescriptorCollection GetEvents(Attribute[] attributes)
public PropertyDescriptorCollection GetProperties()
public PropertyDescriptorCollection GetProperties(Attribute[] attributes)
public object GetPropertyOwner(PropertyDescriptor pd)
}
public System.ComponentModel.DataErrorsChangedEventArgs : EventArgs {
private string propertyName
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
}
public System.ComponentModel.DataObjectAttribute : Attribute {
public DataObjectAttribute DataObject
public DataObjectAttribute NonDataObject
public DataObjectAttribute Default
private bool _isDataObject
public bool IsDataObject
public void .ctor(bool isDataObject)
public bool get_IsDataObject()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DataObjectFieldAttribute : Attribute {
private bool _primaryKey
private bool _isIdentity
private bool _isNullable
private int _length
public bool IsIdentity
public bool IsNullable
public int Length
public bool PrimaryKey
public void .ctor(bool primaryKey)
public void .ctor(bool primaryKey, bool isIdentity)
public void .ctor(bool primaryKey, bool isIdentity, bool isNullable)
public void .ctor(bool primaryKey, bool isIdentity, bool isNullable, int length)
public bool get_IsIdentity()
public bool get_IsNullable()
public int get_Length()
public bool get_PrimaryKey()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DataObjectMethodAttribute : Attribute {
private bool _isDefault
private DataObjectMethodType _methodType
public bool IsDefault
public DataObjectMethodType MethodType
public void .ctor(DataObjectMethodType methodType)
public void .ctor(DataObjectMethodType methodType, bool isDefault)
public bool get_IsDefault()
public DataObjectMethodType get_MethodType()
public bool Equals(object obj)
public int GetHashCode()
public bool Match(object obj)
}
public System.ComponentModel.DataObjectMethodType : Enum {
public int value__
public DataObjectMethodType Fill
public DataObjectMethodType Select
public DataObjectMethodType Update
public DataObjectMethodType Insert
public DataObjectMethodType Delete
}
public System.ComponentModel.DateTimeConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.DateTimeOffsetConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.DecimalConverter : BaseNumberConverter {
internal bool AllowHex
internal Type TargetType
internal bool get_AllowHex()
internal Type get_TargetType()
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.DefaultBindingPropertyAttribute : Attribute {
private string name
public DefaultBindingPropertyAttribute Default
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DefaultEventAttribute : Attribute {
private string name
public DefaultEventAttribute Default
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DefaultPropertyAttribute : Attribute {
private string name
public DefaultPropertyAttribute Default
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DefaultValueAttribute : Attribute {
private object value
public object Value
public void .ctor(Type type, string value)
public void .ctor(char value)
public void .ctor(byte value)
public void .ctor(short value)
public void .ctor(int value)
public void .ctor(long value)
public void .ctor(float value)
public void .ctor(double value)
public void .ctor(bool value)
public void .ctor(string value)
public void .ctor(object value)
public object get_Value()
public bool Equals(object obj)
public int GetHashCode()
protected void SetValue(object value)
}
internal System.ComponentModel.DelegatingTypeDescriptionProvider : TypeDescriptionProvider {
private Type _type
internal TypeDescriptionProvider Provider
internal void .ctor(Type type)
internal TypeDescriptionProvider get_Provider()
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
public IDictionary GetCache(object instance)
public string GetFullComponentName(object component)
public ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance)
protected internal IExtenderProvider[] GetExtenderProviders(object instance)
public Type GetReflectionType(Type objectType, object instance)
public Type GetRuntimeType(Type objectType)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance)
public bool IsSupportedType(Type type)
}
public System.ComponentModel.DescriptionAttribute : Attribute {
public DescriptionAttribute Default
private string description
public string Description
protected string DescriptionValue
public void .ctor(string description)
public string get_Description()
protected string get_DescriptionValue()
protected void set_DescriptionValue(string value)
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.Design.ActiveDesignerEventArgs : EventArgs {
private IDesignerHost oldDesigner
private IDesignerHost newDesigner
public IDesignerHost OldDesigner
public IDesignerHost NewDesigner
public void .ctor(IDesignerHost oldDesigner, IDesignerHost newDesigner)
public IDesignerHost get_OldDesigner()
public IDesignerHost get_NewDesigner()
}
public System.ComponentModel.Design.ActiveDesignerEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ActiveDesignerEventArgs e)
public IAsyncResult BeginInvoke(object sender, ActiveDesignerEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.CheckoutException : ExternalException {
public CheckoutException Canceled
public void .ctor(string message)
public void .ctor(string message, int errorCode)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.ComponentModel.Design.CommandID : object {
private Guid menuGroup
private int commandID
public int ID
public Guid Guid
public void .ctor(Guid menuGroup, int commandID)
public int get_ID()
public bool Equals(object obj)
public int GetHashCode()
public Guid get_Guid()
public string ToString()
}
public System.ComponentModel.Design.ComponentChangedEventArgs : EventArgs {
private object component
private MemberDescriptor member
private object oldValue
private object newValue
public object Component
public MemberDescriptor Member
public object NewValue
public object OldValue
public object get_Component()
public MemberDescriptor get_Member()
public object get_NewValue()
public object get_OldValue()
public void .ctor(object component, MemberDescriptor member, object oldValue, object newValue)
}
public System.ComponentModel.Design.ComponentChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.ComponentChangingEventArgs : EventArgs {
private object component
private MemberDescriptor member
public object Component
public MemberDescriptor Member
public object get_Component()
public MemberDescriptor get_Member()
public void .ctor(object component, MemberDescriptor member)
}
public System.ComponentModel.Design.ComponentChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.ComponentEventArgs : EventArgs {
private IComponent component
public IComponent Component
public IComponent get_Component()
public void .ctor(IComponent component)
}
public System.ComponentModel.Design.ComponentEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.ComponentRenameEventArgs : EventArgs {
private object component
private string oldName
private string newName
public object Component
public string OldName
public string NewName
public object get_Component()
public string get_OldName()
public string get_NewName()
public void .ctor(object component, string oldName, string newName)
}
public System.ComponentModel.Design.ComponentRenameEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentRenameEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentRenameEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.DesignerCollection : object {
private IList designers
public int Count
public IDesignerHost Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(IDesignerHost[] designers)
public void .ctor(IList designers)
public int get_Count()
public IDesignerHost get_Item(int index)
public IEnumerator GetEnumerator()
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.ComponentModel.Design.DesignerEventArgs : EventArgs {
private IDesignerHost host
public IDesignerHost Designer
public void .ctor(IDesignerHost host)
public IDesignerHost get_Designer()
}
public System.ComponentModel.Design.DesignerEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DesignerEventArgs e)
public IAsyncResult BeginInvoke(object sender, DesignerEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.DesignerOptionService : object {
private DesignerOptionCollection _options
public DesignerOptionCollection Options
public DesignerOptionCollection get_Options()
protected DesignerOptionCollection CreateOptionCollection(DesignerOptionCollection parent, string name, object value)
private PropertyDescriptor GetOptionProperty(string pageName, string valueName)
protected void PopulateOptionCollection(DesignerOptionCollection options)
protected bool ShowDialog(DesignerOptionCollection options, object optionObject)
private object System.ComponentModel.Design.IDesignerOptionService.GetOptionValue(string pageName, string valueName)
private void System.ComponentModel.Design.IDesignerOptionService.SetOptionValue(string pageName, string valueName, object value)
}
public System.ComponentModel.Design.DesignerTransaction : object {
private bool committed
private bool canceled
private bool suppressedFinalization
private string desc
public bool Canceled
public bool Committed
public string Description
protected void .ctor(string description)
public bool get_Canceled()
public bool get_Committed()
public string get_Description()
public void Cancel()
public void Commit()
protected void OnCancel()
protected void OnCommit()
protected void Finalize()
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
}
public System.ComponentModel.Design.DesignerTransactionCloseEventArgs : EventArgs {
private bool commit
private bool lastTransaction
public bool TransactionCommitted
public bool LastTransaction
public void .ctor(bool commit)
public void .ctor(bool commit, bool lastTransaction)
public bool get_TransactionCommitted()
public bool get_LastTransaction()
}
public System.ComponentModel.Design.DesignerTransactionCloseEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DesignerTransactionCloseEventArgs e)
public IAsyncResult BeginInvoke(object sender, DesignerTransactionCloseEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.DesignerVerb : MenuCommand {
public string Description
public string Text
public void .ctor(string text, EventHandler handler)
public void .ctor(string text, EventHandler handler, CommandID startCommandID)
public string get_Description()
public void set_Description(string value)
public string get_Text()
public string ToString()
}
public System.ComponentModel.Design.DesignerVerbCollection : CollectionBase {
public DesignerVerb Item
public void .ctor(DesignerVerb[] value)
public DesignerVerb get_Item(int index)
public void set_Item(int index, DesignerVerb value)
public int Add(DesignerVerb value)
public void AddRange(DesignerVerb[] value)
public void AddRange(DesignerVerbCollection value)
public void Insert(int index, DesignerVerb value)
public int IndexOf(DesignerVerb value)
public bool Contains(DesignerVerb value)
public void Remove(DesignerVerb value)
public void CopyTo(DesignerVerb[] array, int index)
protected void OnSet(int index, object oldValue, object newValue)
protected void OnInsert(int index, object value)
protected void OnClear()
protected void OnRemove(int index, object value)
protected void OnValidate(object value)
}
public System.ComponentModel.Design.DesigntimeLicenseContext : LicenseContext {
internal Hashtable savedLicenseKeys
public LicenseUsageMode UsageMode
public LicenseUsageMode get_UsageMode()
public string GetSavedLicenseKey(Type type, Assembly resourceAssembly)
public void SetSavedLicenseKey(Type type, string key)
}
public System.ComponentModel.Design.DesigntimeLicenseContextSerializer : object {
public void Serialize(Stream o, string cryptoKey, DesigntimeLicenseContext context)
internal void Deserialize(Stream o, string cryptoKey, RuntimeLicenseContext context)
}
public System.ComponentModel.Design.HelpContextType : Enum {
public int value__
public HelpContextType Ambient
public HelpContextType Window
public HelpContextType Selection
public HelpContextType ToolWindowSelection
}
public System.ComponentModel.Design.HelpKeywordAttribute : Attribute {
public HelpKeywordAttribute Default
private string contextKeyword
public string HelpKeyword
public void .ctor(string keyword)
public void .ctor(Type t)
public string get_HelpKeyword()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.Design.HelpKeywordType : Enum {
public int value__
public HelpKeywordType F1Keyword
public HelpKeywordType GeneralKeyword
public HelpKeywordType FilterKeyword
}
public System.ComponentModel.Design.IComponentChangeService {
public void add_ComponentAdded(ComponentEventHandler value)
public void remove_ComponentAdded(ComponentEventHandler value)
public void add_ComponentAdding(ComponentEventHandler value)
public void remove_ComponentAdding(ComponentEventHandler value)
public void add_ComponentChanged(ComponentChangedEventHandler value)
public void remove_ComponentChanged(ComponentChangedEventHandler value)
public void add_ComponentChanging(ComponentChangingEventHandler value)
public void remove_ComponentChanging(ComponentChangingEventHandler value)
public void add_ComponentRemoved(ComponentEventHandler value)
public void remove_ComponentRemoved(ComponentEventHandler value)
public void add_ComponentRemoving(ComponentEventHandler value)
public void remove_ComponentRemoving(ComponentEventHandler value)
public void add_ComponentRename(ComponentRenameEventHandler value)
public void remove_ComponentRename(ComponentRenameEventHandler value)
public void OnComponentChanged(object component, MemberDescriptor member, object oldValue, object newValue)
public void OnComponentChanging(object component, MemberDescriptor member)
}
public System.ComponentModel.Design.IComponentDiscoveryService {
public ICollection GetComponentTypes(IDesignerHost designerHost, Type baseType)
}
public System.ComponentModel.Design.IComponentInitializer {
public void InitializeExistingComponent(IDictionary defaultValues)
public void InitializeNewComponent(IDictionary defaultValues)
}
public System.ComponentModel.Design.IDesigner {
public IComponent Component
public DesignerVerbCollection Verbs
public IComponent get_Component()
public DesignerVerbCollection get_Verbs()
public void DoDefaultAction()
public void Initialize(IComponent component)
}
public System.ComponentModel.Design.IDesignerEventService {
public IDesignerHost ActiveDesigner
public DesignerCollection Designers
public IDesignerHost get_ActiveDesigner()
public DesignerCollection get_Designers()
public void add_ActiveDesignerChanged(ActiveDesignerEventHandler value)
public void remove_ActiveDesignerChanged(ActiveDesignerEventHandler value)
public void add_DesignerCreated(DesignerEventHandler value)
public void remove_DesignerCreated(DesignerEventHandler value)
public void add_DesignerDisposed(DesignerEventHandler value)
public void remove_DesignerDisposed(DesignerEventHandler value)
public void add_SelectionChanged(EventHandler value)
public void remove_SelectionChanged(EventHandler value)
}
public System.ComponentModel.Design.IDesignerFilter {
public void PostFilterAttributes(IDictionary attributes)
public void PostFilterEvents(IDictionary events)
public void PostFilterProperties(IDictionary properties)
public void PreFilterAttributes(IDictionary attributes)
public void PreFilterEvents(IDictionary events)
public void PreFilterProperties(IDictionary properties)
}
public System.ComponentModel.Design.IDesignerHost {
public bool Loading
public bool InTransaction
public IContainer Container
public IComponent RootComponent
public string RootComponentClassName
public string TransactionDescription
public bool get_Loading()
public bool get_InTransaction()
public IContainer get_Container()
public IComponent get_RootComponent()
public string get_RootComponentClassName()
public string get_TransactionDescription()
public void add_Activated(EventHandler value)
public void remove_Activated(EventHandler value)
public void add_Deactivated(EventHandler value)
public void remove_Deactivated(EventHandler value)
public void add_LoadComplete(EventHandler value)
public void remove_LoadComplete(EventHandler value)
public void add_TransactionClosed(DesignerTransactionCloseEventHandler value)
public void remove_TransactionClosed(DesignerTransactionCloseEventHandler value)
public void add_TransactionClosing(DesignerTransactionCloseEventHandler value)
public void remove_TransactionClosing(DesignerTransactionCloseEventHandler value)
public void add_TransactionOpened(EventHandler value)
public void remove_TransactionOpened(EventHandler value)
public void add_TransactionOpening(EventHandler value)
public void remove_TransactionOpening(EventHandler value)
public void Activate()
public IComponent CreateComponent(Type componentClass)
public IComponent CreateComponent(Type componentClass, string name)
public DesignerTransaction CreateTransaction()
public DesignerTransaction CreateTransaction(string description)
public void DestroyComponent(IComponent component)
public IDesigner GetDesigner(IComponent component)
public Type GetType(string typeName)
}
public System.ComponentModel.Design.IDesignerHostTransactionState {
public bool IsClosingTransaction
public bool get_IsClosingTransaction()
}
public System.ComponentModel.Design.IDesignerOptionService {
public object GetOptionValue(string pageName, string valueName)
public void SetOptionValue(string pageName, string valueName, object value)
}
public System.ComponentModel.Design.IDictionaryService {
public object GetKey(object value)
public object GetValue(object key)
public void SetValue(object key, object value)
}
public System.ComponentModel.Design.IEventBindingService {
public string CreateUniqueMethodName(IComponent component, EventDescriptor e)
public ICollection GetCompatibleMethods(EventDescriptor e)
public EventDescriptor GetEvent(PropertyDescriptor property)
public PropertyDescriptorCollection GetEventProperties(EventDescriptorCollection events)
public PropertyDescriptor GetEventProperty(EventDescriptor e)
public bool ShowCode()
public bool ShowCode(int lineNumber)
public bool ShowCode(IComponent component, EventDescriptor e)
}
public System.ComponentModel.Design.IExtenderListService {
public IExtenderProvider[] GetExtenderProviders()
}
public System.ComponentModel.Design.IExtenderProviderService {
public void AddExtenderProvider(IExtenderProvider provider)
public void RemoveExtenderProvider(IExtenderProvider provider)
}
public System.ComponentModel.Design.IHelpService {
public void AddContextAttribute(string name, string value, HelpKeywordType keywordType)
public void ClearContextAttributes()
public IHelpService CreateLocalContext(HelpContextType contextType)
public void RemoveContextAttribute(string name, string value)
public void RemoveLocalContext(IHelpService localContext)
public void ShowHelpFromKeyword(string helpKeyword)
public void ShowHelpFromUrl(string helpUrl)
}
public System.ComponentModel.Design.IInheritanceService {
public void AddInheritedComponents(IComponent component, IContainer container)
public InheritanceAttribute GetInheritanceAttribute(IComponent component)
}
public System.ComponentModel.Design.IMenuCommandService {
public DesignerVerbCollection Verbs
public DesignerVerbCollection get_Verbs()
public void AddCommand(MenuCommand command)
public void AddVerb(DesignerVerb verb)
public MenuCommand FindCommand(CommandID commandID)
public bool GlobalInvoke(CommandID commandID)
public void RemoveCommand(MenuCommand command)
public void RemoveVerb(DesignerVerb verb)
public void ShowContextMenu(CommandID menuID, int x, int y)
}
public System.ComponentModel.Design.IReferenceService {
public IComponent GetComponent(object reference)
public object GetReference(string name)
public string GetName(object reference)
public Object[] GetReferences()
public Object[] GetReferences(Type baseType)
}
public System.ComponentModel.Design.IResourceService {
public IResourceReader GetResourceReader(CultureInfo info)
public IResourceWriter GetResourceWriter(CultureInfo info)
}
public System.ComponentModel.Design.IRootDesigner {
public ViewTechnology[] SupportedTechnologies
public ViewTechnology[] get_SupportedTechnologies()
public object GetView(ViewTechnology technology)
}
public System.ComponentModel.Design.ISelectionService {
public object PrimarySelection
public int SelectionCount
public object get_PrimarySelection()
public int get_SelectionCount()
public void add_SelectionChanged(EventHandler value)
public void remove_SelectionChanged(EventHandler value)
public void add_SelectionChanging(EventHandler value)
public void remove_SelectionChanging(EventHandler value)
public bool GetComponentSelected(object component)
public ICollection GetSelectedComponents()
public void SetSelectedComponents(ICollection components)
public void SetSelectedComponents(ICollection components, SelectionTypes selectionType)
}
public System.ComponentModel.Design.IServiceContainer {
public void AddService(Type serviceType, object serviceInstance)
public void AddService(Type serviceType, object serviceInstance, bool promote)
public void AddService(Type serviceType, ServiceCreatorCallback callback)
public void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote)
public void RemoveService(Type serviceType)
public void RemoveService(Type serviceType, bool promote)
}
public System.ComponentModel.Design.ITreeDesigner {
public ICollection Children
public IDesigner Parent
public ICollection get_Children()
public IDesigner get_Parent()
}
public System.ComponentModel.Design.ITypeDescriptorFilterService {
public bool FilterAttributes(IComponent component, IDictionary attributes)
public bool FilterEvents(IComponent component, IDictionary events)
public bool FilterProperties(IComponent component, IDictionary properties)
}
public System.ComponentModel.Design.ITypeDiscoveryService {
public ICollection GetTypes(Type baseType, bool excludeGlobalTypes)
}
public System.ComponentModel.Design.ITypeResolutionService {
public Assembly GetAssembly(AssemblyName name)
public Assembly GetAssembly(AssemblyName name, bool throwOnError)
public Type GetType(string name)
public Type GetType(string name, bool throwOnError)
public Type GetType(string name, bool throwOnError, bool ignoreCase)
public void ReferenceAssembly(AssemblyName name)
public string GetPathOfAssembly(AssemblyName name)
}
public System.ComponentModel.Design.MenuCommand : object {
private EventHandler execHandler
private EventHandler statusHandler
private CommandID commandID
private int status
private IDictionary properties
private int ENABLED
private int INVISIBLE
private int CHECKED
private int SUPPORTED
public bool Checked
public bool Enabled
public IDictionary Properties
public bool Supported
public bool Visible
public CommandID CommandID
public int OleStatus
public void .ctor(EventHandler handler, CommandID command)
public bool get_Checked()
public void set_Checked(bool value)
public bool get_Enabled()
public void set_Enabled(bool value)
private void SetStatus(int mask, bool value)
public IDictionary get_Properties()
public bool get_Supported()
public void set_Supported(bool value)
public bool get_Visible()
public void set_Visible(bool value)
public void add_CommandChanged(EventHandler value)
public void remove_CommandChanged(EventHandler value)
public CommandID get_CommandID()
public void Invoke()
public void Invoke(object arg)
public int get_OleStatus()
protected void OnCommandChanged(EventArgs e)
public string ToString()
}
internal System.ComponentModel.Design.RuntimeLicenseContext : LicenseContext {
private TraceSwitch RuntimeLicenseContextSwitch
private int ReadBlock
internal Hashtable savedLicenseKeys
private string GetLocalPath(string fileName)
public string GetSavedLicenseKey(Type type, Assembly resourceAssembly)
private Stream CaseInsensitiveManifestResourceStreamLookup(Assembly satellite, string name)
private Stream OpenRead(Uri resourceUri)
}
public System.ComponentModel.Design.SelectionTypes : Enum {
public int value__
public SelectionTypes Auto
public SelectionTypes Normal
public SelectionTypes Replace
public SelectionTypes MouseDown
public SelectionTypes MouseUp
public SelectionTypes Click
public SelectionTypes Primary
public SelectionTypes Toggle
public SelectionTypes Add
public SelectionTypes Remove
public SelectionTypes Valid
}
public System.ComponentModel.Design.Serialization.ComponentSerializationService : object {
public SerializationStore CreateStore()
public SerializationStore LoadStore(Stream stream)
public void Serialize(SerializationStore store, object value)
public void SerializeAbsolute(SerializationStore store, object value)
public void SerializeMember(SerializationStore store, object owningObject, MemberDescriptor member)
public void SerializeMemberAbsolute(SerializationStore store, object owningObject, MemberDescriptor member)
public ICollection Deserialize(SerializationStore store)
public ICollection Deserialize(SerializationStore store, IContainer container)
public void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes, bool applyDefaults)
public void DeserializeTo(SerializationStore store, IContainer container)
public void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes)
}
public System.ComponentModel.Design.Serialization.ContextStack : object {
private ArrayList contextStack
public object Current
public object Item
public object Item
public object get_Current()
public object get_Item(int level)
public object get_Item(Type type)
public void Append(object context)
public object Pop()
public void Push(object context)
}
public System.ComponentModel.Design.Serialization.DefaultSerializationProviderAttribute : Attribute {
private string _providerTypeName
public string ProviderTypeName
public void .ctor(Type providerType)
public void .ctor(string providerTypeName)
public string get_ProviderTypeName()
}
public System.ComponentModel.Design.Serialization.DesignerLoader : object {
public bool Loading
public bool get_Loading()
public void BeginLoad(IDesignerLoaderHost host)
public void Dispose()
public void Flush()
}
public System.ComponentModel.Design.Serialization.DesignerSerializerAttribute : Attribute {
private string serializerTypeName
private string serializerBaseTypeName
private string typeId
public string SerializerTypeName
public string SerializerBaseTypeName
public object TypeId
public void .ctor(Type serializerType, Type baseSerializerType)
public void .ctor(string serializerTypeName, Type baseSerializerType)
public void .ctor(string serializerTypeName, string baseSerializerTypeName)
public string get_SerializerTypeName()
public string get_SerializerBaseTypeName()
public object get_TypeId()
}
public System.ComponentModel.Design.Serialization.IDesignerLoaderHost {
public void EndLoad(string baseClassName, bool successful, ICollection errorCollection)
public void Reload()
}
public System.ComponentModel.Design.Serialization.IDesignerLoaderHost2 {
public bool IgnoreErrorsDuringReload
public bool CanReloadWithErrors
public bool get_IgnoreErrorsDuringReload()
public void set_IgnoreErrorsDuringReload(bool value)
public bool get_CanReloadWithErrors()
public void set_CanReloadWithErrors(bool value)
}
public System.ComponentModel.Design.Serialization.IDesignerLoaderService {
public void AddLoadDependency()
public void DependentLoadComplete(bool successful, ICollection errorCollection)
public bool Reload()
}
public System.ComponentModel.Design.Serialization.IDesignerSerializationManager {
public ContextStack Context
public PropertyDescriptorCollection Properties
public ContextStack get_Context()
public PropertyDescriptorCollection get_Properties()
public void add_ResolveName(ResolveNameEventHandler value)
public void remove_ResolveName(ResolveNameEventHandler value)
public void add_SerializationComplete(EventHandler value)
public void remove_SerializationComplete(EventHandler value)
public void AddSerializationProvider(IDesignerSerializationProvider provider)
public object CreateInstance(Type type, ICollection arguments, string name, bool addToContainer)
public object GetInstance(string name)
public string GetName(object value)
public object GetSerializer(Type objectType, Type serializerType)
public Type GetType(string typeName)
public void RemoveSerializationProvider(IDesignerSerializationProvider provider)
public void ReportError(object errorInformation)
public void SetName(object instance, string name)
}
public System.ComponentModel.Design.Serialization.IDesignerSerializationProvider {
public object GetSerializer(IDesignerSerializationManager manager, object currentSerializer, Type objectType, Type serializerType)
}
public System.ComponentModel.Design.Serialization.IDesignerSerializationService {
public ICollection Deserialize(object serializationData)
public object Serialize(ICollection objects)
}
public System.ComponentModel.Design.Serialization.INameCreationService {
public string CreateName(IContainer container, Type dataType)
public bool IsValidName(string name)
public void ValidateName(string name)
}
public System.ComponentModel.Design.Serialization.InstanceDescriptor : object {
private MemberInfo member
private ICollection arguments
private bool isComplete
public ICollection Arguments
public bool IsComplete
public MemberInfo MemberInfo
public void .ctor(MemberInfo member, ICollection arguments)
public void .ctor(MemberInfo member, ICollection arguments, bool isComplete)
public ICollection get_Arguments()
public bool get_IsComplete()
public MemberInfo get_MemberInfo()
public object Invoke()
}
public System.ComponentModel.Design.Serialization.MemberRelationship : ValueType {
private object _owner
private MemberDescriptor _member
public MemberRelationship Empty
public bool IsEmpty
public MemberDescriptor Member
public object Owner
public void .ctor(object owner, MemberDescriptor member)
public bool get_IsEmpty()
public MemberDescriptor get_Member()
public object get_Owner()
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(MemberRelationship left, MemberRelationship right)
public bool op_Inequality(MemberRelationship left, MemberRelationship right)
}
public System.ComponentModel.Design.Serialization.MemberRelationshipService : object {
private Dictionary`2<RelationshipEntry, RelationshipEntry> _relationships
public MemberRelationship Item
public MemberRelationship Item
public MemberRelationship get_Item(MemberRelationship source)
public void set_Item(MemberRelationship source, MemberRelationship value)
public MemberRelationship get_Item(object sourceOwner, MemberDescriptor sourceMember)
public void set_Item(object sourceOwner, MemberDescriptor sourceMember, MemberRelationship value)
protected MemberRelationship GetRelationship(MemberRelationship source)
protected void SetRelationship(MemberRelationship source, MemberRelationship relationship)
public bool SupportsRelationship(MemberRelationship source, MemberRelationship relationship)
}
public System.ComponentModel.Design.Serialization.ResolveNameEventArgs : EventArgs {
private string name
private object value
public string Name
public object Value
public void .ctor(string name)
public string get_Name()
public object get_Value()
public void set_Value(object value)
}
public System.ComponentModel.Design.Serialization.ResolveNameEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ResolveNameEventArgs e)
public IAsyncResult BeginInvoke(object sender, ResolveNameEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.Serialization.RootDesignerSerializerAttribute : Attribute {
private bool reloadable
private string serializerTypeName
private string serializerBaseTypeName
private string typeId
public bool Reloadable
public string SerializerTypeName
public string SerializerBaseTypeName
public object TypeId
public void .ctor(Type serializerType, Type baseSerializerType, bool reloadable)
public void .ctor(string serializerTypeName, Type baseSerializerType, bool reloadable)
public void .ctor(string serializerTypeName, string baseSerializerTypeName, bool reloadable)
public bool get_Reloadable()
public string get_SerializerTypeName()
public string get_SerializerBaseTypeName()
public object get_TypeId()
}
public System.ComponentModel.Design.Serialization.SerializationStore : object {
public ICollection Errors
public ICollection get_Errors()
public void Close()
public void Save(Stream stream)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
}
public System.ComponentModel.Design.ServiceContainer : object {
private ServiceCollection`1<object> services
private IServiceProvider parentProvider
private Type[] _defaultServices
private TraceSwitch TRACESERVICE
private IServiceContainer Container
protected Type[] DefaultServices
private ServiceCollection`1<object> Services
public void .ctor(IServiceProvider parentProvider)
private IServiceContainer get_Container()
protected Type[] get_DefaultServices()
private ServiceCollection`1<object> get_Services()
public void AddService(Type serviceType, object serviceInstance)
public void AddService(Type serviceType, object serviceInstance, bool promote)
public void AddService(Type serviceType, ServiceCreatorCallback callback)
public void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote)
public void Dispose()
protected void Dispose(bool disposing)
public object GetService(Type serviceType)
public void RemoveService(Type serviceType)
public void RemoveService(Type serviceType, bool promote)
}
public System.ComponentModel.Design.ServiceCreatorCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(IServiceContainer container, Type serviceType)
public IAsyncResult BeginInvoke(IServiceContainer container, Type serviceType, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.StandardCommands : object {
private Guid standardCommandSet
private Guid ndpCommandSet
private int cmdidDesignerVerbFirst
private int cmdidDesignerVerbLast
private int cmdidArrangeIcons
private int cmdidLineupIcons
private int cmdidShowLargeIcons
public CommandID AlignBottom
public CommandID AlignHorizontalCenters
public CommandID AlignLeft
public CommandID AlignRight
public CommandID AlignToGrid
public CommandID AlignTop
public CommandID AlignVerticalCenters
public CommandID ArrangeBottom
public CommandID ArrangeRight
public CommandID BringForward
public CommandID BringToFront
public CommandID CenterHorizontally
public CommandID CenterVertically
public CommandID ViewCode
public CommandID DocumentOutline
public CommandID Copy
public CommandID Cut
public CommandID Delete
public CommandID Group
public CommandID HorizSpaceConcatenate
public CommandID HorizSpaceDecrease
public CommandID HorizSpaceIncrease
public CommandID HorizSpaceMakeEqual
public CommandID Paste
public CommandID Properties
public CommandID Redo
public CommandID MultiLevelRedo
public CommandID SelectAll
public CommandID SendBackward
public CommandID SendToBack
public CommandID SizeToControl
public CommandID SizeToControlHeight
public CommandID SizeToControlWidth
public CommandID SizeToFit
public CommandID SizeToGrid
public CommandID SnapToGrid
public CommandID TabOrder
public CommandID Undo
public CommandID MultiLevelUndo
public CommandID Ungroup
public CommandID VertSpaceConcatenate
public CommandID VertSpaceDecrease
public CommandID VertSpaceIncrease
public CommandID VertSpaceMakeEqual
public CommandID ShowGrid
public CommandID ViewGrid
public CommandID Replace
public CommandID PropertiesWindow
public CommandID LockControls
public CommandID F1Help
public CommandID ArrangeIcons
public CommandID LineupIcons
public CommandID ShowLargeIcons
public CommandID VerbFirst
public CommandID VerbLast
}
public System.ComponentModel.Design.StandardToolWindows : object {
public Guid ObjectBrowser
public Guid OutputWindow
public Guid ProjectExplorer
public Guid PropertyBrowser
public Guid RelatedLinks
public Guid ServerExplorer
public Guid TaskList
public Guid Toolbox
}
public System.ComponentModel.Design.TypeDescriptionProviderService : object {
public TypeDescriptionProvider GetProvider(object instance)
public TypeDescriptionProvider GetProvider(Type type)
}
public System.ComponentModel.Design.ViewTechnology : Enum {
public int value__
public ViewTechnology Passthrough
public ViewTechnology WindowsForms
public ViewTechnology Default
}
public System.ComponentModel.DesignerAttribute : Attribute {
private string designerTypeName
private string designerBaseTypeName
private string typeId
public string DesignerBaseTypeName
public string DesignerTypeName
public object TypeId
public void .ctor(string designerTypeName)
public void .ctor(Type designerType)
public void .ctor(string designerTypeName, string designerBaseTypeName)
public void .ctor(string designerTypeName, Type designerBaseType)
public void .ctor(Type designerType, Type designerBaseType)
public string get_DesignerBaseTypeName()
public string get_DesignerTypeName()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DesignerCategoryAttribute : Attribute {
private string category
private string typeId
public DesignerCategoryAttribute Component
public DesignerCategoryAttribute Default
public DesignerCategoryAttribute Form
public DesignerCategoryAttribute Generic
public string Category
public object TypeId
public void .ctor(string category)
public string get_Category()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DesignerSerializationVisibility : Enum {
public int value__
public DesignerSerializationVisibility Hidden
public DesignerSerializationVisibility Visible
public DesignerSerializationVisibility Content
}
public System.ComponentModel.DesignerSerializationVisibilityAttribute : Attribute {
public DesignerSerializationVisibilityAttribute Content
public DesignerSerializationVisibilityAttribute Hidden
public DesignerSerializationVisibilityAttribute Visible
public DesignerSerializationVisibilityAttribute Default
private DesignerSerializationVisibility visibility
public DesignerSerializationVisibility Visibility
public void .ctor(DesignerSerializationVisibility visibility)
public DesignerSerializationVisibility get_Visibility()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DesignOnlyAttribute : Attribute {
private bool isDesignOnly
public DesignOnlyAttribute Yes
public DesignOnlyAttribute No
public DesignOnlyAttribute Default
public bool IsDesignOnly
public void .ctor(bool isDesignOnly)
public bool get_IsDesignOnly()
public bool IsDefaultAttribute()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DesignTimeVisibleAttribute : Attribute {
private bool visible
public DesignTimeVisibleAttribute Yes
public DesignTimeVisibleAttribute No
public DesignTimeVisibleAttribute Default
public bool Visible
public void .ctor(bool visible)
public bool get_Visible()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DisplayNameAttribute : Attribute {
public DisplayNameAttribute Default
private string _displayName
public string DisplayName
protected string DisplayNameValue
public void .ctor(string displayName)
public string get_DisplayName()
protected string get_DisplayNameValue()
protected void set_DisplayNameValue(string value)
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DoubleConverter : BaseNumberConverter {
internal bool AllowHex
internal Type TargetType
internal bool get_AllowHex()
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.DoWorkEventArgs : CancelEventArgs {
private object result
private object argument
public object Argument
public object Result
public void .ctor(object argument)
public object get_Argument()
public object get_Result()
public void set_Result(object value)
}
public System.ComponentModel.DoWorkEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DoWorkEventArgs e)
public IAsyncResult BeginInvoke(object sender, DoWorkEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.EditorAttribute : Attribute {
private string baseTypeName
private string typeName
private string typeId
public string EditorBaseTypeName
public string EditorTypeName
public object TypeId
public void .ctor(string typeName, string baseTypeName)
public void .ctor(string typeName, Type baseType)
public void .ctor(Type type, Type baseType)
public string get_EditorBaseTypeName()
public string get_EditorTypeName()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.EditorBrowsableAttribute : Attribute {
private EditorBrowsableState browsableState
public EditorBrowsableState State
public void .ctor(EditorBrowsableState state)
public EditorBrowsableState get_State()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.EditorBrowsableState : Enum {
public int value__
public EditorBrowsableState Always
public EditorBrowsableState Never
public EditorBrowsableState Advanced
}
public System.ComponentModel.EnumConverter : TypeConverter {
private StandardValuesCollection values
private Type type
protected Type EnumType
protected StandardValuesCollection Values
protected IComparer Comparer
public void .ctor(Type type)
protected Type get_EnumType()
protected StandardValuesCollection get_Values()
protected void set_Values(StandardValuesCollection value)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
protected IComparer get_Comparer()
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public bool IsValid(ITypeDescriptorContext context, object value)
}
public System.ComponentModel.EventDescriptor : MemberDescriptor {
public Type ComponentType
public Type EventType
public bool IsMulticast
protected void .ctor(string name, Attribute[] attrs)
protected void .ctor(MemberDescriptor descr)
protected void .ctor(MemberDescriptor descr, Attribute[] attrs)
public Type get_ComponentType()
public Type get_EventType()
public bool get_IsMulticast()
public void AddEventHandler(object component, Delegate value)
public void RemoveEventHandler(object component, Delegate value)
}
public System.ComponentModel.EventDescriptorCollection : object {
private EventDescriptor[] events
private String[] namedSort
private IComparer comparer
private bool eventsOwned
private bool needSort
private int eventCount
private bool readOnly
public EventDescriptorCollection Empty
public int Count
public EventDescriptor Item
public EventDescriptor Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private object System.Collections.IList.Item
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
public void .ctor(EventDescriptor[] events)
public void .ctor(EventDescriptor[] events, bool readOnly)
private void .ctor(EventDescriptor[] events, int eventCount, String[] namedSort, IComparer comparer)
public int get_Count()
public EventDescriptor get_Item(int index)
public EventDescriptor get_Item(string name)
public int Add(EventDescriptor value)
public void Clear()
public bool Contains(EventDescriptor value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private void EnsureEventsOwned()
private void EnsureSize(int sizeNeeded)
public EventDescriptor Find(string name, bool ignoreCase)
public int IndexOf(EventDescriptor value)
public void Insert(int index, EventDescriptor value)
public void Remove(EventDescriptor value)
public void RemoveAt(int index)
public IEnumerator GetEnumerator()
public EventDescriptorCollection Sort()
public EventDescriptorCollection Sort(String[] names)
public EventDescriptorCollection Sort(String[] names, IComparer comparer)
public EventDescriptorCollection Sort(IComparer comparer)
protected void InternalSort(String[] names)
protected void InternalSort(IComparer sorter)
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
}
public System.ComponentModel.EventHandlerList : object {
private ListEntry head
private Component parent
public Delegate Item
internal void .ctor(Component parent)
public Delegate get_Item(object key)
public void set_Item(object key, Delegate value)
public void AddHandler(object key, Delegate value)
public void AddHandlers(EventHandlerList listToAddFrom)
public void Dispose()
private ListEntry Find(object key)
public void RemoveHandler(object key, Delegate value)
}
public System.ComponentModel.ExpandableObjectConverter : TypeConverter {
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
internal System.ComponentModel.ExtendedPropertyDescriptor : PropertyDescriptor {
private ReflectPropertyDescriptor extenderInfo
private IExtenderProvider provider
public Type ComponentType
public bool IsReadOnly
public Type PropertyType
public string DisplayName
public void .ctor(ReflectPropertyDescriptor extenderInfo, Type receiverType, IExtenderProvider provider, Attribute[] attributes)
public void .ctor(PropertyDescriptor extender, Attribute[] attributes)
public bool CanResetValue(object comp)
public Type get_ComponentType()
public bool get_IsReadOnly()
public Type get_PropertyType()
public string get_DisplayName()
public object GetValue(object comp)
public void ResetValue(object comp)
public void SetValue(object component, object value)
public bool ShouldSerializeValue(object comp)
}
public System.ComponentModel.ExtenderProvidedPropertyAttribute : Attribute {
private PropertyDescriptor extenderProperty
private IExtenderProvider provider
private Type receiverType
public PropertyDescriptor ExtenderProperty
public IExtenderProvider Provider
public Type ReceiverType
internal ExtenderProvidedPropertyAttribute Create(PropertyDescriptor extenderProperty, Type receiverType, IExtenderProvider provider)
public PropertyDescriptor get_ExtenderProperty()
public IExtenderProvider get_Provider()
public Type get_ReceiverType()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.GuidConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.HandledEventArgs : EventArgs {
private bool handled
public bool Handled
public void .ctor(bool defaultHandledValue)
public bool get_Handled()
public void set_Handled(bool value)
}
public System.ComponentModel.HandledEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, HandledEventArgs e)
public IAsyncResult BeginInvoke(object sender, HandledEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.IBindingList {
public bool AllowNew
public bool AllowEdit
public bool AllowRemove
public bool SupportsChangeNotification
public bool SupportsSearching
public bool SupportsSorting
public bool IsSorted
public PropertyDescriptor SortProperty
public ListSortDirection SortDirection
public bool get_AllowNew()
public object AddNew()
public bool get_AllowEdit()
public bool get_AllowRemove()
public bool get_SupportsChangeNotification()
public bool get_SupportsSearching()
public bool get_SupportsSorting()
public bool get_IsSorted()
public PropertyDescriptor get_SortProperty()
public ListSortDirection get_SortDirection()
public void add_ListChanged(ListChangedEventHandler value)
public void remove_ListChanged(ListChangedEventHandler value)
public void AddIndex(PropertyDescriptor property)
public void ApplySort(PropertyDescriptor property, ListSortDirection direction)
public int Find(PropertyDescriptor property, object key)
public void RemoveIndex(PropertyDescriptor property)
public void RemoveSort()
}
public System.ComponentModel.IBindingListView {
public string Filter
public ListSortDescriptionCollection SortDescriptions
public bool SupportsAdvancedSorting
public bool SupportsFiltering
public void ApplySort(ListSortDescriptionCollection sorts)
public string get_Filter()
public void set_Filter(string value)
public ListSortDescriptionCollection get_SortDescriptions()
public void RemoveFilter()
public bool get_SupportsAdvancedSorting()
public bool get_SupportsFiltering()
}
public System.ComponentModel.ICancelAddNew {
public void CancelNew(int itemIndex)
public void EndNew(int itemIndex)
}
public System.ComponentModel.IChangeTracking {
public bool IsChanged
public bool get_IsChanged()
public void AcceptChanges()
}
public System.ComponentModel.IComNativeDescriptorHandler {
public AttributeCollection GetAttributes(object component)
public string GetClassName(object component)
public TypeConverter GetConverter(object component)
public EventDescriptor GetDefaultEvent(object component)
public PropertyDescriptor GetDefaultProperty(object component)
public object GetEditor(object component, Type baseEditorType)
public string GetName(object component)
public EventDescriptorCollection GetEvents(object component)
public EventDescriptorCollection GetEvents(object component, Attribute[] attributes)
public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes)
public object GetPropertyValue(object component, string propertyName, Boolean& success)
public object GetPropertyValue(object component, int dispid, Boolean& success)
}
public System.ComponentModel.IComponent {
public ISite Site
public ISite get_Site()
public void set_Site(ISite value)
public void add_Disposed(EventHandler value)
public void remove_Disposed(EventHandler value)
}
public System.ComponentModel.IContainer {
public ComponentCollection Components
public void Add(IComponent component)
public void Add(IComponent component, string name)
public ComponentCollection get_Components()
public void Remove(IComponent component)
}
public System.ComponentModel.ICustomTypeDescriptor {
public AttributeCollection GetAttributes()
public string GetClassName()
public string GetComponentName()
public TypeConverter GetConverter()
public EventDescriptor GetDefaultEvent()
public PropertyDescriptor GetDefaultProperty()
public object GetEditor(Type editorBaseType)
public EventDescriptorCollection GetEvents()
public EventDescriptorCollection GetEvents(Attribute[] attributes)
public PropertyDescriptorCollection GetProperties()
public PropertyDescriptorCollection GetProperties(Attribute[] attributes)
public object GetPropertyOwner(PropertyDescriptor pd)
}
public System.ComponentModel.IDataErrorInfo {
public string Item
public string Error
public string get_Item(string columnName)
public string get_Error()
}
public System.ComponentModel.IEditableObject {
public void BeginEdit()
public void EndEdit()
public void CancelEdit()
}
public System.ComponentModel.IExtenderProvider {
public bool CanExtend(object extendee)
}
public System.ComponentModel.IIntellisenseBuilder {
public string Name
public string get_Name()
public bool Show(string language, string value, String& newValue)
}
public System.ComponentModel.IListSource {
public bool ContainsListCollection
public bool get_ContainsListCollection()
public IList GetList()
}
public System.ComponentModel.ImmutableObjectAttribute : Attribute {
public ImmutableObjectAttribute Yes
public ImmutableObjectAttribute No
public ImmutableObjectAttribute Default
private bool immutable
public bool Immutable
public void .ctor(bool immutable)
public bool get_Immutable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.INestedContainer {
public IComponent Owner
public IComponent get_Owner()
}
public System.ComponentModel.INestedSite {
public string FullName
public string get_FullName()
}
public System.ComponentModel.InheritanceAttribute : Attribute {
private InheritanceLevel inheritanceLevel
public InheritanceAttribute Inherited
public InheritanceAttribute InheritedReadOnly
public InheritanceAttribute NotInherited
public InheritanceAttribute Default
public InheritanceLevel InheritanceLevel
public void .ctor(InheritanceLevel inheritanceLevel)
public InheritanceLevel get_InheritanceLevel()
public bool Equals(object value)
public int GetHashCode()
public bool IsDefaultAttribute()
public string ToString()
}
public System.ComponentModel.InheritanceLevel : Enum {
public int value__
public InheritanceLevel Inherited
public InheritanceLevel InheritedReadOnly
public InheritanceLevel NotInherited
}
public System.ComponentModel.InitializationEventAttribute : Attribute {
private string eventName
public string EventName
public void .ctor(string eventName)
public string get_EventName()
}
public System.ComponentModel.INotifyDataErrorInfo {
public bool HasErrors
public bool get_HasErrors()
public IEnumerable GetErrors(string propertyName)
public void add_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value)
public void remove_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value)
}
public System.ComponentModel.INotifyPropertyChanged {
public void add_PropertyChanged(PropertyChangedEventHandler value)
public void remove_PropertyChanged(PropertyChangedEventHandler value)
}
public System.ComponentModel.INotifyPropertyChanging {
public void add_PropertyChanging(PropertyChangingEventHandler value)
public void remove_PropertyChanging(PropertyChangingEventHandler value)
}
public System.ComponentModel.InstallerTypeAttribute : Attribute {
private string _typeName
public Type InstallerType
public void .ctor(Type installerType)
public void .ctor(string typeName)
public Type get_InstallerType()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.InstanceCreationEditor : object {
public string Text
public string get_Text()
public object CreateInstance(ITypeDescriptorContext context, Type instanceType)
}
public System.ComponentModel.Int16Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, CultureInfo culture)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.Int32Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.Int64Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
internal System.ComponentModel.IntSecurity : object {
public string UnsafeGetFullPath(string fileName)
}
public System.ComponentModel.InvalidAsynchronousStateException : ArgumentException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.InvalidEnumArgumentException : ArgumentException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string argumentName, int invalidValue, Type enumClass)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.IRaiseItemChangedEvents {
public bool RaisesItemChangedEvents
public bool get_RaisesItemChangedEvents()
}
public System.ComponentModel.IRevertibleChangeTracking {
public void RejectChanges()
}
public System.ComponentModel.ISite {
public IComponent Component
public IContainer Container
public bool DesignMode
public string Name
public IComponent get_Component()
public IContainer get_Container()
public bool get_DesignMode()
public string get_Name()
public void set_Name(string value)
}
public System.ComponentModel.ISupportInitialize {
public void BeginInit()
public void EndInit()
}
public System.ComponentModel.ISupportInitializeNotification {
public bool IsInitialized
public bool get_IsInitialized()
public void add_Initialized(EventHandler value)
public void remove_Initialized(EventHandler value)
}
public System.ComponentModel.ISynchronizeInvoke {
public bool InvokeRequired
public bool get_InvokeRequired()
public IAsyncResult BeginInvoke(Delegate method, Object[] args)
public object EndInvoke(IAsyncResult result)
public object Invoke(Delegate method, Object[] args)
}
public System.ComponentModel.ITypeDescriptorContext {
public IContainer Container
public object Instance
public PropertyDescriptor PropertyDescriptor
public IContainer get_Container()
public object get_Instance()
public PropertyDescriptor get_PropertyDescriptor()
public bool OnComponentChanging()
public void OnComponentChanged()
}
public System.ComponentModel.ITypedList {
public string GetListName(PropertyDescriptor[] listAccessors)
public PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors)
}
public System.ComponentModel.License : object {
public string LicenseKey
public string get_LicenseKey()
public void Dispose()
}
public System.ComponentModel.LicenseContext : object {
public LicenseUsageMode UsageMode
public LicenseUsageMode get_UsageMode()
public string GetSavedLicenseKey(Type type, Assembly resourceAssembly)
public object GetService(Type type)
public void SetSavedLicenseKey(Type type, string key)
}
public System.ComponentModel.LicenseException : SystemException {
private Type type
private object instance
public Type LicensedType
public void .ctor(Type type)
public void .ctor(Type type, object instance)
public void .ctor(Type type, object instance, string message)
public void .ctor(Type type, object instance, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public Type get_LicensedType()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.LicenseManager : object {
private object selfLock
private LicenseContext modreq(System.Runtime.CompilerServices.IsVolatile) context
private object contextLockHolder
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) providers
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) providerInstances
private object internalSyncObject
public LicenseContext CurrentContext
public LicenseUsageMode UsageMode
public LicenseContext get_CurrentContext()
public void set_CurrentContext(LicenseContext value)
public LicenseUsageMode get_UsageMode()
private void CacheProvider(Type type, LicenseProvider provider)
public object CreateWithContext(Type type, LicenseContext creationContext)
public object CreateWithContext(Type type, LicenseContext creationContext, Object[] args)
private bool GetCachedNoLicenseProvider(Type type)
private LicenseProvider GetCachedProvider(Type type)
private LicenseProvider GetCachedProviderInstance(Type providerType)
private IntPtr GetLicenseInteropHelperType()
public bool IsLicensed(Type type)
public bool IsValid(Type type)
public bool IsValid(Type type, object instance, License& license)
public void LockContext(object contextUser)
public void UnlockContext(object contextUser)
private bool ValidateInternal(Type type, object instance, bool allowExceptions, License& license)
private bool ValidateInternalRecursive(LicenseContext context, Type type, object instance, bool allowExceptions, License& license, String& licenseKey)
public void Validate(Type type)
public License Validate(Type type, object instance)
}
public System.ComponentModel.LicenseProvider : object {
public License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions)
}
public System.ComponentModel.LicenseProviderAttribute : Attribute {
public LicenseProviderAttribute Default
private Type licenseProviderType
private string licenseProviderName
public Type LicenseProvider
public object TypeId
public void .ctor(string typeName)
public void .ctor(Type type)
public Type get_LicenseProvider()
public object get_TypeId()
public bool Equals(object value)
public int GetHashCode()
}
public System.ComponentModel.LicenseUsageMode : Enum {
public int value__
public LicenseUsageMode Runtime
public LicenseUsageMode Designtime
}
public System.ComponentModel.LicFileLicenseProvider : LicenseProvider {
protected bool IsKeyValid(string key, Type type)
protected string GetKey(Type type)
public License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions)
}
public System.ComponentModel.ListBindableAttribute : Attribute {
public ListBindableAttribute Yes
public ListBindableAttribute No
public ListBindableAttribute Default
private bool listBindable
private bool isDefault
public bool ListBindable
public void .ctor(bool listBindable)
public void .ctor(BindableSupport flags)
public bool get_ListBindable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ListChangedEventArgs : EventArgs {
private ListChangedType listChangedType
private int newIndex
private int oldIndex
private PropertyDescriptor propDesc
public ListChangedType ListChangedType
public int NewIndex
public int OldIndex
public PropertyDescriptor PropertyDescriptor
public void .ctor(ListChangedType listChangedType, int newIndex)
public void .ctor(ListChangedType listChangedType, int newIndex, PropertyDescriptor propDesc)
public void .ctor(ListChangedType listChangedType, PropertyDescriptor propDesc)
public void .ctor(ListChangedType listChangedType, int newIndex, int oldIndex)
public ListChangedType get_ListChangedType()
public int get_NewIndex()
public int get_OldIndex()
public PropertyDescriptor get_PropertyDescriptor()
}
public System.ComponentModel.ListChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ListChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ListChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.ListChangedType : Enum {
public int value__
public ListChangedType Reset
public ListChangedType ItemAdded
public ListChangedType ItemDeleted
public ListChangedType ItemMoved
public ListChangedType ItemChanged
public ListChangedType PropertyDescriptorAdded
public ListChangedType PropertyDescriptorDeleted
public ListChangedType PropertyDescriptorChanged
}
public System.ComponentModel.ListSortDescription : object {
private PropertyDescriptor property
private ListSortDirection sortDirection
public PropertyDescriptor PropertyDescriptor
public ListSortDirection SortDirection
public void .ctor(PropertyDescriptor property, ListSortDirection direction)
public PropertyDescriptor get_PropertyDescriptor()
public void set_PropertyDescriptor(PropertyDescriptor value)
public ListSortDirection get_SortDirection()
public void set_SortDirection(ListSortDirection value)
}
public System.ComponentModel.ListSortDescriptionCollection : object {
private ArrayList sorts
public ListSortDescription Item
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(ListSortDescription[] sorts)
public ListSortDescription get_Item(int index)
public void set_Item(int index, ListSortDescription value)
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
public bool Contains(object value)
public int IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.ComponentModel.ListSortDirection : Enum {
public int value__
public ListSortDirection Ascending
public ListSortDirection Descending
}
public System.ComponentModel.LocalizableAttribute : Attribute {
private bool isLocalizable
public LocalizableAttribute Yes
public LocalizableAttribute No
public LocalizableAttribute Default
public bool IsLocalizable
public void .ctor(bool isLocalizable)
public bool get_IsLocalizable()
public bool IsDefaultAttribute()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.LookupBindingPropertiesAttribute : Attribute {
private string dataSource
private string displayMember
private string valueMember
private string lookupMember
public LookupBindingPropertiesAttribute Default
public string DataSource
public string DisplayMember
public string ValueMember
public string LookupMember
public void .ctor(string dataSource, string displayMember, string valueMember, string lookupMember)
public string get_DataSource()
public string get_DisplayMember()
public string get_ValueMember()
public string get_LookupMember()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.MarshalByValueComponent : object {
private object EventDisposed
private ISite site
private EventHandlerList events
protected EventHandlerList Events
public ISite Site
public IContainer Container
public bool DesignMode
protected void Finalize()
public void add_Disposed(EventHandler value)
public void remove_Disposed(EventHandler value)
protected EventHandlerList get_Events()
public ISite get_Site()
public void set_Site(ISite value)
public void Dispose()
protected void Dispose(bool disposing)
public IContainer get_Container()
public object GetService(Type service)
public bool get_DesignMode()
public string ToString()
}
public System.ComponentModel.MaskedTextProvider : object {
private char spaceChar
private char defaultPromptChar
private char nullPasswordChar
private bool defaultAllowPrompt
private int invalidIndex
private byte editAny
private byte editUnassigned
private byte editAssigned
private bool forward
private bool backward
private int ASCII_ONLY
private int ALLOW_PROMPT_AS_INPUT
private int INCLUDE_PROMPT
private int INCLUDE_LITERALS
private int RESET_ON_PROMPT
private int RESET_ON_LITERALS
private int SKIP_SPACE
private Type maskTextProviderType
private BitVector32 flagState
private CultureInfo culture
private StringBuilder testString
private int assignedCharCount
private int requiredCharCount
private int requiredEditChars
private int optionalEditChars
private string mask
private char passwordChar
private char promptChar
private List`1<CharDescriptor> stringDescriptor
public bool AllowPromptAsInput
public int AssignedEditPositionCount
public int AvailableEditPositionCount
public CultureInfo Culture
public char DefaultPasswordChar
public int EditPositionCount
public IEnumerator EditPositions
public bool IncludeLiterals
public bool IncludePrompt
public bool AsciiOnly
public bool IsPassword
public int InvalidIndex
public int LastAssignedPosition
public int Length
public string Mask
public bool MaskCompleted
public bool MaskFull
public char PasswordChar
public char PromptChar
public bool ResetOnPrompt
public bool ResetOnSpace
public bool SkipLiterals
public char Item
public void .ctor(string mask)
public void .ctor(string mask, bool restrictToAscii)
public void .ctor(string mask, CultureInfo culture)
public void .ctor(string mask, CultureInfo culture, bool restrictToAscii)
public void .ctor(string mask, char passwordChar, bool allowPromptAsInput)
public void .ctor(string mask, CultureInfo culture, char passwordChar, bool allowPromptAsInput)
public void .ctor(string mask, CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii)
private void Initialize()
public bool get_AllowPromptAsInput()
public int get_AssignedEditPositionCount()
public int get_AvailableEditPositionCount()
public object Clone()
public CultureInfo get_Culture()
public char get_DefaultPasswordChar()
public int get_EditPositionCount()
public IEnumerator get_EditPositions()
public bool get_IncludeLiterals()
public void set_IncludeLiterals(bool value)
public bool get_IncludePrompt()
public void set_IncludePrompt(bool value)
public bool get_AsciiOnly()
public bool get_IsPassword()
public void set_IsPassword(bool value)
public int get_InvalidIndex()
public int get_LastAssignedPosition()
public int get_Length()
public string get_Mask()
public bool get_MaskCompleted()
public bool get_MaskFull()
public char get_PasswordChar()
public void set_PasswordChar(char value)
public char get_PromptChar()
public void set_PromptChar(char value)
public bool get_ResetOnPrompt()
public void set_ResetOnPrompt(bool value)
public bool get_ResetOnSpace()
public void set_ResetOnSpace(bool value)
public bool get_SkipLiterals()
public void set_SkipLiterals(bool value)
public char get_Item(int index)
public bool Add(char input)
public bool Add(char input, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Add(string input)
public bool Add(string input, Int32& testPosition, MaskedTextResultHint& resultHint)
public void Clear()
public void Clear(MaskedTextResultHint& resultHint)
public int FindAssignedEditPositionFrom(int position, bool direction)
public int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction)
public int FindEditPositionFrom(int position, bool direction)
public int FindEditPositionInRange(int startPosition, int endPosition, bool direction)
private int FindEditPositionInRange(int startPosition, int endPosition, bool direction, byte assignedStatus)
public int FindNonEditPositionFrom(int position, bool direction)
public int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction)
private int FindPositionInRange(int startPosition, int endPosition, bool direction, CharType charTypeFlags)
public int FindUnassignedEditPositionFrom(int position, bool direction)
public int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction)
public bool GetOperationResultFromHint(MaskedTextResultHint hint)
public bool InsertAt(char input, int position)
public bool InsertAt(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool InsertAt(string input, int position)
public bool InsertAt(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
private bool InsertAtInt(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint, bool testOnly)
private bool IsAscii(char c)
private bool IsAciiAlphanumeric(char c)
private bool IsAlphanumeric(char c)
private bool IsAsciiLetter(char c)
public bool IsAvailablePosition(int position)
public bool IsEditPosition(int position)
private bool IsEditPosition(CharDescriptor charDescriptor)
private bool IsLiteralPosition(CharDescriptor charDescriptor)
private bool IsPrintableChar(char c)
public bool IsValidInputChar(char c)
public bool IsValidMaskChar(char c)
public bool IsValidPasswordChar(char c)
public bool Remove()
public bool Remove(Int32& testPosition, MaskedTextResultHint& resultHint)
public bool RemoveAt(int position)
public bool RemoveAt(int startPosition, int endPosition)
public bool RemoveAt(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint)
private bool RemoveAtInt(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint, bool testOnly)
public bool Replace(char input, int position)
public bool Replace(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(char input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(string input, int position)
public bool Replace(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(string input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint)
private void ResetChar(int testPosition)
private void ResetString(int startPosition, int endPosition)
public bool Set(string input)
public bool Set(string input, Int32& testPosition, MaskedTextResultHint& resultHint)
private void SetChar(char input, int position)
private void SetChar(char input, int position, CharDescriptor charDescriptor)
private void SetString(string input, int testPosition)
private bool TestChar(char input, int position, MaskedTextResultHint& resultHint)
private bool TestEscapeChar(char input, int position)
private bool TestEscapeChar(char input, int position, CharDescriptor charDex)
private bool TestSetChar(char input, int position, MaskedTextResultHint& resultHint)
private bool TestSetString(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
private bool TestString(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public string ToDisplayString()
public string ToString()
public string ToString(bool ignorePasswordChar)
public string ToString(int startPosition, int length)
public string ToString(bool ignorePasswordChar, int startPosition, int length)
public string ToString(bool includePrompt, bool includeLiterals)
public string ToString(bool includePrompt, bool includeLiterals, int startPosition, int length)
public string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length)
public bool VerifyChar(char input, int position, MaskedTextResultHint& hint)
public bool VerifyEscapeChar(char input, int position)
public bool VerifyString(string input)
public bool VerifyString(string input, Int32& testPosition, MaskedTextResultHint& resultHint)
}
public System.ComponentModel.MaskedTextResultHint : Enum {
public int value__
public MaskedTextResultHint Unknown
public MaskedTextResultHint CharacterEscaped
public MaskedTextResultHint NoEffect
public MaskedTextResultHint SideEffect
public MaskedTextResultHint Success
public MaskedTextResultHint AsciiCharacterExpected
public MaskedTextResultHint AlphanumericCharacterExpected
public MaskedTextResultHint DigitExpected
public MaskedTextResultHint LetterExpected
public MaskedTextResultHint SignedDigitExpected
public MaskedTextResultHint InvalidInput
public MaskedTextResultHint PromptCharNotAllowed
public MaskedTextResultHint UnavailableEditPosition
public MaskedTextResultHint NonEditPosition
public MaskedTextResultHint PositionOutOfRange
}
public System.ComponentModel.MemberDescriptor : object {
private string name
private string displayName
private int nameHash
private AttributeCollection attributeCollection
private Attribute[] attributes
private Attribute[] originalAttributes
private bool attributesFiltered
private bool attributesFilled
private int metadataVersion
private string category
private string description
private object lockCookie
protected Attribute[] AttributeArray
public AttributeCollection Attributes
public string Category
public string Description
public bool IsBrowsable
public string Name
protected int NameHashCode
public bool DesignTimeOnly
public string DisplayName
protected void .ctor(string name)
protected void .ctor(string name, Attribute[] attributes)
protected void .ctor(MemberDescriptor descr)
protected void .ctor(MemberDescriptor oldMemberDescriptor, Attribute[] newAttributes)
protected Attribute[] get_AttributeArray()
protected void set_AttributeArray(Attribute[] value)
public AttributeCollection get_Attributes()
public string get_Category()
public string get_Description()
public bool get_IsBrowsable()
public string get_Name()
protected int get_NameHashCode()
public bool get_DesignTimeOnly()
public string get_DisplayName()
private void CheckAttributesValid()
protected AttributeCollection CreateAttributeCollection()
public bool Equals(object obj)
protected void FillAttributes(IList attributeList)
private void FilterAttributesIfNeeded()
protected MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType)
protected MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType, bool publicOnly)
public int GetHashCode()
protected object GetInvocationTarget(Type type, object instance)
protected ISite GetSite(object component)
protected object GetInvokee(Type componentClass, object component)
}
public System.ComponentModel.MergablePropertyAttribute : Attribute {
public MergablePropertyAttribute Yes
public MergablePropertyAttribute No
public MergablePropertyAttribute Default
private bool allowMerge
public bool AllowMerge
public void .ctor(bool allowMerge)
public bool get_AllowMerge()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.MultilineStringConverter : TypeConverter {
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.NestedContainer : Container {
private IComponent _owner
public IComponent Owner
protected string OwnerName
public void .ctor(IComponent owner)
public IComponent get_Owner()
protected string get_OwnerName()
protected ISite CreateSite(IComponent component, string name)
protected void Dispose(bool disposing)
protected object GetService(Type service)
private void OnOwnerDisposed(object sender, EventArgs e)
}
public System.ComponentModel.NotifyParentPropertyAttribute : Attribute {
public NotifyParentPropertyAttribute Yes
public NotifyParentPropertyAttribute No
public NotifyParentPropertyAttribute Default
private bool notifyParent
public bool NotifyParent
public void .ctor(bool notifyParent)
public bool get_NotifyParent()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.NullableConverter : TypeConverter {
private Type nullableType
private Type simpleType
private TypeConverter simpleTypeConverter
public Type NullableType
public Type UnderlyingType
public TypeConverter UnderlyingTypeConverter
public void .ctor(Type type)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
public bool GetCreateInstanceSupported(ITypeDescriptorContext context)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public bool IsValid(ITypeDescriptorContext context, object value)
public Type get_NullableType()
public Type get_UnderlyingType()
public TypeConverter get_UnderlyingTypeConverter()
}
public System.ComponentModel.ParenthesizePropertyNameAttribute : Attribute {
public ParenthesizePropertyNameAttribute Default
private bool needParenthesis
public bool NeedParenthesis
public void .ctor(bool needParenthesis)
public bool get_NeedParenthesis()
public bool Equals(object o)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.PasswordPropertyTextAttribute : Attribute {
public PasswordPropertyTextAttribute Yes
public PasswordPropertyTextAttribute No
public PasswordPropertyTextAttribute Default
private bool _password
public bool Password
public void .ctor(bool password)
public bool get_Password()
public bool Equals(object o)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ProgressChangedEventArgs : EventArgs {
private int progressPercentage
private object userState
public int ProgressPercentage
public object UserState
public void .ctor(int progressPercentage, object userState)
public int get_ProgressPercentage()
public object get_UserState()
}
public System.ComponentModel.ProgressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ProgressChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ProgressChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyChangedEventArgs : EventArgs {
private string propertyName
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
}
public System.ComponentModel.PropertyChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PropertyChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyChangingEventArgs : EventArgs {
private string propertyName
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
}
public System.ComponentModel.PropertyChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PropertyChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, PropertyChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyDescriptor : MemberDescriptor {
private TypeConverter converter
private Hashtable valueChangedHandlers
private Object[] editors
private Type[] editorTypes
private int editorCount
public Type ComponentType
public TypeConverter Converter
public bool IsLocalizable
public bool IsReadOnly
public DesignerSerializationVisibility SerializationVisibility
public Type PropertyType
public bool SupportsChangeEvents
protected void .ctor(string name, Attribute[] attrs)
protected void .ctor(MemberDescriptor descr)
protected void .ctor(MemberDescriptor descr, Attribute[] attrs)
public Type get_ComponentType()
public TypeConverter get_Converter()
public bool get_IsLocalizable()
public bool get_IsReadOnly()
public DesignerSerializationVisibility get_SerializationVisibility()
public Type get_PropertyType()
public void AddValueChanged(object component, EventHandler handler)
public bool CanResetValue(object component)
public bool Equals(object obj)
protected object CreateInstance(Type type)
protected void FillAttributes(IList attributeList)
public PropertyDescriptorCollection GetChildProperties()
public PropertyDescriptorCollection GetChildProperties(Attribute[] filter)
public PropertyDescriptorCollection GetChildProperties(object instance)
public PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter)
public object GetEditor(Type editorBaseType)
public int GetHashCode()
protected object GetInvocationTarget(Type type, object instance)
protected Type GetTypeFromName(string typeName)
public object GetValue(object component)
protected void OnValueChanged(object component, EventArgs e)
public void RemoveValueChanged(object component, EventHandler handler)
protected internal EventHandler GetValueChangedHandler(object component)
public void ResetValue(object component)
public void SetValue(object component, object value)
public bool ShouldSerializeValue(object component)
public bool get_SupportsChangeEvents()
}
public System.ComponentModel.PropertyDescriptorCollection : object {
public PropertyDescriptorCollection Empty
private IDictionary cachedFoundProperties
private bool cachedIgnoreCase
private PropertyDescriptor[] properties
private int propCount
private String[] namedSort
private IComparer comparer
private bool propsOwned
private bool needSort
private bool readOnly
public int Count
public PropertyDescriptor Item
public PropertyDescriptor Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private object System.Collections.IDictionary.Item
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
public void .ctor(PropertyDescriptor[] properties)
public void .ctor(PropertyDescriptor[] properties, bool readOnly)
private void .ctor(PropertyDescriptor[] properties, int propCount, String[] namedSort, IComparer comparer)
public int get_Count()
public PropertyDescriptor get_Item(int index)
public PropertyDescriptor get_Item(string name)
public int Add(PropertyDescriptor value)
public void Clear()
public bool Contains(PropertyDescriptor value)
public void CopyTo(Array array, int index)
private void EnsurePropsOwned()
private void EnsureSize(int sizeNeeded)
public PropertyDescriptor Find(string name, bool ignoreCase)
public int IndexOf(PropertyDescriptor value)
public void Insert(int index, PropertyDescriptor value)
public void Remove(PropertyDescriptor value)
public void RemoveAt(int index)
public PropertyDescriptorCollection Sort()
public PropertyDescriptorCollection Sort(String[] names)
public PropertyDescriptorCollection Sort(String[] names, IComparer comparer)
public PropertyDescriptorCollection Sort(IComparer comparer)
protected void InternalSort(String[] names)
protected void InternalSort(IComparer sorter)
public IEnumerator GetEnumerator()
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.IDictionary.Add(object key, object value)
private void System.Collections.IDictionary.Clear()
private bool System.Collections.IDictionary.Contains(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private ICollection System.Collections.IDictionary.get_Keys()
private ICollection System.Collections.IDictionary.get_Values()
private void System.Collections.IDictionary.Remove(object key)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
}
public System.ComponentModel.PropertyTabAttribute : Attribute {
private PropertyTabScope[] tabScopes
private Type[] tabClasses
private String[] tabClassNames
public Type[] TabClasses
protected String[] TabClassNames
public PropertyTabScope[] TabScopes
public void .ctor(Type tabClass)
public void .ctor(string tabClassName)
public void .ctor(Type tabClass, PropertyTabScope tabScope)
public void .ctor(string tabClassName, PropertyTabScope tabScope)
public Type[] get_TabClasses()
protected String[] get_TabClassNames()
public PropertyTabScope[] get_TabScopes()
public bool Equals(object other)
public bool Equals(PropertyTabAttribute other)
public int GetHashCode()
protected void InitializeArrays(String[] tabClassNames, PropertyTabScope[] tabScopes)
protected void InitializeArrays(Type[] tabClasses, PropertyTabScope[] tabScopes)
private void InitializeArrays(String[] tabClassNames, Type[] tabClasses, PropertyTabScope[] tabScopes)
}
public System.ComponentModel.PropertyTabScope : Enum {
public int value__
public PropertyTabScope Static
public PropertyTabScope Global
public PropertyTabScope Document
public PropertyTabScope Component
}
public System.ComponentModel.ProvidePropertyAttribute : Attribute {
private string propertyName
private string receiverTypeName
public string PropertyName
public string ReceiverTypeName
public object TypeId
public void .ctor(string propertyName, Type receiverType)
public void .ctor(string propertyName, string receiverTypeName)
public string get_PropertyName()
public string get_ReceiverTypeName()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.ReadOnlyAttribute : Attribute {
private bool isReadOnly
public ReadOnlyAttribute Yes
public ReadOnlyAttribute No
public ReadOnlyAttribute Default
public bool IsReadOnly
public void .ctor(bool isReadOnly)
public bool get_IsReadOnly()
public bool Equals(object value)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.RecommendedAsConfigurableAttribute : Attribute {
private bool recommendedAsConfigurable
public RecommendedAsConfigurableAttribute No
public RecommendedAsConfigurableAttribute Yes
public RecommendedAsConfigurableAttribute Default
public bool RecommendedAsConfigurable
public void .ctor(bool recommendedAsConfigurable)
public bool get_RecommendedAsConfigurable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ReferenceConverter : TypeConverter {
private string none
private Type type
public void .ctor(Type type)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
protected bool IsValueAllowed(ITypeDescriptorContext context, object value)
}
internal System.ComponentModel.ReflectEventDescriptor : EventDescriptor {
private Type type
private Type componentClass
private MethodInfo addMethod
private MethodInfo removeMethod
private EventInfo realEvent
private bool filledMethods
public Type ComponentType
public Type EventType
public bool IsMulticast
public void .ctor(Type componentClass, string name, Type type, Attribute[] attributes)
public void .ctor(Type componentClass, EventInfo eventInfo)
public void .ctor(Type componentType, EventDescriptor oldReflectEventDescriptor, Attribute[] attributes)
public Type get_ComponentType()
public Type get_EventType()
public bool get_IsMulticast()
public void AddEventHandler(object component, Delegate value)
protected void FillAttributes(IList attributes)
private void FillEventInfoAttribute(EventInfo realEventInfo, IList attributes)
private void FillMethods()
private void FillSingleMethodAttribute(MethodInfo realMethodInfo, IList attributes)
public void RemoveEventHandler(object component, Delegate value)
}
internal System.ComponentModel.ReflectPropertyDescriptor : PropertyDescriptor {
private Type[] argsNone
private object noValue
private TraceSwitch PropDescCreateSwitch
private TraceSwitch PropDescUsageSwitch
private int BitDefaultValueQueried
private int BitGetQueried
private int BitSetQueried
private int BitShouldSerializeQueried
private int BitResetQueried
private int BitChangedQueried
private int BitIPropChangedQueried
private int BitReadOnlyChecked
private int BitAmbientValueQueried
private int BitSetOnDemand
private BitVector32 state
private Type componentClass
private Type type
private object defaultValue
private object ambientValue
private PropertyInfo propInfo
private MethodInfo getMethod
private MethodInfo setMethod
private MethodInfo shouldSerializeMethod
private MethodInfo resetMethod
private EventDescriptor realChangedEvent
private EventDescriptor realIPropChangedEvent
private Type receiverType
private object AmbientValue
private EventDescriptor ChangedEventValue
private EventDescriptor IPropChangedEventValue
public Type ComponentType
private object DefaultValue
private MethodInfo GetMethodValue
private bool IsExtender
public bool IsReadOnly
public Type PropertyType
private MethodInfo ResetMethodValue
private MethodInfo SetMethodValue
private MethodInfo ShouldSerializeMethodValue
public bool SupportsChangeEvents
public void .ctor(Type componentClass, string name, Type type, Attribute[] attributes)
public void .ctor(Type componentClass, string name, Type type, PropertyInfo propInfo, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs)
public void .ctor(Type componentClass, string name, Type type, Type receiverType, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs)
public void .ctor(Type componentClass, PropertyDescriptor oldReflectPropertyDescriptor, Attribute[] attributes)
private object get_AmbientValue()
private EventDescriptor get_ChangedEventValue()
private EventDescriptor get_IPropChangedEventValue()
private void set_IPropChangedEventValue(EventDescriptor value)
public Type get_ComponentType()
private object get_DefaultValue()
private MethodInfo get_GetMethodValue()
private bool get_IsExtender()
public bool get_IsReadOnly()
public Type get_PropertyType()
private MethodInfo get_ResetMethodValue()
private MethodInfo get_SetMethodValue()
private MethodInfo get_ShouldSerializeMethodValue()
public void AddValueChanged(object component, EventHandler handler)
internal bool ExtenderCanResetValue(IExtenderProvider provider, object component)
internal Type ExtenderGetReceiverType()
internal Type ExtenderGetType(IExtenderProvider provider)
internal object ExtenderGetValue(IExtenderProvider provider, object component)
internal void ExtenderResetValue(IExtenderProvider provider, object component, PropertyDescriptor notifyDesc)
internal void ExtenderSetValue(IExtenderProvider provider, object component, object value, PropertyDescriptor notifyDesc)
internal bool ExtenderShouldSerializeValue(IExtenderProvider provider, object component)
public bool CanResetValue(object component)
protected void FillAttributes(IList attributes)
public object GetValue(object component)
internal void OnINotifyPropertyChanged(object component, PropertyChangedEventArgs e)
protected void OnValueChanged(object component, EventArgs e)
public void RemoveValueChanged(object component, EventHandler handler)
public void ResetValue(object component)
public void SetValue(object component, object value)
public bool ShouldSerializeValue(object component)
public bool get_SupportsChangeEvents()
}
internal System.ComponentModel.ReflectTypeDescriptionProvider : TypeDescriptionProvider {
private Hashtable _typeData
private Type[] _typeConstructor
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _editorTables
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _intrinsicTypeConverters
private object _intrinsicReferenceKey
private object _intrinsicNullableKey
private object _dictionaryKey
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _propertyCache
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _eventCache
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _attributeCache
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _extendedPropertyCache
private Guid _extenderProviderKey
private Guid _extenderPropertiesKey
private Guid _extenderProviderPropertiesKey
private Type[] _skipInterfaceAttributeList
private object _internalSyncObject
internal Guid ExtenderProviderKey
private Hashtable IntrinsicTypeConverters
internal Guid get_ExtenderProviderKey()
private Hashtable get_IntrinsicTypeConverters()
internal void AddEditorTable(Type editorBaseType, Hashtable table)
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
private object CreateInstance(Type objectType, Type callingType)
internal AttributeCollection GetAttributes(Type type)
public IDictionary GetCache(object instance)
internal string GetClassName(Type type)
internal string GetComponentName(Type type, object instance)
internal TypeConverter GetConverter(Type type, object instance)
internal EventDescriptor GetDefaultEvent(Type type, object instance)
internal PropertyDescriptor GetDefaultProperty(Type type, object instance)
internal object GetEditor(Type type, object instance, Type editorBaseType)
private Hashtable GetEditorTable(Type editorBaseType)
internal EventDescriptorCollection GetEvents(Type type)
internal AttributeCollection GetExtendedAttributes(object instance)
internal string GetExtendedClassName(object instance)
internal string GetExtendedComponentName(object instance)
internal TypeConverter GetExtendedConverter(object instance)
internal EventDescriptor GetExtendedDefaultEvent(object instance)
internal PropertyDescriptor GetExtendedDefaultProperty(object instance)
internal object GetExtendedEditor(object instance, Type editorBaseType)
internal EventDescriptorCollection GetExtendedEvents(object instance)
internal PropertyDescriptorCollection GetExtendedProperties(object instance)
protected internal IExtenderProvider[] GetExtenderProviders(object instance)
private IExtenderProvider[] GetExtenders(ICollection components, object instance, IDictionary cache)
internal object GetExtendedPropertyOwner(object instance, PropertyDescriptor pd)
public ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance)
public string GetFullComponentName(object component)
internal Type[] GetPopulatedTypes(Module module)
internal PropertyDescriptorCollection GetProperties(Type type)
internal object GetPropertyOwner(Type type, object instance, PropertyDescriptor pd)
public Type GetReflectionType(Type objectType, object instance)
private ReflectedTypeData GetTypeData(Type type, bool createIfNeeded)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance)
private Type GetTypeFromName(string typeName)
internal bool IsPopulated(Type type)
private Attribute[] ReflectGetAttributes(Type type)
internal Attribute[] ReflectGetAttributes(MemberInfo member)
private EventDescriptor[] ReflectGetEvents(Type type)
private PropertyDescriptor[] ReflectGetExtendedProperties(IExtenderProvider provider)
private PropertyDescriptor[] ReflectGetProperties(Type type)
internal void Refresh(Type type)
private object SearchIntrinsicTable(Hashtable table, Type callingType)
}
public System.ComponentModel.RefreshEventArgs : EventArgs {
private object componentChanged
private Type typeChanged
public object ComponentChanged
public Type TypeChanged
public void .ctor(object componentChanged)
public void .ctor(Type typeChanged)
public object get_ComponentChanged()
public Type get_TypeChanged()
}
public System.ComponentModel.RefreshEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(RefreshEventArgs e)
public IAsyncResult BeginInvoke(RefreshEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.RefreshProperties : Enum {
public int value__
public RefreshProperties None
public RefreshProperties All
public RefreshProperties Repaint
}
public System.ComponentModel.RefreshPropertiesAttribute : Attribute {
public RefreshPropertiesAttribute All
public RefreshPropertiesAttribute Repaint
public RefreshPropertiesAttribute Default
private RefreshProperties refresh
public RefreshProperties RefreshProperties
public void .ctor(RefreshProperties refresh)
public RefreshProperties get_RefreshProperties()
public bool Equals(object value)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.RunInstallerAttribute : Attribute {
private bool runInstaller
public RunInstallerAttribute Yes
public RunInstallerAttribute No
public RunInstallerAttribute Default
public bool RunInstaller
public void .ctor(bool runInstaller)
public bool get_RunInstaller()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.RunWorkerCompletedEventArgs : AsyncCompletedEventArgs {
private object result
public object Result
public object UserState
public void .ctor(object result, Exception error, bool cancelled)
public object get_Result()
public object get_UserState()
}
public System.ComponentModel.RunWorkerCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, RunWorkerCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, RunWorkerCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.SByteConverter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.SettingsBindableAttribute : Attribute {
public SettingsBindableAttribute Yes
public SettingsBindableAttribute No
private bool _bindable
public bool Bindable
public void .ctor(bool bindable)
public bool get_Bindable()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.SingleConverter : BaseNumberConverter {
internal bool AllowHex
internal Type TargetType
internal bool get_AllowHex()
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
internal System.ComponentModel.SRCategoryAttribute : CategoryAttribute {
public void .ctor(string category)
}
public System.ComponentModel.StringConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
}
public System.ComponentModel.SyntaxCheck : object {
public bool CheckMachineName(string value)
public bool CheckPath(string value)
public bool CheckRootedPath(string value)
}
public System.ComponentModel.TimeSpanConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.ToolboxItemAttribute : Attribute {
private Type toolboxItemType
private string toolboxItemTypeName
public ToolboxItemAttribute Default
public ToolboxItemAttribute None
public Type ToolboxItemType
public string ToolboxItemTypeName
public bool IsDefaultAttribute()
public void .ctor(bool defaultType)
public void .ctor(string toolboxItemTypeName)
public void .ctor(Type toolboxItemType)
public Type get_ToolboxItemType()
public string get_ToolboxItemTypeName()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.ToolboxItemFilterAttribute : Attribute {
private ToolboxItemFilterType filterType
private string filterString
private string typeId
public string FilterString
public ToolboxItemFilterType FilterType
public object TypeId
public void .ctor(string filterString)
public void .ctor(string filterString, ToolboxItemFilterType filterType)
public string get_FilterString()
public ToolboxItemFilterType get_FilterType()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
public bool Match(object obj)
public string ToString()
}
public System.ComponentModel.ToolboxItemFilterType : Enum {
public int value__
public ToolboxItemFilterType Allow
public ToolboxItemFilterType Custom
public ToolboxItemFilterType Prevent
public ToolboxItemFilterType Require
}
public System.ComponentModel.TypeConverter : object {
private string s_UseCompatibleTypeConverterBehavior
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) useCompatibleTypeConversion
private bool UseCompatibleTypeConversion
private bool get_UseCompatibleTypeConversion()
public bool CanConvertFrom(Type sourceType)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(Type destinationType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(object value)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertFromInvariantString(string text)
public object ConvertFromInvariantString(ITypeDescriptorContext context, string text)
public object ConvertFromString(string text)
public object ConvertFromString(ITypeDescriptorContext context, string text)
public object ConvertFromString(ITypeDescriptorContext context, CultureInfo culture, string text)
public object ConvertTo(object value, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public string ConvertToInvariantString(object value)
public string ConvertToInvariantString(ITypeDescriptorContext context, object value)
public string ConvertToString(object value)
public string ConvertToString(ITypeDescriptorContext context, object value)
public string ConvertToString(ITypeDescriptorContext context, CultureInfo culture, object value)
public object CreateInstance(IDictionary propertyValues)
public object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
protected Exception GetConvertFromException(object value)
protected Exception GetConvertToException(object value, Type destinationType)
public bool GetCreateInstanceSupported()
public bool GetCreateInstanceSupported(ITypeDescriptorContext context)
public PropertyDescriptorCollection GetProperties(object value)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported()
public bool GetPropertiesSupported(ITypeDescriptorContext context)
public ICollection GetStandardValues()
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive()
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported()
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public bool IsValid(object value)
public bool IsValid(ITypeDescriptorContext context, object value)
protected PropertyDescriptorCollection SortProperties(PropertyDescriptorCollection props, String[] names)
}
public System.ComponentModel.TypeConverterAttribute : Attribute {
private string typeName
public TypeConverterAttribute Default
public string ConverterTypeName
public void .ctor(Type type)
public void .ctor(string typeName)
public string get_ConverterTypeName()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.TypeDescriptionProvider : object {
private TypeDescriptionProvider _parent
private EmptyCustomTypeDescriptor _emptyDescriptor
protected void .ctor(TypeDescriptionProvider parent)
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
public IDictionary GetCache(object instance)
public ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance)
protected internal IExtenderProvider[] GetExtenderProviders(object instance)
public string GetFullComponentName(object component)
public Type GetReflectionType(Type objectType)
public Type GetReflectionType(object instance)
public Type GetReflectionType(Type objectType, object instance)
public Type GetRuntimeType(Type reflectionType)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType)
public ICustomTypeDescriptor GetTypeDescriptor(object instance)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance)
public bool IsSupportedType(Type type)
}
public System.ComponentModel.TypeDescriptionProviderAttribute : Attribute {
private string _typeName
public string TypeName
public void .ctor(string typeName)
public void .ctor(Type type)
public string get_TypeName()
}
public System.ComponentModel.TypeDescriptor : object {
private WeakHashtable _providerTable
private Hashtable _providerTypeTable
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _defaultProviders
private WeakHashtable modreq(System.Runtime.CompilerServices.IsVolatile) _associationTable
private int _metadataVersion
private int _collisionIndex
private BooleanSwitch TraceDescriptor
private int PIPELINE_ATTRIBUTES
private int PIPELINE_PROPERTIES
private int PIPELINE_EVENTS
private Guid[] _pipelineInitializeKeys
private Guid[] _pipelineMergeKeys
private Guid[] _pipelineFilterKeys
private Guid[] _pipelineAttributeFilterKeys
private object _internalSyncObject
private RefreshEventHandler Refreshed
public IComNativeDescriptorHandler ComNativeDescriptorHandler
public Type ComObjectType
public Type InterfaceType
internal int MetadataVersion
public IComNativeDescriptorHandler get_ComNativeDescriptorHandler()
public void set_ComNativeDescriptorHandler(IComNativeDescriptorHandler value)
public Type get_ComObjectType()
public Type get_InterfaceType()
internal int get_MetadataVersion()
public void add_Refreshed(RefreshEventHandler value)
public void remove_Refreshed(RefreshEventHandler value)
public TypeDescriptionProvider AddAttributes(Type type, Attribute[] attributes)
public TypeDescriptionProvider AddAttributes(object instance, Attribute[] attributes)
public void AddEditorTable(Type editorBaseType, Hashtable table)
public void AddProvider(TypeDescriptionProvider provider, Type type)
public void AddProvider(TypeDescriptionProvider provider, object instance)
public void AddProviderTransparent(TypeDescriptionProvider provider, Type type)
public void AddProviderTransparent(TypeDescriptionProvider provider, object instance)
private void CheckDefaultProvider(Type type)
public void CreateAssociation(object primary, object secondary)
public IDesigner CreateDesigner(IComponent component, Type designerBaseType)
public EventDescriptor CreateEvent(Type componentType, string name, Type type, Attribute[] attributes)
public EventDescriptor CreateEvent(Type componentType, EventDescriptor oldEventDescriptor, Attribute[] attributes)
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
public PropertyDescriptor CreateProperty(Type componentType, string name, Type type, Attribute[] attributes)
public PropertyDescriptor CreateProperty(Type componentType, PropertyDescriptor oldPropertyDescriptor, Attribute[] attributes)
private void DebugValidate(Type type, AttributeCollection attributes, AttributeCollection debugAttributes)
private void DebugValidate(AttributeCollection attributes, AttributeCollection debugAttributes)
private void DebugValidate(AttributeCollection attributes, Type type)
private void DebugValidate(AttributeCollection attributes, object instance, bool noCustomTypeDesc)
private void DebugValidate(TypeConverter converter, Type type)
private void DebugValidate(TypeConverter converter, object instance, bool noCustomTypeDesc)
private void DebugValidate(EventDescriptorCollection events, Type type, Attribute[] attributes)
private void DebugValidate(EventDescriptorCollection events, object instance, Attribute[] attributes, bool noCustomTypeDesc)
private void DebugValidate(PropertyDescriptorCollection properties, Type type, Attribute[] attributes)
private void DebugValidate(PropertyDescriptorCollection properties, object instance, Attribute[] attributes, bool noCustomTypeDesc)
private ArrayList FilterMembers(IList members, Attribute[] attributes)
public object GetAssociation(Type type, object primary)
public AttributeCollection GetAttributes(Type componentType)
public AttributeCollection GetAttributes(object component)
public AttributeCollection GetAttributes(object component, bool noCustomTypeDesc)
internal IDictionary GetCache(object instance)
public string GetClassName(object component)
public string GetClassName(object component, bool noCustomTypeDesc)
public string GetClassName(Type componentType)
public string GetComponentName(object component)
public string GetComponentName(object component, bool noCustomTypeDesc)
public TypeConverter GetConverter(object component)
public TypeConverter GetConverter(object component, bool noCustomTypeDesc)
public TypeConverter GetConverter(Type type)
public EventDescriptor GetDefaultEvent(Type componentType)
public EventDescriptor GetDefaultEvent(object component)
public EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc)
public PropertyDescriptor GetDefaultProperty(Type componentType)
public PropertyDescriptor GetDefaultProperty(object component)
public PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc)
internal ICustomTypeDescriptor GetDescriptor(Type type, string typeName)
internal ICustomTypeDescriptor GetDescriptor(object component, bool noCustomTypeDesc)
internal ICustomTypeDescriptor GetExtendedDescriptor(object component)
public object GetEditor(object component, Type editorBaseType)
public object GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc)
public object GetEditor(Type type, Type editorBaseType)
public EventDescriptorCollection GetEvents(Type componentType)
public EventDescriptorCollection GetEvents(Type componentType, Attribute[] attributes)
public EventDescriptorCollection GetEvents(object component)
public EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc)
public EventDescriptorCollection GetEvents(object component, Attribute[] attributes)
public EventDescriptorCollection GetEvents(object component, Attribute[] attributes, bool noCustomTypeDesc)
private string GetExtenderCollisionSuffix(MemberDescriptor member)
public string GetFullComponentName(object component)
private Type GetNodeForBaseType(Type searchType)
public PropertyDescriptorCollection GetProperties(Type componentType)
public PropertyDescriptorCollection GetProperties(Type componentType, Attribute[] attributes)
public PropertyDescriptorCollection GetProperties(object component)
public PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc)
public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes)
public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes, bool noCustomTypeDesc)
private PropertyDescriptorCollection GetPropertiesImpl(object component, Attribute[] attributes, bool noCustomTypeDesc, bool noAttributes)
public TypeDescriptionProvider GetProvider(Type type)
public TypeDescriptionProvider GetProvider(object instance)
internal TypeDescriptionProvider GetProviderRecursive(Type type)
public Type GetReflectionType(Type type)
public Type GetReflectionType(object instance)
private TypeDescriptionNode NodeFor(Type type)
private TypeDescriptionNode NodeFor(Type type, bool createDelegator)
private TypeDescriptionNode NodeFor(object instance)
private TypeDescriptionNode NodeFor(object instance, bool createDelegator)
private void NodeRemove(object key, TypeDescriptionProvider provider)
private ICollection PipelineAttributeFilter(int pipelineType, ICollection members, Attribute[] filter, object instance, IDictionary cache)
private ICollection PipelineFilter(int pipelineType, ICollection members, object instance, IDictionary cache)
private ICollection PipelineInitialize(int pipelineType, ICollection members, IDictionary cache)
private ICollection PipelineMerge(int pipelineType, ICollection primary, ICollection secondary, object instance, IDictionary cache)
private void RaiseRefresh(object component)
private void RaiseRefresh(Type type)
public void Refresh(object component)
private void Refresh(object component, bool refreshReflectionProvider)
public void Refresh(Type type)
public void Refresh(Module module)
public void Refresh(Assembly assembly)
public void RemoveAssociation(object primary, object secondary)
public void RemoveAssociations(object primary)
public void RemoveProvider(TypeDescriptionProvider provider, Type type)
public void RemoveProvider(TypeDescriptionProvider provider, object instance)
public void RemoveProviderTransparent(TypeDescriptionProvider provider, Type type)
public void RemoveProviderTransparent(TypeDescriptionProvider provider, object instance)
private bool ShouldHideMember(MemberDescriptor member, Attribute attribute)
public void SortDescriptorArray(IList infos)
internal void Trace(string message, Object[] args)
}
public System.ComponentModel.TypeListConverter : TypeConverter {
private Type[] types
private StandardValuesCollection values
protected void .ctor(Type[] types)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.UInt16Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.UInt32Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.UInt64Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal object FromString(string value, CultureInfo culture)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.WarningException : SystemException {
private string helpUrl
private string helpTopic
public string HelpUrl
public string HelpTopic
public void .ctor(string message)
public void .ctor(string message, string helpUrl)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string helpUrl, string helpTopic)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_HelpUrl()
public string get_HelpTopic()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.ComponentModel.WeakHashtable : Hashtable {
private IEqualityComparer _comparer
private long _lastGlobalMem
private int _lastHashCount
public void Clear()
public void Remove(object key)
public void SetWeak(object key, object value)
private void ScavengeKeys()
}
public System.ComponentModel.Win32Exception : ExternalException {
private int nativeErrorCode
private bool s_ErrorMessagesInitialized
private Dictionary`2<int, string> s_ErrorMessage
public int NativeErrorCode
public void .ctor(int error)
public void .ctor(int error, string message)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_NativeErrorCode()
public void GetObjectData(SerializationInfo info, StreamingContext context)
private int FormatMessage(int dwFlags, IntPtr lpSource, UInt32 dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr[] arguments)
internal string GetErrorMessage(int error)
private void InitializeErrorMessages()
}
internal System.Configuration.AllowDefinition : Enum {
public int value__
public AllowDefinition Everywhere
public AllowDefinition MachineOnly
public AllowDefinition MachineToApplication
}
public System.Configuration.ApplicationSettingsBase : SettingsBase {
private PropertyChangedEventHandler PropertyChanged
private SettingChangingEventHandler SettingChanging
private SettingsLoadedEventHandler SettingsLoaded
private SettingsSavingEventHandler SettingsSaving
private string settingsKey
private SettingsContext context
private SettingsPropertyCollection properties
private ISettingsProviderService providerService
private SettingsPropertyValueCollection propertyValues
private SettingsProviderCollection providers
public SettingsContext Context
public object Item
public SettingsPropertyCollection Properties
public SettingsPropertyValueCollection PropertyValues
public SettingsProviderCollection Providers
public string SettingsKey
protected void .ctor(IComponent owner)
protected void .ctor(string settingsKey)
protected void .ctor(IComponent owner, string settingsKey)
public void add_PropertyChanged(PropertyChangedEventHandler value)
public void remove_PropertyChanged(PropertyChangedEventHandler value)
public void add_SettingChanging(SettingChangingEventHandler value)
public void remove_SettingChanging(SettingChangingEventHandler value)
public void add_SettingsLoaded(SettingsLoadedEventHandler value)
public void remove_SettingsLoaded(SettingsLoadedEventHandler value)
public void add_SettingsSaving(SettingsSavingEventHandler value)
public void remove_SettingsSaving(SettingsSavingEventHandler value)
public object GetPreviousVersion(string propertyName)
public void Reload()
public void Reset()
public void Save()
public void Upgrade()
protected void OnPropertyChanged(object sender, PropertyChangedEventArgs e)
protected void OnSettingChanging(object sender, SettingChangingEventArgs e)
protected void OnSettingsLoaded(object sender, SettingsLoadedEventArgs e)
protected void OnSettingsSaving(object sender, CancelEventArgs e)
public SettingsContext get_Context()
private void CacheValuesByProvider(SettingsProvider provider)
private void InitializeSettings(SettingsPropertyCollection settings)
private object GetPropertyValue(string propertyName)
public object get_Item(string propertyName)
public void set_Item(string propertyName, object value)
public SettingsPropertyCollection get_Properties()
private void CreateSettingsProperty(PropertyInfo prop, SettingsPropertyCollection properties, SettingsProvider& local_provider)
public SettingsPropertyValueCollection get_PropertyValues()
public SettingsProviderCollection get_Providers()
public string get_SettingsKey()
public void set_SettingsKey(string value)
}
public System.Configuration.AppSettingsReader : object {
private NameValueCollection appSettings
public object GetValue(string key, Type type)
}
public System.Configuration.ClientSettingsSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty settings_prop
public SettingElementCollection Settings
protected ConfigurationPropertyCollection Properties
public SettingElementCollection get_Settings()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Configuration.ConfigHelper : object {
internal IDictionary GetDictionary(IDictionary prev, XmlNode region, string nameAtt, string valueAtt)
internal ConfigNameValueCollection GetNameValueCollection(NameValueCollection prev, XmlNode region, string nameAtt, string valueAtt)
private CollectionWrapper GoGetThem(CollectionWrapper result, XmlNode region, string nameAtt, string valueAtt)
}
internal System.Configuration.ConfigNameValueCollection : NameValueCollection {
private bool modified
public bool IsModified
public void .ctor(ConfigNameValueCollection col)
public void .ctor(IHashCodeProvider hashProvider, IComparer comparer)
public void ResetModified()
public bool get_IsModified()
public void Set(string name, string value)
}
internal System.Configuration.ConfigurationData : object {
private ConfigurationData parent
private Hashtable factories
private object removedMark
private object emptyMark
private Hashtable pending
private string fileName
private object groupMark
private Hashtable cache
private Hashtable FileCache
private Hashtable get_FileCache()
public void .ctor(ConfigurationData parent)
public bool Load(string fileName)
public bool LoadString(string data)
private object GetHandler(string sectionName)
private object CreateNewHandler(string sectionName, SectionData section)
private XmlDocument GetInnerDoc(XmlDocument doc, int i, String[] sectionPath)
private XmlDocument GetDocumentForSection(string sectionName)
private object GetConfigInternal(string sectionName)
public object GetConfig(string sectionName)
private object LookForFactory(string key)
private bool InitRead(XmlTextReader reader)
private void MoveToNextElement(XmlTextReader reader)
private void ReadSection(XmlTextReader reader, string sectionName)
private void ReadRemoveSection(XmlTextReader reader, string sectionName)
private void ReadSectionGroup(XmlTextReader reader, string configSection)
private void ReadSections(XmlTextReader reader, string configSection)
private void StorePending(string name, XmlTextReader reader)
private void ReadConfigFile(XmlTextReader reader)
private void ThrowException(string text, XmlTextReader reader)
}
public System.Configuration.ConfigurationException : SystemException {
private string filename
private int line
public string BareMessage
public string Filename
public int Line
public string Message
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string message, XmlNode node)
public void .ctor(string message, Exception inner, XmlNode node)
public void .ctor(string message, string filename, int line)
public void .ctor(string message, Exception inner, string filename, int line)
public string get_BareMessage()
public string get_Filename()
public int get_Line()
public string get_Message()
public string GetXmlNodeFilename(XmlNode node)
public int GetXmlNodeLineNumber(XmlNode node)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Configuration.ConfigurationSettings : object {
private IConfigurationSystem config
private object lockobj
public NameValueCollection AppSettings
public object GetConfig(string sectionName)
public NameValueCollection get_AppSettings()
internal IConfigurationSystem ChangeConfigurationSystem(IConfigurationSystem newSystem)
}
public System.Configuration.ConfigXmlDocument : XmlDocument {
private XmlTextReader reader
private string fileName
private int lineNumber
public string Filename
public int LineNumber
private string System.Configuration.Internal.IConfigErrorInfo.Filename
private int System.Configuration.Internal.IConfigErrorInfo.LineNumber
private string System.Configuration.IConfigXmlNode.Filename
private int System.Configuration.IConfigXmlNode.LineNumber
public XmlAttribute CreateAttribute(string prefix, string localName, string namespaceUri)
public XmlCDataSection CreateCDataSection(string data)
public XmlComment CreateComment(string data)
public XmlElement CreateElement(string prefix, string localName, string namespaceUri)
public XmlSignificantWhitespace CreateSignificantWhitespace(string data)
public XmlText CreateTextNode(string text)
public XmlWhitespace CreateWhitespace(string data)
public void Load(string filename)
public void LoadSingleElement(string filename, XmlTextReader sourceReader)
public string get_Filename()
public int get_LineNumber()
private string System.Configuration.Internal.IConfigErrorInfo.get_Filename()
private int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber()
private string System.Configuration.IConfigXmlNode.get_Filename()
private int System.Configuration.IConfigXmlNode.get_LineNumber()
}
internal System.Configuration.CustomizableFileSettingsProvider : SettingsProvider {
private Type webConfigurationFileMapType
private string userRoamingPath
private string userLocalPath
private string userRoamingPathPrevVersion
private string userLocalPathPrevVersion
private string userRoamingName
private string userLocalName
private string userRoamingBasePath
private string userLocalBasePath
private string CompanyName
private string ProductName
private string ForceVersion
private String[] ProductVersion
private bool isVersionMajor
private bool isVersionMinor
private bool isVersionBuild
private bool isVersionRevision
private bool isCompany
private bool isProduct
private bool isEvidence
private bool userDefine
private UserConfigLocationOption userConfig
private string app_name
private ExeConfigurationFileMap exeMapCurrent
private ExeConfigurationFileMap exeMapPrev
private SettingsPropertyValueCollection values
internal string UserRoamingFullPath
internal string UserLocalFullPath
public string PrevUserRoamingFullPath
public string PrevUserLocalFullPath
public string UserRoamingPath
public string UserLocalPath
public string UserRoamingName
public string UserLocalName
public UserConfigLocationOption UserConfigSelector
public bool IsVersionMajor
public bool IsVersionMinor
public bool IsVersionBuild
public bool IsVersionRevision
public bool IsCompany
public bool IsEvidence
public string Name
public string ApplicationName
public void Initialize(string name, NameValueCollection config)
internal string get_UserRoamingFullPath()
internal string get_UserLocalFullPath()
public string get_PrevUserRoamingFullPath()
public string get_PrevUserLocalFullPath()
public string get_UserRoamingPath()
public string get_UserLocalPath()
public string get_UserRoamingName()
public string get_UserLocalName()
public UserConfigLocationOption get_UserConfigSelector()
public void set_UserConfigSelector(UserConfigLocationOption value)
public bool get_IsVersionMajor()
public void set_IsVersionMajor(bool value)
public bool get_IsVersionMinor()
public void set_IsVersionMinor(bool value)
public bool get_IsVersionBuild()
public void set_IsVersionBuild(bool value)
public bool get_IsVersionRevision()
public void set_IsVersionRevision(bool value)
public bool get_IsCompany()
public void set_IsCompany(bool value)
public bool get_IsEvidence()
public void set_IsEvidence(bool value)
private string GetCompanyName()
private string GetProductName()
private string GetEvidenceHash()
private string GetProductVersion()
private void CreateUserConfigPath()
private string PrevVersionPath(string dirName, string currentVersion)
public bool SetUserRoamingPath(string configPath)
public bool SetUserLocalPath(string configPath)
private bool CheckFileName(string configFile)
public bool SetUserRoamingFileName(string configFile)
public bool SetUserLocalFileName(string configFile)
public bool SetCompanyName(string companyName)
public bool SetProductName(string productName)
public bool SetVersion(int major)
public bool SetVersion(int major, int minor)
public bool SetVersion(int major, int minor, int build)
public bool SetVersion(int major, int minor, int build, int revision)
public bool SetVersion(string forceVersion)
private bool CheckPath(string configPath)
public string get_Name()
public string get_ApplicationName()
public void set_ApplicationName(string value)
private string StripXmlHeader(string serializedValue)
private void SaveProperties(ExeConfigurationFileMap exeMap, SettingsPropertyValueCollection collection, ConfigurationUserLevel level, SettingsContext context, bool checkUserLevel)
private string NormalizeInvalidXmlChars(string str)
private void LoadPropertyValue(SettingsPropertyCollection collection, SettingElement element, bool allowOverwrite)
private void LoadProperties(ExeConfigurationFileMap exeMap, SettingsPropertyCollection collection, ConfigurationUserLevel level, string sectionGroupName, bool allowOverwrite, string groupName)
public void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection)
public SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection)
private void CreateExeMap()
public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property)
public void Reset(SettingsContext context)
public void Upgrade(SettingsContext context, SettingsPropertyCollection properties)
public void setCreate()
}
internal System.Configuration.DefaultConfig : object {
private DefaultConfig instance
private ConfigurationData config
public DefaultConfig GetInstance()
public object GetConfig(string sectionName)
public void Init()
private string get_bundled_machine_config()
internal string GetBundledMachineConfig()
private string get_machine_config_path()
internal string GetMachineConfigPath()
private string GetAppConfigPath()
}
public System.Configuration.DefaultSettingValueAttribute : Attribute {
private string value
public string Value
public void .ctor(string value)
public string get_Value()
}
public System.Configuration.DictionarySectionHandler : object {
protected string KeyAttributeName
protected string ValueAttributeName
public object Create(object parent, object context, XmlNode section)
protected string get_KeyAttributeName()
protected string get_ValueAttributeName()
}
public System.Configuration.IApplicationSettingsProvider {
public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property)
public void Reset(SettingsContext context)
public void Upgrade(SettingsContext context, SettingsPropertyCollection properties)
}
public System.Configuration.IConfigurationSectionHandler {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Configuration.IConfigurationSystem {
public object GetConfig(string configKey)
public void Init()
}
internal System.Configuration.IConfigXmlNode {
public string Filename
public int LineNumber
public string get_Filename()
public int get_LineNumber()
}
public System.Configuration.IdnElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty enabled_prop
internal UriIdnScope EnabledDefaultValue
public UriIdnScope Enabled
protected ConfigurationPropertyCollection Properties
public UriIdnScope get_Enabled()
public void set_Enabled(UriIdnScope value)
protected ConfigurationPropertyCollection get_Properties()
public bool Equals(object o)
public int GetHashCode()
}
public System.Configuration.IgnoreSectionHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Configuration.IPersistComponentSettings {
public bool SaveSettings
public string SettingsKey
public bool get_SaveSettings()
public void set_SaveSettings(bool value)
public string get_SettingsKey()
public void set_SettingsKey(string value)
public void LoadComponentSettings()
public void ResetComponentSettings()
public void SaveComponentSettings()
}
public System.Configuration.IriParsingElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty enabled_prop
public bool Enabled
protected ConfigurationPropertyCollection Properties
public bool get_Enabled()
public void set_Enabled(bool value)
protected ConfigurationPropertyCollection get_Properties()
public bool Equals(object o)
public int GetHashCode()
}
public System.Configuration.ISettingsProviderService {
public SettingsProvider GetSettingsProvider(SettingsProperty property)
}
public System.Configuration.LocalFileSettingsProvider : SettingsProvider {
private CustomizableFileSettingsProvider impl
public string ApplicationName
public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property)
public SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection properties)
public void Initialize(string name, NameValueCollection values)
public void Reset(SettingsContext context)
public void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection values)
public void Upgrade(SettingsContext context, SettingsPropertyCollection properties)
public string get_ApplicationName()
public void set_ApplicationName(string value)
}
public System.Configuration.NameValueFileSectionHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Configuration.NameValueSectionHandler : object {
protected string KeyAttributeName
protected string ValueAttributeName
public object Create(object parent, object context, XmlNode section)
protected string get_KeyAttributeName()
protected string get_ValueAttributeName()
}
internal System.Configuration.PrivilegedConfigurationManager : object {
internal ConnectionStringSettingsCollection ConnectionStrings
internal ConnectionStringSettingsCollection get_ConnectionStrings()
internal object GetSection(string sectionName)
}
internal System.Configuration.SectionData : object {
public string SectionName
public string TypeName
public bool AllowLocation
public AllowDefinition AllowDefinition
public string FileName
public bool RequirePermission
public void .ctor(string sectionName, string typeName, bool allowLocation, AllowDefinition allowDefinition, bool requirePermission)
}
public System.Configuration.SettingChangingEventArgs : CancelEventArgs {
private string settingName
private string settingClass
private string settingKey
private object newValue
public string SettingName
public string SettingClass
public string SettingKey
public object NewValue
public void .ctor(string settingName, string settingClass, string settingKey, object newValue, bool cancel)
public string get_SettingName()
public string get_SettingClass()
public string get_SettingKey()
public object get_NewValue()
}
public System.Configuration.SettingChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SettingChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, SettingChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Configuration.SettingElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty name_prop
private ConfigurationProperty serialize_as_prop
private ConfigurationProperty value_prop
public string Name
public SettingValueElement Value
public SettingsSerializeAs SerializeAs
protected ConfigurationPropertyCollection Properties
public void .ctor(string name, SettingsSerializeAs serializeAs)
public string get_Name()
public void set_Name(string value)
public SettingValueElement get_Value()
public void set_Value(SettingValueElement value)
public SettingsSerializeAs get_SerializeAs()
public void set_SerializeAs(SettingsSerializeAs value)
protected ConfigurationPropertyCollection get_Properties()
public bool Equals(object settings)
public int GetHashCode()
}
public System.Configuration.SettingElementCollection : ConfigurationElementCollection {
public ConfigurationElementCollectionType CollectionType
protected string ElementName
public void Add(SettingElement element)
public void Clear()
public SettingElement Get(string elementKey)
public void Remove(SettingElement element)
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public ConfigurationElementCollectionType get_CollectionType()
protected string get_ElementName()
}
public System.Configuration.SettingsAttributeDictionary : Hashtable {
public void .ctor(SettingsAttributeDictionary attributes)
}
public System.Configuration.SettingsBase : object {
private bool sync
private SettingsContext context
private SettingsPropertyCollection properties
private SettingsProviderCollection providers
private SettingsPropertyValueCollection values
public SettingsContext Context
public bool IsSynchronized
public object Item
public SettingsPropertyCollection Properties
public SettingsPropertyValueCollection PropertyValues
public SettingsProviderCollection Providers
public void Initialize(SettingsContext context, SettingsPropertyCollection properties, SettingsProviderCollection providers)
public void Save()
private void SaveCore()
public SettingsBase Synchronized(SettingsBase settingsBase)
public SettingsContext get_Context()
public bool get_IsSynchronized()
public object get_Item(string propertyName)
public void set_Item(string propertyName, object value)
public SettingsPropertyCollection get_Properties()
public SettingsPropertyValueCollection get_PropertyValues()
public SettingsProviderCollection get_Providers()
private object GetPropertyValue(string propertyName)
private void SetPropertyValue(string propertyName, object value)
}
public System.Configuration.SettingsContext : Hashtable {
private ApplicationSettingsBase current
internal ApplicationSettingsBase CurrentSettings
internal ApplicationSettingsBase get_CurrentSettings()
internal void set_CurrentSettings(ApplicationSettingsBase value)
}
public System.Configuration.SettingsDescriptionAttribute : Attribute {
private string desc
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Configuration.SettingsGroupDescriptionAttribute : Attribute {
private string desc
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Configuration.SettingsGroupNameAttribute : Attribute {
private string group_name
public string GroupName
public void .ctor(string groupName)
public string get_GroupName()
}
public System.Configuration.SettingsLoadedEventArgs : EventArgs {
private SettingsProvider provider
public SettingsProvider Provider
public void .ctor(SettingsProvider provider)
public SettingsProvider get_Provider()
}
public System.Configuration.SettingsLoadedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SettingsLoadedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SettingsLoadedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Configuration.SettingsManageability : Enum {
public int value__
public SettingsManageability Roaming
}
public System.Configuration.SettingsManageabilityAttribute : Attribute {
private SettingsManageability manageability
public SettingsManageability Manageability
public void .ctor(SettingsManageability manageability)
public SettingsManageability get_Manageability()
}
public System.Configuration.SettingsProperty : object {
private string name
private Type propertyType
private SettingsProvider provider
private bool isReadOnly
private object defaultValue
private SettingsSerializeAs serializeAs
private SettingsAttributeDictionary attributes
private bool throwOnErrorDeserializing
private bool throwOnErrorSerializing
public SettingsAttributeDictionary Attributes
public object DefaultValue
public bool IsReadOnly
public string Name
public Type PropertyType
public SettingsProvider Provider
public SettingsSerializeAs SerializeAs
public bool ThrowOnErrorDeserializing
public bool ThrowOnErrorSerializing
public void .ctor(SettingsProperty propertyToCopy)
public void .ctor(string name)
public void .ctor(string name, Type propertyType, SettingsProvider provider, bool isReadOnly, object defaultValue, SettingsSerializeAs serializeAs, SettingsAttributeDictionary attributes, bool throwOnErrorDeserializing, bool throwOnErrorSerializing)
public SettingsAttributeDictionary get_Attributes()
public object get_DefaultValue()
public void set_DefaultValue(object value)
public bool get_IsReadOnly()
public void set_IsReadOnly(bool value)
public string get_Name()
public void set_Name(string value)
public Type get_PropertyType()
public void set_PropertyType(Type value)
public SettingsProvider get_Provider()
public void set_Provider(SettingsProvider value)
public SettingsSerializeAs get_SerializeAs()
public void set_SerializeAs(SettingsSerializeAs value)
public bool get_ThrowOnErrorDeserializing()
public void set_ThrowOnErrorDeserializing(bool value)
public bool get_ThrowOnErrorSerializing()
public void set_ThrowOnErrorSerializing(bool value)
}
public System.Configuration.SettingsPropertyCollection : object {
private Hashtable items
private bool isReadOnly
public int Count
public bool IsSynchronized
public SettingsProperty Item
public object SyncRoot
public void Add(SettingsProperty property)
public void Clear()
public object Clone()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string name)
public void SetReadOnly()
protected void OnAdd(SettingsProperty property)
protected void OnAddComplete(SettingsProperty property)
protected void OnClear()
protected void OnClearComplete()
protected void OnRemove(SettingsProperty property)
protected void OnRemoveComplete(SettingsProperty property)
public int get_Count()
public bool get_IsSynchronized()
public SettingsProperty get_Item(string name)
public object get_SyncRoot()
}
public System.Configuration.SettingsPropertyIsReadOnlyException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Configuration.SettingsPropertyNotFoundException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Configuration.SettingsPropertyValue : object {
private SettingsProperty property
private object propertyValue
private object serializedValue
private bool needSerializedValue
private bool needPropertyValue
private bool dirty
private bool defaulted
private bool deserialized
public bool Deserialized
public bool IsDirty
public string Name
public SettingsProperty Property
public object PropertyValue
public object SerializedValue
public bool UsingDefaultValue
public void .ctor(SettingsProperty property)
public bool get_Deserialized()
public void set_Deserialized(bool value)
public bool get_IsDirty()
public void set_IsDirty(bool value)
public string get_Name()
public SettingsProperty get_Property()
public object get_PropertyValue()
public void set_PropertyValue(object value)
public object get_SerializedValue()
public void set_SerializedValue(object value)
public bool get_UsingDefaultValue()
internal object Reset()
private object GetDeserializedDefaultValue()
private object GetDeserializedValue(object serializedValue)
}
public System.Configuration.SettingsPropertyValueCollection : object {
private Hashtable items
private bool isReadOnly
public int Count
public bool IsSynchronized
public SettingsPropertyValue Item
public object SyncRoot
public void Add(SettingsPropertyValue property)
internal void Add(SettingsPropertyValueCollection vals)
public void Clear()
public object Clone()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string name)
public void SetReadOnly()
public int get_Count()
public bool get_IsSynchronized()
public SettingsPropertyValue get_Item(string name)
public object get_SyncRoot()
}
public System.Configuration.SettingsPropertyWrongTypeException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Configuration.SettingsProvider : ProviderBase {
public string ApplicationName
public SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection)
public void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection)
public string get_ApplicationName()
public void set_ApplicationName(string value)
}
public System.Configuration.SettingsProviderAttribute : Attribute {
private string providerTypeName
public string ProviderTypeName
public void .ctor(string providerTypeName)
public void .ctor(Type providerType)
public string get_ProviderTypeName()
}
public System.Configuration.SettingsProviderCollection : ProviderCollection {
public SettingsProvider Item
public void Add(ProviderBase provider)
public SettingsProvider get_Item(string name)
}
public System.Configuration.SettingsSavingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, CancelEventArgs e)
public IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Configuration.SettingsSerializeAs : Enum {
public int value__
public SettingsSerializeAs String
public SettingsSerializeAs Xml
public SettingsSerializeAs Binary
public SettingsSerializeAs ProviderSpecific
}
public System.Configuration.SettingsSerializeAsAttribute : Attribute {
private SettingsSerializeAs serializeAs
public SettingsSerializeAs SerializeAs
public void .ctor(SettingsSerializeAs serializeAs)
public SettingsSerializeAs get_SerializeAs()
}
public System.Configuration.SettingValueElement : ConfigurationElement {
private XmlNode node
private XmlNode original
protected ConfigurationPropertyCollection Properties
public XmlNode ValueXml
protected ConfigurationPropertyCollection get_Properties()
public XmlNode get_ValueXml()
public void set_ValueXml(XmlNode value)
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
public bool Equals(object settingValue)
public int GetHashCode()
protected bool IsModified()
protected void Reset(ConfigurationElement parentElement)
protected void ResetModified()
protected bool SerializeToXmlElement(XmlWriter writer, string elementName)
protected void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
private bool HasValue(ConfigurationElement element, string propName)
private object GetItem(ConfigurationElement element, string property)
private bool PropertyIsElement(PropertyInformation prop)
private bool ElementIsModified(ConfigurationElement element)
private void ElementUnmerge(ConfigurationElement target, ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
}
public System.Configuration.SingleTagSectionHandler : object {
public object Create(object parent, object context, XmlNode section)
}
public System.Configuration.SpecialSetting : Enum {
public int value__
public SpecialSetting ConnectionString
public SpecialSetting WebServiceUrl
}
public System.Configuration.SpecialSettingAttribute : Attribute {
private SpecialSetting setting
public SpecialSetting SpecialSetting
public void .ctor(SpecialSetting specialSetting)
public SpecialSetting get_SpecialSetting()
}
public System.Configuration.UriSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty idn_prop
private ConfigurationProperty iriParsing_prop
public IdnElement Idn
public IriParsingElement IriParsing
protected ConfigurationPropertyCollection Properties
public IdnElement get_Idn()
public IriParsingElement get_IriParsing()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Configuration.UserConfigLocationOption : Enum {
public UInt32 value__
public UserConfigLocationOption Product
public UserConfigLocationOption Product_VersionMajor
public UserConfigLocationOption Product_VersionMinor
public UserConfigLocationOption Product_VersionBuild
public UserConfigLocationOption Product_VersionRevision
public UserConfigLocationOption Company_Product
public UserConfigLocationOption Company_Product_VersionMajor
public UserConfigLocationOption Company_Product_VersionMinor
public UserConfigLocationOption Company_Product_VersionBuild
public UserConfigLocationOption Company_Product_VersionRevision
public UserConfigLocationOption Evidence
public UserConfigLocationOption Other
}
internal System.CSharpHelpers : object {
private Dictionary`2<string, object> s_fixedStringLookup
private String[][] s_keywords
public string CreateEscapedIdentifier(string name)
public bool IsValidLanguageIndependentIdentifier(string value)
internal bool IsKeyword(string value)
internal bool IsPrefixTwoUnderscore(string value)
internal bool IsValidTypeNameOrIdentifier(string value, bool isTypeName)
internal bool IsSpecialTypeChar(char ch, Boolean& nextMustBeStartChar)
}
internal System.Diagnostics.AlphabeticalEnumConverter : EnumConverter {
public void .ctor(Type type)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
}
internal System.Diagnostics.AssertSection : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propAssertUIEnabled
private ConfigurationProperty _propLogFile
public bool AssertUIEnabled
public string LogFileName
protected ConfigurationPropertyCollection Properties
public bool get_AssertUIEnabled()
public string get_LogFileName()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Diagnostics.AssertWrapper : object {
public void ShowAssert(string stackTrace, StackFrame frame, string message, string detailMessage)
}
internal System.Diagnostics.AsyncStreamReader : object {
internal int DefaultBufferSize
private int MinBufferSize
private Stream stream
private Encoding encoding
private Decoder decoder
private Byte[] byteBuffer
private Char[] charBuffer
private int _maxCharsPerBuffer
private Process process
private UserCallBack userCallBack
private bool cancelOperation
private ManualResetEvent eofEvent
private Queue messageQueue
private StringBuilder sb
private bool bLastCarriageReturn
private int currentLinePos
private object syncObject
public Encoding CurrentEncoding
public Stream BaseStream
internal void .ctor(Process process, Stream stream, UserCallBack callback, Encoding encoding)
internal void .ctor(Process process, Stream stream, UserCallBack callback, Encoding encoding, int bufferSize)
private void Init(Process process, Stream stream, UserCallBack callback, Encoding encoding, int bufferSize)
public void Close()
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
public Encoding get_CurrentEncoding()
public Stream get_BaseStream()
internal void BeginReadLine()
internal void CancelOperation()
private void ReadBuffer(IAsyncResult ar)
private void GetLinesFromStringBuilder()
private void FlushMessageQueue()
internal void WaitUtilEOF()
}
public System.Diagnostics.BooleanSwitch : Switch {
public bool Enabled
public void .ctor(string displayName, string description)
public void .ctor(string displayName, string description, string defaultSwitchValue)
public bool get_Enabled()
public void set_Enabled(bool value)
protected void OnValueChanged()
}
public System.Diagnostics.ConsoleTraceListener : TextWriterTraceListener {
public void .ctor(bool useErrorStream)
public void Close()
}
public System.Diagnostics.CorrelationManager : object {
private string transactionSlotName
private string activityIdSlotName
public Guid ActivityId
public Stack LogicalOperationStack
public Guid get_ActivityId()
public void set_ActivityId(Guid value)
public Stack get_LogicalOperationStack()
public void StartLogicalOperation(object operationId)
public void StartLogicalOperation()
public void StopLogicalOperation()
private Stack GetLogicalOperationStack()
}
public System.Diagnostics.CounterCreationData : object {
private string help
private string name
private PerformanceCounterType type
public string CounterHelp
public string CounterName
public PerformanceCounterType CounterType
public void .ctor(string counterName, string counterHelp, PerformanceCounterType counterType)
public string get_CounterHelp()
public void set_CounterHelp(string value)
public string get_CounterName()
public void set_CounterName(string value)
public PerformanceCounterType get_CounterType()
public void set_CounterType(PerformanceCounterType value)
}
public System.Diagnostics.CounterCreationDataCollection : CollectionBase {
public CounterCreationData Item
public void .ctor(CounterCreationData[] value)
public void .ctor(CounterCreationDataCollection value)
public CounterCreationData get_Item(int index)
public void set_Item(int index, CounterCreationData value)
public int Add(CounterCreationData value)
public void AddRange(CounterCreationData[] value)
public void AddRange(CounterCreationDataCollection value)
public bool Contains(CounterCreationData value)
public void CopyTo(CounterCreationData[] array, int index)
public int IndexOf(CounterCreationData value)
public void Insert(int index, CounterCreationData value)
protected void OnValidate(object value)
public void Remove(CounterCreationData value)
}
public System.Diagnostics.CounterSample : ValueType {
private long rawValue
private long baseValue
private long counterFrequency
private long systemFrequency
private long timeStamp
private long timeStamp100nSec
private long counterTimeStamp
private PerformanceCounterType counterType
public CounterSample Empty
public long BaseValue
public long CounterFrequency
public long CounterTimeStamp
public PerformanceCounterType CounterType
public long RawValue
public long SystemFrequency
public long TimeStamp
public long TimeStamp100nSec
public void .ctor(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType)
public void .ctor(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType, long counterTimeStamp)
public long get_BaseValue()
public long get_CounterFrequency()
public long get_CounterTimeStamp()
public PerformanceCounterType get_CounterType()
public long get_RawValue()
public long get_SystemFrequency()
public long get_TimeStamp()
public long get_TimeStamp100nSec()
public float Calculate(CounterSample counterSample)
public float Calculate(CounterSample counterSample, CounterSample nextCounterSample)
public bool Equals(object o)
public bool Equals(CounterSample sample)
public bool op_Equality(CounterSample a, CounterSample b)
public bool op_Inequality(CounterSample a, CounterSample b)
public int GetHashCode()
}
public System.Diagnostics.CounterSampleCalculator : object {
public float ComputeCounterValue(CounterSample newSample)
public float ComputeCounterValue(CounterSample oldSample, CounterSample newSample)
}
public System.Diagnostics.DataReceivedEventArgs : EventArgs {
private string data
public string Data
internal void .ctor(string data)
public string get_Data()
}
public System.Diagnostics.DataReceivedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DataReceivedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DataReceivedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Diagnostics.Debug : object {
public TraceListenerCollection Listeners
public bool AutoFlush
public int IndentLevel
public int IndentSize
public TraceListenerCollection get_Listeners()
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public void Flush()
public void Close()
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Assert(bool condition, string message, string detailMessageFormat, Object[] args)
public void Fail(string message)
public void Fail(string message, string detailMessage)
public void Print(string message)
public void Print(string format, Object[] args)
public void Write(string message)
public void Write(object value)
public void Write(string message, string category)
public void Write(object value, string category)
public void WriteLine(string message)
public void WriteLine(object value)
public void WriteLine(string message, string category)
public void WriteLine(object value, string category)
public void WriteLine(string format, Object[] args)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message, string category)
public void WriteIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, string message, string category)
public void WriteLineIf(bool condition, object value, string category)
public void Indent()
public void Unindent()
}
public System.Diagnostics.DefaultTraceListener : TraceListener {
private bool OnWin32
private string ConsoleOutTrace
private string ConsoleErrorTrace
private string MonoTracePrefix
private string MonoTraceFile
private string logFileName
private bool assertUiEnabled
public bool AssertUiEnabled
public string LogFileName
private string GetPrefix(string var, string target)
public bool get_AssertUiEnabled()
public void set_AssertUiEnabled(bool value)
public string get_LogFileName()
public void set_LogFileName(string value)
public void Fail(string message)
public void Fail(string message, string detailMessage)
private DialogResult ProcessUI(string message, string detailMessage)
private void WriteWindowsDebugString(string message)
private void WriteDebugString(string message)
private void WriteMonoTrace(string message)
private void WritePrefix()
private void WriteImpl(string message)
private void WriteLogFile(string message, string logFile)
public void Write(string message)
public void WriteLine(string message)
}
public System.Diagnostics.DelimitedListTraceListener : TextWriterTraceListener {
private string delimiter
private string secondaryDelim
private bool initializedDelim
public string Delimiter
public void .ctor(Stream stream)
public void .ctor(Stream stream, string name)
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string name)
public void .ctor(string fileName)
public void .ctor(string fileName, string name)
public string get_Delimiter()
public void set_Delimiter(string value)
protected internal String[] GetSupportedAttributes()
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
private void WriteHeader(string source, TraceEventType eventType, int id)
private void WriteFooter(TraceEventCache eventCache)
private void WriteEscaped(string message)
private void WriteStackEscaped(Stack stack)
}
internal System.Diagnostics.DiagnosticsConfiguration : object {
private SystemDiagnosticsSection modreq(System.Runtime.CompilerServices.IsVolatile) configSection
private InitState modreq(System.Runtime.CompilerServices.IsVolatile) initState
internal SwitchElementsCollection SwitchSettings
internal bool AssertUIEnabled
internal string ConfigFilePath
internal string LogFileName
internal bool AutoFlush
internal bool UseGlobalLock
internal int IndentSize
internal ListenerElementsCollection SharedListeners
internal SourceElementsCollection Sources
internal SystemDiagnosticsSection SystemDiagnosticsSection
internal SwitchElementsCollection get_SwitchSettings()
internal bool get_AssertUIEnabled()
internal string get_ConfigFilePath()
internal string get_LogFileName()
internal bool get_AutoFlush()
internal bool get_UseGlobalLock()
internal int get_IndentSize()
internal ListenerElementsCollection get_SharedListeners()
internal SourceElementsCollection get_Sources()
internal SystemDiagnosticsSection get_SystemDiagnosticsSection()
private SystemDiagnosticsSection GetConfigSection()
internal bool IsInitializing()
internal bool IsInitialized()
internal bool CanInitialize()
internal void Initialize()
internal void Refresh()
}
public System.Diagnostics.DiagnosticsConfigurationHandler : object {
private TraceImplSettings configValues
private IDictionary elementHandlers
public object Create(object parent, object configContext, XmlNode section)
private void AddAssertNode(IDictionary d, XmlNode node)
private void AddPerformanceCountersNode(IDictionary d, XmlNode node)
private void AddSwitchesNode(IDictionary d, XmlNode node)
private object GetSwitchValue(string name, string value)
private void AddTraceNode(IDictionary d, XmlNode node)
private void AddTraceAttributes(IDictionary d, XmlNode node)
private TraceListenerCollection GetSharedListeners(IDictionary d)
private void AddSourcesNode(IDictionary d, XmlNode node)
private void AddTraceSource(IDictionary d, Hashtable sources, XmlNode node)
private void AddTraceListeners(IDictionary d, XmlNode listenersNode, TraceListenerCollection listeners)
private void AddTraceListener(IDictionary d, XmlNode child, XmlAttributeCollection attributes, TraceListenerCollection listeners)
private void RemoveTraceListener(string name)
private string GetAttribute(XmlAttributeCollection attrs, string attr, bool required, XmlNode node)
private void ValidateAttribute(string attribute, string value, XmlNode node)
private void ValidateInvalidAttributes(XmlAttributeCollection c, XmlNode node)
private void ThrowMissingAttribute(string attribute, XmlNode node)
private void ThrowUnrecognizedNode(XmlNode node)
private void ThrowUnrecognizedElement(XmlNode node)
private void ThrowUnrecognizedAttribute(string attribute, XmlNode node)
}
public System.Diagnostics.EntryWrittenEventArgs : EventArgs {
private EventLogEntry entry
public EventLogEntry Entry
public void .ctor(EventLogEntry entry)
public EventLogEntry get_Entry()
}
public System.Diagnostics.EntryWrittenEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, EntryWrittenEventArgs e)
public IAsyncResult BeginInvoke(object sender, EntryWrittenEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Diagnostics.EnvironmentBlock : object {
public Byte[] ToByteArray(StringDictionary sd, bool unicode)
}
public System.Diagnostics.EventInstance : object {
private int _categoryId
private EventLogEntryType _entryType
private long _instanceId
public int CategoryId
public EventLogEntryType EntryType
public long InstanceId
public void .ctor(long instanceId, int categoryId)
public void .ctor(long instanceId, int categoryId, EventLogEntryType entryType)
public int get_CategoryId()
public void set_CategoryId(int value)
public EventLogEntryType get_EntryType()
public void set_EntryType(EventLogEntryType value)
public long get_InstanceId()
public void set_InstanceId(long value)
}
public System.Diagnostics.EventLog : Component {
private string source
private string logName
private string machineName
private bool doRaiseEvents
private ISynchronizeInvoke synchronizingObject
internal string LOCAL_FILE_IMPL
private string WIN32_IMPL
private string NULL_IMPL
internal string EVENTLOG_TYPE_VAR
private EventLogImpl Impl
private EntryWrittenEventHandler EntryWritten
public bool EnableRaisingEvents
public EventLogEntryCollection Entries
public string Log
public string LogDisplayName
public string MachineName
public string Source
public ISynchronizeInvoke SynchronizingObject
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
private bool Win32EventLogEnabled
private string EventLogImplType
public void .ctor(string logName)
public void .ctor(string logName, string machineName)
public void .ctor(string logName, string machineName, string source)
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
public EventLogEntryCollection get_Entries()
public string get_Log()
public void set_Log(string value)
public string get_LogDisplayName()
public string get_MachineName()
public void set_MachineName(string value)
public string get_Source()
public void set_Source(string value)
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
public void BeginInit()
public void Clear()
public void Close()
internal void Reset()
public void CreateEventSource(string source, string logName)
public void CreateEventSource(string source, string logName, string machineName)
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source)
public void DeleteEventSource(string source, string machineName)
protected void Dispose(bool disposing)
public void EndInit()
public bool Exists(string logName)
public bool Exists(string logName, string machineName)
public EventLog[] GetEventLogs()
public EventLog[] GetEventLogs(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source)
public bool SourceExists(string source, string machineName)
public void WriteEntry(string message)
public void WriteEntry(string message, EventLogEntryType type)
public void WriteEntry(string message, EventLogEntryType type, int eventID)
public void WriteEntry(string message, EventLogEntryType type, int eventID, short category)
public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, Byte[] rawData)
public void WriteEntry(string source, string message)
public void WriteEntry(string source, string message, EventLogEntryType type)
public void WriteEntry(string source, string message, EventLogEntryType type, int eventID)
public void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category)
public void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category, Byte[] rawData)
public void WriteEvent(EventInstance instance, Object[] values)
public void WriteEvent(EventInstance instance, Byte[] data, Object[] values)
public void WriteEvent(string source, EventInstance instance, Object[] values)
public void WriteEvent(string source, EventInstance instance, Byte[] data, Object[] values)
internal void OnEntryWritten(EventLogEntry newEntry)
public void add_EntryWritten(EntryWrittenEventHandler value)
public void remove_EntryWritten(EntryWrittenEventHandler value)
internal string GetLogName()
private EventLogImpl CreateEventLogImpl(string logName, string machineName, string source)
private EventLogImpl CreateEventLogImpl(EventLog eventLog)
private bool get_Win32EventLogEnabled()
private string get_EventLogImplType()
private void WriteEntry(String[] replacementStrings, EventLogEntryType type, long instanceID, short category, Byte[] rawData)
private void ValidateEventID(long instanceID)
internal int GetEventID(long instanceID)
}
public System.Diagnostics.EventLogEntry : Component {
private string category
private short categoryNumber
private Byte[] data
private EventLogEntryType entryType
private int eventID
private int index
private string machineName
private string message
private String[] replacementStrings
private string source
private DateTime timeGenerated
private DateTime timeWritten
private string userName
private long instanceId
public string Category
public short CategoryNumber
public Byte[] Data
public EventLogEntryType EntryType
public int EventID
public int Index
public long InstanceId
public string MachineName
public string Message
public String[] ReplacementStrings
public string Source
public DateTime TimeGenerated
public DateTime TimeWritten
public string UserName
internal void .ctor(string category, short categoryNumber, int index, int eventID, string source, string message, string userName, string machineName, EventLogEntryType entryType, DateTime timeGenerated, DateTime timeWritten, Byte[] data, String[] replacementStrings, long instanceId)
private void .ctor(SerializationInfo info, StreamingContext context)
public string get_Category()
public short get_CategoryNumber()
public Byte[] get_Data()
public EventLogEntryType get_EntryType()
public int get_EventID()
public int get_Index()
public long get_InstanceId()
public string get_MachineName()
public string get_Message()
public String[] get_ReplacementStrings()
public string get_Source()
public DateTime get_TimeGenerated()
public DateTime get_TimeWritten()
public string get_UserName()
public bool Equals(EventLogEntry otherEntry)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Diagnostics.EventLogEntryCollection : object {
private EventLogImpl _impl
public int Count
public EventLogEntry Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
internal void .ctor(EventLogImpl impl)
public int get_Count()
public EventLogEntry get_Item(int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void CopyTo(EventLogEntry[] entries, int index)
public IEnumerator GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int index)
}
public System.Diagnostics.EventLogEntryType : Enum {
public int value__
public EventLogEntryType Error
public EventLogEntryType Warning
public EventLogEntryType Information
public EventLogEntryType SuccessAudit
public EventLogEntryType FailureAudit
}
internal System.Diagnostics.EventLogImpl : object {
private EventLog _coreEventLog
protected EventLog CoreEventLog
public int EntryCount
public EventLogEntry Item
public string LogDisplayName
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
protected void .ctor(EventLog coreEventLog)
protected EventLog get_CoreEventLog()
public int get_EntryCount()
public EventLogEntry get_Item(int index)
public string get_LogDisplayName()
public EventLogEntry[] GetEntries()
public void DisableNotification()
public void EnableNotification()
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void EndInit()
public bool Exists(string logName, string machineName)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
public EventLog[] GetEventLogs(string machineName)
protected string GetLogDisplayName()
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
protected string FormatMessage(string source, UInt32 messageID, String[] replacementStrings)
protected String[] GetLogNames(string machineName)
protected void ValidateCustomerLogName(string logName, string machineName)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
}
public System.Diagnostics.EventLogPermission : ResourcePermissionBase {
private EventLogPermissionEntryCollection innerCollection
public EventLogPermissionEntryCollection PermissionEntries
public void .ctor(EventLogPermissionEntry[] permissionAccessEntries)
public void .ctor(PermissionState state)
public void .ctor(EventLogPermissionAccess permissionAccess, string machineName)
public EventLogPermissionEntryCollection get_PermissionEntries()
private void SetUp()
internal ResourcePermissionBaseEntry[] GetEntries()
internal void ClearEntries()
internal void Add(object obj)
internal void Remove(object obj)
}
public System.Diagnostics.EventLogPermissionAccess : Enum {
public int value__
public EventLogPermissionAccess None
public EventLogPermissionAccess Browse
public EventLogPermissionAccess Instrument
public EventLogPermissionAccess Audit
public EventLogPermissionAccess Write
public EventLogPermissionAccess Administer
}
public System.Diagnostics.EventLogPermissionAttribute : CodeAccessSecurityAttribute {
private string machineName
private EventLogPermissionAccess permissionAccess
public string MachineName
public EventLogPermissionAccess PermissionAccess
public void .ctor(SecurityAction action)
public string get_MachineName()
public void set_MachineName(string value)
public EventLogPermissionAccess get_PermissionAccess()
public void set_PermissionAccess(EventLogPermissionAccess value)
public IPermission CreatePermission()
}
public System.Diagnostics.EventLogPermissionEntry : object {
private EventLogPermissionAccess permissionAccess
private string machineName
public string MachineName
public EventLogPermissionAccess PermissionAccess
public void .ctor(EventLogPermissionAccess permissionAccess, string machineName)
public string get_MachineName()
public EventLogPermissionAccess get_PermissionAccess()
internal ResourcePermissionBaseEntry CreateResourcePermissionBaseEntry()
}
public System.Diagnostics.EventLogPermissionEntryCollection : CollectionBase {
private EventLogPermission owner
public EventLogPermissionEntry Item
internal void .ctor(EventLogPermission owner)
public EventLogPermissionEntry get_Item(int index)
public void set_Item(int index, EventLogPermissionEntry value)
public int Add(EventLogPermissionEntry value)
public void AddRange(EventLogPermissionEntry[] value)
public void AddRange(EventLogPermissionEntryCollection value)
public bool Contains(EventLogPermissionEntry value)
public void CopyTo(EventLogPermissionEntry[] array, int index)
public int IndexOf(EventLogPermissionEntry value)
public void Insert(int index, EventLogPermissionEntry value)
protected void OnClear()
protected void OnInsert(int index, object value)
protected void OnRemove(int index, object value)
protected void OnSet(int index, object oldValue, object newValue)
public void Remove(EventLogPermissionEntry value)
}
public System.Diagnostics.EventLogTraceListener : TraceListener {
private EventLog event_log
private string name
public EventLog EventLog
public string Name
public void .ctor(EventLog eventLog)
public void .ctor(string source)
public EventLog get_EventLog()
public void set_EventLog(EventLog value)
public string get_Name()
public void set_Name(string value)
public void Close()
protected void Dispose(bool disposing)
public void Write(string message)
public void WriteLine(string message)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, Object[] data)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string message)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string format, Object[] args)
}
public System.Diagnostics.EventSourceCreationData : object {
private string _source
private string _logName
private string _machineName
private string _messageResourceFile
private string _parameterResourceFile
private string _categoryResourceFile
private int _categoryCount
public int CategoryCount
public string CategoryResourceFile
public string LogName
public string MachineName
public string MessageResourceFile
public string ParameterResourceFile
public string Source
public void .ctor(string source, string logName)
internal void .ctor(string source, string logName, string machineName)
public int get_CategoryCount()
public void set_CategoryCount(int value)
public string get_CategoryResourceFile()
public void set_CategoryResourceFile(string value)
public string get_LogName()
public void set_LogName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public string get_MessageResourceFile()
public void set_MessageResourceFile(string value)
public string get_ParameterResourceFile()
public void set_ParameterResourceFile(string value)
public string get_Source()
public void set_Source(string value)
}
public System.Diagnostics.EventTypeFilter : TraceFilter {
private SourceLevels level
public SourceLevels EventType
public void .ctor(SourceLevels level)
public bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data)
public SourceLevels get_EventType()
public void set_EventType(SourceLevels value)
}
public System.Diagnostics.FileVersionInfo : object {
private string comments
private string companyname
private string filedescription
private string filename
private string fileversion
private string internalname
private string language
private string legalcopyright
private string legaltrademarks
private string originalfilename
private string privatebuild
private string productname
private string productversion
private string specialbuild
private bool isdebug
private bool ispatched
private bool isprerelease
private bool isprivatebuild
private bool isspecialbuild
private int filemajorpart
private int fileminorpart
private int filebuildpart
private int fileprivatepart
private int productmajorpart
private int productminorpart
private int productbuildpart
private int productprivatepart
public string Comments
public string CompanyName
public int FileBuildPart
public string FileDescription
public int FileMajorPart
public int FileMinorPart
public string FileName
public int FilePrivatePart
public string FileVersion
public string InternalName
public bool IsDebug
public bool IsPatched
public bool IsPreRelease
public bool IsPrivateBuild
public bool IsSpecialBuild
public string Language
public string LegalCopyright
public string LegalTrademarks
public string OriginalFilename
public string PrivateBuild
public int ProductBuildPart
public int ProductMajorPart
public int ProductMinorPart
public string ProductName
public int ProductPrivatePart
public string ProductVersion
public string SpecialBuild
public string get_Comments()
public string get_CompanyName()
public int get_FileBuildPart()
public string get_FileDescription()
public int get_FileMajorPart()
public int get_FileMinorPart()
public string get_FileName()
public int get_FilePrivatePart()
public string get_FileVersion()
public string get_InternalName()
public bool get_IsDebug()
public bool get_IsPatched()
public bool get_IsPreRelease()
public bool get_IsPrivateBuild()
public bool get_IsSpecialBuild()
public string get_Language()
public string get_LegalCopyright()
public string get_LegalTrademarks()
public string get_OriginalFilename()
public string get_PrivateBuild()
public int get_ProductBuildPart()
public int get_ProductMajorPart()
public int get_ProductMinorPart()
public string get_ProductName()
public int get_ProductPrivatePart()
public string get_ProductVersion()
public string get_SpecialBuild()
private void GetVersionInfo_internal(string fileName)
public FileVersionInfo GetVersionInfo(string fileName)
private void AppendFormat(StringBuilder sb, string format, Object[] args)
public string ToString()
}
internal System.Diagnostics.FilterElement : TypedElement {
public TraceFilter GetRuntimeObject()
internal TraceFilter RefreshRuntimeObject(TraceFilter filter)
}
public System.Diagnostics.ICollectData {
public void CloseData()
public void CollectData(int id, IntPtr valueName, IntPtr data, int totalBytes, IntPtr& res)
}
internal System.Diagnostics.InitState : Enum {
public int value__
public InitState NotInitialized
public InitState Initializing
public InitState Initialized
}
public System.Diagnostics.InstanceData : object {
private string instanceName
private CounterSample sample
public string InstanceName
public long RawValue
public CounterSample Sample
public void .ctor(string instanceName, CounterSample sample)
public string get_InstanceName()
public long get_RawValue()
public CounterSample get_Sample()
}
public System.Diagnostics.InstanceDataCollection : DictionaryBase {
private string counterName
public string CounterName
public InstanceData Item
public ICollection Keys
public ICollection Values
private void CheckNull(object value, string name)
public void .ctor(string counterName)
public string get_CounterName()
public InstanceData get_Item(string instanceName)
public ICollection get_Keys()
public ICollection get_Values()
public bool Contains(string instanceName)
public void CopyTo(InstanceData[] instances, int index)
}
public System.Diagnostics.InstanceDataCollectionCollection : DictionaryBase {
public InstanceDataCollection Item
public ICollection Keys
public ICollection Values
private void CheckNull(object value, string name)
public InstanceDataCollection get_Item(string counterName)
public ICollection get_Keys()
public ICollection get_Values()
public bool Contains(string counterName)
public void CopyTo(InstanceDataCollection[] counters, int index)
}
internal System.Diagnostics.ListenerElement : TypedElement {
private ConfigurationProperty _propFilter
private ConfigurationProperty _propName
private ConfigurationProperty _propOutputOpts
private ConfigurationProperty _propListenerTypeName
private bool _allowReferences
private Hashtable _attributes
internal bool _isAddedByDefault
public Hashtable Attributes
public FilterElement Filter
public string Name
public TraceOptions TraceOutputOptions
public string TypeName
public void .ctor(bool allowReferences)
public Hashtable get_Attributes()
public FilterElement get_Filter()
public string get_Name()
public void set_Name(string value)
public TraceOptions get_TraceOutputOptions()
public void set_TraceOutputOptions(TraceOptions value)
public string get_TypeName()
public void set_TypeName(string value)
public bool Equals(object compareTo)
public int GetHashCode()
public TraceListener GetRuntimeObject()
protected bool OnDeserializeUnrecognizedAttribute(string name, string value)
protected void PreSerialize(XmlWriter writer)
protected bool SerializeElement(XmlWriter writer, bool serializeCollectionKey)
protected void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
internal void ResetProperties()
internal TraceListener RefreshRuntimeObject(TraceListener listener)
}
internal System.Diagnostics.ListenerElementsCollection : ConfigurationElementCollection {
public ListenerElement Item
public ConfigurationElementCollectionType CollectionType
public ListenerElement get_Item(string name)
public ConfigurationElementCollectionType get_CollectionType()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public TraceListenerCollection GetRuntimeObject()
protected void InitializeDefault()
internal void InitializeDefaultInternal()
protected void BaseAdd(ConfigurationElement element)
}
internal System.Diagnostics.LocalFileEventLog : EventLogImpl {
private string DateFormat
private object lockObject
private FileSystemWatcher file_watcher
private int last_notification_index
private bool _notifying
private bool RunningOnUnix
private string EventLogStore
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
public void .ctor(EventLog coreEventLog)
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void DisableNotification()
public void EnableNotification()
public void EndInit()
public bool Exists(string logName, string machineName)
protected string FormatMessage(string source, UInt32 eventID, String[] replacementStrings)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
protected string GetLogDisplayName()
protected String[] GetLogNames(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
private string FindSourceDirectory(string source)
private bool get_RunningOnUnix()
private string FindLogStore(string logName)
private string get_EventLogStore()
private int GetLatestIndex()
private void ModifyAccessPermissions(string path, string permissions)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
private void <EnableNotification>b__14_0(object o, FileSystemEventArgs e)
}
public System.Diagnostics.MonitoringDescriptionAttribute : DescriptionAttribute {
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.Diagnostics.NullEventLog : EventLogImpl {
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
public void .ctor(EventLog coreEventLog)
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void DisableNotification()
public void EnableNotification()
public void EndInit()
public bool Exists(string logName, string machineName)
protected string FormatMessage(string source, UInt32 messageID, String[] replacementStrings)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
protected string GetLogDisplayName()
protected String[] GetLogNames(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
}
internal System.Diagnostics.OrdinalCaseInsensitiveComparer : object {
internal OrdinalCaseInsensitiveComparer Default
public int Compare(object a, object b)
}
public System.Diagnostics.OverflowAction : Enum {
public int value__
public OverflowAction DoNotOverwrite
public OverflowAction OverwriteAsNeeded
public OverflowAction OverwriteOlder
}
internal System.Diagnostics.PerfCounterSection : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propFileMappingSize
public int FileMappingSize
protected ConfigurationPropertyCollection Properties
public int get_FileMappingSize()
protected ConfigurationPropertyCollection get_Properties()
}
public System.Diagnostics.PerformanceCounter : Component {
private string categoryName
private string counterName
private string instanceName
private string machineName
private IntPtr impl
private PerformanceCounterType type
private CounterSample old_sample
private bool readOnly
private bool valid_old
private bool changed
private bool is_custom
private PerformanceCounterInstanceLifetime lifetime
public int DefaultFileMappingSize
public string CategoryName
public string CounterHelp
public string CounterName
public PerformanceCounterType CounterType
public PerformanceCounterInstanceLifetime InstanceLifetime
public string InstanceName
public string MachineName
public long RawValue
public bool ReadOnly
public void .ctor(string categoryName, string counterName)
public void .ctor(string categoryName, string counterName, bool readOnly)
public void .ctor(string categoryName, string counterName, string instanceName)
public void .ctor(string categoryName, string counterName, string instanceName, bool readOnly)
public void .ctor(string categoryName, string counterName, string instanceName, string machineName)
private IntPtr GetImpl(string category, string counter, string instance, string machine, PerformanceCounterType& ctype, Boolean& custom)
private bool GetSample(IntPtr impl, bool only_value, CounterSample& sample)
private long UpdateValue(IntPtr impl, bool do_incr, long value)
private void FreeData(IntPtr impl)
private void UpdateInfo()
public string get_CategoryName()
public void set_CategoryName(string value)
public string get_CounterHelp()
public string get_CounterName()
public void set_CounterName(string value)
public PerformanceCounterType get_CounterType()
public PerformanceCounterInstanceLifetime get_InstanceLifetime()
public void set_InstanceLifetime(PerformanceCounterInstanceLifetime value)
public string get_InstanceName()
public void set_InstanceName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public long get_RawValue()
public void set_RawValue(long value)
public bool get_ReadOnly()
public void set_ReadOnly(bool value)
public void BeginInit()
public void EndInit()
public void Close()
public void CloseSharedResources()
public long Decrement()
protected void Dispose(bool disposing)
public long Increment()
public long IncrementBy(long value)
public CounterSample NextSample()
public float NextValue()
public void RemoveInstance()
}
public System.Diagnostics.PerformanceCounterCategory : object {
private string categoryName
private string machineName
private PerformanceCounterCategoryType type
public string CategoryHelp
public string CategoryName
public string MachineName
public PerformanceCounterCategoryType CategoryType
private bool CategoryDelete(string name)
private string CategoryHelpInternal(string category, string machine)
private bool CounterCategoryExists(string counter, string category, string machine)
private bool Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationData[] items)
private int InstanceExistsInternal(string instance, string category, string machine)
private String[] GetCategoryNames(string machine)
private String[] GetCounterNames(string category, string machine)
private String[] GetInstanceNames(string category, string machine)
private void CheckCategory(string categoryName)
public void .ctor(string categoryName)
public void .ctor(string categoryName, string machineName)
public string get_CategoryHelp()
public string get_CategoryName()
public void set_CategoryName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public PerformanceCounterCategoryType get_CategoryType()
public bool CounterExists(string counterName)
public bool CounterExists(string counterName, string categoryName)
public bool CounterExists(string counterName, string categoryName, string machineName)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, CounterCreationDataCollection counterData)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, string counterName, string counterHelp)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp)
public void Delete(string categoryName)
public bool Exists(string categoryName)
public bool Exists(string categoryName, string machineName)
public PerformanceCounterCategory[] GetCategories()
public PerformanceCounterCategory[] GetCategories(string machineName)
public PerformanceCounter[] GetCounters()
public PerformanceCounter[] GetCounters(string instanceName)
public String[] GetInstanceNames()
public bool InstanceExists(string instanceName)
public bool InstanceExists(string instanceName, string categoryName)
public bool InstanceExists(string instanceName, string categoryName, string machineName)
public InstanceDataCollectionCollection ReadCategory()
}
public System.Diagnostics.PerformanceCounterCategoryType : Enum {
public int value__
public PerformanceCounterCategoryType SingleInstance
public PerformanceCounterCategoryType MultiInstance
public PerformanceCounterCategoryType Unknown
}
public System.Diagnostics.PerformanceCounterInstanceLifetime : Enum {
public int value__
public PerformanceCounterInstanceLifetime Global
public PerformanceCounterInstanceLifetime Process
}
public System.Diagnostics.PerformanceCounterManager : object {
private void System.Diagnostics.ICollectData.CloseData()
private void System.Diagnostics.ICollectData.CollectData(int callIdx, IntPtr valueNamePtr, IntPtr dataPtr, int totalBytes, IntPtr& res)
}
public System.Diagnostics.PerformanceCounterPermission : ResourcePermissionBase {
private PerformanceCounterPermissionEntryCollection innerCollection
public PerformanceCounterPermissionEntryCollection PermissionEntries
public void .ctor(PerformanceCounterPermissionEntry[] permissionAccessEntries)
public void .ctor(PermissionState state)
public void .ctor(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName)
public PerformanceCounterPermissionEntryCollection get_PermissionEntries()
private void SetUp()
internal ResourcePermissionBaseEntry[] GetEntries()
internal void ClearEntries()
internal void Add(object obj)
internal void Remove(object obj)
}
public System.Diagnostics.PerformanceCounterPermissionAccess : Enum {
public int value__
public PerformanceCounterPermissionAccess None
public PerformanceCounterPermissionAccess Browse
public PerformanceCounterPermissionAccess Read
public PerformanceCounterPermissionAccess Write
public PerformanceCounterPermissionAccess Instrument
public PerformanceCounterPermissionAccess Administer
}
public System.Diagnostics.PerformanceCounterPermissionAttribute : CodeAccessSecurityAttribute {
private string categoryName
private string machineName
private PerformanceCounterPermissionAccess permissionAccess
public string CategoryName
public string MachineName
public PerformanceCounterPermissionAccess PermissionAccess
public void .ctor(SecurityAction action)
public string get_CategoryName()
public void set_CategoryName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public PerformanceCounterPermissionAccess get_PermissionAccess()
public void set_PermissionAccess(PerformanceCounterPermissionAccess value)
public IPermission CreatePermission()
}
public System.Diagnostics.PerformanceCounterPermissionEntry : object {
private PerformanceCounterPermissionAccess All
private PerformanceCounterPermissionAccess permissionAccess
private string machineName
private string categoryName
public string CategoryName
public string MachineName
public PerformanceCounterPermissionAccess PermissionAccess
public void .ctor(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName)
public string get_CategoryName()
public string get_MachineName()
public PerformanceCounterPermissionAccess get_PermissionAccess()
internal ResourcePermissionBaseEntry CreateResourcePermissionBaseEntry()
}
public System.Diagnostics.PerformanceCounterPermissionEntryCollection : CollectionBase {
private PerformanceCounterPermission owner
public PerformanceCounterPermissionEntry Item
internal void .ctor(PerformanceCounterPermission owner)
internal void .ctor(ResourcePermissionBaseEntry[] entries)
public PerformanceCounterPermissionEntry get_Item(int index)
public void set_Item(int index, PerformanceCounterPermissionEntry value)
public int Add(PerformanceCounterPermissionEntry value)
public void AddRange(PerformanceCounterPermissionEntry[] value)
public void AddRange(PerformanceCounterPermissionEntryCollection value)
public bool Contains(PerformanceCounterPermissionEntry value)
public void CopyTo(PerformanceCounterPermissionEntry[] array, int index)
public int IndexOf(PerformanceCounterPermissionEntry value)
public void Insert(int index, PerformanceCounterPermissionEntry value)
protected void OnClear()
protected void OnInsert(int index, object value)
protected void OnRemove(int index, object value)
protected void OnSet(int index, object oldValue, object newValue)
public void Remove(PerformanceCounterPermissionEntry value)
}
public System.Diagnostics.PerformanceCounterType : Enum {
public int value__
public PerformanceCounterType NumberOfItemsHEX32
public PerformanceCounterType NumberOfItemsHEX64
public PerformanceCounterType NumberOfItems32
public PerformanceCounterType NumberOfItems64
public PerformanceCounterType CounterDelta32
public PerformanceCounterType CounterDelta64
public PerformanceCounterType SampleCounter
public PerformanceCounterType CountPerTimeInterval32
public PerformanceCounterType CountPerTimeInterval64
public PerformanceCounterType RateOfCountsPerSecond32
public PerformanceCounterType RateOfCountsPerSecond64
public PerformanceCounterType RawFraction
public PerformanceCounterType CounterTimer
public PerformanceCounterType Timer100Ns
public PerformanceCounterType SampleFraction
public PerformanceCounterType CounterTimerInverse
public PerformanceCounterType Timer100NsInverse
public PerformanceCounterType CounterMultiTimer
public PerformanceCounterType CounterMultiTimer100Ns
public PerformanceCounterType CounterMultiTimerInverse
public PerformanceCounterType CounterMultiTimer100NsInverse
public PerformanceCounterType AverageTimer32
public PerformanceCounterType ElapsedTime
public PerformanceCounterType AverageCount64
public PerformanceCounterType SampleBase
public PerformanceCounterType AverageBase
public PerformanceCounterType RawBase
public PerformanceCounterType CounterMultiBase
}
public System.Diagnostics.Process : Component {
private bool haveProcessId
private int processId
private bool haveProcessHandle
private SafeProcessHandle m_processHandle
private bool isRemoteMachine
private string machineName
private int m_processAccess
private ProcessThreadCollection threads
private ProcessModuleCollection modules
private bool haveWorkingSetLimits
private IntPtr minWorkingSet
private IntPtr maxWorkingSet
private bool havePriorityClass
private ProcessPriorityClass priorityClass
private ProcessStartInfo startInfo
private bool watchForExit
private bool watchingForExit
private EventHandler onExited
private bool exited
private int exitCode
private bool signaled
private DateTime exitTime
private bool haveExitTime
private bool raisedOnExited
private RegisteredWaitHandle registeredWaitHandle
private WaitHandle waitHandle
private ISynchronizeInvoke synchronizingObject
private StreamReader standardOutput
private StreamWriter standardInput
private StreamReader standardError
private OperatingSystem operatingSystem
private bool disposed
private StreamReadMode outputStreamReadMode
private StreamReadMode errorStreamReadMode
private StreamReadMode inputStreamReadMode
private DataReceivedEventHandler OutputDataReceived
private DataReceivedEventHandler ErrorDataReceived
internal AsyncStreamReader output
internal AsyncStreamReader error
internal bool pendingOutputRead
internal bool pendingErrorRead
internal TraceSwitch processTracing
private string process_name
private ProcessModule current_main_module
private bool Associated
public int ExitCode
public bool HasExited
public DateTime ExitTime
public IntPtr Handle
public SafeProcessHandle SafeHandle
public int Id
public string MachineName
public IntPtr MaxWorkingSet
public IntPtr MinWorkingSet
private OperatingSystem OperatingSystem
public ProcessPriorityClass PriorityClass
public TimeSpan PrivilegedProcessorTime
public ProcessStartInfo StartInfo
public DateTime StartTime
public ISynchronizeInvoke SynchronizingObject
public TimeSpan TotalProcessorTime
public TimeSpan UserProcessorTime
public bool EnableRaisingEvents
public StreamWriter StandardInput
public StreamReader StandardOutput
public StreamReader StandardError
public int BasePriority
public int HandleCount
public ProcessModule MainModule
public IntPtr MainWindowHandle
public string MainWindowTitle
public ProcessModuleCollection Modules
public int NonpagedSystemMemorySize
public int PagedMemorySize
public int PagedSystemMemorySize
public int PeakPagedMemorySize
public int PeakVirtualMemorySize
public int PeakWorkingSet
public long NonpagedSystemMemorySize64
public long PagedMemorySize64
public long PagedSystemMemorySize64
public long PeakPagedMemorySize64
public long PeakVirtualMemorySize64
public long PeakWorkingSet64
public bool PriorityBoostEnabled
public int PrivateMemorySize
public int SessionId
public string ProcessName
public IntPtr ProcessorAffinity
public bool Responding
public ProcessThreadCollection Threads
public int VirtualMemorySize
public int WorkingSet
public long PrivateMemorySize64
public long VirtualMemorySize64
public long WorkingSet64
private bool IsWindows
public void add_OutputDataReceived(DataReceivedEventHandler value)
public void remove_OutputDataReceived(DataReceivedEventHandler value)
public void add_ErrorDataReceived(DataReceivedEventHandler value)
public void remove_ErrorDataReceived(DataReceivedEventHandler value)
private void .ctor(string machineName, bool isRemoteMachine, int processId, ProcessInfo processInfo)
private bool get_Associated()
public int get_ExitCode()
public bool get_HasExited()
private ProcessThreadTimes GetProcessTimes()
public DateTime get_ExitTime()
public IntPtr get_Handle()
public SafeProcessHandle get_SafeHandle()
public int get_Id()
public string get_MachineName()
public IntPtr get_MaxWorkingSet()
public void set_MaxWorkingSet(IntPtr value)
public IntPtr get_MinWorkingSet()
public void set_MinWorkingSet(IntPtr value)
private OperatingSystem get_OperatingSystem()
public ProcessPriorityClass get_PriorityClass()
public void set_PriorityClass(ProcessPriorityClass value)
public TimeSpan get_PrivilegedProcessorTime()
public ProcessStartInfo get_StartInfo()
public void set_StartInfo(ProcessStartInfo value)
public DateTime get_StartTime()
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public TimeSpan get_TotalProcessorTime()
public TimeSpan get_UserProcessorTime()
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
public StreamWriter get_StandardInput()
public StreamReader get_StandardOutput()
public StreamReader get_StandardError()
public void add_Exited(EventHandler value)
public void remove_Exited(EventHandler value)
private void ReleaseProcessHandle(SafeProcessHandle handle)
private void CompletionCallback(object context, bool wasSignaled)
protected void Dispose(bool disposing)
public void Close()
private void EnsureState(State state)
private void EnsureWatchingForExit()
private void EnsureWorkingSetLimits()
public void EnterDebugMode()
public void LeaveDebugMode()
public Process GetProcessById(int processId)
public Process[] GetProcessesByName(string processName)
public Process[] GetProcesses()
public Process GetCurrentProcess()
protected void OnExited()
private SafeProcessHandle GetProcessHandle(int access, bool throwIfExited)
private SafeProcessHandle GetProcessHandle(int access)
private SafeProcessHandle OpenProcessHandle()
private SafeProcessHandle OpenProcessHandle(int access)
public void Refresh()
private void SetProcessHandle(SafeProcessHandle processHandle)
private void SetProcessId(int processId)
private void SetWorkingSetLimits(object newMin, object newMax)
public bool Start()
public Process Start(string fileName, string userName, SecureString password, string domain)
public Process Start(string fileName, string arguments, string userName, SecureString password, string domain)
public Process Start(string fileName)
public Process Start(string fileName, string arguments)
public Process Start(ProcessStartInfo startInfo)
public void Kill()
private void StopWatchingForExit()
public string ToString()
public bool WaitForExit(int milliseconds)
public void WaitForExit()
public bool WaitForInputIdle(int milliseconds)
public bool WaitForInputIdle()
public void BeginOutputReadLine()
public void BeginErrorReadLine()
public void CancelOutputRead()
public void CancelErrorRead()
internal void OutputReadNotifyUser(string data)
internal void ErrorReadNotifyUser(string data)
private void .ctor(SafeProcessHandle handle, int id)
public int get_BasePriority()
public int get_HandleCount()
public ProcessModule get_MainModule()
public IntPtr get_MainWindowHandle()
public string get_MainWindowTitle()
private ProcessModule[] GetModules_internal(IntPtr handle)
private ProcessModule[] GetModules_internal(SafeProcessHandle handle)
public ProcessModuleCollection get_Modules()
private long GetProcessData(int pid, int data_type, Int32& error)
public int get_NonpagedSystemMemorySize()
public int get_PagedMemorySize()
public int get_PagedSystemMemorySize()
public int get_PeakPagedMemorySize()
public int get_PeakVirtualMemorySize()
public int get_PeakWorkingSet()
public long get_NonpagedSystemMemorySize64()
public long get_PagedMemorySize64()
public long get_PagedSystemMemorySize64()
public long get_PeakPagedMemorySize64()
public long get_PeakVirtualMemorySize64()
public long get_PeakWorkingSet64()
public bool get_PriorityBoostEnabled()
public void set_PriorityBoostEnabled(bool value)
public int get_PrivateMemorySize()
public int get_SessionId()
private string ProcessName_internal(IntPtr handle)
private string ProcessName_internal(SafeProcessHandle handle)
public string get_ProcessName()
public IntPtr get_ProcessorAffinity()
public void set_ProcessorAffinity(IntPtr value)
public bool get_Responding()
public ProcessThreadCollection get_Threads()
public int get_VirtualMemorySize()
public int get_WorkingSet()
public long get_PrivateMemorySize64()
public long get_VirtualMemorySize64()
public long get_WorkingSet64()
public bool CloseMainWindow()
private IntPtr GetProcess_internal(int pid)
public Process GetProcessById(int processId, string machineName)
public Process[] GetProcessesByName(string processName, string machineName)
private Int32[] GetProcesses_internal()
public Process[] GetProcesses(string machineName)
private bool IsLocalMachine(string machineName)
private bool ShellExecuteEx_internal(ProcessStartInfo startInfo, ProcInfo& procInfo)
private bool CreateProcess_internal(ProcessStartInfo startInfo, IntPtr stdin, IntPtr stdout, IntPtr stderr, ProcInfo& procInfo)
private bool StartWithShellExecuteEx(ProcessStartInfo startInfo)
private void CreatePipe(IntPtr& read, IntPtr& write, bool writeDirection)
private bool get_IsWindows()
private bool StartWithCreateProcess(ProcessStartInfo startInfo)
private void FillUserInfo(ProcessStartInfo startInfo, ProcInfo& procInfo)
private void RaiseOnExited()
}
public System.Diagnostics.ProcessModule : Component {
private IntPtr baseaddr
private IntPtr entryaddr
private string filename
private FileVersionInfo version_info
private int memory_size
private string modulename
public IntPtr BaseAddress
public IntPtr EntryPointAddress
public string FileName
public FileVersionInfo FileVersionInfo
public int ModuleMemorySize
public string ModuleName
internal void .ctor(IntPtr baseaddr, IntPtr entryaddr, string filename, FileVersionInfo version_info, int memory_size, string modulename)
public IntPtr get_BaseAddress()
public IntPtr get_EntryPointAddress()
public string get_FileName()
public FileVersionInfo get_FileVersionInfo()
public int get_ModuleMemorySize()
public string get_ModuleName()
public string ToString()
}
public System.Diagnostics.ProcessModuleCollection : ReadOnlyCollectionBase {
public ProcessModule Item
public void .ctor(ProcessModule[] processModules)
public ProcessModule get_Item(int index)
public int IndexOf(ProcessModule module)
public bool Contains(ProcessModule module)
public void CopyTo(ProcessModule[] array, int index)
}
public System.Diagnostics.ProcessPriorityClass : Enum {
public int value__
public ProcessPriorityClass AboveNormal
public ProcessPriorityClass BelowNormal
public ProcessPriorityClass High
public ProcessPriorityClass Idle
public ProcessPriorityClass Normal
public ProcessPriorityClass RealTime
}
public System.Diagnostics.ProcessStartInfo : object {
private string fileName
private string arguments
private string directory
private string verb
private ProcessWindowStyle windowStyle
private bool errorDialog
private IntPtr errorDialogParentHandle
private bool useShellExecute
private string userName
private string domain
private SecureString password
private string passwordInClearText
private bool loadUserProfile
private bool redirectStandardInput
private bool redirectStandardOutput
private bool redirectStandardError
private Encoding standardOutputEncoding
private Encoding standardErrorEncoding
private bool createNoWindow
private WeakReference weakParentProcess
internal StringDictionary environmentVariables
private IDictionary`2<string, string> environment
private String[] empty
public string Verb
public string Arguments
public bool CreateNoWindow
public StringDictionary EnvironmentVariables
public IDictionary`2<string, string> Environment
public bool RedirectStandardInput
public bool RedirectStandardOutput
public bool RedirectStandardError
public Encoding StandardErrorEncoding
public Encoding StandardOutputEncoding
public bool UseShellExecute
public string UserName
public SecureString Password
public string PasswordInClearText
public string Domain
public bool LoadUserProfile
public string FileName
public string WorkingDirectory
public bool ErrorDialog
public IntPtr ErrorDialogParentHandle
public ProcessWindowStyle WindowStyle
internal bool HaveEnvVars
public String[] Verbs
internal void .ctor(Process parent)
public void .ctor(string fileName)
public void .ctor(string fileName, string arguments)
public string get_Verb()
public void set_Verb(string value)
public string get_Arguments()
public void set_Arguments(string value)
public bool get_CreateNoWindow()
public void set_CreateNoWindow(bool value)
public StringDictionary get_EnvironmentVariables()
public IDictionary`2<string, string> get_Environment()
public bool get_RedirectStandardInput()
public void set_RedirectStandardInput(bool value)
public bool get_RedirectStandardOutput()
public void set_RedirectStandardOutput(bool value)
public bool get_RedirectStandardError()
public void set_RedirectStandardError(bool value)
public Encoding get_StandardErrorEncoding()
public void set_StandardErrorEncoding(Encoding value)
public Encoding get_StandardOutputEncoding()
public void set_StandardOutputEncoding(Encoding value)
public bool get_UseShellExecute()
public void set_UseShellExecute(bool value)
public string get_UserName()
public void set_UserName(string value)
public SecureString get_Password()
public void set_Password(SecureString value)
public string get_PasswordInClearText()
public void set_PasswordInClearText(string value)
public string get_Domain()
public void set_Domain(string value)
public bool get_LoadUserProfile()
public void set_LoadUserProfile(bool value)
public string get_FileName()
public void set_FileName(string value)
public string get_WorkingDirectory()
public void set_WorkingDirectory(string value)
public bool get_ErrorDialog()
public void set_ErrorDialog(bool value)
public IntPtr get_ErrorDialogParentHandle()
public void set_ErrorDialogParentHandle(IntPtr value)
public ProcessWindowStyle get_WindowStyle()
public void set_WindowStyle(ProcessWindowStyle value)
internal bool get_HaveEnvVars()
public String[] get_Verbs()
}
public System.Diagnostics.ProcessThread : Component {
public int BasePriority
public int CurrentPriority
public int Id
public int IdealProcessor
public bool PriorityBoostEnabled
public ThreadPriorityLevel PriorityLevel
public TimeSpan PrivilegedProcessorTime
public IntPtr ProcessorAffinity
public IntPtr StartAddress
public DateTime StartTime
public ThreadState ThreadState
public TimeSpan TotalProcessorTime
public TimeSpan UserProcessorTime
public ThreadWaitReason WaitReason
public int get_BasePriority()
public int get_CurrentPriority()
public int get_Id()
public void set_IdealProcessor(int value)
public bool get_PriorityBoostEnabled()
public void set_PriorityBoostEnabled(bool value)
public ThreadPriorityLevel get_PriorityLevel()
public void set_PriorityLevel(ThreadPriorityLevel value)
public TimeSpan get_PrivilegedProcessorTime()
public void set_ProcessorAffinity(IntPtr value)
public IntPtr get_StartAddress()
public DateTime get_StartTime()
public ThreadState get_ThreadState()
public TimeSpan get_TotalProcessorTime()
public TimeSpan get_UserProcessorTime()
public ThreadWaitReason get_WaitReason()
public void ResetIdealProcessor()
}
public System.Diagnostics.ProcessThreadCollection : ReadOnlyCollectionBase {
public ProcessThread Item
public void .ctor(ProcessThread[] processThreads)
public ProcessThread get_Item(int index)
public int Add(ProcessThread thread)
public void Insert(int index, ProcessThread thread)
public int IndexOf(ProcessThread thread)
public bool Contains(ProcessThread thread)
public void Remove(ProcessThread thread)
public void CopyTo(ProcessThread[] array, int index)
}
internal System.Diagnostics.ProcessThreadTimes : object {
internal long create
internal long exit
internal long kernel
internal long user
public DateTime StartTime
public DateTime ExitTime
public TimeSpan PrivilegedProcessorTime
public TimeSpan UserProcessorTime
public TimeSpan TotalProcessorTime
public DateTime get_StartTime()
public DateTime get_ExitTime()
public TimeSpan get_PrivilegedProcessorTime()
public TimeSpan get_UserProcessorTime()
public TimeSpan get_TotalProcessorTime()
}
internal System.Diagnostics.ProcessWaitHandle : WaitHandle {
internal void .ctor(SafeProcessHandle processHandle)
}
public System.Diagnostics.ProcessWindowStyle : Enum {
public int value__
public ProcessWindowStyle Hidden
public ProcessWindowStyle Maximized
public ProcessWindowStyle Minimized
public ProcessWindowStyle Normal
}
internal System.Diagnostics.SharedListenerElementsCollection : ListenerElementsCollection {
public ConfigurationElementCollectionType CollectionType
protected string ElementName
public ConfigurationElementCollectionType get_CollectionType()
protected ConfigurationElement CreateNewElement()
protected string get_ElementName()
}
internal System.Diagnostics.SourceElement : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propName
private ConfigurationProperty _propSwitchName
private ConfigurationProperty _propSwitchValue
private ConfigurationProperty _propSwitchType
private ConfigurationProperty _propListeners
private Hashtable _attributes
public Hashtable Attributes
public ListenerElementsCollection Listeners
public string Name
protected ConfigurationPropertyCollection Properties
public string SwitchName
public string SwitchValue
public string SwitchType
public Hashtable get_Attributes()
public ListenerElementsCollection get_Listeners()
public string get_Name()
protected ConfigurationPropertyCollection get_Properties()
public string get_SwitchName()
public string get_SwitchValue()
public string get_SwitchType()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
protected bool OnDeserializeUnrecognizedAttribute(string name, string value)
protected void PreSerialize(XmlWriter writer)
protected bool SerializeElement(XmlWriter writer, bool serializeCollectionKey)
protected void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
internal void ResetProperties()
}
internal System.Diagnostics.SourceElementsCollection : ConfigurationElementCollection {
public SourceElement Item
protected string ElementName
public ConfigurationElementCollectionType CollectionType
public SourceElement get_Item(string name)
protected string get_ElementName()
public ConfigurationElementCollectionType get_CollectionType()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
}
public System.Diagnostics.SourceFilter : TraceFilter {
private string src
public string Source
public void .ctor(string source)
public bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data)
public string get_Source()
public void set_Source(string value)
}
public System.Diagnostics.SourceLevels : Enum {
public int value__
public SourceLevels Off
public SourceLevels Critical
public SourceLevels Error
public SourceLevels Warning
public SourceLevels Information
public SourceLevels Verbose
public SourceLevels ActivityTracing
public SourceLevels All
}
public System.Diagnostics.SourceSwitch : Switch {
public SourceLevels Level
public void .ctor(string name)
public void .ctor(string displayName, string defaultSwitchValue)
public SourceLevels get_Level()
public void set_Level(SourceLevels value)
public bool ShouldTrace(TraceEventType eventType)
protected void OnValueChanged()
}
public System.Diagnostics.Stopwatch : object {
public long Frequency
public bool IsHighResolution
private long elapsed
private long started
private bool is_running
public TimeSpan Elapsed
public long ElapsedMilliseconds
public long ElapsedTicks
public bool IsRunning
public long GetTimestamp()
public Stopwatch StartNew()
public TimeSpan get_Elapsed()
public long get_ElapsedMilliseconds()
public long get_ElapsedTicks()
public bool get_IsRunning()
public void Reset()
public void Start()
public void Stop()
public void Restart()
}
public System.Diagnostics.Switch : object {
private SwitchElementsCollection switchSettings
private string description
private string displayName
private int switchSetting
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) initialized
private bool initializing
private String modreq(System.Runtime.CompilerServices.IsVolatile) switchValueString
private StringDictionary attributes
private string defaultValue
private object m_intializedLock
private List`1<WeakReference> switches
private int s_LastCollectionCount
private object IntializedLock
public StringDictionary Attributes
public string DisplayName
public string Description
protected int SwitchSetting
protected string Value
private object get_IntializedLock()
protected void .ctor(string displayName, string description)
protected void .ctor(string displayName, string description, string defaultSwitchValue)
private void _pruneCachedSwitches()
public StringDictionary get_Attributes()
public string get_DisplayName()
public string get_Description()
protected int get_SwitchSetting()
protected void set_SwitchSetting(int value)
protected string get_Value()
protected void set_Value(string value)
private void Initialize()
private bool InitializeWithStatus()
private bool InitializeConfigSettings()
protected internal String[] GetSupportedAttributes()
protected void OnSwitchSettingChanged()
protected void OnValueChanged()
internal void RefreshAll()
internal void Refresh()
}
public System.Diagnostics.SwitchAttribute : Attribute {
private Type type
private string name
private string description
public string SwitchName
public Type SwitchType
public string SwitchDescription
public void .ctor(string switchName, Type switchType)
public string get_SwitchName()
public void set_SwitchName(string value)
public Type get_SwitchType()
public void set_SwitchType(Type value)
public string get_SwitchDescription()
public void set_SwitchDescription(string value)
public SwitchAttribute[] GetAll(Assembly assembly)
private void GetAllRecursive(Type type, ArrayList switchAttribs)
private void GetAllRecursive(MemberInfo member, ArrayList switchAttribs)
}
internal System.Diagnostics.SwitchElement : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propName
private ConfigurationProperty _propValue
private Hashtable _attributes
public Hashtable Attributes
public string Name
protected ConfigurationPropertyCollection Properties
public string Value
public Hashtable get_Attributes()
public string get_Name()
protected ConfigurationPropertyCollection get_Properties()
public string get_Value()
protected bool OnDeserializeUnrecognizedAttribute(string name, string value)
protected void PreSerialize(XmlWriter writer)
protected bool SerializeElement(XmlWriter writer, bool serializeCollectionKey)
protected void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
internal void ResetProperties()
}
internal System.Diagnostics.SwitchElementsCollection : ConfigurationElementCollection {
public SwitchElement Item
public ConfigurationElementCollectionType CollectionType
public SwitchElement get_Item(string name)
public ConfigurationElementCollectionType get_CollectionType()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
}
public System.Diagnostics.SwitchLevelAttribute : Attribute {
private Type type
public Type SwitchLevelType
public void .ctor(Type switchLevelType)
public Type get_SwitchLevelType()
public void set_SwitchLevelType(Type value)
}
internal System.Diagnostics.SystemDiagnosticsSection : ConfigurationSection {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propAssert
private ConfigurationProperty _propPerfCounters
private ConfigurationProperty _propSources
private ConfigurationProperty _propSharedListeners
private ConfigurationProperty _propSwitches
private ConfigurationProperty _propTrace
public AssertSection Assert
public PerfCounterSection PerfCounters
protected ConfigurationPropertyCollection Properties
public SourceElementsCollection Sources
public ListenerElementsCollection SharedListeners
public SwitchElementsCollection Switches
public TraceSection Trace
public AssertSection get_Assert()
public PerfCounterSection get_PerfCounters()
protected ConfigurationPropertyCollection get_Properties()
public SourceElementsCollection get_Sources()
public ListenerElementsCollection get_SharedListeners()
public SwitchElementsCollection get_Switches()
public TraceSection get_Trace()
protected void InitializeDefault()
}
public System.Diagnostics.TextWriterTraceListener : TraceListener {
internal TextWriter writer
private string fileName
public TextWriter Writer
public void .ctor(Stream stream)
public void .ctor(Stream stream, string name)
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string name)
public void .ctor(string fileName)
public void .ctor(string fileName, string name)
public TextWriter get_Writer()
public void set_Writer(TextWriter value)
public void Close()
protected void Dispose(bool disposing)
public void Flush()
public void Write(string message)
public void WriteLine(string message)
private Encoding GetEncodingWithFallback(Encoding encoding)
internal bool EnsureWriter()
}
public System.Diagnostics.ThreadPriorityLevel : Enum {
public int value__
public ThreadPriorityLevel AboveNormal
public ThreadPriorityLevel BelowNormal
public ThreadPriorityLevel Highest
public ThreadPriorityLevel Idle
public ThreadPriorityLevel Lowest
public ThreadPriorityLevel Normal
public ThreadPriorityLevel TimeCritical
}
public System.Diagnostics.ThreadState : Enum {
public int value__
public ThreadState Initialized
public ThreadState Ready
public ThreadState Running
public ThreadState Standby
public ThreadState Terminated
public ThreadState Transition
public ThreadState Unknown
public ThreadState Wait
}
public System.Diagnostics.ThreadWaitReason : Enum {
public int value__
public ThreadWaitReason EventPairHigh
public ThreadWaitReason EventPairLow
public ThreadWaitReason ExecutionDelay
public ThreadWaitReason Executive
public ThreadWaitReason FreePage
public ThreadWaitReason LpcReceive
public ThreadWaitReason LpcReply
public ThreadWaitReason PageIn
public ThreadWaitReason PageOut
public ThreadWaitReason Suspended
public ThreadWaitReason SystemAllocation
public ThreadWaitReason Unknown
public ThreadWaitReason UserRequest
public ThreadWaitReason VirtualMemory
}
public System.Diagnostics.Trace : object {
private CorrelationManager modreq(System.Runtime.CompilerServices.IsVolatile) correlationManager
public TraceListenerCollection Listeners
public bool AutoFlush
public bool UseGlobalLock
public CorrelationManager CorrelationManager
public int IndentLevel
public int IndentSize
public TraceListenerCollection get_Listeners()
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public bool get_UseGlobalLock()
public void set_UseGlobalLock(bool value)
public CorrelationManager get_CorrelationManager()
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public void Flush()
public void Close()
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Fail(string message)
public void Fail(string message, string detailMessage)
public void Refresh()
public void TraceInformation(string message)
public void TraceInformation(string format, Object[] args)
public void TraceWarning(string message)
public void TraceWarning(string format, Object[] args)
public void TraceError(string message)
public void TraceError(string format, Object[] args)
public void Write(string message)
public void Write(object value)
public void Write(string message, string category)
public void Write(object value, string category)
public void WriteLine(string message)
public void WriteLine(object value)
public void WriteLine(string message, string category)
public void WriteLine(object value, string category)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message, string category)
public void WriteIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, string message, string category)
public void WriteLineIf(bool condition, object value, string category)
public void Indent()
public void Unindent()
}
public System.Diagnostics.TraceEventCache : object {
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) processId
private String modreq(System.Runtime.CompilerServices.IsVolatile) processName
private long timeStamp
private DateTime dateTime
private string stackTrace
internal Guid ActivityId
public string Callstack
public Stack LogicalOperationStack
public DateTime DateTime
public int ProcessId
public string ThreadId
public long Timestamp
internal Guid get_ActivityId()
public string get_Callstack()
public Stack get_LogicalOperationStack()
public DateTime get_DateTime()
public int get_ProcessId()
public string get_ThreadId()
public long get_Timestamp()
private void InitProcessInfo()
internal int GetProcessId()
internal string GetProcessName()
internal int GetThreadId()
}
public System.Diagnostics.TraceEventType : Enum {
public int value__
public TraceEventType Critical
public TraceEventType Error
public TraceEventType Warning
public TraceEventType Information
public TraceEventType Verbose
public TraceEventType Start
public TraceEventType Stop
public TraceEventType Suspend
public TraceEventType Resume
public TraceEventType Transfer
}
public System.Diagnostics.TraceFilter : object {
internal string initializeData
public bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data)
internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage)
internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args)
internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1)
}
internal System.Diagnostics.TraceImplSettings : object {
public string Key
public bool AutoFlush
public int IndentSize
public TraceListenerCollection Listeners
}
internal System.Diagnostics.TraceInternal : object {
private String modreq(System.Runtime.CompilerServices.IsVolatile) appName
private TraceListenerCollection modreq(System.Runtime.CompilerServices.IsVolatile) listeners
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) autoFlush
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) useGlobalLock
private int indentLevel
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) indentSize
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) settingsInitialized
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) defaultInitialized
internal object critSec
public TraceListenerCollection Listeners
internal string AppName
public bool AutoFlush
public bool UseGlobalLock
public int IndentLevel
public int IndentSize
public TraceListenerCollection get_Listeners()
internal string get_AppName()
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public bool get_UseGlobalLock()
public void set_UseGlobalLock(bool value)
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
private void SetIndentSize(int value)
public void Indent()
public void Unindent()
public void Flush()
public void Close()
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Fail(string message)
public void Fail(string message, string detailMessage)
private void InitializeSettings()
internal void Refresh()
public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args)
public void Write(string message)
public void Write(object value)
public void Write(string message, string category)
public void Write(object value, string category)
public void WriteLine(string message)
public void WriteLine(object value)
public void WriteLine(string message, string category)
public void WriteLine(object value, string category)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message, string category)
public void WriteIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, string message, string category)
public void WriteLineIf(bool condition, object value, string category)
}
public System.Diagnostics.TraceLevel : Enum {
public int value__
public TraceLevel Off
public TraceLevel Error
public TraceLevel Warning
public TraceLevel Info
public TraceLevel Verbose
}
public System.Diagnostics.TraceListener : MarshalByRefObject {
private int indentLevel
private int indentSize
private TraceOptions traceOptions
private bool needIndent
private string listenerName
private TraceFilter filter
private StringDictionary attributes
internal string initializeData
public StringDictionary Attributes
public string Name
public bool IsThreadSafe
public int IndentLevel
public int IndentSize
public TraceFilter Filter
protected bool NeedIndent
public TraceOptions TraceOutputOptions
protected void .ctor(string name)
public StringDictionary get_Attributes()
public string get_Name()
public void set_Name(string value)
public bool get_IsThreadSafe()
public void Dispose()
protected void Dispose(bool disposing)
public void Close()
public void Flush()
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public TraceFilter get_Filter()
public void set_Filter(TraceFilter value)
protected bool get_NeedIndent()
protected void set_NeedIndent(bool value)
public TraceOptions get_TraceOutputOptions()
public void set_TraceOutputOptions(TraceOptions value)
internal void SetAttributes(Hashtable attribs)
public void Fail(string message)
public void Fail(string message, string detailMessage)
protected internal String[] GetSupportedAttributes()
public void Write(string message)
public void Write(object o)
public void Write(string message, string category)
public void Write(object o, string category)
protected void WriteIndent()
public void WriteLine(string message)
public void WriteLine(object o)
public void WriteLine(string message, string category)
public void WriteLine(object o, string category)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
public void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId)
private void WriteHeader(string source, TraceEventType eventType, int id)
private void WriteFooter(TraceEventCache eventCache)
internal bool IsEnabled(TraceOptions opts)
}
public System.Diagnostics.TraceListenerCollection : object {
private ArrayList list
public TraceListener Item
public TraceListener Item
public int Count
private object System.Collections.IList.Item
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
public TraceListener get_Item(int i)
public void set_Item(int i, TraceListener value)
public TraceListener get_Item(string name)
public int get_Count()
public int Add(TraceListener listener)
public void AddRange(TraceListener[] value)
public void AddRange(TraceListenerCollection value)
public void Clear()
public bool Contains(TraceListener listener)
public void CopyTo(TraceListener[] listeners, int index)
public IEnumerator GetEnumerator()
internal void InitializeListener(TraceListener listener)
public int IndexOf(TraceListener listener)
public void Insert(int index, TraceListener listener)
public void Remove(TraceListener listener)
public void Remove(string name)
public void RemoveAt(int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
private void System.Collections.ICollection.CopyTo(Array array, int index)
}
public System.Diagnostics.TraceOptions : Enum {
public int value__
public TraceOptions None
public TraceOptions LogicalOperationStack
public TraceOptions DateTime
public TraceOptions Timestamp
public TraceOptions ProcessId
public TraceOptions ThreadId
public TraceOptions Callstack
}
internal System.Diagnostics.TraceSection : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propListeners
private ConfigurationProperty _propAutoFlush
private ConfigurationProperty _propIndentSize
private ConfigurationProperty _propUseGlobalLock
public bool AutoFlush
public int IndentSize
public ListenerElementsCollection Listeners
public bool UseGlobalLock
protected ConfigurationPropertyCollection Properties
public bool get_AutoFlush()
public int get_IndentSize()
public ListenerElementsCollection get_Listeners()
public bool get_UseGlobalLock()
protected ConfigurationPropertyCollection get_Properties()
}
public System.Diagnostics.TraceSource : object {
private List`1<WeakReference> tracesources
private int s_LastCollectionCount
private SourceSwitch modreq(System.Runtime.CompilerServices.IsVolatile) internalSwitch
private TraceListenerCollection modreq(System.Runtime.CompilerServices.IsVolatile) listeners
private StringDictionary attributes
private SourceLevels switchLevel
private String modreq(System.Runtime.CompilerServices.IsVolatile) sourceName
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initCalled
public StringDictionary Attributes
public string Name
public TraceListenerCollection Listeners
public SourceSwitch Switch
public void .ctor(string name)
public void .ctor(string name, SourceLevels defaultLevel)
private void _pruneCachedTraceSources()
private void Initialize()
private void NoConfigInit()
public void Close()
public void Flush()
protected internal String[] GetSupportedAttributes()
internal void RefreshAll()
internal void Refresh()
public void TraceEvent(TraceEventType eventType, int id)
public void TraceEvent(TraceEventType eventType, int id, string message)
public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args)
public void TraceData(TraceEventType eventType, int id, object data)
public void TraceData(TraceEventType eventType, int id, Object[] data)
public void TraceInformation(string message)
public void TraceInformation(string format, Object[] args)
public void TraceTransfer(int id, string message, Guid relatedActivityId)
private void CreateSwitch(string typename, string name)
public StringDictionary get_Attributes()
public string get_Name()
public TraceListenerCollection get_Listeners()
public SourceSwitch get_Switch()
public void set_Switch(SourceSwitch value)
}
internal System.Diagnostics.TraceSourceInfo : object {
private string name
private SourceLevels levels
private TraceListenerCollection listeners
public string Name
public SourceLevels Levels
public TraceListenerCollection Listeners
public void .ctor(string name, SourceLevels levels)
internal void .ctor(string name, SourceLevels levels, TraceImplSettings settings)
public string get_Name()
public SourceLevels get_Levels()
public TraceListenerCollection get_Listeners()
}
public System.Diagnostics.TraceSwitch : Switch {
public TraceLevel Level
public bool TraceError
public bool TraceWarning
public bool TraceInfo
public bool TraceVerbose
public void .ctor(string displayName, string description)
public void .ctor(string displayName, string description, string defaultSwitchValue)
public TraceLevel get_Level()
public void set_Level(TraceLevel value)
public bool get_TraceError()
public bool get_TraceWarning()
public bool get_TraceInfo()
public bool get_TraceVerbose()
protected void OnSwitchSettingChanged()
protected void OnValueChanged()
}
internal System.Diagnostics.TraceUtils : object {
internal object GetRuntimeObject(string className, Type baseType, string initializeData)
internal bool IsOwnedTL(Type type)
internal bool IsOwnedTextWriterTL(Type type)
private object ConvertToBaseTypeOrEnum(string value, Type type)
internal void VerifyAttributes(IDictionary attributes, String[] supportedAttributes, object parent)
}
internal System.Diagnostics.TypedElement : ConfigurationElement {
protected ConfigurationProperty _propTypeName
protected ConfigurationProperty _propInitData
protected ConfigurationPropertyCollection _properties
protected object _runtimeObject
private Type _baseType
public string InitData
protected ConfigurationPropertyCollection Properties
public string TypeName
public void .ctor(Type baseType)
public string get_InitData()
public void set_InitData(string value)
protected ConfigurationPropertyCollection get_Properties()
public string get_TypeName()
public void set_TypeName(string value)
protected object BaseGetRuntimeObject()
}
internal System.Diagnostics.UserCallBack : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(string data)
public IAsyncResult BeginInvoke(string data, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Diagnostics.Win32EventLog : EventLogImpl {
private int MESSAGE_NOT_FOUND
private ManualResetEvent _notifyResetEvent
private IntPtr _readHandle
private Thread _notifyThread
private int _lastEntryWritten
private object _eventLock
private int OldestEventLogEntry
private IntPtr ReadHandle
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
public void .ctor(EventLog coreEventLog)
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void EndInit()
public bool Exists(string logName, string machineName)
protected string FormatMessage(string source, UInt32 messageID, String[] replacementStrings)
private string FormatCategory(string source, int category)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
protected string GetLogDisplayName()
protected String[] GetLogNames(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
private void UpdateLogRegistry(RegistryKey logKey)
private void UpdateSourceRegistry(RegistryKey sourceKey, EventSourceCreationData data)
private string GetLogName(RegistryKey logKey)
private void ReadEventLog(int index, Byte[] buffer, Int32& bytesRead, Int32& minBufferNeeded)
private RegistryKey GetEventLogKey(string machineName, bool writable)
private RegistryKey FindSourceKeyByName(string source, string machineName, bool writable)
private RegistryKey FindLogKeyByName(string logName, string machineName, bool writable)
private RegistryKey FindLogKeyBySource(string source, string machineName, bool writable)
private int get_OldestEventLogEntry()
private void CloseEventLog(IntPtr hEventLog)
private void DeregisterEventSource(IntPtr hEventLog)
private string LookupAccountSid(string machineName, Byte[] sid)
private string FetchMessage(string msgDll, UInt32 messageID, String[] replacementStrings)
private String[] GetMessageResourceDlls(string source, string valueName)
private IntPtr get_ReadHandle()
private IntPtr RegisterEventSource()
public void DisableNotification()
public void EnableNotification()
private void NotifyEventThread(ManualResetEvent resetEvent)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
private void <EnableNotification>b__44_0()
}
public System.Diagnostics.XmlWriterTraceListener : TextWriterTraceListener {
private string fixedHeader
private string machineName
private StringBuilder strBldr
private XmlTextWriter xmlBlobWriter
internal bool shouldRespectFilterOnTraceTransfer
public void .ctor(Stream stream)
public void .ctor(Stream stream, string name)
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string name)
public void .ctor(string filename)
public void .ctor(string filename, string name)
public void Write(string message)
public void WriteLine(string message)
public void Fail(string message, string detailMessage)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
private void WriteData(object data)
public void Close()
public void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId)
private void WriteHeader(string source, TraceEventType eventType, int id, TraceEventCache eventCache, Guid relatedActivityId)
private void WriteHeader(string source, TraceEventType eventType, int id, TraceEventCache eventCache)
private void WriteStartHeader(string source, TraceEventType eventType, int id, TraceEventCache eventCache)
private void WriteEndHeader(TraceEventCache eventCache)
private void WriteFooter(TraceEventCache eventCache)
private void WriteEscaped(string str)
private void InternalWrite(string message)
}
internal System.DomainNameHelper : object {
private char c_DummyChar
internal string Localhost
internal string Loopback
internal string ParseCanonicalName(string str, int start, int end, Boolean& loopback)
internal bool IsValid(Char* name, ushort pos, Int32& returnedEnd, Boolean& notCanonical, bool notImplicitFile)
internal bool IsValidByIri(Char* name, ushort pos, Int32& returnedEnd, Boolean& notCanonical, bool notImplicitFile)
internal string IdnEquivalent(string hostname)
internal string IdnEquivalent(Char* hostname, int start, int end, Boolean& allAscii, Boolean& atLeastOneValidIdn)
internal string IdnEquivalent(Char* hostname, int start, int end, Boolean& allAscii, String& bidiStrippedHost)
private bool IsIdnAce(string input, int index)
private bool IsIdnAce(Char* input, int index)
internal string UnicodeEquivalent(string idnHost, Char* hostname, int start, int end)
internal string UnicodeEquivalent(Char* hostname, int start, int end, Boolean& allAscii, Boolean& atLeastOneValidIdn)
private bool IsASCIILetterOrDigit(char character, Boolean& notCanonical)
private bool IsValidDomainLabelCharacter(char character, Boolean& notCanonical)
}
internal System.EnvironmentHelpers : object {
internal bool IsWindowsVistaOrAbove()
}
public System.GenericUriParser : UriParser {
private UriSyntaxFlags DefaultGenericUriParserFlags
public void .ctor(GenericUriParserOptions options)
private UriSyntaxFlags MapGenericParserOptions(GenericUriParserOptions options)
}
public System.GenericUriParserOptions : Enum {
public int value__
public GenericUriParserOptions Default
public GenericUriParserOptions GenericAuthority
public GenericUriParserOptions AllowEmptyAuthority
public GenericUriParserOptions NoUserInfo
public GenericUriParserOptions NoPort
public GenericUriParserOptions NoQuery
public GenericUriParserOptions NoFragment
public GenericUriParserOptions DontConvertPathBackslashes
public GenericUriParserOptions DontCompressPath
public GenericUriParserOptions DontUnescapePathDotsAndSlashes
public GenericUriParserOptions Idn
public GenericUriParserOptions IriParsing
}
internal System.HResults : object {
internal int Configuration
internal int Xml
internal int XmlSchema
internal int XmlXslt
internal int XmlXPath
internal int Data
internal int DataDeletedRowInaccessible
internal int DataDuplicateName
internal int DataInRowChangingEvent
internal int DataInvalidConstraint
internal int DataMissingPrimaryKey
internal int DataNoNullAllowed
internal int DataReadOnly
internal int DataRowNotInTable
internal int DataVersionNotFound
internal int DataConstraint
internal int StrongTyping
internal int SqlType
internal int SqlNullValue
internal int SqlTruncate
internal int AdapterMapping
internal int DataAdapter
internal int DBConcurrency
internal int OperationAborted
internal int InvalidUdt
internal int Metadata
internal int InvalidQuery
internal int CommandCompilation
internal int CommandExecution
internal int SqlException
internal int OdbcException
internal int OracleException
internal int ConnectionPlanException
internal int NteBadKeySet
internal int Win32AccessDenied
internal int Win32InvalidHandle
internal int License
internal int InternalBufferOverflow
internal int ServiceControllerTimeout
internal int Install
internal int EFail
}
internal System.InvariantComparer : object {
private CompareInfo m_compareInfo
internal InvariantComparer Default
public int Compare(object a, object b)
}
public System.IO.Compression.CompressionLevel : Enum {
public int value__
public CompressionLevel Optimal
public CompressionLevel Fastest
public CompressionLevel NoCompression
}
public System.IO.Compression.CompressionMode : Enum {
public int value__
public CompressionMode Decompress
public CompressionMode Compress
}
public System.IO.Compression.DeflateStream : Stream {
private Stream base_stream
private CompressionMode mode
private bool leaveOpen
private bool disposed
private DeflateStreamNative native
public Stream BaseStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(Stream stream, CompressionMode mode)
public void .ctor(Stream stream, CompressionMode mode, bool leaveOpen)
internal void .ctor(Stream stream, CompressionMode mode, bool leaveOpen, int windowsBits)
internal void .ctor(Stream compressedStream, CompressionMode mode, bool leaveOpen, bool gzip)
public void .ctor(Stream stream, CompressionLevel compressionLevel)
public void .ctor(Stream stream, CompressionLevel compressionLevel, bool leaveOpen)
internal void .ctor(Stream stream, CompressionLevel compressionLevel, bool leaveOpen, int windowsBits)
internal void .ctor(Stream stream, CompressionLevel compressionLevel, bool leaveOpen, bool gzip)
protected void Dispose(bool disposing)
private int ReadInternal(Byte[] array, int offset, int count)
internal ValueTask`1<int> ReadAsyncMemory(Memory`1<byte> destination, CancellationToken cancellationToken)
internal int ReadCore(Span`1<byte> destination)
public int Read(Byte[] array, int offset, int count)
private void WriteInternal(Byte[] array, int offset, int count)
internal Task WriteAsyncMemory(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken)
internal void WriteCore(ReadOnlySpan`1<byte> source)
public void Write(Byte[] array, int offset, int count)
public void Flush()
public IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public Stream get_BaseStream()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
}
internal System.IO.Compression.DeflateStreamNative : object {
private int BufferSize
private UnmanagedReadOrWrite feeder
private Stream base_stream
private SafeDeflateStreamHandle z_stream
private GCHandle data
private bool disposed
private Byte[] io_buffer
private string LIBNAME
public DeflateStreamNative Create(Stream compressedStream, CompressionMode mode, bool gzip)
protected void Finalize()
public void Dispose(bool disposing)
public void Flush()
public int ReadZStream(IntPtr buffer, int length)
public void WriteZStream(IntPtr buffer, int length)
private int UnmanagedRead(IntPtr buffer, int length, IntPtr data)
private int UnmanagedRead(IntPtr buffer, int length)
private int UnmanagedWrite(IntPtr buffer, int length, IntPtr data)
private int UnmanagedWrite(IntPtr buffer, int length)
private void CheckResult(int result, string where)
private SafeDeflateStreamHandle CreateZStream(CompressionMode compress, bool gzip, UnmanagedReadOrWrite feeder, IntPtr data)
private int CloseZStream(IntPtr stream)
private int Flush(SafeDeflateStreamHandle stream)
private int ReadZStream(SafeDeflateStreamHandle stream, IntPtr buffer, int length)
private int WriteZStream(SafeDeflateStreamHandle stream, IntPtr buffer, int length)
}
public System.IO.Compression.GZipStream : Stream {
private DeflateStream _deflateStream
public bool CanRead
public bool CanWrite
public bool CanSeek
public long Length
public long Position
public Stream BaseStream
public void .ctor(Stream stream, CompressionMode mode)
public void .ctor(Stream stream, CompressionMode mode, bool leaveOpen)
public void .ctor(Stream stream, CompressionLevel compressionLevel)
public void .ctor(Stream stream, CompressionLevel compressionLevel, bool leaveOpen)
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public int ReadByte()
public IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public int EndRead(IAsyncResult asyncResult)
public int Read(Byte[] array, int offset, int count)
public int Read(Span`1<byte> destination)
public IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void EndWrite(IAsyncResult asyncResult)
public void Write(Byte[] array, int offset, int count)
public void Write(ReadOnlySpan`1<byte> source)
public void CopyTo(Stream destination, int bufferSize)
protected void Dispose(bool disposing)
public Stream get_BaseStream()
public Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken)
public ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken)
public Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken)
public Task WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken)
public Task FlushAsync(CancellationToken cancellationToken)
public Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
private void CheckDeflateStream()
private void ThrowStreamClosedException()
}
internal System.IO.Compression.ZLibNative : object {
public int GZip_DefaultWindowBits
}
internal System.IO.DefaultWatcher : object {
private DefaultWatcher instance
private Thread thread
private Hashtable watches
private String[] NoStringsArray
public bool GetInstance(IFileWatcher& watcher)
public void StartDispatching(FileSystemWatcher fsw)
public void StopDispatching(FileSystemWatcher fsw)
private void Monitor()
private bool UpdateDataAndDispatch(DefaultWatcherData data, bool dispatch)
private void DispatchEvents(FileSystemWatcher fsw, FileAction action, string filename)
private void DoFiles(DefaultWatcherData data, string directory, bool dispatch)
private void IterateAndModifyFilesData(DefaultWatcherData data, string directory, bool dispatch, String[] files)
private FileData CreateFileData(string directory, string filename)
}
internal System.IO.DefaultWatcherData : object {
public FileSystemWatcher FSW
public string Directory
public string FileMask
public bool IncludeSubdirs
public bool Enabled
public bool NoWildcards
public DateTime DisabledTime
public object FilesLock
public Hashtable Files
}
public System.IO.ErrorEventArgs : EventArgs {
private Exception exception
public void .ctor(Exception exception)
public Exception GetException()
}
public System.IO.ErrorEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ErrorEventArgs e)
public IAsyncResult BeginInvoke(object sender, ErrorEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.IO.EventFilter : Enum {
public short value__
public EventFilter Read
public EventFilter Write
public EventFilter Aio
public EventFilter Vnode
public EventFilter Proc
public EventFilter Signal
public EventFilter Timer
public EventFilter MachPort
public EventFilter FS
public EventFilter User
public EventFilter VM
}
internal System.IO.EventFlags : Enum {
public ushort value__
public EventFlags Add
public EventFlags Delete
public EventFlags Enable
public EventFlags Disable
public EventFlags OneShot
public EventFlags Clear
public EventFlags Receipt
public EventFlags Dispatch
public EventFlags Flag0
public EventFlags Flag1
public EventFlags SystemFlags
public EventFlags EOF
public EventFlags Error
}
internal System.IO.FAMCodes : Enum {
public int value__
public FAMCodes Changed
public FAMCodes Deleted
public FAMCodes StartExecuting
public FAMCodes StopExecuting
public FAMCodes Created
public FAMCodes Moved
public FAMCodes Acknowledge
public FAMCodes Exists
public FAMCodes EndExist
}
internal System.IO.FAMConnection : ValueType {
public int FD
public IntPtr opaque
}
internal System.IO.FAMData : object {
public FileSystemWatcher FSW
public string Directory
public string FileMask
public bool IncludeSubdirs
public bool Enabled
public FAMRequest Request
public Hashtable SubDirs
}
internal System.IO.FAMRequest : ValueType {
public int ReqNum
}
internal System.IO.FAMWatcher : object {
private bool failed
private FAMWatcher instance
private Hashtable watches
private Hashtable requests
private FAMConnection conn
private Thread thread
private bool stop
private bool use_gamin
private NotifyFilters changed
public bool GetInstance(IFileWatcher& watcher, bool gamin)
public void StartDispatching(FileSystemWatcher fsw)
private void StartMonitoringDirectory(FAMData data, bool justcreated)
public void StopDispatching(FileSystemWatcher fsw)
private void StopMonitoringDirectory(FAMData data)
private void Monitor()
private void ProcessEvents()
protected void Finalize()
private int FAMOpen(FAMConnection& fc)
private int FAMClose(FAMConnection& fc)
private int FAMMonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data)
private int FAMCancelMonitor(FAMConnection& fc, FAMRequest& fr)
private int FAMPending(FAMConnection& fc)
private int fam_Open(FAMConnection& fc)
private int fam_Close(FAMConnection& fc)
private int fam_MonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data)
private int fam_CancelMonitor(FAMConnection& fc, FAMRequest& fr)
private int fam_Pending(FAMConnection& fc)
private int gamin_Open(FAMConnection& fc)
private int gamin_Close(FAMConnection& fc)
private int gamin_MonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data)
private int gamin_CancelMonitor(FAMConnection& fc, FAMRequest& fr)
private int gamin_Pending(FAMConnection& fc)
private int InternalFAMNextEvent(FAMConnection& fc, String& filename, Int32& code, Int32& reqnum)
}
internal System.IO.FileAction : Enum {
public int value__
public FileAction Added
public FileAction Removed
public FileAction Modified
public FileAction RenamedOldName
public FileAction RenamedNewName
}
internal System.IO.FileData : object {
public string Directory
public FileAttributes Attributes
public bool NotExists
public DateTime CreationTime
public DateTime LastWriteTime
}
public System.IO.FileSystemEventArgs : EventArgs {
private WatcherChangeTypes changeType
private string directory
private string name
public WatcherChangeTypes ChangeType
public string FullPath
public string Name
public void .ctor(WatcherChangeTypes changeType, string directory, string name)
internal void SetName(string name)
public WatcherChangeTypes get_ChangeType()
public string get_FullPath()
public string get_Name()
}
public System.IO.FileSystemEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, FileSystemEventArgs e)
public IAsyncResult BeginInvoke(object sender, FileSystemEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.FileSystemWatcher : Component {
private bool enableRaisingEvents
private string filter
private bool includeSubdirectories
private int internalBufferSize
private NotifyFilters notifyFilter
private string path
private string fullpath
private ISynchronizeInvoke synchronizingObject
private WaitForChangedResult lastData
private bool waiting
private SearchPattern2 pattern
private bool disposed
private string mangledFilter
private IFileWatcher watcher
private object lockobj
private FileSystemEventHandler Changed
private FileSystemEventHandler Created
private FileSystemEventHandler Deleted
private ErrorEventHandler Error
private RenamedEventHandler Renamed
internal bool Waiting
internal string MangledFilter
internal SearchPattern2 Pattern
internal string FullPath
public bool EnableRaisingEvents
public string Filter
public bool IncludeSubdirectories
public int InternalBufferSize
public NotifyFilters NotifyFilter
public string Path
public ISite Site
public ISynchronizeInvoke SynchronizingObject
public void .ctor(string path)
public void .ctor(string path, string filter)
private void InitWatcher()
private void ShowWatcherInfo()
internal bool get_Waiting()
internal void set_Waiting(bool value)
internal string get_MangledFilter()
internal SearchPattern2 get_Pattern()
internal string get_FullPath()
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
public string get_Filter()
public void set_Filter(string value)
public bool get_IncludeSubdirectories()
public void set_IncludeSubdirectories(bool value)
public int get_InternalBufferSize()
public void set_InternalBufferSize(int value)
public NotifyFilters get_NotifyFilter()
public void set_NotifyFilter(NotifyFilters value)
public string get_Path()
public void set_Path(string value)
public ISite get_Site()
public void set_Site(ISite value)
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public void BeginInit()
protected void Dispose(bool disposing)
protected void Finalize()
public void EndInit()
private void RaiseEvent(Delegate ev, EventArgs arg, EventType evtype)
protected void OnChanged(FileSystemEventArgs e)
protected void OnCreated(FileSystemEventArgs e)
protected void OnDeleted(FileSystemEventArgs e)
protected void OnError(ErrorEventArgs e)
protected void OnRenamed(RenamedEventArgs e)
public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType)
public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout)
internal void DispatchErrorEvents(ErrorEventArgs args)
internal void DispatchEvents(FileAction act, string filename, RenamedEventArgs& renamed)
private void Start()
private void Stop()
public void add_Changed(FileSystemEventHandler value)
public void remove_Changed(FileSystemEventHandler value)
public void add_Created(FileSystemEventHandler value)
public void remove_Created(FileSystemEventHandler value)
public void add_Deleted(FileSystemEventHandler value)
public void remove_Deleted(FileSystemEventHandler value)
public void add_Error(ErrorEventHandler value)
public void remove_Error(ErrorEventHandler value)
public void add_Renamed(RenamedEventHandler value)
public void remove_Renamed(RenamedEventHandler value)
private int InternalSupportsFSW()
}
internal System.IO.FilterFlags : Enum {
public UInt32 value__
public FilterFlags ReadPoll
public FilterFlags ReadOutOfBand
public FilterFlags ReadLowWaterMark
public FilterFlags WriteLowWaterMark
public FilterFlags NoteTrigger
public FilterFlags NoteFFNop
public FilterFlags NoteFFAnd
public FilterFlags NoteFFOr
public FilterFlags NoteFFCopy
public FilterFlags NoteFFCtrlMask
public FilterFlags NoteFFlagsMask
public FilterFlags VNodeDelete
public FilterFlags VNodeWrite
public FilterFlags VNodeExtend
public FilterFlags VNodeAttrib
public FilterFlags VNodeLink
public FilterFlags VNodeRename
public FilterFlags VNodeRevoke
public FilterFlags VNodeNone
public FilterFlags ProcExit
public FilterFlags ProcFork
public FilterFlags ProcExec
public FilterFlags ProcReap
public FilterFlags ProcSignal
public FilterFlags ProcExitStatus
public FilterFlags ProcResourceEnd
public FilterFlags ProcAppactive
public FilterFlags ProcAppBackground
public FilterFlags ProcAppNonUI
public FilterFlags ProcAppInactive
public FilterFlags ProcAppAllStates
public FilterFlags ProcPDataMask
public FilterFlags ProcControlMask
public FilterFlags VMPressure
public FilterFlags VMPressureTerminate
public FilterFlags VMPressureSuddenTerminate
public FilterFlags VMError
public FilterFlags TimerSeconds
public FilterFlags TimerMicroSeconds
public FilterFlags TimerNanoSeconds
public FilterFlags TimerAbsolute
}
internal System.IO.IFileWatcher {
public void StartDispatching(FileSystemWatcher fsw)
public void StopDispatching(FileSystemWatcher fsw)
}
internal System.IO.InotifyData : object {
public FileSystemWatcher FSW
public string Directory
public int Watch
}
internal System.IO.InotifyEvent : ValueType {
public InotifyEvent Default
public int WatchDescriptor
public InotifyMask Mask
public string Name
public string ToString()
}
internal System.IO.InotifyMask : Enum {
public UInt32 value__
public InotifyMask Access
public InotifyMask Modify
public InotifyMask Attrib
public InotifyMask CloseWrite
public InotifyMask CloseNoWrite
public InotifyMask Open
public InotifyMask MovedFrom
public InotifyMask MovedTo
public InotifyMask Create
public InotifyMask Delete
public InotifyMask DeleteSelf
public InotifyMask MoveSelf
public InotifyMask BaseEvents
public InotifyMask Umount
public InotifyMask Overflow
public InotifyMask Ignored
public InotifyMask OnlyDir
public InotifyMask DontFollow
public InotifyMask AddMask
public InotifyMask Directory
public InotifyMask OneShot
}
internal System.IO.InotifyWatcher : object {
private bool failed
private InotifyWatcher instance
private Hashtable watches
private Hashtable requests
private IntPtr FD
private Thread thread
private bool stop
private InotifyMask Interesting
public bool GetInstance(IFileWatcher& watcher, bool gamin)
public void StartDispatching(FileSystemWatcher fsw)
private void AppendRequestData(InotifyData data)
private bool RemoveRequestData(InotifyData data)
private InotifyMask GetMaskFromFilters(NotifyFilters filters)
private void StartMonitoringDirectory(InotifyData data, bool justcreated)
public void StopDispatching(FileSystemWatcher fsw)
private void StopMonitoringDirectory(InotifyData data)
private void Monitor()
private int ReadEvent(Byte[] source, int off, int size, InotifyEvent& evt)
private IEnumerable GetEnumerator(object source)
private void ProcessEvents(Byte[] buffer, int length)
private int AddDirectoryWatch(IntPtr fd, string directory, InotifyMask mask)
internal int Close(IntPtr fd)
private int ReadFromFD(IntPtr fd, Byte[] buffer, IntPtr length)
private IntPtr GetInotifyInstance()
private int AddWatch(IntPtr fd, string name, InotifyMask mask)
private IntPtr RemoveWatch(IntPtr fd, int wd)
}
public System.IO.InternalBufferOverflowException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
public System.IO.InvalidDataException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
private void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.IODescriptionAttribute : DescriptionAttribute {
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.IO.kevent : ValueType {
public UIntPtr ident
public EventFilter filter
public EventFlags flags
public FilterFlags fflags
public IntPtr data
public IntPtr udata
public void Dispose()
}
internal System.IO.KeventWatcher : object {
private bool failed
private KeventWatcher instance
private Hashtable watches
public bool GetInstance(IFileWatcher& watcher)
public void StartDispatching(FileSystemWatcher fsw)
public void StopDispatching(FileSystemWatcher fsw)
private int close(int fd)
private int kqueue()
}
internal System.IO.KqueueMonitor : object {
private bool initialized
private int O_EVTONLY
private int F_GETPATH
private int __DARWIN_MAXPATHLEN
private int EINTR
private kevent[] emptyEventList
private int maxFds
private FileSystemWatcher fsw
private int conn
private Thread thread
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) requestStop
private AutoResetEvent startedEvent
private bool started
private bool inDispatch
private Exception exc
private object stateLock
private object connLock
private Dictionary`2<string, PathData> pathsDict
private Dictionary`2<int, PathData> fdsDict
private string fixupPath
private string fullPathNoLastSlash
public int Connection
public int get_Connection()
public void .ctor(FileSystemWatcher fsw)
public void Dispose()
public void Start()
public void Stop()
private void CleanUp()
private void DoMonitor()
private void Setup()
private kevent[] CreateChangeList(List`1& FdList)
private void Monitor()
private PathData Add(string path, bool postEvents, List`1& fds)
private void Remove(PathData pathData)
private void RemoveTree(PathData pathData)
private void UpdatePath(PathData pathData)
private void Scan(string path, bool postEvents, List`1& fds)
private void PostEvent(FileAction action, string path, string newPath)
private string GetFilenameFromFd(int fd)
private int fcntl(int file_names_by_descriptor, int cmd, StringBuilder sb)
private IntPtr realpath(string pathname, StringBuilder sb)
private int open(string path, int flags, int mode_t)
private int close(int fd)
private int kqueue()
private int kevent(int kq, kevent[] ev, int nchanges, kevent[] evtlist, int nevents, timespec& time)
private int kevent_notimeout(Int32& kq, IntPtr ev, int nchanges, IntPtr evtlist, int nevents)
private void <Start>b__5_0()
}
public System.IO.NotifyFilters : Enum {
public int value__
public NotifyFilters Attributes
public NotifyFilters CreationTime
public NotifyFilters DirectoryName
public NotifyFilters FileName
public NotifyFilters LastAccess
public NotifyFilters LastWrite
public NotifyFilters Security
public NotifyFilters Size
}
internal System.IO.NullFileWatcher : object {
private IFileWatcher instance
public void StartDispatching(FileSystemWatcher fsw)
public void StopDispatching(FileSystemWatcher fsw)
public bool GetInstance(IFileWatcher& watcher)
}
internal System.IO.ParentInotifyData : object {
public bool IncludeSubdirs
public bool Enabled
public ArrayList children
public InotifyData data
}
internal System.IO.PathData : object {
public string Path
public bool IsDirectory
public int Fd
}
internal System.IO.Ports.CommStat : ValueType {
public UInt32 flags
public UInt32 BytesIn
public UInt32 BytesOut
}
internal System.IO.Ports.DCB : object {
public int dcb_length
public int baud_rate
public int flags
public short w_reserved
public short xon_lim
public short xoff_lim
public byte byte_size
public byte parity
public byte stop_bits
public byte xon_char
public byte xoff_char
public byte error_char
public byte eof_char
public byte evt_char
public short w_reserved1
private int fOutxCtsFlow
private int fOutX
private int fInX
private int fRtsControl2
public void SetValues(int baud_rate, Parity parity, int byte_size, StopBits sb, Handshake hs)
}
public System.IO.Ports.Handshake : Enum {
public int value__
public Handshake None
public Handshake XOnXOff
public Handshake RequestToSend
public Handshake RequestToSendXOnXOff
}
internal System.IO.Ports.InternalResources : object {
internal void EndOfFile()
internal string GetMessage(int errorCode)
internal void FileNotOpen()
internal void WrongAsyncResult()
internal void EndReadCalledTwice()
internal void EndWriteCalledTwice()
internal void WinIOError(int errorCode, string str)
internal int MakeHRFromErrorCode(int errorCode)
}
internal System.IO.Ports.ISerialStream {
public int BytesToRead
public int BytesToWrite
public int ReadTimeout
public int WriteTimeout
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
public void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits sb, Handshake hs)
public void DiscardInBuffer()
public void DiscardOutBuffer()
public SerialSignal GetSignals()
public void SetSignal(SerialSignal signal, bool value)
public void SetBreakState(bool value)
public void Close()
public int get_BytesToRead()
public int get_BytesToWrite()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
}
public System.IO.Ports.Parity : Enum {
public int value__
public Parity None
public Parity Odd
public Parity Even
public Parity Mark
public Parity Space
}
public System.IO.Ports.SerialData : Enum {
public int value__
public SerialData Chars
public SerialData Eof
}
public System.IO.Ports.SerialDataReceivedEventArgs : EventArgs {
private SerialData eventType
public SerialData EventType
internal void .ctor(SerialData eventType)
public SerialData get_EventType()
}
public System.IO.Ports.SerialDataReceivedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SerialDataReceivedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SerialDataReceivedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Ports.SerialError : Enum {
public int value__
public SerialError RXOver
public SerialError Overrun
public SerialError RXParity
public SerialError Frame
public SerialError TXFull
}
public System.IO.Ports.SerialErrorReceivedEventArgs : EventArgs {
private SerialError eventType
public SerialError EventType
internal void .ctor(SerialError eventType)
public SerialError get_EventType()
}
public System.IO.Ports.SerialErrorReceivedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SerialErrorReceivedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SerialErrorReceivedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Ports.SerialPinChange : Enum {
public int value__
public SerialPinChange CtsChanged
public SerialPinChange DsrChanged
public SerialPinChange CDChanged
public SerialPinChange Break
public SerialPinChange Ring
}
public System.IO.Ports.SerialPinChangedEventArgs : EventArgs {
private SerialPinChange eventType
public SerialPinChange EventType
internal void .ctor(SerialPinChange eventType)
public SerialPinChange get_EventType()
}
public System.IO.Ports.SerialPinChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SerialPinChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SerialPinChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Ports.SerialPort : Component {
public int InfiniteTimeout
private int DefaultReadBufferSize
private int DefaultWriteBufferSize
private int DefaultBaudRate
private int DefaultDataBits
private Parity DefaultParity
private StopBits DefaultStopBits
private bool is_open
private int baud_rate
private Parity parity
private StopBits stop_bits
private Handshake handshake
private int data_bits
private bool break_state
private bool dtr_enable
private bool rts_enable
private ISerialStream stream
private Encoding encoding
private string new_line
private string port_name
private int read_timeout
private int write_timeout
private int readBufferSize
private int writeBufferSize
private object error_received
private object data_received
private object pin_changed
public Stream BaseStream
public int BaudRate
public bool BreakState
public int BytesToRead
public int BytesToWrite
public bool CDHolding
public bool CtsHolding
public int DataBits
public bool DiscardNull
public bool DsrHolding
public bool DtrEnable
public Encoding Encoding
public Handshake Handshake
public bool IsOpen
public string NewLine
public Parity Parity
public byte ParityReplace
public string PortName
public int ReadBufferSize
public int ReadTimeout
public int ReceivedBytesThreshold
public bool RtsEnable
public StopBits StopBits
public int WriteBufferSize
public int WriteTimeout
private bool IsWindows
public void .ctor(IContainer container)
public void .ctor(string portName)
public void .ctor(string portName, int baudRate)
public void .ctor(string portName, int baudRate, Parity parity)
public void .ctor(string portName, int baudRate, Parity parity, int dataBits)
public void .ctor(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits)
private string GetDefaultPortName()
public Stream get_BaseStream()
public int get_BaudRate()
public void set_BaudRate(int value)
public bool get_BreakState()
public void set_BreakState(bool value)
public int get_BytesToRead()
public int get_BytesToWrite()
public bool get_CDHolding()
public bool get_CtsHolding()
public int get_DataBits()
public void set_DataBits(int value)
public bool get_DiscardNull()
public void set_DiscardNull(bool value)
public bool get_DsrHolding()
public bool get_DtrEnable()
public void set_DtrEnable(bool value)
public Encoding get_Encoding()
public void set_Encoding(Encoding value)
public Handshake get_Handshake()
public void set_Handshake(Handshake value)
public bool get_IsOpen()
public string get_NewLine()
public void set_NewLine(string value)
public Parity get_Parity()
public void set_Parity(Parity value)
public byte get_ParityReplace()
public void set_ParityReplace(byte value)
public string get_PortName()
public void set_PortName(string value)
public int get_ReadBufferSize()
public void set_ReadBufferSize(int value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_ReceivedBytesThreshold()
public void set_ReceivedBytesThreshold(int value)
public bool get_RtsEnable()
public void set_RtsEnable(bool value)
public StopBits get_StopBits()
public void set_StopBits(StopBits value)
public int get_WriteBufferSize()
public void set_WriteBufferSize(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public void Close()
protected void Dispose(bool disposing)
public void DiscardInBuffer()
public void DiscardOutBuffer()
public String[] GetPortNames()
private bool get_IsWindows()
public void Open()
public int Read(Byte[] buffer, int offset, int count)
public int Read(Char[] buffer, int offset, int count)
internal int read_byte()
public int ReadByte()
public int ReadChar()
public string ReadExisting()
public string ReadLine()
public string ReadTo(string value)
public void Write(string text)
public void Write(Byte[] buffer, int offset, int count)
public void Write(Char[] buffer, int offset, int count)
public void WriteLine(string text)
private void CheckOpen()
internal void OnErrorReceived(SerialErrorReceivedEventArgs args)
internal void OnDataReceived(SerialDataReceivedEventArgs args)
internal void OnDataReceived(SerialPinChangedEventArgs args)
public void add_ErrorReceived(SerialErrorReceivedEventHandler value)
public void remove_ErrorReceived(SerialErrorReceivedEventHandler value)
public void add_PinChanged(SerialPinChangedEventHandler value)
public void remove_PinChanged(SerialPinChangedEventHandler value)
public void add_DataReceived(SerialDataReceivedEventHandler value)
public void remove_DataReceived(SerialDataReceivedEventHandler value)
}
internal System.IO.Ports.SerialPortStream : Stream {
private int fd
private int read_timeout
private int write_timeout
private bool disposed
public bool CanRead
public bool CanSeek
public bool CanWrite
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
public int BytesToRead
public int BytesToWrite
private int open_serial(string portName)
public void .ctor(string portName, int baudRate, int dataBits, Parity parity, StopBits stopBits, bool dtrEnable, bool rtsEnable, Handshake handshake, int readTimeout, int writeTimeout, int readBufferSize, int writeBufferSize)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
private int read_serial(int fd, Byte[] buffer, int offset, int count)
private bool poll_serial(int fd, Int32& error, int timeout)
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
private int write_serial(int fd, Byte[] buffer, int offset, int count, int timeout)
public void Write(Byte[] buffer, int offset, int count)
protected void Dispose(bool disposing)
private int close_serial(int fd)
public void Close()
private void System.IDisposable.Dispose()
protected void Finalize()
private void CheckDisposed()
private bool set_attributes(int fd, int baudRate, Parity parity, int dataBits, StopBits stopBits, Handshake handshake)
public void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits sb, Handshake hs)
private int get_bytes_in_buffer(int fd, int input)
public int get_BytesToRead()
public int get_BytesToWrite()
private int discard_buffer(int fd, bool inputBuffer)
public void DiscardInBuffer()
public void DiscardOutBuffer()
private SerialSignal get_signals(int fd, Int32& error)
public SerialSignal GetSignals()
private int set_signal(int fd, SerialSignal signal, bool value)
public void SetSignal(SerialSignal signal, bool value)
private int breakprop(int fd)
public void SetBreakState(bool value)
private IntPtr strerror(int errnum)
private void ThrowIOException()
private bool is_baud_rate_legal(int baud_rate)
private void TryBaudRate(int baudRate)
}
internal System.IO.Ports.SerialSignal : Enum {
public int value__
public SerialSignal None
public SerialSignal Cd
public SerialSignal Cts
public SerialSignal Dsr
public SerialSignal Dtr
public SerialSignal Rts
}
public System.IO.Ports.StopBits : Enum {
public int value__
public StopBits None
public StopBits One
public StopBits Two
public StopBits OnePointFive
}
internal System.IO.Ports.Timeouts : object {
public UInt32 ReadIntervalTimeout
public UInt32 ReadTotalTimeoutMultiplier
public UInt32 ReadTotalTimeoutConstant
public UInt32 WriteTotalTimeoutMultiplier
public UInt32 WriteTotalTimeoutConstant
public UInt32 MaxDWord
public void .ctor(int read_timeout, int write_timeout)
public void SetValues(int read_timeout, int write_timeout)
}
internal System.IO.Ports.WinSerialStream : Stream {
private UInt32 GenericRead
private UInt32 GenericWrite
private UInt32 OpenExisting
private UInt32 FileFlagOverlapped
private UInt32 PurgeRxClear
private UInt32 PurgeTxClear
private UInt32 WinInfiniteTimeout
private UInt32 FileIOPending
private UInt32 SetRts
private UInt32 ClearRts
private UInt32 SetDtr
private UInt32 ClearDtr
private UInt32 SetBreak
private UInt32 ClearBreak
private UInt32 CtsOn
private UInt32 DsrOn
private UInt32 RsldOn
private UInt32 EvRxChar
private UInt32 EvCts
private UInt32 EvDsr
private UInt32 EvRlsd
private UInt32 EvBreak
private UInt32 EvErr
private UInt32 EvRing
private int handle
private int read_timeout
private int write_timeout
private bool disposed
private IntPtr write_overlapped
private IntPtr read_overlapped
private ManualResetEvent read_event
private ManualResetEvent write_event
private Timeouts timeouts
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
public int BytesToRead
public int BytesToWrite
private int CreateFile(string port_name, UInt32 desired_access, UInt32 share_mode, UInt32 security_attrs, UInt32 creation, UInt32 flags, UInt32 template)
private bool SetupComm(int handle, int read_buffer_size, int write_buffer_size)
private bool PurgeComm(int handle, UInt32 flags)
private bool SetCommTimeouts(int handle, Timeouts timeouts)
public void .ctor(string port_name, int baud_rate, int data_bits, Parity parity, StopBits sb, bool dtr_enable, bool rts_enable, Handshake hs, int read_timeout, int write_timeout, int read_buffer_size, int write_buffer_size)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
private bool CloseHandle(int handle)
protected void Dispose(bool disposing)
private void System.IDisposable.Dispose()
public void Close()
protected void Finalize()
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
private bool ReadFile(int handle, Byte* buffer, int bytes_to_read, Int32& bytes_read, IntPtr overlapped)
private bool GetOverlappedResult(int handle, IntPtr overlapped, Int32& bytes_transfered, bool wait)
public int Read(Byte[] buffer, int offset, int count)
private bool WriteFile(int handle, Byte* buffer, int bytes_to_write, Int32& bytes_written, IntPtr overlapped)
public void Write(Byte[] buffer, int offset, int count)
private bool GetCommState(int handle, DCB dcb)
private bool SetCommState(int handle, DCB dcb)
public void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits bits, Handshake hs)
private void ReportIOError(string optional_arg)
private void CheckDisposed()
public void DiscardInBuffer()
public void DiscardOutBuffer()
private bool ClearCommError(int handle, UInt32& errors, CommStat& stat)
public int get_BytesToRead()
public int get_BytesToWrite()
private bool GetCommModemStatus(int handle, UInt32& flags)
public SerialSignal GetSignals()
private bool EscapeCommFunction(int handle, UInt32 flags)
public void SetSignal(SerialSignal signal, bool value)
public void SetBreakState(bool value)
}
public System.IO.RenamedEventArgs : FileSystemEventArgs {
private string oldName
private string oldFullPath
public string OldFullPath
public string OldName
public void .ctor(WatcherChangeTypes changeType, string directory, string name, string oldName)
public string get_OldFullPath()
public string get_OldName()
}
public System.IO.RenamedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, RenamedEventArgs e)
public IAsyncResult BeginInvoke(object sender, RenamedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.IO.SearchPattern2 : object {
private Op ops
private bool ignore
private bool hasWildcard
private string pattern
internal Char[] WildcardChars
internal Char[] InvalidChars
public bool HasWildcard
public void .ctor(string pattern)
public void .ctor(string pattern, bool ignore)
public bool IsMatch(string text, bool ignorecase)
public bool IsMatch(string text)
public bool get_HasWildcard()
private void Compile(string pattern)
private bool Match(Op op, string text, int ptr)
}
internal System.IO.timespec : ValueType {
public IntPtr tv_sec
public IntPtr tv_nsec
}
public System.IO.WaitForChangedResult : ValueType {
private WatcherChangeTypes changeType
private string name
private string oldName
private bool timedOut
public WatcherChangeTypes ChangeType
public string Name
public string OldName
public bool TimedOut
public WatcherChangeTypes get_ChangeType()
public void set_ChangeType(WatcherChangeTypes value)
public string get_Name()
public void set_Name(string value)
public string get_OldName()
public void set_OldName(string value)
public bool get_TimedOut()
public void set_TimedOut(bool value)
}
public System.IO.WatcherChangeTypes : Enum {
public int value__
public WatcherChangeTypes All
public WatcherChangeTypes Changed
public WatcherChangeTypes Created
public WatcherChangeTypes Deleted
public WatcherChangeTypes Renamed
}
internal System.IO.WindowsWatcher : object {
public bool GetInstance(IFileWatcher& watcher)
public void StartDispatching(FileSystemWatcher fsw)
public void StopDispatching(FileSystemWatcher fsw)
}
internal System.IOAsyncCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(IOAsyncResult ioares)
public IAsyncResult BeginInvoke(IOAsyncResult ioares, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.IOAsyncResult : object {
private AsyncCallback async_callback
private object async_state
private ManualResetEvent wait_handle
private bool completed_synchronously
private bool completed
public AsyncCallback AsyncCallback
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
protected void Init(AsyncCallback async_callback, object async_state)
protected void .ctor(AsyncCallback async_callback, object async_state)
public AsyncCallback get_AsyncCallback()
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
protected void set_CompletedSynchronously(bool value)
public bool get_IsCompleted()
protected void set_IsCompleted(bool value)
internal void CompleteDisposed()
}
internal System.IOOperation : Enum {
public int value__
public IOOperation Read
public IOOperation Write
}
internal System.IOSelector : object {
public void Add(IntPtr handle, IOSelectorJob job)
public void Remove(IntPtr handle)
}
internal System.IOSelectorJob : object {
private IOOperation operation
private IOAsyncCallback callback
private IOAsyncResult state
public void .ctor(IOOperation operation, IOAsyncCallback callback, IOAsyncResult state)
private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae)
public void MarkDisposed()
}
internal System.IPv4AddressHelper : object {
internal long Invalid
private long MaxIPv4Value
private int Octal
private int Decimal
private int Hex
private int NumberOfLabels
internal string ParseCanonicalName(string str, int start, int end, Boolean& isLoopback)
internal int ParseHostNumber(string str, int start, int end)
internal bool IsValid(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile, bool unknownScheme)
internal bool IsValidCanonical(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile)
internal long ParseNonCanonical(Char* name, int start, Int32& end, bool notImplicitFile)
private bool Parse(string name, Byte* numbers, int start, int end)
private bool ParseCanonical(string name, Byte* numbers, int start, int end)
}
internal System.IPv6AddressHelper : object {
private int NumberOfLabels
private string LegacyFormat
private string CanonicalNumberFormat
private string EmbeddedIPv4Format
private string Separator
internal string ParseCanonicalName(string str, int start, Boolean& isLoopback, String& scopeId)
internal string CreateCanonicalName(UInt16* numbers)
private KeyValuePair`2<int, int> FindCompressionRange(UInt16* numbers)
private bool ShouldHaveIpv4Embedded(UInt16* numbers)
private bool InternalIsValid(Char* name, int start, Int32& end, bool validateStrictAddress)
internal bool IsValid(Char* name, int start, Int32& end)
internal bool IsValidStrict(Char* name, int start, Int32& end)
internal bool Parse(string address, UInt16* numbers, int start, String& scopeId)
}
internal System.IriHelper : object {
internal bool CheckIriUnicodeRange(char unicode, bool isQuery)
internal bool CheckIriUnicodeRange(char highSurr, char lowSurr, Boolean& surrogatePair, bool isQuery)
internal bool CheckIsReserved(char ch, UriComponents component)
internal string EscapeUnescapeIri(Char* pInput, int start, int end, UriComponents component)
}
internal System.LocalAppContextSwitches : object {
public bool MemberDescriptorEqualsReturnsFalseIfEquivalent
}
public System.Media.SoundPlayer : Component {
private string sound_location
private Stream audiostream
private object tag
private MemoryStream mstream
private bool load_completed
private int load_timeout
private AudioDevice adev
private AudioData adata
private bool stopped
private Win32SoundPlayer win32_player
private bool use_win32_player
private AsyncCompletedEventHandler LoadCompleted
private EventHandler SoundLocationChanged
private EventHandler StreamChanged
public bool IsLoadCompleted
public int LoadTimeout
public string SoundLocation
public Stream Stream
public object Tag
public void .ctor(Stream stream)
public void .ctor(string soundLocation)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext context)
private void LoadFromStream(Stream s)
private void LoadFromUri(string location)
public void Load()
private void AsyncFinished(IAsyncResult ar)
public void LoadAsync()
protected void OnLoadCompleted(AsyncCompletedEventArgs e)
protected void OnSoundLocationChanged(EventArgs e)
protected void OnStreamChanged(EventArgs e)
private void Start()
public void Play()
private void PlayLoop()
public void PlayLooping()
public void PlaySync()
public void Stop()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public bool get_IsLoadCompleted()
public int get_LoadTimeout()
public void set_LoadTimeout(int value)
public string get_SoundLocation()
public void set_SoundLocation(string value)
public Stream get_Stream()
public void set_Stream(Stream value)
public object get_Tag()
public void set_Tag(object value)
public void add_LoadCompleted(AsyncCompletedEventHandler value)
public void remove_LoadCompleted(AsyncCompletedEventHandler value)
public void add_SoundLocationChanged(EventHandler value)
public void remove_SoundLocationChanged(EventHandler value)
public void add_StreamChanged(EventHandler value)
public void remove_StreamChanged(EventHandler value)
}
public System.Media.SystemSound : object {
private Stream resource
internal void .ctor(string tag)
public void Play()
}
public System.Media.SystemSounds : object {
public SystemSound Asterisk
public SystemSound Beep
public SystemSound Exclamation
public SystemSound Hand
public SystemSound Question
public SystemSound get_Asterisk()
public SystemSound get_Beep()
public SystemSound get_Exclamation()
public SystemSound get_Hand()
public SystemSound get_Question()
}
internal System.MonoToolsLocator : object {
public string Mono
public string McsCSharpCompiler
public string VBCompiler
public string AssemblyLinker
private UInt32 GetModuleFileName(IntPtr hModule, StringBuilder lpFilename, int nSize)
}
public System.Net.AuthenticationManager : object {
private ArrayList modules
private object locker
private ICredentialPolicy credential_policy
public ICredentialPolicy CredentialPolicy
public StringDictionary CustomTargetNameDictionary
public IEnumerator RegisteredModules
internal bool OSSupportsExtendedProtection
private void EnsureModules()
public ICredentialPolicy get_CredentialPolicy()
public void set_CredentialPolicy(ICredentialPolicy value)
private Exception GetMustImplement()
public StringDictionary get_CustomTargetNameDictionary()
public IEnumerator get_RegisteredModules()
internal bool get_OSSupportsExtendedProtection()
internal void Clear()
public Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials)
private Authorization DoAuthenticate(string challenge, WebRequest request, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest request, ICredentials credentials)
public void Register(IAuthenticationModule authenticationModule)
public void Unregister(IAuthenticationModule authenticationModule)
public void Unregister(string authenticationScheme)
private void DoUnregister(string authenticationScheme, bool throwEx)
}
public System.Net.AuthenticationSchemes : Enum {
public int value__
public AuthenticationSchemes None
public AuthenticationSchemes Digest
public AuthenticationSchemes Negotiate
public AuthenticationSchemes Ntlm
public AuthenticationSchemes Basic
public AuthenticationSchemes Anonymous
public AuthenticationSchemes IntegratedWindowsAuthentication
}
public System.Net.AuthenticationSchemeSelector : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public AuthenticationSchemes Invoke(HttpListenerRequest httpRequest)
public IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object)
public AuthenticationSchemes EndInvoke(IAsyncResult result)
}
public System.Net.Authorization : object {
private string m_Message
private bool m_Complete
private String[] m_ProtectionRealm
private string m_ConnectionGroupId
private bool m_MutualAuth
internal string ModuleAuthenticationType
public string Message
public string ConnectionGroupId
public bool Complete
public String[] ProtectionRealm
public bool MutuallyAuthenticated
public void .ctor(string token)
public void .ctor(string token, bool finished)
public void .ctor(string token, bool finished, string connectionGroupId)
internal void .ctor(string token, bool finished, string connectionGroupId, bool mutualAuth)
public string get_Message()
public string get_ConnectionGroupId()
public bool get_Complete()
internal void SetComplete(bool complete)
public String[] get_ProtectionRealm()
public void set_ProtectionRealm(String[] value)
public bool get_MutuallyAuthenticated()
public void set_MutuallyAuthenticated(bool value)
}
internal System.Net.AutoWebProxyScriptEngine : object {
private Uri <AutomaticConfigurationScript>k__BackingField
private bool <AutomaticallyDetectSettings>k__BackingField
public Uri AutomaticConfigurationScript
public bool AutomaticallyDetectSettings
public void .ctor(WebProxy proxy, bool useRegistry)
public Uri get_AutomaticConfigurationScript()
public void set_AutomaticConfigurationScript(Uri value)
public bool get_AutomaticallyDetectSettings()
public void set_AutomaticallyDetectSettings(bool value)
public bool GetProxies(Uri destination, IList`1& proxyList)
public bool GetProxies(Uri destination, IList`1& proxyList, Int32& syncStatus)
public void Close()
public void Abort(Int32& syncStatus)
public void CheckForChanges()
public WebProxyData GetWebProxyData()
private WebProxyData ReadEnvVariables()
private bool IsWindows()
private WebProxyData InitializeRegistryGlobalProxy()
private Uri ToUri(string address)
private ArrayList CreateBypassList(ArrayList al)
}
internal System.Net.Base64Stream : DelegatedStream {
private Byte[] base64DecodeMap
private Byte[] base64EncodeMap
private int lineLength
private ReadStateInfo readState
private Base64WriteStateInfo writeState
private int sizeOfBase64EncodedChar
private byte invalidBase64Value
public bool CanWrite
private ReadStateInfo ReadState
internal Base64WriteStateInfo WriteState
internal void .ctor(Stream stream, Base64WriteStateInfo writeStateInfo)
internal void .ctor(Stream stream, int lineLength)
internal void .ctor(Base64WriteStateInfo writeStateInfo)
public bool get_CanWrite()
private ReadStateInfo get_ReadState()
internal Base64WriteStateInfo get_WriteState()
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
internal int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF)
public Stream GetStream()
public string GetEncodedString()
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
private void FlushInternal()
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
}
internal System.Net.BaseLoggingObject : object {
internal void EnterFunc(string funcname)
internal void LeaveFunc(string funcname)
internal void DumpArrayToConsole()
internal void PrintLine(string msg)
internal void DumpArray(bool shouldClose)
internal void DumpArrayToFile(bool shouldClose)
internal void Flush()
internal void Flush(bool close)
internal void LoggingMonitorTick()
internal void Dump(Byte[] buffer)
internal void Dump(Byte[] buffer, int length)
internal void Dump(Byte[] buffer, int offset, int length)
internal void Dump(IntPtr pBuffer, int offset, int length)
}
internal System.Net.BasicClient : object {
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
private Byte[] GetBytes(string str)
private Authorization InternalAuthenticate(WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
public System.Net.BindIPEndPoint : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public IPEndPoint Invoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount)
public IAsyncResult BeginInvoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount, AsyncCallback callback, object object)
public IPEndPoint EndInvoke(IAsyncResult result)
}
internal System.Net.Blob : ValueType {
public int cbSize
public int pBlobData
}
internal System.Net.BufferOffsetSize : object {
internal Byte[] Buffer
internal int Offset
internal int Size
internal void .ctor(Byte[] buffer, int offset, int size, bool copyBuffer)
internal void .ctor(Byte[] buffer, bool copyBuffer)
}
internal System.Net.BufferType : Enum {
public int value__
public BufferType Empty
public BufferType Data
public BufferType Token
public BufferType Parameters
public BufferType Missing
public BufferType Extra
public BufferType Trailer
public BufferType Header
public BufferType Padding
public BufferType Stream
public BufferType ChannelBindings
public BufferType TargetHost
public BufferType ReadOnlyFlag
public BufferType ReadOnlyWithChecksum
}
public System.Net.Cache.HttpCacheAgeControl : Enum {
public int value__
public HttpCacheAgeControl None
public HttpCacheAgeControl MinFresh
public HttpCacheAgeControl MaxAge
public HttpCacheAgeControl MaxStale
public HttpCacheAgeControl MaxAgeAndMinFresh
public HttpCacheAgeControl MaxAgeAndMaxStale
}
public System.Net.Cache.HttpRequestCacheLevel : Enum {
public int value__
public HttpRequestCacheLevel Default
public HttpRequestCacheLevel BypassCache
public HttpRequestCacheLevel CacheOnly
public HttpRequestCacheLevel CacheIfAvailable
public HttpRequestCacheLevel Revalidate
public HttpRequestCacheLevel Reload
public HttpRequestCacheLevel NoCacheNoStore
public HttpRequestCacheLevel CacheOrNextCacheOnly
public HttpRequestCacheLevel Refresh
}
public System.Net.Cache.HttpRequestCachePolicy : RequestCachePolicy {
internal HttpRequestCachePolicy BypassCache
private HttpRequestCacheLevel m_Level
private DateTime m_LastSyncDateUtc
private TimeSpan m_MaxAge
private TimeSpan m_MinFresh
private TimeSpan m_MaxStale
public HttpRequestCacheLevel Level
public DateTime CacheSyncDate
internal DateTime InternalCacheSyncDateUtc
public TimeSpan MaxAge
public TimeSpan MinFresh
public TimeSpan MaxStale
public void .ctor(HttpRequestCacheLevel level)
public void .ctor(HttpCacheAgeControl cacheAgeControl, TimeSpan ageOrFreshOrStale)
public void .ctor(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale)
public void .ctor(DateTime cacheSyncDate)
public void .ctor(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale, DateTime cacheSyncDate)
public HttpRequestCacheLevel get_Level()
public DateTime get_CacheSyncDate()
internal DateTime get_InternalCacheSyncDateUtc()
public TimeSpan get_MaxAge()
public TimeSpan get_MinFresh()
public TimeSpan get_MaxStale()
public string ToString()
private RequestCacheLevel MapLevel(HttpRequestCacheLevel level)
}
internal System.Net.Cache.RequestCache : object {
internal Char[] LineSplits
private bool _IsPrivateCache
private bool _CanWrite
internal bool IsPrivateCache
internal bool CanWrite
protected void .ctor(bool isPrivateCache, bool canWrite)
internal bool get_IsPrivateCache()
internal bool get_CanWrite()
internal Stream Retrieve(string key, RequestCacheEntry& cacheEntry)
internal Stream Store(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata)
internal void Remove(string key)
internal void Update(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata)
internal bool TryRetrieve(string key, RequestCacheEntry& cacheEntry, Stream& readStream)
internal bool TryStore(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata, Stream& writeStream)
internal bool TryRemove(string key)
internal bool TryUpdate(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata)
internal void UnlockEntry(Stream retrieveStream)
}
internal System.Net.Cache.RequestCacheBinding : object {
private RequestCache m_RequestCache
private RequestCacheValidator m_CacheValidator
private RequestCachePolicy m_Policy
internal RequestCache Cache
internal RequestCacheValidator Validator
internal RequestCachePolicy Policy
internal void .ctor(RequestCache requestCache, RequestCacheValidator cacheValidator, RequestCachePolicy policy)
internal RequestCache get_Cache()
internal RequestCacheValidator get_Validator()
internal RequestCachePolicy get_Policy()
}
internal System.Net.Cache.RequestCacheEntry : object {
private bool m_IsPrivateEntry
private long m_StreamSize
private DateTime m_ExpiresUtc
private int m_HitCount
private DateTime m_LastAccessedUtc
private DateTime m_LastModifiedUtc
private DateTime m_LastSynchronizedUtc
private TimeSpan m_MaxStale
private int m_UsageCount
private bool m_IsPartialEntry
private StringCollection m_EntryMetadata
private StringCollection m_SystemMetadata
internal bool IsPrivateEntry
internal long StreamSize
internal DateTime ExpiresUtc
internal DateTime LastAccessedUtc
internal DateTime LastModifiedUtc
internal DateTime LastSynchronizedUtc
internal TimeSpan MaxStale
internal int HitCount
internal int UsageCount
internal bool IsPartialEntry
internal StringCollection EntryMetadata
internal StringCollection SystemMetadata
internal bool get_IsPrivateEntry()
internal void set_IsPrivateEntry(bool value)
internal long get_StreamSize()
internal void set_StreamSize(long value)
internal DateTime get_ExpiresUtc()
internal void set_ExpiresUtc(DateTime value)
internal DateTime get_LastAccessedUtc()
internal void set_LastAccessedUtc(DateTime value)
internal DateTime get_LastModifiedUtc()
internal void set_LastModifiedUtc(DateTime value)
internal DateTime get_LastSynchronizedUtc()
internal void set_LastSynchronizedUtc(DateTime value)
internal TimeSpan get_MaxStale()
internal void set_MaxStale(TimeSpan value)
internal int get_HitCount()
internal void set_HitCount(int value)
internal int get_UsageCount()
internal void set_UsageCount(int value)
internal bool get_IsPartialEntry()
internal void set_IsPartialEntry(bool value)
internal StringCollection get_EntryMetadata()
internal void set_EntryMetadata(StringCollection value)
internal StringCollection get_SystemMetadata()
internal void set_SystemMetadata(StringCollection value)
internal string ToString(bool verbose)
}
public System.Net.Cache.RequestCacheLevel : Enum {
public int value__
public RequestCacheLevel Default
public RequestCacheLevel BypassCache
public RequestCacheLevel CacheOnly
public RequestCacheLevel CacheIfAvailable
public RequestCacheLevel Revalidate
public RequestCacheLevel Reload
public RequestCacheLevel NoCacheNoStore
}
internal System.Net.Cache.RequestCacheManager : object {
private RequestCachingSectionInternal modreq(System.Runtime.CompilerServices.IsVolatile) s_CacheConfigSettings
private RequestCacheBinding s_BypassCacheBinding
private RequestCacheBinding modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultGlobalBinding
private RequestCacheBinding modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultHttpBinding
private RequestCacheBinding modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultFtpBinding
internal bool IsCachingEnabled
internal RequestCacheBinding GetBinding(string internedScheme)
internal bool get_IsCachingEnabled()
internal void SetBinding(string uriScheme, RequestCacheBinding binding)
private void LoadConfigSettings()
}
public System.Net.Cache.RequestCachePolicy : object {
private RequestCacheLevel m_Level
public RequestCacheLevel Level
public void .ctor(RequestCacheLevel level)
public RequestCacheLevel get_Level()
public string ToString()
}
internal System.Net.Cache.RequestCacheProtocol : object {
public void .ctor(object arg1, object arg2)
}
internal System.Net.Cache.RequestCacheValidator : object {
public object CreateValidator()
}
internal System.Net.Cache.RequestCachingSectionInternal : object {
public bool DisableAllCaching
}
internal System.Net.CachedTransportContext : TransportContext {
private ChannelBinding binding
internal void .ctor(ChannelBinding binding)
public ChannelBinding GetChannelBinding(ChannelBindingKind kind)
}
internal System.Net.CaseInsensitiveAscii : object {
internal CaseInsensitiveAscii StaticInstance
internal Byte[] AsciiToLower
public int GetHashCode(object myObject)
public int Compare(object firstObject, object secondObject)
private int FastGetHashCode(string myString)
public bool Equals(object firstObject, object secondObject)
}
internal System.Net.CertificateEncoding : Enum {
public int value__
public CertificateEncoding Zero
public CertificateEncoding X509AsnEncoding
public CertificateEncoding X509NdrEncoding
public CertificateEncoding Pkcs7AsnEncoding
public CertificateEncoding Pkcs7NdrEncoding
public CertificateEncoding AnyAsnEncoding
}
internal System.Net.CertificateProblem : Enum {
public int value__
public CertificateProblem OK
public CertificateProblem TrustNOSIGNATURE
public CertificateProblem CertEXPIRED
public CertificateProblem CertVALIDITYPERIODNESTING
public CertificateProblem CertROLE
public CertificateProblem CertPATHLENCONST
public CertificateProblem CertCRITICAL
public CertificateProblem CertPURPOSE
public CertificateProblem CertISSUERCHAINING
public CertificateProblem CertMALFORMED
public CertificateProblem CertUNTRUSTEDROOT
public CertificateProblem CertCHAINING
public CertificateProblem CertREVOKED
public CertificateProblem CertUNTRUSTEDTESTROOT
public CertificateProblem CertREVOCATION_FAILURE
public CertificateProblem CertCN_NO_MATCH
public CertificateProblem CertWRONG_USAGE
public CertificateProblem TrustEXPLICITDISTRUST
public CertificateProblem CertUNTRUSTEDCA
public CertificateProblem CertINVALIDPOLICY
public CertificateProblem CertINVALIDNAME
public CertificateProblem CryptNOREVOCATIONCHECK
public CertificateProblem CryptREVOCATIONOFFLINE
public CertificateProblem TrustSYSTEMERROR
public CertificateProblem TrustNOSIGNERCERT
public CertificateProblem TrustCOUNTERSIGNER
public CertificateProblem TrustCERTSIGNATURE
public CertificateProblem TrustTIMESTAMP
public CertificateProblem TrustBADDIGEST
public CertificateProblem TrustBASICCONSTRAINTS
public CertificateProblem TrustFINANCIALCRITERIA
}
internal System.Net.CertUsage : Enum {
public int value__
public CertUsage MatchTypeAnd
public CertUsage MatchTypeOr
}
internal System.Net.ChainPolicyType : Enum {
public int value__
public ChainPolicyType Base
public ChainPolicyType Authenticode
public ChainPolicyType Authenticode_TS
public ChainPolicyType SSL
public ChainPolicyType BasicConstraints
public ChainPolicyType NtAuth
}
internal System.Net.ChunkedInputStream : RequestStream {
private bool disposed
private MonoChunkStream decoder
private HttpListenerContext context
private bool no_more_data
public MonoChunkStream Decoder
public void .ctor(HttpListenerContext context, Stream stream, Byte[] buffer, int offset, int length)
public MonoChunkStream get_Decoder()
public void set_Decoder(MonoChunkStream value)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
private void OnRead(IAsyncResult base_ares)
public int EndRead(IAsyncResult ares)
public void Close()
}
internal System.Net.ClosableStream : DelegatedStream {
private EventHandler onClose
private int closed
internal void .ctor(Stream stream, EventHandler onClose)
public void Close()
}
internal System.Net.CloseExState : Enum {
public int value__
public CloseExState Normal
public CloseExState Abort
public CloseExState Silent
}
internal System.Net.Comparer : object {
private int System.Collections.IComparer.Compare(object ol, object or)
}
internal System.Net.CompletionDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(Byte[] responseBytes, Exception exception, object State)
public IAsyncResult BeginInvoke(Byte[] responseBytes, Exception exception, object State, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.Configuration.AuthenticationModuleElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty typeProp
protected ConfigurationPropertyCollection Properties
public string Type
public void .ctor(string typeName)
protected ConfigurationPropertyCollection get_Properties()
public string get_Type()
public void set_Type(string value)
}
public System.Net.Configuration.AuthenticationModuleElementCollection : ConfigurationElementCollection {
public AuthenticationModuleElement Item
public AuthenticationModuleElement Item
public AuthenticationModuleElement get_Item(int index)
public void set_Item(int index, AuthenticationModuleElement value)
public AuthenticationModuleElement get_Item(string name)
public void set_Item(string name, AuthenticationModuleElement value)
public void Add(AuthenticationModuleElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(AuthenticationModuleElement element)
public void Remove(AuthenticationModuleElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
public System.Net.Configuration.AuthenticationModulesSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty authenticationModulesProp
protected ConfigurationPropertyCollection Properties
public AuthenticationModuleElementCollection AuthenticationModules
protected ConfigurationPropertyCollection get_Properties()
public AuthenticationModuleElementCollection get_AuthenticationModules()
protected void PostDeserialize()
protected void InitializeDefault()
}
public System.Net.Configuration.BypassElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty addressProp
public string Address
protected ConfigurationPropertyCollection Properties
public void .ctor(string address)
public string get_Address()
public void set_Address(string value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.BypassElementCollection : ConfigurationElementCollection {
public BypassElement Item
public BypassElement Item
protected bool ThrowOnDuplicate
public BypassElement get_Item(int index)
public void set_Item(int index, BypassElement value)
public BypassElement get_Item(string name)
public void set_Item(string name, BypassElement value)
protected bool get_ThrowOnDuplicate()
public void Add(BypassElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(BypassElement element)
public void Remove(BypassElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
internal System.Net.Configuration.ConnectionManagementData : object {
private Hashtable data
private int defaultMaxConnections
public Hashtable Data
public void .ctor(object parent)
public void Add(string address, string nconns)
public void Add(string address, int nconns)
public void Remove(string address)
public void Clear()
public UInt32 GetMaxConnections(string hostOrIP)
public Hashtable get_Data()
}
public System.Net.Configuration.ConnectionManagementElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty addressProp
private ConfigurationProperty maxConnectionProp
public string Address
public int MaxConnection
protected ConfigurationPropertyCollection Properties
public void .ctor(string address, int maxConnection)
public string get_Address()
public void set_Address(string value)
public int get_MaxConnection()
public void set_MaxConnection(int value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.ConnectionManagementElementCollection : ConfigurationElementCollection {
public ConnectionManagementElement Item
public ConnectionManagementElement Item
public ConnectionManagementElement get_Item(int index)
public void set_Item(int index, ConnectionManagementElement value)
public ConnectionManagementElement get_Item(string name)
public void set_Item(string name, ConnectionManagementElement value)
public void Add(ConnectionManagementElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(ConnectionManagementElement element)
public void Remove(ConnectionManagementElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
internal System.Net.Configuration.ConnectionManagementHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Net.Configuration.ConnectionManagementSection : ConfigurationSection {
private ConfigurationProperty connectionManagementProp
private ConfigurationPropertyCollection properties
public ConnectionManagementElementCollection ConnectionManagement
protected ConfigurationPropertyCollection Properties
public ConnectionManagementElementCollection get_ConnectionManagement()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Net.Configuration.DefaultProxyHandler : object {
public object Create(object parent, object configContext, XmlNode section)
private void FillByPassList(XmlNode node, WebProxy proxy)
}
public System.Net.Configuration.DefaultProxySection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty bypassListProp
private ConfigurationProperty enabledProp
private ConfigurationProperty moduleProp
private ConfigurationProperty proxyProp
private ConfigurationProperty useDefaultCredentialsProp
public BypassElementCollection BypassList
public bool Enabled
public ModuleElement Module
public ProxyElement Proxy
public bool UseDefaultCredentials
protected ConfigurationPropertyCollection Properties
public BypassElementCollection get_BypassList()
public bool get_Enabled()
public void set_Enabled(bool value)
public ModuleElement get_Module()
public ProxyElement get_Proxy()
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
protected void Reset(ConfigurationElement parentElement)
}
internal System.Net.Configuration.DefaultProxySectionInternal : object {
private IWebProxy webProxy
private object classSyncObject
internal object ClassSyncObject
internal IWebProxy WebProxy
private IWebProxy GetDefaultProxy_UsingOldMonoCode()
private IWebProxy GetSystemWebProxy()
internal object get_ClassSyncObject()
internal DefaultProxySectionInternal GetSection()
internal IWebProxy get_WebProxy()
}
public System.Net.Configuration.FtpCachePolicyElement : ConfigurationElement {
private ConfigurationProperty policyLevelProp
private ConfigurationPropertyCollection properties
public RequestCacheLevel PolicyLevel
protected ConfigurationPropertyCollection Properties
public RequestCacheLevel get_PolicyLevel()
public void set_PolicyLevel(RequestCacheLevel value)
protected ConfigurationPropertyCollection get_Properties()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
protected void Reset(ConfigurationElement parentElement)
}
internal System.Net.Configuration.HandlersUtil : object {
internal string ExtractAttributeValue(string attKey, XmlNode node)
internal string ExtractAttributeValue(string attKey, XmlNode node, bool optional)
internal void ThrowException(string msg, XmlNode node)
}
public System.Net.Configuration.HttpCachePolicyElement : ConfigurationElement {
private ConfigurationProperty maximumAgeProp
private ConfigurationProperty maximumStaleProp
private ConfigurationProperty minimumFreshProp
private ConfigurationProperty policyLevelProp
private ConfigurationPropertyCollection properties
public TimeSpan MaximumAge
public TimeSpan MaximumStale
public TimeSpan MinimumFresh
public HttpRequestCacheLevel PolicyLevel
protected ConfigurationPropertyCollection Properties
public TimeSpan get_MaximumAge()
public void set_MaximumAge(TimeSpan value)
public TimeSpan get_MaximumStale()
public void set_MaximumStale(TimeSpan value)
public TimeSpan get_MinimumFresh()
public void set_MinimumFresh(TimeSpan value)
public HttpRequestCacheLevel get_PolicyLevel()
public void set_PolicyLevel(HttpRequestCacheLevel value)
protected ConfigurationPropertyCollection get_Properties()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
protected void Reset(ConfigurationElement parentElement)
}
public System.Net.Configuration.HttpWebRequestElement : ConfigurationElement {
private ConfigurationProperty maximumErrorResponseLengthProp
private ConfigurationProperty maximumResponseHeadersLengthProp
private ConfigurationProperty maximumUnauthorizedUploadLengthProp
private ConfigurationProperty useUnsafeHeaderParsingProp
private ConfigurationPropertyCollection properties
public int MaximumErrorResponseLength
public int MaximumResponseHeadersLength
public int MaximumUnauthorizedUploadLength
public bool UseUnsafeHeaderParsing
protected ConfigurationPropertyCollection Properties
public int get_MaximumErrorResponseLength()
public void set_MaximumErrorResponseLength(int value)
public int get_MaximumResponseHeadersLength()
public void set_MaximumResponseHeadersLength(int value)
public int get_MaximumUnauthorizedUploadLength()
public void set_MaximumUnauthorizedUploadLength(int value)
public bool get_UseUnsafeHeaderParsing()
public void set_UseUnsafeHeaderParsing(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
}
public System.Net.Configuration.Ipv6Element : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty enabledProp
public bool Enabled
protected ConfigurationPropertyCollection Properties
public bool get_Enabled()
public void set_Enabled(bool value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.MailSettingsSectionGroup : ConfigurationSectionGroup {
public SmtpSection Smtp
public SmtpSection get_Smtp()
}
public System.Net.Configuration.ModuleElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty typeProp
protected ConfigurationPropertyCollection Properties
public string Type
protected ConfigurationPropertyCollection get_Properties()
public string get_Type()
public void set_Type(string value)
}
internal System.Net.Configuration.NetAuthenticationModuleHandler : object {
public object Create(object parent, object configContext, XmlNode section)
private IAuthenticationModule CreateInstance(string typeName, XmlNode node)
}
internal System.Net.Configuration.NetConfigurationHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Net.Configuration.NetSectionGroup : ConfigurationSectionGroup {
public AuthenticationModulesSection AuthenticationModules
public ConnectionManagementSection ConnectionManagement
public DefaultProxySection DefaultProxy
public MailSettingsSectionGroup MailSettings
public RequestCachingSection RequestCaching
public SettingsSection Settings
public WebRequestModulesSection WebRequestModules
public AuthenticationModulesSection get_AuthenticationModules()
public ConnectionManagementSection get_ConnectionManagement()
public DefaultProxySection get_DefaultProxy()
public MailSettingsSectionGroup get_MailSettings()
public RequestCachingSection get_RequestCaching()
public SettingsSection get_Settings()
public WebRequestModulesSection get_WebRequestModules()
public NetSectionGroup GetSectionGroup(Configuration config)
}
public System.Net.Configuration.PerformanceCountersElement : ConfigurationElement {
private ConfigurationProperty enabledProp
private ConfigurationPropertyCollection properties
public bool Enabled
protected ConfigurationPropertyCollection Properties
public bool get_Enabled()
public void set_Enabled(bool value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.ProxyElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty autoDetectProp
private ConfigurationProperty bypassOnLocalProp
private ConfigurationProperty proxyAddressProp
private ConfigurationProperty scriptLocationProp
private ConfigurationProperty useSystemDefaultProp
public AutoDetectValues AutoDetect
public BypassOnLocalValues BypassOnLocal
public Uri ProxyAddress
public Uri ScriptLocation
public UseSystemDefaultValues UseSystemDefault
protected ConfigurationPropertyCollection Properties
public AutoDetectValues get_AutoDetect()
public void set_AutoDetect(AutoDetectValues value)
public BypassOnLocalValues get_BypassOnLocal()
public void set_BypassOnLocal(BypassOnLocalValues value)
public Uri get_ProxyAddress()
public void set_ProxyAddress(Uri value)
public Uri get_ScriptLocation()
public void set_ScriptLocation(Uri value)
public UseSystemDefaultValues get_UseSystemDefault()
public void set_UseSystemDefault(UseSystemDefaultValues value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.RequestCachingSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty defaultFtpCachePolicyProp
private ConfigurationProperty defaultHttpCachePolicyProp
private ConfigurationProperty defaultPolicyLevelProp
private ConfigurationProperty disableAllCachingProp
private ConfigurationProperty isPrivateCacheProp
private ConfigurationProperty unspecifiedMaximumAgeProp
public FtpCachePolicyElement DefaultFtpCachePolicy
public HttpCachePolicyElement DefaultHttpCachePolicy
public RequestCacheLevel DefaultPolicyLevel
public bool DisableAllCaching
public bool IsPrivateCache
public TimeSpan UnspecifiedMaximumAge
protected ConfigurationPropertyCollection Properties
public FtpCachePolicyElement get_DefaultFtpCachePolicy()
public HttpCachePolicyElement get_DefaultHttpCachePolicy()
public RequestCacheLevel get_DefaultPolicyLevel()
public void set_DefaultPolicyLevel(RequestCacheLevel value)
public bool get_DisableAllCaching()
public void set_DisableAllCaching(bool value)
public bool get_IsPrivateCache()
public void set_IsPrivateCache(bool value)
public TimeSpan get_UnspecifiedMaximumAge()
public void set_UnspecifiedMaximumAge(TimeSpan value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
}
public System.Net.Configuration.ServicePointManagerElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty checkCertificateNameProp
private ConfigurationProperty checkCertificateRevocationListProp
private ConfigurationProperty dnsRefreshTimeoutProp
private ConfigurationProperty enableDnsRoundRobinProp
private ConfigurationProperty expect100ContinueProp
private ConfigurationProperty useNagleAlgorithmProp
public bool CheckCertificateName
public bool CheckCertificateRevocationList
public int DnsRefreshTimeout
public bool EnableDnsRoundRobin
public bool Expect100Continue
public bool UseNagleAlgorithm
protected ConfigurationPropertyCollection Properties
public bool get_CheckCertificateName()
public void set_CheckCertificateName(bool value)
public bool get_CheckCertificateRevocationList()
public void set_CheckCertificateRevocationList(bool value)
public int get_DnsRefreshTimeout()
public void set_DnsRefreshTimeout(int value)
public bool get_EnableDnsRoundRobin()
public void set_EnableDnsRoundRobin(bool value)
public bool get_Expect100Continue()
public void set_Expect100Continue(bool value)
public bool get_UseNagleAlgorithm()
public void set_UseNagleAlgorithm(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
}
public System.Net.Configuration.SettingsSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty httpWebRequestProp
private ConfigurationProperty ipv6Prop
private ConfigurationProperty performanceCountersProp
private ConfigurationProperty servicePointManagerProp
private ConfigurationProperty webProxyScriptProp
private ConfigurationProperty socketProp
public HttpWebRequestElement HttpWebRequest
public Ipv6Element Ipv6
public PerformanceCountersElement PerformanceCounters
public ServicePointManagerElement ServicePointManager
public SocketElement Socket
public WebProxyScriptElement WebProxyScript
protected ConfigurationPropertyCollection Properties
public HttpWebRequestElement get_HttpWebRequest()
public Ipv6Element get_Ipv6()
public PerformanceCountersElement get_PerformanceCounters()
public ServicePointManagerElement get_ServicePointManager()
public SocketElement get_Socket()
public WebProxyScriptElement get_WebProxyScript()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Net.Configuration.SettingsSectionInternal : object {
private SettingsSectionInternal instance
internal UnicodeEncodingConformance WebUtilityUnicodeEncodingConformance
internal UnicodeDecodingConformance WebUtilityUnicodeDecodingConformance
internal bool HttpListenerUnescapeRequestUrl
internal IPProtectionLevel IPProtectionLevel
private bool <UseNagleAlgorithm>k__BackingField
private bool <Expect100Continue>k__BackingField
private bool <CheckCertificateName>k__BackingField
private int <DnsRefreshTimeout>k__BackingField
private bool <EnableDnsRoundRobin>k__BackingField
private bool <CheckCertificateRevocationList>k__BackingField
private EncryptionPolicy <EncryptionPolicy>k__BackingField
internal SettingsSectionInternal Section
internal bool UseNagleAlgorithm
internal bool Expect100Continue
internal bool CheckCertificateName
internal int DnsRefreshTimeout
internal bool EnableDnsRoundRobin
internal bool CheckCertificateRevocationList
internal EncryptionPolicy EncryptionPolicy
internal bool Ipv6Enabled
internal SettingsSectionInternal get_Section()
internal bool get_UseNagleAlgorithm()
internal void set_UseNagleAlgorithm(bool value)
internal bool get_Expect100Continue()
internal void set_Expect100Continue(bool value)
internal bool get_CheckCertificateName()
private void set_CheckCertificateName(bool value)
internal int get_DnsRefreshTimeout()
internal void set_DnsRefreshTimeout(int value)
internal bool get_EnableDnsRoundRobin()
internal void set_EnableDnsRoundRobin(bool value)
internal bool get_CheckCertificateRevocationList()
internal void set_CheckCertificateRevocationList(bool value)
internal EncryptionPolicy get_EncryptionPolicy()
private void set_EncryptionPolicy(EncryptionPolicy value)
internal bool get_Ipv6Enabled()
}
public System.Net.Configuration.SmtpNetworkElement : ConfigurationElement {
public bool DefaultCredentials
public string Host
public string Password
public int Port
public string UserName
public string TargetName
public bool EnableSsl
protected ConfigurationPropertyCollection Properties
public bool get_DefaultCredentials()
public void set_DefaultCredentials(bool value)
public string get_Host()
public void set_Host(string value)
public string get_Password()
public void set_Password(string value)
public int get_Port()
public void set_Port(int value)
public string get_UserName()
public void set_UserName(string value)
public string get_TargetName()
public void set_TargetName(string value)
public bool get_EnableSsl()
public void set_EnableSsl(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
}
public System.Net.Configuration.SmtpSection : ConfigurationSection {
public SmtpDeliveryMethod DeliveryMethod
public SmtpDeliveryFormat DeliveryFormat
public string From
public SmtpNetworkElement Network
public SmtpSpecifiedPickupDirectoryElement SpecifiedPickupDirectory
protected ConfigurationPropertyCollection Properties
public SmtpDeliveryMethod get_DeliveryMethod()
public void set_DeliveryMethod(SmtpDeliveryMethod value)
public SmtpDeliveryFormat get_DeliveryFormat()
public void set_DeliveryFormat(SmtpDeliveryFormat value)
public string get_From()
public void set_From(string value)
public SmtpNetworkElement get_Network()
public SmtpSpecifiedPickupDirectoryElement get_SpecifiedPickupDirectory()
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.SmtpSpecifiedPickupDirectoryElement : ConfigurationElement {
private ConfigurationProperty pickupDirectoryLocationProp
private ConfigurationPropertyCollection properties
public string PickupDirectoryLocation
protected ConfigurationPropertyCollection Properties
public string get_PickupDirectoryLocation()
public void set_PickupDirectoryLocation(string value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.SocketElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty alwaysUseCompletionPortsForAcceptProp
private ConfigurationProperty alwaysUseCompletionPortsForConnectProp
public bool AlwaysUseCompletionPortsForAccept
public bool AlwaysUseCompletionPortsForConnect
protected ConfigurationPropertyCollection Properties
public bool get_AlwaysUseCompletionPortsForAccept()
public void set_AlwaysUseCompletionPortsForAccept(bool value)
public bool get_AlwaysUseCompletionPortsForConnect()
public void set_AlwaysUseCompletionPortsForConnect(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
}
public System.Net.Configuration.UnicodeDecodingConformance : Enum {
public int value__
public UnicodeDecodingConformance Auto
public UnicodeDecodingConformance Strict
public UnicodeDecodingConformance Compat
public UnicodeDecodingConformance Loose
}
public System.Net.Configuration.UnicodeEncodingConformance : Enum {
public int value__
public UnicodeEncodingConformance Auto
public UnicodeEncodingConformance Strict
public UnicodeEncodingConformance Compat
}
public System.Net.Configuration.WebProxyScriptElement : ConfigurationElement {
private ConfigurationProperty downloadTimeoutProp
private ConfigurationPropertyCollection properties
public TimeSpan DownloadTimeout
protected ConfigurationPropertyCollection Properties
protected void PostDeserialize()
public TimeSpan get_DownloadTimeout()
public void set_DownloadTimeout(TimeSpan value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.WebRequestModuleElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty prefixProp
private ConfigurationProperty typeProp
public string Prefix
public Type Type
protected ConfigurationPropertyCollection Properties
public void .ctor(string prefix, string type)
public void .ctor(string prefix, Type type)
public string get_Prefix()
public void set_Prefix(string value)
public Type get_Type()
public void set_Type(Type value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.WebRequestModuleElementCollection : ConfigurationElementCollection {
public WebRequestModuleElement Item
public WebRequestModuleElement Item
public WebRequestModuleElement get_Item(int index)
public void set_Item(int index, WebRequestModuleElement value)
public WebRequestModuleElement get_Item(string name)
public void set_Item(string name, WebRequestModuleElement value)
public void Add(WebRequestModuleElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(WebRequestModuleElement element)
public void Remove(WebRequestModuleElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
internal System.Net.Configuration.WebRequestModuleHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Net.Configuration.WebRequestModulesSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty webRequestModulesProp
protected ConfigurationPropertyCollection Properties
public WebRequestModuleElementCollection WebRequestModules
protected ConfigurationPropertyCollection get_Properties()
public WebRequestModuleElementCollection get_WebRequestModules()
protected void PostDeserialize()
protected void InitializeDefault()
}
internal System.Net.ConnectionPool : object {
private Callback s_CleanupCallback
private Callback s_CancelErrorCallback
private Queue s_CancelErrorQueue
private int MaxQueueSize
private int SemaphoreHandleIndex
private int ErrorHandleIndex
private int CreationHandleIndex
private int WaitTimeout
private int WaitAbandoned
private int ErrorWait
private Queue m_CleanupQueue
private State m_State
private InterlockedStack m_StackOld
private InterlockedStack m_StackNew
private int m_WaitCount
private WaitHandle[] m_WaitHandles
private Exception m_ResError
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_ErrorOccured
private Timer m_ErrorTimer
private ArrayList m_ObjectList
private int m_TotalObjects
private Queue m_QueuedRequests
private Thread m_AsyncThread
private int m_MaxPoolSize
private int m_MinPoolSize
private ServicePoint m_ServicePoint
private CreateConnectionDelegate m_CreateConnectionCallback
private Mutex CreationMutex
private ManualResetEvent ErrorEvent
private Semaphore Semaphore
internal int Count
internal ServicePoint ServicePoint
internal int MaxPoolSize
internal int MinPoolSize
private bool ErrorOccurred
private Mutex get_CreationMutex()
private ManualResetEvent get_ErrorEvent()
private Semaphore get_Semaphore()
internal void .ctor(ServicePoint servicePoint, int maxPoolSize, int minPoolSize, int idleTimeout, CreateConnectionDelegate createConnectionCallback)
private void Initialize()
private void QueueRequest(AsyncConnectionPoolRequest asyncRequest)
private void AsyncThread()
internal int get_Count()
internal ServicePoint get_ServicePoint()
internal int get_MaxPoolSize()
internal int get_MinPoolSize()
private bool get_ErrorOccurred()
private void CleanupCallbackWrapper(Timer timer, int timeNoticed, object context)
internal void ForceCleanup()
private void CleanupCallback()
private PooledStream Create(CreateConnectionDelegate createConnectionCallback)
private void Destroy(PooledStream pooledStream)
private void CancelErrorCallbackWrapper(Timer timer, int timeNoticed, object context)
private void CancelErrorCallback()
private PooledStream GetFromPool(object owningObject)
private PooledStream Get(object owningObject, int result, Boolean& continueLoop, WaitHandle[]& waitHandles)
internal void Abort()
internal PooledStream GetConnection(object owningObject, GeneralAsyncDelegate asyncCallback, int creationTimeout)
internal void PutConnection(PooledStream pooledStream, object owningObject, int creationTimeout)
internal void PutConnection(PooledStream pooledStream, object owningObject, int creationTimeout, bool canReuse)
private void PutNew(PooledStream pooledStream)
private bool ReclaimEmancipatedObjects()
private PooledStream UserCreateRequest()
}
internal System.Net.ContentTypeValues : Enum {
public int value__
public ContentTypeValues ChangeCipherSpec
public ContentTypeValues Alert
public ContentTypeValues HandShake
public ContentTypeValues AppData
public ContentTypeValues Unrecognized
}
internal System.Net.ContextAttribute : Enum {
public int value__
public ContextAttribute Sizes
public ContextAttribute Names
public ContextAttribute Lifespan
public ContextAttribute DceInfo
public ContextAttribute StreamSizes
public ContextAttribute Authority
public ContextAttribute PackageInfo
public ContextAttribute NegotiationInfo
public ContextAttribute UniqueBindings
public ContextAttribute EndpointBindings
public ContextAttribute ClientSpecifiedSpn
public ContextAttribute RemoteCertificate
public ContextAttribute LocalCertificate
public ContextAttribute RootStore
public ContextAttribute IssuerListInfoEx
public ContextAttribute ConnectionInfo
public ContextAttribute UiInfo
}
public System.Net.Cookie : object {
internal int MaxSupportedVersion
internal string CommentAttributeName
internal string CommentUrlAttributeName
internal string DiscardAttributeName
internal string DomainAttributeName
internal string ExpiresAttributeName
internal string MaxAgeAttributeName
internal string PathAttributeName
internal string PortAttributeName
internal string SecureAttributeName
internal string VersionAttributeName
internal string HttpOnlyAttributeName
internal string SeparatorLiteral
internal string EqualsLiteral
internal string QuotesLiteral
internal string SpecialAttributeLiteral
internal Char[] PortSplitDelimiters
internal Char[] Reserved2Name
internal Char[] Reserved2Value
private Comparer staticComparer
private string m_comment
private Uri m_commentUri
private CookieVariant m_cookieVariant
private bool m_discard
private string m_domain
private bool m_domain_implicit
private DateTime m_expires
private string m_name
private string m_path
private bool m_path_implicit
private string m_port
private bool m_port_implicit
private Int32[] m_port_list
private bool m_secure
private bool m_httpOnly
private DateTime m_timeStamp
private string m_value
private int m_version
private string m_domainKey
internal bool IsQuotedVersion
internal bool IsQuotedDomain
public string Comment
public Uri CommentUri
public bool HttpOnly
public bool Discard
public string Domain
private string _Domain
internal bool DomainImplicit
public bool Expired
public DateTime Expires
public string Name
public string Path
private string _Path
internal bool Plain
public string Port
internal Int32[] PortList
private string _Port
public bool Secure
public DateTime TimeStamp
public string Value
internal CookieVariant Variant
internal string DomainKey
public int Version
private string _Version
public void .ctor(string name, string value)
public void .ctor(string name, string value, string path)
public void .ctor(string name, string value, string path, string domain)
public string get_Comment()
public void set_Comment(string value)
public Uri get_CommentUri()
public void set_CommentUri(Uri value)
public bool get_HttpOnly()
public void set_HttpOnly(bool value)
public bool get_Discard()
public void set_Discard(bool value)
public string get_Domain()
public void set_Domain(string value)
private string get__Domain()
internal bool get_DomainImplicit()
internal void set_DomainImplicit(bool value)
public bool get_Expired()
public void set_Expired(bool value)
public DateTime get_Expires()
public void set_Expires(DateTime value)
public string get_Name()
public void set_Name(string value)
internal bool InternalSetName(string value)
public string get_Path()
public void set_Path(string value)
private string get__Path()
internal bool get_Plain()
internal Cookie Clone()
private bool IsDomainEqualToHost(string domain, string host)
internal bool VerifySetDefaults(CookieVariant variant, Uri uri, bool isLocalDomain, string localDomain, bool set_default, bool isThrow)
private bool DomainCharsTest(string name)
public string get_Port()
public void set_Port(string value)
internal Int32[] get_PortList()
private string get__Port()
public bool get_Secure()
public void set_Secure(bool value)
public DateTime get_TimeStamp()
public string get_Value()
public void set_Value(string value)
internal CookieVariant get_Variant()
internal void set_Variant(CookieVariant value)
internal string get_DomainKey()
public int get_Version()
public void set_Version(int value)
private string get__Version()
internal IComparer GetComparer()
public bool Equals(object comparand)
public int GetHashCode()
public string ToString()
internal string ToServerString()
}
public System.Net.CookieCollection : object {
internal int m_version
private ArrayList m_list
private DateTime m_TimeStamp
private bool m_has_other_versions
private bool m_IsReadOnly
public bool IsReadOnly
public Cookie Item
public Cookie Item
public int Count
public bool IsSynchronized
public object SyncRoot
internal bool IsOtherVersionSeen
internal void .ctor(bool IsReadOnly)
public bool get_IsReadOnly()
public Cookie get_Item(int index)
public Cookie get_Item(string name)
public void Add(Cookie cookie)
public void Add(CookieCollection cookies)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public void CopyTo(Cookie[] array, int index)
internal DateTime TimeStamp(Stamp how)
internal bool get_IsOtherVersionSeen()
internal int InternalAdd(Cookie cookie, bool isStrict)
internal int IndexOf(Cookie cookie)
internal void RemoveAt(int idx)
public IEnumerator GetEnumerator()
}
public System.Net.CookieContainer : object {
public int DefaultCookieLimit
public int DefaultPerDomainCookieLimit
public int DefaultCookieLengthLimit
private HeaderVariantInfo[] HeaderInfo
private Hashtable m_domainTable
private int m_maxCookieSize
private int m_maxCookies
private int m_maxCookiesPerDomain
private int m_count
private string m_fqdnMyDomain
public int Capacity
public int Count
public int MaxCookieSize
public int PerDomainCapacity
public void .ctor(int capacity)
public void .ctor(int capacity, int perDomainCapacity, int maxCookieSize)
public int get_Capacity()
public void set_Capacity(int value)
public int get_Count()
public int get_MaxCookieSize()
public void set_MaxCookieSize(int value)
public int get_PerDomainCapacity()
public void set_PerDomainCapacity(int value)
public void Add(Cookie cookie)
private void AddRemoveDomain(string key, PathList value)
internal void Add(Cookie cookie, bool throwOnError)
private bool AgeCookies(string domain)
private int ExpireCollection(CookieCollection cc)
public void Add(CookieCollection cookies)
internal bool IsLocalDomain(string host)
public void Add(Uri uri, Cookie cookie)
public void Add(Uri uri, CookieCollection cookies)
internal CookieCollection CookieCutter(Uri uri, string headerName, string setCookieHeader, bool isThrow)
public CookieCollection GetCookies(Uri uri)
internal CookieCollection InternalGetCookies(Uri uri)
private void BuildCookieCollectionFromDomainMatches(Uri uri, bool isSecure, int port, CookieCollection cookies, List`1<string> domainAttribute, bool matchOnlyPlainCookie)
private void MergeUpdateCollections(CookieCollection destination, CookieCollection source, int port, bool isSecure, bool isPlainOnly)
public string GetCookieHeader(Uri uri)
internal string GetCookieHeader(Uri uri, String& optCookie2)
public void SetCookies(Uri uri, string cookieHeader)
}
public System.Net.CookieException : FormatException {
internal void .ctor(string message)
internal void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.Net.CookieParser : object {
private CookieTokenizer m_tokenizer
private Cookie m_savedCookie
internal void .ctor(string cookieString)
internal Cookie Get()
internal Cookie GetServer()
internal string CheckQuoted(string value)
}
internal System.Net.CookieToken : Enum {
public int value__
public CookieToken Nothing
public CookieToken NameValuePair
public CookieToken Attribute
public CookieToken EndToken
public CookieToken EndCookie
public CookieToken End
public CookieToken Equals
public CookieToken Comment
public CookieToken CommentUrl
public CookieToken CookieName
public CookieToken Discard
public CookieToken Domain
public CookieToken Expires
public CookieToken MaxAge
public CookieToken Path
public CookieToken Port
public CookieToken Secure
public CookieToken HttpOnly
public CookieToken Unknown
public CookieToken Version
}
internal System.Net.CookieTokenizer : object {
private bool m_eofCookie
private int m_index
private int m_length
private string m_name
private bool m_quoted
private int m_start
private CookieToken m_token
private int m_tokenLength
private string m_tokenStream
private string m_value
private RecognizedAttribute[] RecognizedAttributes
private RecognizedAttribute[] RecognizedServerAttributes
internal bool EndOfCookie
internal bool Eof
internal string Name
internal bool Quoted
internal CookieToken Token
internal string Value
internal void .ctor(string tokenStream)
internal bool get_EndOfCookie()
internal void set_EndOfCookie(bool value)
internal bool get_Eof()
internal string get_Name()
internal void set_Name(string value)
internal bool get_Quoted()
internal void set_Quoted(bool value)
internal CookieToken get_Token()
internal void set_Token(CookieToken value)
internal string get_Value()
internal void set_Value(string value)
internal string Extract()
internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals)
internal CookieToken Next(bool first, bool parseResponseCookies)
internal void Reset()
internal CookieToken TokenFromName(bool parseResponseCookies)
}
internal System.Net.CookieVariant : Enum {
public int value__
public CookieVariant Unknown
public CookieVariant Plain
public CookieVariant Rfc2109
public CookieVariant Rfc2965
public CookieVariant Default
}
internal System.Net.CreateConnectionDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public PooledStream Invoke(ConnectionPool pool)
public IAsyncResult BeginInvoke(ConnectionPool pool, AsyncCallback callback, object object)
public PooledStream EndInvoke(IAsyncResult result)
}
public System.Net.CredentialCache : object {
private Hashtable cache
private Hashtable cacheForHosts
internal int m_version
private int m_NumbDefaultCredInCache
internal bool IsDefaultInCache
public ICredentials DefaultCredentials
public NetworkCredential DefaultNetworkCredentials
internal bool get_IsDefaultInCache()
public void Add(Uri uriPrefix, string authType, NetworkCredential cred)
public void Add(string host, int port, string authenticationType, NetworkCredential credential)
public void Remove(Uri uriPrefix, string authType)
public void Remove(string host, int port, string authenticationType)
public NetworkCredential GetCredential(Uri uriPrefix, string authType)
public NetworkCredential GetCredential(string host, int port, string authenticationType)
public IEnumerator GetEnumerator()
public ICredentials get_DefaultCredentials()
public NetworkCredential get_DefaultNetworkCredentials()
}
internal System.Net.CredentialHostKey : object {
internal string Host
internal string AuthenticationType
internal int Port
private int m_HashCode
private bool m_ComputedHashCode
internal void .ctor(string host, int port, string authenticationType)
internal bool Match(string host, int port, string authenticationType)
public int GetHashCode()
public bool Equals(object comparand)
public string ToString()
}
internal System.Net.CredentialKey : object {
internal Uri UriPrefix
internal int UriPrefixLength
internal string AuthenticationType
private int m_HashCode
private bool m_ComputedHashCode
internal void .ctor(Uri uriPrefix, string authenticationType)
internal bool Match(Uri uri, string authenticationType)
internal bool IsPrefix(Uri uri, Uri prefixUri)
public int GetHashCode()
public bool Equals(object comparand)
public string ToString()
}
internal System.Net.CredentialUse : Enum {
public int value__
public CredentialUse Inbound
public CredentialUse Outbound
public CredentialUse Both
}
internal System.Net.DataParseStatus : Enum {
public int value__
public DataParseStatus NeedMoreData
public DataParseStatus ContinueParsing
public DataParseStatus Done
public DataParseStatus Invalid
public DataParseStatus DataTooBig
}
public System.Net.DecompressionMethods : Enum {
public int value__
public DecompressionMethods None
public DecompressionMethods GZip
public DecompressionMethods Deflate
}
internal System.Net.DefaultCertificatePolicy : object {
public bool CheckValidationResult(ServicePoint point, X509Certificate certificate, WebRequest request, int certificateProblem)
}
internal System.Net.DefaultPorts : Enum {
public int value__
public DefaultPorts DEFAULT_FTP_PORT
public DefaultPorts DEFAULT_GOPHER_PORT
public DefaultPorts DEFAULT_HTTP_PORT
public DefaultPorts DEFAULT_HTTPS_PORT
public DefaultPorts DEFAULT_NNTP_PORT
public DefaultPorts DEFAULT_SMTP_PORT
public DefaultPorts DEFAULT_TELNET_PORT
}
internal System.Net.DelayedRegex : object {
private Regex _AsRegex
private string _AsString
internal Regex AsRegex
internal void .ctor(string regexString)
internal void .ctor(Regex regex)
internal Regex get_AsRegex()
public string ToString()
}
internal System.Net.DelegatedStream : Stream {
private Stream stream
private NetworkStream netStream
protected Stream BaseStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
protected void .ctor(Stream stream)
protected Stream get_BaseStream()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
}
internal System.Net.DigestClient : object {
private Hashtable cache
private Hashtable Cache
public string AuthenticationType
public bool CanPreAuthenticate
private Hashtable get_Cache()
private void CheckExpired(int count)
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
internal System.Net.DigestHeaderParser : object {
private string header
private int length
private int pos
private String[] keywords
private String[] values
public string Realm
public string Opaque
public string Nonce
public string Algorithm
public string QOP
public void .ctor(string header)
public string get_Realm()
public string get_Opaque()
public string get_Nonce()
public string get_Algorithm()
public string get_QOP()
public bool Parse()
private void SkipWhitespace()
private string GetKey()
private bool GetKeywordAndValue(String& key, String& value)
}
internal System.Net.DigestSession : object {
private RandomNumberGenerator rng
private DateTime lastUse
private int _nc
private HashAlgorithm hash
private DigestHeaderParser parser
private string _cnonce
public string Algorithm
public string Realm
public string Nonce
public string Opaque
public string QOP
public string CNonce
public DateTime LastUse
public string get_Algorithm()
public string get_Realm()
public string get_Nonce()
public string get_Opaque()
public string get_QOP()
public string get_CNonce()
public bool Parse(string challenge)
private string HashToHexString(string toBeHashed)
private string HA1(string username, string password)
private string HA2(HttpWebRequest webRequest)
private string Response(string username, string password, HttpWebRequest webRequest)
public Authorization Authenticate(WebRequest webRequest, ICredentials credentials)
public DateTime get_LastUse()
}
internal System.Net.DirectProxy : ProxyChain {
private bool m_ProxyRetrieved
internal void .ctor(Uri destination)
protected bool GetNextProxy(Uri& proxy)
}
public System.Net.Dns : object {
private bool use_mono_dns
private SimpleResolver resolver
internal bool UseMonoDns
internal bool get_UseMonoDns()
private void OnCompleted(object sender, SimpleResolverEventArgs e)
private IAsyncResult BeginAsyncCallAddresses(string host, AsyncCallback callback, object state)
private IAsyncResult BeginAsyncCall(string host, AsyncCallback callback, object state)
private IPHostEntry EndAsyncCall(DnsAsyncResult ares)
public IAsyncResult BeginGetHostByName(string hostName, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginResolve(string hostName, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginGetHostAddresses(string hostNameOrAddress, AsyncCallback requestCallback, object state)
public IAsyncResult BeginGetHostEntry(string hostNameOrAddress, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginGetHostEntry(IPAddress address, AsyncCallback requestCallback, object stateObject)
public IPHostEntry EndGetHostByName(IAsyncResult asyncResult)
public IPHostEntry EndResolve(IAsyncResult asyncResult)
public IPAddress[] EndGetHostAddresses(IAsyncResult asyncResult)
public IPHostEntry EndGetHostEntry(IAsyncResult asyncResult)
private bool GetHostByName_internal(string host, String& h_name, String[]& h_aliases, String[]& h_addr_list, int hint)
private bool GetHostByAddr_internal(string addr, String& h_name, String[]& h_aliases, String[]& h_addr_list, int hint)
private bool GetHostName_internal(String& h_name)
private void Error_11001(string hostName)
private IPHostEntry hostent_to_IPHostEntry(string originalHostName, string h_name, String[] h_aliases, String[] h_addrlist)
public IPHostEntry GetHostByAddress(IPAddress address)
public IPHostEntry GetHostByAddress(string address)
private IPHostEntry GetHostByAddressFromString(string address, bool parse)
public IPHostEntry GetHostEntry(string hostNameOrAddress)
public IPHostEntry GetHostEntry(IPAddress address)
public IPAddress[] GetHostAddresses(string hostNameOrAddress)
public IPHostEntry GetHostByName(string hostName)
public string GetHostName()
public IPHostEntry Resolve(string hostName)
public Task`1<IPAddress[]> GetHostAddressesAsync(string hostNameOrAddress)
public Task`1<IPHostEntry> GetHostEntryAsync(IPAddress address)
public Task`1<IPHostEntry> GetHostEntryAsync(string hostNameOrAddress)
}
internal System.Net.DnsAsyncResult : object {
private WaitCallback internal_cb
private ManualResetEvent handle
private bool synch
private bool is_completed
private AsyncCallback callback
private object state
private IPHostEntry entry
private Exception exc
public object AsyncState
public WaitHandle AsyncWaitHandle
public Exception Exception
public IPHostEntry HostEntry
public bool CompletedSynchronously
public bool IsCompleted
public void .ctor(AsyncCallback cb, object state)
public void SetCompleted(bool synch, IPHostEntry entry, Exception e)
public void SetCompleted(bool synch, Exception e)
public void SetCompleted(bool synch, IPHostEntry entry)
private void CB(object _this)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public Exception get_Exception()
public IPHostEntry get_HostEntry()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
}
public System.Net.DnsEndPoint : EndPoint {
private string m_Host
private int m_Port
private AddressFamily m_Family
public string Host
public AddressFamily AddressFamily
public int Port
public void .ctor(string host, int port)
public void .ctor(string host, int port, AddressFamily addressFamily)
public bool Equals(object comparand)
public int GetHashCode()
public string ToString()
public string get_Host()
public AddressFamily get_AddressFamily()
public int get_Port()
}
public System.Net.DnsPermission : CodeAccessPermission {
private int version
private bool m_noRestriction
public void .ctor(PermissionState state)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public void FromXml(SecurityElement securityElement)
public IPermission Union(IPermission target)
private bool IsEmpty()
private DnsPermission Cast(IPermission target)
}
public System.Net.DnsPermissionAttribute : CodeAccessSecurityAttribute {
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
}
public System.Net.DownloadDataCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] m_Result
public Byte[] Result
internal void .ctor(Byte[] result, Exception exception, bool cancelled, object userToken)
public Byte[] get_Result()
}
public System.Net.DownloadDataCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DownloadDataCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DownloadDataCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.DownloadProgressChangedEventArgs : ProgressChangedEventArgs {
private long m_BytesReceived
private long m_TotalBytesToReceive
public long BytesReceived
public long TotalBytesToReceive
internal void .ctor(int progressPercentage, object userToken, long bytesReceived, long totalBytesToReceive)
public long get_BytesReceived()
public long get_TotalBytesToReceive()
}
public System.Net.DownloadProgressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DownloadProgressChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DownloadProgressChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.DownloadStringCompletedEventArgs : AsyncCompletedEventArgs {
private string m_Result
public string Result
internal void .ctor(string result, Exception exception, bool cancelled, object userToken)
public string get_Result()
}
public System.Net.DownloadStringCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DownloadStringCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DownloadStringCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.EmptyWebProxy : object {
private ICredentials m_credentials
public ICredentials Credentials
public Uri GetProxy(Uri uri)
public bool IsBypassed(Uri uri)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
private ProxyChain System.Net.IAutoWebProxy.GetProxies(Uri destination)
}
internal System.Net.Endianness : Enum {
public int value__
public Endianness Network
public Endianness Native
}
public System.Net.EndPoint : object {
public AddressFamily AddressFamily
public AddressFamily get_AddressFamily()
public SocketAddress Serialize()
public EndPoint Create(SocketAddress socketAddress)
}
internal System.Net.EndPointListener : object {
private HttpListener listener
private IPEndPoint endpoint
private Socket sock
private Hashtable prefixes
private ArrayList unhandled
private ArrayList all
private X509Certificate cert
private bool secure
private Dictionary`2<HttpConnection, HttpConnection> unregistered
internal HttpListener Listener
public void .ctor(HttpListener listener, IPAddress addr, int port, bool secure)
internal HttpListener get_Listener()
private void Accept(Socket socket, SocketAsyncEventArgs e, Socket& accepted)
private void ProcessAccept(SocketAsyncEventArgs args)
private void OnAccept(object sender, SocketAsyncEventArgs e)
internal void RemoveConnection(HttpConnection conn)
public bool BindContext(HttpListenerContext context)
public void UnbindContext(HttpListenerContext context)
private HttpListener SearchListener(Uri uri, ListenerPrefix& prefix)
private HttpListener MatchFromList(string host, string path, ArrayList list, ListenerPrefix& prefix)
private void AddSpecial(ArrayList coll, ListenerPrefix prefix)
private bool RemoveSpecial(ArrayList coll, ListenerPrefix prefix)
private void CheckIfRemove()
public void Close()
public void AddPrefix(ListenerPrefix prefix, HttpListener listener)
public void RemovePrefix(ListenerPrefix prefix, HttpListener listener)
}
internal System.Net.EndPointManager : object {
private Hashtable ip_to_endpoints
public void AddListener(HttpListener listener)
public void AddPrefix(string prefix, HttpListener listener)
private void AddPrefixInternal(string p, HttpListener listener)
private EndPointListener GetEPListener(string host, int port, HttpListener listener, bool secure)
public void RemoveEndPoint(EndPointListener epl, IPEndPoint ep)
public void RemoveListener(HttpListener listener)
public void RemovePrefix(string prefix, HttpListener listener)
private void RemovePrefixInternal(string prefix, HttpListener listener)
}
public System.Net.EndpointPermission : object {
private Char[] dot_char
private string hostname
private int port
private TransportType transport
private bool resolved
private bool hasWildcard
private IPAddress[] addresses
public string Hostname
public int Port
public TransportType Transport
internal void .ctor(string hostname, int port, TransportType transport)
public string get_Hostname()
public int get_Port()
public TransportType get_Transport()
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
internal bool IsSubsetOf(EndpointPermission perm)
private bool IsSubsetOf(string addr1, string addr2)
internal EndpointPermission Intersect(EndpointPermission perm)
private string IntersectHostname(EndpointPermission perm)
private string Intersect(string addr1, string addr2)
private int ToNumber(string value)
internal void Resolve()
internal void UndoResolve()
}
internal System.Net.ExceptionHelper : object {
internal NotImplementedException MethodNotImplementedException
internal NotImplementedException PropertyNotImplementedException
internal NotSupportedException MethodNotSupportedException
internal NotSupportedException PropertyNotSupportedException
internal WebException IsolatedException
internal WebException RequestAbortedException
internal WebException CacheEntryNotFoundException
internal WebException RequestProhibitedByCachePolicyException
internal NotImplementedException get_MethodNotImplementedException()
internal NotImplementedException get_PropertyNotImplementedException()
internal NotSupportedException get_MethodNotSupportedException()
internal NotSupportedException get_PropertyNotSupportedException()
internal WebException get_IsolatedException()
internal WebException get_RequestAbortedException()
internal WebException get_CacheEntryNotFoundException()
internal WebException get_RequestProhibitedByCachePolicyException()
}
public System.Net.FileWebRequest : WebRequest {
private WaitCallback s_GetRequestStreamCallback
private WaitCallback s_GetResponseCallback
private string m_connectionGroupName
private long m_contentLength
private ICredentials m_credentials
private FileAccess m_fileAccess
private WebHeaderCollection m_headers
private string m_method
private bool m_preauthenticate
private IWebProxy m_proxy
private ManualResetEvent m_readerEvent
private bool m_readPending
private WebResponse m_response
private Stream m_stream
private bool m_syncHint
private int m_timeout
private Uri m_uri
private bool m_writePending
private bool m_writing
private LazyAsyncResult m_WriteAResult
private LazyAsyncResult m_ReadAResult
private int m_Aborted
internal bool Aborted
public string ConnectionGroupName
public long ContentLength
public string ContentType
public ICredentials Credentials
public WebHeaderCollection Headers
public string Method
public bool PreAuthenticate
public IWebProxy Proxy
public int Timeout
public Uri RequestUri
public bool UseDefaultCredentials
internal void .ctor(Uri uri)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal bool get_Aborted()
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public long get_ContentLength()
public void set_ContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public WebHeaderCollection get_Headers()
public string get_Method()
public void set_Method(string value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public int get_Timeout()
public void set_Timeout(int value)
public Uri get_RequestUri()
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
private bool CanGetRequestStream()
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public Stream GetRequestStream()
public WebResponse GetResponse()
private void GetRequestStreamCallback(object state)
private void GetResponseCallback(object state)
internal void UnblockReader()
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public void Abort()
}
internal System.Net.FileWebRequestCreator : object {
public WebRequest Create(Uri uri)
}
public System.Net.FileWebResponse : WebResponse {
private int DefaultFileStreamBufferSize
private string DefaultFileContentType
private bool m_closed
private long m_contentLength
private FileAccess m_fileAccess
private WebHeaderCollection m_headers
private Stream m_stream
private Uri m_uri
public long ContentLength
public string ContentType
public WebHeaderCollection Headers
public bool SupportsHeaders
public Uri ResponseUri
internal void .ctor(FileWebRequest request, Uri uri, FileAccess access, bool asyncHint)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public long get_ContentLength()
public string get_ContentType()
public WebHeaderCollection get_Headers()
public bool get_SupportsHeaders()
public Uri get_ResponseUri()
private void CheckDisposed()
public void Close()
private void System.Net.ICloseEx.CloseEx(CloseExState closeState)
public Stream GetResponseStream()
}
internal System.Net.FileWebStream : FileStream {
private FileWebRequest m_request
public void .ctor(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing)
public void .ctor(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing, int length, bool async)
protected void Dispose(bool disposing)
private void System.Net.ICloseEx.CloseEx(CloseExState closeState)
public int Read(Byte[] buffer, int offset, int size)
public void Write(Byte[] buffer, int offset, int size)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public int EndRead(IAsyncResult ar)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult ar)
private void CheckError()
}
internal System.Net.FtpAsyncResult : object {
private FtpWebResponse response
private ManualResetEvent waitHandle
private Exception exception
private AsyncCallback callback
private Stream stream
private object state
private bool completed
private bool synch
private object locker
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
internal bool GotException
internal Exception Exception
internal FtpWebResponse Response
internal Stream Stream
public void .ctor(AsyncCallback callback, object state)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
internal bool get_GotException()
internal Exception get_Exception()
internal FtpWebResponse get_Response()
internal void set_Response(FtpWebResponse value)
internal Stream get_Stream()
internal void set_Stream(Stream value)
internal void WaitUntilComplete()
internal bool WaitUntilComplete(int timeout, bool exitContext)
internal void SetCompleted(bool synch, Exception exc, FtpWebResponse response)
internal void SetCompleted(bool synch, FtpWebResponse response)
internal void SetCompleted(bool synch, Exception exc)
internal void DoCallback()
internal void Reset()
}
internal System.Net.FtpDataStream : Stream {
private FtpWebRequest request
private Stream networkStream
private bool disposed
private bool isRead
private int totalRead
public bool CanRead
public bool CanWrite
public bool CanSeek
public long Length
public long Position
internal Stream NetworkStream
internal void .ctor(FtpWebRequest request, Stream stream, bool isRead)
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
internal Stream get_NetworkStream()
public void Close()
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
private int ReadInternal(Byte[] buffer, int offset, int size)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
public int EndRead(IAsyncResult asyncResult)
public int Read(Byte[] buffer, int offset, int size)
private void WriteInternal(Byte[] buffer, int offset, int size)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
public void EndWrite(IAsyncResult asyncResult)
public void Write(Byte[] buffer, int offset, int size)
protected void Finalize()
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
private void CheckDisposed()
}
internal System.Net.FtpRequestCreator : object {
public WebRequest Create(Uri uri)
}
internal System.Net.FtpStatus : object {
private FtpStatusCode statusCode
private string statusDescription
public FtpStatusCode StatusCode
public string StatusDescription
public void .ctor(FtpStatusCode statusCode, string statusDescription)
public FtpStatusCode get_StatusCode()
public string get_StatusDescription()
}
public System.Net.FtpStatusCode : Enum {
public int value__
public FtpStatusCode Undefined
public FtpStatusCode RestartMarker
public FtpStatusCode ServiceTemporarilyNotAvailable
public FtpStatusCode DataAlreadyOpen
public FtpStatusCode OpeningData
public FtpStatusCode CommandOK
public FtpStatusCode CommandExtraneous
public FtpStatusCode DirectoryStatus
public FtpStatusCode FileStatus
public FtpStatusCode SystemType
public FtpStatusCode SendUserCommand
public FtpStatusCode ClosingControl
public FtpStatusCode ClosingData
public FtpStatusCode EnteringPassive
public FtpStatusCode LoggedInProceed
public FtpStatusCode ServerWantsSecureSession
public FtpStatusCode FileActionOK
public FtpStatusCode PathnameCreated
public FtpStatusCode SendPasswordCommand
public FtpStatusCode NeedLoginAccount
public FtpStatusCode FileCommandPending
public FtpStatusCode ServiceNotAvailable
public FtpStatusCode CantOpenData
public FtpStatusCode ConnectionClosed
public FtpStatusCode ActionNotTakenFileUnavailableOrBusy
public FtpStatusCode ActionAbortedLocalProcessingError
public FtpStatusCode ActionNotTakenInsufficientSpace
public FtpStatusCode CommandSyntaxError
public FtpStatusCode ArgumentSyntaxError
public FtpStatusCode CommandNotImplemented
public FtpStatusCode BadCommandSequence
public FtpStatusCode NotLoggedIn
public FtpStatusCode AccountNeeded
public FtpStatusCode ActionNotTakenFileUnavailable
public FtpStatusCode ActionAbortedUnknownPageType
public FtpStatusCode FileActionAborted
public FtpStatusCode ActionNotTakenFilenameNotAllowed
}
public System.Net.FtpWebRequest : WebRequest {
private Uri requestUri
private string file_name
private ServicePoint servicePoint
private Stream origDataStream
private Stream dataStream
private Stream controlStream
private StreamReader controlReader
private NetworkCredential credentials
private IPHostEntry hostEntry
private IPEndPoint localEndPoint
private IPEndPoint remoteEndPoint
private IWebProxy proxy
private int timeout
private int rwTimeout
private long offset
private bool binary
private bool enableSsl
private bool usePassive
private bool keepAlive
private string method
private string renameTo
private object locker
private RequestState requestState
private FtpAsyncResult asyncResult
private FtpWebResponse ftpResponse
private Stream requestStream
private string initial_path
private string ChangeDir
private string UserCommand
private string PasswordCommand
private string TypeCommand
private string PassiveCommand
private string ExtendedPassiveCommand
private string PortCommand
private string ExtendedPortCommand
private string AbortCommand
private string AuthCommand
private string RestCommand
private string RenameFromCommand
private string RenameToCommand
private string QuitCommand
private string EOL
private String[] supportedCommands
private Encoding dataEncoding
public X509CertificateCollection ClientCertificates
public string ConnectionGroupName
public string ContentType
public long ContentLength
public long ContentOffset
public ICredentials Credentials
public RequestCachePolicy DefaultCachePolicy
public bool EnableSsl
public WebHeaderCollection Headers
public bool KeepAlive
public string Method
public bool PreAuthenticate
public IWebProxy Proxy
public int ReadWriteTimeout
public string RenameTo
public Uri RequestUri
public ServicePoint ServicePoint
public bool UsePassive
public bool UseDefaultCredentials
public bool UseBinary
public int Timeout
private string DataType
private RequestState State
internal void .ctor(Uri uri)
private Exception GetMustImplement()
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public string get_ContentType()
public void set_ContentType(string value)
public long get_ContentLength()
public void set_ContentLength(long value)
public long get_ContentOffset()
public void set_ContentOffset(long value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public RequestCachePolicy get_DefaultCachePolicy()
public void set_DefaultCachePolicy(RequestCachePolicy value)
public bool get_EnableSsl()
public void set_EnableSsl(bool value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public string get_Method()
public void set_Method(string value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public int get_ReadWriteTimeout()
public void set_ReadWriteTimeout(int value)
public string get_RenameTo()
public void set_RenameTo(string value)
public Uri get_RequestUri()
public ServicePoint get_ServicePoint()
public bool get_UsePassive()
public void set_UsePassive(bool value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public bool get_UseBinary()
public void set_UseBinary(bool value)
public int get_Timeout()
public void set_Timeout(int value)
private string get_DataType()
private RequestState get_State()
private void set_State(RequestState value)
public void Abort()
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public WebResponse GetResponse()
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public Stream GetRequestStream()
private ServicePoint GetServicePoint()
private void ResolveHost()
private void ProcessRequest()
private void SetType()
private string GetRemoteFolderPath(Uri uri)
private void CWDAndSetFileName(Uri uri)
private void ProcessMethod()
private void CloseControlConnection()
internal void CloseDataConnection()
private void CloseConnection()
private void ProcessSimpleMethod()
private void UploadData()
private void DownloadData()
private void CheckRequestStarted()
private void OpenControlConnection()
private string GetInitialPath(FtpStatus status)
private Socket SetupPassiveConnection(string statusDescription, bool ipv6)
private int GetPortV4(string responseString)
private int GetPortV6(string responseString)
private string FormatAddress(IPAddress address, int Port)
private string FormatAddressV6(IPAddress address, int port)
private Exception CreateExceptionFromResponse(FtpStatus status)
internal void SetTransferCompleted()
internal void OperationCompleted()
private void SetCompleteWithError(Exception exc)
private Socket InitDataConnection()
private void OpenDataConnection()
private void Authenticate()
private FtpStatus SendCommand(string command, String[] parameters)
private FtpStatus SendCommand(bool waitResponse, string command, String[] parameters)
internal FtpStatus ServiceNotAvailable()
internal FtpStatus GetResponseStatus()
private void InitiateSecureConnection(Stream& stream)
internal bool ChangeToSSLSocket(Stream& stream)
private bool InFinalState()
private bool InProgress()
internal void CheckIfAborted()
private void CheckFinalState()
}
public System.Net.FtpWebResponse : WebResponse {
private Stream stream
private Uri uri
private FtpStatusCode statusCode
private DateTime lastModified
private string bannerMessage
private string welcomeMessage
private string exitMessage
private string statusDescription
private string method
private bool disposed
private FtpWebRequest request
internal long contentLength
public long ContentLength
public WebHeaderCollection Headers
public Uri ResponseUri
public DateTime LastModified
public string BannerMessage
public string WelcomeMessage
public string ExitMessage
public FtpStatusCode StatusCode
public bool SupportsHeaders
public string StatusDescription
internal Stream Stream
internal void .ctor(FtpWebRequest request, Uri uri, string method, bool keepAlive)
internal void .ctor(FtpWebRequest request, Uri uri, string method, FtpStatusCode statusCode, string statusDescription)
internal void .ctor(FtpWebRequest request, Uri uri, string method, FtpStatus status)
public long get_ContentLength()
public WebHeaderCollection get_Headers()
public Uri get_ResponseUri()
public DateTime get_LastModified()
internal void set_LastModified(DateTime value)
public string get_BannerMessage()
internal void set_BannerMessage(string value)
public string get_WelcomeMessage()
internal void set_WelcomeMessage(string value)
public string get_ExitMessage()
internal void set_ExitMessage(string value)
public FtpStatusCode get_StatusCode()
internal void set_StatusCode(FtpStatusCode value)
public bool get_SupportsHeaders()
public string get_StatusDescription()
internal void set_StatusDescription(string value)
public void Close()
public Stream GetResponseStream()
internal void set_Stream(Stream value)
internal Stream get_Stream()
internal void UpdateStatus(FtpStatus status)
private void CheckDisposed()
internal bool IsFinal()
}
internal System.Net.GeneralAsyncDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object request, object state)
public IAsyncResult BeginInvoke(object request, object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.GlobalLog : object {
private BaseLoggingObject Logobject
internal ThreadKinds CurrentThreadKind
private BaseLoggingObject LoggingInitialize()
internal ThreadKinds get_CurrentThreadKind()
internal void SetThreadSource(ThreadKinds source)
internal void ThreadContract(ThreadKinds kind, string errorMsg)
internal void ThreadContract(ThreadKinds kind, ThreadKinds allowedSources, string errorMsg)
public void AddToArray(string msg)
public void Ignore(object msg)
public void Print(string msg)
public void PrintHex(string msg, object value)
public void Enter(string func)
public void Enter(string func, string parms)
public void Assert(bool condition, string messageFormat, Object[] data)
public void Assert(string message)
public void Assert(string message, string detailMessage)
public void LeaveException(string func, Exception exception)
public void Leave(string func)
public void Leave(string func, string result)
public void Leave(string func, int returnval)
public void Leave(string func, bool returnval)
public void DumpArray()
public void Dump(Byte[] buffer)
public void Dump(Byte[] buffer, int length)
public void Dump(Byte[] buffer, int offset, int length)
public void Dump(IntPtr buffer, int offset, int length)
}
public System.Net.GlobalProxySelection : object {
public IWebProxy Select
public IWebProxy get_Select()
public void set_Select(IWebProxy value)
public IWebProxy GetEmptyWebProxy()
}
internal System.Net.HeaderInfo : object {
internal bool IsRequestRestricted
internal bool IsResponseRestricted
internal HeaderParser Parser
internal string HeaderName
internal bool AllowMultiValues
internal void .ctor(string name, bool requestRestricted, bool responseRestricted, bool multi, HeaderParser p)
}
internal System.Net.HeaderInfoTable : object {
private Hashtable HeaderHashTable
private HeaderInfo UnknownHeaderInfo
private HeaderParser SingleParser
private HeaderParser MultiParser
internal HeaderInfo Item
private String[] ParseSingleValue(string value)
private String[] ParseMultiValue(string value)
internal HeaderInfo get_Item(string name)
}
internal System.Net.HeaderParser : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public String[] Invoke(string value)
public IAsyncResult BeginInvoke(string value, AsyncCallback callback, object object)
public String[] EndInvoke(IAsyncResult result)
}
internal System.Net.HeaderVariantInfo : ValueType {
private string m_name
private CookieVariant m_variant
internal string Name
internal CookieVariant Variant
internal void .ctor(string name, CookieVariant variant)
internal string get_Name()
internal CookieVariant get_Variant()
}
internal System.Net.hostent : ValueType {
public IntPtr h_name
public IntPtr h_aliases
public short h_addrtype
public short h_length
public IntPtr h_addr_list
}
internal System.Net.HostHeaderString : object {
private bool m_Converted
private string m_String
private Byte[] m_Bytes
internal string String
internal int ByteCount
internal Byte[] Bytes
internal void .ctor(string s)
private void Init(string s)
private void Convert()
internal string get_String()
internal void set_String(string value)
internal int get_ByteCount()
internal Byte[] get_Bytes()
internal void Copy(Byte[] destBytes, int destByteIndex)
}
internal System.Net.HttpAbortDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(HttpWebRequest request, WebException webException)
public IAsyncResult BeginInvoke(HttpWebRequest request, WebException webException, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal System.Net.HttpBehaviour : Enum {
public byte value__
public HttpBehaviour Unknown
public HttpBehaviour HTTP10
public HttpBehaviour HTTP11PartiallyCompliant
public HttpBehaviour HTTP11
}
internal System.Net.HttpConnection : object {
private AsyncCallback onread_cb
private int BufferSize
private Socket sock
private Stream stream
private EndPointListener epl
private MemoryStream ms
private Byte[] buffer
private HttpListenerContext context
private StringBuilder current_line
private ListenerPrefix prefix
private RequestStream i_stream
private ResponseStream o_stream
private bool chunked
private int reuses
private bool context_bound
private bool secure
private X509Certificate cert
private int s_timeout
private Timer timer
private IPEndPoint local_ep
private HttpListener last_listener
private Int32[] client_cert_errors
private X509Certificate2 client_cert
private SslStream ssl_stream
private InputState input_state
private LineState line_state
private int position
internal SslStream SslStream
internal Int32[] ClientCertificateErrors
internal X509Certificate2 ClientCertificate
public bool IsClosed
public int Reuses
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public bool IsSecure
public ListenerPrefix Prefix
public void .ctor(Socket sock, EndPointListener epl, bool secure, X509Certificate cert)
internal SslStream get_SslStream()
internal Int32[] get_ClientCertificateErrors()
internal X509Certificate2 get_ClientCertificate()
private void Init()
public bool get_IsClosed()
public int get_Reuses()
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
public bool get_IsSecure()
public ListenerPrefix get_Prefix()
public void set_Prefix(ListenerPrefix value)
private void OnTimeout(object unused)
public void BeginReadRequest()
public RequestStream GetRequestStream(bool chunked, long contentlength)
public ResponseStream GetResponseStream()
private void OnRead(IAsyncResult ares)
private void OnReadInternal(IAsyncResult ares)
private void RemoveConnection()
private bool ProcessInput(MemoryStream ms)
private string ReadLine(Byte[] buffer, int offset, int len, Int32& used)
public void SendError(string msg, int status)
public void SendError()
private void Unbind()
public void Close()
private void CloseSocket()
internal void Close(bool force_close)
private bool <.ctor>b__24_0(object t, X509Certificate c, X509Chain ch, SslPolicyErrors e)
}
public System.Net.HttpContinueDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(int StatusCode, WebHeaderCollection httpHeaders)
public IAsyncResult BeginInvoke(int StatusCode, WebHeaderCollection httpHeaders, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.HttpDateParse : object {
private int BASE_DEC
private int DATE_INDEX_DAY_OF_WEEK
private int DATE_1123_INDEX_DAY
private int DATE_1123_INDEX_MONTH
private int DATE_1123_INDEX_YEAR
private int DATE_1123_INDEX_HRS
private int DATE_1123_INDEX_MINS
private int DATE_1123_INDEX_SECS
private int DATE_ANSI_INDEX_MONTH
private int DATE_ANSI_INDEX_DAY
private int DATE_ANSI_INDEX_HRS
private int DATE_ANSI_INDEX_MINS
private int DATE_ANSI_INDEX_SECS
private int DATE_ANSI_INDEX_YEAR
private int DATE_INDEX_TZ
private int DATE_INDEX_LAST
private int MAX_FIELD_DATE_ENTRIES
private int DATE_TOKEN_JANUARY
private int DATE_TOKEN_FEBRUARY
private int DATE_TOKEN_Microsoft
private int DATE_TOKEN_APRIL
private int DATE_TOKEN_MAY
private int DATE_TOKEN_JUNE
private int DATE_TOKEN_JULY
private int DATE_TOKEN_AUGUST
private int DATE_TOKEN_SEPTEMBER
private int DATE_TOKEN_OCTOBER
private int DATE_TOKEN_NOVEMBER
private int DATE_TOKEN_DECEMBER
private int DATE_TOKEN_LAST_MONTH
private int DATE_TOKEN_SUNDAY
private int DATE_TOKEN_MONDAY
private int DATE_TOKEN_TUESDAY
private int DATE_TOKEN_WEDNESDAY
private int DATE_TOKEN_THURSDAY
private int DATE_TOKEN_FRIDAY
private int DATE_TOKEN_SATURDAY
private int DATE_TOKEN_LAST_DAY
private int DATE_TOKEN_GMT
private int DATE_TOKEN_LAST
private int DATE_TOKEN_ERROR
private char MAKE_UPPER(char c)
private int MapDayMonthToDword(Char[] lpszDay, int index)
public bool ParseHttpDate(string DateString, DateTime& dtOut)
}
internal System.Net.HttpKnownHeaderNames : object {
public string CacheControl
public string Connection
public string Date
public string KeepAlive
public string Pragma
public string ProxyConnection
public string Trailer
public string TransferEncoding
public string Upgrade
public string Via
public string Warning
public string ContentLength
public string ContentType
public string ContentDisposition
public string ContentEncoding
public string ContentLanguage
public string ContentLocation
public string ContentRange
public string Expires
public string LastModified
public string Age
public string Location
public string ProxyAuthenticate
public string RetryAfter
public string Server
public string SetCookie
public string SetCookie2
public string Vary
public string WWWAuthenticate
public string Accept
public string AcceptCharset
public string AcceptEncoding
public string AcceptLanguage
public string Authorization
public string Cookie
public string Cookie2
public string Expect
public string From
public string Host
public string IfMatch
public string IfModifiedSince
public string IfNoneMatch
public string IfRange
public string IfUnmodifiedSince
public string MaxForwards
public string ProxyAuthorization
public string Referer
public string Range
public string UserAgent
public string ContentMD5
public string ETag
public string TE
public string Allow
public string AcceptRanges
public string P3P
public string XPoweredBy
public string XAspNetVersion
public string SecWebSocketKey
public string SecWebSocketExtensions
public string SecWebSocketAccept
public string Origin
public string SecWebSocketProtocol
public string SecWebSocketVersion
}
public System.Net.HttpListener : object {
private MonoTlsProvider tlsProvider
private MonoTlsSettings tlsSettings
private X509Certificate certificate
private AuthenticationSchemes auth_schemes
private HttpListenerPrefixCollection prefixes
private AuthenticationSchemeSelector auth_selector
private string realm
private bool ignore_write_exceptions
private bool unsafe_ntlm_auth
private bool listening
private bool disposed
private object _internalLock
private Hashtable registry
private ArrayList ctx_queue
private ArrayList wait_queue
private Hashtable connections
private ServiceNameStore defaultServiceNames
private ExtendedProtectionPolicy extendedProtectionPolicy
private ExtendedProtectionSelector extendedProtectionSelectorDelegate
public AuthenticationSchemes AuthenticationSchemes
public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate
public ExtendedProtectionSelector ExtendedProtectionSelectorDelegate
public bool IgnoreWriteExceptions
public bool IsListening
public bool IsSupported
public HttpListenerPrefixCollection Prefixes
public HttpListenerTimeoutManager TimeoutManager
public ExtendedProtectionPolicy ExtendedProtectionPolicy
public ServiceNameCollection DefaultServiceNames
public string Realm
public bool UnsafeConnectionNtlmAuthentication
internal void .ctor(X509Certificate certificate, MonoTlsProvider tlsProvider, MonoTlsSettings tlsSettings)
internal X509Certificate LoadCertificateAndKey(IPAddress addr, int port)
internal SslStream CreateSslStream(Stream innerStream, bool ownsStream, RemoteCertificateValidationCallback callback)
public AuthenticationSchemes get_AuthenticationSchemes()
public void set_AuthenticationSchemes(AuthenticationSchemes value)
public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate()
public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value)
public ExtendedProtectionSelector get_ExtendedProtectionSelectorDelegate()
public void set_ExtendedProtectionSelectorDelegate(ExtendedProtectionSelector value)
public bool get_IgnoreWriteExceptions()
public void set_IgnoreWriteExceptions(bool value)
public bool get_IsListening()
public bool get_IsSupported()
public HttpListenerPrefixCollection get_Prefixes()
public HttpListenerTimeoutManager get_TimeoutManager()
public ExtendedProtectionPolicy get_ExtendedProtectionPolicy()
public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value)
public ServiceNameCollection get_DefaultServiceNames()
public string get_Realm()
public void set_Realm(string value)
public bool get_UnsafeConnectionNtlmAuthentication()
public void set_UnsafeConnectionNtlmAuthentication(bool value)
public void Abort()
public void Close()
private void Close(bool force)
private void Cleanup(bool close_existing)
public IAsyncResult BeginGetContext(AsyncCallback callback, object state)
public HttpListenerContext EndGetContext(IAsyncResult asyncResult)
internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerContext context)
public HttpListenerContext GetContext()
public void Start()
public void Stop()
private void System.IDisposable.Dispose()
public Task`1<HttpListenerContext> GetContextAsync()
internal void CheckDisposed()
private HttpListenerContext GetContextFromQueue()
internal void RegisterContext(HttpListenerContext context)
internal void UnregisterContext(HttpListenerContext context)
internal void AddConnection(HttpConnection cnc)
internal void RemoveConnection(HttpConnection cnc)
}
public System.Net.HttpListenerBasicIdentity : GenericIdentity {
private string password
public string Password
public void .ctor(string username, string password)
public string get_Password()
}
public System.Net.HttpListenerContext : object {
private HttpListenerRequest request
private HttpListenerResponse response
private IPrincipal user
private HttpConnection cnc
private string error
private int err_status
internal HttpListener Listener
internal int ErrorStatus
internal string ErrorMessage
internal bool HaveError
internal HttpConnection Connection
public HttpListenerRequest Request
public HttpListenerResponse Response
public IPrincipal User
internal void .ctor(HttpConnection cnc)
internal int get_ErrorStatus()
internal void set_ErrorStatus(int value)
internal string get_ErrorMessage()
internal void set_ErrorMessage(string value)
internal bool get_HaveError()
internal HttpConnection get_Connection()
public HttpListenerRequest get_Request()
public HttpListenerResponse get_Response()
public IPrincipal get_User()
internal void ParseAuthentication(AuthenticationSchemes expectedSchemes)
internal IPrincipal ParseBasicAuthentication(string authData)
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol)
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, TimeSpan keepAliveInterval)
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval)
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer)
}
public System.Net.HttpListenerException : Win32Exception {
public int ErrorCode
public void .ctor(int errorCode)
public void .ctor(int errorCode, string message)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public int get_ErrorCode()
}
public System.Net.HttpListenerPrefixCollection : object {
private List`1<string> prefixes
private HttpListener listener
public int Count
public bool IsReadOnly
public bool IsSynchronized
internal void .ctor(HttpListener listener)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public void Add(string uriPrefix)
public void Clear()
public bool Contains(string uriPrefix)
public void CopyTo(String[] array, int offset)
public void CopyTo(Array array, int offset)
public IEnumerator`1<string> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Remove(string uriPrefix)
}
public System.Net.HttpListenerRequest : object {
private String[] accept_types
private Encoding content_encoding
private long content_length
private bool cl_set
private CookieCollection cookies
private WebHeaderCollection headers
private string method
private Stream input_stream
private Version version
private NameValueCollection query_string
private string raw_url
private Uri url
private Uri referrer
private String[] user_languages
private HttpListenerContext context
private bool is_chunked
private bool ka_set
private bool keep_alive
private GCCDelegate gcc_delegate
private Byte[] _100continue
private Char[] separators
public String[] AcceptTypes
public int ClientCertificateError
public Encoding ContentEncoding
public long ContentLength64
public string ContentType
public CookieCollection Cookies
public bool HasEntityBody
public NameValueCollection Headers
public string HttpMethod
public Stream InputStream
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public bool KeepAlive
public IPEndPoint LocalEndPoint
public Version ProtocolVersion
public NameValueCollection QueryString
public string RawUrl
public IPEndPoint RemoteEndPoint
public Guid RequestTraceIdentifier
public Uri Url
public Uri UrlReferrer
public string UserAgent
public string UserHostAddress
public string UserHostName
public String[] UserLanguages
public string ServiceName
public TransportContext TransportContext
public bool IsWebSocketRequest
internal void .ctor(HttpListenerContext context)
internal void SetRequestLine(string req)
private void CreateQueryString(string query)
private bool MaybeUri(string s)
private bool IsPredefinedScheme(string scheme)
internal void FinishInitialization()
internal string Unquote(string str)
internal void AddHeader(string header)
internal bool FlushInput()
public String[] get_AcceptTypes()
public int get_ClientCertificateError()
public Encoding get_ContentEncoding()
public long get_ContentLength64()
public string get_ContentType()
public CookieCollection get_Cookies()
public bool get_HasEntityBody()
public NameValueCollection get_Headers()
public string get_HttpMethod()
public Stream get_InputStream()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public bool get_KeepAlive()
public IPEndPoint get_LocalEndPoint()
public Version get_ProtocolVersion()
public NameValueCollection get_QueryString()
public string get_RawUrl()
public IPEndPoint get_RemoteEndPoint()
public Guid get_RequestTraceIdentifier()
public Uri get_Url()
public Uri get_UrlReferrer()
public string get_UserAgent()
public string get_UserHostAddress()
public string get_UserHostName()
public String[] get_UserLanguages()
public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state)
public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult)
public X509Certificate2 GetClientCertificate()
public string get_ServiceName()
public TransportContext get_TransportContext()
public bool get_IsWebSocketRequest()
public Task`1<X509Certificate2> GetClientCertificateAsync()
}
internal System.Net.HttpListenerRequestUriBuilder : object {
private bool useCookedRequestUrl
private Encoding utf8Encoding
private Encoding ansiEncoding
private string rawUri
private string cookedUriScheme
private string cookedUriHost
private string cookedUriPath
private string cookedUriQuery
private StringBuilder requestUriString
private List`1<byte> rawOctets
private string rawPath
private Uri requestUri
private void .ctor(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery)
public Uri GetRequestUri(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery)
private Uri Build()
private void BuildRequestUriUsingCookedPath()
private void BuildRequestUriUsingRawPath()
private Encoding GetEncoding(EncodingType type)
private ParsingResult BuildRequestUriUsingRawPath(Encoding encoding)
private ParsingResult ParseRawPath(Encoding encoding)
private bool AppendUnicodeCodePointValuePercentEncoded(string codePoint)
private bool AddPercentEncodedOctetToRawOctetsList(Encoding encoding, string escapedCharacter)
private bool EmptyDecodeAndAppendRawOctetsList(Encoding encoding)
private void AppendOctetsPercentEncoded(StringBuilder target, IEnumerable`1<byte> octets)
private string GetOctetsAsString(IEnumerable`1<byte> octets)
private string GetPath(string uriString)
private string AddSlashToAsteriskOnlyPath(string path)
private void LogWarning(string methodName, string message, Object[] args)
}
public System.Net.HttpListenerResponse : object {
private bool disposed
private Encoding content_encoding
private long content_length
private bool cl_set
private string content_type
private CookieCollection cookies
private WebHeaderCollection headers
private bool keep_alive
private ResponseStream output_stream
private Version version
private string location
private int status_code
private string status_description
private bool chunked
private HttpListenerContext context
internal bool HeadersSent
internal object headers_lock
private bool force_close_chunked
private string tspecials
internal bool ForceCloseChunked
public Encoding ContentEncoding
public long ContentLength64
public string ContentType
public CookieCollection Cookies
public WebHeaderCollection Headers
public bool KeepAlive
public Stream OutputStream
public Version ProtocolVersion
public string RedirectLocation
public bool SendChunked
public int StatusCode
public string StatusDescription
internal void .ctor(HttpListenerContext context)
internal bool get_ForceCloseChunked()
public Encoding get_ContentEncoding()
public void set_ContentEncoding(Encoding value)
public long get_ContentLength64()
public void set_ContentLength64(long value)
public string get_ContentType()
public void set_ContentType(string value)
public CookieCollection get_Cookies()
public void set_Cookies(CookieCollection value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public Stream get_OutputStream()
public Version get_ProtocolVersion()
public void set_ProtocolVersion(Version value)
public string get_RedirectLocation()
public void set_RedirectLocation(string value)
public bool get_SendChunked()
public void set_SendChunked(bool value)
public int get_StatusCode()
public void set_StatusCode(int value)
public string get_StatusDescription()
public void set_StatusDescription(string value)
private void System.IDisposable.Dispose()
public void Abort()
public void AddHeader(string name, string value)
public void AppendCookie(Cookie cookie)
public void AppendHeader(string name, string value)
private void Close(bool force)
public void Close()
public void Close(Byte[] responseEntity, bool willBlock)
public void CopyFrom(HttpListenerResponse templateResponse)
public void Redirect(string url)
private bool FindCookie(Cookie cookie)
internal void SendHeaders(bool closing, MemoryStream ms)
private string FormatHeaders(WebHeaderCollection headers)
private string CookieToClientString(Cookie cookie)
private string QuotedString(Cookie cookie, string value)
private bool IsToken(string value)
public void SetCookie(Cookie cookie)
}
public System.Net.HttpListenerTimeoutManager : object {
public TimeSpan EntityBody
public TimeSpan DrainEntityBody
public TimeSpan RequestQueue
public TimeSpan IdleConnection
public TimeSpan HeaderWait
public long MinSendBytesPerSecond
public TimeSpan get_EntityBody()
public void set_EntityBody(TimeSpan value)
public TimeSpan get_DrainEntityBody()
public void set_DrainEntityBody(TimeSpan value)
public TimeSpan get_RequestQueue()
public void set_RequestQueue(TimeSpan value)
public TimeSpan get_IdleConnection()
public void set_IdleConnection(TimeSpan value)
public TimeSpan get_HeaderWait()
public void set_HeaderWait(TimeSpan value)
public long get_MinSendBytesPerSecond()
public void set_MinSendBytesPerSecond(long value)
}
internal System.Net.HttpProcessingResult : Enum {
public int value__
public HttpProcessingResult Continue
public HttpProcessingResult ReadWait
public HttpProcessingResult WriteWait
}
internal System.Net.HttpProtocolUtils : object {
internal DateTime string2date(string S)
internal string date2string(DateTime D)
}
internal System.Net.HttpRequestCreator : object {
public WebRequest Create(Uri uri)
}
public System.Net.HttpRequestHeader : Enum {
public int value__
public HttpRequestHeader CacheControl
public HttpRequestHeader Connection
public HttpRequestHeader Date
public HttpRequestHeader KeepAlive
public HttpRequestHeader Pragma
public HttpRequestHeader Trailer
public HttpRequestHeader TransferEncoding
public HttpRequestHeader Upgrade
public HttpRequestHeader Via
public HttpRequestHeader Warning
public HttpRequestHeader Allow
public HttpRequestHeader ContentLength
public HttpRequestHeader ContentType
public HttpRequestHeader ContentEncoding
public HttpRequestHeader ContentLanguage
public HttpRequestHeader ContentLocation
public HttpRequestHeader ContentMd5
public HttpRequestHeader ContentRange
public HttpRequestHeader Expires
public HttpRequestHeader LastModified
public HttpRequestHeader Accept
public HttpRequestHeader AcceptCharset
public HttpRequestHeader AcceptEncoding
public HttpRequestHeader AcceptLanguage
public HttpRequestHeader Authorization
public HttpRequestHeader Cookie
public HttpRequestHeader Expect
public HttpRequestHeader From
public HttpRequestHeader Host
public HttpRequestHeader IfMatch
public HttpRequestHeader IfModifiedSince
public HttpRequestHeader IfNoneMatch
public HttpRequestHeader IfRange
public HttpRequestHeader IfUnmodifiedSince
public HttpRequestHeader MaxForwards
public HttpRequestHeader ProxyAuthorization
public HttpRequestHeader Referer
public HttpRequestHeader Range
public HttpRequestHeader Te
public HttpRequestHeader Translate
public HttpRequestHeader UserAgent
}
public System.Net.HttpResponseHeader : Enum {
public int value__
public HttpResponseHeader CacheControl
public HttpResponseHeader Connection
public HttpResponseHeader Date
public HttpResponseHeader KeepAlive
public HttpResponseHeader Pragma
public HttpResponseHeader Trailer
public HttpResponseHeader TransferEncoding
public HttpResponseHeader Upgrade
public HttpResponseHeader Via
public HttpResponseHeader Warning
public HttpResponseHeader Allow
public HttpResponseHeader ContentLength
public HttpResponseHeader ContentType
public HttpResponseHeader ContentEncoding
public HttpResponseHeader ContentLanguage
public HttpResponseHeader ContentLocation
public HttpResponseHeader ContentMd5
public HttpResponseHeader ContentRange
public HttpResponseHeader Expires
public HttpResponseHeader LastModified
public HttpResponseHeader AcceptRanges
public HttpResponseHeader Age
public HttpResponseHeader ETag
public HttpResponseHeader Location
public HttpResponseHeader ProxyAuthenticate
public HttpResponseHeader RetryAfter
public HttpResponseHeader Server
public HttpResponseHeader SetCookie
public HttpResponseHeader Vary
public HttpResponseHeader WwwAuthenticate
}
public System.Net.HttpStatusCode : Enum {
public int value__
public HttpStatusCode Continue
public HttpStatusCode SwitchingProtocols
public HttpStatusCode OK
public HttpStatusCode Created
public HttpStatusCode Accepted
public HttpStatusCode NonAuthoritativeInformation
public HttpStatusCode NoContent
public HttpStatusCode ResetContent
public HttpStatusCode PartialContent
public HttpStatusCode MultipleChoices
public HttpStatusCode Ambiguous
public HttpStatusCode MovedPermanently
public HttpStatusCode Moved
public HttpStatusCode Found
public HttpStatusCode Redirect
public HttpStatusCode SeeOther
public HttpStatusCode RedirectMethod
public HttpStatusCode NotModified
public HttpStatusCode UseProxy
public HttpStatusCode Unused
public HttpStatusCode TemporaryRedirect
public HttpStatusCode RedirectKeepVerb
public HttpStatusCode BadRequest
public HttpStatusCode Unauthorized
public HttpStatusCode PaymentRequired
public HttpStatusCode Forbidden
public HttpStatusCode NotFound
public HttpStatusCode MethodNotAllowed
public HttpStatusCode NotAcceptable
public HttpStatusCode ProxyAuthenticationRequired
public HttpStatusCode RequestTimeout
public HttpStatusCode Conflict
public HttpStatusCode Gone
public HttpStatusCode LengthRequired
public HttpStatusCode PreconditionFailed
public HttpStatusCode RequestEntityTooLarge
public HttpStatusCode RequestUriTooLong
public HttpStatusCode UnsupportedMediaType
public HttpStatusCode RequestedRangeNotSatisfiable
public HttpStatusCode ExpectationFailed
public HttpStatusCode UpgradeRequired
public HttpStatusCode InternalServerError
public HttpStatusCode NotImplemented
public HttpStatusCode BadGateway
public HttpStatusCode ServiceUnavailable
public HttpStatusCode GatewayTimeout
public HttpStatusCode HttpVersionNotSupported
}
internal System.Net.HttpStatusDescription : object {
internal string Get(HttpStatusCode code)
internal string Get(int code)
}
internal System.Net.HttpStreamAsyncResult : object {
private object locker
private ManualResetEvent handle
private bool completed
internal Byte[] Buffer
internal int Offset
internal int Count
internal AsyncCallback Callback
internal object State
internal int SynchRead
internal Exception Error
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public void Complete(Exception e)
public void Complete()
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
}
internal System.Net.HttpSysSettings : object {
public bool EnableNonUtf8
public bool FavorUtf8
}
public System.Net.HttpVersion : object {
public Version Version10
public Version Version11
}
public System.Net.HttpWebRequest : WebRequest {
private Uri requestUri
private Uri actualUri
private bool hostChanged
private bool allowAutoRedirect
private bool allowBuffering
private X509CertificateCollection certificates
private string connectionGroup
private bool haveContentLength
private long contentLength
private HttpContinueDelegate continueDelegate
private CookieContainer cookieContainer
private ICredentials credentials
private bool haveResponse
private bool haveRequest
private bool requestSent
private WebHeaderCollection webHeaders
private bool keepAlive
private int maxAutoRedirect
private string mediaType
private string method
private string initialMethod
private bool pipelined
private bool preAuthenticate
private bool usedPreAuth
private Version version
private bool force_version
private Version actualVersion
private IWebProxy proxy
private bool sendChunked
private ServicePoint servicePoint
private int timeout
private WebConnectionStream writeStream
private HttpWebResponse webResponse
private WebAsyncResult asyncWrite
private WebAsyncResult asyncRead
private EventHandler abortHandler
private int aborted
private bool gotRequestStream
private int redirects
private bool expectContinue
private Byte[] bodyBuffer
private int bodyBufferLength
private bool getResponseCalled
private Exception saved_exc
private object locker
private bool finished_reading
internal WebConnection WebConnection
private DecompressionMethods auto_decomp
private int maxResponseHeadersLength
private int defaultMaxResponseHeadersLength
private int readWriteTimeout
private MonoTlsProvider tlsProvider
private MonoTlsSettings tlsSettings
private ServerCertValidationCallback certValidationCallback
private AuthorizationState auth_state
private AuthorizationState proxy_auth_state
private string host
internal Action`1<Stream> ResendContentFactory
private bool <ThrowOnError>k__BackingField
private bool unsafe_auth_blah
private bool <ReuseConnection>k__BackingField
internal WebConnection StoredConnection
public string Accept
public Uri Address
public bool AllowAutoRedirect
public bool AllowWriteStreamBuffering
public bool AllowReadStreamBuffering
public DecompressionMethods AutomaticDecompression
internal bool InternalAllowBuffering
private bool MethodWithBuffer
internal MonoTlsProvider TlsProvider
internal MonoTlsSettings TlsSettings
public X509CertificateCollection ClientCertificates
public string Connection
public string ConnectionGroupName
public long ContentLength
internal long InternalContentLength
internal bool ThrowOnError
public string ContentType
public HttpContinueDelegate ContinueDelegate
public CookieContainer CookieContainer
public ICredentials Credentials
public DateTime Date
public RequestCachePolicy DefaultCachePolicy
public int DefaultMaximumErrorResponseLength
public string Expect
public bool HaveResponse
public WebHeaderCollection Headers
public string Host
public DateTime IfModifiedSince
public bool KeepAlive
public int MaximumAutomaticRedirections
public int MaximumResponseHeadersLength
public int DefaultMaximumResponseHeadersLength
public int ReadWriteTimeout
public int ContinueTimeout
public string MediaType
public string Method
public bool Pipelined
public bool PreAuthenticate
public Version ProtocolVersion
public IWebProxy Proxy
public string Referer
public Uri RequestUri
public bool SendChunked
public ServicePoint ServicePoint
internal ServicePoint ServicePointNoLock
public bool SupportsCookieContainer
public int Timeout
public string TransferEncoding
public bool UseDefaultCredentials
public string UserAgent
public bool UnsafeAuthenticatedConnectionSharing
internal bool GotRequestStream
internal bool ExpectContinue
internal Uri AuthUri
internal bool ProxyQuery
internal ServerCertValidationCallback ServerCertValidationCallback
public RemoteCertificateValidationCallback ServerCertificateValidationCallback
internal bool FinishedReading
internal bool Aborted
internal bool ReuseConnection
internal void .ctor(Uri uri)
internal void .ctor(Uri uri, MonoTlsProvider tlsProvider, MonoTlsSettings settings)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void ResetAuthorization()
private void SetSpecialHeaders(string HeaderName, string value)
public string get_Accept()
public void set_Accept(string value)
public Uri get_Address()
internal void set_Address(Uri value)
public bool get_AllowAutoRedirect()
public void set_AllowAutoRedirect(bool value)
public bool get_AllowWriteStreamBuffering()
public void set_AllowWriteStreamBuffering(bool value)
public bool get_AllowReadStreamBuffering()
public void set_AllowReadStreamBuffering(bool value)
private Exception GetMustImplement()
public DecompressionMethods get_AutomaticDecompression()
public void set_AutomaticDecompression(DecompressionMethods value)
internal bool get_InternalAllowBuffering()
private bool get_MethodWithBuffer()
internal MonoTlsProvider get_TlsProvider()
internal MonoTlsSettings get_TlsSettings()
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public string get_Connection()
public void set_Connection(string value)
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public long get_ContentLength()
public void set_ContentLength(long value)
internal void set_InternalContentLength(long value)
internal bool get_ThrowOnError()
internal void set_ThrowOnError(bool value)
public string get_ContentType()
public void set_ContentType(string value)
public HttpContinueDelegate get_ContinueDelegate()
public void set_ContinueDelegate(HttpContinueDelegate value)
public CookieContainer get_CookieContainer()
public void set_CookieContainer(CookieContainer value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public DateTime get_Date()
public void set_Date(DateTime value)
private void SetDateHeaderHelper(string headerName, DateTime dateTime)
public RequestCachePolicy get_DefaultCachePolicy()
public void set_DefaultCachePolicy(RequestCachePolicy value)
public int get_DefaultMaximumErrorResponseLength()
public void set_DefaultMaximumErrorResponseLength(int value)
public string get_Expect()
public void set_Expect(string value)
public bool get_HaveResponse()
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public string get_Host()
public void set_Host(string value)
private bool CheckValidHost(string scheme, string val)
public DateTime get_IfModifiedSince()
public void set_IfModifiedSince(DateTime value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public int get_MaximumAutomaticRedirections()
public void set_MaximumAutomaticRedirections(int value)
public int get_MaximumResponseHeadersLength()
public void set_MaximumResponseHeadersLength(int value)
public int get_DefaultMaximumResponseHeadersLength()
public void set_DefaultMaximumResponseHeadersLength(int value)
public int get_ReadWriteTimeout()
public void set_ReadWriteTimeout(int value)
public int get_ContinueTimeout()
public void set_ContinueTimeout(int value)
public string get_MediaType()
public void set_MediaType(string value)
public string get_Method()
public void set_Method(string value)
public bool get_Pipelined()
public void set_Pipelined(bool value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public Version get_ProtocolVersion()
public void set_ProtocolVersion(Version value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public string get_Referer()
public void set_Referer(string value)
public Uri get_RequestUri()
public bool get_SendChunked()
public void set_SendChunked(bool value)
public ServicePoint get_ServicePoint()
internal ServicePoint get_ServicePointNoLock()
public bool get_SupportsCookieContainer()
public int get_Timeout()
public void set_Timeout(int value)
public string get_TransferEncoding()
public void set_TransferEncoding(string value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public string get_UserAgent()
public void set_UserAgent(string value)
public bool get_UnsafeAuthenticatedConnectionSharing()
public void set_UnsafeAuthenticatedConnectionSharing(bool value)
internal bool get_GotRequestStream()
internal bool get_ExpectContinue()
internal void set_ExpectContinue(bool value)
internal Uri get_AuthUri()
internal bool get_ProxyQuery()
internal ServerCertValidationCallback get_ServerCertValidationCallback()
public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback()
public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value)
internal ServicePoint GetServicePoint()
public void AddRange(int range)
public void AddRange(int from, int to)
public void AddRange(string rangeSpecifier, int range)
public void AddRange(string rangeSpecifier, int from, int to)
public void AddRange(long range)
public void AddRange(long from, long to)
public void AddRange(string rangeSpecifier, long range)
public void AddRange(string rangeSpecifier, long from, long to)
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public Stream GetRequestStream()
public Stream GetRequestStream(TransportContext& context)
private bool CheckIfForceWrite(SimpleAsyncResult result)
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public Stream EndGetRequestStream(IAsyncResult asyncResult, TransportContext& context)
public WebResponse GetResponse()
internal bool get_FinishedReading()
internal void set_FinishedReading(bool value)
internal bool get_Aborted()
public void Abort()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void CheckRequestStarted()
internal void DoContinueDelegate(int statusCode, WebHeaderCollection headers)
private void RewriteRedirectToGet()
private bool Redirect(WebAsyncResult result, HttpStatusCode code, WebResponse response)
private string GetHeaders()
private void DoPreAuthenticate()
internal void SetWriteStreamError(WebExceptionStatus status, Exception exc)
internal Byte[] GetRequestHeaders()
internal void SetWriteStream(WebConnectionStream stream)
private void SetWriteStreamInner(SimpleAsyncCallback callback)
private void SetWriteStreamError(Exception exc)
internal void SetResponseError(WebExceptionStatus status, Exception e, string where)
private void CheckSendError(WebConnectionData data)
private bool HandleNtlmAuth(WebAsyncResult r)
internal void SetResponseData(WebConnectionData data)
private bool CheckAuthorization(WebResponse response, HttpStatusCode code)
private bool CheckFinalStatus(WebAsyncResult result)
internal bool get_ReuseConnection()
internal void set_ReuseConnection(bool value)
internal StringBuilder GenerateConnectionGroup(string connectionGroupName, bool unsafeConnectionGroup, bool isInternalGroup)
private void <SetWriteStream>b__261_0(SimpleAsyncResult result)
private void <SetWriteStream>b__261_1(SimpleAsyncResult inner)
private bool <SetWriteStreamInner>b__262_0(SimpleAsyncResult result)
}
public System.Net.HttpWebResponse : WebResponse {
private Uri uri
private WebHeaderCollection webHeaders
private CookieCollection cookieCollection
private string method
private Version version
private HttpStatusCode statusCode
private string statusDescription
private long contentLength
private string contentType
private CookieContainer cookie_container
private bool disposed
private Stream stream
public string CharacterSet
public string ContentEncoding
public long ContentLength
public string ContentType
public CookieCollection Cookies
public WebHeaderCollection Headers
public bool IsMutuallyAuthenticated
public DateTime LastModified
public string Method
public Version ProtocolVersion
public Uri ResponseUri
public string Server
public HttpStatusCode StatusCode
public string StatusDescription
public bool SupportsHeaders
internal void .ctor(Uri uri, string method, WebConnectionData data, CookieContainer container)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public string get_CharacterSet()
public string get_ContentEncoding()
public long get_ContentLength()
public string get_ContentType()
public CookieCollection get_Cookies()
public void set_Cookies(CookieCollection value)
public WebHeaderCollection get_Headers()
private Exception GetMustImplement()
public bool get_IsMutuallyAuthenticated()
public DateTime get_LastModified()
public string get_Method()
public Version get_ProtocolVersion()
public Uri get_ResponseUri()
public string get_Server()
public HttpStatusCode get_StatusCode()
public string get_StatusDescription()
public bool get_SupportsHeaders()
public string GetResponseHeader(string headerName)
internal void ReadAll()
public Stream GetResponseStream()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void Close()
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
private void CheckDisposed()
private void FillCookies()
}
internal System.Net.HttpWriteMode : Enum {
public int value__
public HttpWriteMode Unknown
public HttpWriteMode ContentLength
public HttpWriteMode Chunked
public HttpWriteMode Buffer
public HttpWriteMode None
}
public System.Net.IAuthenticationModule {
public bool CanPreAuthenticate
public string AuthenticationType
public Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest request, ICredentials credentials)
public bool get_CanPreAuthenticate()
public string get_AuthenticationType()
}
internal System.Net.IAutoWebProxy {
public ProxyChain GetProxies(Uri destination)
}
public System.Net.ICertificatePolicy {
public bool CheckValidationResult(ServicePoint srvPoint, X509Certificate certificate, WebRequest request, int certificateProblem)
}
internal System.Net.ICloseEx {
public void CloseEx(CloseExState closeState)
}
public System.Net.ICredentialPolicy {
public bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule)
}
public System.Net.ICredentials {
public NetworkCredential GetCredential(Uri uri, string authType)
}
public System.Net.ICredentialsByHost {
public NetworkCredential GetCredential(string host, int port, string authenticationType)
}
internal System.Net.IgnoreCertProblem : Enum {
public int value__
public IgnoreCertProblem not_time_valid
public IgnoreCertProblem ctl_not_time_valid
public IgnoreCertProblem not_time_nested
public IgnoreCertProblem invalid_basic_constraints
public IgnoreCertProblem all_not_time_valid
public IgnoreCertProblem allow_unknown_ca
public IgnoreCertProblem wrong_usage
public IgnoreCertProblem invalid_name
public IgnoreCertProblem invalid_policy
public IgnoreCertProblem end_rev_unknown
public IgnoreCertProblem ctl_signer_rev_unknown
public IgnoreCertProblem ca_rev_unknown
public IgnoreCertProblem root_rev_unknown
public IgnoreCertProblem all_rev_unknown
public IgnoreCertProblem none
}
internal System.Net.InterlockedGate : ValueType {
private int m_State
internal int Open
internal int Triggering
internal int Triggered
internal int Signaling
internal int Signaled
internal int Completed
internal void Reset()
internal bool Trigger(bool exclusive)
internal bool StartTriggering(bool exclusive)
internal void FinishTriggering()
internal bool StartSignaling(bool exclusive)
internal void FinishSignaling()
internal bool Complete()
}
internal System.Net.InterlockedStack : object {
private Stack _stack
internal void Push(object pooledStream)
internal object Pop()
}
internal System.Net.InternalException : SystemException {
internal void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.Net.IntPtrHelper : object {
internal IntPtr Add(IntPtr a, int b)
internal long Subtract(IntPtr a, IntPtr b)
}
public System.Net.IPAddress : object {
public IPAddress Any
public IPAddress Loopback
public IPAddress Broadcast
public IPAddress None
internal long LoopbackMask
internal long m_Address
internal string m_ToString
public IPAddress IPv6Any
public IPAddress IPv6Loopback
public IPAddress IPv6None
private AddressFamily m_Family
private UInt16[] m_Numbers
private long m_ScopeId
private int m_HashCode
internal int IPv4AddressBytes
internal int IPv6AddressBytes
internal int NumberOfLabels
public long Address
public AddressFamily AddressFamily
public long ScopeId
internal bool IsBroadcast
public bool IsIPv6Multicast
public bool IsIPv6LinkLocal
public bool IsIPv6SiteLocal
public bool IsIPv6Teredo
public bool IsIPv4MappedToIPv6
public void .ctor(long newAddress)
public void .ctor(Byte[] address, long scopeid)
private void .ctor(UInt16[] address, UInt32 scopeid)
public void .ctor(Byte[] address)
internal void .ctor(int newAddress)
public bool TryParse(string ipString, IPAddress& address)
public IPAddress Parse(string ipString)
private IPAddress InternalParse(string ipString, bool tryParse)
public long get_Address()
public void set_Address(long value)
public Byte[] GetAddressBytes()
public AddressFamily get_AddressFamily()
public long get_ScopeId()
public void set_ScopeId(long value)
public string ToString()
public long HostToNetworkOrder(long host)
public int HostToNetworkOrder(int host)
public short HostToNetworkOrder(short host)
public long NetworkToHostOrder(long network)
public int NetworkToHostOrder(int network)
public short NetworkToHostOrder(short network)
public bool IsLoopback(IPAddress address)
internal bool get_IsBroadcast()
public bool get_IsIPv6Multicast()
public bool get_IsIPv6LinkLocal()
public bool get_IsIPv6SiteLocal()
public bool get_IsIPv6Teredo()
public bool get_IsIPv4MappedToIPv6()
internal bool Equals(object comparandObj, bool compareScopeId)
public bool Equals(object comparand)
public int GetHashCode()
internal IPAddress Snapshot()
public IPAddress MapToIPv6()
public IPAddress MapToIPv4()
}
public System.Net.IPEndPoint : EndPoint {
public int MinPort
public int MaxPort
private IPAddress m_Address
private int m_Port
internal int AnyPort
internal IPEndPoint Any
internal IPEndPoint IPv6Any
public AddressFamily AddressFamily
public IPAddress Address
public int Port
public AddressFamily get_AddressFamily()
public void .ctor(long address, int port)
public void .ctor(IPAddress address, int port)
public IPAddress get_Address()
public void set_Address(IPAddress value)
public int get_Port()
public void set_Port(int value)
public string ToString()
public SocketAddress Serialize()
public EndPoint Create(SocketAddress socketAddress)
public bool Equals(object comparand)
public int GetHashCode()
internal IPEndPoint Snapshot()
}
public System.Net.IPHostEntry : object {
private string hostName
private String[] aliases
private IPAddress[] addressList
internal bool isTrustedHost
public string HostName
public String[] Aliases
public IPAddress[] AddressList
public string get_HostName()
public void set_HostName(string value)
public String[] get_Aliases()
public void set_Aliases(String[] value)
public IPAddress[] get_AddressList()
public void set_AddressList(IPAddress[] value)
}
internal System.Net.IPv6AddressFormatter : ValueType {
private UInt16[] address
private long scopeId
public void .ctor(UInt16[] addr, long scopeId)
private ushort SwapUShort(ushort number)
private UInt32 AsIPv4Int()
private bool IsIPv4Compatible()
private bool IsIPv4Mapped()
public string ToString()
}
internal System.Net.IWebConnectionState {
public WebConnectionGroup Group
public ServicePoint ServicePoint
public bool Busy
public DateTime IdleSince
public WebConnectionGroup get_Group()
public ServicePoint get_ServicePoint()
public bool get_Busy()
public DateTime get_IdleSince()
public bool TrySetBusy()
public void SetIdle()
}
public System.Net.IWebProxy {
public ICredentials Credentials
public Uri GetProxy(Uri destination)
public bool IsBypassed(Uri host)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
}
internal System.Net.IWebProxyFinder {
public bool IsValid
public bool GetProxies(Uri destination, IList`1& proxyList)
public void Abort()
public void Reset()
public bool get_IsValid()
}
public System.Net.IWebProxyScript {
public void Close()
public bool Load(Uri scriptLocation, string script, Type helperType)
public string Run(string url, string host)
}
public System.Net.IWebRequestCreate {
public WebRequest Create(Uri uri)
}
internal System.Net.KnownHttpVerb : object {
internal string Name
internal bool RequireContentBody
internal bool ContentBodyNotAllowed
internal bool ConnectRequest
internal bool ExpectNoContentResponse
private ListDictionary NamedHeaders
internal KnownHttpVerb Get
internal KnownHttpVerb Connect
internal KnownHttpVerb Head
internal KnownHttpVerb Put
internal KnownHttpVerb Post
internal KnownHttpVerb MkCol
internal void .ctor(string name, bool requireContentBody, bool contentBodyNotAllowed, bool connectRequest, bool expectNoContentResponse)
public bool Equals(KnownHttpVerb verb)
public KnownHttpVerb Parse(string name)
}
internal System.Net.LazyAsyncResult : object {
private int c_HighBit
private int c_ForceAsyncCount
private ThreadContext t_ThreadContext
private object m_AsyncObject
private object m_AsyncState
private AsyncCallback m_AsyncCallback
private object m_Result
private int m_ErrorCode
private int m_IntCompleted
private bool m_EndCalled
private bool m_UserEvent
private object m_Event
private ThreadContext CurrentThreadContext
internal object AsyncObject
public object AsyncState
protected AsyncCallback AsyncCallback
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
internal bool InternalPeekCompleted
internal object Result
internal bool EndCalled
internal int ErrorCode
private ThreadContext get_CurrentThreadContext()
internal void .ctor(object myObject, object myState, AsyncCallback myCallBack)
internal void .ctor(object myObject, object myState, AsyncCallback myCallBack, object result)
internal object get_AsyncObject()
public object get_AsyncState()
protected AsyncCallback get_AsyncCallback()
protected void set_AsyncCallback(AsyncCallback value)
public WaitHandle get_AsyncWaitHandle()
private bool LazilyCreateEvent(ManualResetEvent& waitHandle)
protected void DebugProtectState(bool protect)
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
internal bool get_InternalPeekCompleted()
internal object get_Result()
internal void set_Result(object value)
internal bool get_EndCalled()
internal void set_EndCalled(bool value)
internal int get_ErrorCode()
internal void set_ErrorCode(int value)
protected void ProtectedInvokeCallback(object result, IntPtr userToken)
internal void InvokeCallback(object result)
internal void InvokeCallback()
protected void Complete(IntPtr userToken)
private void WorkerThreadComplete(object state)
protected void Cleanup()
internal object InternalWaitForCompletion()
private object WaitForCompletion(bool snap)
internal void InternalCleanup()
}
internal System.Net.ListenerAsyncResult : object {
private ManualResetEvent handle
private bool synch
private bool completed
private AsyncCallback cb
private object state
private Exception exception
private HttpListenerContext context
private object locker
private ListenerAsyncResult forward
internal bool EndCalled
internal bool InGet
private WaitCallback InvokeCB
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public void .ctor(AsyncCallback cb, object state)
internal void Complete(Exception exc)
private void InvokeCallback(object o)
internal void Complete(HttpListenerContext context)
internal void Complete(HttpListenerContext context, bool synch)
internal HttpListenerContext GetContext()
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
}
internal System.Net.ListenerPrefix : object {
private string original
private string host
private ushort port
private string path
private bool secure
private IPAddress[] addresses
public HttpListener Listener
public IPAddress[] Addresses
public bool Secure
public string Host
public int Port
public string Path
public void .ctor(string prefix)
public string ToString()
public IPAddress[] get_Addresses()
public void set_Addresses(IPAddress[] value)
public bool get_Secure()
public string get_Host()
public int get_Port()
public string get_Path()
public bool Equals(object o)
public int GetHashCode()
private void Parse(string uri)
public void CheckUri(string uri)
}
internal System.Net.Logging : object {
internal bool On
internal TraceSource Web
internal TraceSource HttpListener
internal TraceSource Sockets
internal TraceSource get_Web()
internal TraceSource get_HttpListener()
internal TraceSource get_Sockets()
internal void Enter(TraceSource traceSource, object obj, string method, object paramObject)
internal void Enter(TraceSource traceSource, string msg)
internal void Enter(TraceSource traceSource, string msg, string parameters)
internal void Exception(TraceSource traceSource, object obj, string method, Exception e)
internal void Exit(TraceSource traceSource, object obj, string method, object retObject)
internal void Exit(TraceSource traceSource, string msg)
internal void Exit(TraceSource traceSource, string msg, string parameters)
internal void PrintInfo(TraceSource traceSource, object obj, string method, string msg)
internal void PrintInfo(TraceSource traceSource, object obj, string msg)
internal void PrintInfo(TraceSource traceSource, string msg)
internal void PrintWarning(TraceSource traceSource, object obj, string method, string msg)
internal void PrintWarning(TraceSource traceSource, string msg)
internal void PrintError(TraceSource traceSource, string msg)
}
public System.Net.Mail.AlternateView : AttachmentBase {
private Uri baseUri
private LinkedResourceCollection linkedResources
public Uri BaseUri
public LinkedResourceCollection LinkedResources
public void .ctor(string fileName)
public void .ctor(string fileName, ContentType contentType)
public void .ctor(string fileName, string mediaType)
public void .ctor(Stream contentStream)
public void .ctor(Stream contentStream, string mediaType)
public void .ctor(Stream contentStream, ContentType contentType)
public Uri get_BaseUri()
public void set_BaseUri(Uri value)
public LinkedResourceCollection get_LinkedResources()
public AlternateView CreateAlternateViewFromString(string content)
public AlternateView CreateAlternateViewFromString(string content, ContentType contentType)
public AlternateView CreateAlternateViewFromString(string content, Encoding contentEncoding, string mediaType)
protected void Dispose(bool disposing)
}
public System.Net.Mail.AlternateViewCollection : Collection`1<AlternateView> {
public void Dispose()
protected void ClearItems()
protected void InsertItem(int index, AlternateView item)
protected void RemoveItem(int index)
protected void SetItem(int index, AlternateView item)
}
public System.Net.Mail.Attachment : AttachmentBase {
private ContentDisposition contentDisposition
private Encoding nameEncoding
public ContentDisposition ContentDisposition
public string Name
public Encoding NameEncoding
public void .ctor(string fileName)
public void .ctor(string fileName, string mediaType)
public void .ctor(string fileName, ContentType contentType)
public void .ctor(Stream contentStream, ContentType contentType)
public void .ctor(Stream contentStream, string name)
public void .ctor(Stream contentStream, string name, string mediaType)
public ContentDisposition get_ContentDisposition()
public string get_Name()
public void set_Name(string value)
public Encoding get_NameEncoding()
public void set_NameEncoding(Encoding value)
public Attachment CreateAttachmentFromString(string content, ContentType contentType)
public Attachment CreateAttachmentFromString(string content, string name)
public Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType)
private void InitName(string fileName)
}
public System.Net.Mail.AttachmentBase : object {
private string id
private ContentType contentType
private Stream contentStream
private TransferEncoding transferEncoding
public string ContentId
public Stream ContentStream
public ContentType ContentType
public TransferEncoding TransferEncoding
protected void .ctor(Stream contentStream)
protected void .ctor(Stream contentStream, ContentType contentType)
protected void .ctor(Stream contentStream, string mediaType)
protected void .ctor(string fileName)
protected void .ctor(string fileName, ContentType contentType)
protected void .ctor(string fileName, string mediaType)
public string get_ContentId()
public void set_ContentId(string value)
public Stream get_ContentStream()
public ContentType get_ContentType()
public void set_ContentType(ContentType value)
public TransferEncoding get_TransferEncoding()
public void set_TransferEncoding(TransferEncoding value)
public void Dispose()
protected void Dispose(bool disposing)
}
public System.Net.Mail.AttachmentCollection : Collection`1<Attachment> {
public void Dispose()
protected void ClearItems()
protected void InsertItem(int index, Attachment item)
protected void RemoveItem(int index)
protected void SetItem(int index, Attachment item)
}
internal System.Net.Mail.BufferBuilder : object {
private Byte[] buffer
private int offset
internal int Length
internal void .ctor(int initialSize)
private void EnsureBuffer(int count)
internal void Append(byte value)
internal void Append(Byte[] value)
internal void Append(Byte[] value, int offset, int count)
internal void Append(string value)
internal void Append(string value, bool allowUnicode)
internal void Append(string value, int offset, int count, bool allowUnicode)
internal void Append(string value, int offset, int count)
internal int get_Length()
internal Byte[] GetBuffer()
internal void Reset()
}
internal System.Net.Mail.CCredentialsByHost : object {
private string userName
private string password
public void .ctor(string userName, string password)
public NetworkCredential GetCredential(string host, int port, string authenticationType)
}
public System.Net.Mail.DeliveryNotificationOptions : Enum {
public int value__
public DeliveryNotificationOptions None
public DeliveryNotificationOptions OnSuccess
public DeliveryNotificationOptions OnFailure
public DeliveryNotificationOptions Delay
public DeliveryNotificationOptions Never
}
public System.Net.Mail.LinkedResource : AttachmentBase {
private Uri contentLink
public Uri ContentLink
public void .ctor(string fileName)
public void .ctor(string fileName, ContentType contentType)
public void .ctor(string fileName, string mediaType)
public void .ctor(Stream contentStream)
public void .ctor(Stream contentStream, ContentType contentType)
public void .ctor(Stream contentStream, string mediaType)
public Uri get_ContentLink()
public void set_ContentLink(Uri value)
public LinkedResource CreateLinkedResourceFromString(string content)
public LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType)
public LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType)
}
public System.Net.Mail.LinkedResourceCollection : Collection`1<LinkedResource> {
public void Dispose()
private void Dispose(bool disposing)
protected void ClearItems()
protected void InsertItem(int index, LinkedResource item)
protected void RemoveItem(int index)
protected void SetItem(int index, LinkedResource item)
}
public System.Net.Mail.MailAddress : object {
private string address
private string displayName
private string host
private string user
private string to_string
public string Address
public string DisplayName
public string Host
public string User
public void .ctor(string address)
public void .ctor(string address, string displayName)
public void .ctor(string address, string displayName, Encoding displayNameEncoding)
private void ParseAddress(string address)
public string get_Address()
public string get_DisplayName()
public string get_Host()
public string get_User()
public bool Equals(object value)
public int GetHashCode()
public string ToString()
private FormatException CreateFormatException()
}
public System.Net.Mail.MailAddressCollection : Collection`1<MailAddress> {
public void Add(string addresses)
protected void InsertItem(int index, MailAddress item)
protected void SetItem(int index, MailAddress item)
public string ToString()
}
internal System.Net.Mail.MailHeaderID : Enum {
public int value__
public MailHeaderID Bcc
public MailHeaderID Cc
public MailHeaderID Comments
public MailHeaderID ContentDescription
public MailHeaderID ContentDisposition
public MailHeaderID ContentID
public MailHeaderID ContentLocation
public MailHeaderID ContentTransferEncoding
public MailHeaderID ContentType
public MailHeaderID Date
public MailHeaderID From
public MailHeaderID Importance
public MailHeaderID InReplyTo
public MailHeaderID Keywords
public MailHeaderID Max
public MailHeaderID MessageID
public MailHeaderID MimeVersion
public MailHeaderID Priority
public MailHeaderID References
public MailHeaderID ReplyTo
public MailHeaderID ResentBcc
public MailHeaderID ResentCc
public MailHeaderID ResentDate
public MailHeaderID ResentFrom
public MailHeaderID ResentMessageID
public MailHeaderID ResentSender
public MailHeaderID ResentTo
public MailHeaderID Sender
public MailHeaderID Subject
public MailHeaderID To
public MailHeaderID XPriority
public MailHeaderID XReceiver
public MailHeaderID XSender
public MailHeaderID ZMaxEnumValue
public MailHeaderID Unknown
}
internal System.Net.Mail.MailHeaderInfo : object {
private HeaderInfo[] m_HeaderInfo
private Dictionary`2<string, int> m_HeaderDictionary
internal string GetString(MailHeaderID id)
internal MailHeaderID GetID(string name)
internal bool IsWellKnown(string name)
internal bool IsUserSettable(string name)
internal bool IsSingleton(string name)
internal string NormalizeCase(string name)
internal bool IsMatch(string name, MailHeaderID header)
internal bool AllowsUnicode(string name)
}
public System.Net.Mail.MailMessage : object {
private AlternateViewCollection alternateViews
private AttachmentCollection attachments
private MailAddressCollection bcc
private MailAddressCollection replyTo
private string body
private MailPriority priority
private MailAddress sender
private DeliveryNotificationOptions deliveryNotificationOptions
private MailAddressCollection cc
private MailAddress from
private NameValueCollection headers
private MailAddressCollection to
private string subject
private Encoding subjectEncoding
private Encoding bodyEncoding
private Encoding headersEncoding
private bool isHtml
private Char[] hex
private Encoding utf8unmarked
public AlternateViewCollection AlternateViews
public AttachmentCollection Attachments
public MailAddressCollection Bcc
public string Body
internal ContentType BodyContentType
internal TransferEncoding ContentTransferEncoding
public Encoding BodyEncoding
public TransferEncoding BodyTransferEncoding
public MailAddressCollection CC
public DeliveryNotificationOptions DeliveryNotificationOptions
public MailAddress From
public NameValueCollection Headers
public bool IsBodyHtml
public MailPriority Priority
public Encoding HeadersEncoding
public MailAddressCollection ReplyToList
public MailAddress ReplyTo
public MailAddress Sender
public string Subject
public Encoding SubjectEncoding
public MailAddressCollection To
private Encoding UTF8Unmarked
public void .ctor(MailAddress from, MailAddress to)
public void .ctor(string from, string to)
public void .ctor(string from, string to, string subject, string body)
public AlternateViewCollection get_AlternateViews()
public AttachmentCollection get_Attachments()
public MailAddressCollection get_Bcc()
public string get_Body()
public void set_Body(string value)
internal ContentType get_BodyContentType()
internal TransferEncoding get_ContentTransferEncoding()
public Encoding get_BodyEncoding()
public void set_BodyEncoding(Encoding value)
public TransferEncoding get_BodyTransferEncoding()
public void set_BodyTransferEncoding(TransferEncoding value)
public MailAddressCollection get_CC()
public DeliveryNotificationOptions get_DeliveryNotificationOptions()
public void set_DeliveryNotificationOptions(DeliveryNotificationOptions value)
public MailAddress get_From()
public void set_From(MailAddress value)
public NameValueCollection get_Headers()
public bool get_IsBodyHtml()
public void set_IsBodyHtml(bool value)
public MailPriority get_Priority()
public void set_Priority(MailPriority value)
public Encoding get_HeadersEncoding()
public void set_HeadersEncoding(Encoding value)
public MailAddressCollection get_ReplyToList()
public MailAddress get_ReplyTo()
public void set_ReplyTo(MailAddress value)
public MailAddress get_Sender()
public void set_Sender(MailAddress value)
public string get_Subject()
public void set_Subject(string value)
public Encoding get_SubjectEncoding()
public void set_SubjectEncoding(Encoding value)
public MailAddressCollection get_To()
public void Dispose()
protected void Dispose(bool disposing)
private Encoding GuessEncoding(string s)
internal TransferEncoding GuessTransferEncoding(Encoding enc)
internal string To2047(Byte[] bytes)
internal string EncodeSubjectRFC2047(string s, Encoding enc)
private Encoding get_UTF8Unmarked()
}
public System.Net.Mail.MailPriority : Enum {
public int value__
public MailPriority Normal
public MailPriority Low
public MailPriority High
}
public System.Net.Mail.SendCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AsyncCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.Mail.SmtpAccess : Enum {
public int value__
public SmtpAccess None
public SmtpAccess Connect
public SmtpAccess ConnectToUnrestrictedPort
}
public System.Net.Mail.SmtpClient : object {
private string host
private int port
private int timeout
private ICredentialsByHost credentials
private string pickupDirectoryLocation
private SmtpDeliveryMethod deliveryMethod
private SmtpDeliveryFormat deliveryFormat
private bool enableSsl
private X509CertificateCollection clientCertificates
private TcpClient client
private Stream stream
private StreamWriter writer
private StreamReader reader
private int boundaryIndex
private MailAddress defaultFrom
private MailMessage messageInProcess
private BackgroundWorker worker
private object user_async_state
private AuthMechs authMechs
private Mutex mutex
private string <TargetName>k__BackingField
private SendCompletedEventHandler SendCompleted
public X509CertificateCollection ClientCertificates
public string TargetName
public ICredentialsByHost Credentials
public SmtpDeliveryMethod DeliveryMethod
public bool EnableSsl
public string Host
public string PickupDirectoryLocation
public int Port
public SmtpDeliveryFormat DeliveryFormat
public ServicePoint ServicePoint
public int Timeout
public bool UseDefaultCredentials
public void .ctor(string host)
public void .ctor(string host, int port)
public X509CertificateCollection get_ClientCertificates()
public string get_TargetName()
public void set_TargetName(string value)
public ICredentialsByHost get_Credentials()
public void set_Credentials(ICredentialsByHost value)
public SmtpDeliveryMethod get_DeliveryMethod()
public void set_DeliveryMethod(SmtpDeliveryMethod value)
public bool get_EnableSsl()
public void set_EnableSsl(bool value)
public string get_Host()
public void set_Host(string value)
public string get_PickupDirectoryLocation()
public void set_PickupDirectoryLocation(string value)
public int get_Port()
public void set_Port(int value)
public SmtpDeliveryFormat get_DeliveryFormat()
public void set_DeliveryFormat(SmtpDeliveryFormat value)
public ServicePoint get_ServicePoint()
public int get_Timeout()
public void set_Timeout(int value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public void add_SendCompleted(SendCompletedEventHandler value)
public void remove_SendCompleted(SendCompletedEventHandler value)
public void Dispose()
protected void Dispose(bool disposing)
private void CheckState()
private string EncodeAddress(MailAddress address)
private string EncodeAddresses(MailAddressCollection addresses)
private string EncodeSubjectRFC2047(MailMessage message)
private string EncodeBody(MailMessage message)
private string EncodeBody(AlternateView av)
private void EndSection(string section)
private string GenerateBoundary()
private string GenerateBoundary(int index)
private bool IsError(SmtpResponse status)
protected void OnSendCompleted(AsyncCompletedEventArgs e)
private void CheckCancellation()
private SmtpResponse Read()
private void ResetExtensions()
private void ParseExtensions(string extens)
public void Send(MailMessage message)
private void SendInternal(MailMessage message)
private void SendToFile(MailMessage message)
private void SendCore(MailMessage message)
public void Send(string from, string recipients, string subject, string body)
public Task SendMailAsync(MailMessage message)
public Task SendMailAsync(string from, string recipients, string subject, string body)
private void SendMailAsyncCompletedHandler(TaskCompletionSource`1<object> source, AsyncCompletedEventArgs e, SendCompletedEventHandler handler, SmtpClient client)
private void SendDot()
private void SendData(string data)
public void SendAsync(MailMessage message, object userToken)
public void SendAsync(string from, string recipients, string subject, string body, object userToken)
public void SendAsyncCancel()
private void AddPriorityHeader(MailMessage message)
private void SendSimpleBody(MailMessage message)
private void SendBodylessSingleAlternate(AlternateView av)
private void SendWithoutAttachments(MailMessage message, string boundary, bool attachmentExists)
private void SendWithAttachments(MailMessage message)
private void SendBodyWithAlternateViews(MailMessage message, string boundary, bool attachmentExists)
private void SendLinkedResources(MailMessage message, LinkedResourceCollection resources, string boundary)
private void SendAttachments(MailMessage message, Attachment body, string boundary)
private SmtpResponse SendCommand(string command)
private void SendHeader(string name, string value)
private void StartSection(string section, ContentType sectionContentType)
private void StartSection(string section, ContentType sectionContentType, AttachmentBase att)
private void StartSection(string section, ContentType sectionContentType, Attachment att, bool sendDisposition)
private string ToQuotedPrintable(string input, Encoding enc)
private string ToQuotedPrintable(Byte[] bytes)
private string GetTransferEncodingName(TransferEncoding encoding)
private void InitiateSecureConnection()
private void Authenticate()
private void CheckStatus(SmtpResponse status, int i)
private void ThrowIfError(SmtpResponse status)
private void Authenticate(string user, string password)
}
public System.Net.Mail.SmtpDeliveryFormat : Enum {
public int value__
public SmtpDeliveryFormat SevenBit
public SmtpDeliveryFormat International
}
public System.Net.Mail.SmtpDeliveryMethod : Enum {
public int value__
public SmtpDeliveryMethod Network
public SmtpDeliveryMethod SpecifiedPickupDirectory
public SmtpDeliveryMethod PickupDirectoryFromIis
}
public System.Net.Mail.SmtpException : Exception {
private SmtpStatusCode statusCode
public SmtpStatusCode StatusCode
public void .ctor(SmtpStatusCode statusCode)
public void .ctor(string message)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void .ctor(SmtpStatusCode statusCode, string message)
public void .ctor(string message, Exception innerException)
public SmtpStatusCode get_StatusCode()
public void set_StatusCode(SmtpStatusCode value)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Net.Mail.SmtpFailedRecipientException : SmtpException {
private string failedRecipient
public string FailedRecipient
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(SmtpStatusCode statusCode, string failedRecipient)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string failedRecipient, Exception innerException)
public void .ctor(SmtpStatusCode statusCode, string failedRecipient, string serverResponse)
public string get_FailedRecipient()
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Net.Mail.SmtpFailedRecipientsException : SmtpFailedRecipientException {
private SmtpFailedRecipientException[] innerExceptions
public SmtpFailedRecipientException[] InnerExceptions
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, SmtpFailedRecipientException[] innerExceptions)
protected void .ctor(SerializationInfo info, StreamingContext context)
public SmtpFailedRecipientException[] get_InnerExceptions()
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Net.Mail.SmtpPermission : CodeAccessPermission {
private int version
private bool unrestricted
private SmtpAccess access
public SmtpAccess Access
public void .ctor(bool unrestricted)
public void .ctor(PermissionState state)
public void .ctor(SmtpAccess access)
public SmtpAccess get_Access()
public void AddPermission(SmtpAccess access)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public void FromXml(SecurityElement securityElement)
public IPermission Union(IPermission target)
private bool IsEmpty()
private SmtpPermission Cast(IPermission target)
}
public System.Net.Mail.SmtpPermissionAttribute : CodeAccessSecurityAttribute {
private string access
public string Access
public void .ctor(SecurityAction action)
public string get_Access()
public void set_Access(string value)
private SmtpAccess GetSmtpAccess()
public IPermission CreatePermission()
}
public System.Net.Mail.SmtpStatusCode : Enum {
public int value__
public SmtpStatusCode BadCommandSequence
public SmtpStatusCode CannotVerifyUserWillAttemptDelivery
public SmtpStatusCode ClientNotPermitted
public SmtpStatusCode CommandNotImplemented
public SmtpStatusCode CommandParameterNotImplemented
public SmtpStatusCode CommandUnrecognized
public SmtpStatusCode ExceededStorageAllocation
public SmtpStatusCode GeneralFailure
public SmtpStatusCode HelpMessage
public SmtpStatusCode InsufficientStorage
public SmtpStatusCode LocalErrorInProcessing
public SmtpStatusCode MailboxBusy
public SmtpStatusCode MailboxNameNotAllowed
public SmtpStatusCode MailboxUnavailable
public SmtpStatusCode Ok
public SmtpStatusCode ServiceClosingTransmissionChannel
public SmtpStatusCode ServiceNotAvailable
public SmtpStatusCode ServiceReady
public SmtpStatusCode StartMailInput
public SmtpStatusCode SyntaxError
public SmtpStatusCode SystemStatus
public SmtpStatusCode TransactionFailed
public SmtpStatusCode UserNotLocalTryAlternatePath
public SmtpStatusCode UserNotLocalWillForward
public SmtpStatusCode MustIssueStartTlsFirst
}
internal System.Net.Mime.Base64WriteStateInfo : WriteStateInfoBase {
private int <Padding>k__BackingField
private byte <LastBits>k__BackingField
internal int Padding
internal byte LastBits
internal void .ctor(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength)
internal int get_Padding()
internal void set_Padding(int value)
internal byte get_LastBits()
internal void set_LastBits(byte value)
}
internal System.Net.Mime.BaseWriter : object {
private int DefaultLineLength
private AsyncCallback onWrite
protected Byte[] CRLF
protected BufferBuilder bufferBuilder
protected Stream contentStream
protected bool isInContent
protected Stream stream
private int lineLength
private EventHandler onCloseHandler
private bool shouldEncodeLeadingDots
protected void .ctor(Stream stream, bool shouldEncodeLeadingDots)
internal void WriteHeaders(NameValueCollection headers, bool allowUnicode)
internal void WriteHeader(string name, string value, bool allowUnicode)
private void WriteAndFold(string value, int charsAlreadyOnLine, bool allowUnicode)
internal Stream GetContentStream()
private Stream GetContentStream(MultiAsyncResult multiResult)
internal IAsyncResult BeginGetContentStream(AsyncCallback callback, object state)
internal Stream EndGetContentStream(IAsyncResult result)
protected void Flush(MultiAsyncResult multiResult)
protected void OnWrite(IAsyncResult result)
internal void Close()
protected void OnClose(object sender, EventArgs args)
protected void CheckBoundary()
}
public System.Net.Mime.ContentDisposition : object {
private string dispositionType
private TrackingValidationObjectDictionary parameters
private bool isChanged
private bool isPersisted
private string disposition
private string creationDate
private string readDate
private string modificationDate
private string size
private string fileName
private ValidateAndParseValue dateParser
private ValidateAndParseValue longParser
private IDictionary`2<string, ValidateAndParseValue> validators
public string DispositionType
public StringDictionary Parameters
public string FileName
public DateTime CreationDate
public DateTime ModificationDate
public bool Inline
public DateTime ReadDate
public long Size
internal bool IsChanged
public void .ctor(string disposition)
internal DateTime GetDateParameter(string parameterName)
public string get_DispositionType()
public void set_DispositionType(string value)
public StringDictionary get_Parameters()
public string get_FileName()
public void set_FileName(string value)
public DateTime get_CreationDate()
public void set_CreationDate(DateTime value)
public DateTime get_ModificationDate()
public void set_ModificationDate(DateTime value)
public bool get_Inline()
public void set_Inline(bool value)
public DateTime get_ReadDate()
public void set_ReadDate(DateTime value)
public long get_Size()
public void set_Size(long value)
internal void Set(string contentDisposition, HeaderCollection headers)
internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist)
internal bool get_IsChanged()
public string ToString()
internal string Encode(bool allowUnicode)
private void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode)
public bool Equals(object rparam)
public int GetHashCode()
private void ParseValue()
}
public System.Net.Mime.ContentType : object {
private string mediaType
private string subType
private bool isChanged
private string type
private bool isPersisted
private TrackingStringDictionary parameters
internal string Default
public string Boundary
public string CharSet
public string MediaType
public string Name
public StringDictionary Parameters
internal bool IsChanged
public void .ctor(string contentType)
public string get_Boundary()
public void set_Boundary(string value)
public string get_CharSet()
public void set_CharSet(string value)
public string get_MediaType()
public void set_MediaType(string value)
public string get_Name()
public void set_Name(string value)
public StringDictionary get_Parameters()
internal void Set(string contentType, HeaderCollection headers)
internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist)
internal bool get_IsChanged()
public string ToString()
internal string Encode(bool allowUnicode)
private void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode)
public bool Equals(object rparam)
public int GetHashCode()
private void ParseValue()
}
public System.Net.Mime.DispositionTypeNames : object {
public string Inline
public string Attachment
}
internal System.Net.Mime.EightBitStream : DelegatedStream {
private WriteStateInfoBase writeState
private bool shouldEncodeLeadingDots
private WriteStateInfoBase WriteState
private WriteStateInfoBase get_WriteState()
internal void .ctor(Stream stream)
internal void .ctor(Stream stream, bool shouldEncodeLeadingDots)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
public void Write(Byte[] buffer, int offset, int count)
private void EncodeLines(Byte[] buffer, int offset, int count)
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
public Stream GetStream()
public string GetEncodedString()
}
internal System.Net.Mime.EncodedStreamFactory : object {
private int defaultMaxLineLength
private int initialBufferSize
internal int DefaultMaxLineLength
internal int get_DefaultMaxLineLength()
internal IEncodableStream GetEncoder(TransferEncoding encoding, Stream stream)
internal IEncodableStream GetEncoderForHeader(Encoding encoding, bool useBase64Encoding, int headerTextLength)
protected Byte[] CreateHeader(Encoding encoding, bool useBase64Encoding)
protected Byte[] CreateFooter()
}
internal System.Net.Mime.HeaderCollection : NameValueCollection {
private MimeBasePart part
public void Remove(string name)
public string Get(string name)
public String[] GetValues(string name)
internal void InternalRemove(string name)
internal void InternalSet(string name, string value)
internal void InternalAdd(string name, string value)
public void Set(string name, string value)
public void Add(string name, string value)
}
internal System.Net.Mime.IEncodableStream {
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
public string GetEncodedString()
public Stream GetStream()
}
internal System.Net.Mime.MailBnfHelper : object {
internal Boolean[] Atext
internal Boolean[] Qtext
internal Boolean[] Dtext
internal Boolean[] Ftext
internal Boolean[] Ttext
internal Boolean[] Ctext
internal int Ascii7bitMaxValue
internal char Quote
internal char Space
internal char Tab
internal char CR
internal char LF
internal char StartComment
internal char EndComment
internal char Backslash
internal char At
internal char EndAngleBracket
internal char StartAngleBracket
internal char StartSquareBracket
internal char EndSquareBracket
internal char Comma
internal char Dot
internal IList`1<char> Whitespace
private String[] s_months
internal bool SkipCFWS(string data, Int32& offset)
internal void ValidateHeaderName(string data)
internal string ReadQuotedString(string data, Int32& offset, StringBuilder builder)
internal string ReadQuotedString(string data, Int32& offset, StringBuilder builder, bool doesntRequireQuotes, bool permitUnicodeInDisplayName)
internal string ReadParameterAttribute(string data, Int32& offset, StringBuilder builder)
internal string ReadToken(string data, Int32& offset, StringBuilder builder)
internal string GetDateTimeString(DateTime value, StringBuilder builder)
internal void GetTokenOrQuotedString(string data, StringBuilder builder, bool allowUnicode)
private bool CheckForUnicode(char ch, bool allowUnicode)
internal bool HasCROrLF(string data)
internal bool IsFWSAt(string data, int index)
}
internal System.Net.Mime.MimeBasePart : object {
protected ContentType contentType
protected ContentDisposition contentDisposition
private HeaderCollection headers
internal string defaultCharSet
internal string ContentID
internal string ContentLocation
internal NameValueCollection Headers
internal ContentType ContentType
internal bool ShouldUseBase64Encoding(Encoding encoding)
internal string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding)
internal string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding, int headerLength)
internal string DecodeHeaderValue(string value)
internal Encoding DecodeEncoding(string value)
internal bool IsAscii(string value, bool permitCROrLF)
internal bool IsAnsi(string value, bool permitCROrLF)
internal string get_ContentID()
internal void set_ContentID(string value)
internal string get_ContentLocation()
internal void set_ContentLocation(string value)
internal NameValueCollection get_Headers()
internal ContentType get_ContentType()
internal void set_ContentType(ContentType value)
internal void PrepareHeaders(bool allowUnicode)
internal void Send(BaseWriter writer, bool allowUnicode)
internal IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state)
internal void EndSend(IAsyncResult asyncResult)
}
internal System.Net.Mime.MimeMultiPart : MimeBasePart {
private Collection`1<MimeBasePart> parts
private int boundary
private AsyncCallback mimePartSentCallback
private bool allowUnicode
internal MimeMultiPartType MimeMultiPartType
internal Collection`1<MimeBasePart> Parts
internal void .ctor(MimeMultiPartType type)
internal void set_MimeMultiPartType(MimeMultiPartType value)
private void SetType(MimeMultiPartType type)
internal Collection`1<MimeBasePart> get_Parts()
internal void Complete(IAsyncResult result, Exception e)
internal void MimeWriterCloseCallback(IAsyncResult result)
private void MimeWriterCloseCallbackHandler(IAsyncResult result)
internal void MimePartSentCallback(IAsyncResult result)
private void MimePartSentCallbackHandler(IAsyncResult result)
internal void ContentStreamCallback(IAsyncResult result)
private void ContentStreamCallbackHandler(IAsyncResult result)
internal IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state)
internal void Send(BaseWriter writer, bool allowUnicode)
internal string GetNextBoundary()
}
internal System.Net.Mime.MimeMultiPartType : Enum {
public int value__
public MimeMultiPartType Mixed
public MimeMultiPartType Alternative
public MimeMultiPartType Parallel
public MimeMultiPartType Related
public MimeMultiPartType Unknown
}
internal System.Net.Mime.MimePart : MimeBasePart {
private Stream stream
private bool streamSet
private bool streamUsedOnce
private AsyncCallback readCallback
private AsyncCallback writeCallback
private int maxBufferSize
internal Stream Stream
internal ContentDisposition ContentDisposition
internal TransferEncoding TransferEncoding
public void Dispose()
internal Stream get_Stream()
internal ContentDisposition get_ContentDisposition()
internal void set_ContentDisposition(ContentDisposition value)
internal TransferEncoding get_TransferEncoding()
internal void set_TransferEncoding(TransferEncoding value)
internal void SetContent(Stream stream)
internal void SetContent(Stream stream, string name, string mimeType)
internal void SetContent(Stream stream, ContentType contentType)
internal void Complete(IAsyncResult result, Exception e)
internal void ReadCallback(IAsyncResult result)
internal void ReadCallbackHandler(IAsyncResult result)
internal void WriteCallback(IAsyncResult result)
internal void WriteCallbackHandler(IAsyncResult result)
internal Stream GetEncodedStream(Stream stream)
internal void ContentStreamCallbackHandler(IAsyncResult result)
internal void ContentStreamCallback(IAsyncResult result)
internal IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state)
internal void Send(BaseWriter writer, bool allowUnicode)
internal void ResetStream()
}
internal System.Net.Mime.MimeWriter : BaseWriter {
private Byte[] DASHDASH
private Byte[] boundaryBytes
private bool writeBoundary
internal void .ctor(Stream stream, string boundary)
internal void WriteHeaders(NameValueCollection headers, bool allowUnicode)
internal IAsyncResult BeginClose(AsyncCallback callback, object state)
internal void EndClose(IAsyncResult result)
internal void Close()
private void Close(MultiAsyncResult multiResult)
protected void OnClose(object sender, EventArgs args)
protected void CheckBoundary()
}
internal System.Net.Mime.MultiAsyncResult : LazyAsyncResult {
private int outstanding
private object context
internal object Context
internal void .ctor(object context, AsyncCallback callback, object state)
internal object get_Context()
internal void Enter()
internal void Leave()
internal void Leave(object result)
private void Decrement()
private void Increment()
internal void CompleteSequence()
internal object End(IAsyncResult result)
}
internal System.Net.Mime.QEncodedStream : DelegatedStream {
private int sizeOfFoldingCRLF
private Byte[] hexDecodeMap
private Byte[] hexEncodeMap
private ReadStateInfo readState
private WriteStateInfoBase writeState
private ReadStateInfo ReadState
internal WriteStateInfoBase WriteState
internal void .ctor(WriteStateInfoBase wsi)
private ReadStateInfo get_ReadState()
internal WriteStateInfoBase get_WriteState()
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
public Stream GetStream()
public string GetEncodedString()
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
private void FlushInternal()
public void Write(Byte[] buffer, int offset, int count)
}
internal System.Net.Mime.QuotedPrintableStream : DelegatedStream {
private bool encodeCRLF
private int sizeOfSoftCRLF
private int sizeOfEncodedChar
private int sizeOfEncodedCRLF
private int sizeOfNonEncodedCRLF
private Byte[] hexDecodeMap
private Byte[] hexEncodeMap
private int lineLength
private ReadStateInfo readState
private WriteStateInfoBase writeState
private ReadStateInfo ReadState
internal WriteStateInfoBase WriteState
internal void .ctor(Stream stream, int lineLength)
internal void .ctor(Stream stream, bool encodeCRLF)
private ReadStateInfo get_ReadState()
internal WriteStateInfoBase get_WriteState()
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
public Stream GetStream()
public string GetEncodedString()
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
private void FlushInternal()
public void Write(Byte[] buffer, int offset, int count)
}
internal System.Net.Mime.SmtpDateTime : object {
internal string unknownTimeZoneDefaultOffset
internal string utcDefaultTimeZoneOffset
internal int offsetLength
internal int maxMinuteValue
internal string dateFormatWithDayOfWeek
internal string dateFormatWithoutDayOfWeek
internal string dateFormatWithDayOfWeekAndNoSeconds
internal string dateFormatWithoutDayOfWeekAndNoSeconds
internal String[] validDateTimeFormats
internal Char[] allowedWhiteSpaceChars
internal IDictionary`2<string, TimeSpan> timeZoneOffsetLookup
internal long timeSpanMaxTicks
internal int offsetMaxValue
private DateTime date
private TimeSpan timeZone
private bool unknownTimeZone
internal DateTime Date
internal IDictionary`2<string, TimeSpan> InitializeShortHandLookups()
internal void .ctor(DateTime value)
internal void .ctor(string value)
internal DateTime get_Date()
public string ToString()
internal void ValidateAndGetTimeZoneOffsetValues(string offset, Boolean& positive, Int32& hours, Int32& minutes)
internal void ValidateTimeZoneShortHandValue(string value)
internal string FormatDate(DateTime value)
internal DateTime ParseValue(string data, String& timeZone)
internal bool TryParseTimeZoneString(string timeZoneString, TimeSpan& timeZone)
internal TimeSpan ValidateAndGetSanitizedTimeSpan(TimeSpan span)
internal string TimeSpanToOffset(TimeSpan span)
}
public System.Net.Mime.TransferEncoding : Enum {
public int value__
public TransferEncoding QuotedPrintable
public TransferEncoding Base64
public TransferEncoding SevenBit
public TransferEncoding EightBit
public TransferEncoding Unknown
}
internal System.Net.Mime.WriteStateInfoBase : object {
protected Byte[] _header
protected Byte[] _footer
protected int _maxLineLength
protected Byte[] buffer
protected int _currentLineLength
protected int _currentBufferUsed
protected int defaultBufferSize
internal int FooterLength
internal Byte[] Footer
internal Byte[] Header
internal Byte[] Buffer
internal int Length
internal int CurrentLineLength
internal int MaxLineLength
internal void .ctor(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength)
internal void .ctor(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength)
internal int get_FooterLength()
internal Byte[] get_Footer()
internal Byte[] get_Header()
internal Byte[] get_Buffer()
internal int get_Length()
internal int get_CurrentLineLength()
private void EnsureSpaceInBuffer(int moreBytes)
internal void Append(byte aByte)
internal void Append(Byte[] bytes)
internal void AppendCRLF(bool includeSpace)
internal void AppendHeader()
internal void AppendFooter()
internal int get_MaxLineLength()
internal void Reset()
internal void BufferFlushed()
}
internal System.Net.MonoChunkStream : object {
internal WebHeaderCollection headers
private int chunkSize
private int chunkRead
private int totalWritten
private State state
private StringBuilder saved
private bool sawCR
private bool gotit
private int trailerState
private ArrayList chunks
public bool WantMore
public bool DataAvailable
public int TotalDataSize
public int ChunkLeft
public void .ctor(Byte[] buffer, int offset, int size, WebHeaderCollection headers)
public void .ctor(WebHeaderCollection headers)
public void ResetBuffer()
public void WriteAndReadBack(Byte[] buffer, int offset, int size, Int32& read)
public int Read(Byte[] buffer, int offset, int size)
private int ReadFromChunks(Byte[] buffer, int offset, int size)
public void Write(Byte[] buffer, int offset, int size)
private void InternalWrite(Byte[] buffer, Int32& offset, int size)
public bool get_WantMore()
public bool get_DataAvailable()
public int get_TotalDataSize()
public int get_ChunkLeft()
private State ReadBody(Byte[] buffer, Int32& offset, int size)
private State GetChunkSize(Byte[] buffer, Int32& offset, int size)
private string RemoveChunkExtension(string input)
private State ReadCRLF(Byte[] buffer, Int32& offset, int size)
private State ReadTrailer(Byte[] buffer, Int32& offset, int size)
private void ThrowProtocolViolation(string message)
}
internal System.Net.MonoHttpDate : object {
private string rfc1123_date
private string rfc850_date
private string asctime_date
private String[] formats
internal DateTime Parse(string dateStr)
}
internal System.Net.NclConstants : object {
internal object Sentinel
internal Object[] EmptyObjectArray
internal Uri[] EmptyUriArray
internal Byte[] CRLF
internal Byte[] ChunkTerminator
}
internal System.Net.NclUtilities : object {
private ContextCallback modreq(System.Runtime.CompilerServices.IsVolatile) s_ContextRelativeDemandCallback
private IPAddress[] modreq(System.Runtime.CompilerServices.IsVolatile) _LocalAddresses
private object _LocalAddressesLock
private int HostNameBufferLength
internal string _LocalDomainName
internal bool HasShutdownStarted
internal ContextCallback ContextRelativeDemandCallback
internal IPAddress[] LocalAddresses
private object LocalAddressesLock
internal bool IsThreadPoolLow()
internal bool get_HasShutdownStarted()
internal bool IsCredentialFailure(SecurityStatus error)
internal bool IsClientFault(SecurityStatus error)
internal ContextCallback get_ContextRelativeDemandCallback()
private void DemandCallback(object state)
internal bool GuessWhetherHostIsLoopback(string host)
internal bool IsFatal(Exception exception)
internal bool IsAddressLocal(IPAddress ipAddress)
private IPHostEntry GetLocalHost()
internal IPAddress[] get_LocalAddresses()
private object get_LocalAddressesLock()
}
internal System.Net.NetConfig : object {
internal bool ipv6Enabled
internal int MaxResponseHeadersLength
private object System.ICloneable.Clone()
}
internal System.Net.NetEventSource : EventSource {
public NetEventSource Log
private string MissingMember
private string NullInstance
private string StaticMethodObject
private string NoParameters
private int MaxDumpSize
private int EnterEventId
private int ExitEventId
private int AssociateEventId
private int InfoEventId
private int ErrorEventId
private int CriticalFailureEventId
private int DumpArrayEventId
private int NextAvailableEventId
public bool IsEnabled
public void Enter(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Enter(object thisOrContextObject, object arg0, string memberName)
public void Enter(object thisOrContextObject, object arg0, object arg1, string memberName)
public void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName)
private void Enter(string thisOrContextObject, string memberName, string parameters)
public void Exit(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Exit(object thisOrContextObject, object arg0, string memberName)
public void Exit(object thisOrContextObject, object arg0, object arg1, string memberName)
private void Exit(string thisOrContextObject, string memberName, string result)
public void Info(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Info(object thisOrContextObject, object message, string memberName)
private void Info(string thisOrContextObject, string memberName, string message)
public void Error(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Error(object thisOrContextObject, object message, string memberName)
private void ErrorMessage(string thisOrContextObject, string memberName, string message)
public void Fail(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Fail(object thisOrContextObject, object message, string memberName)
private void CriticalFailure(string thisOrContextObject, string memberName, string message)
public void DumpBuffer(object thisOrContextObject, Byte[] buffer, string memberName)
public void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName)
public void DumpBuffer(object thisOrContextObject, IntPtr bufferPtr, int count, string memberName)
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer)
public void Associate(object first, object second, string memberName)
public void Associate(object thisOrContextObject, object first, object second, string memberName)
private void Associate(string thisOrContextObject, string memberName, string first, string second)
private void DebugValidateArg(object arg)
private void DebugValidateArg(FormattableString arg)
public bool get_IsEnabled()
public string IdOf(object value)
public int GetHashCode(object value)
public object Format(object value)
private string Format(FormattableString s)
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4)
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3)
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4)
private void WriteEvent(int eventId, string arg1, int arg2, string arg3)
private void WriteEvent(int eventId, string arg1, string arg2, int arg3)
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4)
}
internal System.Net.NetRes : object {
public string GetWebStatusString(string Res, WebExceptionStatus Status)
public string GetWebStatusString(WebExceptionStatus Status)
public string GetWebStatusCodeString(HttpStatusCode statusCode, string statusDescription)
public string GetWebStatusCodeString(FtpStatusCode statusCode, string statusDescription)
}
public System.Net.NetworkAccess : Enum {
public int value__
public NetworkAccess Accept
public NetworkAccess Connect
}
public System.Net.NetworkCredential : object {
private string m_domain
private string m_userName
private SecureString m_password
public string UserName
public string Password
public SecureString SecurePassword
public string Domain
public void .ctor(string userName, string password)
public void .ctor(string userName, SecureString password)
public void .ctor(string userName, string password, string domain)
public void .ctor(string userName, SecureString password, string domain)
public string get_UserName()
public void set_UserName(string value)
public string get_Password()
public void set_Password(string value)
public SecureString get_SecurePassword()
public void set_SecurePassword(SecureString value)
public string get_Domain()
public void set_Domain(string value)
internal string InternalGetUserName()
internal string InternalGetPassword()
internal SecureString InternalGetSecurePassword()
internal string InternalGetDomain()
internal string InternalGetDomainUserName()
public NetworkCredential GetCredential(Uri uri, string authType)
public NetworkCredential GetCredential(string host, int port, string authenticationType)
}
internal System.Net.NetworkInformation.AlignmentUnion : ValueType {
public ulong Alignment
public int Length
public int IfIndex
}
internal System.Net.NetworkInformation.CommonUnixIPGlobalProperties : IPGlobalProperties {
public string DhcpScopeName
public string DomainName
public string HostName
public bool IsWinsProxy
public NetBiosNodeType NodeType
private int gethostname(Byte[] name, int len)
private int getdomainname(Byte[] name, int len)
public string get_DhcpScopeName()
public string get_DomainName()
public string get_HostName()
public bool get_IsWinsProxy()
public NetBiosNodeType get_NodeType()
}
public System.Net.NetworkInformation.DuplicateAddressDetectionState : Enum {
public int value__
public DuplicateAddressDetectionState Invalid
public DuplicateAddressDetectionState Tentative
public DuplicateAddressDetectionState Duplicate
public DuplicateAddressDetectionState Deprecated
public DuplicateAddressDetectionState Preferred
}
public System.Net.NetworkInformation.GatewayIPAddressInformation : object {
public IPAddress Address
public IPAddress get_Address()
}
public System.Net.NetworkInformation.GatewayIPAddressInformationCollection : object {
private Collection`1<GatewayIPAddressInformation> addresses
public int Count
public bool IsReadOnly
public GatewayIPAddressInformation Item
public void CopyTo(GatewayIPAddressInformation[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public GatewayIPAddressInformation get_Item(int index)
public void Add(GatewayIPAddressInformation address)
internal void InternalAdd(GatewayIPAddressInformation address)
public bool Contains(GatewayIPAddressInformation address)
public IEnumerator`1<GatewayIPAddressInformation> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Remove(GatewayIPAddressInformation address)
public void Clear()
}
internal System.Net.NetworkInformation.IcmpV4Code : Enum {
public int value__
public IcmpV4Code ICMP4_UNREACH_NET
public IcmpV4Code ICMP4_UNREACH_HOST
public IcmpV4Code ICMP4_UNREACH_PROTOCOL
public IcmpV4Code ICMP4_UNREACH_PORT
public IcmpV4Code ICMP4_UNREACH_FRAG_NEEDED
public IcmpV4Code ICMP4_UNREACH_SOURCEROUTE_FAILED
public IcmpV4Code ICMP4_UNREACH_NET_UNKNOWN
public IcmpV4Code ICMP4_UNREACH_HOST_UNKNOWN
public IcmpV4Code ICMP4_UNREACH_ISOLATED
public IcmpV4Code ICMP4_UNREACH_NET_ADMIN
public IcmpV4Code ICMP4_UNREACH_HOST_ADMIN
public IcmpV4Code ICMP4_UNREACH_NET_TOS
public IcmpV4Code ICMP4_UNREACH_HOST_TOS
public IcmpV4Code ICMP4_UNREACH_ADMIN
}
public System.Net.NetworkInformation.IcmpV4Statistics : object {
public long AddressMaskRepliesReceived
public long AddressMaskRepliesSent
public long AddressMaskRequestsReceived
public long AddressMaskRequestsSent
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MessagesReceived
public long MessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long SourceQuenchesReceived
public long SourceQuenchesSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long TimestampRepliesReceived
public long TimestampRepliesSent
public long TimestampRequestsReceived
public long TimestampRequestsSent
public long get_AddressMaskRepliesReceived()
public long get_AddressMaskRepliesSent()
public long get_AddressMaskRequestsReceived()
public long get_AddressMaskRequestsSent()
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_SourceQuenchesReceived()
public long get_SourceQuenchesSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
public long get_TimestampRepliesReceived()
public long get_TimestampRepliesSent()
public long get_TimestampRequestsReceived()
public long get_TimestampRequestsSent()
}
internal System.Net.NetworkInformation.IcmpV4Type : Enum {
public int value__
public IcmpV4Type ICMP4_ECHO_REPLY
public IcmpV4Type ICMP4_DST_UNREACH
public IcmpV4Type ICMP4_SOURCE_QUENCH
public IcmpV4Type ICMP4_TIME_EXCEEDED
public IcmpV4Type ICMP4_PARAM_PROB
public IcmpV4Type ICMP4_REDIRECT
public IcmpV4Type ICMP4_ECHO_REQUEST
public IcmpV4Type ICMP4_ROUTER_ADVERT
public IcmpV4Type ICMP4_ROUTER_SOLICIT
public IcmpV4Type ICMP4_TIMESTAMP_REQUEST
public IcmpV4Type ICMP4_TIMESTAMP_REPLY
public IcmpV4Type ICMP4_MASK_REQUEST
public IcmpV4Type ICMP4_MASK_REPLY
}
internal System.Net.NetworkInformation.IcmpV6MessageTypes : object {
public int DestinationUnreachable
public int PacketTooBig
public int TimeExceeded
public int ParameterProblem
public int EchoRequest
public int EchoReply
public int GroupMembershipQuery
public int GroupMembershipReport
public int GroupMembershipReduction
public int RouterSolicitation
public int RouterAdvertisement
public int NeighborSolicitation
public int NeighborAdvertisement
public int Redirect
public int RouterRenumbering
}
public System.Net.NetworkInformation.IcmpV6Statistics : object {
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MembershipQueriesReceived
public long MembershipQueriesSent
public long MembershipReductionsReceived
public long MembershipReductionsSent
public long MembershipReportsReceived
public long MembershipReportsSent
public long MessagesReceived
public long MessagesSent
public long NeighborAdvertisementsReceived
public long NeighborAdvertisementsSent
public long NeighborSolicitsReceived
public long NeighborSolicitsSent
public long PacketTooBigMessagesReceived
public long PacketTooBigMessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long RouterAdvertisementsReceived
public long RouterAdvertisementsSent
public long RouterSolicitsReceived
public long RouterSolicitsSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MembershipQueriesReceived()
public long get_MembershipQueriesSent()
public long get_MembershipReductionsReceived()
public long get_MembershipReductionsSent()
public long get_MembershipReportsReceived()
public long get_MembershipReportsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_NeighborAdvertisementsReceived()
public long get_NeighborAdvertisementsSent()
public long get_NeighborSolicitsReceived()
public long get_NeighborSolicitsSent()
public long get_PacketTooBigMessagesReceived()
public long get_PacketTooBigMessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_RouterAdvertisementsReceived()
public long get_RouterAdvertisementsSent()
public long get_RouterSolicitsReceived()
public long get_RouterSolicitsSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
}
internal System.Net.NetworkInformation.ifa_ifu : ValueType {
public IntPtr ifu_broadaddr
public IntPtr ifu_dstaddr
}
internal System.Net.NetworkInformation.ifaddrs : ValueType {
public IntPtr ifa_next
public string ifa_name
public UInt32 ifa_flags
public IntPtr ifa_addr
public IntPtr ifa_netmask
public ifa_ifu ifa_ifu
public IntPtr ifa_data
}
internal System.Net.NetworkInformation.in6_addr : ValueType {
public Byte[] u6_addr8
}
internal System.Net.NetworkInformation.INetworkChange {
public bool HasRegisteredEvents
public void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public bool get_HasRegisteredEvents()
}
public System.Net.NetworkInformation.IPAddressCollection : object {
private Collection`1<IPAddress> addresses
public int Count
public bool IsReadOnly
public IPAddress Item
public void CopyTo(IPAddress[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public void Add(IPAddress address)
internal void InternalAdd(IPAddress address)
public bool Contains(IPAddress address)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<IPAddress> GetEnumerator()
public IPAddress get_Item(int index)
public bool Remove(IPAddress address)
public void Clear()
}
public System.Net.NetworkInformation.IPAddressInformation : object {
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
}
public System.Net.NetworkInformation.IPAddressInformationCollection : object {
private Collection`1<IPAddressInformation> addresses
public int Count
public bool IsReadOnly
public IPAddressInformation Item
public void CopyTo(IPAddressInformation[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public void Add(IPAddressInformation address)
internal void InternalAdd(IPAddressInformation address)
public bool Contains(IPAddressInformation address)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<IPAddressInformation> GetEnumerator()
public IPAddressInformation get_Item(int index)
public bool Remove(IPAddressInformation address)
public void Clear()
}
public System.Net.NetworkInformation.IPGlobalProperties : object {
public string DhcpScopeName
public string DomainName
public string HostName
public bool IsWinsProxy
public NetBiosNodeType NodeType
public IPGlobalProperties GetIPGlobalProperties()
internal IPGlobalProperties InternalGetIPGlobalProperties()
public IPEndPoint[] GetActiveUdpListeners()
public IPEndPoint[] GetActiveTcpListeners()
public TcpConnectionInformation[] GetActiveTcpConnections()
public string get_DhcpScopeName()
public string get_DomainName()
public string get_HostName()
public bool get_IsWinsProxy()
public NetBiosNodeType get_NodeType()
public TcpStatistics GetTcpIPv4Statistics()
public TcpStatistics GetTcpIPv6Statistics()
public UdpStatistics GetUdpIPv4Statistics()
public UdpStatistics GetUdpIPv6Statistics()
public IcmpV4Statistics GetIcmpV4Statistics()
public IcmpV6Statistics GetIcmpV6Statistics()
public IPGlobalStatistics GetIPv4GlobalStatistics()
public IPGlobalStatistics GetIPv6GlobalStatistics()
public UnicastIPAddressInformationCollection GetUnicastAddresses()
public IAsyncResult BeginGetUnicastAddresses(AsyncCallback callback, object state)
public UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult)
public Task`1<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync()
}
public System.Net.NetworkInformation.IPGlobalStatistics : object {
public int DefaultTtl
public bool ForwardingEnabled
public int NumberOfInterfaces
public int NumberOfIPAddresses
public long OutputPacketRequests
public long OutputPacketRoutingDiscards
public long OutputPacketsDiscarded
public long OutputPacketsWithNoRoute
public long PacketFragmentFailures
public long PacketReassembliesRequired
public long PacketReassemblyFailures
public long PacketReassemblyTimeout
public long PacketsFragmented
public long PacketsReassembled
public long ReceivedPackets
public long ReceivedPacketsDelivered
public long ReceivedPacketsDiscarded
public long ReceivedPacketsForwarded
public long ReceivedPacketsWithAddressErrors
public long ReceivedPacketsWithHeadersErrors
public long ReceivedPacketsWithUnknownProtocol
public int NumberOfRoutes
public int get_DefaultTtl()
public bool get_ForwardingEnabled()
public int get_NumberOfInterfaces()
public int get_NumberOfIPAddresses()
public long get_OutputPacketRequests()
public long get_OutputPacketRoutingDiscards()
public long get_OutputPacketsDiscarded()
public long get_OutputPacketsWithNoRoute()
public long get_PacketFragmentFailures()
public long get_PacketReassembliesRequired()
public long get_PacketReassemblyFailures()
public long get_PacketReassemblyTimeout()
public long get_PacketsFragmented()
public long get_PacketsReassembled()
public long get_ReceivedPackets()
public long get_ReceivedPacketsDelivered()
public long get_ReceivedPacketsDiscarded()
public long get_ReceivedPacketsForwarded()
public long get_ReceivedPacketsWithAddressErrors()
public long get_ReceivedPacketsWithHeadersErrors()
public long get_ReceivedPacketsWithUnknownProtocol()
public int get_NumberOfRoutes()
}
public System.Net.NetworkInformation.IPInterfaceProperties : object {
public bool IsDnsEnabled
public string DnsSuffix
public bool IsDynamicDnsEnabled
public UnicastIPAddressInformationCollection UnicastAddresses
public MulticastIPAddressInformationCollection MulticastAddresses
public IPAddressInformationCollection AnycastAddresses
public IPAddressCollection DnsAddresses
public GatewayIPAddressInformationCollection GatewayAddresses
public IPAddressCollection DhcpServerAddresses
public IPAddressCollection WinsServersAddresses
public bool get_IsDnsEnabled()
public string get_DnsSuffix()
public bool get_IsDynamicDnsEnabled()
public UnicastIPAddressInformationCollection get_UnicastAddresses()
public MulticastIPAddressInformationCollection get_MulticastAddresses()
public IPAddressInformationCollection get_AnycastAddresses()
public IPAddressCollection get_DnsAddresses()
public GatewayIPAddressInformationCollection get_GatewayAddresses()
public IPAddressCollection get_DhcpServerAddresses()
public IPAddressCollection get_WinsServersAddresses()
public IPv4InterfaceProperties GetIPv4Properties()
public IPv6InterfaceProperties GetIPv6Properties()
}
public System.Net.NetworkInformation.IPInterfaceStatistics : object {
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
public System.Net.NetworkInformation.IPStatus : Enum {
public int value__
public IPStatus Success
public IPStatus DestinationNetworkUnreachable
public IPStatus DestinationHostUnreachable
public IPStatus DestinationProtocolUnreachable
public IPStatus DestinationPortUnreachable
public IPStatus DestinationProhibited
public IPStatus NoResources
public IPStatus BadOption
public IPStatus HardwareError
public IPStatus PacketTooBig
public IPStatus TimedOut
public IPStatus BadRoute
public IPStatus TtlExpired
public IPStatus TtlReassemblyTimeExceeded
public IPStatus ParameterProblem
public IPStatus SourceQuench
public IPStatus BadDestination
public IPStatus DestinationUnreachable
public IPStatus TimeExceeded
public IPStatus BadHeader
public IPStatus UnrecognizedNextHeader
public IPStatus IcmpError
public IPStatus DestinationScopeMismatch
public IPStatus Unknown
}
public System.Net.NetworkInformation.IPv4InterfaceProperties : object {
public bool UsesWins
public bool IsDhcpEnabled
public bool IsAutomaticPrivateAddressingActive
public bool IsAutomaticPrivateAddressingEnabled
public int Index
public bool IsForwardingEnabled
public int Mtu
public bool get_UsesWins()
public bool get_IsDhcpEnabled()
public bool get_IsAutomaticPrivateAddressingActive()
public bool get_IsAutomaticPrivateAddressingEnabled()
public int get_Index()
public bool get_IsForwardingEnabled()
public int get_Mtu()
}
public System.Net.NetworkInformation.IPv4InterfaceStatistics : object {
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
public System.Net.NetworkInformation.IPv6InterfaceProperties : object {
public int Index
public int Mtu
public int get_Index()
public int get_Mtu()
public long GetScopeId(ScopeLevel scopeLevel)
}
internal System.Net.NetworkInformation.LinuxArpHardware : Enum {
public int value__
public LinuxArpHardware ETHER
public LinuxArpHardware EETHER
public LinuxArpHardware PRONET
public LinuxArpHardware ATM
public LinuxArpHardware SLIP
public LinuxArpHardware CSLIP
public LinuxArpHardware SLIP6
public LinuxArpHardware CSLIP6
public LinuxArpHardware PPP
public LinuxArpHardware LOOPBACK
public LinuxArpHardware FDDI
public LinuxArpHardware TUNNEL
public LinuxArpHardware TUNNEL6
public LinuxArpHardware SIT
public LinuxArpHardware IPDDP
public LinuxArpHardware IPGRE
public LinuxArpHardware IP6GRE
}
internal System.Net.NetworkInformation.LinuxIPInterfaceProperties : UnixIPInterfaceProperties {
public GatewayIPAddressInformationCollection GatewayAddresses
public void .ctor(LinuxNetworkInterface iface, List`1<IPAddress> addresses)
public IPv4InterfaceProperties GetIPv4Properties()
private IPAddressCollection ParseRouteInfo(string iface)
public GatewayIPAddressInformationCollection get_GatewayAddresses()
}
internal System.Net.NetworkInformation.LinuxIPv4InterfaceProperties : UnixIPv4InterfaceProperties {
public bool IsForwardingEnabled
public int Mtu
public void .ctor(LinuxNetworkInterface iface)
public bool get_IsForwardingEnabled()
public int get_Mtu()
}
internal System.Net.NetworkInformation.LinuxIPv4InterfaceStatistics : IPv4InterfaceStatistics {
private LinuxNetworkInterface linux
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public void .ctor(LinuxNetworkInterface parent)
private long Read(string file)
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
internal System.Net.NetworkInformation.LinuxNetworkChange : object {
private object _lock
private Socket nl_sock
private SocketAsyncEventArgs nl_args
private EventType pending_events
private Timer timer
private NetworkAddressChangedEventHandler AddressChanged
private NetworkAvailabilityChangedEventHandler AvailabilityChanged
private string LIBNAME
public bool HasRegisteredEvents
public void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public bool get_HasRegisteredEvents()
public void Dispose()
private bool EnsureSocket()
private void MaybeCloseSocket()
private bool GetAvailability()
private void OnAvailabilityChanged(object unused)
private void OnAddressChanged(object unused)
private void OnEventDue(object unused)
private void QueueEvent(EventType type)
private void OnDataAvailable(object sender, SocketAsyncEventArgs args)
private void Register(NetworkAddressChangedEventHandler d)
private void Register(NetworkAvailabilityChangedEventHandler d)
private void Unregister(NetworkAddressChangedEventHandler d)
private void Unregister(NetworkAvailabilityChangedEventHandler d)
private IntPtr CreateNLSocket()
private EventType ReadEvents(IntPtr sock, IntPtr buffer, int count, int size)
private IntPtr CloseNLSocket(IntPtr sock)
}
internal System.Net.NetworkInformation.LinuxNetworkInterface : UnixNetworkInterface {
private string iface_path
private string iface_operstate_path
private string iface_flags_path
internal string IfacePath
public OperationalStatus OperationalStatus
public bool SupportsMulticast
internal string get_IfacePath()
internal void .ctor(string name)
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public OperationalStatus get_OperationalStatus()
public bool get_SupportsMulticast()
internal string ReadLine(string path)
}
internal System.Net.NetworkInformation.LinuxUnicastIPAddressInformation : UnicastIPAddressInformation {
private IPAddress address
private IPAddress ipv4Mask
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public IPAddress IPv4Mask
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public void .ctor(IPAddress address)
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public IPAddress get_IPv4Mask()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
}
internal System.Net.NetworkInformation.MacNetworkChange : object {
private string DL_LIB
private string CORE_SERVICES_LIB
private string CORE_FOUNDATION_LIB
private IntPtr handle
private IntPtr runLoopMode
private SCNetworkReachabilityCallback callback
private bool scheduledWithRunLoop
private NetworkReachabilityFlags flags
private NetworkAddressChangedEventHandler networkAddressChanged
private NetworkAvailabilityChangedEventHandler networkAvailabilityChanged
private bool IsAvailable
public bool HasRegisteredEvents
private IntPtr dlopen(string path, int mode)
private IntPtr dlsym(IntPtr handle, string symbol)
private int dlclose(IntPtr handle)
private void CFRelease(IntPtr handle)
private IntPtr CFRunLoopGetMain()
private IntPtr SCNetworkReachabilityCreateWithAddress(IntPtr allocator, sockaddr_in& sockaddr)
private bool SCNetworkReachabilityGetFlags(IntPtr reachability, NetworkReachabilityFlags& flags)
private bool SCNetworkReachabilitySetCallback(IntPtr reachability, SCNetworkReachabilityCallback callback, SCNetworkReachabilityContext& context)
private bool SCNetworkReachabilityScheduleWithRunLoop(IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode)
private bool SCNetworkReachabilityUnscheduleFromRunLoop(IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode)
private void add_networkAddressChanged(NetworkAddressChangedEventHandler value)
private void remove_networkAddressChanged(NetworkAddressChangedEventHandler value)
private void add_networkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
private void remove_networkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
private bool get_IsAvailable()
public bool get_HasRegisteredEvents()
private bool LoadRunLoopMode()
public void Dispose()
private void HandleCallback(IntPtr reachability, NetworkReachabilityFlags flags, IntPtr info)
}
internal System.Net.NetworkInformation.MacOsArpHardware : Enum {
public int value__
public MacOsArpHardware ETHER
public MacOsArpHardware ATM
public MacOsArpHardware SLIP
public MacOsArpHardware PPP
public MacOsArpHardware LOOPBACK
public MacOsArpHardware FDDI
}
internal System.Net.NetworkInformation.MacOsInterfaceFlags : Enum {
public int value__
public MacOsInterfaceFlags IFF_UP
public MacOsInterfaceFlags IFF_BROADCAST
public MacOsInterfaceFlags IFF_DEBUG
public MacOsInterfaceFlags IFF_LOOPBACK
public MacOsInterfaceFlags IFF_POINTOPOINT
public MacOsInterfaceFlags IFF_NOTRAILERS
public MacOsInterfaceFlags IFF_RUNNING
public MacOsInterfaceFlags IFF_NOARP
public MacOsInterfaceFlags IFF_PROMISC
public MacOsInterfaceFlags IFF_ALLMULTI
public MacOsInterfaceFlags IFF_OACTIVE
public MacOsInterfaceFlags IFF_SIMPLEX
public MacOsInterfaceFlags IFF_LINK0
public MacOsInterfaceFlags IFF_LINK1
public MacOsInterfaceFlags IFF_LINK2
public MacOsInterfaceFlags IFF_MULTICAST
}
internal System.Net.NetworkInformation.MacOsIPInterfaceProperties : UnixIPInterfaceProperties {
public GatewayIPAddressInformationCollection GatewayAddresses
public void .ctor(MacOsNetworkInterface iface, List`1<IPAddress> addresses)
public IPv4InterfaceProperties GetIPv4Properties()
private bool ParseRouteInfo_internal(string iface, String[]& gw_addr_list)
public GatewayIPAddressInformationCollection get_GatewayAddresses()
}
internal System.Net.NetworkInformation.MacOsIPv4InterfaceProperties : UnixIPv4InterfaceProperties {
public bool IsForwardingEnabled
public int Mtu
public void .ctor(MacOsNetworkInterface iface)
public bool get_IsForwardingEnabled()
public int get_Mtu()
}
internal System.Net.NetworkInformation.MacOsIPv4InterfaceStatistics : IPv4InterfaceStatistics {
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public void .ctor(MacOsNetworkInterface parent)
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
internal System.Net.NetworkInformation.MacOsNetworkInterface : UnixNetworkInterface {
private UInt32 _ifa_flags
public OperationalStatus OperationalStatus
public bool SupportsMulticast
internal void .ctor(string name, UInt32 ifa_flags)
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public OperationalStatus get_OperationalStatus()
public bool get_SupportsMulticast()
}
internal System.Net.NetworkInformation.MacOsStructs.ifaddrs : ValueType {
public IntPtr ifa_next
public string ifa_name
public UInt32 ifa_flags
public IntPtr ifa_addr
public IntPtr ifa_netmask
public IntPtr ifa_dstaddr
public IntPtr ifa_data
}
internal System.Net.NetworkInformation.MacOsStructs.in6_addr : ValueType {
public Byte[] u6_addr8
}
internal System.Net.NetworkInformation.MacOsStructs.sockaddr : ValueType {
public byte sa_len
public byte sa_family
}
internal System.Net.NetworkInformation.MacOsStructs.sockaddr_dl : ValueType {
public byte sdl_len
public byte sdl_family
public ushort sdl_index
public byte sdl_type
public byte sdl_nlen
public byte sdl_alen
public byte sdl_slen
public Byte[] sdl_data
internal void Read(IntPtr ptr)
}
internal System.Net.NetworkInformation.MacOsStructs.sockaddr_in : ValueType {
public byte sin_len
public byte sin_family
public ushort sin_port
public UInt32 sin_addr
}
internal System.Net.NetworkInformation.MacOsStructs.sockaddr_in6 : ValueType {
public byte sin6_len
public byte sin6_family
public ushort sin6_port
public UInt32 sin6_flowinfo
public in6_addr sin6_addr
public UInt32 sin6_scope_id
}
internal System.Net.NetworkInformation.MibIcmpV4Statistics : IcmpV4Statistics {
private StringDictionary dic
public long AddressMaskRepliesReceived
public long AddressMaskRepliesSent
public long AddressMaskRequestsReceived
public long AddressMaskRequestsSent
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MessagesReceived
public long MessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long SourceQuenchesReceived
public long SourceQuenchesSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long TimestampRepliesReceived
public long TimestampRepliesSent
public long TimestampRequestsReceived
public long TimestampRequestsSent
public void .ctor(StringDictionary dic)
private long Get(string name)
public long get_AddressMaskRepliesReceived()
public long get_AddressMaskRepliesSent()
public long get_AddressMaskRequestsReceived()
public long get_AddressMaskRequestsSent()
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_SourceQuenchesReceived()
public long get_SourceQuenchesSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
public long get_TimestampRepliesReceived()
public long get_TimestampRepliesSent()
public long get_TimestampRequestsReceived()
public long get_TimestampRequestsSent()
}
internal System.Net.NetworkInformation.MibIcmpV6Statistics : IcmpV6Statistics {
private StringDictionary dic
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MembershipQueriesReceived
public long MembershipQueriesSent
public long MembershipReductionsReceived
public long MembershipReductionsSent
public long MembershipReportsReceived
public long MembershipReportsSent
public long MessagesReceived
public long MessagesSent
public long NeighborAdvertisementsReceived
public long NeighborAdvertisementsSent
public long NeighborSolicitsReceived
public long NeighborSolicitsSent
public long PacketTooBigMessagesReceived
public long PacketTooBigMessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long RouterAdvertisementsReceived
public long RouterAdvertisementsSent
public long RouterSolicitsReceived
public long RouterSolicitsSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public void .ctor(StringDictionary dic)
private long Get(string name)
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MembershipQueriesReceived()
public long get_MembershipQueriesSent()
public long get_MembershipReductionsReceived()
public long get_MembershipReductionsSent()
public long get_MembershipReportsReceived()
public long get_MembershipReportsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_NeighborAdvertisementsReceived()
public long get_NeighborAdvertisementsSent()
public long get_NeighborSolicitsReceived()
public long get_NeighborSolicitsSent()
public long get_PacketTooBigMessagesReceived()
public long get_PacketTooBigMessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_RouterAdvertisementsReceived()
public long get_RouterAdvertisementsSent()
public long get_RouterSolicitsReceived()
public long get_RouterSolicitsSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
}
internal System.Net.NetworkInformation.MibIPGlobalProperties : UnixIPGlobalProperties {
public string ProcDir
public string CompatProcDir
public string StatisticsFile
public string StatisticsFileIPv6
public string TcpFile
public string Tcp6File
public string UdpFile
public string Udp6File
private Char[] wsChars
public void .ctor(string procDir)
private StringDictionary GetProperties4(string item)
private StringDictionary GetProperties6(string item)
private Exception CreateException(string file, string msg)
private IPEndPoint[] GetLocalAddresses(List`1<String[]> list)
private IPEndPoint ToEndpoint(string s)
private void GetRows(string file, List`1<String[]> list)
public TcpConnectionInformation[] GetActiveTcpConnections()
public IPEndPoint[] GetActiveTcpListeners()
public IPEndPoint[] GetActiveUdpListeners()
public IcmpV4Statistics GetIcmpV4Statistics()
public IcmpV6Statistics GetIcmpV6Statistics()
public IPGlobalStatistics GetIPv4GlobalStatistics()
public IPGlobalStatistics GetIPv6GlobalStatistics()
public TcpStatistics GetTcpIPv4Statistics()
public TcpStatistics GetTcpIPv6Statistics()
public UdpStatistics GetUdpIPv4Statistics()
public UdpStatistics GetUdpIPv6Statistics()
}
internal System.Net.NetworkInformation.MibIPGlobalStatistics : IPGlobalStatistics {
private StringDictionary dic
public int DefaultTtl
public bool ForwardingEnabled
public int NumberOfInterfaces
public int NumberOfIPAddresses
public int NumberOfRoutes
public long OutputPacketRequests
public long OutputPacketRoutingDiscards
public long OutputPacketsDiscarded
public long OutputPacketsWithNoRoute
public long PacketFragmentFailures
public long PacketReassembliesRequired
public long PacketReassemblyFailures
public long PacketReassemblyTimeout
public long PacketsFragmented
public long PacketsReassembled
public long ReceivedPackets
public long ReceivedPacketsDelivered
public long ReceivedPacketsDiscarded
public long ReceivedPacketsForwarded
public long ReceivedPacketsWithAddressErrors
public long ReceivedPacketsWithHeadersErrors
public long ReceivedPacketsWithUnknownProtocol
public void .ctor(StringDictionary dic)
private long Get(string name)
public int get_DefaultTtl()
public bool get_ForwardingEnabled()
public int get_NumberOfInterfaces()
public int get_NumberOfIPAddresses()
public int get_NumberOfRoutes()
public long get_OutputPacketRequests()
public long get_OutputPacketRoutingDiscards()
public long get_OutputPacketsDiscarded()
public long get_OutputPacketsWithNoRoute()
public long get_PacketFragmentFailures()
public long get_PacketReassembliesRequired()
public long get_PacketReassemblyFailures()
public long get_PacketReassemblyTimeout()
public long get_PacketsFragmented()
public long get_PacketsReassembled()
public long get_ReceivedPackets()
public long get_ReceivedPacketsDelivered()
public long get_ReceivedPacketsDiscarded()
public long get_ReceivedPacketsForwarded()
public long get_ReceivedPacketsWithAddressErrors()
public long get_ReceivedPacketsWithHeadersErrors()
public long get_ReceivedPacketsWithUnknownProtocol()
}
internal System.Net.NetworkInformation.MibTcpStatistics : TcpStatistics {
private StringDictionary dic
public long ConnectionsAccepted
public long ConnectionsInitiated
public long CumulativeConnections
public long CurrentConnections
public long ErrorsReceived
public long FailedConnectionAttempts
public long MaximumConnections
public long MaximumTransmissionTimeout
public long MinimumTransmissionTimeout
public long ResetConnections
public long ResetsSent
public long SegmentsReceived
public long SegmentsResent
public long SegmentsSent
public void .ctor(StringDictionary dic)
private long Get(string name)
public long get_ConnectionsAccepted()
public long get_ConnectionsInitiated()
public long get_CumulativeConnections()
public long get_CurrentConnections()
public long get_ErrorsReceived()
public long get_FailedConnectionAttempts()
public long get_MaximumConnections()
public long get_MaximumTransmissionTimeout()
public long get_MinimumTransmissionTimeout()
public long get_ResetConnections()
public long get_ResetsSent()
public long get_SegmentsReceived()
public long get_SegmentsResent()
public long get_SegmentsSent()
}
internal System.Net.NetworkInformation.MibUdpStatistics : UdpStatistics {
private StringDictionary dic
public long DatagramsReceived
public long DatagramsSent
public long IncomingDatagramsDiscarded
public long IncomingDatagramsWithErrors
public int UdpListeners
public void .ctor(StringDictionary dic)
private long Get(string name)
public long get_DatagramsReceived()
public long get_DatagramsSent()
public long get_IncomingDatagramsDiscarded()
public long get_IncomingDatagramsWithErrors()
public int get_UdpListeners()
}
public System.Net.NetworkInformation.MulticastIPAddressInformation : IPAddressInformation {
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
}
public System.Net.NetworkInformation.MulticastIPAddressInformationCollection : object {
private Collection`1<MulticastIPAddressInformation> addresses
public int Count
public bool IsReadOnly
public MulticastIPAddressInformation Item
public void CopyTo(MulticastIPAddressInformation[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public void Add(MulticastIPAddressInformation address)
internal void InternalAdd(MulticastIPAddressInformation address)
public bool Contains(MulticastIPAddressInformation address)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<MulticastIPAddressInformation> GetEnumerator()
public MulticastIPAddressInformation get_Item(int index)
public bool Remove(MulticastIPAddressInformation address)
public void Clear()
}
public System.Net.NetworkInformation.NetBiosNodeType : Enum {
public int value__
public NetBiosNodeType Unknown
public NetBiosNodeType Broadcast
public NetBiosNodeType Peer2Peer
public NetBiosNodeType Mixed
public NetBiosNodeType Hybrid
}
public System.Net.NetworkInformation.NetworkAddressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, EventArgs e)
public IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.NetworkInformation.NetworkAvailabilityChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, NetworkAvailabilityEventArgs e)
public IAsyncResult BeginInvoke(object sender, NetworkAvailabilityEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.NetworkInformation.NetworkAvailabilityEventArgs : EventArgs {
private bool isAvailable
public bool IsAvailable
internal void .ctor(bool isAvailable)
public bool get_IsAvailable()
}
public System.Net.NetworkInformation.NetworkChange : object {
private INetworkChange networkChange
public void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
private void MaybeCreate()
private void MaybeDispose()
}
public System.Net.NetworkInformation.NetworkInformationAccess : Enum {
public int value__
public NetworkInformationAccess None
public NetworkInformationAccess Read
public NetworkInformationAccess Ping
}
public System.Net.NetworkInformation.NetworkInformationException : Win32Exception {
public int ErrorCode
public void .ctor(int errorCode)
internal void .ctor(SocketError socketError)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public int get_ErrorCode()
}
public System.Net.NetworkInformation.NetworkInformationPermission : CodeAccessPermission {
private NetworkInformationAccess access
private bool unrestricted
public NetworkInformationAccess Access
public void .ctor(PermissionState state)
internal void .ctor(bool unrestricted)
public void .ctor(NetworkInformationAccess access)
public NetworkInformationAccess get_Access()
public void AddPermission(NetworkInformationAccess access)
public bool IsUnrestricted()
public IPermission Copy()
public IPermission Union(IPermission target)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
}
public System.Net.NetworkInformation.NetworkInformationPermissionAttribute : CodeAccessSecurityAttribute {
private string strAccess
private string access
public string Access
public void .ctor(SecurityAction action)
public string get_Access()
public void set_Access(string value)
public IPermission CreatePermission()
}
public System.Net.NetworkInformation.NetworkInterface : object {
public int LoopbackInterfaceIndex
public int IPv6LoopbackInterfaceIndex
public string Id
public string Name
public string Description
public OperationalStatus OperationalStatus
public long Speed
public bool IsReceiveOnly
public bool SupportsMulticast
public NetworkInterfaceType NetworkInterfaceType
public NetworkInterface[] GetAllNetworkInterfaces()
public bool GetIsNetworkAvailable()
public int get_LoopbackInterfaceIndex()
public int get_IPv6LoopbackInterfaceIndex()
public string get_Id()
public string get_Name()
public string get_Description()
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public IPInterfaceStatistics GetIPStatistics()
public OperationalStatus get_OperationalStatus()
public long get_Speed()
public bool get_IsReceiveOnly()
public bool get_SupportsMulticast()
public PhysicalAddress GetPhysicalAddress()
public NetworkInterfaceType get_NetworkInterfaceType()
public bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
}
public System.Net.NetworkInformation.NetworkInterfaceComponent : Enum {
public int value__
public NetworkInterfaceComponent IPv4
public NetworkInterfaceComponent IPv6
}
internal System.Net.NetworkInformation.NetworkInterfaceFactory : object {
public NetworkInterface[] GetAllNetworkInterfaces()
public int GetLoopbackInterfaceIndex()
public IPAddress GetNetMask(IPAddress address)
public NetworkInterfaceFactory Create()
}
public System.Net.NetworkInformation.NetworkInterfaceType : Enum {
public int value__
public NetworkInterfaceType Unknown
public NetworkInterfaceType Ethernet
public NetworkInterfaceType TokenRing
public NetworkInterfaceType Fddi
public NetworkInterfaceType BasicIsdn
public NetworkInterfaceType PrimaryIsdn
public NetworkInterfaceType Ppp
public NetworkInterfaceType Loopback
public NetworkInterfaceType Ethernet3Megabit
public NetworkInterfaceType Slip
public NetworkInterfaceType Atm
public NetworkInterfaceType GenericModem
public NetworkInterfaceType FastEthernetT
public NetworkInterfaceType Isdn
public NetworkInterfaceType FastEthernetFx
public NetworkInterfaceType Wireless80211
public NetworkInterfaceType AsymmetricDsl
public NetworkInterfaceType RateAdaptDsl
public NetworkInterfaceType SymmetricDsl
public NetworkInterfaceType VeryHighSpeedDsl
public NetworkInterfaceType IPOverAtm
public NetworkInterfaceType GigabitEthernet
public NetworkInterfaceType Tunnel
public NetworkInterfaceType MultiRateSymmetricDsl
public NetworkInterfaceType HighPerformanceSerialBus
public NetworkInterfaceType Wman
public NetworkInterfaceType Wwanpp
public NetworkInterfaceType Wwanpp2
}
public System.Net.NetworkInformation.OperationalStatus : Enum {
public int value__
public OperationalStatus Up
public OperationalStatus Down
public OperationalStatus Testing
public OperationalStatus Unknown
public OperationalStatus Dormant
public OperationalStatus NotPresent
public OperationalStatus LowerLayerDown
}
public System.Net.NetworkInformation.PhysicalAddress : object {
private Byte[] address
private bool changed
private int hash
public PhysicalAddress None
public void .ctor(Byte[] address)
public int GetHashCode()
public bool Equals(object comparand)
public string ToString()
public Byte[] GetAddressBytes()
public PhysicalAddress Parse(string address)
}
public System.Net.NetworkInformation.Ping : Component {
private int DefaultCount
private String[] PingBinPaths
private string PingBinPath
private bool canSendPrivileged
private int default_timeout
private ushort identifier
private UInt32 _LINUX_CAPABILITY_VERSION_1
private Byte[] default_buffer
private BackgroundWorker worker
private object user_async_state
private CancellationTokenSource cts
private PingCompletedEventHandler PingCompleted
public void add_PingCompleted(PingCompletedEventHandler value)
public void remove_PingCompleted(PingCompletedEventHandler value)
private int capget(cap_user_header_t& header, cap_user_data_t& data)
private void CheckLinuxCapabilities()
private void System.IDisposable.Dispose()
protected void OnPingCompleted(PingCompletedEventArgs e)
public PingReply Send(IPAddress address)
public PingReply Send(IPAddress address, int timeout)
public PingReply Send(IPAddress address, int timeout, Byte[] buffer)
public PingReply Send(string hostNameOrAddress)
public PingReply Send(string hostNameOrAddress, int timeout)
public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer)
public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options)
public PingReply Send(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
private PingReply SendPrivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
private PingReply SendUnprivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
public void SendAsync(IPAddress address, int timeout, Byte[] buffer, object userToken)
public void SendAsync(IPAddress address, int timeout, object userToken)
public void SendAsync(IPAddress address, object userToken)
public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, object userToken)
public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options, object userToken)
public void SendAsync(string hostNameOrAddress, int timeout, object userToken)
public void SendAsync(string hostNameOrAddress, object userToken)
public void SendAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options, object userToken)
public void SendAsyncCancel()
private string BuildPingArgs(IPAddress address, int timeout, PingOptions options)
public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer)
public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout)
public Task`1<PingReply> SendPingAsync(IPAddress address)
public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer)
public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options)
public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout)
public Task`1<PingReply> SendPingAsync(string hostNameOrAddress)
public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
}
public System.Net.NetworkInformation.PingCompletedEventArgs : AsyncCompletedEventArgs {
private PingReply reply
public PingReply Reply
internal void .ctor(Exception ex, bool cancelled, object userState, PingReply reply)
public PingReply get_Reply()
}
public System.Net.NetworkInformation.PingCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PingCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, PingCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.NetworkInformation.PingException : InvalidOperationException {
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Net.NetworkInformation.PingOptions : object {
private int DontFragmentFlag
private int ttl
private bool dontFragment
public int Ttl
public bool DontFragment
public void .ctor(int ttl, bool dontFragment)
public int get_Ttl()
public void set_Ttl(int value)
public bool get_DontFragment()
public void set_DontFragment(bool value)
}
public System.Net.NetworkInformation.PingReply : object {
private IPAddress address
private PingOptions options
private IPStatus ipStatus
private long rtt
private Byte[] buffer
public IPStatus Status
public IPAddress Address
public long RoundtripTime
public PingOptions Options
public Byte[] Buffer
internal void .ctor(IPStatus ipStatus)
internal void .ctor(Byte[] data, int dataLength, IPAddress address, int time)
internal void .ctor(IPAddress address, Byte[] buffer, PingOptions options, long roundtripTime, IPStatus status)
private IPStatus GetIPStatus(IcmpV4Type type, IcmpV4Code code)
public IPStatus get_Status()
public IPAddress get_Address()
public long get_RoundtripTime()
public PingOptions get_Options()
public Byte[] get_Buffer()
}
public System.Net.NetworkInformation.PrefixOrigin : Enum {
public int value__
public PrefixOrigin Other
public PrefixOrigin Manual
public PrefixOrigin WellKnown
public PrefixOrigin Dhcp
public PrefixOrigin RouterAdvertisement
}
public System.Net.NetworkInformation.ScopeLevel : Enum {
public int value__
public ScopeLevel None
public ScopeLevel Interface
public ScopeLevel Link
public ScopeLevel Subnet
public ScopeLevel Admin
public ScopeLevel Site
public ScopeLevel Organization
public ScopeLevel Global
}
internal System.Net.NetworkInformation.sockaddr_in : ValueType {
public ushort sin_family
public ushort sin_port
public UInt32 sin_addr
}
internal System.Net.NetworkInformation.sockaddr_in6 : ValueType {
public ushort sin6_family
public ushort sin6_port
public UInt32 sin6_flowinfo
public in6_addr sin6_addr
public UInt32 sin6_scope_id
}
internal System.Net.NetworkInformation.sockaddr_ll : ValueType {
public ushort sll_family
public ushort sll_protocol
public int sll_ifindex
public ushort sll_hatype
public byte sll_pkttype
public byte sll_halen
public Byte[] sll_addr
}
internal System.Net.NetworkInformation.StartIPOptions : Enum {
public int value__
public StartIPOptions Both
public StartIPOptions None
public StartIPOptions StartIPv4
public StartIPOptions StartIPv6
}
public System.Net.NetworkInformation.SuffixOrigin : Enum {
public int value__
public SuffixOrigin Other
public SuffixOrigin Manual
public SuffixOrigin WellKnown
public SuffixOrigin OriginDhcp
public SuffixOrigin LinkLayerAddress
public SuffixOrigin Random
}
internal System.Net.NetworkInformation.SystemGatewayIPAddressInformation : GatewayIPAddressInformation {
private IPAddress address
public IPAddress Address
internal void .ctor(IPAddress address)
public IPAddress get_Address()
internal GatewayIPAddressInformationCollection ToGatewayIpAddressInformationCollection(IPAddressCollection addresses)
}
internal System.Net.NetworkInformation.SystemIPAddressInformation : IPAddressInformation {
private IPAddress address
internal bool transient
internal bool dnsEligible
public IPAddress Address
public bool IsTransient
public bool IsDnsEligible
public void .ctor(IPAddress address, bool isDnsEligible, bool isTransient)
public IPAddress get_Address()
public bool get_IsTransient()
public bool get_IsDnsEligible()
}
internal System.Net.NetworkInformation.SystemMulticastIPAddressInformation : MulticastIPAddressInformation {
private SystemIPAddressInformation innerInfo
public IPAddress Address
public bool IsTransient
public bool IsDnsEligible
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public long AddressValidLifetime
public long AddressPreferredLifetime
public long DhcpLeaseLifetime
public void .ctor(SystemIPAddressInformation addressInfo)
public IPAddress get_Address()
public bool get_IsTransient()
public bool get_IsDnsEligible()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public long get_AddressValidLifetime()
public long get_AddressPreferredLifetime()
public long get_DhcpLeaseLifetime()
internal MulticastIPAddressInformationCollection ToMulticastIpAddressInformationCollection(IPAddressInformationCollection addresses)
}
internal System.Net.NetworkInformation.SystemNetworkInterface : object {
private NetworkInterfaceFactory nif
public int InternalLoopbackInterfaceIndex
public int InternalIPv6LoopbackInterfaceIndex
public NetworkInterface[] GetNetworkInterfaces()
public bool InternalGetIsNetworkAvailable()
public int get_InternalLoopbackInterfaceIndex()
public int get_InternalIPv6LoopbackInterfaceIndex()
public IPAddress GetNetMask(IPAddress address)
}
internal System.Net.NetworkInformation.SystemTcpConnectionInformation : TcpConnectionInformation {
private IPEndPoint localEndPoint
private IPEndPoint remoteEndPoint
private TcpState state
public TcpState State
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public void .ctor(IPEndPoint local, IPEndPoint remote, TcpState state)
public TcpState get_State()
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
}
public System.Net.NetworkInformation.TcpConnectionInformation : object {
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public TcpState State
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
public TcpState get_State()
}
public System.Net.NetworkInformation.TcpState : Enum {
public int value__
public TcpState Unknown
public TcpState Closed
public TcpState Listen
public TcpState SynSent
public TcpState SynReceived
public TcpState Established
public TcpState FinWait1
public TcpState FinWait2
public TcpState CloseWait
public TcpState Closing
public TcpState LastAck
public TcpState TimeWait
public TcpState DeleteTcb
}
public System.Net.NetworkInformation.TcpStatistics : object {
public long ConnectionsAccepted
public long ConnectionsInitiated
public long CumulativeConnections
public long CurrentConnections
public long ErrorsReceived
public long FailedConnectionAttempts
public long MaximumConnections
public long MaximumTransmissionTimeout
public long MinimumTransmissionTimeout
public long ResetConnections
public long SegmentsReceived
public long SegmentsResent
public long SegmentsSent
public long ResetsSent
public long get_ConnectionsAccepted()
public long get_ConnectionsInitiated()
public long get_CumulativeConnections()
public long get_CurrentConnections()
public long get_ErrorsReceived()
public long get_FailedConnectionAttempts()
public long get_MaximumConnections()
public long get_MaximumTransmissionTimeout()
public long get_MinimumTransmissionTimeout()
public long get_ResetConnections()
public long get_SegmentsReceived()
public long get_SegmentsResent()
public long get_SegmentsSent()
public long get_ResetsSent()
}
public System.Net.NetworkInformation.UdpStatistics : object {
public long DatagramsReceived
public long DatagramsSent
public long IncomingDatagramsDiscarded
public long IncomingDatagramsWithErrors
public int UdpListeners
public long get_DatagramsReceived()
public long get_DatagramsSent()
public long get_IncomingDatagramsDiscarded()
public long get_IncomingDatagramsWithErrors()
public int get_UdpListeners()
}
public System.Net.NetworkInformation.UnicastIPAddressInformation : IPAddressInformation {
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public IPAddress IPv4Mask
public int PrefixLength
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
public IPAddress get_IPv4Mask()
public int get_PrefixLength()
}
public System.Net.NetworkInformation.UnicastIPAddressInformationCollection : object {
private Collection`1<UnicastIPAddressInformation> addresses
public int Count
public bool IsReadOnly
public UnicastIPAddressInformation Item
public void CopyTo(UnicastIPAddressInformation[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public void Add(UnicastIPAddressInformation address)
internal void InternalAdd(UnicastIPAddressInformation address)
public bool Contains(UnicastIPAddressInformation address)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<UnicastIPAddressInformation> GetEnumerator()
public UnicastIPAddressInformation get_Item(int index)
public bool Remove(UnicastIPAddressInformation address)
public void Clear()
}
internal System.Net.NetworkInformation.UnixIPGlobalProperties : CommonUnixIPGlobalProperties {
public TcpConnectionInformation[] GetActiveTcpConnections()
public IPEndPoint[] GetActiveTcpListeners()
public IPEndPoint[] GetActiveUdpListeners()
public IcmpV4Statistics GetIcmpV4Statistics()
public IcmpV6Statistics GetIcmpV6Statistics()
public IPGlobalStatistics GetIPv4GlobalStatistics()
public IPGlobalStatistics GetIPv6GlobalStatistics()
public TcpStatistics GetTcpIPv4Statistics()
public TcpStatistics GetTcpIPv6Statistics()
public UdpStatistics GetUdpIPv4Statistics()
public UdpStatistics GetUdpIPv6Statistics()
}
internal System.Net.NetworkInformation.UnixIPInterfaceProperties : IPInterfaceProperties {
protected IPv4InterfaceProperties ipv4iface_properties
protected UnixNetworkInterface iface
private List`1<IPAddress> addresses
private IPAddressCollection dns_servers
private Regex ns
private Regex search
private string dns_suffix
private DateTime last_parse
public IPAddressInformationCollection AnycastAddresses
public IPAddressCollection DhcpServerAddresses
public IPAddressCollection DnsAddresses
public string DnsSuffix
public bool IsDnsEnabled
public bool IsDynamicDnsEnabled
public MulticastIPAddressInformationCollection MulticastAddresses
public UnicastIPAddressInformationCollection UnicastAddresses
public IPAddressCollection WinsServersAddresses
public void .ctor(UnixNetworkInterface iface, List`1<IPAddress> addresses)
public IPv6InterfaceProperties GetIPv6Properties()
private void ParseResolvConf()
public IPAddressInformationCollection get_AnycastAddresses()
public IPAddressCollection get_DhcpServerAddresses()
public IPAddressCollection get_DnsAddresses()
public string get_DnsSuffix()
public bool get_IsDnsEnabled()
public bool get_IsDynamicDnsEnabled()
public MulticastIPAddressInformationCollection get_MulticastAddresses()
public UnicastIPAddressInformationCollection get_UnicastAddresses()
public IPAddressCollection get_WinsServersAddresses()
}
internal System.Net.NetworkInformation.UnixIPv4InterfaceProperties : IPv4InterfaceProperties {
protected UnixNetworkInterface iface
public int Index
public bool IsAutomaticPrivateAddressingActive
public bool IsAutomaticPrivateAddressingEnabled
public bool IsDhcpEnabled
public bool UsesWins
public void .ctor(UnixNetworkInterface iface)
public int get_Index()
public bool get_IsAutomaticPrivateAddressingActive()
public bool get_IsAutomaticPrivateAddressingEnabled()
public bool get_IsDhcpEnabled()
public bool get_UsesWins()
}
internal System.Net.NetworkInformation.UnixNetworkInterface : NetworkInterface {
protected IPv4InterfaceStatistics ipv4stats
protected IPInterfaceProperties ipproperties
private string name
protected List`1<IPAddress> addresses
private Byte[] macAddress
private NetworkInterfaceType type
public string Description
public string Id
public bool IsReceiveOnly
public string Name
public NetworkInterfaceType NetworkInterfaceType
public long Speed
internal int NameIndex
internal void .ctor(string name)
internal void AddAddress(IPAddress address)
internal void SetLinkLayerInfo(int index, Byte[] macAddress, NetworkInterfaceType type)
public PhysicalAddress GetPhysicalAddress()
public bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
public string get_Description()
public string get_Id()
public bool get_IsReceiveOnly()
public string get_Name()
public NetworkInterfaceType get_NetworkInterfaceType()
public long get_Speed()
internal int get_NameIndex()
}
internal System.Net.NetworkInformation.Win32_FIXED_INFO : ValueType {
private int MAX_HOSTNAME_LEN
private int MAX_DOMAIN_NAME_LEN
private int MAX_SCOPE_ID_LEN
public string HostName
public string DomainName
public IntPtr CurrentDnsServer
public Win32_IP_ADDR_STRING DnsServerList
public NetBiosNodeType NodeType
public string ScopeId
public UInt32 EnableRouting
public UInt32 EnableProxy
public UInt32 EnableDns
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_ADDRESSES : ValueType {
public AlignmentUnion Alignment
public IntPtr Next
public string AdapterName
public IntPtr FirstUnicastAddress
public IntPtr FirstAnycastAddress
public IntPtr FirstMulticastAddress
public IntPtr FirstDnsServerAddress
public string DnsSuffix
public string Description
public string FriendlyName
public Byte[] PhysicalAddress
public UInt32 PhysicalAddressLength
public UInt32 Flags
public UInt32 Mtu
public NetworkInterfaceType IfType
public OperationalStatus OperStatus
public int Ipv6IfIndex
public UInt32[] ZoneIndices
private int MAX_ADAPTER_ADDRESS_LENGTH
private int IP_ADAPTER_DDNS_ENABLED
private int IP_ADAPTER_RECEIVE_ONLY
private int IP_ADAPTER_NO_MULTICAST
public bool DdnsEnabled
public bool IsReceiveOnly
public bool NoMulticast
public bool get_DdnsEnabled()
public bool get_IsReceiveOnly()
public bool get_NoMulticast()
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_ANYCAST_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_DNS_SERVER_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_INFO : ValueType {
private int MAX_ADAPTER_NAME_LENGTH
private int MAX_ADAPTER_DESCRIPTION_LENGTH
private int MAX_ADAPTER_ADDRESS_LENGTH
public IntPtr Next
public int ComboIndex
public string AdapterName
public string Description
public UInt32 AddressLength
public Byte[] Address
public UInt32 Index
public UInt32 Type
public UInt32 DhcpEnabled
public IntPtr CurrentIpAddress
public Win32_IP_ADDR_STRING IpAddressList
public Win32_IP_ADDR_STRING GatewayList
public Win32_IP_ADDR_STRING DhcpServer
public bool HaveWins
public Win32_IP_ADDR_STRING PrimaryWinsServer
public Win32_IP_ADDR_STRING SecondaryWinsServer
public long LeaseObtained
public long LeaseExpires
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_MULTICAST_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_UNICAST_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public DuplicateAddressDetectionState DadState
public UInt32 ValidLifetime
public UInt32 PreferredLifetime
public UInt32 LeaseLifetime
public byte OnLinkPrefixLength
}
internal System.Net.NetworkInformation.Win32_IP_ADDR_STRING : ValueType {
public IntPtr Next
public string IpAddress
public string IpMask
public UInt32 Context
}
internal System.Net.NetworkInformation.Win32_IP_PER_ADAPTER_INFO : object {
public UInt32 AutoconfigEnabled
public UInt32 AutoconfigActive
public IntPtr CurrentDnsServer
public Win32_IP_ADDR_STRING DnsServerList
}
internal System.Net.NetworkInformation.Win32_MIB_ICMP_EX : ValueType {
public Win32_MIBICMPSTATS_EX InStats
public Win32_MIBICMPSTATS_EX OutStats
}
internal System.Net.NetworkInformation.Win32_MIB_IFROW : ValueType {
private int MAX_INTERFACE_NAME_LEN
private int MAXLEN_PHYSADDR
private int MAXLEN_IFDESCR
public Char[] Name
public int Index
public NetworkInterfaceType Type
public int Mtu
public UInt32 Speed
public int PhysAddrLen
public Byte[] PhysAddr
public UInt32 AdminStatus
public UInt32 OperStatus
public UInt32 LastChange
public int InOctets
public int InUcastPkts
public int InNUcastPkts
public int InDiscards
public int InErrors
public int InUnknownProtos
public int OutOctets
public int OutUcastPkts
public int OutNUcastPkts
public int OutDiscards
public int OutErrors
public int OutQLen
public int DescrLen
public Byte[] Descr
}
internal System.Net.NetworkInformation.Win32_MIB_IPSTATS : ValueType {
public int Forwarding
public int DefaultTTL
public UInt32 InReceives
public UInt32 InHdrErrors
public UInt32 InAddrErrors
public UInt32 ForwDatagrams
public UInt32 InUnknownProtos
public UInt32 InDiscards
public UInt32 InDelivers
public UInt32 OutRequests
public UInt32 RoutingDiscards
public UInt32 OutDiscards
public UInt32 OutNoRoutes
public UInt32 ReasmTimeout
public UInt32 ReasmReqds
public UInt32 ReasmOks
public UInt32 ReasmFails
public UInt32 FragOks
public UInt32 FragFails
public UInt32 FragCreates
public int NumIf
public int NumAddr
public int NumRoutes
}
internal System.Net.NetworkInformation.Win32_MIB_TCPSTATS : ValueType {
public UInt32 RtoAlgorithm
public UInt32 RtoMin
public UInt32 RtoMax
public UInt32 MaxConn
public UInt32 ActiveOpens
public UInt32 PassiveOpens
public UInt32 AttemptFails
public UInt32 EstabResets
public UInt32 CurrEstab
public UInt32 InSegs
public UInt32 OutSegs
public UInt32 RetransSegs
public UInt32 InErrs
public UInt32 OutRsts
public UInt32 NumConns
}
internal System.Net.NetworkInformation.Win32_MIB_UDPSTATS : ValueType {
public UInt32 InDatagrams
public UInt32 NoPorts
public UInt32 InErrors
public UInt32 OutDatagrams
public int NumAddrs
}
internal System.Net.NetworkInformation.Win32_MIBICMPINFO : ValueType {
public Win32_MIBICMPSTATS InStats
public Win32_MIBICMPSTATS OutStats
}
internal System.Net.NetworkInformation.Win32_MIBICMPSTATS : ValueType {
public UInt32 Msgs
public UInt32 Errors
public UInt32 DestUnreachs
public UInt32 TimeExcds
public UInt32 ParmProbs
public UInt32 SrcQuenchs
public UInt32 Redirects
public UInt32 Echos
public UInt32 EchoReps
public UInt32 Timestamps
public UInt32 TimestampReps
public UInt32 AddrMasks
public UInt32 AddrMaskReps
}
internal System.Net.NetworkInformation.Win32_MIBICMPSTATS_EX : ValueType {
public UInt32 Msgs
public UInt32 Errors
public UInt32[] Counts
}
internal System.Net.NetworkInformation.Win32_SOCKADDR : ValueType {
public ushort AddressFamily
public Byte[] AddressData
}
internal System.Net.NetworkInformation.Win32_SOCKET_ADDRESS : ValueType {
public IntPtr Sockaddr
public int SockaddrLength
private int AF_INET6
public IPAddress GetIPAddress()
}
internal System.Net.NetworkInformation.Win32IcmpV4Statistics : IcmpV4Statistics {
private Win32_MIBICMPSTATS iin
private Win32_MIBICMPSTATS iout
public long AddressMaskRepliesReceived
public long AddressMaskRepliesSent
public long AddressMaskRequestsReceived
public long AddressMaskRequestsSent
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MessagesReceived
public long MessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long SourceQuenchesReceived
public long SourceQuenchesSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long TimestampRepliesReceived
public long TimestampRepliesSent
public long TimestampRequestsReceived
public long TimestampRequestsSent
public void .ctor(Win32_MIBICMPINFO info)
public long get_AddressMaskRepliesReceived()
public long get_AddressMaskRepliesSent()
public long get_AddressMaskRequestsReceived()
public long get_AddressMaskRequestsSent()
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_SourceQuenchesReceived()
public long get_SourceQuenchesSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
public long get_TimestampRepliesReceived()
public long get_TimestampRepliesSent()
public long get_TimestampRequestsReceived()
public long get_TimestampRequestsSent()
}
internal System.Net.NetworkInformation.Win32IcmpV6Statistics : IcmpV6Statistics {
private Win32_MIBICMPSTATS_EX iin
private Win32_MIBICMPSTATS_EX iout
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MembershipQueriesReceived
public long MembershipQueriesSent
public long MembershipReductionsReceived
public long MembershipReductionsSent
public long MembershipReportsReceived
public long MembershipReportsSent
public long MessagesReceived
public long MessagesSent
public long NeighborAdvertisementsReceived
public long NeighborAdvertisementsSent
public long NeighborSolicitsReceived
public long NeighborSolicitsSent
public long PacketTooBigMessagesReceived
public long PacketTooBigMessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long RouterAdvertisementsReceived
public long RouterAdvertisementsSent
public long RouterSolicitsReceived
public long RouterSolicitsSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public void .ctor(Win32_MIB_ICMP_EX info)
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MembershipQueriesReceived()
public long get_MembershipQueriesSent()
public long get_MembershipReductionsReceived()
public long get_MembershipReductionsSent()
public long get_MembershipReportsReceived()
public long get_MembershipReportsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_NeighborAdvertisementsReceived()
public long get_NeighborAdvertisementsSent()
public long get_NeighborSolicitsReceived()
public long get_NeighborSolicitsSent()
public long get_PacketTooBigMessagesReceived()
public long get_PacketTooBigMessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_RouterAdvertisementsReceived()
public long get_RouterAdvertisementsSent()
public long get_RouterSolicitsReceived()
public long get_RouterSolicitsSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
}
internal System.Net.NetworkInformation.Win32IPAddressCollection : IPAddressCollection {
public Win32IPAddressCollection Empty
public void .ctor(IntPtr[] heads)
public void .ctor(Win32_IP_ADDR_STRING[] al)
public Win32IPAddressCollection FromAnycast(IntPtr ptr)
public Win32IPAddressCollection FromDnsServer(IntPtr ptr)
private void AddSubsequentlyString(IntPtr head)
}
internal System.Net.NetworkInformation.Win32IPGlobalProperties : IPGlobalProperties {
public int AF_INET
public int AF_INET6
public string DhcpScopeName
public string DomainName
public string HostName
public bool IsWinsProxy
public NetBiosNodeType NodeType
private void FillTcpTable(List`1& tab4, List`1& tab6)
private bool IsListenerState(TcpState state)
public TcpConnectionInformation[] GetActiveTcpConnections()
public IPEndPoint[] GetActiveTcpListeners()
public IPEndPoint[] GetActiveUdpListeners()
public IcmpV4Statistics GetIcmpV4Statistics()
public IcmpV6Statistics GetIcmpV6Statistics()
public IPGlobalStatistics GetIPv4GlobalStatistics()
public IPGlobalStatistics GetIPv6GlobalStatistics()
public TcpStatistics GetTcpIPv4Statistics()
public TcpStatistics GetTcpIPv6Statistics()
public UdpStatistics GetUdpIPv4Statistics()
public UdpStatistics GetUdpIPv6Statistics()
public string get_DhcpScopeName()
public string get_DomainName()
public string get_HostName()
public bool get_IsWinsProxy()
public NetBiosNodeType get_NodeType()
private int GetTcpTable(Byte[] pTcpTable, Int32& pdwSize, bool bOrder)
private int GetTcp6Table(Byte[] TcpTable, Int32& SizePointer, bool Order)
private int GetUdpTable(Byte[] pUdpTable, Int32& pdwSize, bool bOrder)
private int GetUdp6Table(Byte[] Udp6Table, Int32& SizePointer, bool Order)
private int GetTcpStatisticsEx(Win32_MIB_TCPSTATS& pStats, int dwFamily)
private int GetUdpStatisticsEx(Win32_MIB_UDPSTATS& pStats, int dwFamily)
private int GetIcmpStatistics(Win32_MIBICMPINFO& pStats, int dwFamily)
private int GetIcmpStatisticsEx(Win32_MIB_ICMP_EX& pStats, int dwFamily)
private int GetIpStatisticsEx(Win32_MIB_IPSTATS& pStats, int dwFamily)
}
internal System.Net.NetworkInformation.Win32IPGlobalStatistics : IPGlobalStatistics {
private Win32_MIB_IPSTATS info
public int DefaultTtl
public bool ForwardingEnabled
public int NumberOfInterfaces
public int NumberOfIPAddresses
public int NumberOfRoutes
public long OutputPacketRequests
public long OutputPacketRoutingDiscards
public long OutputPacketsDiscarded
public long OutputPacketsWithNoRoute
public long PacketFragmentFailures
public long PacketReassembliesRequired
public long PacketReassemblyFailures
public long PacketReassemblyTimeout
public long PacketsFragmented
public long PacketsReassembled
public long ReceivedPackets
public long ReceivedPacketsDelivered
public long ReceivedPacketsDiscarded
public long ReceivedPacketsForwarded
public long ReceivedPacketsWithAddressErrors
public long ReceivedPacketsWithHeadersErrors
public long ReceivedPacketsWithUnknownProtocol
public void .ctor(Win32_MIB_IPSTATS info)
public int get_DefaultTtl()
public bool get_ForwardingEnabled()
public int get_NumberOfInterfaces()
public int get_NumberOfIPAddresses()
public int get_NumberOfRoutes()
public long get_OutputPacketRequests()
public long get_OutputPacketRoutingDiscards()
public long get_OutputPacketsDiscarded()
public long get_OutputPacketsWithNoRoute()
public long get_PacketFragmentFailures()
public long get_PacketReassembliesRequired()
public long get_PacketReassemblyFailures()
public long get_PacketReassemblyTimeout()
public long get_PacketsFragmented()
public long get_PacketsReassembled()
public long get_ReceivedPackets()
public long get_ReceivedPacketsDelivered()
public long get_ReceivedPacketsDiscarded()
public long get_ReceivedPacketsForwarded()
public long get_ReceivedPacketsWithAddressErrors()
public long get_ReceivedPacketsWithHeadersErrors()
public long get_ReceivedPacketsWithUnknownProtocol()
}
internal System.Net.NetworkInformation.Win32IPInterfaceProperties2 : IPInterfaceProperties {
private Win32_IP_ADAPTER_ADDRESSES addr
private Win32_MIB_IFROW mib4
private Win32_MIB_IFROW mib6
public IPAddressInformationCollection AnycastAddresses
public IPAddressCollection DhcpServerAddresses
public IPAddressCollection DnsAddresses
public string DnsSuffix
public GatewayIPAddressInformationCollection GatewayAddresses
public bool IsDnsEnabled
public bool IsDynamicDnsEnabled
public MulticastIPAddressInformationCollection MulticastAddresses
public UnicastIPAddressInformationCollection UnicastAddresses
public IPAddressCollection WinsServersAddresses
public void .ctor(Win32_IP_ADAPTER_ADDRESSES addr, Win32_MIB_IFROW mib4, Win32_MIB_IFROW mib6)
public IPv4InterfaceProperties GetIPv4Properties()
public IPv6InterfaceProperties GetIPv6Properties()
public IPAddressInformationCollection get_AnycastAddresses()
private IPAddressInformationCollection Win32FromAnycast(IntPtr ptr)
public IPAddressCollection get_DhcpServerAddresses()
public IPAddressCollection get_DnsAddresses()
public string get_DnsSuffix()
public GatewayIPAddressInformationCollection get_GatewayAddresses()
private void AddSubsequently(IntPtr head, GatewayIPAddressInformationCollection col)
public bool get_IsDnsEnabled()
public bool get_IsDynamicDnsEnabled()
public MulticastIPAddressInformationCollection get_MulticastAddresses()
private MulticastIPAddressInformationCollection Win32FromMulticast(IntPtr ptr)
public UnicastIPAddressInformationCollection get_UnicastAddresses()
private UnicastIPAddressInformationCollection Win32FromUnicast(IntPtr ptr)
public IPAddressCollection get_WinsServersAddresses()
}
internal System.Net.NetworkInformation.Win32IPv4InterfaceProperties : IPv4InterfaceProperties {
private Win32_IP_ADAPTER_INFO ainfo
private Win32_IP_PER_ADAPTER_INFO painfo
private Win32_MIB_IFROW mib
public int Index
public bool IsAutomaticPrivateAddressingActive
public bool IsAutomaticPrivateAddressingEnabled
public bool IsDhcpEnabled
public bool IsForwardingEnabled
public int Mtu
public bool UsesWins
private int GetPerAdapterInfo(int IfIndex, Win32_IP_PER_ADAPTER_INFO pPerAdapterInfo, Int32& pOutBufLen)
public void .ctor(Win32_IP_ADAPTER_INFO ainfo, Win32_MIB_IFROW mib)
public int get_Index()
public bool get_IsAutomaticPrivateAddressingActive()
public bool get_IsAutomaticPrivateAddressingEnabled()
public bool get_IsDhcpEnabled()
public bool get_IsForwardingEnabled()
public int get_Mtu()
public bool get_UsesWins()
}
internal System.Net.NetworkInformation.Win32IPv4InterfaceStatistics : IPv4InterfaceStatistics {
private Win32_MIB_IFROW info
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public void .ctor(Win32_MIB_IFROW info)
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
internal System.Net.NetworkInformation.Win32IPv6InterfaceProperties : IPv6InterfaceProperties {
private Win32_MIB_IFROW mib
public int Index
public int Mtu
public void .ctor(Win32_MIB_IFROW mib)
public int get_Index()
public int get_Mtu()
}
internal System.Net.NetworkInformation.Win32LengthFlagsUnion : ValueType {
private int IP_ADAPTER_ADDRESS_DNS_ELIGIBLE
private int IP_ADAPTER_ADDRESS_TRANSIENT
public UInt32 Length
public UInt32 Flags
public bool IsDnsEligible
public bool IsTransient
public bool get_IsDnsEligible()
public bool get_IsTransient()
}
internal System.Net.NetworkInformation.Win32NetworkInterface : object {
private Win32_FIXED_INFO fixedInfo
private bool initialized
public Win32_FIXED_INFO FixedInfo
private int GetNetworkParams(IntPtr ptr, Int32& size)
public Win32_FIXED_INFO get_FixedInfo()
}
internal System.Net.NetworkInformation.Win32NetworkInterface2 : NetworkInterface {
private Win32_IP_ADAPTER_ADDRESSES addr
private Win32_MIB_IFROW mib4
private Win32_MIB_IFROW mib6
private Win32IPv4InterfaceStatistics ip4stats
private IPInterfaceProperties ip_if_props
public string Description
public string Id
public bool IsReceiveOnly
public string Name
public NetworkInterfaceType NetworkInterfaceType
public OperationalStatus OperationalStatus
public long Speed
public bool SupportsMulticast
private int GetAdaptersInfo(IntPtr info, Int32& size)
private int GetIfEntry(Win32_MIB_IFROW& row)
public Win32_IP_ADAPTER_INFO GetAdapterInfoByIndex(int index)
private Win32_IP_ADAPTER_INFO[] GetAdaptersInfo()
internal void .ctor(Win32_IP_ADAPTER_ADDRESSES addr)
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public PhysicalAddress GetPhysicalAddress()
public bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
public string get_Description()
public string get_Id()
public bool get_IsReceiveOnly()
public string get_Name()
public NetworkInterfaceType get_NetworkInterfaceType()
public OperationalStatus get_OperationalStatus()
public long get_Speed()
public bool get_SupportsMulticast()
}
internal System.Net.NetworkInformation.Win32TcpStatistics : TcpStatistics {
private Win32_MIB_TCPSTATS info
public long ConnectionsAccepted
public long ConnectionsInitiated
public long CumulativeConnections
public long CurrentConnections
public long ErrorsReceived
public long FailedConnectionAttempts
public long MaximumConnections
public long MaximumTransmissionTimeout
public long MinimumTransmissionTimeout
public long ResetConnections
public long ResetsSent
public long SegmentsReceived
public long SegmentsResent
public long SegmentsSent
public void .ctor(Win32_MIB_TCPSTATS info)
public long get_ConnectionsAccepted()
public long get_ConnectionsInitiated()
public long get_CumulativeConnections()
public long get_CurrentConnections()
public long get_ErrorsReceived()
public long get_FailedConnectionAttempts()
public long get_MaximumConnections()
public long get_MaximumTransmissionTimeout()
public long get_MinimumTransmissionTimeout()
public long get_ResetConnections()
public long get_ResetsSent()
public long get_SegmentsReceived()
public long get_SegmentsResent()
public long get_SegmentsSent()
}
internal System.Net.NetworkInformation.Win32UdpStatistics : UdpStatistics {
private Win32_MIB_UDPSTATS info
public long DatagramsReceived
public long DatagramsSent
public long IncomingDatagramsDiscarded
public long IncomingDatagramsWithErrors
public int UdpListeners
public void .ctor(Win32_MIB_UDPSTATS info)
public long get_DatagramsReceived()
public long get_DatagramsSent()
public long get_IncomingDatagramsDiscarded()
public long get_IncomingDatagramsWithErrors()
public int get_UdpListeners()
}
internal System.Net.NetworkInformation.Win32UnicastIPAddressInformation : UnicastIPAddressInformation {
private Win32_IP_ADAPTER_UNICAST_ADDRESS info
private IPAddress ipv4Mask
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public IPAddress IPv4Mask
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public void .ctor(Win32_IP_ADAPTER_UNICAST_ADDRESS info)
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public IPAddress get_IPv4Mask()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
private IPAddress PrefixLengthToSubnetMask(byte prefixLength, AddressFamily family)
}
internal System.Net.NtlmClient : object {
private IAuthenticationModule authObject
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
public System.Net.OpenReadCompletedEventArgs : AsyncCompletedEventArgs {
private Stream m_Result
public Stream Result
internal void .ctor(Stream result, Exception exception, bool cancelled, object userToken)
public Stream get_Result()
}
public System.Net.OpenReadCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, OpenReadCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, OpenReadCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.OpenWriteCompletedEventArgs : AsyncCompletedEventArgs {
private Stream m_Result
public Stream Result
internal void .ctor(Stream result, Exception exception, bool cancelled, object userToken)
public Stream get_Result()
}
public System.Net.OpenWriteCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, OpenWriteCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, OpenWriteCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.PathList : object {
private SortedList m_list
public int Count
public ICollection Values
public object Item
public object SyncRoot
public int get_Count()
public int GetCookiesCount()
public ICollection get_Values()
public object get_Item(string s)
public void set_Item(string s, object value)
public IEnumerator GetEnumerator()
public object get_SyncRoot()
}
internal System.Net.PooledStream : Stream {
private bool m_CheckLifetime
private TimeSpan m_Lifetime
private DateTime m_CreateTime
private bool m_ConnectionIsDoomed
private ConnectionPool m_ConnectionPool
private WeakReference m_Owner
private int m_PooledCount
private bool m_Initalizing
private IPAddress m_ServerAddress
private NetworkStream m_NetworkStream
private Socket m_AbortSocket
private Socket m_AbortSocket6
private bool m_JustConnected
private GeneralAsyncDelegate m_AsyncCallback
internal bool JustConnected
internal IPAddress ServerAddress
internal bool IsInitalizing
internal bool CanBePooled
internal bool IsEmancipated
internal object Owner
internal ConnectionPool Pool
internal ServicePoint ServicePoint
protected bool UsingSecureStream
internal NetworkStream NetworkStream
protected Socket Socket
public bool CanRead
public bool CanSeek
public bool CanWrite
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
internal void .ctor(object owner)
internal void .ctor(ConnectionPool connectionPool, TimeSpan lifetime, bool checkLifetime)
internal bool get_JustConnected()
internal IPAddress get_ServerAddress()
internal bool get_IsInitalizing()
internal bool get_CanBePooled()
internal void set_CanBePooled(bool value)
internal bool get_IsEmancipated()
internal object get_Owner()
internal void set_Owner(object value)
internal ConnectionPool get_Pool()
internal ServicePoint get_ServicePoint()
internal bool Activate(object owningObject, GeneralAsyncDelegate asyncCallback)
protected bool Activate(object owningObject, bool async, GeneralAsyncDelegate asyncCallback)
internal void Deactivate()
internal void ConnectionCallback(object owningObject, Exception e, Socket socket, IPAddress address)
protected void CheckLifetime()
internal void UpdateLifetime()
internal void PrePush(object expectedOwner)
internal void PostPop(object newOwner)
protected bool get_UsingSecureStream()
internal NetworkStream get_NetworkStream()
internal void set_NetworkStream(NetworkStream value)
protected Socket get_Socket()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public long Seek(long offset, SeekOrigin origin)
public int Read(Byte[] buffer, int offset, int size)
public void Write(Byte[] buffer, int offset, int size)
internal void MultipleWrite(BufferOffsetSize[] buffers)
protected void Dispose(bool disposing)
internal void CloseSocket()
public void Close(int timeout)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
internal IAsyncResult BeginMultipleWrite(BufferOffsetSize[] buffers, AsyncCallback callback, object state)
internal void EndMultipleWrite(IAsyncResult asyncResult)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public void SetLength(long value)
internal void SetSocketTimeoutOption(SocketShutdown mode, int timeout, bool silent)
internal bool Poll(int microSeconds, SelectMode mode)
internal bool PollRead()
}
public System.Net.ProtocolViolationException : InvalidOperationException {
public void .ctor(string message)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.Net.ProxyChain : object {
private List`1<Uri> m_Cache
private bool m_CacheComplete
private ProxyEnumerator m_MainEnumerator
private Uri m_Destination
private HttpAbortDelegate m_HttpAbortDelegate
internal IEnumerator`1<Uri> Enumerator
internal Uri Destination
internal HttpAbortDelegate HttpAbortDelegate
protected void .ctor(Uri destination)
public IEnumerator`1<Uri> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Dispose()
internal IEnumerator`1<Uri> get_Enumerator()
internal Uri get_Destination()
internal void Abort()
internal bool HttpAbort(HttpWebRequest request, WebException webException)
internal HttpAbortDelegate get_HttpAbortDelegate()
protected bool GetNextProxy(Uri& proxy)
}
internal System.Net.ProxyScriptChain : ProxyChain {
private WebProxy m_Proxy
private Uri[] m_ScriptProxies
private int m_CurrentIndex
private int m_SyncStatus
internal void .ctor(WebProxy proxy, Uri destination)
protected bool GetNextProxy(Uri& proxy)
internal void Abort()
}
internal System.Net.ReadState : Enum {
public int value__
public ReadState None
public ReadState Status
public ReadState Headers
public ReadState Content
public ReadState Aborted
}
internal System.Net.RequestStream : Stream {
private Byte[] buffer
private int offset
private int length
private long remaining_body
private bool disposed
private Stream stream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
internal void .ctor(Stream stream, Byte[] buffer, int offset, int length)
internal void .ctor(Stream stream, Byte[] buffer, int offset, int length, long contentlength)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Close()
public void Flush()
private int FillFromBuffer(Byte[] buffer, int off, int count)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public int EndRead(IAsyncResult ares)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public void EndWrite(IAsyncResult async_result)
}
internal System.Net.ResponseStream : Stream {
private HttpListenerResponse response
private bool ignore_errors
private bool disposed
private bool trailer_sent
private Stream stream
private Byte[] crlf
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
internal void .ctor(Stream stream, HttpListenerResponse response, bool ignore_errors)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Close()
private MemoryStream GetHeaders(bool closing)
public void Flush()
private Byte[] GetChunkSizeBytes(int size, bool final)
internal void InternalWrite(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public void EndWrite(IAsyncResult ares)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public int EndRead(IAsyncResult ares)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
}
internal System.Net.ScatterGatherBuffers : object {
private MemoryChunk headChunk
private MemoryChunk currentChunk
private int nextChunkLength
private int totalLength
private int chunkCount
private bool Empty
internal int Length
internal void .ctor(long totalSize)
internal BufferOffsetSize[] GetBuffers()
private bool get_Empty()
internal int get_Length()
internal void Write(Byte[] buffer, int offset, int count)
private MemoryChunk AllocateMemoryChunk(int newSize)
}
internal System.Net.SecChannelBindings : object {
internal int dwInitiatorAddrType
internal int cbInitiatorLength
internal int dwInitiatorOffset
internal int dwAcceptorAddrType
internal int cbAcceptorLength
internal int dwAcceptorOffset
internal int cbApplicationDataLength
internal int dwApplicationDataOffset
}
public System.Net.Security.AuthenticatedStream : Stream {
private Stream _InnerStream
private bool _LeaveStreamOpen
public bool LeaveInnerStreamOpen
protected Stream InnerStream
public bool IsAuthenticated
public bool IsMutuallyAuthenticated
public bool IsEncrypted
public bool IsSigned
public bool IsServer
protected void .ctor(Stream innerStream, bool leaveInnerStreamOpen)
public bool get_LeaveInnerStreamOpen()
protected Stream get_InnerStream()
protected void Dispose(bool disposing)
public bool get_IsAuthenticated()
public bool get_IsMutuallyAuthenticated()
public bool get_IsEncrypted()
public bool get_IsSigned()
public bool get_IsServer()
}
public System.Net.Security.AuthenticationLevel : Enum {
public int value__
public AuthenticationLevel None
public AuthenticationLevel MutualAuthRequested
public AuthenticationLevel MutualAuthRequired
}
public System.Net.Security.EncryptionPolicy : Enum {
public int value__
public EncryptionPolicy RequireEncryption
public EncryptionPolicy AllowNoEncryption
public EncryptionPolicy NoEncryption
}
public System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
public IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object)
public X509Certificate EndInvoke(IAsyncResult result)
}
internal System.Net.Security.LocalCertSelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public X509Certificate Invoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
public IAsyncResult BeginInvoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object)
public X509Certificate EndInvoke(IAsyncResult result)
}
public System.Net.Security.NegotiateStream : AuthenticatedStream {
private int readTimeout
private int writeTimeout
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public TokenImpersonationLevel ImpersonationLevel
public bool IsAuthenticated
public bool IsEncrypted
public bool IsMutuallyAuthenticated
public bool IsServer
public bool IsSigned
public long Length
public long Position
public int ReadTimeout
public IIdentity RemoteIdentity
public int WriteTimeout
public void .ctor(Stream innerStream)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public TokenImpersonationLevel get_ImpersonationLevel()
public bool get_IsAuthenticated()
public bool get_IsEncrypted()
public bool get_IsMutuallyAuthenticated()
public bool get_IsServer()
public bool get_IsSigned()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public IIdentity get_RemoteIdentity()
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void AuthenticateAsClient()
public void AuthenticateAsClient(NetworkCredential credential, string targetName)
public void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName)
public void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)
public void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)
public void AuthenticateAsServer()
public void AuthenticateAsServer(ExtendedProtectionPolicy policy)
public void AuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
public void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
protected void Dispose(bool disposing)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public int EndRead(IAsyncResult asyncResult)
public void EndAuthenticateAsServer(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public Task AuthenticateAsClientAsync()
public Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName)
public Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)
public Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName)
public Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)
public Task AuthenticateAsServerAsync()
public Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy)
public Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
public Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
}
public System.Net.Security.ProtectionLevel : Enum {
public int value__
public ProtectionLevel None
public ProtectionLevel Sign
public ProtectionLevel EncryptAndSign
}
public System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
public IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal System.Net.Security.RemoteCertValidationCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(string host, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
public IAsyncResult BeginInvoke(string host, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Net.Security.SslPolicyErrors : Enum {
public int value__
public SslPolicyErrors None
public SslPolicyErrors RemoteCertificateNotAvailable
public SslPolicyErrors RemoteCertificateNameMismatch
public SslPolicyErrors RemoteCertificateChainErrors
}
public System.Net.Security.SslStream : AuthenticatedStream {
private MonoTlsProvider provider
private IMonoSslStream impl
internal IMonoSslStream Impl
internal MonoTlsProvider Provider
public TransportContext TransportContext
public bool IsAuthenticated
public bool IsMutuallyAuthenticated
public bool IsEncrypted
public bool IsSigned
public bool IsServer
public SslProtocols SslProtocol
public bool CheckCertRevocationStatus
public X509Certificate LocalCertificate
public X509Certificate RemoteCertificate
public CipherAlgorithmType CipherAlgorithm
public int CipherStrength
public HashAlgorithmType HashAlgorithm
public int HashStrength
public ExchangeAlgorithmType KeyExchangeAlgorithm
public int KeyExchangeStrength
public bool CanSeek
public bool CanRead
public bool CanTimeout
public bool CanWrite
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
internal IMonoSslStream get_Impl()
internal MonoTlsProvider get_Provider()
private MonoTlsProvider GetProvider()
public void .ctor(Stream innerStream)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy)
internal void .ctor(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsProvider provider, MonoTlsSettings settings)
internal IMonoSslStream CreateMonoSslStream(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsProvider provider, MonoTlsSettings settings)
public void AuthenticateAsClient(string targetHost)
public void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public void AuthenticateAsServer(X509Certificate serverCertificate)
public void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public void EndAuthenticateAsServer(IAsyncResult asyncResult)
public TransportContext get_TransportContext()
public Task AuthenticateAsClientAsync(string targetHost)
public Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task ShutdownAsync()
public bool get_IsAuthenticated()
public bool get_IsMutuallyAuthenticated()
public bool get_IsEncrypted()
public bool get_IsSigned()
public bool get_IsServer()
public SslProtocols get_SslProtocol()
public bool get_CheckCertRevocationStatus()
public X509Certificate get_LocalCertificate()
public X509Certificate get_RemoteCertificate()
public CipherAlgorithmType get_CipherAlgorithm()
public int get_CipherStrength()
public HashAlgorithmType get_HashAlgorithm()
public int get_HashStrength()
public ExchangeAlgorithmType get_KeyExchangeAlgorithm()
public int get_KeyExchangeStrength()
public bool get_CanSeek()
public bool get_CanRead()
public bool get_CanTimeout()
public bool get_CanWrite()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void SetLength(long value)
public long Seek(long offset, SeekOrigin origin)
public Task FlushAsync(CancellationToken cancellationToken)
public void Flush()
private void CheckDisposed()
protected void Dispose(bool disposing)
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer)
public void Write(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public int EndRead(IAsyncResult asyncResult)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void EndWrite(IAsyncResult asyncResult)
}
internal System.Net.SecurityBuffer : object {
public int size
public BufferType type
public Byte[] token
public SafeHandle unmanagedToken
public int offset
public void .ctor(Byte[] data, int offset, int size, BufferType tokentype)
public void .ctor(Byte[] data, BufferType tokentype)
public void .ctor(int size, BufferType tokentype)
public void .ctor(ChannelBinding binding)
}
internal System.Net.SecurityBufferDescriptor : object {
public int Version
public int Count
public Void* UnmanagedPointer
public void .ctor(int count)
internal void DebugDump()
}
internal System.Net.SecurityBufferStruct : ValueType {
public int count
public BufferType type
public IntPtr token
public int Size
}
internal System.Net.SecurityProtocol : object {
public SslProtocols AllowedSecurityProtocols
public SslProtocols DefaultSecurityProtocols
public SslProtocols SystemDefaultSecurityProtocols
public void ThrowOnNotAllowed(SslProtocols protocols, bool allowNone)
}
public System.Net.SecurityProtocolType : Enum {
public int value__
public SecurityProtocolType SystemDefault
public SecurityProtocolType Ssl3
public SecurityProtocolType Tls
public SecurityProtocolType Tls11
public SecurityProtocolType Tls12
}
internal System.Net.SecurityStatus : Enum {
public int value__
public SecurityStatus OK
public SecurityStatus ContinueNeeded
public SecurityStatus CompleteNeeded
public SecurityStatus CompAndContinue
public SecurityStatus ContextExpired
public SecurityStatus CredentialsNeeded
public SecurityStatus Renegotiate
public SecurityStatus OutOfMemory
public SecurityStatus InvalidHandle
public SecurityStatus Unsupported
public SecurityStatus TargetUnknown
public SecurityStatus InternalError
public SecurityStatus PackageNotFound
public SecurityStatus NotOwner
public SecurityStatus CannotInstall
public SecurityStatus InvalidToken
public SecurityStatus CannotPack
public SecurityStatus QopNotSupported
public SecurityStatus NoImpersonation
public SecurityStatus LogonDenied
public SecurityStatus UnknownCredentials
public SecurityStatus NoCredentials
public SecurityStatus MessageAltered
public SecurityStatus OutOfSequence
public SecurityStatus NoAuthenticatingAuthority
public SecurityStatus IncompleteMessage
public SecurityStatus IncompleteCredentials
public SecurityStatus BufferNotEnough
public SecurityStatus WrongPrincipal
public SecurityStatus TimeSkew
public SecurityStatus UntrustedRoot
public SecurityStatus IllegalMessage
public SecurityStatus CertUnknown
public SecurityStatus CertExpired
public SecurityStatus AlgorithmMismatch
public SecurityStatus SecurityQosFailed
public SecurityStatus SmartcardLogonRequired
public SecurityStatus UnsupportedPreauth
public SecurityStatus BadBinding
}
internal System.Net.Semaphore : WaitHandle {
internal void .ctor(int initialCount, int maxCount)
internal bool ReleaseSemaphore()
}
internal System.Net.ServerCertValidationCallback : object {
private RemoteCertificateValidationCallback m_ValidationCallback
private ExecutionContext m_Context
internal RemoteCertificateValidationCallback ValidationCallback
internal void .ctor(RemoteCertificateValidationCallback validationCallback)
internal RemoteCertificateValidationCallback get_ValidationCallback()
internal void Callback(object state)
internal bool Invoke(object request, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
}
internal System.Net.ServiceNameStore : object {
private List`1<string> serviceNames
private ServiceNameCollection serviceNameCollection
public ServiceNameCollection ServiceNames
public ServiceNameCollection get_ServiceNames()
private bool AddSingleServiceName(string spn)
public bool Add(string uriPrefix)
public bool Remove(string uriPrefix)
private bool Contains(string newServiceName)
public void Clear()
private string ExtractHostname(string uriPrefix, bool allowInvalidUriStrings)
public string BuildSimpleServiceName(string uriPrefix)
public String[] BuildServiceNames(string uriPrefix)
}
public System.Net.ServicePoint : object {
private Uri uri
private int connectionLimit
private int maxIdleTime
private int currentConnections
private DateTime idleSince
private DateTime lastDnsResolve
private Version protocolVersion
private IPHostEntry host
private bool usesProxy
private Dictionary`2<string, WebConnectionGroup> groups
private bool sendContinue
private bool useConnect
private object hostE
private bool useNagle
private BindIPEndPoint endPointCallback
private bool tcp_keepalive
private int tcp_keepalive_time
private int tcp_keepalive_interval
private Timer idleTimer
private object m_ServerCertificateOrBytes
private object m_ClientCertificateOrBytes
public Uri Address
public BindIPEndPoint BindIPEndPointDelegate
public int ConnectionLeaseTimeout
public int ConnectionLimit
public string ConnectionName
public int CurrentConnections
public DateTime IdleSince
public int MaxIdleTime
public Version ProtocolVersion
public int ReceiveBufferSize
public bool SupportsPipelining
public bool Expect100Continue
public bool UseNagleAlgorithm
internal bool SendContinue
internal bool UsesProxy
internal bool UseConnect
private bool HasTimedOut
internal IPHostEntry HostEntry
public X509Certificate Certificate
public X509Certificate ClientCertificate
internal void .ctor(Uri uri, int connectionLimit, int maxIdleTime)
public Uri get_Address()
private Exception GetMustImplement()
public BindIPEndPoint get_BindIPEndPointDelegate()
public void set_BindIPEndPointDelegate(BindIPEndPoint value)
public int get_ConnectionLeaseTimeout()
public void set_ConnectionLeaseTimeout(int value)
public int get_ConnectionLimit()
public void set_ConnectionLimit(int value)
public string get_ConnectionName()
public int get_CurrentConnections()
public DateTime get_IdleSince()
public int get_MaxIdleTime()
public void set_MaxIdleTime(int value)
public Version get_ProtocolVersion()
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public bool get_SupportsPipelining()
public bool get_Expect100Continue()
public void set_Expect100Continue(bool value)
public bool get_UseNagleAlgorithm()
public void set_UseNagleAlgorithm(bool value)
internal bool get_SendContinue()
internal void set_SendContinue(bool value)
public void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval)
internal void KeepAliveSetup(Socket socket)
private void PutBytes(Byte[] bytes, UInt32 v, int offset)
internal bool get_UsesProxy()
internal void set_UsesProxy(bool value)
internal bool get_UseConnect()
internal void set_UseConnect(bool value)
private WebConnectionGroup GetConnectionGroup(string name)
private void RemoveConnectionGroup(WebConnectionGroup group)
private bool CheckAvailableForRecycling(DateTime& outIdleSince)
private void IdleTimerCallback(object obj)
private bool get_HasTimedOut()
internal IPHostEntry get_HostEntry()
internal void SetVersion(Version version)
internal EventHandler SendRequest(HttpWebRequest request, string groupName)
public bool CloseConnectionGroup(string connectionGroupName)
public X509Certificate get_Certificate()
internal void UpdateServerCertificate(X509Certificate certificate)
public X509Certificate get_ClientCertificate()
internal void UpdateClientCertificate(X509Certificate certificate)
internal bool CallEndPointDelegate(Socket sock, IPEndPoint remote)
internal Socket GetConnection(PooledStream PooledStream, object owner, bool async, IPAddress& address, Socket& abortSocket, Socket& abortSocket6)
private void <GetConnectionGroup>b__66_0(object s, EventArgs e)
}
public System.Net.ServicePointManager : object {
private HybridDictionary servicePoints
private ICertificatePolicy policy
private int defaultConnectionLimit
private int maxServicePointIdleTime
private int maxServicePoints
private int dnsRefreshTimeout
private bool _checkCRL
private SecurityProtocolType _securityProtocol
private bool expectContinue
private bool useNagle
private ServerCertValidationCallback server_cert_cb
private bool tcp_keepalive
private int tcp_keepalive_time
private int tcp_keepalive_interval
public int DefaultNonPersistentConnectionLimit
public int DefaultPersistentConnectionLimit
private string configKey
private ConnectionManagementData manager
public ICertificatePolicy CertificatePolicy
public bool CheckCertificateRevocationList
public int DefaultConnectionLimit
public int DnsRefreshTimeout
public bool EnableDnsRoundRobin
public int MaxServicePointIdleTime
public int MaxServicePoints
public bool ReusePort
public SecurityProtocolType SecurityProtocol
internal ServerCertValidationCallback ServerCertValidationCallback
public RemoteCertificateValidationCallback ServerCertificateValidationCallback
public EncryptionPolicy EncryptionPolicy
public bool Expect100Continue
public bool UseNagleAlgorithm
internal bool DisableStrongCrypto
internal bool DisableSendAuxRecord
public ICertificatePolicy get_CertificatePolicy()
public void set_CertificatePolicy(ICertificatePolicy value)
internal ICertificatePolicy GetLegacyCertificatePolicy()
public bool get_CheckCertificateRevocationList()
public void set_CheckCertificateRevocationList(bool value)
public int get_DefaultConnectionLimit()
public void set_DefaultConnectionLimit(int value)
private Exception GetMustImplement()
public int get_DnsRefreshTimeout()
public void set_DnsRefreshTimeout(int value)
public bool get_EnableDnsRoundRobin()
public void set_EnableDnsRoundRobin(bool value)
public int get_MaxServicePointIdleTime()
public void set_MaxServicePointIdleTime(int value)
public int get_MaxServicePoints()
public void set_MaxServicePoints(int value)
public bool get_ReusePort()
public void set_ReusePort(bool value)
public SecurityProtocolType get_SecurityProtocol()
public void set_SecurityProtocol(SecurityProtocolType value)
internal ServerCertValidationCallback get_ServerCertValidationCallback()
public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback()
public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value)
public EncryptionPolicy get_EncryptionPolicy()
public bool get_Expect100Continue()
public void set_Expect100Continue(bool value)
public bool get_UseNagleAlgorithm()
public void set_UseNagleAlgorithm(bool value)
internal bool get_DisableStrongCrypto()
internal bool get_DisableSendAuxRecord()
public void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval)
public ServicePoint FindServicePoint(Uri address)
public ServicePoint FindServicePoint(string uriString, IWebProxy proxy)
public ServicePoint FindServicePoint(Uri address, IWebProxy proxy)
internal void CloseConnectionGroup(string connectionGroupName)
}
internal System.Net.SimpleAsyncCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(SimpleAsyncResult result)
public IAsyncResult BeginInvoke(SimpleAsyncResult result, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.SimpleAsyncResult : object {
private ManualResetEvent handle
private bool synch
private bool isCompleted
private SimpleAsyncCallback cb
private object state
private bool callbackDone
private Exception exc
private object locker
private Nullable`1<bool> user_read_synch
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
internal bool CompletedSynchronouslyPeek
public bool IsCompleted
internal bool GotException
internal Exception Exception
private void .ctor(SimpleAsyncCallback cb)
protected void .ctor(AsyncCallback cb, object state)
public void Run(Func`2<SimpleAsyncResult, bool> func, SimpleAsyncCallback callback)
public void RunWithLock(object locker, Func`2<SimpleAsyncResult, bool> func, SimpleAsyncCallback callback)
protected void Reset_internal()
internal void SetCompleted(bool synch, Exception e)
internal void SetCompleted(bool synch)
private void SetCompleted_internal(bool synch, Exception e)
protected void SetCompleted_internal(bool synch)
private void DoCallback_private()
protected void DoCallback_internal()
internal void WaitUntilComplete()
internal bool WaitUntilComplete(int timeout, bool exitContext)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
internal bool get_CompletedSynchronouslyPeek()
public bool get_IsCompleted()
internal bool get_GotException()
internal Exception get_Exception()
}
public System.Net.SocketAddress : object {
internal int IPv6AddressSize
internal int IPv4AddressSize
internal int m_Size
internal Byte[] m_Buffer
private int WriteableOffset
private int MaxSize
private bool m_changed
private int m_hash
public AddressFamily Family
public int Size
public byte Item
public AddressFamily get_Family()
public int get_Size()
public byte get_Item(int offset)
public void set_Item(int offset, byte value)
public void .ctor(AddressFamily family)
public void .ctor(AddressFamily family, int size)
internal void .ctor(IPAddress ipAddress)
internal void .ctor(IPAddress ipaddress, int port)
internal IPAddress GetIPAddress()
internal IPEndPoint GetIPEndPoint()
internal void CopyAddressSizeIntoBuffer()
internal int GetAddressSizeOffset()
internal void SetSize(IntPtr ptr)
public bool Equals(object comparand)
public int GetHashCode()
public string ToString()
}
public System.Net.SocketPermission : CodeAccessPermission {
private ArrayList m_acceptList
private ArrayList m_connectList
private bool m_noRestriction
public int AllPorts
public IEnumerator AcceptList
public IEnumerator ConnectList
public void .ctor(PermissionState state)
public void .ctor(NetworkAccess access, TransportType transport, string hostName, int portNumber)
public IEnumerator get_AcceptList()
public IEnumerator get_ConnectList()
public void AddPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber)
public IPermission Copy()
public IPermission Intersect(IPermission target)
private bool IntersectEmpty(SocketPermission permission)
private void Intersect(ArrayList list1, ArrayList list2, ArrayList result)
public bool IsSubsetOf(IPermission target)
private bool IsSubsetOf(ArrayList list1, ArrayList list2)
public bool IsUnrestricted()
public SecurityElement ToXml()
private void ToXml(SecurityElement root, string childName, IEnumerator enumerator)
public void FromXml(SecurityElement securityElement)
private void FromXml(ArrayList endpoints, NetworkAccess access)
public IPermission Union(IPermission target)
}
public System.Net.SocketPermissionAttribute : CodeAccessSecurityAttribute {
private string m_access
private string m_host
private string m_port
private string m_transport
public string Access
public string Host
public string Port
public string Transport
public void .ctor(SecurityAction action)
public string get_Access()
public void set_Access(string value)
public string get_Host()
public void set_Host(string value)
public string get_Port()
public void set_Port(string value)
public string get_Transport()
public void set_Transport(string value)
public IPermission CreatePermission()
internal void AlreadySet(string property)
}
public System.Net.Sockets.AddressFamily : Enum {
public int value__
public AddressFamily Unknown
public AddressFamily Unspecified
public AddressFamily Unix
public AddressFamily InterNetwork
public AddressFamily ImpLink
public AddressFamily Pup
public AddressFamily Chaos
public AddressFamily NS
public AddressFamily Ipx
public AddressFamily Iso
public AddressFamily Osi
public AddressFamily Ecma
public AddressFamily DataKit
public AddressFamily Ccitt
public AddressFamily Sna
public AddressFamily DecNet
public AddressFamily DataLink
public AddressFamily Lat
public AddressFamily HyperChannel
public AddressFamily AppleTalk
public AddressFamily NetBios
public AddressFamily VoiceView
public AddressFamily FireFox
public AddressFamily Banyan
public AddressFamily Atm
public AddressFamily InterNetworkV6
public AddressFamily Cluster
public AddressFamily Ieee12844
public AddressFamily Irda
public AddressFamily NetworkDesigners
public AddressFamily Max
}
public System.Net.Sockets.IOControlCode : Enum {
public long value__
public IOControlCode AsyncIO
public IOControlCode NonBlockingIO
public IOControlCode DataToRead
public IOControlCode OobDataRead
public IOControlCode AssociateHandle
public IOControlCode EnableCircularQueuing
public IOControlCode Flush
public IOControlCode GetBroadcastAddress
public IOControlCode GetExtensionFunctionPointer
public IOControlCode GetQos
public IOControlCode GetGroupQos
public IOControlCode MultipointLoopback
public IOControlCode MulticastScope
public IOControlCode SetQos
public IOControlCode SetGroupQos
public IOControlCode TranslateHandle
public IOControlCode RoutingInterfaceQuery
public IOControlCode RoutingInterfaceChange
public IOControlCode AddressListQuery
public IOControlCode AddressListChange
public IOControlCode QueryTargetPnpHandle
public IOControlCode NamespaceChange
public IOControlCode AddressListSort
public IOControlCode ReceiveAll
public IOControlCode ReceiveAllMulticast
public IOControlCode ReceiveAllIgmpMulticast
public IOControlCode KeepAliveValues
public IOControlCode AbsorbRouterAlert
public IOControlCode UnicastInterface
public IOControlCode LimitBroadcasts
public IOControlCode BindToInterface
public IOControlCode MulticastInterface
public IOControlCode AddMulticastGroupOnInterface
public IOControlCode DeleteMulticastGroupFromInterface
}
public System.Net.Sockets.IPPacketInformation : ValueType {
private IPAddress address
private int networkInterface
public IPAddress Address
public int Interface
internal void .ctor(IPAddress address, int networkInterface)
public IPAddress get_Address()
public int get_Interface()
public bool op_Equality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2)
public bool op_Inequality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2)
public bool Equals(object comparand)
public int GetHashCode()
}
public System.Net.Sockets.IPProtectionLevel : Enum {
public int value__
public IPProtectionLevel Unspecified
public IPProtectionLevel Unrestricted
public IPProtectionLevel EdgeRestricted
public IPProtectionLevel Restricted
}
public System.Net.Sockets.IPv6MulticastOption : object {
private IPAddress m_Group
private long m_Interface
public IPAddress Group
public long InterfaceIndex
public void .ctor(IPAddress group, long ifindex)
public void .ctor(IPAddress group)
public IPAddress get_Group()
public void set_Group(IPAddress value)
public long get_InterfaceIndex()
public void set_InterfaceIndex(long value)
}
public System.Net.Sockets.LingerOption : object {
private bool enabled
private int lingerTime
public bool Enabled
public int LingerTime
public void .ctor(bool enable, int seconds)
public bool get_Enabled()
public void set_Enabled(bool value)
public int get_LingerTime()
public void set_LingerTime(int value)
}
public System.Net.Sockets.MulticastOption : object {
private IPAddress group
private IPAddress localAddress
private int ifIndex
public IPAddress Group
public IPAddress LocalAddress
public int InterfaceIndex
public void .ctor(IPAddress group, IPAddress mcint)
public void .ctor(IPAddress group, int interfaceIndex)
public void .ctor(IPAddress group)
public IPAddress get_Group()
public void set_Group(IPAddress value)
public IPAddress get_LocalAddress()
public void set_LocalAddress(IPAddress value)
public int get_InterfaceIndex()
public void set_InterfaceIndex(int value)
}
internal System.Net.Sockets.MultipleConnectAsync : object {
protected SocketAsyncEventArgs userArgs
protected SocketAsyncEventArgs internalArgs
protected DnsEndPoint endPoint
protected IPAddress[] addressList
protected int nextAddress
private State state
private object lockObject
public bool StartConnectAsync(SocketAsyncEventArgs args, DnsEndPoint endPoint)
private void DnsCallback(IAsyncResult result)
private bool DoDnsCallback(IAsyncResult result, bool sync)
private void InternalConnectCallback(object sender, SocketAsyncEventArgs args)
private Exception AttemptConnection()
protected void OnSucceed()
protected void Succeed()
protected void OnFail(bool abortive)
private bool Fail(bool sync, Exception e)
private void SyncFail(Exception e)
private void AsyncFail(Exception e)
public void Cancel()
private void CallAsyncFail(object ignored)
protected IPAddress GetNextAddress(Socket& attemptSocket)
}
internal System.Net.Sockets.MultipleSocketMultipleConnectAsync : MultipleConnectAsync {
private Socket socket4
private Socket socket6
public void .ctor(SocketType socketType, ProtocolType protocolType)
protected IPAddress GetNextAddress(Socket& attemptSocket)
protected void OnSucceed()
protected void OnFail(bool abortive)
}
public System.Net.Sockets.NetworkStream : Stream {
private Socket m_StreamSocket
private bool m_Readable
private bool m_Writeable
private bool m_OwnsSocket
private int m_CloseTimeout
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_CleanedUp
private int m_CurrentReadTimeout
private int m_CurrentWriteTimeout
protected Socket Socket
internal Socket InternalSocket
protected bool Readable
protected bool Writeable
public bool CanRead
public bool CanSeek
public bool CanWrite
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public bool DataAvailable
public long Length
public long Position
internal bool Connected
public void .ctor(Socket socket)
public void .ctor(Socket socket, bool ownsSocket)
internal void .ctor(NetworkStream networkStream, bool ownsSocket)
public void .ctor(Socket socket, FileAccess access)
public void .ctor(Socket socket, FileAccess access, bool ownsSocket)
protected Socket get_Socket()
internal Socket get_InternalSocket()
internal void InternalAbortSocket()
internal void ConvertToNotSocketOwner()
protected bool get_Readable()
protected void set_Readable(bool value)
protected bool get_Writeable()
protected void set_Writeable(bool value)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public bool get_DataAvailable()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public long Seek(long offset, SeekOrigin origin)
internal void InitNetworkStream(Socket socket, FileAccess Access)
internal bool PollRead()
internal bool Poll(int microSeconds, SelectMode mode)
public int Read(Byte[] buffer, int offset, int size)
public void Write(Byte[] buffer, int offset, int size)
public void Close(int timeout)
protected void Dispose(bool disposing)
protected void Finalize()
internal bool get_Connected()
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
internal void MultipleWrite(BufferOffsetSize[] buffers)
internal IAsyncResult BeginMultipleWrite(BufferOffsetSize[] buffers, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginMultipleWrite(BufferOffsetSize[] buffers, AsyncCallback callback, object state)
internal void EndMultipleWrite(IAsyncResult asyncResult)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public void SetLength(long value)
internal void SetSocketTimeoutOption(SocketShutdown mode, int timeout, bool silent)
}
public System.Net.Sockets.ProtocolFamily : Enum {
public int value__
public ProtocolFamily Unknown
public ProtocolFamily Unspecified
public ProtocolFamily Unix
public ProtocolFamily InterNetwork
public ProtocolFamily ImpLink
public ProtocolFamily Pup
public ProtocolFamily Chaos
public ProtocolFamily NS
public ProtocolFamily Ipx
public ProtocolFamily Iso
public ProtocolFamily Osi
public ProtocolFamily Ecma
public ProtocolFamily DataKit
public ProtocolFamily Ccitt
public ProtocolFamily Sna
public ProtocolFamily DecNet
public ProtocolFamily DataLink
public ProtocolFamily Lat
public ProtocolFamily HyperChannel
public ProtocolFamily AppleTalk
public ProtocolFamily NetBios
public ProtocolFamily VoiceView
public ProtocolFamily FireFox
public ProtocolFamily Banyan
public ProtocolFamily Atm
public ProtocolFamily InterNetworkV6
public ProtocolFamily Cluster
public ProtocolFamily Ieee12844
public ProtocolFamily Irda
public ProtocolFamily NetworkDesigners
public ProtocolFamily Max
}
public System.Net.Sockets.ProtocolType : Enum {
public int value__
public ProtocolType IP
public ProtocolType IPv6HopByHopOptions
public ProtocolType Icmp
public ProtocolType Igmp
public ProtocolType Ggp
public ProtocolType IPv4
public ProtocolType Tcp
public ProtocolType Pup
public ProtocolType Udp
public ProtocolType Idp
public ProtocolType IPv6
public ProtocolType IPv6RoutingHeader
public ProtocolType IPv6FragmentHeader
public ProtocolType IPSecEncapsulatingSecurityPayload
public ProtocolType IPSecAuthenticationHeader
public ProtocolType IcmpV6
public ProtocolType IPv6NoNextHeader
public ProtocolType IPv6DestinationOptions
public ProtocolType ND
public ProtocolType Raw
public ProtocolType Unspecified
public ProtocolType Ipx
public ProtocolType Spx
public ProtocolType SpxII
public ProtocolType Unknown
}
internal System.Net.Sockets.SafeSocketHandle : SafeHandleZeroOrMinusOneIsInvalid {
private List`1<Thread> blocking_threads
private Dictionary`2<Thread, StackTrace> threads_stacktraces
private bool in_cleanup
private int SOCKET_CLOSED
private int ABORT_RETRIES
private bool THROW_ON_ABORT_RETRIES
public void .ctor(IntPtr preexistingHandle, bool ownsHandle)
protected bool ReleaseHandle()
public void RegisterForBlockingSyscall()
public void UnRegisterForBlockingSyscall()
}
public System.Net.Sockets.SelectMode : Enum {
public int value__
public SelectMode SelectRead
public SelectMode SelectWrite
public SelectMode SelectError
}
public System.Net.Sockets.SendPacketsElement : object {
internal string m_FilePath
internal Byte[] m_Buffer
internal int m_Offset
internal int m_Count
private bool m_endOfPacket
public string FilePath
public Byte[] Buffer
public int Count
public int Offset
public bool EndOfPacket
public void .ctor(string filepath)
public void .ctor(string filepath, int offset, int count)
public void .ctor(string filepath, int offset, int count, bool endOfPacket)
public void .ctor(Byte[] buffer)
public void .ctor(Byte[] buffer, int offset, int count)
public void .ctor(Byte[] buffer, int offset, int count, bool endOfPacket)
private void Initialize(string filePath, Byte[] buffer, int offset, int count, bool endOfPacket)
public string get_FilePath()
public Byte[] get_Buffer()
public int get_Count()
public int get_Offset()
public bool get_EndOfPacket()
}
internal System.Net.Sockets.SingleSocketMultipleConnectAsync : MultipleConnectAsync {
private Socket socket
private bool userSocket
public void .ctor(Socket socket, bool userSocket)
protected IPAddress GetNextAddress(Socket& attemptSocket)
protected void OnFail(bool abortive)
protected void OnSucceed()
}
public System.Net.Sockets.Socket : object {
private object s_InternalSyncObject
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_SupportsIPv4
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_SupportsIPv6
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_OSSupportsIPv6
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_Initialized
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_LoggingEnabled
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_PerfCountersEnabled
internal int DefaultCloseTimeout
private int SOCKET_CLOSED_CODE
private string TIMEOUT_EXCEPTION_MSG
private bool is_closed
private bool is_listening
private bool useOverlappedIO
private int linger_timeout
private AddressFamily addressFamily
private SocketType socketType
private ProtocolType protocolType
internal SafeSocketHandle m_Handle
internal EndPoint seed_endpoint
internal SemaphoreSlim ReadSem
internal SemaphoreSlim WriteSem
internal bool is_blocking
internal bool is_bound
internal bool is_connected
private int m_IntCleanedUp
internal bool connect_in_progress
private AsyncCallback AcceptAsyncCallback
private IOAsyncCallback BeginAcceptCallback
private IOAsyncCallback BeginAcceptReceiveCallback
private AsyncCallback ConnectAsyncCallback
private IOAsyncCallback BeginConnectCallback
private AsyncCallback DisconnectAsyncCallback
private IOAsyncCallback BeginDisconnectCallback
private AsyncCallback ReceiveAsyncCallback
private IOAsyncCallback BeginReceiveCallback
private IOAsyncCallback BeginReceiveGenericCallback
private AsyncCallback ReceiveFromAsyncCallback
private IOAsyncCallback BeginReceiveFromCallback
private AsyncCallback SendAsyncCallback
private IOAsyncCallback BeginSendGenericCallback
private AsyncCallback SendToAsyncCallback
public bool SupportsIPv4
public bool OSSupportsIPv4
public bool SupportsIPv6
internal bool LegacySupportsIPv6
public bool OSSupportsIPv6
public IntPtr Handle
public bool UseOnlyOverlappedIO
public AddressFamily AddressFamily
public SocketType SocketType
public ProtocolType ProtocolType
public bool ExclusiveAddressUse
public int ReceiveBufferSize
public int SendBufferSize
public int ReceiveTimeout
public int SendTimeout
public LingerOption LingerState
public short Ttl
public bool DontFragment
public bool DualMode
private bool IsDualMode
private object InternalSyncObject
internal bool CleanedUp
public int Available
public bool EnableBroadcast
public bool IsBound
public bool MulticastLoopback
public EndPoint LocalEndPoint
public bool Blocking
public bool Connected
public bool NoDelay
public EndPoint RemoteEndPoint
internal int FamilyHint
public void .ctor(SocketType socketType, ProtocolType protocolType)
public void .ctor(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)
public bool get_SupportsIPv4()
public bool get_OSSupportsIPv4()
public bool get_SupportsIPv6()
internal bool get_LegacySupportsIPv6()
public bool get_OSSupportsIPv6()
public IntPtr get_Handle()
public bool get_UseOnlyOverlappedIO()
public void set_UseOnlyOverlappedIO(bool value)
public AddressFamily get_AddressFamily()
public SocketType get_SocketType()
public ProtocolType get_ProtocolType()
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public int get_SendBufferSize()
public void set_SendBufferSize(int value)
public int get_ReceiveTimeout()
public void set_ReceiveTimeout(int value)
public int get_SendTimeout()
public void set_SendTimeout(int value)
public LingerOption get_LingerState()
public void set_LingerState(LingerOption value)
public short get_Ttl()
public void set_Ttl(short value)
public bool get_DontFragment()
public void set_DontFragment(bool value)
public bool get_DualMode()
public void set_DualMode(bool value)
private bool get_IsDualMode()
internal bool CanTryAddressFamily(AddressFamily family)
public void Connect(IPAddress[] addresses, int port)
public int Send(Byte[] buffer, int size, SocketFlags socketFlags)
public int Send(Byte[] buffer, SocketFlags socketFlags)
public int Send(Byte[] buffer)
public int Send(IList`1<ArraySegment`1<byte>> buffers)
public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public void SendFile(string fileName)
public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags)
public int SendTo(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP)
public int SendTo(Byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP)
public int SendTo(Byte[] buffer, EndPoint remoteEP)
public int Receive(Byte[] buffer, int size, SocketFlags socketFlags)
public int Receive(Byte[] buffer, SocketFlags socketFlags)
public int Receive(Byte[] buffer)
public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags)
public int Receive(IList`1<ArraySegment`1<byte>> buffers)
public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public int ReceiveFrom(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint& remoteEP)
public int ReceiveFrom(Byte[] buffer, SocketFlags socketFlags, EndPoint& remoteEP)
public int ReceiveFrom(Byte[] buffer, EndPoint& remoteEP)
public int IOControl(IOControlCode ioControlCode, Byte[] optionInValue, Byte[] optionOutValue)
public void SetIPProtectionLevel(IPProtectionLevel level)
public IAsyncResult BeginSendFile(string fileName, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state)
public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state)
public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
public int EndSend(IAsyncResult asyncResult)
public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state)
public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
public int EndReceive(IAsyncResult asyncResult)
public IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, object state)
public Socket EndAccept(Byte[]& buffer, IAsyncResult asyncResult)
private object get_InternalSyncObject()
internal bool get_CleanedUp()
internal void InitializeSockets()
public void Dispose()
protected void Finalize()
public bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e)
internal void InternalShutdown(SocketShutdown how)
internal IAsyncResult UnsafeBeginConnect(EndPoint remoteEP, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state)
internal IAsyncResult BeginMultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginMultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
internal int EndMultipleSend(IAsyncResult asyncResult)
internal void MultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags)
internal void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue, bool silent)
public void .ctor(SocketInformation socketInformation)
internal void .ctor(AddressFamily family, SocketType type, ProtocolType proto, SafeSocketHandle safe_handle)
private void SocketDefaults()
private IntPtr Socket_internal(AddressFamily family, SocketType type, ProtocolType proto, Int32& error)
public int get_Available()
private int Available_internal(SafeSocketHandle safeHandle, Int32& error)
private int Available_internal(IntPtr socket, Int32& error)
public bool get_EnableBroadcast()
public void set_EnableBroadcast(bool value)
public bool get_IsBound()
public bool get_MulticastLoopback()
public void set_MulticastLoopback(bool value)
public EndPoint get_LocalEndPoint()
private SocketAddress LocalEndPoint_internal(SafeSocketHandle safeHandle, int family, Int32& error)
private SocketAddress LocalEndPoint_internal(IntPtr socket, int family, Int32& error)
public bool get_Blocking()
public void set_Blocking(bool value)
private void Blocking_internal(SafeSocketHandle safeHandle, bool block, Int32& error)
internal void Blocking_internal(IntPtr socket, bool block, Int32& error)
public bool get_Connected()
internal void set_Connected(bool value)
public bool get_NoDelay()
public void set_NoDelay(bool value)
public EndPoint get_RemoteEndPoint()
private SocketAddress RemoteEndPoint_internal(SafeSocketHandle safeHandle, int family, Int32& error)
private SocketAddress RemoteEndPoint_internal(IntPtr socket, int family, Int32& error)
public void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds)
private void AddSockets(List`1<Socket> sockets, IList list, string name)
private void Select_internal(Socket[]& sockets, int microSeconds, Int32& error)
public bool Poll(int microSeconds, SelectMode mode)
private bool Poll_internal(SafeSocketHandle safeHandle, SelectMode mode, int timeout, Int32& error)
private bool Poll_internal(IntPtr socket, SelectMode mode, int timeout, Int32& error)
public Socket Accept()
internal void Accept(Socket acceptSocket)
public bool AcceptAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginAccept(AsyncCallback callback, object state)
public IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, object state)
public Socket EndAccept(IAsyncResult asyncResult)
public Socket EndAccept(Byte[]& buffer, Int32& bytesTransferred, IAsyncResult asyncResult)
private SafeSocketHandle Accept_internal(SafeSocketHandle safeHandle, Int32& error, bool blocking)
private IntPtr Accept_internal(IntPtr sock, Int32& error, bool blocking)
public void Bind(EndPoint localEP)
private void Bind_internal(SafeSocketHandle safeHandle, SocketAddress sa, Int32& error)
private void Bind_internal(IntPtr sock, SocketAddress sa, Int32& error)
public void Listen(int backlog)
private void Listen_internal(SafeSocketHandle safeHandle, int backlog, Int32& error)
private void Listen_internal(IntPtr sock, int backlog, Int32& error)
public void Connect(IPAddress address, int port)
public void Connect(string host, int port)
public void Connect(EndPoint remoteEP)
public bool ConnectAsync(SocketAsyncEventArgs e)
public void CancelConnectAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state)
public IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state)
private void BeginMConnect(SocketAsyncResult sockares)
private void BeginSConnect(SocketAsyncResult sockares)
public void EndConnect(IAsyncResult asyncResult)
private void Connect_internal(SafeSocketHandle safeHandle, SocketAddress sa, Int32& error, bool blocking)
private void Connect_internal(IntPtr sock, SocketAddress sa, Int32& error, bool blocking)
private bool GetCheckedIPs(SocketAsyncEventArgs e, IPAddress[]& addresses)
public void Disconnect(bool reuseSocket)
public bool DisconnectAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginDisconnect(bool reuseSocket, AsyncCallback callback, object state)
public void EndDisconnect(IAsyncResult asyncResult)
private void Disconnect_internal(SafeSocketHandle safeHandle, bool reuse, Int32& error)
private void Disconnect_internal(IntPtr sock, bool reuse, Int32& error)
public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode)
public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode)
public bool ReceiveAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
public int EndReceive(IAsyncResult asyncResult, SocketError& errorCode)
private int Receive_internal(SafeSocketHandle safeHandle, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking)
private int Receive_internal(IntPtr sock, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking)
private int Receive_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking)
private int Receive_internal(IntPtr sock, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking)
public int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP)
internal int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, SocketError& errorCode)
public bool ReceiveFromAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state)
public int EndReceiveFrom(IAsyncResult asyncResult, EndPoint& endPoint)
private int ReceiveFrom_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, SocketAddress& sockaddr, Int32& error, bool blocking)
private int ReceiveFrom_internal(IntPtr sock, Byte* buffer, int count, SocketFlags flags, SocketAddress& sockaddr, Int32& error, bool blocking)
public int ReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags& socketFlags, EndPoint& remoteEP, IPPacketInformation& ipPacketInformation)
public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state)
public int EndReceiveMessageFrom(IAsyncResult asyncResult, SocketFlags& socketFlags, EndPoint& endPoint, IPPacketInformation& ipPacketInformation)
public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode)
public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode)
public bool SendAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
private void BeginSendCallback(SocketAsyncResult sockares, int sent_so_far)
public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
public int EndSend(IAsyncResult asyncResult, SocketError& errorCode)
private int Send_internal(SafeSocketHandle safeHandle, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking)
private int Send_internal(IntPtr sock, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking)
private int Send_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking)
private int Send_internal(IntPtr sock, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking)
public int SendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP)
public bool SendToAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP, AsyncCallback callback, object state)
private void BeginSendToCallback(SocketAsyncResult sockares, int sent_so_far)
public int EndSendTo(IAsyncResult asyncResult)
private int SendTo_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, SocketAddress sa, Int32& error, bool blocking)
private int SendTo_internal(IntPtr sock, Byte* buffer, int count, SocketFlags flags, SocketAddress sa, Int32& error, bool blocking)
public void SendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags)
public IAsyncResult BeginSendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags, AsyncCallback callback, object state)
public void EndSendFile(IAsyncResult asyncResult)
private bool SendFile_internal(SafeSocketHandle safeHandle, string filename, Byte[] pre_buffer, Byte[] post_buffer, TransmitFileOptions flags, Int32& error, bool blocking)
private bool SendFile_internal(IntPtr sock, string filename, Byte[] pre_buffer, Byte[] post_buffer, TransmitFileOptions flags, Int32& error, bool blocking)
public bool SendPacketsAsync(SocketAsyncEventArgs e)
private bool Duplicate_internal(IntPtr handle, int targetProcessId, IntPtr& duplicateHandle, MonoIOError& error)
public SocketInformation DuplicateAndClose(int targetProcessId)
public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue)
public Byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength)
public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName)
private void GetSocketOption_arr_internal(SafeSocketHandle safeHandle, SocketOptionLevel level, SocketOptionName name, Byte[]& byte_val, Int32& error)
private void GetSocketOption_arr_internal(IntPtr socket, SocketOptionLevel level, SocketOptionName name, Byte[]& byte_val, Int32& error)
private void GetSocketOption_obj_internal(SafeSocketHandle safeHandle, SocketOptionLevel level, SocketOptionName name, Object& obj_val, Int32& error)
private void GetSocketOption_obj_internal(IntPtr socket, SocketOptionLevel level, SocketOptionName name, Object& obj_val, Int32& error)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue)
private void SetSocketOption_internal(SafeSocketHandle safeHandle, SocketOptionLevel level, SocketOptionName name, object obj_val, Byte[] byte_val, int int_val, Int32& error)
private void SetSocketOption_internal(IntPtr socket, SocketOptionLevel level, SocketOptionName name, object obj_val, Byte[] byte_val, int int_val, Int32& error)
public int IOControl(int ioControlCode, Byte[] optionInValue, Byte[] optionOutValue)
private int IOControl_internal(SafeSocketHandle safeHandle, int ioctl_code, Byte[] input, Byte[] output, Int32& error)
private int IOControl_internal(IntPtr sock, int ioctl_code, Byte[] input, Byte[] output, Int32& error)
public void Close()
public void Close(int timeout)
internal void Close_internal(IntPtr socket, Int32& error)
public void Shutdown(SocketShutdown how)
private void Shutdown_internal(SafeSocketHandle safeHandle, SocketShutdown how, Int32& error)
internal void Shutdown_internal(IntPtr socket, SocketShutdown how, Int32& error)
protected void Dispose(bool disposing)
private void Linger(IntPtr handle)
private void ThrowIfDisposedAndClosed(Socket socket)
private void ThrowIfDisposedAndClosed()
private void ThrowIfBufferNull(Byte[] buffer)
private void ThrowIfBufferOutOfRange(Byte[] buffer, int offset, int size)
private void ThrowIfUdp()
private SocketAsyncResult ValidateEndIAsyncResult(IAsyncResult ares, string methodName, string argName)
private void QueueIOSelectorJob(SemaphoreSlim sem, IntPtr handle, IOSelectorJob job)
private void InitSocketAsyncEventArgs(SocketAsyncEventArgs e, AsyncCallback callback, object state, SocketOperation operation)
private SocketAsyncOperation SocketOperationToSocketAsyncOperation(SocketOperation op)
private IPEndPoint RemapIPEndPoint(IPEndPoint input)
internal void cancel_blocking_socket_operation(Thread thread)
internal bool SupportsPortReuse(ProtocolType proto)
internal int get_FamilyHint()
private bool IsProtocolSupported_internal(NetworkInterfaceComponent networkInterface)
private bool IsProtocolSupported(NetworkInterfaceComponent networkInterface)
}
public System.Net.Sockets.SocketAsyncEventArgs : EventArgs {
private bool disposed
internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) in_progress
internal EndPoint remote_ep
internal Socket current_socket
internal SocketAsyncResult socket_async_result
private Exception <ConnectByNameError>k__BackingField
private Socket <AcceptSocket>k__BackingField
private Byte[] <Buffer>k__BackingField
internal IList`1<ArraySegment`1<byte>> m_BufferList
private int <BytesTransferred>k__BackingField
private int <Count>k__BackingField
private bool <DisconnectReuseSocket>k__BackingField
private SocketAsyncOperation <LastOperation>k__BackingField
private int <Offset>k__BackingField
private IPPacketInformation <ReceiveMessageFromPacketInfo>k__BackingField
private SendPacketsElement[] <SendPacketsElements>k__BackingField
private TransmitFileOptions <SendPacketsFlags>k__BackingField
private int <SendPacketsSendSize>k__BackingField
private SocketError <SocketError>k__BackingField
private SocketFlags <SocketFlags>k__BackingField
private object <UserToken>k__BackingField
private bool <PolicyRestricted>k__BackingField
private EventHandler`1<SocketAsyncEventArgs> Completed
public Exception ConnectByNameError
public Socket AcceptSocket
public Byte[] Buffer
public IList`1<ArraySegment`1<byte>> BufferList
public int BytesTransferred
public int Count
public bool DisconnectReuseSocket
public SocketAsyncOperation LastOperation
public int Offset
public EndPoint RemoteEndPoint
public IPPacketInformation ReceiveMessageFromPacketInfo
public SendPacketsElement[] SendPacketsElements
public TransmitFileOptions SendPacketsFlags
public int SendPacketsSendSize
public SocketError SocketError
public SocketFlags SocketFlags
public object UserToken
public Socket ConnectSocket
internal bool PolicyRestricted
public Exception get_ConnectByNameError()
internal void set_ConnectByNameError(Exception value)
public Socket get_AcceptSocket()
public void set_AcceptSocket(Socket value)
public Byte[] get_Buffer()
private void set_Buffer(Byte[] value)
public IList`1<ArraySegment`1<byte>> get_BufferList()
public void set_BufferList(IList`1<ArraySegment`1<byte>> value)
public int get_BytesTransferred()
internal void set_BytesTransferred(int value)
public int get_Count()
internal void set_Count(int value)
public bool get_DisconnectReuseSocket()
public void set_DisconnectReuseSocket(bool value)
public SocketAsyncOperation get_LastOperation()
private void set_LastOperation(SocketAsyncOperation value)
public int get_Offset()
private void set_Offset(int value)
public EndPoint get_RemoteEndPoint()
public void set_RemoteEndPoint(EndPoint value)
public IPPacketInformation get_ReceiveMessageFromPacketInfo()
private void set_ReceiveMessageFromPacketInfo(IPPacketInformation value)
public SendPacketsElement[] get_SendPacketsElements()
public void set_SendPacketsElements(SendPacketsElement[] value)
public TransmitFileOptions get_SendPacketsFlags()
public void set_SendPacketsFlags(TransmitFileOptions value)
public int get_SendPacketsSendSize()
public void set_SendPacketsSendSize(int value)
public SocketError get_SocketError()
public void set_SocketError(SocketError value)
public SocketFlags get_SocketFlags()
public void set_SocketFlags(SocketFlags value)
public object get_UserToken()
public void set_UserToken(object value)
public Socket get_ConnectSocket()
internal bool get_PolicyRestricted()
private void set_PolicyRestricted(bool value)
public void add_Completed(EventHandler`1<SocketAsyncEventArgs> value)
public void remove_Completed(EventHandler`1<SocketAsyncEventArgs> value)
internal void .ctor(bool policy)
protected void Finalize()
private void Dispose(bool disposing)
public void Dispose()
internal void SetLastOperation(SocketAsyncOperation op)
internal void Complete()
protected void OnCompleted(SocketAsyncEventArgs e)
public void SetBuffer(int offset, int count)
public void SetBuffer(Byte[] buffer, int offset, int count)
internal void StartOperationCommon(Socket socket)
internal void StartOperationWrapperConnect(MultipleConnectAsync args)
internal void FinishConnectByNameSyncFailure(Exception exception, int bytesTransferred, SocketFlags flags)
internal void FinishOperationAsyncFailure(Exception exception, int bytesTransferred, SocketFlags flags)
internal void FinishWrapperConnectSuccess(Socket connectSocket, int bytesTransferred, SocketFlags flags)
internal void SetResults(SocketError socketError, int bytesTransferred, SocketFlags flags)
}
public System.Net.Sockets.SocketAsyncOperation : Enum {
public int value__
public SocketAsyncOperation None
public SocketAsyncOperation Accept
public SocketAsyncOperation Connect
public SocketAsyncOperation Disconnect
public SocketAsyncOperation Receive
public SocketAsyncOperation ReceiveFrom
public SocketAsyncOperation ReceiveMessageFrom
public SocketAsyncOperation Send
public SocketAsyncOperation SendPackets
public SocketAsyncOperation SendTo
}
internal System.Net.Sockets.SocketAsyncResult : IOAsyncResult {
public Socket socket
public SocketOperation operation
private Exception DelayedException
public EndPoint EndPoint
public Byte[] Buffer
public int Offset
public int Size
public SocketFlags SockFlags
public Socket AcceptSocket
public IPAddress[] Addresses
public int Port
public IList`1<ArraySegment`1<byte>> Buffers
public bool ReuseSocket
public int CurrentAddress
public Socket AcceptedSocket
public int Total
internal int error
public int EndCalled
public IntPtr Handle
public SocketError ErrorCode
public IntPtr get_Handle()
public void Init(Socket socket, AsyncCallback callback, object state, SocketOperation operation)
public void .ctor(Socket socket, AsyncCallback callback, object state, SocketOperation operation)
public SocketError get_ErrorCode()
public void CheckIfThrowDelayedException()
internal void CompleteDisposed()
public void Complete()
public void Complete(bool synch)
public void Complete(int total)
public void Complete(Exception e, bool synch)
public void Complete(Exception e)
public void Complete(Socket s)
public void Complete(Socket s, int total)
}
public System.Net.Sockets.SocketClientAccessPolicyProtocol : Enum {
public int value__
public SocketClientAccessPolicyProtocol Tcp
public SocketClientAccessPolicyProtocol Http
}
public System.Net.Sockets.SocketError : Enum {
public int value__
public SocketError Success
public SocketError SocketError
public SocketError Interrupted
public SocketError AccessDenied
public SocketError Fault
public SocketError InvalidArgument
public SocketError TooManyOpenSockets
public SocketError WouldBlock
public SocketError InProgress
public SocketError AlreadyInProgress
public SocketError NotSocket
public SocketError DestinationAddressRequired
public SocketError MessageSize
public SocketError ProtocolType
public SocketError ProtocolOption
public SocketError ProtocolNotSupported
public SocketError SocketNotSupported
public SocketError OperationNotSupported
public SocketError ProtocolFamilyNotSupported
public SocketError AddressFamilyNotSupported
public SocketError AddressAlreadyInUse
public SocketError AddressNotAvailable
public SocketError NetworkDown
public SocketError NetworkUnreachable
public SocketError NetworkReset
public SocketError ConnectionAborted
public SocketError ConnectionReset
public SocketError NoBufferSpaceAvailable
public SocketError IsConnected
public SocketError NotConnected
public SocketError Shutdown
public SocketError TimedOut
public SocketError ConnectionRefused
public SocketError HostDown
public SocketError HostUnreachable
public SocketError ProcessLimit
public SocketError SystemNotReady
public SocketError VersionNotSupported
public SocketError NotInitialized
public SocketError Disconnecting
public SocketError TypeNotFound
public SocketError HostNotFound
public SocketError TryAgain
public SocketError NoRecovery
public SocketError NoData
public SocketError IOPending
public SocketError OperationAborted
}
public System.Net.Sockets.SocketException : Win32Exception {
private EndPoint m_EndPoint
public int ErrorCode
public string Message
public SocketError SocketErrorCode
private int WSAGetLastError_internal()
internal void .ctor(int error, string message)
internal void .ctor(EndPoint endPoint)
public void .ctor(int errorCode)
internal void .ctor(int errorCode, EndPoint endPoint)
internal void .ctor(SocketError socketError)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public int get_ErrorCode()
public string get_Message()
public SocketError get_SocketErrorCode()
}
public System.Net.Sockets.SocketFlags : Enum {
public int value__
public SocketFlags None
public SocketFlags OutOfBand
public SocketFlags Peek
public SocketFlags DontRoute
public SocketFlags MaxIOVectorLength
public SocketFlags Truncated
public SocketFlags ControlDataTruncated
public SocketFlags Broadcast
public SocketFlags Multicast
public SocketFlags Partial
}
public System.Net.Sockets.SocketInformation : ValueType {
private Byte[] protocolInformation
private SocketInformationOptions options
private EndPoint remoteEndPoint
public Byte[] ProtocolInformation
public SocketInformationOptions Options
internal bool IsNonBlocking
internal bool IsConnected
internal bool IsListening
internal bool UseOnlyOverlappedIO
internal EndPoint RemoteEndPoint
public Byte[] get_ProtocolInformation()
public void set_ProtocolInformation(Byte[] value)
public SocketInformationOptions get_Options()
public void set_Options(SocketInformationOptions value)
internal bool get_IsNonBlocking()
internal void set_IsNonBlocking(bool value)
internal bool get_IsConnected()
internal void set_IsConnected(bool value)
internal bool get_IsListening()
internal void set_IsListening(bool value)
internal bool get_UseOnlyOverlappedIO()
internal void set_UseOnlyOverlappedIO(bool value)
internal EndPoint get_RemoteEndPoint()
internal void set_RemoteEndPoint(EndPoint value)
}
public System.Net.Sockets.SocketInformationOptions : Enum {
public int value__
public SocketInformationOptions NonBlocking
public SocketInformationOptions Connected
public SocketInformationOptions Listening
public SocketInformationOptions UseOnlyOverlappedIO
}
internal System.Net.Sockets.SocketOperation : Enum {
public int value__
public SocketOperation Accept
public SocketOperation Connect
public SocketOperation Receive
public SocketOperation ReceiveFrom
public SocketOperation Send
public SocketOperation SendTo
public SocketOperation RecvJustCallback
public SocketOperation SendJustCallback
public SocketOperation Disconnect
public SocketOperation AcceptReceive
public SocketOperation ReceiveGeneric
public SocketOperation SendGeneric
}
public System.Net.Sockets.SocketOptionLevel : Enum {
public int value__
public SocketOptionLevel Socket
public SocketOptionLevel IP
public SocketOptionLevel IPv6
public SocketOptionLevel Tcp
public SocketOptionLevel Udp
}
public System.Net.Sockets.SocketOptionName : Enum {
public int value__
public SocketOptionName Debug
public SocketOptionName AcceptConnection
public SocketOptionName ReuseAddress
public SocketOptionName KeepAlive
public SocketOptionName DontRoute
public SocketOptionName Broadcast
public SocketOptionName UseLoopback
public SocketOptionName Linger
public SocketOptionName OutOfBandInline
public SocketOptionName DontLinger
public SocketOptionName ExclusiveAddressUse
public SocketOptionName SendBuffer
public SocketOptionName ReceiveBuffer
public SocketOptionName SendLowWater
public SocketOptionName ReceiveLowWater
public SocketOptionName SendTimeout
public SocketOptionName ReceiveTimeout
public SocketOptionName Error
public SocketOptionName Type
public SocketOptionName ReuseUnicastPort
public SocketOptionName MaxConnections
public SocketOptionName IPOptions
public SocketOptionName HeaderIncluded
public SocketOptionName TypeOfService
public SocketOptionName IpTimeToLive
public SocketOptionName MulticastInterface
public SocketOptionName MulticastTimeToLive
public SocketOptionName MulticastLoopback
public SocketOptionName AddMembership
public SocketOptionName DropMembership
public SocketOptionName DontFragment
public SocketOptionName AddSourceMembership
public SocketOptionName DropSourceMembership
public SocketOptionName BlockSource
public SocketOptionName UnblockSource
public SocketOptionName PacketInformation
public SocketOptionName HopLimit
public SocketOptionName IPProtectionLevel
public SocketOptionName IPv6Only
public SocketOptionName NoDelay
public SocketOptionName BsdUrgent
public SocketOptionName Expedited
public SocketOptionName NoChecksum
public SocketOptionName ChecksumCoverage
public SocketOptionName UpdateAcceptContext
public SocketOptionName UpdateConnectContext
}
public System.Net.Sockets.SocketReceiveFromResult : ValueType {
public int ReceivedBytes
public EndPoint RemoteEndPoint
}
public System.Net.Sockets.SocketReceiveMessageFromResult : ValueType {
public int ReceivedBytes
public SocketFlags SocketFlags
public EndPoint RemoteEndPoint
public IPPacketInformation PacketInformation
}
public System.Net.Sockets.SocketShutdown : Enum {
public int value__
public SocketShutdown Receive
public SocketShutdown Send
public SocketShutdown Both
}
public System.Net.Sockets.SocketTaskExtensions : object {
public Task`1<Socket> AcceptAsync(Socket socket)
public Task`1<Socket> AcceptAsync(Socket socket, Socket acceptSocket)
public Task ConnectAsync(Socket socket, EndPoint remoteEP)
public Task ConnectAsync(Socket socket, IPAddress address, int port)
public Task ConnectAsync(Socket socket, IPAddress[] addresses, int port)
public Task ConnectAsync(Socket socket, string host, int port)
public Task`1<int> ReceiveAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags)
public Task`1<int> ReceiveAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public Task`1<SocketReceiveFromResult> ReceiveFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint)
public Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint)
public Task`1<int> SendAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags)
public Task`1<int> SendAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public Task`1<int> SendToAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP)
}
public System.Net.Sockets.SocketType : Enum {
public int value__
public SocketType Stream
public SocketType Dgram
public SocketType Raw
public SocketType Rdm
public SocketType Seqpacket
public SocketType Unknown
}
public System.Net.Sockets.TcpClient : object {
private Socket m_ClientSocket
private bool m_Active
private NetworkStream m_DataStream
private AddressFamily m_Family
private bool m_CleanedUp
public Socket Client
protected bool Active
public int Available
public bool Connected
public bool ExclusiveAddressUse
public int ReceiveBufferSize
public int SendBufferSize
public int ReceiveTimeout
public int SendTimeout
public LingerOption LingerState
public bool NoDelay
public void .ctor(IPEndPoint localEP)
public void .ctor(AddressFamily family)
public void .ctor(string hostname, int port)
internal void .ctor(Socket acceptedSocket)
public Socket get_Client()
public void set_Client(Socket value)
protected bool get_Active()
protected void set_Active(bool value)
public int get_Available()
public bool get_Connected()
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public void Connect(string hostname, int port)
public void Connect(IPAddress address, int port)
public void Connect(IPEndPoint remoteEP)
public void Connect(IPAddress[] ipAddresses, int port)
public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state)
public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state)
public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state)
public void EndConnect(IAsyncResult asyncResult)
public Task ConnectAsync(IPAddress address, int port)
public Task ConnectAsync(string host, int port)
public Task ConnectAsync(IPAddress[] addresses, int port)
public NetworkStream GetStream()
public void Close()
protected void Dispose(bool disposing)
public void Dispose()
protected void Finalize()
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public int get_SendBufferSize()
public void set_SendBufferSize(int value)
public int get_ReceiveTimeout()
public void set_ReceiveTimeout(int value)
public int get_SendTimeout()
public void set_SendTimeout(int value)
public LingerOption get_LingerState()
public void set_LingerState(LingerOption value)
public bool get_NoDelay()
public void set_NoDelay(bool value)
private void initialize()
private int numericOption(SocketOptionLevel optionLevel, SocketOptionName optionName)
}
public System.Net.Sockets.TcpListener : object {
private IPEndPoint m_ServerSocketEP
private Socket m_ServerSocket
private bool m_Active
private bool m_ExclusiveAddressUse
public Socket Server
protected bool Active
public EndPoint LocalEndpoint
public bool ExclusiveAddressUse
public void .ctor(IPEndPoint localEP)
public void .ctor(IPAddress localaddr, int port)
public void .ctor(int port)
public TcpListener Create(int port)
public Socket get_Server()
protected bool get_Active()
public EndPoint get_LocalEndpoint()
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public void AllowNatTraversal(bool allowed)
public void Start()
public void Start(int backlog)
public void Stop()
public bool Pending()
public Socket AcceptSocket()
public TcpClient AcceptTcpClient()
public IAsyncResult BeginAcceptSocket(AsyncCallback callback, object state)
public Socket EndAcceptSocket(IAsyncResult asyncResult)
public IAsyncResult BeginAcceptTcpClient(AsyncCallback callback, object state)
public TcpClient EndAcceptTcpClient(IAsyncResult asyncResult)
public Task`1<Socket> AcceptSocketAsync()
public Task`1<TcpClient> AcceptTcpClientAsync()
}
public System.Net.Sockets.TransmitFileOptions : Enum {
public int value__
public TransmitFileOptions UseDefaultWorkerThread
public TransmitFileOptions Disconnect
public TransmitFileOptions ReuseSocket
public TransmitFileOptions WriteBehind
public TransmitFileOptions UseSystemThread
public TransmitFileOptions UseKernelApc
}
public System.Net.Sockets.UdpClient : object {
private int MaxUDPSize
private Socket m_ClientSocket
private bool m_Active
private Byte[] m_Buffer
private AddressFamily m_Family
private bool m_CleanedUp
private bool m_IsBroadcast
public Socket Client
protected bool Active
public int Available
public short Ttl
public bool DontFragment
public bool MulticastLoopback
public bool EnableBroadcast
public bool ExclusiveAddressUse
public void .ctor(AddressFamily family)
public void .ctor(int port)
public void .ctor(int port, AddressFamily family)
public void .ctor(IPEndPoint localEP)
public void .ctor(string hostname, int port)
public Socket get_Client()
public void set_Client(Socket value)
protected bool get_Active()
protected void set_Active(bool value)
public int get_Available()
public short get_Ttl()
public void set_Ttl(short value)
public bool get_DontFragment()
public void set_DontFragment(bool value)
public bool get_MulticastLoopback()
public void set_MulticastLoopback(bool value)
public bool get_EnableBroadcast()
public void set_EnableBroadcast(bool value)
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public void AllowNatTraversal(bool allowed)
public void Close()
private void FreeResources()
public void Dispose()
protected void Dispose(bool disposing)
public void Connect(string hostname, int port)
public void Connect(IPAddress addr, int port)
public void Connect(IPEndPoint endPoint)
private void CheckForBroadcast(IPAddress ipAddress)
public int Send(Byte[] dgram, int bytes, IPEndPoint endPoint)
public int Send(Byte[] dgram, int bytes, string hostname, int port)
public int Send(Byte[] dgram, int bytes)
public IAsyncResult BeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, object state)
public IAsyncResult BeginSend(Byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state)
public IAsyncResult BeginSend(Byte[] datagram, int bytes, AsyncCallback requestCallback, object state)
public int EndSend(IAsyncResult asyncResult)
public Byte[] Receive(IPEndPoint& remoteEP)
public IAsyncResult BeginReceive(AsyncCallback requestCallback, object state)
public Byte[] EndReceive(IAsyncResult asyncResult, IPEndPoint& remoteEP)
public void JoinMulticastGroup(IPAddress multicastAddr)
public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress)
public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr)
public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive)
public void DropMulticastGroup(IPAddress multicastAddr)
public void DropMulticastGroup(IPAddress multicastAddr, int ifindex)
public Task`1<int> SendAsync(Byte[] datagram, int bytes)
public Task`1<int> SendAsync(Byte[] datagram, int bytes, IPEndPoint endPoint)
public Task`1<int> SendAsync(Byte[] datagram, int bytes, string hostname, int port)
public Task`1<UdpReceiveResult> ReceiveAsync()
private void createClientSocket()
private IAsyncResult <ReceiveAsync>b__64_0(AsyncCallback callback, object state)
private UdpReceiveResult <ReceiveAsync>b__64_1(IAsyncResult ar)
}
public System.Net.Sockets.UdpReceiveResult : ValueType {
private Byte[] m_buffer
private IPEndPoint m_remoteEndPoint
public Byte[] Buffer
public IPEndPoint RemoteEndPoint
public void .ctor(Byte[] buffer, IPEndPoint remoteEndPoint)
public Byte[] get_Buffer()
public IPEndPoint get_RemoteEndPoint()
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(UdpReceiveResult other)
public bool op_Equality(UdpReceiveResult left, UdpReceiveResult right)
public bool op_Inequality(UdpReceiveResult left, UdpReceiveResult right)
}
internal System.Net.SplitWritesState : object {
private int c_SplitEncryptedBuffersSize
private BufferOffsetSize[] _UserBuffers
private int _Index
private int _LastBufferConsumed
private BufferOffsetSize[] _RealBuffers
internal bool IsDone
internal void .ctor(BufferOffsetSize[] buffers)
internal bool get_IsDone()
internal BufferOffsetSize[] GetNextBuffers()
}
internal System.Net.StaticProxy : ProxyChain {
private Uri m_Proxy
internal void .ctor(Uri destination, Uri proxy)
protected bool GetNextProxy(Uri& proxy)
}
internal System.Net.SystemNetworkCredential : NetworkCredential {
internal SystemNetworkCredential defaultCredential
}
internal System.Net.ThreadKinds : Enum {
public int value__
public ThreadKinds Unknown
public ThreadKinds User
public ThreadKinds System
public ThreadKinds Sync
public ThreadKinds Async
public ThreadKinds Timer
public ThreadKinds CompletionPort
public ThreadKinds Worker
public ThreadKinds Finalization
public ThreadKinds Other
public ThreadKinds OwnerMask
public ThreadKinds SyncMask
public ThreadKinds SourceMask
public ThreadKinds SafeSources
public ThreadKinds ThreadPool
}
internal System.Net.TimerThread : object {
private int c_ThreadIdleTimeoutMilliseconds
private int c_CacheScanPerIterations
private int c_TickCountResolution
private LinkedList`1<WeakReference> s_Queues
private LinkedList`1<WeakReference> s_NewQueues
private int s_ThreadState
private AutoResetEvent s_ThreadReadyEvent
private ManualResetEvent s_ThreadShutdownEvent
private WaitHandle[] s_ThreadEvents
private int s_CacheScanIteration
private Hashtable s_QueuesCache
internal Queue CreateQueue(int durationMilliseconds)
internal Queue GetOrCreateQueue(int durationMilliseconds)
private void Prod()
private void ThreadProc()
private void StopTimerThread()
private bool IsTickBetween(int start, int end, int comparand)
private void OnDomainUnload(object sender, EventArgs e)
}
internal System.Net.TrackingStringDictionary : StringDictionary {
private bool isChanged
private bool isReadOnly
internal bool IsChanged
public string Item
internal void .ctor(bool isReadOnly)
internal bool get_IsChanged()
internal void set_IsChanged(bool value)
public void Add(string key, string value)
public void Clear()
public void Remove(string key)
public string get_Item(string key)
public void set_Item(string key, string value)
}
internal System.Net.TrackingValidationObjectDictionary : StringDictionary {
private IDictionary`2<string, object> internalObjects
private IDictionary`2<string, ValidateAndParseValue> validators
private bool <IsChanged>k__BackingField
internal bool IsChanged
public string Item
internal void .ctor(IDictionary`2<string, ValidateAndParseValue> validators)
private void PersistValue(string key, string value, bool addValue)
internal bool get_IsChanged()
internal void set_IsChanged(bool value)
internal object InternalGet(string key)
internal void InternalSet(string key, object value)
public string get_Item(string key)
public void set_Item(string key, string value)
public void Add(string key, string value)
public void Clear()
public void Remove(string key)
}
public System.Net.TransportContext : object {
public ChannelBinding GetChannelBinding(ChannelBindingKind kind)
public IEnumerable`1<TokenBinding> GetTlsTokenBindings()
}
public System.Net.TransportType : Enum {
public int value__
public TransportType Udp
public TransportType Connectionless
public TransportType Tcp
public TransportType ConnectionOriented
public TransportType All
}
internal System.Net.TriState : Enum {
public int value__
public TriState Unspecified
public TriState False
public TriState True
}
internal System.Net.UnlockConnectionDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadDataCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] m_Result
public Byte[] Result
internal void .ctor(Byte[] result, Exception exception, bool cancelled, object userToken)
public Byte[] get_Result()
}
public System.Net.UploadDataCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadDataCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadDataCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadFileCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] m_Result
public Byte[] Result
internal void .ctor(Byte[] result, Exception exception, bool cancelled, object userToken)
public Byte[] get_Result()
}
public System.Net.UploadFileCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadFileCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadFileCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadProgressChangedEventArgs : ProgressChangedEventArgs {
private long m_BytesReceived
private long m_TotalBytesToReceive
private long m_BytesSent
private long m_TotalBytesToSend
public long BytesReceived
public long TotalBytesToReceive
public long BytesSent
public long TotalBytesToSend
internal void .ctor(int progressPercentage, object userToken, long bytesSent, long totalBytesToSend, long bytesReceived, long totalBytesToReceive)
public long get_BytesReceived()
public long get_TotalBytesToReceive()
public long get_BytesSent()
public long get_TotalBytesToSend()
}
public System.Net.UploadProgressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadProgressChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadProgressChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadStringCompletedEventArgs : AsyncCompletedEventArgs {
private string m_Result
public string Result
internal void .ctor(string result, Exception exception, bool cancelled, object userToken)
public string get_Result()
}
public System.Net.UploadStringCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadStringCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadStringCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadValuesCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] m_Result
public Byte[] Result
internal void .ctor(Byte[] result, Exception exception, bool cancelled, object userToken)
public Byte[] get_Result()
}
public System.Net.UploadValuesCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadValuesCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadValuesCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.UriScheme : object {
public string File
public string Ftp
public string Gopher
public string Http
public string Https
public string News
public string NetPipe
public string NetTcp
public string Nntp
public string Mailto
public string Ws
public string Wss
public string SchemeDelimiter
}
internal System.Net.ValidationHelper : object {
public String[] EmptyArray
internal Char[] InvalidMethodChars
internal Char[] InvalidParamChars
public String[] MakeEmptyArrayNull(String[] stringArray)
public string MakeStringNull(string stringValue)
public string ExceptionMessage(Exception exception)
public string ToString(object objectValue)
public string HashString(object objectValue)
public bool IsInvalidHttpString(string stringValue)
public bool IsBlankString(string stringValue)
public bool ValidateTcpPort(int port)
public bool ValidateRange(int actual, int fromAllowed, int toAllowed)
internal void ValidateSegment(ArraySegment`1<byte> segment)
}
internal System.Net.WebAsyncResult : SimpleAsyncResult {
private int nbytes
private IAsyncResult innerAsyncResult
private HttpWebResponse response
private Stream writeStream
private Byte[] buffer
private int offset
private int size
public bool EndCalled
public bool AsyncWriteAll
public HttpWebRequest AsyncObject
internal int NBytes
internal IAsyncResult InnerAsyncResult
internal Stream WriteStream
internal HttpWebResponse Response
internal Byte[] Buffer
internal int Offset
internal int Size
public void .ctor(AsyncCallback cb, object state)
public void .ctor(HttpWebRequest request, AsyncCallback cb, object state)
public void .ctor(AsyncCallback cb, object state, Byte[] buffer, int offset, int size)
internal void Reset()
internal void SetCompleted(bool synch, int nbytes)
internal void SetCompleted(bool synch, Stream writeStream)
internal void SetCompleted(bool synch, HttpWebResponse response)
internal void DoCallback()
internal int get_NBytes()
internal void set_NBytes(int value)
internal IAsyncResult get_InnerAsyncResult()
internal void set_InnerAsyncResult(IAsyncResult value)
internal Stream get_WriteStream()
internal HttpWebResponse get_Response()
internal Byte[] get_Buffer()
internal int get_Offset()
internal int get_Size()
}
public System.Net.WebClient : Component {
private int DefaultCopyBufferLength
private int DefaultDownloadBufferLength
private string DefaultUploadFileContentType
private string UploadFileContentType
private string UploadValuesContentType
private Uri m_baseAddress
private ICredentials m_credentials
private WebHeaderCollection m_headers
private NameValueCollection m_requestParameters
private WebResponse m_WebResponse
private WebRequest m_WebRequest
private Encoding m_Encoding
private string m_Method
private long m_ContentLength
private bool m_InitWebClientAsync
private bool m_Cancelled
private ProgressData m_Progress
private IWebProxy m_Proxy
private bool m_ProxySet
private RequestCachePolicy m_CachePolicy
private bool <AllowReadStreamBuffering>k__BackingField
private bool <AllowWriteStreamBuffering>k__BackingField
private int m_CallNesting
private AsyncOperation m_AsyncOp
private OpenReadCompletedEventHandler OpenReadCompleted
private SendOrPostCallback openReadOperationCompleted
private OpenWriteCompletedEventHandler OpenWriteCompleted
private SendOrPostCallback openWriteOperationCompleted
private DownloadStringCompletedEventHandler DownloadStringCompleted
private SendOrPostCallback downloadStringOperationCompleted
private DownloadDataCompletedEventHandler DownloadDataCompleted
private SendOrPostCallback downloadDataOperationCompleted
private AsyncCompletedEventHandler DownloadFileCompleted
private SendOrPostCallback downloadFileOperationCompleted
private UploadStringCompletedEventHandler UploadStringCompleted
private SendOrPostCallback uploadStringOperationCompleted
private UploadDataCompletedEventHandler UploadDataCompleted
private SendOrPostCallback uploadDataOperationCompleted
private UploadFileCompletedEventHandler UploadFileCompleted
private SendOrPostCallback uploadFileOperationCompleted
private UploadValuesCompletedEventHandler UploadValuesCompleted
private SendOrPostCallback uploadValuesOperationCompleted
private DownloadProgressChangedEventHandler DownloadProgressChanged
private UploadProgressChangedEventHandler UploadProgressChanged
private SendOrPostCallback reportDownloadProgressChanged
private SendOrPostCallback reportUploadProgressChanged
public bool AllowReadStreamBuffering
public bool AllowWriteStreamBuffering
public Encoding Encoding
public string BaseAddress
public ICredentials Credentials
public bool UseDefaultCredentials
public WebHeaderCollection Headers
public NameValueCollection QueryString
public WebHeaderCollection ResponseHeaders
public IWebProxy Proxy
public RequestCachePolicy CachePolicy
public bool IsBusy
private void InitWebClientAsync()
private void ClearWebClientState()
private void CompleteWebClientState()
public bool get_AllowReadStreamBuffering()
public void set_AllowReadStreamBuffering(bool value)
public bool get_AllowWriteStreamBuffering()
public void set_AllowWriteStreamBuffering(bool value)
public void add_WriteStreamClosed(WriteStreamClosedEventHandler value)
public void remove_WriteStreamClosed(WriteStreamClosedEventHandler value)
protected void OnWriteStreamClosed(WriteStreamClosedEventArgs e)
public Encoding get_Encoding()
public void set_Encoding(Encoding value)
public string get_BaseAddress()
public void set_BaseAddress(string value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public NameValueCollection get_QueryString()
public void set_QueryString(NameValueCollection value)
public WebHeaderCollection get_ResponseHeaders()
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public RequestCachePolicy get_CachePolicy()
public void set_CachePolicy(RequestCachePolicy value)
public bool get_IsBusy()
protected WebRequest GetWebRequest(Uri address)
protected WebResponse GetWebResponse(WebRequest request)
protected WebResponse GetWebResponse(WebRequest request, IAsyncResult result)
public Byte[] DownloadData(string address)
public Byte[] DownloadData(Uri address)
private Byte[] DownloadDataInternal(Uri address, WebRequest& request)
public void DownloadFile(string address, string fileName)
public void DownloadFile(Uri address, string fileName)
public Stream OpenRead(string address)
public Stream OpenRead(Uri address)
public Stream OpenWrite(string address)
public Stream OpenWrite(Uri address)
public Stream OpenWrite(string address, string method)
public Stream OpenWrite(Uri address, string method)
public Byte[] UploadData(string address, Byte[] data)
public Byte[] UploadData(Uri address, Byte[] data)
public Byte[] UploadData(string address, string method, Byte[] data)
public Byte[] UploadData(Uri address, string method, Byte[] data)
private Byte[] UploadDataInternal(Uri address, string method, Byte[] data, WebRequest& request)
private void OpenFileInternal(bool needsHeaderAndBoundary, string fileName, FileStream& fs, Byte[]& buffer, Byte[]& formHeaderBytes, Byte[]& boundaryBytes)
public Byte[] UploadFile(string address, string fileName)
public Byte[] UploadFile(Uri address, string fileName)
public Byte[] UploadFile(string address, string method, string fileName)
public Byte[] UploadFile(Uri address, string method, string fileName)
private Byte[] UploadValuesInternal(NameValueCollection data)
public Byte[] UploadValues(string address, NameValueCollection data)
public Byte[] UploadValues(Uri address, NameValueCollection data)
public Byte[] UploadValues(string address, string method, NameValueCollection data)
public Byte[] UploadValues(Uri address, string method, NameValueCollection data)
public string UploadString(string address, string data)
public string UploadString(Uri address, string data)
public string UploadString(string address, string method, string data)
public string UploadString(Uri address, string method, string data)
public string DownloadString(string address)
public string DownloadString(Uri address)
private void AbortRequest(WebRequest request)
private void CopyHeadersTo(WebRequest request)
private Uri GetUri(string path)
private Uri GetUri(Uri address)
private void DownloadBitsResponseCallback(IAsyncResult result)
private void DownloadBitsReadCallback(IAsyncResult result)
private void DownloadBitsReadCallbackState(DownloadBitsState state, IAsyncResult result)
private Byte[] DownloadBits(WebRequest request, Stream writeStream, CompletionDelegate completionDelegate, AsyncOperation asyncOp)
private void UploadBitsRequestCallback(IAsyncResult result)
private void UploadBitsWriteCallback(IAsyncResult result)
private void UploadBits(WebRequest request, Stream readStream, Byte[] buffer, int chunkSize, Byte[] header, Byte[] footer, CompletionDelegate uploadCompletionDelegate, CompletionDelegate downloadCompletionDelegate, AsyncOperation asyncOp)
private bool ByteArrayHasPrefix(Byte[] prefix, Byte[] byteArray)
private string GetStringUsingEncoding(WebRequest request, Byte[] data)
private string MapToDefaultMethod(Uri address)
private string UrlEncode(string str)
private string UrlEncode(string str, Encoding e)
private Byte[] UrlEncodeToBytes(string str, Encoding e)
private Byte[] UrlEncodeBytesToBytesInternal(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue)
private char IntToHex(int n)
private bool IsSafe(char ch)
private void InvokeOperationCompleted(AsyncOperation asyncOp, SendOrPostCallback callback, AsyncCompletedEventArgs eventArgs)
private bool AnotherCallInProgress(int callNesting)
public void add_OpenReadCompleted(OpenReadCompletedEventHandler value)
public void remove_OpenReadCompleted(OpenReadCompletedEventHandler value)
protected void OnOpenReadCompleted(OpenReadCompletedEventArgs e)
private void OpenReadOperationCompleted(object arg)
private void OpenReadAsyncCallback(IAsyncResult result)
public void OpenReadAsync(Uri address)
public void OpenReadAsync(Uri address, object userToken)
public void add_OpenWriteCompleted(OpenWriteCompletedEventHandler value)
public void remove_OpenWriteCompleted(OpenWriteCompletedEventHandler value)
protected void OnOpenWriteCompleted(OpenWriteCompletedEventArgs e)
private void OpenWriteOperationCompleted(object arg)
private void OpenWriteAsyncCallback(IAsyncResult result)
public void OpenWriteAsync(Uri address)
public void OpenWriteAsync(Uri address, string method)
public void OpenWriteAsync(Uri address, string method, object userToken)
public void add_DownloadStringCompleted(DownloadStringCompletedEventHandler value)
public void remove_DownloadStringCompleted(DownloadStringCompletedEventHandler value)
protected void OnDownloadStringCompleted(DownloadStringCompletedEventArgs e)
private void DownloadStringOperationCompleted(object arg)
private void DownloadStringAsyncCallback(Byte[] returnBytes, Exception exception, object state)
public void DownloadStringAsync(Uri address)
public void DownloadStringAsync(Uri address, object userToken)
public void add_DownloadDataCompleted(DownloadDataCompletedEventHandler value)
public void remove_DownloadDataCompleted(DownloadDataCompletedEventHandler value)
protected void OnDownloadDataCompleted(DownloadDataCompletedEventArgs e)
private void DownloadDataOperationCompleted(object arg)
private void DownloadDataAsyncCallback(Byte[] returnBytes, Exception exception, object state)
public void DownloadDataAsync(Uri address)
public void DownloadDataAsync(Uri address, object userToken)
public void add_DownloadFileCompleted(AsyncCompletedEventHandler value)
public void remove_DownloadFileCompleted(AsyncCompletedEventHandler value)
protected void OnDownloadFileCompleted(AsyncCompletedEventArgs e)
private void DownloadFileOperationCompleted(object arg)
private void DownloadFileAsyncCallback(Byte[] returnBytes, Exception exception, object state)
public void DownloadFileAsync(Uri address, string fileName)
public void DownloadFileAsync(Uri address, string fileName, object userToken)
public void add_UploadStringCompleted(UploadStringCompletedEventHandler value)
public void remove_UploadStringCompleted(UploadStringCompletedEventHandler value)
protected void OnUploadStringCompleted(UploadStringCompletedEventArgs e)
private void UploadStringOperationCompleted(object arg)
private void StartDownloadAsync(UploadBitsState state)
private void UploadStringAsyncWriteCallback(Byte[] returnBytes, Exception exception, object state)
private void UploadStringAsyncReadCallback(Byte[] returnBytes, Exception exception, object state)
public void UploadStringAsync(Uri address, string data)
public void UploadStringAsync(Uri address, string method, string data)
public void UploadStringAsync(Uri address, string method, string data, object userToken)
public void add_UploadDataCompleted(UploadDataCompletedEventHandler value)
public void remove_UploadDataCompleted(UploadDataCompletedEventHandler value)
protected void OnUploadDataCompleted(UploadDataCompletedEventArgs e)
private void UploadDataOperationCompleted(object arg)
private void UploadDataAsyncWriteCallback(Byte[] returnBytes, Exception exception, object state)
private void UploadDataAsyncReadCallback(Byte[] returnBytes, Exception exception, object state)
public void UploadDataAsync(Uri address, Byte[] data)
public void UploadDataAsync(Uri address, string method, Byte[] data)
public void UploadDataAsync(Uri address, string method, Byte[] data, object userToken)
public void add_UploadFileCompleted(UploadFileCompletedEventHandler value)
public void remove_UploadFileCompleted(UploadFileCompletedEventHandler value)
protected void OnUploadFileCompleted(UploadFileCompletedEventArgs e)
private void UploadFileOperationCompleted(object arg)
private void UploadFileAsyncWriteCallback(Byte[] returnBytes, Exception exception, object state)
private void UploadFileAsyncReadCallback(Byte[] returnBytes, Exception exception, object state)
public void UploadFileAsync(Uri address, string fileName)
public void UploadFileAsync(Uri address, string method, string fileName)
public void UploadFileAsync(Uri address, string method, string fileName, object userToken)
public void add_UploadValuesCompleted(UploadValuesCompletedEventHandler value)
public void remove_UploadValuesCompleted(UploadValuesCompletedEventHandler value)
protected void OnUploadValuesCompleted(UploadValuesCompletedEventArgs e)
private void UploadValuesOperationCompleted(object arg)
private void UploadValuesAsyncWriteCallback(Byte[] returnBytes, Exception exception, object state)
private void UploadValuesAsyncReadCallback(Byte[] returnBytes, Exception exception, object state)
public void UploadValuesAsync(Uri address, NameValueCollection data)
public void UploadValuesAsync(Uri address, string method, NameValueCollection data)
public void UploadValuesAsync(Uri address, string method, NameValueCollection data, object userToken)
public void CancelAsync()
public Task`1<string> DownloadStringTaskAsync(string address)
public Task`1<string> DownloadStringTaskAsync(Uri address)
public Task`1<Stream> OpenReadTaskAsync(string address)
public Task`1<Stream> OpenReadTaskAsync(Uri address)
public Task`1<Stream> OpenWriteTaskAsync(string address)
public Task`1<Stream> OpenWriteTaskAsync(Uri address)
public Task`1<Stream> OpenWriteTaskAsync(string address, string method)
public Task`1<Stream> OpenWriteTaskAsync(Uri address, string method)
public Task`1<string> UploadStringTaskAsync(string address, string data)
public Task`1<string> UploadStringTaskAsync(Uri address, string data)
public Task`1<string> UploadStringTaskAsync(string address, string method, string data)
public Task`1<string> UploadStringTaskAsync(Uri address, string method, string data)
public Task`1<Byte[]> DownloadDataTaskAsync(string address)
public Task`1<Byte[]> DownloadDataTaskAsync(Uri address)
public Task DownloadFileTaskAsync(string address, string fileName)
public Task DownloadFileTaskAsync(Uri address, string fileName)
public Task`1<Byte[]> UploadDataTaskAsync(string address, Byte[] data)
public Task`1<Byte[]> UploadDataTaskAsync(Uri address, Byte[] data)
public Task`1<Byte[]> UploadDataTaskAsync(string address, string method, Byte[] data)
public Task`1<Byte[]> UploadDataTaskAsync(Uri address, string method, Byte[] data)
public Task`1<Byte[]> UploadFileTaskAsync(string address, string fileName)
public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string fileName)
public Task`1<Byte[]> UploadFileTaskAsync(string address, string method, string fileName)
public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string method, string fileName)
public Task`1<Byte[]> UploadValuesTaskAsync(string address, NameValueCollection data)
public Task`1<Byte[]> UploadValuesTaskAsync(string address, string method, NameValueCollection data)
public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, NameValueCollection data)
public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, string method, NameValueCollection data)
private void HandleCompletion(TaskCompletionSource`1<T> tcs, TAsyncCompletedEventArgs e, Func`2<TAsyncCompletedEventArgs, T> getResult, TCompletionDelegate handler, Action`2<WebClient, TCompletionDelegate> unregisterHandler)
public void add_DownloadProgressChanged(DownloadProgressChangedEventHandler value)
public void remove_DownloadProgressChanged(DownloadProgressChangedEventHandler value)
public void add_UploadProgressChanged(UploadProgressChangedEventHandler value)
public void remove_UploadProgressChanged(UploadProgressChangedEventHandler value)
protected void OnDownloadProgressChanged(DownloadProgressChangedEventArgs e)
protected void OnUploadProgressChanged(UploadProgressChangedEventArgs e)
private void ReportDownloadProgressChanged(object arg)
private void ReportUploadProgressChanged(object arg)
private void PostProgressChanged(AsyncOperation asyncOp, ProgressData progress)
}
internal System.Net.WebConnection : object {
private ServicePoint sPoint
private Stream nstream
internal Socket socket
private object socketLock
private IWebConnectionState state
private WebExceptionStatus status
private bool keepAlive
private Byte[] buffer
private EventHandler abortHandler
private AbortHelper abortHelper
internal WebConnectionData Data
private bool chunkedRead
private MonoChunkStream chunkStream
private Queue queue
private bool reused
private int position
private HttpWebRequest priority_request
private NetworkCredential ntlm_credentials
private bool ntlm_authenticated
private bool unsafe_sharing
private NtlmAuthState connect_ntlm_auth_state
private HttpWebRequest connect_request
private Exception connect_exception
private MonoTlsStream tlsStream
internal MonoChunkStream MonoChunkStream
internal bool Connected
internal HttpWebRequest PriorityRequest
internal bool NtlmAuthenticated
internal NetworkCredential NtlmCredential
internal bool UnsafeAuthenticatedConnectionSharing
internal MonoChunkStream get_MonoChunkStream()
public void .ctor(IWebConnectionState wcs, ServicePoint sPoint)
private bool CanReuse()
private void Connect(HttpWebRequest request)
private bool CreateTunnel(HttpWebRequest request, Uri connectUri, Stream stream, Byte[]& buffer)
private WebHeaderCollection ReadHeaders(Stream stream, Byte[]& retBuffer, Int32& status)
private void FlushContents(Stream stream, int contentLength)
private bool CreateStream(HttpWebRequest request)
private void HandleError(WebExceptionStatus st, Exception e, string where)
private void ReadDone(IAsyncResult result)
private bool ExpectContent(int statusCode, string method)
internal void InitRead()
private int GetResponse(WebConnectionData data, ServicePoint sPoint, Byte[] buffer, int max)
private void InitConnection(HttpWebRequest request)
internal EventHandler SendRequest(HttpWebRequest request)
private void SendNext()
internal void NextRead()
private bool ReadLine(Byte[] buffer, Int32& start, int max, String& output)
internal IAsyncResult BeginRead(HttpWebRequest request, Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
internal int EndRead(HttpWebRequest request, IAsyncResult result)
private int EnsureRead(Byte[] buffer, int offset, int size)
private bool CompleteChunkedRead()
internal IAsyncResult BeginWrite(HttpWebRequest request, Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
internal bool EndWrite(HttpWebRequest request, bool throwOnError, IAsyncResult result)
internal int Read(HttpWebRequest request, Byte[] buffer, int offset, int size)
internal bool Write(HttpWebRequest request, Byte[] buffer, int offset, int size, String& err_msg)
internal void Close(bool sendNext)
private void Abort(object sender, EventArgs args)
internal void ResetNtlm()
internal bool get_Connected()
internal void set_PriorityRequest(HttpWebRequest value)
internal bool get_NtlmAuthenticated()
internal void set_NtlmAuthenticated(bool value)
internal NetworkCredential get_NtlmCredential()
internal void set_NtlmCredential(NetworkCredential value)
internal bool get_UnsafeAuthenticatedConnectionSharing()
internal void set_UnsafeAuthenticatedConnectionSharing(bool value)
private void <SendRequest>b__41_0(object o)
}
internal System.Net.WebConnectionData : object {
private HttpWebRequest _request
public int StatusCode
public string StatusDescription
public WebHeaderCollection Headers
public Version Version
public Version ProxyVersion
public Stream stream
public String[] Challenge
private ReadState _readState
public HttpWebRequest request
public ReadState ReadState
public void .ctor(HttpWebRequest request)
public HttpWebRequest get_request()
public void set_request(HttpWebRequest value)
public ReadState get_ReadState()
public void set_ReadState(ReadState value)
}
internal System.Net.WebConnectionGroup : object {
private ServicePoint sPoint
private string name
private LinkedList`1<ConnectionState> connections
private Queue queue
private bool closing
private EventHandler ConnectionClosed
public string Name
internal Queue Queue
public void .ctor(ServicePoint sPoint, string name)
public void add_ConnectionClosed(EventHandler value)
public void remove_ConnectionClosed(EventHandler value)
private void OnConnectionClosed()
public void Close()
public WebConnection GetConnection(HttpWebRequest request, Boolean& created)
private void PrepareSharingNtlm(WebConnection cnc, HttpWebRequest request)
private ConnectionState FindIdleConnection()
private WebConnection CreateOrReuseConnection(HttpWebRequest request, Boolean& created)
public string get_Name()
internal Queue get_Queue()
internal bool TryRecycle(TimeSpan maxIdleTime, DateTime& idleSince)
}
internal System.Net.WebConnectionStream : Stream {
private Byte[] crlf
private bool isRead
private WebConnection cnc
private HttpWebRequest request
private Byte[] readBuffer
private int readBufferOffset
private int readBufferSize
private int stream_length
private long contentLength
private long totalRead
internal long totalWritten
private bool nextReadCalled
private int pendingReads
private int pendingWrites
private ManualResetEvent pending
private bool allowBuffering
private bool sendChunked
private MemoryStream writeBuffer
private bool requestWritten
private Byte[] headers
private bool disposed
private bool headersSent
private object locker
private bool initRead
private bool read_eof
private bool complete_request_written
private int read_timeout
private int write_timeout
private AsyncCallback cb_wrapper
internal bool IgnoreIOErrors
private bool <GetResponseOnClose>k__BackingField
internal HttpWebRequest Request
internal WebConnection Connection
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
internal bool CompleteRequestWritten
internal bool SendChunked
internal Byte[] ReadBuffer
internal int ReadBufferOffset
internal int ReadBufferSize
internal Byte[] WriteBuffer
internal int WriteBufferLength
internal bool RequestWritten
internal bool GetResponseOnClose
public bool CanSeek
public bool CanRead
public bool CanWrite
public long Length
public long Position
public void .ctor(WebConnection cnc, WebConnectionData data)
public void .ctor(WebConnection cnc, HttpWebRequest request)
private bool CheckAuthHeader(string headerName)
private bool IsNtlmAuth()
internal void CheckResponseInBuffer()
internal HttpWebRequest get_Request()
internal WebConnection get_Connection()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
internal bool get_CompleteRequestWritten()
internal void set_SendChunked(bool value)
internal void set_ReadBuffer(Byte[] value)
internal void set_ReadBufferOffset(int value)
internal void set_ReadBufferSize(int value)
internal Byte[] get_WriteBuffer()
internal int get_WriteBufferLength()
internal void ForceCompletion()
internal void CheckComplete()
internal void ReadAll()
private void WriteCallbackWrapper(IAsyncResult r)
private void ReadCallbackWrapper(IAsyncResult r)
public int Read(Byte[] buffer, int offset, int size)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
public int EndRead(IAsyncResult r)
private void WriteAsyncCB(IAsyncResult r)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
private void CheckWriteOverflow(long contentLength, long totalWritten, long size)
public void EndWrite(IAsyncResult r)
public void Write(Byte[] buffer, int offset, int size)
public void Flush()
internal void SetHeadersAsync(bool setInternalLength, SimpleAsyncCallback callback)
private bool SetHeadersAsync(SimpleAsyncResult result, bool setInternalLength)
internal bool get_RequestWritten()
internal SimpleAsyncResult WriteRequestAsync(SimpleAsyncCallback callback)
internal bool WriteRequestAsync(SimpleAsyncResult result)
internal void InternalClose()
internal bool get_GetResponseOnClose()
internal void set_GetResponseOnClose(bool value)
public void Close()
internal void KillBuffer()
public long Seek(long a, SeekOrigin b)
public void SetLength(long a)
public bool get_CanSeek()
public bool get_CanRead()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
}
public System.Net.WebException : InvalidOperationException {
private WebExceptionStatus m_Status
private WebResponse m_Response
private WebExceptionInternalStatus m_InternalStatus
public WebExceptionStatus Status
public WebResponse Response
internal WebExceptionInternalStatus InternalStatus
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, WebExceptionStatus status)
internal void .ctor(string message, WebExceptionStatus status, WebExceptionInternalStatus internalStatus, Exception innerException)
public void .ctor(string message, Exception innerException, WebExceptionStatus status, WebResponse response)
internal void .ctor(string message, string data, Exception innerException, WebExceptionStatus status, WebResponse response)
internal void .ctor(string message, Exception innerException, WebExceptionStatus status, WebResponse response, WebExceptionInternalStatus internalStatus)
internal void .ctor(string message, string data, Exception innerException, WebExceptionStatus status, WebResponse response, WebExceptionInternalStatus internalStatus)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public WebExceptionStatus get_Status()
public WebResponse get_Response()
internal WebExceptionInternalStatus get_InternalStatus()
}
internal System.Net.WebExceptionInternalStatus : Enum {
public int value__
public WebExceptionInternalStatus RequestFatal
public WebExceptionInternalStatus ServicePointFatal
public WebExceptionInternalStatus Recoverable
public WebExceptionInternalStatus Isolated
}
internal System.Net.WebExceptionMapping : object {
private String[] s_Mapping
internal string GetWebStatusString(WebExceptionStatus status)
}
public System.Net.WebExceptionStatus : Enum {
public int value__
public WebExceptionStatus Success
public WebExceptionStatus NameResolutionFailure
public WebExceptionStatus ConnectFailure
public WebExceptionStatus ReceiveFailure
public WebExceptionStatus SendFailure
public WebExceptionStatus PipelineFailure
public WebExceptionStatus RequestCanceled
public WebExceptionStatus ProtocolError
public WebExceptionStatus ConnectionClosed
public WebExceptionStatus TrustFailure
public WebExceptionStatus SecureChannelFailure
public WebExceptionStatus ServerProtocolViolation
public WebExceptionStatus KeepAliveFailure
public WebExceptionStatus Pending
public WebExceptionStatus Timeout
public WebExceptionStatus ProxyNameResolutionFailure
public WebExceptionStatus UnknownError
public WebExceptionStatus MessageLengthLimitExceeded
public WebExceptionStatus CacheEntryNotFound
public WebExceptionStatus RequestProhibitedByCachePolicy
public WebExceptionStatus RequestProhibitedByProxy
}
public System.Net.WebHeaderCollection : NameValueCollection {
private int ApproxAveHeaderLineSize
private int ApproxHighAvgNumHeaders
private HeaderInfoTable HInfo
private String[] m_CommonHeaders
private int m_NumCommonHeaders
private String[] s_CommonHeaderNames
private SByte[] s_CommonHeaderHints
private int c_AcceptRanges
private int c_ContentLength
private int c_CacheControl
private int c_ContentType
private int c_Date
private int c_Expires
private int c_ETag
private int c_LastModified
private int c_Location
private int c_ProxyAuthenticate
private int c_P3P
private int c_SetCookie2
private int c_SetCookie
private int c_Server
private int c_Via
private int c_WwwAuthenticate
private int c_XAspNetVersion
private int c_XPoweredBy
private NameValueCollection m_InnerCollection
private WebHeaderCollectionType m_Type
private Char[] HttpTrimCharacters
private RfcChar[] RfcCharMap
internal string ContentLength
internal string CacheControl
internal string ContentType
internal string Date
internal string Expires
internal string ETag
internal string LastModified
internal string Location
internal string ProxyAuthenticate
internal string SetCookie2
internal string SetCookie
internal string Server
internal string Via
private NameValueCollection InnerCollection
private bool AllowHttpRequestHeader
internal bool AllowHttpResponseHeader
public string Item
public string Item
public int Count
public KeysCollection Keys
public String[] AllKeys
internal string get_ContentLength()
internal string get_CacheControl()
internal string get_ContentType()
internal string get_Date()
internal string get_Expires()
internal string get_ETag()
internal string get_LastModified()
internal string get_Location()
internal string get_ProxyAuthenticate()
internal string get_SetCookie2()
internal string get_SetCookie()
internal string get_Server()
internal string get_Via()
private void NormalizeCommonHeaders()
private NameValueCollection get_InnerCollection()
internal bool AllowMultiValues(string name)
private bool get_AllowHttpRequestHeader()
internal bool get_AllowHttpResponseHeader()
public string get_Item(HttpRequestHeader header)
public void set_Item(HttpRequestHeader header, string value)
public string get_Item(HttpResponseHeader header)
public void set_Item(HttpResponseHeader header, string value)
public void Add(HttpRequestHeader header, string value)
public void Add(HttpResponseHeader header, string value)
public void Set(HttpRequestHeader header, string value)
public void Set(HttpResponseHeader header, string value)
internal void SetInternal(HttpResponseHeader header, string value)
public void Remove(HttpRequestHeader header)
public void Remove(HttpResponseHeader header)
protected void AddWithoutValidate(string headerName, string headerValue)
internal void SetAddVerified(string name, string value)
internal void AddInternal(string name, string value)
internal void ChangeInternal(string name, string value)
internal void RemoveInternal(string name)
internal void CheckUpdate(string name, string value)
private void AddInternalNotCommon(string name, string value)
internal string CheckBadChars(string name, bool isHeaderValue)
internal bool IsValidToken(string token)
internal bool ContainsNonAsciiChars(string token)
internal void ThrowOnRestrictedHeader(string headerName)
public void Add(string name, string value)
public void Add(string header)
public void Set(string name, string value)
internal void SetInternal(string name, string value)
public void Remove(string name)
public String[] GetValues(string header)
public string ToString()
internal string ToString(bool forTrace)
internal string GetAsString(NameValueCollection cc, bool winInetCompat, bool forTrace)
public Byte[] ToByteArray()
public bool IsRestricted(string headerName)
public bool IsRestricted(string headerName, bool response)
internal void .ctor(WebHeaderCollectionType type)
internal void .ctor(NameValueCollection cc)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void OnDeserialization(object sender)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal DataParseStatus ParseHeaders(Byte[] buffer, int size, Int32& unparsed, Int32& totalResponseHeadersLength, int maximumResponseHeadersLength, WebParseError& parseError)
internal DataParseStatus ParseHeadersStrict(Byte[] buffer, int size, Int32& unparsed, Int32& totalResponseHeadersLength, int maximumResponseHeadersLength, WebParseError& parseError)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public string Get(string name)
public IEnumerator GetEnumerator()
public int get_Count()
public KeysCollection get_Keys()
internal bool InternalHasKeys()
public string Get(int index)
public String[] GetValues(int index)
public string GetKey(int index)
public String[] get_AllKeys()
public void Clear()
}
internal System.Net.WebHeaderCollectionType : Enum {
public ushort value__
public WebHeaderCollectionType Unknown
public WebHeaderCollectionType WebRequest
public WebHeaderCollectionType WebResponse
public WebHeaderCollectionType HttpWebRequest
public WebHeaderCollectionType HttpWebResponse
public WebHeaderCollectionType HttpListenerRequest
public WebHeaderCollectionType HttpListenerResponse
public WebHeaderCollectionType FtpWebRequest
public WebHeaderCollectionType FtpWebResponse
public WebHeaderCollectionType FileWebRequest
public WebHeaderCollectionType FileWebResponse
}
internal System.Net.WebParseError : ValueType {
public WebParseErrorSection Section
public WebParseErrorCode Code
}
internal System.Net.WebParseErrorCode : Enum {
public int value__
public WebParseErrorCode Generic
public WebParseErrorCode InvalidHeaderName
public WebParseErrorCode InvalidContentLength
public WebParseErrorCode IncompleteHeaderLine
public WebParseErrorCode CrLfError
public WebParseErrorCode InvalidChunkFormat
public WebParseErrorCode UnexpectedServerResponse
}
internal System.Net.WebParseErrorSection : Enum {
public int value__
public WebParseErrorSection Generic
public WebParseErrorSection ResponseHeader
public WebParseErrorSection ResponseStatusLine
public WebParseErrorSection ResponseBody
}
public System.Net.WebPermission : CodeAccessPermission {
private bool m_noRestriction
private bool m_UnrestrictedConnect
private bool m_UnrestrictedAccept
private ArrayList m_connectList
private ArrayList m_acceptList
internal string MatchAll
private Regex modreq(System.Runtime.CompilerServices.IsVolatile) s_MatchAllRegex
internal Regex MatchAllRegex
public IEnumerator ConnectList
public IEnumerator AcceptList
internal Regex get_MatchAllRegex()
public IEnumerator get_ConnectList()
public IEnumerator get_AcceptList()
public void .ctor(PermissionState state)
internal void .ctor(bool unrestricted)
internal void .ctor(NetworkAccess access)
public void .ctor(NetworkAccess access, Regex uriRegex)
public void .ctor(NetworkAccess access, string uriString)
internal void .ctor(NetworkAccess access, Uri uri)
public void AddPermission(NetworkAccess access, string uriString)
internal void AddPermission(NetworkAccess access, Uri uri)
public void AddPermission(NetworkAccess access, Regex uriRegex)
internal void AddAsPattern(NetworkAccess access, DelayedRegex uriRegexPattern)
public bool IsUnrestricted()
public IPermission Copy()
public bool IsSubsetOf(IPermission target)
private bool isSpecialSubsetCase(string regexToCheck, ArrayList permList)
public IPermission Union(IPermission target)
public IPermission Intersect(IPermission target)
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
private bool isMatchedURI(object uriToCheck, ArrayList uriPatternList)
private void intersectList(ArrayList A, ArrayList B, ArrayList result)
private object intersectPair(object L, object R, Boolean& isUri)
}
public System.Net.WebPermissionAttribute : CodeAccessSecurityAttribute {
private object m_accept
private object m_connect
public string Connect
public string Accept
public string ConnectPattern
public string AcceptPattern
public void .ctor(SecurityAction action)
public string get_Connect()
public void set_Connect(string value)
public string get_Accept()
public void set_Accept(string value)
public string get_ConnectPattern()
public void set_ConnectPattern(string value)
public string get_AcceptPattern()
public void set_AcceptPattern(string value)
public IPermission CreatePermission()
}
public System.Net.WebProxy : object {
private bool _UseRegistry
private bool _BypassOnLocal
private bool m_EnableAutoproxy
private Uri _ProxyAddress
private ArrayList _BypassList
private ICredentials _Credentials
private Regex[] _RegExBypassList
private Hashtable _ProxyHostAddresses
private AutoWebProxyScriptEngine m_ScriptEngine
public Uri Address
internal bool AutoDetect
internal Uri ScriptLocation
public bool BypassProxyOnLocal
public String[] BypassList
public ICredentials Credentials
public bool UseDefaultCredentials
public ArrayList BypassArrayList
internal AutoWebProxyScriptEngine ScriptEngine
public void .ctor(Uri Address)
public void .ctor(Uri Address, bool BypassOnLocal)
public void .ctor(Uri Address, bool BypassOnLocal, String[] BypassList)
public void .ctor(Uri Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials)
public void .ctor(string Host, int Port)
public void .ctor(string Address)
public void .ctor(string Address, bool BypassOnLocal)
public void .ctor(string Address, bool BypassOnLocal, String[] BypassList)
public void .ctor(string Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials)
public Uri get_Address()
public void set_Address(Uri value)
internal void set_AutoDetect(bool value)
internal void set_ScriptLocation(Uri value)
public bool get_BypassProxyOnLocal()
public void set_BypassProxyOnLocal(bool value)
public String[] get_BypassList()
public void set_BypassList(String[] value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public ArrayList get_BypassArrayList()
internal void CheckForChanges()
public Uri GetProxy(Uri destination)
private Uri CreateProxyUri(string address)
private void UpdateRegExList(bool canThrow)
private bool IsMatchInBypassList(Uri input)
private bool IsLocal(Uri host)
private bool IsLocalInProxyHash(Uri host)
public bool IsBypassed(Uri host)
private bool IsBypassedManual(Uri host)
public WebProxy GetDefaultProxy()
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal AutoWebProxyScriptEngine get_ScriptEngine()
internal void set_ScriptEngine(AutoWebProxyScriptEngine value)
public IWebProxy CreateDefaultProxy()
internal void .ctor(bool enableAutoproxy)
internal void DeleteScriptEngine()
internal void UnsafeUpdateFromRegistry()
internal void Update(WebProxyData webProxyData)
private ProxyChain System.Net.IAutoWebProxy.GetProxies(Uri destination)
private bool GetProxyAuto(Uri destination, Uri& proxyUri)
private bool IsBypassedAuto(Uri destination, Boolean& isBypassed)
internal Uri[] GetProxiesAuto(Uri destination, Int32& syncStatus)
internal void AbortGetProxiesAuto(Int32& syncStatus)
internal Uri GetProxyAutoFailover(Uri destination)
private bool AreAllBypassed(IEnumerable`1<string> proxies, bool checkFirstOnly)
private Uri ProxyUri(string proxyName)
}
internal System.Net.WebProxyData : object {
internal bool bypassOnLocal
internal bool automaticallyDetectSettings
internal Uri proxyAddress
internal Hashtable proxyHostAddresses
internal Uri scriptLocation
internal ArrayList bypassList
}
internal System.Net.WebProxyDataBuilder : object {
private char addressListDelimiter
private char addressListSchemeValueDelimiter
private char bypassListDelimiter
private WebProxyData m_Result
private string regexReserved
public WebProxyData Build()
protected void BuildInternal()
protected void SetProxyAndBypassList(string addressString, string bypassListString)
protected void SetAutoProxyUrl(string autoConfigUrl)
protected void SetAutoDetectSettings(bool value)
private Uri ParseProxyUri(string proxyString)
private Hashtable ParseProtocolProxies(string proxyListString)
private FormatException CreateInvalidProxyStringException(string originalProxyString)
private string BypassStringEscape(string rawString)
private string ConvertRegexReservedChars(string rawString)
private ArrayList ParseBypassList(string bypassListString, Boolean& bypassOnLocal)
}
public System.Net.WebRequest : MarshalByRefObject {
internal int DefaultTimeout
private ArrayList modreq(System.Runtime.CompilerServices.IsVolatile) s_PrefixList
private object s_InternalSyncObject
private Queue s_DefaultTimerQueue
private AuthenticationLevel m_AuthenticationLevel
private TokenImpersonationLevel m_ImpersonationLevel
private RequestCachePolicy m_CachePolicy
private RequestCacheProtocol m_CacheProtocol
private RequestCacheBinding m_CacheBinding
private DesignerWebRequestCreate webRequestCreate
private IWebProxy modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultWebProxy
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultWebProxyInitialized
public IWebRequestCreate CreatorInstance
private object InternalSyncObject
internal Queue DefaultTimerQueue
internal ArrayList PrefixList
public RequestCachePolicy DefaultCachePolicy
public RequestCachePolicy CachePolicy
public string Method
public Uri RequestUri
public string ConnectionGroupName
public WebHeaderCollection Headers
public long ContentLength
public string ContentType
public ICredentials Credentials
public bool UseDefaultCredentials
public IWebProxy Proxy
public bool PreAuthenticate
public int Timeout
internal RequestCacheProtocol CacheProtocol
public AuthenticationLevel AuthenticationLevel
public TokenImpersonationLevel ImpersonationLevel
internal IWebProxy InternalDefaultWebProxy
public IWebProxy DefaultWebProxy
public IWebRequestCreate get_CreatorInstance()
public void RegisterPortableWebRequestCreator(IWebRequestCreate creator)
private object get_InternalSyncObject()
internal Queue get_DefaultTimerQueue()
private WebRequest Create(Uri requestUri, bool useUriBase)
public WebRequest Create(string requestUriString)
public WebRequest Create(Uri requestUri)
public WebRequest CreateDefault(Uri requestUri)
public HttpWebRequest CreateHttp(string requestUriString)
public HttpWebRequest CreateHttp(Uri requestUri)
public bool RegisterPrefix(string prefix, IWebRequestCreate creator)
internal ArrayList get_PrefixList()
internal void set_PrefixList(ArrayList value)
private ArrayList PopulatePrefixList()
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public RequestCachePolicy get_DefaultCachePolicy()
public void set_DefaultCachePolicy(RequestCachePolicy value)
public RequestCachePolicy get_CachePolicy()
public void set_CachePolicy(RequestCachePolicy value)
private void InternalSetCachePolicy(RequestCachePolicy policy)
public string get_Method()
public void set_Method(string value)
public Uri get_RequestUri()
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public long get_ContentLength()
public void set_ContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public int get_Timeout()
public void set_Timeout(int value)
public Stream GetRequestStream()
public WebResponse GetResponse()
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public Task`1<Stream> GetRequestStreamAsync()
public Task`1<WebResponse> GetResponseAsync()
private WindowsIdentity SafeCaptureIdenity()
public void Abort()
internal RequestCacheProtocol get_CacheProtocol()
internal void set_CacheProtocol(RequestCacheProtocol value)
public AuthenticationLevel get_AuthenticationLevel()
public void set_AuthenticationLevel(AuthenticationLevel value)
public TokenImpersonationLevel get_ImpersonationLevel()
public void set_ImpersonationLevel(TokenImpersonationLevel value)
internal void RequestCallback(object obj)
internal IWebProxy get_InternalDefaultWebProxy()
internal void set_InternalDefaultWebProxy(IWebProxy value)
public IWebProxy get_DefaultWebProxy()
public void set_DefaultWebProxy(IWebProxy value)
public IWebProxy GetSystemWebProxy()
internal IWebProxy InternalGetSystemWebProxy()
internal void SetupCacheProtocol(Uri uri)
private Task`1<Stream> <GetRequestStreamAsync>b__78_0()
private Task`1<WebResponse> <GetResponseAsync>b__79_0()
}
internal System.Net.WebRequestPrefixElement : object {
public string Prefix
internal IWebRequestCreate creator
internal Type creatorType
public IWebRequestCreate Creator
public IWebRequestCreate get_Creator()
public void set_Creator(IWebRequestCreate value)
public void .ctor(string P, Type creatorType)
public void .ctor(string P, IWebRequestCreate C)
}
public System.Net.WebResponse : MarshalByRefObject {
private bool m_IsCacheFresh
private bool m_IsFromCache
public bool IsFromCache
internal bool InternalSetFromCache
internal bool IsCacheFresh
internal bool InternalSetIsCacheFresh
public bool IsMutuallyAuthenticated
public long ContentLength
public string ContentType
public Uri ResponseUri
public WebHeaderCollection Headers
public bool SupportsHeaders
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
public bool get_IsFromCache()
internal void set_InternalSetFromCache(bool value)
internal bool get_IsCacheFresh()
internal void set_InternalSetIsCacheFresh(bool value)
public bool get_IsMutuallyAuthenticated()
public long get_ContentLength()
public void set_ContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public Stream GetResponseStream()
public Uri get_ResponseUri()
public WebHeaderCollection get_Headers()
public bool get_SupportsHeaders()
}
public System.Net.WebSockets.ClientWebSocket : WebSocket {
private ClientWebSocketOptions _options
private WebSocketHandle _innerWebSocket
private int _state
public ClientWebSocketOptions Options
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public string SubProtocol
public WebSocketState State
public ClientWebSocketOptions get_Options()
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
public string get_SubProtocol()
public WebSocketState get_State()
public Task ConnectAsync(Uri uri, CancellationToken cancellationToken)
private Task ConnectAsyncCore(Uri uri, CancellationToken cancellationToken)
public Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken)
public Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public void Abort()
public void Dispose()
private void ThrowIfNotConnected()
}
public System.Net.WebSockets.ClientWebSocketOptions : object {
private bool _isReadOnly
private List`1<string> _requestedSubProtocols
private WebHeaderCollection _requestHeaders
private TimeSpan _keepAliveInterval
private bool _useDefaultCredentials
private ICredentials _credentials
private IWebProxy _proxy
private X509CertificateCollection _clientCertificates
private CookieContainer _cookies
private int _receiveBufferSize
private int _sendBufferSize
private Nullable`1<ArraySegment`1<byte>> _buffer
internal WebHeaderCollection RequestHeaders
internal List`1<string> RequestedSubProtocols
public bool UseDefaultCredentials
public ICredentials Credentials
public IWebProxy Proxy
public X509CertificateCollection ClientCertificates
public CookieContainer Cookies
public TimeSpan KeepAliveInterval
internal int ReceiveBufferSize
internal int SendBufferSize
internal Nullable`1<ArraySegment`1<byte>> Buffer
public void SetRequestHeader(string headerName, string headerValue)
internal WebHeaderCollection get_RequestHeaders()
internal List`1<string> get_RequestedSubProtocols()
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public CookieContainer get_Cookies()
public void set_Cookies(CookieContainer value)
public void AddSubProtocol(string subProtocol)
public TimeSpan get_KeepAliveInterval()
public void set_KeepAliveInterval(TimeSpan value)
internal int get_ReceiveBufferSize()
internal int get_SendBufferSize()
internal Nullable`1<ArraySegment`1<byte>> get_Buffer()
public void SetBuffer(int receiveBufferSize, int sendBufferSize)
public void SetBuffer(int receiveBufferSize, int sendBufferSize, ArraySegment`1<byte> buffer)
internal void SetToReadOnly()
private void ThrowIfReadOnly()
}
public System.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
private Uri _requestUri
private NameValueCollection _headers
private CookieCollection _cookieCollection
private IPrincipal _user
private bool _isAuthenticated
private bool _isLocal
private bool _isSecureConnection
private string _origin
private IEnumerable`1<string> _secWebSocketProtocols
private string _secWebSocketVersion
private string _secWebSocketKey
private WebSocket _webSocket
public Uri RequestUri
public NameValueCollection Headers
public string Origin
public IEnumerable`1<string> SecWebSocketProtocols
public string SecWebSocketVersion
public string SecWebSocketKey
public CookieCollection CookieCollection
public IPrincipal User
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public WebSocket WebSocket
internal void .ctor(Uri requestUri, NameValueCollection headers, CookieCollection cookieCollection, IPrincipal user, bool isAuthenticated, bool isLocal, bool isSecureConnection, string origin, IEnumerable`1<string> secWebSocketProtocols, string secWebSocketVersion, string secWebSocketKey, WebSocket webSocket)
public Uri get_RequestUri()
public NameValueCollection get_Headers()
public string get_Origin()
public IEnumerable`1<string> get_SecWebSocketProtocols()
public string get_SecWebSocketVersion()
public string get_SecWebSocketKey()
public CookieCollection get_CookieCollection()
public IPrincipal get_User()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public WebSocket get_WebSocket()
private IPrincipal CopyPrincipal(IPrincipal user)
}
internal System.Net.WebSockets.ManagedWebSocket : WebSocket {
private RandomNumberGenerator s_random
private UTF8Encoding s_textEncoding
private WebSocketState[] s_validSendStates
private WebSocketState[] s_validReceiveStates
private WebSocketState[] s_validCloseOutputStates
private WebSocketState[] s_validCloseStates
private int MaxMessageHeaderLength
private int MaxControlPayloadLength
private int MaskLength
private Stream _stream
private bool _isServer
private string _subprotocol
private Timer _keepAliveTimer
private CancellationTokenSource _abortSource
private Byte[] _receiveBuffer
private bool _receiveBufferFromPool
private Utf8MessageState _utf8TextState
private SemaphoreSlim _sendFrameAsyncLock
private WebSocketState _state
private bool _disposed
private bool _sentCloseFrame
private bool _receivedCloseFrame
private Nullable`1<WebSocketCloseStatus> _closeStatus
private string _closeStatusDescription
private MessageHeader _lastReceiveHeader
private int _receiveBufferOffset
private int _receiveBufferCount
private int _receivedMaskOffsetOffset
private Byte[] _sendBuffer
private bool _lastSendWasFragment
private Task _lastSendAsync
private Task`1<WebSocketReceiveResult> _lastReceiveAsync
private object StateUpdateLock
private object ReceiveAsyncLock
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public WebSocketState State
public string SubProtocol
public ManagedWebSocket CreateFromConnectedStream(Stream stream, bool isServer, string subprotocol, TimeSpan keepAliveInterval, int receiveBufferSize, Nullable`1<ArraySegment`1<byte>> receiveBuffer)
private object get_StateUpdateLock()
private object get_ReceiveAsyncLock()
private void .ctor(Stream stream, bool isServer, string subprotocol, TimeSpan keepAliveInterval, int receiveBufferSize, Nullable`1<ArraySegment`1<byte>> receiveBuffer)
public void Dispose()
private void DisposeCore()
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
public WebSocketState get_State()
public string get_SubProtocol()
public Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken)
public Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public void Abort()
private Task SendFrameAsync(MessageOpcode opcode, bool endOfMessage, ArraySegment`1<byte> payloadBuffer, CancellationToken cancellationToken)
private Task SendFrameLockAcquiredNonCancelableAsync(MessageOpcode opcode, bool endOfMessage, ArraySegment`1<byte> payloadBuffer)
private Task SendFrameFallbackAsync(MessageOpcode opcode, bool endOfMessage, ArraySegment`1<byte> payloadBuffer, CancellationToken cancellationToken)
private int WriteFrameToSendBuffer(MessageOpcode opcode, bool endOfMessage, ArraySegment`1<byte> payloadBuffer)
private void SendKeepAliveFrameAsync()
private int WriteHeader(MessageOpcode opcode, Byte[] sendBuffer, ArraySegment`1<byte> payload, bool endOfMessage, bool useMask)
private void WriteRandomMask(Byte[] buffer, int offset)
private Task`1<WebSocketReceiveResult> ReceiveAsyncPrivate(ArraySegment`1<byte> payloadBuffer, CancellationToken cancellationToken)
private Task`1<WebSocketReceiveResult> HandleReceivedCloseAsync(MessageHeader header, CancellationToken cancellationToken)
private Task HandleReceivedPingPongAsync(MessageHeader header, CancellationToken cancellationToken)
private bool IsValidCloseStatus(WebSocketCloseStatus closeStatus)
private Task CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus closeStatus, WebSocketError error, CancellationToken cancellationToken, Exception innerException)
private bool TryParseMessageHeaderFromReceiveBuffer(MessageHeader& resultHeader)
private Task CloseAsyncPrivate(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
private Task SendCloseFrameAsync(WebSocketCloseStatus closeStatus, string closeStatusDescription, CancellationToken cancellationToken)
private void ConsumeFromBuffer(int count)
private Task EnsureBufferContainsAsync(int minimumRequiredBytes, CancellationToken cancellationToken, bool throwOnPrematureClosure)
private void AllocateSendBuffer(int minLength)
private void ReleaseSendBuffer()
private int CombineMaskBytes(Byte[] buffer, int maskOffset)
private int ApplyMask(Byte[] toMask, int toMaskOffset, Byte[] mask, int maskOffset, int maskOffsetIndex, long count)
private int ApplyMask(Byte[] toMask, int toMaskOffset, int mask, int maskIndex, long count)
private void ThrowIfOperationInProgress(Task operationTask, string methodName)
private Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken)
private bool TryValidateUtf8(ArraySegment`1<byte> arraySegment, bool endOfMessage, Utf8MessageState state)
}
public System.Net.WebSockets.WebSocket : object {
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public string SubProtocol
public WebSocketState State
public TimeSpan DefaultKeepAliveInterval
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
public string get_SubProtocol()
public WebSocketState get_State()
public void Abort()
public Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public void Dispose()
public Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken)
public Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public TimeSpan get_DefaultKeepAliveInterval()
protected void ThrowOnInvalidState(WebSocketState state, WebSocketState[] validStates)
protected bool IsStateTerminal(WebSocketState state)
public ArraySegment`1<byte> CreateClientBuffer(int receiveBufferSize, int sendBufferSize)
public ArraySegment`1<byte> CreateServerBuffer(int receiveBufferSize)
public bool IsApplicationTargeting45()
public void RegisterPrefixes()
public WebSocket CreateClientWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval, bool useZeroMaskingKey, ArraySegment`1<byte> internalBuffer)
}
public System.Net.WebSockets.WebSocketCloseStatus : Enum {
public int value__
public WebSocketCloseStatus NormalClosure
public WebSocketCloseStatus EndpointUnavailable
public WebSocketCloseStatus ProtocolError
public WebSocketCloseStatus InvalidMessageType
public WebSocketCloseStatus Empty
public WebSocketCloseStatus InvalidPayloadData
public WebSocketCloseStatus PolicyViolation
public WebSocketCloseStatus MessageTooBig
public WebSocketCloseStatus MandatoryExtension
public WebSocketCloseStatus InternalServerError
}
public System.Net.WebSockets.WebSocketContext : object {
public Uri RequestUri
public NameValueCollection Headers
public string Origin
public IEnumerable`1<string> SecWebSocketProtocols
public string SecWebSocketVersion
public string SecWebSocketKey
public CookieCollection CookieCollection
public IPrincipal User
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public WebSocket WebSocket
public Uri get_RequestUri()
public NameValueCollection get_Headers()
public string get_Origin()
public IEnumerable`1<string> get_SecWebSocketProtocols()
public string get_SecWebSocketVersion()
public string get_SecWebSocketKey()
public CookieCollection get_CookieCollection()
public IPrincipal get_User()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public WebSocket get_WebSocket()
}
public System.Net.WebSockets.WebSocketError : Enum {
public int value__
public WebSocketError Success
public WebSocketError InvalidMessageType
public WebSocketError Faulted
public WebSocketError NativeError
public WebSocketError NotAWebSocket
public WebSocketError UnsupportedVersion
public WebSocketError UnsupportedProtocol
public WebSocketError HeaderError
public WebSocketError ConnectionClosedPrematurely
public WebSocketError InvalidState
}
public System.Net.WebSockets.WebSocketException : Win32Exception {
private WebSocketError _webSocketErrorCode
public int ErrorCode
public WebSocketError WebSocketErrorCode
public void .ctor(WebSocketError error)
public void .ctor(WebSocketError error, string message)
public void .ctor(WebSocketError error, Exception innerException)
public void .ctor(WebSocketError error, string message, Exception innerException)
public void .ctor(int nativeError)
public void .ctor(int nativeError, string message)
public void .ctor(int nativeError, Exception innerException)
public void .ctor(WebSocketError error, int nativeError)
public void .ctor(WebSocketError error, int nativeError, string message)
public void .ctor(WebSocketError error, int nativeError, Exception innerException)
public void .ctor(WebSocketError error, int nativeError, string message, Exception innerException)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public int get_ErrorCode()
public WebSocketError get_WebSocketErrorCode()
private string GetErrorMessage(WebSocketError error)
private void SetErrorCodeOnError(int nativeError)
private bool Succeeded(int hr)
}
internal System.Net.WebSockets.WebSocketHandle : object {
private StringBuilder t_cachedStringBuilder
private Encoding s_defaultHttpEncoding
private int DefaultReceiveBufferSize
private string WSServerGuid
private CancellationTokenSource _abortSource
private WebSocketState _state
private WebSocket _webSocket
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public WebSocketState State
public string SubProtocol
public WebSocketHandle Create()
public bool IsValid(WebSocketHandle handle)
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
public WebSocketState get_State()
public string get_SubProtocol()
public void CheckPlatformSupport()
public void Dispose()
public void Abort()
public Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken)
public Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task ConnectAsyncCore(Uri uri, CancellationToken cancellationToken, ClientWebSocketOptions options)
private Task`1<Socket> ConnectSocketAsync(string host, int port, CancellationToken cancellationToken)
private Byte[] BuildRequestHeader(Uri uri, ClientWebSocketOptions options, string secKey)
private KeyValuePair`2<string, string> CreateSecKeyAndSecWebSocketAccept()
private Task`1<string> ParseAndValidateConnectResponseAsync(Stream stream, ClientWebSocketOptions options, string expectedSecWebSocketAccept, CancellationToken cancellationToken)
private void ValidateAndTrackHeader(string targetHeaderName, string targetHeaderValue, string foundHeaderName, string foundHeaderValue, Boolean& foundHeader)
private Task`1<string> ReadResponseHeaderLineAsync(Stream stream, CancellationToken cancellationToken)
}
public System.Net.WebSockets.WebSocketMessageType : Enum {
public int value__
public WebSocketMessageType Text
public WebSocketMessageType Binary
public WebSocketMessageType Close
}
public System.Net.WebSockets.WebSocketReceiveResult : object {
private int <Count>k__BackingField
private bool <EndOfMessage>k__BackingField
private WebSocketMessageType <MessageType>k__BackingField
private Nullable`1<WebSocketCloseStatus> <CloseStatus>k__BackingField
private string <CloseStatusDescription>k__BackingField
public int Count
public bool EndOfMessage
public WebSocketMessageType MessageType
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public void .ctor(int count, WebSocketMessageType messageType, bool endOfMessage)
public void .ctor(int count, WebSocketMessageType messageType, bool endOfMessage, Nullable`1<WebSocketCloseStatus> closeStatus, string closeStatusDescription)
public int get_Count()
public bool get_EndOfMessage()
public WebSocketMessageType get_MessageType()
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
}
public System.Net.WebSockets.WebSocketState : Enum {
public int value__
public WebSocketState None
public WebSocketState Connecting
public WebSocketState Open
public WebSocketState CloseSent
public WebSocketState CloseReceived
public WebSocketState Closed
public WebSocketState Aborted
}
internal System.Net.WebSockets.WebSocketValidate : object {
internal int MaxControlFramePayloadLength
private int CloseStatusCodeAbort
private int CloseStatusCodeFailedTLSHandshake
private int InvalidCloseStatusCodesFrom
private int InvalidCloseStatusCodesTo
private string Separators
internal void ThrowIfInvalidState(WebSocketState currentState, bool isDisposed, WebSocketState[] validStates)
internal void ValidateSubprotocol(string subProtocol)
internal void ValidateCloseStatus(WebSocketCloseStatus closeStatus, string statusDescription)
internal void ThrowPlatformNotSupportedException()
internal void ValidateArraySegment(ArraySegment`1<byte> arraySegment, string parameterName)
internal void ValidateBuffer(Byte[] buffer, int offset, int count)
}
public System.Net.WebUtility : object {
private char HIGH_SURROGATE_START
private char LOW_SURROGATE_START
private char LOW_SURROGATE_END
private int UNICODE_PLANE00_END
private int UNICODE_PLANE01_START
private int UNICODE_PLANE16_END
private int UnicodeReplacementChar
private Char[] _htmlEntityEndingChars
private UnicodeDecodingConformance modreq(System.Runtime.CompilerServices.IsVolatile) _htmlDecodeConformance
private UnicodeEncodingConformance modreq(System.Runtime.CompilerServices.IsVolatile) _htmlEncodeConformance
private UnicodeDecodingConformance HtmlDecodeConformance
private UnicodeEncodingConformance HtmlEncodeConformance
public string HtmlEncode(string value)
public void HtmlEncode(string value, TextWriter output)
public string HtmlDecode(string value)
public void HtmlDecode(string value, TextWriter output)
private int IndexOfHtmlEncodingChars(string s, int startPos)
private UnicodeDecodingConformance get_HtmlDecodeConformance()
private UnicodeEncodingConformance get_HtmlEncodeConformance()
private Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue)
private Byte[] UrlEncode(Byte[] bytes, int offset, int count)
public string UrlEncode(string value)
public Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count)
private string UrlDecodeInternal(string value, Encoding encoding)
private Byte[] UrlDecodeInternal(Byte[] bytes, int offset, int count)
public string UrlDecode(string encodedValue)
public Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count)
private void ConvertSmpToUtf16(UInt32 smpChar, Char& leadingSurrogate, Char& trailingSurrogate)
private int GetNextUnicodeScalarValueFromUtf16Surrogate(Char*& pch, Int32& charsRemaining)
private int HexToInt(char h)
private char IntToHex(int n)
private bool IsUrlSafeChar(char ch)
private bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count)
private bool StringRequiresHtmlDecoding(string s)
}
internal System.Net.WindowsInstallationType : Enum {
public int value__
public WindowsInstallationType Unknown
public WindowsInstallationType Client
public WindowsInstallationType Server
public WindowsInstallationType ServerCore
public WindowsInstallationType Embedded
}
internal System.Net.WriteBufferState : Enum {
public int value__
public WriteBufferState Disabled
public WriteBufferState Headers
public WriteBufferState Buffer
public WriteBufferState Playback
}
public System.Net.WriteStreamClosedEventArgs : EventArgs {
public Exception Error
public Exception get_Error()
}
public System.Net.WriteStreamClosedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, WriteStreamClosedEventArgs e)
public IAsyncResult BeginInvoke(object sender, WriteStreamClosedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.ParsingError : Enum {
public int value__
public ParsingError None
public ParsingError BadFormat
public ParsingError BadScheme
public ParsingError BadAuthority
public ParsingError EmptyUriString
public ParsingError LastRelativeUriOkErrIndex
public ParsingError SchemeLimit
public ParsingError SizeLimit
public ParsingError MustRootedPath
public ParsingError BadHostName
public ParsingError NonEmptyHost
public ParsingError BadPort
public ParsingError BadAuthorityTerminator
public ParsingError CannotCreateRelative
}
internal System.Platform : object {
private bool checkedOS
private bool isMacOS
private bool isFreeBSD
public bool IsMacOS
public bool IsFreeBSD
private int uname(IntPtr buf)
private void CheckOS()
public bool get_IsMacOS()
public bool get_IsFreeBSD()
}
public System.Runtime.InteropServices.ComTypes.ADVF : Enum {
public int value__
public ADVF ADVF_NODATA
public ADVF ADVF_PRIMEFIRST
public ADVF ADVF_ONLYONCE
public ADVF ADVFCACHE_NOHANDLER
public ADVF ADVFCACHE_FORCEBUILTIN
public ADVF ADVFCACHE_ONSAVE
public ADVF ADVF_DATAONSTOP
}
public System.Runtime.InteropServices.ComTypes.DATADIR : Enum {
public int value__
public DATADIR DATADIR_GET
public DATADIR DATADIR_SET
}
public System.Runtime.InteropServices.ComTypes.DVASPECT : Enum {
public int value__
public DVASPECT DVASPECT_CONTENT
public DVASPECT DVASPECT_THUMBNAIL
public DVASPECT DVASPECT_ICON
public DVASPECT DVASPECT_DOCPRINT
}
public System.Runtime.InteropServices.ComTypes.FORMATETC : ValueType {
public short cfFormat
public DVASPECT dwAspect
public int lindex
public IntPtr ptd
public TYMED tymed
}
public System.Runtime.InteropServices.ComTypes.IAdviseSink {
public void OnClose()
public void OnDataChange(FORMATETC& format, STGMEDIUM& stgmedium)
public void OnRename(IMoniker moniker)
public void OnSave()
public void OnViewChange(int aspect, int index)
}
public System.Runtime.InteropServices.ComTypes.IDataObject {
public int DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink adviseSink, Int32& connection)
public void DUnadvise(int connection)
public int EnumDAdvise(IEnumSTATDATA& enumAdvise)
public IEnumFORMATETC EnumFormatEtc(DATADIR direction)
public int GetCanonicalFormatEtc(FORMATETC& formatIn, FORMATETC& formatOut)
public void GetData(FORMATETC& format, STGMEDIUM& medium)
public void GetDataHere(FORMATETC& format, STGMEDIUM& medium)
public int QueryGetData(FORMATETC& format)
public void SetData(FORMATETC& formatIn, STGMEDIUM& medium, bool release)
}
public System.Runtime.InteropServices.ComTypes.IEnumFORMATETC {
public void Clone(IEnumFORMATETC& newEnum)
public int Next(int celt, FORMATETC[] rgelt, Int32[] pceltFetched)
public int Reset()
public int Skip(int celt)
}
public System.Runtime.InteropServices.ComTypes.IEnumSTATDATA {
public void Clone(IEnumSTATDATA& newEnum)
public int Next(int celt, STATDATA[] rgelt, Int32[] pceltFetched)
public int Reset()
public int Skip(int celt)
}
public System.Runtime.InteropServices.ComTypes.STATDATA : ValueType {
public ADVF advf
public IAdviseSink advSink
public int connection
public FORMATETC formatetc
}
public System.Runtime.InteropServices.ComTypes.STGMEDIUM : ValueType {
public object pUnkForRelease
public TYMED tymed
public IntPtr unionmember
}
public System.Runtime.InteropServices.ComTypes.TYMED : Enum {
public int value__
public TYMED TYMED_HGLOBAL
public TYMED TYMED_FILE
public TYMED TYMED_ISTREAM
public TYMED TYMED_ISTORAGE
public TYMED TYMED_GDI
public TYMED TYMED_MFPICT
public TYMED TYMED_ENHMF
public TYMED TYMED_NULL
}
public System.Runtime.InteropServices.DefaultParameterValueAttribute : Attribute {
private object value
public object Value
public void .ctor(object value)
public object get_Value()
}
public System.Runtime.InteropServices.HandleCollector : object {
private int deltaPercent
private string name
private int initialThreshold
private int maximumThreshold
private int threshold
private int handleCount
private Int32[] gc_counts
private int gc_gen
public int Count
public int InitialThreshold
public int MaximumThreshold
public string Name
public void .ctor(string name, int initialThreshold)
public void .ctor(string name, int initialThreshold, int maximumThreshold)
public int get_Count()
public int get_InitialThreshold()
public int get_MaximumThreshold()
public string get_Name()
public void Add()
public void Remove()
}
internal System.Runtime.Versioning.BinaryCompatibility : object {
public bool TargetsAtLeast_Desktop_V4_5
}
public System.Runtime.Versioning.FrameworkName : object {
private string m_identifier
private Version m_version
private string m_profile
private string m_fullName
private char c_componentSeparator
private char c_keyValueSeparator
private char c_versionValuePrefix
private string c_versionKey
private string c_profileKey
public string Identifier
public Version Version
public string Profile
public string FullName
public string get_Identifier()
public Version get_Version()
public string get_Profile()
public string get_FullName()
public bool Equals(object obj)
public bool Equals(FrameworkName other)
public int GetHashCode()
public string ToString()
public void .ctor(string identifier, Version version)
public void .ctor(string identifier, Version version, string profile)
public void .ctor(string frameworkName)
public bool op_Equality(FrameworkName left, FrameworkName right)
public bool op_Inequality(FrameworkName left, FrameworkName right)
}
public System.Security.AccessControl.SemaphoreAccessRule : AccessRule {
public SemaphoreRights SemaphoreRights
public void .ctor(IdentityReference identity, SemaphoreRights eventRights, AccessControlType type)
public void .ctor(string identity, SemaphoreRights eventRights, AccessControlType type)
public SemaphoreRights get_SemaphoreRights()
}
public System.Security.AccessControl.SemaphoreAuditRule : AuditRule {
public SemaphoreRights SemaphoreRights
public void .ctor(IdentityReference identity, SemaphoreRights eventRights, AuditFlags flags)
public SemaphoreRights get_SemaphoreRights()
}
public System.Security.AccessControl.SemaphoreRights : Enum {
public int value__
public SemaphoreRights Modify
public SemaphoreRights Delete
public SemaphoreRights ReadPermissions
public SemaphoreRights ChangePermissions
public SemaphoreRights TakeOwnership
public SemaphoreRights Synchronize
public SemaphoreRights FullControl
}
public System.Security.AccessControl.SemaphoreSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public void .ctor(string name, AccessControlSections includeSections)
internal void .ctor(SafeHandle handle, AccessControlSections includeSections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(SemaphoreAccessRule rule)
public bool RemoveAccessRule(SemaphoreAccessRule rule)
public void RemoveAccessRuleAll(SemaphoreAccessRule rule)
public void RemoveAccessRuleSpecific(SemaphoreAccessRule rule)
public void ResetAccessRule(SemaphoreAccessRule rule)
public void SetAccessRule(SemaphoreAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(SemaphoreAuditRule rule)
public bool RemoveAuditRule(SemaphoreAuditRule rule)
public void RemoveAuditRuleAll(SemaphoreAuditRule rule)
public void RemoveAuditRuleSpecific(SemaphoreAuditRule rule)
public void SetAuditRule(SemaphoreAuditRule rule)
internal void Persist(SafeHandle handle)
}
public System.Security.Authentication.AuthenticationException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Security.Authentication.CipherAlgorithmType : Enum {
public int value__
public CipherAlgorithmType None
public CipherAlgorithmType Null
public CipherAlgorithmType Aes
public CipherAlgorithmType Aes128
public CipherAlgorithmType Aes192
public CipherAlgorithmType Aes256
public CipherAlgorithmType Des
public CipherAlgorithmType Rc2
public CipherAlgorithmType Rc4
public CipherAlgorithmType TripleDes
}
public System.Security.Authentication.ExchangeAlgorithmType : Enum {
public int value__
public ExchangeAlgorithmType None
public ExchangeAlgorithmType DiffieHellman
public ExchangeAlgorithmType RsaKeyX
public ExchangeAlgorithmType RsaSign
}
public System.Security.Authentication.ExtendedProtection.ChannelBinding : SafeHandleZeroOrMinusOneIsInvalid {
public int Size
public int get_Size()
protected void .ctor(bool ownsHandle)
}
public System.Security.Authentication.ExtendedProtection.ChannelBindingKind : Enum {
public int value__
public ChannelBindingKind Unknown
public ChannelBindingKind Unique
public ChannelBindingKind Endpoint
}
internal System.Security.Authentication.ExtendedProtection.Configuration.ConfigUtil : object {
internal T GetCustomAttribute(MemberInfo m, bool inherit)
internal ConfigurationProperty BuildProperty(Type t, string name)
}
public System.Security.Authentication.ExtendedProtection.Configuration.ExtendedProtectionPolicyElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty custom_service_names
private ConfigurationProperty policy_enforcement
private ConfigurationProperty protection_scenario
public ServiceNameElementCollection CustomServiceNames
public PolicyEnforcement PolicyEnforcement
public ProtectionScenario ProtectionScenario
protected ConfigurationPropertyCollection Properties
public ServiceNameElementCollection get_CustomServiceNames()
public PolicyEnforcement get_PolicyEnforcement()
public void set_PolicyEnforcement(PolicyEnforcement value)
public ProtectionScenario get_ProtectionScenario()
public void set_ProtectionScenario(ProtectionScenario value)
protected ConfigurationPropertyCollection get_Properties()
public ExtendedProtectionPolicy BuildPolicy()
}
public System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty name
public string Name
protected ConfigurationPropertyCollection Properties
public string get_Name()
public void set_Name(string value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElementCollection : ConfigurationElementCollection {
public ServiceNameElement Item
public ServiceNameElement Item
public ServiceNameElement get_Item(int index)
public ServiceNameElement get_Item(string name)
public void Add(ServiceNameElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(ServiceNameElement element)
public void Remove(string name)
public void Remove(ServiceNameElement element)
public void RemoveAt(int index)
}
public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy : object {
public ChannelBinding CustomChannelBinding
public ServiceNameCollection CustomServiceNames
public bool OSSupportsExtendedProtection
public PolicyEnforcement PolicyEnforcement
public ProtectionScenario ProtectionScenario
public void .ctor(PolicyEnforcement policyEnforcement)
public void .ctor(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding)
public void .ctor(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames)
public void .ctor(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames)
protected void .ctor(SerializationInfo info, StreamingContext context)
public ChannelBinding get_CustomChannelBinding()
public ServiceNameCollection get_CustomServiceNames()
public bool get_OSSupportsExtendedProtection()
public PolicyEnforcement get_PolicyEnforcement()
public ProtectionScenario get_ProtectionScenario()
public string ToString()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicyTypeConverter : TypeConverter {
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.Security.Authentication.ExtendedProtection.PolicyEnforcement : Enum {
public int value__
public PolicyEnforcement Never
public PolicyEnforcement WhenSupported
public PolicyEnforcement Always
}
public System.Security.Authentication.ExtendedProtection.ProtectionScenario : Enum {
public int value__
public ProtectionScenario TransportSelected
public ProtectionScenario TrustedProxy
}
public System.Security.Authentication.ExtendedProtection.ServiceNameCollection : ReadOnlyCollectionBase {
public void .ctor(ICollection items)
public ServiceNameCollection Merge(string serviceName)
public ServiceNameCollection Merge(IEnumerable serviceNames)
private void AddIfNew(ArrayList newServiceNames, string serviceName)
internal bool Contains(string searchServiceName, ICollection serviceNames)
public bool Contains(string searchServiceName)
internal string NormalizeServiceName(string inputServiceName)
internal bool Match(string serviceName1, string serviceName2)
}
public System.Security.Authentication.ExtendedProtection.TokenBinding : object {
private Byte[] _rawTokenBindingId
private TokenBindingType <BindingType>k__BackingField
public TokenBindingType BindingType
internal void .ctor(TokenBindingType bindingType, Byte[] rawData)
public Byte[] GetRawTokenBindingId()
public TokenBindingType get_BindingType()
private void set_BindingType(TokenBindingType value)
}
public System.Security.Authentication.ExtendedProtection.TokenBindingType : Enum {
public int value__
public TokenBindingType Provided
public TokenBindingType Referred
}
public System.Security.Authentication.HashAlgorithmType : Enum {
public int value__
public HashAlgorithmType None
public HashAlgorithmType Md5
public HashAlgorithmType Sha1
}
public System.Security.Authentication.InvalidCredentialException : AuthenticationException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Security.Authentication.SslProtocols : Enum {
public int value__
public SslProtocols None
public SslProtocols Ssl2
public SslProtocols Ssl3
public SslProtocols Tls
public SslProtocols Tls11
public SslProtocols Tls12
public SslProtocols Default
}
internal System.Security.Cryptography.AsnDecodeStatus : Enum {
public int value__
public AsnDecodeStatus NotDecoded
public AsnDecodeStatus Ok
public AsnDecodeStatus BadAsn
public AsnDecodeStatus BadTag
public AsnDecodeStatus BadLength
public AsnDecodeStatus InformationNotAvailable
}
public System.Security.Cryptography.AsnEncodedData : object {
internal Oid _oid
internal Byte[] _raw
public Oid Oid
public Byte[] RawData
public void .ctor(string oid, Byte[] rawData)
public void .ctor(Oid oid, Byte[] rawData)
public void .ctor(AsnEncodedData asnEncodedData)
public void .ctor(Byte[] rawData)
public Oid get_Oid()
public void set_Oid(Oid value)
public Byte[] get_RawData()
public void set_RawData(Byte[] value)
public void CopyFrom(AsnEncodedData asnEncodedData)
public string Format(bool multiLine)
internal string ToString(bool multiLine)
internal string Default(bool multiLine)
internal string BasicConstraintsExtension(bool multiLine)
internal string EnhancedKeyUsageExtension(bool multiLine)
internal string KeyUsageExtension(bool multiLine)
internal string SubjectKeyIdentifierExtension(bool multiLine)
internal string SubjectAltName(bool multiLine)
internal string NetscapeCertType(bool multiLine)
}
public System.Security.Cryptography.AsnEncodedDataCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public AsnEncodedData Item
public object SyncRoot
public void .ctor(AsnEncodedData asnEncodedData)
public int get_Count()
public bool get_IsSynchronized()
public AsnEncodedData get_Item(int index)
public object get_SyncRoot()
public int Add(AsnEncodedData asnEncodedData)
public void CopyTo(AsnEncodedData[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public AsnEncodedDataEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Remove(AsnEncodedData asnEncodedData)
}
public System.Security.Cryptography.AsnEncodedDataEnumerator : object {
private AsnEncodedDataCollection _collection
private int _position
public AsnEncodedData Current
private object System.Collections.IEnumerator.Current
internal void .ctor(AsnEncodedDataCollection collection)
public AsnEncodedData get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
internal System.Security.Cryptography.CAPI : object {
internal UInt32 CRYPT_OID_INFO_OID_KEY
internal UInt32 CRYPT_OID_INFO_NAME_KEY
internal UInt32 CRYPT_OID_INFO_ALGID_KEY
internal UInt32 CRYPT_OID_INFO_SIGN_KEY
public string CryptFindOIDInfoNameFromKey(string key, OidGroup oidGroup)
public string CryptFindOIDInfoKeyFromName(string name, OidGroup oidGroup)
}
public System.Security.Cryptography.Oid : object {
private string m_value
private string m_friendlyName
private OidGroup m_group
public string Value
public string FriendlyName
public void .ctor(string oid)
internal void .ctor(string oid, OidGroup group, bool lookupFriendlyName)
public void .ctor(string value, string friendlyName)
public void .ctor(Oid oid)
private void .ctor(string value, string friendlyName, OidGroup group)
public Oid FromFriendlyName(string friendlyName, OidGroup group)
public Oid FromOidValue(string oidValue, OidGroup group)
public string get_Value()
public void set_Value(string value)
public string get_FriendlyName()
public void set_FriendlyName(string value)
}
public System.Security.Cryptography.OidCollection : object {
private ArrayList m_list
public Oid Item
public Oid Item
public int Count
public bool IsSynchronized
public object SyncRoot
public int Add(Oid oid)
public Oid get_Item(int index)
public Oid get_Item(string oid)
public int get_Count()
public OidEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int index)
public void CopyTo(Oid[] array, int index)
public bool get_IsSynchronized()
public object get_SyncRoot()
}
public System.Security.Cryptography.OidEnumerator : object {
private OidCollection m_oids
private int m_current
public Oid Current
private object System.Collections.IEnumerator.Current
internal void .ctor(OidCollection oids)
public Oid get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.OidGroup : Enum {
public int value__
public OidGroup All
public OidGroup HashAlgorithm
public OidGroup EncryptionAlgorithm
public OidGroup PublicKeyAlgorithm
public OidGroup SignatureAlgorithm
public OidGroup Attribute
public OidGroup ExtensionOrAttribute
public OidGroup EnhancedKeyUsage
public OidGroup Policy
public OidGroup Template
public OidGroup KeyDerivationFunction
}
public System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
public int value__
public OpenFlags ReadOnly
public OpenFlags ReadWrite
public OpenFlags MaxAllowed
public OpenFlags OpenExistingOnly
public OpenFlags IncludeArchived
}
internal System.Security.Cryptography.X509Certificates.OSX509Certificates : object {
public string SecurityLibrary
public string CoreFoundationLibrary
private IntPtr SecCertificateCreateWithData(IntPtr allocator, IntPtr nsdataRef)
private int SecTrustCreateWithCertificates(IntPtr certOrCertArray, IntPtr policies, IntPtr& sectrustref)
private int SecTrustSetAnchorCertificates(IntPtr trust, IntPtr anchorCertificates)
private IntPtr SecPolicyCreateSSL(bool server, IntPtr cfStringHostname)
private int SecTrustEvaluate(IntPtr secTrustRef, SecTrustResult& secTrustResultTime)
private IntPtr CFStringCreateWithCharacters(IntPtr allocator, string str, IntPtr count)
private IntPtr CFDataCreate(IntPtr allocator, Byte* bytes, IntPtr length)
private void CFRetain(IntPtr handle)
private void CFRelease(IntPtr handle)
private IntPtr CFArrayCreate(IntPtr allocator, IntPtr values, IntPtr numValues, IntPtr callbacks)
private IntPtr MakeCFData(Byte[] data)
private IntPtr FromIntPtrs(IntPtr[] values)
private IntPtr GetCertificate(X509Certificate certificate)
public SecTrustResult TrustEvaluateSsl(X509CertificateCollection certificates, X509CertificateCollection anchors, string host)
private SecTrustResult _TrustEvaluateSsl(X509CertificateCollection certificates, X509CertificateCollection anchors, string hostName)
}
public System.Security.Cryptography.X509Certificates.PublicKey : object {
private string rsaOid
private string dsaOid
private AsymmetricAlgorithm _key
private AsnEncodedData _keyValue
private AsnEncodedData _params
private Oid _oid
private Byte[] Empty
public AsnEncodedData EncodedKeyValue
public AsnEncodedData EncodedParameters
public AsymmetricAlgorithm Key
public Oid Oid
public void .ctor(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue)
internal void .ctor(X509Certificate certificate)
public AsnEncodedData get_EncodedKeyValue()
public AsnEncodedData get_EncodedParameters()
public AsymmetricAlgorithm get_Key()
public Oid get_Oid()
private Byte[] GetUnsignedBigInteger(Byte[] integer)
internal DSA DecodeDSA(Byte[] rawPublicKey, Byte[] rawParameters)
internal RSA DecodeRSA(Byte[] rawPublicKey)
}
public System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
public int value__
public StoreLocation CurrentUser
public StoreLocation LocalMachine
}
public System.Security.Cryptography.X509Certificates.StoreName : Enum {
public int value__
public StoreName AddressBook
public StoreName AuthRoot
public StoreName CertificateAuthority
public StoreName Disallowed
public StoreName My
public StoreName Root
public StoreName TrustedPeople
public StoreName TrustedPublisher
}
public System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
private X500DistinguishedNameFlags AllFlags
private string name
private Byte[] canonEncoding
internal Byte[] CanonicalEncoding
public string Name
public void .ctor(AsnEncodedData encodedDistinguishedName)
public void .ctor(Byte[] encodedDistinguishedName)
public void .ctor(string distinguishedName)
public void .ctor(string distinguishedName, X500DistinguishedNameFlags flag)
public void .ctor(X500DistinguishedName distinguishedName)
internal void .ctor(Byte[] encoded, Byte[] canonEncoding, string name)
internal Byte[] get_CanonicalEncoding()
public string get_Name()
public string Decode(X500DistinguishedNameFlags flag)
public string Format(bool multiLine)
private string GetSeparator(X500DistinguishedNameFlags flag)
private void DecodeRawData()
private string Canonize(string s)
internal bool AreEqual(X500DistinguishedName name1, X500DistinguishedName name2)
}
public System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
public int value__
public X500DistinguishedNameFlags None
public X500DistinguishedNameFlags Reversed
public X500DistinguishedNameFlags UseSemicolons
public X500DistinguishedNameFlags DoNotUsePlusSign
public X500DistinguishedNameFlags DoNotUseQuotes
public X500DistinguishedNameFlags UseCommas
public X500DistinguishedNameFlags UseNewLines
public X500DistinguishedNameFlags UseUTF8Encoding
public X500DistinguishedNameFlags UseT61Encoding
public X500DistinguishedNameFlags ForceUTF8Encoding
}
public System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
internal string oid
internal string friendlyName
private bool _certificateAuthority
private bool _hasPathLengthConstraint
private int _pathLengthConstraint
private AsnDecodeStatus _status
public bool CertificateAuthority
public bool HasPathLengthConstraint
public int PathLengthConstraint
public void .ctor(AsnEncodedData encodedBasicConstraints, bool critical)
public void .ctor(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical)
public bool get_CertificateAuthority()
public bool get_HasPathLengthConstraint()
public int get_PathLengthConstraint()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
private string friendlyName
private Byte[] signedData
internal X509Certificate2Impl Impl
public bool Archived
public X509ExtensionCollection Extensions
public string FriendlyName
public bool HasPrivateKey
public X500DistinguishedName IssuerName
public DateTime NotAfter
public DateTime NotBefore
public AsymmetricAlgorithm PrivateKey
public PublicKey PublicKey
public Byte[] RawData
public string SerialNumber
public Oid SignatureAlgorithm
public X500DistinguishedName SubjectName
public string Thumbprint
public int Version
internal X509Certificate MonoCertificate
internal X509Certificate2Impl get_Impl()
public void .ctor(Byte[] rawData)
public void .ctor(Byte[] rawData, string password)
public void .ctor(Byte[] rawData, SecureString password)
public void .ctor(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(string fileName)
public void .ctor(string fileName, string password)
public void .ctor(string fileName, SecureString password)
public void .ctor(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(IntPtr handle)
public void .ctor(X509Certificate certificate)
protected void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(X509Certificate2Impl impl)
public bool get_Archived()
public void set_Archived(bool value)
public X509ExtensionCollection get_Extensions()
public string get_FriendlyName()
public void set_FriendlyName(string value)
public bool get_HasPrivateKey()
public X500DistinguishedName get_IssuerName()
public DateTime get_NotAfter()
public DateTime get_NotBefore()
public AsymmetricAlgorithm get_PrivateKey()
public void set_PrivateKey(AsymmetricAlgorithm value)
public PublicKey get_PublicKey()
public Byte[] get_RawData()
public string get_SerialNumber()
public Oid get_SignatureAlgorithm()
public X500DistinguishedName get_SubjectName()
public string get_Thumbprint()
public int get_Version()
public string GetNameInfo(X509NameType nameType, bool forIssuer)
public void Import(Byte[] rawData)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName)
public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
public Byte[] Export(X509ContentType contentType, string password)
public void Reset()
public string ToString()
public string ToString(bool verbose)
private void AppendBuffer(StringBuilder sb, Byte[] buffer)
public bool Verify()
public X509ContentType GetCertContentType(Byte[] rawData)
public X509ContentType GetCertContentType(string fileName)
internal X509Certificate get_MonoCertificate()
}
public System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
private String[] newline_split
public X509Certificate2 Item
public void .ctor(X509Certificate2Collection certificates)
public void .ctor(X509Certificate2 certificate)
public void .ctor(X509Certificate2[] certificates)
public X509Certificate2 get_Item(int index)
public void set_Item(int index, X509Certificate2 value)
public int Add(X509Certificate2 certificate)
public void AddRange(X509Certificate2[] certificates)
public void AddRange(X509Certificate2Collection certificates)
public bool Contains(X509Certificate2 certificate)
public Byte[] Export(X509ContentType contentType)
public Byte[] Export(X509ContentType contentType, string password)
public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly)
public X509Certificate2Enumerator GetEnumerator()
public void Import(Byte[] rawData)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName)
public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void Insert(int index, X509Certificate2 certificate)
public void Remove(X509Certificate2 certificate)
public void RemoveRange(X509Certificate2[] certificates)
public void RemoveRange(X509Certificate2Collection certificates)
}
public System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
private IEnumerator enumerator
public X509Certificate2 Current
private object System.Collections.IEnumerator.Current
internal void .ctor(X509Certificate2Collection collection)
public X509Certificate2 get_Current()
public bool MoveNext()
public void Reset()
private object System.Collections.IEnumerator.get_Current()
private bool System.Collections.IEnumerator.MoveNext()
private void System.Collections.IEnumerator.Reset()
}
internal System.Security.Cryptography.X509Certificates.X509Certificate2Impl : X509CertificateImpl {
public bool Archived
public X509ExtensionCollection Extensions
public bool HasPrivateKey
public X500DistinguishedName IssuerName
public AsymmetricAlgorithm PrivateKey
public PublicKey PublicKey
public Oid SignatureAlgorithm
public X500DistinguishedName SubjectName
public int Version
internal X509CertificateImplCollection IntermediateCertificates
internal X509Certificate2Impl FallbackImpl
public bool get_Archived()
public void set_Archived(bool value)
public X509ExtensionCollection get_Extensions()
public bool get_HasPrivateKey()
public X500DistinguishedName get_IssuerName()
public AsymmetricAlgorithm get_PrivateKey()
public void set_PrivateKey(AsymmetricAlgorithm value)
public PublicKey get_PublicKey()
public Oid get_SignatureAlgorithm()
public X500DistinguishedName get_SubjectName()
public int get_Version()
internal X509CertificateImplCollection get_IntermediateCertificates()
internal X509Certificate2Impl get_FallbackImpl()
public string GetNameInfo(X509NameType nameType, bool forIssuer)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public Byte[] Export(X509ContentType contentType, string password)
public bool Verify(X509Certificate2 thisCertificate)
public void Reset()
}
internal System.Security.Cryptography.X509Certificates.X509Certificate2ImplMono : X509Certificate2Impl {
private bool _archived
private X509ExtensionCollection _extensions
private PublicKey _publicKey
private X500DistinguishedName issuer_name
private X500DistinguishedName subject_name
private Oid signature_algorithm
private X509CertificateImplCollection intermediateCerts
private X509Certificate _cert
private string empty_error
private Byte[] commonName
private Byte[] email
private Byte[] signedData
public bool IsValid
public IntPtr Handle
public bool Archived
public X509ExtensionCollection Extensions
public bool HasPrivateKey
public X500DistinguishedName IssuerName
public AsymmetricAlgorithm PrivateKey
public PublicKey PublicKey
public Oid SignatureAlgorithm
public X500DistinguishedName SubjectName
public int Version
internal X509CertificateImplCollection IntermediateCertificates
internal X509Certificate MonoCertificate
internal X509Certificate2Impl FallbackImpl
public bool get_IsValid()
public IntPtr get_Handle()
public IntPtr GetNativeAppleCertificate()
private void .ctor(X509Certificate cert)
private void .ctor(X509Certificate2ImplMono other)
public X509CertificateImpl Clone()
public string GetIssuerName(bool legacyV1Mode)
public string GetSubjectName(bool legacyV1Mode)
public Byte[] GetRawCertData()
protected Byte[] GetCertHash(bool lazy)
public DateTime GetValidFrom()
public DateTime GetValidUntil()
public bool Equals(X509CertificateImpl other, Boolean& result)
public string GetKeyAlgorithm()
public Byte[] GetKeyAlgorithmParameters()
public Byte[] GetPublicKey()
public Byte[] GetSerialNumber()
public Byte[] Export(X509ContentType contentType, Byte[] password)
public bool get_Archived()
public void set_Archived(bool value)
public X509ExtensionCollection get_Extensions()
public bool get_HasPrivateKey()
public X500DistinguishedName get_IssuerName()
public AsymmetricAlgorithm get_PrivateKey()
public void set_PrivateKey(AsymmetricAlgorithm value)
public PublicKey get_PublicKey()
public Oid get_SignatureAlgorithm()
public X500DistinguishedName get_SubjectName()
public int get_Version()
public string GetNameInfo(X509NameType nameType, bool forIssuer)
private ASN1 Find(Byte[] oid, ASN1 dn)
private string GetValueAsString(ASN1 pair)
private X509Certificate ImportPkcs12(Byte[] rawData, string password)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public Byte[] Export(X509ContentType contentType, string password)
private Byte[] ExportPkcs12(string password)
public void Reset()
public string ToString()
public string ToString(bool verbose)
private void AppendBuffer(StringBuilder sb, Byte[] buffer)
public bool Verify(X509Certificate2 thisCertificate)
public X509ContentType GetCertContentType(Byte[] rawData)
public X509ContentType GetCertContentType(string fileName)
internal X509CertificateImplCollection get_IntermediateCertificates()
internal X509Certificate get_MonoCertificate()
internal X509Certificate2Impl get_FallbackImpl()
}
public System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
public X509Certificate Item
public void .ctor(X509Certificate[] value)
public void .ctor(X509CertificateCollection value)
public X509Certificate get_Item(int index)
public void set_Item(int index, X509Certificate value)
public int Add(X509Certificate value)
public void AddRange(X509Certificate[] value)
public void AddRange(X509CertificateCollection value)
public bool Contains(X509Certificate value)
public void CopyTo(X509Certificate[] array, int index)
public X509CertificateEnumerator GetEnumerator()
public int GetHashCode()
public int IndexOf(X509Certificate value)
public void Insert(int index, X509Certificate value)
public void Remove(X509Certificate value)
private bool Compare(Byte[] array1, Byte[] array2)
}
internal System.Security.Cryptography.X509Certificates.X509CertificateImplCollection : object {
private List`1<X509CertificateImpl> list
public int Count
public X509CertificateImpl Item
private void .ctor(X509CertificateImplCollection other)
public int get_Count()
public X509CertificateImpl get_Item(int index)
public void Add(X509CertificateImpl impl, bool takeOwnership)
public X509CertificateImplCollection Clone()
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
public System.Security.Cryptography.X509Certificates.X509Chain : object {
private X509ChainImpl impl
internal X509ChainImpl Impl
internal bool IsValid
public IntPtr ChainContext
public X509ChainElementCollection ChainElements
public X509ChainPolicy ChainPolicy
public X509ChainStatus[] ChainStatus
public SafeX509ChainHandle SafeHandle
internal X509ChainImpl get_Impl()
internal bool get_IsValid()
internal void ThrowIfContextInvalid()
public void .ctor(bool useMachineContext)
internal void .ctor(X509ChainImpl impl)
public void .ctor(IntPtr chainContext)
public IntPtr get_ChainContext()
public X509ChainElementCollection get_ChainElements()
public X509ChainPolicy get_ChainPolicy()
public void set_ChainPolicy(X509ChainPolicy value)
public X509ChainStatus[] get_ChainStatus()
public SafeX509ChainHandle get_SafeHandle()
public bool Build(X509Certificate2 certificate)
public void Reset()
public X509Chain Create()
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
public System.Security.Cryptography.X509Certificates.X509ChainElement : object {
private X509Certificate2 certificate
private X509ChainStatus[] status
private string info
private X509ChainStatusFlags compressed_status_flags
public X509Certificate2 Certificate
public X509ChainStatus[] ChainElementStatus
public string Information
internal X509ChainStatusFlags StatusFlags
internal void .ctor(X509Certificate2 certificate)
public X509Certificate2 get_Certificate()
public X509ChainStatus[] get_ChainElementStatus()
public string get_Information()
internal X509ChainStatusFlags get_StatusFlags()
internal void set_StatusFlags(X509ChainStatusFlags value)
private int Count(X509ChainStatusFlags flags)
private void Set(X509ChainStatus[] status, Int32& position, X509ChainStatusFlags flags, X509ChainStatusFlags mask)
internal void UncompressFlags()
}
public System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public X509ChainElement Item
public object SyncRoot
public int get_Count()
public bool get_IsSynchronized()
public X509ChainElement get_Item(int index)
public object get_SyncRoot()
public void CopyTo(X509ChainElement[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public X509ChainElementEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
internal void Add(X509Certificate2 certificate)
internal void Clear()
internal bool Contains(X509Certificate2 certificate)
}
public System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
private IEnumerator enumerator
public X509ChainElement Current
private object System.Collections.IEnumerator.Current
internal void .ctor(IEnumerable enumerable)
public X509ChainElement get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
internal System.Security.Cryptography.X509Certificates.X509ChainImpl : object {
public bool IsValid
public IntPtr Handle
public X509ChainElementCollection ChainElements
public X509ChainPolicy ChainPolicy
public X509ChainStatus[] ChainStatus
public bool get_IsValid()
public IntPtr get_Handle()
protected void ThrowIfContextInvalid()
public X509ChainElementCollection get_ChainElements()
public X509ChainPolicy get_ChainPolicy()
public void set_ChainPolicy(X509ChainPolicy value)
public X509ChainStatus[] get_ChainStatus()
public bool Build(X509Certificate2 certificate)
public void Reset()
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
internal System.Security.Cryptography.X509Certificates.X509ChainImplMono : X509ChainImpl {
private StoreLocation location
private X509ChainElementCollection elements
private X509ChainPolicy policy
private X509ChainStatus[] status
private X509ChainStatus[] Empty
private int max_path_length
private X500DistinguishedName working_issuer_name
private AsymmetricAlgorithm working_public_key
private X509ChainElement bce_restriction
private X509Certificate2Collection roots
private X509Certificate2Collection cas
private X509Store root_store
private X509Store ca_store
private X509Store user_root_store
private X509Store user_ca_store
private X509Certificate2Collection collection
public bool IsValid
public IntPtr Handle
public X509ChainElementCollection ChainElements
public X509ChainPolicy ChainPolicy
public X509ChainStatus[] ChainStatus
private X509Certificate2Collection Roots
private X509Certificate2Collection CertificateAuthorities
private X509Store LMRootStore
private X509Store UserRootStore
private X509Store LMCAStore
private X509Store UserCAStore
private X509Certificate2Collection CertificateCollection
public void .ctor(bool useMachineContext)
public void .ctor(IntPtr chainContext)
public bool get_IsValid()
public IntPtr get_Handle()
public X509ChainElementCollection get_ChainElements()
public X509ChainPolicy get_ChainPolicy()
public void set_ChainPolicy(X509ChainPolicy value)
public X509ChainStatus[] get_ChainStatus()
public bool Build(X509Certificate2 certificate)
public void Reset()
private X509Certificate2Collection get_Roots()
private X509Certificate2Collection get_CertificateAuthorities()
private X509Store get_LMRootStore()
private X509Store get_UserRootStore()
private X509Store get_LMCAStore()
private X509Store get_UserCAStore()
private X509Certificate2Collection get_CertificateCollection()
private X509ChainStatusFlags BuildChainFrom(X509Certificate2 certificate)
private X509Certificate2 SelectBestFromCollection(X509Certificate2 child, X509Certificate2Collection c)
private X509Certificate2 FindParent(X509Certificate2 certificate)
private bool IsChainComplete(X509Certificate2 certificate)
private bool IsSelfIssued(X509Certificate2 certificate)
private void ValidateChain(X509ChainStatusFlags flag)
private void Process(int n)
private void PrepareForNextCertificate(int n)
private void WrapUp()
private void ProcessCertificateExtensions(X509ChainElement element)
private bool IsSignedWith(X509Certificate2 signed, AsymmetricAlgorithm pubkey)
private string GetSubjectKeyIdentifier(X509Certificate2 certificate)
private string GetAuthorityKeyIdentifier(X509Certificate2 certificate)
private string GetAuthorityKeyIdentifier(X509Crl crl)
private string GetAuthorityKeyIdentifier(X509Extension ext)
private void CheckRevocationOnChain(X509ChainStatusFlags flag)
private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, int ca, bool online)
private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, X509Certificate2 ca_cert, bool online)
private X509Crl CheckCrls(string subject, string ski, X509Store store)
private X509Crl FindCrl(X509Certificate2 caCertificate)
private bool ProcessCrlExtensions(X509Crl crl)
private bool ProcessCrlEntryExtensions(X509CrlEntry entry)
}
public System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
private OidCollection apps
private OidCollection cert
private X509CertificateCollection store
private X509Certificate2Collection store2
private X509RevocationFlag rflag
private X509RevocationMode mode
private TimeSpan timeout
private X509VerificationFlags vflags
private DateTime vtime
public OidCollection ApplicationPolicy
public OidCollection CertificatePolicy
public X509Certificate2Collection ExtraStore
public X509RevocationFlag RevocationFlag
public X509RevocationMode RevocationMode
public TimeSpan UrlRetrievalTimeout
public X509VerificationFlags VerificationFlags
public DateTime VerificationTime
internal void .ctor(X509CertificateCollection store)
public OidCollection get_ApplicationPolicy()
public OidCollection get_CertificatePolicy()
public X509Certificate2Collection get_ExtraStore()
internal void set_ExtraStore(X509Certificate2Collection value)
public X509RevocationFlag get_RevocationFlag()
public void set_RevocationFlag(X509RevocationFlag value)
public X509RevocationMode get_RevocationMode()
public void set_RevocationMode(X509RevocationMode value)
public TimeSpan get_UrlRetrievalTimeout()
public void set_UrlRetrievalTimeout(TimeSpan value)
public X509VerificationFlags get_VerificationFlags()
public void set_VerificationFlags(X509VerificationFlags value)
public DateTime get_VerificationTime()
public void set_VerificationTime(DateTime value)
public void Reset()
}
public System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
private X509ChainStatusFlags status
private string info
public X509ChainStatusFlags Status
public string StatusInformation
internal void .ctor(X509ChainStatusFlags flag)
public X509ChainStatusFlags get_Status()
public void set_Status(X509ChainStatusFlags value)
public string get_StatusInformation()
public void set_StatusInformation(string value)
internal string GetInformation(X509ChainStatusFlags flags)
}
public System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
public int value__
public X509ChainStatusFlags NoError
public X509ChainStatusFlags NotTimeValid
public X509ChainStatusFlags NotTimeNested
public X509ChainStatusFlags Revoked
public X509ChainStatusFlags NotSignatureValid
public X509ChainStatusFlags NotValidForUsage
public X509ChainStatusFlags UntrustedRoot
public X509ChainStatusFlags RevocationStatusUnknown
public X509ChainStatusFlags Cyclic
public X509ChainStatusFlags InvalidExtension
public X509ChainStatusFlags InvalidPolicyConstraints
public X509ChainStatusFlags InvalidBasicConstraints
public X509ChainStatusFlags InvalidNameConstraints
public X509ChainStatusFlags HasNotSupportedNameConstraint
public X509ChainStatusFlags HasNotDefinedNameConstraint
public X509ChainStatusFlags HasNotPermittedNameConstraint
public X509ChainStatusFlags HasExcludedNameConstraint
public X509ChainStatusFlags PartialChain
public X509ChainStatusFlags CtlNotTimeValid
public X509ChainStatusFlags CtlNotSignatureValid
public X509ChainStatusFlags CtlNotValidForUsage
public X509ChainStatusFlags OfflineRevocation
public X509ChainStatusFlags NoIssuanceChainPolicy
public X509ChainStatusFlags ExplicitDistrust
public X509ChainStatusFlags HasNotSupportedCriticalExtension
public X509ChainStatusFlags HasWeakSignature
}
public System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
internal string oid
internal string friendlyName
private OidCollection _enhKeyUsage
private AsnDecodeStatus _status
public OidCollection EnhancedKeyUsages
public void .ctor(AsnEncodedData encodedEnhancedKeyUsages, bool critical)
public void .ctor(OidCollection enhancedKeyUsages, bool critical)
public OidCollection get_EnhancedKeyUsages()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
private bool _critical
public bool Critical
public void .ctor(AsnEncodedData encodedExtension, bool critical)
public void .ctor(Oid oid, Byte[] rawData, bool critical)
public void .ctor(string oid, Byte[] rawData, bool critical)
public bool get_Critical()
public void set_Critical(bool value)
public void CopyFrom(AsnEncodedData asnEncodedData)
internal string FormatUnkownData(Byte[] data)
}
public System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
private Byte[] Empty
private ArrayList _list
public int Count
public bool IsSynchronized
public object SyncRoot
public X509Extension Item
public X509Extension Item
internal void .ctor(X509Certificate cert)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public X509Extension get_Item(int index)
public X509Extension get_Item(string oid)
public int Add(X509Extension extension)
public void CopyTo(X509Extension[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public X509ExtensionEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
private IEnumerator enumerator
public X509Extension Current
private object System.Collections.IEnumerator.Current
internal void .ctor(ArrayList list)
public X509Extension get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.X509Certificates.X509FindType : Enum {
public int value__
public X509FindType FindByThumbprint
public X509FindType FindBySubjectName
public X509FindType FindBySubjectDistinguishedName
public X509FindType FindByIssuerName
public X509FindType FindByIssuerDistinguishedName
public X509FindType FindBySerialNumber
public X509FindType FindByTimeValid
public X509FindType FindByTimeNotYetValid
public X509FindType FindByTimeExpired
public X509FindType FindByTemplateName
public X509FindType FindByApplicationPolicy
public X509FindType FindByCertificatePolicy
public X509FindType FindByExtension
public X509FindType FindByKeyUsage
public X509FindType FindBySubjectKeyIdentifier
}
internal System.Security.Cryptography.X509Certificates.X509Helper2 : object {
internal long GetSubjectNameHash(X509Certificate certificate)
internal long GetSubjectNameHash(X509CertificateImpl impl)
internal void ExportAsPEM(X509Certificate certificate, Stream stream, bool includeHumanReadableForm)
internal void ExportAsPEM(X509CertificateImpl impl, Stream stream, bool includeHumanReadableForm)
internal void Initialize()
internal void ThrowIfContextInvalid(X509CertificateImpl impl)
private X509Certificate GetNativeInstance(X509CertificateImpl impl)
internal X509Certificate2Impl Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags, bool disableProvider)
internal X509Certificate2Impl Import(X509Certificate cert, bool disableProvider)
internal X509Certificate GetMonoCertificate(X509Certificate2 certificate)
internal X509ChainImpl CreateChainImpl(bool useMachineContext)
public bool IsValid(X509ChainImpl impl)
internal void ThrowIfContextInvalid(X509ChainImpl impl)
internal Exception GetInvalidChainContextException()
}
public System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
public int value__
public X509IncludeOption None
public X509IncludeOption ExcludeRoot
public X509IncludeOption EndCertOnly
public X509IncludeOption WholeChain
}
public System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
internal string oid
internal string friendlyName
internal X509KeyUsageFlags all
private X509KeyUsageFlags _keyUsages
private AsnDecodeStatus _status
public X509KeyUsageFlags KeyUsages
public void .ctor(AsnEncodedData encodedKeyUsage, bool critical)
public void .ctor(X509KeyUsageFlags keyUsages, bool critical)
public X509KeyUsageFlags get_KeyUsages()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal X509KeyUsageFlags GetValidFlags(X509KeyUsageFlags flags)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
public int value__
public X509KeyUsageFlags None
public X509KeyUsageFlags EncipherOnly
public X509KeyUsageFlags CrlSign
public X509KeyUsageFlags KeyCertSign
public X509KeyUsageFlags KeyAgreement
public X509KeyUsageFlags DataEncipherment
public X509KeyUsageFlags KeyEncipherment
public X509KeyUsageFlags NonRepudiation
public X509KeyUsageFlags DigitalSignature
public X509KeyUsageFlags DecipherOnly
}
public System.Security.Cryptography.X509Certificates.X509NameType : Enum {
public int value__
public X509NameType SimpleName
public X509NameType EmailName
public X509NameType UpnName
public X509NameType DnsName
public X509NameType DnsFromAlternativeName
public X509NameType UrlName
}
public System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
public int value__
public X509RevocationFlag EndCertificateOnly
public X509RevocationFlag EntireChain
public X509RevocationFlag ExcludeRoot
}
public System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
public int value__
public X509RevocationMode NoCheck
public X509RevocationMode Online
public X509RevocationMode Offline
}
public System.Security.Cryptography.X509Certificates.X509Store : object {
private string _name
private StoreLocation _location
private X509Certificate2Collection list
private OpenFlags _flags
private X509Store store
public X509Certificate2Collection Certificates
public StoreLocation Location
public string Name
private X509Stores Factory
private bool IsOpen
private bool IsReadOnly
internal X509Store Store
public IntPtr StoreHandle
public void .ctor(string storeName)
public void .ctor(StoreName storeName)
public void .ctor(StoreLocation storeLocation)
public void .ctor(StoreName storeName, StoreLocation storeLocation)
public void .ctor(IntPtr storeHandle)
public void .ctor(string storeName, StoreLocation storeLocation)
public X509Certificate2Collection get_Certificates()
public StoreLocation get_Location()
public string get_Name()
private X509Stores get_Factory()
private bool get_IsOpen()
private bool get_IsReadOnly()
internal X509Store get_Store()
public IntPtr get_StoreHandle()
public void Add(X509Certificate2 certificate)
public void AddRange(X509Certificate2Collection certificates)
public void Close()
public void Dispose()
public void Open(OpenFlags flags)
public void Remove(X509Certificate2 certificate)
public void RemoveRange(X509Certificate2Collection certificates)
private bool Exists(X509Certificate2 certificate)
}
public System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
internal string oid
internal string friendlyName
private Byte[] _subjectKeyIdentifier
private string _ski
private AsnDecodeStatus _status
public string SubjectKeyIdentifier
public void .ctor(AsnEncodedData encodedSubjectKeyIdentifier, bool critical)
public void .ctor(Byte[] subjectKeyIdentifier, bool critical)
public void .ctor(string subjectKeyIdentifier, bool critical)
public void .ctor(PublicKey key, bool critical)
public void .ctor(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical)
public string get_SubjectKeyIdentifier()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal byte FromHexChar(char c)
internal byte FromHexChars(char c1, char c2)
internal Byte[] FromHex(string hex)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
public int value__
public X509SubjectKeyIdentifierHashAlgorithm Sha1
public X509SubjectKeyIdentifierHashAlgorithm ShortSha1
public X509SubjectKeyIdentifierHashAlgorithm CapiSha1
}
internal System.Security.Cryptography.X509Certificates.X509Utils : object {
internal string FindOidInfo(UInt32 keyType, string keyValue, OidGroup oidGroup)
internal string FindOidInfoWithFallback(UInt32 key, string value, OidGroup group)
}
public System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
public int value__
public X509VerificationFlags NoFlag
public X509VerificationFlags IgnoreNotTimeValid
public X509VerificationFlags IgnoreCtlNotTimeValid
public X509VerificationFlags IgnoreNotTimeNested
public X509VerificationFlags IgnoreInvalidBasicConstraints
public X509VerificationFlags AllowUnknownCertificateAuthority
public X509VerificationFlags IgnoreWrongUsage
public X509VerificationFlags IgnoreInvalidName
public X509VerificationFlags IgnoreInvalidPolicy
public X509VerificationFlags IgnoreEndRevocationUnknown
public X509VerificationFlags IgnoreCtlSignerRevocationUnknown
public X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown
public X509VerificationFlags IgnoreRootRevocationUnknown
public X509VerificationFlags AllFlags
}
internal System.Security.Permissions.PermissionHelper : object {
internal SecurityElement Element(Type type, int version)
internal PermissionState CheckPermissionState(PermissionState state, bool allowUnrestricted)
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
internal bool IsUnrestricted(SecurityElement se)
internal void ThrowInvalidPermission(IPermission target, Type expected)
}
public System.Security.Permissions.ResourcePermissionBase : CodeAccessPermission {
private int version
private ArrayList _list
private bool _unrestricted
private Type _type
private String[] _tags
public string Any
public string Local
private Char[] invalidChars
protected Type PermissionAccessType
protected String[] TagNames
protected void .ctor(PermissionState state)
protected Type get_PermissionAccessType()
protected void set_PermissionAccessType(Type value)
protected String[] get_TagNames()
protected void set_TagNames(String[] value)
protected void AddPermissionAccess(ResourcePermissionBaseEntry entry)
protected void Clear()
public IPermission Copy()
public void FromXml(SecurityElement securityElement)
protected ResourcePermissionBaseEntry[] GetPermissionEntries()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
protected void RemovePermissionAccess(ResourcePermissionBaseEntry entry)
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private bool IsEmpty()
private ResourcePermissionBase Cast(IPermission target)
internal void CheckEntry(ResourcePermissionBaseEntry entry)
internal bool Equals(ResourcePermissionBaseEntry entry1, ResourcePermissionBaseEntry entry2)
internal bool Exists(ResourcePermissionBaseEntry entry)
internal void ValidateMachineName(string name)
internal ResourcePermissionBase CreateFromType(Type type, bool unrestricted)
}
public System.Security.Permissions.ResourcePermissionBaseEntry : object {
private int permissionAccess
private String[] permissionAccessPath
public int PermissionAccess
public String[] PermissionAccessPath
public void .ctor(int permissionAccess, String[] permissionAccessPath)
public int get_PermissionAccess()
public String[] get_PermissionAccessPath()
}
public System.Security.Permissions.StorePermission : CodeAccessPermission {
private int version
private StorePermissionFlags _flags
public StorePermissionFlags Flags
public void .ctor(PermissionState state)
public void .ctor(StorePermissionFlags flag)
public StorePermissionFlags get_Flags()
public void set_Flags(StorePermissionFlags value)
public bool IsUnrestricted()
public IPermission Copy()
public IPermission Intersect(IPermission target)
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
private StorePermission Cast(IPermission target)
}
public System.Security.Permissions.StorePermissionAttribute : CodeAccessSecurityAttribute {
private StorePermissionFlags _flags
public StorePermissionFlags Flags
public bool AddToStore
public bool CreateStore
public bool DeleteStore
public bool EnumerateCertificates
public bool EnumerateStores
public bool OpenStore
public bool RemoveFromStore
public void .ctor(SecurityAction action)
public StorePermissionFlags get_Flags()
public void set_Flags(StorePermissionFlags value)
public bool get_AddToStore()
public void set_AddToStore(bool value)
public bool get_CreateStore()
public void set_CreateStore(bool value)
public bool get_DeleteStore()
public void set_DeleteStore(bool value)
public bool get_EnumerateCertificates()
public void set_EnumerateCertificates(bool value)
public bool get_EnumerateStores()
public void set_EnumerateStores(bool value)
public bool get_OpenStore()
public void set_OpenStore(bool value)
public bool get_RemoveFromStore()
public void set_RemoveFromStore(bool value)
public IPermission CreatePermission()
}
public System.Security.Permissions.StorePermissionFlags : Enum {
public int value__
public StorePermissionFlags NoFlags
public StorePermissionFlags CreateStore
public StorePermissionFlags DeleteStore
public StorePermissionFlags EnumerateStores
public StorePermissionFlags OpenStore
public StorePermissionFlags AddToStore
public StorePermissionFlags RemoveFromStore
public StorePermissionFlags EnumerateCertificates
public StorePermissionFlags AllFlags
}
public System.Security.Permissions.TypeDescriptorPermission : CodeAccessPermission {
private TypeDescriptorPermissionFlags m_flags
public TypeDescriptorPermissionFlags Flags
public void .ctor(PermissionState state)
public void .ctor(TypeDescriptorPermissionFlags flag)
private void SetUnrestricted(bool unrestricted)
private void Reset()
public void set_Flags(TypeDescriptorPermissionFlags value)
public TypeDescriptorPermissionFlags get_Flags()
public bool IsUnrestricted()
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Intersect(IPermission target)
public IPermission Copy()
private void VerifyAccess(TypeDescriptorPermissionFlags type)
public SecurityElement ToXml()
public void FromXml(SecurityElement securityElement)
internal void VerifyFlags(TypeDescriptorPermissionFlags flags)
}
public System.Security.Permissions.TypeDescriptorPermissionFlags : Enum {
public int value__
public TypeDescriptorPermissionFlags NoFlags
public TypeDescriptorPermissionFlags RestrictedRegistrationAccess
}
internal System.SecurityUtils : object {
private ReflectionPermission modreq(System.Runtime.CompilerServices.IsVolatile) memberAccessPermission
private ReflectionPermission modreq(System.Runtime.CompilerServices.IsVolatile) restrictedMemberAccessPermission
private ReflectionPermission MemberAccessPermission
private ReflectionPermission RestrictedMemberAccessPermission
private ReflectionPermission get_MemberAccessPermission()
private ReflectionPermission get_RestrictedMemberAccessPermission()
private void DemandReflectionAccess(Type type)
private void DemandGrantSet(Assembly assembly)
private bool HasReflectionPermission(Type type)
internal object SecureCreateInstance(Type type)
internal object SecureCreateInstance(Type type, Object[] args, bool allowNonPublic)
internal object SecureCreateInstance(Type type, Object[] args)
internal object SecureConstructorInvoke(Type type, Type[] argTypes, Object[] args, bool allowNonPublic)
internal object SecureConstructorInvoke(Type type, Type[] argTypes, Object[] args, bool allowNonPublic, BindingFlags extraFlags)
private bool GenericArgumentsAreVisible(MethodInfo method)
internal object FieldInfoGetValue(FieldInfo field, object target)
internal object MethodInfoInvoke(MethodInfo method, object target, Object[] args)
internal object ConstructorInfoInvoke(ConstructorInfo ctor, Object[] args)
internal object ArrayCreateInstance(Type type, int length)
}
internal System.SRDescriptionAttribute : DescriptionAttribute {
private bool isReplaced
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.StringExtensions : object {
internal string SubstringTrim(string value, int startIndex)
internal string SubstringTrim(string value, int startIndex, int length)
}
internal System.Text.RegularExpressions.CachedCodeEntry : object {
internal string _key
internal RegexCode _code
internal Hashtable _caps
internal Hashtable _capnames
internal String[] _capslist
internal int _capsize
internal RegexRunnerFactory _factory
internal ExclusiveReference _runnerref
internal SharedReference _replref
internal void .ctor(string key, Hashtable capnames, String[] capslist, RegexCode code, Hashtable caps, int capsize, ExclusiveReference runner, SharedReference repl)
internal void AddCompiled(RegexRunnerFactory factory)
}
public System.Text.RegularExpressions.Capture : object {
internal string _text
internal int _index
internal int _length
public int Index
public int Length
public string Value
internal void .ctor(string text, int i, int l)
public int get_Index()
public int get_Length()
public string get_Value()
public string ToString()
internal string GetOriginalString()
internal string GetLeftSubstring()
internal string GetRightSubstring()
}
public System.Text.RegularExpressions.CaptureCollection : object {
internal Group _group
internal int _capcount
internal Capture[] _captures
public object SyncRoot
public bool IsSynchronized
public bool IsReadOnly
public int Count
public Capture Item
internal void .ctor(Group group)
public object get_SyncRoot()
public bool get_IsSynchronized()
public bool get_IsReadOnly()
public int get_Count()
public Capture get_Item(int i)
public void CopyTo(Array array, int arrayIndex)
public IEnumerator GetEnumerator()
internal Capture GetCapture(int i)
}
internal System.Text.RegularExpressions.CaptureEnumerator : object {
internal CaptureCollection _rcc
internal int _curindex
public object Current
public Capture Capture
internal void .ctor(CaptureCollection rcc)
public bool MoveNext()
public object get_Current()
public Capture get_Capture()
public void Reset()
}
internal System.Text.RegularExpressions.CompiledRegexRunner : RegexRunner {
private NoParamDelegate goMethod
private FindFirstCharDelegate findFirstCharMethod
private NoParamDelegate initTrackCountMethod
internal void SetDelegates(NoParamDelegate go, FindFirstCharDelegate firstChar, NoParamDelegate trackCount)
protected void Go()
protected bool FindFirstChar()
protected void InitTrackCount()
}
internal System.Text.RegularExpressions.CompiledRegexRunnerFactory : RegexRunnerFactory {
private DynamicMethod goMethod
private DynamicMethod findFirstCharMethod
private DynamicMethod initTrackCountMethod
internal void .ctor(DynamicMethod go, DynamicMethod firstChar, DynamicMethod trackCount)
protected internal RegexRunner CreateInstance()
}
internal System.Text.RegularExpressions.CreateInstanceDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public RegexRunner Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public RegexRunner EndInvoke(IAsyncResult result)
}
internal System.Text.RegularExpressions.ExclusiveReference : object {
private RegexRunner _ref
private object _obj
private int _locked
internal object Get()
internal void Release(object obj)
}
internal System.Text.RegularExpressions.FindFirstCharDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(RegexRunner r)
public IAsyncResult BeginInvoke(RegexRunner r, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Text.RegularExpressions.Group : Capture {
internal Group _emptygroup
internal Int32[] _caps
internal int _capcount
internal CaptureCollection _capcoll
internal string _name
public bool Success
public string Name
public CaptureCollection Captures
internal void .ctor(string text, Int32[] caps, int capcount, string name)
public bool get_Success()
public string get_Name()
public CaptureCollection get_Captures()
public Group Synchronized(Group inner)
}
public System.Text.RegularExpressions.GroupCollection : object {
internal Match _match
internal Hashtable _captureMap
internal Group[] _groups
public object SyncRoot
public bool IsSynchronized
public bool IsReadOnly
public int Count
public Group Item
public Group Item
internal void .ctor(Match match, Hashtable caps)
public object get_SyncRoot()
public bool get_IsSynchronized()
public bool get_IsReadOnly()
public int get_Count()
public Group get_Item(int groupnum)
public Group get_Item(string groupname)
internal Group GetGroup(int groupnum)
internal Group GetGroupImpl(int groupnum)
public void CopyTo(Array array, int arrayIndex)
public IEnumerator GetEnumerator()
}
internal System.Text.RegularExpressions.GroupEnumerator : object {
internal GroupCollection _rgc
internal int _curindex
public object Current
public Capture Capture
internal void .ctor(GroupCollection rgc)
public bool MoveNext()
public object get_Current()
public Capture get_Capture()
public void Reset()
}
public System.Text.RegularExpressions.Match : Group {
internal Match _empty
internal GroupCollection _groupcoll
internal Regex _regex
internal int _textbeg
internal int _textpos
internal int _textend
internal int _textstart
internal Int32[][] _matches
internal Int32[] _matchcount
internal bool _balancing
public Match Empty
public GroupCollection Groups
public Match get_Empty()
internal void .ctor(Regex regex, int capcount, string text, int begpos, int len, int startpos)
internal void Reset(Regex regex, string text, int textbeg, int textend, int textstart)
public GroupCollection get_Groups()
public Match NextMatch()
public string Result(string replacement)
internal string GroupToStringImpl(int groupnum)
internal string LastGroupToStringImpl()
public Match Synchronized(Match inner)
internal void AddMatch(int cap, int start, int len)
internal void BalanceMatch(int cap)
internal void RemoveMatch(int cap)
internal bool IsMatched(int cap)
internal int MatchIndex(int cap)
internal int MatchLength(int cap)
internal void Tidy(int textpos)
}
public System.Text.RegularExpressions.MatchCollection : object {
internal Regex _regex
internal ArrayList _matches
internal bool _done
internal string _input
internal int _beginning
internal int _length
internal int _startat
internal int _prevlen
private int infinite
public int Count
public object SyncRoot
public bool IsSynchronized
public bool IsReadOnly
public Match Item
internal void .ctor(Regex regex, string input, int beginning, int length, int startat)
internal Match GetMatch(int i)
public int get_Count()
public object get_SyncRoot()
public bool get_IsSynchronized()
public bool get_IsReadOnly()
public Match get_Item(int i)
public void CopyTo(Array array, int arrayIndex)
public IEnumerator GetEnumerator()
}
internal System.Text.RegularExpressions.MatchEnumerator : object {
internal MatchCollection _matchcoll
internal Match _match
internal int _curindex
internal bool _done
public object Current
internal void .ctor(MatchCollection matchcoll)
public bool MoveNext()
public object get_Current()
public void Reset()
}
public System.Text.RegularExpressions.MatchEvaluator : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public string Invoke(Match match)
public IAsyncResult BeginInvoke(Match match, AsyncCallback callback, object object)
public string EndInvoke(IAsyncResult result)
}
internal System.Text.RegularExpressions.MatchSparse : Match {
internal Hashtable _caps
public GroupCollection Groups
internal void .ctor(Regex regex, Hashtable caps, int capcount, string text, int begpos, int len, int startpos)
public GroupCollection get_Groups()
}
internal System.Text.RegularExpressions.NoParamDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(RegexRunner r)
public IAsyncResult BeginInvoke(RegexRunner r, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Text.RegularExpressions.Regex : object {
protected internal string pattern
protected internal RegexRunnerFactory factory
protected internal RegexOptions roptions
private TimeSpan MaximumMatchTimeout
public TimeSpan InfiniteMatchTimeout
protected internal TimeSpan internalMatchTimeout
private string DefaultMatchTimeout_ConfigKeyName
internal TimeSpan FallbackDefaultMatchTimeout
internal TimeSpan DefaultMatchTimeout
protected internal Hashtable caps
protected internal Hashtable capnames
protected internal String[] capslist
protected internal int capsize
internal ExclusiveReference runnerref
internal SharedReference replref
internal RegexCode code
internal bool refsInitialized
internal LinkedList`1<CachedCodeEntry> livecode
internal int cacheSize
internal int MaxOptionShift
public int CacheSize
protected IDictionary Caps
protected IDictionary CapNames
public RegexOptions Options
public TimeSpan MatchTimeout
public bool RightToLeft
public void .ctor(string pattern)
public void .ctor(string pattern, RegexOptions options)
public void .ctor(string pattern, RegexOptions options, TimeSpan matchTimeout)
private void .ctor(string pattern, RegexOptions options, TimeSpan matchTimeout, bool useCache)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
protected internal void ValidateMatchTimeout(TimeSpan matchTimeout)
private TimeSpan InitDefaultMatchTimeout()
internal RegexRunnerFactory Compile(RegexCode code, RegexOptions roptions)
public string Escape(string str)
public string Unescape(string str)
public int get_CacheSize()
public void set_CacheSize(int value)
protected IDictionary get_Caps()
protected void set_Caps(IDictionary value)
protected IDictionary get_CapNames()
protected void set_CapNames(IDictionary value)
public RegexOptions get_Options()
public TimeSpan get_MatchTimeout()
public bool get_RightToLeft()
public string ToString()
public String[] GetGroupNames()
public Int32[] GetGroupNumbers()
public string GroupNameFromNumber(int i)
public int GroupNumberFromName(string name)
public bool IsMatch(string input, string pattern)
public bool IsMatch(string input, string pattern, RegexOptions options)
public bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
public bool IsMatch(string input)
public bool IsMatch(string input, int startat)
public Match Match(string input, string pattern)
public Match Match(string input, string pattern, RegexOptions options)
public Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
public Match Match(string input)
public Match Match(string input, int startat)
public Match Match(string input, int beginning, int length)
public MatchCollection Matches(string input, string pattern)
public MatchCollection Matches(string input, string pattern, RegexOptions options)
public MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
public MatchCollection Matches(string input)
public MatchCollection Matches(string input, int startat)
public string Replace(string input, string pattern, string replacement)
public string Replace(string input, string pattern, string replacement, RegexOptions options)
public string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout)
public string Replace(string input, string replacement)
public string Replace(string input, string replacement, int count)
public string Replace(string input, string replacement, int count, int startat)
public string Replace(string input, string pattern, MatchEvaluator evaluator)
public string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options)
public string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout)
public string Replace(string input, MatchEvaluator evaluator)
public string Replace(string input, MatchEvaluator evaluator, int count)
public string Replace(string input, MatchEvaluator evaluator, int count, int startat)
public String[] Split(string input, string pattern)
public String[] Split(string input, string pattern, RegexOptions options)
public String[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
public String[] Split(string input)
public String[] Split(string input, int count)
public String[] Split(string input, int count, int startat)
public void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname)
public void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes)
public void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile)
private void CompileToAssemblyInternal(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile)
protected void InitializeReferences()
internal Match Run(bool quick, int prevlen, string input, int beginning, int length, int startat)
private CachedCodeEntry LookupCachedAndUpdate(string key)
private CachedCodeEntry CacheCode(string key)
protected bool UseOptionC()
protected bool UseOptionR()
internal bool UseOptionInvariant()
}
internal System.Text.RegularExpressions.RegexBoyerMoore : object {
internal Int32[] _positive
internal Int32[] _negativeASCII
internal Int32[][] _negativeUnicode
internal string _pattern
internal int _lowASCII
internal int _highASCII
internal bool _rightToLeft
internal bool _caseInsensitive
internal CultureInfo _culture
internal int infinite
internal void .ctor(string pattern, bool caseInsensitive, bool rightToLeft, CultureInfo culture)
private bool MatchPattern(string text, int index)
internal bool IsMatch(string text, int index, int beglimit, int endlimit)
internal int Scan(string text, int index, int beglimit, int endlimit)
public string ToString()
}
internal System.Text.RegularExpressions.RegexCharClass : object {
private List`1<SingleRange> _rangelist
private StringBuilder _categories
private bool _canonical
private bool _negate
private RegexCharClass _subtractor
private int FLAGS
private int SETLENGTH
private int CATEGORYLENGTH
private int SETSTART
private char Nullchar
private char Lastchar
private char GroupChar
private short SpaceConst
private short NotSpaceConst
private char ZeroWidthJoiner
private char ZeroWidthNonJoiner
private string InternalRegexIgnoreCase
private string Space
private string NotSpace
private string Word
private string NotWord
internal string SpaceClass
internal string NotSpaceClass
internal string WordClass
internal string NotWordClass
internal string DigitClass
internal string NotDigitClass
private string ECMASpaceSet
private string NotECMASpaceSet
private string ECMAWordSet
private string NotECMAWordSet
private string ECMADigitSet
private string NotECMADigitSet
internal string ECMASpaceClass
internal string NotECMASpaceClass
internal string ECMAWordClass
internal string NotECMAWordClass
internal string ECMADigitClass
internal string NotECMADigitClass
internal string AnyClass
internal string EmptyClass
private Dictionary`2<string, string> _definedCategories
private String[0...,0...] _propTable
private int LowercaseSet
private int LowercaseAdd
private int LowercaseBor
private int LowercaseBad
private LowerCaseMapping[] _lcTable
internal bool CanMerge
internal bool Negate
private void .ctor(bool negate, List`1<SingleRange> ranges, StringBuilder categories, RegexCharClass subtraction)
internal bool get_CanMerge()
internal void set_Negate(bool value)
internal void AddChar(char c)
internal void AddCharClass(RegexCharClass cc)
private void AddSet(string set)
internal void AddSubtraction(RegexCharClass sub)
internal void AddRange(char first, char last)
internal void AddCategoryFromName(string categoryName, bool invert, bool caseInsensitive, string pattern)
private void AddCategory(string category)
internal void AddLowercase(CultureInfo culture)
private void AddLowercaseRange(char chMin, char chMax, CultureInfo culture)
internal void AddWord(bool ecma, bool negate)
internal void AddSpace(bool ecma, bool negate)
internal void AddDigit(bool ecma, bool negate, string pattern)
internal string ConvertOldStringsToClass(string set, string category)
internal char SingletonChar(string set)
internal bool IsMergeable(string charClass)
internal bool IsEmpty(string charClass)
internal bool IsSingleton(string set)
internal bool IsSingletonInverse(string set)
private bool IsSubtraction(string charClass)
internal bool IsNegated(string set)
internal bool IsECMAWordChar(char ch)
internal bool IsWordChar(char ch)
internal bool CharInClass(char ch, string set)
internal bool CharInClassRecursive(char ch, string set, int start)
private bool CharInClassInternal(char ch, string set, int start, int mySetLength, int myCategoryLength)
private bool CharInCategory(char ch, string set, int start, int mySetLength, int myCategoryLength)
private bool CharInCategoryGroup(char ch, UnicodeCategory chcategory, string category, Int32& i)
private string NegateCategory(string category)
internal RegexCharClass Parse(string charClass)
private RegexCharClass ParseRecursive(string charClass, int start)
private int RangeCount()
internal string ToStringClass()
private SingleRange GetRangeAt(int i)
private void Canonicalize()
private string SetFromProperty(string capname, bool invert, string pattern)
}
internal System.Text.RegularExpressions.RegexCode : object {
internal int Onerep
internal int Notonerep
internal int Setrep
internal int Oneloop
internal int Notoneloop
internal int Setloop
internal int Onelazy
internal int Notonelazy
internal int Setlazy
internal int One
internal int Notone
internal int Set
internal int Multi
internal int Ref
internal int Bol
internal int Eol
internal int Boundary
internal int Nonboundary
internal int Beginning
internal int Start
internal int EndZ
internal int End
internal int Nothing
internal int Lazybranch
internal int Branchmark
internal int Lazybranchmark
internal int Nullcount
internal int Setcount
internal int Branchcount
internal int Lazybranchcount
internal int Nullmark
internal int Setmark
internal int Capturemark
internal int Getmark
internal int Setjump
internal int Backjump
internal int Forejump
internal int Testref
internal int Goto
internal int Prune
internal int Stop
internal int ECMABoundary
internal int NonECMABoundary
internal int Mask
internal int Rtl
internal int Back
internal int Back2
internal int Ci
internal Int32[] _codes
internal String[] _strings
internal int _trackcount
internal Hashtable _caps
internal int _capsize
internal RegexPrefix _fcPrefix
internal RegexBoyerMoore _bmPrefix
internal int _anchors
internal bool _rightToLeft
internal void .ctor(Int32[] codes, List`1<string> stringlist, int trackcount, Hashtable caps, int capsize, RegexBoyerMoore bmPrefix, RegexPrefix fcPrefix, int anchors, bool rightToLeft)
internal bool OpcodeBacktracks(int Op)
internal int OpcodeSize(int Opcode)
internal ArgumentException MakeException(string message)
}
public System.Text.RegularExpressions.RegexCompilationInfo : object {
private string pattern
private RegexOptions options
private string name
private string nspace
private bool isPublic
private TimeSpan matchTimeout
public string Pattern
public RegexOptions Options
public string Name
public string Namespace
public bool IsPublic
public TimeSpan MatchTimeout
private void InitMatchTimeoutDefaultForOldVersionDeserialization(StreamingContext unusedContext)
public void .ctor(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic)
public void .ctor(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic, TimeSpan matchTimeout)
public string get_Pattern()
public void set_Pattern(string value)
public RegexOptions get_Options()
public void set_Options(RegexOptions value)
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public TimeSpan get_MatchTimeout()
public void set_MatchTimeout(TimeSpan value)
}
internal System.Text.RegularExpressions.RegexCompiler : object {
internal FieldInfo _textbegF
internal FieldInfo _textendF
internal FieldInfo _textstartF
internal FieldInfo _textposF
internal FieldInfo _textF
internal FieldInfo _trackposF
internal FieldInfo _trackF
internal FieldInfo _stackposF
internal FieldInfo _stackF
internal FieldInfo _trackcountF
internal MethodInfo _ensurestorageM
internal MethodInfo _captureM
internal MethodInfo _transferM
internal MethodInfo _uncaptureM
internal MethodInfo _ismatchedM
internal MethodInfo _matchlengthM
internal MethodInfo _matchindexM
internal MethodInfo _isboundaryM
internal MethodInfo _isECMABoundaryM
internal MethodInfo _chartolowerM
internal MethodInfo _getcharM
internal MethodInfo _crawlposM
internal MethodInfo _charInSetM
internal MethodInfo _getCurrentCulture
internal MethodInfo _getInvariantCulture
internal MethodInfo _checkTimeoutM
internal ILGenerator _ilg
internal LocalBuilder _textstartV
internal LocalBuilder _textbegV
internal LocalBuilder _textendV
internal LocalBuilder _textposV
internal LocalBuilder _textV
internal LocalBuilder _trackposV
internal LocalBuilder _trackV
internal LocalBuilder _stackposV
internal LocalBuilder _stackV
internal LocalBuilder _tempV
internal LocalBuilder _temp2V
internal LocalBuilder _temp3V
internal RegexCode _code
internal Int32[] _codes
internal String[] _strings
internal RegexPrefix _fcPrefix
internal RegexBoyerMoore _bmPrefix
internal int _anchors
internal Label[] _labels
internal BacktrackNote[] _notes
internal int _notecount
internal int _trackcount
internal Label _backtrack
internal int _regexopcode
internal int _codepos
internal int _backpos
internal RegexOptions _options
internal Int32[] _uniquenote
internal Int32[] _goto
internal int stackpop
internal int stackpop2
internal int stackpop3
internal int capback
internal int capback2
internal int branchmarkback2
internal int lazybranchmarkback2
internal int branchcountback2
internal int lazybranchcountback2
internal int forejumpback
internal int uniquecount
private FieldInfo RegexRunnerField(string fieldname)
private MethodInfo RegexRunnerMethod(string methname)
internal RegexRunnerFactory Compile(RegexCode code, RegexOptions options)
internal void CompileToAssembly(RegexCompilationInfo[] regexes, AssemblyName an, CustomAttributeBuilder[] attribs, string resourceFile)
internal int AddBacktrackNote(int flags, Label l, int codepos)
internal int AddTrack()
internal int AddTrack(int flags)
internal int AddGoto(int destpos)
internal int AddUniqueTrack(int i)
internal int AddUniqueTrack(int i, int flags)
internal Label DefineLabel()
internal void MarkLabel(Label l)
internal int Operand(int i)
internal bool IsRtl()
internal bool IsCi()
internal int Code()
internal void Ldstr(string str)
internal void Ldc(int i)
internal void LdcI8(long i)
internal void Dup()
internal void Ret()
internal void Pop()
internal void Add()
internal void Add(bool negate)
internal void Sub()
internal void Sub(bool negate)
internal void Ldloc(LocalBuilder lt)
internal void Stloc(LocalBuilder lt)
internal void Ldthis()
internal void Ldthisfld(FieldInfo ft)
internal void Mvfldloc(FieldInfo ft, LocalBuilder lt)
internal void Mvlocfld(LocalBuilder lt, FieldInfo ft)
internal void Stfld(FieldInfo ft)
internal void Callvirt(MethodInfo mt)
internal void Call(MethodInfo mt)
internal void Newobj(ConstructorInfo ct)
internal void BrfalseFar(Label l)
internal void BrtrueFar(Label l)
internal void BrFar(Label l)
internal void BleFar(Label l)
internal void BltFar(Label l)
internal void BgeFar(Label l)
internal void BgtFar(Label l)
internal void BneFar(Label l)
internal void BeqFar(Label l)
internal void Brfalse(Label l)
internal void Br(Label l)
internal void Ble(Label l)
internal void Blt(Label l)
internal void Bge(Label l)
internal void Bgt(Label l)
internal void Bgtun(Label l)
internal void Bne(Label l)
internal void Beq(Label l)
internal void Ldlen()
internal void Rightchar()
internal void Rightcharnext()
internal void Leftchar()
internal void Leftcharnext()
internal void Track()
internal void Trackagain()
internal void PushTrack(LocalBuilder lt)
internal void TrackUnique(int i)
internal void TrackUnique2(int i)
internal void ReadyPushTrack()
internal void PopTrack()
internal void TopTrack()
internal void PushStack(LocalBuilder lt)
internal void ReadyReplaceStack(int i)
internal void ReadyPushStack()
internal void TopStack()
internal void PopStack()
internal void PopDiscardStack()
internal void PopDiscardStack(int i)
internal void DoReplace()
internal void DoPush()
internal void Back()
internal void Goto(int i)
internal int NextCodepos()
internal Label AdvanceLabel()
internal void Advance()
internal void CallToLower()
internal void GenerateForwardSection()
internal void GenerateMiddleSection()
internal void GenerateBacktrackSection()
internal void GenerateFindFirstChar()
internal void GenerateInitTrackCount()
internal LocalBuilder DeclareInt()
internal LocalBuilder DeclareIntArray()
internal LocalBuilder DeclareString()
internal void GenerateGo()
internal void GenerateOneCode()
}
internal System.Text.RegularExpressions.RegexFC : object {
internal RegexCharClass _cc
internal bool _nullable
internal bool _caseInsensitive
internal void .ctor(bool nullable)
internal void .ctor(char ch, bool not, bool nullable, bool caseInsensitive)
internal void .ctor(string charClass, bool nullable, bool caseInsensitive)
internal bool AddFC(RegexFC fc, bool concatenate)
internal string GetFirstChars(CultureInfo culture)
internal bool IsCaseInsensitive()
}
internal System.Text.RegularExpressions.RegexFCD : object {
private Int32[] _intStack
private int _intDepth
private RegexFC[] _fcStack
private int _fcDepth
private bool _skipAllChildren
private bool _skipchild
private bool _failed
private int BeforeChild
private int AfterChild
internal int Beginning
internal int Bol
internal int Start
internal int Eol
internal int EndZ
internal int End
internal int Boundary
internal int ECMABoundary
internal RegexPrefix FirstChars(RegexTree t)
internal RegexPrefix Prefix(RegexTree tree)
internal int Anchors(RegexTree tree)
private int AnchorFromType(int type)
private void PushInt(int I)
private bool IntIsEmpty()
private int PopInt()
private void PushFC(RegexFC fc)
private bool FCIsEmpty()
private RegexFC PopFC()
private RegexFC TopFC()
private RegexFC RegexFCFromRegexTree(RegexTree tree)
private void SkipChild()
private void CalculateFC(int NodeType, RegexNode node, int CurIndex)
}
internal System.Text.RegularExpressions.RegexInterpreter : RegexRunner {
internal int runoperator
internal Int32[] runcodes
internal int runcodepos
internal String[] runstrings
internal RegexCode runcode
internal RegexPrefix runfcPrefix
internal RegexBoyerMoore runbmPrefix
internal int runanchors
internal bool runrtl
internal bool runci
internal CultureInfo runculture
internal void .ctor(RegexCode code, CultureInfo culture)
protected void InitTrackCount()
private void Advance()
private void Advance(int i)
private void Goto(int newpos)
private void Textto(int newpos)
private void Trackto(int newpos)
private int Textstart()
private int Textpos()
private int Trackpos()
private void TrackPush()
private void TrackPush(int I1)
private void TrackPush(int I1, int I2)
private void TrackPush(int I1, int I2, int I3)
private void TrackPush2(int I1)
private void TrackPush2(int I1, int I2)
private void Backtrack()
private void SetOperator(int op)
private void TrackPop()
private void TrackPop(int framesize)
private int TrackPeek()
private int TrackPeek(int i)
private void StackPush(int I1)
private void StackPush(int I1, int I2)
private void StackPop()
private void StackPop(int framesize)
private int StackPeek()
private int StackPeek(int i)
private int Operator()
private int Operand(int i)
private int Leftchars()
private int Rightchars()
private int Bump()
private int Forwardchars()
private char Forwardcharnext()
private bool Stringmatch(string str)
private bool Refmatch(int index, int len)
private void Backwardnext()
private char CharAt(int j)
protected bool FindFirstChar()
protected void Go()
}
internal System.Text.RegularExpressions.RegexLWCGCompiler : RegexCompiler {
private int _regexCount
private Type[] _paramTypes
internal RegexRunnerFactory FactoryInstanceFromCode(RegexCode code, RegexOptions options)
internal DynamicMethod DefineDynamicMethod(string methname, Type returntype, Type hostType)
}
public System.Text.RegularExpressions.RegexMatchTimeoutException : TimeoutException {
private string regexInput
private string regexPattern
private TimeSpan matchTimeout
public string Pattern
public string Input
public TimeSpan MatchTimeout
public void .ctor(string regexInput, string regexPattern, TimeSpan matchTimeout)
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
private void Init()
private void Init(string input, string pattern, TimeSpan timeout)
public string get_Pattern()
public string get_Input()
public TimeSpan get_MatchTimeout()
}
internal System.Text.RegularExpressions.RegexNode : object {
internal int Oneloop
internal int Notoneloop
internal int Setloop
internal int Onelazy
internal int Notonelazy
internal int Setlazy
internal int One
internal int Notone
internal int Set
internal int Multi
internal int Ref
internal int Bol
internal int Eol
internal int Boundary
internal int Nonboundary
internal int ECMABoundary
internal int NonECMABoundary
internal int Beginning
internal int Start
internal int EndZ
internal int End
internal int Nothing
internal int Empty
internal int Alternate
internal int Concatenate
internal int Loop
internal int Lazyloop
internal int Capture
internal int Group
internal int Require
internal int Prevent
internal int Greedy
internal int Testref
internal int Testgroup
internal int _type
internal List`1<RegexNode> _children
internal string _str
internal char _ch
internal int _m
internal int _n
internal RegexOptions _options
internal RegexNode _next
internal void .ctor(int type, RegexOptions options)
internal void .ctor(int type, RegexOptions options, char ch)
internal void .ctor(int type, RegexOptions options, string str)
internal void .ctor(int type, RegexOptions options, int m)
internal void .ctor(int type, RegexOptions options, int m, int n)
internal bool UseOptionR()
internal RegexNode ReverseLeft()
internal void MakeRep(int type, int min, int max)
internal RegexNode Reduce()
internal RegexNode StripEnation(int emptyType)
internal RegexNode ReduceGroup()
internal RegexNode ReduceRep()
internal RegexNode ReduceSet()
internal RegexNode ReduceAlternation()
internal RegexNode ReduceConcatenation()
internal RegexNode MakeQuantifier(bool lazy, int min, int max)
internal void AddChild(RegexNode newChild)
internal RegexNode Child(int i)
internal int ChildCount()
internal int Type()
}
public System.Text.RegularExpressions.RegexOptions : Enum {
public int value__
public RegexOptions None
public RegexOptions IgnoreCase
public RegexOptions Multiline
public RegexOptions ExplicitCapture
public RegexOptions Compiled
public RegexOptions Singleline
public RegexOptions IgnorePatternWhitespace
public RegexOptions RightToLeft
public RegexOptions ECMAScript
public RegexOptions CultureInvariant
}
internal System.Text.RegularExpressions.RegexParser : object {
internal RegexNode _stack
internal RegexNode _group
internal RegexNode _alternation
internal RegexNode _concatenation
internal RegexNode _unit
internal string _pattern
internal int _currentPos
internal CultureInfo _culture
internal int _autocap
internal int _capcount
internal int _captop
internal int _capsize
internal Hashtable _caps
internal Hashtable _capnames
internal Int32[] _capnumlist
internal List`1<string> _capnamelist
internal RegexOptions _options
internal List`1<RegexOptions> _optionsStack
internal bool _ignoreNextParen
internal int MaxValueDiv10
internal int MaxValueMod10
internal byte Q
internal byte S
internal byte Z
internal byte X
internal byte E
internal Byte[] _category
internal RegexTree Parse(string re, RegexOptions op)
internal RegexReplacement ParseReplacement(string rep, Hashtable caps, int capsize, Hashtable capnames, RegexOptions op)
internal string Escape(string input)
internal string Unescape(string input)
private void .ctor(CultureInfo culture)
internal void SetPattern(string Re)
internal void Reset(RegexOptions topopts)
internal RegexNode ScanRegex()
internal RegexNode ScanReplacement()
internal RegexCharClass ScanCharClass(bool caseInsensitive)
internal RegexCharClass ScanCharClass(bool caseInsensitive, bool scanOnly)
internal RegexNode ScanGroupOpen()
internal void ScanBlank()
internal RegexNode ScanBackslash()
internal RegexNode ScanBasicBackslash()
internal RegexNode ScanDollar()
internal string ScanCapname()
internal char ScanOctal()
internal int ScanDecimal()
internal char ScanHex(int c)
internal int HexDigit(char ch)
internal char ScanControl()
internal bool IsOnlyTopOption(RegexOptions option)
internal void ScanOptions()
internal char ScanCharEscape()
internal string ParseProperty()
internal int TypeFromCode(char ch)
internal RegexOptions OptionFromCode(char ch)
internal void CountCaptures()
internal void NoteCaptureSlot(int i, int pos)
internal void NoteCaptureName(string name, int pos)
internal void NoteCaptures(Hashtable caps, int capsize, Hashtable capnames)
internal void AssignNameSlots()
internal int CaptureSlotFromName(string capname)
internal bool IsCaptureSlot(int i)
internal bool IsCaptureName(string capname)
internal bool UseOptionN()
internal bool UseOptionI()
internal bool UseOptionM()
internal bool UseOptionS()
internal bool UseOptionX()
internal bool UseOptionE()
internal bool IsSpecial(char ch)
internal bool IsStopperX(char ch)
internal bool IsQuantifier(char ch)
internal bool IsTrueQuantifier()
internal bool IsSpace(char ch)
internal bool IsMetachar(char ch)
internal void AddConcatenate(int pos, int cch, bool isReplacement)
internal void PushGroup()
internal void PopGroup()
internal bool EmptyStack()
internal void StartGroup(RegexNode openGroup)
internal void AddAlternate()
internal void AddConcatenate()
internal void AddConcatenate(bool lazy, int min, int max)
internal RegexNode Unit()
internal void AddUnitOne(char ch)
internal void AddUnitNotone(char ch)
internal void AddUnitSet(string cc)
internal void AddUnitNode(RegexNode node)
internal void AddUnitType(int type)
internal void AddGroup()
internal void PushOptions()
internal void PopOptions()
internal bool EmptyOptionsStack()
internal void PopKeepOptions()
internal ArgumentException MakeException(string message)
internal int Textpos()
internal void Textto(int pos)
internal char MoveRightGetChar()
internal void MoveRight()
internal void MoveRight(int i)
internal void MoveLeft()
internal char CharAt(int i)
internal char RightChar()
internal char RightChar(int i)
internal int CharsRight()
}
internal System.Text.RegularExpressions.RegexPrefix : object {
internal string _prefix
internal bool _caseInsensitive
internal RegexPrefix _empty
internal string Prefix
internal bool CaseInsensitive
internal RegexPrefix Empty
internal void .ctor(string prefix, bool ci)
internal string get_Prefix()
internal bool get_CaseInsensitive()
internal RegexPrefix get_Empty()
}
internal System.Text.RegularExpressions.RegexReplacement : object {
internal string _rep
internal List`1<string> _strings
internal List`1<int> _rules
internal int Specials
internal int LeftPortion
internal int RightPortion
internal int LastGroup
internal int WholeString
internal string Pattern
internal void .ctor(string rep, RegexNode concat, Hashtable _caps)
private void ReplacementImpl(StringBuilder sb, Match match)
private void ReplacementImplRTL(List`1<string> al, Match match)
internal string get_Pattern()
internal string Replacement(Match match)
internal string Replace(Regex regex, string input, int count, int startat)
internal string Replace(MatchEvaluator evaluator, Regex regex, string input, int count, int startat)
internal String[] Split(Regex regex, string input, int count, int startat)
}
public System.Text.RegularExpressions.RegexRunner : object {
protected internal int runtextbeg
protected internal int runtextend
protected internal int runtextstart
protected internal string runtext
protected internal int runtextpos
protected internal Int32[] runtrack
protected internal int runtrackpos
protected internal Int32[] runstack
protected internal int runstackpos
protected internal Int32[] runcrawl
protected internal int runcrawlpos
protected internal int runtrackcount
protected internal Match runmatch
protected internal Regex runregex
private int timeout
private bool ignoreTimeout
private int timeoutOccursAt
private int TimeoutCheckFrequency
private int timeoutChecksToSkip
protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick)
protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, TimeSpan timeout)
private void StartTimeoutWatch()
protected void CheckTimeout()
private void DoCheckTimeout()
protected void Go()
protected bool FindFirstChar()
protected void InitTrackCount()
private void InitMatch()
private Match TidyMatch(bool quick)
protected void EnsureStorage()
protected bool IsBoundary(int index, int startpos, int endpos)
protected bool IsECMABoundary(int index, int startpos, int endpos)
protected bool CharInSet(char ch, string set, string category)
protected bool CharInClass(char ch, string charClass)
protected void DoubleTrack()
protected void DoubleStack()
protected void DoubleCrawl()
protected void Crawl(int i)
protected int Popcrawl()
protected int Crawlpos()
protected void Capture(int capnum, int start, int end)
protected void TransferCapture(int capnum, int uncapnum, int start, int end)
protected void Uncapture()
protected bool IsMatched(int cap)
protected int MatchIndex(int cap)
protected int MatchLength(int cap)
}
public System.Text.RegularExpressions.RegexRunnerFactory : object {
protected internal RegexRunner CreateInstance()
}
internal System.Text.RegularExpressions.RegexTree : object {
internal RegexNode _root
internal Hashtable _caps
internal Int32[] _capnumlist
internal Hashtable _capnames
internal String[] _capslist
internal RegexOptions _options
internal int _captop
internal void .ctor(RegexNode root, Hashtable caps, Int32[] capnumlist, int captop, Hashtable capnames, String[] capslist, RegexOptions opts)
}
internal System.Text.RegularExpressions.RegexTypeCompiler : RegexCompiler {
private int _typeCount
private AssemblyBuilder _assembly
private ModuleBuilder _module
private TypeBuilder _typebuilder
private MethodBuilder _methbuilder
internal void .ctor(AssemblyName an, CustomAttributeBuilder[] attribs, string resourceFile)
internal Type FactoryTypeFromCode(RegexCode code, RegexOptions options, string typeprefix)
internal void GenerateRegexType(string pattern, RegexOptions opts, string name, bool ispublic, RegexCode code, RegexTree tree, Type factory, TimeSpan matchTimeout)
internal void GenerateCreateHashtable(FieldInfo field, Hashtable ht)
private FieldInfo RegexField(string fieldname)
internal void Save()
internal void GenerateCreateInstance(Type newtype)
internal void DefineType(string typename, bool ispublic, Type inheritfromclass)
internal void DefineMethod(string methname, Type returntype)
internal void BakeMethod()
internal Type BakeType()
}
internal System.Text.RegularExpressions.RegexWriter : object {
internal Int32[] _intStack
internal int _depth
internal Int32[] _emitted
internal int _curpos
internal Dictionary`2<string, int> _stringhash
internal List`1<string> _stringtable
internal bool _counting
internal int _count
internal int _trackcount
internal Hashtable _caps
internal int BeforeChild
internal int AfterChild
internal RegexCode Write(RegexTree t)
internal void PushInt(int I)
internal bool EmptyStack()
internal int PopInt()
internal int CurPos()
internal void PatchJump(int Offset, int jumpDest)
internal void Emit(int op)
internal void Emit(int op, int opd1)
internal void Emit(int op, int opd1, int opd2)
internal int StringCode(string str)
internal ArgumentException MakeException(string message)
internal int MapCapnum(int capnum)
internal RegexCode RegexCodeFromRegexTree(RegexTree tree)
internal void EmitFragment(int nodetype, RegexNode node, int CurIndex)
}
internal System.Text.RegularExpressions.SharedReference : object {
private WeakReference _ref
private int _locked
internal object Get()
internal void Cache(object obj)
}
public System.Threading.Barrier : object {
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentTotalCount
private int CURRENT_MASK
private int TOTAL_MASK
private int SENSE_MASK
private int MAX_PARTICIPANTS
private long m_currentPhase
private bool m_disposed
private ManualResetEventSlim m_oddEvent
private ManualResetEventSlim m_evenEvent
private ExecutionContext m_ownerThreadContext
private ContextCallback s_invokePostPhaseAction
private Action`1<Barrier> m_postPhaseAction
private Exception m_exception
private int m_actionCallerID
public int ParticipantsRemaining
public int ParticipantCount
public long CurrentPhaseNumber
public int get_ParticipantsRemaining()
public int get_ParticipantCount()
public long get_CurrentPhaseNumber()
internal void set_CurrentPhaseNumber(long value)
public void .ctor(int participantCount)
public void .ctor(int participantCount, Action`1<Barrier> postPhaseAction)
private void GetCurrentTotal(int currentTotal, Int32& current, Int32& total, Boolean& sense)
private bool SetCurrentTotal(int currentTotal, int current, int total, bool sense)
public long AddParticipant()
public long AddParticipants(int participantCount)
public void RemoveParticipant()
public void RemoveParticipants(int participantCount)
public void SignalAndWait()
public void SignalAndWait(CancellationToken cancellationToken)
public bool SignalAndWait(TimeSpan timeout)
public bool SignalAndWait(TimeSpan timeout, CancellationToken cancellationToken)
public bool SignalAndWait(int millisecondsTimeout)
public bool SignalAndWait(int millisecondsTimeout, CancellationToken cancellationToken)
private void FinishPhase(bool observedSense)
private void InvokePostPhaseAction(object obj)
private void SetResetEvents(bool observedSense)
private void WaitCurrentPhase(ManualResetEventSlim currentPhaseEvent, long observedPhase)
private bool DiscontinuousWait(ManualResetEventSlim currentPhaseEvent, int totalTimeout, CancellationToken token, long observedPhase)
public void Dispose()
protected void Dispose(bool disposing)
private void ThrowIfDisposed()
}
public System.Threading.BarrierPostPhaseException : Exception {
public void .ctor(Exception innerException)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.Semaphore : WaitHandle {
private int MAX_PATH
public void .ctor(int initialCount, int maximumCount)
public void .ctor(int initialCount, int maximumCount, string name)
public void .ctor(int initialCount, int maximumCount, string name, Boolean& createdNew)
public void .ctor(int initialCount, int maximumCount, string name, Boolean& createdNew, SemaphoreSecurity semaphoreSecurity)
private void .ctor(SafeWaitHandle handle)
public Semaphore OpenExisting(string name)
public Semaphore OpenExisting(string name, SemaphoreRights rights)
public bool TryOpenExisting(string name, Semaphore& result)
public bool TryOpenExisting(string name, SemaphoreRights rights, Semaphore& result)
private OpenExistingResult OpenExistingWorker(string name, SemaphoreRights rights, Semaphore& result)
public int Release()
public int Release(int releaseCount)
public SemaphoreSecurity GetAccessControl()
public void SetAccessControl(SemaphoreSecurity semaphoreSecurity)
internal IntPtr CreateSemaphore_internal(int initialCount, int maximumCount, string name, Int32& errorCode)
internal bool ReleaseSemaphore_internal(IntPtr handle, int releaseCount, Int32& previousCount)
private IntPtr OpenSemaphore_internal(string name, SemaphoreRights rights, Int32& errorCode)
}
public System.Threading.ThreadExceptionEventArgs : EventArgs {
private Exception exception
public Exception Exception
public void .ctor(Exception t)
public Exception get_Exception()
}
public System.Threading.ThreadExceptionEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ThreadExceptionEventArgs e)
public IAsyncResult BeginInvoke(object sender, ThreadExceptionEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Timers.ElapsedEventArgs : EventArgs {
private DateTime time
public DateTime SignalTime
internal void .ctor(DateTime time)
public DateTime get_SignalTime()
}
public System.Timers.ElapsedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ElapsedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ElapsedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Timers.Timer : Component {
private double interval
private bool enabled
private bool initializing
private bool delayedEnable
private ElapsedEventHandler onIntervalElapsed
private bool autoReset
private ISynchronizeInvoke synchronizingObject
private bool disposed
private Timer timer
private TimerCallback callback
private object cookie
public bool AutoReset
public bool Enabled
public double Interval
public ISite Site
public ISynchronizeInvoke SynchronizingObject
public void .ctor(double interval)
public bool get_AutoReset()
public void set_AutoReset(bool value)
public bool get_Enabled()
public void set_Enabled(bool value)
private int CalculateRoundedInterval(double interval, bool argumentCheck)
private void UpdateTimer()
public double get_Interval()
public void set_Interval(double value)
public void add_Elapsed(ElapsedEventHandler value)
public void remove_Elapsed(ElapsedEventHandler value)
public void set_Site(ISite value)
public ISite get_Site()
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public void BeginInit()
public void Close()
protected void Dispose(bool disposing)
public void EndInit()
public void Start()
public void Stop()
private void MyTimerCallback(object state)
}
public System.Timers.TimersDescriptionAttribute : DescriptionAttribute {
private bool replaced
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.UncNameHelper : object {
internal int MaximumInternetNameLength
internal string ParseCanonicalName(string str, int start, int end, Boolean& loopback)
internal bool IsValid(Char* name, ushort start, Int32& returnedEnd, bool notImplicitFile)
}
internal System.UnescapeMode : Enum {
public int value__
public UnescapeMode CopyOnly
public UnescapeMode Escape
public UnescapeMode Unescape
public UnescapeMode EscapeUnescape
public UnescapeMode V1ToStringFlag
public UnescapeMode UnescapeAll
public UnescapeMode UnescapeAllOrThrow
}
public System.Uri : object {
public string UriSchemeFile
public string UriSchemeFtp
public string UriSchemeGopher
public string UriSchemeHttp
public string UriSchemeHttps
internal string UriSchemeWs
internal string UriSchemeWss
public string UriSchemeMailto
public string UriSchemeNews
public string UriSchemeNntp
public string UriSchemeNetTcp
public string UriSchemeNetPipe
public string SchemeDelimiter
private int c_Max16BitUtf8SequenceLength
internal int c_MaxUriBufferSize
private int c_MaxUriSchemeName
private string m_String
private string m_originalUnicodeString
private UriParser m_Syntax
private string m_DnsSafeHost
private Flags m_Flags
private UriInfo m_Info
private bool m_iriParsing
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_ConfigInitialized
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_ConfigInitializing
private UriIdnScope modreq(System.Runtime.CompilerServices.IsVolatile) s_IdnScope
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_IriParsing
private bool useDotNetRelativeOrAbsolute
private UriKind DotNetRelativeOrAbsolute
internal bool IsWindowsFileSystem
private object s_initLock
private UriFormat V1ToStringUnescape
internal char c_DummyChar
internal char c_EOL
internal Char[] HexLowerChars
private Char[] _WSchars
private bool IsImplicitFile
private bool IsUncOrDosPath
private bool IsDosPath
private bool IsUncPath
private Flags HostType
private UriParser Syntax
private bool IsNotAbsoluteUri
private bool AllowIdn
internal bool UserDrivenParsing
private ushort SecuredPathIndex
public string AbsolutePath
private string PrivateAbsolutePath
public string AbsoluteUri
public string LocalPath
public string Authority
public UriHostNameType HostNameType
public bool IsDefaultPort
public bool IsFile
public bool IsLoopback
public string PathAndQuery
public String[] Segments
public bool IsUnc
public string Host
private object InitializeLock
public int Port
public string Query
public string Fragment
public string Scheme
private bool OriginalStringSwitched
public string OriginalString
public string DnsSafeHost
public string IdnHost
public bool IsAbsoluteUri
public bool UserEscaped
public string UserInfo
internal bool HasAuthority
private bool get_IsImplicitFile()
private bool get_IsUncOrDosPath()
private bool get_IsDosPath()
private bool get_IsUncPath()
private Flags get_HostType()
private UriParser get_Syntax()
private bool get_IsNotAbsoluteUri()
internal bool IriParsingStatic(UriParser syntax)
private bool get_AllowIdn()
private bool AllowIdnStatic(UriParser syntax, Flags flags)
private bool IsIntranet(string schemeHost)
internal bool get_UserDrivenParsing()
private void SetUserDrivenParsing()
private ushort get_SecuredPathIndex()
private bool NotAny(Flags flags)
private bool InFact(Flags flags)
private bool StaticNotAny(Flags allFlags, Flags checkFlags)
private bool StaticInFact(Flags allFlags, Flags checkFlags)
private UriInfo EnsureUriInfo()
private void EnsureParseRemaining()
private void EnsureHostString(bool allowDnsOptimization)
public void .ctor(string uriString)
public void .ctor(string uriString, bool dontEscape)
public void .ctor(Uri baseUri, string relativeUri, bool dontEscape)
public void .ctor(string uriString, UriKind uriKind)
public void .ctor(Uri baseUri, string relativeUri)
private void CreateUri(Uri baseUri, string relativeUri, bool dontEscape)
public void .ctor(Uri baseUri, Uri relativeUri)
private ParsingError GetCombinedString(Uri baseUri, string relativeStr, bool dontEscape, String& result)
private UriFormatException GetException(ParsingError err)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public string get_AbsolutePath()
private string get_PrivateAbsolutePath()
public string get_AbsoluteUri()
public string get_LocalPath()
public string get_Authority()
public UriHostNameType get_HostNameType()
public bool get_IsDefaultPort()
public bool get_IsFile()
public bool get_IsLoopback()
public string get_PathAndQuery()
public String[] get_Segments()
public bool get_IsUnc()
public string get_Host()
private bool StaticIsFile(UriParser syntax)
private object get_InitializeLock()
private void InitializeUriConfig()
private string GetLocalPath()
public int get_Port()
public string get_Query()
public string get_Fragment()
public string get_Scheme()
private bool get_OriginalStringSwitched()
public string get_OriginalString()
public string get_DnsSafeHost()
public string get_IdnHost()
public bool get_IsAbsoluteUri()
public bool get_UserEscaped()
public string get_UserInfo()
public UriHostNameType CheckHostName(string name)
public string GetLeftPart(UriPartial part)
public string HexEscape(char character)
public char HexUnescape(string pattern, Int32& index)
public bool IsHexEncoding(string pattern, int index)
internal bool IsGenDelim(char ch)
public bool CheckSchemeName(string schemeName)
public bool IsHexDigit(char character)
public int FromHex(char digit)
public int GetHashCode()
public string ToString()
public bool op_Equality(Uri uri1, Uri uri2)
public bool op_Inequality(Uri uri1, Uri uri2)
public bool Equals(object comparand)
public Uri MakeRelativeUri(Uri uri)
private bool CheckForColonInFirstPathSegment(string uriString)
internal string InternalEscapeString(string rawString)
private ParsingError ParseScheme(string uriString, Flags& flags, UriParser& syntax)
internal UriFormatException ParseMinimal()
private ParsingError PrivateParseMinimal()
private void PrivateParseMinimalIri(string newHost, ushort idx)
private void CreateUriInfo(Flags cF)
private void CreateHostString()
private string CreateHostStringHelper(string str, ushort idx, ushort end, Flags& flags, String& scopeId)
private void GetHostViaCustomSyntax()
internal string GetParts(UriComponents uriParts, UriFormat formatAs)
private string GetEscapedParts(UriComponents uriParts)
private string GetUnescapedParts(UriComponents uriParts, UriFormat formatAs)
private string ReCreateParts(UriComponents parts, ushort nonCanonical, UriFormat formatAs)
private string GetUriPartsFromUserString(UriComponents uriParts)
private void ParseRemaining()
private ushort ParseSchemeCheckImplicitFile(Char* uriString, ushort length, ParsingError& err, Flags& flags, UriParser& syntax)
private bool CheckKnownSchemes(Int64* lptr, ushort nChars, UriParser& syntax)
private ParsingError CheckSchemeSyntax(Char* ptr, ushort length, UriParser& syntax)
private ushort CheckAuthorityHelper(Char* pString, ushort idx, ushort length, ParsingError& err, Flags& flags, UriParser syntax, String& newHost)
private void CheckAuthorityHelperHandleDnsIri(Char* pString, ushort start, int end, int startInput, bool iriParsing, bool hasUnicode, UriParser syntax, string userInfoString, Flags& flags, Boolean& justNormalized, String& newHost, ParsingError& err)
private void CheckAuthorityHelperHandleAnyHostIri(Char* pString, int startInput, int end, bool iriParsing, bool hasUnicode, UriParser syntax, Flags& flags, String& newHost, ParsingError& err)
private void FindEndOfComponent(string input, UInt16& idx, ushort end, char delim)
private void FindEndOfComponent(Char* str, UInt16& idx, ushort end, char delim)
private Check CheckCanonical(Char* str, UInt16& idx, ushort end, char delim)
private Char[] GetCanonicalPath(Char[] dest, Int32& pos, UriFormat formatAs)
private void UnescapeOnly(Char* pch, int start, Int32& end, char ch1, char ch2, char ch3)
private Char[] Compress(Char[] dest, ushort start, Int32& destLength, UriParser syntax)
internal int CalculateCaseInsensitiveHashCode(string text)
private string CombineUri(Uri basePart, string relativePart, UriFormat uriFormat)
private string PathDifference(string path1, string path2, bool compareCase)
internal bool get_HasAuthority()
private bool IsLWS(char ch)
private bool IsAsciiLetter(char character)
internal bool IsAsciiLetterOrDigit(char character)
internal bool IsBidiControlCharacter(char ch)
internal string StripBidiControlCharacter(Char* strToClean, int start, int length)
public string MakeRelative(Uri toUri)
protected void Parse()
protected void Canonicalize()
protected void Escape()
protected string Unescape(string path)
protected string EscapeString(string str)
protected void CheckSecurity()
protected bool IsReservedCharacter(char character)
protected bool IsExcludedCharacter(char character)
protected bool IsBadFileSystemCharacter(char character)
private void CreateThis(string uri, bool dontEscape, UriKind uriKind)
private void InitializeUri(ParsingError err, UriKind uriKind, UriFormatException& e)
private bool CheckForConfigLoad(string data)
private bool CheckForUnicode(string data)
private bool CheckForEscapedUnreserved(string data)
public bool TryCreate(string uriString, UriKind uriKind, Uri& result)
public bool TryCreate(Uri baseUri, string relativeUri, Uri& result)
public bool TryCreate(Uri baseUri, Uri relativeUri, Uri& result)
public string GetComponents(UriComponents components, UriFormat format)
public int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType)
public bool IsWellFormedOriginalString()
public bool IsWellFormedUriString(string uriString, UriKind uriKind)
internal bool InternalIsWellFormedOriginalString()
public string UnescapeDataString(string stringToUnescape)
public string EscapeUriString(string stringToEscape)
public string EscapeDataString(string stringToEscape)
internal string EscapeUnescapeIri(string input, int start, int end, UriComponents component)
private void .ctor(Flags flags, UriParser uriParser, string uri)
internal Uri CreateHelper(string uriString, bool dontEscape, UriKind uriKind, UriFormatException& e)
internal Uri ResolveHelper(Uri baseUri, Uri relativeUri, String& newUriString, Boolean& userEscaped, UriFormatException& e)
private string GetRelativeSerializationString(UriFormat format)
internal string GetComponentsHelper(UriComponents uriComponents, UriFormat uriFormat)
public bool IsBaseOf(Uri uri)
internal bool IsBaseOfHelper(Uri uriLink)
private void CreateThisFromUri(Uri otherUri)
}
public System.UriBuilder : object {
private bool _changed
private string _fragment
private string _host
private string _password
private string _path
private int _port
private string _query
private string _scheme
private string _schemeDelimiter
private Uri _uri
private string _username
private string Extra
public string Fragment
public string Host
public string Password
public string Path
public int Port
public string Query
public string Scheme
public Uri Uri
public string UserName
public void .ctor(string uri)
public void .ctor(Uri uri)
private void Init(Uri uri)
public void .ctor(string schemeName, string hostName)
public void .ctor(string scheme, string host, int portNumber)
public void .ctor(string scheme, string host, int port, string pathValue)
public void .ctor(string scheme, string host, int port, string path, string extraValue)
private void set_Extra(string value)
public string get_Fragment()
public void set_Fragment(string value)
public string get_Host()
public void set_Host(string value)
public string get_Password()
public void set_Password(string value)
public string get_Path()
public void set_Path(string value)
public int get_Port()
public void set_Port(int value)
public string get_Query()
public void set_Query(string value)
public string get_Scheme()
public void set_Scheme(string value)
public Uri get_Uri()
public string get_UserName()
public void set_UserName(string value)
public bool Equals(object rparam)
public int GetHashCode()
private void SetFieldsFromUri(Uri uri)
public string ToString()
}
public System.UriComponents : Enum {
public int value__
public UriComponents Scheme
public UriComponents UserInfo
public UriComponents Host
public UriComponents Port
public UriComponents Path
public UriComponents Query
public UriComponents Fragment
public UriComponents StrongPort
public UriComponents NormalizedHost
public UriComponents KeepDelimiter
public UriComponents SerializationInfoString
public UriComponents AbsoluteUri
public UriComponents HostAndPort
public UriComponents StrongAuthority
public UriComponents SchemeAndServer
public UriComponents HttpRequestUrl
public UriComponents PathAndQuery
}
public System.UriFormat : Enum {
public int value__
public UriFormat UriEscaped
public UriFormat Unescaped
public UriFormat SafeUnescaped
}
public System.UriFormatException : FormatException {
public void .ctor(string textString)
public void .ctor(string textString, Exception e)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.UriHelper : object {
private Char[] HexUpperChars
private short c_MaxAsciiCharsReallocate
private short c_MaxUnicodeCharsReallocate
private short c_MaxUTF_8BytesPerUnicodeChar
private short c_EncodedCharsPerByte
private string RFC2396ReservedMarks
private string RFC3986ReservedMarks
private string RFC2396UnreservedMarks
private string RFC3986UnreservedMarks
internal bool TestForSubPath(Char* pMe, ushort meLength, Char* pShe, ushort sheLength, bool ignoreCase)
internal Char[] EscapeString(string input, int start, int end, Char[] dest, Int32& destPos, bool isUriString, char force1, char force2, char rsvd)
private Char[] EnsureDestinationSize(Char* pStr, Char[] dest, int currentInputPos, short charsToAdd, short minReallocateChars, Int32& destPos, int prevInputPos)
internal Char[] UnescapeString(string input, int start, int end, Char[] dest, Int32& destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery)
internal Char[] UnescapeString(Char* pStr, int start, int end, Char[] dest, Int32& destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery)
internal void MatchUTF8Sequence(Char* pDest, Char[] dest, Int32& destOffset, Char[] unescapedChars, int charCount, Byte[] bytes, int byteCount, bool isQuery, bool iriParsing)
internal void EscapeAsciiChar(char ch, Char[] to, Int32& pos)
internal char EscapedAscii(char digit, char next)
internal bool IsNotSafeForUnescape(char ch)
private bool IsReservedUnreservedOrHash(char c)
internal bool IsUnreserved(char c)
internal bool Is3986Unreserved(char c)
}
public System.UriHostNameType : Enum {
public int value__
public UriHostNameType Unknown
public UriHostNameType Basic
public UriHostNameType Dns
public UriHostNameType IPv4
public UriHostNameType IPv6
}
public System.UriIdnScope : Enum {
public int value__
public UriIdnScope None
public UriIdnScope AllExceptIntranet
public UriIdnScope All
}
public System.UriKind : Enum {
public int value__
public UriKind RelativeOrAbsolute
public UriKind Absolute
public UriKind Relative
}
public System.UriParser : object {
private UriSyntaxFlags SchemeOnlyFlags
private Dictionary`2<string, UriParser> m_Table
private Dictionary`2<string, UriParser> m_TempTable
private UriSyntaxFlags m_Flags
private UriSyntaxFlags modreq(System.Runtime.CompilerServices.IsVolatile) m_UpdatableFlags
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_UpdatableFlagsUsed
private UriSyntaxFlags c_UpdatableFlags
private int m_Port
private string m_Scheme
internal int NoDefaultPort
private int c_InitialTableSize
internal UriParser HttpUri
internal UriParser HttpsUri
internal UriParser WsUri
internal UriParser WssUri
internal UriParser FtpUri
internal UriParser FileUri
internal UriParser GopherUri
internal UriParser NntpUri
internal UriParser NewsUri
internal UriParser MailToUri
internal UriParser UuidUri
internal UriParser TelnetUri
internal UriParser LdapUri
internal UriParser NetTcpUri
internal UriParser NetPipeUri
internal UriParser VsMacrosUri
private UriQuirksVersion s_QuirksVersion
private int c_MaxCapacity
private UriSyntaxFlags UnknownV1SyntaxFlags
private UriSyntaxFlags HttpSyntaxFlags
private UriSyntaxFlags FtpSyntaxFlags
private UriSyntaxFlags FileSyntaxFlags
private UriSyntaxFlags VsmacrosSyntaxFlags
private UriSyntaxFlags GopherSyntaxFlags
private UriSyntaxFlags NewsSyntaxFlags
private UriSyntaxFlags NntpSyntaxFlags
private UriSyntaxFlags TelnetSyntaxFlags
private UriSyntaxFlags LdapSyntaxFlags
private UriSyntaxFlags MailtoSyntaxFlags
private UriSyntaxFlags NetPipeSyntaxFlags
private UriSyntaxFlags NetTcpSyntaxFlags
internal string SchemeName
internal int DefaultPort
internal bool ShouldUseLegacyV2Quirks
internal UriSyntaxFlags Flags
internal bool IsSimple
internal string get_SchemeName()
internal int get_DefaultPort()
protected UriParser OnNewUri()
protected void OnRegister(string schemeName, int defaultPort)
protected void InitializeAndValidate(Uri uri, UriFormatException& parsingError)
protected string Resolve(Uri baseUri, Uri relativeUri, UriFormatException& parsingError)
protected bool IsBaseOf(Uri baseUri, Uri relativeUri)
protected string GetComponents(Uri uri, UriComponents components, UriFormat format)
protected bool IsWellFormedOriginalString(Uri uri)
public void Register(UriParser uriParser, string schemeName, int defaultPort)
public bool IsKnownScheme(string schemeName)
internal bool get_ShouldUseLegacyV2Quirks()
internal UriSyntaxFlags get_Flags()
internal bool NotAny(UriSyntaxFlags flags)
internal bool InFact(UriSyntaxFlags flags)
internal bool IsAllSet(UriSyntaxFlags flags)
private bool IsFullMatch(UriSyntaxFlags flags, UriSyntaxFlags expected)
internal void .ctor(UriSyntaxFlags flags)
private void FetchSyntax(UriParser syntax, string lwrCaseSchemeName, int defaultPort)
internal UriParser FindOrFetchAsUnknownV1Syntax(string lwrCaseScheme)
internal UriParser GetSyntax(string lwrCaseScheme)
internal bool get_IsSimple()
internal void CheckSetIsSimpleFlag()
internal void SetUpdatableFlags(UriSyntaxFlags flags)
internal UriParser InternalOnNewUri()
internal void InternalValidate(Uri thisUri, UriFormatException& parsingError)
internal string InternalResolve(Uri thisBaseUri, Uri uriLink, UriFormatException& parsingError)
internal bool InternalIsBaseOf(Uri thisBaseUri, Uri uriLink)
internal string InternalGetComponents(Uri thisUri, UriComponents uriComponents, UriFormat uriFormat)
internal bool InternalIsWellFormedOriginalString(Uri thisUri)
}
public System.UriPartial : Enum {
public int value__
public UriPartial Scheme
public UriPartial Authority
public UriPartial Path
public UriPartial Query
}
internal System.UriSyntaxFlags : Enum {
public int value__
public UriSyntaxFlags None
public UriSyntaxFlags MustHaveAuthority
public UriSyntaxFlags OptionalAuthority
public UriSyntaxFlags MayHaveUserInfo
public UriSyntaxFlags MayHavePort
public UriSyntaxFlags MayHavePath
public UriSyntaxFlags MayHaveQuery
public UriSyntaxFlags MayHaveFragment
public UriSyntaxFlags AllowEmptyHost
public UriSyntaxFlags AllowUncHost
public UriSyntaxFlags AllowDnsHost
public UriSyntaxFlags AllowIPv4Host
public UriSyntaxFlags AllowIPv6Host
public UriSyntaxFlags AllowAnInternetHost
public UriSyntaxFlags AllowAnyOtherHost
public UriSyntaxFlags FileLikeUri
public UriSyntaxFlags MailToLikeUri
public UriSyntaxFlags V1_UnknownUri
public UriSyntaxFlags SimpleUserSyntax
public UriSyntaxFlags BuiltInSyntax
public UriSyntaxFlags ParserSchemeOnly
public UriSyntaxFlags AllowDOSPath
public UriSyntaxFlags PathIsRooted
public UriSyntaxFlags ConvertPathSlashes
public UriSyntaxFlags CompressPath
public UriSyntaxFlags CanonicalizeAsFilePath
public UriSyntaxFlags UnEscapeDotsAndSlashes
public UriSyntaxFlags AllowIdn
public UriSyntaxFlags AllowIriParsing
}
public System.UriTypeConverter : TypeConverter {
private bool CanConvert(Type type)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool IsValid(ITypeDescriptorContext context, object value)
}
public System.Web.AspNetHostingPermission : CodeAccessPermission {
private int version
private AspNetHostingPermissionLevel _level
public AspNetHostingPermissionLevel Level
public void .ctor(AspNetHostingPermissionLevel level)
public void .ctor(PermissionState state)
public AspNetHostingPermissionLevel get_Level()
public void set_Level(AspNetHostingPermissionLevel value)
public bool IsUnrestricted()
public IPermission Copy()
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
private bool IsEmpty()
private AspNetHostingPermission Cast(IPermission target)
}
public System.Web.AspNetHostingPermissionAttribute : CodeAccessSecurityAttribute {
private AspNetHostingPermissionLevel _level
public AspNetHostingPermissionLevel Level
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
public AspNetHostingPermissionLevel get_Level()
public void set_Level(AspNetHostingPermissionLevel value)
}
public System.Web.AspNetHostingPermissionLevel : Enum {
public int value__
public AspNetHostingPermissionLevel None
public AspNetHostingPermissionLevel Minimal
public AspNetHostingPermissionLevel Low
public AspNetHostingPermissionLevel Medium
public AspNetHostingPermissionLevel High
public AspNetHostingPermissionLevel Unrestricted
}
public System.Windows.Input.ICommand {
public bool CanExecute(object parameter)
public void Execute(object parameter)
public void add_CanExecuteChanged(EventHandler value)
public void remove_CanExecuteChanged(EventHandler value)
}
public System.Windows.Markup.ValueSerializerAttribute : Attribute {
private Type _valueSerializerType
private string _valueSerializerTypeName
public Type ValueSerializerType
public string ValueSerializerTypeName
public void .ctor(Type valueSerializerType)
public void .ctor(string valueSerializerTypeName)
public Type get_ValueSerializerType()
public string get_ValueSerializerTypeName()
}
