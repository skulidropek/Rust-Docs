internal Internal.Cryptography.OidLookup : object {
private ConcurrentDictionary`2<string, string> s_lateBoundOidToFriendlyName
private ConcurrentDictionary`2<string, string> s_lateBoundFriendlyNameToOid
private Dictionary`2<string, string> s_friendlyNameToOid
private Dictionary`2<string, string> s_oidToFriendlyName
private Dictionary`2<string, string> s_compatOids
private bool ShouldUseCache(OidGroup oidGroup)
private string NativeOidToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups)
private string NativeFriendlyNameToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups)
public string ToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups)
public string ToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups)
}
internal Internal.Cryptography.Oids : object {
public string CommonName
public string Organization
public string OrganizationalUnit
public string BasicConstraints
public string SubjectKeyIdentifier
public string SubjectAltName
public string IssuerAltName
public string KeyUsage
public string BasicConstraints2
public string CrlDistributionPoints
public string CertPolicies
public string AnyCertPolicy
public string CertPolicyMappings
public string CertPolicyConstraints
public string EnhancedKeyUsage
public string InhibitAnyPolicyExtension
public string Sha256
public string Sha384
public string Sha512
public string EccCurveSecp384r1
public string EccCurveSecp521r1
public string Ecc
public string EccCurveSecp256r1
public string ECDsaSha256
public string ECDsaSha384
public string ECDsaSha512
public string RsaRsa
public string Mgf1
public string RsaSsaPss
public string RsaPkcs1Sha256
public string RsaPkcs1Sha384
public string RsaPkcs1Sha512
public string Pkcs9ExtensionRequest
public string DsaDsa
public string EmailAddress
public string EnrollCertTypeExtension
public string UserPrincipalName
public string CertificateTemplate
public string ApplicationCertPolicies
public string AuthorityInformationAccess
public string CertificateAuthorityIssuers
}
internal Internal.Cryptography.Pal.CertificateData : ValueType {
internal Byte[] RawData
internal Byte[] SubjectPublicKeyInfo
internal int Version
internal Byte[] SerialNumber
internal AlgorithmIdentifier TbsSignature
internal X500DistinguishedName Issuer
internal DateTime NotBefore
internal DateTime NotAfter
internal X500DistinguishedName Subject
internal AlgorithmIdentifier PublicKeyAlgorithm
internal Byte[] PublicKey
internal Byte[] IssuerUniqueId
internal Byte[] SubjectUniqueId
internal List`1<X509Extension> Extensions
internal AlgorithmIdentifier SignatureAlgorithm
internal Byte[] SignatureValue
internal void .ctor(Byte[] rawData)
public string GetNameInfo(X509NameType nameType, bool forIssuer)
private string GetSimpleNameInfo(X500DistinguishedName name)
private string FindAltNameMatch(Byte[] extensionBytes, GeneralNameType matchType, string otherOid)
private IEnumerable`1<KeyValuePair`2<string, string>> ReadReverseRdns(X500DistinguishedName name)
}
internal Internal.Cryptography.Pal.GeneralNameType : Enum {
public int value__
public GeneralNameType OtherName
public GeneralNameType Rfc822Name
public GeneralNameType Email
public GeneralNameType DnsName
public GeneralNameType X400Address
public GeneralNameType DirectoryName
public GeneralNameType EdiPartyName
public GeneralNameType UniformResourceIdentifier
public GeneralNameType IPAddress
public GeneralNameType RegisteredId
}
internal Microsoft.CSharp.CSharpCodeGenerator : object {
private Char[] s_periodArray
private ExposedTabStringIndentedTextWriter _output
private CodeGeneratorOptions _options
private CodeTypeDeclaration _currentClass
private CodeTypeMember _currentMember
private bool _inNestedBinary
private IDictionary`2<string, string> _provOptions
private int ParameterMultilineThreshold
private int MaxLineLength
private GeneratorSupport LanguageSupport
private String[][] s_keywords
private bool _generatingForLoop
private string ErrorRegexPattern
private Regex RelatedSymbolsRegex
private string FileExtension
private string CompilerName
private string CurrentTypeName
private int Indent
private bool IsCurrentInterface
private bool IsCurrentClass
private bool IsCurrentStruct
private bool IsCurrentEnum
private bool IsCurrentDelegate
private string NullToken
private CodeGeneratorOptions Options
private TextWriter Output
internal void .ctor(IDictionary`2<string, string> providerOptions)
private string get_FileExtension()
private string get_CompilerName()
private string get_CurrentTypeName()
private int get_Indent()
private void set_Indent(int value)
private bool get_IsCurrentInterface()
private bool get_IsCurrentClass()
private bool get_IsCurrentStruct()
private bool get_IsCurrentEnum()
private bool get_IsCurrentDelegate()
private string get_NullToken()
private CodeGeneratorOptions get_Options()
private TextWriter get_Output()
private string QuoteSnippetStringCStyle(string value)
private string QuoteSnippetStringVerbatimStyle(string value)
private string QuoteSnippetString(string value)
private void ContinueOnNewLine(string st)
private void OutputIdentifier(string ident)
private void OutputType(CodeTypeReference typeRef)
private void GenerateArrayCreateExpression(CodeArrayCreateExpression e)
private void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e)
private void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
private void GenerateCastExpression(CodeCastExpression e)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
private void GenerateDefaultValueExpression(CodeDefaultValueExpression e)
private void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e)
private void GenerateEvents(CodeTypeDeclaration e)
private void GenerateFields(CodeTypeDeclaration e)
private void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e)
private void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
private void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e)
private void GenerateIndexerExpression(CodeIndexerExpression e)
private void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e)
private void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e)
private void GenerateSnippetExpression(CodeSnippetExpression e)
private void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e)
private void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e)
private bool GetUserData(CodeObject e, string property, bool defaultValue)
private void GenerateNamespace(CodeNamespace e)
private void GenerateStatement(CodeStatement e)
private void GenerateStatements(CodeStatementCollection stmts)
private void GenerateNamespaceImports(CodeNamespace e)
private void GenerateEventReferenceExpression(CodeEventReferenceExpression e)
private void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
private void GenerateObjectCreateExpression(CodeObjectCreateExpression e)
private void GeneratePrimitiveExpression(CodePrimitiveExpression e)
private void GeneratePrimitiveExpressionBase(CodePrimitiveExpression e)
private void GeneratePrimitiveChar(char c)
private void AppendEscapedChar(StringBuilder b, char value)
private void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
private void GenerateThisReferenceExpression(CodeThisReferenceExpression e)
private void GenerateExpressionStatement(CodeExpressionStatement e)
private void GenerateIterationStatement(CodeIterationStatement e)
private void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e)
private void GenerateComment(CodeComment e)
private void GenerateCommentStatement(CodeCommentStatement e)
private void GenerateCommentStatements(CodeCommentStatementCollection e)
private void GenerateMethodReturnStatement(CodeMethodReturnStatement e)
private void GenerateConditionStatement(CodeConditionStatement e)
private void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e)
private void GenerateAssignStatement(CodeAssignStatement e)
private void GenerateAttachEventStatement(CodeAttachEventStatement e)
private void GenerateRemoveEventStatement(CodeRemoveEventStatement e)
private void GenerateSnippetStatement(CodeSnippetStatement e)
private void GenerateGotoStatement(CodeGotoStatement e)
private void GenerateLabeledStatement(CodeLabeledStatement e)
private void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
private void GenerateLinePragmaStart(CodeLinePragma e)
private void GenerateLinePragmaEnd(CodeLinePragma e)
private void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c)
private void GenerateExpression(CodeExpression e)
private void GenerateField(CodeMemberField e)
private void GenerateSnippetMember(CodeSnippetTypeMember e)
private void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
private void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c)
private void GenerateMethods(CodeTypeDeclaration e)
private void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c)
private void GenerateProperties(CodeTypeDeclaration e)
private void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c)
private void GenerateSingleFloatValue(float s)
private void GenerateDoubleValue(double d)
private void GenerateDecimalValue(decimal d)
private void OutputVTableModifier(MemberAttributes attributes)
private void OutputMemberAccessModifier(MemberAttributes attributes)
private void OutputMemberScopeModifier(MemberAttributes attributes)
private void OutputOperator(CodeBinaryOperatorType op)
private void OutputFieldScopeModifier(MemberAttributes attributes)
private void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e)
private void GenerateConstructors(CodeTypeDeclaration e)
private void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c)
private void GenerateTypeConstructor(CodeTypeConstructor e)
private void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e)
private void GenerateTypeOfExpression(CodeTypeOfExpression e)
private void GenerateType(CodeTypeDeclaration e)
private void GenerateTypes(CodeNamespace e)
private void GenerateTypeStart(CodeTypeDeclaration e)
private void GenerateTypeMember(CodeTypeMember member, CodeTypeDeclaration declaredType)
private void GenerateTypeConstructors(CodeTypeDeclaration e)
private void GenerateSnippetMembers(CodeTypeDeclaration e)
private void GenerateNestedTypes(CodeTypeDeclaration e)
private void GenerateNamespaces(CodeCompileUnit e)
private void OutputAttributeArgument(CodeAttributeArgument arg)
private void OutputDirection(FieldDirection dir)
private void OutputExpressionList(CodeExpressionCollection expressions)
private void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems)
private void OutputParameters(CodeParameterDeclarationExpressionCollection parameters)
private void OutputTypeNamePair(CodeTypeReference typeRef, string name)
private void OutputTypeParameters(CodeTypeParameterCollection typeParameters)
private void OutputTypeParameterConstraints(CodeTypeParameterCollection typeParameters)
private void OutputTypeAttributes(CodeTypeDeclaration e)
private void GenerateTypeEnd(CodeTypeDeclaration e)
private void GenerateNamespaceStart(CodeNamespace e)
private void GenerateCompileUnit(CodeCompileUnit e)
private void GenerateCompileUnitStart(CodeCompileUnit e)
private void GenerateCompileUnitEnd(CodeCompileUnit e)
private void GenerateDirectionExpression(CodeDirectionExpression e)
private void GenerateDirectives(CodeDirectiveCollection directives)
private void GenerateChecksumPragma(CodeChecksumPragma checksumPragma)
private void GenerateCodeRegionDirective(CodeRegionDirective regionDirective)
private void GenerateNamespaceEnd(CodeNamespace e)
private void GenerateNamespaceImport(CodeNamespaceImport e)
private void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
private void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
private void GenerateAttributes(CodeAttributeDeclarationCollection attributes)
private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix)
private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix, bool inLine)
public bool Supports(GeneratorSupport support)
public bool IsValidIdentifier(string value)
public void ValidateIdentifier(string value)
public string CreateValidIdentifier(string name)
public string CreateEscapedIdentifier(string name)
private string GetBaseTypeOutput(CodeTypeReference typeRef, bool preferBuiltInTypes)
private string GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments)
private void GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments, int start, int length, StringBuilder sb)
public string GetTypeOutput(CodeTypeReference typeRef)
private void OutputStartingBrace()
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
private CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e)
private CompilerResults FromFile(CompilerParameters options, string fileName)
private CompilerResults FromSource(CompilerParameters options, string source)
private CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
private void ResolveReferencedAssemblies(CompilerParameters options, CodeCompileUnit e)
private CompilerResults FromSourceBatch(CompilerParameters options, String[] sources)
private string JoinStringArray(String[] sa, string separator)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o)
private CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames)
private string BuildArgs(CompilerParameters options, String[] fileNames, IDictionary`2<string, string> providerOptions)
private CompilerError CreateErrorFromString(string error_string)
private string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension, bool keepFile)
}
public Microsoft.CSharp.CSharpCodeProvider : CodeDomProvider {
private CSharpCodeGenerator _generator
public string FileExtension
public void .ctor(IDictionary`2<string, string> providerOptions)
public string get_FileExtension()
public ICodeGenerator CreateGenerator()
public ICodeCompiler CreateCompiler()
public TypeConverter GetConverter(Type type)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
}
internal Microsoft.CSharp.CSharpMemberAttributeConverter : CSharpModifierAttributeConverter {
private CSharpMemberAttributeConverter <Default>k__BackingField
private String[] <Names>k__BackingField
private Object[] <Values>k__BackingField
public CSharpMemberAttributeConverter Default
protected String[] Names
protected Object[] Values
protected object DefaultValue
public CSharpMemberAttributeConverter get_Default()
protected String[] get_Names()
protected Object[] get_Values()
protected object get_DefaultValue()
}
internal Microsoft.CSharp.CSharpModifierAttributeConverter : TypeConverter {
protected Object[] Values
protected String[] Names
protected object DefaultValue
protected Object[] get_Values()
protected String[] get_Names()
protected object get_DefaultValue()
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
}
internal Microsoft.CSharp.CSharpTypeAttributeConverter : CSharpModifierAttributeConverter {
private CSharpTypeAttributeConverter <Default>k__BackingField
private String[] <Names>k__BackingField
private Object[] <Values>k__BackingField
public CSharpTypeAttributeConverter Default
protected String[] Names
protected Object[] Values
protected object DefaultValue
public CSharpTypeAttributeConverter get_Default()
protected String[] get_Names()
protected Object[] get_Values()
protected object get_DefaultValue()
}
internal Microsoft.VisualBasic.VBCodeGenerator : CodeCompiler {
private Char[] s_periodArray
private int MaxLineLength
private GeneratorSupport LanguageSupport
private int _statementDepth
private IDictionary`2<string, string> _provOptions
private String[][] s_keywords
protected string FileExtension
protected string CompilerName
private bool IsCurrentModule
protected string NullToken
internal void .ctor(IDictionary`2<string, string> providerOptions)
protected string get_FileExtension()
protected string get_CompilerName()
private bool get_IsCurrentModule()
protected string get_NullToken()
private void EnsureInDoubleQuotes(Boolean& fInDoubleQuotes, StringBuilder b)
private void EnsureNotInDoubleQuotes(Boolean& fInDoubleQuotes, StringBuilder b)
protected string QuoteSnippetString(string value)
private void AppendEscapedChar(StringBuilder b, char value)
protected void ProcessCompilerOutputLine(CompilerResults results, string line)
protected string CmdArgsFromParameters(CompilerParameters options)
protected void OutputAttributeArgument(CodeAttributeArgument arg)
private void OutputAttributes(CodeAttributeDeclarationCollection attributes, bool inLine)
private void OutputAttributes(CodeAttributeDeclarationCollection attributes, bool inLine, string prefix, bool closingLine)
protected void OutputDirection(FieldDirection dir)
protected void GenerateDefaultValueExpression(CodeDefaultValueExpression e)
protected void GenerateDirectionExpression(CodeDirectionExpression e)
protected void OutputFieldScopeModifier(MemberAttributes attributes)
protected void OutputMemberAccessModifier(MemberAttributes attributes)
private void OutputVTableModifier(MemberAttributes attributes)
protected void OutputMemberScopeModifier(MemberAttributes attributes)
protected void OutputOperator(CodeBinaryOperatorType op)
private void GenerateNotIsNullExpression(CodeExpression e)
protected void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
protected string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs)
protected void OutputIdentifier(string ident)
protected void OutputType(CodeTypeReference typeRef)
private void OutputTypeAttributes(CodeTypeDeclaration e)
protected void OutputTypeNamePair(CodeTypeReference typeRef, string name)
private string GetArrayPostfix(CodeTypeReference typeRef)
private void OutputArrayPostfix(CodeTypeReference typeRef)
protected void GenerateIterationStatement(CodeIterationStatement e)
protected void GeneratePrimitiveExpression(CodePrimitiveExpression e)
protected void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e)
protected void GenerateArrayCreateExpression(CodeArrayCreateExpression e)
protected void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e)
protected void GenerateCastExpression(CodeCastExpression e)
protected void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e)
protected void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e)
protected void GenerateSingleFloatValue(float s)
protected void GenerateDoubleValue(double d)
protected void GenerateDecimalValue(decimal d)
protected void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
protected void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e)
protected void GenerateIndexerExpression(CodeIndexerExpression e)
protected void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e)
protected void GenerateSnippetExpression(CodeSnippetExpression e)
protected void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e)
protected void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e)
protected void GenerateEventReferenceExpression(CodeEventReferenceExpression e)
private void GenerateFormalEventReferenceExpression(CodeEventReferenceExpression e)
protected void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
protected void GenerateObjectCreateExpression(CodeObjectCreateExpression e)
protected void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
protected void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
protected void GenerateThisReferenceExpression(CodeThisReferenceExpression e)
protected void GenerateExpressionStatement(CodeExpressionStatement e)
private bool IsDocComment(CodeCommentStatement comment)
protected void GenerateCommentStatements(CodeCommentStatementCollection e)
protected void GenerateComment(CodeComment e)
protected void GenerateMethodReturnStatement(CodeMethodReturnStatement e)
protected void GenerateConditionStatement(CodeConditionStatement e)
protected void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e)
protected void GenerateAssignStatement(CodeAssignStatement e)
protected void GenerateAttachEventStatement(CodeAttachEventStatement e)
protected void GenerateRemoveEventStatement(CodeRemoveEventStatement e)
protected void GenerateSnippetStatement(CodeSnippetStatement e)
protected void GenerateGotoStatement(CodeGotoStatement e)
protected void GenerateLabeledStatement(CodeLabeledStatement e)
protected void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
protected void GenerateLinePragmaStart(CodeLinePragma e)
protected void GenerateLinePragmaEnd(CodeLinePragma e)
protected void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c)
protected void GenerateField(CodeMemberField e)
private bool MethodIsOverloaded(CodeMemberMethod e, CodeTypeDeclaration c)
protected void GenerateSnippetMember(CodeSnippetTypeMember e)
protected void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c)
protected void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c)
private bool PropertyIsOverloaded(CodeMemberProperty e, CodeTypeDeclaration c)
protected void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c)
protected void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e)
protected void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c)
protected void GenerateTypeConstructor(CodeTypeConstructor e)
protected void GenerateTypeOfExpression(CodeTypeOfExpression e)
protected void GenerateTypeStart(CodeTypeDeclaration e)
private void OutputTypeParameters(CodeTypeParameterCollection typeParameters)
private void OutputTypeParameterConstraints(CodeTypeParameter typeParameter)
protected void GenerateTypeEnd(CodeTypeDeclaration e)
protected void GenerateNamespace(CodeNamespace e)
private bool AllowLateBound(CodeCompileUnit e)
private bool RequireVariableDeclaration(CodeCompileUnit e)
private bool GetUserData(CodeObject e, string property, bool defaultValue)
protected void GenerateCompileUnitStart(CodeCompileUnit e)
protected void GenerateCompileUnit(CodeCompileUnit e)
protected void GenerateDirectives(CodeDirectiveCollection directives)
private void GenerateChecksumPragma(CodeChecksumPragma checksumPragma)
private void GenerateCodeRegionDirective(CodeRegionDirective regionDirective)
protected void GenerateNamespaceStart(CodeNamespace e)
protected void GenerateNamespaceEnd(CodeNamespace e)
protected void GenerateNamespaceImport(CodeNamespaceImport e)
protected void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
protected void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
public bool IsKeyword(string value)
protected bool Supports(GeneratorSupport support)
protected bool IsValidIdentifier(string value)
protected string CreateValidIdentifier(string name)
protected string CreateEscapedIdentifier(string name)
private string GetBaseTypeOutput(CodeTypeReference typeRef, bool preferBuiltInTypes)
private string GetTypeOutputWithoutArrayPostFix(CodeTypeReference typeRef)
private string GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments)
private void GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments, int start, int length, StringBuilder sb)
protected string GetTypeOutput(CodeTypeReference typeRef)
protected void ContinueOnNewLine(string st)
private bool IsGeneratingStatements()
private void GenerateVBStatements(CodeStatementCollection stms)
protected CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames)
private string BuildArgs(CompilerParameters options, String[] fileNames)
private CompilerError CreateErrorFromString(string error_string)
private string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension, bool keepFile)
}
public Microsoft.VisualBasic.VBCodeProvider : CodeDomProvider {
private VBCodeGenerator _generator
public string FileExtension
public LanguageOptions LanguageOptions
public void .ctor(IDictionary`2<string, string> providerOptions)
public string get_FileExtension()
public LanguageOptions get_LanguageOptions()
public ICodeGenerator CreateGenerator()
public ICodeCompiler CreateCompiler()
public TypeConverter GetConverter(Type type)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
}
internal Microsoft.VisualBasic.VBMemberAttributeConverter : VBModifierAttributeConverter {
private VBMemberAttributeConverter <Default>k__BackingField
private String[] <Names>k__BackingField
private Object[] <Values>k__BackingField
public VBMemberAttributeConverter Default
protected String[] Names
protected Object[] Values
protected object DefaultValue
public VBMemberAttributeConverter get_Default()
protected String[] get_Names()
protected Object[] get_Values()
protected object get_DefaultValue()
}
internal Microsoft.VisualBasic.VBModifierAttributeConverter : TypeConverter {
protected Object[] Values
protected String[] Names
protected object DefaultValue
protected Object[] get_Values()
protected String[] get_Names()
protected object get_DefaultValue()
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
}
internal Microsoft.VisualBasic.VBTypeAttributeConverter : VBModifierAttributeConverter {
private VBTypeAttributeConverter <Default>k__BackingField
private String[] <Names>k__BackingField
private Object[] <Values>k__BackingField
public VBTypeAttributeConverter Default
protected String[] Names
protected Object[] Values
protected object DefaultValue
public VBTypeAttributeConverter get_Default()
protected String[] get_Names()
protected Object[] get_Values()
protected object get_DefaultValue()
}
public Microsoft.Win32.IntranetZoneCredentialPolicy : object {
public bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authModule)
}
internal Microsoft.Win32.NativeMethods : object {
public int E_ABORT
public int PROCESS_TERMINATE
public int PROCESS_CREATE_THREAD
public int PROCESS_SET_SESSIONID
public int PROCESS_VM_OPERATION
public int PROCESS_VM_READ
public int PROCESS_VM_WRITE
public int PROCESS_DUP_HANDLE
public int PROCESS_CREATE_PROCESS
public int PROCESS_SET_QUOTA
public int PROCESS_SET_INFORMATION
public int PROCESS_QUERY_INFORMATION
public int PROCESS_QUERY_LIMITED_INFORMATION
public int STANDARD_RIGHTS_REQUIRED
public int SYNCHRONIZE
public int PROCESS_ALL_ACCESS
public int DUPLICATE_CLOSE_SOURCE
public int DUPLICATE_SAME_ACCESS
public int STILL_ACTIVE
public int WAIT_OBJECT_0
public int WAIT_FAILED
public int WAIT_TIMEOUT
public int WAIT_ABANDONED
public int WAIT_ABANDONED_0
public int ERROR_FILE_NOT_FOUND
public int ERROR_PATH_NOT_FOUND
public int ERROR_ACCESS_DENIED
public int ERROR_INVALID_HANDLE
public int ERROR_SHARING_VIOLATION
public int ERROR_INVALID_NAME
public int ERROR_ALREADY_EXISTS
public int ERROR_FILENAME_EXCED_RANGE
public bool DuplicateHandle(HandleRef hSourceProcessHandle, SafeHandle hSourceHandle, HandleRef hTargetProcess, SafeWaitHandle& targetHandle, int dwDesiredAccess, bool bInheritHandle, int dwOptions)
public bool DuplicateHandle(HandleRef hSourceProcessHandle, HandleRef hSourceHandle, HandleRef hTargetProcess, SafeProcessHandle& targetHandle, int dwDesiredAccess, bool bInheritHandle, int dwOptions)
public IntPtr GetCurrentProcess()
public bool GetExitCodeProcess(IntPtr processHandle, Int32& exitCode)
public bool GetExitCodeProcess(SafeProcessHandle processHandle, Int32& exitCode)
public bool TerminateProcess(IntPtr processHandle, int exitCode)
public bool TerminateProcess(SafeProcessHandle processHandle, int exitCode)
public int WaitForInputIdle(IntPtr handle, int milliseconds)
public int WaitForInputIdle(SafeProcessHandle handle, int milliseconds)
public bool GetProcessWorkingSetSize(IntPtr handle, IntPtr& min, IntPtr& max)
public bool GetProcessWorkingSetSize(SafeProcessHandle handle, IntPtr& min, IntPtr& max)
public bool SetProcessWorkingSetSize(IntPtr handle, IntPtr min, IntPtr max)
public bool SetProcessWorkingSetSize(SafeProcessHandle handle, IntPtr min, IntPtr max)
public bool GetProcessTimes(IntPtr handle, Int64& creation, Int64& exit, Int64& kernel, Int64& user)
public bool GetProcessTimes(SafeProcessHandle handle, Int64& creation, Int64& exit, Int64& kernel, Int64& user)
public int GetCurrentProcessId()
public int GetPriorityClass(IntPtr handle)
public int GetPriorityClass(SafeProcessHandle handle)
public bool SetPriorityClass(IntPtr handle, int priorityClass)
public bool SetPriorityClass(SafeProcessHandle handle, int priorityClass)
public bool CloseProcess(IntPtr handle)
}
public Microsoft.Win32.PowerModeChangedEventArgs : EventArgs {
private PowerModes mymode
public PowerModes Mode
public void .ctor(PowerModes mode)
public PowerModes get_Mode()
}
public Microsoft.Win32.PowerModeChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PowerModeChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, PowerModeChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.PowerModes : Enum {
public int value__
public PowerModes Resume
public PowerModes StatusChange
public PowerModes Suspend
}
public Microsoft.Win32.SafeHandles.SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
internal SafeProcessHandle InvalidHandle
internal void .ctor(IntPtr handle)
public void .ctor(IntPtr existingHandle, bool ownsHandle)
internal void InitialSetHandle(IntPtr h)
protected bool ReleaseHandle()
}
public Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
internal void .ctor(IntPtr handle)
protected bool ReleaseHandle()
}
public Microsoft.Win32.SessionEndedEventArgs : EventArgs {
private SessionEndReasons myreason
public SessionEndReasons Reason
public void .ctor(SessionEndReasons reason)
public SessionEndReasons get_Reason()
}
public Microsoft.Win32.SessionEndedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SessionEndedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SessionEndedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.SessionEndingEventArgs : EventArgs {
private SessionEndReasons myreason
private bool mycancel
public SessionEndReasons Reason
public bool Cancel
public void .ctor(SessionEndReasons reason)
public SessionEndReasons get_Reason()
public bool get_Cancel()
public void set_Cancel(bool value)
}
public Microsoft.Win32.SessionEndingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SessionEndingEventArgs e)
public IAsyncResult BeginInvoke(object sender, SessionEndingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.SessionEndReasons : Enum {
public int value__
public SessionEndReasons Logoff
public SessionEndReasons SystemShutdown
}
public Microsoft.Win32.SessionSwitchEventArgs : EventArgs {
private SessionSwitchReason reason
public SessionSwitchReason Reason
public void .ctor(SessionSwitchReason reason)
public SessionSwitchReason get_Reason()
}
public Microsoft.Win32.SessionSwitchEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SessionSwitchEventArgs e)
public IAsyncResult BeginInvoke(object sender, SessionSwitchEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.SessionSwitchReason : Enum {
public int value__
public SessionSwitchReason ConsoleConnect
public SessionSwitchReason ConsoleDisconnect
public SessionSwitchReason RemoteConnect
public SessionSwitchReason RemoteDisconnect
public SessionSwitchReason SessionLogon
public SessionSwitchReason SessionLogoff
public SessionSwitchReason SessionLock
public SessionSwitchReason SessionUnlock
public SessionSwitchReason SessionRemoteControl
}
public Microsoft.Win32.SystemEvents : object {
private Hashtable TimerStore
private TimerElapsedEventHandler TimerElapsed
public IntPtr CreateTimer(int interval)
public void KillTimer(IntPtr timerId)
private void InternalTimerElapsed(object e, ElapsedEventArgs args)
public void InvokeOnEventsThread(Delegate method)
public void add_DisplaySettingsChanged(EventHandler value)
public void remove_DisplaySettingsChanged(EventHandler value)
public void add_DisplaySettingsChanging(EventHandler value)
public void remove_DisplaySettingsChanging(EventHandler value)
public void add_EventsThreadShutdown(EventHandler value)
public void remove_EventsThreadShutdown(EventHandler value)
public void add_InstalledFontsChanged(EventHandler value)
public void remove_InstalledFontsChanged(EventHandler value)
public void add_LowMemory(EventHandler value)
public void remove_LowMemory(EventHandler value)
public void add_PaletteChanged(EventHandler value)
public void remove_PaletteChanged(EventHandler value)
public void add_PowerModeChanged(PowerModeChangedEventHandler value)
public void remove_PowerModeChanged(PowerModeChangedEventHandler value)
public void add_SessionEnded(SessionEndedEventHandler value)
public void remove_SessionEnded(SessionEndedEventHandler value)
public void add_SessionEnding(SessionEndingEventHandler value)
public void remove_SessionEnding(SessionEndingEventHandler value)
public void add_SessionSwitch(SessionSwitchEventHandler value)
public void remove_SessionSwitch(SessionSwitchEventHandler value)
public void add_TimeChanged(EventHandler value)
public void remove_TimeChanged(EventHandler value)
public void add_TimerElapsed(TimerElapsedEventHandler value)
public void remove_TimerElapsed(TimerElapsedEventHandler value)
public void add_UserPreferenceChanged(UserPreferenceChangedEventHandler value)
public void remove_UserPreferenceChanged(UserPreferenceChangedEventHandler value)
public void add_UserPreferenceChanging(UserPreferenceChangingEventHandler value)
public void remove_UserPreferenceChanging(UserPreferenceChangingEventHandler value)
}
public Microsoft.Win32.TimerElapsedEventArgs : EventArgs {
private IntPtr mytimerId
public IntPtr TimerId
public void .ctor(IntPtr timerId)
public IntPtr get_TimerId()
}
public Microsoft.Win32.TimerElapsedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, TimerElapsedEventArgs e)
public IAsyncResult BeginInvoke(object sender, TimerElapsedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.UserPreferenceCategory : Enum {
public int value__
public UserPreferenceCategory Accessibility
public UserPreferenceCategory Color
public UserPreferenceCategory Desktop
public UserPreferenceCategory General
public UserPreferenceCategory Icon
public UserPreferenceCategory Keyboard
public UserPreferenceCategory Menu
public UserPreferenceCategory Mouse
public UserPreferenceCategory Policy
public UserPreferenceCategory Power
public UserPreferenceCategory Screensaver
public UserPreferenceCategory Window
public UserPreferenceCategory Locale
public UserPreferenceCategory VisualStyle
}
public Microsoft.Win32.UserPreferenceChangedEventArgs : EventArgs {
private UserPreferenceCategory mycategory
public UserPreferenceCategory Category
public void .ctor(UserPreferenceCategory category)
public UserPreferenceCategory get_Category()
}
public Microsoft.Win32.UserPreferenceChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UserPreferenceChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UserPreferenceChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.UserPreferenceChangingEventArgs : EventArgs {
private UserPreferenceCategory mycategory
public UserPreferenceCategory Category
public void .ctor(UserPreferenceCategory category)
public UserPreferenceCategory get_Category()
}
public Microsoft.Win32.UserPreferenceChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UserPreferenceChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, UserPreferenceChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal Mono.Audio.AlsaDevice : AudioDevice {
private IntPtr handle
private IntPtr hw_param
private IntPtr sw_param
private int snd_pcm_open(IntPtr& handle, string pcm_name, int stream, int mode)
private int snd_pcm_close(IntPtr handle)
private int snd_pcm_drain(IntPtr handle)
private int snd_pcm_writei(IntPtr handle, Byte[] buf, int size)
private int snd_pcm_set_params(IntPtr handle, int format, int access, int channels, int rate, int soft_resample, int latency)
private int snd_pcm_state(IntPtr handle)
private int snd_pcm_prepare(IntPtr handle)
private int snd_pcm_hw_params(IntPtr handle, IntPtr param)
private int snd_pcm_hw_params_malloc(IntPtr& param)
private void snd_pcm_hw_params_free(IntPtr param)
private int snd_pcm_hw_params_any(IntPtr handle, IntPtr param)
private int snd_pcm_hw_params_set_access(IntPtr handle, IntPtr param, int access)
private int snd_pcm_hw_params_set_format(IntPtr handle, IntPtr param, int format)
private int snd_pcm_hw_params_set_channels(IntPtr handle, IntPtr param, UInt32 channel)
private int snd_pcm_hw_params_set_rate_near(IntPtr handle, IntPtr param, UInt32& rate, Int32& dir)
private int snd_pcm_hw_params_set_period_time_near(IntPtr handle, IntPtr param, UInt32& period, Int32& dir)
private int snd_pcm_hw_params_get_period_size(IntPtr param, UInt32& period, Int32& dir)
private int snd_pcm_hw_params_set_buffer_size_near(IntPtr handle, IntPtr param, UInt32& buff_size)
private int snd_pcm_hw_params_get_buffer_time_max(IntPtr param, UInt32& buffer_time, Int32& dir)
private int snd_pcm_hw_params_set_buffer_time_near(IntPtr handle, IntPtr param, UInt32& BufferTime, Int32& dir)
private int snd_pcm_hw_params_get_buffer_size(IntPtr param, UInt32& BufferSize)
private int snd_pcm_sw_params(IntPtr handle, IntPtr param)
private int snd_pcm_sw_params_malloc(IntPtr& param)
private void snd_pcm_sw_params_free(IntPtr param)
private int snd_pcm_sw_params_current(IntPtr handle, IntPtr param)
private int snd_pcm_sw_params_set_avail_min(IntPtr handle, IntPtr param, UInt32 frames)
private int snd_pcm_sw_params_set_start_threshold(IntPtr handle, IntPtr param, UInt32 StartThreshold)
public void .ctor(string name)
protected void Finalize()
public void Dispose()
protected void Dispose(bool disposing)
public bool SetFormat(AudioFormat format, int channels, int rate)
public int PlaySample(Byte[] buffer, int num_frames)
public int XRunRecovery(int err)
public void Wait()
}
internal Mono.Audio.AuData : AudioData {
private Stream stream
private short channels
private ushort frame_divider
private int sample_rate
private int data_len
private AudioFormat format
public int Channels
public int Rate
public AudioFormat Format
public void .ctor(Stream data)
public void Play(AudioDevice dev)
public int get_Channels()
public int get_Rate()
public AudioFormat get_Format()
}
internal Mono.Audio.AudioData : object {
protected int buffer_size
private bool stopped
public int Channels
public int Rate
public AudioFormat Format
public bool IsStopped
public int get_Channels()
public int get_Rate()
public AudioFormat get_Format()
public void Setup(AudioDevice dev)
public void Play(AudioDevice dev)
public bool get_IsStopped()
public void set_IsStopped(bool value)
}
internal Mono.Audio.AudioDevice : object {
protected UInt32 chunk_size
public UInt32 ChunkSize
private AudioDevice TryAlsa(string name)
public AudioDevice CreateDevice(string name)
public bool SetFormat(AudioFormat format, int channels, int rate)
public int PlaySample(Byte[] buffer, int num_frames)
public int XRunRecovery(int err)
public void Wait()
public UInt32 get_ChunkSize()
}
internal Mono.Audio.AudioFormat : Enum {
public int value__
public AudioFormat S8
public AudioFormat U8
public AudioFormat S16_LE
public AudioFormat S16_BE
public AudioFormat U16_LE
public AudioFormat U16_BE
public AudioFormat S24_LE
public AudioFormat S24_BE
public AudioFormat U24_LE
public AudioFormat U24_BE
public AudioFormat S32_LE
public AudioFormat S32_BE
public AudioFormat U32_LE
public AudioFormat U32_BE
public AudioFormat FLOAT_LE
public AudioFormat FLOAT_BE
public AudioFormat FLOAT64_LE
public AudioFormat FLOAT64_BE
public AudioFormat IEC958_SUBFRAME_LE
public AudioFormat IEC958_SUBFRAME_BE
public AudioFormat MU_LAW
public AudioFormat A_LAW
public AudioFormat IMA_ADPCM
public AudioFormat MPEG
public AudioFormat GSM
}
internal Mono.Audio.WavData : AudioData {
private Stream stream
private short channels
private ushort frame_divider
private int sample_rate
private int data_len
private long data_offset
private AudioFormat format
public int Channels
public int Rate
public AudioFormat Format
public void .ctor(Stream data)
public void Play(AudioDevice dev)
public int get_Channels()
public int get_Rate()
public AudioFormat get_Format()
}
internal Mono.Audio.Win32SoundPlayer : object {
private Byte[] _buffer
private bool _disposed
public Stream Stream
public void .ctor(Stream s)
private bool PlaySound(Byte[] ptrToSound, UIntPtr hmod, SoundFlags flags)
public void set_Stream(Stream value)
public void Dispose()
protected void Finalize()
protected void Dispose(bool disposing)
public void Play()
public void PlayLooping()
public void PlaySync()
public void Stop()
}
internal Mono.Btls.IMonoBtlsBioMono {
public int Read(Byte[] buffer, int offset, int size, Boolean& wantMore)
public bool Write(Byte[] buffer, int offset, int size)
public void Flush()
public void Close()
}
internal Mono.Btls.MonoBtlsBio : MonoBtlsObject {
protected internal BoringBioHandle Handle
internal void .ctor(BoringBioHandle handle)
protected internal BoringBioHandle get_Handle()
public MonoBtlsBio CreateMonoStream(Stream stream)
private int mono_btls_bio_read(IntPtr bio, IntPtr data, int len)
private int mono_btls_bio_write(IntPtr bio, IntPtr data, int len)
private int mono_btls_bio_flush(IntPtr bio)
private int mono_btls_bio_indent(IntPtr bio, UInt32 indent, UInt32 max_indent)
private int mono_btls_bio_hexdump(IntPtr bio, IntPtr data, int len, UInt32 indent)
private void mono_btls_bio_print_errors(IntPtr bio)
private void mono_btls_bio_free(IntPtr handle)
public int Read(Byte[] buffer, int offset, int size)
public int Write(Byte[] buffer, int offset, int size)
public int Flush()
public int Indent(UInt32 indent, UInt32 max_indent)
public int HexDump(Byte[] buffer, UInt32 indent)
public void PrintErrors()
}
internal Mono.Btls.MonoBtlsBioMemory : MonoBtlsBio {
private IntPtr mono_btls_bio_mem_new()
private int mono_btls_bio_mem_get_data(IntPtr handle, IntPtr& data)
public Byte[] GetData()
}
internal Mono.Btls.MonoBtlsBioMono : MonoBtlsBio {
private GCHandle handle
private IntPtr instance
private BioReadFunc readFunc
private BioWriteFunc writeFunc
private BioControlFunc controlFunc
private IntPtr readFuncPtr
private IntPtr writeFuncPtr
private IntPtr controlFuncPtr
private IMonoBtlsBioMono backend
public void .ctor(IMonoBtlsBioMono backend)
public MonoBtlsBioMono CreateStream(Stream stream, bool ownsStream)
public MonoBtlsBioMono CreateString(StringWriter writer)
private IntPtr mono_btls_bio_mono_new()
private void mono_btls_bio_mono_initialize(IntPtr handle, IntPtr instance, IntPtr readFunc, IntPtr writeFunc, IntPtr controlFunc)
private long Control(ControlCommand command, long arg)
private int OnRead(IntPtr data, int dataLength, Int32& wantMore)
private int OnRead(IntPtr instance, IntPtr data, int dataLength, Int32& wantMore)
private int OnWrite(IntPtr data, int dataLength)
private int OnWrite(IntPtr instance, IntPtr data, int dataLength)
private long Control(IntPtr instance, ControlCommand command, long arg)
protected void Close()
}
internal Mono.Btls.MonoBtlsContext : MobileTlsContext {
private X509Certificate2 remoteCertificate
private X509Certificate clientCertificate
private X509CertificateImplBtls nativeServerCertificate
private X509CertificateImplBtls nativeClientCertificate
private MonoBtlsSslCtx ctx
private MonoBtlsSsl ssl
private MonoBtlsBio bio
private MonoBtlsBio errbio
private MonoTlsConnectionInfo connectionInfo
private bool certificateValidated
private bool isAuthenticated
private bool connected
public MonoBtlsProvider Provider
public bool CanRenegotiate
public bool HasContext
public bool IsAuthenticated
public MonoTlsConnectionInfo ConnectionInfo
internal bool IsRemoteCertificateAvailable
internal X509Certificate LocalClientCertificate
public X509Certificate2 RemoteCertificate
public TlsProtocols NegotiatedProtocol
public void .ctor(MobileAuthenticatedStream parent, MonoSslAuthenticationOptions options)
private X509CertificateImplBtls GetPrivateCertificate(X509Certificate certificate)
public MonoBtlsProvider get_Provider()
private int VerifyCallback(MonoBtlsX509StoreCtx storeCtx)
private int SelectCallback(String[] acceptableIssuers)
private int ServerNameCallback()
public void StartHandshake()
private void SetPrivateCertificate(X509CertificateImplBtls privateCert)
private Exception GetException(MonoBtlsSslError status)
public bool ProcessHandshake()
private MonoBtlsSslError DoProcessHandshake()
public void FinishHandshake()
private void InitializeConnection()
private void GetPeerCertificate()
private void InitializeSession()
private TlsProtocols GetProtocol(TlsProtocolCode protocol)
public void Flush()
public ValueTuple`2<int, bool> Read(Byte[] buffer, int offset, int size)
public ValueTuple`2<int, bool> Write(Byte[] buffer, int offset, int size)
public bool get_CanRenegotiate()
public void Renegotiate()
public void Shutdown()
public bool PendingRenegotiation()
private void Dispose(T& disposable)
protected void Dispose(bool disposing)
private int Mono.Btls.IMonoBtlsBioMono.Read(Byte[] buffer, int offset, int size, Boolean& wantMore)
private bool Mono.Btls.IMonoBtlsBioMono.Write(Byte[] buffer, int offset, int size)
private void Mono.Btls.IMonoBtlsBioMono.Flush()
private void Mono.Btls.IMonoBtlsBioMono.Close()
public bool get_HasContext()
public bool get_IsAuthenticated()
public MonoTlsConnectionInfo get_ConnectionInfo()
internal bool get_IsRemoteCertificateAvailable()
internal X509Certificate get_LocalClientCertificate()
public X509Certificate2 get_RemoteCertificate()
public TlsProtocols get_NegotiatedProtocol()
}
internal Mono.Btls.MonoBtlsError : object {
private int mono_btls_error_peek_error()
private int mono_btls_error_get_error()
private void mono_btls_error_clear_error()
private int mono_btls_error_peek_error_line(IntPtr& file, Int32& line)
private int mono_btls_error_get_error_line(IntPtr& file, Int32& line)
private void mono_btls_error_get_error_string_n(int error, IntPtr buf, int len)
private int mono_btls_error_get_reason(int error)
public int PeekError()
public int GetError()
public void ClearError()
public string GetErrorString(int error)
public int PeekError(String& file, Int32& line)
public int GetError(String& file, Int32& line)
public int GetErrorReason(int error)
}
internal Mono.Btls.MonoBtlsException : Exception {
public void .ctor(MonoBtlsSslError error)
public void .ctor(string message)
public void .ctor(string format, Object[] args)
}
internal Mono.Btls.MonoBtlsKey : MonoBtlsObject {
internal BoringKeyHandle Handle
public bool IsRsa
private IntPtr mono_btls_key_new()
private void mono_btls_key_free(IntPtr handle)
private IntPtr mono_btls_key_up_ref(IntPtr handle)
private int mono_btls_key_get_bytes(IntPtr handle, IntPtr& data, Int32& size, int include_private_bits)
private int mono_btls_key_get_bits(IntPtr handle)
private int mono_btls_key_is_rsa(IntPtr handle)
private int mono_btls_key_assign_rsa_private_key(IntPtr handle, Byte[] der, int der_length)
internal BoringKeyHandle get_Handle()
internal void .ctor(BoringKeyHandle handle)
public Byte[] GetBytes(bool include_private_bits)
public bool get_IsRsa()
public MonoBtlsKey Copy()
public MonoBtlsKey CreateFromRSAPrivateKey(RSA privateKey)
}
internal Mono.Btls.MonoBtlsObject : object {
internal string BTLS_DYLIB
private MonoBtlsHandle handle
private Exception lastError
internal MonoBtlsHandle Handle
public bool IsValid
internal void .ctor(MonoBtlsHandle handle)
internal MonoBtlsHandle get_Handle()
public bool get_IsValid()
protected void CheckThrow()
protected Exception SetException(Exception ex)
protected void CheckError(bool ok, string callerName)
protected void CheckError(int ret, string callerName)
protected internal void CheckLastError(string callerName)
private void mono_btls_free(IntPtr data)
protected void FreeDataPtr(IntPtr data)
protected void Close()
protected void Dispose(bool disposing)
public void Dispose()
protected void Finalize()
}
internal Mono.Btls.MonoBtlsPkcs12 : MonoBtlsObject {
private MonoBtlsKey privateKey
internal BoringPkcs12Handle Handle
public int Count
public bool HasPrivateKey
internal BoringPkcs12Handle get_Handle()
private void mono_btls_pkcs12_free(IntPtr handle)
private IntPtr mono_btls_pkcs12_new()
private int mono_btls_pkcs12_get_count(IntPtr handle)
private IntPtr mono_btls_pkcs12_get_cert(IntPtr Handle, int index)
private int mono_btls_pkcs12_add_cert(IntPtr chain, IntPtr x509)
private int mono_btls_pkcs12_import(IntPtr chain, Void* data, int len, SafePasswordHandle password)
private int mono_btls_pkcs12_has_private_key(IntPtr pkcs12)
private IntPtr mono_btls_pkcs12_get_private_key(IntPtr pkcs12)
internal void .ctor(BoringPkcs12Handle handle)
public int get_Count()
public MonoBtlsX509 GetCertificate(int index)
public void AddCertificate(MonoBtlsX509 x509)
public void Import(Byte[] buffer, SafePasswordHandle password)
public bool get_HasPrivateKey()
public MonoBtlsKey GetPrivateKey()
}
internal Mono.Btls.MonoBtlsProvider : MobileTlsProvider {
public Guid ID
public string Name
public bool SupportsSslStream
public bool SupportsMonoExtensions
public bool SupportsConnectionInfo
internal bool SupportsCleanShutdown
public SslProtocols SupportedProtocols
internal bool HasNativeCertificates
public Guid get_ID()
public string get_Name()
public bool get_SupportsSslStream()
public bool get_SupportsMonoExtensions()
public bool get_SupportsConnectionInfo()
internal bool get_SupportsCleanShutdown()
public SslProtocols get_SupportedProtocols()
internal MobileAuthenticatedStream CreateSslStream(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
internal bool get_HasNativeCertificates()
internal X509Certificate2Impl GetNativeCertificate(Byte[] data, string password, X509KeyStorageFlags flags)
internal X509Certificate2Impl GetNativeCertificate(X509Certificate certificate)
internal X509Certificate2Impl GetNativeCertificate(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags flags)
internal MonoBtlsX509VerifyParam GetVerifyParam(MonoTlsSettings settings, string targetHost, bool serverMode)
internal bool ValidateCertificate(ChainValidationHelper validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain& chain, SslPolicyErrors& errors, Int32& status11)
internal bool ValidateCertificate(MonoBtlsX509Chain chain, MonoBtlsX509VerifyParam param)
private void CheckValidationResult(ChainValidationHelper validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain chain, MonoBtlsX509StoreCtx storeCtx, bool success, SslPolicyErrors& errors, Int32& status11)
internal X509ChainStatusFlags MapVerifyErrorToChainStatus(MonoBtlsX509Error code)
internal void SetupCertificateStore(MonoBtlsX509Store store, MonoTlsSettings settings, bool server)
private void SetupDefaultCertificateStore(MonoBtlsX509Store store)
private void AddUserStore(MonoBtlsX509Store store)
private void AddMachineStore(MonoBtlsX509Store store)
private void AddTrustedRoots(MonoBtlsX509Store store, MonoTlsSettings settings, bool server)
public string GetSystemStoreLocation()
public X509Certificate2 CreateCertificate(Byte[] data, MonoBtlsX509Format format)
public X509Certificate2 CreateCertificate(Byte[] data, string password, bool disallowFallback)
public X509Certificate2 CreateCertificate(MonoBtlsX509 x509)
public X509Chain CreateChain()
public X509Chain GetManagedChain(MonoBtlsX509Chain chain)
public MonoBtlsX509 GetBtlsCertificate(X509Certificate certificate)
public MonoBtlsX509Chain GetNativeChain(X509CertificateCollection certificates)
}
internal Mono.Btls.MonoBtlsSelectCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public int Invoke(String[] acceptableIssuers)
public IAsyncResult BeginInvoke(String[] acceptableIssuers, AsyncCallback callback, object object)
public int EndInvoke(IAsyncResult result)
}
internal Mono.Btls.MonoBtlsServerNameCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public int Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public int EndInvoke(IAsyncResult result)
}
internal Mono.Btls.MonoBtlsSsl : MonoBtlsObject {
private MonoBtlsBio bio
private PrintErrorsCallbackFunc printErrorsFunc
private IntPtr printErrorsFuncPtr
internal BoringSslHandle Handle
private void mono_btls_ssl_destroy(IntPtr handle)
private IntPtr mono_btls_ssl_new(IntPtr handle)
private int mono_btls_ssl_use_certificate(IntPtr handle, IntPtr x509)
private int mono_btls_ssl_use_private_key(IntPtr handle, IntPtr key)
private int mono_btls_ssl_add_chain_certificate(IntPtr handle, IntPtr x509)
private int mono_btls_ssl_accept(IntPtr handle)
private int mono_btls_ssl_connect(IntPtr handle)
private int mono_btls_ssl_handshake(IntPtr handle)
private void mono_btls_ssl_close(IntPtr handle)
private int mono_btls_ssl_shutdown(IntPtr handle)
private void mono_btls_ssl_set_quiet_shutdown(IntPtr handle, int mode)
private void mono_btls_ssl_set_bio(IntPtr handle, IntPtr bio)
private int mono_btls_ssl_read(IntPtr handle, IntPtr data, int len)
private int mono_btls_ssl_write(IntPtr handle, IntPtr data, int len)
private int mono_btls_ssl_get_error(IntPtr handle, int ret_code)
private int mono_btls_ssl_get_version(IntPtr handle)
private void mono_btls_ssl_set_min_version(IntPtr handle, int version)
private void mono_btls_ssl_set_max_version(IntPtr handle, int version)
private int mono_btls_ssl_get_cipher(IntPtr handle)
private int mono_btls_ssl_get_ciphers(IntPtr handle, IntPtr& data)
private IntPtr mono_btls_ssl_get_peer_certificate(IntPtr handle)
private int mono_btls_ssl_set_cipher_list(IntPtr handle, IntPtr str)
private void mono_btls_ssl_print_errors_cb(IntPtr func, IntPtr ctx)
private int mono_btls_ssl_set_verify_param(IntPtr handle, IntPtr param)
private int mono_btls_ssl_set_server_name(IntPtr handle, IntPtr name)
private IntPtr mono_btls_ssl_get_server_name(IntPtr handle)
private void mono_btls_ssl_set_renegotiate_mode(IntPtr handle, int mode)
private int mono_btls_ssl_renegotiate_pending(IntPtr handle)
private BoringSslHandle Create_internal(MonoBtlsSslCtx ctx)
public void .ctor(MonoBtlsSslCtx ctx)
internal BoringSslHandle get_Handle()
public void SetBio(MonoBtlsBio bio)
private Exception ThrowError(string callerName)
private MonoBtlsSslError GetError(int ret_code)
public void SetCertificate(MonoBtlsX509 x509)
public void SetPrivateKey(MonoBtlsKey key)
public void AddIntermediateCertificate(MonoBtlsX509 x509)
public MonoBtlsSslError Accept()
public MonoBtlsSslError Connect()
public MonoBtlsSslError Handshake()
private int PrintErrorsCallback(IntPtr str, IntPtr len, IntPtr ctx)
public string GetErrors()
public void PrintErrors()
public MonoBtlsSslError Read(IntPtr data, Int32& dataSize)
public MonoBtlsSslError Write(IntPtr data, Int32& dataSize)
public int GetVersion()
public void SetMinVersion(int version)
public void SetMaxVersion(int version)
public int GetCipher()
public Int16[] GetCiphers()
public void SetCipherList(string str)
public MonoBtlsX509 GetPeerCertificate()
public void SetVerifyParam(MonoBtlsX509VerifyParam param)
public void SetServerName(string name)
public string GetServerName()
public void Shutdown()
public void SetQuietShutdown()
protected void Close()
public void SetRenegotiateMode(MonoBtlsSslRenegotiateMode mode)
public bool RenegotiatePending()
}
internal Mono.Btls.MonoBtlsSslCtx : MonoBtlsObject {
private NativeVerifyFunc verifyFunc
private NativeSelectFunc selectFunc
private NativeServerNameFunc serverNameFunc
private IntPtr verifyFuncPtr
private IntPtr selectFuncPtr
private IntPtr serverNameFuncPtr
private MonoBtlsVerifyCallback verifyCallback
private MonoBtlsSelectCallback selectCallback
private MonoBtlsServerNameCallback serverNameCallback
private MonoBtlsX509Store store
private GCHandle instance
private IntPtr instancePtr
internal BoringSslCtxHandle Handle
public MonoBtlsX509Store CertificateStore
internal BoringSslCtxHandle get_Handle()
private IntPtr mono_btls_ssl_ctx_new()
private int mono_btls_ssl_ctx_free(IntPtr handle)
private IntPtr mono_btls_ssl_ctx_up_ref(IntPtr handle)
private void mono_btls_ssl_ctx_initialize(IntPtr handle, IntPtr instance)
private void mono_btls_ssl_ctx_set_debug_bio(IntPtr handle, IntPtr bio)
private void mono_btls_ssl_ctx_set_cert_verify_callback(IntPtr handle, IntPtr func, int cert_required)
private void mono_btls_ssl_ctx_set_cert_select_callback(IntPtr handle, IntPtr func)
private void mono_btls_ssl_ctx_set_min_version(IntPtr handle, int version)
private void mono_btls_ssl_ctx_set_max_version(IntPtr handle, int version)
private int mono_btls_ssl_ctx_is_cipher_supported(IntPtr handle, short value)
private int mono_btls_ssl_ctx_set_ciphers(IntPtr handle, int count, IntPtr data, int allow_unsupported)
private int mono_btls_ssl_ctx_set_verify_param(IntPtr handle, IntPtr param)
private int mono_btls_ssl_ctx_set_client_ca_list(IntPtr handle, int count, IntPtr sizes, IntPtr data)
private void mono_btls_ssl_ctx_set_server_name_callback(IntPtr handle, IntPtr func)
internal void .ctor(BoringSslCtxHandle handle)
internal MonoBtlsSslCtx Copy()
public MonoBtlsX509Store get_CertificateStore()
private int VerifyCallback(bool preverify_ok, MonoBtlsX509StoreCtx ctx)
private int NativeVerifyCallback(IntPtr instance, int preverify_ok, IntPtr store_ctx)
private int NativeSelectCallback(IntPtr instance, int count, IntPtr sizes, IntPtr data)
private String[] CopyIssuers(int count, IntPtr sizesPtr, IntPtr dataPtr)
public void SetDebugBio(MonoBtlsBio bio)
public void SetVerifyCallback(MonoBtlsVerifyCallback callback, bool client_cert_required)
public void SetSelectCallback(MonoBtlsSelectCallback callback)
public void SetMinVersion(int version)
public void SetMaxVersion(int version)
public bool IsCipherSupported(short value)
public void SetCiphers(Int16[] ciphers, bool allow_unsupported)
public void SetVerifyParam(MonoBtlsX509VerifyParam param)
public void SetClientCertificateIssuers(String[] acceptableIssuers)
public void SetServerNameCallback(MonoBtlsServerNameCallback callback)
private int NativeServerNameCallback(IntPtr instance)
protected void Close()
}
internal Mono.Btls.MonoBtlsSslError : Enum {
public int value__
public MonoBtlsSslError None
public MonoBtlsSslError Ssl
public MonoBtlsSslError WantRead
public MonoBtlsSslError WantWrite
public MonoBtlsSslError WantX509Lookup
public MonoBtlsSslError Syscall
public MonoBtlsSslError ZeroReturn
public MonoBtlsSslError WantConnect
public MonoBtlsSslError WantAccept
public MonoBtlsSslError WantChannelIdLookup
public MonoBtlsSslError PendingSession
public MonoBtlsSslError PendingCertificate
public MonoBtlsSslError WantPrivateKeyOperation
}
internal Mono.Btls.MonoBtlsSslRenegotiateMode : Enum {
public int value__
public MonoBtlsSslRenegotiateMode NEVER
public MonoBtlsSslRenegotiateMode ONCE
public MonoBtlsSslRenegotiateMode FREELY
public MonoBtlsSslRenegotiateMode IGNORE
}
internal Mono.Btls.MonoBtlsStream : MobileAuthenticatedStream {
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MobileTlsProvider provider)
protected MobileTlsContext CreateContext(MonoSslAuthenticationOptions options)
}
internal Mono.Btls.MonoBtlsUtils : object {
private Byte[] emailOid
private X500DistinguishedNameFlags AllFlags
public bool Compare(Byte[] a, Byte[] b)
private bool AppendEntry(StringBuilder sb, MonoBtlsX509Name name, int index, string separator, bool quotes)
private string GetSeparator(X500DistinguishedNameFlags flag)
public string FormatName(MonoBtlsX509Name name, X500DistinguishedNameFlags flag)
public string FormatName(MonoBtlsX509Name name, bool reversed, string separator, bool quotes)
}
internal Mono.Btls.MonoBtlsVerifyCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public int Invoke(MonoBtlsX509StoreCtx ctx)
public IAsyncResult BeginInvoke(MonoBtlsX509StoreCtx ctx, AsyncCallback callback, object object)
public int EndInvoke(IAsyncResult result)
}
internal Mono.Btls.MonoBtlsX509 : MonoBtlsObject {
internal BoringX509Handle Handle
internal BoringX509Handle get_Handle()
internal void .ctor(BoringX509Handle handle)
private IntPtr mono_btls_x509_up_ref(IntPtr handle)
private IntPtr mono_btls_x509_from_data(IntPtr data, int len, MonoBtlsX509Format format)
private IntPtr mono_btls_x509_get_subject_name(IntPtr handle)
private IntPtr mono_btls_x509_get_issuer_name(IntPtr handle)
private int mono_btls_x509_get_subject_name_string(IntPtr handle, IntPtr buffer, int size)
private int mono_btls_x509_get_issuer_name_string(IntPtr handle, IntPtr buffer, int size)
private int mono_btls_x509_get_raw_data(IntPtr handle, IntPtr bio, MonoBtlsX509Format format)
private int mono_btls_x509_cmp(IntPtr a, IntPtr b)
private int mono_btls_x509_get_hash(IntPtr handle, IntPtr& data)
private long mono_btls_x509_get_not_before(IntPtr handle)
private long mono_btls_x509_get_not_after(IntPtr handle)
private int mono_btls_x509_get_public_key(IntPtr handle, IntPtr bio)
private int mono_btls_x509_get_serial_number(IntPtr handle, IntPtr data, int size, int mono_style)
private int mono_btls_x509_get_version(IntPtr handle)
private int mono_btls_x509_get_signature_algorithm(IntPtr handle, IntPtr buffer, int size)
private int mono_btls_x509_get_public_key_asn1(IntPtr handle, IntPtr oid, int oid_size, IntPtr& data, Int32& size)
private int mono_btls_x509_get_public_key_parameters(IntPtr handle, IntPtr oid, int oid_size, IntPtr& data, Int32& size)
private IntPtr mono_btls_x509_get_pubkey(IntPtr handle)
private int mono_btls_x509_get_subject_key_identifier(IntPtr handle, IntPtr& data, Int32& size)
private int mono_btls_x509_print(IntPtr handle, IntPtr bio)
private void mono_btls_x509_free(IntPtr handle)
private IntPtr mono_btls_x509_dup(IntPtr handle)
private int mono_btls_x509_add_trust_object(IntPtr handle, MonoBtlsX509Purpose purpose)
private int mono_btls_x509_add_reject_object(IntPtr handle, MonoBtlsX509Purpose purpose)
private int mono_btls_x509_add_explicit_trust(IntPtr handle, MonoBtlsX509TrustKind kind)
internal MonoBtlsX509 Copy()
internal MonoBtlsX509 Duplicate()
public MonoBtlsX509 LoadFromData(Byte[] buffer, MonoBtlsX509Format format)
public MonoBtlsX509Name GetSubjectName()
public string GetSubjectNameString()
public long GetSubjectNameHash()
public MonoBtlsX509Name GetIssuerName()
public string GetIssuerNameString()
public Byte[] GetRawData(MonoBtlsX509Format format)
public void GetRawData(MonoBtlsBio bio, MonoBtlsX509Format format)
public int Compare(MonoBtlsX509 a, MonoBtlsX509 b)
public Byte[] GetCertHash()
public DateTime GetNotBefore()
public DateTime GetNotAfter()
public Byte[] GetPublicKeyData()
public Byte[] GetSerialNumber(bool mono_style)
public int GetVersion()
public string GetSignatureAlgorithm()
public AsnEncodedData GetPublicKeyAsn1()
public AsnEncodedData GetPublicKeyParameters()
public Byte[] GetSubjectKeyIdentifier()
public MonoBtlsKey GetPublicKey()
public void Print(MonoBtlsBio bio)
public void ExportAsPEM(MonoBtlsBio bio, bool includeHumanReadableForm)
public void AddTrustObject(MonoBtlsX509Purpose purpose)
public void AddRejectObject(MonoBtlsX509Purpose purpose)
public void AddExplicitTrust(MonoBtlsX509TrustKind kind)
}
internal Mono.Btls.MonoBtlsX509Chain : MonoBtlsObject {
internal BoringX509ChainHandle Handle
public int Count
internal BoringX509ChainHandle get_Handle()
private IntPtr mono_btls_x509_chain_new()
private int mono_btls_x509_chain_get_count(IntPtr handle)
private IntPtr mono_btls_x509_chain_get_cert(IntPtr Handle, int index)
private int mono_btls_x509_chain_add_cert(IntPtr chain, IntPtr x509)
private IntPtr mono_btls_x509_chain_up_ref(IntPtr handle)
private void mono_btls_x509_chain_free(IntPtr handle)
internal void .ctor(BoringX509ChainHandle handle)
public int get_Count()
public MonoBtlsX509 GetCertificate(int index)
public void Dump()
public void AddCertificate(MonoBtlsX509 x509)
internal MonoBtlsX509Chain Copy()
}
internal Mono.Btls.MonoBtlsX509Crl : MonoBtlsObject {
internal BoringX509CrlHandle Handle
internal BoringX509CrlHandle get_Handle()
internal void .ctor(BoringX509CrlHandle handle)
private IntPtr mono_btls_x509_crl_ref(IntPtr handle)
private IntPtr mono_btls_x509_crl_from_data(IntPtr data, int len, MonoBtlsX509Format format)
private IntPtr mono_btls_x509_crl_get_by_cert(IntPtr handle, IntPtr x509)
private IntPtr mono_btls_x509_crl_get_by_serial(IntPtr handle, Void* serial, int len)
private int mono_btls_x509_crl_get_revoked_count(IntPtr handle)
private IntPtr mono_btls_x509_crl_get_revoked(IntPtr handle, int index)
private long mono_btls_x509_crl_get_last_update(IntPtr handle)
private long mono_btls_x509_crl_get_next_update(IntPtr handle)
private long mono_btls_x509_crl_get_version(IntPtr handle)
private IntPtr mono_btls_x509_crl_get_issuer(IntPtr handle)
private void mono_btls_x509_crl_free(IntPtr handle)
public MonoBtlsX509Crl LoadFromData(Byte[] buffer, MonoBtlsX509Format format)
public MonoBtlsX509Revoked GetByCert(MonoBtlsX509 x509)
public MonoBtlsX509Revoked GetBySerial(Byte[] serial)
public int GetRevokedCount()
public MonoBtlsX509Revoked GetRevoked(int index)
public DateTime GetLastUpdate()
public DateTime GetNextUpdate()
public long GetVersion()
public MonoBtlsX509Name GetIssuerName()
}
internal Mono.Btls.MonoBtlsX509Error : Enum {
public int value__
public MonoBtlsX509Error OK
public MonoBtlsX509Error UNABLE_TO_GET_ISSUER_CERT
public MonoBtlsX509Error UNABLE_TO_GET_CRL
public MonoBtlsX509Error UNABLE_TO_DECRYPT_CERT_SIGNATURE
public MonoBtlsX509Error UNABLE_TO_DECRYPT_CRL_SIGNATURE
public MonoBtlsX509Error UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY
public MonoBtlsX509Error CERT_SIGNATURE_FAILURE
public MonoBtlsX509Error CRL_SIGNATURE_FAILURE
public MonoBtlsX509Error CERT_NOT_YET_VALID
public MonoBtlsX509Error CERT_HAS_EXPIRED
public MonoBtlsX509Error CRL_NOT_YET_VALID
public MonoBtlsX509Error CRL_HAS_EXPIRED
public MonoBtlsX509Error ERROR_IN_CERT_NOT_BEFORE_FIELD
public MonoBtlsX509Error ERROR_IN_CERT_NOT_AFTER_FIELD
public MonoBtlsX509Error ERROR_IN_CRL_LAST_UPDATE_FIELD
public MonoBtlsX509Error ERROR_IN_CRL_NEXT_UPDATE_FIELD
public MonoBtlsX509Error OUT_OF_MEM
public MonoBtlsX509Error DEPTH_ZERO_SELF_SIGNED_CERT
public MonoBtlsX509Error SELF_SIGNED_CERT_IN_CHAIN
public MonoBtlsX509Error UNABLE_TO_GET_ISSUER_CERT_LOCALLY
public MonoBtlsX509Error UNABLE_TO_VERIFY_LEAF_SIGNATURE
public MonoBtlsX509Error CERT_CHAIN_TOO_LONG
public MonoBtlsX509Error CERT_REVOKED
public MonoBtlsX509Error INVALID_CA
public MonoBtlsX509Error PATH_LENGTH_EXCEEDED
public MonoBtlsX509Error INVALID_PURPOSE
public MonoBtlsX509Error CERT_UNTRUSTED
public MonoBtlsX509Error CERT_REJECTED
public MonoBtlsX509Error SUBJECT_ISSUER_MISMATCH
public MonoBtlsX509Error AKID_SKID_MISMATCH
public MonoBtlsX509Error AKID_ISSUER_SERIAL_MISMATCH
public MonoBtlsX509Error KEYUSAGE_NO_CERTSIGN
public MonoBtlsX509Error UNABLE_TO_GET_CRL_ISSUER
public MonoBtlsX509Error UNHANDLED_CRITICAL_EXTENSION
public MonoBtlsX509Error KEYUSAGE_NO_CRL_SIGN
public MonoBtlsX509Error UNHANDLED_CRITICAL_CRL_EXTENSION
public MonoBtlsX509Error INVALID_NON_CA
public MonoBtlsX509Error PROXY_PATH_LENGTH_EXCEEDED
public MonoBtlsX509Error KEYUSAGE_NO_DIGITAL_SIGNATURE
public MonoBtlsX509Error PROXY_CERTIFICATES_NOT_ALLOWED
public MonoBtlsX509Error INVALID_EXTENSION
public MonoBtlsX509Error INVALID_POLICY_EXTENSION
public MonoBtlsX509Error NO_EXPLICIT_POLICY
public MonoBtlsX509Error DIFFERENT_CRL_SCOPE
public MonoBtlsX509Error UNSUPPORTED_EXTENSION_FEATURE
public MonoBtlsX509Error UNNESTED_RESOURCE
public MonoBtlsX509Error PERMITTED_VIOLATION
public MonoBtlsX509Error EXCLUDED_VIOLATION
public MonoBtlsX509Error SUBTREE_MINMAX
public MonoBtlsX509Error UNSUPPORTED_CONSTRAINT_TYPE
public MonoBtlsX509Error UNSUPPORTED_CONSTRAINT_SYNTAX
public MonoBtlsX509Error UNSUPPORTED_NAME_SYNTAX
public MonoBtlsX509Error CRL_PATH_VALIDATION_ERROR
public MonoBtlsX509Error SUITE_B_INVALID_VERSION
public MonoBtlsX509Error SUITE_B_INVALID_ALGORITHM
public MonoBtlsX509Error SUITE_B_INVALID_CURVE
public MonoBtlsX509Error SUITE_B_INVALID_SIGNATURE_ALGORITHM
public MonoBtlsX509Error SUITE_B_LOS_NOT_ALLOWED
public MonoBtlsX509Error SUITE_B_CANNOT_SIGN_P_384_WITH_P_256
public MonoBtlsX509Error HOSTNAME_MISMATCH
public MonoBtlsX509Error EMAIL_MISMATCH
public MonoBtlsX509Error IP_ADDRESS_MISMATCH
public MonoBtlsX509Error APPLICATION_VERIFICATION
}
internal Mono.Btls.MonoBtlsX509Exception : Exception {
private MonoBtlsX509Error <ErrorCode>k__BackingField
private string <ErrorMessage>k__BackingField
public MonoBtlsX509Error ErrorCode
public string ErrorMessage
public MonoBtlsX509Error get_ErrorCode()
private void set_ErrorCode(MonoBtlsX509Error value)
public string get_ErrorMessage()
private void set_ErrorMessage(string value)
public void .ctor(MonoBtlsX509Error code, string message)
public string ToString()
}
internal Mono.Btls.MonoBtlsX509FileType : Enum {
public int value__
public MonoBtlsX509FileType PEM
public MonoBtlsX509FileType ASN1
public MonoBtlsX509FileType DEFAULT
}
internal Mono.Btls.MonoBtlsX509Format : Enum {
public int value__
public MonoBtlsX509Format DER
public MonoBtlsX509Format PEM
}
internal Mono.Btls.MonoBtlsX509Lookup : MonoBtlsObject {
private MonoBtlsX509Store store
private MonoBtlsX509LookupType type
private List`1<MonoBtlsX509LookupMono> monoLookups
internal BoringX509LookupHandle Handle
internal BoringX509LookupHandle get_Handle()
private IntPtr mono_btls_x509_lookup_new(IntPtr store, MonoBtlsX509LookupType type)
private int mono_btls_x509_lookup_load_file(IntPtr handle, IntPtr file, MonoBtlsX509FileType type)
private int mono_btls_x509_lookup_add_dir(IntPtr handle, IntPtr dir, MonoBtlsX509FileType type)
private int mono_btls_x509_lookup_add_mono(IntPtr handle, IntPtr monoLookup)
private int mono_btls_x509_lookup_init(IntPtr handle)
private int mono_btls_x509_lookup_shutdown(IntPtr handle)
private IntPtr mono_btls_x509_lookup_by_subject(IntPtr handle, IntPtr name)
private IntPtr mono_btls_x509_lookup_by_fingerprint(IntPtr handle, IntPtr bytes, int len)
private void mono_btls_x509_lookup_free(IntPtr handle)
private IntPtr mono_btls_x509_lookup_peek_lookup(IntPtr handle)
private BoringX509LookupHandle Create_internal(MonoBtlsX509Store store, MonoBtlsX509LookupType type)
internal void .ctor(MonoBtlsX509Store store, MonoBtlsX509LookupType type)
internal IntPtr GetNativeLookup()
public void LoadFile(string file, MonoBtlsX509FileType type)
public void AddDirectory(string dir, MonoBtlsX509FileType type)
internal void AddMono(MonoBtlsX509LookupMono monoLookup)
public void Initialize()
public void Shutdown()
public MonoBtlsX509 LookupBySubject(MonoBtlsX509Name name)
public MonoBtlsX509 LookupByFingerPrint(Byte[] fingerprint)
internal void AddCertificate(MonoBtlsX509 certificate)
protected void Close()
}
internal Mono.Btls.MonoBtlsX509LookupMono : MonoBtlsObject {
private GCHandle gch
private IntPtr instance
private BySubjectFunc bySubjectFunc
private IntPtr bySubjectFuncPtr
private MonoBtlsX509Lookup lookup
internal BoringX509LookupMonoHandle Handle
internal BoringX509LookupMonoHandle get_Handle()
private IntPtr mono_btls_x509_lookup_mono_new()
private void mono_btls_x509_lookup_mono_init(IntPtr handle, IntPtr instance, IntPtr by_subject_func)
private int mono_btls_x509_lookup_mono_free(IntPtr handle)
internal void Install(MonoBtlsX509Lookup lookup)
protected void AddCertificate(MonoBtlsX509 certificate)
protected MonoBtlsX509 OnGetBySubject(MonoBtlsX509Name name)
private int OnGetBySubject(IntPtr instance, IntPtr name_ptr, IntPtr& x509_ptr)
protected void Close()
}
internal Mono.Btls.MonoBtlsX509LookupMonoCollection : MonoBtlsX509LookupMono {
private Int64[] hashes
private MonoBtlsX509[] certificates
private X509CertificateCollection collection
private MonoBtlsX509TrustKind trust
internal void .ctor(X509CertificateCollection collection, MonoBtlsX509TrustKind trust)
private void Initialize()
protected MonoBtlsX509 OnGetBySubject(MonoBtlsX509Name name)
protected void Close()
}
internal Mono.Btls.MonoBtlsX509LookupType : Enum {
public int value__
public MonoBtlsX509LookupType UNKNOWN
public MonoBtlsX509LookupType FILE
public MonoBtlsX509LookupType HASH_DIR
public MonoBtlsX509LookupType MONO
}
internal Mono.Btls.MonoBtlsX509Name : MonoBtlsObject {
internal BoringX509NameHandle Handle
private int mono_btls_x509_name_print_bio(IntPtr handle, IntPtr bio)
private int mono_btls_x509_name_print_string(IntPtr handle, IntPtr buffer, int size)
private int mono_btls_x509_name_get_raw_data(IntPtr handle, IntPtr& buffer, int use_canon_enc)
private long mono_btls_x509_name_hash(IntPtr handle)
private long mono_btls_x509_name_hash_old(IntPtr handle)
private int mono_btls_x509_name_get_entry_count(IntPtr handle)
private MonoBtlsX509NameEntryType mono_btls_x509_name_get_entry_type(IntPtr name, int index)
private int mono_btls_x509_name_get_entry_oid(IntPtr name, int index, IntPtr buffer, int size)
private int mono_btls_x509_name_get_entry_oid_data(IntPtr name, int index, IntPtr& data)
private int mono_btls_x509_name_get_entry_value(IntPtr name, int index, Int32& tag, IntPtr& str)
private IntPtr mono_btls_x509_name_from_data(Void* data, int len, int use_canon_enc)
private void mono_btls_x509_name_free(IntPtr handle)
internal BoringX509NameHandle get_Handle()
internal void .ctor(BoringX509NameHandle handle)
public string GetString()
public void PrintBio(MonoBtlsBio bio)
public Byte[] GetRawData(bool use_canon_enc)
public long GetHash()
public long GetHashOld()
public int GetEntryCount()
public MonoBtlsX509NameEntryType GetEntryType(int index)
public string GetEntryOid(int index)
public Byte[] GetEntryOidData(int index)
public string GetEntryValue(int index, Int32& tag)
public MonoBtlsX509Name CreateFromData(Byte[] data, bool use_canon_enc)
}
internal Mono.Btls.MonoBtlsX509NameEntryType : Enum {
public int value__
public MonoBtlsX509NameEntryType Unknown
public MonoBtlsX509NameEntryType CountryName
public MonoBtlsX509NameEntryType OrganizationName
public MonoBtlsX509NameEntryType OrganizationalUnitName
public MonoBtlsX509NameEntryType CommonName
public MonoBtlsX509NameEntryType LocalityName
public MonoBtlsX509NameEntryType StateOrProvinceName
public MonoBtlsX509NameEntryType StreetAddress
public MonoBtlsX509NameEntryType SerialNumber
public MonoBtlsX509NameEntryType DomainComponent
public MonoBtlsX509NameEntryType UserId
public MonoBtlsX509NameEntryType Email
public MonoBtlsX509NameEntryType DnQualifier
public MonoBtlsX509NameEntryType Title
public MonoBtlsX509NameEntryType Surname
public MonoBtlsX509NameEntryType GivenName
public MonoBtlsX509NameEntryType Initial
}
internal Mono.Btls.MonoBtlsX509Purpose : Enum {
public int value__
public MonoBtlsX509Purpose SSL_CLIENT
public MonoBtlsX509Purpose SSL_SERVER
public MonoBtlsX509Purpose NS_SSL_SERVER
public MonoBtlsX509Purpose SMIME_SIGN
public MonoBtlsX509Purpose SMIME_ENCRYPT
public MonoBtlsX509Purpose CRL_SIGN
public MonoBtlsX509Purpose ANY
public MonoBtlsX509Purpose OCSP_HELPER
public MonoBtlsX509Purpose TIMESTAMP_SIGN
}
internal Mono.Btls.MonoBtlsX509Revoked : MonoBtlsObject {
internal BoringX509RevokedHandle Handle
internal BoringX509RevokedHandle get_Handle()
internal void .ctor(BoringX509RevokedHandle handle)
private int mono_btls_x509_revoked_get_serial_number(IntPtr handle, IntPtr data, int size)
private long mono_btls_x509_revoked_get_revocation_date(IntPtr handle)
private int mono_btls_x509_revoked_get_reason(IntPtr handle)
private int mono_btls_x509_revoked_get_sequence(IntPtr handle)
private void mono_btls_x509_revoked_free(IntPtr handle)
public Byte[] GetSerialNumber()
public DateTime GetRevocationDate()
public int GetReason()
public int GetSequence()
}
internal Mono.Btls.MonoBtlsX509Store : MonoBtlsObject {
private Dictionary`2<IntPtr, MonoBtlsX509Lookup> lookupHash
internal BoringX509StoreHandle Handle
internal BoringX509StoreHandle get_Handle()
private IntPtr mono_btls_x509_store_new()
private IntPtr mono_btls_x509_store_from_ctx(IntPtr ctx)
private IntPtr mono_btls_x509_store_from_ssl_ctx(IntPtr handle)
private int mono_btls_x509_store_load_locations(IntPtr handle, IntPtr file, IntPtr path)
private int mono_btls_x509_store_set_default_paths(IntPtr handle)
private int mono_btls_x509_store_add_cert(IntPtr handle, IntPtr x509)
private int mono_btls_x509_store_get_count(IntPtr handle)
private void mono_btls_x509_store_free(IntPtr handle)
public void LoadLocations(string file, string path)
public void SetDefaultPaths()
private BoringX509StoreHandle Create_internal()
private BoringX509StoreHandle Create_internal(IntPtr store_ctx)
private BoringX509StoreHandle Create_internal(BoringSslCtxHandle ctx)
internal void .ctor(IntPtr store_ctx)
internal void .ctor(BoringSslCtxHandle ctx)
public void AddCertificate(MonoBtlsX509 x509)
public int GetCount()
internal void AddTrustedRoots()
public MonoBtlsX509Lookup AddLookup(MonoBtlsX509LookupType type)
public void AddDirectoryLookup(string dir, MonoBtlsX509FileType type)
public void AddFileLookup(string file, MonoBtlsX509FileType type)
public void AddCollection(X509CertificateCollection collection, MonoBtlsX509TrustKind trust)
protected void Close()
}
internal Mono.Btls.MonoBtlsX509StoreCtx : MonoBtlsObject {
private Nullable`1<int> verifyResult
internal BoringX509StoreCtxHandle Handle
public int VerifyResult
internal BoringX509StoreCtxHandle get_Handle()
private IntPtr mono_btls_x509_store_ctx_new()
private IntPtr mono_btls_x509_store_ctx_from_ptr(IntPtr ctx)
private MonoBtlsX509Error mono_btls_x509_store_ctx_get_error(IntPtr handle, IntPtr& error_string)
private int mono_btls_x509_store_ctx_get_error_depth(IntPtr handle)
private IntPtr mono_btls_x509_store_ctx_get_chain(IntPtr handle)
private int mono_btls_x509_store_ctx_init(IntPtr handle, IntPtr store, IntPtr chain)
private int mono_btls_x509_store_ctx_set_param(IntPtr handle, IntPtr param)
private int mono_btls_x509_store_ctx_verify_cert(IntPtr handle)
private IntPtr mono_btls_x509_store_ctx_get_by_subject(IntPtr handle, IntPtr name)
private IntPtr mono_btls_x509_store_ctx_get_current_cert(IntPtr handle)
private IntPtr mono_btls_x509_store_ctx_get_current_issuer(IntPtr handle)
private IntPtr mono_btls_x509_store_ctx_get_verify_param(IntPtr handle)
private IntPtr mono_btls_x509_store_ctx_get_untrusted(IntPtr handle)
private IntPtr mono_btls_x509_store_ctx_up_ref(IntPtr handle)
private void mono_btls_x509_store_ctx_free(IntPtr handle)
private BoringX509StoreCtxHandle Create_internal(IntPtr store_ctx)
internal void .ctor(int preverify_ok, IntPtr store_ctx)
internal void .ctor(BoringX509StoreCtxHandle ptr, Nullable`1<int> verifyResult)
public MonoBtlsX509Error GetError()
public int GetErrorDepth()
public MonoBtlsX509Exception GetException()
public MonoBtlsX509Chain GetChain()
public MonoBtlsX509Chain GetUntrusted()
public void Initialize(MonoBtlsX509Store store, MonoBtlsX509Chain chain)
public void SetVerifyParam(MonoBtlsX509VerifyParam param)
public int get_VerifyResult()
public int Verify()
public MonoBtlsX509 LookupBySubject(MonoBtlsX509Name name)
public MonoBtlsX509 GetCurrentCertificate()
public MonoBtlsX509 GetCurrentIssuer()
public MonoBtlsX509VerifyParam GetVerifyParam()
public MonoBtlsX509StoreCtx Copy()
}
internal Mono.Btls.MonoBtlsX509StoreManager : object {
private bool initialized
private string machineTrustedRootPath
private string machineIntermediateCAPath
private string machineUntrustedPath
private string userTrustedRootPath
private string userIntermediateCAPath
private string userUntrustedPath
private void Initialize()
private void DoInitialize()
public bool HasStore(MonoBtlsX509StoreType type)
public string GetStorePath(MonoBtlsX509StoreType type)
}
internal Mono.Btls.MonoBtlsX509StoreType : Enum {
public int value__
public MonoBtlsX509StoreType Custom
public MonoBtlsX509StoreType MachineTrustedRoots
public MonoBtlsX509StoreType MachineIntermediateCA
public MonoBtlsX509StoreType MachineUntrusted
public MonoBtlsX509StoreType UserTrustedRoots
public MonoBtlsX509StoreType UserIntermediateCA
public MonoBtlsX509StoreType UserUntrusted
}
internal Mono.Btls.MonoBtlsX509TrustKind : Enum {
public int value__
public MonoBtlsX509TrustKind DEFAULT
public MonoBtlsX509TrustKind TRUST_CLIENT
public MonoBtlsX509TrustKind TRUST_SERVER
public MonoBtlsX509TrustKind TRUST_ALL
public MonoBtlsX509TrustKind REJECT_CLIENT
public MonoBtlsX509TrustKind REJECT_SERVER
public MonoBtlsX509TrustKind REJECT_ALL
}
internal Mono.Btls.MonoBtlsX509VerifyFlags : Enum {
public int value__
public MonoBtlsX509VerifyFlags DEFAULT
public MonoBtlsX509VerifyFlags CRL_CHECK
public MonoBtlsX509VerifyFlags CRL_CHECK_ALL
public MonoBtlsX509VerifyFlags X509_STRIC
}
internal Mono.Btls.MonoBtlsX509VerifyParam : MonoBtlsObject {
internal BoringX509VerifyParamHandle Handle
public bool CanModify
internal BoringX509VerifyParamHandle get_Handle()
private IntPtr mono_btls_x509_verify_param_new()
private IntPtr mono_btls_x509_verify_param_copy(IntPtr handle)
private IntPtr mono_btls_x509_verify_param_lookup(IntPtr name)
private int mono_btls_x509_verify_param_can_modify(IntPtr param)
private int mono_btls_x509_verify_param_set_name(IntPtr handle, IntPtr name)
private int mono_btls_x509_verify_param_set_host(IntPtr handle, IntPtr name, int namelen)
private int mono_btls_x509_verify_param_add_host(IntPtr handle, IntPtr name, int namelen)
private ulong mono_btls_x509_verify_param_get_flags(IntPtr handle)
private int mono_btls_x509_verify_param_set_flags(IntPtr handle, ulong flags)
private MonoBtlsX509VerifyFlags mono_btls_x509_verify_param_get_mono_flags(IntPtr handle)
private int mono_btls_x509_verify_param_set_mono_flags(IntPtr handle, MonoBtlsX509VerifyFlags flags)
private int mono_btls_x509_verify_param_set_purpose(IntPtr handle, MonoBtlsX509Purpose purpose)
private int mono_btls_x509_verify_param_get_depth(IntPtr handle)
private int mono_btls_x509_verify_param_set_depth(IntPtr handle, int depth)
private int mono_btls_x509_verify_param_set_time(IntPtr handle, long time)
private IntPtr mono_btls_x509_verify_param_get_peername(IntPtr handle)
private void mono_btls_x509_verify_param_free(IntPtr handle)
internal void .ctor(BoringX509VerifyParamHandle handle)
public MonoBtlsX509VerifyParam Copy()
public MonoBtlsX509VerifyParam GetSslClient()
public MonoBtlsX509VerifyParam GetSslServer()
public MonoBtlsX509VerifyParam Lookup(string name, bool fail)
public bool get_CanModify()
private void WantToModify()
public void SetName(string name)
public void SetHost(string name)
public void AddHost(string name)
public ulong GetFlags()
public void SetFlags(ulong flags)
public MonoBtlsX509VerifyFlags GetMonoFlags()
public void SetMonoFlags(MonoBtlsX509VerifyFlags flags)
public void SetPurpose(MonoBtlsX509Purpose purpose)
public int GetDepth()
public void SetDepth(int depth)
public void SetTime(DateTime time)
public string GetPeerName()
}
internal Mono.Btls.X509CertificateImplBtls : X509Certificate2ImplUnix {
private MonoBtlsX509 x509
private MonoBtlsKey nativePrivateKey
private X509CertificateImplCollection intermediateCerts
private PublicKey publicKey
public bool IsValid
public IntPtr Handle
internal MonoBtlsX509 X509
internal MonoBtlsKey NativePrivateKey
internal X509CertificateImplCollection IntermediateCertificates
internal X509Certificate2Impl FallbackImpl
public bool HasPrivateKey
public AsymmetricAlgorithm PrivateKey
public PublicKey PublicKey
internal void .ctor(MonoBtlsX509 x509)
private void .ctor(X509CertificateImplBtls other)
internal void .ctor(Byte[] data, MonoBtlsX509Format format)
internal void .ctor(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
public bool get_IsValid()
public IntPtr get_Handle()
public IntPtr GetNativeAppleCertificate()
internal MonoBtlsX509 get_X509()
internal MonoBtlsKey get_NativePrivateKey()
public X509CertificateImpl Clone()
public bool Equals(X509CertificateImpl other, Boolean& result)
protected Byte[] GetRawCertData()
internal X509CertificateImplCollection get_IntermediateCertificates()
protected void Dispose(bool disposing)
internal X509Certificate2Impl get_FallbackImpl()
public bool get_HasPrivateKey()
public AsymmetricAlgorithm get_PrivateKey()
public void set_PrivateKey(AsymmetricAlgorithm value)
public RSA GetRSAPrivateKey()
public DSA GetDSAPrivateKey()
public PublicKey get_PublicKey()
private void Import(Byte[] data)
private void ImportPkcs12(Byte[] data, SafePasswordHandle password)
private void ImportAuthenticode(Byte[] data)
public bool Verify(X509Certificate2 thisCertificate)
public void Reset()
}
internal Mono.Btls.X509ChainImplBtls : X509ChainImpl {
private MonoBtlsX509StoreCtx storeCtx
private MonoBtlsX509Chain chain
private MonoBtlsX509Chain untrustedChain
private X509ChainElementCollection elements
private X509Certificate2Collection untrusted
private X509Certificate2[] certificates
private X509ChainPolicy policy
private List`1<X509ChainStatus> chainStatusList
public bool IsValid
public IntPtr Handle
internal MonoBtlsX509Chain Chain
internal MonoBtlsX509StoreCtx StoreCtx
public X509ChainElementCollection ChainElements
public X509ChainPolicy ChainPolicy
public X509ChainStatus[] ChainStatus
internal void .ctor(MonoBtlsX509Chain chain)
internal void .ctor(MonoBtlsX509StoreCtx storeCtx)
public bool get_IsValid()
public IntPtr get_Handle()
internal MonoBtlsX509Chain get_Chain()
internal MonoBtlsX509StoreCtx get_StoreCtx()
public X509ChainElementCollection get_ChainElements()
public X509ChainPolicy get_ChainPolicy()
public void set_ChainPolicy(X509ChainPolicy value)
public X509ChainStatus[] get_ChainStatus()
public void AddStatus(X509ChainStatusFlags errorCode)
public bool Build(X509Certificate2 certificate)
public void Reset()
protected void Dispose(bool disposing)
}
internal Mono.Btls.X509PalImplBtls : X509PalImpl {
private MonoBtlsProvider <Provider>k__BackingField
private MonoBtlsProvider Provider
public void .ctor(MonoTlsProvider provider)
private MonoBtlsProvider get_Provider()
public X509CertificateImpl Import(Byte[] data)
public X509Certificate2Impl Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
public X509Certificate2Impl Import(X509Certificate cert)
}
internal Mono.CFArray : CFObject {
private IntPtr kCFTypeArrayCallbacks
public int Count
public IntPtr Item
public void .ctor(IntPtr handle, bool own)
private IntPtr CFArrayCreate(IntPtr allocator, IntPtr values, IntPtr numValues, IntPtr callbacks)
public CFArray FromNativeObjects(INativeObject[] values)
public IntPtr Create(IntPtr[] values)
internal CFArray CreateArray(IntPtr[] values)
public CFArray CreateArray(INativeObject[] values)
public IntPtr Create(INativeObject[] values)
private IntPtr CFArrayGetCount(IntPtr handle)
public int get_Count()
private IntPtr CFArrayGetValueAtIndex(IntPtr handle, IntPtr index)
public IntPtr get_Item(int index)
public T[] ArrayFromHandle(IntPtr handle, Func`2<IntPtr, T> creation)
}
internal Mono.CFBoolean : object {
private IntPtr handle
public CFBoolean True
public CFBoolean False
public IntPtr Handle
public bool Value
internal void .ctor(IntPtr handle, bool owns)
protected void Finalize()
public IntPtr get_Handle()
public void Dispose()
protected void Dispose(bool disposing)
public bool op_Implicit(CFBoolean value)
public CFBoolean op_Explicit(bool value)
public CFBoolean FromBoolean(bool value)
private bool CFBooleanGetValue(IntPtr boolean)
public bool get_Value()
public bool GetValue(IntPtr boolean)
}
internal Mono.CFData : CFObject {
public IntPtr Length
public IntPtr Bytes
public byte Item
public void .ctor(IntPtr handle, bool own)
private IntPtr CFDataCreate(IntPtr allocator, IntPtr bytes, IntPtr length)
public CFData FromData(Byte[] buffer)
public CFData FromData(IntPtr buffer, IntPtr length)
public IntPtr get_Length()
internal IntPtr CFDataGetLength(IntPtr theData)
internal IntPtr CFDataGetBytePtr(IntPtr theData)
public IntPtr get_Bytes()
public byte get_Item(long idx)
public void set_Item(long idx, byte value)
}
internal Mono.CFDate : object {
private IntPtr handle
public IntPtr Handle
internal void .ctor(IntPtr handle, bool owns)
protected void Finalize()
private IntPtr CFDateCreate(IntPtr allocator, double at)
public CFDate Create(DateTime date)
public IntPtr get_Handle()
public void Dispose()
protected void Dispose(bool disposing)
}
internal Mono.CFDictionary : CFObject {
private IntPtr KeyCallbacks
private IntPtr ValueCallbacks
public IntPtr Item
public void .ctor(IntPtr handle, bool own)
public CFDictionary FromObjectAndKey(IntPtr obj, IntPtr key)
public CFDictionary FromKeysAndObjects(IList`1<Tuple`2<IntPtr, IntPtr>> items)
private IntPtr CFDictionaryCreate(IntPtr allocator, IntPtr[] keys, IntPtr[] vals, IntPtr len, IntPtr keyCallbacks, IntPtr valCallbacks)
private IntPtr CFDictionaryGetValue(IntPtr handle, IntPtr key)
private IntPtr CFDictionaryCreateCopy(IntPtr allocator, IntPtr handle)
public CFDictionary Copy()
public CFMutableDictionary MutableCopy()
private IntPtr CFDictionaryCreateMutableCopy(IntPtr allocator, IntPtr capacity, IntPtr theDict)
public IntPtr GetValue(IntPtr key)
public IntPtr get_Item(IntPtr key)
}
internal Mono.CFMutableDictionary : CFDictionary {
public void .ctor(IntPtr handle, bool own)
public void SetValue(IntPtr key, IntPtr val)
public CFMutableDictionary Create()
private void CFDictionarySetValue(IntPtr handle, IntPtr key, IntPtr val)
private IntPtr CFDictionaryCreateMutable(IntPtr allocator, IntPtr capacity, IntPtr keyCallback, IntPtr valueCallbacks)
}
internal Mono.CFNumber : CFObject {
public void .ctor(IntPtr handle, bool own)
private bool CFNumberGetValue(IntPtr handle, IntPtr type, Boolean& value)
public bool AsBool(IntPtr handle)
public bool op_Implicit(CFNumber number)
private bool CFNumberGetValue(IntPtr handle, IntPtr type, Int32& value)
public int AsInt32(IntPtr handle)
private IntPtr CFNumberCreate(IntPtr allocator, IntPtr theType, IntPtr valuePtr)
public CFNumber FromInt32(int number)
public int op_Implicit(CFNumber number)
}
internal Mono.CFObject : object {
public string CoreFoundationLibrary
private string SystemLibrary
private IntPtr <Handle>k__BackingField
public IntPtr Handle
public IntPtr dlopen(string path, int mode)
private IntPtr dlsym(IntPtr handle, string symbol)
public void dlclose(IntPtr handle)
public IntPtr GetIndirect(IntPtr handle, string symbol)
public CFString GetStringConstant(IntPtr handle, string symbol)
public IntPtr GetIntPtr(IntPtr handle, string symbol)
public IntPtr GetCFObjectHandle(IntPtr handle, string symbol)
public void .ctor(IntPtr handle, bool own)
protected void Finalize()
public IntPtr get_Handle()
private void set_Handle(IntPtr value)
internal IntPtr CFRetain(IntPtr handle)
private void Retain()
internal void CFRelease(IntPtr handle)
private void Release()
protected void Dispose(bool disposing)
public void Dispose()
}
internal Mono.CFRange : ValueType {
public IntPtr Location
public IntPtr Length
public void .ctor(int loc, int len)
}
internal Mono.CFString : CFObject {
private string str
public int Length
public void .ctor(IntPtr handle, bool own)
private IntPtr CFStringCreateWithCharacters(IntPtr alloc, IntPtr chars, IntPtr length)
public CFString Create(string value)
private IntPtr CFStringGetLength(IntPtr handle)
public int get_Length()
private int CFStringCompare(IntPtr theString1, IntPtr theString2, int compareOptions)
public int Compare(IntPtr string1, IntPtr string2, int compareOptions)
private IntPtr CFStringGetCharactersPtr(IntPtr handle)
private IntPtr CFStringGetCharacters(IntPtr handle, CFRange range, IntPtr buffer)
public string AsString(IntPtr handle)
public string ToString()
public string op_Implicit(CFString str)
public CFString op_Implicit(string str)
}
internal Mono.CFType : object {
public IntPtr GetTypeID(IntPtr typeRef)
}
internal Mono.Http.NtlmClient : object {
private ConditionalWeakTable`2<HttpWebRequest, NtlmSession> cache
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
internal Mono.Http.NtlmSession : object {
private MessageBase message
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
}
internal Mono.Net.CFNetwork : object {
public string CFNetworkLibrary
private object lock_obj
private Queue`1<GetProxyData> get_proxy_queue
private AutoResetEvent proxy_event
private IntPtr CFNetworkCopyProxiesForAutoConfigurationScriptSequential(IntPtr proxyAutoConfigurationScript, IntPtr targetURL, IntPtr& error)
private IntPtr CFNetworkExecuteProxyAutoConfigurationURL(IntPtr proxyAutoConfigURL, IntPtr targetURL, CFProxyAutoConfigurationResultCallback cb, CFStreamClientContext& clientContext)
private void CFNetworkCopyProxiesForAutoConfigurationScriptThread()
private IntPtr CFNetworkCopyProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, IntPtr targetURL, IntPtr& error)
private CFArray CopyProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, CFUrl targetURL)
public CFProxy[] GetProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, CFUrl targetURL)
public CFProxy[] GetProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, Uri targetUri)
public CFProxy[] ExecuteProxyAutoConfigurationURL(IntPtr proxyAutoConfigURL, Uri targetURL)
private IntPtr CFNetworkCopyProxiesForURL(IntPtr url, IntPtr proxySettings)
private CFArray CopyProxiesForURL(CFUrl url, CFDictionary proxySettings)
public CFProxy[] GetProxiesForURL(CFUrl url, CFProxySettings proxySettings)
public CFProxy[] GetProxiesForUri(Uri uri, CFProxySettings proxySettings)
private IntPtr CFNetworkCopySystemProxySettings()
public CFProxySettings GetSystemProxySettings()
public IWebProxy GetDefaultProxy()
}
internal Mono.Net.CFProxy : object {
private IntPtr kCFProxyAutoConfigurationJavaScriptKey
private IntPtr kCFProxyAutoConfigurationURLKey
private IntPtr kCFProxyHostNameKey
private IntPtr kCFProxyPasswordKey
private IntPtr kCFProxyPortNumberKey
private IntPtr kCFProxyTypeKey
private IntPtr kCFProxyUsernameKey
private IntPtr kCFProxyTypeAutoConfigurationURL
private IntPtr kCFProxyTypeAutoConfigurationJavaScript
private IntPtr kCFProxyTypeFTP
private IntPtr kCFProxyTypeHTTP
private IntPtr kCFProxyTypeHTTPS
private IntPtr kCFProxyTypeSOCKS
private CFDictionary settings
public IntPtr AutoConfigurationJavaScript
public IntPtr AutoConfigurationUrl
public string HostName
public string Password
public int Port
public CFProxyType ProxyType
public string Username
internal void .ctor(CFDictionary settings)
private CFProxyType CFProxyTypeToEnum(IntPtr type)
public IntPtr get_AutoConfigurationJavaScript()
public IntPtr get_AutoConfigurationUrl()
public string get_HostName()
public string get_Password()
public int get_Port()
public CFProxyType get_ProxyType()
public string get_Username()
}
internal Mono.Net.CFProxySettings : object {
private IntPtr kCFNetworkProxiesHTTPEnable
private IntPtr kCFNetworkProxiesHTTPPort
private IntPtr kCFNetworkProxiesHTTPProxy
private IntPtr kCFNetworkProxiesProxyAutoConfigEnable
private IntPtr kCFNetworkProxiesProxyAutoConfigJavaScript
private IntPtr kCFNetworkProxiesProxyAutoConfigURLString
private CFDictionary settings
public CFDictionary Dictionary
public bool HTTPEnable
public int HTTPPort
public string HTTPProxy
public bool ProxyAutoConfigEnable
public string ProxyAutoConfigJavaScript
public string ProxyAutoConfigURLString
public void .ctor(CFDictionary settings)
public CFDictionary get_Dictionary()
public bool get_HTTPEnable()
public int get_HTTPPort()
public string get_HTTPProxy()
public bool get_ProxyAutoConfigEnable()
public string get_ProxyAutoConfigJavaScript()
public string get_ProxyAutoConfigURLString()
}
internal Mono.Net.CFProxyType : Enum {
public int value__
public CFProxyType None
public CFProxyType AutoConfigurationUrl
public CFProxyType AutoConfigurationJavaScript
public CFProxyType FTP
public CFProxyType HTTP
public CFProxyType HTTPS
public CFProxyType SOCKS
}
internal Mono.Net.CFRunLoop : CFObject {
public CFRunLoop CurrentRunLoop
private void CFRunLoopAddSource(IntPtr rl, IntPtr source, IntPtr mode)
private void CFRunLoopRemoveSource(IntPtr rl, IntPtr source, IntPtr mode)
private int CFRunLoopRunInMode(IntPtr mode, double seconds, bool returnAfterSourceHandled)
private IntPtr CFRunLoopGetCurrent()
private void CFRunLoopStop(IntPtr rl)
public void .ctor(IntPtr handle, bool own)
public CFRunLoop get_CurrentRunLoop()
public void AddSource(IntPtr source, CFString mode)
public void RemoveSource(IntPtr source, CFString mode)
public int RunInMode(CFString mode, double seconds, bool returnAfterSourceHandled)
public void Stop()
}
internal Mono.Net.CFStreamClientContext : ValueType {
public IntPtr Version
public IntPtr Info
public IntPtr Retain
public IntPtr Release
public IntPtr CopyDescription
}
internal Mono.Net.CFUrl : CFObject {
public void .ctor(IntPtr handle, bool own)
private IntPtr CFURLCreateWithString(IntPtr allocator, IntPtr str, IntPtr baseURL)
public CFUrl Create(string absolute)
}
internal Mono.Net.Dns.DnsClass : Enum {
public ushort value__
public DnsClass Internet
public DnsClass IN
public DnsClass CSNET
public DnsClass CS
public DnsClass CHAOS
public DnsClass CH
public DnsClass Hesiod
public DnsClass HS
}
internal Mono.Net.Dns.DnsHeader : object {
public int DnsHeaderLength
private ArraySegment`1<byte> bytes
public ushort ID
public bool IsQuery
public DnsOpCode OpCode
public bool AuthoritativeAnswer
public bool Truncation
public bool RecursionDesired
public bool RecursionAvailable
public int ZReserved
public DnsRCode RCode
public ushort QuestionCount
public ushort AnswerCount
public ushort AuthorityCount
public ushort AdditionalCount
public void .ctor(Byte[] bytes)
public void .ctor(Byte[] bytes, int offset)
public void .ctor(ArraySegment`1<byte> segment)
public void Clear()
public ushort get_ID()
public void set_ID(ushort value)
public bool get_IsQuery()
public void set_IsQuery(bool value)
public DnsOpCode get_OpCode()
public void set_OpCode(DnsOpCode value)
public bool get_AuthoritativeAnswer()
public void set_AuthoritativeAnswer(bool value)
public bool get_Truncation()
public void set_Truncation(bool value)
public bool get_RecursionDesired()
public void set_RecursionDesired(bool value)
public bool get_RecursionAvailable()
public void set_RecursionAvailable(bool value)
public int get_ZReserved()
public void set_ZReserved(int value)
public DnsRCode get_RCode()
public void set_RCode(DnsRCode value)
private ushort GetUInt16(Byte[] bytes, int offset)
private void SetUInt16(Byte[] bytes, int offset, ushort val)
public ushort get_QuestionCount()
public void set_QuestionCount(ushort value)
public ushort get_AnswerCount()
public void set_AnswerCount(ushort value)
public ushort get_AuthorityCount()
public void set_AuthorityCount(ushort value)
public ushort get_AdditionalCount()
public void set_AdditionalCount(ushort value)
public string ToString()
}
internal Mono.Net.Dns.DnsOpCode : Enum {
public byte value__
public DnsOpCode Query
public DnsOpCode IQuery
public DnsOpCode Status
public DnsOpCode Notify
public DnsOpCode Update
}
internal Mono.Net.Dns.DnsPacket : object {
protected Byte[] packet
protected int position
protected DnsHeader header
public Byte[] Packet
public int Length
public DnsHeader Header
protected void .ctor(int length)
protected void .ctor(Byte[] buffer, int length)
public Byte[] get_Packet()
public int get_Length()
public DnsHeader get_Header()
protected void WriteUInt16(ushort v)
protected void WriteStringBytes(string str, int offset, int count)
protected void WriteLabel(string str, int offset, int count)
protected void WriteDnsName(string name)
protected internal string ReadName(Int32& offset)
protected internal string ReadName(Byte[] buffer, Int32& offset)
protected internal ushort ReadUInt16(Int32& offset)
protected internal int ReadInt32(Int32& offset)
}
internal Mono.Net.Dns.DnsQClass : Enum {
public ushort value__
public DnsQClass Internet
public DnsQClass IN
public DnsQClass CSNET
public DnsQClass CS
public DnsQClass CHAOS
public DnsQClass CH
public DnsQClass Hesiod
public DnsQClass HS
public DnsQClass None
public DnsQClass Any
}
internal Mono.Net.Dns.DnsQType : Enum {
public ushort value__
public DnsQType A
public DnsQType NS
public DnsQType MD
public DnsQType MF
public DnsQType CNAME
public DnsQType SOA
public DnsQType MB
public DnsQType MG
public DnsQType MR
public DnsQType NULL
public DnsQType WKS
public DnsQType PTR
public DnsQType HINFO
public DnsQType MINFO
public DnsQType MX
public DnsQType TXT
public DnsQType RP
public DnsQType AFSDB
public DnsQType X25
public DnsQType ISDN
public DnsQType RT
public DnsQType NSAP
public DnsQType NSAPPTR
public DnsQType SIG
public DnsQType KEY
public DnsQType PX
public DnsQType GPOS
public DnsQType AAAA
public DnsQType LOC
public DnsQType NXT
public DnsQType EID
public DnsQType NIMLOC
public DnsQType SRV
public DnsQType ATMA
public DnsQType NAPTR
public DnsQType KX
public DnsQType CERT
public DnsQType A6
public DnsQType DNAME
public DnsQType SINK
public DnsQType OPT
public DnsQType APL
public DnsQType DS
public DnsQType SSHFP
public DnsQType IPSECKEY
public DnsQType RRSIG
public DnsQType NSEC
public DnsQType DNSKEY
public DnsQType DHCID
public DnsQType NSEC3
public DnsQType NSEC3PARAM
public DnsQType HIP
public DnsQType NINFO
public DnsQType RKEY
public DnsQType TALINK
public DnsQType SPF
public DnsQType UINFO
public DnsQType UID
public DnsQType GID
public DnsQType UNSPEC
public DnsQType TKEY
public DnsQType TSIG
public DnsQType IXFR
public DnsQType AXFR
public DnsQType MAILB
public DnsQType MAILA
public DnsQType ALL
public DnsQType URI
public DnsQType TA
public DnsQType DLV
}
internal Mono.Net.Dns.DnsQuery : DnsPacket {
public void .ctor(string name, DnsQType qtype, DnsQClass qclass)
}
internal Mono.Net.Dns.DnsQuestion : object {
private string name
private DnsQType type
private DnsQClass _class
public string Name
public DnsQType Type
public DnsQClass Class
internal int Init(DnsPacket packet, int offset)
public string get_Name()
public DnsQType get_Type()
public DnsQClass get_Class()
public string ToString()
}
internal Mono.Net.Dns.DnsRCode : Enum {
public ushort value__
public DnsRCode NoError
public DnsRCode FormErr
public DnsRCode ServFail
public DnsRCode NXDomain
public DnsRCode NotImp
public DnsRCode Refused
public DnsRCode YXDomain
public DnsRCode YXRRSet
public DnsRCode NXRRSet
public DnsRCode NotAuth
public DnsRCode NotZone
public DnsRCode BadVers
public DnsRCode BadSig
public DnsRCode BadKey
public DnsRCode BadTime
public DnsRCode BadMode
public DnsRCode BadName
public DnsRCode BadAlg
public DnsRCode BadTrunc
}
internal Mono.Net.Dns.DnsResourceRecord : object {
private string name
private DnsType type
private DnsClass klass
private int ttl
private ushort rdlength
private ArraySegment`1<byte> m_rdata
public string Name
public DnsType Type
public DnsClass Class
public int Ttl
public ArraySegment`1<byte> Data
internal void CopyFrom(DnsResourceRecord rr)
internal DnsResourceRecord CreateFromBuffer(DnsPacket packet, int size, Int32& offset)
public string get_Name()
public DnsType get_Type()
public DnsClass get_Class()
public int get_Ttl()
public ArraySegment`1<byte> get_Data()
public string ToString()
}
internal Mono.Net.Dns.DnsResourceRecordA : DnsResourceRecordIPAddress {
internal void .ctor(DnsResourceRecord rr)
}
internal Mono.Net.Dns.DnsResourceRecordAAAA : DnsResourceRecordIPAddress {
internal void .ctor(DnsResourceRecord rr)
}
internal Mono.Net.Dns.DnsResourceRecordCName : DnsResourceRecord {
private string cname
public string CName
internal void .ctor(DnsResourceRecord rr)
public string get_CName()
public string ToString()
}
internal Mono.Net.Dns.DnsResourceRecordIPAddress : DnsResourceRecord {
private IPAddress address
public IPAddress Address
internal void .ctor(DnsResourceRecord rr, int address_size)
public string ToString()
public IPAddress get_Address()
}
internal Mono.Net.Dns.DnsResourceRecordPTR : DnsResourceRecord {
private string dname
public string DName
internal void .ctor(DnsResourceRecord rr)
public string get_DName()
public string ToString()
}
internal Mono.Net.Dns.DnsResponse : DnsPacket {
private ReadOnlyCollection`1<DnsResourceRecord> EmptyRR
private ReadOnlyCollection`1<DnsQuestion> EmptyQS
private ReadOnlyCollection`1<DnsQuestion> question
private ReadOnlyCollection`1<DnsResourceRecord> answer
private ReadOnlyCollection`1<DnsResourceRecord> authority
private ReadOnlyCollection`1<DnsResourceRecord> additional
private int offset
public void .ctor(Byte[] buffer, int length)
public void Reset()
private ReadOnlyCollection`1<DnsResourceRecord> GetRRs(int count)
private ReadOnlyCollection`1<DnsQuestion> GetQuestions(int count)
public ReadOnlyCollection`1<DnsQuestion> GetQuestions()
public ReadOnlyCollection`1<DnsResourceRecord> GetAnswers()
public ReadOnlyCollection`1<DnsResourceRecord> GetAuthority()
public ReadOnlyCollection`1<DnsResourceRecord> GetAdditional()
public string ToString()
}
internal Mono.Net.Dns.DnsType : Enum {
public ushort value__
public DnsType A
public DnsType NS
public DnsType MD
public DnsType MF
public DnsType CNAME
public DnsType SOA
public DnsType MB
public DnsType MG
public DnsType MR
public DnsType NULL
public DnsType WKS
public DnsType PTR
public DnsType HINFO
public DnsType MINFO
public DnsType MX
public DnsType TXT
public DnsType RP
public DnsType AFSDB
public DnsType X25
public DnsType ISDN
public DnsType RT
public DnsType NSAP
public DnsType NSAPPTR
public DnsType SIG
public DnsType KEY
public DnsType PX
public DnsType GPOS
public DnsType AAAA
public DnsType LOC
public DnsType NXT
public DnsType EID
public DnsType NIMLOC
public DnsType SRV
public DnsType ATMA
public DnsType NAPTR
public DnsType KX
public DnsType CERT
public DnsType A6
public DnsType DNAME
public DnsType SINK
public DnsType OPT
public DnsType APL
public DnsType DS
public DnsType SSHFP
public DnsType IPSECKEY
public DnsType RRSIG
public DnsType NSEC
public DnsType DNSKEY
public DnsType DHCID
public DnsType NSEC3
public DnsType NSEC3PARAM
public DnsType HIP
public DnsType NINFO
public DnsType RKEY
public DnsType TALINK
public DnsType SPF
public DnsType UINFO
public DnsType UID
public DnsType GID
public DnsType UNSPEC
public DnsType TKEY
public DnsType TSIG
public DnsType IXFR
public DnsType AXFR
public DnsType MAILB
public DnsType MAILA
public DnsType URI
public DnsType TA
public DnsType DLV
}
internal Mono.Net.Dns.DnsUtil : object {
public bool IsValidDnsName(string name)
public int GetEncodedLength(string name)
public int GetNameLength(Byte[] buffer)
public int GetNameLength(Byte[] buffer, int offset)
public string ReadName(Byte[] buffer, Int32& offset)
}
internal Mono.Net.Dns.ResolverAsyncOperation : Enum {
public int value__
public ResolverAsyncOperation None
public ResolverAsyncOperation GetHostEntry
public ResolverAsyncOperation GetHostAddresses
}
internal Mono.Net.Dns.ResolverError : Enum {
public int value__
public ResolverError NoError
public ResolverError FormatError
public ResolverError ServerFailure
public ResolverError NameError
public ResolverError NotImplemented
public ResolverError Refused
public ResolverError ResponseHeaderError
public ResolverError ResponseFormatError
public ResolverError Timeout
}
internal Mono.Net.Dns.SimpleResolver : object {
private String[] EmptyStrings
private IPAddress[] EmptyAddresses
private IPEndPoint[] endpoints
private Socket client
private Dictionary`2<int, SimpleResolverEventArgs> queries
private AsyncCallback receive_cb
private TimerCallback timeout_cb
private bool disposed
private void System.IDisposable.Dispose()
public void Close()
private void GetLocalHost(SimpleResolverEventArgs args)
public bool GetHostAddressesAsync(SimpleResolverEventArgs args)
public bool GetHostEntryAsync(SimpleResolverEventArgs args)
private bool AddQuery(DnsQuery query, SimpleResolverEventArgs args)
private DnsQuery GetQuery(string host, DnsQType q, DnsQClass c)
private void SendAQuery(SimpleResolverEventArgs args, bool add_it)
private void SendAQuery(SimpleResolverEventArgs args, string host, bool add_it)
private string GetPTRName(IPAddress address)
private void SendPTRQuery(SimpleResolverEventArgs args, bool add_it)
private void SendQuery(SimpleResolverEventArgs args, DnsQuery query, bool add_it)
private Byte[] GetFreshBuffer()
private void FreeBuffer(Byte[] buffer)
private void InitSocket()
private void BeginReceive()
private void OnTimeout(object obj)
private void OnReceive(IAsyncResult ares)
private void ProcessResponse(SimpleResolverEventArgs args, DnsResponse response, EndPoint server_ep)
private void InitFromSystem()
}
internal Mono.Net.Dns.SimpleResolverEventArgs : EventArgs {
private EventHandler`1<SimpleResolverEventArgs> Completed
private ResolverError <ResolverError>k__BackingField
private string <ErrorMessage>k__BackingField
public ResolverAsyncOperation LastOperation
private string <HostName>k__BackingField
private IPHostEntry <HostEntry>k__BackingField
private object <UserToken>k__BackingField
internal ushort QueryID
internal ushort Retries
internal Timer Timer
internal IPAddress PTRAddress
public ResolverError ResolverError
public string ErrorMessage
public string HostName
public IPHostEntry HostEntry
public object UserToken
public void add_Completed(EventHandler`1<SimpleResolverEventArgs> value)
public void remove_Completed(EventHandler`1<SimpleResolverEventArgs> value)
public ResolverError get_ResolverError()
public void set_ResolverError(ResolverError value)
public string get_ErrorMessage()
public void set_ErrorMessage(string value)
public string get_HostName()
public void set_HostName(string value)
public IPHostEntry get_HostEntry()
internal void set_HostEntry(IPHostEntry value)
public object get_UserToken()
public void set_UserToken(object value)
internal void Reset(ResolverAsyncOperation op)
protected internal void OnCompleted(object sender)
}
internal Mono.Net.Security.AsyncHandshakeRequest : AsyncProtocolRequest {
public void .ctor(MobileAuthenticatedStream parent, bool sync)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
}
internal Mono.Net.Security.AsyncOperationStatus : Enum {
public int value__
public AsyncOperationStatus Initialize
public AsyncOperationStatus Continue
public AsyncOperationStatus ReadDone
public AsyncOperationStatus Complete
}
internal Mono.Net.Security.AsyncProtocolRequest : object {
private MobileAuthenticatedStream <Parent>k__BackingField
private bool <RunSynchronously>k__BackingField
private int <UserResult>k__BackingField
private int Started
private int RequestedSize
private int WriteRequested
private object locker
private int next_id
public MobileAuthenticatedStream Parent
public bool RunSynchronously
public int ID
public string Name
public int UserResult
public MobileAuthenticatedStream get_Parent()
public bool get_RunSynchronously()
public int get_ID()
public string get_Name()
public int get_UserResult()
protected void set_UserResult(int value)
public void .ctor(MobileAuthenticatedStream parent, bool sync)
protected void Debug(string message, Object[] args)
internal void RequestRead(int size)
internal void RequestWrite()
internal Task`1<AsyncProtocolResult> StartOperation(CancellationToken cancellationToken)
private Task ProcessOperation(CancellationToken cancellationToken)
private Task`1<Nullable`1<int>> InnerRead(CancellationToken cancellationToken)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
public string ToString()
}
internal Mono.Net.Security.AsyncProtocolResult : object {
private int <UserResult>k__BackingField
private ExceptionDispatchInfo <Error>k__BackingField
public int UserResult
public ExceptionDispatchInfo Error
public int get_UserResult()
public ExceptionDispatchInfo get_Error()
public void .ctor(int result)
public void .ctor(ExceptionDispatchInfo error)
}
internal Mono.Net.Security.AsyncReadOrWriteRequest : AsyncProtocolRequest {
private BufferOffsetSize <UserBuffer>k__BackingField
private int <CurrentSize>k__BackingField
protected BufferOffsetSize UserBuffer
protected int CurrentSize
protected BufferOffsetSize get_UserBuffer()
protected int get_CurrentSize()
protected void set_CurrentSize(int value)
public void .ctor(MobileAuthenticatedStream parent, bool sync, Byte[] buffer, int offset, int size)
public string ToString()
}
internal Mono.Net.Security.AsyncReadRequest : AsyncReadOrWriteRequest {
public void .ctor(MobileAuthenticatedStream parent, bool sync, Byte[] buffer, int offset, int size)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
}
internal Mono.Net.Security.AsyncRenegotiateRequest : AsyncProtocolRequest {
public void .ctor(MobileAuthenticatedStream parent)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
}
internal Mono.Net.Security.AsyncShutdownRequest : AsyncProtocolRequest {
public void .ctor(MobileAuthenticatedStream parent)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
}
internal Mono.Net.Security.AsyncWriteRequest : AsyncReadOrWriteRequest {
public void .ctor(MobileAuthenticatedStream parent, bool sync, Byte[] buffer, int offset, int size)
protected AsyncOperationStatus Run(AsyncOperationStatus status)
}
internal Mono.Net.Security.BufferOffsetSize : object {
public Byte[] Buffer
public int Offset
public int Size
public int TotalBytes
public bool Complete
public int EndOffset
public int Remaining
public int get_EndOffset()
public int get_Remaining()
public void .ctor(Byte[] buffer, int offset, int size)
public string ToString()
}
internal Mono.Net.Security.BufferOffsetSize2 : BufferOffsetSize {
public int InitialSize
public void .ctor(int size)
public void Reset()
public void MakeRoom(int size)
public void AppendData(Byte[] buffer, int offset, int size)
}
internal Mono.Net.Security.ChainValidationHelper : object {
private WeakReference`1<SslStream> owner
private MonoTlsSettings settings
private MobileTlsProvider provider
private ServerCertValidationCallback certValidationCallback
private LocalCertSelectionCallback certSelectionCallback
private MonoTlsStream tlsStream
private HttpWebRequest request
public MonoTlsProvider Provider
public MonoTlsSettings Settings
public bool HasCertificateSelectionCallback
internal ChainValidationHelper GetInternalValidator(SslStream owner, MobileTlsProvider provider, MonoTlsSettings settings)
internal ICertificateValidator GetDefaultValidator(MonoTlsSettings settings)
internal ChainValidationHelper Create(MobileTlsProvider provider, MonoTlsSettings& settings, MonoTlsStream stream)
private void .ctor(SslStream owner, MobileTlsProvider provider, MonoTlsSettings settings, bool cloneSettings, MonoTlsStream stream)
private ServerCertValidationCallback GetValidationCallback(MonoTlsSettings settings)
private X509Certificate DefaultSelectionCallback(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
public MonoTlsProvider get_Provider()
public MonoTlsSettings get_Settings()
public bool get_HasCertificateSelectionCallback()
public bool SelectClientCertificate(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, X509Certificate& clientCertificate)
internal X509Certificate SelectClientCertificate(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
internal bool ValidateClientCertificate(X509Certificate certificate, MonoSslPolicyErrors errors)
public ValidationResult ValidateCertificate(string host, bool serverMode, X509CertificateCollection certs)
public ValidationResult ValidateCertificate(string host, bool serverMode, X509Certificate leaf, X509Chain chain)
private ValidationResult ValidateChain(string host, bool server, X509Certificate leaf, X509Chain chain, X509CertificateCollection certs, SslPolicyErrors errors)
private ValidationResult ValidateChain(string host, bool server, X509Certificate leaf, X509Chain& chain, X509CertificateCollection certs, SslPolicyErrors errors)
private bool InvokeCallback(X509Certificate leaf, X509Chain chain, SslPolicyErrors errors)
private bool InvokeSystemValidator(string targetHost, bool serverMode, X509CertificateCollection certificates, X509Chain chain, MonoSslPolicyErrors& xerrors, Int32& status11)
}
internal Mono.Net.Security.MobileAuthenticatedStream : AuthenticatedStream {
private MobileTlsContext xobileTlsContext
private ExceptionDispatchInfo lastException
private AsyncProtocolRequest asyncHandshakeRequest
private AsyncProtocolRequest asyncReadRequest
private AsyncProtocolRequest asyncWriteRequest
private BufferOffsetSize2 readBuffer
private BufferOffsetSize2 writeBuffer
private object ioLock
private int closeRequested
private bool shutdown
private Operation operation
private int uniqueNameInteger
private SslStream <SslStream>k__BackingField
private MonoTlsSettings <Settings>k__BackingField
private MobileTlsProvider <Provider>k__BackingField
private string <TargetHost>k__BackingField
private int nextId
internal int ID
public SslStream SslStream
public MonoTlsSettings Settings
public MobileTlsProvider Provider
private MonoTlsProvider Mono.Security.Interface.IMonoSslStream.Provider
internal bool HasContext
internal string TargetHost
public AuthenticatedStream AuthenticatedStream
public bool CanRenegotiate
public bool IsServer
public bool IsAuthenticated
public bool IsMutuallyAuthenticated
public SslProtocols SslProtocol
public X509Certificate RemoteCertificate
public X509Certificate LocalCertificate
public X509Certificate InternalLocalCertificate
public TransportContext TransportContext
public bool CanRead
public bool CanTimeout
public bool CanWrite
public bool CanSeek
public long Length
public long Position
public bool IsEncrypted
public bool IsSigned
public int ReadTimeout
public int WriteTimeout
public CipherAlgorithmType CipherAlgorithm
public HashAlgorithmType HashAlgorithm
public ExchangeAlgorithmType KeyExchangeAlgorithm
public int CipherStrength
public int HashStrength
public int KeyExchangeStrength
public bool CheckCertRevocationStatus
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MobileTlsProvider provider)
public SslStream get_SslStream()
public MonoTlsSettings get_Settings()
public MobileTlsProvider get_Provider()
private MonoTlsProvider Mono.Security.Interface.IMonoSslStream.get_Provider()
internal bool get_HasContext()
internal string get_TargetHost()
private void set_TargetHost(string value)
internal void CheckThrow(bool authSuccessCheck, bool shutdownCheck)
internal Exception GetSSPIException(Exception e)
internal Exception GetIOException(Exception e, string message)
internal Exception GetRenegotiationException(string message)
internal Exception GetInternalError()
internal Exception GetInvalidNestedCallException()
internal ExceptionDispatchInfo SetException(Exception e)
public void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task AuthenticateAsClientAsync(IMonoSslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task AuthenticateAsServerAsync(IMonoSslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken)
public Task ShutdownAsync()
public AuthenticatedStream get_AuthenticatedStream()
private Task ProcessAuthentication(bool runSynchronously, MonoSslAuthenticationOptions options, CancellationToken cancellationToken)
protected MobileTlsContext CreateContext(MonoSslAuthenticationOptions options)
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public bool get_CanRenegotiate()
public Task RenegotiateAsync(CancellationToken cancellationToken)
private Task`1<int> StartOperation(OperationType type, AsyncProtocolRequest asyncRequest, CancellationToken cancellationToken)
protected internal void Debug(string format, Object[] args)
protected internal void Debug(string message)
internal int InternalRead(Byte[] buffer, int offset, int size, Boolean& outWantMore)
private ValueTuple`2<int, bool> InternalRead(AsyncProtocolRequest asyncRequest, BufferOffsetSize internalBuffer, Byte[] buffer, int offset, int size)
internal bool InternalWrite(Byte[] buffer, int offset, int size)
private bool InternalWrite(AsyncProtocolRequest asyncRequest, BufferOffsetSize2 internalBuffer, Byte[] buffer, int offset, int size)
internal Task`1<int> InnerRead(bool sync, int requestedSize, CancellationToken cancellationToken)
internal Task InnerWrite(bool sync, CancellationToken cancellationToken)
internal AsyncOperationStatus ProcessHandshake(AsyncOperationStatus status, bool renegotiate)
internal ValueTuple`2<int, bool> ProcessRead(BufferOffsetSize userBuffer)
internal ValueTuple`2<int, bool> ProcessWrite(BufferOffsetSize userBuffer)
internal AsyncOperationStatus ProcessShutdown(AsyncOperationStatus status)
public bool get_IsServer()
public bool get_IsAuthenticated()
public bool get_IsMutuallyAuthenticated()
protected void Dispose(bool disposing)
public void Flush()
public SslProtocols get_SslProtocol()
public X509Certificate get_RemoteCertificate()
public X509Certificate get_LocalCertificate()
public X509Certificate get_InternalLocalCertificate()
public MonoTlsConnectionInfo GetConnectionInfo()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public TransportContext get_TransportContext()
public bool get_CanRead()
public bool get_CanTimeout()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_IsEncrypted()
public bool get_IsSigned()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public CipherAlgorithmType get_CipherAlgorithm()
public HashAlgorithmType get_HashAlgorithm()
public ExchangeAlgorithmType get_KeyExchangeAlgorithm()
public int get_CipherStrength()
public int get_HashStrength()
public int get_KeyExchangeStrength()
public bool get_CheckCertRevocationStatus()
private void <InnerWrite>b__67_0()
}
internal Mono.Net.Security.MobileTlsContext : object {
private ChainValidationHelper certificateValidator
private MonoSslAuthenticationOptions <Options>k__BackingField
private MobileAuthenticatedStream <Parent>k__BackingField
private bool <IsServer>k__BackingField
private string <TargetHost>k__BackingField
private string <ServerName>k__BackingField
private bool <AskForClientCertificate>k__BackingField
private SslProtocols <EnabledProtocols>k__BackingField
private X509CertificateCollection <ClientCertificates>k__BackingField
private X509Certificate <LocalServerCertificate>k__BackingField
internal MonoSslAuthenticationOptions Options
internal MobileAuthenticatedStream Parent
public MonoTlsSettings Settings
public MonoTlsProvider Provider
public bool HasContext
public bool IsAuthenticated
public bool IsServer
internal string TargetHost
protected string ServerName
protected bool AskForClientCertificate
protected SslProtocols EnabledProtocols
protected X509CertificateCollection ClientCertificates
internal bool AllowRenegotiation
public MonoTlsConnectionInfo ConnectionInfo
internal X509Certificate LocalServerCertificate
internal bool IsRemoteCertificateAvailable
internal X509Certificate LocalClientCertificate
public X509Certificate2 RemoteCertificate
public TlsProtocols NegotiatedProtocol
public bool CanRenegotiate
protected void .ctor(MobileAuthenticatedStream parent, MonoSslAuthenticationOptions options)
internal MonoSslAuthenticationOptions get_Options()
internal MobileAuthenticatedStream get_Parent()
public MonoTlsSettings get_Settings()
public MonoTlsProvider get_Provider()
protected void Debug(string message, Object[] args)
public bool get_HasContext()
public bool get_IsAuthenticated()
public bool get_IsServer()
internal string get_TargetHost()
protected string get_ServerName()
protected bool get_AskForClientCertificate()
protected SslProtocols get_EnabledProtocols()
protected X509CertificateCollection get_ClientCertificates()
internal bool get_AllowRenegotiation()
protected void GetProtocolVersions(Nullable`1& min, Nullable`1& max)
public void StartHandshake()
public bool ProcessHandshake()
public void FinishHandshake()
public MonoTlsConnectionInfo get_ConnectionInfo()
internal X509Certificate get_LocalServerCertificate()
private void set_LocalServerCertificate(X509Certificate value)
internal bool get_IsRemoteCertificateAvailable()
internal X509Certificate get_LocalClientCertificate()
public X509Certificate2 get_RemoteCertificate()
public TlsProtocols get_NegotiatedProtocol()
public void Flush()
public ValueTuple`2<int, bool> Read(Byte[] buffer, int offset, int count)
public ValueTuple`2<int, bool> Write(Byte[] buffer, int offset, int count)
public void Shutdown()
public bool PendingRenegotiation()
protected bool ValidateCertificate(X509Certificate2 leaf, X509Chain chain)
protected bool ValidateCertificate(X509Certificate2Collection certificates)
protected X509Certificate SelectServerCertificate(string serverIdentity)
protected X509Certificate SelectClientCertificate(String[] acceptableIssuers)
public bool get_CanRenegotiate()
public void Renegotiate()
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
internal Mono.Net.Security.MobileTlsProvider : MonoTlsProvider {
public IMonoSslStream CreateSslStream(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
internal MobileAuthenticatedStream CreateSslStream(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
internal bool ValidateCertificate(ChainValidationHelper validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain& chain, SslPolicyErrors& errors, Int32& status11)
}
internal Mono.Net.Security.MonoSslAuthenticationOptions : object {
private ServerCertSelectionCallback <ServerCertSelectionDelegate>k__BackingField
public bool ServerMode
public bool AllowRenegotiation
public RemoteCertificateValidationCallback RemoteCertificateValidationCallback
public SslProtocols EnabledSslProtocols
public EncryptionPolicy EncryptionPolicy
public X509RevocationMode CertificateRevocationCheckMode
public string TargetHost
public X509Certificate ServerCertificate
public X509CertificateCollection ClientCertificates
public bool ClientCertificateRequired
internal ServerCertSelectionCallback ServerCertSelectionDelegate
public bool get_ServerMode()
public bool get_AllowRenegotiation()
public void set_AllowRenegotiation(bool value)
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value)
public SslProtocols get_EnabledSslProtocols()
public void set_EnabledSslProtocols(SslProtocols value)
public EncryptionPolicy get_EncryptionPolicy()
public void set_EncryptionPolicy(EncryptionPolicy value)
public X509RevocationMode get_CertificateRevocationCheckMode()
public void set_CertificateRevocationCheckMode(X509RevocationMode value)
public string get_TargetHost()
public void set_TargetHost(string value)
public X509Certificate get_ServerCertificate()
public void set_ServerCertificate(X509Certificate value)
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public bool get_ClientCertificateRequired()
public void set_ClientCertificateRequired(bool value)
internal ServerCertSelectionCallback get_ServerCertSelectionDelegate()
internal void set_ServerCertSelectionDelegate(ServerCertSelectionCallback value)
}
internal Mono.Net.Security.MonoSslClientAuthenticationOptions : MonoSslAuthenticationOptions {
private SslClientAuthenticationOptions <Options>k__BackingField
public SslClientAuthenticationOptions Options
public bool ServerMode
public bool AllowRenegotiation
public RemoteCertificateValidationCallback RemoteCertificateValidationCallback
public X509RevocationMode CertificateRevocationCheckMode
public EncryptionPolicy EncryptionPolicy
public SslProtocols EnabledSslProtocols
public LocalCertificateSelectionCallback LocalCertificateSelectionCallback
public string TargetHost
public bool ClientCertificateRequired
public X509CertificateCollection ClientCertificates
public X509Certificate ServerCertificate
public SslClientAuthenticationOptions get_Options()
public bool get_ServerMode()
public void .ctor(SslClientAuthenticationOptions options)
public bool get_AllowRenegotiation()
public void set_AllowRenegotiation(bool value)
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value)
public X509RevocationMode get_CertificateRevocationCheckMode()
public void set_CertificateRevocationCheckMode(X509RevocationMode value)
public EncryptionPolicy get_EncryptionPolicy()
public void set_EncryptionPolicy(EncryptionPolicy value)
public SslProtocols get_EnabledSslProtocols()
public void set_EnabledSslProtocols(SslProtocols value)
public LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback()
public void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value)
public string get_TargetHost()
public void set_TargetHost(string value)
public bool get_ClientCertificateRequired()
public void set_ClientCertificateRequired(bool value)
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public X509Certificate get_ServerCertificate()
public void set_ServerCertificate(X509Certificate value)
}
internal Mono.Net.Security.MonoSslServerAuthenticationOptions : MonoSslAuthenticationOptions {
private SslServerAuthenticationOptions <Options>k__BackingField
public SslServerAuthenticationOptions Options
public bool ServerMode
public bool AllowRenegotiation
public RemoteCertificateValidationCallback RemoteCertificateValidationCallback
public X509RevocationMode CertificateRevocationCheckMode
public EncryptionPolicy EncryptionPolicy
public SslProtocols EnabledSslProtocols
public bool ClientCertificateRequired
public ServerCertificateSelectionCallback ServerCertificateSelectionCallback
private MonoServerCertificateSelectionCallback Mono.Security.Interface.IMonoSslServerAuthenticationOptions.ServerCertificateSelectionCallback
public string TargetHost
public X509Certificate ServerCertificate
public X509CertificateCollection ClientCertificates
public SslServerAuthenticationOptions get_Options()
public bool get_ServerMode()
public void .ctor(SslServerAuthenticationOptions options)
public bool get_AllowRenegotiation()
public void set_AllowRenegotiation(bool value)
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value)
public X509RevocationMode get_CertificateRevocationCheckMode()
public void set_CertificateRevocationCheckMode(X509RevocationMode value)
public EncryptionPolicy get_EncryptionPolicy()
public void set_EncryptionPolicy(EncryptionPolicy value)
public SslProtocols get_EnabledSslProtocols()
public void set_EnabledSslProtocols(SslProtocols value)
public bool get_ClientCertificateRequired()
public void set_ClientCertificateRequired(bool value)
public ServerCertificateSelectionCallback get_ServerCertificateSelectionCallback()
public void set_ServerCertificateSelectionCallback(ServerCertificateSelectionCallback value)
private MonoServerCertificateSelectionCallback Mono.Security.Interface.IMonoSslServerAuthenticationOptions.get_ServerCertificateSelectionCallback()
private void Mono.Security.Interface.IMonoSslServerAuthenticationOptions.set_ServerCertificateSelectionCallback(MonoServerCertificateSelectionCallback value)
public string get_TargetHost()
public void set_TargetHost(string value)
public X509Certificate get_ServerCertificate()
public void set_ServerCertificate(X509Certificate value)
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
}
internal Mono.Net.Security.MonoTlsProviderFactory : object {
private object locker
private bool initialized
private MobileTlsProvider defaultProvider
private Dictionary`2<string, Tuple`2<Guid, string>> providerRegistration
private Dictionary`2<Guid, MobileTlsProvider> providerCache
private bool enableDebug
internal Guid UnityTlsId
internal Guid AppleTlsId
internal Guid BtlsId
internal bool IsInitialized
internal MobileTlsProvider GetProviderInternal()
internal void InitializeInternal()
internal void InitializeInternal(string provider)
private Type LookupProviderType(string name, bool throwOnError)
private MobileTlsProvider LookupProvider(string name, bool throwOnError)
private void InitializeDebug()
internal void Debug(string message, Object[] args)
private void InitializeProviderRegistration()
private void PopulateUnityProviders()
private void PopulateProviders()
internal bool IsBtlsSupported()
private MobileTlsProvider CreateDefaultProviderImpl()
internal MobileTlsProvider GetProvider()
internal bool IsProviderSupported(string name)
internal MobileTlsProvider GetProvider(string name)
internal bool get_IsInitialized()
internal void Initialize()
internal void Initialize(string provider)
}
internal Mono.Net.Security.MonoTlsStream : object {
private MobileTlsProvider provider
private NetworkStream networkStream
private HttpWebRequest request
private MonoTlsSettings settings
private SslStream sslStream
private object sslStreamLock
private WebExceptionStatus status
private bool <CertificateValidationFailed>k__BackingField
internal HttpWebRequest Request
internal SslStream SslStream
internal WebExceptionStatus ExceptionStatus
internal bool CertificateValidationFailed
internal HttpWebRequest get_Request()
internal SslStream get_SslStream()
internal WebExceptionStatus get_ExceptionStatus()
internal bool get_CertificateValidationFailed()
internal void set_CertificateValidationFailed(bool value)
public void .ctor(HttpWebRequest request, NetworkStream networkStream)
internal Task`1<Stream> CreateStream(WebConnectionTunnel tunnel, CancellationToken cancellationToken)
public void Dispose()
private void CloseSslStream()
}
internal Mono.Net.Security.NoReflectionHelper : object {
internal bool IsInitialized
internal object GetDefaultValidator(object settings)
internal object GetProvider()
internal bool get_IsInitialized()
internal void Initialize()
internal void Initialize(string provider)
internal HttpWebRequest CreateHttpsRequest(Uri requestUri, object provider, object settings)
internal object CreateHttpListener(object certificate, object provider, object settings)
internal object GetMonoSslStream(SslStream stream)
internal object GetMonoSslStream(HttpListenerContext context)
internal bool IsProviderSupported(string name)
internal object GetProvider(string name)
}
internal Mono.Net.Security.Private.CallbackHelpers : object {
internal MonoRemoteCertificateValidationCallback PublicToMono(RemoteCertificateValidationCallback callback)
internal MonoRemoteCertificateValidationCallback InternalToMono(RemoteCertValidationCallback callback)
internal RemoteCertificateValidationCallback InternalToPublic(string hostname, RemoteCertValidationCallback callback)
internal MonoLocalCertificateSelectionCallback InternalToMono(LocalCertSelectionCallback callback)
internal LocalCertificateSelectionCallback MonoToPublic(MonoLocalCertificateSelectionCallback callback)
internal RemoteCertValidationCallback MonoToInternal(MonoRemoteCertificateValidationCallback callback)
internal LocalCertSelectionCallback MonoToInternal(MonoLocalCertificateSelectionCallback callback)
internal ServerCertificateSelectionCallback MonoToPublic(MonoServerCertificateSelectionCallback callback)
internal MonoServerCertificateSelectionCallback PublicToMono(ServerCertificateSelectionCallback callback)
}
internal Mono.Net.Security.ServerCertValidationCallbackWrapper : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(ServerCertValidationCallback callback, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors)
public IAsyncResult BeginInvoke(ServerCertValidationCallback callback, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors, AsyncCallback __callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal Mono.Net.Security.SystemCertificateValidator : object {
private bool is_macosx
private X509RevocationMode revocation_mode
private X509KeyUsageFlags s_flags
public X509Chain CreateX509Chain(X509CertificateCollection certs)
private bool BuildX509Chain(X509CertificateCollection certs, X509Chain chain, SslPolicyErrors& errors, Int32& status11)
private bool CheckUsage(X509CertificateCollection certs, string host, SslPolicyErrors& errors, Int32& status11)
private bool EvaluateSystem(X509CertificateCollection certs, X509CertificateCollection anchors, string host, X509Chain chain, SslPolicyErrors& errors, Int32& status11)
public bool Evaluate(MonoTlsSettings settings, string host, X509CertificateCollection certs, X509Chain chain, SslPolicyErrors& errors, Int32& status11)
internal bool NeedsChain(MonoTlsSettings settings)
private int GetStatusFromChain(X509Chain chain)
private SslPolicyErrors GetErrorsFromChain(X509Chain chain)
private bool CheckCertificateUsage(X509Certificate2 cert)
private bool CheckServerIdentity(X509Certificate2 cert, string targetHost)
private bool CheckDomainName(string subjectName, string targetHost)
private bool Match(string hostname, string pattern)
}
internal Mono.SystemCertificateProvider : object {
private MonoTlsProvider provider
private int initialized
private X509PalImpl x509pal
private object syncRoot
public MonoTlsProvider Provider
public X509PalImpl X509Pal
public MonoTlsProvider get_Provider()
private X509PalImpl GetX509Pal()
private void EnsureInitialized()
public X509PalImpl get_X509Pal()
public X509CertificateImpl Import(Byte[] data, CertificateImportFlags importFlags)
private X509CertificateImpl Mono.ISystemCertificateProvider.Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags, CertificateImportFlags importFlags)
public X509Certificate2Impl Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags, CertificateImportFlags importFlags)
private X509CertificateImpl Mono.ISystemCertificateProvider.Import(X509Certificate cert, CertificateImportFlags importFlags)
public X509Certificate2Impl Import(X509Certificate cert, CertificateImportFlags importFlags)
}
internal Mono.SystemDependencyProvider : object {
private SystemDependencyProvider instance
private object syncRoot
private SystemCertificateProvider <CertificateProvider>k__BackingField
public SystemDependencyProvider Instance
private ISystemCertificateProvider Mono.ISystemDependencyProvider.CertificateProvider
public SystemCertificateProvider CertificateProvider
public X509PalImpl X509Pal
public SystemDependencyProvider get_Instance()
internal void Initialize()
private ISystemCertificateProvider Mono.ISystemDependencyProvider.get_CertificateProvider()
public SystemCertificateProvider get_CertificateProvider()
public X509PalImpl get_X509Pal()
}
internal Mono.Unity.CertHelper : object {
public void AddCertificatesToNativeChain(unitytls_x509list* nativeCertificateChain, X509CertificateCollection certificates, unitytls_errorstate* errorState)
public void AddCertificateToNativeChain(unitytls_x509list* nativeCertificateChain, X509Certificate certificate, unitytls_errorstate* errorState)
}
internal Mono.Unity.Debug : object {
public void CheckAndThrow(unitytls_errorstate errorState, string context, AlertDescription defaultAlert)
public void CheckAndThrow(unitytls_errorstate errorState, unitytls_x509verify_result verifyResult, string context, AlertDescription defaultAlert)
}
internal Mono.Unity.UnityTls : object {
private unitytls_interface_struct marshalledInterface
public bool IsSupported
public unitytls_interface_struct NativeInterface
private IntPtr GetUnityTlsInterface()
public bool get_IsSupported()
public unitytls_interface_struct get_NativeInterface()
}
internal Mono.Unity.UnityTlsContext : MobileTlsContext {
private bool ActivateTracing
private unitytls_tlsctx* tlsContext
private unitytls_x509list* requestedClientCertChain
private unitytls_key* requestedClientKey
private unitytls_tlsctx_read_callback readCallback
private unitytls_tlsctx_write_callback writeCallback
private unitytls_tlsctx_trace_callback traceCallback
private unitytls_tlsctx_certificate_callback certificateCallback
private unitytls_tlsctx_x509verify_callback verifyCallback
private X509Certificate localClientCertificate
private X509Certificate2 remoteCertificate
private MonoTlsConnectionInfo connectioninfo
private bool isAuthenticated
private bool hasContext
private bool closedGraceful
private Byte[] writeBuffer
private Byte[] readBuffer
private GCHandle handle
private Exception lastException
public bool HasContext
public bool IsAuthenticated
public MonoTlsConnectionInfo ConnectionInfo
internal bool IsRemoteCertificateAvailable
internal X509Certificate LocalClientCertificate
public X509Certificate2 RemoteCertificate
public TlsProtocols NegotiatedProtocol
public bool CanRenegotiate
public void .ctor(MobileAuthenticatedStream parent, MonoSslAuthenticationOptions options)
private void ExtractNativeKeyAndChainFromManagedCertificate(X509Certificate cert, unitytls_errorstate* errorState, unitytls_x509list*& nativeCertChain, unitytls_key*& nativeKey)
public bool get_HasContext()
public bool get_IsAuthenticated()
public MonoTlsConnectionInfo get_ConnectionInfo()
internal bool get_IsRemoteCertificateAvailable()
internal X509Certificate get_LocalClientCertificate()
public X509Certificate2 get_RemoteCertificate()
public TlsProtocols get_NegotiatedProtocol()
public void Flush()
public ValueTuple`2<int, bool> Read(Byte[] buffer, int offset, int count)
public ValueTuple`2<int, bool> Write(Byte[] buffer, int offset, int count)
public bool get_CanRenegotiate()
public void Renegotiate()
public bool PendingRenegotiation()
public void Shutdown()
protected void Dispose(bool disposing)
public void StartHandshake()
public bool ProcessHandshake()
public void FinishHandshake()
private IntPtr WriteCallback(Void* userData, Byte* data, IntPtr bufferLen, unitytls_errorstate* errorState)
private IntPtr WriteCallback(Byte* data, IntPtr bufferLen, unitytls_errorstate* errorState)
private IntPtr ReadCallback(Void* userData, Byte* buffer, IntPtr bufferLen, unitytls_errorstate* errorState)
private IntPtr ReadCallback(Byte* buffer, IntPtr bufferLen, unitytls_errorstate* errorState)
private unitytls_x509verify_result VerifyCallback(Void* userData, unitytls_x509list_ref chain, unitytls_errorstate* errorState)
private unitytls_x509verify_result VerifyCallback(unitytls_x509list_ref chain, unitytls_errorstate* errorState)
private void CertificateCallback(Void* userData, unitytls_tlsctx* ctx, Byte* cn, IntPtr cnLen, unitytls_x509name* caList, IntPtr caListLen, unitytls_x509list_ref* chain, unitytls_key_ref* key, unitytls_errorstate* errorState)
private void CertificateCallback(unitytls_tlsctx* ctx, Byte* cn, IntPtr cnLen, unitytls_x509name* caList, IntPtr caListLen, unitytls_x509list_ref* chain, unitytls_key_ref* key, unitytls_errorstate* errorState)
private void TraceCallback(Void* userData, unitytls_tlsctx* ctx, Byte* traceMessage, IntPtr traceMessageLen)
}
internal Mono.Unity.UnityTlsConversions : object {
public unitytls_protocol GetMinProtocol(SslProtocols protocols)
public unitytls_protocol GetMaxProtocol(SslProtocols protocols)
public TlsProtocols ConvertProtocolVersion(unitytls_protocol protocol)
public AlertDescription VerifyResultToAlertDescription(unitytls_x509verify_result verifyResult, AlertDescription defaultAlert)
public SslPolicyErrors VerifyResultToPolicyErrror(unitytls_x509verify_result verifyResult)
public X509ChainStatusFlags VerifyResultToChainStatus(unitytls_x509verify_result verifyResult)
}
internal Mono.Unity.UnityTlsProvider : MobileTlsProvider {
public string Name
public Guid ID
public bool SupportsSslStream
public bool SupportsMonoExtensions
public bool SupportsConnectionInfo
internal bool SupportsCleanShutdown
public SslProtocols SupportedProtocols
public string get_Name()
public Guid get_ID()
public bool get_SupportsSslStream()
public bool get_SupportsMonoExtensions()
public bool get_SupportsConnectionInfo()
internal bool get_SupportsCleanShutdown()
public SslProtocols get_SupportedProtocols()
internal MobileAuthenticatedStream CreateSslStream(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings)
private unitytls_x509verify_result x509verify_callback(Void* userData, unitytls_x509_ref cert, unitytls_x509verify_result result, unitytls_errorstate* errorState)
internal bool ValidateCertificate(ChainValidationHelper validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain& chain, SslPolicyErrors& errors, Int32& status11)
}
internal Mono.Unity.UnityTlsStream : MobileAuthenticatedStream {
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MobileTlsProvider provider)
protected MobileTlsContext CreateContext(MonoSslAuthenticationOptions options)
}
internal Mono.Unity.X509ChainImplUnityTls : X509ChainImpl {
private X509ChainElementCollection elements
private unitytls_x509list* ownedList
private unitytls_x509list_ref nativeCertificateChain
private X509ChainPolicy policy
private List`1<X509ChainStatus> chainStatusList
private bool reverseOrder
public bool IsValid
public IntPtr Handle
internal unitytls_x509list_ref NativeCertificateChain
public X509ChainElementCollection ChainElements
public X509ChainPolicy ChainPolicy
public X509ChainStatus[] ChainStatus
internal void .ctor(unitytls_x509list_ref nativeCertificateChain, bool reverseOrder)
internal void .ctor(unitytls_x509list* ownedList, unitytls_errorstate* errorState, bool reverseOrder)
public bool get_IsValid()
public IntPtr get_Handle()
internal unitytls_x509list_ref get_NativeCertificateChain()
public X509ChainElementCollection get_ChainElements()
public void AddStatus(X509ChainStatusFlags error)
public X509ChainPolicy get_ChainPolicy()
public void set_ChainPolicy(X509ChainPolicy value)
public X509ChainStatus[] get_ChainStatus()
public bool Build(X509Certificate2 certificate)
public void Reset()
protected void Dispose(bool disposing)
}
internal Mono.Util.MonoPInvokeCallbackAttribute : Attribute {
public void .ctor(Type t)
}
internal Mono.X509Pal : object {
public X509PalImpl Instance
public X509PalImpl get_Instance()
}
internal Mono.X509PalImpl : object {
private Byte[] signedData
public bool SupportsLegacyBasicConstraintsExtension
public X509CertificateImpl Import(Byte[] data)
public X509Certificate2Impl Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
public X509Certificate2Impl Import(X509Certificate cert)
private Byte[] PEM(string type, Byte[] data)
protected Byte[] ConvertData(Byte[] data)
internal X509Certificate2Impl ImportFallback(Byte[] data)
internal X509Certificate2Impl ImportFallback(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
public bool get_SupportsLegacyBasicConstraintsExtension()
public X509ContentType GetCertContentType(Byte[] rawData)
public X509ContentType GetCertContentType(string fileName)
}
internal Mono.X509PalImplMono : X509PalImpl {
public X509CertificateImpl Import(Byte[] data)
public X509Certificate2Impl Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
public X509Certificate2Impl Import(X509Certificate cert)
}
internal ObjCRuntimeInternal.INativeObject {
public IntPtr Handle
public IntPtr get_Handle()
}
internal ObjCRuntimeInternal.NativeObjectHelper : object {
public IntPtr GetHandle(INativeObject self)
}
public System.CodeDom.CodeArgumentReferenceExpression : CodeExpression {
private string _parameterName
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
public void set_ParameterName(string value)
}
public System.CodeDom.CodeArrayCreateExpression : CodeExpression {
private CodeExpressionCollection _initializers
private CodeTypeReference _createType
private int <Size>k__BackingField
private CodeExpression <SizeExpression>k__BackingField
public CodeTypeReference CreateType
public CodeExpressionCollection Initializers
public int Size
public CodeExpression SizeExpression
public void .ctor(CodeTypeReference createType, CodeExpression[] initializers)
public void .ctor(string createType, CodeExpression[] initializers)
public void .ctor(Type createType, CodeExpression[] initializers)
public void .ctor(CodeTypeReference createType, int size)
public void .ctor(string createType, int size)
public void .ctor(Type createType, int size)
public void .ctor(CodeTypeReference createType, CodeExpression size)
public void .ctor(string createType, CodeExpression size)
public void .ctor(Type createType, CodeExpression size)
public CodeTypeReference get_CreateType()
public void set_CreateType(CodeTypeReference value)
public CodeExpressionCollection get_Initializers()
public int get_Size()
public void set_Size(int value)
public CodeExpression get_SizeExpression()
public void set_SizeExpression(CodeExpression value)
}
public System.CodeDom.CodeArrayIndexerExpression : CodeExpression {
private CodeExpressionCollection _indices
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public CodeExpressionCollection Indices
public void .ctor(CodeExpression targetObject, CodeExpression[] indices)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public CodeExpressionCollection get_Indices()
}
public System.CodeDom.CodeAssignStatement : CodeStatement {
private CodeExpression <Left>k__BackingField
private CodeExpression <Right>k__BackingField
public CodeExpression Left
public CodeExpression Right
public void .ctor(CodeExpression left, CodeExpression right)
public CodeExpression get_Left()
public void set_Left(CodeExpression value)
public CodeExpression get_Right()
public void set_Right(CodeExpression value)
}
public System.CodeDom.CodeAttachEventStatement : CodeStatement {
private CodeEventReferenceExpression _eventRef
private CodeExpression <Listener>k__BackingField
public CodeEventReferenceExpression Event
public CodeExpression Listener
public void .ctor(CodeEventReferenceExpression eventRef, CodeExpression listener)
public void .ctor(CodeExpression targetObject, string eventName, CodeExpression listener)
public CodeEventReferenceExpression get_Event()
public void set_Event(CodeEventReferenceExpression value)
public CodeExpression get_Listener()
public void set_Listener(CodeExpression value)
}
public System.CodeDom.CodeAttributeArgument : object {
private string _name
private CodeExpression <Value>k__BackingField
public string Name
public CodeExpression Value
public void .ctor(CodeExpression value)
public void .ctor(string name, CodeExpression value)
public string get_Name()
public void set_Name(string value)
public CodeExpression get_Value()
public void set_Value(CodeExpression value)
}
public System.CodeDom.CodeAttributeArgumentCollection : CollectionBase {
public CodeAttributeArgument Item
public void .ctor(CodeAttributeArgumentCollection value)
public void .ctor(CodeAttributeArgument[] value)
public CodeAttributeArgument get_Item(int index)
public void set_Item(int index, CodeAttributeArgument value)
public int Add(CodeAttributeArgument value)
public void AddRange(CodeAttributeArgument[] value)
public void AddRange(CodeAttributeArgumentCollection value)
public bool Contains(CodeAttributeArgument value)
public void CopyTo(CodeAttributeArgument[] array, int index)
public int IndexOf(CodeAttributeArgument value)
public void Insert(int index, CodeAttributeArgument value)
public void Remove(CodeAttributeArgument value)
}
public System.CodeDom.CodeAttributeDeclaration : object {
private string _name
private CodeAttributeArgumentCollection _arguments
private CodeTypeReference _attributeType
public string Name
public CodeAttributeArgumentCollection Arguments
public CodeTypeReference AttributeType
public void .ctor(string name)
public void .ctor(string name, CodeAttributeArgument[] arguments)
public void .ctor(CodeTypeReference attributeType)
public void .ctor(CodeTypeReference attributeType, CodeAttributeArgument[] arguments)
public string get_Name()
public void set_Name(string value)
public CodeAttributeArgumentCollection get_Arguments()
public CodeTypeReference get_AttributeType()
}
public System.CodeDom.CodeAttributeDeclarationCollection : CollectionBase {
public CodeAttributeDeclaration Item
public void .ctor(CodeAttributeDeclarationCollection value)
public void .ctor(CodeAttributeDeclaration[] value)
public CodeAttributeDeclaration get_Item(int index)
public void set_Item(int index, CodeAttributeDeclaration value)
public int Add(CodeAttributeDeclaration value)
public void AddRange(CodeAttributeDeclaration[] value)
public void AddRange(CodeAttributeDeclarationCollection value)
public bool Contains(CodeAttributeDeclaration value)
public void CopyTo(CodeAttributeDeclaration[] array, int index)
public int IndexOf(CodeAttributeDeclaration value)
public void Insert(int index, CodeAttributeDeclaration value)
public void Remove(CodeAttributeDeclaration value)
}
public System.CodeDom.CodeBinaryOperatorExpression : CodeExpression {
private CodeExpression <Right>k__BackingField
private CodeExpression <Left>k__BackingField
private CodeBinaryOperatorType <Operator>k__BackingField
public CodeExpression Right
public CodeExpression Left
public CodeBinaryOperatorType Operator
public void .ctor(CodeExpression left, CodeBinaryOperatorType op, CodeExpression right)
public CodeExpression get_Right()
public void set_Right(CodeExpression value)
public CodeExpression get_Left()
public void set_Left(CodeExpression value)
public CodeBinaryOperatorType get_Operator()
public void set_Operator(CodeBinaryOperatorType value)
}
public System.CodeDom.CodeBinaryOperatorType : Enum {
public int value__
public CodeBinaryOperatorType Add
public CodeBinaryOperatorType Subtract
public CodeBinaryOperatorType Multiply
public CodeBinaryOperatorType Divide
public CodeBinaryOperatorType Modulus
public CodeBinaryOperatorType Assign
public CodeBinaryOperatorType IdentityInequality
public CodeBinaryOperatorType IdentityEquality
public CodeBinaryOperatorType ValueEquality
public CodeBinaryOperatorType BitwiseOr
public CodeBinaryOperatorType BitwiseAnd
public CodeBinaryOperatorType BooleanOr
public CodeBinaryOperatorType BooleanAnd
public CodeBinaryOperatorType LessThan
public CodeBinaryOperatorType LessThanOrEqual
public CodeBinaryOperatorType GreaterThan
public CodeBinaryOperatorType GreaterThanOrEqual
}
public System.CodeDom.CodeCastExpression : CodeExpression {
private CodeTypeReference _targetType
private CodeExpression <Expression>k__BackingField
public CodeTypeReference TargetType
public CodeExpression Expression
public void .ctor(CodeTypeReference targetType, CodeExpression expression)
public void .ctor(string targetType, CodeExpression expression)
public void .ctor(Type targetType, CodeExpression expression)
public CodeTypeReference get_TargetType()
public void set_TargetType(CodeTypeReference value)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
}
public System.CodeDom.CodeCatchClause : object {
private CodeStatementCollection _statements
private CodeTypeReference _catchExceptionType
private string _localName
public string LocalName
public CodeTypeReference CatchExceptionType
public CodeStatementCollection Statements
public void .ctor(string localName)
public void .ctor(string localName, CodeTypeReference catchExceptionType)
public void .ctor(string localName, CodeTypeReference catchExceptionType, CodeStatement[] statements)
public string get_LocalName()
public void set_LocalName(string value)
public CodeTypeReference get_CatchExceptionType()
public void set_CatchExceptionType(CodeTypeReference value)
public CodeStatementCollection get_Statements()
}
public System.CodeDom.CodeCatchClauseCollection : CollectionBase {
public CodeCatchClause Item
public void .ctor(CodeCatchClauseCollection value)
public void .ctor(CodeCatchClause[] value)
public CodeCatchClause get_Item(int index)
public void set_Item(int index, CodeCatchClause value)
public int Add(CodeCatchClause value)
public void AddRange(CodeCatchClause[] value)
public void AddRange(CodeCatchClauseCollection value)
public bool Contains(CodeCatchClause value)
public void CopyTo(CodeCatchClause[] array, int index)
public int IndexOf(CodeCatchClause value)
public void Insert(int index, CodeCatchClause value)
public void Remove(CodeCatchClause value)
}
public System.CodeDom.CodeChecksumPragma : CodeDirective {
private string _fileName
private Guid <ChecksumAlgorithmId>k__BackingField
private Byte[] <ChecksumData>k__BackingField
public string FileName
public Guid ChecksumAlgorithmId
public Byte[] ChecksumData
public void .ctor(string fileName, Guid checksumAlgorithmId, Byte[] checksumData)
public string get_FileName()
public void set_FileName(string value)
public Guid get_ChecksumAlgorithmId()
public void set_ChecksumAlgorithmId(Guid value)
public Byte[] get_ChecksumData()
public void set_ChecksumData(Byte[] value)
}
public System.CodeDom.CodeComment : CodeObject {
private string _text
private bool <DocComment>k__BackingField
public bool DocComment
public string Text
public void .ctor(string text)
public void .ctor(string text, bool docComment)
public bool get_DocComment()
public void set_DocComment(bool value)
public string get_Text()
public void set_Text(string value)
}
public System.CodeDom.CodeCommentStatement : CodeStatement {
private CodeComment <Comment>k__BackingField
public CodeComment Comment
public void .ctor(CodeComment comment)
public void .ctor(string text)
public void .ctor(string text, bool docComment)
public CodeComment get_Comment()
public void set_Comment(CodeComment value)
}
public System.CodeDom.CodeCommentStatementCollection : CollectionBase {
public CodeCommentStatement Item
public void .ctor(CodeCommentStatementCollection value)
public void .ctor(CodeCommentStatement[] value)
public CodeCommentStatement get_Item(int index)
public void set_Item(int index, CodeCommentStatement value)
public int Add(CodeCommentStatement value)
public void AddRange(CodeCommentStatement[] value)
public void AddRange(CodeCommentStatementCollection value)
public bool Contains(CodeCommentStatement value)
public void CopyTo(CodeCommentStatement[] array, int index)
public int IndexOf(CodeCommentStatement value)
public void Insert(int index, CodeCommentStatement value)
public void Remove(CodeCommentStatement value)
}
public System.CodeDom.CodeCompileUnit : CodeObject {
private StringCollection _assemblies
private CodeAttributeDeclarationCollection _attributes
private CodeDirectiveCollection _startDirectives
private CodeDirectiveCollection _endDirectives
private CodeNamespaceCollection <Namespaces>k__BackingField
public CodeNamespaceCollection Namespaces
public StringCollection ReferencedAssemblies
public CodeAttributeDeclarationCollection AssemblyCustomAttributes
public CodeDirectiveCollection StartDirectives
public CodeDirectiveCollection EndDirectives
public CodeNamespaceCollection get_Namespaces()
public StringCollection get_ReferencedAssemblies()
public CodeAttributeDeclarationCollection get_AssemblyCustomAttributes()
public CodeDirectiveCollection get_StartDirectives()
public CodeDirectiveCollection get_EndDirectives()
}
public System.CodeDom.CodeConditionStatement : CodeStatement {
private CodeExpression <Condition>k__BackingField
private CodeStatementCollection <TrueStatements>k__BackingField
private CodeStatementCollection <FalseStatements>k__BackingField
public CodeExpression Condition
public CodeStatementCollection TrueStatements
public CodeStatementCollection FalseStatements
public void .ctor(CodeExpression condition, CodeStatement[] trueStatements)
public void .ctor(CodeExpression condition, CodeStatement[] trueStatements, CodeStatement[] falseStatements)
public CodeExpression get_Condition()
public void set_Condition(CodeExpression value)
public CodeStatementCollection get_TrueStatements()
public CodeStatementCollection get_FalseStatements()
}
public System.CodeDom.CodeConstructor : CodeMemberMethod {
private CodeExpressionCollection <BaseConstructorArgs>k__BackingField
private CodeExpressionCollection <ChainedConstructorArgs>k__BackingField
public CodeExpressionCollection BaseConstructorArgs
public CodeExpressionCollection ChainedConstructorArgs
public CodeExpressionCollection get_BaseConstructorArgs()
public CodeExpressionCollection get_ChainedConstructorArgs()
}
public System.CodeDom.CodeDefaultValueExpression : CodeExpression {
private CodeTypeReference _type
public CodeTypeReference Type
public void .ctor(CodeTypeReference type)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
}
public System.CodeDom.CodeDelegateCreateExpression : CodeExpression {
private CodeTypeReference _delegateType
private string _methodName
private CodeExpression <TargetObject>k__BackingField
public CodeTypeReference DelegateType
public CodeExpression TargetObject
public string MethodName
public void .ctor(CodeTypeReference delegateType, CodeExpression targetObject, string methodName)
public CodeTypeReference get_DelegateType()
public void set_DelegateType(CodeTypeReference value)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_MethodName()
public void set_MethodName(string value)
}
public System.CodeDom.CodeDelegateInvokeExpression : CodeExpression {
private CodeExpression <TargetObject>k__BackingField
private CodeExpressionCollection <Parameters>k__BackingField
public CodeExpression TargetObject
public CodeExpressionCollection Parameters
public void .ctor(CodeExpression targetObject)
public void .ctor(CodeExpression targetObject, CodeExpression[] parameters)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public CodeExpressionCollection get_Parameters()
}
public System.CodeDom.CodeDirectionExpression : CodeExpression {
private CodeExpression <Expression>k__BackingField
private FieldDirection <Direction>k__BackingField
public CodeExpression Expression
public FieldDirection Direction
public void .ctor(FieldDirection direction, CodeExpression expression)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
public FieldDirection get_Direction()
public void set_Direction(FieldDirection value)
}
public System.CodeDom.CodeDirectiveCollection : CollectionBase {
public CodeDirective Item
public void .ctor(CodeDirectiveCollection value)
public void .ctor(CodeDirective[] value)
public CodeDirective get_Item(int index)
public void set_Item(int index, CodeDirective value)
public int Add(CodeDirective value)
public void AddRange(CodeDirective[] value)
public void AddRange(CodeDirectiveCollection value)
public bool Contains(CodeDirective value)
public void CopyTo(CodeDirective[] array, int index)
public int IndexOf(CodeDirective value)
public void Insert(int index, CodeDirective value)
public void Remove(CodeDirective value)
}
public System.CodeDom.CodeEventReferenceExpression : CodeExpression {
private string _eventName
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public string EventName
public void .ctor(CodeExpression targetObject, string eventName)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_EventName()
public void set_EventName(string value)
}
public System.CodeDom.CodeExpressionCollection : CollectionBase {
public CodeExpression Item
public void .ctor(CodeExpressionCollection value)
public void .ctor(CodeExpression[] value)
public CodeExpression get_Item(int index)
public void set_Item(int index, CodeExpression value)
public int Add(CodeExpression value)
public void AddRange(CodeExpression[] value)
public void AddRange(CodeExpressionCollection value)
public bool Contains(CodeExpression value)
public void CopyTo(CodeExpression[] array, int index)
public int IndexOf(CodeExpression value)
public void Insert(int index, CodeExpression value)
public void Remove(CodeExpression value)
}
public System.CodeDom.CodeExpressionStatement : CodeStatement {
private CodeExpression <Expression>k__BackingField
public CodeExpression Expression
public void .ctor(CodeExpression expression)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
}
public System.CodeDom.CodeFieldReferenceExpression : CodeExpression {
private string _fieldName
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public string FieldName
public void .ctor(CodeExpression targetObject, string fieldName)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_FieldName()
public void set_FieldName(string value)
}
public System.CodeDom.CodeGotoStatement : CodeStatement {
private string _label
public string Label
public void .ctor(string label)
public string get_Label()
public void set_Label(string value)
}
public System.CodeDom.CodeIndexerExpression : CodeExpression {
private CodeExpressionCollection _indices
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public CodeExpressionCollection Indices
public void .ctor(CodeExpression targetObject, CodeExpression[] indices)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public CodeExpressionCollection get_Indices()
}
public System.CodeDom.CodeIterationStatement : CodeStatement {
private CodeStatement <InitStatement>k__BackingField
private CodeExpression <TestExpression>k__BackingField
private CodeStatement <IncrementStatement>k__BackingField
private CodeStatementCollection <Statements>k__BackingField
public CodeStatement InitStatement
public CodeExpression TestExpression
public CodeStatement IncrementStatement
public CodeStatementCollection Statements
public void .ctor(CodeStatement initStatement, CodeExpression testExpression, CodeStatement incrementStatement, CodeStatement[] statements)
public CodeStatement get_InitStatement()
public void set_InitStatement(CodeStatement value)
public CodeExpression get_TestExpression()
public void set_TestExpression(CodeExpression value)
public CodeStatement get_IncrementStatement()
public void set_IncrementStatement(CodeStatement value)
public CodeStatementCollection get_Statements()
}
public System.CodeDom.CodeLabeledStatement : CodeStatement {
private string _label
private CodeStatement <Statement>k__BackingField
public string Label
public CodeStatement Statement
public void .ctor(string label)
public void .ctor(string label, CodeStatement statement)
public string get_Label()
public void set_Label(string value)
public CodeStatement get_Statement()
public void set_Statement(CodeStatement value)
}
public System.CodeDom.CodeLinePragma : object {
private string _fileName
private int <LineNumber>k__BackingField
public string FileName
public int LineNumber
public void .ctor(string fileName, int lineNumber)
public string get_FileName()
public void set_FileName(string value)
public int get_LineNumber()
public void set_LineNumber(int value)
}
public System.CodeDom.CodeMemberEvent : CodeTypeMember {
private CodeTypeReference _type
private CodeTypeReferenceCollection _implementationTypes
private CodeTypeReference <PrivateImplementationType>k__BackingField
public CodeTypeReference Type
public CodeTypeReference PrivateImplementationType
public CodeTypeReferenceCollection ImplementationTypes
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
public CodeTypeReference get_PrivateImplementationType()
public void set_PrivateImplementationType(CodeTypeReference value)
public CodeTypeReferenceCollection get_ImplementationTypes()
}
public System.CodeDom.CodeMemberField : CodeTypeMember {
private CodeTypeReference _type
private CodeExpression <InitExpression>k__BackingField
public CodeTypeReference Type
public CodeExpression InitExpression
public void .ctor(CodeTypeReference type, string name)
public void .ctor(string type, string name)
public void .ctor(Type type, string name)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
public CodeExpression get_InitExpression()
public void set_InitExpression(CodeExpression value)
}
public System.CodeDom.CodeMemberMethod : CodeTypeMember {
private CodeParameterDeclarationExpressionCollection _parameters
private CodeStatementCollection _statements
private CodeTypeReference _returnType
private CodeTypeReferenceCollection _implementationTypes
private CodeAttributeDeclarationCollection _returnAttributes
private CodeTypeParameterCollection _typeParameters
private int _populated
private int ParametersCollection
private int StatementsCollection
private int ImplTypesCollection
private EventHandler PopulateParameters
private EventHandler PopulateStatements
private EventHandler PopulateImplementationTypes
private CodeTypeReference <PrivateImplementationType>k__BackingField
public CodeTypeReference ReturnType
public CodeStatementCollection Statements
public CodeParameterDeclarationExpressionCollection Parameters
public CodeTypeReference PrivateImplementationType
public CodeTypeReferenceCollection ImplementationTypes
public CodeAttributeDeclarationCollection ReturnTypeCustomAttributes
public CodeTypeParameterCollection TypeParameters
public void add_PopulateParameters(EventHandler value)
public void remove_PopulateParameters(EventHandler value)
public void add_PopulateStatements(EventHandler value)
public void remove_PopulateStatements(EventHandler value)
public void add_PopulateImplementationTypes(EventHandler value)
public void remove_PopulateImplementationTypes(EventHandler value)
public CodeTypeReference get_ReturnType()
public void set_ReturnType(CodeTypeReference value)
public CodeStatementCollection get_Statements()
public CodeParameterDeclarationExpressionCollection get_Parameters()
public CodeTypeReference get_PrivateImplementationType()
public void set_PrivateImplementationType(CodeTypeReference value)
public CodeTypeReferenceCollection get_ImplementationTypes()
public CodeAttributeDeclarationCollection get_ReturnTypeCustomAttributes()
public CodeTypeParameterCollection get_TypeParameters()
}
public System.CodeDom.CodeMemberProperty : CodeTypeMember {
private CodeTypeReference _type
private bool _hasGet
private bool _hasSet
private CodeTypeReferenceCollection _implementationTypes
private CodeTypeReference <PrivateImplementationType>k__BackingField
private CodeStatementCollection <GetStatements>k__BackingField
private CodeStatementCollection <SetStatements>k__BackingField
private CodeParameterDeclarationExpressionCollection <Parameters>k__BackingField
public CodeTypeReference PrivateImplementationType
public CodeTypeReferenceCollection ImplementationTypes
public CodeTypeReference Type
public bool HasGet
public bool HasSet
public CodeStatementCollection GetStatements
public CodeStatementCollection SetStatements
public CodeParameterDeclarationExpressionCollection Parameters
public CodeTypeReference get_PrivateImplementationType()
public void set_PrivateImplementationType(CodeTypeReference value)
public CodeTypeReferenceCollection get_ImplementationTypes()
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
public bool get_HasGet()
public void set_HasGet(bool value)
public bool get_HasSet()
public void set_HasSet(bool value)
public CodeStatementCollection get_GetStatements()
public CodeStatementCollection get_SetStatements()
public CodeParameterDeclarationExpressionCollection get_Parameters()
}
public System.CodeDom.CodeMethodInvokeExpression : CodeExpression {
private CodeMethodReferenceExpression _method
private CodeExpressionCollection <Parameters>k__BackingField
public CodeMethodReferenceExpression Method
public CodeExpressionCollection Parameters
public void .ctor(CodeMethodReferenceExpression method, CodeExpression[] parameters)
public void .ctor(CodeExpression targetObject, string methodName, CodeExpression[] parameters)
public CodeMethodReferenceExpression get_Method()
public void set_Method(CodeMethodReferenceExpression value)
public CodeExpressionCollection get_Parameters()
}
public System.CodeDom.CodeMethodReferenceExpression : CodeExpression {
private string _methodName
private CodeTypeReferenceCollection _typeArguments
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public string MethodName
public CodeTypeReferenceCollection TypeArguments
public void .ctor(CodeExpression targetObject, string methodName)
public void .ctor(CodeExpression targetObject, string methodName, CodeTypeReference[] typeParameters)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_MethodName()
public void set_MethodName(string value)
public CodeTypeReferenceCollection get_TypeArguments()
}
public System.CodeDom.CodeMethodReturnStatement : CodeStatement {
private CodeExpression <Expression>k__BackingField
public CodeExpression Expression
public void .ctor(CodeExpression expression)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
}
public System.CodeDom.CodeNamespace : CodeObject {
private string _name
private CodeNamespaceImportCollection _imports
private CodeCommentStatementCollection _comments
private CodeTypeDeclarationCollection _classes
private int _populated
private int ImportsCollection
private int CommentsCollection
private int TypesCollection
private EventHandler PopulateComments
private EventHandler PopulateImports
private EventHandler PopulateTypes
public CodeTypeDeclarationCollection Types
public CodeNamespaceImportCollection Imports
public string Name
public CodeCommentStatementCollection Comments
public void add_PopulateComments(EventHandler value)
public void remove_PopulateComments(EventHandler value)
public void add_PopulateImports(EventHandler value)
public void remove_PopulateImports(EventHandler value)
public void add_PopulateTypes(EventHandler value)
public void remove_PopulateTypes(EventHandler value)
public void .ctor(string name)
public CodeTypeDeclarationCollection get_Types()
public CodeNamespaceImportCollection get_Imports()
public string get_Name()
public void set_Name(string value)
public CodeCommentStatementCollection get_Comments()
}
public System.CodeDom.CodeNamespaceCollection : CollectionBase {
public CodeNamespace Item
public void .ctor(CodeNamespaceCollection value)
public void .ctor(CodeNamespace[] value)
public CodeNamespace get_Item(int index)
public void set_Item(int index, CodeNamespace value)
public int Add(CodeNamespace value)
public void AddRange(CodeNamespace[] value)
public void AddRange(CodeNamespaceCollection value)
public bool Contains(CodeNamespace value)
public void CopyTo(CodeNamespace[] array, int index)
public int IndexOf(CodeNamespace value)
public void Insert(int index, CodeNamespace value)
public void Remove(CodeNamespace value)
}
public System.CodeDom.CodeNamespaceImport : CodeObject {
private string _nameSpace
private CodeLinePragma <LinePragma>k__BackingField
public CodeLinePragma LinePragma
public string Namespace
public void .ctor(string nameSpace)
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public string get_Namespace()
public void set_Namespace(string value)
}
public System.CodeDom.CodeNamespaceImportCollection : object {
private ArrayList _data
private Dictionary`2<string, CodeNamespaceImport> _keys
public CodeNamespaceImport Item
public int Count
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public CodeNamespaceImport get_Item(int index)
public void set_Item(int index, CodeNamespaceImport value)
public int get_Count()
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
public void Add(CodeNamespaceImport value)
public void AddRange(CodeNamespaceImport[] value)
public void Clear()
private void SyncKeys()
public IEnumerator GetEnumerator()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
}
public System.CodeDom.CodeObject : object {
private IDictionary _userData
public IDictionary UserData
public IDictionary get_UserData()
}
public System.CodeDom.CodeObjectCreateExpression : CodeExpression {
private CodeTypeReference _createType
private CodeExpressionCollection <Parameters>k__BackingField
public CodeTypeReference CreateType
public CodeExpressionCollection Parameters
public void .ctor(CodeTypeReference createType, CodeExpression[] parameters)
public void .ctor(string createType, CodeExpression[] parameters)
public void .ctor(Type createType, CodeExpression[] parameters)
public CodeTypeReference get_CreateType()
public void set_CreateType(CodeTypeReference value)
public CodeExpressionCollection get_Parameters()
}
public System.CodeDom.CodeParameterDeclarationExpression : CodeExpression {
private CodeTypeReference _type
private string _name
private CodeAttributeDeclarationCollection _customAttributes
private FieldDirection <Direction>k__BackingField
public CodeAttributeDeclarationCollection CustomAttributes
public FieldDirection Direction
public CodeTypeReference Type
public string Name
public void .ctor(CodeTypeReference type, string name)
public void .ctor(string type, string name)
public void .ctor(Type type, string name)
public CodeAttributeDeclarationCollection get_CustomAttributes()
public void set_CustomAttributes(CodeAttributeDeclarationCollection value)
public FieldDirection get_Direction()
public void set_Direction(FieldDirection value)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
public string get_Name()
public void set_Name(string value)
}
public System.CodeDom.CodeParameterDeclarationExpressionCollection : CollectionBase {
public CodeParameterDeclarationExpression Item
public void .ctor(CodeParameterDeclarationExpressionCollection value)
public void .ctor(CodeParameterDeclarationExpression[] value)
public CodeParameterDeclarationExpression get_Item(int index)
public void set_Item(int index, CodeParameterDeclarationExpression value)
public int Add(CodeParameterDeclarationExpression value)
public void AddRange(CodeParameterDeclarationExpression[] value)
public void AddRange(CodeParameterDeclarationExpressionCollection value)
public bool Contains(CodeParameterDeclarationExpression value)
public void CopyTo(CodeParameterDeclarationExpression[] array, int index)
public int IndexOf(CodeParameterDeclarationExpression value)
public void Insert(int index, CodeParameterDeclarationExpression value)
public void Remove(CodeParameterDeclarationExpression value)
}
public System.CodeDom.CodePrimitiveExpression : CodeExpression {
private object <Value>k__BackingField
public object Value
public void .ctor(object value)
public object get_Value()
public void set_Value(object value)
}
public System.CodeDom.CodePropertyReferenceExpression : CodeExpression {
private string _propertyName
private CodeExpression <TargetObject>k__BackingField
public CodeExpression TargetObject
public string PropertyName
public void .ctor(CodeExpression targetObject, string propertyName)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public string get_PropertyName()
public void set_PropertyName(string value)
}
public System.CodeDom.CodeRegionDirective : CodeDirective {
private string _regionText
private CodeRegionMode <RegionMode>k__BackingField
public string RegionText
public CodeRegionMode RegionMode
public void .ctor(CodeRegionMode regionMode, string regionText)
public string get_RegionText()
public void set_RegionText(string value)
public CodeRegionMode get_RegionMode()
public void set_RegionMode(CodeRegionMode value)
}
public System.CodeDom.CodeRegionMode : Enum {
public int value__
public CodeRegionMode None
public CodeRegionMode Start
public CodeRegionMode End
}
public System.CodeDom.CodeRemoveEventStatement : CodeStatement {
private CodeEventReferenceExpression _eventRef
private CodeExpression <Listener>k__BackingField
public CodeEventReferenceExpression Event
public CodeExpression Listener
public void .ctor(CodeEventReferenceExpression eventRef, CodeExpression listener)
public void .ctor(CodeExpression targetObject, string eventName, CodeExpression listener)
public CodeEventReferenceExpression get_Event()
public void set_Event(CodeEventReferenceExpression value)
public CodeExpression get_Listener()
public void set_Listener(CodeExpression value)
}
public System.CodeDom.CodeSnippetCompileUnit : CodeCompileUnit {
private string _value
private CodeLinePragma <LinePragma>k__BackingField
public string Value
public CodeLinePragma LinePragma
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
}
public System.CodeDom.CodeSnippetExpression : CodeExpression {
private string _value
public string Value
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
}
public System.CodeDom.CodeSnippetStatement : CodeStatement {
private string _value
public string Value
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
}
public System.CodeDom.CodeSnippetTypeMember : CodeTypeMember {
private string _text
public string Text
public void .ctor(string text)
public string get_Text()
public void set_Text(string value)
}
public System.CodeDom.CodeStatement : CodeObject {
private CodeDirectiveCollection _startDirectives
private CodeDirectiveCollection _endDirectives
private CodeLinePragma <LinePragma>k__BackingField
public CodeLinePragma LinePragma
public CodeDirectiveCollection StartDirectives
public CodeDirectiveCollection EndDirectives
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public CodeDirectiveCollection get_StartDirectives()
public CodeDirectiveCollection get_EndDirectives()
}
public System.CodeDom.CodeStatementCollection : CollectionBase {
public CodeStatement Item
public void .ctor(CodeStatementCollection value)
public void .ctor(CodeStatement[] value)
public CodeStatement get_Item(int index)
public void set_Item(int index, CodeStatement value)
public int Add(CodeStatement value)
public int Add(CodeExpression value)
public void AddRange(CodeStatement[] value)
public void AddRange(CodeStatementCollection value)
public bool Contains(CodeStatement value)
public void CopyTo(CodeStatement[] array, int index)
public int IndexOf(CodeStatement value)
public void Insert(int index, CodeStatement value)
public void Remove(CodeStatement value)
}
public System.CodeDom.CodeThrowExceptionStatement : CodeStatement {
private CodeExpression <ToThrow>k__BackingField
public CodeExpression ToThrow
public void .ctor(CodeExpression toThrow)
public CodeExpression get_ToThrow()
public void set_ToThrow(CodeExpression value)
}
public System.CodeDom.CodeTryCatchFinallyStatement : CodeStatement {
private CodeStatementCollection <TryStatements>k__BackingField
private CodeCatchClauseCollection <CatchClauses>k__BackingField
private CodeStatementCollection <FinallyStatements>k__BackingField
public CodeStatementCollection TryStatements
public CodeCatchClauseCollection CatchClauses
public CodeStatementCollection FinallyStatements
public void .ctor(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses)
public void .ctor(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses, CodeStatement[] finallyStatements)
public CodeStatementCollection get_TryStatements()
public CodeCatchClauseCollection get_CatchClauses()
public CodeStatementCollection get_FinallyStatements()
}
public System.CodeDom.CodeTypeDeclaration : CodeTypeMember {
private CodeTypeReferenceCollection _baseTypes
private CodeTypeMemberCollection _members
private bool _isEnum
private bool _isStruct
private int _populated
private int BaseTypesCollection
private int MembersCollection
private CodeTypeParameterCollection _typeParameters
private EventHandler PopulateBaseTypes
private EventHandler PopulateMembers
private TypeAttributes <TypeAttributes>k__BackingField
private bool <IsPartial>k__BackingField
public TypeAttributes TypeAttributes
public CodeTypeReferenceCollection BaseTypes
public bool IsClass
public bool IsStruct
public bool IsEnum
public bool IsInterface
public bool IsPartial
public CodeTypeMemberCollection Members
public CodeTypeParameterCollection TypeParameters
public void add_PopulateBaseTypes(EventHandler value)
public void remove_PopulateBaseTypes(EventHandler value)
public void add_PopulateMembers(EventHandler value)
public void remove_PopulateMembers(EventHandler value)
public void .ctor(string name)
public TypeAttributes get_TypeAttributes()
public void set_TypeAttributes(TypeAttributes value)
public CodeTypeReferenceCollection get_BaseTypes()
public bool get_IsClass()
public void set_IsClass(bool value)
public bool get_IsStruct()
public void set_IsStruct(bool value)
public bool get_IsEnum()
public void set_IsEnum(bool value)
public bool get_IsInterface()
public void set_IsInterface(bool value)
public bool get_IsPartial()
public void set_IsPartial(bool value)
public CodeTypeMemberCollection get_Members()
public CodeTypeParameterCollection get_TypeParameters()
}
public System.CodeDom.CodeTypeDeclarationCollection : CollectionBase {
public CodeTypeDeclaration Item
public void .ctor(CodeTypeDeclarationCollection value)
public void .ctor(CodeTypeDeclaration[] value)
public CodeTypeDeclaration get_Item(int index)
public void set_Item(int index, CodeTypeDeclaration value)
public int Add(CodeTypeDeclaration value)
public void AddRange(CodeTypeDeclaration[] value)
public void AddRange(CodeTypeDeclarationCollection value)
public bool Contains(CodeTypeDeclaration value)
public void CopyTo(CodeTypeDeclaration[] array, int index)
public int IndexOf(CodeTypeDeclaration value)
public void Insert(int index, CodeTypeDeclaration value)
public void Remove(CodeTypeDeclaration value)
}
public System.CodeDom.CodeTypeDelegate : CodeTypeDeclaration {
private CodeTypeReference _returnType
private CodeParameterDeclarationExpressionCollection <Parameters>k__BackingField
public CodeTypeReference ReturnType
public CodeParameterDeclarationExpressionCollection Parameters
public void .ctor(string name)
public CodeTypeReference get_ReturnType()
public void set_ReturnType(CodeTypeReference value)
public CodeParameterDeclarationExpressionCollection get_Parameters()
}
public System.CodeDom.CodeTypeMember : CodeObject {
private string _name
private CodeAttributeDeclarationCollection _customAttributes
private CodeDirectiveCollection _startDirectives
private CodeDirectiveCollection _endDirectives
private MemberAttributes <Attributes>k__BackingField
private CodeLinePragma <LinePragma>k__BackingField
private CodeCommentStatementCollection <Comments>k__BackingField
public string Name
public MemberAttributes Attributes
public CodeAttributeDeclarationCollection CustomAttributes
public CodeLinePragma LinePragma
public CodeCommentStatementCollection Comments
public CodeDirectiveCollection StartDirectives
public CodeDirectiveCollection EndDirectives
public string get_Name()
public void set_Name(string value)
public MemberAttributes get_Attributes()
public void set_Attributes(MemberAttributes value)
public CodeAttributeDeclarationCollection get_CustomAttributes()
public void set_CustomAttributes(CodeAttributeDeclarationCollection value)
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public CodeCommentStatementCollection get_Comments()
public CodeDirectiveCollection get_StartDirectives()
public CodeDirectiveCollection get_EndDirectives()
}
public System.CodeDom.CodeTypeMemberCollection : CollectionBase {
public CodeTypeMember Item
public void .ctor(CodeTypeMemberCollection value)
public void .ctor(CodeTypeMember[] value)
public CodeTypeMember get_Item(int index)
public void set_Item(int index, CodeTypeMember value)
public int Add(CodeTypeMember value)
public void AddRange(CodeTypeMember[] value)
public void AddRange(CodeTypeMemberCollection value)
public bool Contains(CodeTypeMember value)
public void CopyTo(CodeTypeMember[] array, int index)
public int IndexOf(CodeTypeMember value)
public void Insert(int index, CodeTypeMember value)
public void Remove(CodeTypeMember value)
}
public System.CodeDom.CodeTypeOfExpression : CodeExpression {
private CodeTypeReference _type
public CodeTypeReference Type
public void .ctor(CodeTypeReference type)
public void .ctor(string type)
public void .ctor(Type type)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
}
public System.CodeDom.CodeTypeParameter : CodeObject {
private string _name
private CodeAttributeDeclarationCollection _customAttributes
private CodeTypeReferenceCollection _constraints
private bool <HasConstructorConstraint>k__BackingField
public string Name
public CodeTypeReferenceCollection Constraints
public CodeAttributeDeclarationCollection CustomAttributes
public bool HasConstructorConstraint
public void .ctor(string name)
public string get_Name()
public void set_Name(string value)
public CodeTypeReferenceCollection get_Constraints()
public CodeAttributeDeclarationCollection get_CustomAttributes()
public bool get_HasConstructorConstraint()
public void set_HasConstructorConstraint(bool value)
}
public System.CodeDom.CodeTypeParameterCollection : CollectionBase {
public CodeTypeParameter Item
public void .ctor(CodeTypeParameterCollection value)
public void .ctor(CodeTypeParameter[] value)
public CodeTypeParameter get_Item(int index)
public void set_Item(int index, CodeTypeParameter value)
public int Add(CodeTypeParameter value)
public void Add(string value)
public void AddRange(CodeTypeParameter[] value)
public void AddRange(CodeTypeParameterCollection value)
public bool Contains(CodeTypeParameter value)
public void CopyTo(CodeTypeParameter[] array, int index)
public int IndexOf(CodeTypeParameter value)
public void Insert(int index, CodeTypeParameter value)
public void Remove(CodeTypeParameter value)
}
public System.CodeDom.CodeTypeReference : CodeObject {
private string _baseType
private bool _isInterface
private CodeTypeReferenceCollection _typeArguments
private bool _needsFixup
private CodeTypeReference <ArrayElementType>k__BackingField
private int <ArrayRank>k__BackingField
private CodeTypeReferenceOptions <Options>k__BackingField
public CodeTypeReference ArrayElementType
public int ArrayRank
internal int NestedArrayDepth
public string BaseType
public CodeTypeReferenceOptions Options
public CodeTypeReferenceCollection TypeArguments
internal bool IsInterface
public void .ctor(Type type)
public void .ctor(Type type, CodeTypeReferenceOptions codeTypeReferenceOption)
public void .ctor(string typeName, CodeTypeReferenceOptions codeTypeReferenceOption)
public void .ctor(string typeName)
private void InitializeFromType(Type type)
private void Initialize(string typeName)
private void Initialize(string typeName, CodeTypeReferenceOptions options)
public void .ctor(string typeName, CodeTypeReference[] typeArguments)
public void .ctor(CodeTypeParameter typeParameter)
public void .ctor(string baseType, int rank)
public void .ctor(CodeTypeReference arrayType, int rank)
public CodeTypeReference get_ArrayElementType()
public void set_ArrayElementType(CodeTypeReference value)
public int get_ArrayRank()
public void set_ArrayRank(int value)
internal int get_NestedArrayDepth()
public string get_BaseType()
public void set_BaseType(string value)
public CodeTypeReferenceOptions get_Options()
public void set_Options(CodeTypeReferenceOptions value)
public CodeTypeReferenceCollection get_TypeArguments()
internal bool get_IsInterface()
private string RipOffAssemblyInformationFromTypeName(string typeName)
}
public System.CodeDom.CodeTypeReferenceCollection : CollectionBase {
public CodeTypeReference Item
public void .ctor(CodeTypeReferenceCollection value)
public void .ctor(CodeTypeReference[] value)
public CodeTypeReference get_Item(int index)
public void set_Item(int index, CodeTypeReference value)
public int Add(CodeTypeReference value)
public void Add(string value)
public void Add(Type value)
public void AddRange(CodeTypeReference[] value)
public void AddRange(CodeTypeReferenceCollection value)
public bool Contains(CodeTypeReference value)
public void CopyTo(CodeTypeReference[] array, int index)
public int IndexOf(CodeTypeReference value)
public void Insert(int index, CodeTypeReference value)
public void Remove(CodeTypeReference value)
}
public System.CodeDom.CodeTypeReferenceExpression : CodeExpression {
private CodeTypeReference _type
public CodeTypeReference Type
public void .ctor(CodeTypeReference type)
public void .ctor(string type)
public void .ctor(Type type)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
}
public System.CodeDom.CodeTypeReferenceOptions : Enum {
public int value__
public CodeTypeReferenceOptions GlobalReference
public CodeTypeReferenceOptions GenericTypeParameter
}
public System.CodeDom.CodeVariableDeclarationStatement : CodeStatement {
private CodeTypeReference _type
private string _name
private CodeExpression <InitExpression>k__BackingField
public CodeExpression InitExpression
public string Name
public CodeTypeReference Type
public void .ctor(CodeTypeReference type, string name)
public void .ctor(string type, string name)
public void .ctor(Type type, string name)
public void .ctor(CodeTypeReference type, string name, CodeExpression initExpression)
public void .ctor(string type, string name, CodeExpression initExpression)
public void .ctor(Type type, string name, CodeExpression initExpression)
public CodeExpression get_InitExpression()
public void set_InitExpression(CodeExpression value)
public string get_Name()
public void set_Name(string value)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
}
public System.CodeDom.CodeVariableReferenceExpression : CodeExpression {
private string _variableName
public string VariableName
public void .ctor(string variableName)
public string get_VariableName()
public void set_VariableName(string value)
}
public System.CodeDom.Compiler.CodeCompiler : CodeGenerator {
protected string FileExtension
protected string CompilerName
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
protected string get_FileExtension()
protected string get_CompilerName()
protected CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e)
protected CompilerResults FromFile(CompilerParameters options, string fileName)
protected CompilerResults FromSource(CompilerParameters options, string source)
protected CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
private void ResolveReferencedAssemblies(CompilerParameters options, CodeCompileUnit e)
protected CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames)
protected void ProcessCompilerOutputLine(CompilerResults results, string line)
protected string CmdArgsFromParameters(CompilerParameters options)
protected string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs)
protected CompilerResults FromSourceBatch(CompilerParameters options, String[] sources)
protected string JoinStringArray(String[] sa, string separator)
}
internal System.CodeDom.Compiler.CodeDomConfigurationHandler : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty compilersProp
private CompilerCollection default_compilers
public CompilerCollection Compilers
public CompilerInfo[] CompilerInfos
protected ConfigurationPropertyCollection Properties
protected void InitializeDefault()
protected void PostDeserialize()
protected object GetRuntimeObject()
public CompilerCollection get_Compilers()
public CompilerInfo[] get_CompilerInfos()
protected ConfigurationPropertyCollection get_Properties()
}
public System.CodeDom.Compiler.CodeDomProvider : Component {
private Dictionary`2<string, CompilerInfo> s_compilerLanguages
private Dictionary`2<string, CompilerInfo> s_compilerExtensions
private List`1<CompilerInfo> s_allCompilerInfo
public string FileExtension
public LanguageOptions LanguageOptions
private void AddCompilerInfo(CompilerInfo compilerInfo)
public CodeDomProvider CreateProvider(string language, IDictionary`2<string, string> providerOptions)
public CodeDomProvider CreateProvider(string language)
public string GetLanguageFromExtension(string extension)
public bool IsDefinedLanguage(string language)
public bool IsDefinedExtension(string extension)
public CompilerInfo GetCompilerInfo(string language)
private CompilerInfo GetCompilerInfoForLanguageNoThrow(string language)
private CompilerInfo GetCompilerInfoForExtensionNoThrow(string extension)
public CompilerInfo[] GetAllCompilerInfo()
public string get_FileExtension()
public LanguageOptions get_LanguageOptions()
public ICodeGenerator CreateGenerator()
public ICodeGenerator CreateGenerator(TextWriter output)
public ICodeGenerator CreateGenerator(string fileName)
public ICodeCompiler CreateCompiler()
public ICodeParser CreateParser()
public TypeConverter GetConverter(Type type)
public CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit[] compilationUnits)
public CompilerResults CompileAssemblyFromFile(CompilerParameters options, String[] fileNames)
public CompilerResults CompileAssemblyFromSource(CompilerParameters options, String[] sources)
public bool IsValidIdentifier(string value)
public string CreateEscapedIdentifier(string value)
public string CreateValidIdentifier(string value)
public string GetTypeOutput(CodeTypeReference type)
public bool Supports(GeneratorSupport generatorSupport)
public void GenerateCodeFromExpression(CodeExpression expression, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromStatement(CodeStatement statement, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromNamespace(CodeNamespace codeNamespace, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromCompileUnit(CodeCompileUnit compileUnit, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromType(CodeTypeDeclaration codeType, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
public CodeCompileUnit Parse(TextReader codeStream)
private ICodeCompiler CreateCompilerHelper()
private ICodeGenerator CreateGeneratorHelper()
private ICodeParser CreateParserHelper()
}
public System.CodeDom.Compiler.CodeGenerator : object {
private int ParameterMultilineThreshold
private ExposedTabStringIndentedTextWriter _output
private CodeGeneratorOptions _options
private CodeTypeDeclaration _currentClass
private CodeTypeMember _currentMember
private bool _inNestedBinary
protected CodeTypeDeclaration CurrentClass
protected string CurrentTypeName
protected CodeTypeMember CurrentMember
protected string CurrentMemberName
protected bool IsCurrentInterface
protected bool IsCurrentClass
protected bool IsCurrentStruct
protected bool IsCurrentEnum
protected bool IsCurrentDelegate
protected int Indent
protected string NullToken
protected TextWriter Output
protected CodeGeneratorOptions Options
protected CodeTypeDeclaration get_CurrentClass()
protected string get_CurrentTypeName()
protected CodeTypeMember get_CurrentMember()
protected string get_CurrentMemberName()
protected bool get_IsCurrentInterface()
protected bool get_IsCurrentClass()
protected bool get_IsCurrentStruct()
protected bool get_IsCurrentEnum()
protected bool get_IsCurrentDelegate()
protected int get_Indent()
protected void set_Indent(int value)
protected string get_NullToken()
protected TextWriter get_Output()
protected CodeGeneratorOptions get_Options()
private void GenerateType(CodeTypeDeclaration e)
protected void GenerateDirectives(CodeDirectiveCollection directives)
private void GenerateTypeMember(CodeTypeMember member, CodeTypeDeclaration declaredType)
private void GenerateTypeConstructors(CodeTypeDeclaration e)
protected void GenerateNamespaces(CodeCompileUnit e)
protected void GenerateTypes(CodeNamespace e)
private bool System.CodeDom.Compiler.ICodeGenerator.Supports(GeneratorSupport support)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
private bool System.CodeDom.Compiler.ICodeGenerator.IsValidIdentifier(string value)
private void System.CodeDom.Compiler.ICodeGenerator.ValidateIdentifier(string value)
private string System.CodeDom.Compiler.ICodeGenerator.CreateEscapedIdentifier(string value)
private string System.CodeDom.Compiler.ICodeGenerator.CreateValidIdentifier(string value)
private string System.CodeDom.Compiler.ICodeGenerator.GetTypeOutput(CodeTypeReference type)
private void GenerateConstructors(CodeTypeDeclaration e)
private void GenerateEvents(CodeTypeDeclaration e)
protected void GenerateExpression(CodeExpression e)
private void GenerateFields(CodeTypeDeclaration e)
private void GenerateSnippetMembers(CodeTypeDeclaration e)
protected void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e)
private void GenerateMethods(CodeTypeDeclaration e)
private void GenerateNestedTypes(CodeTypeDeclaration e)
protected void GenerateCompileUnit(CodeCompileUnit e)
protected void GenerateNamespace(CodeNamespace e)
protected void GenerateNamespaceImports(CodeNamespace e)
private void GenerateProperties(CodeTypeDeclaration e)
protected void GenerateStatement(CodeStatement e)
protected void GenerateStatements(CodeStatementCollection stmts)
protected void OutputAttributeDeclarations(CodeAttributeDeclarationCollection attributes)
protected void OutputAttributeArgument(CodeAttributeArgument arg)
protected void OutputDirection(FieldDirection dir)
protected void OutputFieldScopeModifier(MemberAttributes attributes)
protected void OutputMemberAccessModifier(MemberAttributes attributes)
protected void OutputMemberScopeModifier(MemberAttributes attributes)
protected void OutputType(CodeTypeReference typeRef)
protected void OutputTypeAttributes(TypeAttributes attributes, bool isStruct, bool isEnum)
protected void OutputTypeNamePair(CodeTypeReference typeRef, string name)
protected void OutputIdentifier(string ident)
protected void OutputExpressionList(CodeExpressionCollection expressions)
protected void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems)
protected void OutputOperator(CodeBinaryOperatorType op)
protected void OutputParameters(CodeParameterDeclarationExpressionCollection parameters)
protected void GenerateArrayCreateExpression(CodeArrayCreateExpression e)
protected void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e)
protected void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
protected void ContinueOnNewLine(string st)
protected void GenerateCastExpression(CodeCastExpression e)
protected void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e)
protected void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e)
protected void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
protected void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e)
protected void GenerateIndexerExpression(CodeIndexerExpression e)
protected void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e)
protected void GenerateSnippetExpression(CodeSnippetExpression e)
protected void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e)
protected void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e)
protected void GenerateEventReferenceExpression(CodeEventReferenceExpression e)
protected void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
protected void GenerateObjectCreateExpression(CodeObjectCreateExpression e)
protected void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
protected void GenerateDirectionExpression(CodeDirectionExpression e)
protected void GeneratePrimitiveExpression(CodePrimitiveExpression e)
protected void GenerateSingleFloatValue(float s)
protected void GenerateDoubleValue(double d)
protected void GenerateDecimalValue(decimal d)
protected void GenerateDefaultValueExpression(CodeDefaultValueExpression e)
protected void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e)
protected void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
protected void GenerateThisReferenceExpression(CodeThisReferenceExpression e)
protected void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e)
protected void GenerateTypeOfExpression(CodeTypeOfExpression e)
protected void GenerateExpressionStatement(CodeExpressionStatement e)
protected void GenerateIterationStatement(CodeIterationStatement e)
protected void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e)
protected void GenerateCommentStatement(CodeCommentStatement e)
protected void GenerateCommentStatements(CodeCommentStatementCollection e)
protected void GenerateComment(CodeComment e)
protected void GenerateMethodReturnStatement(CodeMethodReturnStatement e)
protected void GenerateConditionStatement(CodeConditionStatement e)
protected void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e)
protected void GenerateAssignStatement(CodeAssignStatement e)
protected void GenerateAttachEventStatement(CodeAttachEventStatement e)
protected void GenerateRemoveEventStatement(CodeRemoveEventStatement e)
protected void GenerateGotoStatement(CodeGotoStatement e)
protected void GenerateLabeledStatement(CodeLabeledStatement e)
protected void GenerateSnippetStatement(CodeSnippetStatement e)
protected void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
protected void GenerateLinePragmaStart(CodeLinePragma e)
protected void GenerateLinePragmaEnd(CodeLinePragma e)
protected void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c)
protected void GenerateField(CodeMemberField e)
protected void GenerateSnippetMember(CodeSnippetTypeMember e)
protected void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c)
protected void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c)
protected void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c)
protected void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c)
protected void GenerateTypeConstructor(CodeTypeConstructor e)
protected void GenerateTypeStart(CodeTypeDeclaration e)
protected void GenerateTypeEnd(CodeTypeDeclaration e)
protected void GenerateCompileUnitStart(CodeCompileUnit e)
protected void GenerateCompileUnitEnd(CodeCompileUnit e)
protected void GenerateNamespaceStart(CodeNamespace e)
protected void GenerateNamespaceEnd(CodeNamespace e)
protected void GenerateNamespaceImport(CodeNamespaceImport e)
protected void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
protected void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
protected bool Supports(GeneratorSupport support)
protected bool IsValidIdentifier(string value)
protected void ValidateIdentifier(string value)
protected string CreateEscapedIdentifier(string value)
protected string CreateValidIdentifier(string value)
protected string GetTypeOutput(CodeTypeReference value)
protected string QuoteSnippetString(string value)
public bool IsValidLanguageIndependentIdentifier(string value)
internal bool IsValidLanguageIndependentTypeName(string value)
public void ValidateIdentifiers(CodeObject e)
}
public System.CodeDom.Compiler.CodeGeneratorOptions : object {
private IDictionary _options
public object Item
public string IndentString
public string BracingStyle
public bool ElseOnClosing
public bool BlankLinesBetweenMembers
public bool VerbatimOrder
public object get_Item(string index)
public void set_Item(string index, object value)
public string get_IndentString()
public void set_IndentString(string value)
public string get_BracingStyle()
public void set_BracingStyle(string value)
public bool get_ElseOnClosing()
public void set_ElseOnClosing(bool value)
public bool get_BlankLinesBetweenMembers()
public void set_BlankLinesBetweenMembers(bool value)
public bool get_VerbatimOrder()
public void set_VerbatimOrder(bool value)
}
public System.CodeDom.Compiler.CodeParser : object {
public CodeCompileUnit Parse(TextReader codeStream)
}
internal System.CodeDom.Compiler.CodeValidator : object {
private Char[] s_newLineChars
private CodeTypeDeclaration _currentClass
private bool IsCurrentInterface
private bool IsCurrentEnum
private bool IsCurrentDelegate
internal void ValidateIdentifiers(CodeObject e)
private void ValidateTypeMember(CodeTypeMember e)
private void ValidateCodeCompileUnit(CodeCompileUnit e)
private void ValidateSnippetCompileUnit(CodeSnippetCompileUnit e)
private void ValidateCompileUnitStart(CodeCompileUnit e)
private void ValidateCompileUnitEnd(CodeCompileUnit e)
private void ValidateNamespaces(CodeCompileUnit e)
private void ValidateNamespace(CodeNamespace e)
private void ValidateNamespaceStart(CodeNamespace e)
private void ValidateNamespaceImports(CodeNamespace e)
private void ValidateNamespaceImport(CodeNamespaceImport e)
private void ValidateAttributes(CodeAttributeDeclarationCollection attributes)
private void ValidateAttributeArgument(CodeAttributeArgument arg)
private void ValidateTypes(CodeNamespace e)
private void ValidateTypeDeclaration(CodeTypeDeclaration e)
private void ValidateTypeMembers(CodeTypeDeclaration e)
private void ValidateTypeParameters(CodeTypeParameterCollection parameters)
private void ValidateTypeParameter(CodeTypeParameter e)
private void ValidateField(CodeMemberField e)
private void ValidateConstructor(CodeConstructor e)
private void ValidateProperty(CodeMemberProperty e)
private void ValidateMemberMethod(CodeMemberMethod e)
private void ValidateTypeConstructor(CodeTypeConstructor e)
private void ValidateMethod(CodeMemberMethod e)
private void ValidateSnippetMember(CodeSnippetTypeMember e)
private void ValidateTypeStart(CodeTypeDeclaration e)
private void ValidateCommentStatements(CodeCommentStatementCollection e)
private void ValidateCommentStatement(CodeCommentStatement e)
private void ValidateComment(CodeComment e)
private void ValidateStatement(CodeStatement e)
private void ValidateStatements(CodeStatementCollection stmts)
private void ValidateExpressionStatement(CodeExpressionStatement e)
private void ValidateIterationStatement(CodeIterationStatement e)
private void ValidateThrowExceptionStatement(CodeThrowExceptionStatement e)
private void ValidateMethodReturnStatement(CodeMethodReturnStatement e)
private void ValidateConditionStatement(CodeConditionStatement e)
private void ValidateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e)
private void ValidateAssignStatement(CodeAssignStatement e)
private void ValidateAttachEventStatement(CodeAttachEventStatement e)
private void ValidateRemoveEventStatement(CodeRemoveEventStatement e)
private void ValidateGotoStatement(CodeGotoStatement e)
private void ValidateLabeledStatement(CodeLabeledStatement e)
private void ValidateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
private void ValidateLinePragmaStart(CodeLinePragma e)
private void ValidateEvent(CodeMemberEvent e)
private void ValidateParameters(CodeParameterDeclarationExpressionCollection parameters)
private void ValidateSnippetStatement(CodeSnippetStatement e)
private void ValidateExpressionList(CodeExpressionCollection expressions)
private void ValidateTypeReference(CodeTypeReference e)
private void ValidateTypeReferences(CodeTypeReferenceCollection refs)
private void ValidateArity(CodeTypeReference e)
private void ValidateTypeName(object e, string propertyName, string typeName)
private void ValidateIdentifier(object e, string propertyName, string identifier)
private void ValidateExpression(CodeExpression e)
private void ValidateArrayCreateExpression(CodeArrayCreateExpression e)
private void ValidateBaseReferenceExpression(CodeBaseReferenceExpression e)
private void ValidateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
private void ValidateCastExpression(CodeCastExpression e)
private void ValidateDefaultValueExpression(CodeDefaultValueExpression e)
private void ValidateDelegateCreateExpression(CodeDelegateCreateExpression e)
private void ValidateFieldReferenceExpression(CodeFieldReferenceExpression e)
private void ValidateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
private void ValidateVariableReferenceExpression(CodeVariableReferenceExpression e)
private void ValidateIndexerExpression(CodeIndexerExpression e)
private void ValidateArrayIndexerExpression(CodeArrayIndexerExpression e)
private void ValidateSnippetExpression(CodeSnippetExpression e)
private void ValidateMethodInvokeExpression(CodeMethodInvokeExpression e)
private void ValidateMethodReferenceExpression(CodeMethodReferenceExpression e)
private void ValidateEventReferenceExpression(CodeEventReferenceExpression e)
private void ValidateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
private void ValidateObjectCreateExpression(CodeObjectCreateExpression e)
private void ValidateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
private void ValidateDirectionExpression(CodeDirectionExpression e)
private void ValidatePrimitiveExpression(CodePrimitiveExpression e)
private void ValidatePropertyReferenceExpression(CodePropertyReferenceExpression e)
private void ValidatePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
private void ValidateThisReferenceExpression(CodeThisReferenceExpression e)
private void ValidateTypeOfExpression(CodeTypeOfExpression e)
private void ValidateCodeDirectives(CodeDirectiveCollection e)
private void ValidateCodeDirective(CodeDirective e)
private void ValidateChecksumPragma(CodeChecksumPragma e)
private void ValidateRegionDirective(CodeRegionDirective e)
private bool get_IsCurrentInterface()
private bool get_IsCurrentEnum()
private bool get_IsCurrentDelegate()
}
internal System.CodeDom.Compiler.Compiler : ConfigurationElement {
private ConfigurationProperty compilerOptionsProp
private ConfigurationProperty extensionProp
private ConfigurationProperty languageProp
private ConfigurationProperty typeProp
private ConfigurationProperty warningLevelProp
private ConfigurationProperty providerOptionsProp
private ConfigurationPropertyCollection properties
public string CompilerOptions
public string Extension
public string Language
public string Type
public int WarningLevel
public CompilerProviderOptionsCollection ProviderOptions
public Dictionary`2<string, string> ProviderOptionsDictionary
protected ConfigurationPropertyCollection Properties
public void .ctor(string compilerOptions, string extension, string language, string type, int warningLevel)
public string get_CompilerOptions()
internal void set_CompilerOptions(string value)
public string get_Extension()
internal void set_Extension(string value)
public string get_Language()
internal void set_Language(string value)
public string get_Type()
internal void set_Type(string value)
public int get_WarningLevel()
internal void set_WarningLevel(int value)
public CompilerProviderOptionsCollection get_ProviderOptions()
internal void set_ProviderOptions(CompilerProviderOptionsCollection value)
public Dictionary`2<string, string> get_ProviderOptionsDictionary()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.CodeDom.Compiler.CompilerCollection : ConfigurationElementCollection {
private string defaultCompilerVersion
private ConfigurationPropertyCollection properties
private List`1<CompilerInfo> compiler_infos
private Dictionary`2<string, CompilerInfo> compiler_languages
private Dictionary`2<string, CompilerInfo> compiler_extensions
protected bool ThrowOnDuplicate
public String[] AllKeys
public ConfigurationElementCollectionType CollectionType
protected string ElementName
protected ConfigurationPropertyCollection Properties
public Compiler Item
public CompilerInfo Item
public CompilerInfo[] CompilerInfos
private void AddCompilerInfo(CompilerInfo ci)
private void AddCompilerInfo(Compiler compiler)
protected void BaseAdd(ConfigurationElement element)
protected bool get_ThrowOnDuplicate()
protected ConfigurationElement CreateNewElement()
public CompilerInfo GetCompilerInfoForLanguage(string language)
public CompilerInfo GetCompilerInfoForExtension(string extension)
public string GetLanguageFromExtension(string extension)
public Compiler Get(int index)
public Compiler Get(string language)
protected object GetElementKey(ConfigurationElement element)
public string GetKey(int index)
public String[] get_AllKeys()
public ConfigurationElementCollectionType get_CollectionType()
protected string get_ElementName()
protected ConfigurationPropertyCollection get_Properties()
public Compiler get_Item(int index)
public CompilerInfo get_Item(string language)
public CompilerInfo[] get_CompilerInfos()
}
public System.CodeDom.Compiler.CompilerError : object {
private int <Line>k__BackingField
private int <Column>k__BackingField
private string <ErrorNumber>k__BackingField
private string <ErrorText>k__BackingField
private bool <IsWarning>k__BackingField
private string <FileName>k__BackingField
public int Line
public int Column
public string ErrorNumber
public string ErrorText
public bool IsWarning
public string FileName
private string WarningString
public void .ctor(string fileName, int line, int column, string errorNumber, string errorText)
public int get_Line()
public void set_Line(int value)
public int get_Column()
public void set_Column(int value)
public string get_ErrorNumber()
public void set_ErrorNumber(string value)
public string get_ErrorText()
public void set_ErrorText(string value)
public bool get_IsWarning()
public void set_IsWarning(bool value)
public string get_FileName()
public void set_FileName(string value)
public string ToString()
private string get_WarningString()
}
public System.CodeDom.Compiler.CompilerErrorCollection : CollectionBase {
public CompilerError Item
public bool HasErrors
public bool HasWarnings
public void .ctor(CompilerErrorCollection value)
public void .ctor(CompilerError[] value)
public CompilerError get_Item(int index)
public void set_Item(int index, CompilerError value)
public int Add(CompilerError value)
public void AddRange(CompilerError[] value)
public void AddRange(CompilerErrorCollection value)
public bool Contains(CompilerError value)
public void CopyTo(CompilerError[] array, int index)
public bool get_HasErrors()
public bool get_HasWarnings()
public int IndexOf(CompilerError value)
public void Insert(int index, CompilerError value)
public void Remove(CompilerError value)
}
public System.CodeDom.Compiler.CompilerInfo : object {
internal IDictionary`2<string, string> _providerOptions
internal string _codeDomProviderTypeName
internal CompilerParameters _compilerParams
internal String[] _compilerLanguages
internal String[] _compilerExtensions
private Type _type
public Type CodeDomProviderType
public bool IsCodeDomProviderTypeValid
internal CompilerParameters CompilerParams
internal IDictionary`2<string, string> ProviderOptions
public String[] GetLanguages()
public String[] GetExtensions()
public Type get_CodeDomProviderType()
public bool get_IsCodeDomProviderTypeValid()
public CodeDomProvider CreateProvider()
public CodeDomProvider CreateProvider(IDictionary`2<string, string> providerOptions)
public CompilerParameters CreateDefaultCompilerParameters()
internal void .ctor(CompilerParameters compilerParams, string codeDomProviderTypeName, String[] compilerLanguages, String[] compilerExtensions)
internal void .ctor(CompilerParameters compilerParams, string codeDomProviderTypeName)
public int GetHashCode()
public bool Equals(object o)
private CompilerParameters CloneCompilerParameters()
private String[] CloneCompilerLanguages()
private String[] CloneCompilerExtensions()
internal CompilerParameters get_CompilerParams()
internal IDictionary`2<string, string> get_ProviderOptions()
}
public System.CodeDom.Compiler.CompilerParameters : object {
private Evidence _evidence
private StringCollection _assemblyNames
private StringCollection _embeddedResources
private StringCollection _linkedResources
private TempFileCollection _tempFiles
private string <CoreAssemblyFileName>k__BackingField
private bool <GenerateExecutable>k__BackingField
private bool <GenerateInMemory>k__BackingField
private string <MainClass>k__BackingField
private string <OutputAssembly>k__BackingField
private bool <IncludeDebugInformation>k__BackingField
private bool <TreatWarningsAsErrors>k__BackingField
private int <WarningLevel>k__BackingField
private string <CompilerOptions>k__BackingField
private string <Win32Resource>k__BackingField
private IntPtr <UserToken>k__BackingField
public Evidence Evidence
public string CoreAssemblyFileName
public bool GenerateExecutable
public bool GenerateInMemory
public StringCollection ReferencedAssemblies
public string MainClass
public string OutputAssembly
public TempFileCollection TempFiles
public bool IncludeDebugInformation
public bool TreatWarningsAsErrors
public int WarningLevel
public string CompilerOptions
public string Win32Resource
public StringCollection EmbeddedResources
public StringCollection LinkedResources
public IntPtr UserToken
public Evidence get_Evidence()
public void set_Evidence(Evidence value)
public void .ctor(String[] assemblyNames)
public void .ctor(String[] assemblyNames, string outputName)
public void .ctor(String[] assemblyNames, string outputName, bool includeDebugInformation)
public string get_CoreAssemblyFileName()
public void set_CoreAssemblyFileName(string value)
public bool get_GenerateExecutable()
public void set_GenerateExecutable(bool value)
public bool get_GenerateInMemory()
public void set_GenerateInMemory(bool value)
public StringCollection get_ReferencedAssemblies()
public string get_MainClass()
public void set_MainClass(string value)
public string get_OutputAssembly()
public void set_OutputAssembly(string value)
public TempFileCollection get_TempFiles()
public void set_TempFiles(TempFileCollection value)
public bool get_IncludeDebugInformation()
public void set_IncludeDebugInformation(bool value)
public bool get_TreatWarningsAsErrors()
public void set_TreatWarningsAsErrors(bool value)
public int get_WarningLevel()
public void set_WarningLevel(int value)
public string get_CompilerOptions()
public void set_CompilerOptions(string value)
public string get_Win32Resource()
public void set_Win32Resource(string value)
public StringCollection get_EmbeddedResources()
public StringCollection get_LinkedResources()
public IntPtr get_UserToken()
public void set_UserToken(IntPtr value)
}
internal System.CodeDom.Compiler.CompilerProviderOption : ConfigurationElement {
private ConfigurationProperty nameProp
private ConfigurationProperty valueProp
private ConfigurationPropertyCollection properties
public string Name
public string Value
protected ConfigurationPropertyCollection Properties
public string get_Name()
public void set_Name(string value)
public string get_Value()
public void set_Value(string value)
protected ConfigurationPropertyCollection get_Properties()
}
internal System.CodeDom.Compiler.CompilerProviderOptionsCollection : ConfigurationElementCollection {
private ConfigurationPropertyCollection properties
public String[] AllKeys
protected string ElementName
protected ConfigurationPropertyCollection Properties
public Dictionary`2<string, string> ProviderOptions
public CompilerProviderOption Item
public CompilerProviderOption Item
protected ConfigurationElement CreateNewElement()
public CompilerProviderOption Get(int index)
public CompilerProviderOption Get(string name)
protected object GetElementKey(ConfigurationElement element)
public string GetKey(int index)
public String[] get_AllKeys()
protected string get_ElementName()
protected ConfigurationPropertyCollection get_Properties()
public Dictionary`2<string, string> get_ProviderOptions()
public CompilerProviderOption get_Item(int index)
public CompilerProviderOption get_Item(string name)
}
public System.CodeDom.Compiler.CompilerResults : object {
private Evidence _evidence
private CompilerErrorCollection _errors
private StringCollection _output
private Assembly _compiledAssembly
private TempFileCollection _tempFiles
private string <PathToAssembly>k__BackingField
private int <NativeCompilerReturnValue>k__BackingField
public Evidence Evidence
public TempFileCollection TempFiles
public Assembly CompiledAssembly
public CompilerErrorCollection Errors
public StringCollection Output
public string PathToAssembly
public int NativeCompilerReturnValue
public Evidence get_Evidence()
public void set_Evidence(Evidence value)
public void .ctor(TempFileCollection tempFiles)
public TempFileCollection get_TempFiles()
public void set_TempFiles(TempFileCollection value)
public Assembly get_CompiledAssembly()
public void set_CompiledAssembly(Assembly value)
public CompilerErrorCollection get_Errors()
public StringCollection get_Output()
public string get_PathToAssembly()
public void set_PathToAssembly(string value)
public int get_NativeCompilerReturnValue()
public void set_NativeCompilerReturnValue(int value)
}
public System.CodeDom.Compiler.Executor : object {
public void ExecWait(string cmd, TempFileCollection tempFiles)
public int ExecWaitWithCapture(IntPtr userToken, string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName)
public int ExecWaitWithCapture(IntPtr userToken, string cmd, TempFileCollection tempFiles, String& outputName, String& errorName)
public int ExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName)
public int ExecWaitWithCapture(string cmd, TempFileCollection tempFiles, String& outputName, String& errorName)
private int InternalExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName)
}
internal System.CodeDom.Compiler.ExposedTabStringIndentedTextWriter : IndentedTextWriter {
private string <TabString>k__BackingField
internal string TabString
public void .ctor(TextWriter writer, string tabString)
internal void InternalOutputTabs()
internal string get_TabString()
}
public System.CodeDom.Compiler.GeneratedCodeAttribute : Attribute {
private string tool
private string version
public string Tool
public string Version
public void .ctor(string tool, string version)
public string get_Tool()
public string get_Version()
}
public System.CodeDom.Compiler.GeneratorSupport : Enum {
public int value__
public GeneratorSupport ArraysOfArrays
public GeneratorSupport EntryPointMethod
public GeneratorSupport GotoStatements
public GeneratorSupport MultidimensionalArrays
public GeneratorSupport StaticConstructors
public GeneratorSupport TryCatchStatements
public GeneratorSupport ReturnTypeAttributes
public GeneratorSupport DeclareValueTypes
public GeneratorSupport DeclareEnums
public GeneratorSupport DeclareDelegates
public GeneratorSupport DeclareInterfaces
public GeneratorSupport DeclareEvents
public GeneratorSupport AssemblyAttributes
public GeneratorSupport ParameterAttributes
public GeneratorSupport ReferenceParameters
public GeneratorSupport ChainedConstructorArguments
public GeneratorSupport NestedTypes
public GeneratorSupport MultipleInterfaceMembers
public GeneratorSupport PublicStaticMembers
public GeneratorSupport ComplexExpressions
public GeneratorSupport Win32Resources
public GeneratorSupport Resources
public GeneratorSupport PartialTypes
public GeneratorSupport GenericTypeReference
public GeneratorSupport GenericTypeDeclaration
public GeneratorSupport DeclareIndexerProperties
}
public System.CodeDom.Compiler.ICodeCompiler {
public CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit compilationUnit)
public CompilerResults CompileAssemblyFromFile(CompilerParameters options, string fileName)
public CompilerResults CompileAssemblyFromSource(CompilerParameters options, string source)
public CompilerResults CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] compilationUnits)
public CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames)
public CompilerResults CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources)
}
public System.CodeDom.Compiler.ICodeGenerator {
public bool IsValidIdentifier(string value)
public void ValidateIdentifier(string value)
public string CreateEscapedIdentifier(string value)
public string CreateValidIdentifier(string value)
public string GetTypeOutput(CodeTypeReference type)
public bool Supports(GeneratorSupport supports)
public void GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o)
public void GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o)
}
public System.CodeDom.Compiler.ICodeParser {
public CodeCompileUnit Parse(TextReader codeStream)
}
internal System.CodeDom.Compiler.Indentation : object {
private ExposedTabStringIndentedTextWriter _writer
private int _indent
private string _s
internal string IndentationString
internal void .ctor(ExposedTabStringIndentedTextWriter writer, int indent)
internal string get_IndentationString()
}
public System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
private TextWriter _writer
private string _tabString
private int _indentLevel
private bool _tabsPending
public string DefaultTabString
public Encoding Encoding
public string NewLine
public int Indent
public TextWriter InnerWriter
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string tabString)
public Encoding get_Encoding()
public string get_NewLine()
public void set_NewLine(string value)
public int get_Indent()
public void set_Indent(int value)
public TextWriter get_InnerWriter()
public void Close()
public void Flush()
protected void OutputTabs()
public void Write(string s)
public void Write(bool value)
public void Write(char value)
public void Write(Char[] buffer)
public void Write(Char[] buffer, int index, int count)
public void Write(double value)
public void Write(float value)
public void Write(int value)
public void Write(long value)
public void Write(object value)
public void Write(string format, object arg0)
public void Write(string format, object arg0, object arg1)
public void Write(string format, Object[] arg)
public void WriteLineNoTabs(string s)
public void WriteLine(string s)
public void WriteLine()
public void WriteLine(bool value)
public void WriteLine(char value)
public void WriteLine(Char[] buffer)
public void WriteLine(Char[] buffer, int index, int count)
public void WriteLine(double value)
public void WriteLine(float value)
public void WriteLine(int value)
public void WriteLine(long value)
public void WriteLine(object value)
public void WriteLine(string format, object arg0)
public void WriteLine(string format, object arg0, object arg1)
public void WriteLine(string format, Object[] arg)
public void WriteLine(UInt32 value)
}
public System.CodeDom.Compiler.LanguageOptions : Enum {
public int value__
public LanguageOptions None
public LanguageOptions CaseInsensitive
}
public System.CodeDom.Compiler.TempFileCollection : object {
private string _basePath
private string _tempDir
private Hashtable _files
private bool <KeepFiles>k__BackingField
public int Count
private int System.Collections.ICollection.Count
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
public string TempDir
public string BasePath
public bool KeepFiles
public void .ctor(string tempDir)
public void .ctor(string tempDir, bool keepFiles)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
public string AddExtension(string fileExtension)
public string AddExtension(string fileExtension, bool keepFile)
public void AddFile(string fileName, bool keepFile)
public IEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int start)
public void CopyTo(String[] fileNames, int start)
public int get_Count()
private int System.Collections.ICollection.get_Count()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
public string get_TempDir()
public string get_BasePath()
private void EnsureTempNameCreated()
public bool get_KeepFiles()
public void set_KeepFiles(bool value)
private bool KeepFile(string fileName)
public void Delete()
internal void Delete(string fileName)
internal void SafeDelete()
}
public System.CodeDom.FieldDirection : Enum {
public int value__
public FieldDirection In
public FieldDirection Out
public FieldDirection Ref
}
public System.CodeDom.MemberAttributes : Enum {
public int value__
public MemberAttributes Abstract
public MemberAttributes Final
public MemberAttributes Static
public MemberAttributes Override
public MemberAttributes Const
public MemberAttributes New
public MemberAttributes Overloaded
public MemberAttributes Assembly
public MemberAttributes FamilyAndAssembly
public MemberAttributes Family
public MemberAttributes FamilyOrAssembly
public MemberAttributes Private
public MemberAttributes Public
public MemberAttributes AccessMask
public MemberAttributes ScopeMask
public MemberAttributes VTableMask
}
public System.Collections.Concurrent.BlockingCollection`1 : object {
private IProducerConsumerCollection`1<T> _collection
private int _boundedCapacity
private int NON_BOUNDED
private SemaphoreSlim _freeNodes
private SemaphoreSlim _occupiedNodes
private bool _isDisposed
private CancellationTokenSource _consumersCancellationTokenSource
private CancellationTokenSource _producersCancellationTokenSource
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _currentAdders
private int COMPLETE_ADDING_ON_MASK
public int BoundedCapacity
public bool IsAddingCompleted
public bool IsCompleted
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool IsSTAThread
public int get_BoundedCapacity()
public bool get_IsAddingCompleted()
public bool get_IsCompleted()
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void .ctor(int boundedCapacity)
public void .ctor(IProducerConsumerCollection`1<T> collection, int boundedCapacity)
public void .ctor(IProducerConsumerCollection`1<T> collection)
private void Initialize(IProducerConsumerCollection`1<T> collection, int boundedCapacity, int collectionCount)
public void Add(T item)
public void Add(T item, CancellationToken cancellationToken)
public bool TryAdd(T item)
public bool TryAdd(T item, TimeSpan timeout)
public bool TryAdd(T item, int millisecondsTimeout)
public bool TryAdd(T item, int millisecondsTimeout, CancellationToken cancellationToken)
private bool TryAddWithNoTimeValidation(T item, int millisecondsTimeout, CancellationToken cancellationToken)
public T Take()
public T Take(CancellationToken cancellationToken)
public bool TryTake(T& item)
public bool TryTake(T& item, TimeSpan timeout)
public bool TryTake(T& item, int millisecondsTimeout)
public bool TryTake(T& item, int millisecondsTimeout, CancellationToken cancellationToken)
private bool TryTakeWithNoTimeValidation(T& item, int millisecondsTimeout, CancellationToken cancellationToken, CancellationTokenSource combinedTokenSource)
public int AddToAny(BlockingCollection`1[] collections, T item)
public int AddToAny(BlockingCollection`1[] collections, T item, CancellationToken cancellationToken)
public int TryAddToAny(BlockingCollection`1[] collections, T item)
public int TryAddToAny(BlockingCollection`1[] collections, T item, TimeSpan timeout)
public int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout)
public int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout, CancellationToken cancellationToken)
private int TryAddToAnyCore(BlockingCollection`1[] collections, T item, int millisecondsTimeout, CancellationToken externalCancellationToken)
private int TryAddToAnyFast(BlockingCollection`1[] collections, T item)
private List`1<WaitHandle> GetHandles(BlockingCollection`1[] collections, CancellationToken externalCancellationToken, bool isAddOperation, CancellationToken[]& cancellationTokens)
private int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout)
public int TakeFromAny(BlockingCollection`1[] collections, T& item)
public int TakeFromAny(BlockingCollection`1[] collections, T& item, CancellationToken cancellationToken)
public int TryTakeFromAny(BlockingCollection`1[] collections, T& item)
public int TryTakeFromAny(BlockingCollection`1[] collections, T& item, TimeSpan timeout)
public int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout)
public int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, CancellationToken cancellationToken)
private int TryTakeFromAnyCore(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, bool isTakeOperation, CancellationToken externalCancellationToken)
private int TryTakeFromAnyCoreSlow(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, bool isTakeOperation, CancellationToken externalCancellationToken)
public void CompleteAdding()
private void CancelWaitingConsumers()
private void CancelWaitingProducers()
public void Dispose()
protected void Dispose(bool disposing)
public T[] ToArray()
public void CopyTo(T[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public IEnumerable`1<T> GetConsumingEnumerable()
public IEnumerable`1<T> GetConsumingEnumerable(CancellationToken cancellationToken)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void ValidateCollectionsArray(BlockingCollection`1[] collections, bool isAddOperation)
private bool get_IsSTAThread()
private void ValidateTimeout(TimeSpan timeout)
private void ValidateMillisecondsTimeout(int millisecondsTimeout)
private void CheckDisposed()
}
internal System.Collections.Concurrent.BlockingCollectionDebugView`1 : object {
private BlockingCollection`1<T> _blockingCollection
public T[] Items
public void .ctor(BlockingCollection`1<T> collection)
public T[] get_Items()
}
internal System.Collections.Concurrent.CDSCollectionETWBCLProvider : EventSource {
public CDSCollectionETWBCLProvider Log
private EventKeywords ALL_KEYWORDS
private int CONCURRENTSTACK_FASTPUSHFAILED_ID
private int CONCURRENTSTACK_FASTPOPFAILED_ID
private int CONCURRENTDICTIONARY_ACQUIRINGALLLOCKS_ID
private int CONCURRENTBAG_TRYTAKESTEALS_ID
private int CONCURRENTBAG_TRYPEEKSTEALS_ID
public void ConcurrentStack_FastPushFailed(int spinCount)
public void ConcurrentStack_FastPopFailed(int spinCount)
public void ConcurrentDictionary_AcquiringAllLocks(int numOfBuckets)
public void ConcurrentBag_TryTakeSteals()
public void ConcurrentBag_TryPeekSteals()
}
public System.Collections.Concurrent.ConcurrentBag`1 : object {
private ThreadLocal`1<WorkStealingQueue<T>> _locals
private WorkStealingQueue modreq(System.Runtime.CompilerServices.IsVolatile) _workStealingQueues
private long _emptyToNonEmptyListTransitionCount
public int Count
private int DangerousCount
public bool IsEmpty
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private object GlobalQueuesLock
public void .ctor(IEnumerable`1<T> collection)
public void Add(T item)
private bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item)
public bool TryTake(T& result)
public bool TryPeek(T& result)
private WorkStealingQueue<T> GetCurrentThreadWorkStealingQueue(bool forceCreate)
private WorkStealingQueue<T> CreateWorkStealingQueueForCurrentThread()
private WorkStealingQueue<T> GetUnownedWorkStealingQueue()
private bool TrySteal(T& result, bool take)
private bool TryStealFromTo(WorkStealingQueue<T> startInclusive, WorkStealingQueue<T> endExclusive, T& result, bool take)
public void CopyTo(T[] array, int index)
private int CopyFromEachQueueToArray(T[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public T[] ToArray()
public void Clear()
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
private int get_DangerousCount()
public bool get_IsEmpty()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private object get_GlobalQueuesLock()
private void FreezeBag(Boolean& lockTaken)
private void UnfreezeBag(bool lockTaken)
}
internal System.Collections.Generic.BidirectionalDictionary`2 : object {
private Dictionary`2<T1, T2> _forward
private Dictionary`2<T2, T1> _backward
public int Count
public void .ctor(int capacity)
public int get_Count()
public void Add(T1 item1, T2 item2)
public bool TryGetForward(T1 item1, T2& item2)
public bool TryGetBackward(T2 item2, T1& item1)
public Enumerator<T1, T2> GetEnumerator()
private IEnumerator`1<KeyValuePair`2<T1, T2>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T1,T2>>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.Collections.Generic.BitHelper : object {
private byte MarkedBitFlag
private byte IntSize
private int _length
private Int32* _arrayPtr
private Int32[] _array
private bool _useStackAlloc
internal void .ctor(Int32* bitArrayPtr, int length)
internal void .ctor(Int32[] bitArray, int length)
internal void MarkBit(int bitPosition)
internal bool IsMarked(int bitPosition)
internal int ToIntArrayLength(int n)
}
internal System.Collections.Generic.CollectionDebugView`1 : object {
private ICollection`1<T> _collection
public T[] Items
public void .ctor(ICollection`1<T> collection)
public T[] get_Items()
}
internal System.Collections.Generic.DictionaryDebugView`2 : object {
private IDictionary`2<K, V> _dict
public KeyValuePair`2[] Items
public void .ctor(IDictionary`2<K, V> dictionary)
public KeyValuePair`2[] get_Items()
}
internal System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
private ICollection`1<TKey> _collection
public TKey[] Items
public void .ctor(ICollection`1<TKey> collection)
public TKey[] get_Items()
}
internal System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
private ICollection`1<TValue> _collection
public TValue[] Items
public void .ctor(ICollection`1<TValue> collection)
public TValue[] get_Items()
}
internal System.Collections.Generic.ICollectionDebugView`1 : object {
private ICollection`1<T> _collection
public T[] Items
public void .ctor(ICollection`1<T> collection)
public T[] get_Items()
}
internal System.Collections.Generic.IDictionaryDebugView`2 : object {
private IDictionary`2<K, V> _dict
public KeyValuePair`2[] Items
public void .ctor(IDictionary`2<K, V> dictionary)
public KeyValuePair`2[] get_Items()
}
public System.Collections.Generic.ISet`1 {
public bool Add(T item)
public void UnionWith(IEnumerable`1<T> other)
public void IntersectWith(IEnumerable`1<T> other)
public void ExceptWith(IEnumerable`1<T> other)
public void SymmetricExceptWith(IEnumerable`1<T> other)
public bool IsSubsetOf(IEnumerable`1<T> other)
public bool IsSupersetOf(IEnumerable`1<T> other)
public bool IsProperSupersetOf(IEnumerable`1<T> other)
public bool IsProperSubsetOf(IEnumerable`1<T> other)
public bool Overlaps(IEnumerable`1<T> other)
public bool SetEquals(IEnumerable`1<T> other)
}
public System.Collections.Generic.LinkedList`1 : object {
internal LinkedListNode`1<T> head
internal int count
internal int version
private object _syncRoot
private SerializationInfo _siInfo
private string VersionName
private string CountName
private string ValuesName
public int Count
public LinkedListNode`1<T> First
public LinkedListNode`1<T> Last
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(IEnumerable`1<T> collection)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_Count()
public LinkedListNode`1<T> get_First()
public LinkedListNode`1<T> get_Last()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<T>.Add(T value)
public LinkedListNode`1<T> AddAfter(LinkedListNode`1<T> node, T value)
public void AddAfter(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode)
public LinkedListNode`1<T> AddBefore(LinkedListNode`1<T> node, T value)
public void AddBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode)
public LinkedListNode`1<T> AddFirst(T value)
public void AddFirst(LinkedListNode`1<T> node)
public LinkedListNode`1<T> AddLast(T value)
public void AddLast(LinkedListNode`1<T> node)
public void Clear()
public bool Contains(T value)
public void CopyTo(T[] array, int index)
public LinkedListNode`1<T> Find(T value)
public LinkedListNode`1<T> FindLast(T value)
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
public bool Remove(T value)
public void Remove(LinkedListNode`1<T> node)
public void RemoveFirst()
public void RemoveLast()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
private void InternalInsertNodeBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode)
private void InternalInsertNodeToEmptyList(LinkedListNode`1<T> newNode)
internal void InternalRemoveNode(LinkedListNode`1<T> node)
internal void ValidateNewNode(LinkedListNode`1<T> node)
internal void ValidateNode(LinkedListNode`1<T> node)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Collections.Generic.LinkedListNode`1 : object {
internal LinkedList`1<T> list
internal LinkedListNode`1<T> next
internal LinkedListNode`1<T> prev
internal T item
public LinkedList`1<T> List
public LinkedListNode`1<T> Next
public LinkedListNode`1<T> Previous
public T Value
public void .ctor(T value)
internal void .ctor(LinkedList`1<T> list, T value)
public LinkedList`1<T> get_List()
public LinkedListNode`1<T> get_Next()
public LinkedListNode`1<T> get_Previous()
public T get_Value()
public void set_Value(T value)
internal void Invalidate()
}
internal System.Collections.Generic.NodeColor : Enum {
public byte value__
public NodeColor Black
public NodeColor Red
}
public System.Collections.Generic.SortedDictionary`2 : object {
private KeyCollection<TKey, TValue> _keys
private ValueCollection<TKey, TValue> _values
private TreeSet`1<KeyValuePair`2<TKey, TValue>> _set
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
public TValue Item
public int Count
public IComparer`1<TKey> Comparer
public KeyCollection<TKey, TValue> Keys
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys
public ValueCollection<TKey, TValue> Values
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private object System.Collections.IDictionary.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public void .ctor(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer)
public void .ctor(IComparer`1<TKey> comparer)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public int get_Count()
public IComparer`1<TKey> get_Comparer()
public KeyCollection<TKey, TValue> get_Keys()
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys()
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys()
public ValueCollection<TKey, TValue> get_Values()
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values()
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values()
public void Add(TKey key, TValue value)
public void Clear()
public bool ContainsKey(TKey key)
public bool ContainsValue(TValue value)
public void CopyTo(KeyValuePair`2[] array, int index)
public Enumerator<TKey, TValue> GetEnumerator()
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator()
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private ICollection System.Collections.IDictionary.get_Keys()
private ICollection System.Collections.IDictionary.get_Values()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private void System.Collections.IDictionary.Add(object key, object value)
private bool System.Collections.IDictionary.Contains(object key)
private bool IsCompatibleKey(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private void System.Collections.IDictionary.Remove(object key)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Collections.Generic.SortedList`2 : object {
private TKey[] keys
private TValue[] values
private int _size
private int version
private IComparer`1<TKey> comparer
private KeyList<TKey, TValue> keyList
private ValueList<TKey, TValue> valueList
private object _syncRoot
private int DefaultCapacity
private int MaxArrayLength
public int Capacity
public IComparer`1<TKey> Comparer
public int Count
public IList`1<TKey> Keys
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys
private ICollection System.Collections.IDictionary.Keys
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys
public IList`1<TValue> Values
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values
private ICollection System.Collections.IDictionary.Values
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
private bool System.Collections.IDictionary.IsReadOnly
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public TValue Item
private object System.Collections.IDictionary.Item
public void .ctor(int capacity)
public void .ctor(IComparer`1<TKey> comparer)
public void .ctor(int capacity, IComparer`1<TKey> comparer)
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public void .ctor(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer)
public void Add(TKey key, TValue value)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair)
public int get_Capacity()
public void set_Capacity(int value)
public IComparer`1<TKey> get_Comparer()
private void System.Collections.IDictionary.Add(object key, object value)
public int get_Count()
public IList`1<TKey> get_Keys()
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys()
private ICollection System.Collections.IDictionary.get_Keys()
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys()
public IList`1<TValue> get_Values()
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values()
private ICollection System.Collections.IDictionary.get_Values()
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values()
private KeyList<TKey, TValue> GetKeyListHelper()
private ValueList<TKey, TValue> GetValueListHelper()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
private bool System.Collections.IDictionary.get_IsReadOnly()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void Clear()
private bool System.Collections.IDictionary.Contains(object key)
public bool ContainsKey(TKey key)
public bool ContainsValue(TValue value)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private void EnsureCapacity(int min)
private TValue GetByIndex(int index)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator()
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private TKey GetKey(int index)
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
public int IndexOfKey(TKey key)
public int IndexOfValue(TValue value)
private void Insert(int index, TKey key, TValue value)
public bool TryGetValue(TKey key, TValue& value)
public void RemoveAt(int index)
public bool Remove(TKey key)
private void System.Collections.IDictionary.Remove(object key)
public void TrimExcess()
private bool IsCompatibleKey(object key)
}
public System.Collections.Generic.SortedSet`1 : object {
private Node<T> root
private IComparer`1<T> comparer
private int count
private int version
private object _syncRoot
private SerializationInfo siInfo
private string ComparerName
private string CountName
private string ItemsName
private string VersionName
private string TreeName
private string NodeValueName
private string EnumStartName
private string ReverseName
private string EnumVersionName
private string MinName
private string MaxName
private string LowerBoundActiveName
private string UpperBoundActiveName
internal int StackAllocThreshold
public int Count
public IComparer`1<T> Comparer
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public T Min
internal T MinInternal
public T Max
internal T MaxInternal
public void .ctor(IComparer`1<T> comparer)
public void .ctor(IEnumerable`1<T> collection)
public void .ctor(IEnumerable`1<T> collection, IComparer`1<T> comparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void AddAllElements(IEnumerable`1<T> collection)
private void RemoveAllElements(IEnumerable`1<T> collection)
private bool ContainsAllElements(IEnumerable`1<T> collection)
internal bool InOrderTreeWalk(TreeWalkPredicate`1<T> action)
internal bool BreadthFirstTreeWalk(TreeWalkPredicate`1<T> action)
public int get_Count()
public IComparer`1<T> get_Comparer()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
internal void VersionCheck()
internal bool IsWithinRange(T item)
public bool Add(T item)
private void System.Collections.Generic.ICollection<T>.Add(T item)
internal bool AddIfNotPresent(T item)
public bool Remove(T item)
internal bool DoRemove(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array)
public void CopyTo(T[] array, int index)
public void CopyTo(T[] array, int index, int count)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void InsertionBalance(Node<T> current, Node& parent, Node<T> grandParent, Node<T> greatGrandParent)
private void ReplaceChildOrRoot(Node<T> parent, Node<T> child, Node<T> newChild)
private void ReplaceNode(Node<T> match, Node<T> parentOfMatch, Node<T> successor, Node<T> parentOfSuccessor)
internal Node<T> FindNode(T item)
internal int InternalIndexOf(T item)
internal Node<T> FindRange(T from, T to)
internal Node<T> FindRange(T from, T to, bool lowerBoundActive, bool upperBoundActive)
internal void UpdateVersion()
public IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer()
public IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer(IEqualityComparer`1<T> memberEqualityComparer)
internal bool SortedSetEquals(SortedSet`1<T> set1, SortedSet`1<T> set2, IComparer`1<T> comparer)
private bool HasEqualComparer(SortedSet`1<T> other)
public void UnionWith(IEnumerable`1<T> other)
private Node<T> ConstructRootFromSortedArray(T[] arr, int startIndex, int endIndex, Node<T> redNode)
public void IntersectWith(IEnumerable`1<T> other)
internal void IntersectWithEnumerable(IEnumerable`1<T> other)
public void ExceptWith(IEnumerable`1<T> other)
public void SymmetricExceptWith(IEnumerable`1<T> other)
private void SymmetricExceptWithSameComparer(SortedSet`1<T> other)
private void SymmetricExceptWithSameComparer(T[] other, int count)
public bool IsSubsetOf(IEnumerable`1<T> other)
private bool IsSubsetOfSortedSetWithSameComparer(SortedSet`1<T> asSorted)
public bool IsProperSubsetOf(IEnumerable`1<T> other)
public bool IsSupersetOf(IEnumerable`1<T> other)
public bool IsProperSupersetOf(IEnumerable`1<T> other)
public bool SetEquals(IEnumerable`1<T> other)
public bool Overlaps(IEnumerable`1<T> other)
private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound)
public int RemoveWhere(Predicate`1<T> match)
public T get_Min()
internal T get_MinInternal()
public T get_Max()
internal T get_MaxInternal()
public IEnumerable`1<T> Reverse()
public SortedSet`1<T> GetViewBetween(T lowerValue, T upperValue)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
protected void GetObjectData(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
protected void OnDeserialization(object sender)
public bool TryGetValue(T equalValue, T& actualValue)
private int Log2(int value)
}
internal System.Collections.Generic.SortedSetEqualityComparer`1 : object {
private IComparer`1<T> _comparer
private IEqualityComparer`1<T> _memberEqualityComparer
public void .ctor(IEqualityComparer`1<T> memberEqualityComparer)
private void .ctor(IComparer`1<T> comparer, IEqualityComparer`1<T> memberEqualityComparer)
public bool Equals(SortedSet`1<T> x, SortedSet`1<T> y)
public int GetHashCode(SortedSet`1<T> obj)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.Collections.Generic.TreeRotation : Enum {
public byte value__
public TreeRotation Left
public TreeRotation LeftRight
public TreeRotation Right
public TreeRotation RightLeft
}
internal System.Collections.Generic.TreeSet`1 : SortedSet`1<T> {
public void .ctor(IComparer`1<T> comparer)
public void .ctor(SerializationInfo siInfo, StreamingContext context)
internal bool AddIfNotPresent(T item)
}
internal System.Collections.Generic.TreeWalkPredicate`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(Node<T> node)
public IAsyncResult BeginInvoke(Node<T> node, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal System.Collections.Generic.ValueListBuilder`1 : ValueType {
private Span`1<T> _span
private T[] _arrayFromPool
private int _pos
public int Length
public T& Item
public void .ctor(Span`1<T> initialSpan)
public int get_Length()
public T& get_Item(int index)
public void Append(T item)
public ReadOnlySpan`1<T> AsSpan()
public void Dispose()
private void Grow()
public T Pop()
}
internal System.Collections.HashtableExtensions : object {
public bool TryGetValue(Hashtable table, object key, T& value)
}
internal System.Collections.ObjectModel.EventArgsCache : object {
internal PropertyChangedEventArgs CountPropertyChanged
internal PropertyChangedEventArgs IndexerPropertyChanged
internal NotifyCollectionChangedEventArgs ResetCollectionChanged
}
public System.Collections.ObjectModel.ObservableCollection`1 : Collection`1<T> {
private SimpleMonitor<T> _monitor
private int _blockReentrancyCount
private NotifyCollectionChangedEventHandler CollectionChanged
private PropertyChangedEventHandler PropertyChanged
public void .ctor(IEnumerable`1<T> collection)
public void .ctor(List`1<T> list)
private List`1<T> CreateCopy(IEnumerable`1<T> collection, string paramName)
public void Move(int oldIndex, int newIndex)
private void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value)
private void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value)
public void add_CollectionChanged(NotifyCollectionChangedEventHandler value)
public void remove_CollectionChanged(NotifyCollectionChangedEventHandler value)
protected void ClearItems()
protected void RemoveItem(int index)
protected void InsertItem(int index, T item)
protected void SetItem(int index, T item)
protected void MoveItem(int oldIndex, int newIndex)
protected void OnPropertyChanged(PropertyChangedEventArgs e)
protected void add_PropertyChanged(PropertyChangedEventHandler value)
protected void remove_PropertyChanged(PropertyChangedEventHandler value)
protected void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
protected IDisposable BlockReentrancy()
protected void CheckReentrancy()
private void OnCountPropertyChanged()
private void OnIndexerPropertyChanged()
private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index)
private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index, int oldIndex)
private void OnCollectionChanged(NotifyCollectionChangedAction action, object oldItem, object newItem, int index)
private void OnCollectionReset()
private SimpleMonitor<T> EnsureMonitorInitialized()
private void OnSerializing(StreamingContext context)
private void OnDeserialized(StreamingContext context)
}
public System.Collections.ObjectModel.ReadOnlyObservableCollection`1 : ReadOnlyCollection`1<T> {
private NotifyCollectionChangedEventHandler CollectionChanged
private PropertyChangedEventHandler PropertyChanged
public void .ctor(ObservableCollection`1<T> list)
private void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value)
private void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value)
protected void add_CollectionChanged(NotifyCollectionChangedEventHandler value)
protected void remove_CollectionChanged(NotifyCollectionChangedEventHandler value)
protected void OnCollectionChanged(NotifyCollectionChangedEventArgs args)
private void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value)
private void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value)
protected void add_PropertyChanged(PropertyChangedEventHandler value)
protected void remove_PropertyChanged(PropertyChangedEventHandler value)
protected void OnPropertyChanged(PropertyChangedEventArgs args)
private void HandleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
private void HandlePropertyChanged(object sender, PropertyChangedEventArgs e)
}
public System.Collections.Specialized.BitVector32 : ValueType {
private UInt32 _data
public bool Item
public int Item
public int Data
public void .ctor(int data)
public void .ctor(BitVector32 value)
public bool get_Item(int bit)
public void set_Item(int bit, bool value)
public int get_Item(Section section)
public void set_Item(Section section, int value)
public int get_Data()
private short CountBitsSet(short mask)
public int CreateMask()
public int CreateMask(int previous)
private short CreateMaskFromHighValue(short highValue)
public Section CreateSection(short maxValue)
public Section CreateSection(short maxValue, Section previous)
private Section CreateSectionHelper(short maxValue, short priorMask, short priorOffset)
public bool Equals(object o)
public int GetHashCode()
public string ToString(BitVector32 value)
public string ToString()
}
internal System.Collections.Specialized.CaseSensitiveStringDictionary : StringDictionary {
public string Item
public string get_Item(string key)
public void set_Item(string key, string value)
public void Add(string key, string value)
public bool ContainsKey(string key)
public void Remove(string key)
}
public System.Collections.Specialized.CollectionsUtil : object {
public Hashtable CreateCaseInsensitiveHashtable()
public Hashtable CreateCaseInsensitiveHashtable(int capacity)
public Hashtable CreateCaseInsensitiveHashtable(IDictionary d)
public SortedList CreateCaseInsensitiveSortedList()
}
internal System.Collections.Specialized.CompatibleComparer : object {
private IComparer _comparer
private IComparer modreq(System.Runtime.CompilerServices.IsVolatile) defaultComparer
private IHashCodeProvider _hcp
private IHashCodeProvider modreq(System.Runtime.CompilerServices.IsVolatile) defaultHashProvider
public IComparer Comparer
public IHashCodeProvider HashCodeProvider
public IComparer DefaultComparer
public IHashCodeProvider DefaultHashCodeProvider
internal void .ctor(IComparer comparer, IHashCodeProvider hashCodeProvider)
public bool Equals(object a, object b)
public int GetHashCode(object obj)
public IComparer get_Comparer()
public IHashCodeProvider get_HashCodeProvider()
public IComparer get_DefaultComparer()
public IHashCodeProvider get_DefaultHashCodeProvider()
}
internal System.Collections.Specialized.FixedStringLookup : object {
internal bool Contains(String[][] lookupTable, string value, bool ignoreCase)
private bool Contains(String[] array, string value, bool ignoreCase)
private bool FindCharacter(String[] array, char value, int pos, Int32& min, Int32& max)
}
internal System.Collections.Specialized.GenericAdapter : object {
private StringDictionary m_stringDictionary
private ICollectionToGenericCollectionAdapter _values
private ICollectionToGenericCollectionAdapter _keys
public int Count
public string Item
public ICollection`1<string> Keys
public ICollection`1<string> Values
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.IsReadOnly
internal void .ctor(StringDictionary stringDictionary)
public void Add(string key, string value)
public bool ContainsKey(string key)
public void Clear()
public int get_Count()
public string get_Item(string key)
public void set_Item(string key, string value)
public ICollection`1<string> get_Keys()
public ICollection`1<string> get_Values()
public bool Remove(string key)
public bool TryGetValue(string key, String& value)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Add(KeyValuePair`2<string, string> item)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Contains(KeyValuePair`2<string, string> item)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.CopyTo(KeyValuePair`2[] array, int arrayIndex)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.get_IsReadOnly()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Remove(KeyValuePair`2<string, string> item)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator()
}
public System.Collections.Specialized.HybridDictionary : object {
private int CutoverPoint
private int InitialHashtableSize
private int FixedSizeCutoverPoint
private ListDictionary list
private Hashtable hashtable
private bool caseInsensitive
public object Item
private ListDictionary List
public int Count
public ICollection Keys
public bool IsReadOnly
public bool IsFixedSize
public bool IsSynchronized
public object SyncRoot
public ICollection Values
public void .ctor(int initialSize)
public void .ctor(bool caseInsensitive)
public void .ctor(int initialSize, bool caseInsensitive)
public object get_Item(object key)
public void set_Item(object key, object value)
private ListDictionary get_List()
private void ChangeOver()
public int get_Count()
public ICollection get_Keys()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public bool get_IsSynchronized()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void CopyTo(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Remove(object key)
}
public System.Collections.Specialized.INotifyCollectionChanged {
public void add_CollectionChanged(NotifyCollectionChangedEventHandler value)
public void remove_CollectionChanged(NotifyCollectionChangedEventHandler value)
}
public System.Collections.Specialized.IOrderedDictionary {
public object Item
public object get_Item(int index)
public void set_Item(int index, object value)
public IDictionaryEnumerator GetEnumerator()
public void Insert(int index, object key, object value)
public void RemoveAt(int index)
}
public System.Collections.Specialized.ListDictionary : object {
private DictionaryNode head
private int version
private int count
private IComparer comparer
private object _syncRoot
public object Item
public int Count
public ICollection Keys
public bool IsReadOnly
public bool IsFixedSize
public bool IsSynchronized
public object SyncRoot
public ICollection Values
public void .ctor(IComparer comparer)
public object get_Item(object key)
public void set_Item(object key, object value)
public int get_Count()
public ICollection get_Keys()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public bool get_IsSynchronized()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void CopyTo(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Remove(object key)
}
public System.Collections.Specialized.NameObjectCollectionBase : object {
private string ReadOnlyName
private string CountName
private string ComparerName
private string HashCodeProviderName
private string KeysName
private string ValuesName
private string KeyComparerName
private string VersionName
private bool _readOnly
private ArrayList _entriesArray
private IEqualityComparer _keyComparer
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _entriesTable
private NameObjectEntry modreq(System.Runtime.CompilerServices.IsVolatile) _nullKeyEntry
private KeysCollection _keys
private SerializationInfo _serializationInfo
private int _version
private object _syncRoot
private StringComparer defaultComparer
internal IEqualityComparer Comparer
protected bool IsReadOnly
public int Count
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
public KeysCollection Keys
protected void .ctor(IEqualityComparer equalityComparer)
protected void .ctor(int capacity, IEqualityComparer equalityComparer)
protected void .ctor(IHashCodeProvider hashProvider, IComparer comparer)
protected void .ctor(int capacity, IHashCodeProvider hashProvider, IComparer comparer)
protected void .ctor(int capacity)
internal void .ctor(DBNull dummy)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
private void Reset()
private void Reset(int capacity)
private NameObjectEntry FindEntry(string key)
internal IEqualityComparer get_Comparer()
internal void set_Comparer(IEqualityComparer value)
protected bool get_IsReadOnly()
protected void set_IsReadOnly(bool value)
protected bool BaseHasKeys()
protected void BaseAdd(string name, object value)
protected void BaseRemove(string name)
protected void BaseRemoveAt(int index)
protected void BaseClear()
protected object BaseGet(string name)
protected void BaseSet(string name, object value)
protected object BaseGet(int index)
protected string BaseGetKey(int index)
protected void BaseSet(int index, object value)
public IEnumerator GetEnumerator()
public int get_Count()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
protected String[] BaseGetAllKeys()
protected Object[] BaseGetAllValues()
protected Object[] BaseGetAllValues(Type type)
public KeysCollection get_Keys()
}
public System.Collections.Specialized.NameValueCollection : NameObjectCollectionBase {
private String[] _all
private String[] _allKeys
public string Item
public string Item
public String[] AllKeys
public void .ctor(NameValueCollection col)
public void .ctor(IHashCodeProvider hashProvider, IComparer comparer)
public void .ctor(int capacity)
public void .ctor(IEqualityComparer equalityComparer)
public void .ctor(int capacity, IEqualityComparer equalityComparer)
public void .ctor(int capacity, NameValueCollection col)
public void .ctor(int capacity, IHashCodeProvider hashProvider, IComparer comparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
protected void InvalidateCachedArrays()
private string GetAsOneString(ArrayList list)
private String[] GetAsStringArray(ArrayList list)
public void Add(NameValueCollection c)
public void Clear()
public void CopyTo(Array dest, int index)
public bool HasKeys()
internal bool InternalHasKeys()
public void Add(string name, string value)
public string Get(string name)
public String[] GetValues(string name)
public void Set(string name, string value)
public void Remove(string name)
public string get_Item(string name)
public void set_Item(string name, string value)
public string Get(int index)
public String[] GetValues(int index)
public string GetKey(int index)
public string get_Item(int index)
public String[] get_AllKeys()
internal void .ctor(DBNull dummy)
}
public System.Collections.Specialized.NotifyCollectionChangedAction : Enum {
public int value__
public NotifyCollectionChangedAction Add
public NotifyCollectionChangedAction Remove
public NotifyCollectionChangedAction Replace
public NotifyCollectionChangedAction Move
public NotifyCollectionChangedAction Reset
}
public System.Collections.Specialized.NotifyCollectionChangedEventArgs : EventArgs {
private NotifyCollectionChangedAction _action
private IList _newItems
private IList _oldItems
private int _newStartingIndex
private int _oldStartingIndex
public NotifyCollectionChangedAction Action
public IList NewItems
public IList OldItems
public int NewStartingIndex
public int OldStartingIndex
public void .ctor(NotifyCollectionChangedAction action)
public void .ctor(NotifyCollectionChangedAction action, object changedItem)
public void .ctor(NotifyCollectionChangedAction action, object changedItem, int index)
public void .ctor(NotifyCollectionChangedAction action, IList changedItems)
public void .ctor(NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
public void .ctor(NotifyCollectionChangedAction action, object newItem, object oldItem)
public void .ctor(NotifyCollectionChangedAction action, object newItem, object oldItem, int index)
public void .ctor(NotifyCollectionChangedAction action, IList newItems, IList oldItems)
public void .ctor(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex)
public void .ctor(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex)
public void .ctor(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex)
internal void .ctor(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex)
private void InitializeAddOrRemove(NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
private void InitializeAdd(NotifyCollectionChangedAction action, IList newItems, int newStartingIndex)
private void InitializeRemove(NotifyCollectionChangedAction action, IList oldItems, int oldStartingIndex)
private void InitializeMoveOrReplace(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex, int oldStartingIndex)
public NotifyCollectionChangedAction get_Action()
public IList get_NewItems()
public IList get_OldItems()
public int get_NewStartingIndex()
public int get_OldStartingIndex()
}
public System.Collections.Specialized.NotifyCollectionChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, NotifyCollectionChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Collections.Specialized.OrderedDictionary : object {
private ArrayList _objectsArray
private Hashtable _objectsTable
private int _initialCapacity
private IEqualityComparer _comparer
private bool _readOnly
private object _syncRoot
private SerializationInfo _siInfo
private string KeyComparerName
private string ArrayListName
private string ReadOnlyName
private string InitCapacityName
public int Count
private bool System.Collections.IDictionary.IsFixedSize
public bool IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
public ICollection Keys
private ArrayList objectsArray
private Hashtable objectsTable
private object System.Collections.ICollection.SyncRoot
public object Item
public object Item
public ICollection Values
public void .ctor(int capacity)
public void .ctor(IEqualityComparer comparer)
public void .ctor(int capacity, IEqualityComparer comparer)
private void .ctor(OrderedDictionary dictionary)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_Count()
private bool System.Collections.IDictionary.get_IsFixedSize()
public bool get_IsReadOnly()
private bool System.Collections.ICollection.get_IsSynchronized()
public ICollection get_Keys()
private ArrayList get_objectsArray()
private Hashtable get_objectsTable()
private object System.Collections.ICollection.get_SyncRoot()
public object get_Item(int index)
public void set_Item(int index, object value)
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public OrderedDictionary AsReadOnly()
public bool Contains(object key)
public void CopyTo(Array array, int index)
private int IndexOfKey(object key)
public void Insert(int index, object key, object value)
public void RemoveAt(int index)
public void Remove(object key)
public IDictionaryEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void GetObjectData(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
protected void OnDeserialization(object sender)
}
internal System.Collections.Specialized.ReadOnlyList : object {
private IList _list
public int Count
public bool IsReadOnly
public bool IsFixedSize
public bool IsSynchronized
public object Item
public object SyncRoot
internal void .ctor(IList list)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsFixedSize()
public bool get_IsSynchronized()
public object get_Item(int index)
public void set_Item(int index, object value)
public object get_SyncRoot()
public int Add(object value)
public void Clear()
public bool Contains(object value)
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public int IndexOf(object value)
public void Insert(int index, object value)
public void Remove(object value)
public void RemoveAt(int index)
}
public System.Collections.Specialized.StringCollection : object {
private ArrayList data
public string Item
public int Count
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
public bool IsReadOnly
public bool IsSynchronized
public object SyncRoot
private object System.Collections.IList.Item
public string get_Item(int index)
public void set_Item(int index, string value)
public int get_Count()
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
public int Add(string value)
public void AddRange(String[] value)
public void Clear()
public bool Contains(string value)
public void CopyTo(String[] array, int index)
public StringEnumerator GetEnumerator()
public int IndexOf(string value)
public void Insert(int index, string value)
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public void Remove(string value)
public void RemoveAt(int index)
public object get_SyncRoot()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Collections.Specialized.StringDictionary : object {
internal Hashtable contents
public int Count
public bool IsSynchronized
public string Item
public ICollection Keys
public object SyncRoot
public ICollection Values
public int get_Count()
public bool get_IsSynchronized()
public string get_Item(string key)
public void set_Item(string key, string value)
public ICollection get_Keys()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(string key, string value)
public void Clear()
public bool ContainsKey(string key)
public bool ContainsValue(string value)
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string key)
internal void ReplaceHashtable(Hashtable useThisHashtableInstead)
internal IDictionary`2<string, string> AsGenericDictionary()
}
public System.Collections.Specialized.StringEnumerator : object {
private IEnumerator _baseEnumerator
private IEnumerable _temp
public string Current
internal void .ctor(StringCollection mappings)
public string get_Current()
public bool MoveNext()
public void Reset()
}
public System.ComponentModel.AddingNewEventArgs : EventArgs {
private object <NewObject>k__BackingField
public object NewObject
public void .ctor(object newObject)
public object get_NewObject()
public void set_NewObject(object value)
}
public System.ComponentModel.AddingNewEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AddingNewEventArgs e)
public IAsyncResult BeginInvoke(object sender, AddingNewEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.AmbientValueAttribute : Attribute {
private object <Value>k__BackingField
public object Value
public void .ctor(Type type, string value)
public void .ctor(char value)
public void .ctor(byte value)
public void .ctor(short value)
public void .ctor(int value)
public void .ctor(long value)
public void .ctor(float value)
public void .ctor(double value)
public void .ctor(bool value)
public void .ctor(string value)
public void .ctor(object value)
public object get_Value()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.ArrayConverter : CollectionConverter {
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
internal System.ComponentModel.ArraySubsetEnumerator : object {
private Array array
private int total
private int current
public object Current
public void .ctor(Array array, int count)
public bool MoveNext()
public void Reset()
public object get_Current()
}
public System.ComponentModel.AsyncCompletedEventArgs : EventArgs {
private Exception error
private bool cancelled
private object userState
public bool Cancelled
public Exception Error
public object UserState
public void .ctor(Exception error, bool cancelled, object userState)
public bool get_Cancelled()
public Exception get_Error()
public object get_UserState()
protected void RaiseExceptionIfNecessary()
}
public System.ComponentModel.AsyncCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AsyncCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.AsyncOperation : object {
private SynchronizationContext _syncContext
private object _userSuppliedState
private bool _alreadyCompleted
public object UserSuppliedState
public SynchronizationContext SynchronizationContext
private void .ctor(object userSuppliedState, SynchronizationContext syncContext)
protected void Finalize()
public object get_UserSuppliedState()
public SynchronizationContext get_SynchronizationContext()
public void Post(SendOrPostCallback d, object arg)
public void PostOperationCompleted(SendOrPostCallback d, object arg)
public void OperationCompleted()
private void PostCore(SendOrPostCallback d, object arg, bool markCompleted)
private void OperationCompletedCore()
private void VerifyNotCompleted()
private void VerifyDelegateNotNull(SendOrPostCallback d)
internal AsyncOperation CreateOperation(object userSuppliedState, SynchronizationContext syncContext)
}
public System.ComponentModel.AsyncOperationManager : object {
public SynchronizationContext SynchronizationContext
public AsyncOperation CreateOperation(object userSuppliedState)
public SynchronizationContext get_SynchronizationContext()
public void set_SynchronizationContext(SynchronizationContext value)
}
public System.ComponentModel.AttributeCollection : object {
public AttributeCollection Empty
private Hashtable s_defaultAttributes
private Attribute[] _attributes
private object s_internalSyncObject
private int FOUND_TYPES_LIMIT
private AttributeEntry[] _foundAttributeTypes
private int _index
protected Attribute[] Attributes
public int Count
public Attribute Item
public Attribute Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private int System.Collections.ICollection.Count
public void .ctor(Attribute[] attributes)
public AttributeCollection FromExisting(AttributeCollection existing, Attribute[] newAttributes)
protected Attribute[] get_Attributes()
public int get_Count()
public Attribute get_Item(int index)
public Attribute get_Item(Type attributeType)
public bool Contains(Attribute attribute)
public bool Contains(Attribute[] attributes)
protected Attribute GetDefaultAttribute(Type attributeType)
public IEnumerator GetEnumerator()
public bool Matches(Attribute attribute)
public bool Matches(Attribute[] attributes)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private int System.Collections.ICollection.get_Count()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void CopyTo(Array array, int index)
}
public System.ComponentModel.AttributeProviderAttribute : Attribute {
private string <TypeName>k__BackingField
private string <PropertyName>k__BackingField
public string TypeName
public string PropertyName
public void .ctor(string typeName)
public void .ctor(string typeName, string propertyName)
public void .ctor(Type type)
public string get_TypeName()
public string get_PropertyName()
}
public System.ComponentModel.BackgroundWorker : Component {
private bool _canCancelWorker
private bool _workerReportsProgress
private bool _cancellationPending
private bool _isRunning
private AsyncOperation _asyncOperation
private SendOrPostCallback _operationCompleted
private SendOrPostCallback _progressReporter
private DoWorkEventHandler DoWork
private ProgressChangedEventHandler ProgressChanged
private RunWorkerCompletedEventHandler RunWorkerCompleted
public bool CancellationPending
public bool IsBusy
public bool WorkerReportsProgress
public bool WorkerSupportsCancellation
private void AsyncOperationCompleted(object arg)
public bool get_CancellationPending()
public void CancelAsync()
public void add_DoWork(DoWorkEventHandler value)
public void remove_DoWork(DoWorkEventHandler value)
public bool get_IsBusy()
protected void OnDoWork(DoWorkEventArgs e)
protected void OnRunWorkerCompleted(RunWorkerCompletedEventArgs e)
protected void OnProgressChanged(ProgressChangedEventArgs e)
public void add_ProgressChanged(ProgressChangedEventHandler value)
public void remove_ProgressChanged(ProgressChangedEventHandler value)
private void ProgressReporter(object arg)
public void ReportProgress(int percentProgress)
public void ReportProgress(int percentProgress, object userState)
public void RunWorkerAsync()
public void RunWorkerAsync(object argument)
public void add_RunWorkerCompleted(RunWorkerCompletedEventHandler value)
public void remove_RunWorkerCompleted(RunWorkerCompletedEventHandler value)
public bool get_WorkerReportsProgress()
public void set_WorkerReportsProgress(bool value)
public bool get_WorkerSupportsCancellation()
public void set_WorkerSupportsCancellation(bool value)
private void WorkerThreadStart(object argument)
protected void Dispose(bool disposing)
private void <RunWorkerAsync>b__27_0(object arg)
}
public System.ComponentModel.BaseNumberConverter : TypeConverter {
internal bool AllowHex
internal Type TargetType
internal bool get_AllowHex()
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
}
public System.ComponentModel.BindableAttribute : Attribute {
public BindableAttribute Yes
public BindableAttribute No
public BindableAttribute Default
private bool _isDefault
private bool <Bindable>k__BackingField
private BindingDirection <Direction>k__BackingField
public bool Bindable
public BindingDirection Direction
public void .ctor(bool bindable)
public void .ctor(bool bindable, BindingDirection direction)
public void .ctor(BindableSupport flags)
public void .ctor(BindableSupport flags, BindingDirection direction)
public bool get_Bindable()
public BindingDirection get_Direction()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.BindableSupport : Enum {
public int value__
public BindableSupport No
public BindableSupport Yes
public BindableSupport Default
}
public System.ComponentModel.BindingDirection : Enum {
public int value__
public BindingDirection OneWay
public BindingDirection TwoWay
}
public System.ComponentModel.BindingList`1 : Collection`1<T> {
private int addNewPos
private bool raiseListChangedEvents
private bool raiseItemChangedEvents
private PropertyDescriptorCollection _itemTypeProperties
private PropertyChangedEventHandler _propertyChangedEventHandler
private AddingNewEventHandler _onAddingNew
private ListChangedEventHandler _onListChanged
private int _lastChangeIndex
private bool allowNew
private bool allowEdit
private bool allowRemove
private bool userSetAllowNew
private bool ItemTypeHasDefaultConstructor
public bool RaiseListChangedEvents
private bool AddingNewHandled
public bool AllowNew
private bool System.ComponentModel.IBindingList.AllowNew
public bool AllowEdit
private bool System.ComponentModel.IBindingList.AllowEdit
public bool AllowRemove
private bool System.ComponentModel.IBindingList.AllowRemove
private bool System.ComponentModel.IBindingList.SupportsChangeNotification
protected bool SupportsChangeNotificationCore
private bool System.ComponentModel.IBindingList.SupportsSearching
protected bool SupportsSearchingCore
private bool System.ComponentModel.IBindingList.SupportsSorting
protected bool SupportsSortingCore
private bool System.ComponentModel.IBindingList.IsSorted
protected bool IsSortedCore
private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty
protected PropertyDescriptor SortPropertyCore
private ListSortDirection System.ComponentModel.IBindingList.SortDirection
protected ListSortDirection SortDirectionCore
private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents
public void .ctor(IList`1<T> list)
private void Initialize()
private bool get_ItemTypeHasDefaultConstructor()
public void add_AddingNew(AddingNewEventHandler value)
public void remove_AddingNew(AddingNewEventHandler value)
protected void OnAddingNew(AddingNewEventArgs e)
private object FireAddingNew()
public void add_ListChanged(ListChangedEventHandler value)
public void remove_ListChanged(ListChangedEventHandler value)
protected void OnListChanged(ListChangedEventArgs e)
public bool get_RaiseListChangedEvents()
public void set_RaiseListChangedEvents(bool value)
public void ResetBindings()
public void ResetItem(int position)
private void FireListChanged(ListChangedType type, int index)
protected void ClearItems()
protected void InsertItem(int index, T item)
protected void RemoveItem(int index)
protected void SetItem(int index, T item)
public void CancelNew(int itemIndex)
public void EndNew(int itemIndex)
public T AddNew()
private object System.ComponentModel.IBindingList.AddNew()
private bool get_AddingNewHandled()
protected object AddNewCore()
public bool get_AllowNew()
public void set_AllowNew(bool value)
private bool System.ComponentModel.IBindingList.get_AllowNew()
public bool get_AllowEdit()
public void set_AllowEdit(bool value)
private bool System.ComponentModel.IBindingList.get_AllowEdit()
public bool get_AllowRemove()
public void set_AllowRemove(bool value)
private bool System.ComponentModel.IBindingList.get_AllowRemove()
private bool System.ComponentModel.IBindingList.get_SupportsChangeNotification()
protected bool get_SupportsChangeNotificationCore()
private bool System.ComponentModel.IBindingList.get_SupportsSearching()
protected bool get_SupportsSearchingCore()
private bool System.ComponentModel.IBindingList.get_SupportsSorting()
protected bool get_SupportsSortingCore()
private bool System.ComponentModel.IBindingList.get_IsSorted()
protected bool get_IsSortedCore()
private PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty()
protected PropertyDescriptor get_SortPropertyCore()
private ListSortDirection System.ComponentModel.IBindingList.get_SortDirection()
protected ListSortDirection get_SortDirectionCore()
private void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor prop, ListSortDirection direction)
protected void ApplySortCore(PropertyDescriptor prop, ListSortDirection direction)
private void System.ComponentModel.IBindingList.RemoveSort()
protected void RemoveSortCore()
private int System.ComponentModel.IBindingList.Find(PropertyDescriptor prop, object key)
protected int FindCore(PropertyDescriptor prop, object key)
private void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor prop)
private void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor prop)
private void HookPropertyChanged(T item)
private void UnhookPropertyChanged(T item)
private void Child_PropertyChanged(object sender, PropertyChangedEventArgs e)
private bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents()
}
public System.ComponentModel.BooleanConverter : TypeConverter {
private StandardValuesCollection modreq(System.Runtime.CompilerServices.IsVolatile) s_values
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.BrowsableAttribute : Attribute {
public BrowsableAttribute Yes
public BrowsableAttribute No
public BrowsableAttribute Default
private bool <Browsable>k__BackingField
public bool Browsable
public void .ctor(bool browsable)
public bool get_Browsable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ByteConverter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.CancelEventArgs : EventArgs {
private bool <Cancel>k__BackingField
public bool Cancel
public bool get_Cancel()
public void set_Cancel(bool value)
public void .ctor(bool cancel)
}
public System.ComponentModel.CancelEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, CancelEventArgs e)
public IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.CategoryAttribute : Attribute {
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) appearance
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) asynchronous
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) behavior
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) data
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) design
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) action
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) format
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) layout
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) mouse
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) key
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) focus
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) windowStyle
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) dragDrop
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) defAttr
private bool localized
private string categoryValue
public CategoryAttribute Action
public CategoryAttribute Appearance
public CategoryAttribute Asynchronous
public CategoryAttribute Behavior
public CategoryAttribute Data
public CategoryAttribute Default
public CategoryAttribute Design
public CategoryAttribute DragDrop
public CategoryAttribute Focus
public CategoryAttribute Format
public CategoryAttribute Key
public CategoryAttribute Layout
public CategoryAttribute Mouse
public CategoryAttribute WindowStyle
public string Category
public CategoryAttribute get_Action()
public CategoryAttribute get_Appearance()
public CategoryAttribute get_Asynchronous()
public CategoryAttribute get_Behavior()
public CategoryAttribute get_Data()
public CategoryAttribute get_Default()
public CategoryAttribute get_Design()
public CategoryAttribute get_DragDrop()
public CategoryAttribute get_Focus()
public CategoryAttribute get_Format()
public CategoryAttribute get_Key()
public CategoryAttribute get_Layout()
public CategoryAttribute get_Mouse()
public CategoryAttribute get_WindowStyle()
public void .ctor(string category)
public string get_Category()
public bool Equals(object obj)
public int GetHashCode()
protected string GetLocalizedString(string value)
public bool IsDefaultAttribute()
}
public System.ComponentModel.CharConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
}
public System.ComponentModel.CollectionChangeAction : Enum {
public int value__
public CollectionChangeAction Add
public CollectionChangeAction Remove
public CollectionChangeAction Refresh
}
public System.ComponentModel.CollectionChangeEventArgs : EventArgs {
private CollectionChangeAction <Action>k__BackingField
private object <Element>k__BackingField
public CollectionChangeAction Action
public object Element
public void .ctor(CollectionChangeAction action, object element)
public CollectionChangeAction get_Action()
public object get_Element()
}
public System.ComponentModel.CollectionChangeEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, CollectionChangeEventArgs e)
public IAsyncResult BeginInvoke(object sender, CollectionChangeEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.CollectionConverter : TypeConverter {
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.ComplexBindingPropertiesAttribute : Attribute {
private string <DataSource>k__BackingField
private string <DataMember>k__BackingField
public ComplexBindingPropertiesAttribute Default
public string DataSource
public string DataMember
public void .ctor(string dataSource)
public void .ctor(string dataSource, string dataMember)
public string get_DataSource()
public string get_DataMember()
public bool Equals(object obj)
public int GetHashCode()
}
internal System.ComponentModel.CompModSwitches : object {
private BooleanSwitch modreq(System.Runtime.CompilerServices.IsVolatile) commonDesignerServices
private TraceSwitch modreq(System.Runtime.CompilerServices.IsVolatile) eventLog
public BooleanSwitch CommonDesignerServices
public TraceSwitch EventLog
public BooleanSwitch get_CommonDesignerServices()
public TraceSwitch get_EventLog()
}
public System.ComponentModel.Component : MarshalByRefObject {
private object EventDisposed
private ISite site
private EventHandlerList events
protected bool CanRaiseEvents
internal bool CanRaiseEventsInternal
protected EventHandlerList Events
public ISite Site
public IContainer Container
protected bool DesignMode
protected void Finalize()
protected bool get_CanRaiseEvents()
internal bool get_CanRaiseEventsInternal()
public void add_Disposed(EventHandler value)
public void remove_Disposed(EventHandler value)
protected EventHandlerList get_Events()
public ISite get_Site()
public void set_Site(ISite value)
public void Dispose()
protected void Dispose(bool disposing)
public IContainer get_Container()
protected object GetService(Type service)
protected bool get_DesignMode()
public string ToString()
}
public System.ComponentModel.ComponentCollection : ReadOnlyCollectionBase {
public IComponent Item
public IComponent Item
public void .ctor(IComponent[] components)
public IComponent get_Item(string name)
public IComponent get_Item(int index)
public void CopyTo(IComponent[] array, int index)
}
public System.ComponentModel.ComponentConverter : ReferenceConverter {
public void .ctor(Type type)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.ComponentEditor : object {
public bool EditComponent(object component)
public bool EditComponent(ITypeDescriptorContext context, object component)
}
public System.ComponentModel.ComponentResourceManager : ResourceManager {
private Hashtable _resourceSets
private CultureInfo _neutralResourcesCulture
private CultureInfo NeutralResourcesCulture
public void .ctor(Type t)
private CultureInfo get_NeutralResourcesCulture()
public void ApplyResources(object value, string objectName)
public void ApplyResources(object value, string objectName, CultureInfo culture)
private SortedList`2<string, object> FillResources(CultureInfo culture, ResourceSet& resourceSet)
}
public System.ComponentModel.Container : object {
private ISite[] sites
private int siteCount
private ComponentCollection components
private ContainerFilterService filter
private bool checkedFilter
private object syncObj
public ComponentCollection Components
protected void Finalize()
public void Add(IComponent component)
public void Add(IComponent component, string name)
protected ISite CreateSite(IComponent component, string name)
public void Dispose()
protected void Dispose(bool disposing)
protected object GetService(Type service)
public ComponentCollection get_Components()
public void Remove(IComponent component)
private void Remove(IComponent component, bool preserveSite)
protected void RemoveWithoutUnsiting(IComponent component)
protected void ValidateName(IComponent component, string name)
}
public System.ComponentModel.ContainerFilterService : object {
public ComponentCollection FilterComponents(ComponentCollection components)
}
public System.ComponentModel.CultureInfoConverter : TypeConverter {
private StandardValuesCollection _values
private string DefaultInvariantCultureString
private string DefaultCultureString
private string get_DefaultCultureString()
protected string GetCultureName(CultureInfo culture)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.CustomTypeDescriptor : object {
private ICustomTypeDescriptor _parent
protected void .ctor(ICustomTypeDescriptor parent)
public AttributeCollection GetAttributes()
public string GetClassName()
public string GetComponentName()
public TypeConverter GetConverter()
public EventDescriptor GetDefaultEvent()
public PropertyDescriptor GetDefaultProperty()
public object GetEditor(Type editorBaseType)
public EventDescriptorCollection GetEvents()
public EventDescriptorCollection GetEvents(Attribute[] attributes)
public PropertyDescriptorCollection GetProperties()
public PropertyDescriptorCollection GetProperties(Attribute[] attributes)
public object GetPropertyOwner(PropertyDescriptor pd)
}
public System.ComponentModel.DataErrorsChangedEventArgs : EventArgs {
private string _propertyName
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
}
public System.ComponentModel.DataObjectAttribute : Attribute {
public DataObjectAttribute DataObject
public DataObjectAttribute NonDataObject
public DataObjectAttribute Default
private bool <IsDataObject>k__BackingField
public bool IsDataObject
public void .ctor(bool isDataObject)
public bool get_IsDataObject()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DataObjectFieldAttribute : Attribute {
private bool <IsIdentity>k__BackingField
private bool <IsNullable>k__BackingField
private int <Length>k__BackingField
private bool <PrimaryKey>k__BackingField
public bool IsIdentity
public bool IsNullable
public int Length
public bool PrimaryKey
public void .ctor(bool primaryKey)
public void .ctor(bool primaryKey, bool isIdentity)
public void .ctor(bool primaryKey, bool isIdentity, bool isNullable)
public void .ctor(bool primaryKey, bool isIdentity, bool isNullable, int length)
public bool get_IsIdentity()
public bool get_IsNullable()
public int get_Length()
public bool get_PrimaryKey()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DataObjectMethodAttribute : Attribute {
private bool <IsDefault>k__BackingField
private DataObjectMethodType <MethodType>k__BackingField
public bool IsDefault
public DataObjectMethodType MethodType
public void .ctor(DataObjectMethodType methodType)
public void .ctor(DataObjectMethodType methodType, bool isDefault)
public bool get_IsDefault()
public DataObjectMethodType get_MethodType()
public bool Equals(object obj)
public int GetHashCode()
public bool Match(object obj)
}
public System.ComponentModel.DataObjectMethodType : Enum {
public int value__
public DataObjectMethodType Fill
public DataObjectMethodType Select
public DataObjectMethodType Update
public DataObjectMethodType Insert
public DataObjectMethodType Delete
}
public System.ComponentModel.DateTimeConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.DateTimeOffsetConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.DecimalConverter : BaseNumberConverter {
internal bool AllowHex
internal Type TargetType
internal bool get_AllowHex()
internal Type get_TargetType()
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.DefaultBindingPropertyAttribute : Attribute {
private string <Name>k__BackingField
public DefaultBindingPropertyAttribute Default
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DefaultEventAttribute : Attribute {
private string <Name>k__BackingField
public DefaultEventAttribute Default
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DefaultPropertyAttribute : Attribute {
private string <Name>k__BackingField
public DefaultPropertyAttribute Default
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DefaultValueAttribute : Attribute {
private object _value
private object s_convertFromInvariantString
public object Value
public void .ctor(Type type, string value)
public void .ctor(char value)
public void .ctor(byte value)
public void .ctor(short value)
public void .ctor(int value)
public void .ctor(long value)
public void .ctor(float value)
public void .ctor(double value)
public void .ctor(bool value)
public void .ctor(string value)
public void .ctor(object value)
public void .ctor(sbyte value)
public void .ctor(ushort value)
public void .ctor(UInt32 value)
public void .ctor(ulong value)
public object get_Value()
public bool Equals(object obj)
public int GetHashCode()
protected void SetValue(object value)
internal bool <.ctor>g__TryConvertFromInvariantString|2_0(Type typeToConvert, string stringValue, Object& conversionResult)
}
internal System.ComponentModel.DelegatingTypeDescriptionProvider : TypeDescriptionProvider {
private Type _type
internal TypeDescriptionProvider Provider
internal void .ctor(Type type)
internal TypeDescriptionProvider get_Provider()
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
public IDictionary GetCache(object instance)
public string GetFullComponentName(object component)
public ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance)
protected internal IExtenderProvider[] GetExtenderProviders(object instance)
public Type GetReflectionType(Type objectType, object instance)
public Type GetRuntimeType(Type objectType)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance)
public bool IsSupportedType(Type type)
}
public System.ComponentModel.DescriptionAttribute : Attribute {
public DescriptionAttribute Default
private string <DescriptionValue>k__BackingField
public string Description
protected string DescriptionValue
public void .ctor(string description)
public string get_Description()
protected string get_DescriptionValue()
protected void set_DescriptionValue(string value)
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.Design.ActiveDesignerEventArgs : EventArgs {
private IDesignerHost <OldDesigner>k__BackingField
private IDesignerHost <NewDesigner>k__BackingField
public IDesignerHost OldDesigner
public IDesignerHost NewDesigner
public void .ctor(IDesignerHost oldDesigner, IDesignerHost newDesigner)
public IDesignerHost get_OldDesigner()
public IDesignerHost get_NewDesigner()
}
public System.ComponentModel.Design.ActiveDesignerEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ActiveDesignerEventArgs e)
public IAsyncResult BeginInvoke(object sender, ActiveDesignerEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.CheckoutException : ExternalException {
private int E_ABORT
public CheckoutException Canceled
public void .ctor(string message)
public void .ctor(string message, int errorCode)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.ComponentModel.Design.CommandID : object {
private int <ID>k__BackingField
private Guid <Guid>k__BackingField
public int ID
public Guid Guid
public void .ctor(Guid menuGroup, int commandID)
public int get_ID()
public bool Equals(object obj)
public int GetHashCode()
public Guid get_Guid()
public string ToString()
}
public System.ComponentModel.Design.ComponentChangedEventArgs : EventArgs {
private object <Component>k__BackingField
private MemberDescriptor <Member>k__BackingField
private object <NewValue>k__BackingField
private object <OldValue>k__BackingField
public object Component
public MemberDescriptor Member
public object NewValue
public object OldValue
public object get_Component()
public MemberDescriptor get_Member()
public object get_NewValue()
public object get_OldValue()
public void .ctor(object component, MemberDescriptor member, object oldValue, object newValue)
}
public System.ComponentModel.Design.ComponentChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.ComponentChangingEventArgs : EventArgs {
private object <Component>k__BackingField
private MemberDescriptor <Member>k__BackingField
public object Component
public MemberDescriptor Member
public object get_Component()
public MemberDescriptor get_Member()
public void .ctor(object component, MemberDescriptor member)
}
public System.ComponentModel.Design.ComponentChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.ComponentEventArgs : EventArgs {
private IComponent <Component>k__BackingField
public IComponent Component
public IComponent get_Component()
public void .ctor(IComponent component)
}
public System.ComponentModel.Design.ComponentEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.ComponentRenameEventArgs : EventArgs {
private object <Component>k__BackingField
private string <OldName>k__BackingField
private string <NewName>k__BackingField
public object Component
public string OldName
public string NewName
public object get_Component()
public string get_OldName()
public string get_NewName()
public void .ctor(object component, string oldName, string newName)
}
public System.ComponentModel.Design.ComponentRenameEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentRenameEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentRenameEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.DesignerCollection : object {
private IList _designers
public int Count
public IDesignerHost Item
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(IDesignerHost[] designers)
public void .ctor(IList designers)
public int get_Count()
public IDesignerHost get_Item(int index)
public IEnumerator GetEnumerator()
private int System.Collections.ICollection.get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.ComponentModel.Design.DesignerEventArgs : EventArgs {
private IDesignerHost <Designer>k__BackingField
public IDesignerHost Designer
public void .ctor(IDesignerHost host)
public IDesignerHost get_Designer()
}
public System.ComponentModel.Design.DesignerEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DesignerEventArgs e)
public IAsyncResult BeginInvoke(object sender, DesignerEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.DesignerOptionService : object {
private DesignerOptionCollection _options
public DesignerOptionCollection Options
public DesignerOptionCollection get_Options()
protected DesignerOptionCollection CreateOptionCollection(DesignerOptionCollection parent, string name, object value)
private PropertyDescriptor GetOptionProperty(string pageName, string valueName)
protected void PopulateOptionCollection(DesignerOptionCollection options)
protected bool ShowDialog(DesignerOptionCollection options, object optionObject)
private object System.ComponentModel.Design.IDesignerOptionService.GetOptionValue(string pageName, string valueName)
private void System.ComponentModel.Design.IDesignerOptionService.SetOptionValue(string pageName, string valueName, object value)
}
public System.ComponentModel.Design.DesignerTransaction : object {
private bool _suppressedFinalization
private bool <Canceled>k__BackingField
private bool <Committed>k__BackingField
private string <Description>k__BackingField
public bool Canceled
public bool Committed
public string Description
protected void .ctor(string description)
public bool get_Canceled()
private void set_Canceled(bool value)
public bool get_Committed()
private void set_Committed(bool value)
public string get_Description()
public void Cancel()
public void Commit()
protected void OnCancel()
protected void OnCommit()
protected void Finalize()
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
}
public System.ComponentModel.Design.DesignerTransactionCloseEventArgs : EventArgs {
private bool <TransactionCommitted>k__BackingField
private bool <LastTransaction>k__BackingField
public bool TransactionCommitted
public bool LastTransaction
public void .ctor(bool commit)
public void .ctor(bool commit, bool lastTransaction)
public bool get_TransactionCommitted()
public bool get_LastTransaction()
}
public System.ComponentModel.Design.DesignerTransactionCloseEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DesignerTransactionCloseEventArgs e)
public IAsyncResult BeginInvoke(object sender, DesignerTransactionCloseEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.DesignerVerb : MenuCommand {
public string Description
public string Text
public void .ctor(string text, EventHandler handler)
public void .ctor(string text, EventHandler handler, CommandID startCommandID)
public string get_Description()
public void set_Description(string value)
public string get_Text()
public string ToString()
}
public System.ComponentModel.Design.DesignerVerbCollection : CollectionBase {
public DesignerVerb Item
public void .ctor(DesignerVerb[] value)
public DesignerVerb get_Item(int index)
public void set_Item(int index, DesignerVerb value)
public int Add(DesignerVerb value)
public void AddRange(DesignerVerb[] value)
public void AddRange(DesignerVerbCollection value)
public void Insert(int index, DesignerVerb value)
public int IndexOf(DesignerVerb value)
public bool Contains(DesignerVerb value)
public void Remove(DesignerVerb value)
public void CopyTo(DesignerVerb[] array, int index)
protected void OnSet(int index, object oldValue, object newValue)
protected void OnInsert(int index, object value)
protected void OnClear()
protected void OnRemove(int index, object value)
protected void OnValidate(object value)
}
public System.ComponentModel.Design.DesigntimeLicenseContext : LicenseContext {
internal Hashtable savedLicenseKeys
public LicenseUsageMode UsageMode
public LicenseUsageMode get_UsageMode()
public string GetSavedLicenseKey(Type type, Assembly resourceAssembly)
public void SetSavedLicenseKey(Type type, string key)
}
public System.ComponentModel.Design.DesigntimeLicenseContextSerializer : object {
public void Serialize(Stream o, string cryptoKey, DesigntimeLicenseContext context)
internal void Deserialize(Stream o, string cryptoKey, RuntimeLicenseContext context)
}
public System.ComponentModel.Design.HelpContextType : Enum {
public int value__
public HelpContextType Ambient
public HelpContextType Window
public HelpContextType Selection
public HelpContextType ToolWindowSelection
}
public System.ComponentModel.Design.HelpKeywordAttribute : Attribute {
public HelpKeywordAttribute Default
private string <HelpKeyword>k__BackingField
public string HelpKeyword
public void .ctor(string keyword)
public void .ctor(Type t)
public string get_HelpKeyword()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.Design.HelpKeywordType : Enum {
public int value__
public HelpKeywordType F1Keyword
public HelpKeywordType GeneralKeyword
public HelpKeywordType FilterKeyword
}
public System.ComponentModel.Design.IComponentChangeService {
public void add_ComponentAdded(ComponentEventHandler value)
public void remove_ComponentAdded(ComponentEventHandler value)
public void add_ComponentAdding(ComponentEventHandler value)
public void remove_ComponentAdding(ComponentEventHandler value)
public void add_ComponentChanged(ComponentChangedEventHandler value)
public void remove_ComponentChanged(ComponentChangedEventHandler value)
public void add_ComponentChanging(ComponentChangingEventHandler value)
public void remove_ComponentChanging(ComponentChangingEventHandler value)
public void add_ComponentRemoved(ComponentEventHandler value)
public void remove_ComponentRemoved(ComponentEventHandler value)
public void add_ComponentRemoving(ComponentEventHandler value)
public void remove_ComponentRemoving(ComponentEventHandler value)
public void add_ComponentRename(ComponentRenameEventHandler value)
public void remove_ComponentRename(ComponentRenameEventHandler value)
public void OnComponentChanged(object component, MemberDescriptor member, object oldValue, object newValue)
public void OnComponentChanging(object component, MemberDescriptor member)
}
public System.ComponentModel.Design.IComponentDiscoveryService {
public ICollection GetComponentTypes(IDesignerHost designerHost, Type baseType)
}
public System.ComponentModel.Design.IComponentInitializer {
public void InitializeExistingComponent(IDictionary defaultValues)
public void InitializeNewComponent(IDictionary defaultValues)
}
public System.ComponentModel.Design.IDesigner {
public IComponent Component
public DesignerVerbCollection Verbs
public IComponent get_Component()
public DesignerVerbCollection get_Verbs()
public void DoDefaultAction()
public void Initialize(IComponent component)
}
public System.ComponentModel.Design.IDesignerEventService {
public IDesignerHost ActiveDesigner
public DesignerCollection Designers
public IDesignerHost get_ActiveDesigner()
public DesignerCollection get_Designers()
public void add_ActiveDesignerChanged(ActiveDesignerEventHandler value)
public void remove_ActiveDesignerChanged(ActiveDesignerEventHandler value)
public void add_DesignerCreated(DesignerEventHandler value)
public void remove_DesignerCreated(DesignerEventHandler value)
public void add_DesignerDisposed(DesignerEventHandler value)
public void remove_DesignerDisposed(DesignerEventHandler value)
public void add_SelectionChanged(EventHandler value)
public void remove_SelectionChanged(EventHandler value)
}
public System.ComponentModel.Design.IDesignerFilter {
public void PostFilterAttributes(IDictionary attributes)
public void PostFilterEvents(IDictionary events)
public void PostFilterProperties(IDictionary properties)
public void PreFilterAttributes(IDictionary attributes)
public void PreFilterEvents(IDictionary events)
public void PreFilterProperties(IDictionary properties)
}
public System.ComponentModel.Design.IDesignerHost {
public bool Loading
public bool InTransaction
public IContainer Container
public IComponent RootComponent
public string RootComponentClassName
public string TransactionDescription
public bool get_Loading()
public bool get_InTransaction()
public IContainer get_Container()
public IComponent get_RootComponent()
public string get_RootComponentClassName()
public string get_TransactionDescription()
public void add_Activated(EventHandler value)
public void remove_Activated(EventHandler value)
public void add_Deactivated(EventHandler value)
public void remove_Deactivated(EventHandler value)
public void add_LoadComplete(EventHandler value)
public void remove_LoadComplete(EventHandler value)
public void add_TransactionClosed(DesignerTransactionCloseEventHandler value)
public void remove_TransactionClosed(DesignerTransactionCloseEventHandler value)
public void add_TransactionClosing(DesignerTransactionCloseEventHandler value)
public void remove_TransactionClosing(DesignerTransactionCloseEventHandler value)
public void add_TransactionOpened(EventHandler value)
public void remove_TransactionOpened(EventHandler value)
public void add_TransactionOpening(EventHandler value)
public void remove_TransactionOpening(EventHandler value)
public void Activate()
public IComponent CreateComponent(Type componentClass)
public IComponent CreateComponent(Type componentClass, string name)
public DesignerTransaction CreateTransaction()
public DesignerTransaction CreateTransaction(string description)
public void DestroyComponent(IComponent component)
public IDesigner GetDesigner(IComponent component)
public Type GetType(string typeName)
}
public System.ComponentModel.Design.IDesignerHostTransactionState {
public bool IsClosingTransaction
public bool get_IsClosingTransaction()
}
public System.ComponentModel.Design.IDesignerOptionService {
public object GetOptionValue(string pageName, string valueName)
public void SetOptionValue(string pageName, string valueName, object value)
}
public System.ComponentModel.Design.IDictionaryService {
public object GetKey(object value)
public object GetValue(object key)
public void SetValue(object key, object value)
}
public System.ComponentModel.Design.IEventBindingService {
public string CreateUniqueMethodName(IComponent component, EventDescriptor e)
public ICollection GetCompatibleMethods(EventDescriptor e)
public EventDescriptor GetEvent(PropertyDescriptor property)
public PropertyDescriptorCollection GetEventProperties(EventDescriptorCollection events)
public PropertyDescriptor GetEventProperty(EventDescriptor e)
public bool ShowCode()
public bool ShowCode(int lineNumber)
public bool ShowCode(IComponent component, EventDescriptor e)
}
public System.ComponentModel.Design.IExtenderListService {
public IExtenderProvider[] GetExtenderProviders()
}
public System.ComponentModel.Design.IExtenderProviderService {
public void AddExtenderProvider(IExtenderProvider provider)
public void RemoveExtenderProvider(IExtenderProvider provider)
}
public System.ComponentModel.Design.IHelpService {
public void AddContextAttribute(string name, string value, HelpKeywordType keywordType)
public void ClearContextAttributes()
public IHelpService CreateLocalContext(HelpContextType contextType)
public void RemoveContextAttribute(string name, string value)
public void RemoveLocalContext(IHelpService localContext)
public void ShowHelpFromKeyword(string helpKeyword)
public void ShowHelpFromUrl(string helpUrl)
}
public System.ComponentModel.Design.IInheritanceService {
public void AddInheritedComponents(IComponent component, IContainer container)
public InheritanceAttribute GetInheritanceAttribute(IComponent component)
}
public System.ComponentModel.Design.IMenuCommandService {
public DesignerVerbCollection Verbs
public DesignerVerbCollection get_Verbs()
public void AddCommand(MenuCommand command)
public void AddVerb(DesignerVerb verb)
public MenuCommand FindCommand(CommandID commandID)
public bool GlobalInvoke(CommandID commandID)
public void RemoveCommand(MenuCommand command)
public void RemoveVerb(DesignerVerb verb)
public void ShowContextMenu(CommandID menuID, int x, int y)
}
public System.ComponentModel.Design.IReferenceService {
public IComponent GetComponent(object reference)
public object GetReference(string name)
public string GetName(object reference)
public Object[] GetReferences()
public Object[] GetReferences(Type baseType)
}
public System.ComponentModel.Design.IResourceService {
public IResourceReader GetResourceReader(CultureInfo info)
public IResourceWriter GetResourceWriter(CultureInfo info)
}
public System.ComponentModel.Design.IRootDesigner {
public ViewTechnology[] SupportedTechnologies
public ViewTechnology[] get_SupportedTechnologies()
public object GetView(ViewTechnology technology)
}
public System.ComponentModel.Design.ISelectionService {
public object PrimarySelection
public int SelectionCount
public object get_PrimarySelection()
public int get_SelectionCount()
public void add_SelectionChanged(EventHandler value)
public void remove_SelectionChanged(EventHandler value)
public void add_SelectionChanging(EventHandler value)
public void remove_SelectionChanging(EventHandler value)
public bool GetComponentSelected(object component)
public ICollection GetSelectedComponents()
public void SetSelectedComponents(ICollection components)
public void SetSelectedComponents(ICollection components, SelectionTypes selectionType)
}
public System.ComponentModel.Design.IServiceContainer {
public void AddService(Type serviceType, object serviceInstance)
public void AddService(Type serviceType, object serviceInstance, bool promote)
public void AddService(Type serviceType, ServiceCreatorCallback callback)
public void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote)
public void RemoveService(Type serviceType)
public void RemoveService(Type serviceType, bool promote)
}
public System.ComponentModel.Design.ITreeDesigner {
public ICollection Children
public IDesigner Parent
public ICollection get_Children()
public IDesigner get_Parent()
}
public System.ComponentModel.Design.ITypeDescriptorFilterService {
public bool FilterAttributes(IComponent component, IDictionary attributes)
public bool FilterEvents(IComponent component, IDictionary events)
public bool FilterProperties(IComponent component, IDictionary properties)
}
public System.ComponentModel.Design.ITypeDiscoveryService {
public ICollection GetTypes(Type baseType, bool excludeGlobalTypes)
}
public System.ComponentModel.Design.ITypeResolutionService {
public Assembly GetAssembly(AssemblyName name)
public Assembly GetAssembly(AssemblyName name, bool throwOnError)
public Type GetType(string name)
public Type GetType(string name, bool throwOnError)
public Type GetType(string name, bool throwOnError, bool ignoreCase)
public void ReferenceAssembly(AssemblyName name)
public string GetPathOfAssembly(AssemblyName name)
}
public System.ComponentModel.Design.MenuCommand : object {
private EventHandler _execHandler
private int _status
private IDictionary _properties
private int ENABLED
private int INVISIBLE
private int CHECKED
private int SUPPORTED
private EventHandler CommandChanged
private CommandID <CommandID>k__BackingField
public bool Checked
public bool Enabled
public IDictionary Properties
public bool Supported
public bool Visible
public CommandID CommandID
public int OleStatus
public void .ctor(EventHandler handler, CommandID command)
public bool get_Checked()
public void set_Checked(bool value)
public bool get_Enabled()
public void set_Enabled(bool value)
private void SetStatus(int mask, bool value)
public IDictionary get_Properties()
public bool get_Supported()
public void set_Supported(bool value)
public bool get_Visible()
public void set_Visible(bool value)
public void add_CommandChanged(EventHandler value)
public void remove_CommandChanged(EventHandler value)
public CommandID get_CommandID()
public void Invoke()
public void Invoke(object arg)
public int get_OleStatus()
protected void OnCommandChanged(EventArgs e)
public string ToString()
}
internal System.ComponentModel.Design.RuntimeLicenseContext : LicenseContext {
private TraceSwitch s_runtimeLicenseContextSwitch
private int ReadBlock
internal Hashtable savedLicenseKeys
private string GetLocalPath(string fileName)
public string GetSavedLicenseKey(Type type, Assembly resourceAssembly)
private Stream CaseInsensitiveManifestResourceStreamLookup(Assembly satellite, string name)
}
public System.ComponentModel.Design.SelectionTypes : Enum {
public int value__
public SelectionTypes Auto
public SelectionTypes Normal
public SelectionTypes Replace
public SelectionTypes MouseDown
public SelectionTypes MouseUp
public SelectionTypes Click
public SelectionTypes Primary
public SelectionTypes Toggle
public SelectionTypes Add
public SelectionTypes Remove
public SelectionTypes Valid
}
public System.ComponentModel.Design.Serialization.ComponentSerializationService : object {
public SerializationStore CreateStore()
public SerializationStore LoadStore(Stream stream)
public void Serialize(SerializationStore store, object value)
public void SerializeAbsolute(SerializationStore store, object value)
public void SerializeMember(SerializationStore store, object owningObject, MemberDescriptor member)
public void SerializeMemberAbsolute(SerializationStore store, object owningObject, MemberDescriptor member)
public ICollection Deserialize(SerializationStore store)
public ICollection Deserialize(SerializationStore store, IContainer container)
public void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes, bool applyDefaults)
public void DeserializeTo(SerializationStore store, IContainer container)
public void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes)
}
public System.ComponentModel.Design.Serialization.ContextStack : object {
private ArrayList _contextStack
public object Current
public object Item
public object Item
public object get_Current()
public object get_Item(int level)
public object get_Item(Type type)
public void Append(object context)
public object Pop()
public void Push(object context)
}
public System.ComponentModel.Design.Serialization.DefaultSerializationProviderAttribute : Attribute {
private string <ProviderTypeName>k__BackingField
public string ProviderTypeName
public void .ctor(Type providerType)
public void .ctor(string providerTypeName)
public string get_ProviderTypeName()
}
public System.ComponentModel.Design.Serialization.DesignerLoader : object {
public bool Loading
public bool get_Loading()
public void BeginLoad(IDesignerLoaderHost host)
public void Dispose()
public void Flush()
}
public System.ComponentModel.Design.Serialization.DesignerSerializerAttribute : Attribute {
private string _typeId
private string <SerializerTypeName>k__BackingField
private string <SerializerBaseTypeName>k__BackingField
public string SerializerTypeName
public string SerializerBaseTypeName
public object TypeId
public void .ctor(Type serializerType, Type baseSerializerType)
public void .ctor(string serializerTypeName, Type baseSerializerType)
public void .ctor(string serializerTypeName, string baseSerializerTypeName)
public string get_SerializerTypeName()
public string get_SerializerBaseTypeName()
public object get_TypeId()
}
public System.ComponentModel.Design.Serialization.IDesignerLoaderHost {
public void EndLoad(string baseClassName, bool successful, ICollection errorCollection)
public void Reload()
}
public System.ComponentModel.Design.Serialization.IDesignerLoaderHost2 {
public bool IgnoreErrorsDuringReload
public bool CanReloadWithErrors
public bool get_IgnoreErrorsDuringReload()
public void set_IgnoreErrorsDuringReload(bool value)
public bool get_CanReloadWithErrors()
public void set_CanReloadWithErrors(bool value)
}
public System.ComponentModel.Design.Serialization.IDesignerLoaderService {
public void AddLoadDependency()
public void DependentLoadComplete(bool successful, ICollection errorCollection)
public bool Reload()
}
public System.ComponentModel.Design.Serialization.IDesignerSerializationManager {
public ContextStack Context
public PropertyDescriptorCollection Properties
public ContextStack get_Context()
public PropertyDescriptorCollection get_Properties()
public void add_ResolveName(ResolveNameEventHandler value)
public void remove_ResolveName(ResolveNameEventHandler value)
public void add_SerializationComplete(EventHandler value)
public void remove_SerializationComplete(EventHandler value)
public void AddSerializationProvider(IDesignerSerializationProvider provider)
public object CreateInstance(Type type, ICollection arguments, string name, bool addToContainer)
public object GetInstance(string name)
public string GetName(object value)
public object GetSerializer(Type objectType, Type serializerType)
public Type GetType(string typeName)
public void RemoveSerializationProvider(IDesignerSerializationProvider provider)
public void ReportError(object errorInformation)
public void SetName(object instance, string name)
}
public System.ComponentModel.Design.Serialization.IDesignerSerializationProvider {
public object GetSerializer(IDesignerSerializationManager manager, object currentSerializer, Type objectType, Type serializerType)
}
public System.ComponentModel.Design.Serialization.IDesignerSerializationService {
public ICollection Deserialize(object serializationData)
public object Serialize(ICollection objects)
}
public System.ComponentModel.Design.Serialization.INameCreationService {
public string CreateName(IContainer container, Type dataType)
public bool IsValidName(string name)
public void ValidateName(string name)
}
public System.ComponentModel.Design.Serialization.InstanceDescriptor : object {
private ICollection <Arguments>k__BackingField
private bool <IsComplete>k__BackingField
private MemberInfo <MemberInfo>k__BackingField
public ICollection Arguments
public bool IsComplete
public MemberInfo MemberInfo
public void .ctor(MemberInfo member, ICollection arguments)
public void .ctor(MemberInfo member, ICollection arguments, bool isComplete)
public ICollection get_Arguments()
public bool get_IsComplete()
public MemberInfo get_MemberInfo()
public object Invoke()
}
public System.ComponentModel.Design.Serialization.MemberRelationship : ValueType {
public MemberRelationship Empty
private MemberDescriptor <Member>k__BackingField
private object <Owner>k__BackingField
public bool IsEmpty
public MemberDescriptor Member
public object Owner
public void .ctor(object owner, MemberDescriptor member)
public bool get_IsEmpty()
public MemberDescriptor get_Member()
public object get_Owner()
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(MemberRelationship left, MemberRelationship right)
public bool op_Inequality(MemberRelationship left, MemberRelationship right)
}
public System.ComponentModel.Design.Serialization.MemberRelationshipService : object {
private Dictionary`2<RelationshipEntry, RelationshipEntry> _relationships
public MemberRelationship Item
public MemberRelationship Item
public MemberRelationship get_Item(MemberRelationship source)
public void set_Item(MemberRelationship source, MemberRelationship value)
public MemberRelationship get_Item(object sourceOwner, MemberDescriptor sourceMember)
public void set_Item(object sourceOwner, MemberDescriptor sourceMember, MemberRelationship value)
protected MemberRelationship GetRelationship(MemberRelationship source)
protected void SetRelationship(MemberRelationship source, MemberRelationship relationship)
public bool SupportsRelationship(MemberRelationship source, MemberRelationship relationship)
}
public System.ComponentModel.Design.Serialization.ResolveNameEventArgs : EventArgs {
private string <Name>k__BackingField
private object <Value>k__BackingField
public string Name
public object Value
public void .ctor(string name)
public string get_Name()
public object get_Value()
public void set_Value(object value)
}
public System.ComponentModel.Design.Serialization.ResolveNameEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ResolveNameEventArgs e)
public IAsyncResult BeginInvoke(object sender, ResolveNameEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.Serialization.RootDesignerSerializerAttribute : Attribute {
private string _typeId
private bool <Reloadable>k__BackingField
private string <SerializerTypeName>k__BackingField
private string <SerializerBaseTypeName>k__BackingField
public bool Reloadable
public string SerializerTypeName
public string SerializerBaseTypeName
public object TypeId
public void .ctor(Type serializerType, Type baseSerializerType, bool reloadable)
public void .ctor(string serializerTypeName, Type baseSerializerType, bool reloadable)
public void .ctor(string serializerTypeName, string baseSerializerTypeName, bool reloadable)
public bool get_Reloadable()
public string get_SerializerTypeName()
public string get_SerializerBaseTypeName()
public object get_TypeId()
}
public System.ComponentModel.Design.Serialization.SerializationStore : object {
public ICollection Errors
public ICollection get_Errors()
public void Close()
public void Save(Stream stream)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
}
public System.ComponentModel.Design.ServiceContainer : object {
private ServiceCollection`1<object> _services
private IServiceProvider _parentProvider
private Type[] s_defaultServices
private TraceSwitch s_TRACESERVICE
private IServiceContainer Container
protected Type[] DefaultServices
private ServiceCollection`1<object> Services
public void .ctor(IServiceProvider parentProvider)
private IServiceContainer get_Container()
protected Type[] get_DefaultServices()
private ServiceCollection`1<object> get_Services()
public void AddService(Type serviceType, object serviceInstance)
public void AddService(Type serviceType, object serviceInstance, bool promote)
public void AddService(Type serviceType, ServiceCreatorCallback callback)
public void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote)
public void Dispose()
protected void Dispose(bool disposing)
public object GetService(Type serviceType)
public void RemoveService(Type serviceType)
public void RemoveService(Type serviceType, bool promote)
}
public System.ComponentModel.Design.ServiceCreatorCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(IServiceContainer container, Type serviceType)
public IAsyncResult BeginInvoke(IServiceContainer container, Type serviceType, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.StandardCommands : object {
private Guid s_standardCommandSet
private Guid s_ndpCommandSet
private int cmdidDesignerVerbFirst
private int cmdidDesignerVerbLast
private int cmdidArrangeIcons
private int cmdidLineupIcons
private int cmdidShowLargeIcons
public CommandID AlignBottom
public CommandID AlignHorizontalCenters
public CommandID AlignLeft
public CommandID AlignRight
public CommandID AlignToGrid
public CommandID AlignTop
public CommandID AlignVerticalCenters
public CommandID ArrangeBottom
public CommandID ArrangeRight
public CommandID BringForward
public CommandID BringToFront
public CommandID CenterHorizontally
public CommandID CenterVertically
public CommandID ViewCode
public CommandID DocumentOutline
public CommandID Copy
public CommandID Cut
public CommandID Delete
public CommandID Group
public CommandID HorizSpaceConcatenate
public CommandID HorizSpaceDecrease
public CommandID HorizSpaceIncrease
public CommandID HorizSpaceMakeEqual
public CommandID Paste
public CommandID Properties
public CommandID Redo
public CommandID MultiLevelRedo
public CommandID SelectAll
public CommandID SendBackward
public CommandID SendToBack
public CommandID SizeToControl
public CommandID SizeToControlHeight
public CommandID SizeToControlWidth
public CommandID SizeToFit
public CommandID SizeToGrid
public CommandID SnapToGrid
public CommandID TabOrder
public CommandID Undo
public CommandID MultiLevelUndo
public CommandID Ungroup
public CommandID VertSpaceConcatenate
public CommandID VertSpaceDecrease
public CommandID VertSpaceIncrease
public CommandID VertSpaceMakeEqual
public CommandID ShowGrid
public CommandID ViewGrid
public CommandID Replace
public CommandID PropertiesWindow
public CommandID LockControls
public CommandID F1Help
public CommandID ArrangeIcons
public CommandID LineupIcons
public CommandID ShowLargeIcons
public CommandID VerbFirst
public CommandID VerbLast
}
public System.ComponentModel.Design.StandardToolWindows : object {
public Guid ObjectBrowser
public Guid OutputWindow
public Guid ProjectExplorer
public Guid PropertyBrowser
public Guid RelatedLinks
public Guid ServerExplorer
public Guid TaskList
public Guid Toolbox
}
public System.ComponentModel.Design.TypeDescriptionProviderService : object {
public TypeDescriptionProvider GetProvider(object instance)
public TypeDescriptionProvider GetProvider(Type type)
}
public System.ComponentModel.Design.ViewTechnology : Enum {
public int value__
public ViewTechnology Passthrough
public ViewTechnology WindowsForms
public ViewTechnology Default
}
public System.ComponentModel.DesignerAttribute : Attribute {
private string designerTypeName
private string designerBaseTypeName
private string typeId
public string DesignerBaseTypeName
public string DesignerTypeName
public object TypeId
public void .ctor(string designerTypeName)
public void .ctor(Type designerType)
public void .ctor(string designerTypeName, string designerBaseTypeName)
public void .ctor(string designerTypeName, Type designerBaseType)
public void .ctor(Type designerType, Type designerBaseType)
public string get_DesignerBaseTypeName()
public string get_DesignerTypeName()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DesignerCategoryAttribute : Attribute {
public DesignerCategoryAttribute Component
public DesignerCategoryAttribute Default
public DesignerCategoryAttribute Form
public DesignerCategoryAttribute Generic
private string <Category>k__BackingField
public string Category
public object TypeId
public void .ctor(string category)
public string get_Category()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
public object get_TypeId()
}
public System.ComponentModel.DesignerSerializationVisibility : Enum {
public int value__
public DesignerSerializationVisibility Hidden
public DesignerSerializationVisibility Visible
public DesignerSerializationVisibility Content
}
public System.ComponentModel.DesignerSerializationVisibilityAttribute : Attribute {
public DesignerSerializationVisibilityAttribute Content
public DesignerSerializationVisibilityAttribute Hidden
public DesignerSerializationVisibilityAttribute Visible
public DesignerSerializationVisibilityAttribute Default
private DesignerSerializationVisibility <Visibility>k__BackingField
public DesignerSerializationVisibility Visibility
public void .ctor(DesignerSerializationVisibility visibility)
public DesignerSerializationVisibility get_Visibility()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DesignOnlyAttribute : Attribute {
private bool <IsDesignOnly>k__BackingField
public DesignOnlyAttribute Yes
public DesignOnlyAttribute No
public DesignOnlyAttribute Default
public bool IsDesignOnly
public void .ctor(bool isDesignOnly)
public bool get_IsDesignOnly()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DesignTimeVisibleAttribute : Attribute {
private bool <Visible>k__BackingField
public DesignTimeVisibleAttribute Yes
public DesignTimeVisibleAttribute No
public DesignTimeVisibleAttribute Default
public bool Visible
public void .ctor(bool visible)
public bool get_Visible()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DisplayNameAttribute : Attribute {
public DisplayNameAttribute Default
private string <DisplayNameValue>k__BackingField
public string DisplayName
protected string DisplayNameValue
public void .ctor(string displayName)
public string get_DisplayName()
protected string get_DisplayNameValue()
protected void set_DisplayNameValue(string value)
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DoubleConverter : BaseNumberConverter {
internal bool AllowHex
internal Type TargetType
internal bool get_AllowHex()
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.DoWorkEventArgs : CancelEventArgs {
private object result
private object argument
public object Argument
public object Result
public void .ctor(object argument)
public object get_Argument()
public object get_Result()
public void set_Result(object value)
}
public System.ComponentModel.DoWorkEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DoWorkEventArgs e)
public IAsyncResult BeginInvoke(object sender, DoWorkEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.EditorAttribute : Attribute {
private string _typeId
private string <EditorBaseTypeName>k__BackingField
private string <EditorTypeName>k__BackingField
public string EditorBaseTypeName
public string EditorTypeName
public object TypeId
public void .ctor(string typeName, string baseTypeName)
public void .ctor(string typeName, Type baseType)
public void .ctor(Type type, Type baseType)
public string get_EditorBaseTypeName()
public string get_EditorTypeName()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.EditorBrowsableAttribute : Attribute {
private EditorBrowsableState browsableState
public EditorBrowsableState State
public void .ctor(EditorBrowsableState state)
public EditorBrowsableState get_State()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.EditorBrowsableState : Enum {
public int value__
public EditorBrowsableState Always
public EditorBrowsableState Never
public EditorBrowsableState Advanced
}
public System.ComponentModel.EnumConverter : TypeConverter {
private StandardValuesCollection values
private Type type
protected Type EnumType
protected StandardValuesCollection Values
protected IComparer Comparer
public void .ctor(Type type)
protected Type get_EnumType()
protected StandardValuesCollection get_Values()
protected void set_Values(StandardValuesCollection value)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
protected IComparer get_Comparer()
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public bool IsValid(ITypeDescriptorContext context, object value)
}
public System.ComponentModel.EventDescriptor : MemberDescriptor {
public Type ComponentType
public Type EventType
public bool IsMulticast
protected void .ctor(string name, Attribute[] attrs)
protected void .ctor(MemberDescriptor descr)
protected void .ctor(MemberDescriptor descr, Attribute[] attrs)
public Type get_ComponentType()
public Type get_EventType()
public bool get_IsMulticast()
public void AddEventHandler(object component, Delegate value)
public void RemoveEventHandler(object component, Delegate value)
}
public System.ComponentModel.EventDescriptorCollection : object {
private EventDescriptor[] _events
private String[] _namedSort
private IComparer _comparer
private bool _eventsOwned
private bool _needSort
private bool _readOnly
public EventDescriptorCollection Empty
private int <Count>k__BackingField
public int Count
public EventDescriptor Item
public EventDescriptor Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private int System.Collections.ICollection.Count
private object System.Collections.IList.Item
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
public void .ctor(EventDescriptor[] events)
public void .ctor(EventDescriptor[] events, bool readOnly)
private void .ctor(EventDescriptor[] events, int eventCount, String[] namedSort, IComparer comparer)
public int get_Count()
private void set_Count(int value)
public EventDescriptor get_Item(int index)
public EventDescriptor get_Item(string name)
public int Add(EventDescriptor value)
public void Clear()
public bool Contains(EventDescriptor value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private void EnsureEventsOwned()
private void EnsureSize(int sizeNeeded)
public EventDescriptor Find(string name, bool ignoreCase)
public int IndexOf(EventDescriptor value)
public void Insert(int index, EventDescriptor value)
public void Remove(EventDescriptor value)
public void RemoveAt(int index)
public IEnumerator GetEnumerator()
public EventDescriptorCollection Sort()
public EventDescriptorCollection Sort(String[] names)
public EventDescriptorCollection Sort(String[] names, IComparer comparer)
public EventDescriptorCollection Sort(IComparer comparer)
protected void InternalSort(String[] names)
protected void InternalSort(IComparer sorter)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private int System.Collections.ICollection.get_Count()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private void System.Collections.IList.Clear()
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
}
public System.ComponentModel.EventHandlerList : object {
private ListEntry _head
private Component _parent
public Delegate Item
internal void .ctor(Component parent)
public Delegate get_Item(object key)
public void set_Item(object key, Delegate value)
public void AddHandler(object key, Delegate value)
public void AddHandlers(EventHandlerList listToAddFrom)
public void Dispose()
private ListEntry Find(object key)
public void RemoveHandler(object key, Delegate value)
}
public System.ComponentModel.ExpandableObjectConverter : TypeConverter {
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
internal System.ComponentModel.ExtendedPropertyDescriptor : PropertyDescriptor {
private ReflectPropertyDescriptor _extenderInfo
private IExtenderProvider _provider
public Type ComponentType
public bool IsReadOnly
public Type PropertyType
public string DisplayName
public void .ctor(ReflectPropertyDescriptor extenderInfo, Type receiverType, IExtenderProvider provider, Attribute[] attributes)
public void .ctor(PropertyDescriptor extender, Attribute[] attributes)
public bool CanResetValue(object comp)
public Type get_ComponentType()
public bool get_IsReadOnly()
public Type get_PropertyType()
public string get_DisplayName()
public object GetValue(object comp)
public void ResetValue(object comp)
public void SetValue(object component, object value)
public bool ShouldSerializeValue(object comp)
}
public System.ComponentModel.ExtenderProvidedPropertyAttribute : Attribute {
private PropertyDescriptor <ExtenderProperty>k__BackingField
private IExtenderProvider <Provider>k__BackingField
private Type <ReceiverType>k__BackingField
public PropertyDescriptor ExtenderProperty
public IExtenderProvider Provider
public Type ReceiverType
internal ExtenderProvidedPropertyAttribute Create(PropertyDescriptor extenderProperty, Type receiverType, IExtenderProvider provider)
public PropertyDescriptor get_ExtenderProperty()
private void set_ExtenderProperty(PropertyDescriptor value)
public IExtenderProvider get_Provider()
private void set_Provider(IExtenderProvider value)
public Type get_ReceiverType()
private void set_ReceiverType(Type value)
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.GuidConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.HandledEventArgs : EventArgs {
private bool <Handled>k__BackingField
public bool Handled
public void .ctor(bool defaultHandledValue)
public bool get_Handled()
public void set_Handled(bool value)
}
public System.ComponentModel.HandledEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, HandledEventArgs e)
public IAsyncResult BeginInvoke(object sender, HandledEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.IBindingList {
public bool AllowNew
public bool AllowEdit
public bool AllowRemove
public bool SupportsChangeNotification
public bool SupportsSearching
public bool SupportsSorting
public bool IsSorted
public PropertyDescriptor SortProperty
public ListSortDirection SortDirection
public bool get_AllowNew()
public object AddNew()
public bool get_AllowEdit()
public bool get_AllowRemove()
public bool get_SupportsChangeNotification()
public bool get_SupportsSearching()
public bool get_SupportsSorting()
public bool get_IsSorted()
public PropertyDescriptor get_SortProperty()
public ListSortDirection get_SortDirection()
public void add_ListChanged(ListChangedEventHandler value)
public void remove_ListChanged(ListChangedEventHandler value)
public void AddIndex(PropertyDescriptor property)
public void ApplySort(PropertyDescriptor property, ListSortDirection direction)
public int Find(PropertyDescriptor property, object key)
public void RemoveIndex(PropertyDescriptor property)
public void RemoveSort()
}
public System.ComponentModel.IBindingListView {
public string Filter
public ListSortDescriptionCollection SortDescriptions
public bool SupportsAdvancedSorting
public bool SupportsFiltering
public void ApplySort(ListSortDescriptionCollection sorts)
public string get_Filter()
public void set_Filter(string value)
public ListSortDescriptionCollection get_SortDescriptions()
public void RemoveFilter()
public bool get_SupportsAdvancedSorting()
public bool get_SupportsFiltering()
}
public System.ComponentModel.ICancelAddNew {
public void CancelNew(int itemIndex)
public void EndNew(int itemIndex)
}
public System.ComponentModel.IChangeTracking {
public bool IsChanged
public bool get_IsChanged()
public void AcceptChanges()
}
public System.ComponentModel.IComNativeDescriptorHandler {
public AttributeCollection GetAttributes(object component)
public string GetClassName(object component)
public TypeConverter GetConverter(object component)
public EventDescriptor GetDefaultEvent(object component)
public PropertyDescriptor GetDefaultProperty(object component)
public object GetEditor(object component, Type baseEditorType)
public string GetName(object component)
public EventDescriptorCollection GetEvents(object component)
public EventDescriptorCollection GetEvents(object component, Attribute[] attributes)
public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes)
public object GetPropertyValue(object component, string propertyName, Boolean& success)
public object GetPropertyValue(object component, int dispid, Boolean& success)
}
public System.ComponentModel.IComponent {
public ISite Site
public ISite get_Site()
public void set_Site(ISite value)
public void add_Disposed(EventHandler value)
public void remove_Disposed(EventHandler value)
}
public System.ComponentModel.IContainer {
public ComponentCollection Components
public void Add(IComponent component)
public void Add(IComponent component, string name)
public ComponentCollection get_Components()
public void Remove(IComponent component)
}
public System.ComponentModel.ICustomTypeDescriptor {
public AttributeCollection GetAttributes()
public string GetClassName()
public string GetComponentName()
public TypeConverter GetConverter()
public EventDescriptor GetDefaultEvent()
public PropertyDescriptor GetDefaultProperty()
public object GetEditor(Type editorBaseType)
public EventDescriptorCollection GetEvents()
public EventDescriptorCollection GetEvents(Attribute[] attributes)
public PropertyDescriptorCollection GetProperties()
public PropertyDescriptorCollection GetProperties(Attribute[] attributes)
public object GetPropertyOwner(PropertyDescriptor pd)
}
public System.ComponentModel.IDataErrorInfo {
public string Item
public string Error
public string get_Item(string columnName)
public string get_Error()
}
public System.ComponentModel.IEditableObject {
public void BeginEdit()
public void EndEdit()
public void CancelEdit()
}
public System.ComponentModel.IExtenderProvider {
public bool CanExtend(object extendee)
}
public System.ComponentModel.IIntellisenseBuilder {
public string Name
public string get_Name()
public bool Show(string language, string value, String& newValue)
}
public System.ComponentModel.IListSource {
public bool ContainsListCollection
public bool get_ContainsListCollection()
public IList GetList()
}
public System.ComponentModel.ImmutableObjectAttribute : Attribute {
public ImmutableObjectAttribute Yes
public ImmutableObjectAttribute No
public ImmutableObjectAttribute Default
private bool <Immutable>k__BackingField
public bool Immutable
public void .ctor(bool immutable)
public bool get_Immutable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.INestedContainer {
public IComponent Owner
public IComponent get_Owner()
}
public System.ComponentModel.INestedSite {
public string FullName
public string get_FullName()
}
public System.ComponentModel.InheritanceAttribute : Attribute {
public InheritanceAttribute Inherited
public InheritanceAttribute InheritedReadOnly
public InheritanceAttribute NotInherited
public InheritanceAttribute Default
private InheritanceLevel <InheritanceLevel>k__BackingField
public InheritanceLevel InheritanceLevel
public void .ctor(InheritanceLevel inheritanceLevel)
public InheritanceLevel get_InheritanceLevel()
public bool Equals(object value)
public int GetHashCode()
public bool IsDefaultAttribute()
public string ToString()
}
public System.ComponentModel.InheritanceLevel : Enum {
public int value__
public InheritanceLevel Inherited
public InheritanceLevel InheritedReadOnly
public InheritanceLevel NotInherited
}
public System.ComponentModel.InitializationEventAttribute : Attribute {
private string <EventName>k__BackingField
public string EventName
public void .ctor(string eventName)
public string get_EventName()
}
public System.ComponentModel.INotifyDataErrorInfo {
public bool HasErrors
public bool get_HasErrors()
public IEnumerable GetErrors(string propertyName)
public void add_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value)
public void remove_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value)
}
public System.ComponentModel.INotifyPropertyChanged {
public void add_PropertyChanged(PropertyChangedEventHandler value)
public void remove_PropertyChanged(PropertyChangedEventHandler value)
}
public System.ComponentModel.INotifyPropertyChanging {
public void add_PropertyChanging(PropertyChangingEventHandler value)
public void remove_PropertyChanging(PropertyChangingEventHandler value)
}
public System.ComponentModel.InstallerTypeAttribute : Attribute {
private string _typeName
public Type InstallerType
public void .ctor(Type installerType)
public void .ctor(string typeName)
public Type get_InstallerType()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.InstanceCreationEditor : object {
public string Text
public string get_Text()
public object CreateInstance(ITypeDescriptorContext context, Type instanceType)
}
public System.ComponentModel.Int16Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.Int32Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.Int64Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
internal System.ComponentModel.IntSecurity : object {
public string UnsafeGetFullPath(string fileName)
}
public System.ComponentModel.InvalidAsynchronousStateException : ArgumentException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.InvalidEnumArgumentException : ArgumentException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string argumentName, int invalidValue, Type enumClass)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.IRaiseItemChangedEvents {
public bool RaisesItemChangedEvents
public bool get_RaisesItemChangedEvents()
}
public System.ComponentModel.IRevertibleChangeTracking {
public void RejectChanges()
}
public System.ComponentModel.ISite {
public IComponent Component
public IContainer Container
public bool DesignMode
public string Name
public IComponent get_Component()
public IContainer get_Container()
public bool get_DesignMode()
public string get_Name()
public void set_Name(string value)
}
public System.ComponentModel.ISupportInitialize {
public void BeginInit()
public void EndInit()
}
public System.ComponentModel.ISupportInitializeNotification {
public bool IsInitialized
public bool get_IsInitialized()
public void add_Initialized(EventHandler value)
public void remove_Initialized(EventHandler value)
}
public System.ComponentModel.ISynchronizeInvoke {
public bool InvokeRequired
public bool get_InvokeRequired()
public IAsyncResult BeginInvoke(Delegate method, Object[] args)
public object EndInvoke(IAsyncResult result)
public object Invoke(Delegate method, Object[] args)
}
public System.ComponentModel.ITypeDescriptorContext {
public IContainer Container
public object Instance
public PropertyDescriptor PropertyDescriptor
public IContainer get_Container()
public object get_Instance()
public PropertyDescriptor get_PropertyDescriptor()
public bool OnComponentChanging()
public void OnComponentChanged()
}
public System.ComponentModel.ITypedList {
public string GetListName(PropertyDescriptor[] listAccessors)
public PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors)
}
public System.ComponentModel.License : object {
public string LicenseKey
public string get_LicenseKey()
public void Dispose()
}
public System.ComponentModel.LicenseContext : object {
public LicenseUsageMode UsageMode
public LicenseUsageMode get_UsageMode()
public string GetSavedLicenseKey(Type type, Assembly resourceAssembly)
public object GetService(Type type)
public void SetSavedLicenseKey(Type type, string key)
}
public System.ComponentModel.LicenseException : SystemException {
private Type type
private object instance
public Type LicensedType
public void .ctor(Type type)
public void .ctor(Type type, object instance)
public void .ctor(Type type, object instance, string message)
public void .ctor(Type type, object instance, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public Type get_LicensedType()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.LicenseManager : object {
private object s_selfLock
private LicenseContext modreq(System.Runtime.CompilerServices.IsVolatile) s_context
private object s_contextLockHolder
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) s_providers
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) s_providerInstances
private object s_internalSyncObject
public LicenseContext CurrentContext
public LicenseUsageMode UsageMode
public LicenseContext get_CurrentContext()
public void set_CurrentContext(LicenseContext value)
public LicenseUsageMode get_UsageMode()
private void CacheProvider(Type type, LicenseProvider provider)
public object CreateWithContext(Type type, LicenseContext creationContext)
public object CreateWithContext(Type type, LicenseContext creationContext, Object[] args)
private bool GetCachedNoLicenseProvider(Type type)
private LicenseProvider GetCachedProvider(Type type)
private LicenseProvider GetCachedProviderInstance(Type providerType)
public bool IsLicensed(Type type)
public bool IsValid(Type type)
public bool IsValid(Type type, object instance, License& license)
public void LockContext(object contextUser)
public void UnlockContext(object contextUser)
private bool ValidateInternal(Type type, object instance, bool allowExceptions, License& license)
private bool ValidateInternalRecursive(LicenseContext context, Type type, object instance, bool allowExceptions, License& license, String& licenseKey)
public void Validate(Type type)
public License Validate(Type type, object instance)
}
public System.ComponentModel.LicenseProvider : object {
public License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions)
}
public System.ComponentModel.LicenseProviderAttribute : Attribute {
public LicenseProviderAttribute Default
private Type _licenseProviderType
private string _licenseProviderName
public Type LicenseProvider
public object TypeId
public void .ctor(string typeName)
public void .ctor(Type type)
public Type get_LicenseProvider()
public object get_TypeId()
public bool Equals(object value)
public int GetHashCode()
}
public System.ComponentModel.LicenseUsageMode : Enum {
public int value__
public LicenseUsageMode Runtime
public LicenseUsageMode Designtime
}
public System.ComponentModel.LicFileLicenseProvider : LicenseProvider {
protected bool IsKeyValid(string key, Type type)
protected string GetKey(Type type)
public License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions)
}
public System.ComponentModel.ListBindableAttribute : Attribute {
public ListBindableAttribute Yes
public ListBindableAttribute No
public ListBindableAttribute Default
private bool _isDefault
private bool <ListBindable>k__BackingField
public bool ListBindable
public void .ctor(bool listBindable)
public void .ctor(BindableSupport flags)
public bool get_ListBindable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ListChangedEventArgs : EventArgs {
private ListChangedType <ListChangedType>k__BackingField
private int <NewIndex>k__BackingField
private int <OldIndex>k__BackingField
private PropertyDescriptor <PropertyDescriptor>k__BackingField
public ListChangedType ListChangedType
public int NewIndex
public int OldIndex
public PropertyDescriptor PropertyDescriptor
public void .ctor(ListChangedType listChangedType, int newIndex)
public void .ctor(ListChangedType listChangedType, int newIndex, PropertyDescriptor propDesc)
public void .ctor(ListChangedType listChangedType, PropertyDescriptor propDesc)
public void .ctor(ListChangedType listChangedType, int newIndex, int oldIndex)
public ListChangedType get_ListChangedType()
public int get_NewIndex()
public int get_OldIndex()
public PropertyDescriptor get_PropertyDescriptor()
}
public System.ComponentModel.ListChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ListChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ListChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.ListChangedType : Enum {
public int value__
public ListChangedType Reset
public ListChangedType ItemAdded
public ListChangedType ItemDeleted
public ListChangedType ItemMoved
public ListChangedType ItemChanged
public ListChangedType PropertyDescriptorAdded
public ListChangedType PropertyDescriptorDeleted
public ListChangedType PropertyDescriptorChanged
}
public System.ComponentModel.ListSortDescription : object {
private PropertyDescriptor <PropertyDescriptor>k__BackingField
private ListSortDirection <SortDirection>k__BackingField
public PropertyDescriptor PropertyDescriptor
public ListSortDirection SortDirection
public void .ctor(PropertyDescriptor property, ListSortDirection direction)
public PropertyDescriptor get_PropertyDescriptor()
public void set_PropertyDescriptor(PropertyDescriptor value)
public ListSortDirection get_SortDirection()
public void set_SortDirection(ListSortDirection value)
}
public System.ComponentModel.ListSortDescriptionCollection : object {
private ArrayList _sorts
public ListSortDescription Item
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
public int Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public void .ctor(ListSortDescription[] sorts)
public ListSortDescription get_Item(int index)
public void set_Item(int index, ListSortDescription value)
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
public bool Contains(object value)
public int IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
public int get_Count()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.ComponentModel.ListSortDirection : Enum {
public int value__
public ListSortDirection Ascending
public ListSortDirection Descending
}
public System.ComponentModel.LocalizableAttribute : Attribute {
private bool <IsLocalizable>k__BackingField
public LocalizableAttribute Yes
public LocalizableAttribute No
public LocalizableAttribute Default
public bool IsLocalizable
public void .ctor(bool isLocalizable)
public bool get_IsLocalizable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.LookupBindingPropertiesAttribute : Attribute {
private string <DataSource>k__BackingField
private string <DisplayMember>k__BackingField
private string <ValueMember>k__BackingField
private string <LookupMember>k__BackingField
public LookupBindingPropertiesAttribute Default
public string DataSource
public string DisplayMember
public string ValueMember
public string LookupMember
public void .ctor(string dataSource, string displayMember, string valueMember, string lookupMember)
public string get_DataSource()
public string get_DisplayMember()
public string get_ValueMember()
public string get_LookupMember()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.MarshalByValueComponent : object {
private object s_eventDisposed
private ISite _site
private EventHandlerList _events
protected EventHandlerList Events
public ISite Site
public IContainer Container
public bool DesignMode
protected void Finalize()
public void add_Disposed(EventHandler value)
public void remove_Disposed(EventHandler value)
protected EventHandlerList get_Events()
public ISite get_Site()
public void set_Site(ISite value)
public void Dispose()
protected void Dispose(bool disposing)
public IContainer get_Container()
public object GetService(Type service)
public bool get_DesignMode()
public string ToString()
}
public System.ComponentModel.MaskedTextProvider : object {
private char SPACE_CHAR
private char DEFAULT_PROMPT_CHAR
private char NULL_PASSWORD_CHAR
private bool DEFAULT_ALLOW_PROMPT
private int INVALID_INDEX
private byte EDIT_ANY
private byte EDIT_UNASSIGNED
private byte EDIT_ASSIGNED
private bool FORWARD
private bool BACKWARD
private int s_ASCII_ONLY
private int s_ALLOW_PROMPT_AS_INPUT
private int s_INCLUDE_PROMPT
private int s_INCLUDE_LITERALS
private int s_RESET_ON_PROMPT
private int s_RESET_ON_LITERALS
private int s_SKIP_SPACE
private Type s_maskTextProviderType
private BitVector32 _flagState
private StringBuilder _testString
private int _requiredCharCount
private int _requiredEditChars
private int _optionalEditChars
private char _passwordChar
private char _promptChar
private List`1<CharDescriptor> _stringDescriptor
private int <AssignedEditPositionCount>k__BackingField
private CultureInfo <Culture>k__BackingField
private string <Mask>k__BackingField
public bool AllowPromptAsInput
public int AssignedEditPositionCount
public int AvailableEditPositionCount
public CultureInfo Culture
public char DefaultPasswordChar
public int EditPositionCount
public IEnumerator EditPositions
public bool IncludeLiterals
public bool IncludePrompt
public bool AsciiOnly
public bool IsPassword
public int InvalidIndex
public int LastAssignedPosition
public int Length
public string Mask
public bool MaskCompleted
public bool MaskFull
public char PasswordChar
public char PromptChar
public bool ResetOnPrompt
public bool ResetOnSpace
public bool SkipLiterals
public char Item
public void .ctor(string mask)
public void .ctor(string mask, bool restrictToAscii)
public void .ctor(string mask, CultureInfo culture)
public void .ctor(string mask, CultureInfo culture, bool restrictToAscii)
public void .ctor(string mask, char passwordChar, bool allowPromptAsInput)
public void .ctor(string mask, CultureInfo culture, char passwordChar, bool allowPromptAsInput)
public void .ctor(string mask, CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii)
private void Initialize()
public bool get_AllowPromptAsInput()
public int get_AssignedEditPositionCount()
private void set_AssignedEditPositionCount(int value)
public int get_AvailableEditPositionCount()
public object Clone()
public CultureInfo get_Culture()
public char get_DefaultPasswordChar()
public int get_EditPositionCount()
public IEnumerator get_EditPositions()
public bool get_IncludeLiterals()
public void set_IncludeLiterals(bool value)
public bool get_IncludePrompt()
public void set_IncludePrompt(bool value)
public bool get_AsciiOnly()
public bool get_IsPassword()
public void set_IsPassword(bool value)
public int get_InvalidIndex()
public int get_LastAssignedPosition()
public int get_Length()
public string get_Mask()
public bool get_MaskCompleted()
public bool get_MaskFull()
public char get_PasswordChar()
public void set_PasswordChar(char value)
public char get_PromptChar()
public void set_PromptChar(char value)
public bool get_ResetOnPrompt()
public void set_ResetOnPrompt(bool value)
public bool get_ResetOnSpace()
public void set_ResetOnSpace(bool value)
public bool get_SkipLiterals()
public void set_SkipLiterals(bool value)
public char get_Item(int index)
public bool Add(char input)
public bool Add(char input, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Add(string input)
public bool Add(string input, Int32& testPosition, MaskedTextResultHint& resultHint)
public void Clear()
public void Clear(MaskedTextResultHint& resultHint)
public int FindAssignedEditPositionFrom(int position, bool direction)
public int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction)
public int FindEditPositionFrom(int position, bool direction)
public int FindEditPositionInRange(int startPosition, int endPosition, bool direction)
private int FindEditPositionInRange(int startPosition, int endPosition, bool direction, byte assignedStatus)
public int FindNonEditPositionFrom(int position, bool direction)
public int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction)
private int FindPositionInRange(int startPosition, int endPosition, bool direction, CharType charTypeFlags)
public int FindUnassignedEditPositionFrom(int position, bool direction)
public int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction)
public bool GetOperationResultFromHint(MaskedTextResultHint hint)
public bool InsertAt(char input, int position)
public bool InsertAt(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool InsertAt(string input, int position)
public bool InsertAt(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
private bool InsertAtInt(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint, bool testOnly)
private bool IsAscii(char c)
private bool IsAciiAlphanumeric(char c)
private bool IsAlphanumeric(char c)
private bool IsAsciiLetter(char c)
public bool IsAvailablePosition(int position)
public bool IsEditPosition(int position)
private bool IsEditPosition(CharDescriptor charDescriptor)
private bool IsLiteralPosition(CharDescriptor charDescriptor)
private bool IsPrintableChar(char c)
public bool IsValidInputChar(char c)
public bool IsValidMaskChar(char c)
public bool IsValidPasswordChar(char c)
public bool Remove()
public bool Remove(Int32& testPosition, MaskedTextResultHint& resultHint)
public bool RemoveAt(int position)
public bool RemoveAt(int startPosition, int endPosition)
public bool RemoveAt(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint)
private bool RemoveAtInt(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint, bool testOnly)
public bool Replace(char input, int position)
public bool Replace(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(char input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(string input, int position)
public bool Replace(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(string input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint)
private void ResetChar(int testPosition)
private void ResetString(int startPosition, int endPosition)
public bool Set(string input)
public bool Set(string input, Int32& testPosition, MaskedTextResultHint& resultHint)
private void SetChar(char input, int position)
private void SetChar(char input, int position, CharDescriptor charDescriptor)
private void SetString(string input, int testPosition)
private bool TestChar(char input, int position, MaskedTextResultHint& resultHint)
private bool TestEscapeChar(char input, int position)
private bool TestEscapeChar(char input, int position, CharDescriptor charDex)
private bool TestSetChar(char input, int position, MaskedTextResultHint& resultHint)
private bool TestSetString(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
private bool TestString(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public string ToDisplayString()
public string ToString()
public string ToString(bool ignorePasswordChar)
public string ToString(int startPosition, int length)
public string ToString(bool ignorePasswordChar, int startPosition, int length)
public string ToString(bool includePrompt, bool includeLiterals)
public string ToString(bool includePrompt, bool includeLiterals, int startPosition, int length)
public string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length)
public bool VerifyChar(char input, int position, MaskedTextResultHint& hint)
public bool VerifyEscapeChar(char input, int position)
public bool VerifyString(string input)
public bool VerifyString(string input, Int32& testPosition, MaskedTextResultHint& resultHint)
}
public System.ComponentModel.MaskedTextResultHint : Enum {
public int value__
public MaskedTextResultHint Unknown
public MaskedTextResultHint CharacterEscaped
public MaskedTextResultHint NoEffect
public MaskedTextResultHint SideEffect
public MaskedTextResultHint Success
public MaskedTextResultHint AsciiCharacterExpected
public MaskedTextResultHint AlphanumericCharacterExpected
public MaskedTextResultHint DigitExpected
public MaskedTextResultHint LetterExpected
public MaskedTextResultHint SignedDigitExpected
public MaskedTextResultHint InvalidInput
public MaskedTextResultHint PromptCharNotAllowed
public MaskedTextResultHint UnavailableEditPosition
public MaskedTextResultHint NonEditPosition
public MaskedTextResultHint PositionOutOfRange
}
public System.ComponentModel.MemberDescriptor : object {
private string name
private string displayName
private int nameHash
private AttributeCollection attributeCollection
private Attribute[] attributes
private Attribute[] originalAttributes
private bool attributesFiltered
private bool attributesFilled
private int metadataVersion
private string category
private string description
private object lockCookie
protected Attribute[] AttributeArray
public AttributeCollection Attributes
public string Category
public string Description
public bool IsBrowsable
public string Name
protected int NameHashCode
public bool DesignTimeOnly
public string DisplayName
protected void .ctor(string name)
protected void .ctor(string name, Attribute[] attributes)
protected void .ctor(MemberDescriptor descr)
protected void .ctor(MemberDescriptor oldMemberDescriptor, Attribute[] newAttributes)
protected Attribute[] get_AttributeArray()
protected void set_AttributeArray(Attribute[] value)
public AttributeCollection get_Attributes()
public string get_Category()
public string get_Description()
public bool get_IsBrowsable()
public string get_Name()
protected int get_NameHashCode()
public bool get_DesignTimeOnly()
public string get_DisplayName()
private void CheckAttributesValid()
protected AttributeCollection CreateAttributeCollection()
public bool Equals(object obj)
protected void FillAttributes(IList attributeList)
private void FilterAttributesIfNeeded()
protected MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType)
protected MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType, bool publicOnly)
public int GetHashCode()
protected object GetInvocationTarget(Type type, object instance)
protected ISite GetSite(object component)
protected object GetInvokee(Type componentClass, object component)
}
public System.ComponentModel.MergablePropertyAttribute : Attribute {
public MergablePropertyAttribute Yes
public MergablePropertyAttribute No
public MergablePropertyAttribute Default
private bool <AllowMerge>k__BackingField
public bool AllowMerge
public void .ctor(bool allowMerge)
public bool get_AllowMerge()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.MultilineStringConverter : TypeConverter {
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.NestedContainer : Container {
private IComponent <Owner>k__BackingField
public IComponent Owner
protected string OwnerName
public void .ctor(IComponent owner)
public IComponent get_Owner()
protected string get_OwnerName()
protected ISite CreateSite(IComponent component, string name)
protected void Dispose(bool disposing)
protected object GetService(Type service)
private void OnOwnerDisposed(object sender, EventArgs e)
}
public System.ComponentModel.NotifyParentPropertyAttribute : Attribute {
public NotifyParentPropertyAttribute Yes
public NotifyParentPropertyAttribute No
public NotifyParentPropertyAttribute Default
private bool notifyParent
public bool NotifyParent
public void .ctor(bool notifyParent)
public bool get_NotifyParent()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.NullableConverter : TypeConverter {
private Type <NullableType>k__BackingField
private Type <UnderlyingType>k__BackingField
private TypeConverter <UnderlyingTypeConverter>k__BackingField
public Type NullableType
public Type UnderlyingType
public TypeConverter UnderlyingTypeConverter
public void .ctor(Type type)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
public bool GetCreateInstanceSupported(ITypeDescriptorContext context)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public bool IsValid(ITypeDescriptorContext context, object value)
public Type get_NullableType()
public Type get_UnderlyingType()
public TypeConverter get_UnderlyingTypeConverter()
}
public System.ComponentModel.ParenthesizePropertyNameAttribute : Attribute {
public ParenthesizePropertyNameAttribute Default
private bool needParenthesis
public bool NeedParenthesis
public void .ctor(bool needParenthesis)
public bool get_NeedParenthesis()
public bool Equals(object o)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.PasswordPropertyTextAttribute : Attribute {
public PasswordPropertyTextAttribute Yes
public PasswordPropertyTextAttribute No
public PasswordPropertyTextAttribute Default
private bool <Password>k__BackingField
public bool Password
public void .ctor(bool password)
public bool get_Password()
public bool Equals(object o)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ProgressChangedEventArgs : EventArgs {
private int progressPercentage
private object userState
public int ProgressPercentage
public object UserState
public void .ctor(int progressPercentage, object userState)
public int get_ProgressPercentage()
public object get_UserState()
}
public System.ComponentModel.ProgressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ProgressChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ProgressChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyChangedEventArgs : EventArgs {
private string _propertyName
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
}
public System.ComponentModel.PropertyChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PropertyChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyChangingEventArgs : EventArgs {
private string _propertyName
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
}
public System.ComponentModel.PropertyChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PropertyChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, PropertyChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyDescriptor : MemberDescriptor {
private TypeConverter _converter
private Hashtable _valueChangedHandlers
private Object[] _editors
private Type[] _editorTypes
private int _editorCount
public Type ComponentType
public TypeConverter Converter
public bool IsLocalizable
public bool IsReadOnly
public DesignerSerializationVisibility SerializationVisibility
public Type PropertyType
public bool SupportsChangeEvents
protected void .ctor(string name, Attribute[] attrs)
protected void .ctor(MemberDescriptor descr)
protected void .ctor(MemberDescriptor descr, Attribute[] attrs)
public Type get_ComponentType()
public TypeConverter get_Converter()
public bool get_IsLocalizable()
public bool get_IsReadOnly()
public DesignerSerializationVisibility get_SerializationVisibility()
public Type get_PropertyType()
public void AddValueChanged(object component, EventHandler handler)
public bool CanResetValue(object component)
public bool Equals(object obj)
protected object CreateInstance(Type type)
protected void FillAttributes(IList attributeList)
public PropertyDescriptorCollection GetChildProperties()
public PropertyDescriptorCollection GetChildProperties(Attribute[] filter)
public PropertyDescriptorCollection GetChildProperties(object instance)
public PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter)
public object GetEditor(Type editorBaseType)
public int GetHashCode()
protected object GetInvocationTarget(Type type, object instance)
protected Type GetTypeFromName(string typeName)
public object GetValue(object component)
protected void OnValueChanged(object component, EventArgs e)
public void RemoveValueChanged(object component, EventHandler handler)
protected internal EventHandler GetValueChangedHandler(object component)
public void ResetValue(object component)
public void SetValue(object component, object value)
public bool ShouldSerializeValue(object component)
public bool get_SupportsChangeEvents()
}
public System.ComponentModel.PropertyDescriptorCollection : object {
public PropertyDescriptorCollection Empty
private IDictionary _cachedFoundProperties
private bool _cachedIgnoreCase
private PropertyDescriptor[] _properties
private String[] _namedSort
private IComparer _comparer
private bool _propsOwned
private bool _needSort
private bool _readOnly
private object _internalSyncObject
private int <Count>k__BackingField
public int Count
public PropertyDescriptor Item
public PropertyDescriptor Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private int System.Collections.ICollection.Count
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private object System.Collections.IDictionary.Item
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
public void .ctor(PropertyDescriptor[] properties)
public void .ctor(PropertyDescriptor[] properties, bool readOnly)
private void .ctor(PropertyDescriptor[] properties, int propCount, String[] namedSort, IComparer comparer)
public int get_Count()
private void set_Count(int value)
public PropertyDescriptor get_Item(int index)
public PropertyDescriptor get_Item(string name)
public int Add(PropertyDescriptor value)
public void Clear()
public bool Contains(PropertyDescriptor value)
public void CopyTo(Array array, int index)
private void EnsurePropsOwned()
private void EnsureSize(int sizeNeeded)
public PropertyDescriptor Find(string name, bool ignoreCase)
public int IndexOf(PropertyDescriptor value)
public void Insert(int index, PropertyDescriptor value)
public void Remove(PropertyDescriptor value)
public void RemoveAt(int index)
public PropertyDescriptorCollection Sort()
public PropertyDescriptorCollection Sort(String[] names)
public PropertyDescriptorCollection Sort(String[] names, IComparer comparer)
public PropertyDescriptorCollection Sort(IComparer comparer)
protected void InternalSort(String[] names)
protected void InternalSort(IComparer sorter)
public IEnumerator GetEnumerator()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private int System.Collections.ICollection.get_Count()
private void System.Collections.IList.Clear()
private void System.Collections.IDictionary.Clear()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.IList.RemoveAt(int index)
private void System.Collections.IDictionary.Add(object key, object value)
private bool System.Collections.IDictionary.Contains(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private ICollection System.Collections.IDictionary.get_Keys()
private ICollection System.Collections.IDictionary.get_Values()
private void System.Collections.IDictionary.Remove(object key)
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private void System.Collections.IList.Remove(object value)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
}
public System.ComponentModel.PropertyTabAttribute : Attribute {
private Type[] _tabClasses
private String[] _tabClassNames
private PropertyTabScope[] <TabScopes>k__BackingField
public Type[] TabClasses
protected String[] TabClassNames
public PropertyTabScope[] TabScopes
public void .ctor(Type tabClass)
public void .ctor(string tabClassName)
public void .ctor(Type tabClass, PropertyTabScope tabScope)
public void .ctor(string tabClassName, PropertyTabScope tabScope)
public Type[] get_TabClasses()
protected String[] get_TabClassNames()
public PropertyTabScope[] get_TabScopes()
private void set_TabScopes(PropertyTabScope[] value)
public bool Equals(object other)
public bool Equals(PropertyTabAttribute other)
public int GetHashCode()
protected void InitializeArrays(String[] tabClassNames, PropertyTabScope[] tabScopes)
protected void InitializeArrays(Type[] tabClasses, PropertyTabScope[] tabScopes)
private void InitializeArrays(String[] tabClassNames, Type[] tabClasses, PropertyTabScope[] tabScopes)
}
public System.ComponentModel.PropertyTabScope : Enum {
public int value__
public PropertyTabScope Static
public PropertyTabScope Global
public PropertyTabScope Document
public PropertyTabScope Component
}
public System.ComponentModel.ProvidePropertyAttribute : Attribute {
private string <PropertyName>k__BackingField
private string <ReceiverTypeName>k__BackingField
public string PropertyName
public string ReceiverTypeName
public object TypeId
public void .ctor(string propertyName, Type receiverType)
public void .ctor(string propertyName, string receiverTypeName)
public string get_PropertyName()
public string get_ReceiverTypeName()
public bool Equals(object obj)
public int GetHashCode()
public object get_TypeId()
}
public System.ComponentModel.ReadOnlyAttribute : Attribute {
public ReadOnlyAttribute Yes
public ReadOnlyAttribute No
public ReadOnlyAttribute Default
private bool <IsReadOnly>k__BackingField
public bool IsReadOnly
public void .ctor(bool isReadOnly)
public bool get_IsReadOnly()
public bool Equals(object value)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.RecommendedAsConfigurableAttribute : Attribute {
private bool <RecommendedAsConfigurable>k__BackingField
public RecommendedAsConfigurableAttribute No
public RecommendedAsConfigurableAttribute Yes
public RecommendedAsConfigurableAttribute Default
public bool RecommendedAsConfigurable
public void .ctor(bool recommendedAsConfigurable)
public bool get_RecommendedAsConfigurable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ReferenceConverter : TypeConverter {
private string s_none
private Type _type
public void .ctor(Type type)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
protected bool IsValueAllowed(ITypeDescriptorContext context, object value)
}
internal System.ComponentModel.ReflectEventDescriptor : EventDescriptor {
private Type _type
private Type _componentClass
private MethodInfo _addMethod
private MethodInfo _removeMethod
private EventInfo _realEvent
private bool _filledMethods
public Type ComponentType
public Type EventType
public bool IsMulticast
public void .ctor(Type componentClass, string name, Type type, Attribute[] attributes)
public void .ctor(Type componentClass, EventInfo eventInfo)
public void .ctor(Type componentType, EventDescriptor oldReflectEventDescriptor, Attribute[] attributes)
public Type get_ComponentType()
public Type get_EventType()
public bool get_IsMulticast()
public void AddEventHandler(object component, Delegate value)
protected void FillAttributes(IList attributes)
private void FillEventInfoAttribute(EventInfo realEventInfo, IList attributes)
private void FillMethods()
private void FillSingleMethodAttribute(MethodInfo realMethodInfo, IList attributes)
public void RemoveEventHandler(object component, Delegate value)
}
internal System.ComponentModel.ReflectPropertyDescriptor : PropertyDescriptor {
private Type[] argsNone
private object noValue
private TraceSwitch PropDescCreateSwitch
private TraceSwitch PropDescUsageSwitch
private int BitDefaultValueQueried
private int BitGetQueried
private int BitSetQueried
private int BitShouldSerializeQueried
private int BitResetQueried
private int BitChangedQueried
private int BitIPropChangedQueried
private int BitReadOnlyChecked
private int BitAmbientValueQueried
private int BitSetOnDemand
private BitVector32 state
private Type componentClass
private Type type
private object defaultValue
private object ambientValue
private PropertyInfo propInfo
private MethodInfo getMethod
private MethodInfo setMethod
private MethodInfo shouldSerializeMethod
private MethodInfo resetMethod
private EventDescriptor realChangedEvent
private EventDescriptor realIPropChangedEvent
private Type receiverType
private object AmbientValue
private EventDescriptor ChangedEventValue
private EventDescriptor IPropChangedEventValue
public Type ComponentType
private object DefaultValue
private MethodInfo GetMethodValue
private bool IsExtender
public bool IsReadOnly
public Type PropertyType
private MethodInfo ResetMethodValue
private MethodInfo SetMethodValue
private MethodInfo ShouldSerializeMethodValue
public bool SupportsChangeEvents
public void .ctor(Type componentClass, string name, Type type, Attribute[] attributes)
public void .ctor(Type componentClass, string name, Type type, PropertyInfo propInfo, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs)
public void .ctor(Type componentClass, string name, Type type, Type receiverType, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs)
public void .ctor(Type componentClass, PropertyDescriptor oldReflectPropertyDescriptor, Attribute[] attributes)
private object get_AmbientValue()
private EventDescriptor get_ChangedEventValue()
private EventDescriptor get_IPropChangedEventValue()
private void set_IPropChangedEventValue(EventDescriptor value)
public Type get_ComponentType()
private object get_DefaultValue()
private MethodInfo get_GetMethodValue()
private bool get_IsExtender()
public bool get_IsReadOnly()
public Type get_PropertyType()
private MethodInfo get_ResetMethodValue()
private MethodInfo get_SetMethodValue()
private MethodInfo get_ShouldSerializeMethodValue()
public void AddValueChanged(object component, EventHandler handler)
internal bool ExtenderCanResetValue(IExtenderProvider provider, object component)
internal Type ExtenderGetReceiverType()
internal Type ExtenderGetType(IExtenderProvider provider)
internal object ExtenderGetValue(IExtenderProvider provider, object component)
internal void ExtenderResetValue(IExtenderProvider provider, object component, PropertyDescriptor notifyDesc)
internal void ExtenderSetValue(IExtenderProvider provider, object component, object value, PropertyDescriptor notifyDesc)
internal bool ExtenderShouldSerializeValue(IExtenderProvider provider, object component)
public bool CanResetValue(object component)
protected void FillAttributes(IList attributes)
public object GetValue(object component)
internal void OnINotifyPropertyChanged(object component, PropertyChangedEventArgs e)
protected void OnValueChanged(object component, EventArgs e)
public void RemoveValueChanged(object component, EventHandler handler)
public void ResetValue(object component)
public void SetValue(object component, object value)
public bool ShouldSerializeValue(object component)
public bool get_SupportsChangeEvents()
}
internal System.ComponentModel.ReflectTypeDescriptionProvider : TypeDescriptionProvider {
private Hashtable _typeData
private Type[] _typeConstructor
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _editorTables
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _intrinsicTypeConverters
private object _intrinsicReferenceKey
private object _intrinsicNullableKey
private object _dictionaryKey
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _propertyCache
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _eventCache
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _attributeCache
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _extendedPropertyCache
private Guid _extenderProviderKey
private Guid _extenderPropertiesKey
private Guid _extenderProviderPropertiesKey
private Type[] _skipInterfaceAttributeList
private object _internalSyncObject
internal Guid ExtenderProviderKey
private Hashtable IntrinsicTypeConverters
internal Guid get_ExtenderProviderKey()
private Hashtable get_IntrinsicTypeConverters()
internal void AddEditorTable(Type editorBaseType, Hashtable table)
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
private object CreateInstance(Type objectType, Type callingType)
internal AttributeCollection GetAttributes(Type type)
public IDictionary GetCache(object instance)
internal string GetClassName(Type type)
internal string GetComponentName(Type type, object instance)
internal TypeConverter GetConverter(Type type, object instance)
internal EventDescriptor GetDefaultEvent(Type type, object instance)
internal PropertyDescriptor GetDefaultProperty(Type type, object instance)
internal object GetEditor(Type type, object instance, Type editorBaseType)
private Hashtable GetEditorTable(Type editorBaseType)
internal EventDescriptorCollection GetEvents(Type type)
internal AttributeCollection GetExtendedAttributes(object instance)
internal string GetExtendedClassName(object instance)
internal string GetExtendedComponentName(object instance)
internal TypeConverter GetExtendedConverter(object instance)
internal EventDescriptor GetExtendedDefaultEvent(object instance)
internal PropertyDescriptor GetExtendedDefaultProperty(object instance)
internal object GetExtendedEditor(object instance, Type editorBaseType)
internal EventDescriptorCollection GetExtendedEvents(object instance)
internal PropertyDescriptorCollection GetExtendedProperties(object instance)
protected internal IExtenderProvider[] GetExtenderProviders(object instance)
private IExtenderProvider[] GetExtenders(ICollection components, object instance, IDictionary cache)
internal object GetExtendedPropertyOwner(object instance, PropertyDescriptor pd)
public ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance)
public string GetFullComponentName(object component)
internal Type[] GetPopulatedTypes(Module module)
internal PropertyDescriptorCollection GetProperties(Type type)
internal object GetPropertyOwner(Type type, object instance, PropertyDescriptor pd)
public Type GetReflectionType(Type objectType, object instance)
private ReflectedTypeData GetTypeData(Type type, bool createIfNeeded)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance)
private Type GetTypeFromName(string typeName)
internal bool IsPopulated(Type type)
private Attribute[] ReflectGetAttributes(Type type)
internal Attribute[] ReflectGetAttributes(MemberInfo member)
private EventDescriptor[] ReflectGetEvents(Type type)
private PropertyDescriptor[] ReflectGetExtendedProperties(IExtenderProvider provider)
private PropertyDescriptor[] ReflectGetProperties(Type type)
internal void Refresh(Type type)
private object SearchIntrinsicTable(Hashtable table, Type callingType)
}
public System.ComponentModel.RefreshEventArgs : EventArgs {
private object <ComponentChanged>k__BackingField
private Type <TypeChanged>k__BackingField
public object ComponentChanged
public Type TypeChanged
public void .ctor(object componentChanged)
public void .ctor(Type typeChanged)
public object get_ComponentChanged()
public Type get_TypeChanged()
}
public System.ComponentModel.RefreshEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(RefreshEventArgs e)
public IAsyncResult BeginInvoke(RefreshEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.RefreshProperties : Enum {
public int value__
public RefreshProperties None
public RefreshProperties All
public RefreshProperties Repaint
}
public System.ComponentModel.RefreshPropertiesAttribute : Attribute {
public RefreshPropertiesAttribute All
public RefreshPropertiesAttribute Repaint
public RefreshPropertiesAttribute Default
private RefreshProperties refresh
public RefreshProperties RefreshProperties
public void .ctor(RefreshProperties refresh)
public RefreshProperties get_RefreshProperties()
public bool Equals(object value)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.RunInstallerAttribute : Attribute {
private bool <RunInstaller>k__BackingField
public RunInstallerAttribute Yes
public RunInstallerAttribute No
public RunInstallerAttribute Default
public bool RunInstaller
public void .ctor(bool runInstaller)
public bool get_RunInstaller()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.RunWorkerCompletedEventArgs : AsyncCompletedEventArgs {
private object result
public object Result
public object UserState
public void .ctor(object result, Exception error, bool cancelled)
public object get_Result()
public object get_UserState()
}
public System.ComponentModel.RunWorkerCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, RunWorkerCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, RunWorkerCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.SByteConverter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.SettingsBindableAttribute : Attribute {
public SettingsBindableAttribute Yes
public SettingsBindableAttribute No
private bool <Bindable>k__BackingField
public bool Bindable
public void .ctor(bool bindable)
public bool get_Bindable()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.SingleConverter : BaseNumberConverter {
internal bool AllowHex
internal Type TargetType
internal bool get_AllowHex()
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
internal System.ComponentModel.SRCategoryAttribute : CategoryAttribute {
public void .ctor(string category)
}
public System.ComponentModel.StringConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
}
public System.ComponentModel.SyntaxCheck : object {
public bool CheckMachineName(string value)
public bool CheckPath(string value)
public bool CheckRootedPath(string value)
}
public System.ComponentModel.TimeSpanConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.ToolboxItemAttribute : Attribute {
private Type _toolboxItemType
private string _toolboxItemTypeName
public ToolboxItemAttribute Default
public ToolboxItemAttribute None
public Type ToolboxItemType
public string ToolboxItemTypeName
public bool IsDefaultAttribute()
public void .ctor(bool defaultType)
public void .ctor(string toolboxItemTypeName)
public void .ctor(Type toolboxItemType)
public Type get_ToolboxItemType()
public string get_ToolboxItemTypeName()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.ToolboxItemFilterAttribute : Attribute {
private string _typeId
private string <FilterString>k__BackingField
private ToolboxItemFilterType <FilterType>k__BackingField
public string FilterString
public ToolboxItemFilterType FilterType
public object TypeId
public void .ctor(string filterString)
public void .ctor(string filterString, ToolboxItemFilterType filterType)
public string get_FilterString()
public ToolboxItemFilterType get_FilterType()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
public bool Match(object obj)
public string ToString()
}
public System.ComponentModel.ToolboxItemFilterType : Enum {
public int value__
public ToolboxItemFilterType Allow
public ToolboxItemFilterType Custom
public ToolboxItemFilterType Prevent
public ToolboxItemFilterType Require
}
public System.ComponentModel.TypeConverter : object {
private string s_UseCompatibleTypeConverterBehavior
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) useCompatibleTypeConversion
private bool UseCompatibleTypeConversion
private bool get_UseCompatibleTypeConversion()
public bool CanConvertFrom(Type sourceType)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(Type destinationType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(object value)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertFromInvariantString(string text)
public object ConvertFromInvariantString(ITypeDescriptorContext context, string text)
public object ConvertFromString(string text)
public object ConvertFromString(ITypeDescriptorContext context, string text)
public object ConvertFromString(ITypeDescriptorContext context, CultureInfo culture, string text)
public object ConvertTo(object value, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public string ConvertToInvariantString(object value)
public string ConvertToInvariantString(ITypeDescriptorContext context, object value)
public string ConvertToString(object value)
public string ConvertToString(ITypeDescriptorContext context, object value)
public string ConvertToString(ITypeDescriptorContext context, CultureInfo culture, object value)
public object CreateInstance(IDictionary propertyValues)
public object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
protected Exception GetConvertFromException(object value)
protected Exception GetConvertToException(object value, Type destinationType)
public bool GetCreateInstanceSupported()
public bool GetCreateInstanceSupported(ITypeDescriptorContext context)
public PropertyDescriptorCollection GetProperties(object value)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported()
public bool GetPropertiesSupported(ITypeDescriptorContext context)
public ICollection GetStandardValues()
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive()
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported()
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public bool IsValid(object value)
public bool IsValid(ITypeDescriptorContext context, object value)
protected PropertyDescriptorCollection SortProperties(PropertyDescriptorCollection props, String[] names)
}
public System.ComponentModel.TypeConverterAttribute : Attribute {
public TypeConverterAttribute Default
private string <ConverterTypeName>k__BackingField
public string ConverterTypeName
public void .ctor(Type type)
public void .ctor(string typeName)
public string get_ConverterTypeName()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.TypeDescriptionProvider : object {
private TypeDescriptionProvider _parent
private EmptyCustomTypeDescriptor _emptyDescriptor
protected void .ctor(TypeDescriptionProvider parent)
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
public IDictionary GetCache(object instance)
public ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance)
protected internal IExtenderProvider[] GetExtenderProviders(object instance)
public string GetFullComponentName(object component)
public Type GetReflectionType(Type objectType)
public Type GetReflectionType(object instance)
public Type GetReflectionType(Type objectType, object instance)
public Type GetRuntimeType(Type reflectionType)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType)
public ICustomTypeDescriptor GetTypeDescriptor(object instance)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance)
public bool IsSupportedType(Type type)
}
public System.ComponentModel.TypeDescriptionProviderAttribute : Attribute {
private string <TypeName>k__BackingField
public string TypeName
public void .ctor(string typeName)
public void .ctor(Type type)
public string get_TypeName()
}
public System.ComponentModel.TypeDescriptor : object {
private WeakHashtable _providerTable
private Hashtable _providerTypeTable
private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _defaultProviders
private WeakHashtable modreq(System.Runtime.CompilerServices.IsVolatile) _associationTable
private int _metadataVersion
private int _collisionIndex
private BooleanSwitch TraceDescriptor
private int PIPELINE_ATTRIBUTES
private int PIPELINE_PROPERTIES
private int PIPELINE_EVENTS
private Guid[] _pipelineInitializeKeys
private Guid[] _pipelineMergeKeys
private Guid[] _pipelineFilterKeys
private Guid[] _pipelineAttributeFilterKeys
private object _internalSyncObject
private RefreshEventHandler Refreshed
public IComNativeDescriptorHandler ComNativeDescriptorHandler
public Type ComObjectType
public Type InterfaceType
internal int MetadataVersion
public IComNativeDescriptorHandler get_ComNativeDescriptorHandler()
public void set_ComNativeDescriptorHandler(IComNativeDescriptorHandler value)
public Type get_ComObjectType()
public Type get_InterfaceType()
internal int get_MetadataVersion()
public void add_Refreshed(RefreshEventHandler value)
public void remove_Refreshed(RefreshEventHandler value)
public TypeDescriptionProvider AddAttributes(Type type, Attribute[] attributes)
public TypeDescriptionProvider AddAttributes(object instance, Attribute[] attributes)
public void AddEditorTable(Type editorBaseType, Hashtable table)
public void AddProvider(TypeDescriptionProvider provider, Type type)
public void AddProvider(TypeDescriptionProvider provider, object instance)
public void AddProviderTransparent(TypeDescriptionProvider provider, Type type)
public void AddProviderTransparent(TypeDescriptionProvider provider, object instance)
private void CheckDefaultProvider(Type type)
public void CreateAssociation(object primary, object secondary)
public IDesigner CreateDesigner(IComponent component, Type designerBaseType)
public EventDescriptor CreateEvent(Type componentType, string name, Type type, Attribute[] attributes)
public EventDescriptor CreateEvent(Type componentType, EventDescriptor oldEventDescriptor, Attribute[] attributes)
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
public PropertyDescriptor CreateProperty(Type componentType, string name, Type type, Attribute[] attributes)
public PropertyDescriptor CreateProperty(Type componentType, PropertyDescriptor oldPropertyDescriptor, Attribute[] attributes)
private void DebugValidate(Type type, AttributeCollection attributes, AttributeCollection debugAttributes)
private void DebugValidate(AttributeCollection attributes, AttributeCollection debugAttributes)
private void DebugValidate(AttributeCollection attributes, Type type)
private void DebugValidate(AttributeCollection attributes, object instance, bool noCustomTypeDesc)
private void DebugValidate(TypeConverter converter, Type type)
private void DebugValidate(TypeConverter converter, object instance, bool noCustomTypeDesc)
private void DebugValidate(EventDescriptorCollection events, Type type, Attribute[] attributes)
private void DebugValidate(EventDescriptorCollection events, object instance, Attribute[] attributes, bool noCustomTypeDesc)
private void DebugValidate(PropertyDescriptorCollection properties, Type type, Attribute[] attributes)
private void DebugValidate(PropertyDescriptorCollection properties, object instance, Attribute[] attributes, bool noCustomTypeDesc)
private ArrayList FilterMembers(IList members, Attribute[] attributes)
public object GetAssociation(Type type, object primary)
public AttributeCollection GetAttributes(Type componentType)
public AttributeCollection GetAttributes(object component)
public AttributeCollection GetAttributes(object component, bool noCustomTypeDesc)
internal IDictionary GetCache(object instance)
public string GetClassName(object component)
public string GetClassName(object component, bool noCustomTypeDesc)
public string GetClassName(Type componentType)
public string GetComponentName(object component)
public string GetComponentName(object component, bool noCustomTypeDesc)
public TypeConverter GetConverter(object component)
public TypeConverter GetConverter(object component, bool noCustomTypeDesc)
public TypeConverter GetConverter(Type type)
private object ConvertFromInvariantString(Type type, string stringValue)
public EventDescriptor GetDefaultEvent(Type componentType)
public EventDescriptor GetDefaultEvent(object component)
public EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc)
public PropertyDescriptor GetDefaultProperty(Type componentType)
public PropertyDescriptor GetDefaultProperty(object component)
public PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc)
internal ICustomTypeDescriptor GetDescriptor(Type type, string typeName)
internal ICustomTypeDescriptor GetDescriptor(object component, bool noCustomTypeDesc)
internal ICustomTypeDescriptor GetExtendedDescriptor(object component)
public object GetEditor(object component, Type editorBaseType)
public object GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc)
public object GetEditor(Type type, Type editorBaseType)
public EventDescriptorCollection GetEvents(Type componentType)
public EventDescriptorCollection GetEvents(Type componentType, Attribute[] attributes)
public EventDescriptorCollection GetEvents(object component)
public EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc)
public EventDescriptorCollection GetEvents(object component, Attribute[] attributes)
public EventDescriptorCollection GetEvents(object component, Attribute[] attributes, bool noCustomTypeDesc)
private string GetExtenderCollisionSuffix(MemberDescriptor member)
public string GetFullComponentName(object component)
private Type GetNodeForBaseType(Type searchType)
public PropertyDescriptorCollection GetProperties(Type componentType)
public PropertyDescriptorCollection GetProperties(Type componentType, Attribute[] attributes)
public PropertyDescriptorCollection GetProperties(object component)
public PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc)
public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes)
public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes, bool noCustomTypeDesc)
private PropertyDescriptorCollection GetPropertiesImpl(object component, Attribute[] attributes, bool noCustomTypeDesc, bool noAttributes)
public TypeDescriptionProvider GetProvider(Type type)
public TypeDescriptionProvider GetProvider(object instance)
internal TypeDescriptionProvider GetProviderRecursive(Type type)
public Type GetReflectionType(Type type)
public Type GetReflectionType(object instance)
private TypeDescriptionNode NodeFor(Type type)
private TypeDescriptionNode NodeFor(Type type, bool createDelegator)
private TypeDescriptionNode NodeFor(object instance)
private TypeDescriptionNode NodeFor(object instance, bool createDelegator)
private void NodeRemove(object key, TypeDescriptionProvider provider)
private ICollection PipelineAttributeFilter(int pipelineType, ICollection members, Attribute[] filter, object instance, IDictionary cache)
private ICollection PipelineFilter(int pipelineType, ICollection members, object instance, IDictionary cache)
private ICollection PipelineInitialize(int pipelineType, ICollection members, IDictionary cache)
private ICollection PipelineMerge(int pipelineType, ICollection primary, ICollection secondary, object instance, IDictionary cache)
private void RaiseRefresh(object component)
private void RaiseRefresh(Type type)
public void Refresh(object component)
private void Refresh(object component, bool refreshReflectionProvider)
public void Refresh(Type type)
public void Refresh(Module module)
public void Refresh(Assembly assembly)
public void RemoveAssociation(object primary, object secondary)
public void RemoveAssociations(object primary)
public void RemoveProvider(TypeDescriptionProvider provider, Type type)
public void RemoveProvider(TypeDescriptionProvider provider, object instance)
public void RemoveProviderTransparent(TypeDescriptionProvider provider, Type type)
public void RemoveProviderTransparent(TypeDescriptionProvider provider, object instance)
private bool ShouldHideMember(MemberDescriptor member, Attribute attribute)
public void SortDescriptorArray(IList infos)
internal void Trace(string message, Object[] args)
}
public System.ComponentModel.TypeListConverter : TypeConverter {
private Type[] _types
private StandardValuesCollection _values
protected void .ctor(Type[] types)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.UInt16Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.UInt32Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.UInt64Converter : BaseNumberConverter {
internal Type TargetType
internal Type get_TargetType()
internal object FromString(string value, int radix)
internal object FromString(string value, NumberFormatInfo formatInfo)
internal string ToString(object value, NumberFormatInfo formatInfo)
}
public System.ComponentModel.WarningException : SystemException {
private string <HelpUrl>k__BackingField
private string <HelpTopic>k__BackingField
public string HelpUrl
public string HelpTopic
public void .ctor(string message)
public void .ctor(string message, string helpUrl)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string helpUrl, string helpTopic)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_HelpUrl()
public string get_HelpTopic()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.ComponentModel.WeakHashtable : Hashtable {
private IEqualityComparer _comparer
private long _lastGlobalMem
private int _lastHashCount
public void Clear()
public void Remove(object key)
public void SetWeak(object key, object value)
private void ScavengeKeys()
}
public System.ComponentModel.Win32Exception : ExternalException {
private int nativeErrorCode
private int MAX_MESSAGE_LENGTH
public int NativeErrorCode
public void .ctor(int error)
public void .ctor(int error, string message)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_NativeErrorCode()
public void GetObjectData(SerializationInfo info, StreamingContext context)
private int FormatMessage(int dwFlags, IntPtr lpSource, UInt32 dwMessageId, int dwLanguageId, Char[] lpBuffer, int nSize, IntPtr[] arguments)
internal string GetErrorMessage(int error)
}
internal System.Configuration.AllowDefinition : Enum {
public int value__
public AllowDefinition Everywhere
public AllowDefinition MachineOnly
public AllowDefinition MachineToApplication
}
public System.Configuration.ApplicationSettingsBase : SettingsBase {
private PropertyChangedEventHandler PropertyChanged
private SettingChangingEventHandler SettingChanging
private SettingsLoadedEventHandler SettingsLoaded
private SettingsSavingEventHandler SettingsSaving
private string settingsKey
private SettingsContext context
private SettingsPropertyCollection properties
private ISettingsProviderService providerService
private SettingsPropertyValueCollection propertyValues
private SettingsProviderCollection providers
public SettingsContext Context
public object Item
public SettingsPropertyCollection Properties
public SettingsPropertyValueCollection PropertyValues
public SettingsProviderCollection Providers
public string SettingsKey
protected void .ctor(IComponent owner)
protected void .ctor(string settingsKey)
protected void .ctor(IComponent owner, string settingsKey)
public void add_PropertyChanged(PropertyChangedEventHandler value)
public void remove_PropertyChanged(PropertyChangedEventHandler value)
public void add_SettingChanging(SettingChangingEventHandler value)
public void remove_SettingChanging(SettingChangingEventHandler value)
public void add_SettingsLoaded(SettingsLoadedEventHandler value)
public void remove_SettingsLoaded(SettingsLoadedEventHandler value)
public void add_SettingsSaving(SettingsSavingEventHandler value)
public void remove_SettingsSaving(SettingsSavingEventHandler value)
public object GetPreviousVersion(string propertyName)
public void Reload()
public void Reset()
public void Save()
private void InternalSave()
public void Upgrade()
private SettingsPropertyCollection GetPropertiesForProvider(SettingsProvider provider)
protected void OnPropertyChanged(object sender, PropertyChangedEventArgs e)
protected void OnSettingChanging(object sender, SettingChangingEventArgs e)
protected void OnSettingsLoaded(object sender, SettingsLoadedEventArgs e)
protected void OnSettingsSaving(object sender, CancelEventArgs e)
public SettingsContext get_Context()
private void CacheValuesByProvider(SettingsProvider provider)
private void InitializeSettings(SettingsPropertyCollection settings)
private object GetPropertyValue(string propertyName)
public object get_Item(string propertyName)
public void set_Item(string propertyName, object value)
public SettingsPropertyCollection get_Properties()
private void CreateSettingsProperty(PropertyInfo prop, SettingsPropertyCollection properties, SettingsProvider& local_provider)
public SettingsPropertyValueCollection get_PropertyValues()
public SettingsProviderCollection get_Providers()
public string get_SettingsKey()
public void set_SettingsKey(string value)
}
public System.Configuration.AppSettingsReader : object {
private NameValueCollection appSettings
public object GetValue(string key, Type type)
}
public System.Configuration.ClientSettingsSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty settings_prop
public SettingElementCollection Settings
protected ConfigurationPropertyCollection Properties
public SettingElementCollection get_Settings()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Configuration.ConfigHelper : object {
internal IDictionary GetDictionary(IDictionary prev, XmlNode region, string nameAtt, string valueAtt)
internal ConfigNameValueCollection GetNameValueCollection(NameValueCollection prev, XmlNode region, string nameAtt, string valueAtt)
private CollectionWrapper GoGetThem(CollectionWrapper result, XmlNode region, string nameAtt, string valueAtt)
}
internal System.Configuration.ConfigNameValueCollection : NameValueCollection {
private bool modified
public bool IsModified
public void .ctor(ConfigNameValueCollection col)
public void .ctor(IHashCodeProvider hashProvider, IComparer comparer)
public void ResetModified()
public bool get_IsModified()
public void Set(string name, string value)
}
internal System.Configuration.ConfigurationData : object {
private ConfigurationData parent
private Hashtable factories
private object removedMark
private object emptyMark
private Hashtable pending
private string fileName
private object groupMark
private Hashtable cache
private Hashtable FileCache
private Hashtable get_FileCache()
public void .ctor(ConfigurationData parent)
public bool Load(string fileName)
public bool LoadString(string data)
private object GetHandler(string sectionName)
private object CreateNewHandler(string sectionName, SectionData section)
private XmlDocument GetInnerDoc(XmlDocument doc, int i, String[] sectionPath)
private XmlDocument GetDocumentForSection(string sectionName)
private object GetConfigInternal(string sectionName)
public object GetConfig(string sectionName)
private object LookForFactory(string key)
private bool InitRead(XmlTextReader reader)
private void MoveToNextElement(XmlTextReader reader)
private void ReadSection(XmlTextReader reader, string sectionName)
private void ReadRemoveSection(XmlTextReader reader, string sectionName)
private void ReadSectionGroup(XmlTextReader reader, string configSection)
private void ReadSections(XmlTextReader reader, string configSection)
private void StorePending(string name, XmlTextReader reader)
private void ReadConfigFile(XmlTextReader reader)
private void ThrowException(string text, XmlTextReader reader)
}
public System.Configuration.ConfigurationException : SystemException {
private string filename
private int line
public string BareMessage
public string Filename
public int Line
public string Message
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string message, XmlNode node)
public void .ctor(string message, Exception inner, XmlNode node)
public void .ctor(string message, string filename, int line)
public void .ctor(string message, Exception inner, string filename, int line)
public string get_BareMessage()
public string get_Filename()
public int get_Line()
public string get_Message()
public string GetXmlNodeFilename(XmlNode node)
public int GetXmlNodeLineNumber(XmlNode node)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Configuration.ConfigurationSettings : object {
private IConfigurationSystem config
private object lockobj
public NameValueCollection AppSettings
public object GetConfig(string sectionName)
public NameValueCollection get_AppSettings()
internal IConfigurationSystem ChangeConfigurationSystem(IConfigurationSystem newSystem)
}
public System.Configuration.ConfigXmlDocument : XmlDocument {
private XmlTextReader reader
private string fileName
private int lineNumber
public string Filename
public int LineNumber
private string System.Configuration.Internal.IConfigErrorInfo.Filename
private int System.Configuration.Internal.IConfigErrorInfo.LineNumber
private string System.Configuration.IConfigXmlNode.Filename
private int System.Configuration.IConfigXmlNode.LineNumber
public XmlAttribute CreateAttribute(string prefix, string localName, string namespaceUri)
public XmlCDataSection CreateCDataSection(string data)
public XmlComment CreateComment(string data)
public XmlElement CreateElement(string prefix, string localName, string namespaceUri)
public XmlSignificantWhitespace CreateSignificantWhitespace(string data)
public XmlText CreateTextNode(string text)
public XmlWhitespace CreateWhitespace(string data)
public void Load(string filename)
public void LoadSingleElement(string filename, XmlTextReader sourceReader)
public string get_Filename()
public int get_LineNumber()
private string System.Configuration.Internal.IConfigErrorInfo.get_Filename()
private int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber()
private string System.Configuration.IConfigXmlNode.get_Filename()
private int System.Configuration.IConfigXmlNode.get_LineNumber()
}
internal System.Configuration.CustomizableFileSettingsProvider : SettingsProvider {
private Type webConfigurationFileMapType
private string userRoamingPath
private string userLocalPath
private string userRoamingPathPrevVersion
private string userLocalPathPrevVersion
private string userRoamingName
private string userLocalName
private string userRoamingBasePath
private string userLocalBasePath
private string CompanyName
private string ProductName
private string ForceVersion
private String[] ProductVersion
private bool isVersionMajor
private bool isVersionMinor
private bool isVersionBuild
private bool isVersionRevision
private bool isCompany
private bool isProduct
private bool isEvidence
private bool userDefine
private UserConfigLocationOption userConfig
private string app_name
private ExeConfigurationFileMap exeMapCurrent
private ExeConfigurationFileMap exeMapPrev
private SettingsPropertyValueCollection values
internal string UserRoamingFullPath
internal string UserLocalFullPath
public string PrevUserRoamingFullPath
public string PrevUserLocalFullPath
public string UserRoamingPath
public string UserLocalPath
public string UserRoamingName
public string UserLocalName
public UserConfigLocationOption UserConfigSelector
public bool IsVersionMajor
public bool IsVersionMinor
public bool IsVersionBuild
public bool IsVersionRevision
public bool IsCompany
public bool IsEvidence
public string Name
public string ApplicationName
public void Initialize(string name, NameValueCollection config)
internal string get_UserRoamingFullPath()
internal string get_UserLocalFullPath()
public string get_PrevUserRoamingFullPath()
public string get_PrevUserLocalFullPath()
public string get_UserRoamingPath()
public string get_UserLocalPath()
public string get_UserRoamingName()
public string get_UserLocalName()
public UserConfigLocationOption get_UserConfigSelector()
public void set_UserConfigSelector(UserConfigLocationOption value)
public bool get_IsVersionMajor()
public void set_IsVersionMajor(bool value)
public bool get_IsVersionMinor()
public void set_IsVersionMinor(bool value)
public bool get_IsVersionBuild()
public void set_IsVersionBuild(bool value)
public bool get_IsVersionRevision()
public void set_IsVersionRevision(bool value)
public bool get_IsCompany()
public void set_IsCompany(bool value)
public bool get_IsEvidence()
public void set_IsEvidence(bool value)
private string GetCompanyName()
private string GetProductName()
private string GetEvidenceHash()
private string GetProductVersion()
private void CreateUserConfigPath()
private string PrevVersionPath(string dirName, string currentVersion)
public bool SetUserRoamingPath(string configPath)
public bool SetUserLocalPath(string configPath)
private bool CheckFileName(string configFile)
public bool SetUserRoamingFileName(string configFile)
public bool SetUserLocalFileName(string configFile)
public bool SetCompanyName(string companyName)
public bool SetProductName(string productName)
public bool SetVersion(int major)
public bool SetVersion(int major, int minor)
public bool SetVersion(int major, int minor, int build)
public bool SetVersion(int major, int minor, int build, int revision)
public bool SetVersion(string forceVersion)
private bool CheckPath(string configPath)
public string get_Name()
public string get_ApplicationName()
public void set_ApplicationName(string value)
private string StripXmlHeader(string serializedValue)
private void SaveProperties(ExeConfigurationFileMap exeMap, SettingsPropertyValueCollection collection, ConfigurationUserLevel level, SettingsContext context, bool checkUserLevel)
private string NormalizeInvalidXmlChars(string str)
private void LoadPropertyValue(SettingsPropertyCollection collection, SettingElement element, bool allowOverwrite)
private void LoadProperties(ExeConfigurationFileMap exeMap, SettingsPropertyCollection collection, ConfigurationUserLevel level, string sectionGroupName, bool allowOverwrite, string groupName)
public void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection)
public SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection)
private void CreateExeMap()
public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property)
public void Reset(SettingsContext context)
public void Upgrade(SettingsContext context, SettingsPropertyCollection properties)
public void setCreate()
}
internal System.Configuration.DefaultConfig : object {
private DefaultConfig instance
private ConfigurationData config
public DefaultConfig GetInstance()
public object GetConfig(string sectionName)
public void Init()
private string get_bundled_machine_config()
internal string GetBundledMachineConfig()
private string get_machine_config_path()
internal string GetMachineConfigPath()
private string GetAppConfigPath()
}
public System.Configuration.DefaultSettingValueAttribute : Attribute {
private string value
public string Value
public void .ctor(string value)
public string get_Value()
}
public System.Configuration.DictionarySectionHandler : object {
protected string KeyAttributeName
protected string ValueAttributeName
public object Create(object parent, object context, XmlNode section)
protected string get_KeyAttributeName()
protected string get_ValueAttributeName()
}
public System.Configuration.IApplicationSettingsProvider {
public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property)
public void Reset(SettingsContext context)
public void Upgrade(SettingsContext context, SettingsPropertyCollection properties)
}
public System.Configuration.IConfigurationSectionHandler {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Configuration.IConfigurationSystem {
public object GetConfig(string configKey)
public void Init()
}
internal System.Configuration.IConfigXmlNode {
public string Filename
public int LineNumber
public string get_Filename()
public int get_LineNumber()
}
public System.Configuration.IdnElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty enabled_prop
internal UriIdnScope EnabledDefaultValue
public UriIdnScope Enabled
protected ConfigurationPropertyCollection Properties
public UriIdnScope get_Enabled()
public void set_Enabled(UriIdnScope value)
protected ConfigurationPropertyCollection get_Properties()
public bool Equals(object o)
public int GetHashCode()
}
public System.Configuration.IgnoreSectionHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Configuration.IPersistComponentSettings {
public bool SaveSettings
public string SettingsKey
public bool get_SaveSettings()
public void set_SaveSettings(bool value)
public string get_SettingsKey()
public void set_SettingsKey(string value)
public void LoadComponentSettings()
public void ResetComponentSettings()
public void SaveComponentSettings()
}
public System.Configuration.IriParsingElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty enabled_prop
public bool Enabled
protected ConfigurationPropertyCollection Properties
public bool get_Enabled()
public void set_Enabled(bool value)
protected ConfigurationPropertyCollection get_Properties()
public bool Equals(object o)
public int GetHashCode()
}
public System.Configuration.ISettingsProviderService {
public SettingsProvider GetSettingsProvider(SettingsProperty property)
}
public System.Configuration.LocalFileSettingsProvider : SettingsProvider {
private CustomizableFileSettingsProvider impl
public string ApplicationName
public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property)
public SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection properties)
public void Initialize(string name, NameValueCollection values)
public void Reset(SettingsContext context)
public void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection values)
public void Upgrade(SettingsContext context, SettingsPropertyCollection properties)
public string get_ApplicationName()
public void set_ApplicationName(string value)
}
public System.Configuration.NameValueFileSectionHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Configuration.NameValueSectionHandler : object {
protected string KeyAttributeName
protected string ValueAttributeName
public object Create(object parent, object context, XmlNode section)
protected string get_KeyAttributeName()
protected string get_ValueAttributeName()
}
internal System.Configuration.PrivilegedConfigurationManager : object {
internal ConnectionStringSettingsCollection ConnectionStrings
internal ConnectionStringSettingsCollection get_ConnectionStrings()
internal object GetSection(string sectionName)
}
public System.Configuration.SchemeSettingElement : ConfigurationElement {
public GenericUriParserOptions GenericUriParserOptions
public string Name
public GenericUriParserOptions get_GenericUriParserOptions()
public string get_Name()
}
public System.Configuration.SchemeSettingElementCollection : ConfigurationElementCollection {
public SchemeSettingElement Item
public SchemeSettingElement get_Item(int index)
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(SchemeSettingElement element)
}
internal System.Configuration.SectionData : object {
public string SectionName
public string TypeName
public bool AllowLocation
public AllowDefinition AllowDefinition
public string FileName
public bool RequirePermission
public void .ctor(string sectionName, string typeName, bool allowLocation, AllowDefinition allowDefinition, bool requirePermission)
}
public System.Configuration.SettingChangingEventArgs : CancelEventArgs {
private string settingName
private string settingClass
private string settingKey
private object newValue
public string SettingName
public string SettingClass
public string SettingKey
public object NewValue
public void .ctor(string settingName, string settingClass, string settingKey, object newValue, bool cancel)
public string get_SettingName()
public string get_SettingClass()
public string get_SettingKey()
public object get_NewValue()
}
public System.Configuration.SettingChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SettingChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, SettingChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Configuration.SettingElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty name_prop
private ConfigurationProperty serialize_as_prop
private ConfigurationProperty value_prop
public string Name
public SettingValueElement Value
public SettingsSerializeAs SerializeAs
protected ConfigurationPropertyCollection Properties
public void .ctor(string name, SettingsSerializeAs serializeAs)
public string get_Name()
public void set_Name(string value)
public SettingValueElement get_Value()
public void set_Value(SettingValueElement value)
public SettingsSerializeAs get_SerializeAs()
public void set_SerializeAs(SettingsSerializeAs value)
protected ConfigurationPropertyCollection get_Properties()
public bool Equals(object settings)
public int GetHashCode()
}
public System.Configuration.SettingElementCollection : ConfigurationElementCollection {
public ConfigurationElementCollectionType CollectionType
protected string ElementName
public void Add(SettingElement element)
public void Clear()
public SettingElement Get(string elementKey)
public void Remove(SettingElement element)
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public ConfigurationElementCollectionType get_CollectionType()
protected string get_ElementName()
}
public System.Configuration.SettingsAttributeDictionary : Hashtable {
public void .ctor(SettingsAttributeDictionary attributes)
}
public System.Configuration.SettingsBase : object {
private bool sync
private SettingsContext context
private SettingsPropertyCollection properties
private SettingsProviderCollection providers
private SettingsPropertyValueCollection values
public SettingsContext Context
public bool IsSynchronized
public object Item
public SettingsPropertyCollection Properties
public SettingsPropertyValueCollection PropertyValues
public SettingsProviderCollection Providers
public void Initialize(SettingsContext context, SettingsPropertyCollection properties, SettingsProviderCollection providers)
public void Save()
private void SaveCore()
public SettingsBase Synchronized(SettingsBase settingsBase)
public SettingsContext get_Context()
public bool get_IsSynchronized()
public object get_Item(string propertyName)
public void set_Item(string propertyName, object value)
public SettingsPropertyCollection get_Properties()
public SettingsPropertyValueCollection get_PropertyValues()
public SettingsProviderCollection get_Providers()
private object GetPropertyValue(string propertyName)
private void SetPropertyValue(string propertyName, object value)
}
public System.Configuration.SettingsContext : Hashtable {
private ApplicationSettingsBase current
internal ApplicationSettingsBase CurrentSettings
internal ApplicationSettingsBase get_CurrentSettings()
internal void set_CurrentSettings(ApplicationSettingsBase value)
}
public System.Configuration.SettingsDescriptionAttribute : Attribute {
private string desc
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Configuration.SettingsGroupDescriptionAttribute : Attribute {
private string desc
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Configuration.SettingsGroupNameAttribute : Attribute {
private string group_name
public string GroupName
public void .ctor(string groupName)
public string get_GroupName()
}
public System.Configuration.SettingsLoadedEventArgs : EventArgs {
private SettingsProvider provider
public SettingsProvider Provider
public void .ctor(SettingsProvider provider)
public SettingsProvider get_Provider()
}
public System.Configuration.SettingsLoadedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SettingsLoadedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SettingsLoadedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Configuration.SettingsManageability : Enum {
public int value__
public SettingsManageability Roaming
}
public System.Configuration.SettingsManageabilityAttribute : Attribute {
private SettingsManageability manageability
public SettingsManageability Manageability
public void .ctor(SettingsManageability manageability)
public SettingsManageability get_Manageability()
}
public System.Configuration.SettingsProperty : object {
private string name
private Type propertyType
private SettingsProvider provider
private bool isReadOnly
private object defaultValue
private SettingsSerializeAs serializeAs
private SettingsAttributeDictionary attributes
private bool throwOnErrorDeserializing
private bool throwOnErrorSerializing
public SettingsAttributeDictionary Attributes
public object DefaultValue
public bool IsReadOnly
public string Name
public Type PropertyType
public SettingsProvider Provider
public SettingsSerializeAs SerializeAs
public bool ThrowOnErrorDeserializing
public bool ThrowOnErrorSerializing
public void .ctor(SettingsProperty propertyToCopy)
public void .ctor(string name)
public void .ctor(string name, Type propertyType, SettingsProvider provider, bool isReadOnly, object defaultValue, SettingsSerializeAs serializeAs, SettingsAttributeDictionary attributes, bool throwOnErrorDeserializing, bool throwOnErrorSerializing)
public SettingsAttributeDictionary get_Attributes()
public object get_DefaultValue()
public void set_DefaultValue(object value)
public bool get_IsReadOnly()
public void set_IsReadOnly(bool value)
public string get_Name()
public void set_Name(string value)
public Type get_PropertyType()
public void set_PropertyType(Type value)
public SettingsProvider get_Provider()
public void set_Provider(SettingsProvider value)
public SettingsSerializeAs get_SerializeAs()
public void set_SerializeAs(SettingsSerializeAs value)
public bool get_ThrowOnErrorDeserializing()
public void set_ThrowOnErrorDeserializing(bool value)
public bool get_ThrowOnErrorSerializing()
public void set_ThrowOnErrorSerializing(bool value)
}
public System.Configuration.SettingsPropertyCollection : object {
private Hashtable items
private bool isReadOnly
public int Count
public bool IsSynchronized
public SettingsProperty Item
public object SyncRoot
public void Add(SettingsProperty property)
public void Clear()
public object Clone()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string name)
public void SetReadOnly()
protected void OnAdd(SettingsProperty property)
protected void OnAddComplete(SettingsProperty property)
protected void OnClear()
protected void OnClearComplete()
protected void OnRemove(SettingsProperty property)
protected void OnRemoveComplete(SettingsProperty property)
public int get_Count()
public bool get_IsSynchronized()
public SettingsProperty get_Item(string name)
public object get_SyncRoot()
}
public System.Configuration.SettingsPropertyIsReadOnlyException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Configuration.SettingsPropertyNotFoundException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Configuration.SettingsPropertyValue : object {
private SettingsProperty property
private object propertyValue
private object serializedValue
private bool needSerializedValue
private bool needPropertyValue
private bool dirty
private bool defaulted
private bool deserialized
public bool Deserialized
public bool IsDirty
public string Name
public SettingsProperty Property
public object PropertyValue
public object SerializedValue
public bool UsingDefaultValue
public void .ctor(SettingsProperty property)
public bool get_Deserialized()
public void set_Deserialized(bool value)
public bool get_IsDirty()
public void set_IsDirty(bool value)
public string get_Name()
public SettingsProperty get_Property()
public object get_PropertyValue()
public void set_PropertyValue(object value)
public object get_SerializedValue()
public void set_SerializedValue(object value)
public bool get_UsingDefaultValue()
internal object Reset()
private object GetDeserializedDefaultValue()
private object GetDeserializedValue(object serializedValue)
}
public System.Configuration.SettingsPropertyValueCollection : object {
private Hashtable items
private bool isReadOnly
public int Count
public bool IsSynchronized
public SettingsPropertyValue Item
public object SyncRoot
public void Add(SettingsPropertyValue property)
internal void Add(SettingsPropertyValueCollection vals)
public void Clear()
public object Clone()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string name)
public void SetReadOnly()
public int get_Count()
public bool get_IsSynchronized()
public SettingsPropertyValue get_Item(string name)
public object get_SyncRoot()
}
public System.Configuration.SettingsPropertyWrongTypeException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Configuration.SettingsProvider : ProviderBase {
public string ApplicationName
public SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection)
public void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection)
public string get_ApplicationName()
public void set_ApplicationName(string value)
}
public System.Configuration.SettingsProviderAttribute : Attribute {
private string providerTypeName
public string ProviderTypeName
public void .ctor(string providerTypeName)
public void .ctor(Type providerType)
public string get_ProviderTypeName()
}
public System.Configuration.SettingsProviderCollection : ProviderCollection {
public SettingsProvider Item
public void Add(ProviderBase provider)
public SettingsProvider get_Item(string name)
}
public System.Configuration.SettingsSavingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, CancelEventArgs e)
public IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Configuration.SettingsSerializeAs : Enum {
public int value__
public SettingsSerializeAs String
public SettingsSerializeAs Xml
public SettingsSerializeAs Binary
public SettingsSerializeAs ProviderSpecific
}
public System.Configuration.SettingsSerializeAsAttribute : Attribute {
private SettingsSerializeAs serializeAs
public SettingsSerializeAs SerializeAs
public void .ctor(SettingsSerializeAs serializeAs)
public SettingsSerializeAs get_SerializeAs()
}
public System.Configuration.SettingValueElement : ConfigurationElement {
private XmlNode node
private XmlNode original
protected ConfigurationPropertyCollection Properties
public XmlNode ValueXml
protected ConfigurationPropertyCollection get_Properties()
public XmlNode get_ValueXml()
public void set_ValueXml(XmlNode value)
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
public bool Equals(object settingValue)
public int GetHashCode()
protected bool IsModified()
protected void Reset(ConfigurationElement parentElement)
protected void ResetModified()
protected bool SerializeToXmlElement(XmlWriter writer, string elementName)
protected void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
private bool HasValue(ConfigurationElement element, string propName)
private object GetItem(ConfigurationElement element, string property)
private bool PropertyIsElement(PropertyInformation prop)
private bool ElementIsModified(ConfigurationElement element)
private void ElementUnmerge(ConfigurationElement target, ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
}
public System.Configuration.SingleTagSectionHandler : object {
public object Create(object parent, object context, XmlNode section)
}
public System.Configuration.SpecialSetting : Enum {
public int value__
public SpecialSetting ConnectionString
public SpecialSetting WebServiceUrl
}
public System.Configuration.SpecialSettingAttribute : Attribute {
private SpecialSetting setting
public SpecialSetting SpecialSetting
public void .ctor(SpecialSetting specialSetting)
public SpecialSetting get_SpecialSetting()
}
public System.Configuration.UriSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty idn_prop
private ConfigurationProperty iriParsing_prop
public IdnElement Idn
public IriParsingElement IriParsing
protected ConfigurationPropertyCollection Properties
public SchemeSettingElementCollection SchemeSettings
public IdnElement get_Idn()
public IriParsingElement get_IriParsing()
protected ConfigurationPropertyCollection get_Properties()
public SchemeSettingElementCollection get_SchemeSettings()
}
internal System.Configuration.UserConfigLocationOption : Enum {
public UInt32 value__
public UserConfigLocationOption Product
public UserConfigLocationOption Product_VersionMajor
public UserConfigLocationOption Product_VersionMinor
public UserConfigLocationOption Product_VersionBuild
public UserConfigLocationOption Product_VersionRevision
public UserConfigLocationOption Company_Product
public UserConfigLocationOption Company_Product_VersionMajor
public UserConfigLocationOption Company_Product_VersionMinor
public UserConfigLocationOption Company_Product_VersionBuild
public UserConfigLocationOption Company_Product_VersionRevision
public UserConfigLocationOption Evidence
public UserConfigLocationOption Other
}
internal System.CSharpHelpers : object {
private Dictionary`2<string, object> s_fixedStringLookup
private String[][] s_keywords
public string CreateEscapedIdentifier(string name)
public bool IsValidLanguageIndependentIdentifier(string value)
internal bool IsKeyword(string value)
internal bool IsPrefixTwoUnderscore(string value)
internal bool IsValidTypeNameOrIdentifier(string value, bool isTypeName)
internal bool IsSpecialTypeChar(char ch, Boolean& nextMustBeStartChar)
}
internal System.Diagnostics.AlphabeticalEnumConverter : EnumConverter {
public void .ctor(Type type)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
}
internal System.Diagnostics.AssertSection : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propAssertUIEnabled
private ConfigurationProperty _propLogFile
public bool AssertUIEnabled
public string LogFileName
protected ConfigurationPropertyCollection Properties
public bool get_AssertUIEnabled()
public string get_LogFileName()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Diagnostics.AssertWrapper : object {
public void ShowAssert(string stackTrace, StackFrame frame, string message, string detailMessage)
}
internal System.Diagnostics.AsyncStreamReader : object {
internal int DefaultBufferSize
private int MinBufferSize
private Stream stream
private Encoding encoding
private Decoder decoder
private Byte[] byteBuffer
private Char[] charBuffer
private int _maxCharsPerBuffer
private Process process
private UserCallBack userCallBack
private bool cancelOperation
private ManualResetEvent eofEvent
private Queue messageQueue
private StringBuilder sb
private bool bLastCarriageReturn
private int currentLinePos
private object syncObject
private IAsyncResult asyncReadResult
public Encoding CurrentEncoding
public Stream BaseStream
internal void .ctor(Process process, Stream stream, UserCallBack callback, Encoding encoding)
internal void .ctor(Process process, Stream stream, UserCallBack callback, Encoding encoding, int bufferSize)
private void Init(Process process, Stream stream, UserCallBack callback, Encoding encoding, int bufferSize)
public void Close()
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
public Encoding get_CurrentEncoding()
public Stream get_BaseStream()
internal void BeginReadLine()
internal void CancelOperation()
private void ReadBuffer(IAsyncResult ar)
private void GetLinesFromStringBuilder()
private void FlushMessageQueue()
internal void WaitUtilEOF()
}
public System.Diagnostics.BooleanSwitch : Switch {
public bool Enabled
public void .ctor(string displayName, string description)
public void .ctor(string displayName, string description, string defaultSwitchValue)
public bool get_Enabled()
public void set_Enabled(bool value)
protected void OnValueChanged()
}
public System.Diagnostics.ConsoleTraceListener : TextWriterTraceListener {
public void .ctor(bool useErrorStream)
public void Close()
}
public System.Diagnostics.CorrelationManager : object {
private string transactionSlotName
private string activityIdSlotName
public Guid ActivityId
public Stack LogicalOperationStack
public Guid get_ActivityId()
public void set_ActivityId(Guid value)
public Stack get_LogicalOperationStack()
public void StartLogicalOperation(object operationId)
public void StartLogicalOperation()
public void StopLogicalOperation()
private Stack GetLogicalOperationStack()
}
public System.Diagnostics.CounterCreationData : object {
private string help
private string name
private PerformanceCounterType type
public string CounterHelp
public string CounterName
public PerformanceCounterType CounterType
public void .ctor(string counterName, string counterHelp, PerformanceCounterType counterType)
public string get_CounterHelp()
public void set_CounterHelp(string value)
public string get_CounterName()
public void set_CounterName(string value)
public PerformanceCounterType get_CounterType()
public void set_CounterType(PerformanceCounterType value)
}
public System.Diagnostics.CounterCreationDataCollection : CollectionBase {
public CounterCreationData Item
public void .ctor(CounterCreationData[] value)
public void .ctor(CounterCreationDataCollection value)
public CounterCreationData get_Item(int index)
public void set_Item(int index, CounterCreationData value)
public int Add(CounterCreationData value)
public void AddRange(CounterCreationData[] value)
public void AddRange(CounterCreationDataCollection value)
public bool Contains(CounterCreationData value)
public void CopyTo(CounterCreationData[] array, int index)
public int IndexOf(CounterCreationData value)
public void Insert(int index, CounterCreationData value)
protected void OnValidate(object value)
public void Remove(CounterCreationData value)
}
public System.Diagnostics.CounterSample : ValueType {
private long rawValue
private long baseValue
private long counterFrequency
private long systemFrequency
private long timeStamp
private long timeStamp100nSec
private long counterTimeStamp
private PerformanceCounterType counterType
public CounterSample Empty
public long BaseValue
public long CounterFrequency
public long CounterTimeStamp
public PerformanceCounterType CounterType
public long RawValue
public long SystemFrequency
public long TimeStamp
public long TimeStamp100nSec
public void .ctor(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType)
public void .ctor(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType, long counterTimeStamp)
public long get_BaseValue()
public long get_CounterFrequency()
public long get_CounterTimeStamp()
public PerformanceCounterType get_CounterType()
public long get_RawValue()
public long get_SystemFrequency()
public long get_TimeStamp()
public long get_TimeStamp100nSec()
public float Calculate(CounterSample counterSample)
public float Calculate(CounterSample counterSample, CounterSample nextCounterSample)
public bool Equals(object o)
public bool Equals(CounterSample sample)
public bool op_Equality(CounterSample a, CounterSample b)
public bool op_Inequality(CounterSample a, CounterSample b)
public int GetHashCode()
}
public System.Diagnostics.CounterSampleCalculator : object {
public float ComputeCounterValue(CounterSample newSample)
public float ComputeCounterValue(CounterSample oldSample, CounterSample newSample)
}
public System.Diagnostics.DataReceivedEventArgs : EventArgs {
private string data
public string Data
internal void .ctor(string data)
public string get_Data()
}
public System.Diagnostics.DataReceivedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DataReceivedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DataReceivedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Diagnostics.Debug : object {
public TraceListenerCollection Listeners
public bool AutoFlush
public int IndentLevel
public int IndentSize
public TraceListenerCollection get_Listeners()
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public void Flush()
public void Close()
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Assert(bool condition, string message, string detailMessageFormat, Object[] args)
public void Fail(string message)
public void Fail(string message, string detailMessage)
public void Print(string message)
public void Print(string format, Object[] args)
public void Write(string message)
public void Write(object value)
public void Write(string message, string category)
public void Write(object value, string category)
public void WriteLine(string message)
public void WriteLine(object value)
public void WriteLine(string message, string category)
public void WriteLine(object value, string category)
public void WriteLine(string format, Object[] args)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message, string category)
public void WriteIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, string message, string category)
public void WriteLineIf(bool condition, object value, string category)
public void Indent()
public void Unindent()
}
public System.Diagnostics.DefaultTraceListener : TraceListener {
private bool OnWin32
private string ConsoleOutTrace
private string ConsoleErrorTrace
private string MonoTracePrefix
private string MonoTraceFile
private string logFileName
private bool assertUiEnabled
public bool AssertUiEnabled
public string LogFileName
private string GetPrefix(string var, string target)
public bool get_AssertUiEnabled()
public void set_AssertUiEnabled(bool value)
public string get_LogFileName()
public void set_LogFileName(string value)
public void Fail(string message)
public void Fail(string message, string detailMessage)
private DialogResult ProcessUI(string message, string detailMessage)
private void WriteWindowsDebugString(Char* message)
private void WriteDebugString(string message)
private void WriteMonoTrace(string message)
private void WritePrefix()
private void WriteImpl(string message)
private void WriteLogFile(string message, string logFile)
public void Write(string message)
public void WriteLine(string message)
}
public System.Diagnostics.DelimitedListTraceListener : TextWriterTraceListener {
private string delimiter
private string secondaryDelim
private bool initializedDelim
public string Delimiter
public void .ctor(Stream stream)
public void .ctor(Stream stream, string name)
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string name)
public void .ctor(string fileName)
public void .ctor(string fileName, string name)
public string get_Delimiter()
public void set_Delimiter(string value)
protected internal String[] GetSupportedAttributes()
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
private void WriteHeader(string source, TraceEventType eventType, int id)
private void WriteFooter(TraceEventCache eventCache)
private void WriteEscaped(string message)
private void WriteStackEscaped(Stack stack)
}
internal System.Diagnostics.DiagnosticsConfiguration : object {
private SystemDiagnosticsSection modreq(System.Runtime.CompilerServices.IsVolatile) configSection
private InitState modreq(System.Runtime.CompilerServices.IsVolatile) initState
internal SwitchElementsCollection SwitchSettings
internal bool AssertUIEnabled
internal string ConfigFilePath
internal string LogFileName
internal bool AutoFlush
internal bool UseGlobalLock
internal int IndentSize
internal ListenerElementsCollection SharedListeners
internal SourceElementsCollection Sources
internal SystemDiagnosticsSection SystemDiagnosticsSection
internal SwitchElementsCollection get_SwitchSettings()
internal bool get_AssertUIEnabled()
internal string get_ConfigFilePath()
internal string get_LogFileName()
internal bool get_AutoFlush()
internal bool get_UseGlobalLock()
internal int get_IndentSize()
internal ListenerElementsCollection get_SharedListeners()
internal SourceElementsCollection get_Sources()
internal SystemDiagnosticsSection get_SystemDiagnosticsSection()
private SystemDiagnosticsSection GetConfigSection()
internal bool IsInitializing()
internal bool IsInitialized()
internal bool CanInitialize()
internal void Initialize()
internal void Refresh()
}
public System.Diagnostics.DiagnosticsConfigurationHandler : object {
private TraceImplSettings configValues
private IDictionary elementHandlers
public object Create(object parent, object configContext, XmlNode section)
private void AddAssertNode(IDictionary d, XmlNode node)
private void AddPerformanceCountersNode(IDictionary d, XmlNode node)
private void AddSwitchesNode(IDictionary d, XmlNode node)
private object GetSwitchValue(string name, string value)
private void AddTraceNode(IDictionary d, XmlNode node)
private void AddTraceAttributes(IDictionary d, XmlNode node)
private TraceListenerCollection GetSharedListeners(IDictionary d)
private void AddSourcesNode(IDictionary d, XmlNode node)
private void AddTraceSource(IDictionary d, Hashtable sources, XmlNode node)
private void AddTraceListeners(IDictionary d, XmlNode listenersNode, TraceListenerCollection listeners)
private void AddTraceListener(IDictionary d, XmlNode child, XmlAttributeCollection attributes, TraceListenerCollection listeners)
private void RemoveTraceListener(string name)
private string GetAttribute(XmlAttributeCollection attrs, string attr, bool required, XmlNode node)
private void ValidateAttribute(string attribute, string value, XmlNode node)
private void ValidateInvalidAttributes(XmlAttributeCollection c, XmlNode node)
private void ThrowMissingAttribute(string attribute, XmlNode node)
private void ThrowUnrecognizedNode(XmlNode node)
private void ThrowUnrecognizedElement(XmlNode node)
private void ThrowUnrecognizedAttribute(string attribute, XmlNode node)
}
public System.Diagnostics.EntryWrittenEventArgs : EventArgs {
private EventLogEntry entry
public EventLogEntry Entry
public void .ctor(EventLogEntry entry)
public EventLogEntry get_Entry()
}
public System.Diagnostics.EntryWrittenEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, EntryWrittenEventArgs e)
public IAsyncResult BeginInvoke(object sender, EntryWrittenEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Diagnostics.EnvironmentBlock : object {
public Byte[] ToByteArray(StringDictionary sd, bool unicode)
}
public System.Diagnostics.EventInstance : object {
private int _categoryId
private EventLogEntryType _entryType
private long _instanceId
public int CategoryId
public EventLogEntryType EntryType
public long InstanceId
public void .ctor(long instanceId, int categoryId)
public void .ctor(long instanceId, int categoryId, EventLogEntryType entryType)
public int get_CategoryId()
public void set_CategoryId(int value)
public EventLogEntryType get_EntryType()
public void set_EntryType(EventLogEntryType value)
public long get_InstanceId()
public void set_InstanceId(long value)
}
public System.Diagnostics.EventLog : Component {
private string source
private string logName
private string machineName
private bool doRaiseEvents
private ISynchronizeInvoke synchronizingObject
internal string LOCAL_FILE_IMPL
private string WIN32_IMPL
private string NULL_IMPL
internal string EVENTLOG_TYPE_VAR
private EventLogImpl Impl
private EntryWrittenEventHandler EntryWritten
public bool EnableRaisingEvents
public EventLogEntryCollection Entries
public string Log
public string LogDisplayName
public string MachineName
public string Source
public ISynchronizeInvoke SynchronizingObject
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
private bool Win32EventLogEnabled
private string EventLogImplType
public void .ctor(string logName)
public void .ctor(string logName, string machineName)
public void .ctor(string logName, string machineName, string source)
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
public EventLogEntryCollection get_Entries()
public string get_Log()
public void set_Log(string value)
public string get_LogDisplayName()
public string get_MachineName()
public void set_MachineName(string value)
public string get_Source()
public void set_Source(string value)
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
public void BeginInit()
public void Clear()
public void Close()
internal void Reset()
public void CreateEventSource(string source, string logName)
public void CreateEventSource(string source, string logName, string machineName)
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source)
public void DeleteEventSource(string source, string machineName)
protected void Dispose(bool disposing)
public void EndInit()
public bool Exists(string logName)
public bool Exists(string logName, string machineName)
public EventLog[] GetEventLogs()
public EventLog[] GetEventLogs(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source)
public bool SourceExists(string source, string machineName)
public void WriteEntry(string message)
public void WriteEntry(string message, EventLogEntryType type)
public void WriteEntry(string message, EventLogEntryType type, int eventID)
public void WriteEntry(string message, EventLogEntryType type, int eventID, short category)
public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, Byte[] rawData)
public void WriteEntry(string source, string message)
public void WriteEntry(string source, string message, EventLogEntryType type)
public void WriteEntry(string source, string message, EventLogEntryType type, int eventID)
public void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category)
public void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category, Byte[] rawData)
public void WriteEvent(EventInstance instance, Object[] values)
public void WriteEvent(EventInstance instance, Byte[] data, Object[] values)
public void WriteEvent(string source, EventInstance instance, Object[] values)
public void WriteEvent(string source, EventInstance instance, Byte[] data, Object[] values)
internal void OnEntryWritten(EventLogEntry newEntry)
public void add_EntryWritten(EntryWrittenEventHandler value)
public void remove_EntryWritten(EntryWrittenEventHandler value)
internal string GetLogName()
private EventLogImpl CreateEventLogImpl(string logName, string machineName, string source)
private EventLogImpl CreateEventLogImpl(EventLog eventLog)
private bool get_Win32EventLogEnabled()
private string get_EventLogImplType()
private void WriteEntry(String[] replacementStrings, EventLogEntryType type, long instanceID, short category, Byte[] rawData)
private void ValidateEventID(long instanceID)
internal int GetEventID(long instanceID)
}
public System.Diagnostics.EventLogEntry : Component {
private string category
private short categoryNumber
private Byte[] data
private EventLogEntryType entryType
private int eventID
private int index
private string machineName
private string message
private String[] replacementStrings
private string source
private DateTime timeGenerated
private DateTime timeWritten
private string userName
private long instanceId
public string Category
public short CategoryNumber
public Byte[] Data
public EventLogEntryType EntryType
public int EventID
public int Index
public long InstanceId
public string MachineName
public string Message
public String[] ReplacementStrings
public string Source
public DateTime TimeGenerated
public DateTime TimeWritten
public string UserName
internal void .ctor(string category, short categoryNumber, int index, int eventID, string source, string message, string userName, string machineName, EventLogEntryType entryType, DateTime timeGenerated, DateTime timeWritten, Byte[] data, String[] replacementStrings, long instanceId)
private void .ctor(SerializationInfo info, StreamingContext context)
public string get_Category()
public short get_CategoryNumber()
public Byte[] get_Data()
public EventLogEntryType get_EntryType()
public int get_EventID()
public int get_Index()
public long get_InstanceId()
public string get_MachineName()
public string get_Message()
public String[] get_ReplacementStrings()
public string get_Source()
public DateTime get_TimeGenerated()
public DateTime get_TimeWritten()
public string get_UserName()
public bool Equals(EventLogEntry otherEntry)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Diagnostics.EventLogEntryCollection : object {
private EventLogImpl _impl
public int Count
public EventLogEntry Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
internal void .ctor(EventLogImpl impl)
public int get_Count()
public EventLogEntry get_Item(int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public void CopyTo(EventLogEntry[] entries, int index)
public IEnumerator GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int index)
}
public System.Diagnostics.EventLogEntryType : Enum {
public int value__
public EventLogEntryType Error
public EventLogEntryType Warning
public EventLogEntryType Information
public EventLogEntryType SuccessAudit
public EventLogEntryType FailureAudit
}
internal System.Diagnostics.EventLogImpl : object {
private EventLog _coreEventLog
protected EventLog CoreEventLog
public int EntryCount
public EventLogEntry Item
public string LogDisplayName
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
protected void .ctor(EventLog coreEventLog)
protected EventLog get_CoreEventLog()
public int get_EntryCount()
public EventLogEntry get_Item(int index)
public string get_LogDisplayName()
public EventLogEntry[] GetEntries()
public void DisableNotification()
public void EnableNotification()
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void EndInit()
public bool Exists(string logName, string machineName)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
public EventLog[] GetEventLogs(string machineName)
protected string GetLogDisplayName()
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
protected string FormatMessage(string source, UInt32 messageID, String[] replacementStrings)
protected String[] GetLogNames(string machineName)
protected void ValidateCustomerLogName(string logName, string machineName)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
}
public System.Diagnostics.EventLogPermission : ResourcePermissionBase {
private EventLogPermissionEntryCollection innerCollection
public EventLogPermissionEntryCollection PermissionEntries
public void .ctor(EventLogPermissionEntry[] permissionAccessEntries)
public void .ctor(PermissionState state)
public void .ctor(EventLogPermissionAccess permissionAccess, string machineName)
public EventLogPermissionEntryCollection get_PermissionEntries()
private void SetUp()
internal ResourcePermissionBaseEntry[] GetEntries()
internal void ClearEntries()
internal void Add(object obj)
internal void Remove(object obj)
}
public System.Diagnostics.EventLogPermissionAccess : Enum {
public int value__
public EventLogPermissionAccess None
public EventLogPermissionAccess Browse
public EventLogPermissionAccess Instrument
public EventLogPermissionAccess Audit
public EventLogPermissionAccess Write
public EventLogPermissionAccess Administer
}
public System.Diagnostics.EventLogPermissionAttribute : CodeAccessSecurityAttribute {
private string machineName
private EventLogPermissionAccess permissionAccess
public string MachineName
public EventLogPermissionAccess PermissionAccess
public void .ctor(SecurityAction action)
public string get_MachineName()
public void set_MachineName(string value)
public EventLogPermissionAccess get_PermissionAccess()
public void set_PermissionAccess(EventLogPermissionAccess value)
public IPermission CreatePermission()
}
public System.Diagnostics.EventLogPermissionEntry : object {
private EventLogPermissionAccess permissionAccess
private string machineName
public string MachineName
public EventLogPermissionAccess PermissionAccess
public void .ctor(EventLogPermissionAccess permissionAccess, string machineName)
public string get_MachineName()
public EventLogPermissionAccess get_PermissionAccess()
internal ResourcePermissionBaseEntry CreateResourcePermissionBaseEntry()
}
public System.Diagnostics.EventLogPermissionEntryCollection : CollectionBase {
private EventLogPermission owner
public EventLogPermissionEntry Item
internal void .ctor(EventLogPermission owner)
public EventLogPermissionEntry get_Item(int index)
public void set_Item(int index, EventLogPermissionEntry value)
public int Add(EventLogPermissionEntry value)
public void AddRange(EventLogPermissionEntry[] value)
public void AddRange(EventLogPermissionEntryCollection value)
public bool Contains(EventLogPermissionEntry value)
public void CopyTo(EventLogPermissionEntry[] array, int index)
public int IndexOf(EventLogPermissionEntry value)
public void Insert(int index, EventLogPermissionEntry value)
protected void OnClear()
protected void OnInsert(int index, object value)
protected void OnRemove(int index, object value)
protected void OnSet(int index, object oldValue, object newValue)
public void Remove(EventLogPermissionEntry value)
}
public System.Diagnostics.EventLogTraceListener : TraceListener {
private EventLog event_log
private string name
public EventLog EventLog
public string Name
public void .ctor(EventLog eventLog)
public void .ctor(string source)
public EventLog get_EventLog()
public void set_EventLog(EventLog value)
public string get_Name()
public void set_Name(string value)
public void Close()
protected void Dispose(bool disposing)
public void Write(string message)
public void WriteLine(string message)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, Object[] data)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string message)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string format, Object[] args)
}
public System.Diagnostics.EventSourceCreationData : object {
private string _source
private string _logName
private string _machineName
private string _messageResourceFile
private string _parameterResourceFile
private string _categoryResourceFile
private int _categoryCount
public int CategoryCount
public string CategoryResourceFile
public string LogName
public string MachineName
public string MessageResourceFile
public string ParameterResourceFile
public string Source
public void .ctor(string source, string logName)
internal void .ctor(string source, string logName, string machineName)
public int get_CategoryCount()
public void set_CategoryCount(int value)
public string get_CategoryResourceFile()
public void set_CategoryResourceFile(string value)
public string get_LogName()
public void set_LogName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public string get_MessageResourceFile()
public void set_MessageResourceFile(string value)
public string get_ParameterResourceFile()
public void set_ParameterResourceFile(string value)
public string get_Source()
public void set_Source(string value)
}
public System.Diagnostics.EventTypeFilter : TraceFilter {
private SourceLevels level
public SourceLevels EventType
public void .ctor(SourceLevels level)
public bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data)
public SourceLevels get_EventType()
public void set_EventType(SourceLevels value)
}
public System.Diagnostics.FileVersionInfo : object {
private string comments
private string companyname
private string filedescription
private string filename
private string fileversion
private string internalname
private string language
private string legalcopyright
private string legaltrademarks
private string originalfilename
private string privatebuild
private string productname
private string productversion
private string specialbuild
private bool isdebug
private bool ispatched
private bool isprerelease
private bool isprivatebuild
private bool isspecialbuild
private int filemajorpart
private int fileminorpart
private int filebuildpart
private int fileprivatepart
private int productmajorpart
private int productminorpart
private int productbuildpart
private int productprivatepart
public string Comments
public string CompanyName
public int FileBuildPart
public string FileDescription
public int FileMajorPart
public int FileMinorPart
public string FileName
public int FilePrivatePart
public string FileVersion
public string InternalName
public bool IsDebug
public bool IsPatched
public bool IsPreRelease
public bool IsPrivateBuild
public bool IsSpecialBuild
public string Language
public string LegalCopyright
public string LegalTrademarks
public string OriginalFilename
public string PrivateBuild
public int ProductBuildPart
public int ProductMajorPart
public int ProductMinorPart
public string ProductName
public int ProductPrivatePart
public string ProductVersion
public string SpecialBuild
public string get_Comments()
public string get_CompanyName()
public int get_FileBuildPart()
public string get_FileDescription()
public int get_FileMajorPart()
public int get_FileMinorPart()
public string get_FileName()
public int get_FilePrivatePart()
public string get_FileVersion()
public string get_InternalName()
public bool get_IsDebug()
public bool get_IsPatched()
public bool get_IsPreRelease()
public bool get_IsPrivateBuild()
public bool get_IsSpecialBuild()
public string get_Language()
public string get_LegalCopyright()
public string get_LegalTrademarks()
public string get_OriginalFilename()
public string get_PrivateBuild()
public int get_ProductBuildPart()
public int get_ProductMajorPart()
public int get_ProductMinorPart()
public string get_ProductName()
public int get_ProductPrivatePart()
public string get_ProductVersion()
public string get_SpecialBuild()
private void GetVersionInfo_icall(Char* fileName, int fileName_length)
private void GetVersionInfo_internal(string fileName)
public FileVersionInfo GetVersionInfo(string fileName)
private void AppendFormat(StringBuilder sb, string format, Object[] args)
public string ToString()
}
internal System.Diagnostics.FilterElement : TypedElement {
public TraceFilter GetRuntimeObject()
internal TraceFilter RefreshRuntimeObject(TraceFilter filter)
}
public System.Diagnostics.ICollectData {
public void CloseData()
public void CollectData(int id, IntPtr valueName, IntPtr data, int totalBytes, IntPtr& res)
}
internal System.Diagnostics.InitState : Enum {
public int value__
public InitState NotInitialized
public InitState Initializing
public InitState Initialized
}
public System.Diagnostics.InstanceData : object {
private string instanceName
private CounterSample sample
public string InstanceName
public long RawValue
public CounterSample Sample
public void .ctor(string instanceName, CounterSample sample)
public string get_InstanceName()
public long get_RawValue()
public CounterSample get_Sample()
}
public System.Diagnostics.InstanceDataCollection : DictionaryBase {
private string counterName
public string CounterName
public InstanceData Item
public ICollection Keys
public ICollection Values
private void CheckNull(object value, string name)
public void .ctor(string counterName)
public string get_CounterName()
public InstanceData get_Item(string instanceName)
public ICollection get_Keys()
public ICollection get_Values()
public bool Contains(string instanceName)
public void CopyTo(InstanceData[] instances, int index)
}
public System.Diagnostics.InstanceDataCollectionCollection : DictionaryBase {
public InstanceDataCollection Item
public ICollection Keys
public ICollection Values
private void CheckNull(object value, string name)
public InstanceDataCollection get_Item(string counterName)
public ICollection get_Keys()
public ICollection get_Values()
public bool Contains(string counterName)
public void CopyTo(InstanceDataCollection[] counters, int index)
}
internal System.Diagnostics.ListenerElement : TypedElement {
private ConfigurationProperty _propFilter
private ConfigurationProperty _propName
private ConfigurationProperty _propOutputOpts
private ConfigurationProperty _propListenerTypeName
private bool _allowReferences
private Hashtable _attributes
internal bool _isAddedByDefault
public Hashtable Attributes
public FilterElement Filter
public string Name
public TraceOptions TraceOutputOptions
public string TypeName
public void .ctor(bool allowReferences)
public Hashtable get_Attributes()
public FilterElement get_Filter()
public string get_Name()
public void set_Name(string value)
public TraceOptions get_TraceOutputOptions()
public void set_TraceOutputOptions(TraceOptions value)
public string get_TypeName()
public void set_TypeName(string value)
public bool Equals(object compareTo)
public int GetHashCode()
public TraceListener GetRuntimeObject()
protected bool OnDeserializeUnrecognizedAttribute(string name, string value)
protected void PreSerialize(XmlWriter writer)
protected bool SerializeElement(XmlWriter writer, bool serializeCollectionKey)
protected void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
internal void ResetProperties()
internal TraceListener RefreshRuntimeObject(TraceListener listener)
}
internal System.Diagnostics.ListenerElementsCollection : ConfigurationElementCollection {
public ListenerElement Item
public ConfigurationElementCollectionType CollectionType
public ListenerElement get_Item(string name)
public ConfigurationElementCollectionType get_CollectionType()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public TraceListenerCollection GetRuntimeObject()
protected void InitializeDefault()
internal void InitializeDefaultInternal()
protected void BaseAdd(ConfigurationElement element)
}
internal System.Diagnostics.LocalFileEventLog : EventLogImpl {
private string DateFormat
private object lockObject
private FileSystemWatcher file_watcher
private int last_notification_index
private bool _notifying
private bool RunningOnUnix
private string EventLogStore
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
public void .ctor(EventLog coreEventLog)
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void DisableNotification()
public void EnableNotification()
public void EndInit()
public bool Exists(string logName, string machineName)
protected string FormatMessage(string source, UInt32 eventID, String[] replacementStrings)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
protected string GetLogDisplayName()
protected String[] GetLogNames(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
private string FindSourceDirectory(string source)
private bool get_RunningOnUnix()
private string FindLogStore(string logName)
private string get_EventLogStore()
private int GetLatestIndex()
private void ModifyAccessPermissions(string path, string permissions)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
private void <EnableNotification>b__14_0(object o, FileSystemEventArgs e)
}
public System.Diagnostics.MonitoringDescriptionAttribute : DescriptionAttribute {
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.Diagnostics.NullEventLog : EventLogImpl {
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
public void .ctor(EventLog coreEventLog)
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void DisableNotification()
public void EnableNotification()
public void EndInit()
public bool Exists(string logName, string machineName)
protected string FormatMessage(string source, UInt32 messageID, String[] replacementStrings)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
protected string GetLogDisplayName()
protected String[] GetLogNames(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
}
internal System.Diagnostics.OrdinalCaseInsensitiveComparer : object {
internal OrdinalCaseInsensitiveComparer Default
public int Compare(object a, object b)
}
public System.Diagnostics.OverflowAction : Enum {
public int value__
public OverflowAction DoNotOverwrite
public OverflowAction OverwriteAsNeeded
public OverflowAction OverwriteOlder
}
internal System.Diagnostics.PerfCounterSection : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propFileMappingSize
public int FileMappingSize
protected ConfigurationPropertyCollection Properties
public int get_FileMappingSize()
protected ConfigurationPropertyCollection get_Properties()
}
public System.Diagnostics.PerformanceCounter : Component {
private string categoryName
private string counterName
private string instanceName
private string machineName
private IntPtr impl
private PerformanceCounterType type
private CounterSample old_sample
private bool readOnly
private bool valid_old
private bool changed
private bool is_custom
private PerformanceCounterInstanceLifetime lifetime
public int DefaultFileMappingSize
public string CategoryName
public string CounterHelp
public string CounterName
public PerformanceCounterType CounterType
public PerformanceCounterInstanceLifetime InstanceLifetime
public string InstanceName
public string MachineName
public long RawValue
public bool ReadOnly
public void .ctor(string categoryName, string counterName)
public void .ctor(string categoryName, string counterName, bool readOnly)
public void .ctor(string categoryName, string counterName, string instanceName)
public void .ctor(string categoryName, string counterName, string instanceName, bool readOnly)
public void .ctor(string categoryName, string counterName, string instanceName, string machineName)
private IntPtr GetImpl_icall(Char* category, int category_length, Char* counter, int counter_length, Char* instance, int instance_length, PerformanceCounterType& ctype, Boolean& custom)
private IntPtr GetImpl(string category, string counter, string instance, PerformanceCounterType& ctype, Boolean& custom)
private bool GetSample(IntPtr impl, bool only_value, CounterSample& sample)
private long UpdateValue(IntPtr impl, bool do_incr, long value)
private void FreeData(IntPtr impl)
private bool IsValidMachine(string machine)
private void UpdateInfo()
public string get_CategoryName()
public void set_CategoryName(string value)
public string get_CounterHelp()
public string get_CounterName()
public void set_CounterName(string value)
public PerformanceCounterType get_CounterType()
public PerformanceCounterInstanceLifetime get_InstanceLifetime()
public void set_InstanceLifetime(PerformanceCounterInstanceLifetime value)
public string get_InstanceName()
public void set_InstanceName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public long get_RawValue()
public void set_RawValue(long value)
public bool get_ReadOnly()
public void set_ReadOnly(bool value)
public void BeginInit()
public void EndInit()
public void Close()
public void CloseSharedResources()
public long Decrement()
protected void Dispose(bool disposing)
public long Increment()
public long IncrementBy(long value)
public CounterSample NextSample()
public float NextValue()
public void RemoveInstance()
}
public System.Diagnostics.PerformanceCounterCategory : object {
private string categoryName
private string machineName
private PerformanceCounterCategoryType type
public string CategoryHelp
public string CategoryName
public string MachineName
public PerformanceCounterCategoryType CategoryType
private bool CategoryDelete_icall(Char* name, int name_length)
private bool CategoryDelete(string name)
private string CategoryHelp_icall(Char* category, int category_length)
private string CategoryHelpInternal(string category)
private bool CounterCategoryExists_icall(Char* counter, int counter_length, Char* category, int category_length)
private bool CounterCategoryExists(string counter, string category)
private bool Create_icall(Char* categoryName, int categoryName_length, Char* categoryHelp, int categoryHelp_length, PerformanceCounterCategoryType categoryType, CounterCreationData[] items)
private bool Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationData[] items)
private bool InstanceExistsInternal_icall(Char* instance, int instance_length, Char* category, int category_length)
private bool InstanceExistsInternal(string instance, string category)
private String[] GetCategoryNames()
private String[] GetCounterNames_icall(Char* category, int category_length)
private String[] GetCounterNames(string category)
private String[] GetInstanceNames_icall(Char* category, int category_length)
private String[] GetInstanceNames(string category)
private void CheckCategory(string categoryName)
public void .ctor(string categoryName)
public void .ctor(string categoryName, string machineName)
private bool IsValidMachine(string machine)
public string get_CategoryHelp()
public string get_CategoryName()
public void set_CategoryName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public PerformanceCounterCategoryType get_CategoryType()
public bool CounterExists(string counterName)
public bool CounterExists(string counterName, string categoryName)
public bool CounterExists(string counterName, string categoryName, string machineName)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, CounterCreationDataCollection counterData)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, string counterName, string counterHelp)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp)
public void Delete(string categoryName)
public bool Exists(string categoryName)
public bool Exists(string categoryName, string machineName)
public PerformanceCounterCategory[] GetCategories()
public PerformanceCounterCategory[] GetCategories(string machineName)
public PerformanceCounter[] GetCounters()
public PerformanceCounter[] GetCounters(string instanceName)
public String[] GetInstanceNames()
public bool InstanceExists(string instanceName)
public bool InstanceExists(string instanceName, string categoryName)
public bool InstanceExists(string instanceName, string categoryName, string machineName)
public InstanceDataCollectionCollection ReadCategory()
}
public System.Diagnostics.PerformanceCounterCategoryType : Enum {
public int value__
public PerformanceCounterCategoryType SingleInstance
public PerformanceCounterCategoryType MultiInstance
public PerformanceCounterCategoryType Unknown
}
public System.Diagnostics.PerformanceCounterInstanceLifetime : Enum {
public int value__
public PerformanceCounterInstanceLifetime Global
public PerformanceCounterInstanceLifetime Process
}
public System.Diagnostics.PerformanceCounterManager : object {
private void System.Diagnostics.ICollectData.CloseData()
private void System.Diagnostics.ICollectData.CollectData(int callIdx, IntPtr valueNamePtr, IntPtr dataPtr, int totalBytes, IntPtr& res)
}
public System.Diagnostics.PerformanceCounterPermission : ResourcePermissionBase {
private PerformanceCounterPermissionEntryCollection innerCollection
public PerformanceCounterPermissionEntryCollection PermissionEntries
public void .ctor(PerformanceCounterPermissionEntry[] permissionAccessEntries)
public void .ctor(PermissionState state)
public void .ctor(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName)
public PerformanceCounterPermissionEntryCollection get_PermissionEntries()
private void SetUp()
internal ResourcePermissionBaseEntry[] GetEntries()
internal void ClearEntries()
internal void Add(object obj)
internal void Remove(object obj)
}
public System.Diagnostics.PerformanceCounterPermissionAccess : Enum {
public int value__
public PerformanceCounterPermissionAccess None
public PerformanceCounterPermissionAccess Browse
public PerformanceCounterPermissionAccess Read
public PerformanceCounterPermissionAccess Write
public PerformanceCounterPermissionAccess Instrument
public PerformanceCounterPermissionAccess Administer
}
public System.Diagnostics.PerformanceCounterPermissionAttribute : CodeAccessSecurityAttribute {
private string categoryName
private string machineName
private PerformanceCounterPermissionAccess permissionAccess
public string CategoryName
public string MachineName
public PerformanceCounterPermissionAccess PermissionAccess
public void .ctor(SecurityAction action)
public string get_CategoryName()
public void set_CategoryName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public PerformanceCounterPermissionAccess get_PermissionAccess()
public void set_PermissionAccess(PerformanceCounterPermissionAccess value)
public IPermission CreatePermission()
}
public System.Diagnostics.PerformanceCounterPermissionEntry : object {
private PerformanceCounterPermissionAccess All
private PerformanceCounterPermissionAccess permissionAccess
private string machineName
private string categoryName
public string CategoryName
public string MachineName
public PerformanceCounterPermissionAccess PermissionAccess
public void .ctor(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName)
public string get_CategoryName()
public string get_MachineName()
public PerformanceCounterPermissionAccess get_PermissionAccess()
internal ResourcePermissionBaseEntry CreateResourcePermissionBaseEntry()
}
public System.Diagnostics.PerformanceCounterPermissionEntryCollection : CollectionBase {
private PerformanceCounterPermission owner
public PerformanceCounterPermissionEntry Item
internal void .ctor(PerformanceCounterPermission owner)
internal void .ctor(ResourcePermissionBaseEntry[] entries)
public PerformanceCounterPermissionEntry get_Item(int index)
public void set_Item(int index, PerformanceCounterPermissionEntry value)
public int Add(PerformanceCounterPermissionEntry value)
public void AddRange(PerformanceCounterPermissionEntry[] value)
public void AddRange(PerformanceCounterPermissionEntryCollection value)
public bool Contains(PerformanceCounterPermissionEntry value)
public void CopyTo(PerformanceCounterPermissionEntry[] array, int index)
public int IndexOf(PerformanceCounterPermissionEntry value)
public void Insert(int index, PerformanceCounterPermissionEntry value)
protected void OnClear()
protected void OnInsert(int index, object value)
protected void OnRemove(int index, object value)
protected void OnSet(int index, object oldValue, object newValue)
public void Remove(PerformanceCounterPermissionEntry value)
}
public System.Diagnostics.PerformanceCounterType : Enum {
public int value__
public PerformanceCounterType NumberOfItemsHEX32
public PerformanceCounterType NumberOfItemsHEX64
public PerformanceCounterType NumberOfItems32
public PerformanceCounterType NumberOfItems64
public PerformanceCounterType CounterDelta32
public PerformanceCounterType CounterDelta64
public PerformanceCounterType SampleCounter
public PerformanceCounterType CountPerTimeInterval32
public PerformanceCounterType CountPerTimeInterval64
public PerformanceCounterType RateOfCountsPerSecond32
public PerformanceCounterType RateOfCountsPerSecond64
public PerformanceCounterType RawFraction
public PerformanceCounterType CounterTimer
public PerformanceCounterType Timer100Ns
public PerformanceCounterType SampleFraction
public PerformanceCounterType CounterTimerInverse
public PerformanceCounterType Timer100NsInverse
public PerformanceCounterType CounterMultiTimer
public PerformanceCounterType CounterMultiTimer100Ns
public PerformanceCounterType CounterMultiTimerInverse
public PerformanceCounterType CounterMultiTimer100NsInverse
public PerformanceCounterType AverageTimer32
public PerformanceCounterType ElapsedTime
public PerformanceCounterType AverageCount64
public PerformanceCounterType SampleBase
public PerformanceCounterType AverageBase
public PerformanceCounterType RawBase
public PerformanceCounterType CounterMultiBase
}
public System.Diagnostics.Process : Component {
private bool haveProcessId
private int processId
private bool haveProcessHandle
private SafeProcessHandle m_processHandle
private bool isRemoteMachine
private string machineName
private int m_processAccess
private ProcessThreadCollection threads
private ProcessModuleCollection modules
private bool haveWorkingSetLimits
private IntPtr minWorkingSet
private IntPtr maxWorkingSet
private bool havePriorityClass
private ProcessPriorityClass priorityClass
private ProcessStartInfo startInfo
private bool watchForExit
private bool watchingForExit
private EventHandler onExited
private bool exited
private int exitCode
private bool signaled
private DateTime exitTime
private bool haveExitTime
private bool raisedOnExited
private RegisteredWaitHandle registeredWaitHandle
private WaitHandle waitHandle
private ISynchronizeInvoke synchronizingObject
private StreamReader standardOutput
private StreamWriter standardInput
private StreamReader standardError
private OperatingSystem operatingSystem
private bool disposed
private StreamReadMode outputStreamReadMode
private StreamReadMode errorStreamReadMode
private StreamReadMode inputStreamReadMode
private DataReceivedEventHandler OutputDataReceived
private DataReceivedEventHandler ErrorDataReceived
internal AsyncStreamReader output
internal AsyncStreamReader error
internal bool pendingOutputRead
internal bool pendingErrorRead
internal TraceSwitch processTracing
private string process_name
private ProcessModule current_main_module
private bool Associated
public int ExitCode
public bool HasExited
public DateTime ExitTime
public IntPtr Handle
public SafeProcessHandle SafeHandle
public int Id
public string MachineName
public IntPtr MaxWorkingSet
public IntPtr MinWorkingSet
private OperatingSystem OperatingSystem
public ProcessPriorityClass PriorityClass
public TimeSpan PrivilegedProcessorTime
public ProcessStartInfo StartInfo
public DateTime StartTime
public ISynchronizeInvoke SynchronizingObject
public TimeSpan TotalProcessorTime
public TimeSpan UserProcessorTime
public bool EnableRaisingEvents
public StreamWriter StandardInput
public StreamReader StandardOutput
public StreamReader StandardError
public int BasePriority
public int HandleCount
public ProcessModule MainModule
public IntPtr MainWindowHandle
public string MainWindowTitle
public ProcessModuleCollection Modules
public int NonpagedSystemMemorySize
public int PagedMemorySize
public int PagedSystemMemorySize
public int PeakPagedMemorySize
public int PeakVirtualMemorySize
public int PeakWorkingSet
public long NonpagedSystemMemorySize64
public long PagedMemorySize64
public long PagedSystemMemorySize64
public long PeakPagedMemorySize64
public long PeakVirtualMemorySize64
public long PeakWorkingSet64
public bool PriorityBoostEnabled
public int PrivateMemorySize
public int SessionId
public string ProcessName
public IntPtr ProcessorAffinity
public bool Responding
public ProcessThreadCollection Threads
public int VirtualMemorySize
public int WorkingSet
public long PrivateMemorySize64
public long VirtualMemorySize64
public long WorkingSet64
private bool IsWindows
public void add_OutputDataReceived(DataReceivedEventHandler value)
public void remove_OutputDataReceived(DataReceivedEventHandler value)
public void add_ErrorDataReceived(DataReceivedEventHandler value)
public void remove_ErrorDataReceived(DataReceivedEventHandler value)
private void .ctor(string machineName, bool isRemoteMachine, int processId, ProcessInfo processInfo)
private bool get_Associated()
public int get_ExitCode()
public bool get_HasExited()
private ProcessThreadTimes GetProcessTimes()
public DateTime get_ExitTime()
public IntPtr get_Handle()
public SafeProcessHandle get_SafeHandle()
public int get_Id()
public string get_MachineName()
public IntPtr get_MaxWorkingSet()
public void set_MaxWorkingSet(IntPtr value)
public IntPtr get_MinWorkingSet()
public void set_MinWorkingSet(IntPtr value)
private OperatingSystem get_OperatingSystem()
public ProcessPriorityClass get_PriorityClass()
public void set_PriorityClass(ProcessPriorityClass value)
public TimeSpan get_PrivilegedProcessorTime()
public ProcessStartInfo get_StartInfo()
public void set_StartInfo(ProcessStartInfo value)
public DateTime get_StartTime()
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public TimeSpan get_TotalProcessorTime()
public TimeSpan get_UserProcessorTime()
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
public StreamWriter get_StandardInput()
public StreamReader get_StandardOutput()
public StreamReader get_StandardError()
public void add_Exited(EventHandler value)
public void remove_Exited(EventHandler value)
private void ReleaseProcessHandle(SafeProcessHandle handle)
private void CompletionCallback(object context, bool wasSignaled)
protected void Dispose(bool disposing)
public void Close()
private void EnsureState(State state)
private void EnsureWatchingForExit()
private void EnsureWorkingSetLimits()
public void EnterDebugMode()
public void LeaveDebugMode()
public Process GetProcessById(int processId)
public Process[] GetProcessesByName(string processName)
public Process[] GetProcesses()
public Process GetCurrentProcess()
protected void OnExited()
private SafeProcessHandle GetProcessHandle(int access, bool throwIfExited)
private SafeProcessHandle GetProcessHandle(int access)
private SafeProcessHandle OpenProcessHandle()
private SafeProcessHandle OpenProcessHandle(int access)
public void Refresh()
private void SetProcessHandle(SafeProcessHandle processHandle)
private void SetProcessId(int processId)
private void SetWorkingSetLimits(object newMin, object newMax)
public bool Start()
public Process Start(string fileName, string userName, SecureString password, string domain)
public Process Start(string fileName, string arguments, string userName, SecureString password, string domain)
public Process Start(string fileName)
public Process Start(string fileName, string arguments)
public Process Start(ProcessStartInfo startInfo)
public void Kill()
private void StopWatchingForExit()
public string ToString()
public bool WaitForExit(int milliseconds)
public void WaitForExit()
public bool WaitForInputIdle(int milliseconds)
public bool WaitForInputIdle()
public void BeginOutputReadLine()
public void BeginErrorReadLine()
public void CancelOutputRead()
public void CancelErrorRead()
internal void OutputReadNotifyUser(string data)
internal void ErrorReadNotifyUser(string data)
private void .ctor(SafeProcessHandle handle, int id)
public int get_BasePriority()
public int get_HandleCount()
public ProcessModule get_MainModule()
private IntPtr MainWindowHandle_icall(int pid)
public IntPtr get_MainWindowHandle()
public string get_MainWindowTitle()
private void AppendArguments(StringBuilder stringBuilder, Collection`1<string> argumentList)
private ProcessModule[] GetModules_icall(IntPtr handle)
private ProcessModule[] GetModules_internal(SafeProcessHandle handle)
public ProcessModuleCollection get_Modules()
private long GetProcessData(int pid, int data_type, Int32& error)
public int get_NonpagedSystemMemorySize()
public int get_PagedMemorySize()
public int get_PagedSystemMemorySize()
public int get_PeakPagedMemorySize()
public int get_PeakVirtualMemorySize()
public int get_PeakWorkingSet()
public long get_NonpagedSystemMemorySize64()
public long get_PagedMemorySize64()
public long get_PagedSystemMemorySize64()
public long get_PeakPagedMemorySize64()
public long get_PeakVirtualMemorySize64()
public long get_PeakWorkingSet64()
public bool get_PriorityBoostEnabled()
public void set_PriorityBoostEnabled(bool value)
public int get_PrivateMemorySize()
public int get_SessionId()
private string ProcessName_icall(IntPtr handle)
private string ProcessName_internal(SafeProcessHandle handle)
public string get_ProcessName()
public IntPtr get_ProcessorAffinity()
public void set_ProcessorAffinity(IntPtr value)
public bool get_Responding()
public ProcessThreadCollection get_Threads()
public int get_VirtualMemorySize()
public int get_WorkingSet()
public long get_PrivateMemorySize64()
public long get_VirtualMemorySize64()
public long get_WorkingSet64()
public bool CloseMainWindow()
private IntPtr GetProcess_internal(int pid)
public Process GetProcessById(int processId, string machineName)
public Process[] GetProcessesByName(string processName, string machineName)
private Int32[] GetProcesses_internal()
public Process[] GetProcesses(string machineName)
private bool IsLocalMachine(string machineName)
private bool ShellExecuteEx_internal(ProcessStartInfo startInfo, ProcInfo& procInfo)
private bool CreateProcess_internal(ProcessStartInfo startInfo, IntPtr stdin, IntPtr stdout, IntPtr stderr, ProcInfo& procInfo)
private bool StartWithShellExecuteEx(ProcessStartInfo startInfo)
private void CreatePipe(IntPtr& read, IntPtr& write, bool writeDirection)
private bool get_IsWindows()
private bool StartWithCreateProcess(ProcessStartInfo startInfo)
private void FillUserInfo(ProcessStartInfo startInfo, ProcInfo& procInfo)
private void RaiseOnExited()
}
public System.Diagnostics.ProcessModule : Component {
private IntPtr baseaddr
private IntPtr entryaddr
private string filename
private FileVersionInfo version_info
private int memory_size
private string modulename
public IntPtr BaseAddress
public IntPtr EntryPointAddress
public string FileName
public FileVersionInfo FileVersionInfo
public int ModuleMemorySize
public string ModuleName
internal void .ctor(IntPtr baseaddr, IntPtr entryaddr, string filename, FileVersionInfo version_info, int memory_size, string modulename)
public IntPtr get_BaseAddress()
public IntPtr get_EntryPointAddress()
public string get_FileName()
public FileVersionInfo get_FileVersionInfo()
public int get_ModuleMemorySize()
public string get_ModuleName()
public string ToString()
}
public System.Diagnostics.ProcessModuleCollection : ReadOnlyCollectionBase {
public ProcessModule Item
public void .ctor(ProcessModule[] processModules)
public ProcessModule get_Item(int index)
public int IndexOf(ProcessModule module)
public bool Contains(ProcessModule module)
public void CopyTo(ProcessModule[] array, int index)
}
public System.Diagnostics.ProcessPriorityClass : Enum {
public int value__
public ProcessPriorityClass AboveNormal
public ProcessPriorityClass BelowNormal
public ProcessPriorityClass High
public ProcessPriorityClass Idle
public ProcessPriorityClass Normal
public ProcessPriorityClass RealTime
}
public System.Diagnostics.ProcessStartInfo : object {
private string fileName
private string arguments
private string directory
private string verb
private ProcessWindowStyle windowStyle
private bool errorDialog
private IntPtr errorDialogParentHandle
private bool useShellExecute
private string userName
private string domain
private SecureString password
private string passwordInClearText
private bool loadUserProfile
private bool redirectStandardInput
private bool redirectStandardOutput
private bool redirectStandardError
private Encoding standardOutputEncoding
private Encoding standardErrorEncoding
private bool createNoWindow
private WeakReference weakParentProcess
internal StringDictionary environmentVariables
private String[] empty
private Collection`1<string> _argumentList
private IDictionary`2<string, string> environment
private Encoding <StandardInputEncoding>k__BackingField
public Collection`1<string> ArgumentList
public string Verb
public string Arguments
public bool CreateNoWindow
public StringDictionary EnvironmentVariables
public IDictionary`2<string, string> Environment
public bool RedirectStandardInput
public bool RedirectStandardOutput
public bool RedirectStandardError
public Encoding StandardErrorEncoding
public Encoding StandardOutputEncoding
public bool UseShellExecute
public string UserName
public SecureString Password
public string PasswordInClearText
public string Domain
public bool LoadUserProfile
public string FileName
public string WorkingDirectory
public bool ErrorDialog
public IntPtr ErrorDialogParentHandle
public ProcessWindowStyle WindowStyle
internal bool HaveEnvVars
public Encoding StandardInputEncoding
public String[] Verbs
internal void .ctor(Process parent)
public void .ctor(string fileName)
public void .ctor(string fileName, string arguments)
public Collection`1<string> get_ArgumentList()
public string get_Verb()
public void set_Verb(string value)
public string get_Arguments()
public void set_Arguments(string value)
public bool get_CreateNoWindow()
public void set_CreateNoWindow(bool value)
public StringDictionary get_EnvironmentVariables()
public IDictionary`2<string, string> get_Environment()
public bool get_RedirectStandardInput()
public void set_RedirectStandardInput(bool value)
public bool get_RedirectStandardOutput()
public void set_RedirectStandardOutput(bool value)
public bool get_RedirectStandardError()
public void set_RedirectStandardError(bool value)
public Encoding get_StandardErrorEncoding()
public void set_StandardErrorEncoding(Encoding value)
public Encoding get_StandardOutputEncoding()
public void set_StandardOutputEncoding(Encoding value)
public bool get_UseShellExecute()
public void set_UseShellExecute(bool value)
public string get_UserName()
public void set_UserName(string value)
public SecureString get_Password()
public void set_Password(SecureString value)
public string get_PasswordInClearText()
public void set_PasswordInClearText(string value)
public string get_Domain()
public void set_Domain(string value)
public bool get_LoadUserProfile()
public void set_LoadUserProfile(bool value)
public string get_FileName()
public void set_FileName(string value)
public string get_WorkingDirectory()
public void set_WorkingDirectory(string value)
public bool get_ErrorDialog()
public void set_ErrorDialog(bool value)
public IntPtr get_ErrorDialogParentHandle()
public void set_ErrorDialogParentHandle(IntPtr value)
public ProcessWindowStyle get_WindowStyle()
public void set_WindowStyle(ProcessWindowStyle value)
internal bool get_HaveEnvVars()
public Encoding get_StandardInputEncoding()
public void set_StandardInputEncoding(Encoding value)
public String[] get_Verbs()
}
public System.Diagnostics.ProcessThread : Component {
public int BasePriority
public int CurrentPriority
public int Id
public int IdealProcessor
public bool PriorityBoostEnabled
public ThreadPriorityLevel PriorityLevel
public TimeSpan PrivilegedProcessorTime
public IntPtr ProcessorAffinity
public IntPtr StartAddress
public DateTime StartTime
public ThreadState ThreadState
public TimeSpan TotalProcessorTime
public TimeSpan UserProcessorTime
public ThreadWaitReason WaitReason
public int get_BasePriority()
public int get_CurrentPriority()
public int get_Id()
public void set_IdealProcessor(int value)
public bool get_PriorityBoostEnabled()
public void set_PriorityBoostEnabled(bool value)
public ThreadPriorityLevel get_PriorityLevel()
public void set_PriorityLevel(ThreadPriorityLevel value)
public TimeSpan get_PrivilegedProcessorTime()
public void set_ProcessorAffinity(IntPtr value)
public IntPtr get_StartAddress()
public DateTime get_StartTime()
public ThreadState get_ThreadState()
public TimeSpan get_TotalProcessorTime()
public TimeSpan get_UserProcessorTime()
public ThreadWaitReason get_WaitReason()
public void ResetIdealProcessor()
}
public System.Diagnostics.ProcessThreadCollection : ReadOnlyCollectionBase {
public ProcessThread Item
public void .ctor(ProcessThread[] processThreads)
public ProcessThread get_Item(int index)
public int Add(ProcessThread thread)
public void Insert(int index, ProcessThread thread)
public int IndexOf(ProcessThread thread)
public bool Contains(ProcessThread thread)
public void Remove(ProcessThread thread)
public void CopyTo(ProcessThread[] array, int index)
}
internal System.Diagnostics.ProcessThreadTimes : object {
internal long create
internal long exit
internal long kernel
internal long user
public DateTime StartTime
public DateTime ExitTime
public TimeSpan PrivilegedProcessorTime
public TimeSpan UserProcessorTime
public TimeSpan TotalProcessorTime
public DateTime get_StartTime()
public DateTime get_ExitTime()
public TimeSpan get_PrivilegedProcessorTime()
public TimeSpan get_UserProcessorTime()
public TimeSpan get_TotalProcessorTime()
}
internal System.Diagnostics.ProcessWaitHandle : WaitHandle {
internal void .ctor(SafeProcessHandle processHandle)
}
public System.Diagnostics.ProcessWindowStyle : Enum {
public int value__
public ProcessWindowStyle Hidden
public ProcessWindowStyle Maximized
public ProcessWindowStyle Minimized
public ProcessWindowStyle Normal
}
internal System.Diagnostics.SharedListenerElementsCollection : ListenerElementsCollection {
public ConfigurationElementCollectionType CollectionType
protected string ElementName
public ConfigurationElementCollectionType get_CollectionType()
protected ConfigurationElement CreateNewElement()
protected string get_ElementName()
}
internal System.Diagnostics.SourceElement : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propName
private ConfigurationProperty _propSwitchName
private ConfigurationProperty _propSwitchValue
private ConfigurationProperty _propSwitchType
private ConfigurationProperty _propListeners
private Hashtable _attributes
public Hashtable Attributes
public ListenerElementsCollection Listeners
public string Name
protected ConfigurationPropertyCollection Properties
public string SwitchName
public string SwitchValue
public string SwitchType
public Hashtable get_Attributes()
public ListenerElementsCollection get_Listeners()
public string get_Name()
protected ConfigurationPropertyCollection get_Properties()
public string get_SwitchName()
public string get_SwitchValue()
public string get_SwitchType()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
protected bool OnDeserializeUnrecognizedAttribute(string name, string value)
protected void PreSerialize(XmlWriter writer)
protected bool SerializeElement(XmlWriter writer, bool serializeCollectionKey)
protected void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
internal void ResetProperties()
}
internal System.Diagnostics.SourceElementsCollection : ConfigurationElementCollection {
public SourceElement Item
protected string ElementName
public ConfigurationElementCollectionType CollectionType
public SourceElement get_Item(string name)
protected string get_ElementName()
public ConfigurationElementCollectionType get_CollectionType()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
}
public System.Diagnostics.SourceFilter : TraceFilter {
private string src
public string Source
public void .ctor(string source)
public bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data)
public string get_Source()
public void set_Source(string value)
}
public System.Diagnostics.SourceLevels : Enum {
public int value__
public SourceLevels Off
public SourceLevels Critical
public SourceLevels Error
public SourceLevels Warning
public SourceLevels Information
public SourceLevels Verbose
public SourceLevels ActivityTracing
public SourceLevels All
}
public System.Diagnostics.SourceSwitch : Switch {
public SourceLevels Level
public void .ctor(string name)
public void .ctor(string displayName, string defaultSwitchValue)
public SourceLevels get_Level()
public void set_Level(SourceLevels value)
public bool ShouldTrace(TraceEventType eventType)
protected void OnValueChanged()
}
public System.Diagnostics.StackFrameExtensions : object {
public bool HasNativeImage(StackFrame stackFrame)
public bool HasMethod(StackFrame stackFrame)
public bool HasILOffset(StackFrame stackFrame)
public bool HasSource(StackFrame stackFrame)
public IntPtr GetNativeIP(StackFrame stackFrame)
public IntPtr GetNativeImageBase(StackFrame stackFrame)
}
public System.Diagnostics.Stopwatch : object {
public long Frequency
public bool IsHighResolution
private long elapsed
private long started
private bool is_running
public TimeSpan Elapsed
public long ElapsedMilliseconds
public long ElapsedTicks
public bool IsRunning
public long GetTimestamp()
public Stopwatch StartNew()
public TimeSpan get_Elapsed()
public long get_ElapsedMilliseconds()
public long get_ElapsedTicks()
public bool get_IsRunning()
public void Reset()
public void Start()
public void Stop()
public void Restart()
}
public System.Diagnostics.Switch : object {
private SwitchElementsCollection switchSettings
private string description
private string displayName
private int switchSetting
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) initialized
private bool initializing
private String modreq(System.Runtime.CompilerServices.IsVolatile) switchValueString
private StringDictionary attributes
private string defaultValue
private object m_intializedLock
private List`1<WeakReference> switches
private int s_LastCollectionCount
private object IntializedLock
public StringDictionary Attributes
public string DisplayName
public string Description
protected int SwitchSetting
protected string Value
private object get_IntializedLock()
protected void .ctor(string displayName, string description)
protected void .ctor(string displayName, string description, string defaultSwitchValue)
private void _pruneCachedSwitches()
public StringDictionary get_Attributes()
public string get_DisplayName()
public string get_Description()
protected int get_SwitchSetting()
protected void set_SwitchSetting(int value)
protected string get_Value()
protected void set_Value(string value)
private void Initialize()
private bool InitializeWithStatus()
private bool InitializeConfigSettings()
protected internal String[] GetSupportedAttributes()
protected void OnSwitchSettingChanged()
protected void OnValueChanged()
internal void RefreshAll()
internal void Refresh()
}
public System.Diagnostics.SwitchAttribute : Attribute {
private Type type
private string name
private string description
public string SwitchName
public Type SwitchType
public string SwitchDescription
public void .ctor(string switchName, Type switchType)
public string get_SwitchName()
public void set_SwitchName(string value)
public Type get_SwitchType()
public void set_SwitchType(Type value)
public string get_SwitchDescription()
public void set_SwitchDescription(string value)
public SwitchAttribute[] GetAll(Assembly assembly)
private void GetAllRecursive(Type type, ArrayList switchAttribs)
private void GetAllRecursive(MemberInfo member, ArrayList switchAttribs)
}
internal System.Diagnostics.SwitchElement : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propName
private ConfigurationProperty _propValue
private Hashtable _attributes
public Hashtable Attributes
public string Name
protected ConfigurationPropertyCollection Properties
public string Value
public Hashtable get_Attributes()
public string get_Name()
protected ConfigurationPropertyCollection get_Properties()
public string get_Value()
protected bool OnDeserializeUnrecognizedAttribute(string name, string value)
protected void PreSerialize(XmlWriter writer)
protected bool SerializeElement(XmlWriter writer, bool serializeCollectionKey)
protected void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
internal void ResetProperties()
}
internal System.Diagnostics.SwitchElementsCollection : ConfigurationElementCollection {
public SwitchElement Item
public ConfigurationElementCollectionType CollectionType
public SwitchElement get_Item(string name)
public ConfigurationElementCollectionType get_CollectionType()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
}
public System.Diagnostics.SwitchLevelAttribute : Attribute {
private Type type
public Type SwitchLevelType
public void .ctor(Type switchLevelType)
public Type get_SwitchLevelType()
public void set_SwitchLevelType(Type value)
}
internal System.Diagnostics.SystemDiagnosticsSection : ConfigurationSection {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propAssert
private ConfigurationProperty _propPerfCounters
private ConfigurationProperty _propSources
private ConfigurationProperty _propSharedListeners
private ConfigurationProperty _propSwitches
private ConfigurationProperty _propTrace
public AssertSection Assert
public PerfCounterSection PerfCounters
protected ConfigurationPropertyCollection Properties
public SourceElementsCollection Sources
public ListenerElementsCollection SharedListeners
public SwitchElementsCollection Switches
public TraceSection Trace
public AssertSection get_Assert()
public PerfCounterSection get_PerfCounters()
protected ConfigurationPropertyCollection get_Properties()
public SourceElementsCollection get_Sources()
public ListenerElementsCollection get_SharedListeners()
public SwitchElementsCollection get_Switches()
public TraceSection get_Trace()
protected void InitializeDefault()
}
public System.Diagnostics.TextWriterTraceListener : TraceListener {
internal TextWriter writer
private string fileName
public TextWriter Writer
public void .ctor(Stream stream)
public void .ctor(Stream stream, string name)
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string name)
public void .ctor(string fileName)
public void .ctor(string fileName, string name)
public TextWriter get_Writer()
public void set_Writer(TextWriter value)
public void Close()
protected void Dispose(bool disposing)
public void Flush()
public void Write(string message)
public void WriteLine(string message)
private Encoding GetEncodingWithFallback(Encoding encoding)
internal bool EnsureWriter()
}
public System.Diagnostics.ThreadPriorityLevel : Enum {
public int value__
public ThreadPriorityLevel AboveNormal
public ThreadPriorityLevel BelowNormal
public ThreadPriorityLevel Highest
public ThreadPriorityLevel Idle
public ThreadPriorityLevel Lowest
public ThreadPriorityLevel Normal
public ThreadPriorityLevel TimeCritical
}
public System.Diagnostics.ThreadState : Enum {
public int value__
public ThreadState Initialized
public ThreadState Ready
public ThreadState Running
public ThreadState Standby
public ThreadState Terminated
public ThreadState Transition
public ThreadState Unknown
public ThreadState Wait
}
public System.Diagnostics.ThreadWaitReason : Enum {
public int value__
public ThreadWaitReason EventPairHigh
public ThreadWaitReason EventPairLow
public ThreadWaitReason ExecutionDelay
public ThreadWaitReason Executive
public ThreadWaitReason FreePage
public ThreadWaitReason LpcReceive
public ThreadWaitReason LpcReply
public ThreadWaitReason PageIn
public ThreadWaitReason PageOut
public ThreadWaitReason Suspended
public ThreadWaitReason SystemAllocation
public ThreadWaitReason Unknown
public ThreadWaitReason UserRequest
public ThreadWaitReason VirtualMemory
}
public System.Diagnostics.Trace : object {
private CorrelationManager modreq(System.Runtime.CompilerServices.IsVolatile) correlationManager
public TraceListenerCollection Listeners
public bool AutoFlush
public bool UseGlobalLock
public CorrelationManager CorrelationManager
public int IndentLevel
public int IndentSize
public TraceListenerCollection get_Listeners()
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public bool get_UseGlobalLock()
public void set_UseGlobalLock(bool value)
public CorrelationManager get_CorrelationManager()
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public void Flush()
public void Close()
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Fail(string message)
public void Fail(string message, string detailMessage)
public void Refresh()
public void TraceInformation(string message)
public void TraceInformation(string format, Object[] args)
public void TraceWarning(string message)
public void TraceWarning(string format, Object[] args)
public void TraceError(string message)
public void TraceError(string format, Object[] args)
public void Write(string message)
public void Write(object value)
public void Write(string message, string category)
public void Write(object value, string category)
public void WriteLine(string message)
public void WriteLine(object value)
public void WriteLine(string message, string category)
public void WriteLine(object value, string category)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message, string category)
public void WriteIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, string message, string category)
public void WriteLineIf(bool condition, object value, string category)
public void Indent()
public void Unindent()
}
public System.Diagnostics.TraceEventCache : object {
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) processId
private String modreq(System.Runtime.CompilerServices.IsVolatile) processName
private long timeStamp
private DateTime dateTime
private string stackTrace
internal Guid ActivityId
public string Callstack
public Stack LogicalOperationStack
public DateTime DateTime
public int ProcessId
public string ThreadId
public long Timestamp
internal Guid get_ActivityId()
public string get_Callstack()
public Stack get_LogicalOperationStack()
public DateTime get_DateTime()
public int get_ProcessId()
public string get_ThreadId()
public long get_Timestamp()
private void InitProcessInfo()
internal int GetProcessId()
internal string GetProcessName()
internal int GetThreadId()
}
public System.Diagnostics.TraceEventType : Enum {
public int value__
public TraceEventType Critical
public TraceEventType Error
public TraceEventType Warning
public TraceEventType Information
public TraceEventType Verbose
public TraceEventType Start
public TraceEventType Stop
public TraceEventType Suspend
public TraceEventType Resume
public TraceEventType Transfer
}
public System.Diagnostics.TraceFilter : object {
internal string initializeData
public bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data)
internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage)
internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args)
internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1)
}
internal System.Diagnostics.TraceImplSettings : object {
public string Key
public bool AutoFlush
public int IndentSize
public TraceListenerCollection Listeners
}
internal System.Diagnostics.TraceInternal : object {
private String modreq(System.Runtime.CompilerServices.IsVolatile) appName
private TraceListenerCollection modreq(System.Runtime.CompilerServices.IsVolatile) listeners
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) autoFlush
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) useGlobalLock
private int indentLevel
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) indentSize
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) settingsInitialized
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) defaultInitialized
internal object critSec
public TraceListenerCollection Listeners
internal string AppName
public bool AutoFlush
public bool UseGlobalLock
public int IndentLevel
public int IndentSize
public TraceListenerCollection get_Listeners()
internal string get_AppName()
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public bool get_UseGlobalLock()
public void set_UseGlobalLock(bool value)
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
private void SetIndentSize(int value)
public void Indent()
public void Unindent()
public void Flush()
public void Close()
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Fail(string message)
public void Fail(string message, string detailMessage)
private void InitializeSettings()
internal void Refresh()
public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args)
public void Write(string message)
public void Write(object value)
public void Write(string message, string category)
public void Write(object value, string category)
public void WriteLine(string message)
public void WriteLine(object value)
public void WriteLine(string message, string category)
public void WriteLine(object value, string category)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message, string category)
public void WriteIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, string message, string category)
public void WriteLineIf(bool condition, object value, string category)
}
public System.Diagnostics.TraceLevel : Enum {
public int value__
public TraceLevel Off
public TraceLevel Error
public TraceLevel Warning
public TraceLevel Info
public TraceLevel Verbose
}
public System.Diagnostics.TraceListener : MarshalByRefObject {
private int indentLevel
private int indentSize
private TraceOptions traceOptions
private bool needIndent
private string listenerName
private TraceFilter filter
private StringDictionary attributes
internal string initializeData
public StringDictionary Attributes
public string Name
public bool IsThreadSafe
public int IndentLevel
public int IndentSize
public TraceFilter Filter
protected bool NeedIndent
public TraceOptions TraceOutputOptions
protected void .ctor(string name)
public StringDictionary get_Attributes()
public string get_Name()
public void set_Name(string value)
public bool get_IsThreadSafe()
public void Dispose()
protected void Dispose(bool disposing)
public void Close()
public void Flush()
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public TraceFilter get_Filter()
public void set_Filter(TraceFilter value)
protected bool get_NeedIndent()
protected void set_NeedIndent(bool value)
public TraceOptions get_TraceOutputOptions()
public void set_TraceOutputOptions(TraceOptions value)
internal void SetAttributes(Hashtable attribs)
public void Fail(string message)
public void Fail(string message, string detailMessage)
protected internal String[] GetSupportedAttributes()
public void Write(string message)
public void Write(object o)
public void Write(string message, string category)
public void Write(object o, string category)
protected void WriteIndent()
public void WriteLine(string message)
public void WriteLine(object o)
public void WriteLine(string message, string category)
public void WriteLine(object o, string category)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
public void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId)
private void WriteHeader(string source, TraceEventType eventType, int id)
private void WriteFooter(TraceEventCache eventCache)
internal bool IsEnabled(TraceOptions opts)
}
public System.Diagnostics.TraceListenerCollection : object {
private ArrayList list
public TraceListener Item
public TraceListener Item
public int Count
private object System.Collections.IList.Item
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
public TraceListener get_Item(int i)
public void set_Item(int i, TraceListener value)
public TraceListener get_Item(string name)
public int get_Count()
public int Add(TraceListener listener)
public void AddRange(TraceListener[] value)
public void AddRange(TraceListenerCollection value)
public void Clear()
public bool Contains(TraceListener listener)
public void CopyTo(TraceListener[] listeners, int index)
public IEnumerator GetEnumerator()
internal void InitializeListener(TraceListener listener)
public int IndexOf(TraceListener listener)
public void Insert(int index, TraceListener listener)
public void Remove(TraceListener listener)
public void Remove(string name)
public void RemoveAt(int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
private void System.Collections.ICollection.CopyTo(Array array, int index)
}
public System.Diagnostics.TraceOptions : Enum {
public int value__
public TraceOptions None
public TraceOptions LogicalOperationStack
public TraceOptions DateTime
public TraceOptions Timestamp
public TraceOptions ProcessId
public TraceOptions ThreadId
public TraceOptions Callstack
}
internal System.Diagnostics.TraceSection : ConfigurationElement {
private ConfigurationPropertyCollection _properties
private ConfigurationProperty _propListeners
private ConfigurationProperty _propAutoFlush
private ConfigurationProperty _propIndentSize
private ConfigurationProperty _propUseGlobalLock
public bool AutoFlush
public int IndentSize
public ListenerElementsCollection Listeners
public bool UseGlobalLock
protected ConfigurationPropertyCollection Properties
public bool get_AutoFlush()
public int get_IndentSize()
public ListenerElementsCollection get_Listeners()
public bool get_UseGlobalLock()
protected ConfigurationPropertyCollection get_Properties()
}
public System.Diagnostics.TraceSource : object {
private List`1<WeakReference> tracesources
private int s_LastCollectionCount
private SourceSwitch modreq(System.Runtime.CompilerServices.IsVolatile) internalSwitch
private TraceListenerCollection modreq(System.Runtime.CompilerServices.IsVolatile) listeners
private StringDictionary attributes
private SourceLevels switchLevel
private String modreq(System.Runtime.CompilerServices.IsVolatile) sourceName
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initCalled
public StringDictionary Attributes
public string Name
public TraceListenerCollection Listeners
public SourceSwitch Switch
public void .ctor(string name)
public void .ctor(string name, SourceLevels defaultLevel)
private void _pruneCachedTraceSources()
private void Initialize()
private void NoConfigInit()
public void Close()
public void Flush()
protected internal String[] GetSupportedAttributes()
internal void RefreshAll()
internal void Refresh()
public void TraceEvent(TraceEventType eventType, int id)
public void TraceEvent(TraceEventType eventType, int id, string message)
public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args)
public void TraceData(TraceEventType eventType, int id, object data)
public void TraceData(TraceEventType eventType, int id, Object[] data)
public void TraceInformation(string message)
public void TraceInformation(string format, Object[] args)
public void TraceTransfer(int id, string message, Guid relatedActivityId)
private void CreateSwitch(string typename, string name)
public StringDictionary get_Attributes()
public string get_Name()
public TraceListenerCollection get_Listeners()
public SourceSwitch get_Switch()
public void set_Switch(SourceSwitch value)
}
internal System.Diagnostics.TraceSourceInfo : object {
private string name
private SourceLevels levels
private TraceListenerCollection listeners
public string Name
public SourceLevels Levels
public TraceListenerCollection Listeners
public void .ctor(string name, SourceLevels levels)
internal void .ctor(string name, SourceLevels levels, TraceImplSettings settings)
public string get_Name()
public SourceLevels get_Levels()
public TraceListenerCollection get_Listeners()
}
public System.Diagnostics.TraceSwitch : Switch {
public TraceLevel Level
public bool TraceError
public bool TraceWarning
public bool TraceInfo
public bool TraceVerbose
public void .ctor(string displayName, string description)
public void .ctor(string displayName, string description, string defaultSwitchValue)
public TraceLevel get_Level()
public void set_Level(TraceLevel value)
public bool get_TraceError()
public bool get_TraceWarning()
public bool get_TraceInfo()
public bool get_TraceVerbose()
protected void OnSwitchSettingChanged()
protected void OnValueChanged()
}
internal System.Diagnostics.TraceUtils : object {
internal object GetRuntimeObject(string className, Type baseType, string initializeData)
internal bool IsOwnedTL(Type type)
internal bool IsOwnedTextWriterTL(Type type)
private object ConvertToBaseTypeOrEnum(string value, Type type)
internal void VerifyAttributes(IDictionary attributes, String[] supportedAttributes, object parent)
}
internal System.Diagnostics.TypedElement : ConfigurationElement {
protected ConfigurationProperty _propTypeName
protected ConfigurationProperty _propInitData
protected ConfigurationPropertyCollection _properties
protected object _runtimeObject
private Type _baseType
public string InitData
protected ConfigurationPropertyCollection Properties
public string TypeName
public void .ctor(Type baseType)
public string get_InitData()
public void set_InitData(string value)
protected ConfigurationPropertyCollection get_Properties()
public string get_TypeName()
public void set_TypeName(string value)
protected object BaseGetRuntimeObject()
}
internal System.Diagnostics.UserCallBack : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(string data)
public IAsyncResult BeginInvoke(string data, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Diagnostics.Win32EventLog : EventLogImpl {
private int MESSAGE_NOT_FOUND
private ManualResetEvent _notifyResetEvent
private IntPtr _readHandle
private Thread _notifyThread
private int _lastEntryWritten
private object _eventLock
private int OldestEventLogEntry
private IntPtr ReadHandle
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
public void .ctor(EventLog coreEventLog)
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void EndInit()
public bool Exists(string logName, string machineName)
protected string FormatMessage(string source, UInt32 messageID, String[] replacementStrings)
private string FormatCategory(string source, int category)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
protected string GetLogDisplayName()
protected String[] GetLogNames(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
private void UpdateLogRegistry(RegistryKey logKey)
private void UpdateSourceRegistry(RegistryKey sourceKey, EventSourceCreationData data)
private string GetLogName(RegistryKey logKey)
private void ReadEventLog(int index, Byte[] buffer, Int32& bytesRead, Int32& minBufferNeeded)
private RegistryKey GetEventLogKey(string machineName, bool writable)
private RegistryKey FindSourceKeyByName(string source, string machineName, bool writable)
private RegistryKey FindLogKeyByName(string logName, string machineName, bool writable)
private RegistryKey FindLogKeyBySource(string source, string machineName, bool writable)
private int get_OldestEventLogEntry()
private void CloseEventLog(IntPtr hEventLog)
private void DeregisterEventSource(IntPtr hEventLog)
private string LookupAccountSid(string machineName, Byte[] sid)
private string FetchMessage(string msgDll, UInt32 messageID, String[] replacementStrings)
private String[] GetMessageResourceDlls(string source, string valueName)
private IntPtr get_ReadHandle()
private IntPtr RegisterEventSource()
public void DisableNotification()
public void EnableNotification()
private void NotifyEventThread(ManualResetEvent resetEvent)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
private void <EnableNotification>b__44_0()
}
public System.Diagnostics.XmlWriterTraceListener : TextWriterTraceListener {
private string fixedHeader
private string machineName
private StringBuilder strBldr
private XmlTextWriter xmlBlobWriter
internal bool shouldRespectFilterOnTraceTransfer
public void .ctor(Stream stream)
public void .ctor(Stream stream, string name)
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string name)
public void .ctor(string filename)
public void .ctor(string filename, string name)
public void Write(string message)
public void WriteLine(string message)
public void Fail(string message, string detailMessage)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
private void WriteData(object data)
public void Close()
public void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId)
private void WriteHeader(string source, TraceEventType eventType, int id, TraceEventCache eventCache, Guid relatedActivityId)
private void WriteHeader(string source, TraceEventType eventType, int id, TraceEventCache eventCache)
private void WriteStartHeader(string source, TraceEventType eventType, int id, TraceEventCache eventCache)
private void WriteEndHeader(TraceEventCache eventCache)
private void WriteFooter(TraceEventCache eventCache)
private void WriteEscaped(string str)
private void InternalWrite(string message)
}
internal System.DomainNameHelper : object {
private char c_DummyChar
internal string Localhost
internal string Loopback
internal string ParseCanonicalName(string str, int start, int end, Boolean& loopback)
internal bool IsValid(Char* name, ushort pos, Int32& returnedEnd, Boolean& notCanonical, bool notImplicitFile)
internal bool IsValidByIri(Char* name, ushort pos, Int32& returnedEnd, Boolean& notCanonical, bool notImplicitFile)
internal string IdnEquivalent(string hostname)
internal string IdnEquivalent(Char* hostname, int start, int end, Boolean& allAscii, Boolean& atLeastOneValidIdn)
internal string IdnEquivalent(Char* hostname, int start, int end, Boolean& allAscii, String& bidiStrippedHost)
private bool IsIdnAce(string input, int index)
private bool IsIdnAce(Char* input, int index)
internal string UnicodeEquivalent(string idnHost, Char* hostname, int start, int end)
internal string UnicodeEquivalent(Char* hostname, int start, int end, Boolean& allAscii, Boolean& atLeastOneValidIdn)
private bool IsASCIILetterOrDigit(char character, Boolean& notCanonical)
private bool IsValidDomainLabelCharacter(char character, Boolean& notCanonical)
}
internal System.EnvironmentHelpers : object {
internal bool IsWindowsVistaOrAbove()
}
public System.GenericUriParser : UriParser {
private UriSyntaxFlags DefaultGenericUriParserFlags
public void .ctor(GenericUriParserOptions options)
private UriSyntaxFlags MapGenericParserOptions(GenericUriParserOptions options)
}
public System.GenericUriParserOptions : Enum {
public int value__
public GenericUriParserOptions Default
public GenericUriParserOptions GenericAuthority
public GenericUriParserOptions AllowEmptyAuthority
public GenericUriParserOptions NoUserInfo
public GenericUriParserOptions NoPort
public GenericUriParserOptions NoQuery
public GenericUriParserOptions NoFragment
public GenericUriParserOptions DontConvertPathBackslashes
public GenericUriParserOptions DontCompressPath
public GenericUriParserOptions DontUnescapePathDotsAndSlashes
public GenericUriParserOptions Idn
public GenericUriParserOptions IriParsing
}
internal System.HResults : object {
internal int Configuration
internal int Xml
internal int XmlSchema
internal int XmlXslt
internal int XmlXPath
internal int Data
internal int DataDeletedRowInaccessible
internal int DataDuplicateName
internal int DataInRowChangingEvent
internal int DataInvalidConstraint
internal int DataMissingPrimaryKey
internal int DataNoNullAllowed
internal int DataReadOnly
internal int DataRowNotInTable
internal int DataVersionNotFound
internal int DataConstraint
internal int StrongTyping
internal int SqlType
internal int SqlNullValue
internal int SqlTruncate
internal int AdapterMapping
internal int DataAdapter
internal int DBConcurrency
internal int OperationAborted
internal int InvalidUdt
internal int Metadata
internal int InvalidQuery
internal int CommandCompilation
internal int CommandExecution
internal int SqlException
internal int OdbcException
internal int OracleException
internal int ConnectionPlanException
internal int NteBadKeySet
internal int Win32AccessDenied
internal int Win32InvalidHandle
internal int License
internal int InternalBufferOverflow
internal int ServiceControllerTimeout
internal int Install
internal int EFail
}
internal System.InvariantComparer : object {
private CompareInfo m_compareInfo
internal InvariantComparer Default
public int Compare(object a, object b)
}
internal System.IO.ChunkedMemoryStream : Stream {
private MemoryChunk _headChunk
private MemoryChunk _currentChunk
private int InitialChunkDefaultSize
private int MaxChunkSize
private int _totalLength
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public Byte[] ToArray()
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private void AppendChunk(long count)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public long get_Position()
public void set_Position(long value)
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
}
public System.IO.Compression.CompressionLevel : Enum {
public int value__
public CompressionLevel Optimal
public CompressionLevel Fastest
public CompressionLevel NoCompression
}
public System.IO.Compression.CompressionMode : Enum {
public int value__
public CompressionMode Decompress
public CompressionMode Compress
}
public System.IO.Compression.DeflateStream : Stream {
private Stream base_stream
private CompressionMode mode
private bool leaveOpen
private bool disposed
private DeflateStreamNative native
public Stream BaseStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(Stream stream, CompressionMode mode)
public void .ctor(Stream stream, CompressionMode mode, bool leaveOpen)
internal void .ctor(Stream stream, CompressionMode mode, bool leaveOpen, int windowsBits)
internal void .ctor(Stream compressedStream, CompressionMode mode, bool leaveOpen, bool gzip)
public void .ctor(Stream stream, CompressionLevel compressionLevel)
public void .ctor(Stream stream, CompressionLevel compressionLevel, bool leaveOpen)
internal void .ctor(Stream stream, CompressionLevel compressionLevel, bool leaveOpen, int windowsBits)
internal void .ctor(Stream stream, CompressionLevel compressionLevel, bool leaveOpen, bool gzip)
protected void Finalize()
protected void Dispose(bool disposing)
private int ReadInternal(Byte[] array, int offset, int count)
internal ValueTask`1<int> ReadAsyncMemory(Memory`1<byte> destination, CancellationToken cancellationToken)
internal int ReadCore(Span`1<byte> destination)
public int Read(Byte[] array, int offset, int count)
private void WriteInternal(Byte[] array, int offset, int count)
internal ValueTask WriteAsyncMemory(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken)
internal void WriteCore(ReadOnlySpan`1<byte> source)
public void Write(Byte[] array, int offset, int count)
public void Flush()
public IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public Stream get_BaseStream()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
}
internal System.IO.Compression.DeflateStreamNative : object {
private int BufferSize
private UnmanagedReadOrWrite feeder
private Stream base_stream
private SafeDeflateStreamHandle z_stream
private GCHandle data
private bool disposed
private Byte[] io_buffer
private Exception last_error
public DeflateStreamNative Create(Stream compressedStream, CompressionMode mode, bool gzip)
protected void Finalize()
public void Dispose(bool disposing)
public void Flush()
public int ReadZStream(IntPtr buffer, int length)
public void WriteZStream(IntPtr buffer, int length)
private int UnmanagedRead(IntPtr buffer, int length, IntPtr data)
private int UnmanagedRead(IntPtr buffer, int length)
private int UnmanagedWrite(IntPtr buffer, int length, IntPtr data)
private int UnmanagedWrite(IntPtr buffer, int length)
private void CheckResult(int result, string where)
private SafeDeflateStreamHandle CreateZStream(CompressionMode compress, bool gzip, UnmanagedReadOrWrite feeder, IntPtr data)
private int CloseZStream(IntPtr stream)
private int Flush(SafeDeflateStreamHandle stream)
private int ReadZStream(SafeDeflateStreamHandle stream, IntPtr buffer, int length)
private int WriteZStream(SafeDeflateStreamHandle stream, IntPtr buffer, int length)
}
public System.IO.Compression.GZipStream : Stream {
private DeflateStream _deflateStream
public bool CanRead
public bool CanWrite
public bool CanSeek
public long Length
public long Position
public Stream BaseStream
public void .ctor(Stream stream, CompressionMode mode)
public void .ctor(Stream stream, CompressionMode mode, bool leaveOpen)
public void .ctor(Stream stream, CompressionLevel compressionLevel)
public void .ctor(Stream stream, CompressionLevel compressionLevel, bool leaveOpen)
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public int ReadByte()
public IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public int EndRead(IAsyncResult asyncResult)
public int Read(Byte[] array, int offset, int count)
public int Read(Span`1<byte> buffer)
public IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void EndWrite(IAsyncResult asyncResult)
public void Write(Byte[] array, int offset, int count)
public void Write(ReadOnlySpan`1<byte> buffer)
public void CopyTo(Stream destination, int bufferSize)
protected void Dispose(bool disposing)
public Stream get_BaseStream()
public Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken)
public ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken)
public Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken)
public ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken)
public Task FlushAsync(CancellationToken cancellationToken)
public Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
private void CheckDeflateStream()
private void ThrowStreamClosedException()
}
internal System.IO.Compression.ZLibNative : object {
public int GZip_DefaultWindowBits
}
public System.IO.CoreFX.FileSystemWatcher : Component {
private int _currentSession
private SafeFileHandle _directoryHandle
private NormalizedFilterCollection _filters
private string _directory
private NotifyFilters c_defaultNotifyFilters
private NotifyFilters _notifyFilters
private bool _includeSubdirectories
private bool _enabled
private bool _initializing
private UInt32 _internalBufferSize
private bool _disposed
private FileSystemEventHandler _onChangedHandler
private FileSystemEventHandler _onCreatedHandler
private FileSystemEventHandler _onDeletedHandler
private RenamedEventHandler _onRenamedHandler
private ErrorEventHandler _onErrorHandler
private Char[] s_wildcards
private int c_notifyFiltersValidMask
private ISynchronizeInvoke <SynchronizingObject>k__BackingField
public NotifyFilters NotifyFilter
public Collection`1<string> Filters
public bool EnableRaisingEvents
public string Filter
public bool IncludeSubdirectories
public int InternalBufferSize
public string Path
public ISite Site
public ISynchronizeInvoke SynchronizingObject
private void StartRaisingEvents()
private void StopRaisingEvents()
private void FinalizeDispose()
private bool IsHandleInvalid(SafeFileHandle handle)
private void Monitor(AsyncReadState state)
private void ReadDirectoryChangesCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* overlappedPointer)
private void ParseEventBufferAndNotifyForEach(Byte[] buffer)
public void .ctor(string path)
public void .ctor(string path, string filter)
public NotifyFilters get_NotifyFilter()
public void set_NotifyFilter(NotifyFilters value)
public Collection`1<string> get_Filters()
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
public string get_Filter()
public void set_Filter(string value)
public bool get_IncludeSubdirectories()
public void set_IncludeSubdirectories(bool value)
public int get_InternalBufferSize()
public void set_InternalBufferSize(int value)
private Byte[] AllocateBuffer()
public string get_Path()
public void set_Path(string value)
public void add_Changed(FileSystemEventHandler value)
public void remove_Changed(FileSystemEventHandler value)
public void add_Created(FileSystemEventHandler value)
public void remove_Created(FileSystemEventHandler value)
public void add_Deleted(FileSystemEventHandler value)
public void remove_Deleted(FileSystemEventHandler value)
public void add_Error(ErrorEventHandler value)
public void remove_Error(ErrorEventHandler value)
public void add_Renamed(RenamedEventHandler value)
public void remove_Renamed(RenamedEventHandler value)
protected void Dispose(bool disposing)
private void CheckPathValidity(string path)
private bool MatchPattern(ReadOnlySpan`1<char> relativePath)
private void NotifyInternalBufferOverflowEvent()
private void NotifyRenameEventArgs(WatcherChangeTypes action, ReadOnlySpan`1<char> name, ReadOnlySpan`1<char> oldName)
private FileSystemEventHandler GetHandler(WatcherChangeTypes changeType)
private void NotifyFileSystemEventArgs(WatcherChangeTypes changeType, ReadOnlySpan`1<char> name)
private void NotifyFileSystemEventArgs(WatcherChangeTypes changeType, string name)
protected void OnChanged(FileSystemEventArgs e)
protected void OnCreated(FileSystemEventArgs e)
protected void OnDeleted(FileSystemEventArgs e)
private void InvokeOn(FileSystemEventArgs e, FileSystemEventHandler handler)
protected void OnError(ErrorEventArgs e)
protected void OnRenamed(RenamedEventArgs e)
public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType)
public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout)
private void Restart()
private void StartRaisingEventsIfNotDisposed()
public ISite get_Site()
public void set_Site(ISite value)
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public void BeginInit()
public void EndInit()
private bool IsSuspended()
}
internal System.IO.CoreFXFileSystemWatcherProxy : object {
private IFileWatcher instance
private IDictionary`2<object, FileSystemWatcher> internal_map
private ConditionalWeakTable`2<object, FileSystemWatcher> external_map
private IDictionary`2<object, object> event_map
private int INTERRUPT_MS
protected void Operation(Action`4<IDictionary`2<object, FileSystemWatcher>, ConditionalWeakTable`2<object, FileSystemWatcher>, IDictionary`2<object, object>, object> map_op, Action`2<FileSystemWatcher, FileSystemWatcher> object_op, object handle, Action`2<FileSystemWatcher, FileSystemWatcher> cancel_op)
protected void ProxyDispatch(object sender, FileAction action, FileSystemEventArgs args)
protected void ProxyDispatchError(object sender, ErrorEventArgs args)
public object NewWatcher(FileSystemWatcher fsw)
public void StartDispatching(object handle)
public void StopDispatching(object handle)
public void Dispose(object handle)
public bool GetInstance(IFileWatcher& watcher)
}
internal System.IO.DefaultWatcher : object {
private DefaultWatcher instance
private Thread thread
private Hashtable watches
private String[] NoStringsArray
public bool GetInstance(IFileWatcher& watcher)
public void StartDispatching(object handle)
public void StopDispatching(object handle)
public void Dispose(object handle)
private void Monitor()
private bool UpdateDataAndDispatch(DefaultWatcherData data, bool dispatch)
private void DispatchEvents(FileSystemWatcher fsw, FileAction action, string filename)
private void DoFiles(DefaultWatcherData data, string directory, bool dispatch)
private void IterateAndModifyFilesData(DefaultWatcherData data, string directory, bool dispatch, String[] files)
private FileData CreateFileData(string directory, string filename)
}
internal System.IO.DefaultWatcherData : object {
public FileSystemWatcher FSW
public string Directory
public string FileMask
public bool IncludeSubdirs
public bool Enabled
public bool NoWildcards
public DateTime DisabledTime
public object FilesLock
public Dictionary`2<string, FileData> Files
}
public System.IO.ErrorEventArgs : EventArgs {
private Exception exception
public void .ctor(Exception exception)
public Exception GetException()
}
public System.IO.ErrorEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ErrorEventArgs e)
public IAsyncResult BeginInvoke(object sender, ErrorEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.IO.EventFilter : Enum {
public short value__
public EventFilter Read
public EventFilter Write
public EventFilter Aio
public EventFilter Vnode
public EventFilter Proc
public EventFilter Signal
public EventFilter Timer
public EventFilter MachPort
public EventFilter FS
public EventFilter User
public EventFilter VM
}
internal System.IO.EventFlags : Enum {
public ushort value__
public EventFlags Add
public EventFlags Delete
public EventFlags Enable
public EventFlags Disable
public EventFlags OneShot
public EventFlags Clear
public EventFlags Receipt
public EventFlags Dispatch
public EventFlags Flag0
public EventFlags Flag1
public EventFlags SystemFlags
public EventFlags EOF
public EventFlags Error
}
internal System.IO.FAMCodes : Enum {
public int value__
public FAMCodes Changed
public FAMCodes Deleted
public FAMCodes StartExecuting
public FAMCodes StopExecuting
public FAMCodes Created
public FAMCodes Moved
public FAMCodes Acknowledge
public FAMCodes Exists
public FAMCodes EndExist
}
internal System.IO.FAMConnection : ValueType {
public int FD
public IntPtr opaque
}
internal System.IO.FAMData : object {
public FileSystemWatcher FSW
public string Directory
public string FileMask
public bool IncludeSubdirs
public bool Enabled
public FAMRequest Request
public Hashtable SubDirs
}
internal System.IO.FAMRequest : ValueType {
public int ReqNum
}
internal System.IO.FAMWatcher : object {
private bool failed
private FAMWatcher instance
private Hashtable watches
private Hashtable requests
private FAMConnection conn
private Thread thread
private bool stop
private bool use_gamin
private NotifyFilters changed
public bool GetInstance(IFileWatcher& watcher, bool gamin)
public void StartDispatching(object handle)
private void StartMonitoringDirectory(FAMData data, bool justcreated)
public void StopDispatching(object handle)
private void StopMonitoringDirectory(FAMData data)
private void Monitor()
private void ProcessEvents()
protected void Finalize()
private int FAMOpen(FAMConnection& fc)
private int FAMClose(FAMConnection& fc)
private int FAMMonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data)
private int FAMCancelMonitor(FAMConnection& fc, FAMRequest& fr)
private int FAMPending(FAMConnection& fc)
public void Dispose(object handle)
private int fam_Open(FAMConnection& fc)
private int fam_Close(FAMConnection& fc)
private int fam_MonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data)
private int fam_CancelMonitor(FAMConnection& fc, FAMRequest& fr)
private int fam_Pending(FAMConnection& fc)
private int gamin_Open(FAMConnection& fc)
private int gamin_Close(FAMConnection& fc)
private int gamin_MonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data)
private int gamin_CancelMonitor(FAMConnection& fc, FAMRequest& fr)
private int gamin_Pending(FAMConnection& fc)
private int InternalFAMNextEvent(FAMConnection& fc, String& filename, Int32& code, Int32& reqnum)
}
internal System.IO.FileAction : Enum {
public int value__
public FileAction Added
public FileAction Removed
public FileAction Modified
public FileAction RenamedOldName
public FileAction RenamedNewName
}
internal System.IO.FileData : object {
public string Directory
public FileAttributes Attributes
public bool NotExists
public DateTime CreationTime
public DateTime LastWriteTime
}
public System.IO.FileSystemEventArgs : EventArgs {
private WatcherChangeTypes _changeType
private string _name
private string _fullPath
public WatcherChangeTypes ChangeType
public string FullPath
public string Name
public void .ctor(WatcherChangeTypes changeType, string directory, string name)
internal string Combine(string directoryPath, string name)
public WatcherChangeTypes get_ChangeType()
public string get_FullPath()
public string get_Name()
}
public System.IO.FileSystemEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, FileSystemEventArgs e)
public IAsyncResult BeginInvoke(object sender, FileSystemEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.FileSystemWatcher : Component {
private bool inited
private bool start_requested
private bool enableRaisingEvents
private string filter
private bool includeSubdirectories
private int internalBufferSize
private NotifyFilters notifyFilter
private string path
private string fullpath
private ISynchronizeInvoke synchronizingObject
private WaitForChangedResult lastData
private bool waiting
private SearchPattern2 pattern
private bool disposed
private string mangledFilter
private IFileWatcher watcher
private object watcher_handle
private object lockobj
private FileSystemEventHandler Changed
private FileSystemEventHandler Created
private FileSystemEventHandler Deleted
private ErrorEventHandler Error
private RenamedEventHandler Renamed
internal bool Waiting
internal string MangledFilter
internal SearchPattern2 Pattern
internal string FullPath
public bool EnableRaisingEvents
public string Filter
public bool IncludeSubdirectories
public int InternalBufferSize
public NotifyFilters NotifyFilter
public string Path
public ISite Site
public ISynchronizeInvoke SynchronizingObject
public void .ctor(string path)
public void .ctor(string path, string filter)
private void InitWatcher()
private void ShowWatcherInfo()
internal bool get_Waiting()
internal void set_Waiting(bool value)
internal string get_MangledFilter()
internal SearchPattern2 get_Pattern()
internal string get_FullPath()
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
public string get_Filter()
public void set_Filter(string value)
public bool get_IncludeSubdirectories()
public void set_IncludeSubdirectories(bool value)
public int get_InternalBufferSize()
public void set_InternalBufferSize(int value)
public NotifyFilters get_NotifyFilter()
public void set_NotifyFilter(NotifyFilters value)
public string get_Path()
public void set_Path(string value)
public ISite get_Site()
public void set_Site(ISite value)
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public void BeginInit()
protected void Dispose(bool disposing)
protected void Finalize()
public void EndInit()
private void RaiseEvent(Delegate ev, EventArgs arg, EventType evtype)
protected void OnChanged(FileSystemEventArgs e)
protected void OnCreated(FileSystemEventArgs e)
protected void OnDeleted(FileSystemEventArgs e)
protected void OnError(ErrorEventArgs e)
protected void OnRenamed(RenamedEventArgs e)
public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType)
public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout)
internal void DispatchErrorEvents(ErrorEventArgs args)
internal void DispatchEvents(FileAction act, string filename, RenamedEventArgs& renamed)
private void Start()
private void Stop()
public void add_Changed(FileSystemEventHandler value)
public void remove_Changed(FileSystemEventHandler value)
public void add_Created(FileSystemEventHandler value)
public void remove_Created(FileSystemEventHandler value)
public void add_Deleted(FileSystemEventHandler value)
public void remove_Deleted(FileSystemEventHandler value)
public void add_Error(ErrorEventHandler value)
public void remove_Error(ErrorEventHandler value)
public void add_Renamed(RenamedEventHandler value)
public void remove_Renamed(RenamedEventHandler value)
private int InternalSupportsFSW()
}
internal System.IO.FilterFlags : Enum {
public UInt32 value__
public FilterFlags ReadPoll
public FilterFlags ReadOutOfBand
public FilterFlags ReadLowWaterMark
public FilterFlags WriteLowWaterMark
public FilterFlags NoteTrigger
public FilterFlags NoteFFNop
public FilterFlags NoteFFAnd
public FilterFlags NoteFFOr
public FilterFlags NoteFFCopy
public FilterFlags NoteFFCtrlMask
public FilterFlags NoteFFlagsMask
public FilterFlags VNodeDelete
public FilterFlags VNodeWrite
public FilterFlags VNodeExtend
public FilterFlags VNodeAttrib
public FilterFlags VNodeLink
public FilterFlags VNodeRename
public FilterFlags VNodeRevoke
public FilterFlags VNodeNone
public FilterFlags ProcExit
public FilterFlags ProcFork
public FilterFlags ProcExec
public FilterFlags ProcReap
public FilterFlags ProcSignal
public FilterFlags ProcExitStatus
public FilterFlags ProcResourceEnd
public FilterFlags ProcAppactive
public FilterFlags ProcAppBackground
public FilterFlags ProcAppNonUI
public FilterFlags ProcAppInactive
public FilterFlags ProcAppAllStates
public FilterFlags ProcPDataMask
public FilterFlags ProcControlMask
public FilterFlags VMPressure
public FilterFlags VMPressureTerminate
public FilterFlags VMPressureSuddenTerminate
public FilterFlags VMError
public FilterFlags TimerSeconds
public FilterFlags TimerMicroSeconds
public FilterFlags TimerNanoSeconds
public FilterFlags TimerAbsolute
}
internal System.IO.IFileWatcher {
public void StartDispatching(object fsw)
public void StopDispatching(object fsw)
public void Dispose(object fsw)
}
public System.IO.InternalBufferOverflowException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
public System.IO.InvalidDataException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
private void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.IODescriptionAttribute : DescriptionAttribute {
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.IO.kevent : ValueType {
public UIntPtr ident
public EventFilter filter
public EventFlags flags
public FilterFlags fflags
public IntPtr data
public IntPtr udata
public void Dispose()
}
internal System.IO.KeventWatcher : object {
private bool failed
private KeventWatcher instance
private Hashtable watches
public bool GetInstance(IFileWatcher& watcher)
public void StartDispatching(object handle)
public void StopDispatching(object handle)
public void Dispose(object handle)
private int close(int fd)
private int kqueue()
}
internal System.IO.KqueueMonitor : object {
private bool initialized
private int O_EVTONLY
private int F_GETPATH
private int __DARWIN_MAXPATHLEN
private int EINTR
private kevent[] emptyEventList
private int maxFds
private FileSystemWatcher fsw
private int conn
private Thread thread
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) requestStop
private AutoResetEvent startedEvent
private bool started
private bool inDispatch
private Exception exc
private object stateLock
private object connLock
private Dictionary`2<string, PathData> pathsDict
private Dictionary`2<int, PathData> fdsDict
private string fixupPath
private string fullPathNoLastSlash
public int Connection
public int get_Connection()
public void .ctor(FileSystemWatcher fsw)
public void Dispose()
public void Start()
public void Stop()
private void CleanUp()
private void DoMonitor()
private void Setup()
private kevent[] CreateChangeList(List`1& FdList)
private void Monitor()
private PathData Add(string path, bool postEvents, List`1& fds)
private void Remove(PathData pathData)
private void RemoveTree(PathData pathData)
private void UpdatePath(PathData pathData)
private void Scan(string path, bool postEvents, List`1& fds)
private void PostEvent(FileAction action, string path, string newPath)
private string GetFilenameFromFd(int fd)
private int fcntl(int file_names_by_descriptor, int cmd, StringBuilder sb)
private IntPtr realpath(string pathname, StringBuilder sb)
private int open(string path, int flags, int mode_t)
private int close(int fd)
private int kqueue()
private int kevent(int kq, kevent[] ev, int nchanges, kevent[] evtlist, int nevents, timespec& time)
private int kevent_notimeout(Int32& kq, IntPtr ev, int nchanges, IntPtr evtlist, int nevents)
private void <Start>b__5_0()
}
public System.IO.NotifyFilters : Enum {
public int value__
public NotifyFilters Attributes
public NotifyFilters CreationTime
public NotifyFilters DirectoryName
public NotifyFilters FileName
public NotifyFilters LastAccess
public NotifyFilters LastWrite
public NotifyFilters Security
public NotifyFilters Size
}
internal System.IO.NullFileWatcher : object {
private IFileWatcher instance
public void StartDispatching(object handle)
public void StopDispatching(object handle)
public void Dispose(object handle)
public bool GetInstance(IFileWatcher& watcher)
}
internal System.IO.PathData : object {
public string Path
public bool IsDirectory
public int Fd
}
internal System.IO.PathInternal : object {
private bool s_isCaseSensitive
internal string ExtendedDevicePathPrefix
internal string UncPathPrefix
internal string UncDevicePrefixToInsert
internal string UncExtendedPathPrefix
internal string DevicePathPrefix
internal int MaxShortPath
internal int DevicePrefixLength
internal StringComparison StringComparison
internal bool IsCaseSensitive
internal StringComparison get_StringComparison()
internal bool get_IsCaseSensitive()
private bool GetIsCaseSensitive()
internal bool IsValidDriveChar(char value)
private bool EndsWithPeriodOrSpace(string path)
internal string EnsureExtendedPrefixIfNeeded(string path)
internal string EnsureExtendedPrefix(string path)
internal bool IsDevice(string path)
internal bool IsExtended(string path)
internal int GetRootLength(ReadOnlySpan`1<char> path)
internal bool IsPartiallyQualified(string path)
internal bool IsDirectorySeparator(char c)
}
internal System.IO.Ports.CommStat : ValueType {
public UInt32 flags
public UInt32 BytesIn
public UInt32 BytesOut
}
internal System.IO.Ports.DCB : object {
public int dcb_length
public int baud_rate
public int flags
public short w_reserved
public short xon_lim
public short xoff_lim
public byte byte_size
public byte parity
public byte stop_bits
public byte xon_char
public byte xoff_char
public byte error_char
public byte eof_char
public byte evt_char
public short w_reserved1
private int fOutxCtsFlow
private int fOutX
private int fInX
private int fRtsControl2
public void SetValues(int baud_rate, Parity parity, int byte_size, StopBits sb, Handshake hs)
}
public System.IO.Ports.Handshake : Enum {
public int value__
public Handshake None
public Handshake XOnXOff
public Handshake RequestToSend
public Handshake RequestToSendXOnXOff
}
internal System.IO.Ports.InternalResources : object {
internal void EndOfFile()
internal string GetMessage(int errorCode)
internal void FileNotOpen()
internal void WrongAsyncResult()
internal void EndReadCalledTwice()
internal void EndWriteCalledTwice()
internal void WinIOError(int errorCode, string str)
internal int MakeHRFromErrorCode(int errorCode)
}
internal System.IO.Ports.ISerialStream {
public int BytesToRead
public int BytesToWrite
public int ReadTimeout
public int WriteTimeout
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
public void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits sb, Handshake hs)
public void DiscardInBuffer()
public void DiscardOutBuffer()
public SerialSignal GetSignals()
public void SetSignal(SerialSignal signal, bool value)
public void SetBreakState(bool value)
public void Close()
public int get_BytesToRead()
public int get_BytesToWrite()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
}
public System.IO.Ports.Parity : Enum {
public int value__
public Parity None
public Parity Odd
public Parity Even
public Parity Mark
public Parity Space
}
public System.IO.Ports.SerialData : Enum {
public int value__
public SerialData Chars
public SerialData Eof
}
public System.IO.Ports.SerialDataReceivedEventArgs : EventArgs {
private SerialData eventType
public SerialData EventType
internal void .ctor(SerialData eventType)
public SerialData get_EventType()
}
public System.IO.Ports.SerialDataReceivedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SerialDataReceivedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SerialDataReceivedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Ports.SerialError : Enum {
public int value__
public SerialError RXOver
public SerialError Overrun
public SerialError RXParity
public SerialError Frame
public SerialError TXFull
}
public System.IO.Ports.SerialErrorReceivedEventArgs : EventArgs {
private SerialError eventType
public SerialError EventType
internal void .ctor(SerialError eventType)
public SerialError get_EventType()
}
public System.IO.Ports.SerialErrorReceivedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SerialErrorReceivedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SerialErrorReceivedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Ports.SerialPinChange : Enum {
public int value__
public SerialPinChange CtsChanged
public SerialPinChange DsrChanged
public SerialPinChange CDChanged
public SerialPinChange Break
public SerialPinChange Ring
}
public System.IO.Ports.SerialPinChangedEventArgs : EventArgs {
private SerialPinChange eventType
public SerialPinChange EventType
internal void .ctor(SerialPinChange eventType)
public SerialPinChange get_EventType()
}
public System.IO.Ports.SerialPinChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SerialPinChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SerialPinChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Ports.SerialPort : Component {
public int InfiniteTimeout
private int DefaultReadBufferSize
private int DefaultWriteBufferSize
private int DefaultBaudRate
private int DefaultDataBits
private Parity DefaultParity
private StopBits DefaultStopBits
private bool is_open
private int baud_rate
private Parity parity
private StopBits stop_bits
private Handshake handshake
private int data_bits
private bool break_state
private bool dtr_enable
private bool rts_enable
private ISerialStream stream
private Encoding encoding
private string new_line
private string port_name
private int read_timeout
private int write_timeout
private int readBufferSize
private int writeBufferSize
private object error_received
private object data_received
private object pin_changed
public Stream BaseStream
public int BaudRate
public bool BreakState
public int BytesToRead
public int BytesToWrite
public bool CDHolding
public bool CtsHolding
public int DataBits
public bool DiscardNull
public bool DsrHolding
public bool DtrEnable
public Encoding Encoding
public Handshake Handshake
public bool IsOpen
public string NewLine
public Parity Parity
public byte ParityReplace
public string PortName
public int ReadBufferSize
public int ReadTimeout
public int ReceivedBytesThreshold
public bool RtsEnable
public StopBits StopBits
public int WriteBufferSize
public int WriteTimeout
private bool IsWindows
public void .ctor(IContainer container)
public void .ctor(string portName)
public void .ctor(string portName, int baudRate)
public void .ctor(string portName, int baudRate, Parity parity)
public void .ctor(string portName, int baudRate, Parity parity, int dataBits)
public void .ctor(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits)
private string GetDefaultPortName()
public Stream get_BaseStream()
public int get_BaudRate()
public void set_BaudRate(int value)
public bool get_BreakState()
public void set_BreakState(bool value)
public int get_BytesToRead()
public int get_BytesToWrite()
public bool get_CDHolding()
public bool get_CtsHolding()
public int get_DataBits()
public void set_DataBits(int value)
public bool get_DiscardNull()
public void set_DiscardNull(bool value)
public bool get_DsrHolding()
public bool get_DtrEnable()
public void set_DtrEnable(bool value)
public Encoding get_Encoding()
public void set_Encoding(Encoding value)
public Handshake get_Handshake()
public void set_Handshake(Handshake value)
public bool get_IsOpen()
public string get_NewLine()
public void set_NewLine(string value)
public Parity get_Parity()
public void set_Parity(Parity value)
public byte get_ParityReplace()
public void set_ParityReplace(byte value)
public string get_PortName()
public void set_PortName(string value)
public int get_ReadBufferSize()
public void set_ReadBufferSize(int value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_ReceivedBytesThreshold()
public void set_ReceivedBytesThreshold(int value)
public bool get_RtsEnable()
public void set_RtsEnable(bool value)
public StopBits get_StopBits()
public void set_StopBits(StopBits value)
public int get_WriteBufferSize()
public void set_WriteBufferSize(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public void Close()
protected void Dispose(bool disposing)
public void DiscardInBuffer()
public void DiscardOutBuffer()
public String[] GetPortNames()
private bool get_IsWindows()
public void Open()
public int Read(Byte[] buffer, int offset, int count)
public int Read(Char[] buffer, int offset, int count)
internal int read_byte()
public int ReadByte()
public int ReadChar()
public string ReadExisting()
public string ReadLine()
public string ReadTo(string value)
public void Write(string text)
public void Write(Byte[] buffer, int offset, int count)
public void Write(Char[] buffer, int offset, int count)
public void WriteLine(string text)
private void CheckOpen()
internal void OnErrorReceived(SerialErrorReceivedEventArgs args)
internal void OnDataReceived(SerialDataReceivedEventArgs args)
internal void OnDataReceived(SerialPinChangedEventArgs args)
public void add_ErrorReceived(SerialErrorReceivedEventHandler value)
public void remove_ErrorReceived(SerialErrorReceivedEventHandler value)
public void add_PinChanged(SerialPinChangedEventHandler value)
public void remove_PinChanged(SerialPinChangedEventHandler value)
public void add_DataReceived(SerialDataReceivedEventHandler value)
public void remove_DataReceived(SerialDataReceivedEventHandler value)
}
internal System.IO.Ports.SerialPortStream : Stream {
private int fd
private int read_timeout
private int write_timeout
private bool disposed
public bool CanRead
public bool CanSeek
public bool CanWrite
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
public int BytesToRead
public int BytesToWrite
private int open_serial(string portName)
public void .ctor(string portName, int baudRate, int dataBits, Parity parity, StopBits stopBits, bool dtrEnable, bool rtsEnable, Handshake handshake, int readTimeout, int writeTimeout, int readBufferSize, int writeBufferSize)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
private int read_serial(int fd, Byte[] buffer, int offset, int count)
private bool poll_serial(int fd, Int32& error, int timeout)
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
private int write_serial(int fd, Byte[] buffer, int offset, int count, int timeout)
public void Write(Byte[] buffer, int offset, int count)
protected void Dispose(bool disposing)
private int close_serial(int fd)
public void Close()
private void System.IDisposable.Dispose()
protected void Finalize()
private void CheckDisposed()
private bool set_attributes(int fd, int baudRate, Parity parity, int dataBits, StopBits stopBits, Handshake handshake)
public void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits sb, Handshake hs)
private int get_bytes_in_buffer(int fd, int input)
public int get_BytesToRead()
public int get_BytesToWrite()
private int discard_buffer(int fd, bool inputBuffer)
public void DiscardInBuffer()
public void DiscardOutBuffer()
private SerialSignal get_signals(int fd, Int32& error)
public SerialSignal GetSignals()
private int set_signal(int fd, SerialSignal signal, bool value)
public void SetSignal(SerialSignal signal, bool value)
private int breakprop(int fd)
public void SetBreakState(bool value)
private IntPtr strerror(int errnum)
private void ThrowIOException()
private bool is_baud_rate_legal(int baud_rate)
private void TryBaudRate(int baudRate)
}
internal System.IO.Ports.SerialSignal : Enum {
public int value__
public SerialSignal None
public SerialSignal Cd
public SerialSignal Cts
public SerialSignal Dsr
public SerialSignal Dtr
public SerialSignal Rts
}
public System.IO.Ports.StopBits : Enum {
public int value__
public StopBits None
public StopBits One
public StopBits Two
public StopBits OnePointFive
}
internal System.IO.Ports.Timeouts : object {
public UInt32 ReadIntervalTimeout
public UInt32 ReadTotalTimeoutMultiplier
public UInt32 ReadTotalTimeoutConstant
public UInt32 WriteTotalTimeoutMultiplier
public UInt32 WriteTotalTimeoutConstant
public UInt32 MaxDWord
public void .ctor(int read_timeout, int write_timeout)
public void SetValues(int read_timeout, int write_timeout)
}
internal System.IO.Ports.WinSerialStream : Stream {
private UInt32 GenericRead
private UInt32 GenericWrite
private UInt32 OpenExisting
private UInt32 FileFlagOverlapped
private UInt32 PurgeRxClear
private UInt32 PurgeTxClear
private UInt32 WinInfiniteTimeout
private UInt32 FileIOPending
private UInt32 SetRts
private UInt32 ClearRts
private UInt32 SetDtr
private UInt32 ClearDtr
private UInt32 SetBreak
private UInt32 ClearBreak
private UInt32 CtsOn
private UInt32 DsrOn
private UInt32 RsldOn
private UInt32 EvRxChar
private UInt32 EvCts
private UInt32 EvDsr
private UInt32 EvRlsd
private UInt32 EvBreak
private UInt32 EvErr
private UInt32 EvRing
private int handle
private int read_timeout
private int write_timeout
private bool disposed
private IntPtr write_overlapped
private IntPtr read_overlapped
private ManualResetEvent read_event
private ManualResetEvent write_event
private Timeouts timeouts
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
public int BytesToRead
public int BytesToWrite
private int CreateFile(string port_name, UInt32 desired_access, UInt32 share_mode, UInt32 security_attrs, UInt32 creation, UInt32 flags, UInt32 template)
private bool SetupComm(int handle, int read_buffer_size, int write_buffer_size)
private bool PurgeComm(int handle, UInt32 flags)
private bool SetCommTimeouts(int handle, Timeouts timeouts)
public void .ctor(string port_name, int baud_rate, int data_bits, Parity parity, StopBits sb, bool dtr_enable, bool rts_enable, Handshake hs, int read_timeout, int write_timeout, int read_buffer_size, int write_buffer_size)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
private bool CloseHandle(int handle)
protected void Dispose(bool disposing)
private void System.IDisposable.Dispose()
public void Close()
protected void Finalize()
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
private bool ReadFile(int handle, Byte* buffer, int bytes_to_read, Int32& bytes_read, IntPtr overlapped)
private bool GetOverlappedResult(int handle, IntPtr overlapped, Int32& bytes_transfered, bool wait)
public int Read(Byte[] buffer, int offset, int count)
private bool WriteFile(int handle, Byte* buffer, int bytes_to_write, Int32& bytes_written, IntPtr overlapped)
public void Write(Byte[] buffer, int offset, int count)
private bool GetCommState(int handle, DCB dcb)
private bool SetCommState(int handle, DCB dcb)
public void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits bits, Handshake hs)
private void ReportIOError(string optional_arg)
private void CheckDisposed()
public void DiscardInBuffer()
public void DiscardOutBuffer()
private bool ClearCommError(int handle, UInt32& errors, CommStat& stat)
public int get_BytesToRead()
public int get_BytesToWrite()
private bool GetCommModemStatus(int handle, UInt32& flags)
public SerialSignal GetSignals()
private bool EscapeCommFunction(int handle, UInt32 flags)
public void SetSignal(SerialSignal signal, bool value)
public void SetBreakState(bool value)
}
internal System.IO.ReadOnlyMemoryStream : Stream {
private ReadOnlyMemory`1<byte> _content
private int _position
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(ReadOnlyMemory`1<byte> content)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public long Seek(long offset, SeekOrigin origin)
public int ReadByte()
public int Read(Byte[] buffer, int offset, int count)
public int Read(Span`1<byte> buffer)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public void CopyTo(Stream destination, int bufferSize)
public Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
private void ValidateReadArrayArguments(Byte[] buffer, int offset, int count)
}
public System.IO.RenamedEventArgs : FileSystemEventArgs {
private string _oldName
private string _oldFullPath
public string OldFullPath
public string OldName
public void .ctor(WatcherChangeTypes changeType, string directory, string name, string oldName)
public string get_OldFullPath()
public string get_OldName()
}
public System.IO.RenamedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, RenamedEventArgs e)
public IAsyncResult BeginInvoke(object sender, RenamedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.IO.SearchPattern2 : object {
private Op ops
private bool ignore
private bool hasWildcard
private string pattern
internal Char[] WildcardChars
internal Char[] InvalidChars
public bool HasWildcard
public void .ctor(string pattern)
public void .ctor(string pattern, bool ignore)
public bool IsMatch(string text, bool ignorecase)
public bool IsMatch(string text)
public bool get_HasWildcard()
private void Compile(string pattern)
private bool Match(Op op, string text, int ptr)
}
internal System.IO.timespec : ValueType {
public IntPtr tv_sec
public IntPtr tv_nsec
}
public System.IO.WaitForChangedResult : ValueType {
internal WaitForChangedResult TimedOutResult
private WatcherChangeTypes <ChangeType>k__BackingField
private string <Name>k__BackingField
private string <OldName>k__BackingField
private bool <TimedOut>k__BackingField
public WatcherChangeTypes ChangeType
public string Name
public string OldName
public bool TimedOut
internal void .ctor(WatcherChangeTypes changeType, string name, string oldName, bool timedOut)
public WatcherChangeTypes get_ChangeType()
public void set_ChangeType(WatcherChangeTypes value)
public string get_Name()
public void set_Name(string value)
public string get_OldName()
public void set_OldName(string value)
public bool get_TimedOut()
public void set_TimedOut(bool value)
}
public System.IO.WatcherChangeTypes : Enum {
public int value__
public WatcherChangeTypes All
public WatcherChangeTypes Changed
public WatcherChangeTypes Created
public WatcherChangeTypes Deleted
public WatcherChangeTypes Renamed
}
internal System.IOAsyncCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(IOAsyncResult ioares)
public IAsyncResult BeginInvoke(IOAsyncResult ioares, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.IOAsyncResult : object {
private AsyncCallback async_callback
private object async_state
private ManualResetEvent wait_handle
private bool completed_synchronously
private bool completed
public AsyncCallback AsyncCallback
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
protected void Init(AsyncCallback async_callback, object async_state)
protected void .ctor(AsyncCallback async_callback, object async_state)
public AsyncCallback get_AsyncCallback()
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
protected void set_CompletedSynchronously(bool value)
public bool get_IsCompleted()
protected void set_IsCompleted(bool value)
internal void CompleteDisposed()
}
internal System.IOOperation : Enum {
public int value__
public IOOperation Read
public IOOperation Write
}
internal System.IOSelector : object {
public void Add(IntPtr handle, IOSelectorJob job)
public void Remove(IntPtr handle)
}
internal System.IOSelectorJob : object {
private IOOperation operation
private IOAsyncCallback callback
private IOAsyncResult state
public void .ctor(IOOperation operation, IOAsyncCallback callback, IOAsyncResult state)
private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae)
public void MarkDisposed()
}
internal System.IPv4AddressHelper : object {
internal long Invalid
private long MaxIPv4Value
private int Octal
private int Decimal
private int Hex
private int NumberOfLabels
internal int ParseHostNumber(ReadOnlySpan`1<char> str, int start, int end)
internal bool IsValid(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile, bool unknownScheme)
private bool ParseCanonical(ReadOnlySpan`1<char> name, Byte* numbers, int start, int end)
internal bool IsValidCanonical(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile)
internal long ParseNonCanonical(Char* name, int start, Int32& end, bool notImplicitFile)
internal string ParseCanonicalName(string str, int start, int end, Boolean& isLoopback)
private bool Parse(string name, Byte* numbers, int start, int end)
}
internal System.IPv6AddressHelper : object {
private int NumberOfLabels
internal ValueTuple`2<int, int> FindCompressionRange(ReadOnlySpan`1<ushort> numbers)
internal bool ShouldHaveIpv4Embedded(ReadOnlySpan`1<ushort> numbers)
internal bool IsValidStrict(Char* name, int start, Int32& end)
internal void Parse(ReadOnlySpan`1<char> address, UInt16* numbers, int start, String& scopeId)
internal string ParseCanonicalName(string str, int start, Boolean& isLoopback, String& scopeId)
private bool IsLoopback(ReadOnlySpan`1<ushort> numbers)
private bool ShouldHaveIpv4Embedded(UInt16* numbers)
private bool InternalIsValid(Char* name, int start, Int32& end, bool validateStrictAddress)
internal bool IsValid(Char* name, int start, Int32& end)
}
internal System.IriHelper : object {
internal bool CheckIriUnicodeRange(char unicode, bool isQuery)
internal bool CheckIriUnicodeRange(char highSurr, char lowSurr, Boolean& surrogatePair, bool isQuery)
internal bool CheckIsReserved(char ch, UriComponents component)
internal string EscapeUnescapeIri(Char* pInput, int start, int end, UriComponents component)
}
internal System.LocalAppContextSwitches : object {
public bool MemberDescriptorEqualsReturnsFalseIfEquivalent
}
public System.Media.SoundPlayer : Component {
private string sound_location
private Stream audiostream
private object tag
private MemoryStream mstream
private bool load_completed
private int load_timeout
private AudioDevice adev
private AudioData adata
private bool stopped
private Win32SoundPlayer win32_player
private bool use_win32_player
private AsyncCompletedEventHandler LoadCompleted
private EventHandler SoundLocationChanged
private EventHandler StreamChanged
public bool IsLoadCompleted
public int LoadTimeout
public string SoundLocation
public Stream Stream
public object Tag
public void .ctor(Stream stream)
public void .ctor(string soundLocation)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext context)
private void LoadFromStream(Stream s)
private void LoadFromUri(string location)
public void Load()
private void AsyncFinished(IAsyncResult ar)
public void LoadAsync()
protected void OnLoadCompleted(AsyncCompletedEventArgs e)
protected void OnSoundLocationChanged(EventArgs e)
protected void OnStreamChanged(EventArgs e)
private void Start()
public void Play()
private void PlayLoop()
public void PlayLooping()
public void PlaySync()
public void Stop()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public bool get_IsLoadCompleted()
public int get_LoadTimeout()
public void set_LoadTimeout(int value)
public string get_SoundLocation()
public void set_SoundLocation(string value)
public Stream get_Stream()
public void set_Stream(Stream value)
public object get_Tag()
public void set_Tag(object value)
public void add_LoadCompleted(AsyncCompletedEventHandler value)
public void remove_LoadCompleted(AsyncCompletedEventHandler value)
public void add_SoundLocationChanged(EventHandler value)
public void remove_SoundLocationChanged(EventHandler value)
public void add_StreamChanged(EventHandler value)
public void remove_StreamChanged(EventHandler value)
}
public System.Media.SystemSound : object {
private Stream resource
internal void .ctor(string tag)
public void Play()
}
public System.Media.SystemSounds : object {
public SystemSound Asterisk
public SystemSound Beep
public SystemSound Exclamation
public SystemSound Hand
public SystemSound Question
public SystemSound get_Asterisk()
public SystemSound get_Beep()
public SystemSound get_Exclamation()
public SystemSound get_Hand()
public SystemSound get_Question()
}
internal System.MonoToolsLocator : object {
public string Mono
public string McsCSharpCompiler
public string VBCompiler
public string AssemblyLinker
private UInt32 GetModuleFileName(IntPtr hModule, StringBuilder lpFilename, int nSize)
}
public System.Net.AuthenticationManager : object {
private ArrayList modules
private object locker
private ICredentialPolicy credential_policy
public ICredentialPolicy CredentialPolicy
public StringDictionary CustomTargetNameDictionary
public IEnumerator RegisteredModules
internal bool OSSupportsExtendedProtection
private void EnsureModules()
public ICredentialPolicy get_CredentialPolicy()
public void set_CredentialPolicy(ICredentialPolicy value)
private Exception GetMustImplement()
public StringDictionary get_CustomTargetNameDictionary()
public IEnumerator get_RegisteredModules()
internal bool get_OSSupportsExtendedProtection()
internal void Clear()
public Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials)
private Authorization DoAuthenticate(string challenge, WebRequest request, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest request, ICredentials credentials)
public void Register(IAuthenticationModule authenticationModule)
public void Unregister(IAuthenticationModule authenticationModule)
public void Unregister(string authenticationScheme)
private void DoUnregister(string authenticationScheme, bool throwEx)
}
public System.Net.AuthenticationSchemes : Enum {
public int value__
public AuthenticationSchemes None
public AuthenticationSchemes Digest
public AuthenticationSchemes Negotiate
public AuthenticationSchemes Ntlm
public AuthenticationSchemes Basic
public AuthenticationSchemes Anonymous
public AuthenticationSchemes IntegratedWindowsAuthentication
}
public System.Net.AuthenticationSchemeSelector : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public AuthenticationSchemes Invoke(HttpListenerRequest httpRequest)
public IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object)
public AuthenticationSchemes EndInvoke(IAsyncResult result)
}
public System.Net.Authorization : object {
private string m_Message
private bool m_Complete
private String[] m_ProtectionRealm
private string m_ConnectionGroupId
private bool m_MutualAuth
internal string ModuleAuthenticationType
public string Message
public string ConnectionGroupId
public bool Complete
public String[] ProtectionRealm
public bool MutuallyAuthenticated
public void .ctor(string token)
public void .ctor(string token, bool finished)
public void .ctor(string token, bool finished, string connectionGroupId)
internal void .ctor(string token, bool finished, string connectionGroupId, bool mutualAuth)
public string get_Message()
public string get_ConnectionGroupId()
public bool get_Complete()
internal void SetComplete(bool complete)
public String[] get_ProtectionRealm()
public void set_ProtectionRealm(String[] value)
public bool get_MutuallyAuthenticated()
public void set_MutuallyAuthenticated(bool value)
}
internal System.Net.AutoWebProxyScriptEngine : object {
private Uri <AutomaticConfigurationScript>k__BackingField
private bool <AutomaticallyDetectSettings>k__BackingField
public Uri AutomaticConfigurationScript
public bool AutomaticallyDetectSettings
public void .ctor(WebProxy proxy, bool useRegistry)
public Uri get_AutomaticConfigurationScript()
public void set_AutomaticConfigurationScript(Uri value)
public bool get_AutomaticallyDetectSettings()
public void set_AutomaticallyDetectSettings(bool value)
public bool GetProxies(Uri destination, IList`1& proxyList)
public bool GetProxies(Uri destination, IList`1& proxyList, Int32& syncStatus)
public void Close()
public void Abort(Int32& syncStatus)
public void CheckForChanges()
public WebProxyData GetWebProxyData()
private WebProxyData ReadEnvVariables()
private bool IsWindows()
private WebProxyData InitializeRegistryGlobalProxy()
private Uri ToUri(string address)
private ArrayList CreateBypassList(ArrayList al)
}
internal System.Net.Base64Stream : DelegatedStream {
private Byte[] s_base64DecodeMap
private Byte[] s_base64EncodeMap
private int _lineLength
private Base64WriteStateInfo _writeState
private ReadStateInfo _readState
private int SizeOfBase64EncodedChar
private byte InvalidBase64Value
private ReadStateInfo ReadState
internal Base64WriteStateInfo WriteState
internal void .ctor(Stream stream, Base64WriteStateInfo writeStateInfo)
internal void .ctor(Base64WriteStateInfo writeStateInfo)
private ReadStateInfo get_ReadState()
internal Base64WriteStateInfo get_WriteState()
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
internal int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF)
public Stream GetStream()
public string GetEncodedString()
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
private void FlushInternal()
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
}
internal System.Net.BaseLoggingObject : object {
internal void EnterFunc(string funcname)
internal void LeaveFunc(string funcname)
internal void DumpArrayToConsole()
internal void PrintLine(string msg)
internal void DumpArray(bool shouldClose)
internal void DumpArrayToFile(bool shouldClose)
internal void Flush()
internal void Flush(bool close)
internal void LoggingMonitorTick()
internal void Dump(Byte[] buffer)
internal void Dump(Byte[] buffer, int length)
internal void Dump(Byte[] buffer, int offset, int length)
internal void Dump(IntPtr pBuffer, int offset, int length)
}
internal System.Net.BasicClient : object {
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
private Byte[] GetBytes(string str)
private Authorization InternalAuthenticate(WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
public System.Net.BindIPEndPoint : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public IPEndPoint Invoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount)
public IAsyncResult BeginInvoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount, AsyncCallback callback, object object)
public IPEndPoint EndInvoke(IAsyncResult result)
}
internal System.Net.Blob : ValueType {
public int cbSize
public int pBlobData
}
internal System.Net.BufferedReadStream : WebReadStream {
private BufferOffsetSize readBuffer
public void .ctor(WebOperation operation, Stream innerStream, BufferOffsetSize readBuffer)
protected Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
internal bool TryReadFromBuffer(Byte[] buffer, int offset, int size, Int32& result)
}
internal System.Net.BufferOffsetSize : object {
internal Byte[] Buffer
internal int Offset
internal int Size
internal void .ctor(Byte[] buffer, int offset, int size, bool copyBuffer)
internal void .ctor(Byte[] buffer, bool copyBuffer)
}
internal System.Net.BufferType : Enum {
public int value__
public BufferType Empty
public BufferType Data
public BufferType Token
public BufferType Parameters
public BufferType Missing
public BufferType Extra
public BufferType Trailer
public BufferType Header
public BufferType Padding
public BufferType Stream
public BufferType ChannelBindings
public BufferType TargetHost
public BufferType ReadOnlyFlag
public BufferType ReadOnlyWithChecksum
}
public System.Net.Cache.HttpCacheAgeControl : Enum {
public int value__
public HttpCacheAgeControl None
public HttpCacheAgeControl MinFresh
public HttpCacheAgeControl MaxAge
public HttpCacheAgeControl MaxStale
public HttpCacheAgeControl MaxAgeAndMinFresh
public HttpCacheAgeControl MaxAgeAndMaxStale
}
public System.Net.Cache.HttpRequestCacheLevel : Enum {
public int value__
public HttpRequestCacheLevel Default
public HttpRequestCacheLevel BypassCache
public HttpRequestCacheLevel CacheOnly
public HttpRequestCacheLevel CacheIfAvailable
public HttpRequestCacheLevel Revalidate
public HttpRequestCacheLevel Reload
public HttpRequestCacheLevel NoCacheNoStore
public HttpRequestCacheLevel CacheOrNextCacheOnly
public HttpRequestCacheLevel Refresh
}
public System.Net.Cache.HttpRequestCachePolicy : RequestCachePolicy {
internal HttpRequestCachePolicy BypassCache
private HttpRequestCacheLevel m_Level
private DateTime m_LastSyncDateUtc
private TimeSpan m_MaxAge
private TimeSpan m_MinFresh
private TimeSpan m_MaxStale
public HttpRequestCacheLevel Level
public DateTime CacheSyncDate
internal DateTime InternalCacheSyncDateUtc
public TimeSpan MaxAge
public TimeSpan MinFresh
public TimeSpan MaxStale
public void .ctor(HttpRequestCacheLevel level)
public void .ctor(HttpCacheAgeControl cacheAgeControl, TimeSpan ageOrFreshOrStale)
public void .ctor(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale)
public void .ctor(DateTime cacheSyncDate)
public void .ctor(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale, DateTime cacheSyncDate)
public HttpRequestCacheLevel get_Level()
public DateTime get_CacheSyncDate()
internal DateTime get_InternalCacheSyncDateUtc()
public TimeSpan get_MaxAge()
public TimeSpan get_MinFresh()
public TimeSpan get_MaxStale()
public string ToString()
private RequestCacheLevel MapLevel(HttpRequestCacheLevel level)
}
internal System.Net.Cache.RequestCache : object {
internal Char[] LineSplits
private bool _IsPrivateCache
private bool _CanWrite
internal bool IsPrivateCache
internal bool CanWrite
protected void .ctor(bool isPrivateCache, bool canWrite)
internal bool get_IsPrivateCache()
internal bool get_CanWrite()
internal Stream Retrieve(string key, RequestCacheEntry& cacheEntry)
internal Stream Store(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata)
internal void Remove(string key)
internal void Update(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata)
internal bool TryRetrieve(string key, RequestCacheEntry& cacheEntry, Stream& readStream)
internal bool TryStore(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata, Stream& writeStream)
internal bool TryRemove(string key)
internal bool TryUpdate(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata)
internal void UnlockEntry(Stream retrieveStream)
}
internal System.Net.Cache.RequestCacheBinding : object {
private RequestCache m_RequestCache
private RequestCacheValidator m_CacheValidator
private RequestCachePolicy m_Policy
internal RequestCache Cache
internal RequestCacheValidator Validator
internal RequestCachePolicy Policy
internal void .ctor(RequestCache requestCache, RequestCacheValidator cacheValidator, RequestCachePolicy policy)
internal RequestCache get_Cache()
internal RequestCacheValidator get_Validator()
internal RequestCachePolicy get_Policy()
}
internal System.Net.Cache.RequestCacheEntry : object {
private bool m_IsPrivateEntry
private long m_StreamSize
private DateTime m_ExpiresUtc
private int m_HitCount
private DateTime m_LastAccessedUtc
private DateTime m_LastModifiedUtc
private DateTime m_LastSynchronizedUtc
private TimeSpan m_MaxStale
private int m_UsageCount
private bool m_IsPartialEntry
private StringCollection m_EntryMetadata
private StringCollection m_SystemMetadata
internal bool IsPrivateEntry
internal long StreamSize
internal DateTime ExpiresUtc
internal DateTime LastAccessedUtc
internal DateTime LastModifiedUtc
internal DateTime LastSynchronizedUtc
internal TimeSpan MaxStale
internal int HitCount
internal int UsageCount
internal bool IsPartialEntry
internal StringCollection EntryMetadata
internal StringCollection SystemMetadata
internal bool get_IsPrivateEntry()
internal void set_IsPrivateEntry(bool value)
internal long get_StreamSize()
internal void set_StreamSize(long value)
internal DateTime get_ExpiresUtc()
internal void set_ExpiresUtc(DateTime value)
internal DateTime get_LastAccessedUtc()
internal void set_LastAccessedUtc(DateTime value)
internal DateTime get_LastModifiedUtc()
internal void set_LastModifiedUtc(DateTime value)
internal DateTime get_LastSynchronizedUtc()
internal void set_LastSynchronizedUtc(DateTime value)
internal TimeSpan get_MaxStale()
internal void set_MaxStale(TimeSpan value)
internal int get_HitCount()
internal void set_HitCount(int value)
internal int get_UsageCount()
internal void set_UsageCount(int value)
internal bool get_IsPartialEntry()
internal void set_IsPartialEntry(bool value)
internal StringCollection get_EntryMetadata()
internal void set_EntryMetadata(StringCollection value)
internal StringCollection get_SystemMetadata()
internal void set_SystemMetadata(StringCollection value)
internal string ToString(bool verbose)
}
public System.Net.Cache.RequestCacheLevel : Enum {
public int value__
public RequestCacheLevel Default
public RequestCacheLevel BypassCache
public RequestCacheLevel CacheOnly
public RequestCacheLevel CacheIfAvailable
public RequestCacheLevel Revalidate
public RequestCacheLevel Reload
public RequestCacheLevel NoCacheNoStore
}
internal System.Net.Cache.RequestCacheManager : object {
private RequestCachingSectionInternal modreq(System.Runtime.CompilerServices.IsVolatile) s_CacheConfigSettings
private RequestCacheBinding s_BypassCacheBinding
private RequestCacheBinding modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultGlobalBinding
private RequestCacheBinding modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultHttpBinding
private RequestCacheBinding modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultFtpBinding
internal bool IsCachingEnabled
internal RequestCacheBinding GetBinding(string internedScheme)
internal bool get_IsCachingEnabled()
internal void SetBinding(string uriScheme, RequestCacheBinding binding)
private void LoadConfigSettings()
}
public System.Net.Cache.RequestCachePolicy : object {
private RequestCacheLevel m_Level
public RequestCacheLevel Level
public void .ctor(RequestCacheLevel level)
public RequestCacheLevel get_Level()
public string ToString()
}
internal System.Net.Cache.RequestCacheProtocol : object {
public void .ctor(object arg1, object arg2)
}
internal System.Net.Cache.RequestCacheValidator : object {
public object CreateValidator()
}
internal System.Net.Cache.RequestCachingSectionInternal : object {
public bool DisableAllCaching
}
internal System.Net.CachedTransportContext : TransportContext {
private ChannelBinding binding
internal void .ctor(ChannelBinding binding)
public ChannelBinding GetChannelBinding(ChannelBindingKind kind)
}
internal System.Net.CallbackClosure : object {
private AsyncCallback _savedCallback
private ExecutionContext _savedContext
internal AsyncCallback AsyncCallback
internal ExecutionContext Context
internal void .ctor(ExecutionContext context, AsyncCallback callback)
internal bool IsCompatible(AsyncCallback callback)
internal AsyncCallback get_AsyncCallback()
internal ExecutionContext get_Context()
}
internal System.Net.CaseInsensitiveAscii : object {
internal CaseInsensitiveAscii StaticInstance
internal Byte[] AsciiToLower
public int GetHashCode(object myObject)
public int Compare(object firstObject, object secondObject)
private int FastGetHashCode(string myString)
public bool Equals(object firstObject, object secondObject)
}
internal System.Net.CertificateEncoding : Enum {
public int value__
public CertificateEncoding Zero
public CertificateEncoding X509AsnEncoding
public CertificateEncoding X509NdrEncoding
public CertificateEncoding Pkcs7AsnEncoding
public CertificateEncoding Pkcs7NdrEncoding
public CertificateEncoding AnyAsnEncoding
}
internal System.Net.CertificateProblem : Enum {
public int value__
public CertificateProblem OK
public CertificateProblem TrustNOSIGNATURE
public CertificateProblem CertEXPIRED
public CertificateProblem CertVALIDITYPERIODNESTING
public CertificateProblem CertROLE
public CertificateProblem CertPATHLENCONST
public CertificateProblem CertCRITICAL
public CertificateProblem CertPURPOSE
public CertificateProblem CertISSUERCHAINING
public CertificateProblem CertMALFORMED
public CertificateProblem CertUNTRUSTEDROOT
public CertificateProblem CertCHAINING
public CertificateProblem CertREVOKED
public CertificateProblem CertUNTRUSTEDTESTROOT
public CertificateProblem CertREVOCATION_FAILURE
public CertificateProblem CertCN_NO_MATCH
public CertificateProblem CertWRONG_USAGE
public CertificateProblem TrustEXPLICITDISTRUST
public CertificateProblem CertUNTRUSTEDCA
public CertificateProblem CertINVALIDPOLICY
public CertificateProblem CertINVALIDNAME
public CertificateProblem CryptNOREVOCATIONCHECK
public CertificateProblem CryptREVOCATIONOFFLINE
public CertificateProblem TrustSYSTEMERROR
public CertificateProblem TrustNOSIGNERCERT
public CertificateProblem TrustCOUNTERSIGNER
public CertificateProblem TrustCERTSIGNATURE
public CertificateProblem TrustTIMESTAMP
public CertificateProblem TrustBADDIGEST
public CertificateProblem TrustBASICCONSTRAINTS
public CertificateProblem TrustFINANCIALCRITERIA
}
internal System.Net.CertUsage : Enum {
public int value__
public CertUsage MatchTypeAnd
public CertUsage MatchTypeOr
}
internal System.Net.ChainPolicyType : Enum {
public int value__
public ChainPolicyType Base
public ChainPolicyType Authenticode
public ChainPolicyType Authenticode_TS
public ChainPolicyType SSL
public ChainPolicyType BasicConstraints
public ChainPolicyType NtAuth
}
internal System.Net.ChunkedInputStream : RequestStream {
private bool disposed
private MonoChunkParser decoder
private HttpListenerContext context
private bool no_more_data
public MonoChunkParser Decoder
public void .ctor(HttpListenerContext context, Stream stream, Byte[] buffer, int offset, int length)
public MonoChunkParser get_Decoder()
public void set_Decoder(MonoChunkParser value)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
private void OnRead(IAsyncResult base_ares)
public int EndRead(IAsyncResult ares)
public void Close()
}
internal System.Net.ClosableStream : DelegatedStream {
private EventHandler _onClose
private int _closed
internal void .ctor(Stream stream, EventHandler onClose)
public void Close()
}
internal System.Net.CloseExState : Enum {
public int value__
public CloseExState Normal
public CloseExState Abort
public CloseExState Silent
}
internal System.Net.CommandStream : NetworkStreamWrapper {
private AsyncCallback s_writeCallbackDelegate
private AsyncCallback s_readCallbackDelegate
private bool _recoverableFailure
protected WebRequest _request
protected bool _isAsync
private bool _aborted
protected PipelineEntry[] _commands
protected int _index
private bool _doRead
private bool _doSend
private ResponseDescription _currentResponseDescription
protected string _abortReason
private int WaitingForPipeline
private int CompletedPipeline
private string _buffer
private Encoding _encoding
private Decoder _decoder
internal bool RecoverableFailure
protected Encoding Encoding
internal void .ctor(TcpClient client)
internal void Abort(Exception e)
protected void Dispose(bool disposing)
protected void InvokeRequestCallback(object obj)
internal bool get_RecoverableFailure()
protected void MarkAsRecoverableFailure()
internal Stream SubmitRequest(WebRequest request, bool isAsync, bool readInitalResponseOnConnect)
protected void ClearState()
protected PipelineEntry[] BuildCommandsList(WebRequest request)
protected Exception GenerateException(string message, WebExceptionStatus status, Exception innerException)
protected Exception GenerateException(FtpStatusCode code, string statusDescription, Exception innerException)
protected void InitCommandPipeline(WebRequest request, PipelineEntry[] commands, bool isAsync)
internal void CheckContinuePipeline()
protected Stream ContinueCommandPipeline()
private bool PostSendCommandProcessing(Stream& stream)
private bool PostReadCommandProcessing(Stream& stream)
protected PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream)
private void ReadCallback(IAsyncResult asyncResult)
private void WriteCallback(IAsyncResult asyncResult)
protected Encoding get_Encoding()
protected void set_Encoding(Encoding value)
protected bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength)
private ResponseDescription ReceiveCommandResponse()
private void ReceiveCommandResponseCallback(ReceiveState state, int bytesRead)
}
internal System.Net.Comparer : object {
private int System.Collections.IComparer.Compare(object ol, object or)
}
public System.Net.Configuration.AuthenticationModuleElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty typeProp
protected ConfigurationPropertyCollection Properties
public string Type
public void .ctor(string typeName)
protected ConfigurationPropertyCollection get_Properties()
public string get_Type()
public void set_Type(string value)
}
public System.Net.Configuration.AuthenticationModuleElementCollection : ConfigurationElementCollection {
public AuthenticationModuleElement Item
public AuthenticationModuleElement Item
public AuthenticationModuleElement get_Item(int index)
public void set_Item(int index, AuthenticationModuleElement value)
public AuthenticationModuleElement get_Item(string name)
public void set_Item(string name, AuthenticationModuleElement value)
public void Add(AuthenticationModuleElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(AuthenticationModuleElement element)
public void Remove(AuthenticationModuleElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
public System.Net.Configuration.AuthenticationModulesSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty authenticationModulesProp
protected ConfigurationPropertyCollection Properties
public AuthenticationModuleElementCollection AuthenticationModules
protected ConfigurationPropertyCollection get_Properties()
public AuthenticationModuleElementCollection get_AuthenticationModules()
protected void PostDeserialize()
protected void InitializeDefault()
}
public System.Net.Configuration.BypassElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty addressProp
public string Address
protected ConfigurationPropertyCollection Properties
public void .ctor(string address)
public string get_Address()
public void set_Address(string value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.BypassElementCollection : ConfigurationElementCollection {
public BypassElement Item
public BypassElement Item
protected bool ThrowOnDuplicate
public BypassElement get_Item(int index)
public void set_Item(int index, BypassElement value)
public BypassElement get_Item(string name)
public void set_Item(string name, BypassElement value)
protected bool get_ThrowOnDuplicate()
public void Add(BypassElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(BypassElement element)
public void Remove(BypassElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
internal System.Net.Configuration.ConnectionManagementData : object {
private Hashtable data
private int defaultMaxConnections
public Hashtable Data
public void .ctor(object parent)
public void Add(string address, string nconns)
public void Add(string address, int nconns)
public void Remove(string address)
public void Clear()
public UInt32 GetMaxConnections(string hostOrIP)
public Hashtable get_Data()
}
public System.Net.Configuration.ConnectionManagementElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty addressProp
private ConfigurationProperty maxConnectionProp
public string Address
public int MaxConnection
protected ConfigurationPropertyCollection Properties
public void .ctor(string address, int maxConnection)
public string get_Address()
public void set_Address(string value)
public int get_MaxConnection()
public void set_MaxConnection(int value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.ConnectionManagementElementCollection : ConfigurationElementCollection {
public ConnectionManagementElement Item
public ConnectionManagementElement Item
public ConnectionManagementElement get_Item(int index)
public void set_Item(int index, ConnectionManagementElement value)
public ConnectionManagementElement get_Item(string name)
public void set_Item(string name, ConnectionManagementElement value)
public void Add(ConnectionManagementElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(ConnectionManagementElement element)
public void Remove(ConnectionManagementElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
internal System.Net.Configuration.ConnectionManagementHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Net.Configuration.ConnectionManagementSection : ConfigurationSection {
private ConfigurationProperty connectionManagementProp
private ConfigurationPropertyCollection properties
public ConnectionManagementElementCollection ConnectionManagement
protected ConfigurationPropertyCollection Properties
public ConnectionManagementElementCollection get_ConnectionManagement()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Net.Configuration.DefaultProxyHandler : object {
public object Create(object parent, object configContext, XmlNode section)
private void FillByPassList(XmlNode node, WebProxy proxy)
}
public System.Net.Configuration.DefaultProxySection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty bypassListProp
private ConfigurationProperty enabledProp
private ConfigurationProperty moduleProp
private ConfigurationProperty proxyProp
private ConfigurationProperty useDefaultCredentialsProp
public BypassElementCollection BypassList
public bool Enabled
public ModuleElement Module
public ProxyElement Proxy
public bool UseDefaultCredentials
protected ConfigurationPropertyCollection Properties
public BypassElementCollection get_BypassList()
public bool get_Enabled()
public void set_Enabled(bool value)
public ModuleElement get_Module()
public ProxyElement get_Proxy()
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
protected void Reset(ConfigurationElement parentElement)
}
internal System.Net.Configuration.DefaultProxySectionInternal : object {
private IWebProxy webProxy
private object classSyncObject
internal object ClassSyncObject
internal IWebProxy WebProxy
private IWebProxy GetDefaultProxy_UsingOldMonoCode()
private IWebProxy GetSystemWebProxy()
internal object get_ClassSyncObject()
internal DefaultProxySectionInternal GetSection()
internal IWebProxy get_WebProxy()
}
public System.Net.Configuration.FtpCachePolicyElement : ConfigurationElement {
private ConfigurationProperty policyLevelProp
private ConfigurationPropertyCollection properties
public RequestCacheLevel PolicyLevel
protected ConfigurationPropertyCollection Properties
public RequestCacheLevel get_PolicyLevel()
public void set_PolicyLevel(RequestCacheLevel value)
protected ConfigurationPropertyCollection get_Properties()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
protected void Reset(ConfigurationElement parentElement)
}
internal System.Net.Configuration.HandlersUtil : object {
internal string ExtractAttributeValue(string attKey, XmlNode node)
internal string ExtractAttributeValue(string attKey, XmlNode node, bool optional)
internal void ThrowException(string msg, XmlNode node)
}
public System.Net.Configuration.HttpCachePolicyElement : ConfigurationElement {
private ConfigurationProperty maximumAgeProp
private ConfigurationProperty maximumStaleProp
private ConfigurationProperty minimumFreshProp
private ConfigurationProperty policyLevelProp
private ConfigurationPropertyCollection properties
public TimeSpan MaximumAge
public TimeSpan MaximumStale
public TimeSpan MinimumFresh
public HttpRequestCacheLevel PolicyLevel
protected ConfigurationPropertyCollection Properties
public TimeSpan get_MaximumAge()
public void set_MaximumAge(TimeSpan value)
public TimeSpan get_MaximumStale()
public void set_MaximumStale(TimeSpan value)
public TimeSpan get_MinimumFresh()
public void set_MinimumFresh(TimeSpan value)
public HttpRequestCacheLevel get_PolicyLevel()
public void set_PolicyLevel(HttpRequestCacheLevel value)
protected ConfigurationPropertyCollection get_Properties()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
protected void Reset(ConfigurationElement parentElement)
}
public System.Net.Configuration.HttpListenerElement : ConfigurationElement {
public HttpListenerTimeoutsElement Timeouts
public bool UnescapeRequestUrl
public HttpListenerTimeoutsElement get_Timeouts()
public bool get_UnescapeRequestUrl()
}
public System.Net.Configuration.HttpListenerTimeoutsElement : ConfigurationElement {
public TimeSpan DrainEntityBody
public TimeSpan EntityBody
public TimeSpan HeaderWait
public TimeSpan IdleConnection
public long MinSendBytesPerSecond
public TimeSpan RequestQueue
public TimeSpan get_DrainEntityBody()
public TimeSpan get_EntityBody()
public TimeSpan get_HeaderWait()
public TimeSpan get_IdleConnection()
public long get_MinSendBytesPerSecond()
public TimeSpan get_RequestQueue()
}
public System.Net.Configuration.HttpWebRequestElement : ConfigurationElement {
private ConfigurationProperty maximumErrorResponseLengthProp
private ConfigurationProperty maximumResponseHeadersLengthProp
private ConfigurationProperty maximumUnauthorizedUploadLengthProp
private ConfigurationProperty useUnsafeHeaderParsingProp
private ConfigurationPropertyCollection properties
public int MaximumErrorResponseLength
public int MaximumResponseHeadersLength
public int MaximumUnauthorizedUploadLength
public bool UseUnsafeHeaderParsing
protected ConfigurationPropertyCollection Properties
public int get_MaximumErrorResponseLength()
public void set_MaximumErrorResponseLength(int value)
public int get_MaximumResponseHeadersLength()
public void set_MaximumResponseHeadersLength(int value)
public int get_MaximumUnauthorizedUploadLength()
public void set_MaximumUnauthorizedUploadLength(int value)
public bool get_UseUnsafeHeaderParsing()
public void set_UseUnsafeHeaderParsing(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
}
public System.Net.Configuration.Ipv6Element : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty enabledProp
public bool Enabled
protected ConfigurationPropertyCollection Properties
public bool get_Enabled()
public void set_Enabled(bool value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.MailSettingsSectionGroup : ConfigurationSectionGroup {
public SmtpSection Smtp
public SmtpSection get_Smtp()
}
public System.Net.Configuration.ModuleElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty typeProp
protected ConfigurationPropertyCollection Properties
public string Type
protected ConfigurationPropertyCollection get_Properties()
public string get_Type()
public void set_Type(string value)
}
internal System.Net.Configuration.NetAuthenticationModuleHandler : object {
public object Create(object parent, object configContext, XmlNode section)
private IAuthenticationModule CreateInstance(string typeName, XmlNode node)
}
internal System.Net.Configuration.NetConfigurationHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Net.Configuration.NetSectionGroup : ConfigurationSectionGroup {
public AuthenticationModulesSection AuthenticationModules
public ConnectionManagementSection ConnectionManagement
public DefaultProxySection DefaultProxy
public MailSettingsSectionGroup MailSettings
public RequestCachingSection RequestCaching
public SettingsSection Settings
public WebRequestModulesSection WebRequestModules
public AuthenticationModulesSection get_AuthenticationModules()
public ConnectionManagementSection get_ConnectionManagement()
public DefaultProxySection get_DefaultProxy()
public MailSettingsSectionGroup get_MailSettings()
public RequestCachingSection get_RequestCaching()
public SettingsSection get_Settings()
public WebRequestModulesSection get_WebRequestModules()
public NetSectionGroup GetSectionGroup(Configuration config)
}
public System.Net.Configuration.PerformanceCountersElement : ConfigurationElement {
private ConfigurationProperty enabledProp
private ConfigurationPropertyCollection properties
public bool Enabled
protected ConfigurationPropertyCollection Properties
public bool get_Enabled()
public void set_Enabled(bool value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.ProxyElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty autoDetectProp
private ConfigurationProperty bypassOnLocalProp
private ConfigurationProperty proxyAddressProp
private ConfigurationProperty scriptLocationProp
private ConfigurationProperty useSystemDefaultProp
public AutoDetectValues AutoDetect
public BypassOnLocalValues BypassOnLocal
public Uri ProxyAddress
public Uri ScriptLocation
public UseSystemDefaultValues UseSystemDefault
protected ConfigurationPropertyCollection Properties
public AutoDetectValues get_AutoDetect()
public void set_AutoDetect(AutoDetectValues value)
public BypassOnLocalValues get_BypassOnLocal()
public void set_BypassOnLocal(BypassOnLocalValues value)
public Uri get_ProxyAddress()
public void set_ProxyAddress(Uri value)
public Uri get_ScriptLocation()
public void set_ScriptLocation(Uri value)
public UseSystemDefaultValues get_UseSystemDefault()
public void set_UseSystemDefault(UseSystemDefaultValues value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.RequestCachingSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty defaultFtpCachePolicyProp
private ConfigurationProperty defaultHttpCachePolicyProp
private ConfigurationProperty defaultPolicyLevelProp
private ConfigurationProperty disableAllCachingProp
private ConfigurationProperty isPrivateCacheProp
private ConfigurationProperty unspecifiedMaximumAgeProp
public FtpCachePolicyElement DefaultFtpCachePolicy
public HttpCachePolicyElement DefaultHttpCachePolicy
public RequestCacheLevel DefaultPolicyLevel
public bool DisableAllCaching
public bool IsPrivateCache
public TimeSpan UnspecifiedMaximumAge
protected ConfigurationPropertyCollection Properties
public FtpCachePolicyElement get_DefaultFtpCachePolicy()
public HttpCachePolicyElement get_DefaultHttpCachePolicy()
public RequestCacheLevel get_DefaultPolicyLevel()
public void set_DefaultPolicyLevel(RequestCacheLevel value)
public bool get_DisableAllCaching()
public void set_DisableAllCaching(bool value)
public bool get_IsPrivateCache()
public void set_IsPrivateCache(bool value)
public TimeSpan get_UnspecifiedMaximumAge()
public void set_UnspecifiedMaximumAge(TimeSpan value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
}
public System.Net.Configuration.ServicePointManagerElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty checkCertificateNameProp
private ConfigurationProperty checkCertificateRevocationListProp
private ConfigurationProperty dnsRefreshTimeoutProp
private ConfigurationProperty enableDnsRoundRobinProp
private ConfigurationProperty expect100ContinueProp
private ConfigurationProperty useNagleAlgorithmProp
public bool CheckCertificateName
public bool CheckCertificateRevocationList
public int DnsRefreshTimeout
public bool EnableDnsRoundRobin
public bool Expect100Continue
public bool UseNagleAlgorithm
protected ConfigurationPropertyCollection Properties
public EncryptionPolicy EncryptionPolicy
public bool get_CheckCertificateName()
public void set_CheckCertificateName(bool value)
public bool get_CheckCertificateRevocationList()
public void set_CheckCertificateRevocationList(bool value)
public int get_DnsRefreshTimeout()
public void set_DnsRefreshTimeout(int value)
public bool get_EnableDnsRoundRobin()
public void set_EnableDnsRoundRobin(bool value)
public bool get_Expect100Continue()
public void set_Expect100Continue(bool value)
public bool get_UseNagleAlgorithm()
public void set_UseNagleAlgorithm(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
public EncryptionPolicy get_EncryptionPolicy()
public void set_EncryptionPolicy(EncryptionPolicy value)
}
public System.Net.Configuration.SettingsSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty httpWebRequestProp
private ConfigurationProperty ipv6Prop
private ConfigurationProperty performanceCountersProp
private ConfigurationProperty servicePointManagerProp
private ConfigurationProperty webProxyScriptProp
private ConfigurationProperty socketProp
public HttpWebRequestElement HttpWebRequest
public Ipv6Element Ipv6
public PerformanceCountersElement PerformanceCounters
public ServicePointManagerElement ServicePointManager
public SocketElement Socket
public WebProxyScriptElement WebProxyScript
protected ConfigurationPropertyCollection Properties
public HttpListenerElement HttpListener
public WebUtilityElement WebUtility
public WindowsAuthenticationElement WindowsAuthentication
public HttpWebRequestElement get_HttpWebRequest()
public Ipv6Element get_Ipv6()
public PerformanceCountersElement get_PerformanceCounters()
public ServicePointManagerElement get_ServicePointManager()
public SocketElement get_Socket()
public WebProxyScriptElement get_WebProxyScript()
protected ConfigurationPropertyCollection get_Properties()
public HttpListenerElement get_HttpListener()
public WebUtilityElement get_WebUtility()
public WindowsAuthenticationElement get_WindowsAuthentication()
}
internal System.Net.Configuration.SettingsSectionInternal : object {
private SettingsSectionInternal instance
internal UnicodeEncodingConformance WebUtilityUnicodeEncodingConformance
internal UnicodeDecodingConformance WebUtilityUnicodeDecodingConformance
internal bool HttpListenerUnescapeRequestUrl
internal IPProtectionLevel IPProtectionLevel
private bool <UseNagleAlgorithm>k__BackingField
private bool <Expect100Continue>k__BackingField
private bool <CheckCertificateName>k__BackingField
private int <DnsRefreshTimeout>k__BackingField
private bool <EnableDnsRoundRobin>k__BackingField
private bool <CheckCertificateRevocationList>k__BackingField
private EncryptionPolicy <EncryptionPolicy>k__BackingField
internal SettingsSectionInternal Section
internal bool UseNagleAlgorithm
internal bool Expect100Continue
internal bool CheckCertificateName
internal int DnsRefreshTimeout
internal bool EnableDnsRoundRobin
internal bool CheckCertificateRevocationList
internal EncryptionPolicy EncryptionPolicy
internal bool Ipv6Enabled
internal SettingsSectionInternal get_Section()
internal bool get_UseNagleAlgorithm()
internal void set_UseNagleAlgorithm(bool value)
internal bool get_Expect100Continue()
internal void set_Expect100Continue(bool value)
internal bool get_CheckCertificateName()
private void set_CheckCertificateName(bool value)
internal int get_DnsRefreshTimeout()
internal void set_DnsRefreshTimeout(int value)
internal bool get_EnableDnsRoundRobin()
internal void set_EnableDnsRoundRobin(bool value)
internal bool get_CheckCertificateRevocationList()
internal void set_CheckCertificateRevocationList(bool value)
internal EncryptionPolicy get_EncryptionPolicy()
private void set_EncryptionPolicy(EncryptionPolicy value)
internal bool get_Ipv6Enabled()
}
public System.Net.Configuration.SmtpNetworkElement : ConfigurationElement {
public bool DefaultCredentials
public string Host
public string Password
public int Port
public string UserName
public string TargetName
public bool EnableSsl
protected ConfigurationPropertyCollection Properties
public string ClientDomain
public bool get_DefaultCredentials()
public void set_DefaultCredentials(bool value)
public string get_Host()
public void set_Host(string value)
public string get_Password()
public void set_Password(string value)
public int get_Port()
public void set_Port(int value)
public string get_UserName()
public void set_UserName(string value)
public string get_TargetName()
public void set_TargetName(string value)
public bool get_EnableSsl()
public void set_EnableSsl(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
public string get_ClientDomain()
public void set_ClientDomain(string value)
}
public System.Net.Configuration.SmtpSection : ConfigurationSection {
public SmtpDeliveryMethod DeliveryMethod
public SmtpDeliveryFormat DeliveryFormat
public string From
public SmtpNetworkElement Network
public SmtpSpecifiedPickupDirectoryElement SpecifiedPickupDirectory
protected ConfigurationPropertyCollection Properties
public SmtpDeliveryMethod get_DeliveryMethod()
public void set_DeliveryMethod(SmtpDeliveryMethod value)
public SmtpDeliveryFormat get_DeliveryFormat()
public void set_DeliveryFormat(SmtpDeliveryFormat value)
public string get_From()
public void set_From(string value)
public SmtpNetworkElement get_Network()
public SmtpSpecifiedPickupDirectoryElement get_SpecifiedPickupDirectory()
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.SmtpSpecifiedPickupDirectoryElement : ConfigurationElement {
private ConfigurationProperty pickupDirectoryLocationProp
private ConfigurationPropertyCollection properties
public string PickupDirectoryLocation
protected ConfigurationPropertyCollection Properties
public string get_PickupDirectoryLocation()
public void set_PickupDirectoryLocation(string value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.SocketElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty alwaysUseCompletionPortsForAcceptProp
private ConfigurationProperty alwaysUseCompletionPortsForConnectProp
public bool AlwaysUseCompletionPortsForAccept
public bool AlwaysUseCompletionPortsForConnect
protected ConfigurationPropertyCollection Properties
public IPProtectionLevel IPProtectionLevel
public bool get_AlwaysUseCompletionPortsForAccept()
public void set_AlwaysUseCompletionPortsForAccept(bool value)
public bool get_AlwaysUseCompletionPortsForConnect()
public void set_AlwaysUseCompletionPortsForConnect(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
public IPProtectionLevel get_IPProtectionLevel()
public void set_IPProtectionLevel(IPProtectionLevel value)
}
public System.Net.Configuration.UnicodeDecodingConformance : Enum {
public int value__
public UnicodeDecodingConformance Auto
public UnicodeDecodingConformance Strict
public UnicodeDecodingConformance Compat
public UnicodeDecodingConformance Loose
}
public System.Net.Configuration.UnicodeEncodingConformance : Enum {
public int value__
public UnicodeEncodingConformance Auto
public UnicodeEncodingConformance Strict
public UnicodeEncodingConformance Compat
}
public System.Net.Configuration.WebProxyScriptElement : ConfigurationElement {
private ConfigurationProperty downloadTimeoutProp
private ConfigurationPropertyCollection properties
public TimeSpan DownloadTimeout
protected ConfigurationPropertyCollection Properties
public int AutoConfigUrlRetryInterval
protected void PostDeserialize()
public TimeSpan get_DownloadTimeout()
public void set_DownloadTimeout(TimeSpan value)
protected ConfigurationPropertyCollection get_Properties()
public int get_AutoConfigUrlRetryInterval()
public void set_AutoConfigUrlRetryInterval(int value)
}
public System.Net.Configuration.WebRequestModuleElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty prefixProp
private ConfigurationProperty typeProp
public string Prefix
public Type Type
protected ConfigurationPropertyCollection Properties
public void .ctor(string prefix, string type)
public void .ctor(string prefix, Type type)
public string get_Prefix()
public void set_Prefix(string value)
public Type get_Type()
public void set_Type(Type value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.WebRequestModuleElementCollection : ConfigurationElementCollection {
public WebRequestModuleElement Item
public WebRequestModuleElement Item
public WebRequestModuleElement get_Item(int index)
public void set_Item(int index, WebRequestModuleElement value)
public WebRequestModuleElement get_Item(string name)
public void set_Item(string name, WebRequestModuleElement value)
public void Add(WebRequestModuleElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(WebRequestModuleElement element)
public void Remove(WebRequestModuleElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
internal System.Net.Configuration.WebRequestModuleHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Net.Configuration.WebRequestModulesSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty webRequestModulesProp
protected ConfigurationPropertyCollection Properties
public WebRequestModuleElementCollection WebRequestModules
protected ConfigurationPropertyCollection get_Properties()
public WebRequestModuleElementCollection get_WebRequestModules()
protected void PostDeserialize()
protected void InitializeDefault()
}
public System.Net.Configuration.WebUtilityElement : ConfigurationElement {
public UnicodeDecodingConformance UnicodeDecodingConformance
public UnicodeEncodingConformance UnicodeEncodingConformance
public UnicodeDecodingConformance get_UnicodeDecodingConformance()
public void set_UnicodeDecodingConformance(UnicodeDecodingConformance value)
public UnicodeEncodingConformance get_UnicodeEncodingConformance()
public void set_UnicodeEncodingConformance(UnicodeEncodingConformance value)
}
public System.Net.Configuration.WindowsAuthenticationElement : ConfigurationElement {
public int DefaultCredentialsHandleCacheSize
public int get_DefaultCredentialsHandleCacheSize()
public void set_DefaultCredentialsHandleCacheSize(int value)
}
internal System.Net.ContentDecodeStream : WebReadStream {
private Stream <OriginalInnerStream>k__BackingField
private Stream OriginalInnerStream
public ContentDecodeStream Create(WebOperation operation, Stream innerStream, Mode mode)
private Stream get_OriginalInnerStream()
private void .ctor(WebOperation operation, Stream decodeStream, Stream originalInnerStream)
protected Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
internal Task FinishReading(CancellationToken cancellationToken)
}
internal System.Net.ContentTypeValues : Enum {
public int value__
public ContentTypeValues ChangeCipherSpec
public ContentTypeValues Alert
public ContentTypeValues HandShake
public ContentTypeValues AppData
public ContentTypeValues Unrecognized
}
internal System.Net.ContextAttribute : Enum {
public int value__
public ContextAttribute Sizes
public ContextAttribute Names
public ContextAttribute Lifespan
public ContextAttribute DceInfo
public ContextAttribute StreamSizes
public ContextAttribute Authority
public ContextAttribute PackageInfo
public ContextAttribute NegotiationInfo
public ContextAttribute UniqueBindings
public ContextAttribute EndpointBindings
public ContextAttribute ClientSpecifiedSpn
public ContextAttribute RemoteCertificate
public ContextAttribute LocalCertificate
public ContextAttribute RootStore
public ContextAttribute IssuerListInfoEx
public ContextAttribute ConnectionInfo
public ContextAttribute UiInfo
}
internal System.Net.ContextAwareResult : LazyAsyncResult {
private WindowsIdentity _windowsIdentity
private ExecutionContext modreq(System.Runtime.CompilerServices.IsVolatile) _context
private object _lock
private StateFlags _flags
internal WindowsIdentity Identity
internal ExecutionContext ContextCopy
internal EndPoint RemoteEndPoint
private void SafeCaptureIdentity()
internal WindowsIdentity get_Identity()
private void CleanupInternal()
internal void .ctor(object myObject, object myState, AsyncCallback myCallBack)
internal void .ctor(bool captureIdentity, bool forceCaptureContext, object myObject, object myState, AsyncCallback myCallBack)
internal void .ctor(bool captureIdentity, bool forceCaptureContext, bool threadSafeContextCopy, object myObject, object myState, AsyncCallback myCallBack)
internal ExecutionContext get_ContextCopy()
internal object StartPostingAsyncOp()
internal object StartPostingAsyncOp(bool lockCapture)
internal bool FinishPostingAsyncOp()
internal bool FinishPostingAsyncOp(CallbackClosure& closure)
protected void Cleanup()
private bool CaptureOrComplete(ExecutionContext& cachedContext, bool returnContext)
protected void Complete(IntPtr userToken)
private void CompleteCallback()
internal EndPoint get_RemoteEndPoint()
}
internal System.Net.ContextFlagsAdapterPal : object {
private ContextFlagMapping[] s_contextFlagMapping
internal ContextFlagsPal GetContextFlagsPalFromInterop(ContextFlags win32Flags)
internal ContextFlags GetInteropFromContextFlagsPal(ContextFlagsPal flags)
}
internal System.Net.ContextFlagsPal : Enum {
public int value__
public ContextFlagsPal None
public ContextFlagsPal Delegate
public ContextFlagsPal MutualAuth
public ContextFlagsPal ReplayDetect
public ContextFlagsPal SequenceDetect
public ContextFlagsPal Confidentiality
public ContextFlagsPal UseSessionKey
public ContextFlagsPal AllocateMemory
public ContextFlagsPal Connection
public ContextFlagsPal InitExtendedError
public ContextFlagsPal AcceptExtendedError
public ContextFlagsPal InitStream
public ContextFlagsPal AcceptStream
public ContextFlagsPal InitIntegrity
public ContextFlagsPal AcceptIntegrity
public ContextFlagsPal InitManualCredValidation
public ContextFlagsPal InitUseSuppliedCreds
public ContextFlagsPal InitIdentify
public ContextFlagsPal AcceptIdentify
public ContextFlagsPal ProxyBindings
public ContextFlagsPal AllowMissingBindings
public ContextFlagsPal UnverifiedTargetName
}
public System.Net.Cookie : object {
internal int MaxSupportedVersion
internal string CommentAttributeName
internal string CommentUrlAttributeName
internal string DiscardAttributeName
internal string DomainAttributeName
internal string ExpiresAttributeName
internal string MaxAgeAttributeName
internal string PathAttributeName
internal string PortAttributeName
internal string SecureAttributeName
internal string VersionAttributeName
internal string HttpOnlyAttributeName
internal string SeparatorLiteral
internal string EqualsLiteral
internal string QuotesLiteral
internal string SpecialAttributeLiteral
internal Char[] PortSplitDelimiters
internal Char[] Reserved2Name
internal Char[] Reserved2Value
private Comparer staticComparer
private string m_comment
private Uri m_commentUri
private CookieVariant m_cookieVariant
private bool m_discard
private string m_domain
private bool m_domain_implicit
private DateTime m_expires
private string m_name
private string m_path
private bool m_path_implicit
private string m_port
private bool m_port_implicit
private Int32[] m_port_list
private bool m_secure
private bool m_httpOnly
private DateTime m_timeStamp
private string m_value
private int m_version
private string m_domainKey
internal bool IsQuotedVersion
internal bool IsQuotedDomain
public string Comment
public Uri CommentUri
public bool HttpOnly
public bool Discard
public string Domain
private string _Domain
internal bool DomainImplicit
public bool Expired
public DateTime Expires
public string Name
public string Path
private string _Path
internal bool Plain
public string Port
internal Int32[] PortList
private string _Port
public bool Secure
public DateTime TimeStamp
public string Value
internal CookieVariant Variant
internal string DomainKey
public int Version
private string _Version
public void .ctor(string name, string value)
public void .ctor(string name, string value, string path)
public void .ctor(string name, string value, string path, string domain)
public string get_Comment()
public void set_Comment(string value)
public Uri get_CommentUri()
public void set_CommentUri(Uri value)
public bool get_HttpOnly()
public void set_HttpOnly(bool value)
public bool get_Discard()
public void set_Discard(bool value)
public string get_Domain()
public void set_Domain(string value)
private string get__Domain()
internal bool get_DomainImplicit()
internal void set_DomainImplicit(bool value)
public bool get_Expired()
public void set_Expired(bool value)
public DateTime get_Expires()
public void set_Expires(DateTime value)
public string get_Name()
public void set_Name(string value)
internal bool InternalSetName(string value)
public string get_Path()
public void set_Path(string value)
private string get__Path()
internal bool get_Plain()
internal Cookie Clone()
private bool IsDomainEqualToHost(string domain, string host)
internal bool VerifySetDefaults(CookieVariant variant, Uri uri, bool isLocalDomain, string localDomain, bool set_default, bool isThrow)
private bool DomainCharsTest(string name)
public string get_Port()
public void set_Port(string value)
internal Int32[] get_PortList()
private string get__Port()
public bool get_Secure()
public void set_Secure(bool value)
public DateTime get_TimeStamp()
public string get_Value()
public void set_Value(string value)
internal CookieVariant get_Variant()
internal void set_Variant(CookieVariant value)
internal string get_DomainKey()
public int get_Version()
public void set_Version(int value)
private string get__Version()
internal IComparer GetComparer()
public bool Equals(object comparand)
public int GetHashCode()
public string ToString()
internal string ToServerString()
}
public System.Net.CookieCollection : object {
internal int m_version
private ArrayList m_list
private DateTime m_TimeStamp
private bool m_has_other_versions
private bool m_IsReadOnly
public bool IsReadOnly
public Cookie Item
public Cookie Item
public int Count
public bool IsSynchronized
public object SyncRoot
internal bool IsOtherVersionSeen
internal void .ctor(bool IsReadOnly)
public bool get_IsReadOnly()
public Cookie get_Item(int index)
public Cookie get_Item(string name)
public void Add(Cookie cookie)
public void Add(CookieCollection cookies)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public void CopyTo(Cookie[] array, int index)
internal DateTime TimeStamp(Stamp how)
internal bool get_IsOtherVersionSeen()
internal int InternalAdd(Cookie cookie, bool isStrict)
internal int IndexOf(Cookie cookie)
internal void RemoveAt(int idx)
public IEnumerator GetEnumerator()
}
public System.Net.CookieContainer : object {
public int DefaultCookieLimit
public int DefaultPerDomainCookieLimit
public int DefaultCookieLengthLimit
private HeaderVariantInfo[] HeaderInfo
private Hashtable m_domainTable
private int m_maxCookieSize
private int m_maxCookies
private int m_maxCookiesPerDomain
private int m_count
private string m_fqdnMyDomain
public int Capacity
public int Count
public int MaxCookieSize
public int PerDomainCapacity
public void .ctor(int capacity)
public void .ctor(int capacity, int perDomainCapacity, int maxCookieSize)
public int get_Capacity()
public void set_Capacity(int value)
public int get_Count()
public int get_MaxCookieSize()
public void set_MaxCookieSize(int value)
public int get_PerDomainCapacity()
public void set_PerDomainCapacity(int value)
public void Add(Cookie cookie)
private void AddRemoveDomain(string key, PathList value)
internal void Add(Cookie cookie, bool throwOnError)
private bool AgeCookies(string domain)
private int ExpireCollection(CookieCollection cc)
public void Add(CookieCollection cookies)
internal bool IsLocalDomain(string host)
public void Add(Uri uri, Cookie cookie)
public void Add(Uri uri, CookieCollection cookies)
internal CookieCollection CookieCutter(Uri uri, string headerName, string setCookieHeader, bool isThrow)
public CookieCollection GetCookies(Uri uri)
internal CookieCollection InternalGetCookies(Uri uri)
private void BuildCookieCollectionFromDomainMatches(Uri uri, bool isSecure, int port, CookieCollection cookies, List`1<string> domainAttribute, bool matchOnlyPlainCookie)
private void MergeUpdateCollections(CookieCollection destination, CookieCollection source, int port, bool isSecure, bool isPlainOnly)
public string GetCookieHeader(Uri uri)
internal string GetCookieHeader(Uri uri, String& optCookie2)
public void SetCookies(Uri uri, string cookieHeader)
}
public System.Net.CookieException : FormatException {
internal void .ctor(string message)
internal void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.Net.CookieParser : object {
private CookieTokenizer m_tokenizer
private Cookie m_savedCookie
internal void .ctor(string cookieString)
internal Cookie Get()
internal Cookie GetServer()
internal string CheckQuoted(string value)
}
internal System.Net.CookieToken : Enum {
public int value__
public CookieToken Nothing
public CookieToken NameValuePair
public CookieToken Attribute
public CookieToken EndToken
public CookieToken EndCookie
public CookieToken End
public CookieToken Equals
public CookieToken Comment
public CookieToken CommentUrl
public CookieToken CookieName
public CookieToken Discard
public CookieToken Domain
public CookieToken Expires
public CookieToken MaxAge
public CookieToken Path
public CookieToken Port
public CookieToken Secure
public CookieToken HttpOnly
public CookieToken Unknown
public CookieToken Version
}
internal System.Net.CookieTokenizer : object {
private bool m_eofCookie
private int m_index
private int m_length
private string m_name
private bool m_quoted
private int m_start
private CookieToken m_token
private int m_tokenLength
private string m_tokenStream
private string m_value
private RecognizedAttribute[] RecognizedAttributes
private RecognizedAttribute[] RecognizedServerAttributes
internal bool EndOfCookie
internal bool Eof
internal string Name
internal bool Quoted
internal CookieToken Token
internal string Value
internal void .ctor(string tokenStream)
internal bool get_EndOfCookie()
internal void set_EndOfCookie(bool value)
internal bool get_Eof()
internal string get_Name()
internal void set_Name(string value)
internal bool get_Quoted()
internal void set_Quoted(bool value)
internal CookieToken get_Token()
internal void set_Token(CookieToken value)
internal string get_Value()
internal void set_Value(string value)
internal string Extract()
internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals)
internal CookieToken Next(bool first, bool parseResponseCookies)
internal void Reset()
internal CookieToken TokenFromName(bool parseResponseCookies)
}
internal System.Net.CookieVariant : Enum {
public int value__
public CookieVariant Unknown
public CookieVariant Plain
public CookieVariant Rfc2109
public CookieVariant Rfc2965
public CookieVariant Default
}
public System.Net.CredentialCache : object {
private Hashtable cache
private Hashtable cacheForHosts
internal int m_version
private int m_NumbDefaultCredInCache
internal bool IsDefaultInCache
public ICredentials DefaultCredentials
public NetworkCredential DefaultNetworkCredentials
internal bool get_IsDefaultInCache()
public void Add(Uri uriPrefix, string authType, NetworkCredential cred)
public void Add(string host, int port, string authenticationType, NetworkCredential credential)
public void Remove(Uri uriPrefix, string authType)
public void Remove(string host, int port, string authenticationType)
public NetworkCredential GetCredential(Uri uriPrefix, string authType)
public NetworkCredential GetCredential(string host, int port, string authenticationType)
public IEnumerator GetEnumerator()
public ICredentials get_DefaultCredentials()
public NetworkCredential get_DefaultNetworkCredentials()
}
internal System.Net.CredentialHostKey : object {
internal string Host
internal string AuthenticationType
internal int Port
private int m_HashCode
private bool m_ComputedHashCode
internal void .ctor(string host, int port, string authenticationType)
internal bool Match(string host, int port, string authenticationType)
public int GetHashCode()
public bool Equals(object comparand)
public string ToString()
}
internal System.Net.CredentialKey : object {
internal Uri UriPrefix
internal int UriPrefixLength
internal string AuthenticationType
private int m_HashCode
private bool m_ComputedHashCode
internal void .ctor(Uri uriPrefix, string authenticationType)
internal bool Match(Uri uri, string authenticationType)
internal bool IsPrefix(Uri uri, Uri prefixUri)
public int GetHashCode()
public bool Equals(object comparand)
public string ToString()
}
internal System.Net.CredentialUse : Enum {
public int value__
public CredentialUse Inbound
public CredentialUse Outbound
public CredentialUse Both
}
internal System.Net.DataParseStatus : Enum {
public int value__
public DataParseStatus NeedMoreData
public DataParseStatus ContinueParsing
public DataParseStatus Done
public DataParseStatus Invalid
public DataParseStatus DataTooBig
}
public System.Net.DecompressionMethods : Enum {
public int value__
public DecompressionMethods None
public DecompressionMethods GZip
public DecompressionMethods Deflate
}
internal System.Net.DefaultCertificatePolicy : object {
public bool CheckValidationResult(ServicePoint point, X509Certificate certificate, WebRequest request, int certificateProblem)
}
internal System.Net.DefaultPorts : Enum {
public int value__
public DefaultPorts DEFAULT_FTP_PORT
public DefaultPorts DEFAULT_GOPHER_PORT
public DefaultPorts DEFAULT_HTTP_PORT
public DefaultPorts DEFAULT_HTTPS_PORT
public DefaultPorts DEFAULT_NNTP_PORT
public DefaultPorts DEFAULT_SMTP_PORT
public DefaultPorts DEFAULT_TELNET_PORT
}
internal System.Net.DelayedRegex : object {
private Regex _AsRegex
private string _AsString
internal Regex AsRegex
internal void .ctor(string regexString)
internal void .ctor(Regex regex)
internal Regex get_AsRegex()
public string ToString()
}
internal System.Net.DelegatedStream : Stream {
private Stream _stream
private NetworkStream _netStream
protected Stream BaseStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
protected void .ctor(Stream stream)
protected Stream get_BaseStream()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
}
internal System.Net.DigestClient : object {
private Hashtable cache
private Hashtable Cache
public string AuthenticationType
public bool CanPreAuthenticate
private Hashtable get_Cache()
private void CheckExpired(int count)
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
internal System.Net.DigestHeaderParser : object {
private string header
private int length
private int pos
private String[] keywords
private String[] values
public string Realm
public string Opaque
public string Nonce
public string Algorithm
public string QOP
public void .ctor(string header)
public string get_Realm()
public string get_Opaque()
public string get_Nonce()
public string get_Algorithm()
public string get_QOP()
public bool Parse()
private void SkipWhitespace()
private string GetKey()
private bool GetKeywordAndValue(String& key, String& value)
}
internal System.Net.DigestSession : object {
private RandomNumberGenerator rng
private DateTime lastUse
private int _nc
private HashAlgorithm hash
private DigestHeaderParser parser
private string _cnonce
public string Algorithm
public string Realm
public string Nonce
public string Opaque
public string QOP
public string CNonce
public DateTime LastUse
public string get_Algorithm()
public string get_Realm()
public string get_Nonce()
public string get_Opaque()
public string get_QOP()
public string get_CNonce()
public bool Parse(string challenge)
private string HashToHexString(string toBeHashed)
private string HA1(string username, string password)
private string HA2(HttpWebRequest webRequest)
private string Response(string username, string password, HttpWebRequest webRequest)
public Authorization Authenticate(WebRequest webRequest, ICredentials credentials)
public DateTime get_LastUse()
}
internal System.Net.DirectProxy : ProxyChain {
private bool m_ProxyRetrieved
internal void .ctor(Uri destination)
protected bool GetNextProxy(Uri& proxy)
}
public System.Net.Dns : object {
private bool use_mono_dns
private SimpleResolver resolver
internal bool UseMonoDns
internal bool get_UseMonoDns()
private void OnCompleted(object sender, SimpleResolverEventArgs e)
private IAsyncResult BeginAsyncCallAddresses(string host, AsyncCallback callback, object state)
private IAsyncResult BeginAsyncCall(string host, AsyncCallback callback, object state)
private IPHostEntry EndAsyncCall(DnsAsyncResult ares)
public IAsyncResult BeginGetHostByName(string hostName, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginResolve(string hostName, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginGetHostAddresses(string hostNameOrAddress, AsyncCallback requestCallback, object state)
public IAsyncResult BeginGetHostEntry(string hostNameOrAddress, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginGetHostEntry(IPAddress address, AsyncCallback requestCallback, object stateObject)
public IPHostEntry EndGetHostByName(IAsyncResult asyncResult)
public IPHostEntry EndResolve(IAsyncResult asyncResult)
public IPAddress[] EndGetHostAddresses(IAsyncResult asyncResult)
public IPHostEntry EndGetHostEntry(IAsyncResult asyncResult)
private bool GetHostByName_icall(string host, String& h_name, String[]& h_aliases, String[]& h_addr_list, int hint)
private bool GetHostByAddr_icall(string addr, String& h_name, String[]& h_aliases, String[]& h_addr_list, int hint)
private bool GetHostName_icall(String& h_name)
private void Error_11001(string hostName)
private IPHostEntry hostent_to_IPHostEntry(string originalHostName, string h_name, String[] h_aliases, String[] h_addrlist)
public IPHostEntry GetHostByAddress(IPAddress address)
public IPHostEntry GetHostByAddress(string address)
private IPHostEntry GetHostByAddressFromString(string address, bool parse)
public IPHostEntry GetHostEntry(string hostNameOrAddress)
public IPHostEntry GetHostEntry(IPAddress address)
public IPAddress[] GetHostAddresses(string hostNameOrAddress)
public IPHostEntry GetHostByName(string hostName)
public string GetHostName()
public IPHostEntry Resolve(string hostName)
public Task`1<IPAddress[]> GetHostAddressesAsync(string hostNameOrAddress)
public Task`1<IPHostEntry> GetHostEntryAsync(IPAddress address)
public Task`1<IPHostEntry> GetHostEntryAsync(string hostNameOrAddress)
}
internal System.Net.DnsAsyncResult : object {
private WaitCallback internal_cb
private ManualResetEvent handle
private bool synch
private bool is_completed
private AsyncCallback callback
private object state
private IPHostEntry entry
private Exception exc
public object AsyncState
public WaitHandle AsyncWaitHandle
public Exception Exception
public IPHostEntry HostEntry
public bool CompletedSynchronously
public bool IsCompleted
public void .ctor(AsyncCallback cb, object state)
public void SetCompleted(bool synch, IPHostEntry entry, Exception e)
public void SetCompleted(bool synch, Exception e)
public void SetCompleted(bool synch, IPHostEntry entry)
private void CB(object _this)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public Exception get_Exception()
public IPHostEntry get_HostEntry()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
}
public System.Net.DnsEndPoint : EndPoint {
private string m_Host
private int m_Port
private AddressFamily m_Family
public string Host
public AddressFamily AddressFamily
public int Port
public void .ctor(string host, int port)
public void .ctor(string host, int port, AddressFamily addressFamily)
public bool Equals(object comparand)
public int GetHashCode()
public string ToString()
public string get_Host()
public AddressFamily get_AddressFamily()
public int get_Port()
}
public System.Net.DnsPermission : CodeAccessPermission {
private int version
private bool m_noRestriction
public void .ctor(PermissionState state)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public void FromXml(SecurityElement securityElement)
public IPermission Union(IPermission target)
private bool IsEmpty()
private DnsPermission Cast(IPermission target)
}
public System.Net.DnsPermissionAttribute : CodeAccessSecurityAttribute {
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
}
public System.Net.DownloadDataCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] _result
public Byte[] Result
internal void .ctor(Byte[] result, Exception exception, bool cancelled, object userToken)
public Byte[] get_Result()
}
public System.Net.DownloadDataCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DownloadDataCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DownloadDataCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.DownloadProgressChangedEventArgs : ProgressChangedEventArgs {
private long <BytesReceived>k__BackingField
private long <TotalBytesToReceive>k__BackingField
public long BytesReceived
public long TotalBytesToReceive
internal void .ctor(int progressPercentage, object userToken, long bytesReceived, long totalBytesToReceive)
public long get_BytesReceived()
public long get_TotalBytesToReceive()
}
public System.Net.DownloadProgressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DownloadProgressChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DownloadProgressChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.DownloadStringCompletedEventArgs : AsyncCompletedEventArgs {
private string _result
public string Result
internal void .ctor(string result, Exception exception, bool cancelled, object userToken)
public string get_Result()
}
public System.Net.DownloadStringCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DownloadStringCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DownloadStringCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.EmptyWebProxy : object {
private ICredentials m_credentials
public ICredentials Credentials
public Uri GetProxy(Uri uri)
public bool IsBypassed(Uri uri)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
private ProxyChain System.Net.IAutoWebProxy.GetProxies(Uri destination)
}
internal System.Net.Endianness : Enum {
public int value__
public Endianness Network
public Endianness Native
}
public System.Net.EndPoint : object {
public AddressFamily AddressFamily
public AddressFamily get_AddressFamily()
public SocketAddress Serialize()
public EndPoint Create(SocketAddress socketAddress)
}
internal System.Net.EndPointListener : object {
private HttpListener listener
private IPEndPoint endpoint
private Socket sock
private Hashtable prefixes
private ArrayList unhandled
private ArrayList all
private X509Certificate cert
private bool secure
private Dictionary`2<HttpConnection, HttpConnection> unregistered
internal HttpListener Listener
public void .ctor(HttpListener listener, IPAddress addr, int port, bool secure)
internal HttpListener get_Listener()
private void Accept(Socket socket, SocketAsyncEventArgs e, Socket& accepted)
private void ProcessAccept(SocketAsyncEventArgs args)
private void OnAccept(object sender, SocketAsyncEventArgs e)
internal void RemoveConnection(HttpConnection conn)
public bool BindContext(HttpListenerContext context)
public void UnbindContext(HttpListenerContext context)
private HttpListener SearchListener(Uri uri, ListenerPrefix& prefix)
private HttpListener MatchFromList(string host, string path, ArrayList list, ListenerPrefix& prefix)
private void AddSpecial(ArrayList coll, ListenerPrefix prefix)
private bool RemoveSpecial(ArrayList coll, ListenerPrefix prefix)
private void CheckIfRemove()
public void Close()
public void AddPrefix(ListenerPrefix prefix, HttpListener listener)
public void RemovePrefix(ListenerPrefix prefix, HttpListener listener)
}
internal System.Net.EndPointManager : object {
private Hashtable ip_to_endpoints
public void AddListener(HttpListener listener)
public void AddPrefix(string prefix, HttpListener listener)
private void AddPrefixInternal(string p, HttpListener listener)
private EndPointListener GetEPListener(string host, int port, HttpListener listener, bool secure)
public void RemoveEndPoint(EndPointListener epl, IPEndPoint ep)
public void RemoveListener(HttpListener listener)
public void RemovePrefix(string prefix, HttpListener listener)
private void RemovePrefixInternal(string prefix, HttpListener listener)
}
public System.Net.EndpointPermission : object {
private Char[] dot_char
private string hostname
private int port
private TransportType transport
private bool resolved
private bool hasWildcard
private IPAddress[] addresses
public string Hostname
public int Port
public TransportType Transport
internal void .ctor(string hostname, int port, TransportType transport)
public string get_Hostname()
public int get_Port()
public TransportType get_Transport()
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
internal bool IsSubsetOf(EndpointPermission perm)
private bool IsSubsetOf(string addr1, string addr2)
internal EndpointPermission Intersect(EndpointPermission perm)
private string IntersectHostname(EndpointPermission perm)
private string Intersect(string addr1, string addr2)
private int ToNumber(string value)
internal void Resolve()
internal void UndoResolve()
}
internal System.Net.ExceptionCheck : object {
internal bool IsFatal(Exception exception)
}
internal System.Net.ExceptionHelper : object {
internal NotImplementedException MethodNotImplementedException
internal NotImplementedException PropertyNotImplementedException
internal WebException TimeoutException
internal NotSupportedException MethodNotSupportedException
internal NotSupportedException PropertyNotSupportedException
internal WebException IsolatedException
internal WebException RequestAbortedException
internal WebException CacheEntryNotFoundException
internal WebException RequestProhibitedByCachePolicyException
internal NotImplementedException get_MethodNotImplementedException()
internal NotImplementedException get_PropertyNotImplementedException()
internal WebException get_TimeoutException()
internal NotSupportedException get_MethodNotSupportedException()
internal NotSupportedException get_PropertyNotSupportedException()
internal WebException get_IsolatedException()
internal WebException get_RequestAbortedException()
internal WebException get_CacheEntryNotFoundException()
internal WebException get_RequestProhibitedByCachePolicyException()
}
public System.Net.FileWebRequest : WebRequest {
private WaitCallback s_GetRequestStreamCallback
private WaitCallback s_GetResponseCallback
private string m_connectionGroupName
private long m_contentLength
private ICredentials m_credentials
private FileAccess m_fileAccess
private WebHeaderCollection m_headers
private string m_method
private bool m_preauthenticate
private IWebProxy m_proxy
private ManualResetEvent m_readerEvent
private bool m_readPending
private WebResponse m_response
private Stream m_stream
private bool m_syncHint
private int m_timeout
private Uri m_uri
private bool m_writePending
private bool m_writing
private LazyAsyncResult m_WriteAResult
private LazyAsyncResult m_ReadAResult
private int m_Aborted
internal bool Aborted
public string ConnectionGroupName
public long ContentLength
public string ContentType
public ICredentials Credentials
public WebHeaderCollection Headers
public string Method
public bool PreAuthenticate
public IWebProxy Proxy
public int Timeout
public Uri RequestUri
public bool UseDefaultCredentials
internal void .ctor(Uri uri)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal bool get_Aborted()
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public long get_ContentLength()
public void set_ContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public WebHeaderCollection get_Headers()
public string get_Method()
public void set_Method(string value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public int get_Timeout()
public void set_Timeout(int value)
public Uri get_RequestUri()
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
private bool CanGetRequestStream()
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public Stream GetRequestStream()
public WebResponse GetResponse()
private void GetRequestStreamCallback(object state)
private void GetResponseCallback(object state)
internal void UnblockReader()
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public void Abort()
}
internal System.Net.FileWebRequestCreator : object {
public WebRequest Create(Uri uri)
}
public System.Net.FileWebResponse : WebResponse {
private int DefaultFileStreamBufferSize
private string DefaultFileContentType
private bool m_closed
private long m_contentLength
private FileAccess m_fileAccess
private WebHeaderCollection m_headers
private Stream m_stream
private Uri m_uri
public long ContentLength
public string ContentType
public WebHeaderCollection Headers
public bool SupportsHeaders
public Uri ResponseUri
internal void .ctor(FileWebRequest request, Uri uri, FileAccess access, bool asyncHint)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public long get_ContentLength()
public string get_ContentType()
public WebHeaderCollection get_Headers()
public bool get_SupportsHeaders()
public Uri get_ResponseUri()
private void CheckDisposed()
public void Close()
private void System.Net.ICloseEx.CloseEx(CloseExState closeState)
public Stream GetResponseStream()
}
internal System.Net.FileWebStream : FileStream {
private FileWebRequest m_request
public void .ctor(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing)
public void .ctor(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing, int length, bool async)
protected void Dispose(bool disposing)
private void System.Net.ICloseEx.CloseEx(CloseExState closeState)
public int Read(Byte[] buffer, int offset, int size)
public void Write(Byte[] buffer, int offset, int size)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public int EndRead(IAsyncResult ar)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult ar)
private void CheckError()
}
internal System.Net.FixedSizeReadStream : WebReadStream {
private long <ContentLength>k__BackingField
private long position
public long ContentLength
public long get_ContentLength()
public void .ctor(WebOperation operation, Stream innerStream, long contentLength)
protected Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
}
internal System.Net.FtpControlStream : CommandStream {
private Socket _dataSocket
private IPEndPoint _passiveEndPoint
private TlsStream _tlsStream
private StringBuilder _bannerMessage
private StringBuilder _welcomeMessage
private StringBuilder _exitMessage
private WeakReference _credentials
private string _currentTypeSetting
private long _contentLength
private DateTime _lastModified
private bool _dataHandshakeStarted
private string _loginDirectory
private string _establishedServerDirectory
private string _requestedServerDirectory
private Uri _responseUri
private FtpLoginState _loginState
internal FtpStatusCode StatusCode
internal string StatusLine
private AsyncCallback s_acceptCallbackDelegate
private AsyncCallback s_connectCallbackDelegate
private AsyncCallback s_SSLHandshakeCallback
internal NetworkCredential Credentials
internal long ContentLength
internal DateTime LastModified
internal Uri ResponseUri
internal string BannerMessage
internal string WelcomeMessage
internal string ExitMessage
internal NetworkCredential get_Credentials()
internal void set_Credentials(NetworkCredential value)
internal void .ctor(TcpClient client)
internal void AbortConnect()
private void AcceptCallback(IAsyncResult asyncResult)
private void ConnectCallback(IAsyncResult asyncResult)
private void SSLHandshakeCallback(IAsyncResult asyncResult)
private PipelineInstruction QueueOrCreateFtpDataStream(Stream& stream)
protected void ClearState()
protected PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream)
protected PipelineEntry[] BuildCommandsList(WebRequest req)
private PipelineInstruction QueueOrCreateDataConection(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream, Boolean& isSocketReady)
private void GetPathInfo(GetPathOption pathOption, Uri uri, String& path, String& directory, String& filename)
private string FormatAddress(IPAddress address, int Port)
private string FormatAddressV6(IPAddress address, int port)
internal long get_ContentLength()
internal DateTime get_LastModified()
internal Uri get_ResponseUri()
internal string get_BannerMessage()
internal string get_WelcomeMessage()
internal string get_ExitMessage()
private long GetContentLengthFrom213Response(string responseString)
private DateTime GetLastModifiedFrom213Response(string str)
private void TryUpdateResponseUri(string str, FtpWebRequest request)
private void TryUpdateContentLength(string str)
private string GetLoginDirectory(string str)
private int GetPortV4(string responseString)
private int GetPortV6(string responseString)
private void CreateFtpListenerSocket(FtpWebRequest request)
private string GetPortCommandLine(FtpWebRequest request)
private string FormatFtpCommand(string command, string parameter)
protected Socket CreateFtpDataSocket(FtpWebRequest request, Socket templateSocket)
protected bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength)
private TriState IsFtpDataStreamWriteable()
}
internal System.Net.FtpDataStream : Stream {
private FtpWebRequest _request
private NetworkStream _networkStream
private bool _writeable
private bool _readable
private bool _isFullyRead
private bool _closing
private int DefaultCloseTimeout
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
internal void .ctor(NetworkStream networkStream, FtpWebRequest request, TriState writeOnly)
protected void Dispose(bool disposing)
private void System.Net.ICloseEx.CloseEx(CloseExState closeState)
private void CheckError()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public long Seek(long offset, SeekOrigin origin)
public int Read(Byte[] buffer, int offset, int size)
public void Write(Byte[] buffer, int offset, int size)
private void AsyncReadCallback(IAsyncResult ar)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public int EndRead(IAsyncResult ar)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public void SetLength(long value)
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
internal void SetSocketTimeoutOption(int timeout)
}
internal System.Net.FtpLoginState : Enum {
public byte value__
public FtpLoginState NotLoggedIn
public FtpLoginState LoggedIn
public FtpLoginState LoggedInButNeedsRelogin
public FtpLoginState ReloginFailed
}
internal System.Net.FtpMethodFlags : Enum {
public int value__
public FtpMethodFlags None
public FtpMethodFlags IsDownload
public FtpMethodFlags IsUpload
public FtpMethodFlags TakesParameter
public FtpMethodFlags MayTakeParameter
public FtpMethodFlags DoesNotTakeParameter
public FtpMethodFlags ParameterIsDirectory
public FtpMethodFlags ShouldParseForResponseUri
public FtpMethodFlags HasHttpCommand
public FtpMethodFlags MustChangeWorkingDirectoryToPath
}
internal System.Net.FtpMethodInfo : object {
internal string Method
internal FtpOperation Operation
internal FtpMethodFlags Flags
internal string HttpCommand
private FtpMethodInfo[] s_knownMethodInfo
internal bool IsCommandOnly
internal bool IsUpload
internal bool IsDownload
internal bool ShouldParseForResponseUri
internal void .ctor(string method, FtpOperation operation, FtpMethodFlags flags, string httpCommand)
internal bool HasFlag(FtpMethodFlags flags)
internal bool get_IsCommandOnly()
internal bool get_IsUpload()
internal bool get_IsDownload()
internal bool get_ShouldParseForResponseUri()
internal FtpMethodInfo GetMethodInfo(string method)
}
internal System.Net.FtpOperation : Enum {
public int value__
public FtpOperation DownloadFile
public FtpOperation ListDirectory
public FtpOperation ListDirectoryDetails
public FtpOperation UploadFile
public FtpOperation UploadFileUnique
public FtpOperation AppendFile
public FtpOperation DeleteFile
public FtpOperation GetDateTimestamp
public FtpOperation GetFileSize
public FtpOperation Rename
public FtpOperation MakeDirectory
public FtpOperation RemoveDirectory
public FtpOperation PrintWorkingDirectory
public FtpOperation Other
}
public System.Net.FtpStatusCode : Enum {
public int value__
public FtpStatusCode Undefined
public FtpStatusCode RestartMarker
public FtpStatusCode ServiceTemporarilyNotAvailable
public FtpStatusCode DataAlreadyOpen
public FtpStatusCode OpeningData
public FtpStatusCode CommandOK
public FtpStatusCode CommandExtraneous
public FtpStatusCode DirectoryStatus
public FtpStatusCode FileStatus
public FtpStatusCode SystemType
public FtpStatusCode SendUserCommand
public FtpStatusCode ClosingControl
public FtpStatusCode ClosingData
public FtpStatusCode EnteringPassive
public FtpStatusCode LoggedInProceed
public FtpStatusCode ServerWantsSecureSession
public FtpStatusCode FileActionOK
public FtpStatusCode PathnameCreated
public FtpStatusCode SendPasswordCommand
public FtpStatusCode NeedLoginAccount
public FtpStatusCode FileCommandPending
public FtpStatusCode ServiceNotAvailable
public FtpStatusCode CantOpenData
public FtpStatusCode ConnectionClosed
public FtpStatusCode ActionNotTakenFileUnavailableOrBusy
public FtpStatusCode ActionAbortedLocalProcessingError
public FtpStatusCode ActionNotTakenInsufficientSpace
public FtpStatusCode CommandSyntaxError
public FtpStatusCode ArgumentSyntaxError
public FtpStatusCode CommandNotImplemented
public FtpStatusCode BadCommandSequence
public FtpStatusCode NotLoggedIn
public FtpStatusCode AccountNeeded
public FtpStatusCode ActionNotTakenFileUnavailable
public FtpStatusCode ActionAbortedUnknownPageType
public FtpStatusCode FileActionAborted
public FtpStatusCode ActionNotTakenFilenameNotAllowed
}
public System.Net.FtpWebRequest : WebRequest {
private object _syncObject
private ICredentials _authInfo
private Uri _uri
private FtpMethodInfo _methodInfo
private string _renameTo
private bool _getRequestStreamStarted
private bool _getResponseStarted
private DateTime _startTime
private int _timeout
private int _remainingTimeout
private long _contentLength
private long _contentOffset
private X509CertificateCollection _clientCertificates
private bool _passive
private bool _binary
private string _connectionGroupName
private ServicePoint _servicePoint
private bool _async
private bool _aborted
private bool _timedOut
private Exception _exception
private Queue _timerQueue
private Callback _timerCallback
private bool _enableSsl
private FtpControlStream _connection
private Stream _stream
private RequestStage _requestStage
private bool _onceFailed
private WebHeaderCollection _ftpRequestHeaders
private FtpWebResponse _ftpWebResponse
private int _readWriteTimeout
private ContextAwareResult _writeAsyncResult
private LazyAsyncResult _readAsyncResult
private LazyAsyncResult _requestCompleteAsyncResult
private NetworkCredential s_defaultFtpNetworkCredential
private int s_DefaultTimeout
private Queue s_DefaultTimerQueue
internal FtpMethodInfo MethodInfo
public RequestCachePolicy DefaultCachePolicy
public string Method
public string RenameTo
public ICredentials Credentials
public Uri RequestUri
public int Timeout
internal int RemainingTimeout
public int ReadWriteTimeout
public long ContentOffset
public long ContentLength
public IWebProxy Proxy
public string ConnectionGroupName
public ServicePoint ServicePoint
internal bool Aborted
private Queue TimerQueue
public bool KeepAlive
public RequestCachePolicy CachePolicy
public bool UseBinary
public bool UsePassive
public X509CertificateCollection ClientCertificates
public bool EnableSsl
public WebHeaderCollection Headers
public string ContentType
public bool UseDefaultCredentials
public bool PreAuthenticate
private bool InUse
internal FtpMethodInfo get_MethodInfo()
public RequestCachePolicy get_DefaultCachePolicy()
public void set_DefaultCachePolicy(RequestCachePolicy value)
public string get_Method()
public void set_Method(string value)
public string get_RenameTo()
public void set_RenameTo(string value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public Uri get_RequestUri()
public int get_Timeout()
public void set_Timeout(int value)
internal int get_RemainingTimeout()
public int get_ReadWriteTimeout()
public void set_ReadWriteTimeout(int value)
public long get_ContentOffset()
public void set_ContentOffset(long value)
public long get_ContentLength()
public void set_ContentLength(long value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public ServicePoint get_ServicePoint()
internal bool get_Aborted()
internal void .ctor(Uri uri)
public WebResponse GetResponse()
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public Stream GetRequestStream()
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
private void SubmitRequest(bool isAsync)
private Exception TranslateConnectException(Exception e)
private void CreateConnectionAsync()
private FtpControlStream CreateConnection()
private Stream TimedSubmitRequestHelper(bool isAsync)
private void TimerCallback(Timer timer, int timeNoticed, object context)
private Queue get_TimerQueue()
private bool AttemptedRecovery(Exception e)
private void SetException(Exception exception)
private void CheckError()
internal void RequestCallback(object obj)
private void SyncRequestCallback(object obj)
private void AsyncRequestCallback(object obj)
private RequestStage FinishRequestStage(RequestStage stage)
public void Abort()
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public RequestCachePolicy get_CachePolicy()
public void set_CachePolicy(RequestCachePolicy value)
public bool get_UseBinary()
public void set_UseBinary(bool value)
public bool get_UsePassive()
public void set_UsePassive(bool value)
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public bool get_EnableSsl()
public void set_EnableSsl(bool value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public string get_ContentType()
public void set_ContentType(string value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
private bool get_InUse()
private void EnsureFtpWebResponse(Exception exception)
internal void DataStreamClosed(CloseExState closeState)
}
internal System.Net.FtpWebRequestCreator : object {
public WebRequest Create(Uri uri)
}
public System.Net.FtpWebResponse : WebResponse {
internal Stream _responseStream
private long _contentLength
private Uri _responseUri
private FtpStatusCode _statusCode
private string _statusLine
private WebHeaderCollection _ftpRequestHeaders
private DateTime _lastModified
private string _bannerMessage
private string _welcomeMessage
private string _exitMessage
public long ContentLength
public WebHeaderCollection Headers
public bool SupportsHeaders
public Uri ResponseUri
public FtpStatusCode StatusCode
public string StatusDescription
public DateTime LastModified
public string BannerMessage
public string WelcomeMessage
public string ExitMessage
internal void .ctor(Stream responseStream, long contentLength, Uri responseUri, FtpStatusCode statusCode, string statusLine, DateTime lastModified, string bannerMessage, string welcomeMessage, string exitMessage)
internal void UpdateStatus(FtpStatusCode statusCode, string statusLine, string exitMessage)
public Stream GetResponseStream()
internal void SetResponseStream(Stream stream)
public void Close()
public long get_ContentLength()
public WebHeaderCollection get_Headers()
public bool get_SupportsHeaders()
public Uri get_ResponseUri()
public FtpStatusCode get_StatusCode()
public string get_StatusDescription()
public DateTime get_LastModified()
public string get_BannerMessage()
public string get_WelcomeMessage()
public string get_ExitMessage()
}
internal System.Net.GlobalLog : object {
private BaseLoggingObject Logobject
internal ThreadKinds CurrentThreadKind
private BaseLoggingObject LoggingInitialize()
internal ThreadKinds get_CurrentThreadKind()
internal void SetThreadSource(ThreadKinds source)
internal void ThreadContract(ThreadKinds kind, string errorMsg)
internal void ThreadContract(ThreadKinds kind, ThreadKinds allowedSources, string errorMsg)
public void AddToArray(string msg)
public void Ignore(object msg)
public void Print(string msg)
public void PrintHex(string msg, object value)
public void Enter(string func)
public void Enter(string func, string parms)
public void Assert(bool condition, string messageFormat, Object[] data)
public void Assert(string message)
public void Assert(string message, string detailMessage)
public void LeaveException(string func, Exception exception)
public void Leave(string func)
public void Leave(string func, string result)
public void Leave(string func, int returnval)
public void Leave(string func, bool returnval)
public void DumpArray()
public void Dump(Byte[] buffer)
public void Dump(Byte[] buffer, int length)
public void Dump(Byte[] buffer, int offset, int length)
public void Dump(IntPtr buffer, int offset, int length)
}
public System.Net.GlobalProxySelection : object {
public IWebProxy Select
public IWebProxy get_Select()
public void set_Select(IWebProxy value)
public IWebProxy GetEmptyWebProxy()
}
internal System.Net.GlobalSSPI : object {
internal SSPIInterface SSPIAuth
internal SSPIInterface SSPISecureChannel
}
internal System.Net.HeaderInfo : object {
internal bool IsRequestRestricted
internal bool IsResponseRestricted
internal HeaderParser Parser
internal string HeaderName
internal bool AllowMultiValues
internal void .ctor(string name, bool requestRestricted, bool responseRestricted, bool multi, HeaderParser p)
}
internal System.Net.HeaderInfoTable : object {
private Hashtable HeaderHashTable
private HeaderInfo UnknownHeaderInfo
private HeaderParser SingleParser
private HeaderParser MultiParser
internal HeaderInfo Item
private String[] ParseSingleValue(string value)
private String[] ParseMultiValue(string value)
internal HeaderInfo get_Item(string name)
}
internal System.Net.HeaderParser : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public String[] Invoke(string value)
public IAsyncResult BeginInvoke(string value, AsyncCallback callback, object object)
public String[] EndInvoke(IAsyncResult result)
}
internal System.Net.HeaderVariantInfo : ValueType {
private string m_name
private CookieVariant m_variant
internal string Name
internal CookieVariant Variant
internal void .ctor(string name, CookieVariant variant)
internal string get_Name()
internal CookieVariant get_Variant()
}
internal System.Net.hostent : ValueType {
public IntPtr h_name
public IntPtr h_aliases
public short h_addrtype
public short h_length
public IntPtr h_addr_list
}
internal System.Net.HostHeaderString : object {
private bool m_Converted
private string m_String
private Byte[] m_Bytes
internal string String
internal int ByteCount
internal Byte[] Bytes
internal void .ctor(string s)
private void Init(string s)
private void Convert()
internal string get_String()
internal void set_String(string value)
internal int get_ByteCount()
internal Byte[] get_Bytes()
internal void Copy(Byte[] destBytes, int destByteIndex)
}
internal System.Net.Http.DelegatingStream : Stream {
private Stream _innerStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public int ReadTimeout
public bool CanTimeout
public int WriteTimeout
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public bool get_CanTimeout()
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
protected void .ctor(Stream innerStream)
protected void Dispose(bool disposing)
public long Seek(long offset, SeekOrigin origin)
public int Read(Byte[] buffer, int offset, int count)
public int Read(Span`1<byte> buffer)
public int ReadByte()
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void Write(ReadOnlySpan`1<byte> buffer)
public void WriteByte(byte value)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
public Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
}
internal System.Net.HttpAbortDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(HttpWebRequest request, WebException webException)
public IAsyncResult BeginInvoke(HttpWebRequest request, WebException webException, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal System.Net.HttpBehaviour : Enum {
public byte value__
public HttpBehaviour Unknown
public HttpBehaviour HTTP10
public HttpBehaviour HTTP11PartiallyCompliant
public HttpBehaviour HTTP11
}
internal System.Net.HttpConnection : object {
private AsyncCallback onread_cb
private int BufferSize
private Socket sock
private Stream stream
private EndPointListener epl
private MemoryStream ms
private Byte[] buffer
private HttpListenerContext context
private StringBuilder current_line
private ListenerPrefix prefix
private RequestStream i_stream
private ResponseStream o_stream
private bool chunked
private int reuses
private bool context_bound
private bool secure
private X509Certificate cert
private int s_timeout
private Timer timer
private IPEndPoint local_ep
private HttpListener last_listener
private Int32[] client_cert_errors
private X509Certificate2 client_cert
private SslStream ssl_stream
private InputState input_state
private LineState line_state
private int position
internal SslStream SslStream
internal Int32[] ClientCertificateErrors
internal X509Certificate2 ClientCertificate
public bool IsClosed
public int Reuses
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public bool IsSecure
public ListenerPrefix Prefix
public void .ctor(Socket sock, EndPointListener epl, bool secure, X509Certificate cert)
internal SslStream get_SslStream()
internal Int32[] get_ClientCertificateErrors()
internal X509Certificate2 get_ClientCertificate()
private void Init()
public bool get_IsClosed()
public int get_Reuses()
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
public bool get_IsSecure()
public ListenerPrefix get_Prefix()
public void set_Prefix(ListenerPrefix value)
private void OnTimeout(object unused)
public void BeginReadRequest()
public RequestStream GetRequestStream(bool chunked, long contentlength)
public ResponseStream GetResponseStream()
private void OnRead(IAsyncResult ares)
private void OnReadInternal(IAsyncResult ares)
private void RemoveConnection()
private bool ProcessInput(MemoryStream ms)
private string ReadLine(Byte[] buffer, int offset, int len, Int32& used)
public void SendError(string msg, int status)
public void SendError()
private void Unbind()
public void Close()
private void CloseSocket()
internal void Close(bool force_close)
private bool <.ctor>b__24_0(object t, X509Certificate c, X509Chain ch, SslPolicyErrors e)
}
public System.Net.HttpContinueDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(int StatusCode, WebHeaderCollection httpHeaders)
public IAsyncResult BeginInvoke(int StatusCode, WebHeaderCollection httpHeaders, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.HttpDateParse : object {
private int BASE_DEC
private int DATE_INDEX_DAY_OF_WEEK
private int DATE_1123_INDEX_DAY
private int DATE_1123_INDEX_MONTH
private int DATE_1123_INDEX_YEAR
private int DATE_1123_INDEX_HRS
private int DATE_1123_INDEX_MINS
private int DATE_1123_INDEX_SECS
private int DATE_ANSI_INDEX_MONTH
private int DATE_ANSI_INDEX_DAY
private int DATE_ANSI_INDEX_HRS
private int DATE_ANSI_INDEX_MINS
private int DATE_ANSI_INDEX_SECS
private int DATE_ANSI_INDEX_YEAR
private int DATE_INDEX_TZ
private int DATE_INDEX_LAST
private int MAX_FIELD_DATE_ENTRIES
private int DATE_TOKEN_JANUARY
private int DATE_TOKEN_FEBRUARY
private int DATE_TOKEN_Microsoft
private int DATE_TOKEN_APRIL
private int DATE_TOKEN_MAY
private int DATE_TOKEN_JUNE
private int DATE_TOKEN_JULY
private int DATE_TOKEN_AUGUST
private int DATE_TOKEN_SEPTEMBER
private int DATE_TOKEN_OCTOBER
private int DATE_TOKEN_NOVEMBER
private int DATE_TOKEN_DECEMBER
private int DATE_TOKEN_LAST_MONTH
private int DATE_TOKEN_SUNDAY
private int DATE_TOKEN_MONDAY
private int DATE_TOKEN_TUESDAY
private int DATE_TOKEN_WEDNESDAY
private int DATE_TOKEN_THURSDAY
private int DATE_TOKEN_FRIDAY
private int DATE_TOKEN_SATURDAY
private int DATE_TOKEN_LAST_DAY
private int DATE_TOKEN_GMT
private int DATE_TOKEN_LAST
private int DATE_TOKEN_ERROR
private char MAKE_UPPER(char c)
private int MapDayMonthToDword(Char[] lpszDay, int index)
public bool ParseHttpDate(string DateString, DateTime& dtOut)
}
internal System.Net.HttpKnownHeaderNames : object {
public string CacheControl
public string Connection
public string Date
public string KeepAlive
public string Pragma
public string ProxyConnection
public string Trailer
public string TransferEncoding
public string Upgrade
public string Via
public string Warning
public string ContentLength
public string ContentType
public string ContentDisposition
public string ContentEncoding
public string ContentLanguage
public string ContentLocation
public string ContentRange
public string Expires
public string LastModified
public string Age
public string Location
public string ProxyAuthenticate
public string RetryAfter
public string Server
public string SetCookie
public string SetCookie2
public string Vary
public string WWWAuthenticate
public string Accept
public string AcceptCharset
public string AcceptEncoding
public string AcceptLanguage
public string Authorization
public string Cookie
public string Cookie2
public string Expect
public string From
public string Host
public string IfMatch
public string IfModifiedSince
public string IfNoneMatch
public string IfRange
public string IfUnmodifiedSince
public string MaxForwards
public string ProxyAuthorization
public string Referer
public string Range
public string UserAgent
public string ContentMD5
public string ETag
public string TE
public string Allow
public string AcceptRanges
public string P3P
public string XPoweredBy
public string XAspNetVersion
public string SecWebSocketKey
public string SecWebSocketExtensions
public string SecWebSocketAccept
public string Origin
public string SecWebSocketProtocol
public string SecWebSocketVersion
}
public System.Net.HttpListener : object {
private MonoTlsProvider tlsProvider
private MonoTlsSettings tlsSettings
private X509Certificate certificate
private AuthenticationSchemes auth_schemes
private HttpListenerPrefixCollection prefixes
private AuthenticationSchemeSelector auth_selector
private string realm
private bool ignore_write_exceptions
private bool unsafe_ntlm_auth
private bool listening
private bool disposed
private object _internalLock
private Hashtable registry
private ArrayList ctx_queue
private ArrayList wait_queue
private Hashtable connections
private ServiceNameStore defaultServiceNames
private ExtendedProtectionPolicy extendedProtectionPolicy
private ExtendedProtectionSelector extendedProtectionSelectorDelegate
public AuthenticationSchemes AuthenticationSchemes
public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate
public ExtendedProtectionSelector ExtendedProtectionSelectorDelegate
public bool IgnoreWriteExceptions
public bool IsListening
public bool IsSupported
public HttpListenerPrefixCollection Prefixes
public HttpListenerTimeoutManager TimeoutManager
public ExtendedProtectionPolicy ExtendedProtectionPolicy
public ServiceNameCollection DefaultServiceNames
public string Realm
public bool UnsafeConnectionNtlmAuthentication
internal void .ctor(X509Certificate certificate, MonoTlsProvider tlsProvider, MonoTlsSettings tlsSettings)
internal X509Certificate LoadCertificateAndKey(IPAddress addr, int port)
internal SslStream CreateSslStream(Stream innerStream, bool ownsStream, RemoteCertificateValidationCallback callback)
public AuthenticationSchemes get_AuthenticationSchemes()
public void set_AuthenticationSchemes(AuthenticationSchemes value)
public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate()
public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value)
public ExtendedProtectionSelector get_ExtendedProtectionSelectorDelegate()
public void set_ExtendedProtectionSelectorDelegate(ExtendedProtectionSelector value)
public bool get_IgnoreWriteExceptions()
public void set_IgnoreWriteExceptions(bool value)
public bool get_IsListening()
public bool get_IsSupported()
public HttpListenerPrefixCollection get_Prefixes()
public HttpListenerTimeoutManager get_TimeoutManager()
public ExtendedProtectionPolicy get_ExtendedProtectionPolicy()
public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value)
public ServiceNameCollection get_DefaultServiceNames()
public string get_Realm()
public void set_Realm(string value)
public bool get_UnsafeConnectionNtlmAuthentication()
public void set_UnsafeConnectionNtlmAuthentication(bool value)
public void Abort()
public void Close()
private void Close(bool force)
private void Cleanup(bool close_existing)
public IAsyncResult BeginGetContext(AsyncCallback callback, object state)
public HttpListenerContext EndGetContext(IAsyncResult asyncResult)
internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerContext context)
public HttpListenerContext GetContext()
public void Start()
public void Stop()
private void System.IDisposable.Dispose()
public Task`1<HttpListenerContext> GetContextAsync()
internal void CheckDisposed()
private HttpListenerContext GetContextFromQueue()
internal void RegisterContext(HttpListenerContext context)
internal void UnregisterContext(HttpListenerContext context)
internal void AddConnection(HttpConnection cnc)
internal void RemoveConnection(HttpConnection cnc)
}
public System.Net.HttpListenerBasicIdentity : GenericIdentity {
private string password
public string Password
public void .ctor(string username, string password)
public string get_Password()
}
public System.Net.HttpListenerContext : object {
private HttpListenerRequest request
private HttpListenerResponse response
private IPrincipal user
private HttpConnection cnc
private string error
private int err_status
internal HttpListener Listener
internal int ErrorStatus
internal string ErrorMessage
internal bool HaveError
internal HttpConnection Connection
public HttpListenerRequest Request
public HttpListenerResponse Response
public IPrincipal User
internal void .ctor(HttpConnection cnc)
internal int get_ErrorStatus()
internal void set_ErrorStatus(int value)
internal string get_ErrorMessage()
internal void set_ErrorMessage(string value)
internal bool get_HaveError()
internal HttpConnection get_Connection()
public HttpListenerRequest get_Request()
public HttpListenerResponse get_Response()
public IPrincipal get_User()
internal void ParseAuthentication(AuthenticationSchemes expectedSchemes)
internal IPrincipal ParseBasicAuthentication(string authData)
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol)
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, TimeSpan keepAliveInterval)
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval)
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer)
}
public System.Net.HttpListenerException : Win32Exception {
public int ErrorCode
public void .ctor(int errorCode)
public void .ctor(int errorCode, string message)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public int get_ErrorCode()
}
public System.Net.HttpListenerPrefixCollection : object {
private List`1<string> prefixes
private HttpListener listener
public int Count
public bool IsReadOnly
public bool IsSynchronized
internal void .ctor(HttpListener listener)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public void Add(string uriPrefix)
public void Clear()
public bool Contains(string uriPrefix)
public void CopyTo(String[] array, int offset)
public void CopyTo(Array array, int offset)
public IEnumerator`1<string> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Remove(string uriPrefix)
}
public System.Net.HttpListenerRequest : object {
private String[] accept_types
private Encoding content_encoding
private long content_length
private bool cl_set
private CookieCollection cookies
private WebHeaderCollection headers
private string method
private Stream input_stream
private Version version
private NameValueCollection query_string
private string raw_url
private Uri url
private Uri referrer
private String[] user_languages
private HttpListenerContext context
private bool is_chunked
private bool ka_set
private bool keep_alive
private GCCDelegate gcc_delegate
private Byte[] _100continue
private Char[] separators
public String[] AcceptTypes
public int ClientCertificateError
public Encoding ContentEncoding
public long ContentLength64
public string ContentType
public CookieCollection Cookies
public bool HasEntityBody
public NameValueCollection Headers
public string HttpMethod
public Stream InputStream
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public bool KeepAlive
public IPEndPoint LocalEndPoint
public Version ProtocolVersion
public NameValueCollection QueryString
public string RawUrl
public IPEndPoint RemoteEndPoint
public Guid RequestTraceIdentifier
public Uri Url
public Uri UrlReferrer
public string UserAgent
public string UserHostAddress
public string UserHostName
public String[] UserLanguages
public string ServiceName
public TransportContext TransportContext
public bool IsWebSocketRequest
internal void .ctor(HttpListenerContext context)
internal void SetRequestLine(string req)
private void CreateQueryString(string query)
private bool MaybeUri(string s)
private bool IsPredefinedScheme(string scheme)
internal bool FinishInitialization()
internal string Unquote(string str)
internal void AddHeader(string header)
internal bool FlushInput()
public String[] get_AcceptTypes()
public int get_ClientCertificateError()
public Encoding get_ContentEncoding()
public long get_ContentLength64()
public string get_ContentType()
public CookieCollection get_Cookies()
public bool get_HasEntityBody()
public NameValueCollection get_Headers()
public string get_HttpMethod()
public Stream get_InputStream()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public bool get_KeepAlive()
public IPEndPoint get_LocalEndPoint()
public Version get_ProtocolVersion()
public NameValueCollection get_QueryString()
public string get_RawUrl()
public IPEndPoint get_RemoteEndPoint()
public Guid get_RequestTraceIdentifier()
public Uri get_Url()
public Uri get_UrlReferrer()
public string get_UserAgent()
public string get_UserHostAddress()
public string get_UserHostName()
public String[] get_UserLanguages()
public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state)
public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult)
public X509Certificate2 GetClientCertificate()
public string get_ServiceName()
public TransportContext get_TransportContext()
public bool get_IsWebSocketRequest()
public Task`1<X509Certificate2> GetClientCertificateAsync()
}
internal System.Net.HttpListenerRequestUriBuilder : object {
private bool useCookedRequestUrl
private Encoding utf8Encoding
private Encoding ansiEncoding
private string rawUri
private string cookedUriScheme
private string cookedUriHost
private string cookedUriPath
private string cookedUriQuery
private StringBuilder requestUriString
private List`1<byte> rawOctets
private string rawPath
private Uri requestUri
private void .ctor(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery)
public Uri GetRequestUri(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery)
private Uri Build()
private void BuildRequestUriUsingCookedPath()
private void BuildRequestUriUsingRawPath()
private Encoding GetEncoding(EncodingType type)
private ParsingResult BuildRequestUriUsingRawPath(Encoding encoding)
private ParsingResult ParseRawPath(Encoding encoding)
private bool AppendUnicodeCodePointValuePercentEncoded(string codePoint)
private bool AddPercentEncodedOctetToRawOctetsList(Encoding encoding, string escapedCharacter)
private bool EmptyDecodeAndAppendRawOctetsList(Encoding encoding)
private void AppendOctetsPercentEncoded(StringBuilder target, IEnumerable`1<byte> octets)
private string GetOctetsAsString(IEnumerable`1<byte> octets)
private string GetPath(string uriString)
private string AddSlashToAsteriskOnlyPath(string path)
private void LogWarning(string methodName, string message, Object[] args)
}
public System.Net.HttpListenerResponse : object {
private bool disposed
private Encoding content_encoding
private long content_length
private bool cl_set
private string content_type
private CookieCollection cookies
private WebHeaderCollection headers
private bool keep_alive
private ResponseStream output_stream
private Version version
private string location
private int status_code
private string status_description
private bool chunked
private HttpListenerContext context
internal bool HeadersSent
internal object headers_lock
private bool force_close_chunked
private string tspecials
internal bool ForceCloseChunked
public Encoding ContentEncoding
public long ContentLength64
public string ContentType
public CookieCollection Cookies
public WebHeaderCollection Headers
public bool KeepAlive
public Stream OutputStream
public Version ProtocolVersion
public string RedirectLocation
public bool SendChunked
public int StatusCode
public string StatusDescription
internal void .ctor(HttpListenerContext context)
internal bool get_ForceCloseChunked()
public Encoding get_ContentEncoding()
public void set_ContentEncoding(Encoding value)
public long get_ContentLength64()
public void set_ContentLength64(long value)
public string get_ContentType()
public void set_ContentType(string value)
public CookieCollection get_Cookies()
public void set_Cookies(CookieCollection value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public Stream get_OutputStream()
public Version get_ProtocolVersion()
public void set_ProtocolVersion(Version value)
public string get_RedirectLocation()
public void set_RedirectLocation(string value)
public bool get_SendChunked()
public void set_SendChunked(bool value)
public int get_StatusCode()
public void set_StatusCode(int value)
public string get_StatusDescription()
public void set_StatusDescription(string value)
private void System.IDisposable.Dispose()
public void Abort()
public void AddHeader(string name, string value)
public void AppendCookie(Cookie cookie)
public void AppendHeader(string name, string value)
private void Close(bool force)
public void Close()
public void Close(Byte[] responseEntity, bool willBlock)
public void CopyFrom(HttpListenerResponse templateResponse)
public void Redirect(string url)
private bool FindCookie(Cookie cookie)
internal void SendHeaders(bool closing, MemoryStream ms)
private string FormatHeaders(WebHeaderCollection headers)
private string CookieToClientString(Cookie cookie)
private string QuotedString(Cookie cookie, string value)
private bool IsToken(string value)
public void SetCookie(Cookie cookie)
}
public System.Net.HttpListenerTimeoutManager : object {
public TimeSpan EntityBody
public TimeSpan DrainEntityBody
public TimeSpan RequestQueue
public TimeSpan IdleConnection
public TimeSpan HeaderWait
public long MinSendBytesPerSecond
public TimeSpan get_EntityBody()
public void set_EntityBody(TimeSpan value)
public TimeSpan get_DrainEntityBody()
public void set_DrainEntityBody(TimeSpan value)
public TimeSpan get_RequestQueue()
public void set_RequestQueue(TimeSpan value)
public TimeSpan get_IdleConnection()
public void set_IdleConnection(TimeSpan value)
public TimeSpan get_HeaderWait()
public void set_HeaderWait(TimeSpan value)
public long get_MinSendBytesPerSecond()
public void set_MinSendBytesPerSecond(long value)
}
internal System.Net.HttpProcessingResult : Enum {
public int value__
public HttpProcessingResult Continue
public HttpProcessingResult ReadWait
public HttpProcessingResult WriteWait
}
internal System.Net.HttpProtocolUtils : object {
internal DateTime string2date(string S)
internal string date2string(DateTime D)
}
internal System.Net.HttpRequestCreator : object {
public WebRequest Create(Uri uri)
}
public System.Net.HttpRequestHeader : Enum {
public int value__
public HttpRequestHeader CacheControl
public HttpRequestHeader Connection
public HttpRequestHeader Date
public HttpRequestHeader KeepAlive
public HttpRequestHeader Pragma
public HttpRequestHeader Trailer
public HttpRequestHeader TransferEncoding
public HttpRequestHeader Upgrade
public HttpRequestHeader Via
public HttpRequestHeader Warning
public HttpRequestHeader Allow
public HttpRequestHeader ContentLength
public HttpRequestHeader ContentType
public HttpRequestHeader ContentEncoding
public HttpRequestHeader ContentLanguage
public HttpRequestHeader ContentLocation
public HttpRequestHeader ContentMd5
public HttpRequestHeader ContentRange
public HttpRequestHeader Expires
public HttpRequestHeader LastModified
public HttpRequestHeader Accept
public HttpRequestHeader AcceptCharset
public HttpRequestHeader AcceptEncoding
public HttpRequestHeader AcceptLanguage
public HttpRequestHeader Authorization
public HttpRequestHeader Cookie
public HttpRequestHeader Expect
public HttpRequestHeader From
public HttpRequestHeader Host
public HttpRequestHeader IfMatch
public HttpRequestHeader IfModifiedSince
public HttpRequestHeader IfNoneMatch
public HttpRequestHeader IfRange
public HttpRequestHeader IfUnmodifiedSince
public HttpRequestHeader MaxForwards
public HttpRequestHeader ProxyAuthorization
public HttpRequestHeader Referer
public HttpRequestHeader Range
public HttpRequestHeader Te
public HttpRequestHeader Translate
public HttpRequestHeader UserAgent
}
public System.Net.HttpResponseHeader : Enum {
public int value__
public HttpResponseHeader CacheControl
public HttpResponseHeader Connection
public HttpResponseHeader Date
public HttpResponseHeader KeepAlive
public HttpResponseHeader Pragma
public HttpResponseHeader Trailer
public HttpResponseHeader TransferEncoding
public HttpResponseHeader Upgrade
public HttpResponseHeader Via
public HttpResponseHeader Warning
public HttpResponseHeader Allow
public HttpResponseHeader ContentLength
public HttpResponseHeader ContentType
public HttpResponseHeader ContentEncoding
public HttpResponseHeader ContentLanguage
public HttpResponseHeader ContentLocation
public HttpResponseHeader ContentMd5
public HttpResponseHeader ContentRange
public HttpResponseHeader Expires
public HttpResponseHeader LastModified
public HttpResponseHeader AcceptRanges
public HttpResponseHeader Age
public HttpResponseHeader ETag
public HttpResponseHeader Location
public HttpResponseHeader ProxyAuthenticate
public HttpResponseHeader RetryAfter
public HttpResponseHeader Server
public HttpResponseHeader SetCookie
public HttpResponseHeader Vary
public HttpResponseHeader WwwAuthenticate
}
public System.Net.HttpStatusCode : Enum {
public int value__
public HttpStatusCode Continue
public HttpStatusCode SwitchingProtocols
public HttpStatusCode Processing
public HttpStatusCode EarlyHints
public HttpStatusCode OK
public HttpStatusCode Created
public HttpStatusCode Accepted
public HttpStatusCode NonAuthoritativeInformation
public HttpStatusCode NoContent
public HttpStatusCode ResetContent
public HttpStatusCode PartialContent
public HttpStatusCode MultiStatus
public HttpStatusCode AlreadyReported
public HttpStatusCode IMUsed
public HttpStatusCode MultipleChoices
public HttpStatusCode Ambiguous
public HttpStatusCode MovedPermanently
public HttpStatusCode Moved
public HttpStatusCode Found
public HttpStatusCode Redirect
public HttpStatusCode SeeOther
public HttpStatusCode RedirectMethod
public HttpStatusCode NotModified
public HttpStatusCode UseProxy
public HttpStatusCode Unused
public HttpStatusCode TemporaryRedirect
public HttpStatusCode RedirectKeepVerb
public HttpStatusCode PermanentRedirect
public HttpStatusCode BadRequest
public HttpStatusCode Unauthorized
public HttpStatusCode PaymentRequired
public HttpStatusCode Forbidden
public HttpStatusCode NotFound
public HttpStatusCode MethodNotAllowed
public HttpStatusCode NotAcceptable
public HttpStatusCode ProxyAuthenticationRequired
public HttpStatusCode RequestTimeout
public HttpStatusCode Conflict
public HttpStatusCode Gone
public HttpStatusCode LengthRequired
public HttpStatusCode PreconditionFailed
public HttpStatusCode RequestEntityTooLarge
public HttpStatusCode RequestUriTooLong
public HttpStatusCode UnsupportedMediaType
public HttpStatusCode RequestedRangeNotSatisfiable
public HttpStatusCode ExpectationFailed
public HttpStatusCode MisdirectedRequest
public HttpStatusCode UnprocessableEntity
public HttpStatusCode Locked
public HttpStatusCode FailedDependency
public HttpStatusCode UpgradeRequired
public HttpStatusCode PreconditionRequired
public HttpStatusCode TooManyRequests
public HttpStatusCode RequestHeaderFieldsTooLarge
public HttpStatusCode UnavailableForLegalReasons
public HttpStatusCode InternalServerError
public HttpStatusCode NotImplemented
public HttpStatusCode BadGateway
public HttpStatusCode ServiceUnavailable
public HttpStatusCode GatewayTimeout
public HttpStatusCode HttpVersionNotSupported
public HttpStatusCode VariantAlsoNegotiates
public HttpStatusCode InsufficientStorage
public HttpStatusCode LoopDetected
public HttpStatusCode NotExtended
public HttpStatusCode NetworkAuthenticationRequired
}
internal System.Net.HttpStatusDescription : object {
internal string Get(HttpStatusCode code)
internal string Get(int code)
}
internal System.Net.HttpStreamAsyncResult : object {
private object locker
private ManualResetEvent handle
private bool completed
internal Byte[] Buffer
internal int Offset
internal int Count
internal AsyncCallback Callback
internal object State
internal int SynchRead
internal Exception Error
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public void Complete(Exception e)
public void Complete()
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
}
internal System.Net.HttpSysSettings : object {
public bool EnableNonUtf8
public bool FavorUtf8
}
internal System.Net.HttpValidationHelpers : object {
private Char[] s_httpTrimCharacters
internal string CheckBadHeaderNameChars(string name)
internal bool ContainsNonAsciiChars(string token)
internal bool IsValidToken(string token)
public string CheckBadHeaderValueChars(string value)
public bool IsInvalidMethodOrHeaderString(string stringValue)
}
public System.Net.HttpVersion : object {
public Version Unknown
public Version Version10
public Version Version11
public Version Version20
}
public System.Net.HttpWebRequest : WebRequest {
private Uri requestUri
private Uri actualUri
private bool hostChanged
private bool allowAutoRedirect
private bool allowBuffering
private bool allowReadStreamBuffering
private X509CertificateCollection certificates
private string connectionGroup
private bool haveContentLength
private long contentLength
private HttpContinueDelegate continueDelegate
private CookieContainer cookieContainer
private ICredentials credentials
private bool haveResponse
private bool requestSent
private WebHeaderCollection webHeaders
private bool keepAlive
private int maxAutoRedirect
private string mediaType
private string method
private string initialMethod
private bool pipelined
private bool preAuthenticate
private bool usedPreAuth
private Version version
private bool force_version
private Version actualVersion
private IWebProxy proxy
private bool sendChunked
private ServicePoint servicePoint
private int timeout
private int continueTimeout
private WebRequestStream writeStream
private HttpWebResponse webResponse
private WebCompletionSource responseTask
private WebOperation currentOperation
private int aborted
private bool gotRequestStream
private int redirects
private bool expectContinue
private bool getResponseCalled
private object locker
private bool finished_reading
private DecompressionMethods auto_decomp
private int maxResponseHeadersLength
private int defaultMaxResponseHeadersLength
private int defaultMaximumErrorResponseLength
private RequestCachePolicy defaultCachePolicy
private int readWriteTimeout
private MobileTlsProvider tlsProvider
private MonoTlsSettings tlsSettings
private ServerCertValidationCallback certValidationCallback
private bool hostHasPort
private Uri hostUri
private AuthorizationState auth_state
private AuthorizationState proxy_auth_state
internal Func`2<Stream, Task> ResendContentFactory
internal int ID
private bool <ThrowOnError>k__BackingField
private bool unsafe_auth_blah
private bool <ReuseConnection>k__BackingField
public string Accept
public Uri Address
public bool AllowAutoRedirect
public bool AllowWriteStreamBuffering
public bool AllowReadStreamBuffering
public DecompressionMethods AutomaticDecompression
internal bool InternalAllowBuffering
private bool MethodWithBuffer
internal MobileTlsProvider TlsProvider
internal MonoTlsSettings TlsSettings
public X509CertificateCollection ClientCertificates
public string Connection
public string ConnectionGroupName
public long ContentLength
internal long InternalContentLength
internal bool ThrowOnError
public string ContentType
public HttpContinueDelegate ContinueDelegate
public CookieContainer CookieContainer
public ICredentials Credentials
public DateTime Date
public RequestCachePolicy DefaultCachePolicy
public int DefaultMaximumErrorResponseLength
public string Expect
public bool HaveResponse
public WebHeaderCollection Headers
public string Host
public DateTime IfModifiedSince
public bool KeepAlive
public int MaximumAutomaticRedirections
public int MaximumResponseHeadersLength
public int DefaultMaximumResponseHeadersLength
public int ReadWriteTimeout
public int ContinueTimeout
public string MediaType
public string Method
public bool Pipelined
public bool PreAuthenticate
public Version ProtocolVersion
public IWebProxy Proxy
public string Referer
public Uri RequestUri
public bool SendChunked
public ServicePoint ServicePoint
internal ServicePoint ServicePointNoLock
public bool SupportsCookieContainer
public int Timeout
public string TransferEncoding
public bool UseDefaultCredentials
public string UserAgent
public bool UnsafeAuthenticatedConnectionSharing
internal bool GotRequestStream
internal bool ExpectContinue
internal Uri AuthUri
internal bool ProxyQuery
internal ServerCertValidationCallback ServerCertValidationCallback
public RemoteCertificateValidationCallback ServerCertificateValidationCallback
internal bool FinishedReading
internal bool Aborted
internal bool ReuseConnection
internal void .ctor(Uri uri)
internal void .ctor(Uri uri, MobileTlsProvider tlsProvider, MonoTlsSettings settings)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void ResetAuthorization()
private void SetSpecialHeaders(string HeaderName, string value)
public string get_Accept()
public void set_Accept(string value)
public Uri get_Address()
internal void set_Address(Uri value)
public bool get_AllowAutoRedirect()
public void set_AllowAutoRedirect(bool value)
public bool get_AllowWriteStreamBuffering()
public void set_AllowWriteStreamBuffering(bool value)
public bool get_AllowReadStreamBuffering()
public void set_AllowReadStreamBuffering(bool value)
private Exception GetMustImplement()
public DecompressionMethods get_AutomaticDecompression()
public void set_AutomaticDecompression(DecompressionMethods value)
internal bool get_InternalAllowBuffering()
private bool get_MethodWithBuffer()
internal MobileTlsProvider get_TlsProvider()
internal MonoTlsSettings get_TlsSettings()
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public string get_Connection()
public void set_Connection(string value)
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public long get_ContentLength()
public void set_ContentLength(long value)
internal void set_InternalContentLength(long value)
internal bool get_ThrowOnError()
internal void set_ThrowOnError(bool value)
public string get_ContentType()
public void set_ContentType(string value)
public HttpContinueDelegate get_ContinueDelegate()
public void set_ContinueDelegate(HttpContinueDelegate value)
public CookieContainer get_CookieContainer()
public void set_CookieContainer(CookieContainer value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public DateTime get_Date()
public void set_Date(DateTime value)
private void SetDateHeaderHelper(string headerName, DateTime dateTime)
public RequestCachePolicy get_DefaultCachePolicy()
public void set_DefaultCachePolicy(RequestCachePolicy value)
public int get_DefaultMaximumErrorResponseLength()
public void set_DefaultMaximumErrorResponseLength(int value)
public string get_Expect()
public void set_Expect(string value)
public bool get_HaveResponse()
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public string get_Host()
public void set_Host(string value)
private bool TryGetHostUri(string hostName, Uri& hostUri)
public DateTime get_IfModifiedSince()
public void set_IfModifiedSince(DateTime value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public int get_MaximumAutomaticRedirections()
public void set_MaximumAutomaticRedirections(int value)
public int get_MaximumResponseHeadersLength()
public void set_MaximumResponseHeadersLength(int value)
public int get_DefaultMaximumResponseHeadersLength()
public void set_DefaultMaximumResponseHeadersLength(int value)
public int get_ReadWriteTimeout()
public void set_ReadWriteTimeout(int value)
public int get_ContinueTimeout()
public void set_ContinueTimeout(int value)
public string get_MediaType()
public void set_MediaType(string value)
public string get_Method()
public void set_Method(string value)
public bool get_Pipelined()
public void set_Pipelined(bool value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public Version get_ProtocolVersion()
public void set_ProtocolVersion(Version value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public string get_Referer()
public void set_Referer(string value)
public Uri get_RequestUri()
public bool get_SendChunked()
public void set_SendChunked(bool value)
public ServicePoint get_ServicePoint()
internal ServicePoint get_ServicePointNoLock()
public bool get_SupportsCookieContainer()
public int get_Timeout()
public void set_Timeout(int value)
public string get_TransferEncoding()
public void set_TransferEncoding(string value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public string get_UserAgent()
public void set_UserAgent(string value)
public bool get_UnsafeAuthenticatedConnectionSharing()
public void set_UnsafeAuthenticatedConnectionSharing(bool value)
internal bool get_GotRequestStream()
internal bool get_ExpectContinue()
internal void set_ExpectContinue(bool value)
internal Uri get_AuthUri()
internal bool get_ProxyQuery()
internal ServerCertValidationCallback get_ServerCertValidationCallback()
public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback()
public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value)
internal ServicePoint GetServicePoint()
public void AddRange(int range)
public void AddRange(int from, int to)
public void AddRange(string rangeSpecifier, int range)
public void AddRange(string rangeSpecifier, int from, int to)
public void AddRange(long range)
public void AddRange(long from, long to)
public void AddRange(string rangeSpecifier, long range)
public void AddRange(string rangeSpecifier, long from, long to)
private WebOperation SendRequest(bool redirecting, BufferOffsetSize writeBuffer, CancellationToken cancellationToken)
private Task`1<Stream> MyGetRequestStreamAsync(CancellationToken cancellationToken)
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public Stream GetRequestStream()
public Stream GetRequestStream(TransportContext& context)
public Task`1<Stream> GetRequestStreamAsync()
internal Task`1<T> RunWithTimeout(Func`2<CancellationToken, Task`1<T>> func, int timeout, Action abort, Func`1<bool> aborted, CancellationToken cancellationToken)
private Task`1<T> RunWithTimeoutWorker(Task`1<T> workerTask, int timeout, Action abort, Func`1<bool> aborted, CancellationTokenSource cts)
private Task`1<T> RunWithTimeout(Func`2<CancellationToken, Task`1<T>> func)
private Task`1<HttpWebResponse> MyGetResponseAsync(CancellationToken cancellationToken)
private Task`1<ValueTuple`5<HttpWebResponse, bool, bool, BufferOffsetSize, WebOperation>> GetResponseFromData(WebResponseStream stream, CancellationToken cancellationToken)
internal Exception FlattenException(Exception e)
private WebException GetWebException(Exception e)
private WebException GetWebException(Exception e, bool aborted)
internal WebException CreateRequestAbortedException()
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public Stream EndGetRequestStream(IAsyncResult asyncResult, TransportContext& context)
public WebResponse GetResponse()
internal bool get_FinishedReading()
internal void set_FinishedReading(bool value)
internal bool get_Aborted()
public void Abort()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void CheckRequestStarted()
internal void DoContinueDelegate(int statusCode, WebHeaderCollection headers)
private void RewriteRedirectToGet()
private bool Redirect(HttpStatusCode code, WebResponse response)
private string GetHeaders()
private void DoPreAuthenticate()
internal Byte[] GetRequestHeaders()
private ValueTuple`2<WebOperation, bool> HandleNtlmAuth(WebResponseStream stream, HttpWebResponse response, BufferOffsetSize writeBuffer, CancellationToken cancellationToken)
private bool CheckAuthorization(WebResponse response, HttpStatusCode code)
private ValueTuple`2<Task`1<BufferOffsetSize>, WebException> GetRewriteHandler(HttpWebResponse response, bool redirect)
private ValueTuple`4<bool, bool, Task`1<BufferOffsetSize>, WebException> CheckFinalStatus(HttpWebResponse response)
internal bool get_ReuseConnection()
internal void set_ReuseConnection(bool value)
internal StringBuilder GenerateConnectionGroup(string connectionGroupName, bool unsafeConnectionGroup, bool isInternalGroup)
private bool <RunWithTimeout>b__245_0()
private Task`1<BufferOffsetSize> <GetRewriteHandler>b__274_0()
}
public System.Net.HttpWebResponse : WebResponse {
private Uri uri
private WebHeaderCollection webHeaders
private CookieCollection cookieCollection
private string method
private Version version
private HttpStatusCode statusCode
private string statusDescription
private long contentLength
private string contentType
private CookieContainer cookie_container
private bool disposed
private Stream stream
public string CharacterSet
public string ContentEncoding
public long ContentLength
public string ContentType
public CookieCollection Cookies
public WebHeaderCollection Headers
public bool IsMutuallyAuthenticated
public DateTime LastModified
public string Method
public Version ProtocolVersion
public Uri ResponseUri
public string Server
public HttpStatusCode StatusCode
public string StatusDescription
public bool SupportsHeaders
internal void .ctor(Uri uri, string method, HttpStatusCode status, WebHeaderCollection headers)
internal void .ctor(Uri uri, string method, WebResponseStream stream, CookieContainer container)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public string get_CharacterSet()
public string get_ContentEncoding()
public long get_ContentLength()
public string get_ContentType()
public CookieCollection get_Cookies()
public void set_Cookies(CookieCollection value)
public WebHeaderCollection get_Headers()
private Exception GetMustImplement()
public bool get_IsMutuallyAuthenticated()
public DateTime get_LastModified()
public string get_Method()
public Version get_ProtocolVersion()
public Uri get_ResponseUri()
public string get_Server()
public HttpStatusCode get_StatusCode()
public string get_StatusDescription()
public bool get_SupportsHeaders()
public string GetResponseHeader(string headerName)
public Stream GetResponseStream()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void Close()
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
private void CheckDisposed()
private void FillCookies()
}
internal System.Net.HttpWriteMode : Enum {
public int value__
public HttpWriteMode Unknown
public HttpWriteMode ContentLength
public HttpWriteMode Chunked
public HttpWriteMode Buffer
public HttpWriteMode None
}
public System.Net.IAuthenticationModule {
public bool CanPreAuthenticate
public string AuthenticationType
public Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest request, ICredentials credentials)
public bool get_CanPreAuthenticate()
public string get_AuthenticationType()
}
internal System.Net.IAutoWebProxy {
public ProxyChain GetProxies(Uri destination)
}
public System.Net.ICertificatePolicy {
public bool CheckValidationResult(ServicePoint srvPoint, X509Certificate certificate, WebRequest request, int certificateProblem)
}
internal System.Net.ICloseEx {
public void CloseEx(CloseExState closeState)
}
public System.Net.ICredentialPolicy {
public bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule)
}
public System.Net.ICredentials {
public NetworkCredential GetCredential(Uri uri, string authType)
}
public System.Net.ICredentialsByHost {
public NetworkCredential GetCredential(string host, int port, string authenticationType)
}
internal System.Net.IgnoreCertProblem : Enum {
public int value__
public IgnoreCertProblem not_time_valid
public IgnoreCertProblem ctl_not_time_valid
public IgnoreCertProblem not_time_nested
public IgnoreCertProblem invalid_basic_constraints
public IgnoreCertProblem all_not_time_valid
public IgnoreCertProblem allow_unknown_ca
public IgnoreCertProblem wrong_usage
public IgnoreCertProblem invalid_name
public IgnoreCertProblem invalid_policy
public IgnoreCertProblem end_rev_unknown
public IgnoreCertProblem ctl_signer_rev_unknown
public IgnoreCertProblem ca_rev_unknown
public IgnoreCertProblem root_rev_unknown
public IgnoreCertProblem all_rev_unknown
public IgnoreCertProblem none
}
internal System.Net.InterlockedGate : ValueType {
private int m_State
internal int Open
internal int Triggering
internal int Triggered
internal int Signaling
internal int Signaled
internal int Completed
internal void Reset()
internal bool Trigger(bool exclusive)
internal bool StartTriggering(bool exclusive)
internal void FinishTriggering()
internal bool StartSignaling(bool exclusive)
internal void FinishSignaling()
internal bool Complete()
}
internal System.Net.InternalException : SystemException {
internal void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.Net.IntPtrHelper : object {
internal IntPtr Add(IntPtr a, int b)
internal long Subtract(IntPtr a, IntPtr b)
}
public System.Net.IPAddress : object {
public IPAddress Any
public IPAddress Loopback
public IPAddress Broadcast
public IPAddress None
internal long LoopbackMask
public IPAddress IPv6Any
public IPAddress IPv6Loopback
public IPAddress IPv6None
private UInt32 _addressOrScopeId
private UInt16[] _numbers
private string _toString
private int _hashCode
internal int NumberOfLabels
private bool IsIPv4
private bool IsIPv6
private UInt32 PrivateAddress
private UInt32 PrivateScopeId
public AddressFamily AddressFamily
public long ScopeId
public bool IsIPv6Multicast
public bool IsIPv6LinkLocal
public bool IsIPv6SiteLocal
public bool IsIPv6Teredo
public bool IsIPv4MappedToIPv6
public long Address
private bool get_IsIPv4()
private bool get_IsIPv6()
private UInt32 get_PrivateAddress()
private void set_PrivateAddress(UInt32 value)
private UInt32 get_PrivateScopeId()
private void set_PrivateScopeId(UInt32 value)
public void .ctor(long newAddress)
public void .ctor(Byte[] address, long scopeid)
public void .ctor(ReadOnlySpan`1<byte> address, long scopeid)
internal void .ctor(UInt16* numbers, int numbersLength, UInt32 scopeid)
private void .ctor(UInt16[] numbers, UInt32 scopeid)
public void .ctor(Byte[] address)
public void .ctor(ReadOnlySpan`1<byte> address)
internal void .ctor(int newAddress)
public bool TryParse(string ipString, IPAddress& address)
public bool TryParse(ReadOnlySpan`1<char> ipSpan, IPAddress& address)
public IPAddress Parse(string ipString)
public IPAddress Parse(ReadOnlySpan`1<char> ipSpan)
public bool TryWriteBytes(Span`1<byte> destination, Int32& bytesWritten)
private void WriteIPv6Bytes(Span`1<byte> destination)
private void WriteIPv4Bytes(Span`1<byte> destination)
public Byte[] GetAddressBytes()
public AddressFamily get_AddressFamily()
public long get_ScopeId()
public void set_ScopeId(long value)
public string ToString()
public bool TryFormat(Span`1<char> destination, Int32& charsWritten)
public long HostToNetworkOrder(long host)
public int HostToNetworkOrder(int host)
public short HostToNetworkOrder(short host)
public long NetworkToHostOrder(long network)
public int NetworkToHostOrder(int network)
public short NetworkToHostOrder(short network)
public bool IsLoopback(IPAddress address)
public bool get_IsIPv6Multicast()
public bool get_IsIPv6LinkLocal()
public bool get_IsIPv6SiteLocal()
public bool get_IsIPv6Teredo()
public bool get_IsIPv4MappedToIPv6()
public long get_Address()
public void set_Address(long value)
internal bool Equals(object comparandObj, bool compareScopeId)
public bool Equals(object comparand)
public int GetHashCode()
public IPAddress MapToIPv6()
public IPAddress MapToIPv4()
private Byte[] ThrowAddressNullException()
}
internal System.Net.IPAddressParser : object {
private int MaxIPv4StringLength
internal IPAddress Parse(ReadOnlySpan`1<char> ipSpan, bool tryParse)
internal string IPv4AddressToString(UInt32 address)
internal void IPv4AddressToString(UInt32 address, StringBuilder destination)
internal bool IPv4AddressToString(UInt32 address, Span`1<char> formatted, Int32& charsWritten)
private int IPv4AddressToStringHelper(UInt32 address, Char* addressString)
internal string IPv6AddressToString(UInt16[] address, UInt32 scopeId)
internal bool IPv6AddressToString(UInt16[] address, UInt32 scopeId, Span`1<char> destination, Int32& charsWritten)
internal StringBuilder IPv6AddressToStringHelper(UInt16[] address, UInt32 scopeId)
private void FormatIPv4AddressNumber(int number, Char* addressString, Int32& offset)
public bool Ipv4StringToAddress(ReadOnlySpan`1<char> ipSpan, Int64& address)
public bool Ipv6StringToAddress(ReadOnlySpan`1<char> ipSpan, UInt16* numbers, int numbersLength, UInt32& scope)
private void AppendSections(UInt16[] address, int fromInclusive, int toExclusive, StringBuilder buffer)
private void AppendHex(ushort value, StringBuilder buffer)
private UInt32 ExtractIPv4Address(UInt16[] address)
private ushort Reverse(ushort number)
}
internal System.Net.IPAddressParserStatics : object {
public int IPv4AddressBytes
public int IPv6AddressBytes
public int IPv6AddressShorts
}
public System.Net.IPEndPoint : EndPoint {
public int MinPort
public int MaxPort
private IPAddress _address
private int _port
internal int AnyPort
internal IPEndPoint Any
internal IPEndPoint IPv6Any
public AddressFamily AddressFamily
public IPAddress Address
public int Port
public AddressFamily get_AddressFamily()
public void .ctor(long address, int port)
public void .ctor(IPAddress address, int port)
public IPAddress get_Address()
public void set_Address(IPAddress value)
public int get_Port()
public void set_Port(int value)
public string ToString()
public SocketAddress Serialize()
public EndPoint Create(SocketAddress socketAddress)
public bool Equals(object comparand)
public int GetHashCode()
}
public System.Net.IPHostEntry : object {
private string hostName
private String[] aliases
private IPAddress[] addressList
internal bool isTrustedHost
public string HostName
public String[] Aliases
public IPAddress[] AddressList
public string get_HostName()
public void set_HostName(string value)
public String[] get_Aliases()
public void set_Aliases(String[] value)
public IPAddress[] get_AddressList()
public void set_AddressList(IPAddress[] value)
}
internal System.Net.IPv6AddressFormatter : ValueType {
private UInt16[] address
private long scopeId
public void .ctor(UInt16[] addr, long scopeId)
private ushort SwapUShort(ushort number)
private UInt32 AsIPv4Int()
private bool IsIPv4Compatible()
private bool IsIPv4Mapped()
public string ToString()
}
public System.Net.IWebProxy {
public ICredentials Credentials
public Uri GetProxy(Uri destination)
public bool IsBypassed(Uri host)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
}
internal System.Net.IWebProxyFinder {
public bool IsValid
public bool GetProxies(Uri destination, IList`1& proxyList)
public void Abort()
public void Reset()
public bool get_IsValid()
}
public System.Net.IWebProxyScript {
public void Close()
public bool Load(Uri scriptLocation, string script, Type helperType)
public string Run(string url, string host)
}
public System.Net.IWebRequestCreate {
public WebRequest Create(Uri uri)
}
internal System.Net.KnownHttpVerb : object {
internal string Name
internal bool RequireContentBody
internal bool ContentBodyNotAllowed
internal bool ConnectRequest
internal bool ExpectNoContentResponse
private ListDictionary NamedHeaders
internal KnownHttpVerb Get
internal KnownHttpVerb Connect
internal KnownHttpVerb Head
internal KnownHttpVerb Put
internal KnownHttpVerb Post
internal KnownHttpVerb MkCol
internal void .ctor(string name, bool requireContentBody, bool contentBodyNotAllowed, bool connectRequest, bool expectNoContentResponse)
public bool Equals(KnownHttpVerb verb)
public KnownHttpVerb Parse(string name)
}
internal System.Net.LazyAsyncResult : object {
private int c_HighBit
private int c_ForceAsyncCount
private ThreadContext t_ThreadContext
private object m_AsyncObject
private object m_AsyncState
private AsyncCallback m_AsyncCallback
private object m_Result
private int m_ErrorCode
private int m_IntCompleted
private bool m_EndCalled
private bool m_UserEvent
private object m_Event
private ThreadContext CurrentThreadContext
internal object AsyncObject
public object AsyncState
protected AsyncCallback AsyncCallback
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
internal bool InternalPeekCompleted
internal object Result
internal bool EndCalled
internal int ErrorCode
private ThreadContext get_CurrentThreadContext()
internal void .ctor(object myObject, object myState, AsyncCallback myCallBack)
internal void .ctor(object myObject, object myState, AsyncCallback myCallBack, object result)
internal object get_AsyncObject()
public object get_AsyncState()
protected AsyncCallback get_AsyncCallback()
protected void set_AsyncCallback(AsyncCallback value)
public WaitHandle get_AsyncWaitHandle()
private bool LazilyCreateEvent(ManualResetEvent& waitHandle)
protected void DebugProtectState(bool protect)
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
internal bool get_InternalPeekCompleted()
internal object get_Result()
internal void set_Result(object value)
internal bool get_EndCalled()
internal void set_EndCalled(bool value)
internal int get_ErrorCode()
internal void set_ErrorCode(int value)
protected void ProtectedInvokeCallback(object result, IntPtr userToken)
internal void InvokeCallback(object result)
internal void InvokeCallback()
protected void Complete(IntPtr userToken)
private void WorkerThreadComplete(object state)
protected void Cleanup()
internal object InternalWaitForCompletion()
private object WaitForCompletion(bool snap)
internal void InternalCleanup()
}
internal System.Net.ListenerAsyncResult : object {
private ManualResetEvent handle
private bool synch
private bool completed
private AsyncCallback cb
private object state
private Exception exception
private HttpListenerContext context
private object locker
private ListenerAsyncResult forward
internal bool EndCalled
internal bool InGet
private WaitCallback InvokeCB
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public void .ctor(AsyncCallback cb, object state)
internal void Complete(Exception exc)
private void InvokeCallback(object o)
internal void Complete(HttpListenerContext context)
internal void Complete(HttpListenerContext context, bool synch)
internal HttpListenerContext GetContext()
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
}
internal System.Net.ListenerPrefix : object {
private string original
private string host
private ushort port
private string path
private bool secure
private IPAddress[] addresses
public HttpListener Listener
public IPAddress[] Addresses
public bool Secure
public string Host
public int Port
public string Path
public void .ctor(string prefix)
public string ToString()
public IPAddress[] get_Addresses()
public void set_Addresses(IPAddress[] value)
public bool get_Secure()
public string get_Host()
public int get_Port()
public string get_Path()
public bool Equals(object o)
public int GetHashCode()
private void Parse(string uri)
public void CheckUri(string uri)
}
internal System.Net.Logging : object {
internal bool On
internal TraceSource Web
internal TraceSource HttpListener
internal TraceSource Sockets
internal bool get_On()
internal TraceSource get_Web()
internal TraceSource get_HttpListener()
internal TraceSource get_Sockets()
internal void Enter(TraceSource traceSource, object obj, string method, object paramObject)
internal void Enter(TraceSource traceSource, string msg)
internal void Enter(TraceSource traceSource, string msg, string parameters)
internal void Exception(TraceSource traceSource, object obj, string method, Exception e)
internal void Exit(TraceSource traceSource, object obj, string method, object retObject)
internal void Exit(TraceSource traceSource, string msg)
internal void Exit(TraceSource traceSource, string msg, string parameters)
internal void PrintInfo(TraceSource traceSource, object obj, string method, string msg)
internal void PrintInfo(TraceSource traceSource, object obj, string msg)
internal void PrintInfo(TraceSource traceSource, string msg)
internal void PrintWarning(TraceSource traceSource, object obj, string method, string msg)
internal void PrintWarning(TraceSource traceSource, string msg)
internal void PrintError(TraceSource traceSource, string msg)
}
public System.Net.Mail.AlternateView : AttachmentBase {
private Uri baseUri
private LinkedResourceCollection linkedResources
public Uri BaseUri
public LinkedResourceCollection LinkedResources
public void .ctor(string fileName)
public void .ctor(string fileName, ContentType contentType)
public void .ctor(string fileName, string mediaType)
public void .ctor(Stream contentStream)
public void .ctor(Stream contentStream, string mediaType)
public void .ctor(Stream contentStream, ContentType contentType)
public Uri get_BaseUri()
public void set_BaseUri(Uri value)
public LinkedResourceCollection get_LinkedResources()
public AlternateView CreateAlternateViewFromString(string content)
public AlternateView CreateAlternateViewFromString(string content, ContentType contentType)
public AlternateView CreateAlternateViewFromString(string content, Encoding contentEncoding, string mediaType)
protected void Dispose(bool disposing)
}
public System.Net.Mail.AlternateViewCollection : Collection`1<AlternateView> {
public void Dispose()
protected void ClearItems()
protected void InsertItem(int index, AlternateView item)
protected void RemoveItem(int index)
protected void SetItem(int index, AlternateView item)
}
public System.Net.Mail.Attachment : AttachmentBase {
private ContentDisposition contentDisposition
private Encoding nameEncoding
public ContentDisposition ContentDisposition
public string Name
public Encoding NameEncoding
public void .ctor(string fileName)
public void .ctor(string fileName, string mediaType)
public void .ctor(string fileName, ContentType contentType)
public void .ctor(Stream contentStream, ContentType contentType)
public void .ctor(Stream contentStream, string name)
public void .ctor(Stream contentStream, string name, string mediaType)
public ContentDisposition get_ContentDisposition()
public string get_Name()
public void set_Name(string value)
public Encoding get_NameEncoding()
public void set_NameEncoding(Encoding value)
public Attachment CreateAttachmentFromString(string content, ContentType contentType)
public Attachment CreateAttachmentFromString(string content, string name)
public Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType)
private void InitName(string fileName)
}
public System.Net.Mail.AttachmentBase : object {
private string id
private ContentType contentType
private Stream contentStream
private TransferEncoding transferEncoding
public string ContentId
public Stream ContentStream
public ContentType ContentType
public TransferEncoding TransferEncoding
protected void .ctor(Stream contentStream)
protected void .ctor(Stream contentStream, ContentType contentType)
protected void .ctor(Stream contentStream, string mediaType)
protected void .ctor(string fileName)
protected void .ctor(string fileName, ContentType contentType)
protected void .ctor(string fileName, string mediaType)
public string get_ContentId()
public void set_ContentId(string value)
public Stream get_ContentStream()
public ContentType get_ContentType()
public void set_ContentType(ContentType value)
public TransferEncoding get_TransferEncoding()
public void set_TransferEncoding(TransferEncoding value)
public void Dispose()
protected void Dispose(bool disposing)
}
public System.Net.Mail.AttachmentCollection : Collection`1<Attachment> {
public void Dispose()
protected void ClearItems()
protected void InsertItem(int index, Attachment item)
protected void RemoveItem(int index)
protected void SetItem(int index, Attachment item)
}
internal System.Net.Mail.BufferBuilder : object {
private Byte[] _buffer
private int _offset
internal int Length
internal void .ctor(int initialSize)
private void EnsureBuffer(int count)
internal void Append(byte value)
internal void Append(Byte[] value)
internal void Append(Byte[] value, int offset, int count)
internal void Append(string value)
internal void Append(string value, bool allowUnicode)
internal void Append(string value, int offset, int count, bool allowUnicode)
internal void Append(string value, int offset, int count)
internal int get_Length()
internal Byte[] GetBuffer()
internal void Reset()
}
internal System.Net.Mail.CCredentialsByHost : object {
private string userName
private string password
public void .ctor(string userName, string password)
public NetworkCredential GetCredential(string host, int port, string authenticationType)
}
public System.Net.Mail.DeliveryNotificationOptions : Enum {
public int value__
public DeliveryNotificationOptions None
public DeliveryNotificationOptions OnSuccess
public DeliveryNotificationOptions OnFailure
public DeliveryNotificationOptions Delay
public DeliveryNotificationOptions Never
}
internal System.Net.Mail.DomainLiteralReader : object {
internal int ReadReverse(string data, int index)
}
internal System.Net.Mail.DotAtomReader : object {
internal int ReadReverse(string data, int index)
}
public System.Net.Mail.LinkedResource : AttachmentBase {
private Uri contentLink
public Uri ContentLink
public void .ctor(string fileName)
public void .ctor(string fileName, ContentType contentType)
public void .ctor(string fileName, string mediaType)
public void .ctor(Stream contentStream)
public void .ctor(Stream contentStream, ContentType contentType)
public void .ctor(Stream contentStream, string mediaType)
public Uri get_ContentLink()
public void set_ContentLink(Uri value)
public LinkedResource CreateLinkedResourceFromString(string content)
public LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType)
public LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType)
}
public System.Net.Mail.LinkedResourceCollection : Collection`1<LinkedResource> {
public void Dispose()
private void Dispose(bool disposing)
protected void ClearItems()
protected void InsertItem(int index, LinkedResource item)
protected void RemoveItem(int index)
protected void SetItem(int index, LinkedResource item)
}
public System.Net.Mail.MailAddress : object {
private Encoding _displayNameEncoding
private string _displayName
private string _userName
private string _host
private EncodedStreamFactory s_encoderFactory
public string DisplayName
public string User
public string Host
public string Address
private string SmtpAddress
internal void .ctor(string displayName, string userName, string domain)
public void .ctor(string address)
public void .ctor(string address, string displayName)
public void .ctor(string address, string displayName, Encoding displayNameEncoding)
public string get_DisplayName()
public string get_User()
private string GetUser(bool allowUnicode)
public string get_Host()
private string GetHost(bool allowUnicode)
public string get_Address()
private string GetAddress(bool allowUnicode)
private string get_SmtpAddress()
internal string GetSmtpAddress(bool allowUnicode)
public string ToString()
public bool Equals(object value)
public int GetHashCode()
internal string Encode(int charsConsumed, bool allowUnicode)
}
public System.Net.Mail.MailAddressCollection : Collection`1<MailAddress> {
public void Add(string addresses)
protected void SetItem(int index, MailAddress item)
protected void InsertItem(int index, MailAddress item)
internal void ParseValue(string addresses)
public string ToString()
internal string Encode(int charsConsumed, bool allowUnicode)
}
internal System.Net.Mail.MailAddressParser : object {
internal MailAddress ParseAddress(string data)
internal List`1<MailAddress> ParseMultipleAddresses(string data)
private MailAddress ParseAddress(string data, bool expectMultipleAddresses, Int32& index)
private int ReadCfwsAndThrowIfIncomplete(string data, int index)
private string ParseDomain(string data, Int32& index)
private string ParseLocalPart(string data, Int32& index, bool expectAngleBracket, bool expectMultipleAddresses)
private string ParseDisplayName(string data, Int32& index, bool expectMultipleAddresses)
internal string NormalizeOrThrow(string input)
}
internal System.Net.Mail.MailHeaderID : Enum {
public int value__
public MailHeaderID Bcc
public MailHeaderID Cc
public MailHeaderID Comments
public MailHeaderID ContentDescription
public MailHeaderID ContentDisposition
public MailHeaderID ContentID
public MailHeaderID ContentLocation
public MailHeaderID ContentTransferEncoding
public MailHeaderID ContentType
public MailHeaderID Date
public MailHeaderID From
public MailHeaderID Importance
public MailHeaderID InReplyTo
public MailHeaderID Keywords
public MailHeaderID Max
public MailHeaderID MessageID
public MailHeaderID MimeVersion
public MailHeaderID Priority
public MailHeaderID References
public MailHeaderID ReplyTo
public MailHeaderID ResentBcc
public MailHeaderID ResentCc
public MailHeaderID ResentDate
public MailHeaderID ResentFrom
public MailHeaderID ResentMessageID
public MailHeaderID ResentSender
public MailHeaderID ResentTo
public MailHeaderID Sender
public MailHeaderID Subject
public MailHeaderID To
public MailHeaderID XPriority
public MailHeaderID XReceiver
public MailHeaderID XSender
public MailHeaderID ZMaxEnumValue
public MailHeaderID Unknown
}
internal System.Net.Mail.MailHeaderInfo : object {
private HeaderInfo[] s_headerInfo
private Dictionary`2<string, int> s_headerDictionary
internal string GetString(MailHeaderID id)
internal MailHeaderID GetID(string name)
internal bool IsUserSettable(string name)
internal bool IsSingleton(string name)
internal string NormalizeCase(string name)
internal bool AllowsUnicode(string name)
}
public System.Net.Mail.MailMessage : object {
private AlternateViewCollection alternateViews
private AttachmentCollection attachments
private MailAddressCollection bcc
private MailAddressCollection replyTo
private string body
private MailPriority priority
private MailAddress sender
private DeliveryNotificationOptions deliveryNotificationOptions
private MailAddressCollection cc
private MailAddress from
private NameValueCollection headers
private MailAddressCollection to
private string subject
private Encoding subjectEncoding
private Encoding bodyEncoding
private Encoding headersEncoding
private bool isHtml
private Char[] hex
private Encoding utf8unmarked
public AlternateViewCollection AlternateViews
public AttachmentCollection Attachments
public MailAddressCollection Bcc
public string Body
internal ContentType BodyContentType
internal TransferEncoding ContentTransferEncoding
public Encoding BodyEncoding
public TransferEncoding BodyTransferEncoding
public MailAddressCollection CC
public DeliveryNotificationOptions DeliveryNotificationOptions
public MailAddress From
public NameValueCollection Headers
public bool IsBodyHtml
public MailPriority Priority
public Encoding HeadersEncoding
public MailAddressCollection ReplyToList
public MailAddress ReplyTo
public MailAddress Sender
public string Subject
public Encoding SubjectEncoding
public MailAddressCollection To
private Encoding UTF8Unmarked
public void .ctor(MailAddress from, MailAddress to)
public void .ctor(string from, string to)
public void .ctor(string from, string to, string subject, string body)
public AlternateViewCollection get_AlternateViews()
public AttachmentCollection get_Attachments()
public MailAddressCollection get_Bcc()
public string get_Body()
public void set_Body(string value)
internal ContentType get_BodyContentType()
internal TransferEncoding get_ContentTransferEncoding()
public Encoding get_BodyEncoding()
public void set_BodyEncoding(Encoding value)
public TransferEncoding get_BodyTransferEncoding()
public void set_BodyTransferEncoding(TransferEncoding value)
public MailAddressCollection get_CC()
public DeliveryNotificationOptions get_DeliveryNotificationOptions()
public void set_DeliveryNotificationOptions(DeliveryNotificationOptions value)
public MailAddress get_From()
public void set_From(MailAddress value)
public NameValueCollection get_Headers()
public bool get_IsBodyHtml()
public void set_IsBodyHtml(bool value)
public MailPriority get_Priority()
public void set_Priority(MailPriority value)
public Encoding get_HeadersEncoding()
public void set_HeadersEncoding(Encoding value)
public MailAddressCollection get_ReplyToList()
public MailAddress get_ReplyTo()
public void set_ReplyTo(MailAddress value)
public MailAddress get_Sender()
public void set_Sender(MailAddress value)
public string get_Subject()
public void set_Subject(string value)
public Encoding get_SubjectEncoding()
public void set_SubjectEncoding(Encoding value)
public MailAddressCollection get_To()
public void Dispose()
protected void Dispose(bool disposing)
private Encoding GuessEncoding(string s)
internal TransferEncoding GuessTransferEncoding(Encoding enc)
internal string To2047(Byte[] bytes)
internal string EncodeSubjectRFC2047(string s, Encoding enc)
private Encoding get_UTF8Unmarked()
}
public System.Net.Mail.MailPriority : Enum {
public int value__
public MailPriority Normal
public MailPriority Low
public MailPriority High
}
internal System.Net.Mail.QuotedPairReader : object {
internal int CountQuotedChars(string data, int index, bool permitUnicodeEscaping)
private int CountBackslashes(string data, int index)
}
internal System.Net.Mail.QuotedStringFormatReader : object {
internal int ReadReverseQuoted(string data, int index, bool permitUnicode)
internal int ReadReverseUnQuoted(string data, int index, bool permitUnicode, bool expectCommaDelimiter)
private bool IsValidQtext(bool allowUnicode, char ch)
}
public System.Net.Mail.SendCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AsyncCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.Mail.SmtpAccess : Enum {
public int value__
public SmtpAccess None
public SmtpAccess Connect
public SmtpAccess ConnectToUnrestrictedPort
}
public System.Net.Mail.SmtpClient : object {
private string host
private int port
private int timeout
private ICredentialsByHost credentials
private string pickupDirectoryLocation
private SmtpDeliveryMethod deliveryMethod
private SmtpDeliveryFormat deliveryFormat
private bool enableSsl
private X509CertificateCollection clientCertificates
private TcpClient client
private Stream stream
private StreamWriter writer
private StreamReader reader
private int boundaryIndex
private MailAddress defaultFrom
private MailMessage messageInProcess
private BackgroundWorker worker
private object user_async_state
private AuthMechs authMechs
private Mutex mutex
private string <TargetName>k__BackingField
private SendCompletedEventHandler SendCompleted
public X509CertificateCollection ClientCertificates
public string TargetName
public ICredentialsByHost Credentials
public SmtpDeliveryMethod DeliveryMethod
public bool EnableSsl
public string Host
public string PickupDirectoryLocation
public int Port
public SmtpDeliveryFormat DeliveryFormat
public ServicePoint ServicePoint
public int Timeout
public bool UseDefaultCredentials
public void .ctor(string host)
public void .ctor(string host, int port)
public X509CertificateCollection get_ClientCertificates()
public string get_TargetName()
public void set_TargetName(string value)
public ICredentialsByHost get_Credentials()
public void set_Credentials(ICredentialsByHost value)
public SmtpDeliveryMethod get_DeliveryMethod()
public void set_DeliveryMethod(SmtpDeliveryMethod value)
public bool get_EnableSsl()
public void set_EnableSsl(bool value)
public string get_Host()
public void set_Host(string value)
public string get_PickupDirectoryLocation()
public void set_PickupDirectoryLocation(string value)
public int get_Port()
public void set_Port(int value)
public SmtpDeliveryFormat get_DeliveryFormat()
public void set_DeliveryFormat(SmtpDeliveryFormat value)
public ServicePoint get_ServicePoint()
public int get_Timeout()
public void set_Timeout(int value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public void add_SendCompleted(SendCompletedEventHandler value)
public void remove_SendCompleted(SendCompletedEventHandler value)
public void Dispose()
protected void Dispose(bool disposing)
private void CheckState()
private string EncodeAddress(MailAddress address)
private string EncodeAddresses(MailAddressCollection addresses)
private string EncodeSubjectRFC2047(MailMessage message)
private string EncodeBody(MailMessage message)
private string EncodeBody(AlternateView av)
private void EndSection(string section)
private string GenerateBoundary()
private string GenerateBoundary(int index)
private bool IsError(SmtpResponse status)
protected void OnSendCompleted(AsyncCompletedEventArgs e)
private void CheckCancellation()
private SmtpResponse Read()
private void ResetExtensions()
private void ParseExtensions(string extens)
public void Send(MailMessage message)
private void SendInternal(MailMessage message)
private void SendToFile(MailMessage message)
private void SendCore(MailMessage message)
public void Send(string from, string recipients, string subject, string body)
public Task SendMailAsync(MailMessage message)
public Task SendMailAsync(string from, string recipients, string subject, string body)
private void SendMailAsyncCompletedHandler(TaskCompletionSource`1<object> source, AsyncCompletedEventArgs e, SendCompletedEventHandler handler, SmtpClient client)
private void SendDot()
private void SendData(string data)
public void SendAsync(MailMessage message, object userToken)
public void SendAsync(string from, string recipients, string subject, string body, object userToken)
public void SendAsyncCancel()
private void AddPriorityHeader(MailMessage message)
private void SendSimpleBody(MailMessage message)
private void SendBodylessSingleAlternate(AlternateView av)
private void SendWithoutAttachments(MailMessage message, string boundary, bool attachmentExists)
private void SendWithAttachments(MailMessage message)
private void SendBodyWithAlternateViews(MailMessage message, string boundary, bool attachmentExists)
private void SendLinkedResources(MailMessage message, LinkedResourceCollection resources, string boundary)
private void SendAttachments(MailMessage message, Attachment body, string boundary)
private SmtpResponse SendCommand(string command)
private void SendHeader(string name, string value)
private void StartSection(string section, ContentType sectionContentType)
private void StartSection(string section, ContentType sectionContentType, AttachmentBase att)
private void StartSection(string section, ContentType sectionContentType, Attachment att, bool sendDisposition)
private string ToQuotedPrintable(string input, Encoding enc)
private string ToQuotedPrintable(Byte[] bytes)
private string GetTransferEncodingName(TransferEncoding encoding)
private void InitiateSecureConnection()
private void Authenticate()
private void CheckStatus(SmtpResponse status, int i)
private void ThrowIfError(SmtpResponse status)
private void Authenticate(string user, string password)
}
public System.Net.Mail.SmtpDeliveryFormat : Enum {
public int value__
public SmtpDeliveryFormat SevenBit
public SmtpDeliveryFormat International
}
public System.Net.Mail.SmtpDeliveryMethod : Enum {
public int value__
public SmtpDeliveryMethod Network
public SmtpDeliveryMethod SpecifiedPickupDirectory
public SmtpDeliveryMethod PickupDirectoryFromIis
}
public System.Net.Mail.SmtpException : Exception {
private SmtpStatusCode statusCode
public SmtpStatusCode StatusCode
public void .ctor(SmtpStatusCode statusCode)
public void .ctor(string message)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void .ctor(SmtpStatusCode statusCode, string message)
public void .ctor(string message, Exception innerException)
public SmtpStatusCode get_StatusCode()
public void set_StatusCode(SmtpStatusCode value)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Net.Mail.SmtpFailedRecipientException : SmtpException {
private string failedRecipient
public string FailedRecipient
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(SmtpStatusCode statusCode, string failedRecipient)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string failedRecipient, Exception innerException)
public void .ctor(SmtpStatusCode statusCode, string failedRecipient, string serverResponse)
public string get_FailedRecipient()
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Net.Mail.SmtpFailedRecipientsException : SmtpFailedRecipientException {
private SmtpFailedRecipientException[] innerExceptions
public SmtpFailedRecipientException[] InnerExceptions
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, SmtpFailedRecipientException[] innerExceptions)
protected void .ctor(SerializationInfo info, StreamingContext context)
public SmtpFailedRecipientException[] get_InnerExceptions()
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Net.Mail.SmtpPermission : CodeAccessPermission {
private int version
private bool unrestricted
private SmtpAccess access
public SmtpAccess Access
public void .ctor(bool unrestricted)
public void .ctor(PermissionState state)
public void .ctor(SmtpAccess access)
public SmtpAccess get_Access()
public void AddPermission(SmtpAccess access)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public void FromXml(SecurityElement securityElement)
public IPermission Union(IPermission target)
private bool IsEmpty()
private SmtpPermission Cast(IPermission target)
}
public System.Net.Mail.SmtpPermissionAttribute : CodeAccessSecurityAttribute {
private string access
public string Access
public void .ctor(SecurityAction action)
public string get_Access()
public void set_Access(string value)
private SmtpAccess GetSmtpAccess()
public IPermission CreatePermission()
}
public System.Net.Mail.SmtpStatusCode : Enum {
public int value__
public SmtpStatusCode BadCommandSequence
public SmtpStatusCode CannotVerifyUserWillAttemptDelivery
public SmtpStatusCode ClientNotPermitted
public SmtpStatusCode CommandNotImplemented
public SmtpStatusCode CommandParameterNotImplemented
public SmtpStatusCode CommandUnrecognized
public SmtpStatusCode ExceededStorageAllocation
public SmtpStatusCode GeneralFailure
public SmtpStatusCode HelpMessage
public SmtpStatusCode InsufficientStorage
public SmtpStatusCode LocalErrorInProcessing
public SmtpStatusCode MailboxBusy
public SmtpStatusCode MailboxNameNotAllowed
public SmtpStatusCode MailboxUnavailable
public SmtpStatusCode Ok
public SmtpStatusCode ServiceClosingTransmissionChannel
public SmtpStatusCode ServiceNotAvailable
public SmtpStatusCode ServiceReady
public SmtpStatusCode StartMailInput
public SmtpStatusCode SyntaxError
public SmtpStatusCode SystemStatus
public SmtpStatusCode TransactionFailed
public SmtpStatusCode UserNotLocalTryAlternatePath
public SmtpStatusCode UserNotLocalWillForward
public SmtpStatusCode MustIssueStartTlsFirst
}
internal System.Net.Mail.WhitespaceReader : object {
internal int ReadFwsReverse(string data, int index)
internal int ReadCfwsReverse(string data, int index)
}
internal System.Net.Mime.Base64WriteStateInfo : WriteStateInfoBase {
private int <Padding>k__BackingField
private byte <LastBits>k__BackingField
internal int Padding
internal byte LastBits
internal void .ctor(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength)
internal int get_Padding()
internal void set_Padding(int value)
internal byte get_LastBits()
internal void set_LastBits(byte value)
}
internal System.Net.Mime.BaseWriter : object {
private int DefaultLineLength
private AsyncCallback s_onWrite
protected Byte[] s_crlf
protected BufferBuilder _bufferBuilder
protected Stream _stream
private EventHandler _onCloseHandler
private bool _shouldEncodeLeadingDots
private int _lineLength
protected Stream _contentStream
protected bool _isInContent
protected void .ctor(Stream stream, bool shouldEncodeLeadingDots)
internal void WriteHeaders(NameValueCollection headers, bool allowUnicode)
internal void WriteHeader(string name, string value, bool allowUnicode)
private void WriteAndFold(string value, int charsAlreadyOnLine, bool allowUnicode)
internal Stream GetContentStream()
private Stream GetContentStream(MultiAsyncResult multiResult)
internal IAsyncResult BeginGetContentStream(AsyncCallback callback, object state)
internal Stream EndGetContentStream(IAsyncResult result)
protected void Flush(MultiAsyncResult multiResult)
protected void OnWrite(IAsyncResult result)
internal void Close()
protected void OnClose(object sender, EventArgs args)
protected void CheckBoundary()
}
public System.Net.Mime.ContentDisposition : object {
private string CreationDateKey
private string ModificationDateKey
private string ReadDateKey
private string FileNameKey
private string SizeKey
private TrackingValidationObjectDictionary _parameters
private string _disposition
private string _dispositionType
private bool _isChanged
private bool _isPersisted
private ValidateAndParseValue s_dateParser
private ValidateAndParseValue s_longParser
private Dictionary`2<string, ValidateAndParseValue> s_validators
public string DispositionType
public StringDictionary Parameters
public string FileName
public DateTime CreationDate
public DateTime ModificationDate
public bool Inline
public DateTime ReadDate
public long Size
internal bool IsChanged
public void .ctor(string disposition)
internal DateTime GetDateParameter(string parameterName)
public string get_DispositionType()
public void set_DispositionType(string value)
public StringDictionary get_Parameters()
public string get_FileName()
public void set_FileName(string value)
public DateTime get_CreationDate()
public void set_CreationDate(DateTime value)
public DateTime get_ModificationDate()
public void set_ModificationDate(DateTime value)
public bool get_Inline()
public void set_Inline(bool value)
public DateTime get_ReadDate()
public void set_ReadDate(DateTime value)
public long get_Size()
public void set_Size(long value)
internal void Set(string contentDisposition, HeaderCollection headers)
internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist)
internal bool get_IsChanged()
public string ToString()
internal string Encode(bool allowUnicode)
private void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode)
public bool Equals(object rparam)
public int GetHashCode()
private void ParseValue()
}
public System.Net.Mime.ContentType : object {
private TrackingStringDictionary _parameters
private string _mediaType
private string _subType
private bool _isChanged
private string _type
private bool _isPersisted
internal string Default
public string Boundary
public string CharSet
public string MediaType
public string Name
public StringDictionary Parameters
internal bool IsChanged
public void .ctor(string contentType)
public string get_Boundary()
public void set_Boundary(string value)
public string get_CharSet()
public void set_CharSet(string value)
public string get_MediaType()
public void set_MediaType(string value)
public string get_Name()
public void set_Name(string value)
public StringDictionary get_Parameters()
internal void Set(string contentType, HeaderCollection headers)
internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist)
internal bool get_IsChanged()
public string ToString()
internal string Encode(bool allowUnicode)
private void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode)
public bool Equals(object rparam)
public int GetHashCode()
private void ParseValue()
}
public System.Net.Mime.DispositionTypeNames : object {
public string Inline
public string Attachment
}
internal System.Net.Mime.EightBitStream : DelegatedStream {
private WriteStateInfoBase _writeState
private bool _shouldEncodeLeadingDots
private WriteStateInfoBase WriteState
private WriteStateInfoBase get_WriteState()
internal void .ctor(Stream stream)
internal void .ctor(Stream stream, bool shouldEncodeLeadingDots)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
public void Write(Byte[] buffer, int offset, int count)
private void EncodeLines(Byte[] buffer, int offset, int count)
public Stream GetStream()
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
public string GetEncodedString()
}
internal System.Net.Mime.EncodedStreamFactory : object {
internal int DefaultMaxLineLength
private int InitialBufferSize
internal IEncodableStream GetEncoder(TransferEncoding encoding, Stream stream)
internal IEncodableStream GetEncoderForHeader(Encoding encoding, bool useBase64Encoding, int headerTextLength)
protected Byte[] CreateHeader(Encoding encoding, bool useBase64Encoding)
protected Byte[] CreateFooter()
}
internal System.Net.Mime.HeaderCollection : NameValueCollection {
private MimeBasePart _part
public void Remove(string name)
public string Get(string name)
public String[] GetValues(string name)
internal void InternalRemove(string name)
internal void InternalSet(string name, string value)
internal void InternalAdd(string name, string value)
public void Set(string name, string value)
public void Add(string name, string value)
}
internal System.Net.Mime.IEncodableStream {
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
public string GetEncodedString()
public Stream GetStream()
}
internal System.Net.Mime.MailBnfHelper : object {
internal Boolean[] Atext
internal Boolean[] Qtext
internal Boolean[] Dtext
internal Boolean[] Ftext
internal Boolean[] Ttext
internal Boolean[] Ctext
internal int Ascii7bitMaxValue
internal char Quote
internal char Space
internal char Tab
internal char CR
internal char LF
internal char StartComment
internal char EndComment
internal char Backslash
internal char At
internal char EndAngleBracket
internal char StartAngleBracket
internal char StartSquareBracket
internal char EndSquareBracket
internal char Comma
internal char Dot
private Char[] s_colonSeparator
private String[] s_months
private Boolean[] CreateCharactersAllowedInAtoms()
private Boolean[] CreateCharactersAllowedInQuotedStrings()
private Boolean[] CreateCharactersAllowedInDomainLiterals()
private Boolean[] CreateCharactersAllowedInHeaderNames()
private Boolean[] CreateCharactersAllowedInTokens()
private Boolean[] CreateCharactersAllowedInComments()
internal bool SkipCFWS(string data, Int32& offset)
internal void ValidateHeaderName(string data)
internal string ReadQuotedString(string data, Int32& offset, StringBuilder builder)
internal string ReadQuotedString(string data, Int32& offset, StringBuilder builder, bool doesntRequireQuotes, bool permitUnicodeInDisplayName)
internal string ReadParameterAttribute(string data, Int32& offset, StringBuilder builder)
internal string ReadToken(string data, Int32& offset, StringBuilder builder)
internal string GetDateTimeString(DateTime value, StringBuilder builder)
internal void GetTokenOrQuotedString(string data, StringBuilder builder, bool allowUnicode)
private bool CheckForUnicode(char ch, bool allowUnicode)
internal bool IsAllowedWhiteSpace(char c)
internal bool HasCROrLF(string data)
internal bool IsFWSAt(string data, int index)
}
internal System.Net.Mime.MimeBasePart : object {
internal string DefaultCharSet
private Char[] s_decodeEncodingSplitChars
protected ContentType _contentType
protected ContentDisposition _contentDisposition
private HeaderCollection _headers
private Char[] s_headerValueSplitChars
private Char[] s_questionMarkSplitChars
internal string ContentID
internal string ContentLocation
internal NameValueCollection Headers
internal ContentType ContentType
internal bool ShouldUseBase64Encoding(Encoding encoding)
internal string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding)
internal string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding, int headerLength)
internal string DecodeHeaderValue(string value)
internal Encoding DecodeEncoding(string value)
internal bool IsAscii(string value, bool permitCROrLF)
internal string get_ContentID()
internal void set_ContentID(string value)
internal string get_ContentLocation()
internal void set_ContentLocation(string value)
internal NameValueCollection get_Headers()
internal ContentType get_ContentType()
internal void set_ContentType(ContentType value)
internal void PrepareHeaders(bool allowUnicode)
internal void Send(BaseWriter writer, bool allowUnicode)
internal IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state)
internal void EndSend(IAsyncResult asyncResult)
}
internal System.Net.Mime.MimeMultiPart : MimeBasePart {
private Collection`1<MimeBasePart> _parts
private int s_boundary
private AsyncCallback _mimePartSentCallback
private bool _allowUnicode
internal MimeMultiPartType MimeMultiPartType
internal Collection`1<MimeBasePart> Parts
internal void .ctor(MimeMultiPartType type)
internal void set_MimeMultiPartType(MimeMultiPartType value)
private void SetType(MimeMultiPartType type)
internal Collection`1<MimeBasePart> get_Parts()
internal void Complete(IAsyncResult result, Exception e)
internal void MimeWriterCloseCallback(IAsyncResult result)
private void MimeWriterCloseCallbackHandler(IAsyncResult result)
internal void MimePartSentCallback(IAsyncResult result)
private void MimePartSentCallbackHandler(IAsyncResult result)
internal void ContentStreamCallback(IAsyncResult result)
private void ContentStreamCallbackHandler(IAsyncResult result)
internal IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state)
internal void Send(BaseWriter writer, bool allowUnicode)
internal string GetNextBoundary()
}
internal System.Net.Mime.MimeMultiPartType : Enum {
public int value__
public MimeMultiPartType Mixed
public MimeMultiPartType Alternative
public MimeMultiPartType Parallel
public MimeMultiPartType Related
public MimeMultiPartType Unknown
}
internal System.Net.Mime.MimePart : MimeBasePart {
private Stream _stream
private bool _streamSet
private bool _streamUsedOnce
private AsyncCallback _readCallback
private AsyncCallback _writeCallback
private int maxBufferSize
internal Stream Stream
internal ContentDisposition ContentDisposition
internal TransferEncoding TransferEncoding
public void Dispose()
internal Stream get_Stream()
internal ContentDisposition get_ContentDisposition()
internal void set_ContentDisposition(ContentDisposition value)
internal TransferEncoding get_TransferEncoding()
internal void set_TransferEncoding(TransferEncoding value)
internal void SetContent(Stream stream)
internal void SetContent(Stream stream, string name, string mimeType)
internal void SetContent(Stream stream, ContentType contentType)
internal void Complete(IAsyncResult result, Exception e)
internal void ReadCallback(IAsyncResult result)
internal void ReadCallbackHandler(IAsyncResult result)
internal void WriteCallback(IAsyncResult result)
internal void WriteCallbackHandler(IAsyncResult result)
internal Stream GetEncodedStream(Stream stream)
internal void ContentStreamCallbackHandler(IAsyncResult result)
internal void ContentStreamCallback(IAsyncResult result)
internal IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state)
internal void Send(BaseWriter writer, bool allowUnicode)
internal void ResetStream()
}
internal System.Net.Mime.MimeWriter : BaseWriter {
private Byte[] s_DASHDASH
private Byte[] _boundaryBytes
private bool _writeBoundary
internal void .ctor(Stream stream, string boundary)
internal void WriteHeaders(NameValueCollection headers, bool allowUnicode)
internal IAsyncResult BeginClose(AsyncCallback callback, object state)
internal void EndClose(IAsyncResult result)
internal void Close()
private void Close(MultiAsyncResult multiResult)
protected void OnClose(object sender, EventArgs args)
protected void CheckBoundary()
}
internal System.Net.Mime.MultiAsyncResult : LazyAsyncResult {
private object _context
private int _outstanding
internal object Context
internal void .ctor(object context, AsyncCallback callback, object state)
internal object get_Context()
internal void Enter()
internal void Leave()
internal void Leave(object result)
private void Decrement()
private void Increment()
internal void CompleteSequence()
internal object End(IAsyncResult result)
}
internal System.Net.Mime.QEncodedStream : DelegatedStream {
private int SizeOfFoldingCRLF
private Byte[] s_hexDecodeMap
private Byte[] s_hexEncodeMap
private ReadStateInfo _readState
private WriteStateInfoBase _writeState
private ReadStateInfo ReadState
internal WriteStateInfoBase WriteState
internal void .ctor(WriteStateInfoBase wsi)
private ReadStateInfo get_ReadState()
internal WriteStateInfoBase get_WriteState()
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
private bool IsAsciiLetterOrDigit(char character)
private bool IsAsciiLetter(char character)
public Stream GetStream()
public string GetEncodedString()
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
private void FlushInternal()
public void Write(Byte[] buffer, int offset, int count)
}
internal System.Net.Mime.QuotedPrintableStream : DelegatedStream {
private bool _encodeCRLF
private int SizeOfSoftCRLF
private int SizeOfEncodedChar
private int SizeOfEncodedCRLF
private int SizeOfNonEncodedCRLF
private Byte[] s_hexDecodeMap
private Byte[] s_hexEncodeMap
private int _lineLength
private ReadStateInfo _readState
private WriteStateInfoBase _writeState
private ReadStateInfo ReadState
internal WriteStateInfoBase WriteState
internal void .ctor(Stream stream, int lineLength)
internal void .ctor(Stream stream, bool encodeCRLF)
private ReadStateInfo get_ReadState()
internal WriteStateInfoBase get_WriteState()
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void Close()
public int DecodeBytes(Byte[] buffer, int offset, int count)
public int EncodeBytes(Byte[] buffer, int offset, int count)
public Stream GetStream()
public string GetEncodedString()
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
private void FlushInternal()
public void Write(Byte[] buffer, int offset, int count)
}
internal System.Net.Mime.SmtpDateTime : object {
internal string UnknownTimeZoneDefaultOffset
internal string UtcDefaultTimeZoneOffset
internal int OffsetLength
internal int MaxMinuteValue
internal string DateFormatWithDayOfWeek
internal string DateFormatWithoutDayOfWeek
internal string DateFormatWithDayOfWeekAndNoSeconds
internal string DateFormatWithoutDayOfWeekAndNoSeconds
internal String[] s_validDateTimeFormats
internal Char[] s_allowedWhiteSpaceChars
internal Dictionary`2<string, TimeSpan> s_timeZoneOffsetLookup
internal long TimeSpanMaxTicks
internal int OffsetMaxValue
private DateTime _date
private TimeSpan _timeZone
private bool _unknownTimeZone
internal DateTime Date
internal Dictionary`2<string, TimeSpan> InitializeShortHandLookups()
internal void .ctor(DateTime value)
internal void .ctor(string value)
internal DateTime get_Date()
public string ToString()
internal void ValidateAndGetTimeZoneOffsetValues(string offset, Boolean& positive, Int32& hours, Int32& minutes)
internal void ValidateTimeZoneShortHandValue(string value)
internal string FormatDate(DateTime value)
internal DateTime ParseValue(string data, String& timeZone)
internal bool TryParseTimeZoneString(string timeZoneString, TimeSpan& timeZone)
internal TimeSpan ValidateAndGetSanitizedTimeSpan(TimeSpan span)
internal string TimeSpanToOffset(TimeSpan span)
}
public System.Net.Mime.TransferEncoding : Enum {
public int value__
public TransferEncoding Unknown
public TransferEncoding QuotedPrintable
public TransferEncoding Base64
public TransferEncoding SevenBit
public TransferEncoding EightBit
}
internal System.Net.Mime.WriteStateInfoBase : object {
protected Byte[] _header
protected Byte[] _footer
protected int _maxLineLength
protected Byte[] _buffer
protected int _currentLineLength
protected int _currentBufferUsed
protected int DefaultBufferSize
internal int FooterLength
internal Byte[] Footer
internal Byte[] Header
internal Byte[] Buffer
internal int Length
internal int CurrentLineLength
internal int MaxLineLength
internal void .ctor(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength)
internal void .ctor(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength)
internal int get_FooterLength()
internal Byte[] get_Footer()
internal Byte[] get_Header()
internal Byte[] get_Buffer()
internal int get_Length()
internal int get_CurrentLineLength()
private void EnsureSpaceInBuffer(int moreBytes)
internal void Append(byte aByte)
internal void Append(Byte[] bytes)
internal void AppendCRLF(bool includeSpace)
internal void AppendHeader()
internal void AppendFooter()
internal int get_MaxLineLength()
internal void Reset()
internal void BufferFlushed()
}
internal System.Net.MonoChunkParser : object {
private WebHeaderCollection headers
private int chunkSize
private int chunkRead
private int totalWritten
private State state
private StringBuilder saved
private bool sawCR
private bool gotit
private int trailerState
private ArrayList chunks
public bool WantMore
public bool DataAvailable
public int TotalDataSize
public int ChunkLeft
public void .ctor(WebHeaderCollection headers)
public void WriteAndReadBack(Byte[] buffer, int offset, int size, Int32& read)
public int Read(Byte[] buffer, int offset, int size)
private int ReadFromChunks(Byte[] buffer, int offset, int size)
public void Write(Byte[] buffer, int offset, int size)
private void InternalWrite(Byte[] buffer, Int32& offset, int size)
public bool get_WantMore()
public bool get_DataAvailable()
public int get_TotalDataSize()
public int get_ChunkLeft()
private State ReadBody(Byte[] buffer, Int32& offset, int size)
private State GetChunkSize(Byte[] buffer, Int32& offset, int size)
private string RemoveChunkExtension(string input)
private State ReadCRLF(Byte[] buffer, Int32& offset, int size)
private State ReadTrailer(Byte[] buffer, Int32& offset, int size)
private void ThrowProtocolViolation(string message)
}
internal System.Net.MonoChunkStream : WebReadStream {
private WebHeaderCollection <Headers>k__BackingField
private MonoChunkParser <Decoder>k__BackingField
protected WebHeaderCollection Headers
protected MonoChunkParser Decoder
protected WebHeaderCollection get_Headers()
protected MonoChunkParser get_Decoder()
public void .ctor(WebOperation operation, Stream innerStream, WebHeaderCollection headers)
protected Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
internal Task FinishReading(CancellationToken cancellationToken)
private void ThrowExpectingChunkTrailer()
private Task <>n__0(CancellationToken cancellationToken)
}
internal System.Net.MonoHttpDate : object {
private string rfc1123_date
private string rfc850_date
private string asctime_date
private String[] formats
internal DateTime Parse(string dateStr)
}
internal System.Net.NclConstants : object {
internal object Sentinel
internal Object[] EmptyObjectArray
internal Uri[] EmptyUriArray
internal Byte[] CRLF
internal Byte[] ChunkTerminator
}
internal System.Net.NclUtilities : object {
private ContextCallback modreq(System.Runtime.CompilerServices.IsVolatile) s_ContextRelativeDemandCallback
private IPAddress[] modreq(System.Runtime.CompilerServices.IsVolatile) _LocalAddresses
private object _LocalAddressesLock
private int HostNameBufferLength
internal string _LocalDomainName
internal bool HasShutdownStarted
internal ContextCallback ContextRelativeDemandCallback
internal IPAddress[] LocalAddresses
private object LocalAddressesLock
internal bool IsThreadPoolLow()
internal bool get_HasShutdownStarted()
internal bool IsCredentialFailure(SecurityStatus error)
internal bool IsClientFault(SecurityStatus error)
internal ContextCallback get_ContextRelativeDemandCallback()
private void DemandCallback(object state)
internal bool GuessWhetherHostIsLoopback(string host)
internal bool IsFatal(Exception exception)
internal bool IsAddressLocal(IPAddress ipAddress)
private IPHostEntry GetLocalHost()
internal IPAddress[] get_LocalAddresses()
private object get_LocalAddressesLock()
}
internal System.Net.NegotiationInfoClass : object {
internal string AuthenticationPackage
internal string NTLM
internal string Kerberos
internal string Negotiate
internal string Basic
internal void .ctor(SafeHandle safeHandle, int negotiationState)
}
internal System.Net.NetConfig : object {
internal bool ipv6Enabled
internal int MaxResponseHeadersLength
private object System.ICloneable.Clone()
}
internal System.Net.NetEventSource : EventSource {
public NetEventSource Log
private string MissingMember
private string NullInstance
private string StaticMethodObject
private string NoParameters
private int MaxDumpSize
private int EnterEventId
private int ExitEventId
private int AssociateEventId
private int InfoEventId
private int ErrorEventId
private int CriticalFailureEventId
private int DumpArrayEventId
private int EnumerateSecurityPackagesId
private int SspiPackageNotFoundId
private int AcquireDefaultCredentialId
private int AcquireCredentialsHandleId
private int InitializeSecurityContextId
private int SecurityContextInputBufferId
private int SecurityContextInputBuffersId
private int AcceptSecuritContextId
private int OperationReturnedSomethingId
private int NextAvailableEventId
public bool IsEnabled
public void Enter(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Enter(object thisOrContextObject, object arg0, string memberName)
public void Enter(object thisOrContextObject, object arg0, object arg1, string memberName)
public void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName)
private void Enter(string thisOrContextObject, string memberName, string parameters)
public void Exit(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Exit(object thisOrContextObject, object arg0, string memberName)
public void Exit(object thisOrContextObject, object arg0, object arg1, string memberName)
private void Exit(string thisOrContextObject, string memberName, string result)
public void Info(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Info(object thisOrContextObject, object message, string memberName)
private void Info(string thisOrContextObject, string memberName, string message)
public void Error(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Error(object thisOrContextObject, object message, string memberName)
private void ErrorMessage(string thisOrContextObject, string memberName, string message)
public void Fail(object thisOrContextObject, FormattableString formattableString, string memberName)
public void Fail(object thisOrContextObject, object message, string memberName)
private void CriticalFailure(string thisOrContextObject, string memberName, string message)
public void DumpBuffer(object thisOrContextObject, Byte[] buffer, string memberName)
public void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName)
public void DumpBuffer(object thisOrContextObject, IntPtr bufferPtr, int count, string memberName)
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer)
public void Associate(object first, object second, string memberName)
public void Associate(object thisOrContextObject, object first, object second, string memberName)
private void Associate(string thisOrContextObject, string memberName, string first, string second)
private void DebugValidateArg(object arg)
private void DebugValidateArg(FormattableString arg)
public bool get_IsEnabled()
public string IdOf(object value)
public int GetHashCode(object value)
public object Format(object value)
private string Format(FormattableString s)
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4)
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3)
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4)
private void WriteEvent(int eventId, string arg1, int arg2, string arg3)
private void WriteEvent(int eventId, string arg1, string arg2, int arg3)
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4)
public void AcquireDefaultCredential(string packageName, CredentialUse intent)
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, object authdata)
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, string authdata)
public void InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, string targetName, ContextFlags inFlags)
private void InitializeSecurityContext(string credential, string context, string targetName, ContextFlags inFlags)
public void AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, ContextFlags inFlags)
private void AcceptSecurityContext(string credential, string context, ContextFlags inFlags)
public void OperationReturnedSomething(string operation, SECURITY_STATUS errorCode)
public void SecurityContextInputBuffer(string context, int inputBufferSize, int outputBufferSize, SECURITY_STATUS errorCode)
public void SecurityContextInputBuffers(string context, int inputBuffersSize, int outputBufferSize, SECURITY_STATUS errorCode)
public void EnumerateSecurityPackages(string securityPackage)
public void SspiPackageNotFound(string packageName)
}
internal System.Net.NetRes : object {
public string GetWebStatusString(string Res, WebExceptionStatus Status)
public string GetWebStatusString(WebExceptionStatus Status)
public string GetWebStatusCodeString(HttpStatusCode statusCode, string statusDescription)
public string GetWebStatusCodeString(FtpStatusCode statusCode, string statusDescription)
}
public System.Net.NetworkAccess : Enum {
public int value__
public NetworkAccess Accept
public NetworkAccess Connect
}
public System.Net.NetworkCredential : object {
private string m_domain
private string m_userName
private SecureString m_password
public string UserName
public string Password
public SecureString SecurePassword
public string Domain
public void .ctor(string userName, string password)
public void .ctor(string userName, SecureString password)
public void .ctor(string userName, string password, string domain)
public void .ctor(string userName, SecureString password, string domain)
public string get_UserName()
public void set_UserName(string value)
public string get_Password()
public void set_Password(string value)
public SecureString get_SecurePassword()
public void set_SecurePassword(SecureString value)
public string get_Domain()
public void set_Domain(string value)
internal string InternalGetUserName()
internal string InternalGetPassword()
internal SecureString InternalGetSecurePassword()
internal string InternalGetDomain()
internal string InternalGetDomainUserName()
public NetworkCredential GetCredential(Uri uri, string authType)
public NetworkCredential GetCredential(string host, int port, string authenticationType)
}
internal System.Net.NetworkInformation.AlignmentUnion : ValueType {
public ulong Alignment
public int Length
public int IfIndex
}
public System.Net.NetworkInformation.DuplicateAddressDetectionState : Enum {
public int value__
public DuplicateAddressDetectionState Invalid
public DuplicateAddressDetectionState Tentative
public DuplicateAddressDetectionState Duplicate
public DuplicateAddressDetectionState Deprecated
public DuplicateAddressDetectionState Preferred
}
public System.Net.NetworkInformation.GatewayIPAddressInformation : object {
public IPAddress Address
public IPAddress get_Address()
}
public System.Net.NetworkInformation.GatewayIPAddressInformationCollection : object {
private Collection`1<GatewayIPAddressInformation> addresses
public int Count
public bool IsReadOnly
public GatewayIPAddressInformation Item
public void CopyTo(GatewayIPAddressInformation[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public GatewayIPAddressInformation get_Item(int index)
public void Add(GatewayIPAddressInformation address)
internal void InternalAdd(GatewayIPAddressInformation address)
public bool Contains(GatewayIPAddressInformation address)
public IEnumerator`1<GatewayIPAddressInformation> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Remove(GatewayIPAddressInformation address)
public void Clear()
}
internal System.Net.NetworkInformation.IcmpV4Code : Enum {
public int value__
public IcmpV4Code ICMP4_UNREACH_NET
public IcmpV4Code ICMP4_UNREACH_HOST
public IcmpV4Code ICMP4_UNREACH_PROTOCOL
public IcmpV4Code ICMP4_UNREACH_PORT
public IcmpV4Code ICMP4_UNREACH_FRAG_NEEDED
public IcmpV4Code ICMP4_UNREACH_SOURCEROUTE_FAILED
public IcmpV4Code ICMP4_UNREACH_NET_UNKNOWN
public IcmpV4Code ICMP4_UNREACH_HOST_UNKNOWN
public IcmpV4Code ICMP4_UNREACH_ISOLATED
public IcmpV4Code ICMP4_UNREACH_NET_ADMIN
public IcmpV4Code ICMP4_UNREACH_HOST_ADMIN
public IcmpV4Code ICMP4_UNREACH_NET_TOS
public IcmpV4Code ICMP4_UNREACH_HOST_TOS
public IcmpV4Code ICMP4_UNREACH_ADMIN
}
public System.Net.NetworkInformation.IcmpV4Statistics : object {
public long AddressMaskRepliesReceived
public long AddressMaskRepliesSent
public long AddressMaskRequestsReceived
public long AddressMaskRequestsSent
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MessagesReceived
public long MessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long SourceQuenchesReceived
public long SourceQuenchesSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long TimestampRepliesReceived
public long TimestampRepliesSent
public long TimestampRequestsReceived
public long TimestampRequestsSent
public long get_AddressMaskRepliesReceived()
public long get_AddressMaskRepliesSent()
public long get_AddressMaskRequestsReceived()
public long get_AddressMaskRequestsSent()
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_SourceQuenchesReceived()
public long get_SourceQuenchesSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
public long get_TimestampRepliesReceived()
public long get_TimestampRepliesSent()
public long get_TimestampRequestsReceived()
public long get_TimestampRequestsSent()
}
internal System.Net.NetworkInformation.IcmpV4Type : Enum {
public int value__
public IcmpV4Type ICMP4_ECHO_REPLY
public IcmpV4Type ICMP4_DST_UNREACH
public IcmpV4Type ICMP4_SOURCE_QUENCH
public IcmpV4Type ICMP4_TIME_EXCEEDED
public IcmpV4Type ICMP4_PARAM_PROB
public IcmpV4Type ICMP4_REDIRECT
public IcmpV4Type ICMP4_ECHO_REQUEST
public IcmpV4Type ICMP4_ROUTER_ADVERT
public IcmpV4Type ICMP4_ROUTER_SOLICIT
public IcmpV4Type ICMP4_TIMESTAMP_REQUEST
public IcmpV4Type ICMP4_TIMESTAMP_REPLY
public IcmpV4Type ICMP4_MASK_REQUEST
public IcmpV4Type ICMP4_MASK_REPLY
}
internal System.Net.NetworkInformation.IcmpV6MessageTypes : object {
public int DestinationUnreachable
public int PacketTooBig
public int TimeExceeded
public int ParameterProblem
public int EchoRequest
public int EchoReply
public int GroupMembershipQuery
public int GroupMembershipReport
public int GroupMembershipReduction
public int RouterSolicitation
public int RouterAdvertisement
public int NeighborSolicitation
public int NeighborAdvertisement
public int Redirect
public int RouterRenumbering
}
public System.Net.NetworkInformation.IcmpV6Statistics : object {
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MembershipQueriesReceived
public long MembershipQueriesSent
public long MembershipReductionsReceived
public long MembershipReductionsSent
public long MembershipReportsReceived
public long MembershipReportsSent
public long MessagesReceived
public long MessagesSent
public long NeighborAdvertisementsReceived
public long NeighborAdvertisementsSent
public long NeighborSolicitsReceived
public long NeighborSolicitsSent
public long PacketTooBigMessagesReceived
public long PacketTooBigMessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long RouterAdvertisementsReceived
public long RouterAdvertisementsSent
public long RouterSolicitsReceived
public long RouterSolicitsSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MembershipQueriesReceived()
public long get_MembershipQueriesSent()
public long get_MembershipReductionsReceived()
public long get_MembershipReductionsSent()
public long get_MembershipReportsReceived()
public long get_MembershipReportsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_NeighborAdvertisementsReceived()
public long get_NeighborAdvertisementsSent()
public long get_NeighborSolicitsReceived()
public long get_NeighborSolicitsSent()
public long get_PacketTooBigMessagesReceived()
public long get_PacketTooBigMessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_RouterAdvertisementsReceived()
public long get_RouterAdvertisementsSent()
public long get_RouterSolicitsReceived()
public long get_RouterSolicitsSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
}
internal System.Net.NetworkInformation.INetworkChange {
public bool HasRegisteredEvents
public void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public bool get_HasRegisteredEvents()
}
public System.Net.NetworkInformation.IPAddressCollection : object {
private Collection`1<IPAddress> addresses
public int Count
public bool IsReadOnly
public IPAddress Item
public void CopyTo(IPAddress[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public void Add(IPAddress address)
internal void InternalAdd(IPAddress address)
public bool Contains(IPAddress address)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<IPAddress> GetEnumerator()
public IPAddress get_Item(int index)
public bool Remove(IPAddress address)
public void Clear()
}
public System.Net.NetworkInformation.IPAddressInformation : object {
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
}
public System.Net.NetworkInformation.IPAddressInformationCollection : object {
private Collection`1<IPAddressInformation> addresses
public int Count
public bool IsReadOnly
public IPAddressInformation Item
public void CopyTo(IPAddressInformation[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public void Add(IPAddressInformation address)
internal void InternalAdd(IPAddressInformation address)
public bool Contains(IPAddressInformation address)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<IPAddressInformation> GetEnumerator()
public IPAddressInformation get_Item(int index)
public bool Remove(IPAddressInformation address)
public void Clear()
}
public System.Net.NetworkInformation.IPGlobalProperties : object {
public string DhcpScopeName
public string DomainName
public string HostName
public bool IsWinsProxy
public NetBiosNodeType NodeType
public IPGlobalProperties GetIPGlobalProperties()
internal IPGlobalProperties InternalGetIPGlobalProperties()
public IPEndPoint[] GetActiveUdpListeners()
public IPEndPoint[] GetActiveTcpListeners()
public TcpConnectionInformation[] GetActiveTcpConnections()
public string get_DhcpScopeName()
public string get_DomainName()
public string get_HostName()
public bool get_IsWinsProxy()
public NetBiosNodeType get_NodeType()
public TcpStatistics GetTcpIPv4Statistics()
public TcpStatistics GetTcpIPv6Statistics()
public UdpStatistics GetUdpIPv4Statistics()
public UdpStatistics GetUdpIPv6Statistics()
public IcmpV4Statistics GetIcmpV4Statistics()
public IcmpV6Statistics GetIcmpV6Statistics()
public IPGlobalStatistics GetIPv4GlobalStatistics()
public IPGlobalStatistics GetIPv6GlobalStatistics()
public UnicastIPAddressInformationCollection GetUnicastAddresses()
public IAsyncResult BeginGetUnicastAddresses(AsyncCallback callback, object state)
public UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult)
public Task`1<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync()
}
internal System.Net.NetworkInformation.IPGlobalPropertiesFactoryPal : object {
public IPGlobalProperties Create()
}
public System.Net.NetworkInformation.IPGlobalStatistics : object {
public int DefaultTtl
public bool ForwardingEnabled
public int NumberOfInterfaces
public int NumberOfIPAddresses
public long OutputPacketRequests
public long OutputPacketRoutingDiscards
public long OutputPacketsDiscarded
public long OutputPacketsWithNoRoute
public long PacketFragmentFailures
public long PacketReassembliesRequired
public long PacketReassemblyFailures
public long PacketReassemblyTimeout
public long PacketsFragmented
public long PacketsReassembled
public long ReceivedPackets
public long ReceivedPacketsDelivered
public long ReceivedPacketsDiscarded
public long ReceivedPacketsForwarded
public long ReceivedPacketsWithAddressErrors
public long ReceivedPacketsWithHeadersErrors
public long ReceivedPacketsWithUnknownProtocol
public int NumberOfRoutes
public int get_DefaultTtl()
public bool get_ForwardingEnabled()
public int get_NumberOfInterfaces()
public int get_NumberOfIPAddresses()
public long get_OutputPacketRequests()
public long get_OutputPacketRoutingDiscards()
public long get_OutputPacketsDiscarded()
public long get_OutputPacketsWithNoRoute()
public long get_PacketFragmentFailures()
public long get_PacketReassembliesRequired()
public long get_PacketReassemblyFailures()
public long get_PacketReassemblyTimeout()
public long get_PacketsFragmented()
public long get_PacketsReassembled()
public long get_ReceivedPackets()
public long get_ReceivedPacketsDelivered()
public long get_ReceivedPacketsDiscarded()
public long get_ReceivedPacketsForwarded()
public long get_ReceivedPacketsWithAddressErrors()
public long get_ReceivedPacketsWithHeadersErrors()
public long get_ReceivedPacketsWithUnknownProtocol()
public int get_NumberOfRoutes()
}
public System.Net.NetworkInformation.IPInterfaceProperties : object {
public bool IsDnsEnabled
public string DnsSuffix
public bool IsDynamicDnsEnabled
public UnicastIPAddressInformationCollection UnicastAddresses
public MulticastIPAddressInformationCollection MulticastAddresses
public IPAddressInformationCollection AnycastAddresses
public IPAddressCollection DnsAddresses
public GatewayIPAddressInformationCollection GatewayAddresses
public IPAddressCollection DhcpServerAddresses
public IPAddressCollection WinsServersAddresses
public bool get_IsDnsEnabled()
public string get_DnsSuffix()
public bool get_IsDynamicDnsEnabled()
public UnicastIPAddressInformationCollection get_UnicastAddresses()
public MulticastIPAddressInformationCollection get_MulticastAddresses()
public IPAddressInformationCollection get_AnycastAddresses()
public IPAddressCollection get_DnsAddresses()
public GatewayIPAddressInformationCollection get_GatewayAddresses()
public IPAddressCollection get_DhcpServerAddresses()
public IPAddressCollection get_WinsServersAddresses()
public IPv4InterfaceProperties GetIPv4Properties()
public IPv6InterfaceProperties GetIPv6Properties()
}
public System.Net.NetworkInformation.IPInterfaceStatistics : object {
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
public System.Net.NetworkInformation.IPStatus : Enum {
public int value__
public IPStatus Success
public IPStatus DestinationNetworkUnreachable
public IPStatus DestinationHostUnreachable
public IPStatus DestinationProtocolUnreachable
public IPStatus DestinationPortUnreachable
public IPStatus DestinationProhibited
public IPStatus NoResources
public IPStatus BadOption
public IPStatus HardwareError
public IPStatus PacketTooBig
public IPStatus TimedOut
public IPStatus BadRoute
public IPStatus TtlExpired
public IPStatus TtlReassemblyTimeExceeded
public IPStatus ParameterProblem
public IPStatus SourceQuench
public IPStatus BadDestination
public IPStatus DestinationUnreachable
public IPStatus TimeExceeded
public IPStatus BadHeader
public IPStatus UnrecognizedNextHeader
public IPStatus IcmpError
public IPStatus DestinationScopeMismatch
public IPStatus Unknown
}
public System.Net.NetworkInformation.IPv4InterfaceProperties : object {
public bool UsesWins
public bool IsDhcpEnabled
public bool IsAutomaticPrivateAddressingActive
public bool IsAutomaticPrivateAddressingEnabled
public int Index
public bool IsForwardingEnabled
public int Mtu
public bool get_UsesWins()
public bool get_IsDhcpEnabled()
public bool get_IsAutomaticPrivateAddressingActive()
public bool get_IsAutomaticPrivateAddressingEnabled()
public int get_Index()
public bool get_IsForwardingEnabled()
public int get_Mtu()
}
public System.Net.NetworkInformation.IPv4InterfaceStatistics : object {
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
public System.Net.NetworkInformation.IPv6InterfaceProperties : object {
public int Index
public int Mtu
public int get_Index()
public int get_Mtu()
public long GetScopeId(ScopeLevel scopeLevel)
}
internal System.Net.NetworkInformation.LinuxNetworkChange : object {
private object _lock
private Socket nl_sock
private SocketAsyncEventArgs nl_args
private EventType pending_events
private Timer timer
private NetworkAddressChangedEventHandler AddressChanged
private NetworkAvailabilityChangedEventHandler AvailabilityChanged
public bool HasRegisteredEvents
public void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public bool get_HasRegisteredEvents()
public void Dispose()
private bool EnsureSocket()
private void MaybeCloseSocket()
private bool GetAvailability()
private void OnAvailabilityChanged(object unused)
private void OnAddressChanged(object unused)
private void OnEventDue(object unused)
private void QueueEvent(EventType type)
private void OnDataAvailable(object sender, SocketAsyncEventArgs args)
private void Register(NetworkAddressChangedEventHandler d)
private void Register(NetworkAvailabilityChangedEventHandler d)
private void Unregister(NetworkAddressChangedEventHandler d)
private void Unregister(NetworkAvailabilityChangedEventHandler d)
private IntPtr CreateNLSocket()
private EventType ReadEvents(IntPtr sock, IntPtr buffer, int count, int size)
private IntPtr CloseNLSocket(IntPtr sock)
}
internal System.Net.NetworkInformation.MacNetworkChange : object {
private string DL_LIB
private string CORE_SERVICES_LIB
private string CORE_FOUNDATION_LIB
private IntPtr handle
private IntPtr runLoopMode
private SCNetworkReachabilityCallback callback
private bool scheduledWithRunLoop
private NetworkReachabilityFlags flags
private NetworkAddressChangedEventHandler networkAddressChanged
private NetworkAvailabilityChangedEventHandler networkAvailabilityChanged
private bool IsAvailable
public bool HasRegisteredEvents
private IntPtr dlopen(string path, int mode)
private IntPtr dlsym(IntPtr handle, string symbol)
private int dlclose(IntPtr handle)
private void CFRelease(IntPtr handle)
private IntPtr CFRunLoopGetMain()
private IntPtr SCNetworkReachabilityCreateWithAddress(IntPtr allocator, sockaddr_in& sockaddr)
private bool SCNetworkReachabilityGetFlags(IntPtr reachability, NetworkReachabilityFlags& flags)
private bool SCNetworkReachabilitySetCallback(IntPtr reachability, SCNetworkReachabilityCallback callback, SCNetworkReachabilityContext& context)
private bool SCNetworkReachabilityScheduleWithRunLoop(IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode)
private bool SCNetworkReachabilityUnscheduleFromRunLoop(IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode)
private void add_networkAddressChanged(NetworkAddressChangedEventHandler value)
private void remove_networkAddressChanged(NetworkAddressChangedEventHandler value)
private void add_networkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
private void remove_networkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
private bool get_IsAvailable()
public bool get_HasRegisteredEvents()
private bool LoadRunLoopMode()
public void Dispose()
private void HandleCallback(IntPtr reachability, NetworkReachabilityFlags flags, IntPtr info)
}
public System.Net.NetworkInformation.MulticastIPAddressInformation : IPAddressInformation {
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
}
public System.Net.NetworkInformation.MulticastIPAddressInformationCollection : object {
private Collection`1<MulticastIPAddressInformation> addresses
public int Count
public bool IsReadOnly
public MulticastIPAddressInformation Item
public void CopyTo(MulticastIPAddressInformation[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public void Add(MulticastIPAddressInformation address)
internal void InternalAdd(MulticastIPAddressInformation address)
public bool Contains(MulticastIPAddressInformation address)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<MulticastIPAddressInformation> GetEnumerator()
public MulticastIPAddressInformation get_Item(int index)
public bool Remove(MulticastIPAddressInformation address)
public void Clear()
}
public System.Net.NetworkInformation.NetBiosNodeType : Enum {
public int value__
public NetBiosNodeType Unknown
public NetBiosNodeType Broadcast
public NetBiosNodeType Peer2Peer
public NetBiosNodeType Mixed
public NetBiosNodeType Hybrid
}
public System.Net.NetworkInformation.NetworkAddressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, EventArgs e)
public IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.NetworkInformation.NetworkAvailabilityChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, NetworkAvailabilityEventArgs e)
public IAsyncResult BeginInvoke(object sender, NetworkAvailabilityEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.NetworkInformation.NetworkAvailabilityEventArgs : EventArgs {
private bool isAvailable
public bool IsAvailable
internal void .ctor(bool isAvailable)
public bool get_IsAvailable()
}
public System.Net.NetworkInformation.NetworkChange : object {
private INetworkChange networkChange
private bool IsWindows
public void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
private void MaybeCreate()
private bool get_IsWindows()
private void MaybeDispose()
public void RegisterNetworkChange(NetworkChange nc)
}
public System.Net.NetworkInformation.NetworkInformationAccess : Enum {
public int value__
public NetworkInformationAccess None
public NetworkInformationAccess Read
public NetworkInformationAccess Ping
}
public System.Net.NetworkInformation.NetworkInformationException : Win32Exception {
public int ErrorCode
public void .ctor(int errorCode)
internal void .ctor(SocketError socketError)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public int get_ErrorCode()
}
public System.Net.NetworkInformation.NetworkInformationPermission : CodeAccessPermission {
private NetworkInformationAccess access
private bool unrestricted
public NetworkInformationAccess Access
public void .ctor(PermissionState state)
internal void .ctor(bool unrestricted)
public void .ctor(NetworkInformationAccess access)
public NetworkInformationAccess get_Access()
public void AddPermission(NetworkInformationAccess access)
public bool IsUnrestricted()
public IPermission Copy()
public IPermission Union(IPermission target)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
}
public System.Net.NetworkInformation.NetworkInformationPermissionAttribute : CodeAccessSecurityAttribute {
private string strAccess
private string access
public string Access
public void .ctor(SecurityAction action)
public string get_Access()
public void set_Access(string value)
public IPermission CreatePermission()
}
public System.Net.NetworkInformation.NetworkInterface : object {
public int LoopbackInterfaceIndex
public int IPv6LoopbackInterfaceIndex
public string Id
public string Name
public string Description
public OperationalStatus OperationalStatus
public long Speed
public bool IsReceiveOnly
public bool SupportsMulticast
public NetworkInterfaceType NetworkInterfaceType
public NetworkInterface[] GetAllNetworkInterfaces()
public bool GetIsNetworkAvailable()
public int get_LoopbackInterfaceIndex()
public int get_IPv6LoopbackInterfaceIndex()
public string get_Id()
public string get_Name()
public string get_Description()
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public IPInterfaceStatistics GetIPStatistics()
public OperationalStatus get_OperationalStatus()
public long get_Speed()
public bool get_IsReceiveOnly()
public bool get_SupportsMulticast()
public PhysicalAddress GetPhysicalAddress()
public NetworkInterfaceType get_NetworkInterfaceType()
public bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
}
public System.Net.NetworkInformation.NetworkInterfaceComponent : Enum {
public int value__
public NetworkInterfaceComponent IPv4
public NetworkInterfaceComponent IPv6
}
internal System.Net.NetworkInformation.NetworkInterfaceFactory : object {
public NetworkInterface[] GetAllNetworkInterfaces()
public int GetLoopbackInterfaceIndex()
public IPAddress GetNetMask(IPAddress address)
public NetworkInterfaceFactory Create()
}
internal System.Net.NetworkInformation.NetworkInterfaceFactoryPal : object {
public NetworkInterfaceFactory Create()
}
public System.Net.NetworkInformation.NetworkInterfaceType : Enum {
public int value__
public NetworkInterfaceType Unknown
public NetworkInterfaceType Ethernet
public NetworkInterfaceType TokenRing
public NetworkInterfaceType Fddi
public NetworkInterfaceType BasicIsdn
public NetworkInterfaceType PrimaryIsdn
public NetworkInterfaceType Ppp
public NetworkInterfaceType Loopback
public NetworkInterfaceType Ethernet3Megabit
public NetworkInterfaceType Slip
public NetworkInterfaceType Atm
public NetworkInterfaceType GenericModem
public NetworkInterfaceType FastEthernetT
public NetworkInterfaceType Isdn
public NetworkInterfaceType FastEthernetFx
public NetworkInterfaceType Wireless80211
public NetworkInterfaceType AsymmetricDsl
public NetworkInterfaceType RateAdaptDsl
public NetworkInterfaceType SymmetricDsl
public NetworkInterfaceType VeryHighSpeedDsl
public NetworkInterfaceType IPOverAtm
public NetworkInterfaceType GigabitEthernet
public NetworkInterfaceType Tunnel
public NetworkInterfaceType MultiRateSymmetricDsl
public NetworkInterfaceType HighPerformanceSerialBus
public NetworkInterfaceType Wman
public NetworkInterfaceType Wwanpp
public NetworkInterfaceType Wwanpp2
}
public System.Net.NetworkInformation.OperationalStatus : Enum {
public int value__
public OperationalStatus Up
public OperationalStatus Down
public OperationalStatus Testing
public OperationalStatus Unknown
public OperationalStatus Dormant
public OperationalStatus NotPresent
public OperationalStatus LowerLayerDown
}
public System.Net.NetworkInformation.PhysicalAddress : object {
private Byte[] address
private bool changed
private int hash
public PhysicalAddress None
public void .ctor(Byte[] address)
public int GetHashCode()
public bool Equals(object comparand)
public string ToString()
public Byte[] GetAddressBytes()
public PhysicalAddress Parse(string address)
}
public System.Net.NetworkInformation.Ping : Component {
private int DefaultCount
private String[] PingBinPaths
private string PingBinPath
private bool canSendPrivileged
private int default_timeout
private ushort identifier
private UInt32 _LINUX_CAPABILITY_VERSION_1
private Byte[] default_buffer
private BackgroundWorker worker
private object user_async_state
private CancellationTokenSource cts
private PingCompletedEventHandler PingCompleted
public void add_PingCompleted(PingCompletedEventHandler value)
public void remove_PingCompleted(PingCompletedEventHandler value)
private int capget(cap_user_header_t& header, cap_user_data_t& data)
private void CheckLinuxCapabilities()
private void System.IDisposable.Dispose()
protected void OnPingCompleted(PingCompletedEventArgs e)
public PingReply Send(IPAddress address)
public PingReply Send(IPAddress address, int timeout)
public PingReply Send(IPAddress address, int timeout, Byte[] buffer)
public PingReply Send(string hostNameOrAddress)
public PingReply Send(string hostNameOrAddress, int timeout)
public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer)
public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options)
public PingReply Send(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
private PingReply SendPrivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
private PingReply SendUnprivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
public void SendAsync(IPAddress address, int timeout, Byte[] buffer, object userToken)
public void SendAsync(IPAddress address, int timeout, object userToken)
public void SendAsync(IPAddress address, object userToken)
public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, object userToken)
public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options, object userToken)
public void SendAsync(string hostNameOrAddress, int timeout, object userToken)
public void SendAsync(string hostNameOrAddress, object userToken)
public void SendAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options, object userToken)
public void SendAsyncCancel()
private string BuildPingArgs(IPAddress address, int timeout, PingOptions options)
public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer)
public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout)
public Task`1<PingReply> SendPingAsync(IPAddress address)
public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer)
public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options)
public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout)
public Task`1<PingReply> SendPingAsync(string hostNameOrAddress)
public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
}
public System.Net.NetworkInformation.PingCompletedEventArgs : AsyncCompletedEventArgs {
private PingReply reply
public PingReply Reply
internal void .ctor(Exception ex, bool cancelled, object userState, PingReply reply)
public PingReply get_Reply()
}
public System.Net.NetworkInformation.PingCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PingCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, PingCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.NetworkInformation.PingException : InvalidOperationException {
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Net.NetworkInformation.PingOptions : object {
private int DontFragmentFlag
private int ttl
private bool dontFragment
public int Ttl
public bool DontFragment
public void .ctor(int ttl, bool dontFragment)
public int get_Ttl()
public void set_Ttl(int value)
public bool get_DontFragment()
public void set_DontFragment(bool value)
}
public System.Net.NetworkInformation.PingReply : object {
private IPAddress address
private PingOptions options
private IPStatus ipStatus
private long rtt
private Byte[] buffer
public IPStatus Status
public IPAddress Address
public long RoundtripTime
public PingOptions Options
public Byte[] Buffer
internal void .ctor(IPStatus ipStatus)
internal void .ctor(Byte[] data, int dataLength, IPAddress address, int time)
internal void .ctor(IPAddress address, Byte[] buffer, PingOptions options, long roundtripTime, IPStatus status)
private IPStatus GetIPStatus(IcmpV4Type type, IcmpV4Code code)
public IPStatus get_Status()
public IPAddress get_Address()
public long get_RoundtripTime()
public PingOptions get_Options()
public Byte[] get_Buffer()
}
public System.Net.NetworkInformation.PrefixOrigin : Enum {
public int value__
public PrefixOrigin Other
public PrefixOrigin Manual
public PrefixOrigin WellKnown
public PrefixOrigin Dhcp
public PrefixOrigin RouterAdvertisement
}
public System.Net.NetworkInformation.ScopeLevel : Enum {
public int value__
public ScopeLevel None
public ScopeLevel Interface
public ScopeLevel Link
public ScopeLevel Subnet
public ScopeLevel Admin
public ScopeLevel Site
public ScopeLevel Organization
public ScopeLevel Global
}
internal System.Net.NetworkInformation.StartIPOptions : Enum {
public int value__
public StartIPOptions Both
public StartIPOptions None
public StartIPOptions StartIPv4
public StartIPOptions StartIPv6
}
public System.Net.NetworkInformation.SuffixOrigin : Enum {
public int value__
public SuffixOrigin Other
public SuffixOrigin Manual
public SuffixOrigin WellKnown
public SuffixOrigin OriginDhcp
public SuffixOrigin LinkLayerAddress
public SuffixOrigin Random
}
internal System.Net.NetworkInformation.SystemGatewayIPAddressInformation : GatewayIPAddressInformation {
private IPAddress address
public IPAddress Address
internal void .ctor(IPAddress address)
public IPAddress get_Address()
internal GatewayIPAddressInformationCollection ToGatewayIpAddressInformationCollection(IPAddressCollection addresses)
}
internal System.Net.NetworkInformation.SystemIPAddressInformation : IPAddressInformation {
private IPAddress address
internal bool transient
internal bool dnsEligible
public IPAddress Address
public bool IsTransient
public bool IsDnsEligible
public void .ctor(IPAddress address, bool isDnsEligible, bool isTransient)
public IPAddress get_Address()
public bool get_IsTransient()
public bool get_IsDnsEligible()
}
internal System.Net.NetworkInformation.SystemMulticastIPAddressInformation : MulticastIPAddressInformation {
private SystemIPAddressInformation innerInfo
public IPAddress Address
public bool IsTransient
public bool IsDnsEligible
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public long AddressValidLifetime
public long AddressPreferredLifetime
public long DhcpLeaseLifetime
public void .ctor(SystemIPAddressInformation addressInfo)
public IPAddress get_Address()
public bool get_IsTransient()
public bool get_IsDnsEligible()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public long get_AddressValidLifetime()
public long get_AddressPreferredLifetime()
public long get_DhcpLeaseLifetime()
internal MulticastIPAddressInformationCollection ToMulticastIpAddressInformationCollection(IPAddressInformationCollection addresses)
}
internal System.Net.NetworkInformation.SystemNetworkInterface : object {
private NetworkInterfaceFactory nif
public int InternalLoopbackInterfaceIndex
public int InternalIPv6LoopbackInterfaceIndex
public NetworkInterface[] GetNetworkInterfaces()
public bool InternalGetIsNetworkAvailable()
public int get_InternalLoopbackInterfaceIndex()
public int get_InternalIPv6LoopbackInterfaceIndex()
public IPAddress GetNetMask(IPAddress address)
}
internal System.Net.NetworkInformation.SystemTcpConnectionInformation : TcpConnectionInformation {
private IPEndPoint localEndPoint
private IPEndPoint remoteEndPoint
private TcpState state
public TcpState State
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public void .ctor(IPEndPoint local, IPEndPoint remote, TcpState state)
public TcpState get_State()
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
}
public System.Net.NetworkInformation.TcpConnectionInformation : object {
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public TcpState State
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
public TcpState get_State()
}
public System.Net.NetworkInformation.TcpState : Enum {
public int value__
public TcpState Unknown
public TcpState Closed
public TcpState Listen
public TcpState SynSent
public TcpState SynReceived
public TcpState Established
public TcpState FinWait1
public TcpState FinWait2
public TcpState CloseWait
public TcpState Closing
public TcpState LastAck
public TcpState TimeWait
public TcpState DeleteTcb
}
public System.Net.NetworkInformation.TcpStatistics : object {
public long ConnectionsAccepted
public long ConnectionsInitiated
public long CumulativeConnections
public long CurrentConnections
public long ErrorsReceived
public long FailedConnectionAttempts
public long MaximumConnections
public long MaximumTransmissionTimeout
public long MinimumTransmissionTimeout
public long ResetConnections
public long SegmentsReceived
public long SegmentsResent
public long SegmentsSent
public long ResetsSent
public long get_ConnectionsAccepted()
public long get_ConnectionsInitiated()
public long get_CumulativeConnections()
public long get_CurrentConnections()
public long get_ErrorsReceived()
public long get_FailedConnectionAttempts()
public long get_MaximumConnections()
public long get_MaximumTransmissionTimeout()
public long get_MinimumTransmissionTimeout()
public long get_ResetConnections()
public long get_SegmentsReceived()
public long get_SegmentsResent()
public long get_SegmentsSent()
public long get_ResetsSent()
}
public System.Net.NetworkInformation.UdpStatistics : object {
public long DatagramsReceived
public long DatagramsSent
public long IncomingDatagramsDiscarded
public long IncomingDatagramsWithErrors
public int UdpListeners
public long get_DatagramsReceived()
public long get_DatagramsSent()
public long get_IncomingDatagramsDiscarded()
public long get_IncomingDatagramsWithErrors()
public int get_UdpListeners()
}
public System.Net.NetworkInformation.UnicastIPAddressInformation : IPAddressInformation {
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public IPAddress IPv4Mask
public int PrefixLength
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
public IPAddress get_IPv4Mask()
public int get_PrefixLength()
}
public System.Net.NetworkInformation.UnicastIPAddressInformationCollection : object {
private Collection`1<UnicastIPAddressInformation> addresses
public int Count
public bool IsReadOnly
public UnicastIPAddressInformation Item
public void CopyTo(UnicastIPAddressInformation[] array, int offset)
public int get_Count()
public bool get_IsReadOnly()
public void Add(UnicastIPAddressInformation address)
internal void InternalAdd(UnicastIPAddressInformation address)
public bool Contains(UnicastIPAddressInformation address)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<UnicastIPAddressInformation> GetEnumerator()
public UnicastIPAddressInformation get_Item(int index)
public bool Remove(UnicastIPAddressInformation address)
public void Clear()
}
internal System.Net.NetworkInformation.UnixIPGlobalPropertiesFactoryPal : object {
public IPGlobalProperties Create()
}
internal System.Net.NetworkInformation.UnixNetworkInterfaceFactoryPal : object {
public NetworkInterfaceFactory Create()
}
internal System.Net.NetworkInformation.Win32_FIXED_INFO : ValueType {
public string HostName
public string DomainName
public IntPtr CurrentDnsServer
public Win32_IP_ADDR_STRING DnsServerList
public NetBiosNodeType NodeType
public string ScopeId
public UInt32 EnableRouting
public UInt32 EnableProxy
public UInt32 EnableDns
}
internal System.Net.NetworkInformation.Win32_FIXED_INFO_Marshal : ValueType {
private int MAX_HOSTNAME_LEN
private int MAX_DOMAIN_NAME_LEN
private int MAX_SCOPE_ID_LEN
public <HostName>e__FixedBuffer HostName
public <DomainName>e__FixedBuffer DomainName
public IntPtr CurrentDnsServer
public Win32_IP_ADDR_STRING DnsServerList
public NetBiosNodeType NodeType
public <ScopeId>e__FixedBuffer ScopeId
public UInt32 EnableRouting
public UInt32 EnableProxy
public UInt32 EnableDns
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_ADDRESSES : ValueType {
public AlignmentUnion Alignment
public IntPtr Next
public string AdapterName
public IntPtr FirstUnicastAddress
public IntPtr FirstAnycastAddress
public IntPtr FirstMulticastAddress
public IntPtr FirstDnsServerAddress
public string DnsSuffix
public string Description
public string FriendlyName
public Byte[] PhysicalAddress
public UInt32 PhysicalAddressLength
public UInt32 Flags
public UInt32 Mtu
public NetworkInterfaceType IfType
public OperationalStatus OperStatus
public int Ipv6IfIndex
public UInt32[] ZoneIndices
public IntPtr FirstPrefix
public ulong TransmitLinkSpeed
public ulong ReceiveLinkSpeed
public IntPtr FirstWinsServerAddress
public IntPtr FirstGatewayAddress
public UInt32 Ipv4Metric
public UInt32 Ipv6Metric
public ulong Luid
public Win32_SOCKET_ADDRESS Dhcpv4Server
public UInt32 CompartmentId
public ulong NetworkGuid
public int ConnectionType
public int TunnelType
public Win32_SOCKET_ADDRESS Dhcpv6Server
public Byte[] Dhcpv6ClientDuid
public ulong Dhcpv6ClientDuidLength
public ulong Dhcpv6Iaid
public IntPtr FirstDnsSuffix
public int GAA_FLAG_INCLUDE_WINS_INFO
public int GAA_FLAG_INCLUDE_GATEWAYS
private int MAX_ADAPTER_ADDRESS_LENGTH
private int MAX_DHCPV6_DUID_LENGTH
private int IP_ADAPTER_DDNS_ENABLED
private int IP_ADAPTER_DHCP_ENABLED
private int IP_ADAPTER_RECEIVE_ONLY
private int IP_ADAPTER_NO_MULTICAST
public bool DdnsEnabled
public bool DhcpEnabled
public bool IsReceiveOnly
public bool NoMulticast
public bool get_DdnsEnabled()
public bool get_DhcpEnabled()
public bool get_IsReceiveOnly()
public bool get_NoMulticast()
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_ANYCAST_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_DNS_SERVER_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_GATEWAY_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_INFO : ValueType {
private int MAX_ADAPTER_NAME_LENGTH
private int MAX_ADAPTER_DESCRIPTION_LENGTH
private int MAX_ADAPTER_ADDRESS_LENGTH
public IntPtr Next
public int ComboIndex
public string AdapterName
public string Description
public UInt32 AddressLength
public Byte[] Address
public UInt32 Index
public UInt32 Type
public UInt32 DhcpEnabled
public IntPtr CurrentIpAddress
public Win32_IP_ADDR_STRING IpAddressList
public Win32_IP_ADDR_STRING GatewayList
public Win32_IP_ADDR_STRING DhcpServer
public bool HaveWins
public Win32_IP_ADDR_STRING PrimaryWinsServer
public Win32_IP_ADDR_STRING SecondaryWinsServer
public long LeaseObtained
public long LeaseExpires
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_MULTICAST_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_UNICAST_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public DuplicateAddressDetectionState DadState
public UInt32 ValidLifetime
public UInt32 PreferredLifetime
public UInt32 LeaseLifetime
public byte OnLinkPrefixLength
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_WINS_SERVER_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADDR_STRING : ValueType {
public IntPtr Next
public string IpAddress
public string IpMask
public UInt32 Context
}
internal System.Net.NetworkInformation.Win32_IP_PER_ADAPTER_INFO : object {
public UInt32 AutoconfigEnabled
public UInt32 AutoconfigActive
public IntPtr CurrentDnsServer
public Win32_IP_ADDR_STRING DnsServerList
}
internal System.Net.NetworkInformation.Win32_MIB_ICMP_EX : ValueType {
public Win32_MIBICMPSTATS_EX InStats
public Win32_MIBICMPSTATS_EX OutStats
}
internal System.Net.NetworkInformation.Win32_MIB_IFROW : ValueType {
private int MAX_INTERFACE_NAME_LEN
private int MAXLEN_PHYSADDR
private int MAXLEN_IFDESCR
public Char[] Name
public int Index
public NetworkInterfaceType Type
public int Mtu
public UInt32 Speed
public int PhysAddrLen
public Byte[] PhysAddr
public UInt32 AdminStatus
public UInt32 OperStatus
public UInt32 LastChange
public int InOctets
public int InUcastPkts
public int InNUcastPkts
public int InDiscards
public int InErrors
public int InUnknownProtos
public int OutOctets
public int OutUcastPkts
public int OutNUcastPkts
public int OutDiscards
public int OutErrors
public int OutQLen
public int DescrLen
public Byte[] Descr
}
internal System.Net.NetworkInformation.Win32_MIB_IPSTATS : ValueType {
public int Forwarding
public int DefaultTTL
public UInt32 InReceives
public UInt32 InHdrErrors
public UInt32 InAddrErrors
public UInt32 ForwDatagrams
public UInt32 InUnknownProtos
public UInt32 InDiscards
public UInt32 InDelivers
public UInt32 OutRequests
public UInt32 RoutingDiscards
public UInt32 OutDiscards
public UInt32 OutNoRoutes
public UInt32 ReasmTimeout
public UInt32 ReasmReqds
public UInt32 ReasmOks
public UInt32 ReasmFails
public UInt32 FragOks
public UInt32 FragFails
public UInt32 FragCreates
public int NumIf
public int NumAddr
public int NumRoutes
}
internal System.Net.NetworkInformation.Win32_MIB_TCPSTATS : ValueType {
public UInt32 RtoAlgorithm
public UInt32 RtoMin
public UInt32 RtoMax
public UInt32 MaxConn
public UInt32 ActiveOpens
public UInt32 PassiveOpens
public UInt32 AttemptFails
public UInt32 EstabResets
public UInt32 CurrEstab
public UInt32 InSegs
public UInt32 OutSegs
public UInt32 RetransSegs
public UInt32 InErrs
public UInt32 OutRsts
public UInt32 NumConns
}
internal System.Net.NetworkInformation.Win32_MIB_UDPSTATS : ValueType {
public UInt32 InDatagrams
public UInt32 NoPorts
public UInt32 InErrors
public UInt32 OutDatagrams
public int NumAddrs
}
internal System.Net.NetworkInformation.Win32_MIBICMPINFO : ValueType {
public Win32_MIBICMPSTATS InStats
public Win32_MIBICMPSTATS OutStats
}
internal System.Net.NetworkInformation.Win32_MIBICMPSTATS : ValueType {
public UInt32 Msgs
public UInt32 Errors
public UInt32 DestUnreachs
public UInt32 TimeExcds
public UInt32 ParmProbs
public UInt32 SrcQuenchs
public UInt32 Redirects
public UInt32 Echos
public UInt32 EchoReps
public UInt32 Timestamps
public UInt32 TimestampReps
public UInt32 AddrMasks
public UInt32 AddrMaskReps
}
internal System.Net.NetworkInformation.Win32_MIBICMPSTATS_EX : ValueType {
public UInt32 Msgs
public UInt32 Errors
public UInt32[] Counts
}
internal System.Net.NetworkInformation.Win32_SOCKADDR : ValueType {
public ushort AddressFamily
public Byte[] AddressData
}
internal System.Net.NetworkInformation.Win32_SOCKET_ADDRESS : ValueType {
public IntPtr Sockaddr
public int SockaddrLength
private int AF_INET6
public IPAddress GetIPAddress()
}
internal System.Net.NetworkInformation.Win32IcmpV4Statistics : IcmpV4Statistics {
private Win32_MIBICMPSTATS iin
private Win32_MIBICMPSTATS iout
public long AddressMaskRepliesReceived
public long AddressMaskRepliesSent
public long AddressMaskRequestsReceived
public long AddressMaskRequestsSent
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MessagesReceived
public long MessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long SourceQuenchesReceived
public long SourceQuenchesSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long TimestampRepliesReceived
public long TimestampRepliesSent
public long TimestampRequestsReceived
public long TimestampRequestsSent
public void .ctor(Win32_MIBICMPINFO info)
public long get_AddressMaskRepliesReceived()
public long get_AddressMaskRepliesSent()
public long get_AddressMaskRequestsReceived()
public long get_AddressMaskRequestsSent()
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_SourceQuenchesReceived()
public long get_SourceQuenchesSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
public long get_TimestampRepliesReceived()
public long get_TimestampRepliesSent()
public long get_TimestampRequestsReceived()
public long get_TimestampRequestsSent()
}
internal System.Net.NetworkInformation.Win32IcmpV6Statistics : IcmpV6Statistics {
private Win32_MIBICMPSTATS_EX iin
private Win32_MIBICMPSTATS_EX iout
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MembershipQueriesReceived
public long MembershipQueriesSent
public long MembershipReductionsReceived
public long MembershipReductionsSent
public long MembershipReportsReceived
public long MembershipReportsSent
public long MessagesReceived
public long MessagesSent
public long NeighborAdvertisementsReceived
public long NeighborAdvertisementsSent
public long NeighborSolicitsReceived
public long NeighborSolicitsSent
public long PacketTooBigMessagesReceived
public long PacketTooBigMessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long RouterAdvertisementsReceived
public long RouterAdvertisementsSent
public long RouterSolicitsReceived
public long RouterSolicitsSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public void .ctor(Win32_MIB_ICMP_EX info)
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MembershipQueriesReceived()
public long get_MembershipQueriesSent()
public long get_MembershipReductionsReceived()
public long get_MembershipReductionsSent()
public long get_MembershipReportsReceived()
public long get_MembershipReportsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_NeighborAdvertisementsReceived()
public long get_NeighborAdvertisementsSent()
public long get_NeighborSolicitsReceived()
public long get_NeighborSolicitsSent()
public long get_PacketTooBigMessagesReceived()
public long get_PacketTooBigMessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_RouterAdvertisementsReceived()
public long get_RouterAdvertisementsSent()
public long get_RouterSolicitsReceived()
public long get_RouterSolicitsSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
}
internal System.Net.NetworkInformation.Win32IPAddressCollection : IPAddressCollection {
public Win32IPAddressCollection Empty
public void .ctor(IntPtr[] heads)
public void .ctor(Win32_IP_ADDR_STRING[] al)
public Win32IPAddressCollection FromAnycast(IntPtr ptr)
public Win32IPAddressCollection FromDnsServer(IntPtr ptr)
public Win32IPAddressCollection FromSocketAddress(Win32_SOCKET_ADDRESS addr)
public Win32IPAddressCollection FromWinsServer(IntPtr ptr)
private void AddSubsequentlyString(IntPtr head)
}
internal System.Net.NetworkInformation.Win32IPGlobalProperties : IPGlobalProperties {
public int AF_INET
public int AF_INET6
public string DhcpScopeName
public string DomainName
public string HostName
public bool IsWinsProxy
public NetBiosNodeType NodeType
private void FillTcpTable(List`1& tab4, List`1& tab6)
private bool IsListenerState(TcpState state)
public TcpConnectionInformation[] GetActiveTcpConnections()
public IPEndPoint[] GetActiveTcpListeners()
public IPEndPoint[] GetActiveUdpListeners()
public IcmpV4Statistics GetIcmpV4Statistics()
public IcmpV6Statistics GetIcmpV6Statistics()
public IPGlobalStatistics GetIPv4GlobalStatistics()
public IPGlobalStatistics GetIPv6GlobalStatistics()
public TcpStatistics GetTcpIPv4Statistics()
public TcpStatistics GetTcpIPv6Statistics()
public UdpStatistics GetUdpIPv4Statistics()
public UdpStatistics GetUdpIPv6Statistics()
public string get_DhcpScopeName()
public string get_DomainName()
public string get_HostName()
public bool get_IsWinsProxy()
public NetBiosNodeType get_NodeType()
private int GetTcpTable(Byte[] pTcpTable, Int32& pdwSize, bool bOrder)
private int GetTcp6Table(Byte[] TcpTable, Int32& SizePointer, bool Order)
private int GetUdpTable(Byte[] pUdpTable, Int32& pdwSize, bool bOrder)
private int GetUdp6Table(Byte[] Udp6Table, Int32& SizePointer, bool Order)
private int GetTcpStatisticsEx(Win32_MIB_TCPSTATS& pStats, int dwFamily)
private int GetUdpStatisticsEx(Win32_MIB_UDPSTATS& pStats, int dwFamily)
private int GetIcmpStatistics(Win32_MIBICMPINFO& pStats, int dwFamily)
private int GetIcmpStatisticsEx(Win32_MIB_ICMP_EX& pStats, int dwFamily)
private int GetIpStatisticsEx(Win32_MIB_IPSTATS& pStats, int dwFamily)
private ushort ntohs(ushort netshort)
}
internal System.Net.NetworkInformation.Win32IPGlobalPropertiesFactoryPal : object {
public IPGlobalProperties Create()
}
internal System.Net.NetworkInformation.Win32IPGlobalStatistics : IPGlobalStatistics {
private Win32_MIB_IPSTATS info
public int DefaultTtl
public bool ForwardingEnabled
public int NumberOfInterfaces
public int NumberOfIPAddresses
public int NumberOfRoutes
public long OutputPacketRequests
public long OutputPacketRoutingDiscards
public long OutputPacketsDiscarded
public long OutputPacketsWithNoRoute
public long PacketFragmentFailures
public long PacketReassembliesRequired
public long PacketReassemblyFailures
public long PacketReassemblyTimeout
public long PacketsFragmented
public long PacketsReassembled
public long ReceivedPackets
public long ReceivedPacketsDelivered
public long ReceivedPacketsDiscarded
public long ReceivedPacketsForwarded
public long ReceivedPacketsWithAddressErrors
public long ReceivedPacketsWithHeadersErrors
public long ReceivedPacketsWithUnknownProtocol
public void .ctor(Win32_MIB_IPSTATS info)
public int get_DefaultTtl()
public bool get_ForwardingEnabled()
public int get_NumberOfInterfaces()
public int get_NumberOfIPAddresses()
public int get_NumberOfRoutes()
public long get_OutputPacketRequests()
public long get_OutputPacketRoutingDiscards()
public long get_OutputPacketsDiscarded()
public long get_OutputPacketsWithNoRoute()
public long get_PacketFragmentFailures()
public long get_PacketReassembliesRequired()
public long get_PacketReassemblyFailures()
public long get_PacketReassemblyTimeout()
public long get_PacketsFragmented()
public long get_PacketsReassembled()
public long get_ReceivedPackets()
public long get_ReceivedPacketsDelivered()
public long get_ReceivedPacketsDiscarded()
public long get_ReceivedPacketsForwarded()
public long get_ReceivedPacketsWithAddressErrors()
public long get_ReceivedPacketsWithHeadersErrors()
public long get_ReceivedPacketsWithUnknownProtocol()
}
internal System.Net.NetworkInformation.Win32IPInterfaceProperties2 : IPInterfaceProperties {
private Win32_IP_ADAPTER_ADDRESSES addr
private Win32_MIB_IFROW mib4
private Win32_MIB_IFROW mib6
public IPAddressInformationCollection AnycastAddresses
public IPAddressCollection DhcpServerAddresses
public IPAddressCollection DnsAddresses
public string DnsSuffix
public GatewayIPAddressInformationCollection GatewayAddresses
public bool IsDnsEnabled
public bool IsDynamicDnsEnabled
public MulticastIPAddressInformationCollection MulticastAddresses
public UnicastIPAddressInformationCollection UnicastAddresses
public IPAddressCollection WinsServersAddresses
public void .ctor(Win32_IP_ADAPTER_ADDRESSES addr, Win32_MIB_IFROW mib4, Win32_MIB_IFROW mib6)
public IPv4InterfaceProperties GetIPv4Properties()
public IPv6InterfaceProperties GetIPv6Properties()
public IPAddressInformationCollection get_AnycastAddresses()
private IPAddressInformationCollection Win32FromAnycast(IntPtr ptr)
public IPAddressCollection get_DhcpServerAddresses()
public IPAddressCollection get_DnsAddresses()
public string get_DnsSuffix()
public GatewayIPAddressInformationCollection get_GatewayAddresses()
public bool get_IsDnsEnabled()
public bool get_IsDynamicDnsEnabled()
public MulticastIPAddressInformationCollection get_MulticastAddresses()
private MulticastIPAddressInformationCollection Win32FromMulticast(IntPtr ptr)
public UnicastIPAddressInformationCollection get_UnicastAddresses()
private UnicastIPAddressInformationCollection Win32FromUnicast(IntPtr ptr)
public IPAddressCollection get_WinsServersAddresses()
}
internal System.Net.NetworkInformation.Win32IPv4InterfaceProperties : IPv4InterfaceProperties {
private Win32_IP_ADAPTER_ADDRESSES addr
private Win32_IP_PER_ADAPTER_INFO painfo
private Win32_MIB_IFROW mib
public int Index
public bool IsAutomaticPrivateAddressingActive
public bool IsAutomaticPrivateAddressingEnabled
public bool IsDhcpEnabled
public bool IsForwardingEnabled
public int Mtu
public bool UsesWins
private int GetPerAdapterInfo(int IfIndex, Win32_IP_PER_ADAPTER_INFO pPerAdapterInfo, Int32& pOutBufLen)
public void .ctor(Win32_IP_ADAPTER_ADDRESSES addr, Win32_MIB_IFROW mib)
public int get_Index()
public bool get_IsAutomaticPrivateAddressingActive()
public bool get_IsAutomaticPrivateAddressingEnabled()
public bool get_IsDhcpEnabled()
public bool get_IsForwardingEnabled()
public int get_Mtu()
public bool get_UsesWins()
}
internal System.Net.NetworkInformation.Win32IPv4InterfaceStatistics : IPv4InterfaceStatistics {
private Win32_MIB_IFROW info
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public void .ctor(Win32_MIB_IFROW info)
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
internal System.Net.NetworkInformation.Win32IPv6InterfaceProperties : IPv6InterfaceProperties {
private Win32_MIB_IFROW mib
public int Index
public int Mtu
public void .ctor(Win32_MIB_IFROW mib)
public int get_Index()
public int get_Mtu()
}
internal System.Net.NetworkInformation.Win32LengthFlagsUnion : ValueType {
private int IP_ADAPTER_ADDRESS_DNS_ELIGIBLE
private int IP_ADAPTER_ADDRESS_TRANSIENT
public UInt32 Length
public UInt32 Flags
public bool IsDnsEligible
public bool IsTransient
public bool get_IsDnsEligible()
public bool get_IsTransient()
}
internal System.Net.NetworkInformation.Win32NetworkInterface : object {
private Win32_FIXED_INFO fixedInfo
private bool initialized
public Win32_FIXED_INFO FixedInfo
private int GetNetworkParams(IntPtr ptr, Int32& size)
private int MultiByteToWideChar(UInt32 CodePage, UInt32 dwFlags, Byte* lpMultiByteStr, int cbMultiByte, Char* lpWideCharStr, int cchWideChar)
public Win32_FIXED_INFO get_FixedInfo()
internal string <get_FixedInfo>g__GetStringFromMultiByte|5_0(Byte* bytes)
}
internal System.Net.NetworkInformation.Win32NetworkInterface2 : NetworkInterface {
private Win32_IP_ADAPTER_ADDRESSES addr
private Win32_MIB_IFROW mib4
private Win32_MIB_IFROW mib6
private Win32IPv4InterfaceStatistics ip4stats
private IPInterfaceProperties ip_if_props
public string Description
public string Id
public bool IsReceiveOnly
public string Name
public NetworkInterfaceType NetworkInterfaceType
public OperationalStatus OperationalStatus
public long Speed
public bool SupportsMulticast
private int GetAdaptersInfo(IntPtr info, Int32& size)
private int GetIfEntry(Win32_MIB_IFROW& row)
private Win32_IP_ADAPTER_INFO[] GetAdaptersInfo()
internal void .ctor(Win32_IP_ADAPTER_ADDRESSES addr)
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public PhysicalAddress GetPhysicalAddress()
public bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
public string get_Description()
public string get_Id()
public bool get_IsReceiveOnly()
public string get_Name()
public NetworkInterfaceType get_NetworkInterfaceType()
public OperationalStatus get_OperationalStatus()
public long get_Speed()
public bool get_SupportsMulticast()
}
internal System.Net.NetworkInformation.Win32NetworkInterfaceAPI : NetworkInterfaceFactory {
private string IPHLPAPI
private int GetAdaptersAddresses(UInt32 family, UInt32 flags, IntPtr reserved, IntPtr info, Int32& size)
private UInt32 GetBestInterfaceEx(Byte[] ipAddress, Int32& index)
private Win32_IP_ADAPTER_ADDRESSES[] GetAdaptersAddresses()
public NetworkInterface[] GetAllNetworkInterfaces()
private int GetBestInterfaceForAddress(IPAddress addr)
public int GetLoopbackInterfaceIndex()
public IPAddress GetNetMask(IPAddress address)
}
internal System.Net.NetworkInformation.Win32NetworkInterfaceFactoryPal : object {
public NetworkInterfaceFactory Create()
}
internal System.Net.NetworkInformation.Win32TcpStatistics : TcpStatistics {
private Win32_MIB_TCPSTATS info
public long ConnectionsAccepted
public long ConnectionsInitiated
public long CumulativeConnections
public long CurrentConnections
public long ErrorsReceived
public long FailedConnectionAttempts
public long MaximumConnections
public long MaximumTransmissionTimeout
public long MinimumTransmissionTimeout
public long ResetConnections
public long ResetsSent
public long SegmentsReceived
public long SegmentsResent
public long SegmentsSent
public void .ctor(Win32_MIB_TCPSTATS info)
public long get_ConnectionsAccepted()
public long get_ConnectionsInitiated()
public long get_CumulativeConnections()
public long get_CurrentConnections()
public long get_ErrorsReceived()
public long get_FailedConnectionAttempts()
public long get_MaximumConnections()
public long get_MaximumTransmissionTimeout()
public long get_MinimumTransmissionTimeout()
public long get_ResetConnections()
public long get_ResetsSent()
public long get_SegmentsReceived()
public long get_SegmentsResent()
public long get_SegmentsSent()
}
internal System.Net.NetworkInformation.Win32UdpStatistics : UdpStatistics {
private Win32_MIB_UDPSTATS info
public long DatagramsReceived
public long DatagramsSent
public long IncomingDatagramsDiscarded
public long IncomingDatagramsWithErrors
public int UdpListeners
public void .ctor(Win32_MIB_UDPSTATS info)
public long get_DatagramsReceived()
public long get_DatagramsSent()
public long get_IncomingDatagramsDiscarded()
public long get_IncomingDatagramsWithErrors()
public int get_UdpListeners()
}
internal System.Net.NetworkInformation.Win32UnicastIPAddressInformation : UnicastIPAddressInformation {
private Win32_IP_ADAPTER_UNICAST_ADDRESS info
private IPAddress ipv4Mask
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public IPAddress IPv4Mask
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public void .ctor(Win32_IP_ADAPTER_UNICAST_ADDRESS info)
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public IPAddress get_IPv4Mask()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
private IPAddress PrefixLengthToSubnetMask(byte prefixLength, AddressFamily family)
}
internal System.Net.NetworkStreamWrapper : Stream {
private TcpClient _client
private NetworkStream _networkStream
protected bool UsingSecureStream
internal IPAddress ServerAddress
internal Socket Socket
internal NetworkStream NetworkStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
internal void .ctor(TcpClient client)
protected bool get_UsingSecureStream()
internal IPAddress get_ServerAddress()
internal Socket get_Socket()
internal NetworkStream get_NetworkStream()
internal void set_NetworkStream(NetworkStream value)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public long Seek(long offset, SeekOrigin origin)
public int Read(Byte[] buffer, int offset, int size)
public void Write(Byte[] buffer, int offset, int size)
protected void Dispose(bool disposing)
internal void CloseSocket()
public void Close(int timeout)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public void SetLength(long value)
internal void SetSocketTimeoutOption(int timeout)
}
internal System.Net.NTAuthentication : object {
private bool _isServer
private SafeFreeCredentials _credentialsHandle
private SafeDeleteContext _securityContext
private string _spn
private int _tokenSize
private ContextFlagsPal _requestedContextFlags
private ContextFlagsPal _contextFlags
private bool _isCompleted
private string _package
private string _lastProtocolName
private string _protocolName
private string _clientSpecifiedSpn
private ChannelBinding _channelBinding
internal bool IsCompleted
internal bool IsValidContext
internal string Package
internal bool IsServer
internal string ClientSpecifiedSpn
internal string ProtocolName
internal bool IsKerberos
internal bool get_IsCompleted()
internal bool get_IsValidContext()
internal string get_Package()
internal bool get_IsServer()
internal string get_ClientSpecifiedSpn()
internal string get_ProtocolName()
internal bool get_IsKerberos()
internal void .ctor(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding)
private void Initialize(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding)
internal SafeDeleteContext GetContext(SecurityStatusPal& status)
internal void CloseContext()
internal int VerifySignature(Byte[] buffer, int offset, int count)
internal int MakeSignature(Byte[] buffer, int offset, int count, Byte[]& output)
internal string GetOutgoingBlob(string incomingBlob)
internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool thrownOnError)
internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool throwOnError, SecurityStatusPal& statusCode)
private string GetClientSpecifiedSpn()
}
internal System.Net.NtlmClient : object {
private IAuthenticationModule authObject
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
public System.Net.OpenReadCompletedEventArgs : AsyncCompletedEventArgs {
private Stream _result
public Stream Result
internal void .ctor(Stream result, Exception exception, bool cancelled, object userToken)
public Stream get_Result()
}
public System.Net.OpenReadCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, OpenReadCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, OpenReadCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.OpenWriteCompletedEventArgs : AsyncCompletedEventArgs {
private Stream _result
public Stream Result
internal void .ctor(Stream result, Exception exception, bool cancelled, object userToken)
public Stream get_Result()
}
public System.Net.OpenWriteCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, OpenWriteCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, OpenWriteCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.PathList : object {
private SortedList m_list
public int Count
public ICollection Values
public object Item
public object SyncRoot
public int get_Count()
public int GetCookiesCount()
public ICollection get_Values()
public object get_Item(string s)
public void set_Item(string s, object value)
public IEnumerator GetEnumerator()
public object get_SyncRoot()
}
public System.Net.ProtocolViolationException : InvalidOperationException {
public void .ctor(string message)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.Net.ProxyChain : object {
private List`1<Uri> m_Cache
private bool m_CacheComplete
private ProxyEnumerator m_MainEnumerator
private Uri m_Destination
private HttpAbortDelegate m_HttpAbortDelegate
internal IEnumerator`1<Uri> Enumerator
internal Uri Destination
internal HttpAbortDelegate HttpAbortDelegate
protected void .ctor(Uri destination)
public IEnumerator`1<Uri> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Dispose()
internal IEnumerator`1<Uri> get_Enumerator()
internal Uri get_Destination()
internal void Abort()
internal bool HttpAbort(HttpWebRequest request, WebException webException)
internal HttpAbortDelegate get_HttpAbortDelegate()
protected bool GetNextProxy(Uri& proxy)
}
internal System.Net.ProxyScriptChain : ProxyChain {
private WebProxy m_Proxy
private Uri[] m_ScriptProxies
private int m_CurrentIndex
private int m_SyncStatus
internal void .ctor(WebProxy proxy, Uri destination)
protected bool GetNextProxy(Uri& proxy)
internal void Abort()
}
internal System.Net.RangeValidationHelpers : object {
public bool ValidateRange(int actual, int fromAllowed, int toAllowed)
public void ValidateSegment(ArraySegment`1<byte> segment)
}
internal System.Net.ReadState : Enum {
public int value__
public ReadState None
public ReadState Status
public ReadState Headers
public ReadState Content
public ReadState Aborted
}
internal System.Net.ReceiveState : object {
private int bufferSize
internal ResponseDescription Resp
internal int ValidThrough
internal Byte[] Buffer
internal CommandStream Connection
internal void .ctor(CommandStream connection)
}
internal System.Net.RequestStream : Stream {
private Byte[] buffer
private int offset
private int length
private long remaining_body
private bool disposed
private Stream stream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
internal void .ctor(Stream stream, Byte[] buffer, int offset, int length)
internal void .ctor(Stream stream, Byte[] buffer, int offset, int length, long contentlength)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Close()
public void Flush()
private int FillFromBuffer(Byte[] buffer, int off, int count)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public int EndRead(IAsyncResult ares)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public void EndWrite(IAsyncResult async_result)
}
internal System.Net.ResponseDescription : object {
internal int NoStatus
internal bool Multiline
internal int Status
internal string StatusDescription
internal StringBuilder StatusBuffer
internal string StatusCodeString
internal bool PositiveIntermediate
internal bool PositiveCompletion
internal bool TransientFailure
internal bool PermanentFailure
internal bool InvalidStatusCode
internal bool get_PositiveIntermediate()
internal bool get_PositiveCompletion()
internal bool get_TransientFailure()
internal bool get_PermanentFailure()
internal bool get_InvalidStatusCode()
}
internal System.Net.ResponseStream : Stream {
private HttpListenerResponse response
private bool ignore_errors
private bool disposed
private bool trailer_sent
private Stream stream
private Byte[] crlf
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
internal void .ctor(Stream stream, HttpListenerResponse response, bool ignore_errors)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Close()
private MemoryStream GetHeaders(bool closing)
public void Flush()
private Byte[] GetChunkSizeBytes(int size, bool final)
internal void InternalWrite(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public void EndWrite(IAsyncResult ares)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public int EndRead(IAsyncResult ares)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
}
internal System.Net.ScatterGatherBuffers : object {
private MemoryChunk headChunk
private MemoryChunk currentChunk
private int nextChunkLength
private int totalLength
private int chunkCount
private bool Empty
internal int Length
internal void .ctor(long totalSize)
internal BufferOffsetSize[] GetBuffers()
private bool get_Empty()
internal int get_Length()
internal void Write(Byte[] buffer, int offset, int count)
private MemoryChunk AllocateMemoryChunk(int newSize)
}
internal System.Net.SecChannelBindings : object {
internal int dwInitiatorAddrType
internal int cbInitiatorLength
internal int dwInitiatorOffset
internal int dwAcceptorAddrType
internal int cbAcceptorLength
internal int dwAcceptorOffset
internal int cbApplicationDataLength
internal int dwApplicationDataOffset
}
internal System.Net.SecPkgContext_Bindings : ValueType {
internal int BindingsLength
internal IntPtr Bindings
}
internal System.Net.SecPkgContext_ConnectionInfo : object {
public int Protocol
public int DataCipherAlg
public int DataKeySize
public int DataHashAlg
public int DataHashKeySize
public int KeyExchangeAlg
public int KeyExchKeySize
internal void .ctor(Byte[] nativeBuffer)
}
internal System.Net.SecPkgContext_NegotiationInfoW : ValueType {
internal IntPtr PackageInfo
internal UInt32 NegotiationState
}
internal System.Net.SecPkgContext_Sizes : object {
public int cbMaxToken
public int cbMaxSignature
public int cbBlockSize
public int cbSecurityTrailer
public int SizeOf
internal void .ctor(Byte[] memory)
}
internal System.Net.SecPkgContext_StreamSizes : object {
public int cbHeader
public int cbTrailer
public int cbMaximumMessage
public int cBuffers
public int cbBlockSize
public int SizeOf
internal void .ctor(Byte[] memory)
}
public System.Net.Security.AuthenticatedStream : Stream {
private Stream _InnerStream
private bool _LeaveStreamOpen
public bool LeaveInnerStreamOpen
protected Stream InnerStream
public bool IsAuthenticated
public bool IsMutuallyAuthenticated
public bool IsEncrypted
public bool IsSigned
public bool IsServer
protected void .ctor(Stream innerStream, bool leaveInnerStreamOpen)
public bool get_LeaveInnerStreamOpen()
protected Stream get_InnerStream()
protected void Dispose(bool disposing)
public bool get_IsAuthenticated()
public bool get_IsMutuallyAuthenticated()
public bool get_IsEncrypted()
public bool get_IsSigned()
public bool get_IsServer()
}
public System.Net.Security.AuthenticationLevel : Enum {
public int value__
public AuthenticationLevel None
public AuthenticationLevel MutualAuthRequested
public AuthenticationLevel MutualAuthRequired
}
internal System.Net.Security.CertificateHelper : object {
private string ClientAuthenticationOID
internal X509Certificate2 GetEligibleClientCertificate(X509CertificateCollection candidateCerts)
internal X509Certificate2 GetEligibleClientCertificate(X509Certificate2Collection candidateCerts)
private bool IsValidClientCertificate(X509Certificate2 cert)
private bool IsValidForClientAuthenticationEKU(X509EnhancedKeyUsageExtension eku)
private bool IsValidForDigitalSignatureUsage(X509KeyUsageExtension ku)
internal X509Certificate2 GetEligibleClientCertificate()
}
public System.Net.Security.EncryptionPolicy : Enum {
public int value__
public EncryptionPolicy RequireEncryption
public EncryptionPolicy AllowNoEncryption
public EncryptionPolicy NoEncryption
}
public System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
public IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object)
public X509Certificate EndInvoke(IAsyncResult result)
}
internal System.Net.Security.LocalCertSelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public X509Certificate Invoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
public IAsyncResult BeginInvoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object)
public X509Certificate EndInvoke(IAsyncResult result)
}
public System.Net.Security.NegotiateStream : AuthenticatedStream {
private int readTimeout
private int writeTimeout
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public TokenImpersonationLevel ImpersonationLevel
public bool IsAuthenticated
public bool IsEncrypted
public bool IsMutuallyAuthenticated
public bool IsServer
public bool IsSigned
public long Length
public long Position
public int ReadTimeout
public IIdentity RemoteIdentity
public int WriteTimeout
public void .ctor(Stream innerStream)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public TokenImpersonationLevel get_ImpersonationLevel()
public bool get_IsAuthenticated()
public bool get_IsEncrypted()
public bool get_IsMutuallyAuthenticated()
public bool get_IsServer()
public bool get_IsSigned()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public IIdentity get_RemoteIdentity()
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void AuthenticateAsClient()
public void AuthenticateAsClient(NetworkCredential credential, string targetName)
public void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName)
public void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)
public void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)
public void AuthenticateAsServer()
public void AuthenticateAsServer(ExtendedProtectionPolicy policy)
public void AuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
public void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
protected void Dispose(bool disposing)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public int EndRead(IAsyncResult asyncResult)
public void EndAuthenticateAsServer(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public Task AuthenticateAsClientAsync()
public Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName)
public Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)
public Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName)
public Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)
public Task AuthenticateAsServerAsync()
public Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy)
public Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
public Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
}
internal System.Net.Security.NegotiateStreamPal : object {
internal int QueryMaxTokenSize(string package)
internal SafeFreeCredentials AcquireDefaultCredential(string package, bool isServer)
internal SafeFreeCredentials AcquireCredentialsHandle(string package, bool isServer, NetworkCredential credential)
internal string QueryContextClientSpecifiedSpn(SafeDeleteContext securityContext)
internal string QueryContextAuthenticationPackage(SafeDeleteContext securityContext)
internal SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, string spn, ContextFlagsPal requestedContextFlags, SecurityBuffer[] inSecurityBufferArray, SecurityBuffer outSecurityBuffer, ContextFlagsPal& contextFlags)
internal SecurityStatusPal CompleteAuthToken(SafeDeleteContext& securityContext, SecurityBuffer[] inSecurityBufferArray)
internal SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, ContextFlagsPal requestedContextFlags, SecurityBuffer[] inSecurityBufferArray, SecurityBuffer outSecurityBuffer, ContextFlagsPal& contextFlags)
internal Win32Exception CreateExceptionFromError(SecurityStatusPal statusCode)
internal int VerifySignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count)
internal int MakeSignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, Byte[]& output)
}
public System.Net.Security.ProtectionLevel : Enum {
public int value__
public ProtectionLevel None
public ProtectionLevel Sign
public ProtectionLevel EncryptAndSign
}
public System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
public IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal System.Net.Security.RemoteCertValidationCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(string host, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
public IAsyncResult BeginInvoke(string host, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal System.Net.Security.SafeCredentialReference : CriticalHandleMinusOneIsInvalid {
internal SafeFreeCredentials Target
internal SafeCredentialReference CreateReference(SafeFreeCredentials target)
private void .ctor(SafeFreeCredentials target)
protected bool ReleaseHandle()
}
internal System.Net.Security.SafeDeleteContext : SafeHandle {
internal CredHandle _handle
private string dummyStr
private Byte[] s_dummyBytes
private IdnMapping s_idnMapping
protected SafeFreeCredentials _EffectiveCredential
public bool IsInvalid
public bool get_IsInvalid()
public string ToString()
internal int InitializeSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inSecBuffer, SecurityBuffer[] inSecBuffers, SecurityBuffer outSecBuffer, ContextFlags& outFlags)
private int MustRunInitializeSecurityContext(SafeFreeCredentials& inCredentials, Void* inContextPtr, Byte* targetName, ContextFlags inFlags, Endianness endianness, SecBufferDesc* inputBuffer, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& attributes, SafeFreeContextBuffer handleTemplate)
internal int AcceptSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, ContextFlags inFlags, Endianness endianness, SecurityBuffer inSecBuffer, SecurityBuffer[] inSecBuffers, SecurityBuffer outSecBuffer, ContextFlags& outFlags)
private int MustRunAcceptSecurityContext_SECURITY(SafeFreeCredentials& inCredentials, Void* inContextPtr, SecBufferDesc* inputBuffer, ContextFlags inFlags, Endianness endianness, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& outFlags, SafeFreeContextBuffer handleTemplate)
internal int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inSecBuffers)
internal int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inSecBuffers)
}
internal System.Net.Security.SafeDeleteContext_SECURITY : SafeDeleteContext {
protected bool ReleaseHandle()
}
internal System.Net.Security.SafeFreeCertContext : SafeHandleZeroOrMinusOneIsInvalid {
private UInt32 CRYPT_ACQUIRE_SILENT_FLAG
internal void Set(IntPtr value)
protected bool ReleaseHandle()
}
internal System.Net.Security.SafeFreeContextBuffer : SafeHandleZeroOrMinusOneIsInvalid {
internal void Set(IntPtr value)
internal int EnumeratePackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray)
internal SafeFreeContextBuffer CreateEmptyHandle()
public int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte* buffer, SafeHandle refHandle)
public int SetContextAttributes(SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte[] buffer)
}
internal System.Net.Security.SafeFreeContextBuffer_SECURITY : SafeFreeContextBuffer {
protected bool ReleaseHandle()
}
internal System.Net.Security.SafeFreeContextBufferChannelBinding : ChannelBinding {
private int _size
public int Size
public bool IsInvalid
public int get_Size()
public bool get_IsInvalid()
internal void Set(IntPtr value)
internal SafeFreeContextBufferChannelBinding CreateEmptyHandle()
public int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute contextAttribute, SecPkgContext_Bindings* buffer, SafeFreeContextBufferChannelBinding refHandle)
public string ToString()
}
internal System.Net.Security.SafeFreeContextBufferChannelBinding_SECURITY : SafeFreeContextBufferChannelBinding {
protected bool ReleaseHandle()
}
internal System.Net.Security.SafeFreeCredential_SECURITY : SafeFreeCredentials {
protected bool ReleaseHandle()
}
internal System.Net.Security.SafeFreeCredentials : SafeHandle {
internal CredHandle _handle
public bool IsInvalid
public bool get_IsInvalid()
public int AcquireCredentialsHandle(string package, CredentialUse intent, SEC_WINNT_AUTH_IDENTITY_W& authdata, SafeFreeCredentials& outCredential)
public int AcquireDefaultCredential(string package, CredentialUse intent, SafeFreeCredentials& outCredential)
public int AcquireCredentialsHandle(string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential)
public int AcquireCredentialsHandle(string package, CredentialUse intent, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential)
}
internal System.Net.Security.SafeSspiAuthDataHandle : SafeHandleZeroOrMinusOneIsInvalid {
protected bool ReleaseHandle()
}
internal System.Net.Security.SecurityBuffer : object {
public int size
public SecurityBufferType type
public Byte[] token
public SafeHandle unmanagedToken
public int offset
public void .ctor(Byte[] data, int offset, int size, SecurityBufferType tokentype)
public void .ctor(Byte[] data, SecurityBufferType tokentype)
public void .ctor(int size, SecurityBufferType tokentype)
public void .ctor(ChannelBinding binding)
}
internal System.Net.Security.SecurityBufferType : Enum {
public int value__
public SecurityBufferType SECBUFFER_EMPTY
public SecurityBufferType SECBUFFER_DATA
public SecurityBufferType SECBUFFER_TOKEN
public SecurityBufferType SECBUFFER_PKG_PARAMS
public SecurityBufferType SECBUFFER_MISSING
public SecurityBufferType SECBUFFER_EXTRA
public SecurityBufferType SECBUFFER_STREAM_TRAILER
public SecurityBufferType SECBUFFER_STREAM_HEADER
public SecurityBufferType SECBUFFER_PADDING
public SecurityBufferType SECBUFFER_STREAM
public SecurityBufferType SECBUFFER_CHANNEL_BINDINGS
public SecurityBufferType SECBUFFER_TARGET_HOST
public SecurityBufferType SECBUFFER_ALERT
public SecurityBufferType SECBUFFER_APPLICATION_PROTOCOLS
public SecurityBufferType SECBUFFER_READONLY
public SecurityBufferType SECBUFFER_READONLY_WITH_CHECKSUM
}
internal System.Net.Security.SecurityContextTokenHandle : CriticalHandleZeroOrMinusOneIsInvalid {
private int _disposed
internal IntPtr DangerousGetHandle()
protected bool ReleaseHandle()
}
public System.Net.Security.ServerCertificateSelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public X509Certificate Invoke(object sender, string hostName)
public IAsyncResult BeginInvoke(object sender, string hostName, AsyncCallback callback, object object)
public X509Certificate EndInvoke(IAsyncResult result)
}
internal System.Net.Security.ServerCertSelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public X509Certificate Invoke(string hostName)
public IAsyncResult BeginInvoke(string hostName, AsyncCallback callback, object object)
public X509Certificate EndInvoke(IAsyncResult result)
}
public System.Net.Security.SslApplicationProtocol : ValueType {
private ReadOnlyMemory`1<byte> _readOnlyProtocol
private Encoding s_utf8
public SslApplicationProtocol Http2
public SslApplicationProtocol Http11
public ReadOnlyMemory`1<byte> Protocol
internal void .ctor(Byte[] protocol, bool copy)
public void .ctor(Byte[] protocol)
public void .ctor(string protocol)
public ReadOnlyMemory`1<byte> get_Protocol()
public bool Equals(SslApplicationProtocol other)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
private char GetHexValue(int i)
public bool op_Equality(SslApplicationProtocol left, SslApplicationProtocol right)
public bool op_Inequality(SslApplicationProtocol left, SslApplicationProtocol right)
}
internal System.Net.Security.SslAuthenticationOptions : object {
private bool <AllowRenegotiation>k__BackingField
private string <TargetHost>k__BackingField
private X509CertificateCollection <ClientCertificates>k__BackingField
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField
private bool <IsServer>k__BackingField
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField
private LocalCertificateSelectionCallback <LocalCertificateSelectionCallback>k__BackingField
private X509Certificate <ServerCertificate>k__BackingField
private SslProtocols <EnabledSslProtocols>k__BackingField
private X509RevocationMode <CertificateRevocationCheckMode>k__BackingField
private EncryptionPolicy <EncryptionPolicy>k__BackingField
private bool <RemoteCertRequired>k__BackingField
private bool <CheckCertName>k__BackingField
private RemoteCertValidationCallback <CertValidationDelegate>k__BackingField
private LocalCertSelectionCallback <CertSelectionDelegate>k__BackingField
private ServerCertSelectionCallback <ServerCertSelectionDelegate>k__BackingField
internal bool AllowRenegotiation
internal string TargetHost
internal X509CertificateCollection ClientCertificates
internal List`1<SslApplicationProtocol> ApplicationProtocols
internal bool IsServer
internal RemoteCertificateValidationCallback RemoteCertificateValidationCallback
internal LocalCertificateSelectionCallback LocalCertificateSelectionCallback
internal X509Certificate ServerCertificate
internal SslProtocols EnabledSslProtocols
internal X509RevocationMode CertificateRevocationCheckMode
internal EncryptionPolicy EncryptionPolicy
internal bool RemoteCertRequired
internal bool CheckCertName
internal RemoteCertValidationCallback CertValidationDelegate
internal LocalCertSelectionCallback CertSelectionDelegate
internal ServerCertSelectionCallback ServerCertSelectionDelegate
internal void .ctor(SslClientAuthenticationOptions sslClientAuthenticationOptions, RemoteCertValidationCallback remoteCallback, LocalCertSelectionCallback localCallback)
internal void .ctor(SslServerAuthenticationOptions sslServerAuthenticationOptions)
internal bool get_AllowRenegotiation()
internal void set_AllowRenegotiation(bool value)
internal string get_TargetHost()
internal void set_TargetHost(string value)
internal X509CertificateCollection get_ClientCertificates()
internal void set_ClientCertificates(X509CertificateCollection value)
internal List`1<SslApplicationProtocol> get_ApplicationProtocols()
internal bool get_IsServer()
internal void set_IsServer(bool value)
internal RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
internal void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value)
internal LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback()
internal void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value)
internal X509Certificate get_ServerCertificate()
internal void set_ServerCertificate(X509Certificate value)
internal SslProtocols get_EnabledSslProtocols()
internal void set_EnabledSslProtocols(SslProtocols value)
internal X509RevocationMode get_CertificateRevocationCheckMode()
internal void set_CertificateRevocationCheckMode(X509RevocationMode value)
internal EncryptionPolicy get_EncryptionPolicy()
internal void set_EncryptionPolicy(EncryptionPolicy value)
internal bool get_RemoteCertRequired()
internal void set_RemoteCertRequired(bool value)
internal bool get_CheckCertName()
internal void set_CheckCertName(bool value)
internal RemoteCertValidationCallback get_CertValidationDelegate()
internal void set_CertValidationDelegate(RemoteCertValidationCallback value)
internal LocalCertSelectionCallback get_CertSelectionDelegate()
internal void set_CertSelectionDelegate(LocalCertSelectionCallback value)
internal ServerCertSelectionCallback get_ServerCertSelectionDelegate()
internal void set_ServerCertSelectionDelegate(ServerCertSelectionCallback value)
}
public System.Net.Security.SslClientAuthenticationOptions : object {
private EncryptionPolicy _encryptionPolicy
private X509RevocationMode _checkCertificateRevocation
private SslProtocols _enabledSslProtocols
private bool _allowRenegotiation
private LocalCertificateSelectionCallback <LocalCertificateSelectionCallback>k__BackingField
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField
private string <TargetHost>k__BackingField
private X509CertificateCollection <ClientCertificates>k__BackingField
public bool AllowRenegotiation
public LocalCertificateSelectionCallback LocalCertificateSelectionCallback
public RemoteCertificateValidationCallback RemoteCertificateValidationCallback
public List`1<SslApplicationProtocol> ApplicationProtocols
public string TargetHost
public X509CertificateCollection ClientCertificates
public X509RevocationMode CertificateRevocationCheckMode
public EncryptionPolicy EncryptionPolicy
public SslProtocols EnabledSslProtocols
public bool get_AllowRenegotiation()
public void set_AllowRenegotiation(bool value)
public LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback()
public void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value)
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value)
public List`1<SslApplicationProtocol> get_ApplicationProtocols()
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value)
public string get_TargetHost()
public void set_TargetHost(string value)
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public X509RevocationMode get_CertificateRevocationCheckMode()
public void set_CertificateRevocationCheckMode(X509RevocationMode value)
public EncryptionPolicy get_EncryptionPolicy()
public void set_EncryptionPolicy(EncryptionPolicy value)
public SslProtocols get_EnabledSslProtocols()
public void set_EnabledSslProtocols(SslProtocols value)
}
internal System.Net.Security.SslClientAuthenticationOptionsExtensions : object {
public SslClientAuthenticationOptions ShallowClone(SslClientAuthenticationOptions options)
}
public System.Net.Security.SslPolicyErrors : Enum {
public int value__
public SslPolicyErrors None
public SslPolicyErrors RemoteCertificateNotAvailable
public SslPolicyErrors RemoteCertificateNameMismatch
public SslPolicyErrors RemoteCertificateChainErrors
}
public System.Net.Security.SslServerAuthenticationOptions : object {
private X509RevocationMode _checkCertificateRevocation
private SslProtocols _enabledSslProtocols
private EncryptionPolicy _encryptionPolicy
private bool _allowRenegotiation
private bool <ClientCertificateRequired>k__BackingField
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField
private ServerCertificateSelectionCallback <ServerCertificateSelectionCallback>k__BackingField
private X509Certificate <ServerCertificate>k__BackingField
public bool AllowRenegotiation
public bool ClientCertificateRequired
public List`1<SslApplicationProtocol> ApplicationProtocols
public RemoteCertificateValidationCallback RemoteCertificateValidationCallback
public ServerCertificateSelectionCallback ServerCertificateSelectionCallback
public X509Certificate ServerCertificate
public SslProtocols EnabledSslProtocols
public X509RevocationMode CertificateRevocationCheckMode
public EncryptionPolicy EncryptionPolicy
public bool get_AllowRenegotiation()
public void set_AllowRenegotiation(bool value)
public bool get_ClientCertificateRequired()
public void set_ClientCertificateRequired(bool value)
public List`1<SslApplicationProtocol> get_ApplicationProtocols()
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value)
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value)
public ServerCertificateSelectionCallback get_ServerCertificateSelectionCallback()
public void set_ServerCertificateSelectionCallback(ServerCertificateSelectionCallback value)
public X509Certificate get_ServerCertificate()
public void set_ServerCertificate(X509Certificate value)
public SslProtocols get_EnabledSslProtocols()
public void set_EnabledSslProtocols(SslProtocols value)
public X509RevocationMode get_CertificateRevocationCheckMode()
public void set_CertificateRevocationCheckMode(X509RevocationMode value)
public EncryptionPolicy get_EncryptionPolicy()
public void set_EncryptionPolicy(EncryptionPolicy value)
}
public System.Net.Security.SslStream : AuthenticatedStream {
private MobileTlsProvider provider
private MonoTlsSettings settings
private RemoteCertificateValidationCallback validationCallback
private LocalCertificateSelectionCallback selectionCallback
private MobileAuthenticatedStream impl
private bool explicitSettings
internal MobileAuthenticatedStream Impl
internal MonoTlsProvider Provider
internal string InternalTargetHost
public TransportContext TransportContext
public bool IsAuthenticated
public bool IsMutuallyAuthenticated
public bool IsEncrypted
public bool IsSigned
public bool IsServer
public SslProtocols SslProtocol
public bool CheckCertRevocationStatus
public X509Certificate LocalCertificate
public X509Certificate RemoteCertificate
public CipherAlgorithmType CipherAlgorithm
public int CipherStrength
public HashAlgorithmType HashAlgorithm
public int HashStrength
public ExchangeAlgorithmType KeyExchangeAlgorithm
public int KeyExchangeStrength
public SslApplicationProtocol NegotiatedApplicationProtocol
public bool CanSeek
public bool CanRead
public bool CanTimeout
public bool CanWrite
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
internal MobileAuthenticatedStream get_Impl()
internal MonoTlsProvider get_Provider()
internal string get_InternalTargetHost()
private MobileTlsProvider GetProvider()
public void .ctor(Stream innerStream)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback)
public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy)
internal void .ctor(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsProvider provider, MonoTlsSettings settings)
internal IMonoSslStream CreateMonoSslStream(Stream innerStream, bool leaveInnerStreamOpen, MobileTlsProvider provider, MonoTlsSettings settings)
private void SetAndVerifyValidationCallback(RemoteCertificateValidationCallback callback)
private void SetAndVerifySelectionCallback(LocalCertificateSelectionCallback callback)
private MonoSslServerAuthenticationOptions CreateAuthenticationOptions(SslServerAuthenticationOptions sslServerAuthenticationOptions)
public void AuthenticateAsClient(string targetHost)
public void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation)
public void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public void AuthenticateAsServer(X509Certificate serverCertificate)
public void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation)
public void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public void EndAuthenticateAsServer(IAsyncResult asyncResult)
public TransportContext get_TransportContext()
public Task AuthenticateAsClientAsync(string targetHost)
public Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation)
public Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task AuthenticateAsClientAsync(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation)
public Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
public Task AuthenticateAsServerAsync(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken)
public Task ShutdownAsync()
public bool get_IsAuthenticated()
public bool get_IsMutuallyAuthenticated()
public bool get_IsEncrypted()
public bool get_IsSigned()
public bool get_IsServer()
public SslProtocols get_SslProtocol()
public bool get_CheckCertRevocationStatus()
public X509Certificate get_LocalCertificate()
public X509Certificate get_RemoteCertificate()
public CipherAlgorithmType get_CipherAlgorithm()
public int get_CipherStrength()
public HashAlgorithmType get_HashAlgorithm()
public int get_HashStrength()
public ExchangeAlgorithmType get_KeyExchangeAlgorithm()
public int get_KeyExchangeStrength()
public SslApplicationProtocol get_NegotiatedApplicationProtocol()
public bool get_CanSeek()
public bool get_CanRead()
public bool get_CanTimeout()
public bool get_CanWrite()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void SetLength(long value)
public long Seek(long offset, SeekOrigin origin)
public Task FlushAsync(CancellationToken cancellationToken)
public void Flush()
private void CheckDisposed()
protected void Dispose(bool disposing)
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer)
public void Write(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
}
internal System.Net.Security.SSPIHandleCache : object {
private int c_MaxCacheSize
private SafeCredentialReference[] s_cacheSlots
private int s_current
internal void CacheCredential(SafeFreeCredentials newHandle)
}
internal System.Net.SecurityPackageInfo : ValueType {
internal int Capabilities
internal short Version
internal short RPCID
internal int MaxToken
internal IntPtr Name
internal IntPtr Comment
}
internal System.Net.SecurityPackageInfoClass : object {
internal int Capabilities
internal short Version
internal short RPCID
internal int MaxToken
internal string Name
internal string Comment
internal void .ctor(SafeHandle safeHandle, int index)
public string ToString()
}
internal System.Net.SecurityProtocol : object {
public SslProtocols DefaultSecurityProtocols
public SslProtocols SystemDefaultSecurityProtocols
}
public System.Net.SecurityProtocolType : Enum {
public int value__
public SecurityProtocolType SystemDefault
public SecurityProtocolType Ssl3
public SecurityProtocolType Tls
public SecurityProtocolType Tls11
public SecurityProtocolType Tls12
public SecurityProtocolType Tls13
}
internal System.Net.SecurityStatus : Enum {
public int value__
public SecurityStatus OK
public SecurityStatus ContinueNeeded
public SecurityStatus CompleteNeeded
public SecurityStatus CompAndContinue
public SecurityStatus ContextExpired
public SecurityStatus CredentialsNeeded
public SecurityStatus Renegotiate
public SecurityStatus OutOfMemory
public SecurityStatus InvalidHandle
public SecurityStatus Unsupported
public SecurityStatus TargetUnknown
public SecurityStatus InternalError
public SecurityStatus PackageNotFound
public SecurityStatus NotOwner
public SecurityStatus CannotInstall
public SecurityStatus InvalidToken
public SecurityStatus CannotPack
public SecurityStatus QopNotSupported
public SecurityStatus NoImpersonation
public SecurityStatus LogonDenied
public SecurityStatus UnknownCredentials
public SecurityStatus NoCredentials
public SecurityStatus MessageAltered
public SecurityStatus OutOfSequence
public SecurityStatus NoAuthenticatingAuthority
public SecurityStatus IncompleteMessage
public SecurityStatus IncompleteCredentials
public SecurityStatus BufferNotEnough
public SecurityStatus WrongPrincipal
public SecurityStatus TimeSkew
public SecurityStatus UntrustedRoot
public SecurityStatus IllegalMessage
public SecurityStatus CertUnknown
public SecurityStatus CertExpired
public SecurityStatus AlgorithmMismatch
public SecurityStatus SecurityQosFailed
public SecurityStatus SmartcardLogonRequired
public SecurityStatus UnsupportedPreauth
public SecurityStatus BadBinding
}
internal System.Net.SecurityStatusAdapterPal : object {
private int StatusDictionarySize
private BidirectionalDictionary`2<SECURITY_STATUS, SecurityStatusPalErrorCode> s_statusDictionary
internal SecurityStatusPal GetSecurityStatusPalFromNativeInt(int win32SecurityStatus)
internal SecurityStatusPal GetSecurityStatusPalFromInterop(SECURITY_STATUS win32SecurityStatus, bool attachException)
internal SECURITY_STATUS GetInteropFromSecurityStatusPal(SecurityStatusPal status)
}
internal System.Net.SecurityStatusPal : ValueType {
public SecurityStatusPalErrorCode ErrorCode
public Exception Exception
public void .ctor(SecurityStatusPalErrorCode errorCode, Exception exception)
public string ToString()
}
internal System.Net.SecurityStatusPalErrorCode : Enum {
public int value__
public SecurityStatusPalErrorCode NotSet
public SecurityStatusPalErrorCode OK
public SecurityStatusPalErrorCode ContinueNeeded
public SecurityStatusPalErrorCode CompleteNeeded
public SecurityStatusPalErrorCode CompAndContinue
public SecurityStatusPalErrorCode ContextExpired
public SecurityStatusPalErrorCode CredentialsNeeded
public SecurityStatusPalErrorCode Renegotiate
public SecurityStatusPalErrorCode OutOfMemory
public SecurityStatusPalErrorCode InvalidHandle
public SecurityStatusPalErrorCode Unsupported
public SecurityStatusPalErrorCode TargetUnknown
public SecurityStatusPalErrorCode InternalError
public SecurityStatusPalErrorCode PackageNotFound
public SecurityStatusPalErrorCode NotOwner
public SecurityStatusPalErrorCode CannotInstall
public SecurityStatusPalErrorCode InvalidToken
public SecurityStatusPalErrorCode CannotPack
public SecurityStatusPalErrorCode QopNotSupported
public SecurityStatusPalErrorCode NoImpersonation
public SecurityStatusPalErrorCode LogonDenied
public SecurityStatusPalErrorCode UnknownCredentials
public SecurityStatusPalErrorCode NoCredentials
public SecurityStatusPalErrorCode MessageAltered
public SecurityStatusPalErrorCode OutOfSequence
public SecurityStatusPalErrorCode NoAuthenticatingAuthority
public SecurityStatusPalErrorCode IncompleteMessage
public SecurityStatusPalErrorCode IncompleteCredentials
public SecurityStatusPalErrorCode BufferNotEnough
public SecurityStatusPalErrorCode WrongPrincipal
public SecurityStatusPalErrorCode TimeSkew
public SecurityStatusPalErrorCode UntrustedRoot
public SecurityStatusPalErrorCode IllegalMessage
public SecurityStatusPalErrorCode CertUnknown
public SecurityStatusPalErrorCode CertExpired
public SecurityStatusPalErrorCode AlgorithmMismatch
public SecurityStatusPalErrorCode SecurityQosFailed
public SecurityStatusPalErrorCode SmartcardLogonRequired
public SecurityStatusPalErrorCode UnsupportedPreauth
public SecurityStatusPalErrorCode BadBinding
public SecurityStatusPalErrorCode DowngradeDetected
public SecurityStatusPalErrorCode ApplicationProtocolMismatch
}
internal System.Net.Semaphore : WaitHandle {
internal void .ctor(int initialCount, int maxCount)
internal bool ReleaseSemaphore()
}
internal System.Net.ServerCertValidationCallback : object {
private RemoteCertificateValidationCallback m_ValidationCallback
private ExecutionContext m_Context
internal RemoteCertificateValidationCallback ValidationCallback
internal void .ctor(RemoteCertificateValidationCallback validationCallback)
internal RemoteCertificateValidationCallback get_ValidationCallback()
internal void Callback(object state)
internal bool Invoke(object request, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
}
internal System.Net.ServiceNameStore : object {
private List`1<string> serviceNames
private ServiceNameCollection serviceNameCollection
public ServiceNameCollection ServiceNames
public ServiceNameCollection get_ServiceNames()
private bool AddSingleServiceName(string spn)
public bool Add(string uriPrefix)
public bool Remove(string uriPrefix)
private bool Contains(string newServiceName)
public void Clear()
private string ExtractHostname(string uriPrefix, bool allowInvalidUriStrings)
public string BuildSimpleServiceName(string uriPrefix)
public String[] BuildServiceNames(string uriPrefix)
}
public System.Net.ServicePoint : object {
private Uri uri
private DateTime lastDnsResolve
private Version protocolVersion
private IPHostEntry host
private bool usesProxy
private bool sendContinue
private bool useConnect
private object hostE
private bool useNagle
private BindIPEndPoint endPointCallback
private bool tcp_keepalive
private int tcp_keepalive_time
private int tcp_keepalive_interval
private bool disposed
private int connectionLeaseTimeout
private int receiveBufferSize
private SPKey <Key>k__BackingField
private ServicePointScheduler <Scheduler>k__BackingField
private int connectionLimit
private int maxIdleTime
private object m_ServerCertificateOrBytes
private object m_ClientCertificateOrBytes
internal SPKey Key
private ServicePointScheduler Scheduler
public Uri Address
public BindIPEndPoint BindIPEndPointDelegate
public int ConnectionLeaseTimeout
public int ConnectionLimit
public string ConnectionName
public int CurrentConnections
public DateTime IdleSince
public int MaxIdleTime
public Version ProtocolVersion
public int ReceiveBufferSize
public bool SupportsPipelining
public bool Expect100Continue
public bool UseNagleAlgorithm
internal bool SendContinue
internal bool UsesProxy
internal bool UseConnect
private bool HasTimedOut
internal IPHostEntry HostEntry
public X509Certificate Certificate
public X509Certificate ClientCertificate
internal void .ctor(SPKey key, Uri uri, int connectionLimit, int maxIdleTime)
internal SPKey get_Key()
private ServicePointScheduler get_Scheduler()
private void set_Scheduler(ServicePointScheduler value)
public Uri get_Address()
public BindIPEndPoint get_BindIPEndPointDelegate()
public void set_BindIPEndPointDelegate(BindIPEndPoint value)
public int get_ConnectionLeaseTimeout()
public void set_ConnectionLeaseTimeout(int value)
public int get_ConnectionLimit()
public void set_ConnectionLimit(int value)
public string get_ConnectionName()
public int get_CurrentConnections()
public DateTime get_IdleSince()
public int get_MaxIdleTime()
public void set_MaxIdleTime(int value)
public Version get_ProtocolVersion()
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public bool get_SupportsPipelining()
public bool get_Expect100Continue()
public void set_Expect100Continue(bool value)
public bool get_UseNagleAlgorithm()
public void set_UseNagleAlgorithm(bool value)
internal bool get_SendContinue()
internal void set_SendContinue(bool value)
public void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval)
internal void KeepAliveSetup(Socket socket)
private void PutBytes(Byte[] bytes, UInt32 v, int offset)
internal bool get_UsesProxy()
internal void set_UsesProxy(bool value)
internal bool get_UseConnect()
internal void set_UseConnect(bool value)
private bool get_HasTimedOut()
internal IPHostEntry get_HostEntry()
internal void SetVersion(Version version)
internal void SendRequest(WebOperation operation, string groupName)
public bool CloseConnectionGroup(string connectionGroupName)
internal void FreeServicePoint()
public X509Certificate get_Certificate()
internal void UpdateServerCertificate(X509Certificate certificate)
public X509Certificate get_ClientCertificate()
internal void UpdateClientCertificate(X509Certificate certificate)
internal bool CallEndPointDelegate(Socket sock, IPEndPoint remote)
}
public System.Net.ServicePointManager : object {
private ConcurrentDictionary`2<SPKey, ServicePoint> servicePoints
private ICertificatePolicy policy
private int defaultConnectionLimit
private int maxServicePointIdleTime
private int maxServicePoints
private int dnsRefreshTimeout
private bool _checkCRL
private SecurityProtocolType _securityProtocol
private bool expectContinue
private bool useNagle
private ServerCertValidationCallback server_cert_cb
private bool tcp_keepalive
private int tcp_keepalive_time
private int tcp_keepalive_interval
public int DefaultNonPersistentConnectionLimit
public int DefaultPersistentConnectionLimit
private string configKey
private ConnectionManagementData manager
public ICertificatePolicy CertificatePolicy
public bool CheckCertificateRevocationList
public int DefaultConnectionLimit
public int DnsRefreshTimeout
public bool EnableDnsRoundRobin
public int MaxServicePointIdleTime
public int MaxServicePoints
public bool ReusePort
public SecurityProtocolType SecurityProtocol
internal ServerCertValidationCallback ServerCertValidationCallback
public RemoteCertificateValidationCallback ServerCertificateValidationCallback
public EncryptionPolicy EncryptionPolicy
public bool Expect100Continue
public bool UseNagleAlgorithm
internal bool DisableStrongCrypto
internal bool DisableSendAuxRecord
public ICertificatePolicy get_CertificatePolicy()
public void set_CertificatePolicy(ICertificatePolicy value)
internal ICertificatePolicy GetLegacyCertificatePolicy()
public bool get_CheckCertificateRevocationList()
public void set_CheckCertificateRevocationList(bool value)
public int get_DefaultConnectionLimit()
public void set_DefaultConnectionLimit(int value)
private Exception GetMustImplement()
public int get_DnsRefreshTimeout()
public void set_DnsRefreshTimeout(int value)
public bool get_EnableDnsRoundRobin()
public void set_EnableDnsRoundRobin(bool value)
public int get_MaxServicePointIdleTime()
public void set_MaxServicePointIdleTime(int value)
public int get_MaxServicePoints()
public void set_MaxServicePoints(int value)
public bool get_ReusePort()
public void set_ReusePort(bool value)
public SecurityProtocolType get_SecurityProtocol()
public void set_SecurityProtocol(SecurityProtocolType value)
internal ServerCertValidationCallback get_ServerCertValidationCallback()
public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback()
public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value)
public EncryptionPolicy get_EncryptionPolicy()
public bool get_Expect100Continue()
public void set_Expect100Continue(bool value)
public bool get_UseNagleAlgorithm()
public void set_UseNagleAlgorithm(bool value)
internal bool get_DisableStrongCrypto()
internal bool get_DisableSendAuxRecord()
public void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval)
public ServicePoint FindServicePoint(Uri address)
public ServicePoint FindServicePoint(string uriString, IWebProxy proxy)
public ServicePoint FindServicePoint(Uri address, IWebProxy proxy)
internal void CloseConnectionGroup(string connectionGroupName)
internal void RemoveServicePoint(ServicePoint sp)
}
internal System.Net.ServicePointScheduler : object {
private ServicePoint <ServicePoint>k__BackingField
private int running
private int maxIdleTime
private AsyncManualResetEvent schedulerEvent
private ConnectionGroup defaultGroup
private Dictionary`2<string, ConnectionGroup> groups
private LinkedList`1<ValueTuple`2<ConnectionGroup, WebOperation>> operations
private LinkedList`1<ValueTuple`3<ConnectionGroup, WebConnection, Task>> idleConnections
private int currentConnections
private int connectionLimit
private DateTime idleSince
private int nextId
public int ID
private string <ME>k__BackingField
private ServicePoint ServicePoint
public int MaxIdleTime
public int ConnectionLimit
public int CurrentConnections
public DateTime IdleSince
internal string ME
private ServicePoint get_ServicePoint()
private void set_ServicePoint(ServicePoint value)
public int get_MaxIdleTime()
public void set_MaxIdleTime(int value)
public int get_ConnectionLimit()
public void set_ConnectionLimit(int value)
public void .ctor(ServicePoint servicePoint, int connectionLimit, int maxIdleTime)
private void Debug(string message)
public int get_CurrentConnections()
public DateTime get_IdleSince()
internal string get_ME()
public void Run()
private Task RunScheduler()
private void Cleanup()
private void RunSchedulerIteration()
private bool OperationCompleted(ConnectionGroup group, WebOperation operation)
private void CloseIdleConnection(ConnectionGroup group, WebConnection connection)
private bool SchedulerIteration(ConnectionGroup group)
private void RemoveOperation(WebOperation operation)
private void RemoveIdleConnection(WebConnection connection)
private void FinalCleanup()
public void SendRequest(WebOperation operation, string groupName)
public bool CloseConnectionGroup(string groupName)
private ConnectionGroup GetConnectionGroup(string name)
private void OnConnectionCreated(WebConnection connection)
private void OnConnectionClosed(WebConnection connection)
public Task`1<bool> WaitAsync(Task workerTask, int millisecondTimeout)
private Task <Run>b__31_0()
}
public System.Net.SocketAddress : object {
internal int IPv6AddressSize
internal int IPv4AddressSize
internal int m_Size
internal Byte[] m_Buffer
private int WriteableOffset
private int MaxSize
private bool m_changed
private int m_hash
public AddressFamily Family
public int Size
public byte Item
public AddressFamily get_Family()
public int get_Size()
public byte get_Item(int offset)
public void set_Item(int offset, byte value)
public void .ctor(AddressFamily family)
public void .ctor(AddressFamily family, int size)
internal void .ctor(IPAddress ipAddress)
internal void .ctor(IPAddress ipaddress, int port)
internal IPAddress GetIPAddress()
internal IPEndPoint GetIPEndPoint()
internal void CopyAddressSizeIntoBuffer()
internal int GetAddressSizeOffset()
internal void SetSize(IntPtr ptr)
public bool Equals(object comparand)
public int GetHashCode()
public string ToString()
}
public System.Net.SocketPermission : CodeAccessPermission {
private ArrayList m_acceptList
private ArrayList m_connectList
private bool m_noRestriction
public int AllPorts
public IEnumerator AcceptList
public IEnumerator ConnectList
public void .ctor(PermissionState state)
public void .ctor(NetworkAccess access, TransportType transport, string hostName, int portNumber)
public IEnumerator get_AcceptList()
public IEnumerator get_ConnectList()
public void AddPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber)
public IPermission Copy()
public IPermission Intersect(IPermission target)
private bool IntersectEmpty(SocketPermission permission)
private void Intersect(ArrayList list1, ArrayList list2, ArrayList result)
public bool IsSubsetOf(IPermission target)
private bool IsSubsetOf(ArrayList list1, ArrayList list2)
public bool IsUnrestricted()
public SecurityElement ToXml()
private void ToXml(SecurityElement root, string childName, IEnumerator enumerator)
public void FromXml(SecurityElement securityElement)
private void FromXml(ArrayList endpoints, NetworkAccess access)
public IPermission Union(IPermission target)
}
public System.Net.SocketPermissionAttribute : CodeAccessSecurityAttribute {
private string m_access
private string m_host
private string m_port
private string m_transport
public string Access
public string Host
public string Port
public string Transport
public void .ctor(SecurityAction action)
public string get_Access()
public void set_Access(string value)
public string get_Host()
public void set_Host(string value)
public string get_Port()
public void set_Port(string value)
public string get_Transport()
public void set_Transport(string value)
public IPermission CreatePermission()
internal void AlreadySet(string property)
}
public System.Net.Sockets.AddressFamily : Enum {
public int value__
public AddressFamily Unknown
public AddressFamily Unspecified
public AddressFamily Unix
public AddressFamily InterNetwork
public AddressFamily ImpLink
public AddressFamily Pup
public AddressFamily Chaos
public AddressFamily NS
public AddressFamily Ipx
public AddressFamily Iso
public AddressFamily Osi
public AddressFamily Ecma
public AddressFamily DataKit
public AddressFamily Ccitt
public AddressFamily Sna
public AddressFamily DecNet
public AddressFamily DataLink
public AddressFamily Lat
public AddressFamily HyperChannel
public AddressFamily AppleTalk
public AddressFamily NetBios
public AddressFamily VoiceView
public AddressFamily FireFox
public AddressFamily Banyan
public AddressFamily Atm
public AddressFamily InterNetworkV6
public AddressFamily Cluster
public AddressFamily Ieee12844
public AddressFamily Irda
public AddressFamily NetworkDesigners
public AddressFamily Max
}
internal System.Net.Sockets.DualSocketMultipleConnectAsync : MultipleConnectAsync {
private Socket _socket4
private Socket _socket6
public void .ctor(SocketType socketType, ProtocolType protocolType)
protected IPAddress GetNextAddress(Socket& attemptSocket)
protected void OnSucceed()
protected void OnFail(bool abortive)
}
public System.Net.Sockets.IOControlCode : Enum {
public long value__
public IOControlCode AsyncIO
public IOControlCode NonBlockingIO
public IOControlCode DataToRead
public IOControlCode OobDataRead
public IOControlCode AssociateHandle
public IOControlCode EnableCircularQueuing
public IOControlCode Flush
public IOControlCode GetBroadcastAddress
public IOControlCode GetExtensionFunctionPointer
public IOControlCode GetQos
public IOControlCode GetGroupQos
public IOControlCode MultipointLoopback
public IOControlCode MulticastScope
public IOControlCode SetQos
public IOControlCode SetGroupQos
public IOControlCode TranslateHandle
public IOControlCode RoutingInterfaceQuery
public IOControlCode RoutingInterfaceChange
public IOControlCode AddressListQuery
public IOControlCode AddressListChange
public IOControlCode QueryTargetPnpHandle
public IOControlCode NamespaceChange
public IOControlCode AddressListSort
public IOControlCode ReceiveAll
public IOControlCode ReceiveAllMulticast
public IOControlCode ReceiveAllIgmpMulticast
public IOControlCode KeepAliveValues
public IOControlCode AbsorbRouterAlert
public IOControlCode UnicastInterface
public IOControlCode LimitBroadcasts
public IOControlCode BindToInterface
public IOControlCode MulticastInterface
public IOControlCode AddMulticastGroupOnInterface
public IOControlCode DeleteMulticastGroupFromInterface
}
public System.Net.Sockets.IPPacketInformation : ValueType {
private IPAddress address
private int networkInterface
public IPAddress Address
public int Interface
internal void .ctor(IPAddress address, int networkInterface)
public IPAddress get_Address()
public int get_Interface()
public bool op_Equality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2)
public bool op_Inequality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2)
public bool Equals(object comparand)
public int GetHashCode()
}
public System.Net.Sockets.IPProtectionLevel : Enum {
public int value__
public IPProtectionLevel Unspecified
public IPProtectionLevel Unrestricted
public IPProtectionLevel EdgeRestricted
public IPProtectionLevel Restricted
}
public System.Net.Sockets.IPv6MulticastOption : object {
private IPAddress m_Group
private long m_Interface
public IPAddress Group
public long InterfaceIndex
public void .ctor(IPAddress group, long ifindex)
public void .ctor(IPAddress group)
public IPAddress get_Group()
public void set_Group(IPAddress value)
public long get_InterfaceIndex()
public void set_InterfaceIndex(long value)
}
public System.Net.Sockets.LingerOption : object {
private bool enabled
private int lingerTime
public bool Enabled
public int LingerTime
public void .ctor(bool enable, int seconds)
public bool get_Enabled()
public void set_Enabled(bool value)
public int get_LingerTime()
public void set_LingerTime(int value)
}
public System.Net.Sockets.MulticastOption : object {
private IPAddress group
private IPAddress localAddress
private int ifIndex
public IPAddress Group
public IPAddress LocalAddress
public int InterfaceIndex
public void .ctor(IPAddress group, IPAddress mcint)
public void .ctor(IPAddress group, int interfaceIndex)
public void .ctor(IPAddress group)
public IPAddress get_Group()
public void set_Group(IPAddress value)
public IPAddress get_LocalAddress()
public void set_LocalAddress(IPAddress value)
public int get_InterfaceIndex()
public void set_InterfaceIndex(int value)
}
internal System.Net.Sockets.MultipleConnectAsync : object {
protected SocketAsyncEventArgs _userArgs
protected SocketAsyncEventArgs _internalArgs
protected DnsEndPoint _endPoint
protected IPAddress[] _addressList
protected int _nextAddress
private State _state
private object _lockObject
public bool StartConnectAsync(SocketAsyncEventArgs args, DnsEndPoint endPoint)
private void DnsCallback(IAsyncResult result)
private bool DoDnsCallback(IAsyncResult result, bool sync)
private void InternalConnectCallback(object sender, SocketAsyncEventArgs args)
private Exception AttemptConnection()
private Exception AttemptConnection(Socket attemptSocket, SocketAsyncEventArgs args)
protected void OnSucceed()
private void Succeed()
protected void OnFail(bool abortive)
private bool Fail(bool sync, Exception e)
private void SyncFail(Exception e)
private void AsyncFail(Exception e)
public void Cancel()
private void CallAsyncFail(object ignored)
protected IPAddress GetNextAddress(Socket& attemptSocket)
private void <Cancel>b__20_0(object s)
}
public System.Net.Sockets.NetworkStream : Stream {
private Socket _streamSocket
private bool _ownsSocket
private bool _readable
private bool _writeable
private int _closeTimeout
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cleanedUp
private int _currentReadTimeout
private int _currentWriteTimeout
protected Socket Socket
protected bool Readable
protected bool Writeable
public bool CanRead
public bool CanSeek
public bool CanWrite
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public bool DataAvailable
public long Length
public long Position
internal Socket InternalSocket
public void .ctor(Socket socket)
public void .ctor(Socket socket, bool ownsSocket)
public void .ctor(Socket socket, FileAccess access)
public void .ctor(Socket socket, FileAccess access, bool ownsSocket)
protected Socket get_Socket()
protected bool get_Readable()
protected void set_Readable(bool value)
protected bool get_Writeable()
protected void set_Writeable(bool value)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public bool get_DataAvailable()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public long Seek(long offset, SeekOrigin origin)
public int Read(Byte[] buffer, int offset, int size)
public int Read(Span`1<byte> destination)
public int ReadByte()
public void Write(Byte[] buffer, int offset, int size)
public void Write(ReadOnlySpan`1<byte> source)
public void WriteByte(byte value)
public void Close(int timeout)
protected void Dispose(bool disposing)
protected void Finalize()
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
public ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken)
public Task WriteAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
public ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public void SetLength(long value)
internal void SetSocketTimeoutOption(SocketShutdown mode, int timeout, bool silent)
internal Socket get_InternalSocket()
}
public System.Net.Sockets.ProtocolFamily : Enum {
public int value__
public ProtocolFamily Unknown
public ProtocolFamily Unspecified
public ProtocolFamily Unix
public ProtocolFamily InterNetwork
public ProtocolFamily ImpLink
public ProtocolFamily Pup
public ProtocolFamily Chaos
public ProtocolFamily NS
public ProtocolFamily Ipx
public ProtocolFamily Iso
public ProtocolFamily Osi
public ProtocolFamily Ecma
public ProtocolFamily DataKit
public ProtocolFamily Ccitt
public ProtocolFamily Sna
public ProtocolFamily DecNet
public ProtocolFamily DataLink
public ProtocolFamily Lat
public ProtocolFamily HyperChannel
public ProtocolFamily AppleTalk
public ProtocolFamily NetBios
public ProtocolFamily VoiceView
public ProtocolFamily FireFox
public ProtocolFamily Banyan
public ProtocolFamily Atm
public ProtocolFamily InterNetworkV6
public ProtocolFamily Cluster
public ProtocolFamily Ieee12844
public ProtocolFamily Irda
public ProtocolFamily NetworkDesigners
public ProtocolFamily Max
}
public System.Net.Sockets.ProtocolType : Enum {
public int value__
public ProtocolType IP
public ProtocolType IPv6HopByHopOptions
public ProtocolType Icmp
public ProtocolType Igmp
public ProtocolType Ggp
public ProtocolType IPv4
public ProtocolType Tcp
public ProtocolType Pup
public ProtocolType Udp
public ProtocolType Idp
public ProtocolType IPv6
public ProtocolType IPv6RoutingHeader
public ProtocolType IPv6FragmentHeader
public ProtocolType IPSecEncapsulatingSecurityPayload
public ProtocolType IPSecAuthenticationHeader
public ProtocolType IcmpV6
public ProtocolType IPv6NoNextHeader
public ProtocolType IPv6DestinationOptions
public ProtocolType ND
public ProtocolType Raw
public ProtocolType Unspecified
public ProtocolType Ipx
public ProtocolType Spx
public ProtocolType SpxII
public ProtocolType Unknown
}
internal System.Net.Sockets.SafeSocketHandle : SafeHandleZeroOrMinusOneIsInvalid {
private List`1<Thread> blocking_threads
private Dictionary`2<Thread, StackTrace> threads_stacktraces
private bool in_cleanup
private int SOCKET_CLOSED
private int ABORT_RETRIES
private bool THROW_ON_ABORT_RETRIES
public void .ctor(IntPtr preexistingHandle, bool ownsHandle)
protected bool ReleaseHandle()
public void RegisterForBlockingSyscall()
public void UnRegisterForBlockingSyscall()
}
public System.Net.Sockets.SelectMode : Enum {
public int value__
public SelectMode SelectRead
public SelectMode SelectWrite
public SelectMode SelectError
}
public System.Net.Sockets.SendPacketsElement : object {
internal string m_FilePath
internal Byte[] m_Buffer
internal int m_Offset
internal int m_Count
private bool m_endOfPacket
public string FilePath
public Byte[] Buffer
public int Count
public int Offset
public bool EndOfPacket
public void .ctor(string filepath)
public void .ctor(string filepath, int offset, int count)
public void .ctor(string filepath, int offset, int count, bool endOfPacket)
public void .ctor(Byte[] buffer)
public void .ctor(Byte[] buffer, int offset, int count)
public void .ctor(Byte[] buffer, int offset, int count, bool endOfPacket)
private void Initialize(string filePath, Byte[] buffer, int offset, int count, bool endOfPacket)
public string get_FilePath()
public Byte[] get_Buffer()
public int get_Count()
public int get_Offset()
public bool get_EndOfPacket()
}
internal System.Net.Sockets.SingleSocketMultipleConnectAsync : MultipleConnectAsync {
private Socket _socket
private bool _userSocket
public void .ctor(Socket socket, bool userSocket)
protected IPAddress GetNextAddress(Socket& attemptSocket)
protected void OnFail(bool abortive)
protected void OnSucceed()
}
public System.Net.Sockets.Socket : object {
private EventHandler`1<SocketAsyncEventArgs> AcceptCompletedHandler
private EventHandler`1<SocketAsyncEventArgs> ReceiveCompletedHandler
private EventHandler`1<SocketAsyncEventArgs> SendCompletedHandler
private TaskSocketAsyncEventArgs`1<Socket> s_rentedSocketSentinel
private Int32TaskSocketAsyncEventArgs s_rentedInt32Sentinel
private Task`1<int> s_zeroTask
private CachedEventArgs _cachedTaskEventArgs
private object s_InternalSyncObject
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_SupportsIPv4
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_SupportsIPv6
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_OSSupportsIPv6
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_Initialized
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_LoggingEnabled
internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_PerfCountersEnabled
internal int DefaultCloseTimeout
private int SOCKET_CLOSED_CODE
private string TIMEOUT_EXCEPTION_MSG
private bool is_closed
private bool is_listening
private bool useOverlappedIO
private int linger_timeout
private AddressFamily addressFamily
private SocketType socketType
private ProtocolType protocolType
internal SafeSocketHandle m_Handle
internal EndPoint seed_endpoint
internal SemaphoreSlim ReadSem
internal SemaphoreSlim WriteSem
internal bool is_blocking
internal bool is_bound
internal bool is_connected
private int m_IntCleanedUp
internal bool connect_in_progress
internal int ID
private AsyncCallback AcceptAsyncCallback
private IOAsyncCallback BeginAcceptCallback
private IOAsyncCallback BeginAcceptReceiveCallback
private AsyncCallback ConnectAsyncCallback
private IOAsyncCallback BeginConnectCallback
private AsyncCallback DisconnectAsyncCallback
private IOAsyncCallback BeginDisconnectCallback
private AsyncCallback ReceiveAsyncCallback
private IOAsyncCallback BeginReceiveCallback
private IOAsyncCallback BeginReceiveGenericCallback
private AsyncCallback ReceiveFromAsyncCallback
private IOAsyncCallback BeginReceiveFromCallback
private AsyncCallback SendAsyncCallback
private IOAsyncCallback BeginSendGenericCallback
private AsyncCallback SendToAsyncCallback
public bool SupportsIPv4
public bool OSSupportsIPv4
public bool SupportsIPv6
internal bool LegacySupportsIPv6
public bool OSSupportsIPv6
public IntPtr Handle
public bool UseOnlyOverlappedIO
public AddressFamily AddressFamily
public SocketType SocketType
public ProtocolType ProtocolType
public bool ExclusiveAddressUse
public int ReceiveBufferSize
public int SendBufferSize
public int ReceiveTimeout
public int SendTimeout
public LingerOption LingerState
public short Ttl
public bool DontFragment
public bool DualMode
private bool IsDualMode
private object InternalSyncObject
internal bool CleanedUp
public int Available
public bool EnableBroadcast
public bool IsBound
public bool MulticastLoopback
public EndPoint LocalEndPoint
public bool Blocking
public bool Connected
public bool NoDelay
public EndPoint RemoteEndPoint
internal SafeHandle SafeHandle
internal int FamilyHint
internal Task`1<Socket> AcceptAsync(Socket acceptSocket)
private Task`1<Socket> AcceptAsyncApm(Socket acceptSocket)
internal Task ConnectAsync(EndPoint remoteEP)
internal Task ConnectAsync(IPAddress address, int port)
internal Task ConnectAsync(IPAddress[] addresses, int port)
internal Task ConnectAsync(string host, int port)
internal Task`1<int> ReceiveAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, bool fromNetworkStream)
internal ValueTask`1<int> ReceiveAsync(Memory`1<byte> buffer, SocketFlags socketFlags, bool fromNetworkStream, CancellationToken cancellationToken)
private Task`1<int> ReceiveAsyncApm(Memory`1<byte> buffer, SocketFlags socketFlags)
internal Task`1<int> ReceiveAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
private Task`1<int> ReceiveAsyncApm(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
internal Task`1<SocketReceiveFromResult> ReceiveFromAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint)
internal Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint)
internal Task`1<int> SendAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags)
internal ValueTask`1<int> SendAsync(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken)
internal ValueTask SendAsyncForNetworkStream(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken)
private Task`1<int> SendAsyncApm(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags)
internal Task`1<int> SendAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
private Task`1<int> SendAsyncApm(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
internal Task`1<int> SendToAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP)
private void ValidateBuffer(ArraySegment`1<byte> buffer)
private void ValidateBuffersList(IList`1<ArraySegment`1<byte>> buffers)
private void ConfigureBufferList(Int32TaskSocketAsyncEventArgs saea, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
private Task`1<int> GetTaskForSendReceive(bool pending, Int32TaskSocketAsyncEventArgs saea, bool fromNetworkStream, bool isReceive)
private void CompleteAccept(Socket s, TaskSocketAsyncEventArgs`1<Socket> saea)
private void CompleteSendReceive(Socket s, Int32TaskSocketAsyncEventArgs saea, bool isReceive)
private Exception GetException(SocketError error, bool wrapExceptionsInIOExceptions)
private Int32TaskSocketAsyncEventArgs RentSocketAsyncEventArgs(bool isReceive)
private void ReturnSocketAsyncEventArgs(Int32TaskSocketAsyncEventArgs saea, bool isReceive)
private void ReturnSocketAsyncEventArgs(TaskSocketAsyncEventArgs`1<Socket> saea)
private void DisposeCachedTaskSocketAsyncEventArgs()
public void .ctor(SocketType socketType, ProtocolType protocolType)
public void .ctor(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)
public bool get_SupportsIPv4()
public bool get_OSSupportsIPv4()
public bool get_SupportsIPv6()
internal bool get_LegacySupportsIPv6()
public bool get_OSSupportsIPv6()
public IntPtr get_Handle()
public bool get_UseOnlyOverlappedIO()
public void set_UseOnlyOverlappedIO(bool value)
public AddressFamily get_AddressFamily()
public SocketType get_SocketType()
public ProtocolType get_ProtocolType()
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public int get_SendBufferSize()
public void set_SendBufferSize(int value)
public int get_ReceiveTimeout()
public void set_ReceiveTimeout(int value)
public int get_SendTimeout()
public void set_SendTimeout(int value)
public LingerOption get_LingerState()
public void set_LingerState(LingerOption value)
public short get_Ttl()
public void set_Ttl(short value)
public bool get_DontFragment()
public void set_DontFragment(bool value)
public bool get_DualMode()
public void set_DualMode(bool value)
private bool get_IsDualMode()
internal bool CanTryAddressFamily(AddressFamily family)
public void Connect(IPAddress[] addresses, int port)
public int Send(Byte[] buffer, int size, SocketFlags socketFlags)
public int Send(Byte[] buffer, SocketFlags socketFlags)
public int Send(Byte[] buffer)
public int Send(IList`1<ArraySegment`1<byte>> buffers)
public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public void SendFile(string fileName)
public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags)
public int SendTo(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP)
public int SendTo(Byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP)
public int SendTo(Byte[] buffer, EndPoint remoteEP)
public int Receive(Byte[] buffer, int size, SocketFlags socketFlags)
public int Receive(Byte[] buffer, SocketFlags socketFlags)
public int Receive(Byte[] buffer)
public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags)
public int Receive(IList`1<ArraySegment`1<byte>> buffers)
public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public int ReceiveFrom(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint& remoteEP)
public int ReceiveFrom(Byte[] buffer, SocketFlags socketFlags, EndPoint& remoteEP)
public int ReceiveFrom(Byte[] buffer, EndPoint& remoteEP)
public int IOControl(IOControlCode ioControlCode, Byte[] optionInValue, Byte[] optionOutValue)
public void SetIPProtectionLevel(IPProtectionLevel level)
public IAsyncResult BeginSendFile(string fileName, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state)
public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state)
public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
public int EndSend(IAsyncResult asyncResult)
public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state)
public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
public int EndReceive(IAsyncResult asyncResult)
public IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, object state)
public Socket EndAccept(Byte[]& buffer, IAsyncResult asyncResult)
private object get_InternalSyncObject()
internal bool get_CleanedUp()
internal void InitializeSockets()
public void Dispose()
protected void Finalize()
public bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e)
internal void InternalShutdown(SocketShutdown how)
internal IAsyncResult UnsafeBeginConnect(EndPoint remoteEP, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state)
internal IAsyncResult BeginMultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
internal IAsyncResult UnsafeBeginMultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
internal int EndMultipleSend(IAsyncResult asyncResult)
internal void MultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags)
internal void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue, bool silent)
public void .ctor(SocketInformation socketInformation)
internal void .ctor(AddressFamily family, SocketType type, ProtocolType proto, SafeSocketHandle safe_handle)
private void SocketDefaults()
private IntPtr Socket_icall(AddressFamily family, SocketType type, ProtocolType proto, Int32& error)
public int get_Available()
private int Available_internal(SafeSocketHandle safeHandle, Int32& error)
private int Available_icall(IntPtr socket, Int32& error)
public bool get_EnableBroadcast()
public void set_EnableBroadcast(bool value)
public bool get_IsBound()
public bool get_MulticastLoopback()
public void set_MulticastLoopback(bool value)
public EndPoint get_LocalEndPoint()
private SocketAddress LocalEndPoint_internal(SafeSocketHandle safeHandle, int family, Int32& error)
private SocketAddress LocalEndPoint_icall(IntPtr socket, int family, Int32& error)
public bool get_Blocking()
public void set_Blocking(bool value)
private void Blocking_internal(SafeSocketHandle safeHandle, bool block, Int32& error)
internal void Blocking_icall(IntPtr socket, bool block, Int32& error)
public bool get_Connected()
internal void set_Connected(bool value)
public bool get_NoDelay()
public void set_NoDelay(bool value)
public EndPoint get_RemoteEndPoint()
private SocketAddress RemoteEndPoint_internal(SafeSocketHandle safeHandle, int family, Int32& error)
private SocketAddress RemoteEndPoint_icall(IntPtr socket, int family, Int32& error)
internal SafeHandle get_SafeHandle()
public void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds)
private void AddSockets(List`1<Socket> sockets, IList list, string name)
private void Select_icall(Socket[]& sockets, int microSeconds, Int32& error)
public bool Poll(int microSeconds, SelectMode mode)
private bool Poll_internal(SafeSocketHandle safeHandle, SelectMode mode, int timeout, Int32& error)
private bool Poll_icall(IntPtr socket, SelectMode mode, int timeout, Int32& error)
public Socket Accept()
internal void Accept(Socket acceptSocket)
public bool AcceptAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginAccept(AsyncCallback callback, object state)
public IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, object state)
public Socket EndAccept(IAsyncResult asyncResult)
public Socket EndAccept(Byte[]& buffer, Int32& bytesTransferred, IAsyncResult asyncResult)
private SafeSocketHandle Accept_internal(SafeSocketHandle safeHandle, Int32& error, bool blocking)
private IntPtr Accept_icall(IntPtr sock, Int32& error, bool blocking)
public void Bind(EndPoint localEP)
private void Bind_internal(SafeSocketHandle safeHandle, SocketAddress sa, Int32& error)
private void Bind_icall(IntPtr sock, SocketAddress sa, Int32& error)
public void Listen(int backlog)
private void Listen_internal(SafeSocketHandle safeHandle, int backlog, Int32& error)
private void Listen_icall(IntPtr sock, int backlog, Int32& error)
public void Connect(IPAddress address, int port)
public void Connect(string host, int port)
public void Connect(EndPoint remoteEP)
public bool ConnectAsync(SocketAsyncEventArgs e)
public void CancelConnectAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginConnect(string host, int port, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state)
private bool BeginMConnect(SocketAsyncResult sockares)
private bool BeginSConnect(SocketAsyncResult sockares)
public void EndConnect(IAsyncResult asyncResult)
private void Connect_internal(SafeSocketHandle safeHandle, SocketAddress sa, Int32& error, bool blocking)
private void Connect_icall(IntPtr sock, SocketAddress sa, Int32& error, bool blocking)
private bool GetCheckedIPs(SocketAsyncEventArgs e, IPAddress[]& addresses)
public void Disconnect(bool reuseSocket)
public bool DisconnectAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginDisconnect(bool reuseSocket, AsyncCallback callback, object state)
public void EndDisconnect(IAsyncResult asyncResult)
private void Disconnect_internal(SafeSocketHandle safeHandle, bool reuse, Int32& error)
private void Disconnect_icall(IntPtr sock, bool reuse, Int32& error)
public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode)
private int Receive(Memory`1<byte> buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode)
public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode)
public int Receive(Span`1<byte> buffer, SocketFlags socketFlags, SocketError& errorCode)
public int Send(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags, SocketError& errorCode)
public int Receive(Span`1<byte> buffer, SocketFlags socketFlags)
public int Receive(Span`1<byte> buffer)
public bool ReceiveAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
public int EndReceive(IAsyncResult asyncResult, SocketError& errorCode)
private int Receive_internal(SafeSocketHandle safeHandle, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking)
private int Receive_array_icall(IntPtr sock, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking)
private int Receive_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking)
private int Receive_icall(IntPtr sock, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking)
public int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP)
internal int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, SocketError& errorCode)
private int ReceiveFrom(Memory`1<byte> buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, SocketError& errorCode)
public bool ReceiveFromAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state)
public int EndReceiveFrom(IAsyncResult asyncResult, EndPoint& endPoint)
private int EndReceiveFrom_internal(SocketAsyncResult sockares, SocketAsyncEventArgs ares)
private int ReceiveFrom_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, SocketAddress& sockaddr, Int32& error, bool blocking)
private int ReceiveFrom_icall(IntPtr sock, Byte* buffer, int count, SocketFlags flags, SocketAddress& sockaddr, Int32& error, bool blocking)
public int ReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags& socketFlags, EndPoint& remoteEP, IPPacketInformation& ipPacketInformation)
public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state)
public int EndReceiveMessageFrom(IAsyncResult asyncResult, SocketFlags& socketFlags, EndPoint& endPoint, IPPacketInformation& ipPacketInformation)
public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode)
public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode)
public int Send(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags)
public int Send(ReadOnlySpan`1<byte> buffer)
public bool SendAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
private void BeginSendCallback(SocketAsyncResult sockares, int sent_so_far)
public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
public int EndSend(IAsyncResult asyncResult, SocketError& errorCode)
private int Send_internal(SafeSocketHandle safeHandle, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking)
private int Send_array_icall(IntPtr sock, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking)
private int Send_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking)
private int Send_icall(IntPtr sock, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking)
public int SendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP)
private int SendTo(Memory`1<byte> buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP)
public bool SendToAsync(SocketAsyncEventArgs e)
public IAsyncResult BeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP, AsyncCallback callback, object state)
private void BeginSendToCallback(SocketAsyncResult sockares, int sent_so_far)
public int EndSendTo(IAsyncResult asyncResult)
private int SendTo_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, SocketAddress sa, Int32& error, bool blocking)
private int SendTo_icall(IntPtr sock, Byte* buffer, int count, SocketFlags flags, SocketAddress sa, Int32& error, bool blocking)
public void SendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags)
public IAsyncResult BeginSendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags, AsyncCallback callback, object state)
public void EndSendFile(IAsyncResult asyncResult)
private bool SendFile_internal(SafeSocketHandle safeHandle, string filename, Byte[] pre_buffer, Byte[] post_buffer, TransmitFileOptions flags, Int32& error, bool blocking)
private bool SendFile_icall(IntPtr sock, string filename, Byte[] pre_buffer, Byte[] post_buffer, TransmitFileOptions flags, Int32& error, bool blocking)
public bool SendPacketsAsync(SocketAsyncEventArgs e)
private bool Duplicate_icall(IntPtr handle, int targetProcessId, IntPtr& duplicateHandle, MonoIOError& error)
public SocketInformation DuplicateAndClose(int targetProcessId)
public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue)
public Byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength)
public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName)
private void GetSocketOption_arr_internal(SafeSocketHandle safeHandle, SocketOptionLevel level, SocketOptionName name, Byte[]& byte_val, Int32& error)
private void GetSocketOption_arr_icall(IntPtr socket, SocketOptionLevel level, SocketOptionName name, Byte[]& byte_val, Int32& error)
private void GetSocketOption_obj_internal(SafeSocketHandle safeHandle, SocketOptionLevel level, SocketOptionName name, Object& obj_val, Int32& error)
private void GetSocketOption_obj_icall(IntPtr socket, SocketOptionLevel level, SocketOptionName name, Object& obj_val, Int32& error)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue)
private void SetSocketOption_internal(SafeSocketHandle safeHandle, SocketOptionLevel level, SocketOptionName name, object obj_val, Byte[] byte_val, int int_val, Int32& error)
private void SetSocketOption_icall(IntPtr socket, SocketOptionLevel level, SocketOptionName name, object obj_val, Byte[] byte_val, int int_val, Int32& error)
public int IOControl(int ioControlCode, Byte[] optionInValue, Byte[] optionOutValue)
private int IOControl_internal(SafeSocketHandle safeHandle, int ioctl_code, Byte[] input, Byte[] output, Int32& error)
private int IOControl_icall(IntPtr sock, int ioctl_code, Byte[] input, Byte[] output, Int32& error)
public void Close()
public void Close(int timeout)
internal void Close_icall(IntPtr socket, Int32& error)
public void Shutdown(SocketShutdown how)
private void Shutdown_internal(SafeSocketHandle safeHandle, SocketShutdown how, Int32& error)
internal void Shutdown_icall(IntPtr socket, SocketShutdown how, Int32& error)
protected void Dispose(bool disposing)
private void Linger(IntPtr handle)
private void ThrowIfDisposedAndClosed(Socket socket)
private void ThrowIfDisposedAndClosed()
private void ThrowIfBufferNull(Byte[] buffer)
private void ThrowIfBufferOutOfRange(Byte[] buffer, int offset, int size)
private void ThrowIfUdp()
private SocketAsyncResult ValidateEndIAsyncResult(IAsyncResult ares, string methodName, string argName)
private void QueueIOSelectorJob(SemaphoreSlim sem, IntPtr handle, IOSelectorJob job)
private void InitSocketAsyncEventArgs(SocketAsyncEventArgs e, AsyncCallback callback, object state, SocketOperation operation)
private SocketAsyncOperation SocketOperationToSocketAsyncOperation(SocketOperation op)
private IPEndPoint RemapIPEndPoint(IPEndPoint input)
internal void cancel_blocking_socket_operation(Thread thread)
internal bool SupportsPortReuse(ProtocolType proto)
internal int get_FamilyHint()
private bool IsProtocolSupported_internal(NetworkInterfaceComponent networkInterface)
private bool IsProtocolSupported(NetworkInterfaceComponent networkInterface)
internal void ReplaceHandleIfNecessaryAfterFailedConnect()
}
public System.Net.Sockets.SocketAsyncEventArgs : EventArgs {
private bool disposed
internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) in_progress
private EndPoint remote_ep
private Socket current_socket
internal SocketAsyncResult socket_async_result
private Exception <ConnectByNameError>k__BackingField
private Socket <AcceptSocket>k__BackingField
private int <BytesTransferred>k__BackingField
private bool <DisconnectReuseSocket>k__BackingField
private SocketAsyncOperation <LastOperation>k__BackingField
private IPPacketInformation <ReceiveMessageFromPacketInfo>k__BackingField
private SendPacketsElement[] <SendPacketsElements>k__BackingField
private TransmitFileOptions <SendPacketsFlags>k__BackingField
private int <SendPacketsSendSize>k__BackingField
private SocketError <SocketError>k__BackingField
private SocketFlags <SocketFlags>k__BackingField
private object <UserToken>k__BackingField
private EventHandler`1<SocketAsyncEventArgs> Completed
private Memory`1<byte> _buffer
private int _offset
private int _count
private bool _bufferIsExplicitArray
private IList`1<ArraySegment`1<byte>> _bufferList
private List`1<ArraySegment`1<byte>> _bufferListInternal
public Exception ConnectByNameError
public Socket AcceptSocket
public int BytesTransferred
public bool DisconnectReuseSocket
public SocketAsyncOperation LastOperation
public EndPoint RemoteEndPoint
public IPPacketInformation ReceiveMessageFromPacketInfo
public SendPacketsElement[] SendPacketsElements
public TransmitFileOptions SendPacketsFlags
public int SendPacketsSendSize
public SocketError SocketError
public SocketFlags SocketFlags
public object UserToken
public Socket ConnectSocket
internal Socket CurrentSocket
public Byte[] Buffer
public Memory`1<byte> MemoryBuffer
public int Offset
public int Count
public IList`1<ArraySegment`1<byte>> BufferList
internal bool HasMultipleBuffers
public SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol
public Exception get_ConnectByNameError()
private void set_ConnectByNameError(Exception value)
public Socket get_AcceptSocket()
public void set_AcceptSocket(Socket value)
public int get_BytesTransferred()
private void set_BytesTransferred(int value)
public bool get_DisconnectReuseSocket()
public void set_DisconnectReuseSocket(bool value)
public SocketAsyncOperation get_LastOperation()
private void set_LastOperation(SocketAsyncOperation value)
public EndPoint get_RemoteEndPoint()
public void set_RemoteEndPoint(EndPoint value)
public IPPacketInformation get_ReceiveMessageFromPacketInfo()
private void set_ReceiveMessageFromPacketInfo(IPPacketInformation value)
public SendPacketsElement[] get_SendPacketsElements()
public void set_SendPacketsElements(SendPacketsElement[] value)
public TransmitFileOptions get_SendPacketsFlags()
public void set_SendPacketsFlags(TransmitFileOptions value)
public int get_SendPacketsSendSize()
public void set_SendPacketsSendSize(int value)
public SocketError get_SocketError()
public void set_SocketError(SocketError value)
public SocketFlags get_SocketFlags()
public void set_SocketFlags(SocketFlags value)
public object get_UserToken()
public void set_UserToken(object value)
public Socket get_ConnectSocket()
public void add_Completed(EventHandler`1<SocketAsyncEventArgs> value)
public void remove_Completed(EventHandler`1<SocketAsyncEventArgs> value)
internal void .ctor(bool flowExecutionContext)
protected void Finalize()
private void Dispose(bool disposing)
public void Dispose()
internal void SetConnectByNameError(Exception error)
internal void SetBytesTransferred(int value)
internal Socket get_CurrentSocket()
internal void SetCurrentSocket(Socket socket)
internal void SetLastOperation(SocketAsyncOperation op)
internal void Complete_internal()
protected void OnCompleted(SocketAsyncEventArgs e)
internal void StartOperationCommon(Socket socket)
internal void StartOperationWrapperConnect(MultipleConnectAsync args)
internal void FinishConnectByNameSyncFailure(Exception exception, int bytesTransferred, SocketFlags flags)
internal void FinishOperationAsyncFailure(Exception exception, int bytesTransferred, SocketFlags flags)
internal void FinishWrapperConnectSuccess(Socket connectSocket, int bytesTransferred, SocketFlags flags)
internal void SetResults(SocketError socketError, int bytesTransferred, SocketFlags flags)
internal void SetResults(Exception exception, int bytesTransferred, SocketFlags flags)
public Byte[] get_Buffer()
public Memory`1<byte> get_MemoryBuffer()
public int get_Offset()
public int get_Count()
public IList`1<ArraySegment`1<byte>> get_BufferList()
public void set_BufferList(IList`1<ArraySegment`1<byte>> value)
public void SetBuffer(int offset, int count)
internal void CopyBufferFrom(SocketAsyncEventArgs source)
public void SetBuffer(Byte[] buffer, int offset, int count)
public void SetBuffer(Memory`1<byte> buffer)
internal bool get_HasMultipleBuffers()
public SocketClientAccessPolicyProtocol get_SocketClientAccessPolicyProtocol()
public void set_SocketClientAccessPolicyProtocol(SocketClientAccessPolicyProtocol value)
}
public System.Net.Sockets.SocketAsyncOperation : Enum {
public int value__
public SocketAsyncOperation None
public SocketAsyncOperation Accept
public SocketAsyncOperation Connect
public SocketAsyncOperation Disconnect
public SocketAsyncOperation Receive
public SocketAsyncOperation ReceiveFrom
public SocketAsyncOperation ReceiveMessageFrom
public SocketAsyncOperation Send
public SocketAsyncOperation SendPackets
public SocketAsyncOperation SendTo
}
internal System.Net.Sockets.SocketAsyncResult : IOAsyncResult {
public Socket socket
public SocketOperation operation
private Exception DelayedException
public EndPoint EndPoint
public Memory`1<byte> Buffer
public int Offset
public int Size
public SocketFlags SockFlags
public Socket AcceptSocket
public IPAddress[] Addresses
public int Port
public IList`1<ArraySegment`1<byte>> Buffers
public bool ReuseSocket
public int CurrentAddress
public Socket AcceptedSocket
public int Total
internal int error
public int EndCalled
public IntPtr Handle
public SocketError ErrorCode
public IntPtr get_Handle()
public void Init(Socket socket, AsyncCallback callback, object state, SocketOperation operation)
public void .ctor(Socket socket, AsyncCallback callback, object state, SocketOperation operation)
public SocketError get_ErrorCode()
public void CheckIfThrowDelayedException()
internal void CompleteDisposed()
public void Complete()
public void Complete(bool synch)
public void Complete(int total)
public void Complete(Exception e, bool synch)
public void Complete(Exception e)
public void Complete(Socket s)
public void Complete(Socket s, int total)
}
public System.Net.Sockets.SocketClientAccessPolicyProtocol : Enum {
public int value__
public SocketClientAccessPolicyProtocol Tcp
public SocketClientAccessPolicyProtocol Http
}
public System.Net.Sockets.SocketError : Enum {
public int value__
public SocketError Success
public SocketError SocketError
public SocketError Interrupted
public SocketError AccessDenied
public SocketError Fault
public SocketError InvalidArgument
public SocketError TooManyOpenSockets
public SocketError WouldBlock
public SocketError InProgress
public SocketError AlreadyInProgress
public SocketError NotSocket
public SocketError DestinationAddressRequired
public SocketError MessageSize
public SocketError ProtocolType
public SocketError ProtocolOption
public SocketError ProtocolNotSupported
public SocketError SocketNotSupported
public SocketError OperationNotSupported
public SocketError ProtocolFamilyNotSupported
public SocketError AddressFamilyNotSupported
public SocketError AddressAlreadyInUse
public SocketError AddressNotAvailable
public SocketError NetworkDown
public SocketError NetworkUnreachable
public SocketError NetworkReset
public SocketError ConnectionAborted
public SocketError ConnectionReset
public SocketError NoBufferSpaceAvailable
public SocketError IsConnected
public SocketError NotConnected
public SocketError Shutdown
public SocketError TimedOut
public SocketError ConnectionRefused
public SocketError HostDown
public SocketError HostUnreachable
public SocketError ProcessLimit
public SocketError SystemNotReady
public SocketError VersionNotSupported
public SocketError NotInitialized
public SocketError Disconnecting
public SocketError TypeNotFound
public SocketError HostNotFound
public SocketError TryAgain
public SocketError NoRecovery
public SocketError NoData
public SocketError IOPending
public SocketError OperationAborted
}
public System.Net.Sockets.SocketException : Win32Exception {
private EndPoint m_EndPoint
public int ErrorCode
public string Message
public SocketError SocketErrorCode
private int WSAGetLastError_icall()
internal void .ctor(int error, string message)
internal void .ctor(EndPoint endPoint)
public void .ctor(int errorCode)
internal void .ctor(int errorCode, EndPoint endPoint)
internal void .ctor(SocketError socketError)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public int get_ErrorCode()
public string get_Message()
public SocketError get_SocketErrorCode()
}
public System.Net.Sockets.SocketFlags : Enum {
public int value__
public SocketFlags None
public SocketFlags OutOfBand
public SocketFlags Peek
public SocketFlags DontRoute
public SocketFlags MaxIOVectorLength
public SocketFlags Truncated
public SocketFlags ControlDataTruncated
public SocketFlags Broadcast
public SocketFlags Multicast
public SocketFlags Partial
}
public System.Net.Sockets.SocketInformation : ValueType {
private Byte[] protocolInformation
private SocketInformationOptions options
private EndPoint remoteEndPoint
public Byte[] ProtocolInformation
public SocketInformationOptions Options
internal bool IsNonBlocking
internal bool IsConnected
internal bool IsListening
internal bool UseOnlyOverlappedIO
internal EndPoint RemoteEndPoint
public Byte[] get_ProtocolInformation()
public void set_ProtocolInformation(Byte[] value)
public SocketInformationOptions get_Options()
public void set_Options(SocketInformationOptions value)
internal bool get_IsNonBlocking()
internal void set_IsNonBlocking(bool value)
internal bool get_IsConnected()
internal void set_IsConnected(bool value)
internal bool get_IsListening()
internal void set_IsListening(bool value)
internal bool get_UseOnlyOverlappedIO()
internal void set_UseOnlyOverlappedIO(bool value)
internal EndPoint get_RemoteEndPoint()
internal void set_RemoteEndPoint(EndPoint value)
}
public System.Net.Sockets.SocketInformationOptions : Enum {
public int value__
public SocketInformationOptions NonBlocking
public SocketInformationOptions Connected
public SocketInformationOptions Listening
public SocketInformationOptions UseOnlyOverlappedIO
}
internal System.Net.Sockets.SocketOperation : Enum {
public int value__
public SocketOperation Accept
public SocketOperation Connect
public SocketOperation Receive
public SocketOperation ReceiveFrom
public SocketOperation Send
public SocketOperation SendTo
public SocketOperation RecvJustCallback
public SocketOperation SendJustCallback
public SocketOperation Disconnect
public SocketOperation AcceptReceive
public SocketOperation ReceiveGeneric
public SocketOperation SendGeneric
}
public System.Net.Sockets.SocketOptionLevel : Enum {
public int value__
public SocketOptionLevel Socket
public SocketOptionLevel IP
public SocketOptionLevel IPv6
public SocketOptionLevel Tcp
public SocketOptionLevel Udp
}
public System.Net.Sockets.SocketOptionName : Enum {
public int value__
public SocketOptionName Debug
public SocketOptionName AcceptConnection
public SocketOptionName ReuseAddress
public SocketOptionName KeepAlive
public SocketOptionName DontRoute
public SocketOptionName Broadcast
public SocketOptionName UseLoopback
public SocketOptionName Linger
public SocketOptionName OutOfBandInline
public SocketOptionName DontLinger
public SocketOptionName ExclusiveAddressUse
public SocketOptionName SendBuffer
public SocketOptionName ReceiveBuffer
public SocketOptionName SendLowWater
public SocketOptionName ReceiveLowWater
public SocketOptionName SendTimeout
public SocketOptionName ReceiveTimeout
public SocketOptionName Error
public SocketOptionName Type
public SocketOptionName ReuseUnicastPort
public SocketOptionName MaxConnections
public SocketOptionName IPOptions
public SocketOptionName HeaderIncluded
public SocketOptionName TypeOfService
public SocketOptionName IpTimeToLive
public SocketOptionName MulticastInterface
public SocketOptionName MulticastTimeToLive
public SocketOptionName MulticastLoopback
public SocketOptionName AddMembership
public SocketOptionName DropMembership
public SocketOptionName DontFragment
public SocketOptionName AddSourceMembership
public SocketOptionName DropSourceMembership
public SocketOptionName BlockSource
public SocketOptionName UnblockSource
public SocketOptionName PacketInformation
public SocketOptionName HopLimit
public SocketOptionName IPProtectionLevel
public SocketOptionName IPv6Only
public SocketOptionName NoDelay
public SocketOptionName BsdUrgent
public SocketOptionName Expedited
public SocketOptionName NoChecksum
public SocketOptionName ChecksumCoverage
public SocketOptionName UpdateAcceptContext
public SocketOptionName UpdateConnectContext
}
public System.Net.Sockets.SocketReceiveFromResult : ValueType {
public int ReceivedBytes
public EndPoint RemoteEndPoint
}
public System.Net.Sockets.SocketReceiveMessageFromResult : ValueType {
public int ReceivedBytes
public SocketFlags SocketFlags
public EndPoint RemoteEndPoint
public IPPacketInformation PacketInformation
}
public System.Net.Sockets.SocketShutdown : Enum {
public int value__
public SocketShutdown Receive
public SocketShutdown Send
public SocketShutdown Both
}
public System.Net.Sockets.SocketTaskExtensions : object {
public Task`1<Socket> AcceptAsync(Socket socket)
public Task`1<Socket> AcceptAsync(Socket socket, Socket acceptSocket)
public Task ConnectAsync(Socket socket, EndPoint remoteEP)
public Task ConnectAsync(Socket socket, IPAddress address, int port)
public Task ConnectAsync(Socket socket, IPAddress[] addresses, int port)
public Task ConnectAsync(Socket socket, string host, int port)
public Task`1<int> ReceiveAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags)
public Task`1<int> ReceiveAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public Task`1<SocketReceiveFromResult> ReceiveFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint)
public Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint)
public Task`1<int> SendAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags)
public Task`1<int> SendAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public Task`1<int> SendToAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP)
public ValueTask`1<int> SendAsync(Socket socket, ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken)
public ValueTask`1<int> ReceiveAsync(Socket socket, Memory`1<byte> memory, SocketFlags socketFlags, CancellationToken cancellationToken)
}
public System.Net.Sockets.SocketType : Enum {
public int value__
public SocketType Stream
public SocketType Dgram
public SocketType Raw
public SocketType Rdm
public SocketType Seqpacket
public SocketType Unknown
}
public System.Net.Sockets.TcpClient : object {
private Socket m_ClientSocket
private bool m_Active
private NetworkStream m_DataStream
private AddressFamily m_Family
private bool m_CleanedUp
public Socket Client
protected bool Active
public int Available
public bool Connected
public bool ExclusiveAddressUse
public int ReceiveBufferSize
public int SendBufferSize
public int ReceiveTimeout
public int SendTimeout
public LingerOption LingerState
public bool NoDelay
public void .ctor(IPEndPoint localEP)
public void .ctor(AddressFamily family)
public void .ctor(string hostname, int port)
internal void .ctor(Socket acceptedSocket)
public Socket get_Client()
public void set_Client(Socket value)
protected bool get_Active()
protected void set_Active(bool value)
public int get_Available()
public bool get_Connected()
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public void Connect(string hostname, int port)
public void Connect(IPAddress address, int port)
public void Connect(IPEndPoint remoteEP)
public void Connect(IPAddress[] ipAddresses, int port)
public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state)
public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state)
public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state)
public void EndConnect(IAsyncResult asyncResult)
public Task ConnectAsync(IPAddress address, int port)
public Task ConnectAsync(string host, int port)
public Task ConnectAsync(IPAddress[] addresses, int port)
public NetworkStream GetStream()
public void Close()
protected void Dispose(bool disposing)
public void Dispose()
protected void Finalize()
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public int get_SendBufferSize()
public void set_SendBufferSize(int value)
public int get_ReceiveTimeout()
public void set_ReceiveTimeout(int value)
public int get_SendTimeout()
public void set_SendTimeout(int value)
public LingerOption get_LingerState()
public void set_LingerState(LingerOption value)
public bool get_NoDelay()
public void set_NoDelay(bool value)
private void initialize()
private int numericOption(SocketOptionLevel optionLevel, SocketOptionName optionName)
}
public System.Net.Sockets.TcpListener : object {
private IPEndPoint m_ServerSocketEP
private Socket m_ServerSocket
private bool m_Active
private bool m_ExclusiveAddressUse
public Socket Server
protected bool Active
public EndPoint LocalEndpoint
public bool ExclusiveAddressUse
public void .ctor(IPEndPoint localEP)
public void .ctor(IPAddress localaddr, int port)
public void .ctor(int port)
public TcpListener Create(int port)
public Socket get_Server()
protected bool get_Active()
public EndPoint get_LocalEndpoint()
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public void AllowNatTraversal(bool allowed)
public void Start()
public void Start(int backlog)
public void Stop()
public bool Pending()
public Socket AcceptSocket()
public TcpClient AcceptTcpClient()
public IAsyncResult BeginAcceptSocket(AsyncCallback callback, object state)
public Socket EndAcceptSocket(IAsyncResult asyncResult)
public IAsyncResult BeginAcceptTcpClient(AsyncCallback callback, object state)
public TcpClient EndAcceptTcpClient(IAsyncResult asyncResult)
public Task`1<Socket> AcceptSocketAsync()
public Task`1<TcpClient> AcceptTcpClientAsync()
}
public System.Net.Sockets.TransmitFileOptions : Enum {
public int value__
public TransmitFileOptions UseDefaultWorkerThread
public TransmitFileOptions Disconnect
public TransmitFileOptions ReuseSocket
public TransmitFileOptions WriteBehind
public TransmitFileOptions UseSystemThread
public TransmitFileOptions UseKernelApc
}
public System.Net.Sockets.UdpClient : object {
private int MaxUDPSize
private Socket m_ClientSocket
private bool m_Active
private Byte[] m_Buffer
private AddressFamily m_Family
private bool m_CleanedUp
private bool m_IsBroadcast
public Socket Client
protected bool Active
public int Available
public short Ttl
public bool DontFragment
public bool MulticastLoopback
public bool EnableBroadcast
public bool ExclusiveAddressUse
public void .ctor(AddressFamily family)
public void .ctor(int port)
public void .ctor(int port, AddressFamily family)
public void .ctor(IPEndPoint localEP)
public void .ctor(string hostname, int port)
public Socket get_Client()
public void set_Client(Socket value)
protected bool get_Active()
protected void set_Active(bool value)
public int get_Available()
public short get_Ttl()
public void set_Ttl(short value)
public bool get_DontFragment()
public void set_DontFragment(bool value)
public bool get_MulticastLoopback()
public void set_MulticastLoopback(bool value)
public bool get_EnableBroadcast()
public void set_EnableBroadcast(bool value)
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public void AllowNatTraversal(bool allowed)
public void Close()
private void FreeResources()
public void Dispose()
protected void Dispose(bool disposing)
public void Connect(string hostname, int port)
public void Connect(IPAddress addr, int port)
public void Connect(IPEndPoint endPoint)
private void CheckForBroadcast(IPAddress ipAddress)
private bool IsBroadcast(IPAddress address)
public int Send(Byte[] dgram, int bytes, IPEndPoint endPoint)
public int Send(Byte[] dgram, int bytes, string hostname, int port)
public int Send(Byte[] dgram, int bytes)
public IAsyncResult BeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, object state)
public IAsyncResult BeginSend(Byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state)
public IAsyncResult BeginSend(Byte[] datagram, int bytes, AsyncCallback requestCallback, object state)
public int EndSend(IAsyncResult asyncResult)
public Byte[] Receive(IPEndPoint& remoteEP)
public IAsyncResult BeginReceive(AsyncCallback requestCallback, object state)
public Byte[] EndReceive(IAsyncResult asyncResult, IPEndPoint& remoteEP)
public void JoinMulticastGroup(IPAddress multicastAddr)
public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress)
public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr)
public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive)
public void DropMulticastGroup(IPAddress multicastAddr)
public void DropMulticastGroup(IPAddress multicastAddr, int ifindex)
public Task`1<int> SendAsync(Byte[] datagram, int bytes)
public Task`1<int> SendAsync(Byte[] datagram, int bytes, IPEndPoint endPoint)
public Task`1<int> SendAsync(Byte[] datagram, int bytes, string hostname, int port)
public Task`1<UdpReceiveResult> ReceiveAsync()
private void createClientSocket()
private IAsyncResult <ReceiveAsync>b__65_0(AsyncCallback callback, object state)
private UdpReceiveResult <ReceiveAsync>b__65_1(IAsyncResult ar)
}
public System.Net.Sockets.UdpReceiveResult : ValueType {
private Byte[] m_buffer
private IPEndPoint m_remoteEndPoint
public Byte[] Buffer
public IPEndPoint RemoteEndPoint
public void .ctor(Byte[] buffer, IPEndPoint remoteEndPoint)
public Byte[] get_Buffer()
public IPEndPoint get_RemoteEndPoint()
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(UdpReceiveResult other)
public bool op_Equality(UdpReceiveResult left, UdpReceiveResult right)
public bool op_Inequality(UdpReceiveResult left, UdpReceiveResult right)
}
internal System.Net.SplitWritesState : object {
private int c_SplitEncryptedBuffersSize
private BufferOffsetSize[] _UserBuffers
private int _Index
private int _LastBufferConsumed
private BufferOffsetSize[] _RealBuffers
internal bool IsDone
internal void .ctor(BufferOffsetSize[] buffers)
internal bool get_IsDone()
internal BufferOffsetSize[] GetNextBuffers()
}
internal System.Net.SSPIAuthType : object {
private SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages
public SecurityPackageInfoClass[] SecurityPackages
public SecurityPackageInfoClass[] get_SecurityPackages()
public void set_SecurityPackages(SecurityPackageInfoClass[] value)
public int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray)
public int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SEC_WINNT_AUTH_IDENTITY_W& authdata, SafeFreeCredentials& outCredential)
public int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential)
public int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential)
public int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential)
public int AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int QueryContextChannelBinding(SafeDeleteContext context, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& binding)
public int QueryContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Byte[] buffer, Type handleType, SafeHandle& refHandle)
public int SetContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Byte[] buffer)
public int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken)
public int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers)
private int GetSecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& safeHandle)
public int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers)
}
internal System.Net.SSPIInterface {
public SecurityPackageInfoClass[] SecurityPackages
public SecurityPackageInfoClass[] get_SecurityPackages()
public void set_SecurityPackages(SecurityPackageInfoClass[] value)
public int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray)
public int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SEC_WINNT_AUTH_IDENTITY_W& authdata, SafeFreeCredentials& outCredential)
public int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential)
public int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential)
public int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential)
public int AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle)
public int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer, Type handleType, SafeHandle& refHandle)
public int SetContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer)
public int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken)
public int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers)
public int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers)
}
internal System.Net.SSPISecureChannelType : object {
private SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages
public SecurityPackageInfoClass[] SecurityPackages
public SecurityPackageInfoClass[] get_SecurityPackages()
public void set_SecurityPackages(SecurityPackageInfoClass[] value)
public int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray)
public int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SEC_WINNT_AUTH_IDENTITY_W& authdata, SafeFreeCredentials& outCredential)
public int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential)
public int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential)
public int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential)
public int AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags)
public int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber)
public int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle)
public int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer, Type handleType, SafeHandle& refHandle)
public int SetContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer)
public int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken)
public int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers)
public int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers)
}
internal System.Net.SSPIWrapper : object {
internal SecurityPackageInfoClass[] EnumerateSecurityPackages(SSPIInterface secModule)
internal SecurityPackageInfoClass GetVerifyPackageInfo(SSPIInterface secModule, string packageName)
internal SecurityPackageInfoClass GetVerifyPackageInfo(SSPIInterface secModule, string packageName, bool throwIfMissing)
public SafeFreeCredentials AcquireDefaultCredential(SSPIInterface secModule, string package, CredentialUse intent)
public SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SEC_WINNT_AUTH_IDENTITY_W& authdata)
public SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata)
public SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SCHANNEL_CRED scc)
internal int InitializeSecurityContext(SSPIInterface secModule, SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness datarep, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags)
internal int InitializeSecurityContext(SSPIInterface secModule, SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness datarep, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags)
internal int AcceptSecurityContext(SSPIInterface secModule, SafeFreeCredentials& credential, SafeDeleteContext& context, ContextFlags inFlags, Endianness datarep, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags)
internal int AcceptSecurityContext(SSPIInterface secModule, SafeFreeCredentials credential, SafeDeleteContext& context, ContextFlags inFlags, Endianness datarep, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags)
internal int CompleteAuthToken(SSPIInterface secModule, SafeDeleteContext& context, SecurityBuffer[] inputBuffers)
internal int ApplyControlToken(SSPIInterface secModule, SafeDeleteContext& context, SecurityBuffer[] inputBuffers)
public int QuerySecurityContextToken(SSPIInterface secModule, SafeDeleteContext context, SecurityContextTokenHandle& token)
public int EncryptMessage(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber)
public int DecryptMessage(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber)
internal int MakeSignature(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber)
public int VerifySignature(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber)
private int EncryptDecryptHelper(OP op, SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber)
public SafeFreeContextBufferChannelBinding QueryContextChannelBinding(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute)
public object QueryContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute)
public object QueryContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, Int32& errorCode)
public string ErrorDescription(int errorCode)
}
internal System.Net.StaticProxy : ProxyChain {
private Uri m_Proxy
internal void .ctor(Uri destination, Uri proxy)
protected bool GetNextProxy(Uri& proxy)
}
internal System.Net.SystemNetworkCredential : NetworkCredential {
internal SystemNetworkCredential defaultCredential
}
internal System.Net.TcpValidationHelpers : object {
public bool ValidatePortNumber(int port)
}
internal System.Net.ThreadKinds : Enum {
public int value__
public ThreadKinds Unknown
public ThreadKinds User
public ThreadKinds System
public ThreadKinds Sync
public ThreadKinds Async
public ThreadKinds Timer
public ThreadKinds CompletionPort
public ThreadKinds Worker
public ThreadKinds Finalization
public ThreadKinds Other
public ThreadKinds OwnerMask
public ThreadKinds SyncMask
public ThreadKinds SourceMask
public ThreadKinds SafeSources
public ThreadKinds ThreadPool
}
internal System.Net.TimerThread : object {
private int c_ThreadIdleTimeoutMilliseconds
private int c_CacheScanPerIterations
private int c_TickCountResolution
private LinkedList`1<WeakReference> s_Queues
private LinkedList`1<WeakReference> s_NewQueues
private int s_ThreadState
private AutoResetEvent s_ThreadReadyEvent
private ManualResetEvent s_ThreadShutdownEvent
private WaitHandle[] s_ThreadEvents
private int s_CacheScanIteration
private Hashtable s_QueuesCache
internal Queue CreateQueue(int durationMilliseconds)
internal Queue GetOrCreateQueue(int durationMilliseconds)
private void Prod()
private void ThreadProc()
private void StopTimerThread()
private bool IsTickBetween(int start, int end, int comparand)
private void OnDomainUnload(object sender, EventArgs e)
}
internal System.Net.TlsStream : NetworkStream {
private SslStream _sslStream
private string _host
private X509CertificateCollection _clientCertificates
public void .ctor(NetworkStream stream, Socket socket, string host, X509CertificateCollection clientCertificates)
public void AuthenticateAsClient()
public IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object state)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult result)
public void Write(Byte[] buffer, int offset, int size)
public int Read(Byte[] buffer, int offset, int size)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public void Close()
}
internal System.Net.TrackingStringDictionary : StringDictionary {
private bool _isReadOnly
private bool _isChanged
internal bool IsChanged
public string Item
internal void .ctor(bool isReadOnly)
internal bool get_IsChanged()
internal void set_IsChanged(bool value)
public void Add(string key, string value)
public void Clear()
public void Remove(string key)
public string get_Item(string key)
public void set_Item(string key, string value)
}
internal System.Net.TrackingValidationObjectDictionary : StringDictionary {
private Dictionary`2<string, ValidateAndParseValue> _validators
private Dictionary`2<string, object> _internalObjects
private bool <IsChanged>k__BackingField
internal bool IsChanged
public string Item
internal void .ctor(Dictionary`2<string, ValidateAndParseValue> validators)
private void PersistValue(string key, string value, bool addValue)
internal bool get_IsChanged()
internal void set_IsChanged(bool value)
internal object InternalGet(string key)
internal void InternalSet(string key, object value)
public string get_Item(string key)
public void set_Item(string key, string value)
public void Add(string key, string value)
public void Clear()
public void Remove(string key)
}
public System.Net.TransportContext : object {
public ChannelBinding GetChannelBinding(ChannelBindingKind kind)
public IEnumerable`1<TokenBinding> GetTlsTokenBindings()
}
public System.Net.TransportType : Enum {
public int value__
public TransportType Udp
public TransportType Connectionless
public TransportType Tcp
public TransportType ConnectionOriented
public TransportType All
}
internal System.Net.TriState : Enum {
public int value__
public TriState Unspecified
public TriState False
public TriState True
}
internal System.Net.UnlockConnectionDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadDataCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] _result
public Byte[] Result
internal void .ctor(Byte[] result, Exception exception, bool cancelled, object userToken)
public Byte[] get_Result()
}
public System.Net.UploadDataCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadDataCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadDataCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadFileCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] _result
public Byte[] Result
internal void .ctor(Byte[] result, Exception exception, bool cancelled, object userToken)
public Byte[] get_Result()
}
public System.Net.UploadFileCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadFileCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadFileCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadProgressChangedEventArgs : ProgressChangedEventArgs {
private long <BytesReceived>k__BackingField
private long <TotalBytesToReceive>k__BackingField
private long <BytesSent>k__BackingField
private long <TotalBytesToSend>k__BackingField
public long BytesReceived
public long TotalBytesToReceive
public long BytesSent
public long TotalBytesToSend
internal void .ctor(int progressPercentage, object userToken, long bytesSent, long totalBytesToSend, long bytesReceived, long totalBytesToReceive)
public long get_BytesReceived()
public long get_TotalBytesToReceive()
public long get_BytesSent()
public long get_TotalBytesToSend()
}
public System.Net.UploadProgressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadProgressChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadProgressChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadStringCompletedEventArgs : AsyncCompletedEventArgs {
private string _result
public string Result
internal void .ctor(string result, Exception exception, bool cancelled, object userToken)
public string get_Result()
}
public System.Net.UploadStringCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadStringCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadStringCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadValuesCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] _result
public Byte[] Result
internal void .ctor(Byte[] result, Exception exception, bool cancelled, object userToken)
public Byte[] get_Result()
}
public System.Net.UploadValuesCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadValuesCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadValuesCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.UriScheme : object {
public string File
public string Ftp
public string Gopher
public string Http
public string Https
public string News
public string NetPipe
public string NetTcp
public string Nntp
public string Mailto
public string Ws
public string Wss
public string SchemeDelimiter
}
internal System.Net.ValidationHelper : object {
public String[] EmptyArray
internal Char[] InvalidMethodChars
internal Char[] InvalidParamChars
public String[] MakeEmptyArrayNull(String[] stringArray)
public string MakeStringNull(string stringValue)
public string ExceptionMessage(Exception exception)
public string ToString(object objectValue)
public string HashString(object objectValue)
public bool IsInvalidHttpString(string stringValue)
public bool IsBlankString(string stringValue)
public bool ValidateTcpPort(int port)
public bool ValidateRange(int actual, int fromAllowed, int toAllowed)
internal void ValidateSegment(ArraySegment`1<byte> segment)
}
public System.Net.WebClient : Component {
private int DefaultCopyBufferLength
private int DefaultDownloadBufferLength
private string DefaultUploadFileContentType
private string UploadFileContentType
private string UploadValuesContentType
private Uri _baseAddress
private ICredentials _credentials
private WebHeaderCollection _headers
private NameValueCollection _requestParameters
private WebResponse _webResponse
private WebRequest _webRequest
private Encoding _encoding
private string _method
private long _contentLength
private bool _initWebClientAsync
private bool _canceled
private ProgressData _progress
private IWebProxy _proxy
private bool _proxySet
private int _callNesting
private AsyncOperation _asyncOp
private SendOrPostCallback _downloadDataOperationCompleted
private SendOrPostCallback _openReadOperationCompleted
private SendOrPostCallback _openWriteOperationCompleted
private SendOrPostCallback _downloadStringOperationCompleted
private SendOrPostCallback _downloadFileOperationCompleted
private SendOrPostCallback _uploadStringOperationCompleted
private SendOrPostCallback _uploadDataOperationCompleted
private SendOrPostCallback _uploadFileOperationCompleted
private SendOrPostCallback _uploadValuesOperationCompleted
private SendOrPostCallback _reportDownloadProgressChanged
private SendOrPostCallback _reportUploadProgressChanged
private DownloadStringCompletedEventHandler DownloadStringCompleted
private DownloadDataCompletedEventHandler DownloadDataCompleted
private AsyncCompletedEventHandler DownloadFileCompleted
private UploadStringCompletedEventHandler UploadStringCompleted
private UploadDataCompletedEventHandler UploadDataCompleted
private UploadFileCompletedEventHandler UploadFileCompleted
private UploadValuesCompletedEventHandler UploadValuesCompleted
private OpenReadCompletedEventHandler OpenReadCompleted
private OpenWriteCompletedEventHandler OpenWriteCompleted
private DownloadProgressChangedEventHandler DownloadProgressChanged
private UploadProgressChangedEventHandler UploadProgressChanged
private RequestCachePolicy <CachePolicy>k__BackingField
private Char[] s_parseContentTypeSeparators
private Encoding[] s_knownEncodings
private bool <AllowReadStreamBuffering>k__BackingField
private bool <AllowWriteStreamBuffering>k__BackingField
public Encoding Encoding
public string BaseAddress
public ICredentials Credentials
public bool UseDefaultCredentials
public WebHeaderCollection Headers
public NameValueCollection QueryString
public WebHeaderCollection ResponseHeaders
public IWebProxy Proxy
public RequestCachePolicy CachePolicy
public bool IsBusy
public bool AllowReadStreamBuffering
public bool AllowWriteStreamBuffering
public void add_DownloadStringCompleted(DownloadStringCompletedEventHandler value)
public void remove_DownloadStringCompleted(DownloadStringCompletedEventHandler value)
public void add_DownloadDataCompleted(DownloadDataCompletedEventHandler value)
public void remove_DownloadDataCompleted(DownloadDataCompletedEventHandler value)
public void add_DownloadFileCompleted(AsyncCompletedEventHandler value)
public void remove_DownloadFileCompleted(AsyncCompletedEventHandler value)
public void add_UploadStringCompleted(UploadStringCompletedEventHandler value)
public void remove_UploadStringCompleted(UploadStringCompletedEventHandler value)
public void add_UploadDataCompleted(UploadDataCompletedEventHandler value)
public void remove_UploadDataCompleted(UploadDataCompletedEventHandler value)
public void add_UploadFileCompleted(UploadFileCompletedEventHandler value)
public void remove_UploadFileCompleted(UploadFileCompletedEventHandler value)
public void add_UploadValuesCompleted(UploadValuesCompletedEventHandler value)
public void remove_UploadValuesCompleted(UploadValuesCompletedEventHandler value)
public void add_OpenReadCompleted(OpenReadCompletedEventHandler value)
public void remove_OpenReadCompleted(OpenReadCompletedEventHandler value)
public void add_OpenWriteCompleted(OpenWriteCompletedEventHandler value)
public void remove_OpenWriteCompleted(OpenWriteCompletedEventHandler value)
public void add_DownloadProgressChanged(DownloadProgressChangedEventHandler value)
public void remove_DownloadProgressChanged(DownloadProgressChangedEventHandler value)
public void add_UploadProgressChanged(UploadProgressChangedEventHandler value)
public void remove_UploadProgressChanged(UploadProgressChangedEventHandler value)
protected void OnDownloadStringCompleted(DownloadStringCompletedEventArgs e)
protected void OnDownloadDataCompleted(DownloadDataCompletedEventArgs e)
protected void OnDownloadFileCompleted(AsyncCompletedEventArgs e)
protected void OnDownloadProgressChanged(DownloadProgressChangedEventArgs e)
protected void OnUploadStringCompleted(UploadStringCompletedEventArgs e)
protected void OnUploadDataCompleted(UploadDataCompletedEventArgs e)
protected void OnUploadFileCompleted(UploadFileCompletedEventArgs e)
protected void OnUploadValuesCompleted(UploadValuesCompletedEventArgs e)
protected void OnUploadProgressChanged(UploadProgressChangedEventArgs e)
protected void OnOpenReadCompleted(OpenReadCompletedEventArgs e)
protected void OnOpenWriteCompleted(OpenWriteCompletedEventArgs e)
private void StartOperation()
private AsyncOperation StartAsyncOperation(object userToken)
private void EndOperation()
public Encoding get_Encoding()
public void set_Encoding(Encoding value)
public string get_BaseAddress()
public void set_BaseAddress(string value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public NameValueCollection get_QueryString()
public void set_QueryString(NameValueCollection value)
public WebHeaderCollection get_ResponseHeaders()
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public RequestCachePolicy get_CachePolicy()
public void set_CachePolicy(RequestCachePolicy value)
public bool get_IsBusy()
protected WebRequest GetWebRequest(Uri address)
protected WebResponse GetWebResponse(WebRequest request)
protected WebResponse GetWebResponse(WebRequest request, IAsyncResult result)
private Task`1<WebResponse> GetWebResponseTaskAsync(WebRequest request)
public Byte[] DownloadData(string address)
public Byte[] DownloadData(Uri address)
private Byte[] DownloadDataInternal(Uri address, WebRequest& request)
public void DownloadFile(string address, string fileName)
public void DownloadFile(Uri address, string fileName)
public Stream OpenRead(string address)
public Stream OpenRead(Uri address)
public Stream OpenWrite(string address)
public Stream OpenWrite(Uri address)
public Stream OpenWrite(string address, string method)
public Stream OpenWrite(Uri address, string method)
public Byte[] UploadData(string address, Byte[] data)
public Byte[] UploadData(Uri address, Byte[] data)
public Byte[] UploadData(string address, string method, Byte[] data)
public Byte[] UploadData(Uri address, string method, Byte[] data)
private Byte[] UploadDataInternal(Uri address, string method, Byte[] data, WebRequest& request)
private void OpenFileInternal(bool needsHeaderAndBoundary, string fileName, FileStream& fs, Byte[]& buffer, Byte[]& formHeaderBytes, Byte[]& boundaryBytes)
public Byte[] UploadFile(string address, string fileName)
public Byte[] UploadFile(Uri address, string fileName)
public Byte[] UploadFile(string address, string method, string fileName)
public Byte[] UploadFile(Uri address, string method, string fileName)
private Byte[] GetValuesToUpload(NameValueCollection data)
public Byte[] UploadValues(string address, NameValueCollection data)
public Byte[] UploadValues(Uri address, NameValueCollection data)
public Byte[] UploadValues(string address, string method, NameValueCollection data)
public Byte[] UploadValues(Uri address, string method, NameValueCollection data)
public string UploadString(string address, string data)
public string UploadString(Uri address, string data)
public string UploadString(string address, string method, string data)
public string UploadString(Uri address, string method, string data)
public string DownloadString(string address)
public string DownloadString(Uri address)
private void AbortRequest(WebRequest request)
private void CopyHeadersTo(WebRequest request)
private Uri GetUri(string address)
private Uri GetUri(Uri address)
private Byte[] DownloadBits(WebRequest request, Stream writeStream)
private void DownloadBitsAsync(WebRequest request, Stream writeStream, AsyncOperation asyncOp, Action`3<Byte[], Exception, AsyncOperation> completionDelegate)
private Byte[] UploadBits(WebRequest request, Stream readStream, Byte[] buffer, int chunkSize, Byte[] header, Byte[] footer)
private void UploadBitsAsync(WebRequest request, Stream readStream, Byte[] buffer, int chunkSize, Byte[] header, Byte[] footer, AsyncOperation asyncOp, Action`3<Byte[], Exception, AsyncOperation> completionDelegate)
private bool ByteArrayHasPrefix(Byte[] prefix, Byte[] byteArray)
private string GetStringUsingEncoding(WebRequest request, Byte[] data)
private string MapToDefaultMethod(Uri address)
private string UrlEncode(string str)
private Byte[] UrlEncodeBytesToBytesInternal(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue)
private char IntToHex(int n)
private bool IsSafe(char ch)
private void InvokeOperationCompleted(AsyncOperation asyncOp, SendOrPostCallback callback, AsyncCompletedEventArgs eventArgs)
public void OpenReadAsync(Uri address)
public void OpenReadAsync(Uri address, object userToken)
public void OpenWriteAsync(Uri address)
public void OpenWriteAsync(Uri address, string method)
public void OpenWriteAsync(Uri address, string method, object userToken)
private void DownloadStringAsyncCallback(Byte[] returnBytes, Exception exception, object state)
public void DownloadStringAsync(Uri address)
public void DownloadStringAsync(Uri address, object userToken)
private void DownloadDataAsyncCallback(Byte[] returnBytes, Exception exception, object state)
public void DownloadDataAsync(Uri address)
public void DownloadDataAsync(Uri address, object userToken)
private void DownloadFileAsyncCallback(Byte[] returnBytes, Exception exception, object state)
public void DownloadFileAsync(Uri address, string fileName)
public void DownloadFileAsync(Uri address, string fileName, object userToken)
public void UploadStringAsync(Uri address, string data)
public void UploadStringAsync(Uri address, string method, string data)
public void UploadStringAsync(Uri address, string method, string data, object userToken)
public void UploadDataAsync(Uri address, Byte[] data)
public void UploadDataAsync(Uri address, string method, Byte[] data)
public void UploadDataAsync(Uri address, string method, Byte[] data, object userToken)
public void UploadFileAsync(Uri address, string fileName)
public void UploadFileAsync(Uri address, string method, string fileName)
public void UploadFileAsync(Uri address, string method, string fileName, object userToken)
public void UploadValuesAsync(Uri address, NameValueCollection data)
public void UploadValuesAsync(Uri address, string method, NameValueCollection data)
public void UploadValuesAsync(Uri address, string method, NameValueCollection data, object userToken)
private Exception GetExceptionToPropagate(Exception e)
public void CancelAsync()
public Task`1<string> DownloadStringTaskAsync(string address)
public Task`1<string> DownloadStringTaskAsync(Uri address)
public Task`1<Stream> OpenReadTaskAsync(string address)
public Task`1<Stream> OpenReadTaskAsync(Uri address)
public Task`1<Stream> OpenWriteTaskAsync(string address)
public Task`1<Stream> OpenWriteTaskAsync(Uri address)
public Task`1<Stream> OpenWriteTaskAsync(string address, string method)
public Task`1<Stream> OpenWriteTaskAsync(Uri address, string method)
public Task`1<string> UploadStringTaskAsync(string address, string data)
public Task`1<string> UploadStringTaskAsync(Uri address, string data)
public Task`1<string> UploadStringTaskAsync(string address, string method, string data)
public Task`1<string> UploadStringTaskAsync(Uri address, string method, string data)
public Task`1<Byte[]> DownloadDataTaskAsync(string address)
public Task`1<Byte[]> DownloadDataTaskAsync(Uri address)
public Task DownloadFileTaskAsync(string address, string fileName)
public Task DownloadFileTaskAsync(Uri address, string fileName)
public Task`1<Byte[]> UploadDataTaskAsync(string address, Byte[] data)
public Task`1<Byte[]> UploadDataTaskAsync(Uri address, Byte[] data)
public Task`1<Byte[]> UploadDataTaskAsync(string address, string method, Byte[] data)
public Task`1<Byte[]> UploadDataTaskAsync(Uri address, string method, Byte[] data)
public Task`1<Byte[]> UploadFileTaskAsync(string address, string fileName)
public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string fileName)
public Task`1<Byte[]> UploadFileTaskAsync(string address, string method, string fileName)
public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string method, string fileName)
public Task`1<Byte[]> UploadValuesTaskAsync(string address, NameValueCollection data)
public Task`1<Byte[]> UploadValuesTaskAsync(string address, string method, NameValueCollection data)
public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, NameValueCollection data)
public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, string method, NameValueCollection data)
private void HandleCompletion(TaskCompletionSource`1<T> tcs, TAsyncCompletedEventArgs e, Func`2<TAsyncCompletedEventArgs, T> getResult, TCompletionDelegate handler, Action`2<WebClient, TCompletionDelegate> unregisterHandler)
private void PostProgressChanged(AsyncOperation asyncOp, ProgressData progress)
private void ThrowIfNull(object argument, string parameterName)
public bool get_AllowReadStreamBuffering()
public void set_AllowReadStreamBuffering(bool value)
public bool get_AllowWriteStreamBuffering()
public void set_AllowWriteStreamBuffering(bool value)
public void add_WriteStreamClosed(WriteStreamClosedEventHandler value)
public void remove_WriteStreamClosed(WriteStreamClosedEventHandler value)
protected void OnWriteStreamClosed(WriteStreamClosedEventArgs e)
private void <StartAsyncOperation>b__78_0(object arg)
private void <StartAsyncOperation>b__78_1(object arg)
private void <StartAsyncOperation>b__78_2(object arg)
private void <StartAsyncOperation>b__78_3(object arg)
private void <StartAsyncOperation>b__78_4(object arg)
private void <StartAsyncOperation>b__78_5(object arg)
private void <StartAsyncOperation>b__78_6(object arg)
private void <StartAsyncOperation>b__78_7(object arg)
private void <StartAsyncOperation>b__78_8(object arg)
private void <StartAsyncOperation>b__78_9(object arg)
private void <StartAsyncOperation>b__78_10(object arg)
private void <UploadStringAsync>b__179_0(Byte[] bytesResult, Exception error, AsyncOperation uploadAsyncOp)
}
internal System.Net.WebCompletionSource`1 : object {
private TaskCompletionSource`1<Result<T>> completion
private Result<T> currentResult
internal Result<T> CurrentResult
internal Status<T> CurrentStatus
internal Task Task
public void .ctor(bool runAsync)
internal Result<T> get_CurrentResult()
internal Status<T> get_CurrentStatus()
internal Task get_Task()
public bool TrySetCompleted(T argument)
public bool TrySetCompleted()
public bool TrySetCanceled()
public bool TrySetCanceled(OperationCanceledException error)
public bool TrySetException(Exception error)
public void ThrowOnError()
public Task`1<T> WaitForCompletion()
}
internal System.Net.WebConnection : object {
private NetworkCredential ntlm_credentials
private bool ntlm_authenticated
private bool unsafe_sharing
private Stream networkStream
private Socket socket
private MonoTlsStream monoTlsStream
private WebConnectionTunnel tunnel
private int disposed
private ServicePoint <ServicePoint>k__BackingField
internal int ID
private DateTime idleSince
private WebOperation currentOperation
public ServicePoint ServicePoint
public bool Closed
public bool Busy
public DateTime IdleSince
internal bool NtlmAuthenticated
internal NetworkCredential NtlmCredential
internal bool UnsafeAuthenticatedConnectionSharing
public ServicePoint get_ServicePoint()
public void .ctor(ServicePoint sPoint)
internal void Debug(string message, Object[] args)
internal void Debug(string message)
private bool CanReuse()
private bool CheckReusable()
private Task Connect(WebOperation operation, CancellationToken cancellationToken)
private Task`1<bool> CreateStream(WebOperation operation, bool reused, CancellationToken cancellationToken)
internal Task`1<WebRequestStream> InitConnection(WebOperation operation, CancellationToken cancellationToken)
internal WebException GetException(WebExceptionStatus status, Exception error)
internal bool ReadLine(Byte[] buffer, Int32& start, int max, String& output)
internal bool CanReuseConnection(WebOperation operation)
private bool PrepareSharingNtlm(WebOperation operation)
private void Reset()
private void Close(bool reset)
private void CloseSocket()
public bool get_Closed()
public bool get_Busy()
public DateTime get_IdleSince()
public bool StartOperation(WebOperation operation, bool reused)
public bool Continue(WebOperation next)
private void Dispose(bool disposing)
public void Dispose()
private void ResetNtlm()
internal bool get_NtlmAuthenticated()
internal void set_NtlmAuthenticated(bool value)
internal NetworkCredential get_NtlmCredential()
internal void set_NtlmCredential(NetworkCredential value)
internal bool get_UnsafeAuthenticatedConnectionSharing()
internal void set_UnsafeAuthenticatedConnectionSharing(bool value)
}
internal System.Net.WebConnectionStream : Stream {
protected bool closed
private bool disposed
private object locker
private int read_timeout
private int write_timeout
internal bool IgnoreIOErrors
private HttpWebRequest <Request>k__BackingField
private WebConnection <Connection>k__BackingField
private WebOperation <Operation>k__BackingField
internal HttpWebRequest Request
internal WebConnection Connection
internal WebOperation Operation
internal ServicePoint ServicePoint
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public bool CanSeek
public long Length
public long Position
protected void .ctor(WebConnection cnc, WebOperation operation)
internal HttpWebRequest get_Request()
internal WebConnection get_Connection()
internal WebOperation get_Operation()
internal ServicePoint get_ServicePoint()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
protected Exception GetException(Exception e)
protected bool TryReadFromBufferedContent(Byte[] buffer, int offset, int count, Int32& result)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cb, object state)
public int EndRead(IAsyncResult r)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cb, object state)
public void EndWrite(IAsyncResult r)
public void Write(Byte[] buffer, int offset, int count)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
internal void InternalClose()
protected void Close_internal(Boolean& disposed)
public void Close()
public long Seek(long a, SeekOrigin b)
public void SetLength(long a)
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
}
internal System.Net.WebConnectionTunnel : object {
private HttpWebRequest <Request>k__BackingField
private Uri <ConnectUri>k__BackingField
private HttpWebRequest connectRequest
private NtlmAuthState ntlmAuthState
private bool <Success>k__BackingField
private bool <CloseConnection>k__BackingField
private int <StatusCode>k__BackingField
private string <StatusDescription>k__BackingField
private String[] <Challenge>k__BackingField
private WebHeaderCollection <Headers>k__BackingField
private Version <ProxyVersion>k__BackingField
private Byte[] <Data>k__BackingField
public HttpWebRequest Request
public Uri ConnectUri
public bool Success
public bool CloseConnection
public int StatusCode
public string StatusDescription
public String[] Challenge
public WebHeaderCollection Headers
public Version ProxyVersion
public Byte[] Data
public HttpWebRequest get_Request()
public Uri get_ConnectUri()
public void .ctor(HttpWebRequest request, Uri connectUri)
public bool get_Success()
private void set_Success(bool value)
public bool get_CloseConnection()
private void set_CloseConnection(bool value)
public int get_StatusCode()
private void set_StatusCode(int value)
public string get_StatusDescription()
private void set_StatusDescription(string value)
public String[] get_Challenge()
private void set_Challenge(String[] value)
public WebHeaderCollection get_Headers()
private void set_Headers(WebHeaderCollection value)
public Version get_ProxyVersion()
private void set_ProxyVersion(Version value)
public Byte[] get_Data()
private void set_Data(Byte[] value)
internal Task Initialize(Stream stream, CancellationToken cancellationToken)
private Task`1<ValueTuple`3<WebHeaderCollection, Byte[], int>> ReadHeaders(Stream stream, CancellationToken cancellationToken)
private void FlushContents(Stream stream, int contentLength)
}
public System.Net.WebException : InvalidOperationException {
private WebExceptionStatus m_Status
private WebResponse m_Response
private WebExceptionInternalStatus m_InternalStatus
public WebExceptionStatus Status
public WebResponse Response
internal WebExceptionInternalStatus InternalStatus
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, WebExceptionStatus status)
internal void .ctor(string message, WebExceptionStatus status, WebExceptionInternalStatus internalStatus, Exception innerException)
public void .ctor(string message, Exception innerException, WebExceptionStatus status, WebResponse response)
internal void .ctor(string message, string data, Exception innerException, WebExceptionStatus status, WebResponse response)
internal void .ctor(string message, Exception innerException, WebExceptionStatus status, WebResponse response, WebExceptionInternalStatus internalStatus)
internal void .ctor(string message, string data, Exception innerException, WebExceptionStatus status, WebResponse response, WebExceptionInternalStatus internalStatus)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public WebExceptionStatus get_Status()
public WebResponse get_Response()
internal WebExceptionInternalStatus get_InternalStatus()
}
internal System.Net.WebExceptionInternalStatus : Enum {
public int value__
public WebExceptionInternalStatus RequestFatal
public WebExceptionInternalStatus ServicePointFatal
public WebExceptionInternalStatus Recoverable
public WebExceptionInternalStatus Isolated
}
internal System.Net.WebExceptionMapping : object {
private String[] s_Mapping
internal string GetWebStatusString(WebExceptionStatus status)
}
public System.Net.WebExceptionStatus : Enum {
public int value__
public WebExceptionStatus Success
public WebExceptionStatus NameResolutionFailure
public WebExceptionStatus ConnectFailure
public WebExceptionStatus ReceiveFailure
public WebExceptionStatus SendFailure
public WebExceptionStatus PipelineFailure
public WebExceptionStatus RequestCanceled
public WebExceptionStatus ProtocolError
public WebExceptionStatus ConnectionClosed
public WebExceptionStatus TrustFailure
public WebExceptionStatus SecureChannelFailure
public WebExceptionStatus ServerProtocolViolation
public WebExceptionStatus KeepAliveFailure
public WebExceptionStatus Pending
public WebExceptionStatus Timeout
public WebExceptionStatus ProxyNameResolutionFailure
public WebExceptionStatus UnknownError
public WebExceptionStatus MessageLengthLimitExceeded
public WebExceptionStatus CacheEntryNotFound
public WebExceptionStatus RequestProhibitedByCachePolicy
public WebExceptionStatus RequestProhibitedByProxy
}
public System.Net.WebHeaderCollection : NameValueCollection {
private int ApproxAveHeaderLineSize
private int ApproxHighAvgNumHeaders
private HeaderInfoTable HInfo
private String[] m_CommonHeaders
private int m_NumCommonHeaders
private String[] s_CommonHeaderNames
private SByte[] s_CommonHeaderHints
private int c_AcceptRanges
private int c_ContentLength
private int c_CacheControl
private int c_ContentType
private int c_Date
private int c_Expires
private int c_ETag
private int c_LastModified
private int c_Location
private int c_ProxyAuthenticate
private int c_P3P
private int c_SetCookie2
private int c_SetCookie
private int c_Server
private int c_Via
private int c_WwwAuthenticate
private int c_XAspNetVersion
private int c_XPoweredBy
private NameValueCollection m_InnerCollection
private WebHeaderCollectionType m_Type
private Char[] HttpTrimCharacters
private RfcChar[] RfcCharMap
internal string ContentLength
internal string CacheControl
internal string ContentType
internal string Date
internal string Expires
internal string ETag
internal string LastModified
internal string Location
internal string ProxyAuthenticate
internal string SetCookie2
internal string SetCookie
internal string Server
internal string Via
private NameValueCollection InnerCollection
private bool AllowHttpRequestHeader
internal bool AllowHttpResponseHeader
public string Item
public string Item
public int Count
public KeysCollection Keys
public String[] AllKeys
internal string get_ContentLength()
internal string get_CacheControl()
internal string get_ContentType()
internal string get_Date()
internal string get_Expires()
internal string get_ETag()
internal string get_LastModified()
internal string get_Location()
internal string get_ProxyAuthenticate()
internal string get_SetCookie2()
internal string get_SetCookie()
internal string get_Server()
internal string get_Via()
private void NormalizeCommonHeaders()
private NameValueCollection get_InnerCollection()
internal bool AllowMultiValues(string name)
private bool get_AllowHttpRequestHeader()
internal bool get_AllowHttpResponseHeader()
public string get_Item(HttpRequestHeader header)
public void set_Item(HttpRequestHeader header, string value)
public string get_Item(HttpResponseHeader header)
public void set_Item(HttpResponseHeader header, string value)
public void Add(HttpRequestHeader header, string value)
public void Add(HttpResponseHeader header, string value)
public void Set(HttpRequestHeader header, string value)
public void Set(HttpResponseHeader header, string value)
internal void SetInternal(HttpResponseHeader header, string value)
public void Remove(HttpRequestHeader header)
public void Remove(HttpResponseHeader header)
protected void AddWithoutValidate(string headerName, string headerValue)
internal void SetAddVerified(string name, string value)
internal void AddInternal(string name, string value)
internal void ChangeInternal(string name, string value)
internal void RemoveInternal(string name)
internal void CheckUpdate(string name, string value)
private void AddInternalNotCommon(string name, string value)
internal string CheckBadChars(string name, bool isHeaderValue)
internal bool IsValidToken(string token)
internal bool ContainsNonAsciiChars(string token)
internal void ThrowOnRestrictedHeader(string headerName)
public void Add(string name, string value)
public void Add(string header)
public void Set(string name, string value)
internal void SetInternal(string name, string value)
public void Remove(string name)
public String[] GetValues(string header)
public string ToString()
internal string ToString(bool forTrace)
internal string GetAsString(NameValueCollection cc, bool winInetCompat, bool forTrace)
public Byte[] ToByteArray()
public bool IsRestricted(string headerName)
public bool IsRestricted(string headerName, bool response)
internal void .ctor(WebHeaderCollectionType type)
internal void .ctor(NameValueCollection cc)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void OnDeserialization(object sender)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal DataParseStatus ParseHeaders(Byte[] buffer, int size, Int32& unparsed, Int32& totalResponseHeadersLength, int maximumResponseHeadersLength, WebParseError& parseError)
internal DataParseStatus ParseHeadersStrict(Byte[] buffer, int size, Int32& unparsed, Int32& totalResponseHeadersLength, int maximumResponseHeadersLength, WebParseError& parseError)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public string Get(string name)
public IEnumerator GetEnumerator()
public int get_Count()
public KeysCollection get_Keys()
internal bool InternalHasKeys()
public string Get(int index)
public String[] GetValues(int index)
public string GetKey(int index)
public String[] get_AllKeys()
public void Clear()
}
internal System.Net.WebHeaderCollectionType : Enum {
public ushort value__
public WebHeaderCollectionType Unknown
public WebHeaderCollectionType WebRequest
public WebHeaderCollectionType WebResponse
public WebHeaderCollectionType HttpWebRequest
public WebHeaderCollectionType HttpWebResponse
public WebHeaderCollectionType HttpListenerRequest
public WebHeaderCollectionType HttpListenerResponse
public WebHeaderCollectionType FtpWebRequest
public WebHeaderCollectionType FtpWebResponse
public WebHeaderCollectionType FileWebRequest
public WebHeaderCollectionType FileWebResponse
}
internal System.Net.WebOperation : object {
private HttpWebRequest <Request>k__BackingField
private WebConnection <Connection>k__BackingField
private ServicePoint <ServicePoint>k__BackingField
private BufferOffsetSize <WriteBuffer>k__BackingField
private bool <IsNtlmChallenge>k__BackingField
internal int ID
private CancellationTokenSource cts
private WebCompletionSource`1<WebRequestStream> requestTask
private WebCompletionSource`1<WebRequestStream> requestWrittenTask
private WebCompletionSource`1<WebResponseStream> responseTask
private WebCompletionSource`1<ValueTuple`2<bool, WebOperation>> finishedTask
private WebRequestStream writeStream
private WebResponseStream responseStream
private ExceptionDispatchInfo disposedInfo
private ExceptionDispatchInfo closedInfo
private WebOperation priorityRequest
private int requestSent
private int finished
public HttpWebRequest Request
public WebConnection Connection
public ServicePoint ServicePoint
public BufferOffsetSize WriteBuffer
public bool IsNtlmChallenge
internal string ME
public bool Aborted
public bool Closed
public WebRequestStream WriteStream
internal WebCompletionSource`1<ValueTuple`2<bool, WebOperation>> Finished
public HttpWebRequest get_Request()
public WebConnection get_Connection()
private void set_Connection(WebConnection value)
public ServicePoint get_ServicePoint()
private void set_ServicePoint(ServicePoint value)
public BufferOffsetSize get_WriteBuffer()
public bool get_IsNtlmChallenge()
internal string get_ME()
public void .ctor(HttpWebRequest request, BufferOffsetSize writeBuffer, bool isNtlmChallenge, CancellationToken cancellationToken)
public bool get_Aborted()
public bool get_Closed()
public void Abort()
public void Close()
private void SetCanceled()
private void SetError(Exception error)
private ValueTuple`2<ExceptionDispatchInfo, bool> SetDisposed(ExceptionDispatchInfo& field)
internal ExceptionDispatchInfo CheckDisposed(CancellationToken cancellationToken)
internal void ThrowIfDisposed()
internal void ThrowIfDisposed(CancellationToken cancellationToken)
internal void ThrowIfClosedOrDisposed()
internal void ThrowIfClosedOrDisposed(CancellationToken cancellationToken)
private ExceptionDispatchInfo CheckThrowDisposed(bool throwIt, ExceptionDispatchInfo& field)
internal void RegisterRequest(ServicePoint servicePoint, WebConnection connection)
public void SetPriorityRequest(WebOperation operation)
public Task`1<Stream> GetRequestStream()
internal Task`1<WebRequestStream> GetRequestStreamInternal()
public Task WaitUntilRequestWritten()
public WebRequestStream get_WriteStream()
public Task`1<WebResponseStream> GetResponseStream()
internal WebCompletionSource`1<ValueTuple`2<bool, WebOperation>> get_Finished()
internal void Run()
internal void CompleteRequestWritten(WebRequestStream stream, Exception error)
internal void Finish(bool ok, Exception error)
private void <RegisterRequest>b__48_0()
}
internal System.Net.WebParseError : ValueType {
public WebParseErrorSection Section
public WebParseErrorCode Code
}
internal System.Net.WebParseErrorCode : Enum {
public int value__
public WebParseErrorCode Generic
public WebParseErrorCode InvalidHeaderName
public WebParseErrorCode InvalidContentLength
public WebParseErrorCode IncompleteHeaderLine
public WebParseErrorCode CrLfError
public WebParseErrorCode InvalidChunkFormat
public WebParseErrorCode UnexpectedServerResponse
}
internal System.Net.WebParseErrorSection : Enum {
public int value__
public WebParseErrorSection Generic
public WebParseErrorSection ResponseHeader
public WebParseErrorSection ResponseStatusLine
public WebParseErrorSection ResponseBody
}
public System.Net.WebPermission : CodeAccessPermission {
private bool m_noRestriction
private bool m_UnrestrictedConnect
private bool m_UnrestrictedAccept
private ArrayList m_connectList
private ArrayList m_acceptList
internal string MatchAll
private Regex modreq(System.Runtime.CompilerServices.IsVolatile) s_MatchAllRegex
internal Regex MatchAllRegex
public IEnumerator ConnectList
public IEnumerator AcceptList
internal Regex get_MatchAllRegex()
public IEnumerator get_ConnectList()
public IEnumerator get_AcceptList()
public void .ctor(PermissionState state)
internal void .ctor(bool unrestricted)
internal void .ctor(NetworkAccess access)
public void .ctor(NetworkAccess access, Regex uriRegex)
public void .ctor(NetworkAccess access, string uriString)
internal void .ctor(NetworkAccess access, Uri uri)
public void AddPermission(NetworkAccess access, string uriString)
internal void AddPermission(NetworkAccess access, Uri uri)
public void AddPermission(NetworkAccess access, Regex uriRegex)
internal void AddAsPattern(NetworkAccess access, DelayedRegex uriRegexPattern)
public bool IsUnrestricted()
public IPermission Copy()
public bool IsSubsetOf(IPermission target)
private bool isSpecialSubsetCase(string regexToCheck, ArrayList permList)
public IPermission Union(IPermission target)
public IPermission Intersect(IPermission target)
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
private bool isMatchedURI(object uriToCheck, ArrayList uriPatternList)
private void intersectList(ArrayList A, ArrayList B, ArrayList result)
private object intersectPair(object L, object R, Boolean& isUri)
}
public System.Net.WebPermissionAttribute : CodeAccessSecurityAttribute {
private object m_accept
private object m_connect
public string Connect
public string Accept
public string ConnectPattern
public string AcceptPattern
public void .ctor(SecurityAction action)
public string get_Connect()
public void set_Connect(string value)
public string get_Accept()
public void set_Accept(string value)
public string get_ConnectPattern()
public void set_ConnectPattern(string value)
public string get_AcceptPattern()
public void set_AcceptPattern(string value)
public IPermission CreatePermission()
}
public System.Net.WebProxy : object {
private bool _UseRegistry
private bool _BypassOnLocal
private bool m_EnableAutoproxy
private Uri _ProxyAddress
private ArrayList _BypassList
private ICredentials _Credentials
private Regex[] _RegExBypassList
private Hashtable _ProxyHostAddresses
private AutoWebProxyScriptEngine m_ScriptEngine
public Uri Address
internal bool AutoDetect
internal Uri ScriptLocation
public bool BypassProxyOnLocal
public String[] BypassList
public ICredentials Credentials
public bool UseDefaultCredentials
public ArrayList BypassArrayList
internal AutoWebProxyScriptEngine ScriptEngine
public void .ctor(Uri Address)
public void .ctor(Uri Address, bool BypassOnLocal)
public void .ctor(Uri Address, bool BypassOnLocal, String[] BypassList)
public void .ctor(Uri Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials)
public void .ctor(string Host, int Port)
public void .ctor(string Address)
public void .ctor(string Address, bool BypassOnLocal)
public void .ctor(string Address, bool BypassOnLocal, String[] BypassList)
public void .ctor(string Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials)
public Uri get_Address()
public void set_Address(Uri value)
internal void set_AutoDetect(bool value)
internal void set_ScriptLocation(Uri value)
public bool get_BypassProxyOnLocal()
public void set_BypassProxyOnLocal(bool value)
public String[] get_BypassList()
public void set_BypassList(String[] value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public ArrayList get_BypassArrayList()
internal void CheckForChanges()
public Uri GetProxy(Uri destination)
private Uri CreateProxyUri(string address)
private void UpdateRegExList(bool canThrow)
private bool IsMatchInBypassList(Uri input)
private bool IsLocal(Uri host)
private bool IsLocalInProxyHash(Uri host)
public bool IsBypassed(Uri host)
private bool IsBypassedManual(Uri host)
public WebProxy GetDefaultProxy()
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal AutoWebProxyScriptEngine get_ScriptEngine()
internal void set_ScriptEngine(AutoWebProxyScriptEngine value)
public IWebProxy CreateDefaultProxy()
internal void .ctor(bool enableAutoproxy)
internal void DeleteScriptEngine()
internal void UnsafeUpdateFromRegistry()
internal void Update(WebProxyData webProxyData)
private ProxyChain System.Net.IAutoWebProxy.GetProxies(Uri destination)
private bool GetProxyAuto(Uri destination, Uri& proxyUri)
private bool IsBypassedAuto(Uri destination, Boolean& isBypassed)
internal Uri[] GetProxiesAuto(Uri destination, Int32& syncStatus)
internal void AbortGetProxiesAuto(Int32& syncStatus)
internal Uri GetProxyAutoFailover(Uri destination)
private bool AreAllBypassed(IEnumerable`1<string> proxies, bool checkFirstOnly)
private Uri ProxyUri(string proxyName)
}
internal System.Net.WebProxyData : object {
internal bool bypassOnLocal
internal bool automaticallyDetectSettings
internal Uri proxyAddress
internal Hashtable proxyHostAddresses
internal Uri scriptLocation
internal ArrayList bypassList
}
internal System.Net.WebProxyDataBuilder : object {
private char addressListDelimiter
private char addressListSchemeValueDelimiter
private char bypassListDelimiter
private WebProxyData m_Result
private string regexReserved
public WebProxyData Build()
protected void BuildInternal()
protected void SetProxyAndBypassList(string addressString, string bypassListString)
protected void SetAutoProxyUrl(string autoConfigUrl)
protected void SetAutoDetectSettings(bool value)
private Uri ParseProxyUri(string proxyString)
private Hashtable ParseProtocolProxies(string proxyListString)
private FormatException CreateInvalidProxyStringException(string originalProxyString)
private string BypassStringEscape(string rawString)
private string ConvertRegexReservedChars(string rawString)
private ArrayList ParseBypassList(string bypassListString, Boolean& bypassOnLocal)
}
internal System.Net.WebReadStream : Stream {
private WebOperation <Operation>k__BackingField
private Stream <InnerStream>k__BackingField
private bool disposed
public WebOperation Operation
protected Stream InnerStream
internal string ME
public long Length
public long Position
public bool CanSeek
public bool CanRead
public bool CanWrite
public WebOperation get_Operation()
protected Stream get_InnerStream()
internal string get_ME()
public void .ctor(WebOperation operation, Stream innerStream)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_CanSeek()
public bool get_CanRead()
public bool get_CanWrite()
public void SetLength(long value)
public long Seek(long offset, SeekOrigin origin)
public void Write(Byte[] buffer, int offset, int count)
public void Flush()
protected Exception GetException(Exception e)
public int Read(Byte[] buffer, int offset, int size)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
public int EndRead(IAsyncResult r)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
protected Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
internal Task FinishReading(CancellationToken cancellationToken)
protected void Dispose(bool disposing)
}
public System.Net.WebRequest : MarshalByRefObject {
internal int DefaultTimeout
private ArrayList modreq(System.Runtime.CompilerServices.IsVolatile) s_PrefixList
private object s_InternalSyncObject
private Queue s_DefaultTimerQueue
private AuthenticationLevel m_AuthenticationLevel
private TokenImpersonationLevel m_ImpersonationLevel
private RequestCachePolicy m_CachePolicy
private RequestCacheProtocol m_CacheProtocol
private RequestCacheBinding m_CacheBinding
private DesignerWebRequestCreate webRequestCreate
private IWebProxy modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultWebProxy
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultWebProxyInitialized
public IWebRequestCreate CreatorInstance
private object InternalSyncObject
internal Queue DefaultTimerQueue
internal ArrayList PrefixList
public RequestCachePolicy DefaultCachePolicy
public RequestCachePolicy CachePolicy
public string Method
public Uri RequestUri
public string ConnectionGroupName
public WebHeaderCollection Headers
public long ContentLength
public string ContentType
public ICredentials Credentials
public bool UseDefaultCredentials
public IWebProxy Proxy
public bool PreAuthenticate
public int Timeout
internal RequestCacheProtocol CacheProtocol
public AuthenticationLevel AuthenticationLevel
public TokenImpersonationLevel ImpersonationLevel
internal IWebProxy InternalDefaultWebProxy
public IWebProxy DefaultWebProxy
public IWebRequestCreate get_CreatorInstance()
public void RegisterPortableWebRequestCreator(IWebRequestCreate creator)
private object get_InternalSyncObject()
internal Queue get_DefaultTimerQueue()
private WebRequest Create(Uri requestUri, bool useUriBase)
public WebRequest Create(string requestUriString)
public WebRequest Create(Uri requestUri)
public WebRequest CreateDefault(Uri requestUri)
public HttpWebRequest CreateHttp(string requestUriString)
public HttpWebRequest CreateHttp(Uri requestUri)
public bool RegisterPrefix(string prefix, IWebRequestCreate creator)
internal ArrayList get_PrefixList()
internal void set_PrefixList(ArrayList value)
private ArrayList PopulatePrefixList()
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public RequestCachePolicy get_DefaultCachePolicy()
public void set_DefaultCachePolicy(RequestCachePolicy value)
public RequestCachePolicy get_CachePolicy()
public void set_CachePolicy(RequestCachePolicy value)
private void InternalSetCachePolicy(RequestCachePolicy policy)
public string get_Method()
public void set_Method(string value)
public Uri get_RequestUri()
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public long get_ContentLength()
public void set_ContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public int get_Timeout()
public void set_Timeout(int value)
public Stream GetRequestStream()
public WebResponse GetResponse()
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public Task`1<Stream> GetRequestStreamAsync()
public Task`1<WebResponse> GetResponseAsync()
private WindowsIdentity SafeCaptureIdenity()
public void Abort()
internal RequestCacheProtocol get_CacheProtocol()
internal void set_CacheProtocol(RequestCacheProtocol value)
public AuthenticationLevel get_AuthenticationLevel()
public void set_AuthenticationLevel(AuthenticationLevel value)
public TokenImpersonationLevel get_ImpersonationLevel()
public void set_ImpersonationLevel(TokenImpersonationLevel value)
internal IWebProxy get_InternalDefaultWebProxy()
internal void set_InternalDefaultWebProxy(IWebProxy value)
public IWebProxy get_DefaultWebProxy()
public void set_DefaultWebProxy(IWebProxy value)
public IWebProxy GetSystemWebProxy()
internal IWebProxy InternalGetSystemWebProxy()
internal void SetupCacheProtocol(Uri uri)
private Task`1<Stream> <GetRequestStreamAsync>b__78_0()
private Task`1<WebResponse> <GetResponseAsync>b__79_0()
}
internal System.Net.WebRequestPrefixElement : object {
public string Prefix
internal IWebRequestCreate creator
internal Type creatorType
public IWebRequestCreate Creator
public IWebRequestCreate get_Creator()
public void set_Creator(IWebRequestCreate value)
public void .ctor(string P, Type creatorType)
public void .ctor(string P, IWebRequestCreate C)
}
internal System.Net.WebRequestStream : WebConnectionStream {
private Byte[] crlf
private MemoryStream writeBuffer
private bool requestWritten
private bool allowBuffering
private bool sendChunked
private WebCompletionSource pendingWrite
private long totalWritten
private Byte[] headers
private bool headersSent
private int completeRequestWritten
private int chunkTrailerWritten
internal string ME
private Stream <InnerStream>k__BackingField
private bool <KeepAlive>k__BackingField
internal Stream InnerStream
public bool KeepAlive
public bool CanRead
public bool CanWrite
internal bool SendChunked
internal bool HasWriteBuffer
internal int WriteBufferLength
public void .ctor(WebConnection connection, WebOperation operation, Stream stream, WebConnectionTunnel tunnel)
internal Stream get_InnerStream()
public bool get_KeepAlive()
public bool get_CanRead()
public bool get_CanWrite()
internal bool get_SendChunked()
internal void set_SendChunked(bool value)
internal bool get_HasWriteBuffer()
internal int get_WriteBufferLength()
internal BufferOffsetSize GetWriteBuffer()
private Task FinishWriting(CancellationToken cancellationToken)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task WriteAsyncInner(Byte[] buffer, int offset, int size, WebCompletionSource completion, CancellationToken cancellationToken)
private Task ProcessWrite(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
private void CheckWriteOverflow(long contentLength, long totalWritten, long size)
internal Task Initialize(CancellationToken cancellationToken)
private Task SetHeadersAsync(bool setInternalLength, CancellationToken cancellationToken)
internal Task WriteRequestAsync(CancellationToken cancellationToken)
private Task WriteChunkTrailer_inner(CancellationToken cancellationToken)
private Task WriteChunkTrailer()
internal void KillBuffer()
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
protected bool TryReadFromBufferedContent(Byte[] buffer, int offset, int count, Int32& result)
protected void Close_internal(Boolean& disposed)
}
public System.Net.WebResponse : MarshalByRefObject {
private bool m_IsCacheFresh
private bool m_IsFromCache
public bool IsFromCache
internal bool InternalSetFromCache
internal bool IsCacheFresh
internal bool InternalSetIsCacheFresh
public bool IsMutuallyAuthenticated
public long ContentLength
public string ContentType
public Uri ResponseUri
public WebHeaderCollection Headers
public bool SupportsHeaders
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
public bool get_IsFromCache()
internal void set_InternalSetFromCache(bool value)
internal bool get_IsCacheFresh()
internal void set_InternalSetIsCacheFresh(bool value)
public bool get_IsMutuallyAuthenticated()
public long get_ContentLength()
public void set_ContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public Stream GetResponseStream()
public Uri get_ResponseUri()
public WebHeaderCollection get_Headers()
public bool get_SupportsHeaders()
}
internal System.Net.WebResponseStream : WebConnectionStream {
private WebReadStream innerStream
private bool nextReadCalled
private bool bufferedEntireContent
private WebCompletionSource pendingRead
private object locker
private int nestedRead
private bool read_eof
private WebRequestStream <RequestStream>k__BackingField
private WebHeaderCollection <Headers>k__BackingField
private HttpStatusCode <StatusCode>k__BackingField
private string <StatusDescription>k__BackingField
private Version <Version>k__BackingField
private bool <KeepAlive>k__BackingField
internal string ME
private bool <ChunkedRead>k__BackingField
public WebRequestStream RequestStream
public WebHeaderCollection Headers
public HttpStatusCode StatusCode
public string StatusDescription
public Version Version
public bool KeepAlive
public bool CanRead
public bool CanWrite
private bool ChunkedRead
private bool ExpectContent
public WebRequestStream get_RequestStream()
public WebHeaderCollection get_Headers()
private void set_Headers(WebHeaderCollection value)
public HttpStatusCode get_StatusCode()
private void set_StatusCode(HttpStatusCode value)
public string get_StatusDescription()
private void set_StatusDescription(string value)
public Version get_Version()
private void set_Version(Version value)
public bool get_KeepAlive()
private void set_KeepAlive(bool value)
public void .ctor(WebRequestStream request)
public bool get_CanRead()
public bool get_CanWrite()
private bool get_ChunkedRead()
private void set_ChunkedRead(bool value)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> ProcessRead(Byte[] buffer, int offset, int size, CancellationToken cancellationToken)
protected bool TryReadFromBufferedContent(Byte[] buffer, int offset, int count, Int32& result)
private bool CheckAuthHeader(string headerName)
private bool get_ExpectContent()
private void Initialize(BufferOffsetSize buffer)
private Task`1<Byte[]> ReadAllAsyncInner(CancellationToken cancellationToken)
internal Task ReadAllAsync(bool resending, CancellationToken cancellationToken)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
protected void Close_internal(Boolean& disposed)
private WebException GetReadException(WebExceptionStatus status, Exception error, string where)
internal Task InitReadAsync(CancellationToken cancellationToken)
private bool GetResponse(BufferOffsetSize buffer, Int32& pos, ReadState& state)
}
public System.Net.WebSockets.ClientWebSocket : WebSocket {
private ClientWebSocketOptions _options
private WebSocketHandle _innerWebSocket
private int _state
public ClientWebSocketOptions Options
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public string SubProtocol
public WebSocketState State
public ClientWebSocketOptions get_Options()
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
public string get_SubProtocol()
public WebSocketState get_State()
public Task ConnectAsync(Uri uri, CancellationToken cancellationToken)
private Task ConnectAsyncCore(Uri uri, CancellationToken cancellationToken)
public Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public ValueTask SendAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken)
public ValueTask`1<ValueWebSocketReceiveResult> ReceiveAsync(Memory`1<byte> buffer, CancellationToken cancellationToken)
public Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public void Abort()
public void Dispose()
private void ThrowIfNotConnected()
}
public System.Net.WebSockets.ClientWebSocketOptions : object {
private bool _isReadOnly
private List`1<string> _requestedSubProtocols
private WebHeaderCollection _requestHeaders
private TimeSpan _keepAliveInterval
private bool _useDefaultCredentials
private ICredentials _credentials
private IWebProxy _proxy
private X509CertificateCollection _clientCertificates
private CookieContainer _cookies
private int _receiveBufferSize
private int _sendBufferSize
private Nullable`1<ArraySegment`1<byte>> _buffer
private RemoteCertificateValidationCallback _remoteCertificateValidationCallback
internal WebHeaderCollection RequestHeaders
internal List`1<string> RequestedSubProtocols
public bool UseDefaultCredentials
public ICredentials Credentials
public IWebProxy Proxy
public X509CertificateCollection ClientCertificates
public RemoteCertificateValidationCallback RemoteCertificateValidationCallback
public CookieContainer Cookies
public TimeSpan KeepAliveInterval
internal int ReceiveBufferSize
internal int SendBufferSize
internal Nullable`1<ArraySegment`1<byte>> Buffer
public void SetRequestHeader(string headerName, string headerValue)
internal WebHeaderCollection get_RequestHeaders()
internal List`1<string> get_RequestedSubProtocols()
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value)
public CookieContainer get_Cookies()
public void set_Cookies(CookieContainer value)
public void AddSubProtocol(string subProtocol)
public TimeSpan get_KeepAliveInterval()
public void set_KeepAliveInterval(TimeSpan value)
internal int get_ReceiveBufferSize()
internal int get_SendBufferSize()
internal Nullable`1<ArraySegment`1<byte>> get_Buffer()
public void SetBuffer(int receiveBufferSize, int sendBufferSize)
public void SetBuffer(int receiveBufferSize, int sendBufferSize, ArraySegment`1<byte> buffer)
internal void SetToReadOnly()
private void ThrowIfReadOnly()
}
public System.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
private Uri _requestUri
private NameValueCollection _headers
private CookieCollection _cookieCollection
private IPrincipal _user
private bool _isAuthenticated
private bool _isLocal
private bool _isSecureConnection
private string _origin
private IEnumerable`1<string> _secWebSocketProtocols
private string _secWebSocketVersion
private string _secWebSocketKey
private WebSocket _webSocket
public Uri RequestUri
public NameValueCollection Headers
public string Origin
public IEnumerable`1<string> SecWebSocketProtocols
public string SecWebSocketVersion
public string SecWebSocketKey
public CookieCollection CookieCollection
public IPrincipal User
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public WebSocket WebSocket
internal void .ctor(Uri requestUri, NameValueCollection headers, CookieCollection cookieCollection, IPrincipal user, bool isAuthenticated, bool isLocal, bool isSecureConnection, string origin, IEnumerable`1<string> secWebSocketProtocols, string secWebSocketVersion, string secWebSocketKey, WebSocket webSocket)
public Uri get_RequestUri()
public NameValueCollection get_Headers()
public string get_Origin()
public IEnumerable`1<string> get_SecWebSocketProtocols()
public string get_SecWebSocketVersion()
public string get_SecWebSocketKey()
public CookieCollection get_CookieCollection()
public IPrincipal get_User()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public WebSocket get_WebSocket()
private IPrincipal CopyPrincipal(IPrincipal user)
}
internal System.Net.WebSockets.ManagedWebSocket : WebSocket {
private RandomNumberGenerator s_random
private UTF8Encoding s_textEncoding
private WebSocketState[] s_validSendStates
private WebSocketState[] s_validReceiveStates
private WebSocketState[] s_validCloseOutputStates
private WebSocketState[] s_validCloseStates
private Task`1<WebSocketReceiveResult> s_cachedCloseTask
internal int MaxMessageHeaderLength
private int MaxControlPayloadLength
private int MaskLength
private Stream _stream
private bool _isServer
private string _subprotocol
private Timer _keepAliveTimer
private CancellationTokenSource _abortSource
private Memory`1<byte> _receiveBuffer
private Utf8MessageState _utf8TextState
private SemaphoreSlim _sendFrameAsyncLock
private WebSocketState _state
private bool _disposed
private bool _sentCloseFrame
private bool _receivedCloseFrame
private Nullable`1<WebSocketCloseStatus> _closeStatus
private string _closeStatusDescription
private MessageHeader _lastReceiveHeader
private int _receiveBufferOffset
private int _receiveBufferCount
private int _receivedMaskOffsetOffset
private Byte[] _sendBuffer
private bool _lastSendWasFragment
private Task _lastReceiveAsync
private object StateUpdateLock
private object ReceiveAsyncLock
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public WebSocketState State
public string SubProtocol
public ManagedWebSocket CreateFromConnectedStream(Stream stream, bool isServer, string subprotocol, TimeSpan keepAliveInterval)
private object get_StateUpdateLock()
private object get_ReceiveAsyncLock()
private void .ctor(Stream stream, bool isServer, string subprotocol, TimeSpan keepAliveInterval)
public void Dispose()
private void DisposeCore()
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
public WebSocketState get_State()
public string get_SubProtocol()
public Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
private ValueTask SendPrivateAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken)
public Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public void Abort()
private ValueTask SendFrameAsync(MessageOpcode opcode, bool endOfMessage, ReadOnlyMemory`1<byte> payloadBuffer, CancellationToken cancellationToken)
private ValueTask SendFrameLockAcquiredNonCancelableAsync(MessageOpcode opcode, bool endOfMessage, ReadOnlyMemory`1<byte> payloadBuffer)
private Task WaitForWriteTaskAsync(ValueTask writeTask)
private Task SendFrameFallbackAsync(MessageOpcode opcode, bool endOfMessage, ReadOnlyMemory`1<byte> payloadBuffer, CancellationToken cancellationToken)
private int WriteFrameToSendBuffer(MessageOpcode opcode, bool endOfMessage, ReadOnlySpan`1<byte> payloadBuffer)
private void SendKeepAliveFrameAsync()
private int WriteHeader(MessageOpcode opcode, Byte[] sendBuffer, ReadOnlySpan`1<byte> payload, bool endOfMessage, bool useMask)
private void WriteRandomMask(Byte[] buffer, int offset)
private ValueTask`1<TWebSocketReceiveResult> ReceiveAsyncPrivate(Memory`1<byte> payloadBuffer, CancellationToken cancellationToken, TWebSocketReceiveResultGetter resultGetter)
private Task HandleReceivedCloseAsync(MessageHeader header, CancellationToken cancellationToken)
private Task WaitForServerToCloseConnectionAsync(CancellationToken cancellationToken)
private Task HandleReceivedPingPongAsync(MessageHeader header, CancellationToken cancellationToken)
private bool IsValidCloseStatus(WebSocketCloseStatus closeStatus)
private Task CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus closeStatus, WebSocketError error, Exception innerException)
private bool TryParseMessageHeaderFromReceiveBuffer(MessageHeader& resultHeader)
private Task CloseAsyncPrivate(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
private Task SendCloseFrameAsync(WebSocketCloseStatus closeStatus, string closeStatusDescription, CancellationToken cancellationToken)
private void ConsumeFromBuffer(int count)
private Task EnsureBufferContainsAsync(int minimumRequiredBytes, CancellationToken cancellationToken, bool throwOnPrematureClosure)
private void ThrowIfEOFUnexpected(bool throwOnPrematureClosure)
private void AllocateSendBuffer(int minLength)
private void ReleaseSendBuffer()
private int CombineMaskBytes(Span`1<byte> buffer, int maskOffset)
private int ApplyMask(Span`1<byte> toMask, Byte[] mask, int maskOffset, int maskOffsetIndex)
private int ApplyMask(Span`1<byte> toMask, int mask, int maskIndex)
private void ThrowIfOperationInProgress(bool operationCompleted, string methodName)
private void ThrowOperationInProgress(string methodName)
private Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken)
private bool TryValidateUtf8(Span`1<byte> span, bool endOfMessage, Utf8MessageState state)
private Task ValidateAndReceiveAsync(Task receiveTask, Byte[] buffer, CancellationToken cancellationToken)
}
public System.Net.WebSockets.ValueWebSocketReceiveResult : ValueType {
private UInt32 _countAndEndOfMessage
private WebSocketMessageType _messageType
public int Count
public bool EndOfMessage
public WebSocketMessageType MessageType
public void .ctor(int count, WebSocketMessageType messageType, bool endOfMessage)
public int get_Count()
public bool get_EndOfMessage()
public WebSocketMessageType get_MessageType()
private void ThrowCountOutOfRange()
private void ThrowMessageTypeOutOfRange()
}
public System.Net.WebSockets.WebSocket : object {
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public string SubProtocol
public WebSocketState State
public TimeSpan DefaultKeepAliveInterval
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
public string get_SubProtocol()
public WebSocketState get_State()
public void Abort()
public Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public void Dispose()
public Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken)
public Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public ValueTask`1<ValueWebSocketReceiveResult> ReceiveAsync(Memory`1<byte> buffer, CancellationToken cancellationToken)
public ValueTask SendAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
private Task SendWithArrayPoolAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public TimeSpan get_DefaultKeepAliveInterval()
protected void ThrowOnInvalidState(WebSocketState state, WebSocketState[] validStates)
protected bool IsStateTerminal(WebSocketState state)
public ArraySegment`1<byte> CreateClientBuffer(int receiveBufferSize, int sendBufferSize)
public ArraySegment`1<byte> CreateServerBuffer(int receiveBufferSize)
public WebSocket CreateFromStream(Stream stream, bool isServer, string subProtocol, TimeSpan keepAliveInterval)
public bool IsApplicationTargeting45()
public void RegisterPrefixes()
public WebSocket CreateClientWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval, bool useZeroMaskingKey, ArraySegment`1<byte> internalBuffer)
}
public System.Net.WebSockets.WebSocketCloseStatus : Enum {
public int value__
public WebSocketCloseStatus NormalClosure
public WebSocketCloseStatus EndpointUnavailable
public WebSocketCloseStatus ProtocolError
public WebSocketCloseStatus InvalidMessageType
public WebSocketCloseStatus Empty
public WebSocketCloseStatus InvalidPayloadData
public WebSocketCloseStatus PolicyViolation
public WebSocketCloseStatus MessageTooBig
public WebSocketCloseStatus MandatoryExtension
public WebSocketCloseStatus InternalServerError
}
public System.Net.WebSockets.WebSocketContext : object {
public Uri RequestUri
public NameValueCollection Headers
public string Origin
public IEnumerable`1<string> SecWebSocketProtocols
public string SecWebSocketVersion
public string SecWebSocketKey
public CookieCollection CookieCollection
public IPrincipal User
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public WebSocket WebSocket
public Uri get_RequestUri()
public NameValueCollection get_Headers()
public string get_Origin()
public IEnumerable`1<string> get_SecWebSocketProtocols()
public string get_SecWebSocketVersion()
public string get_SecWebSocketKey()
public CookieCollection get_CookieCollection()
public IPrincipal get_User()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public WebSocket get_WebSocket()
}
public System.Net.WebSockets.WebSocketError : Enum {
public int value__
public WebSocketError Success
public WebSocketError InvalidMessageType
public WebSocketError Faulted
public WebSocketError NativeError
public WebSocketError NotAWebSocket
public WebSocketError UnsupportedVersion
public WebSocketError UnsupportedProtocol
public WebSocketError HeaderError
public WebSocketError ConnectionClosedPrematurely
public WebSocketError InvalidState
}
public System.Net.WebSockets.WebSocketException : Win32Exception {
private WebSocketError _webSocketErrorCode
public int ErrorCode
public WebSocketError WebSocketErrorCode
public void .ctor(WebSocketError error)
public void .ctor(WebSocketError error, string message)
public void .ctor(WebSocketError error, Exception innerException)
public void .ctor(WebSocketError error, string message, Exception innerException)
public void .ctor(int nativeError)
public void .ctor(int nativeError, string message)
public void .ctor(int nativeError, Exception innerException)
public void .ctor(WebSocketError error, int nativeError)
public void .ctor(WebSocketError error, int nativeError, string message)
public void .ctor(WebSocketError error, int nativeError, Exception innerException)
public void .ctor(WebSocketError error, int nativeError, string message, Exception innerException)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
private void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public int get_ErrorCode()
public WebSocketError get_WebSocketErrorCode()
private string GetErrorMessage(WebSocketError error)
private void SetErrorCodeOnError(int nativeError)
private bool Succeeded(int hr)
}
internal System.Net.WebSockets.WebSocketHandle : object {
private StringBuilder t_cachedStringBuilder
private Encoding s_defaultHttpEncoding
private int DefaultReceiveBufferSize
private string WSServerGuid
private CancellationTokenSource _abortSource
private WebSocketState _state
private WebSocket _webSocket
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public WebSocketState State
public string SubProtocol
public WebSocketHandle Create()
public bool IsValid(WebSocketHandle handle)
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
public WebSocketState get_State()
public string get_SubProtocol()
public void CheckPlatformSupport()
public void Dispose()
public void Abort()
public Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public ValueTask SendAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken)
public Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken)
public ValueTask`1<ValueWebSocketReceiveResult> ReceiveAsync(Memory`1<byte> buffer, CancellationToken cancellationToken)
public Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken)
public Task ConnectAsyncCore(Uri uri, CancellationToken cancellationToken, ClientWebSocketOptions options)
private Task`1<Socket> ConnectSocketAsync(string host, int port, CancellationToken cancellationToken)
private Byte[] BuildRequestHeader(Uri uri, ClientWebSocketOptions options, string secKey)
private KeyValuePair`2<string, string> CreateSecKeyAndSecWebSocketAccept()
private Task`1<string> ParseAndValidateConnectResponseAsync(Stream stream, ClientWebSocketOptions options, string expectedSecWebSocketAccept, CancellationToken cancellationToken)
private void ValidateAndTrackHeader(string targetHeaderName, string targetHeaderValue, string foundHeaderName, string foundHeaderValue, Boolean& foundHeader)
private Task`1<string> ReadResponseHeaderLineAsync(Stream stream, CancellationToken cancellationToken)
}
public System.Net.WebSockets.WebSocketMessageType : Enum {
public int value__
public WebSocketMessageType Text
public WebSocketMessageType Binary
public WebSocketMessageType Close
}
public System.Net.WebSockets.WebSocketReceiveResult : object {
private int <Count>k__BackingField
private bool <EndOfMessage>k__BackingField
private WebSocketMessageType <MessageType>k__BackingField
private Nullable`1<WebSocketCloseStatus> <CloseStatus>k__BackingField
private string <CloseStatusDescription>k__BackingField
public int Count
public bool EndOfMessage
public WebSocketMessageType MessageType
public Nullable`1<WebSocketCloseStatus> CloseStatus
public string CloseStatusDescription
public void .ctor(int count, WebSocketMessageType messageType, bool endOfMessage)
public void .ctor(int count, WebSocketMessageType messageType, bool endOfMessage, Nullable`1<WebSocketCloseStatus> closeStatus, string closeStatusDescription)
public int get_Count()
public bool get_EndOfMessage()
public WebSocketMessageType get_MessageType()
public Nullable`1<WebSocketCloseStatus> get_CloseStatus()
public string get_CloseStatusDescription()
}
public System.Net.WebSockets.WebSocketState : Enum {
public int value__
public WebSocketState None
public WebSocketState Connecting
public WebSocketState Open
public WebSocketState CloseSent
public WebSocketState CloseReceived
public WebSocketState Closed
public WebSocketState Aborted
}
internal System.Net.WebSockets.WebSocketValidate : object {
internal int MaxControlFramePayloadLength
private int CloseStatusCodeAbort
private int CloseStatusCodeFailedTLSHandshake
private int InvalidCloseStatusCodesFrom
private int InvalidCloseStatusCodesTo
private string Separators
internal void ThrowIfInvalidState(WebSocketState currentState, bool isDisposed, WebSocketState[] validStates)
internal void ValidateSubprotocol(string subProtocol)
internal void ValidateCloseStatus(WebSocketCloseStatus closeStatus, string statusDescription)
internal void ThrowPlatformNotSupportedException()
internal void ValidateArraySegment(ArraySegment`1<byte> arraySegment, string parameterName)
internal void ValidateBuffer(Byte[] buffer, int offset, int count)
}
public System.Net.WebUtility : object {
private char HIGH_SURROGATE_START
private char LOW_SURROGATE_START
private char LOW_SURROGATE_END
private int UNICODE_PLANE00_END
private int UNICODE_PLANE01_START
private int UNICODE_PLANE16_END
private int UnicodeReplacementChar
private Char[] _htmlEntityEndingChars
private UnicodeDecodingConformance modreq(System.Runtime.CompilerServices.IsVolatile) _htmlDecodeConformance
private UnicodeEncodingConformance modreq(System.Runtime.CompilerServices.IsVolatile) _htmlEncodeConformance
private UnicodeDecodingConformance HtmlDecodeConformance
private UnicodeEncodingConformance HtmlEncodeConformance
public string HtmlEncode(string value)
public void HtmlEncode(string value, TextWriter output)
public string HtmlDecode(string value)
public void HtmlDecode(string value, TextWriter output)
private int IndexOfHtmlEncodingChars(string s, int startPos)
private UnicodeDecodingConformance get_HtmlDecodeConformance()
private UnicodeEncodingConformance get_HtmlEncodeConformance()
private Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue)
private Byte[] UrlEncode(Byte[] bytes, int offset, int count)
public string UrlEncode(string value)
public Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count)
private string UrlDecodeInternal(string value, Encoding encoding)
private Byte[] UrlDecodeInternal(Byte[] bytes, int offset, int count)
public string UrlDecode(string encodedValue)
public Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count)
private void ConvertSmpToUtf16(UInt32 smpChar, Char& leadingSurrogate, Char& trailingSurrogate)
private int GetNextUnicodeScalarValueFromUtf16Surrogate(Char*& pch, Int32& charsRemaining)
private int HexToInt(char h)
private char IntToHex(int n)
private bool IsUrlSafeChar(char ch)
private bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count)
private bool StringRequiresHtmlDecoding(string s)
}
internal System.Net.WindowsInstallationType : Enum {
public int value__
public WindowsInstallationType Unknown
public WindowsInstallationType Client
public WindowsInstallationType Server
public WindowsInstallationType ServerCore
public WindowsInstallationType Embedded
}
internal System.Net.WriteBufferState : Enum {
public int value__
public WriteBufferState Disabled
public WriteBufferState Headers
public WriteBufferState Buffer
public WriteBufferState Playback
}
public System.Net.WriteStreamClosedEventArgs : EventArgs {
public Exception Error
public Exception get_Error()
}
public System.Net.WriteStreamClosedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, WriteStreamClosedEventArgs e)
public IAsyncResult BeginInvoke(object sender, WriteStreamClosedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.NotImplemented : object {
internal Exception ByDesign
internal Exception get_ByDesign()
internal Exception ByDesignWithMessage(string message)
internal Exception ActiveIssue(string issue)
}
internal System.ParsingError : Enum {
public int value__
public ParsingError None
public ParsingError BadFormat
public ParsingError BadScheme
public ParsingError BadAuthority
public ParsingError EmptyUriString
public ParsingError LastRelativeUriOkErrIndex
public ParsingError SchemeLimit
public ParsingError SizeLimit
public ParsingError MustRootedPath
public ParsingError BadHostName
public ParsingError NonEmptyHost
public ParsingError BadPort
public ParsingError BadAuthorityTerminator
public ParsingError CannotCreateRelative
}
internal System.PasteArguments : object {
private char Quote
private char Backslash
internal void AppendArgument(StringBuilder stringBuilder, string argument)
private bool ContainsNoWhitespaceOrQuotes(string s)
}
internal System.Platform : object {
private bool checkedOS
private bool isMacOS
private bool isAix
private bool isIBMi
private bool isFreeBSD
private bool isOpenBSD
public bool IsMacOS
public bool IsFreeBSD
public bool IsOpenBSD
public bool IsIBMi
public bool IsAix
private int uname(IntPtr buf)
private void CheckOS()
public bool get_IsMacOS()
public bool get_IsFreeBSD()
public bool get_IsOpenBSD()
public bool get_IsIBMi()
public bool get_IsAix()
}
public System.Reflection.ICustomTypeProvider {
public Type GetCustomType()
}
public System.Runtime.InteropServices.ComTypes.ADVF : Enum {
public int value__
public ADVF ADVF_NODATA
public ADVF ADVF_PRIMEFIRST
public ADVF ADVF_ONLYONCE
public ADVF ADVFCACHE_NOHANDLER
public ADVF ADVFCACHE_FORCEBUILTIN
public ADVF ADVFCACHE_ONSAVE
public ADVF ADVF_DATAONSTOP
}
public System.Runtime.InteropServices.ComTypes.DATADIR : Enum {
public int value__
public DATADIR DATADIR_GET
public DATADIR DATADIR_SET
}
public System.Runtime.InteropServices.ComTypes.DVASPECT : Enum {
public int value__
public DVASPECT DVASPECT_CONTENT
public DVASPECT DVASPECT_THUMBNAIL
public DVASPECT DVASPECT_ICON
public DVASPECT DVASPECT_DOCPRINT
}
public System.Runtime.InteropServices.ComTypes.FORMATETC : ValueType {
public short cfFormat
public DVASPECT dwAspect
public int lindex
public IntPtr ptd
public TYMED tymed
}
public System.Runtime.InteropServices.ComTypes.IAdviseSink {
public void OnClose()
public void OnDataChange(FORMATETC& format, STGMEDIUM& stgmedium)
public void OnRename(IMoniker moniker)
public void OnSave()
public void OnViewChange(int aspect, int index)
}
public System.Runtime.InteropServices.ComTypes.IDataObject {
public int DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink adviseSink, Int32& connection)
public void DUnadvise(int connection)
public int EnumDAdvise(IEnumSTATDATA& enumAdvise)
public IEnumFORMATETC EnumFormatEtc(DATADIR direction)
public int GetCanonicalFormatEtc(FORMATETC& formatIn, FORMATETC& formatOut)
public void GetData(FORMATETC& format, STGMEDIUM& medium)
public void GetDataHere(FORMATETC& format, STGMEDIUM& medium)
public int QueryGetData(FORMATETC& format)
public void SetData(FORMATETC& formatIn, STGMEDIUM& medium, bool release)
}
public System.Runtime.InteropServices.ComTypes.IEnumFORMATETC {
public void Clone(IEnumFORMATETC& newEnum)
public int Next(int celt, FORMATETC[] rgelt, Int32[] pceltFetched)
public int Reset()
public int Skip(int celt)
}
public System.Runtime.InteropServices.ComTypes.IEnumSTATDATA {
public void Clone(IEnumSTATDATA& newEnum)
public int Next(int celt, STATDATA[] rgelt, Int32[] pceltFetched)
public int Reset()
public int Skip(int celt)
}
public System.Runtime.InteropServices.ComTypes.STATDATA : ValueType {
public ADVF advf
public IAdviseSink advSink
public int connection
public FORMATETC formatetc
}
public System.Runtime.InteropServices.ComTypes.STGMEDIUM : ValueType {
public object pUnkForRelease
public TYMED tymed
public IntPtr unionmember
}
public System.Runtime.InteropServices.ComTypes.TYMED : Enum {
public int value__
public TYMED TYMED_HGLOBAL
public TYMED TYMED_FILE
public TYMED TYMED_ISTREAM
public TYMED TYMED_ISTORAGE
public TYMED TYMED_GDI
public TYMED TYMED_MFPICT
public TYMED TYMED_ENHMF
public TYMED TYMED_NULL
}
public System.Runtime.InteropServices.DefaultParameterValueAttribute : Attribute {
private object value
public object Value
public void .ctor(object value)
public object get_Value()
}
public System.Runtime.InteropServices.HandleCollector : object {
private int deltaPercent
private string name
private int initialThreshold
private int maximumThreshold
private int threshold
private int handleCount
private Int32[] gc_counts
private int gc_gen
public int Count
public int InitialThreshold
public int MaximumThreshold
public string Name
public void .ctor(string name, int initialThreshold)
public void .ctor(string name, int initialThreshold, int maximumThreshold)
public int get_Count()
public int get_InitialThreshold()
public int get_MaximumThreshold()
public string get_Name()
public void Add()
public void Remove()
}
internal System.Runtime.Versioning.BinaryCompatibility : object {
public bool TargetsAtLeast_Desktop_V4_5
}
public System.Runtime.Versioning.FrameworkName : object {
private string m_identifier
private Version m_version
private string m_profile
private string m_fullName
private char c_componentSeparator
private char c_keyValueSeparator
private char c_versionValuePrefix
private string c_versionKey
private string c_profileKey
public string Identifier
public Version Version
public string Profile
public string FullName
public string get_Identifier()
public Version get_Version()
public string get_Profile()
public string get_FullName()
public bool Equals(object obj)
public bool Equals(FrameworkName other)
public int GetHashCode()
public string ToString()
public void .ctor(string identifier, Version version)
public void .ctor(string identifier, Version version, string profile)
public void .ctor(string frameworkName)
public bool op_Equality(FrameworkName left, FrameworkName right)
public bool op_Inequality(FrameworkName left, FrameworkName right)
}
public System.Security.AccessControl.SemaphoreAccessRule : AccessRule {
public SemaphoreRights SemaphoreRights
public void .ctor(IdentityReference identity, SemaphoreRights eventRights, AccessControlType type)
public void .ctor(string identity, SemaphoreRights eventRights, AccessControlType type)
public SemaphoreRights get_SemaphoreRights()
}
public System.Security.AccessControl.SemaphoreAuditRule : AuditRule {
public SemaphoreRights SemaphoreRights
public void .ctor(IdentityReference identity, SemaphoreRights eventRights, AuditFlags flags)
public SemaphoreRights get_SemaphoreRights()
}
public System.Security.AccessControl.SemaphoreRights : Enum {
public int value__
public SemaphoreRights Modify
public SemaphoreRights Delete
public SemaphoreRights ReadPermissions
public SemaphoreRights ChangePermissions
public SemaphoreRights TakeOwnership
public SemaphoreRights Synchronize
public SemaphoreRights FullControl
}
public System.Security.AccessControl.SemaphoreSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public void .ctor(string name, AccessControlSections includeSections)
internal void .ctor(SafeHandle handle, AccessControlSections includeSections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(SemaphoreAccessRule rule)
public bool RemoveAccessRule(SemaphoreAccessRule rule)
public void RemoveAccessRuleAll(SemaphoreAccessRule rule)
public void RemoveAccessRuleSpecific(SemaphoreAccessRule rule)
public void ResetAccessRule(SemaphoreAccessRule rule)
public void SetAccessRule(SemaphoreAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(SemaphoreAuditRule rule)
public bool RemoveAuditRule(SemaphoreAuditRule rule)
public void RemoveAuditRuleAll(SemaphoreAuditRule rule)
public void RemoveAuditRuleSpecific(SemaphoreAuditRule rule)
public void SetAuditRule(SemaphoreAuditRule rule)
internal void Persist(SafeHandle handle)
}
public System.Security.Authentication.AuthenticationException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Security.Authentication.CipherAlgorithmType : Enum {
public int value__
public CipherAlgorithmType None
public CipherAlgorithmType Null
public CipherAlgorithmType Aes
public CipherAlgorithmType Aes128
public CipherAlgorithmType Aes192
public CipherAlgorithmType Aes256
public CipherAlgorithmType Des
public CipherAlgorithmType Rc2
public CipherAlgorithmType Rc4
public CipherAlgorithmType TripleDes
}
public System.Security.Authentication.ExchangeAlgorithmType : Enum {
public int value__
public ExchangeAlgorithmType None
public ExchangeAlgorithmType DiffieHellman
public ExchangeAlgorithmType RsaKeyX
public ExchangeAlgorithmType RsaSign
}
public System.Security.Authentication.ExtendedProtection.ChannelBinding : SafeHandleZeroOrMinusOneIsInvalid {
public int Size
public int get_Size()
protected void .ctor(bool ownsHandle)
}
public System.Security.Authentication.ExtendedProtection.ChannelBindingKind : Enum {
public int value__
public ChannelBindingKind Unknown
public ChannelBindingKind Unique
public ChannelBindingKind Endpoint
}
internal System.Security.Authentication.ExtendedProtection.Configuration.ConfigUtil : object {
internal T GetCustomAttribute(MemberInfo m, bool inherit)
internal ConfigurationProperty BuildProperty(Type t, string name)
}
public System.Security.Authentication.ExtendedProtection.Configuration.ExtendedProtectionPolicyElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty custom_service_names
private ConfigurationProperty policy_enforcement
private ConfigurationProperty protection_scenario
public ServiceNameElementCollection CustomServiceNames
public PolicyEnforcement PolicyEnforcement
public ProtectionScenario ProtectionScenario
protected ConfigurationPropertyCollection Properties
public ServiceNameElementCollection get_CustomServiceNames()
public PolicyEnforcement get_PolicyEnforcement()
public void set_PolicyEnforcement(PolicyEnforcement value)
public ProtectionScenario get_ProtectionScenario()
public void set_ProtectionScenario(ProtectionScenario value)
protected ConfigurationPropertyCollection get_Properties()
public ExtendedProtectionPolicy BuildPolicy()
}
public System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty name
public string Name
protected ConfigurationPropertyCollection Properties
public string get_Name()
public void set_Name(string value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElementCollection : ConfigurationElementCollection {
public ServiceNameElement Item
public ServiceNameElement Item
public string Item
public ServiceNameElement get_Item(int index)
public ServiceNameElement get_Item(string name)
public void Add(ServiceNameElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(ServiceNameElement element)
public void Remove(string name)
public void Remove(ServiceNameElement element)
public void RemoveAt(int index)
public void set_Item(int index, ServiceNameElement value)
public void set_Item(string name, ServiceNameElement value)
}
public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy : object {
public ChannelBinding CustomChannelBinding
public ServiceNameCollection CustomServiceNames
public bool OSSupportsExtendedProtection
public PolicyEnforcement PolicyEnforcement
public ProtectionScenario ProtectionScenario
public void .ctor(PolicyEnforcement policyEnforcement)
public void .ctor(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding)
public void .ctor(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames)
public void .ctor(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames)
protected void .ctor(SerializationInfo info, StreamingContext context)
public ChannelBinding get_CustomChannelBinding()
public ServiceNameCollection get_CustomServiceNames()
public bool get_OSSupportsExtendedProtection()
public PolicyEnforcement get_PolicyEnforcement()
public ProtectionScenario get_ProtectionScenario()
public string ToString()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicyTypeConverter : TypeConverter {
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.Security.Authentication.ExtendedProtection.PolicyEnforcement : Enum {
public int value__
public PolicyEnforcement Never
public PolicyEnforcement WhenSupported
public PolicyEnforcement Always
}
public System.Security.Authentication.ExtendedProtection.ProtectionScenario : Enum {
public int value__
public ProtectionScenario TransportSelected
public ProtectionScenario TrustedProxy
}
public System.Security.Authentication.ExtendedProtection.ServiceNameCollection : ReadOnlyCollectionBase {
public void .ctor(ICollection items)
public ServiceNameCollection Merge(string serviceName)
public ServiceNameCollection Merge(IEnumerable serviceNames)
private void AddIfNew(ArrayList newServiceNames, string serviceName)
internal bool Contains(string searchServiceName, ICollection serviceNames)
public bool Contains(string searchServiceName)
internal string NormalizeServiceName(string inputServiceName)
internal bool Match(string serviceName1, string serviceName2)
}
public System.Security.Authentication.ExtendedProtection.TokenBinding : object {
private Byte[] _rawTokenBindingId
private TokenBindingType <BindingType>k__BackingField
public TokenBindingType BindingType
internal void .ctor(TokenBindingType bindingType, Byte[] rawData)
public Byte[] GetRawTokenBindingId()
public TokenBindingType get_BindingType()
private void set_BindingType(TokenBindingType value)
}
public System.Security.Authentication.ExtendedProtection.TokenBindingType : Enum {
public int value__
public TokenBindingType Provided
public TokenBindingType Referred
}
public System.Security.Authentication.HashAlgorithmType : Enum {
public int value__
public HashAlgorithmType None
public HashAlgorithmType Md5
public HashAlgorithmType Sha1
public HashAlgorithmType Sha256
public HashAlgorithmType Sha384
public HashAlgorithmType Sha512
}
public System.Security.Authentication.InvalidCredentialException : AuthenticationException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Security.Authentication.SslProtocols : Enum {
public int value__
public SslProtocols None
public SslProtocols Ssl2
public SslProtocols Ssl3
public SslProtocols Tls
public SslProtocols Tls11
public SslProtocols Tls12
public SslProtocols Tls13
public SslProtocols Default
}
public System.Security.Claims.DynamicRoleClaimProvider : object {
public void AddDynamicRoleClaims(ClaimsIdentity claimsIdentity, IEnumerable`1<Claim> claims)
}
internal System.Security.Cryptography.AsnDecodeStatus : Enum {
public int value__
public AsnDecodeStatus NotDecoded
public AsnDecodeStatus Ok
public AsnDecodeStatus BadAsn
public AsnDecodeStatus BadTag
public AsnDecodeStatus BadLength
public AsnDecodeStatus InformationNotAvailable
}
public System.Security.Cryptography.AsnEncodedData : object {
internal Oid _oid
internal Byte[] _raw
public Oid Oid
public Byte[] RawData
public void .ctor(string oid, Byte[] rawData)
public void .ctor(Oid oid, Byte[] rawData)
public void .ctor(AsnEncodedData asnEncodedData)
public void .ctor(Byte[] rawData)
public Oid get_Oid()
public void set_Oid(Oid value)
public Byte[] get_RawData()
public void set_RawData(Byte[] value)
public void CopyFrom(AsnEncodedData asnEncodedData)
public string Format(bool multiLine)
internal string ToString(bool multiLine)
internal string Default(bool multiLine)
internal string BasicConstraintsExtension(bool multiLine)
internal string EnhancedKeyUsageExtension(bool multiLine)
internal string KeyUsageExtension(bool multiLine)
internal string SubjectKeyIdentifierExtension(bool multiLine)
internal string SubjectAltName(bool multiLine)
internal string NetscapeCertType(bool multiLine)
}
public System.Security.Cryptography.AsnEncodedDataCollection : object {
private List`1<AsnEncodedData> _list
public AsnEncodedData Item
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(AsnEncodedData asnEncodedData)
public int Add(AsnEncodedData asnEncodedData)
public void Remove(AsnEncodedData asnEncodedData)
public AsnEncodedData get_Item(int index)
public int get_Count()
public AsnEncodedDataEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int index)
public void CopyTo(AsnEncodedData[] array, int index)
public bool get_IsSynchronized()
public object get_SyncRoot()
}
public System.Security.Cryptography.AsnEncodedDataEnumerator : object {
private AsnEncodedDataCollection _asnEncodedDatas
private int _current
public AsnEncodedData Current
private object System.Collections.IEnumerator.Current
internal void .ctor(AsnEncodedDataCollection asnEncodedDatas)
public AsnEncodedData get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
internal System.Security.Cryptography.DerEncoder : object {
private byte ConstructedFlag
private byte ConstructedSequenceTag
private byte ConstructedSetTag
private Byte[][] s_nullTlv
private Byte[] EncodeLength(int length)
internal Byte[][] SegmentedEncodeBoolean(bool value)
internal Byte[][] SegmentedEncodeUnsignedInteger(UInt32 value)
internal Byte[][] SegmentedEncodeUnsignedInteger(ReadOnlySpan`1<byte> bigEndianBytes)
internal Byte[][] SegmentedEncodeBitString(Byte[][][] childSegments)
internal Byte[][] SegmentedEncodeBitString(Byte[] data)
internal Byte[][] SegmentedEncodeBitString(int unusedBits, Byte[] data)
internal Byte[][] SegmentedEncodeNamedBitList(Byte[] bigEndianBytes, int namedBitsCount)
internal Byte[][] SegmentedEncodeOctetString(Byte[] data)
internal Byte[][] SegmentedEncodeNull()
internal Byte[] EncodeOid(string oidValue)
internal Byte[][] SegmentedEncodeOid(Oid oid)
internal Byte[][] SegmentedEncodeOid(string oidValue)
internal Byte[][] SegmentedEncodeUtf8String(Char[] chars)
internal Byte[][] SegmentedEncodeUtf8String(Char[] chars, int offset, int count)
internal Byte[][] ConstructSegmentedSequence(Byte[][][] items)
internal Byte[][] ConstructSegmentedSequence(IEnumerable`1<Byte[][]> items)
internal Byte[][] ConstructSegmentedContextSpecificValue(int contextId, Byte[][][] items)
internal Byte[][] ConstructSegmentedSet(Byte[][][] items)
internal Byte[][] ConstructSegmentedPresortedSet(Byte[][][] items)
internal bool IsValidPrintableString(Char[] chars)
internal bool IsValidPrintableString(Char[] chars, int offset, int count)
internal Byte[][] SegmentedEncodePrintableString(Char[] chars)
internal Byte[][] SegmentedEncodePrintableString(Char[] chars, int offset, int count)
internal Byte[][] SegmentedEncodeIA5String(Char[] chars)
internal Byte[][] SegmentedEncodeIA5String(Char[] chars, int offset, int count)
internal Byte[][] SegmentedEncodeUtcTime(DateTime utcTime)
internal Byte[][] SegmentedEncodeGeneralizedTime(DateTime utcTime)
internal Byte[] ConstructSequence(Byte[][][] items)
internal Byte[] ConstructSequence(IEnumerable`1<Byte[][]> items)
private BigInteger ParseOidRid(string oidValue, Int32& startIndex)
private int AtoI(char c)
private void EncodeRid(List`1<byte> encodedData, BigInteger& rid)
private bool IsPrintableStringCharacter(char c)
private Byte[] ConcatenateArrays(Byte[][][] segments)
private Byte[] ConcatenateArrays(IEnumerable`1<Byte[][]> segments)
}
internal System.Security.Cryptography.DerSequenceReader : object {
internal byte ContextSpecificTagFlag
internal byte ConstructedFlag
internal byte ContextSpecificConstructedTag0
internal byte ContextSpecificConstructedTag1
internal byte ContextSpecificConstructedTag2
internal byte ContextSpecificConstructedTag3
internal byte ConstructedSequence
internal byte TagClassMask
internal byte TagNumberMask
internal DateTimeFormatInfo s_validityDateTimeFormatInfo
private Encoding s_utf8EncodingWithExceptionFallback
private Encoding s_latin1Encoding
private Byte[] _data
private int _end
private int _position
private int <ContentLength>k__BackingField
internal int ContentLength
internal bool HasData
internal int get_ContentLength()
private void set_ContentLength(int value)
private void .ctor(bool startAtPayload, Byte[] data, int offset, int length)
internal void .ctor(Byte[] data)
internal void .ctor(Byte[] data, int offset, int length)
private void .ctor(DerTag tagToEat, Byte[] data, int offset, int length)
internal DerSequenceReader CreateForPayload(Byte[] payload)
internal bool get_HasData()
internal byte PeekTag()
internal bool HasTag(DerTag expectedTag)
internal bool HasTag(byte expectedTag)
internal void SkipValue()
internal void ValidateAndSkipDerValue()
internal Byte[] ReadNextEncodedValue()
internal bool ReadBoolean()
internal int ReadInteger()
internal Byte[] ReadIntegerBytes()
internal Byte[] ReadBitString()
internal Byte[] ReadOctetString()
internal string ReadOidAsString()
internal Oid ReadOid()
internal string ReadUtf8String()
private DerSequenceReader ReadCollectionWithTag(DerTag expected)
internal DerSequenceReader ReadSequence()
internal DerSequenceReader ReadSet()
internal string ReadPrintableString()
internal string ReadIA5String()
internal string ReadT61String()
internal DateTime ReadX509Date()
internal DateTime ReadUtcTime()
internal DateTime ReadGeneralizedTime()
internal string ReadBMPString()
private string TrimTrailingNulls(string value)
private DateTime ReadTime(DerTag timeTag, string formatString)
private Byte[] ReadContentAsBytes()
private void EatTag(DerTag expected)
private void CheckTag(DerTag expected, Byte[] data, int position)
private int EatLength()
private int ScanContentLength(Byte[] data, int offset, int end, Int32& bytesConsumed)
}
public System.Security.Cryptography.Oid : object {
private string _value
private string _friendlyName
private OidGroup _group
public string Value
public string FriendlyName
public void .ctor(string oid)
public void .ctor(string value, string friendlyName)
public void .ctor(Oid oid)
public Oid FromFriendlyName(string friendlyName, OidGroup group)
public Oid FromOidValue(string oidValue, OidGroup group)
public string get_Value()
public void set_Value(string value)
public string get_FriendlyName()
public void set_FriendlyName(string value)
private void .ctor(string value, string friendlyName, OidGroup group)
}
public System.Security.Cryptography.OidCollection : object {
private List`1<Oid> _list
public Oid Item
public Oid Item
public int Count
public bool IsSynchronized
public object SyncRoot
public int Add(Oid oid)
public Oid get_Item(int index)
public Oid get_Item(string oid)
public int get_Count()
public OidEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int index)
public void CopyTo(Oid[] array, int index)
public bool get_IsSynchronized()
public object get_SyncRoot()
}
public System.Security.Cryptography.OidEnumerator : object {
private OidCollection _oids
private int _current
public Oid Current
private object System.Collections.IEnumerator.Current
internal void .ctor(OidCollection oids)
public Oid get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.OidGroup : Enum {
public int value__
public OidGroup All
public OidGroup HashAlgorithm
public OidGroup EncryptionAlgorithm
public OidGroup PublicKeyAlgorithm
public OidGroup SignatureAlgorithm
public OidGroup Attribute
public OidGroup ExtensionOrAttribute
public OidGroup EnhancedKeyUsage
public OidGroup Policy
public OidGroup Template
public OidGroup KeyDerivationFunction
}
public System.Security.Cryptography.X509Certificates.CertificateRequest : object {
public Collection`1<X509Extension> CertificateExtensions
public HashAlgorithmName HashAlgorithm
public PublicKey PublicKey
public X500DistinguishedName SubjectName
public void .ctor(X500DistinguishedName subjectName, ECDsa key, HashAlgorithmName hashAlgorithm)
public void .ctor(X500DistinguishedName subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
public void .ctor(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm)
public void .ctor(string subjectName, ECDsa key, HashAlgorithmName hashAlgorithm)
public void .ctor(string subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
public Collection`1<X509Extension> get_CertificateExtensions()
public HashAlgorithmName get_HashAlgorithm()
public PublicKey get_PublicKey()
public X500DistinguishedName get_SubjectName()
public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber)
public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber)
public X509Certificate2 CreateSelfSigned(DateTimeOffset notBefore, DateTimeOffset notAfter)
public Byte[] CreateSigningRequest()
public Byte[] CreateSigningRequest(X509SignatureGenerator signatureGenerator)
}
internal System.Security.Cryptography.X509Certificates.GeneralNameEncoder : object {
private IdnMapping s_idnMapping
internal Byte[][] EncodeEmailAddress(string emailAddress)
internal Byte[][] EncodeDnsName(string dnsName)
internal Byte[][] EncodeUri(Uri uri)
internal Byte[][] EncodeIpAddress(IPAddress address)
internal Byte[][] EncodeUserPrincipalName(string upn)
}
public System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
public int value__
public OpenFlags ReadOnly
public OpenFlags ReadWrite
public OpenFlags MaxAllowed
public OpenFlags OpenExistingOnly
public OpenFlags IncludeArchived
}
internal System.Security.Cryptography.X509Certificates.OSX509Certificates : object {
public string SecurityLibrary
public string CoreFoundationLibrary
private IntPtr SecCertificateCreateWithData(IntPtr allocator, IntPtr nsdataRef)
private int SecTrustCreateWithCertificates(IntPtr certOrCertArray, IntPtr policies, IntPtr& sectrustref)
private int SecTrustSetAnchorCertificates(IntPtr trust, IntPtr anchorCertificates)
private IntPtr SecPolicyCreateSSL(bool server, IntPtr cfStringHostname)
private int SecTrustEvaluate(IntPtr secTrustRef, SecTrustResult& secTrustResultTime)
private IntPtr CFStringCreateWithCharacters(IntPtr allocator, string str, IntPtr count)
private IntPtr CFDataCreate(IntPtr allocator, Byte* bytes, IntPtr length)
private void CFRetain(IntPtr handle)
private void CFRelease(IntPtr handle)
private IntPtr CFArrayCreate(IntPtr allocator, IntPtr values, IntPtr numValues, IntPtr callbacks)
private IntPtr MakeCFData(Byte[] data)
private IntPtr FromIntPtrs(IntPtr[] values)
private IntPtr GetCertificate(X509Certificate certificate)
public SecTrustResult TrustEvaluateSsl(X509CertificateCollection certificates, X509CertificateCollection anchors, string host)
private SecTrustResult _TrustEvaluateSsl(X509CertificateCollection certificates, X509CertificateCollection anchors, string hostName)
}
public System.Security.Cryptography.X509Certificates.PublicKey : object {
private string rsaOid
private string dsaOid
private AsymmetricAlgorithm _key
private AsnEncodedData _keyValue
private AsnEncodedData _params
private Oid _oid
private Byte[] Empty
public AsnEncodedData EncodedKeyValue
public AsnEncodedData EncodedParameters
public AsymmetricAlgorithm Key
public Oid Oid
public void .ctor(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue)
internal void .ctor(X509Certificate certificate)
public AsnEncodedData get_EncodedKeyValue()
public AsnEncodedData get_EncodedParameters()
public AsymmetricAlgorithm get_Key()
public Oid get_Oid()
private Byte[] GetUnsignedBigInteger(Byte[] integer)
internal DSA DecodeDSA(Byte[] rawPublicKey, Byte[] rawParameters)
internal RSA DecodeRSA(Byte[] rawPublicKey)
}
public System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
public int value__
public StoreLocation CurrentUser
public StoreLocation LocalMachine
}
public System.Security.Cryptography.X509Certificates.StoreName : Enum {
public int value__
public StoreName AddressBook
public StoreName AuthRoot
public StoreName CertificateAuthority
public StoreName Disallowed
public StoreName My
public StoreName Root
public StoreName TrustedPeople
public StoreName TrustedPublisher
}
public System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder : object {
private List`1<Byte[][]> _encodedTlvs
private GeneralNameEncoder _generalNameEncoder
public void AddEmailAddress(string emailAddress)
public void AddDnsName(string dnsName)
public void AddUri(Uri uri)
public void AddIpAddress(IPAddress ipAddress)
public void AddUserPrincipalName(string upn)
public X509Extension Build(bool critical)
}
public System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
private X500DistinguishedNameFlags AllFlags
private string name
private Byte[] canonEncoding
internal Byte[] CanonicalEncoding
public string Name
public void .ctor(AsnEncodedData encodedDistinguishedName)
public void .ctor(Byte[] encodedDistinguishedName)
public void .ctor(string distinguishedName)
public void .ctor(string distinguishedName, X500DistinguishedNameFlags flag)
public void .ctor(X500DistinguishedName distinguishedName)
internal void .ctor(Byte[] encoded, Byte[] canonEncoding, string name)
internal Byte[] get_CanonicalEncoding()
public string get_Name()
public string Decode(X500DistinguishedNameFlags flag)
public string Format(bool multiLine)
private string GetSeparator(X500DistinguishedNameFlags flag)
private void DecodeRawData()
private string Canonize(string s)
internal bool AreEqual(X500DistinguishedName name1, X500DistinguishedName name2)
}
public System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
public int value__
public X500DistinguishedNameFlags None
public X500DistinguishedNameFlags Reversed
public X500DistinguishedNameFlags UseSemicolons
public X500DistinguishedNameFlags DoNotUsePlusSign
public X500DistinguishedNameFlags DoNotUseQuotes
public X500DistinguishedNameFlags UseCommas
public X500DistinguishedNameFlags UseNewLines
public X500DistinguishedNameFlags UseUTF8Encoding
public X500DistinguishedNameFlags UseT61Encoding
public X500DistinguishedNameFlags ForceUTF8Encoding
}
public System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
internal string oid
internal string friendlyName
private bool _certificateAuthority
private bool _hasPathLengthConstraint
private int _pathLengthConstraint
private AsnDecodeStatus _status
public bool CertificateAuthority
public bool HasPathLengthConstraint
public int PathLengthConstraint
public void .ctor(AsnEncodedData encodedBasicConstraints, bool critical)
public void .ctor(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical)
public bool get_CertificateAuthority()
public bool get_HasPathLengthConstraint()
public int get_PathLengthConstraint()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) lazyRawData
private Oid modreq(System.Runtime.CompilerServices.IsVolatile) lazySignatureAlgorithm
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) lazyVersion
private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) lazySubjectName
private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) lazyIssuerName
private PublicKey modreq(System.Runtime.CompilerServices.IsVolatile) lazyPublicKey
private AsymmetricAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) lazyPrivateKey
private X509ExtensionCollection modreq(System.Runtime.CompilerServices.IsVolatile) lazyExtensions
public bool Archived
public X509ExtensionCollection Extensions
public string FriendlyName
public bool HasPrivateKey
public AsymmetricAlgorithm PrivateKey
public X500DistinguishedName IssuerName
public DateTime NotAfter
public DateTime NotBefore
public PublicKey PublicKey
public Byte[] RawData
public string SerialNumber
public Oid SignatureAlgorithm
public X500DistinguishedName SubjectName
public string Thumbprint
public int Version
internal X509Certificate2Impl Impl
public void Reset()
public void .ctor(Byte[] rawData)
public void .ctor(Byte[] rawData, string password)
public void .ctor(Byte[] rawData, SecureString password)
public void .ctor(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(IntPtr handle)
internal void .ctor(X509Certificate2Impl impl)
public void .ctor(string fileName)
public void .ctor(string fileName, string password)
public void .ctor(string fileName, SecureString password)
public void .ctor(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(X509Certificate certificate)
protected void .ctor(SerializationInfo info, StreamingContext context)
public bool get_Archived()
public void set_Archived(bool value)
public X509ExtensionCollection get_Extensions()
public string get_FriendlyName()
public void set_FriendlyName(string value)
public bool get_HasPrivateKey()
public AsymmetricAlgorithm get_PrivateKey()
public void set_PrivateKey(AsymmetricAlgorithm value)
public X500DistinguishedName get_IssuerName()
public DateTime get_NotAfter()
public DateTime get_NotBefore()
public PublicKey get_PublicKey()
public Byte[] get_RawData()
public string get_SerialNumber()
public Oid get_SignatureAlgorithm()
public X500DistinguishedName get_SubjectName()
public string get_Thumbprint()
public int get_Version()
public X509ContentType GetCertContentType(Byte[] rawData)
public X509ContentType GetCertContentType(string fileName)
public string GetNameInfo(X509NameType nameType, bool forIssuer)
public string ToString()
public string ToString(bool verbose)
public void Import(Byte[] rawData)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName)
public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
public bool Verify()
private X509Extension CreateCustomExtensionIfAny(Oid oid)
internal X509Certificate2Impl get_Impl()
}
public System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
private String[] newline_split
public X509Certificate2 Item
public void .ctor(X509Certificate2Collection certificates)
public void .ctor(X509Certificate2 certificate)
public void .ctor(X509Certificate2[] certificates)
public X509Certificate2 get_Item(int index)
public void set_Item(int index, X509Certificate2 value)
public int Add(X509Certificate2 certificate)
public void AddRange(X509Certificate2[] certificates)
public void AddRange(X509Certificate2Collection certificates)
public bool Contains(X509Certificate2 certificate)
public Byte[] Export(X509ContentType contentType)
public Byte[] Export(X509ContentType contentType, string password)
private string GetKeyIdentifier(X509Certificate2 x)
public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly)
public X509Certificate2Enumerator GetEnumerator()
public void Import(Byte[] rawData)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName)
public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void Insert(int index, X509Certificate2 certificate)
public void Remove(X509Certificate2 certificate)
public void RemoveRange(X509Certificate2[] certificates)
public void RemoveRange(X509Certificate2Collection certificates)
}
public System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
private IEnumerator enumerator
public X509Certificate2 Current
private object System.Collections.IEnumerator.Current
internal void .ctor(X509Certificate2Collection collection)
public X509Certificate2 get_Current()
public bool MoveNext()
public void Reset()
private object System.Collections.IEnumerator.get_Current()
private bool System.Collections.IEnumerator.MoveNext()
private void System.Collections.IEnumerator.Reset()
}
internal System.Security.Cryptography.X509Certificates.X509Certificate2Impl : X509CertificateImpl {
public bool Archived
public IEnumerable`1<X509Extension> Extensions
public string FriendlyName
public X500DistinguishedName IssuerName
public AsymmetricAlgorithm PrivateKey
public PublicKey PublicKey
public string SignatureAlgorithm
public X500DistinguishedName SubjectName
public int Version
internal X509CertificateImplCollection IntermediateCertificates
internal X509Certificate2Impl FallbackImpl
public bool get_Archived()
public void set_Archived(bool value)
public IEnumerable`1<X509Extension> get_Extensions()
public string get_FriendlyName()
public void set_FriendlyName(string value)
public X500DistinguishedName get_IssuerName()
public AsymmetricAlgorithm get_PrivateKey()
public void set_PrivateKey(AsymmetricAlgorithm value)
public PublicKey get_PublicKey()
public string get_SignatureAlgorithm()
public X500DistinguishedName get_SubjectName()
public int get_Version()
internal X509CertificateImplCollection get_IntermediateCertificates()
internal X509Certificate2Impl get_FallbackImpl()
public string GetNameInfo(X509NameType nameType, bool forIssuer)
public bool Verify(X509Certificate2 thisCertificate)
public void AppendPrivateKeyInfo(StringBuilder sb)
public X509CertificateImpl CopyWithPrivateKey(RSA privateKey)
public X509Certificate CreateCertificate()
public void Reset()
}
internal System.Security.Cryptography.X509Certificates.X509Certificate2ImplMono : X509Certificate2ImplUnix {
private PublicKey _publicKey
private X509CertificateImplCollection intermediateCerts
private X509Certificate _cert
private string empty_error
private Byte[] signedData
public bool IsValid
public IntPtr Handle
private X509Certificate Cert
public bool HasPrivateKey
public AsymmetricAlgorithm PrivateKey
public PublicKey PublicKey
internal X509CertificateImplCollection IntermediateCertificates
internal X509Certificate MonoCertificate
internal X509Certificate2Impl FallbackImpl
public bool get_IsValid()
public IntPtr get_Handle()
public IntPtr GetNativeAppleCertificate()
public void .ctor(X509Certificate cert)
private void .ctor(X509Certificate2ImplMono other)
public void .ctor(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags)
public X509CertificateImpl Clone()
private X509Certificate get_Cert()
protected Byte[] GetRawCertData()
public bool Equals(X509CertificateImpl other, Boolean& result)
public bool get_HasPrivateKey()
public AsymmetricAlgorithm get_PrivateKey()
public void set_PrivateKey(AsymmetricAlgorithm value)
public RSA GetRSAPrivateKey()
public DSA GetDSAPrivateKey()
public PublicKey get_PublicKey()
private X509Certificate ImportPkcs12(Byte[] rawData, SafePasswordHandle password)
private X509Certificate ImportPkcs12(Byte[] rawData, string password)
public void Reset()
public bool Verify(X509Certificate2 thisCertificate)
public X509ContentType GetCertContentType(Byte[] rawData)
public X509ContentType GetCertContentType(string fileName)
internal X509CertificateImplCollection get_IntermediateCertificates()
internal X509Certificate get_MonoCertificate()
internal X509Certificate2Impl get_FallbackImpl()
}
internal System.Security.Cryptography.X509Certificates.X509Certificate2ImplUnix : X509Certificate2Impl {
private bool readCertData
private CertificateData certData
public bool Archived
public string KeyAlgorithm
public Byte[] KeyAlgorithmParameters
public Byte[] PublicKeyValue
public Byte[] SerialNumber
public string SignatureAlgorithm
public string FriendlyName
public int Version
public X500DistinguishedName SubjectName
public X500DistinguishedName IssuerName
public string Subject
public string Issuer
public string LegacySubject
public string LegacyIssuer
public Byte[] RawData
public Byte[] Thumbprint
public IEnumerable`1<X509Extension> Extensions
public DateTime NotAfter
public DateTime NotBefore
private void EnsureCertData()
protected Byte[] GetRawCertData()
public bool get_Archived()
public void set_Archived(bool value)
public string get_KeyAlgorithm()
public Byte[] get_KeyAlgorithmParameters()
public Byte[] get_PublicKeyValue()
public Byte[] get_SerialNumber()
public string get_SignatureAlgorithm()
public string get_FriendlyName()
public void set_FriendlyName(string value)
public int get_Version()
public X500DistinguishedName get_SubjectName()
public X500DistinguishedName get_IssuerName()
public string get_Subject()
public string get_Issuer()
public string get_LegacySubject()
public string get_LegacyIssuer()
public Byte[] get_RawData()
public Byte[] get_Thumbprint()
public string GetNameInfo(X509NameType nameType, bool forIssuer)
public IEnumerable`1<X509Extension> get_Extensions()
public DateTime get_NotAfter()
public DateTime get_NotBefore()
public void AppendPrivateKeyInfo(StringBuilder sb)
public void Reset()
public Byte[] Export(X509ContentType contentType, SafePasswordHandle password)
private Byte[] ExportPkcs12(SafePasswordHandle password)
private Byte[] ExportPkcs12(string password)
}
public System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
public X509Certificate Item
public void .ctor(X509Certificate[] value)
public void .ctor(X509CertificateCollection value)
public X509Certificate get_Item(int index)
public void set_Item(int index, X509Certificate value)
public int Add(X509Certificate value)
public void AddRange(X509Certificate[] value)
public void AddRange(X509CertificateCollection value)
public bool Contains(X509Certificate value)
public void CopyTo(X509Certificate[] array, int index)
public X509CertificateEnumerator GetEnumerator()
public int GetHashCode()
public int IndexOf(X509Certificate value)
public void Insert(int index, X509Certificate value)
public void Remove(X509Certificate value)
private bool Compare(Byte[] array1, Byte[] array2)
}
internal System.Security.Cryptography.X509Certificates.X509CertificateImplCollection : object {
private List`1<X509CertificateImpl> list
public int Count
public X509CertificateImpl Item
private void .ctor(X509CertificateImplCollection other)
public int get_Count()
public X509CertificateImpl get_Item(int index)
public void Add(X509CertificateImpl impl, bool takeOwnership)
public X509CertificateImplCollection Clone()
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
public System.Security.Cryptography.X509Certificates.X509Chain : object {
private X509ChainImpl impl
internal X509ChainImpl Impl
internal bool IsValid
public IntPtr ChainContext
public X509ChainElementCollection ChainElements
public X509ChainPolicy ChainPolicy
public X509ChainStatus[] ChainStatus
public SafeX509ChainHandle SafeHandle
internal X509ChainImpl get_Impl()
internal bool get_IsValid()
internal void ThrowIfContextInvalid()
public void .ctor(bool useMachineContext)
internal void .ctor(X509ChainImpl impl)
public void .ctor(IntPtr chainContext)
public IntPtr get_ChainContext()
public X509ChainElementCollection get_ChainElements()
public X509ChainPolicy get_ChainPolicy()
public void set_ChainPolicy(X509ChainPolicy value)
public X509ChainStatus[] get_ChainStatus()
public SafeX509ChainHandle get_SafeHandle()
public bool Build(X509Certificate2 certificate)
public void Reset()
public X509Chain Create()
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
public System.Security.Cryptography.X509Certificates.X509ChainElement : object {
private X509Certificate2 certificate
private X509ChainStatus[] status
private string info
private X509ChainStatusFlags compressed_status_flags
public X509Certificate2 Certificate
public X509ChainStatus[] ChainElementStatus
public string Information
internal X509ChainStatusFlags StatusFlags
internal void .ctor(X509Certificate2 certificate)
public X509Certificate2 get_Certificate()
public X509ChainStatus[] get_ChainElementStatus()
public string get_Information()
internal X509ChainStatusFlags get_StatusFlags()
internal void set_StatusFlags(X509ChainStatusFlags value)
private int Count(X509ChainStatusFlags flags)
private void Set(X509ChainStatus[] status, Int32& position, X509ChainStatusFlags flags, X509ChainStatusFlags mask)
internal void UncompressFlags()
}
public System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public X509ChainElement Item
public object SyncRoot
public int get_Count()
public bool get_IsSynchronized()
public X509ChainElement get_Item(int index)
public object get_SyncRoot()
public void CopyTo(X509ChainElement[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public X509ChainElementEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
internal void Add(X509Certificate2 certificate)
internal void Clear()
internal bool Contains(X509Certificate2 certificate)
}
public System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
private IEnumerator enumerator
public X509ChainElement Current
private object System.Collections.IEnumerator.Current
internal void .ctor(IEnumerable enumerable)
public X509ChainElement get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
internal System.Security.Cryptography.X509Certificates.X509ChainImpl : object {
public bool IsValid
public IntPtr Handle
public X509ChainElementCollection ChainElements
public X509ChainPolicy ChainPolicy
public X509ChainStatus[] ChainStatus
public bool get_IsValid()
public IntPtr get_Handle()
protected void ThrowIfContextInvalid()
public X509ChainElementCollection get_ChainElements()
public X509ChainPolicy get_ChainPolicy()
public void set_ChainPolicy(X509ChainPolicy value)
public X509ChainStatus[] get_ChainStatus()
public bool Build(X509Certificate2 certificate)
public void AddStatus(X509ChainStatusFlags errorCode)
public void Reset()
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
}
internal System.Security.Cryptography.X509Certificates.X509ChainImplMono : X509ChainImpl {
private StoreLocation location
private X509ChainElementCollection elements
private X509ChainPolicy policy
private X509ChainStatus[] status
private X509ChainStatus[] Empty
private int max_path_length
private X500DistinguishedName working_issuer_name
private AsymmetricAlgorithm working_public_key
private X509ChainElement bce_restriction
private X509Certificate2Collection roots
private X509Certificate2Collection cas
private X509Store root_store
private X509Store ca_store
private X509Store user_root_store
private X509Store user_ca_store
private X509Certificate2Collection collection
public bool IsValid
public IntPtr Handle
public X509ChainElementCollection ChainElements
public X509ChainPolicy ChainPolicy
public X509ChainStatus[] ChainStatus
private X509Certificate2Collection Roots
private X509Certificate2Collection CertificateAuthorities
private X509Store LMRootStore
private X509Store UserRootStore
private X509Store LMCAStore
private X509Store UserCAStore
private X509Certificate2Collection CertificateCollection
public void .ctor(bool useMachineContext)
public void .ctor(IntPtr chainContext)
public bool get_IsValid()
public IntPtr get_Handle()
public X509ChainElementCollection get_ChainElements()
public X509ChainPolicy get_ChainPolicy()
public void set_ChainPolicy(X509ChainPolicy value)
public X509ChainStatus[] get_ChainStatus()
public void AddStatus(X509ChainStatusFlags error)
public bool Build(X509Certificate2 certificate)
public void Reset()
private X509Certificate2Collection get_Roots()
private X509Certificate2Collection get_CertificateAuthorities()
private X509Store get_LMRootStore()
private X509Store get_UserRootStore()
private X509Store get_LMCAStore()
private X509Store get_UserCAStore()
private X509Certificate2Collection get_CertificateCollection()
private X509ChainStatusFlags BuildChainFrom(X509Certificate2 certificate)
private X509Certificate2 SelectBestFromCollection(X509Certificate2 child, X509Certificate2Collection c)
private X509Certificate2 FindParent(X509Certificate2 certificate)
private bool IsChainComplete(X509Certificate2 certificate)
private bool IsSelfIssued(X509Certificate2 certificate)
private void ValidateChain(X509ChainStatusFlags flag)
private void Process(int n)
private void PrepareForNextCertificate(int n)
private void WrapUp()
private void ProcessCertificateExtensions(X509ChainElement element)
private bool IsSignedWith(X509Certificate2 signed, AsymmetricAlgorithm pubkey)
private string GetSubjectKeyIdentifier(X509Certificate2 certificate)
private string GetAuthorityKeyIdentifier(X509Certificate2 certificate)
private string GetAuthorityKeyIdentifier(X509Crl crl)
private string GetAuthorityKeyIdentifier(X509Extension ext)
private void CheckRevocationOnChain(X509ChainStatusFlags flag)
private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, int ca, bool online)
private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, X509Certificate2 ca_cert, bool online)
private X509Crl CheckCrls(string subject, string ski, X509Store store)
private X509Crl FindCrl(X509Certificate2 caCertificate)
private bool ProcessCrlExtensions(X509Crl crl)
private bool ProcessCrlEntryExtensions(X509CrlEntry entry)
}
public System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
private OidCollection apps
private OidCollection cert
private X509CertificateCollection store
private X509Certificate2Collection store2
private X509RevocationFlag rflag
private X509RevocationMode mode
private TimeSpan timeout
private X509VerificationFlags vflags
private DateTime vtime
public OidCollection ApplicationPolicy
public OidCollection CertificatePolicy
public X509Certificate2Collection ExtraStore
public X509RevocationFlag RevocationFlag
public X509RevocationMode RevocationMode
public TimeSpan UrlRetrievalTimeout
public X509VerificationFlags VerificationFlags
public DateTime VerificationTime
internal void .ctor(X509CertificateCollection store)
public OidCollection get_ApplicationPolicy()
public OidCollection get_CertificatePolicy()
public X509Certificate2Collection get_ExtraStore()
internal void set_ExtraStore(X509Certificate2Collection value)
public X509RevocationFlag get_RevocationFlag()
public void set_RevocationFlag(X509RevocationFlag value)
public X509RevocationMode get_RevocationMode()
public void set_RevocationMode(X509RevocationMode value)
public TimeSpan get_UrlRetrievalTimeout()
public void set_UrlRetrievalTimeout(TimeSpan value)
public X509VerificationFlags get_VerificationFlags()
public void set_VerificationFlags(X509VerificationFlags value)
public DateTime get_VerificationTime()
public void set_VerificationTime(DateTime value)
public void Reset()
}
public System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
private X509ChainStatusFlags status
private string info
public X509ChainStatusFlags Status
public string StatusInformation
internal void .ctor(X509ChainStatusFlags flag)
public X509ChainStatusFlags get_Status()
public void set_Status(X509ChainStatusFlags value)
public string get_StatusInformation()
public void set_StatusInformation(string value)
internal string GetInformation(X509ChainStatusFlags flags)
}
public System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
public int value__
public X509ChainStatusFlags NoError
public X509ChainStatusFlags NotTimeValid
public X509ChainStatusFlags NotTimeNested
public X509ChainStatusFlags Revoked
public X509ChainStatusFlags NotSignatureValid
public X509ChainStatusFlags NotValidForUsage
public X509ChainStatusFlags UntrustedRoot
public X509ChainStatusFlags RevocationStatusUnknown
public X509ChainStatusFlags Cyclic
public X509ChainStatusFlags InvalidExtension
public X509ChainStatusFlags InvalidPolicyConstraints
public X509ChainStatusFlags InvalidBasicConstraints
public X509ChainStatusFlags InvalidNameConstraints
public X509ChainStatusFlags HasNotSupportedNameConstraint
public X509ChainStatusFlags HasNotDefinedNameConstraint
public X509ChainStatusFlags HasNotPermittedNameConstraint
public X509ChainStatusFlags HasExcludedNameConstraint
public X509ChainStatusFlags PartialChain
public X509ChainStatusFlags CtlNotTimeValid
public X509ChainStatusFlags CtlNotSignatureValid
public X509ChainStatusFlags CtlNotValidForUsage
public X509ChainStatusFlags OfflineRevocation
public X509ChainStatusFlags NoIssuanceChainPolicy
public X509ChainStatusFlags ExplicitDistrust
public X509ChainStatusFlags HasNotSupportedCriticalExtension
public X509ChainStatusFlags HasWeakSignature
}
public System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
internal string oid
internal string friendlyName
private OidCollection _enhKeyUsage
private AsnDecodeStatus _status
public OidCollection EnhancedKeyUsages
public void .ctor(AsnEncodedData encodedEnhancedKeyUsages, bool critical)
public void .ctor(OidCollection enhancedKeyUsages, bool critical)
public OidCollection get_EnhancedKeyUsages()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
private bool _critical
public bool Critical
public void .ctor(AsnEncodedData encodedExtension, bool critical)
public void .ctor(Oid oid, Byte[] rawData, bool critical)
public void .ctor(string oid, Byte[] rawData, bool critical)
public bool get_Critical()
public void set_Critical(bool value)
public void CopyFrom(AsnEncodedData asnEncodedData)
internal string FormatUnkownData(Byte[] data)
}
public System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
private Byte[] Empty
private ArrayList _list
public int Count
public bool IsSynchronized
public object SyncRoot
public X509Extension Item
public X509Extension Item
internal void .ctor(X509Certificate cert)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public X509Extension get_Item(int index)
public X509Extension get_Item(string oid)
public int Add(X509Extension extension)
public void CopyTo(X509Extension[] array, int index)
private void System.Collections.ICollection.CopyTo(Array array, int index)
public X509ExtensionEnumerator GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
private IEnumerator enumerator
public X509Extension Current
private object System.Collections.IEnumerator.Current
internal void .ctor(ArrayList list)
public X509Extension get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.X509Certificates.X509FindType : Enum {
public int value__
public X509FindType FindByThumbprint
public X509FindType FindBySubjectName
public X509FindType FindBySubjectDistinguishedName
public X509FindType FindByIssuerName
public X509FindType FindByIssuerDistinguishedName
public X509FindType FindBySerialNumber
public X509FindType FindByTimeValid
public X509FindType FindByTimeNotYetValid
public X509FindType FindByTimeExpired
public X509FindType FindByTemplateName
public X509FindType FindByApplicationPolicy
public X509FindType FindByCertificatePolicy
public X509FindType FindByExtension
public X509FindType FindByKeyUsage
public X509FindType FindBySubjectKeyIdentifier
}
internal System.Security.Cryptography.X509Certificates.X509Helper2 : object {
internal X509Certificate GetMonoCertificate(X509Certificate2 certificate)
internal X509ChainImpl CreateChainImpl(bool useMachineContext)
public bool IsValid(X509ChainImpl impl)
internal void ThrowIfContextInvalid(X509ChainImpl impl)
internal Exception GetInvalidChainContextException()
internal long GetSubjectNameHash(X509Certificate certificate)
internal void ExportAsPEM(X509Certificate certificate, Stream stream, bool includeHumanReadableForm)
private MonoBtlsX509 GetNativeInstance(X509CertificateImpl impl)
}
public System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
public int value__
public X509IncludeOption None
public X509IncludeOption ExcludeRoot
public X509IncludeOption EndCertOnly
public X509IncludeOption WholeChain
}
public System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
internal string oid
internal string friendlyName
internal X509KeyUsageFlags all
private X509KeyUsageFlags _keyUsages
private AsnDecodeStatus _status
public X509KeyUsageFlags KeyUsages
public void .ctor(AsnEncodedData encodedKeyUsage, bool critical)
public void .ctor(X509KeyUsageFlags keyUsages, bool critical)
public X509KeyUsageFlags get_KeyUsages()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal X509KeyUsageFlags GetValidFlags(X509KeyUsageFlags flags)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
public int value__
public X509KeyUsageFlags None
public X509KeyUsageFlags EncipherOnly
public X509KeyUsageFlags CrlSign
public X509KeyUsageFlags KeyCertSign
public X509KeyUsageFlags KeyAgreement
public X509KeyUsageFlags DataEncipherment
public X509KeyUsageFlags KeyEncipherment
public X509KeyUsageFlags NonRepudiation
public X509KeyUsageFlags DigitalSignature
public X509KeyUsageFlags DecipherOnly
}
public System.Security.Cryptography.X509Certificates.X509NameType : Enum {
public int value__
public X509NameType SimpleName
public X509NameType EmailName
public X509NameType UpnName
public X509NameType DnsName
public X509NameType DnsFromAlternativeName
public X509NameType UrlName
}
public System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
public int value__
public X509RevocationFlag EndCertificateOnly
public X509RevocationFlag EntireChain
public X509RevocationFlag ExcludeRoot
}
public System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
public int value__
public X509RevocationMode NoCheck
public X509RevocationMode Online
public X509RevocationMode Offline
}
public System.Security.Cryptography.X509Certificates.X509SignatureGenerator : object {
public PublicKey PublicKey
public PublicKey get_PublicKey()
protected PublicKey BuildPublicKey()
public X509SignatureGenerator CreateForECDsa(ECDsa key)
public X509SignatureGenerator CreateForRSA(RSA key, RSASignaturePadding signaturePadding)
public Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm)
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm)
}
public System.Security.Cryptography.X509Certificates.X509Store : object {
private string _name
private StoreLocation _location
private X509Certificate2Collection list
private OpenFlags _flags
private X509Store store
public X509Certificate2Collection Certificates
public StoreLocation Location
public string Name
private X509Stores Factory
public bool IsOpen
private bool IsReadOnly
internal X509Store Store
public IntPtr StoreHandle
public void .ctor(string storeName)
public void .ctor(StoreName storeName)
public void .ctor(StoreLocation storeLocation)
public void .ctor(StoreName storeName, StoreLocation storeLocation)
public void .ctor(StoreName storeName, StoreLocation storeLocation, OpenFlags openFlags)
public void .ctor(string storeName, StoreLocation storeLocation, OpenFlags openFlags)
public void .ctor(IntPtr storeHandle)
public void .ctor(string storeName, StoreLocation storeLocation)
public X509Certificate2Collection get_Certificates()
public StoreLocation get_Location()
public string get_Name()
private X509Stores get_Factory()
public bool get_IsOpen()
private bool get_IsReadOnly()
internal X509Store get_Store()
public IntPtr get_StoreHandle()
public void Add(X509Certificate2 certificate)
public void AddRange(X509Certificate2Collection certificates)
public void Close()
public void Dispose()
public void Open(OpenFlags flags)
public void Remove(X509Certificate2 certificate)
public void RemoveRange(X509Certificate2Collection certificates)
private bool Exists(X509Certificate2 certificate)
}
public System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
internal string oid
internal string friendlyName
private Byte[] _subjectKeyIdentifier
private string _ski
private AsnDecodeStatus _status
public string SubjectKeyIdentifier
public void .ctor(AsnEncodedData encodedSubjectKeyIdentifier, bool critical)
public void .ctor(Byte[] subjectKeyIdentifier, bool critical)
public void .ctor(string subjectKeyIdentifier, bool critical)
public void .ctor(PublicKey key, bool critical)
public void .ctor(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical)
public string get_SubjectKeyIdentifier()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal byte FromHexChar(char c)
internal byte FromHexChars(char c1, char c2)
internal Byte[] FromHex(string hex)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
public int value__
public X509SubjectKeyIdentifierHashAlgorithm Sha1
public X509SubjectKeyIdentifierHashAlgorithm ShortSha1
public X509SubjectKeyIdentifierHashAlgorithm CapiSha1
}
public System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
public int value__
public X509VerificationFlags NoFlag
public X509VerificationFlags IgnoreNotTimeValid
public X509VerificationFlags IgnoreCtlNotTimeValid
public X509VerificationFlags IgnoreNotTimeNested
public X509VerificationFlags IgnoreInvalidBasicConstraints
public X509VerificationFlags AllowUnknownCertificateAuthority
public X509VerificationFlags IgnoreWrongUsage
public X509VerificationFlags IgnoreInvalidName
public X509VerificationFlags IgnoreInvalidPolicy
public X509VerificationFlags IgnoreEndRevocationUnknown
public X509VerificationFlags IgnoreCtlSignerRevocationUnknown
public X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown
public X509VerificationFlags IgnoreRootRevocationUnknown
public X509VerificationFlags AllFlags
}
internal System.Security.Permissions.PermissionHelper : object {
internal SecurityElement Element(Type type, int version)
internal PermissionState CheckPermissionState(PermissionState state, bool allowUnrestricted)
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
internal bool IsUnrestricted(SecurityElement se)
internal void ThrowInvalidPermission(IPermission target, Type expected)
}
public System.Security.Permissions.ResourcePermissionBase : CodeAccessPermission {
private int version
private ArrayList _list
private bool _unrestricted
private Type _type
private String[] _tags
public string Any
public string Local
private Char[] invalidChars
protected Type PermissionAccessType
protected String[] TagNames
protected void .ctor(PermissionState state)
protected Type get_PermissionAccessType()
protected void set_PermissionAccessType(Type value)
protected String[] get_TagNames()
protected void set_TagNames(String[] value)
protected void AddPermissionAccess(ResourcePermissionBaseEntry entry)
protected void Clear()
public IPermission Copy()
public void FromXml(SecurityElement securityElement)
protected ResourcePermissionBaseEntry[] GetPermissionEntries()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
protected void RemovePermissionAccess(ResourcePermissionBaseEntry entry)
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private bool IsEmpty()
private ResourcePermissionBase Cast(IPermission target)
internal void CheckEntry(ResourcePermissionBaseEntry entry)
internal bool Equals(ResourcePermissionBaseEntry entry1, ResourcePermissionBaseEntry entry2)
internal bool Exists(ResourcePermissionBaseEntry entry)
internal void ValidateMachineName(string name)
internal ResourcePermissionBase CreateFromType(Type type, bool unrestricted)
}
public System.Security.Permissions.ResourcePermissionBaseEntry : object {
private int permissionAccess
private String[] permissionAccessPath
public int PermissionAccess
public String[] PermissionAccessPath
public void .ctor(int permissionAccess, String[] permissionAccessPath)
public int get_PermissionAccess()
public String[] get_PermissionAccessPath()
}
public System.Security.Permissions.StorePermission : CodeAccessPermission {
private int version
private StorePermissionFlags _flags
public StorePermissionFlags Flags
public void .ctor(PermissionState state)
public void .ctor(StorePermissionFlags flag)
public StorePermissionFlags get_Flags()
public void set_Flags(StorePermissionFlags value)
public bool IsUnrestricted()
public IPermission Copy()
public IPermission Intersect(IPermission target)
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
private StorePermission Cast(IPermission target)
}
public System.Security.Permissions.StorePermissionAttribute : CodeAccessSecurityAttribute {
private StorePermissionFlags _flags
public StorePermissionFlags Flags
public bool AddToStore
public bool CreateStore
public bool DeleteStore
public bool EnumerateCertificates
public bool EnumerateStores
public bool OpenStore
public bool RemoveFromStore
public void .ctor(SecurityAction action)
public StorePermissionFlags get_Flags()
public void set_Flags(StorePermissionFlags value)
public bool get_AddToStore()
public void set_AddToStore(bool value)
public bool get_CreateStore()
public void set_CreateStore(bool value)
public bool get_DeleteStore()
public void set_DeleteStore(bool value)
public bool get_EnumerateCertificates()
public void set_EnumerateCertificates(bool value)
public bool get_EnumerateStores()
public void set_EnumerateStores(bool value)
public bool get_OpenStore()
public void set_OpenStore(bool value)
public bool get_RemoveFromStore()
public void set_RemoveFromStore(bool value)
public IPermission CreatePermission()
}
public System.Security.Permissions.StorePermissionFlags : Enum {
public int value__
public StorePermissionFlags NoFlags
public StorePermissionFlags CreateStore
public StorePermissionFlags DeleteStore
public StorePermissionFlags EnumerateStores
public StorePermissionFlags OpenStore
public StorePermissionFlags AddToStore
public StorePermissionFlags RemoveFromStore
public StorePermissionFlags EnumerateCertificates
public StorePermissionFlags AllFlags
}
public System.Security.Permissions.TypeDescriptorPermission : CodeAccessPermission {
private TypeDescriptorPermissionFlags m_flags
public TypeDescriptorPermissionFlags Flags
public void .ctor(PermissionState state)
public void .ctor(TypeDescriptorPermissionFlags flag)
private void SetUnrestricted(bool unrestricted)
private void Reset()
public void set_Flags(TypeDescriptorPermissionFlags value)
public TypeDescriptorPermissionFlags get_Flags()
public bool IsUnrestricted()
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Intersect(IPermission target)
public IPermission Copy()
private void VerifyAccess(TypeDescriptorPermissionFlags type)
public SecurityElement ToXml()
public void FromXml(SecurityElement securityElement)
internal void VerifyFlags(TypeDescriptorPermissionFlags flags)
}
public System.Security.Permissions.TypeDescriptorPermissionAttribute : CodeAccessSecurityAttribute {
public TypeDescriptorPermissionFlags Flags
public bool RestrictedRegistrationAccess
public void .ctor(SecurityAction action)
public TypeDescriptorPermissionFlags get_Flags()
public void set_Flags(TypeDescriptorPermissionFlags value)
public bool get_RestrictedRegistrationAccess()
public void set_RestrictedRegistrationAccess(bool value)
public IPermission CreatePermission()
}
public System.Security.Permissions.TypeDescriptorPermissionFlags : Enum {
public int value__
public TypeDescriptorPermissionFlags NoFlags
public TypeDescriptorPermissionFlags RestrictedRegistrationAccess
}
public System.Security.SecureStringMarshal : object {
public IntPtr SecureStringToCoTaskMemAnsi(SecureString s)
public IntPtr SecureStringToGlobalAllocAnsi(SecureString s)
public IntPtr SecureStringToCoTaskMemUnicode(SecureString s)
public IntPtr SecureStringToGlobalAllocUnicode(SecureString s)
}
internal System.SecurityUtils : object {
private ReflectionPermission modreq(System.Runtime.CompilerServices.IsVolatile) memberAccessPermission
private ReflectionPermission modreq(System.Runtime.CompilerServices.IsVolatile) restrictedMemberAccessPermission
private ReflectionPermission MemberAccessPermission
private ReflectionPermission RestrictedMemberAccessPermission
private ReflectionPermission get_MemberAccessPermission()
private ReflectionPermission get_RestrictedMemberAccessPermission()
private void DemandReflectionAccess(Type type)
private void DemandGrantSet(Assembly assembly)
private bool HasReflectionPermission(Type type)
internal object SecureCreateInstance(Type type)
internal object SecureCreateInstance(Type type, Object[] args, bool allowNonPublic)
internal object SecureCreateInstance(Type type, Object[] args)
internal object SecureConstructorInvoke(Type type, Type[] argTypes, Object[] args, bool allowNonPublic)
internal object SecureConstructorInvoke(Type type, Type[] argTypes, Object[] args, bool allowNonPublic, BindingFlags extraFlags)
private bool GenericArgumentsAreVisible(MethodInfo method)
internal object FieldInfoGetValue(FieldInfo field, object target)
internal object MethodInfoInvoke(MethodInfo method, object target, Object[] args)
internal object ConstructorInfoInvoke(ConstructorInfo ctor, Object[] args)
internal object ArrayCreateInstance(Type type, int length)
}
internal System.SRDescriptionAttribute : DescriptionAttribute {
private bool isReplaced
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.StringExtensions : object {
internal string SubstringTrim(string value, int startIndex)
internal string SubstringTrim(string value, int startIndex, int length)
}
public System.StringNormalizationExtensions : object {
public bool IsNormalized(string strInput)
public bool IsNormalized(string strInput, NormalizationForm normalizationForm)
public string Normalize(string strInput)
public string Normalize(string strInput, NormalizationForm normalizationForm)
}
public System.Text.RegularExpressions.Capture : object {
private int <Index>k__BackingField
private int <Length>k__BackingField
private string <Text>k__BackingField
public int Index
public int Length
internal string Text
public string Value
internal void .ctor(string text, int index, int length)
public int get_Index()
private protected void set_Index(int value)
public int get_Length()
private protected void set_Length(int value)
internal string get_Text()
private protected void set_Text(string value)
public string get_Value()
public string ToString()
internal ReadOnlySpan`1<char> GetLeftSubstring()
internal ReadOnlySpan`1<char> GetRightSubstring()
}
public System.Text.RegularExpressions.CaptureCollection : object {
private Group _group
private int _capcount
private Capture[] _captures
public bool IsReadOnly
public int Count
public Capture Item
public bool IsSynchronized
public object SyncRoot
private Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Item
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
internal void .ctor(Group group)
public bool get_IsReadOnly()
public int get_Count()
public Capture get_Item(int i)
public IEnumerator GetEnumerator()
private IEnumerator`1<Capture> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Capture>.GetEnumerator()
private Capture GetCapture(int i)
internal void ForceInitialized()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int arrayIndex)
public void CopyTo(Capture[] array, int arrayIndex)
private int System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.IndexOf(Capture item)
private void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Insert(int index, Capture item)
private void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.RemoveAt(int index)
private Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.get_Item(int index)
private void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.set_Item(int index, Capture value)
private void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Add(Capture item)
private void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Clear()
private bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Contains(Capture item)
private bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Remove(Capture item)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsFixedSize()
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
}
internal System.Text.RegularExpressions.CollectionDebuggerProxy`1 : object {
private ICollection`1<T> _collection
public T[] Items
public void .ctor(ICollection`1<T> collection)
public T[] get_Items()
}
internal System.Text.RegularExpressions.CompiledRegexRunner : RegexRunner {
private Action`1<RegexRunner> _goMethod
private Func`2<RegexRunner, bool> _findFirstCharMethod
private Action`1<RegexRunner> _initTrackCountMethod
public void SetDelegates(Action`1<RegexRunner> go, Func`2<RegexRunner, bool> firstChar, Action`1<RegexRunner> trackCount)
protected void Go()
protected bool FindFirstChar()
protected void InitTrackCount()
}
internal System.Text.RegularExpressions.CompiledRegexRunnerFactory : RegexRunnerFactory {
private DynamicMethod _goMethod
private DynamicMethod _findFirstCharMethod
private DynamicMethod _initTrackCountMethod
public void .ctor(DynamicMethod go, DynamicMethod firstChar, DynamicMethod trackCount)
protected internal RegexRunner CreateInstance()
}
internal System.Text.RegularExpressions.ExclusiveReference : object {
private RegexRunner _ref
private RegexRunner _obj
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _locked
public RegexRunner Get()
public void Release(RegexRunner obj)
}
public System.Text.RegularExpressions.Group : Capture {
internal Group s_emptyGroup
internal Int32[] _caps
internal int _capcount
internal CaptureCollection _capcoll
private string <Name>k__BackingField
public bool Success
public string Name
public CaptureCollection Captures
internal void .ctor(string text, Int32[] caps, int capcount, string name)
public bool get_Success()
public string get_Name()
public CaptureCollection get_Captures()
public Group Synchronized(Group inner)
}
public System.Text.RegularExpressions.GroupCollection : object {
private Match _match
private Hashtable _captureMap
private Group[] _groups
public bool IsReadOnly
public int Count
public Group Item
public Group Item
public bool IsSynchronized
public object SyncRoot
private Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Item
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
internal void .ctor(Match match, Hashtable caps)
public bool get_IsReadOnly()
public int get_Count()
public Group get_Item(int groupnum)
public Group get_Item(string groupname)
public IEnumerator GetEnumerator()
private IEnumerator`1<Group> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Group>.GetEnumerator()
private Group GetGroup(int groupnum)
private Group GetGroupImpl(int groupnum)
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int arrayIndex)
public void CopyTo(Group[] array, int arrayIndex)
private int System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.IndexOf(Group item)
private void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Insert(int index, Group item)
private void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.RemoveAt(int index)
private Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.get_Item(int index)
private void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.set_Item(int index, Group value)
private void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Add(Group item)
private void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Clear()
private bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Contains(Group item)
private bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Remove(Group item)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsFixedSize()
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
}
public System.Text.RegularExpressions.Match : Group {
internal GroupCollection _groupcoll
internal Regex _regex
internal int _textbeg
internal int _textpos
internal int _textend
internal int _textstart
internal Int32[][] _matches
internal Int32[] _matchcount
internal bool _balancing
private Match <Empty>k__BackingField
public Match Empty
public GroupCollection Groups
internal void .ctor(Regex regex, int capcount, string text, int begpos, int len, int startpos)
public Match get_Empty()
internal void Reset(Regex regex, string text, int textbeg, int textend, int textstart)
public GroupCollection get_Groups()
public Match NextMatch()
public string Result(string replacement)
internal ReadOnlySpan`1<char> GroupToStringImpl(int groupnum)
internal ReadOnlySpan`1<char> LastGroupToStringImpl()
public Match Synchronized(Match inner)
internal void AddMatch(int cap, int start, int len)
internal void BalanceMatch(int cap)
internal void RemoveMatch(int cap)
internal bool IsMatched(int cap)
internal int MatchIndex(int cap)
internal int MatchLength(int cap)
internal void Tidy(int textpos)
}
public System.Text.RegularExpressions.MatchCollection : object {
private Regex _regex
private List`1<Match> _matches
private bool _done
private string _input
private int _beginning
private int _length
private int _startat
private int _prevlen
public bool IsReadOnly
public int Count
public Match Item
public bool IsSynchronized
public object SyncRoot
private Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Item
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
internal void .ctor(Regex regex, string input, int beginning, int length, int startat)
public bool get_IsReadOnly()
public int get_Count()
public Match get_Item(int i)
public IEnumerator GetEnumerator()
private IEnumerator`1<Match> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Match>.GetEnumerator()
private Match GetMatch(int i)
private void EnsureInitialized()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int arrayIndex)
public void CopyTo(Match[] array, int arrayIndex)
private int System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.IndexOf(Match item)
private void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Insert(int index, Match item)
private void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.RemoveAt(int index)
private Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.get_Item(int index)
private void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.set_Item(int index, Match value)
private void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Add(Match item)
private void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Clear()
private bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Contains(Match item)
private bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Remove(Match item)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private bool System.Collections.IList.get_IsFixedSize()
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
}
public System.Text.RegularExpressions.MatchEvaluator : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public string Invoke(Match match)
public IAsyncResult BeginInvoke(Match match, AsyncCallback callback, object object)
public string EndInvoke(IAsyncResult result)
}
internal System.Text.RegularExpressions.MatchSparse : Match {
internal Hashtable _caps
public GroupCollection Groups
internal void .ctor(Regex regex, Hashtable caps, int capcount, string text, int begpos, int len, int startpos)
public GroupCollection get_Groups()
}
public System.Text.RegularExpressions.Regex : object {
private int CacheDictionarySwitchLimit
private int s_cacheSize
private Dictionary`2<CachedCodeEntryKey, CachedCodeEntry> s_cache
private int s_cacheCount
private CachedCodeEntry s_cacheFirst
private CachedCodeEntry s_cacheLast
private TimeSpan s_maximumMatchTimeout
private string DefaultMatchTimeout_ConfigKeyName
internal TimeSpan s_defaultMatchTimeout
public TimeSpan InfiniteMatchTimeout
protected internal TimeSpan internalMatchTimeout
internal int MaxOptionShift
protected internal string pattern
protected internal RegexOptions roptions
protected internal RegexRunnerFactory factory
protected internal Hashtable caps
protected internal Hashtable capnames
protected internal String[] capslist
protected internal int capsize
internal ExclusiveReference _runnerref
internal WeakReference`1<RegexReplacement> _replref
internal RegexCode _code
internal bool _refsInitialized
public int CacheSize
public TimeSpan MatchTimeout
protected IDictionary Caps
protected IDictionary CapNames
public RegexOptions Options
public bool RightToLeft
public int get_CacheSize()
public void set_CacheSize(int value)
private CachedCodeEntry GetCachedCode(CachedCodeEntryKey key, bool isToAdd)
private CachedCodeEntry GetCachedCodeEntryInternal(CachedCodeEntryKey key, bool isToAdd)
private void FillCacheDictionary()
private bool TryGetCacheValue(CachedCodeEntryKey key, CachedCodeEntry& entry)
private bool TryGetCacheValueSmall(CachedCodeEntryKey key, CachedCodeEntry& entry)
private CachedCodeEntry LookupCachedAndPromote(CachedCodeEntryKey key)
public bool IsMatch(string input, string pattern)
public bool IsMatch(string input, string pattern, RegexOptions options)
public bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
public bool IsMatch(string input)
public bool IsMatch(string input, int startat)
public Match Match(string input, string pattern)
public Match Match(string input, string pattern, RegexOptions options)
public Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
public Match Match(string input)
public Match Match(string input, int startat)
public Match Match(string input, int beginning, int length)
public MatchCollection Matches(string input, string pattern)
public MatchCollection Matches(string input, string pattern, RegexOptions options)
public MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
public MatchCollection Matches(string input)
public MatchCollection Matches(string input, int startat)
public string Replace(string input, string pattern, string replacement)
public string Replace(string input, string pattern, string replacement, RegexOptions options)
public string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout)
public string Replace(string input, string replacement)
public string Replace(string input, string replacement, int count)
public string Replace(string input, string replacement, int count, int startat)
public string Replace(string input, string pattern, MatchEvaluator evaluator)
public string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options)
public string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout)
public string Replace(string input, MatchEvaluator evaluator)
public string Replace(string input, MatchEvaluator evaluator, int count)
public string Replace(string input, MatchEvaluator evaluator, int count, int startat)
private string Replace(MatchEvaluator evaluator, Regex regex, string input, int count, int startat)
public String[] Split(string input, string pattern)
public String[] Split(string input, string pattern, RegexOptions options)
public String[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
public String[] Split(string input)
public String[] Split(string input, int count)
public String[] Split(string input, int count, int startat)
private String[] Split(Regex regex, string input, int count, int startat)
public TimeSpan get_MatchTimeout()
protected internal void ValidateMatchTimeout(TimeSpan matchTimeout)
private TimeSpan InitDefaultMatchTimeout()
public void .ctor(string pattern)
public void .ctor(string pattern, RegexOptions options)
public void .ctor(string pattern, RegexOptions options, TimeSpan matchTimeout)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
private void .ctor(string pattern, RegexOptions options, TimeSpan matchTimeout, bool addToCache)
protected IDictionary get_Caps()
protected void set_Caps(IDictionary value)
protected IDictionary get_CapNames()
protected void set_CapNames(IDictionary value)
private RegexRunnerFactory Compile(RegexCode code, RegexOptions roptions)
public void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname)
public void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes)
public void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile)
public string Escape(string str)
public string Unescape(string str)
public RegexOptions get_Options()
public bool get_RightToLeft()
public string ToString()
public String[] GetGroupNames()
public Int32[] GetGroupNumbers()
public string GroupNameFromNumber(int i)
public int GroupNumberFromName(string name)
protected void InitializeReferences()
internal Match Run(bool quick, int prevlen, string input, int beginning, int length, int startat)
protected bool UseOptionC()
protected internal bool UseOptionR()
internal bool UseOptionInvariant()
}
internal System.Text.RegularExpressions.RegexBoyerMoore : object {
public Int32[] Positive
public Int32[] NegativeASCII
public Int32[][] NegativeUnicode
public string Pattern
public int LowASCII
public int HighASCII
public bool RightToLeft
public bool CaseInsensitive
private CultureInfo _culture
public void .ctor(string pattern, bool caseInsensitive, bool rightToLeft, CultureInfo culture)
private bool MatchPattern(string text, int index)
public bool IsMatch(string text, int index, int beglimit, int endlimit)
public int Scan(string text, int index, int beglimit, int endlimit)
}
internal System.Text.RegularExpressions.RegexCharClass : object {
private int FLAGS
private int SETLENGTH
private int CATEGORYLENGTH
private int SETSTART
private string NullCharString
private char NullChar
private char LastChar
private char GroupChar
private short SpaceConst
private short NotSpaceConst
private char ZeroWidthJoiner
private char ZeroWidthNonJoiner
private string s_internalRegexIgnoreCase
private string s_space
private string s_notSpace
private string s_word
private string s_notWord
public string SpaceClass
public string NotSpaceClass
public string WordClass
public string NotWordClass
public string DigitClass
public string NotDigitClass
private string ECMASpaceSet
private string NotECMASpaceSet
private string ECMAWordSet
private string NotECMAWordSet
private string ECMADigitSet
private string NotECMADigitSet
public string ECMASpaceClass
public string NotECMASpaceClass
public string ECMAWordClass
public string NotECMAWordClass
public string ECMADigitClass
public string NotECMADigitClass
public string AnyClass
public string EmptyClass
private int DefinedCategoriesCapacity
private Dictionary`2<string, string> s_definedCategories
private String[][] s_propTable
private int LowercaseSet
private int LowercaseAdd
private int LowercaseBor
private int LowercaseBad
private LowerCaseMapping[] s_lcTable
private List`1<SingleRange> _rangelist
private StringBuilder _categories
private bool _canonical
private bool _negate
private RegexCharClass _subtractor
public bool CanMerge
public bool Negate
private void .ctor(bool negate, List`1<SingleRange> ranges, StringBuilder categories, RegexCharClass subtraction)
public bool get_CanMerge()
public void set_Negate(bool value)
public void AddChar(char c)
public void AddCharClass(RegexCharClass cc)
private void AddSet(string set)
public void AddSubtraction(RegexCharClass sub)
public void AddRange(char first, char last)
public void AddCategoryFromName(string categoryName, bool invert, bool caseInsensitive, string pattern)
private void AddCategory(string category)
public void AddLowercase(CultureInfo culture)
private void AddLowercaseRange(char chMin, char chMax, CultureInfo culture)
public void AddWord(bool ecma, bool negate)
public void AddSpace(bool ecma, bool negate)
public void AddDigit(bool ecma, bool negate, string pattern)
public string ConvertOldStringsToClass(string set, string category)
public char SingletonChar(string set)
public bool IsMergeable(string charClass)
public bool IsEmpty(string charClass)
public bool IsSingleton(string set)
public bool IsSingletonInverse(string set)
private bool IsSubtraction(string charClass)
private bool IsNegated(string set)
public bool IsECMAWordChar(char ch)
public bool IsWordChar(char ch)
public bool CharInClass(char ch, string set)
private bool CharInClassRecursive(char ch, string set, int start)
private bool CharInClassInternal(char ch, string set, int start, int mySetLength, int myCategoryLength)
private bool CharInCategory(char ch, string set, int start, int mySetLength, int myCategoryLength)
private bool CharInCategoryGroup(char ch, UnicodeCategory chcategory, string category, Int32& i)
private string NegateCategory(string category)
public RegexCharClass Parse(string charClass)
private RegexCharClass ParseRecursive(string charClass, int start)
private int RangeCount()
public string ToStringClass()
private SingleRange GetRangeAt(int i)
private void Canonicalize()
private string SetFromProperty(string capname, bool invert, string pattern)
}
internal System.Text.RegularExpressions.RegexCode : object {
public int Onerep
public int Notonerep
public int Setrep
public int Oneloop
public int Notoneloop
public int Setloop
public int Onelazy
public int Notonelazy
public int Setlazy
public int One
public int Notone
public int Set
public int Multi
public int Ref
public int Bol
public int Eol
public int Boundary
public int Nonboundary
public int Beginning
public int Start
public int EndZ
public int End
public int Nothing
public int Lazybranch
public int Branchmark
public int Lazybranchmark
public int Nullcount
public int Setcount
public int Branchcount
public int Lazybranchcount
public int Nullmark
public int Setmark
public int Capturemark
public int Getmark
public int Setjump
public int Backjump
public int Forejump
public int Testref
public int Goto
public int Prune
public int Stop
public int ECMABoundary
public int NonECMABoundary
public int Mask
public int Rtl
public int Back
public int Back2
public int Ci
public Int32[] Codes
public String[] Strings
public int TrackCount
public Hashtable Caps
public int CapSize
public Nullable`1<RegexPrefix> FCPrefix
public RegexBoyerMoore BMPrefix
public int Anchors
public bool RightToLeft
public void .ctor(Int32[] codes, List`1<string> stringlist, int trackcount, Hashtable caps, int capsize, RegexBoyerMoore bmPrefix, Nullable`1<RegexPrefix> fcPrefix, int anchors, bool rightToLeft)
public bool OpcodeBacktracks(int Op)
public int OpcodeSize(int opcode)
}
public System.Text.RegularExpressions.RegexCompilationInfo : object {
private string _pattern
private string _name
private string _nspace
private TimeSpan _matchTimeout
private bool <IsPublic>k__BackingField
private RegexOptions <Options>k__BackingField
public bool IsPublic
public TimeSpan MatchTimeout
public string Name
public string Namespace
public RegexOptions Options
public string Pattern
public void .ctor(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic)
public void .ctor(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic, TimeSpan matchTimeout)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public TimeSpan get_MatchTimeout()
public void set_MatchTimeout(TimeSpan value)
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public RegexOptions get_Options()
public void set_Options(RegexOptions value)
public string get_Pattern()
public void set_Pattern(string value)
}
internal System.Text.RegularExpressions.RegexCompiler : object {
private FieldInfo s_textbegF
private FieldInfo s_textendF
private FieldInfo s_textstartF
private FieldInfo s_textposF
private FieldInfo s_textF
private FieldInfo s_trackposF
private FieldInfo s_trackF
private FieldInfo s_stackposF
private FieldInfo s_stackF
private FieldInfo s_trackcountF
private MethodInfo s_ensurestorageM
private MethodInfo s_captureM
private MethodInfo s_transferM
private MethodInfo s_uncaptureM
private MethodInfo s_ismatchedM
private MethodInfo s_matchlengthM
private MethodInfo s_matchindexM
private MethodInfo s_isboundaryM
private MethodInfo s_isECMABoundaryM
private MethodInfo s_chartolowerM
private MethodInfo s_getcharM
private MethodInfo s_crawlposM
private MethodInfo s_charInSetM
private MethodInfo s_getCurrentCulture
private MethodInfo s_getInvariantCulture
private MethodInfo s_checkTimeoutM
protected ILGenerator _ilg
private LocalBuilder _textstartV
private LocalBuilder _textbegV
private LocalBuilder _textendV
private LocalBuilder _textposV
private LocalBuilder _textV
private LocalBuilder _trackposV
private LocalBuilder _trackV
private LocalBuilder _stackposV
private LocalBuilder _stackV
private LocalBuilder _tempV
private LocalBuilder _temp2V
private LocalBuilder _temp3V
protected RegexCode _code
protected Int32[] _codes
protected String[] _strings
protected Nullable`1<RegexPrefix> _fcPrefix
protected RegexBoyerMoore _bmPrefix
protected int _anchors
private Label[] _labels
private BacktrackNote[] _notes
private int _notecount
protected int _trackcount
private Label _backtrack
private int _regexopcode
private int _codepos
private int _backpos
protected RegexOptions _options
private Int32[] _uniquenote
private Int32[] _goto
private int Stackpop
private int Stackpop2
private int Stackpop3
private int Capback
private int Capback2
private int Branchmarkback2
private int Lazybranchmarkback2
private int Branchcountback2
private int Lazybranchcountback2
private int Forejumpback
private int Uniquecount
private FieldInfo RegexRunnerField(string fieldname)
private MethodInfo RegexRunnerMethod(string methname)
internal RegexRunnerFactory Compile(RegexCode code, RegexOptions options)
private int AddBacktrackNote(int flags, Label l, int codepos)
private int AddTrack()
private int AddTrack(int flags)
private int AddGoto(int destpos)
private int AddUniqueTrack(int i)
private int AddUniqueTrack(int i, int flags)
private Label DefineLabel()
private void MarkLabel(Label l)
private int Operand(int i)
private bool IsRtl()
private bool IsCi()
private int Code()
private void Ldstr(string str)
private void Ldc(int i)
private void LdcI8(long i)
private void Dup()
private void Ret()
private void Pop()
private void Add()
private void Add(bool negate)
private void Sub()
private void Sub(bool negate)
private void Ldloc(LocalBuilder lt)
private void Stloc(LocalBuilder lt)
private void Ldthis()
private void Ldthisfld(FieldInfo ft)
private void Mvfldloc(FieldInfo ft, LocalBuilder lt)
private void Mvlocfld(LocalBuilder lt, FieldInfo ft)
private void Stfld(FieldInfo ft)
private void Callvirt(MethodInfo mt)
private void Call(MethodInfo mt)
private void Newobj(ConstructorInfo ct)
private void BrfalseFar(Label l)
private void BrtrueFar(Label l)
private void BrFar(Label l)
private void BleFar(Label l)
private void BltFar(Label l)
private void BgeFar(Label l)
private void BgtFar(Label l)
private void BneFar(Label l)
private void BeqFar(Label l)
private void Brfalse(Label l)
private void Br(Label l)
private void Ble(Label l)
private void Blt(Label l)
private void Bge(Label l)
private void Bgt(Label l)
private void Bgtun(Label l)
private void Bne(Label l)
private void Beq(Label l)
private void Ldlen()
private void Rightchar()
private void Rightcharnext()
private void Leftchar()
private void Leftcharnext()
private void Track()
private void Trackagain()
private void PushTrack(LocalBuilder lt)
private void TrackUnique(int i)
private void TrackUnique2(int i)
private void ReadyPushTrack()
private void PopTrack()
private void TopTrack()
private void PushStack(LocalBuilder lt)
internal void ReadyReplaceStack(int i)
private void ReadyPushStack()
private void TopStack()
private void PopStack()
private void PopDiscardStack()
private void PopDiscardStack(int i)
private void DoReplace()
private void DoPush()
private void Back()
private void Goto(int i)
private int NextCodepos()
private Label AdvanceLabel()
private void Advance()
private void CallToLower()
private void GenerateForwardSection()
private void GenerateMiddleSection()
private void GenerateBacktrackSection()
protected void GenerateFindFirstChar()
protected void GenerateInitTrackCount()
private LocalBuilder DeclareInt()
private LocalBuilder DeclareIntArray()
private LocalBuilder DeclareString()
protected void GenerateGo()
private void GenerateOneCode()
}
internal System.Text.RegularExpressions.RegexFC : object {
private RegexCharClass _cc
public bool _nullable
private bool <CaseInsensitive>k__BackingField
public bool CaseInsensitive
public void .ctor(bool nullable)
public void .ctor(char ch, bool not, bool nullable, bool caseInsensitive)
public void .ctor(string charClass, bool nullable, bool caseInsensitive)
public bool AddFC(RegexFC fc, bool concatenate)
public bool get_CaseInsensitive()
private void set_CaseInsensitive(bool value)
public string GetFirstChars(CultureInfo culture)
}
internal System.Text.RegularExpressions.RegexFCD : ValueType {
private int StackBufferSize
private int BeforeChild
private int AfterChild
public int Beginning
public int Bol
public int Start
public int Eol
public int EndZ
public int End
public int Boundary
public int ECMABoundary
private List`1<RegexFC> _fcStack
private ValueListBuilder`1<int> _intStack
private bool _skipAllChildren
private bool _skipchild
private bool _failed
private void .ctor(Span`1<int> intStack)
public Nullable`1<RegexPrefix> FirstChars(RegexTree t)
public RegexPrefix Prefix(RegexTree tree)
public int Anchors(RegexTree tree)
private int AnchorFromType(int type)
private void PushInt(int i)
private bool IntIsEmpty()
private int PopInt()
private void PushFC(RegexFC fc)
private bool FCIsEmpty()
private RegexFC PopFC()
private RegexFC TopFC()
public void Dispose()
private RegexFC RegexFCFromRegexTree(RegexTree tree)
private void SkipChild()
private void CalculateFC(int NodeType, RegexNode node, int CurIndex)
}
internal System.Text.RegularExpressions.RegexInterpreter : RegexRunner {
private RegexCode _code
private CultureInfo _culture
private int _operator
private int _codepos
private bool _rightToLeft
private bool _caseInsensitive
public void .ctor(RegexCode code, CultureInfo culture)
protected void InitTrackCount()
private void Advance(int i)
private void Goto(int newpos)
private void Textto(int newpos)
private void Trackto(int newpos)
private int Textstart()
private int Textpos()
private int Trackpos()
private void TrackPush()
private void TrackPush(int I1)
private void TrackPush(int I1, int I2)
private void TrackPush(int I1, int I2, int I3)
private void TrackPush2(int I1)
private void TrackPush2(int I1, int I2)
private void Backtrack()
private void SetOperator(int op)
private void TrackPop()
private void TrackPop(int framesize)
private int TrackPeek()
private int TrackPeek(int i)
private void StackPush(int I1)
private void StackPush(int I1, int I2)
private void StackPop()
private void StackPop(int framesize)
private int StackPeek()
private int StackPeek(int i)
private int Operator()
private int Operand(int i)
private int Leftchars()
private int Rightchars()
private int Bump()
private int Forwardchars()
private char Forwardcharnext()
private bool Stringmatch(string str)
private bool Refmatch(int index, int len)
private void Backwardnext()
private char CharAt(int j)
protected bool FindFirstChar()
protected void Go()
}
internal System.Text.RegularExpressions.RegexLWCGCompiler : RegexCompiler {
private int s_regexCount
private Type[] s_paramTypes
public RegexRunnerFactory FactoryInstanceFromCode(RegexCode code, RegexOptions options)
public DynamicMethod DefineDynamicMethod(string methname, Type returntype, Type hostType)
}
public System.Text.RegularExpressions.RegexMatchTimeoutException : TimeoutException {
private string <Input>k__BackingField
private string <Pattern>k__BackingField
private TimeSpan <MatchTimeout>k__BackingField
public string Input
public string Pattern
public TimeSpan MatchTimeout
public void .ctor(string regexInput, string regexPattern, TimeSpan matchTimeout)
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public string get_Input()
public string get_Pattern()
public TimeSpan get_MatchTimeout()
}
internal System.Text.RegularExpressions.RegexNode : object {
public int Oneloop
public int Notoneloop
public int Setloop
public int Onelazy
public int Notonelazy
public int Setlazy
public int One
public int Notone
public int Set
public int Multi
public int Ref
public int Bol
public int Eol
public int Boundary
public int Nonboundary
public int ECMABoundary
public int NonECMABoundary
public int Beginning
public int Start
public int EndZ
public int End
public int Nothing
public int Empty
public int Alternate
public int Concatenate
public int Loop
public int Lazyloop
public int Capture
public int Group
public int Require
public int Prevent
public int Greedy
public int Testref
public int Testgroup
public int NType
public List`1<RegexNode> Children
public string Str
public char Ch
public int M
public int N
public RegexOptions Options
public RegexNode Next
public void .ctor(int type, RegexOptions options)
public void .ctor(int type, RegexOptions options, char ch)
public void .ctor(int type, RegexOptions options, string str)
public void .ctor(int type, RegexOptions options, int m)
public void .ctor(int type, RegexOptions options, int m, int n)
public bool UseOptionR()
public RegexNode ReverseLeft()
private void MakeRep(int type, int min, int max)
private RegexNode Reduce()
private RegexNode StripEnation(int emptyType)
private RegexNode ReduceGroup()
private RegexNode ReduceRep()
private RegexNode ReduceSet()
private RegexNode ReduceAlternation()
private RegexNode ReduceConcatenation()
public RegexNode MakeQuantifier(bool lazy, int min, int max)
public void AddChild(RegexNode newChild)
public RegexNode Child(int i)
public int ChildCount()
public int Type()
}
public System.Text.RegularExpressions.RegexOptions : Enum {
public int value__
public RegexOptions None
public RegexOptions IgnoreCase
public RegexOptions Multiline
public RegexOptions ExplicitCapture
public RegexOptions Compiled
public RegexOptions Singleline
public RegexOptions IgnorePatternWhitespace
public RegexOptions RightToLeft
public RegexOptions ECMAScript
public RegexOptions CultureInvariant
}
internal System.Text.RegularExpressions.RegexParser : object {
private int MaxValueDiv10
private int MaxValueMod10
private RegexNode _stack
private RegexNode _group
private RegexNode _alternation
private RegexNode _concatenation
private RegexNode _unit
private string _pattern
private int _currentPos
private CultureInfo _culture
private int _autocap
private int _capcount
private int _captop
private int _capsize
private Hashtable _caps
private Hashtable _capnames
private Int32[] _capnumlist
private List`1<string> _capnamelist
private RegexOptions _options
private List`1<RegexOptions> _optionsStack
private bool _ignoreNextParen
private byte Q
private byte S
private byte Z
private byte X
private byte E
private Byte[] s_category
public RegexTree Parse(string re, RegexOptions op)
public RegexReplacement ParseReplacement(string rep, Hashtable caps, int capsize, Hashtable capnames, RegexOptions op)
public string Escape(string input)
public string Unescape(string input)
private void .ctor(CultureInfo culture)
private void SetPattern(string Re)
private void Reset(RegexOptions topopts)
private RegexNode ScanRegex()
private RegexNode ScanReplacement()
private RegexCharClass ScanCharClass(bool caseInsensitive, bool scanOnly)
private RegexNode ScanGroupOpen()
private void ScanBlank()
private RegexNode ScanBackslash(bool scanOnly)
private RegexNode ScanBasicBackslash(bool scanOnly)
private RegexNode ScanDollar()
private string ScanCapname()
private char ScanOctal()
private int ScanDecimal()
private char ScanHex(int c)
private int HexDigit(char ch)
private char ScanControl()
private bool IsOnlyTopOption(RegexOptions option)
private void ScanOptions()
private char ScanCharEscape()
private string ParseProperty()
private int TypeFromCode(char ch)
private RegexOptions OptionFromCode(char ch)
private void CountCaptures()
private void NoteCaptureSlot(int i, int pos)
private void NoteCaptureName(string name, int pos)
private void NoteCaptures(Hashtable caps, int capsize, Hashtable capnames)
private void AssignNameSlots()
private int CaptureSlotFromName(string capname)
private bool IsCaptureSlot(int i)
private bool IsCaptureName(string capname)
private bool UseOptionN()
private bool UseOptionI()
private bool UseOptionM()
private bool UseOptionS()
private bool UseOptionX()
private bool UseOptionE()
private bool IsSpecial(char ch)
private bool IsStopperX(char ch)
private bool IsQuantifier(char ch)
private bool IsTrueQuantifier()
private bool IsSpace(char ch)
private bool IsMetachar(char ch)
private void AddConcatenate(int pos, int cch, bool isReplacement)
private void PushGroup()
private void PopGroup()
private bool EmptyStack()
private void StartGroup(RegexNode openGroup)
private void AddAlternate()
private void AddConcatenate()
private void AddConcatenate(bool lazy, int min, int max)
private RegexNode Unit()
private void AddUnitOne(char ch)
private void AddUnitNotone(char ch)
private void AddUnitSet(string cc)
private void AddUnitNode(RegexNode node)
private void AddUnitType(int type)
private void AddGroup()
private void PushOptions()
private void PopOptions()
private bool EmptyOptionsStack()
private void PopKeepOptions()
private ArgumentException MakeException(string message)
private int Textpos()
private void Textto(int pos)
private char RightCharMoveRight()
private void MoveRight()
private void MoveRight(int i)
private void MoveLeft()
private char CharAt(int i)
internal char RightChar()
private char RightChar(int i)
private int CharsRight()
}
internal System.Text.RegularExpressions.RegexPrefix : ValueType {
private bool <CaseInsensitive>k__BackingField
private RegexPrefix <Empty>k__BackingField
private string <Prefix>k__BackingField
internal bool CaseInsensitive
internal RegexPrefix Empty
internal string Prefix
internal void .ctor(string prefix, bool ci)
internal bool get_CaseInsensitive()
internal RegexPrefix get_Empty()
internal string get_Prefix()
}
internal System.Text.RegularExpressions.RegexReplacement : object {
private int Specials
public int LeftPortion
public int RightPortion
public int LastGroup
public int WholeString
private List`1<string> _strings
private List`1<int> _rules
private string <Pattern>k__BackingField
public string Pattern
public void .ctor(string rep, RegexNode concat, Hashtable _caps)
public RegexReplacement GetOrCreate(WeakReference`1<RegexReplacement> replRef, string replacement, Hashtable caps, int capsize, Hashtable capnames, RegexOptions roptions)
public string get_Pattern()
private void ReplacementImpl(StringBuilder sb, Match match)
private void ReplacementImplRTL(List`1<string> al, Match match)
public string Replacement(Match match)
public string Replace(Regex regex, string input, int count, int startat)
}
public System.Text.RegularExpressions.RegexRunner : object {
protected internal int runtextbeg
protected internal int runtextend
protected internal int runtextstart
protected internal string runtext
protected internal int runtextpos
protected internal Int32[] runtrack
protected internal int runtrackpos
protected internal Int32[] runstack
protected internal int runstackpos
protected internal Int32[] runcrawl
protected internal int runcrawlpos
protected internal int runtrackcount
protected internal Match runmatch
protected internal Regex runregex
private int _timeout
private bool _ignoreTimeout
private int _timeoutOccursAt
private int TimeoutCheckFrequency
private int _timeoutChecksToSkip
protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick)
protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, TimeSpan timeout)
private void StartTimeoutWatch()
protected void CheckTimeout()
private void DoCheckTimeout()
protected void Go()
protected bool FindFirstChar()
protected void InitTrackCount()
private void InitMatch()
private Match TidyMatch(bool quick)
protected void EnsureStorage()
protected bool IsBoundary(int index, int startpos, int endpos)
protected bool IsECMABoundary(int index, int startpos, int endpos)
protected bool CharInSet(char ch, string set, string category)
protected bool CharInClass(char ch, string charClass)
protected void DoubleTrack()
protected void DoubleStack()
protected void DoubleCrawl()
protected void Crawl(int i)
protected int Popcrawl()
protected int Crawlpos()
protected void Capture(int capnum, int start, int end)
protected void TransferCapture(int capnum, int uncapnum, int start, int end)
protected void Uncapture()
protected bool IsMatched(int cap)
protected int MatchIndex(int cap)
protected int MatchLength(int cap)
}
public System.Text.RegularExpressions.RegexRunnerFactory : object {
protected internal RegexRunner CreateInstance()
}
internal System.Text.RegularExpressions.RegexTree : object {
public RegexNode Root
public Hashtable Caps
public Int32[] CapNumList
public int CapTop
public Hashtable CapNames
public String[] CapsList
public RegexOptions Options
internal void .ctor(RegexNode root, Hashtable caps, Int32[] capNumList, int capTop, Hashtable capNames, String[] capsList, RegexOptions options)
}
internal System.Text.RegularExpressions.RegexWriter : ValueType {
private int BeforeChild
private int AfterChild
private int EmittedSize
private int IntStackSize
private ValueListBuilder`1<int> _emitted
private ValueListBuilder`1<int> _intStack
private Dictionary`2<string, int> _stringHash
private List`1<string> _stringTable
private Hashtable _caps
private int _trackCount
private void .ctor(Span`1<int> emittedSpan, Span`1<int> intStackSpan)
public RegexCode Write(RegexTree tree)
public void Dispose()
public RegexCode RegexCodeFromRegexTree(RegexTree tree)
private void PatchJump(int offset, int jumpDest)
private void Emit(int op)
private void Emit(int op, int opd1)
private void Emit(int op, int opd1, int opd2)
private int StringCode(string str)
private int MapCapnum(int capnum)
private void EmitFragment(int nodetype, RegexNode node, int curIndex)
}
public System.Threading.Barrier : object {
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentTotalCount
private int CURRENT_MASK
private int TOTAL_MASK
private int SENSE_MASK
private int MAX_PARTICIPANTS
private long m_currentPhase
private bool m_disposed
private ManualResetEventSlim m_oddEvent
private ManualResetEventSlim m_evenEvent
private ExecutionContext m_ownerThreadContext
private ContextCallback s_invokePostPhaseAction
private Action`1<Barrier> m_postPhaseAction
private Exception m_exception
private int m_actionCallerID
public int ParticipantsRemaining
public int ParticipantCount
public long CurrentPhaseNumber
public int get_ParticipantsRemaining()
public int get_ParticipantCount()
public long get_CurrentPhaseNumber()
internal void set_CurrentPhaseNumber(long value)
public void .ctor(int participantCount)
public void .ctor(int participantCount, Action`1<Barrier> postPhaseAction)
private void GetCurrentTotal(int currentTotal, Int32& current, Int32& total, Boolean& sense)
private bool SetCurrentTotal(int currentTotal, int current, int total, bool sense)
public long AddParticipant()
public long AddParticipants(int participantCount)
public void RemoveParticipant()
public void RemoveParticipants(int participantCount)
public void SignalAndWait()
public void SignalAndWait(CancellationToken cancellationToken)
public bool SignalAndWait(TimeSpan timeout)
public bool SignalAndWait(TimeSpan timeout, CancellationToken cancellationToken)
public bool SignalAndWait(int millisecondsTimeout)
public bool SignalAndWait(int millisecondsTimeout, CancellationToken cancellationToken)
private void FinishPhase(bool observedSense)
private void InvokePostPhaseAction(object obj)
private void SetResetEvents(bool observedSense)
private void WaitCurrentPhase(ManualResetEventSlim currentPhaseEvent, long observedPhase)
private bool DiscontinuousWait(ManualResetEventSlim currentPhaseEvent, int totalTimeout, CancellationToken token, long observedPhase)
public void Dispose()
protected void Dispose(bool disposing)
private void ThrowIfDisposed()
}
public System.Threading.BarrierPostPhaseException : Exception {
public void .ctor(Exception innerException)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.Semaphore : WaitHandle {
private int MAX_PATH
public void .ctor(int initialCount, int maximumCount)
public void .ctor(int initialCount, int maximumCount, string name)
public void .ctor(int initialCount, int maximumCount, string name, Boolean& createdNew)
public void .ctor(int initialCount, int maximumCount, string name, Boolean& createdNew, SemaphoreSecurity semaphoreSecurity)
private void .ctor(SafeWaitHandle handle)
public Semaphore OpenExisting(string name)
public Semaphore OpenExisting(string name, SemaphoreRights rights)
public bool TryOpenExisting(string name, Semaphore& result)
public bool TryOpenExisting(string name, SemaphoreRights rights, Semaphore& result)
private OpenExistingResult OpenExistingWorker(string name, SemaphoreRights rights, Semaphore& result)
public int Release()
public int Release(int releaseCount)
public SemaphoreSecurity GetAccessControl()
public void SetAccessControl(SemaphoreSecurity semaphoreSecurity)
internal IntPtr CreateSemaphore_internal(int initialCount, int maximumCount, string name, Int32& errorCode)
private IntPtr OpenSemaphore_internal(string name, SemaphoreRights rights, Int32& errorCode)
private IntPtr CreateSemaphore_icall(int initialCount, int maximumCount, Char* name, int name_length, Int32& errorCode)
private IntPtr OpenSemaphore_icall(Char* name, int name_length, SemaphoreRights rights, Int32& errorCode)
internal bool ReleaseSemaphore_internal(IntPtr handle, int releaseCount, Int32& previousCount)
}
public System.Threading.ThreadExceptionEventArgs : EventArgs {
private Exception exception
public Exception Exception
public void .ctor(Exception t)
public Exception get_Exception()
}
public System.Threading.ThreadExceptionEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ThreadExceptionEventArgs e)
public IAsyncResult BeginInvoke(object sender, ThreadExceptionEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Timers.ElapsedEventArgs : EventArgs {
private DateTime time
public DateTime SignalTime
internal void .ctor(DateTime time)
public DateTime get_SignalTime()
}
public System.Timers.ElapsedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ElapsedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ElapsedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Timers.Timer : Component {
private double interval
private bool enabled
private bool initializing
private bool delayedEnable
private ElapsedEventHandler onIntervalElapsed
private bool autoReset
private ISynchronizeInvoke synchronizingObject
private bool disposed
private Timer timer
private TimerCallback callback
private object cookie
public bool AutoReset
public bool Enabled
public double Interval
public ISite Site
public ISynchronizeInvoke SynchronizingObject
public void .ctor(double interval)
public bool get_AutoReset()
public void set_AutoReset(bool value)
public bool get_Enabled()
public void set_Enabled(bool value)
private int CalculateRoundedInterval(double interval, bool argumentCheck)
private void UpdateTimer()
public double get_Interval()
public void set_Interval(double value)
public void add_Elapsed(ElapsedEventHandler value)
public void remove_Elapsed(ElapsedEventHandler value)
public void set_Site(ISite value)
public ISite get_Site()
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public void BeginInit()
public void Close()
protected void Dispose(bool disposing)
public void EndInit()
public void Start()
public void Stop()
private void MyTimerCallback(object state)
}
public System.Timers.TimersDescriptionAttribute : DescriptionAttribute {
private bool replaced
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.UncNameHelper : object {
internal int MaximumInternetNameLength
internal string ParseCanonicalName(string str, int start, int end, Boolean& loopback)
internal bool IsValid(Char* name, ushort start, Int32& returnedEnd, bool notImplicitFile)
}
internal System.UnescapeMode : Enum {
public int value__
public UnescapeMode CopyOnly
public UnescapeMode Escape
public UnescapeMode Unescape
public UnescapeMode EscapeUnescape
public UnescapeMode V1ToStringFlag
public UnescapeMode UnescapeAll
public UnescapeMode UnescapeAllOrThrow
}
public System.Uri : object {
public string UriSchemeFile
public string UriSchemeFtp
public string UriSchemeGopher
public string UriSchemeHttp
public string UriSchemeHttps
internal string UriSchemeWs
internal string UriSchemeWss
public string UriSchemeMailto
public string UriSchemeNews
public string UriSchemeNntp
public string UriSchemeNetTcp
public string UriSchemeNetPipe
public string SchemeDelimiter
private int c_Max16BitUtf8SequenceLength
internal int c_MaxUriBufferSize
private int c_MaxUriSchemeName
private string m_String
private string m_originalUnicodeString
private UriParser m_Syntax
private string m_DnsSafeHost
private Flags m_Flags
private UriInfo m_Info
private bool m_iriParsing
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_ConfigInitialized
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_ConfigInitializing
private UriIdnScope modreq(System.Runtime.CompilerServices.IsVolatile) s_IdnScope
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_IriParsing
private bool useDotNetRelativeOrAbsolute
private UriKind DotNetRelativeOrAbsolute
internal bool IsWindowsFileSystem
private object s_initLock
private UriFormat V1ToStringUnescape
internal char c_DummyChar
internal char c_EOL
internal Char[] HexLowerChars
private Char[] _WSchars
private bool IsImplicitFile
private bool IsUncOrDosPath
private bool IsDosPath
private bool IsUncPath
private Flags HostType
private UriParser Syntax
private bool IsNotAbsoluteUri
private bool AllowIdn
internal bool UserDrivenParsing
private ushort SecuredPathIndex
public string AbsolutePath
private string PrivateAbsolutePath
public string AbsoluteUri
public string LocalPath
public string Authority
public UriHostNameType HostNameType
public bool IsDefaultPort
public bool IsFile
public bool IsLoopback
public string PathAndQuery
public String[] Segments
public bool IsUnc
public string Host
private object InitializeLock
public int Port
public string Query
public string Fragment
public string Scheme
private bool OriginalStringSwitched
public string OriginalString
public string DnsSafeHost
public string IdnHost
public bool IsAbsoluteUri
public bool UserEscaped
public string UserInfo
internal bool HasAuthority
private bool get_IsImplicitFile()
private bool get_IsUncOrDosPath()
private bool get_IsDosPath()
private bool get_IsUncPath()
private Flags get_HostType()
private UriParser get_Syntax()
private bool get_IsNotAbsoluteUri()
internal bool IriParsingStatic(UriParser syntax)
private bool get_AllowIdn()
private bool AllowIdnStatic(UriParser syntax, Flags flags)
private bool IsIntranet(string schemeHost)
internal bool get_UserDrivenParsing()
private void SetUserDrivenParsing()
private ushort get_SecuredPathIndex()
private bool NotAny(Flags flags)
private bool InFact(Flags flags)
private bool StaticNotAny(Flags allFlags, Flags checkFlags)
private bool StaticInFact(Flags allFlags, Flags checkFlags)
private UriInfo EnsureUriInfo()
private void EnsureParseRemaining()
private void EnsureHostString(bool allowDnsOptimization)
public void .ctor(string uriString)
public void .ctor(string uriString, bool dontEscape)
public void .ctor(Uri baseUri, string relativeUri, bool dontEscape)
public void .ctor(string uriString, UriKind uriKind)
public void .ctor(Uri baseUri, string relativeUri)
private void CreateUri(Uri baseUri, string relativeUri, bool dontEscape)
public void .ctor(Uri baseUri, Uri relativeUri)
private ParsingError GetCombinedString(Uri baseUri, string relativeStr, bool dontEscape, String& result)
private UriFormatException GetException(ParsingError err)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public string get_AbsolutePath()
private string get_PrivateAbsolutePath()
public string get_AbsoluteUri()
public string get_LocalPath()
public string get_Authority()
public UriHostNameType get_HostNameType()
public bool get_IsDefaultPort()
public bool get_IsFile()
public bool get_IsLoopback()
public string get_PathAndQuery()
public String[] get_Segments()
public bool get_IsUnc()
public string get_Host()
private bool StaticIsFile(UriParser syntax)
private object get_InitializeLock()
private void InitializeUriConfig()
private string GetLocalPath()
public int get_Port()
public string get_Query()
public string get_Fragment()
public string get_Scheme()
private bool get_OriginalStringSwitched()
public string get_OriginalString()
public string get_DnsSafeHost()
public string get_IdnHost()
public bool get_IsAbsoluteUri()
public bool get_UserEscaped()
public string get_UserInfo()
public UriHostNameType CheckHostName(string name)
public string GetLeftPart(UriPartial part)
public string HexEscape(char character)
public char HexUnescape(string pattern, Int32& index)
public bool IsHexEncoding(string pattern, int index)
internal bool IsGenDelim(char ch)
public bool CheckSchemeName(string schemeName)
public bool IsHexDigit(char character)
public int FromHex(char digit)
public int GetHashCode()
public string ToString()
public bool op_Equality(Uri uri1, Uri uri2)
public bool op_Inequality(Uri uri1, Uri uri2)
public bool Equals(object comparand)
public Uri MakeRelativeUri(Uri uri)
private bool CheckForColonInFirstPathSegment(string uriString)
internal string InternalEscapeString(string rawString)
private ParsingError ParseScheme(string uriString, Flags& flags, UriParser& syntax)
internal UriFormatException ParseMinimal()
private ParsingError PrivateParseMinimal()
private void PrivateParseMinimalIri(string newHost, ushort idx)
private void CreateUriInfo(Flags cF)
private void CreateHostString()
private string CreateHostStringHelper(string str, ushort idx, ushort end, Flags& flags, String& scopeId)
private void GetHostViaCustomSyntax()
internal string GetParts(UriComponents uriParts, UriFormat formatAs)
private string GetEscapedParts(UriComponents uriParts)
private string GetUnescapedParts(UriComponents uriParts, UriFormat formatAs)
private string ReCreateParts(UriComponents parts, ushort nonCanonical, UriFormat formatAs)
private string GetUriPartsFromUserString(UriComponents uriParts)
private void ParseRemaining()
private ushort ParseSchemeCheckImplicitFile(Char* uriString, ushort length, ParsingError& err, Flags& flags, UriParser& syntax)
private bool CheckKnownSchemes(Int64* lptr, ushort nChars, UriParser& syntax)
private ParsingError CheckSchemeSyntax(Char* ptr, ushort length, UriParser& syntax)
private ushort CheckAuthorityHelper(Char* pString, ushort idx, ushort length, ParsingError& err, Flags& flags, UriParser syntax, String& newHost)
private void CheckAuthorityHelperHandleDnsIri(Char* pString, ushort start, int end, int startInput, bool iriParsing, bool hasUnicode, UriParser syntax, string userInfoString, Flags& flags, Boolean& justNormalized, String& newHost, ParsingError& err)
private void CheckAuthorityHelperHandleAnyHostIri(Char* pString, int startInput, int end, bool iriParsing, bool hasUnicode, UriParser syntax, Flags& flags, String& newHost, ParsingError& err)
private void FindEndOfComponent(string input, UInt16& idx, ushort end, char delim)
private void FindEndOfComponent(Char* str, UInt16& idx, ushort end, char delim)
private Check CheckCanonical(Char* str, UInt16& idx, ushort end, char delim)
private Char[] GetCanonicalPath(Char[] dest, Int32& pos, UriFormat formatAs)
private void UnescapeOnly(Char* pch, int start, Int32& end, char ch1, char ch2, char ch3)
private Char[] Compress(Char[] dest, ushort start, Int32& destLength, UriParser syntax)
internal int CalculateCaseInsensitiveHashCode(string text)
private string CombineUri(Uri basePart, string relativePart, UriFormat uriFormat)
private string PathDifference(string path1, string path2, bool compareCase)
internal bool get_HasAuthority()
private bool IsLWS(char ch)
private bool IsAsciiLetter(char character)
internal bool IsAsciiLetterOrDigit(char character)
internal bool IsBidiControlCharacter(char ch)
internal string StripBidiControlCharacter(Char* strToClean, int start, int length)
public string MakeRelative(Uri toUri)
protected void Parse()
protected void Canonicalize()
protected void Escape()
protected string Unescape(string path)
protected string EscapeString(string str)
protected void CheckSecurity()
protected bool IsReservedCharacter(char character)
protected bool IsExcludedCharacter(char character)
protected bool IsBadFileSystemCharacter(char character)
private void CreateThis(string uri, bool dontEscape, UriKind uriKind)
private void InitializeUri(ParsingError err, UriKind uriKind, UriFormatException& e)
private bool CheckForConfigLoad(string data)
private bool CheckForUnicode(string data)
private bool CheckForEscapedUnreserved(string data)
public bool TryCreate(string uriString, UriKind uriKind, Uri& result)
public bool TryCreate(Uri baseUri, string relativeUri, Uri& result)
public bool TryCreate(Uri baseUri, Uri relativeUri, Uri& result)
public string GetComponents(UriComponents components, UriFormat format)
public int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType)
public bool IsWellFormedOriginalString()
public bool IsWellFormedUriString(string uriString, UriKind uriKind)
internal bool InternalIsWellFormedOriginalString()
public string UnescapeDataString(string stringToUnescape)
public string EscapeUriString(string stringToEscape)
public string EscapeDataString(string stringToEscape)
internal string EscapeUnescapeIri(string input, int start, int end, UriComponents component)
private void .ctor(Flags flags, UriParser uriParser, string uri)
internal Uri CreateHelper(string uriString, bool dontEscape, UriKind uriKind, UriFormatException& e)
internal Uri ResolveHelper(Uri baseUri, Uri relativeUri, String& newUriString, Boolean& userEscaped, UriFormatException& e)
private string GetRelativeSerializationString(UriFormat format)
internal string GetComponentsHelper(UriComponents uriComponents, UriFormat uriFormat)
public bool IsBaseOf(Uri uri)
internal bool IsBaseOfHelper(Uri uriLink)
private void CreateThisFromUri(Uri otherUri)
}
public System.UriBuilder : object {
private bool _changed
private string _fragment
private string _host
private string _password
private string _path
private int _port
private string _query
private string _scheme
private string _schemeDelimiter
private Uri _uri
private string _username
private string Extra
public string Fragment
public string Host
public string Password
public string Path
public int Port
public string Query
public string Scheme
public Uri Uri
public string UserName
public void .ctor(string uri)
public void .ctor(Uri uri)
private void Init(Uri uri)
public void .ctor(string schemeName, string hostName)
public void .ctor(string scheme, string host, int portNumber)
public void .ctor(string scheme, string host, int port, string pathValue)
public void .ctor(string scheme, string host, int port, string path, string extraValue)
private void set_Extra(string value)
public string get_Fragment()
public void set_Fragment(string value)
public string get_Host()
public void set_Host(string value)
public string get_Password()
public void set_Password(string value)
public string get_Path()
public void set_Path(string value)
public int get_Port()
public void set_Port(int value)
public string get_Query()
public void set_Query(string value)
public string get_Scheme()
public void set_Scheme(string value)
public Uri get_Uri()
public string get_UserName()
public void set_UserName(string value)
public bool Equals(object rparam)
public int GetHashCode()
private void SetFieldsFromUri(Uri uri)
public string ToString()
}
public System.UriComponents : Enum {
public int value__
public UriComponents Scheme
public UriComponents UserInfo
public UriComponents Host
public UriComponents Port
public UriComponents Path
public UriComponents Query
public UriComponents Fragment
public UriComponents StrongPort
public UriComponents NormalizedHost
public UriComponents KeepDelimiter
public UriComponents SerializationInfoString
public UriComponents AbsoluteUri
public UriComponents HostAndPort
public UriComponents StrongAuthority
public UriComponents SchemeAndServer
public UriComponents HttpRequestUrl
public UriComponents PathAndQuery
}
public System.UriFormat : Enum {
public int value__
public UriFormat UriEscaped
public UriFormat Unescaped
public UriFormat SafeUnescaped
}
public System.UriFormatException : FormatException {
public void .ctor(string textString)
public void .ctor(string textString, Exception e)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.UriHelper : object {
private Char[] HexUpperChars
private short c_MaxAsciiCharsReallocate
private short c_MaxUnicodeCharsReallocate
private short c_MaxUTF_8BytesPerUnicodeChar
private short c_EncodedCharsPerByte
private string RFC2396ReservedMarks
private string RFC3986ReservedMarks
private string RFC2396UnreservedMarks
private string RFC3986UnreservedMarks
internal bool TestForSubPath(Char* pMe, ushort meLength, Char* pShe, ushort sheLength, bool ignoreCase)
internal Char[] EscapeString(string input, int start, int end, Char[] dest, Int32& destPos, bool isUriString, char force1, char force2, char rsvd)
private Char[] EnsureDestinationSize(Char* pStr, Char[] dest, int currentInputPos, short charsToAdd, short minReallocateChars, Int32& destPos, int prevInputPos)
internal Char[] UnescapeString(string input, int start, int end, Char[] dest, Int32& destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery)
internal Char[] UnescapeString(Char* pStr, int start, int end, Char[] dest, Int32& destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery)
internal void MatchUTF8Sequence(Char* pDest, Char[] dest, Int32& destOffset, Char[] unescapedChars, int charCount, Byte[] bytes, int byteCount, bool isQuery, bool iriParsing)
internal void EscapeAsciiChar(char ch, Char[] to, Int32& pos)
internal char EscapedAscii(char digit, char next)
internal bool IsNotSafeForUnescape(char ch)
private bool IsReservedUnreservedOrHash(char c)
internal bool IsUnreserved(char c)
internal bool Is3986Unreserved(char c)
}
public System.UriHostNameType : Enum {
public int value__
public UriHostNameType Unknown
public UriHostNameType Basic
public UriHostNameType Dns
public UriHostNameType IPv4
public UriHostNameType IPv6
}
public System.UriIdnScope : Enum {
public int value__
public UriIdnScope None
public UriIdnScope AllExceptIntranet
public UriIdnScope All
}
public System.UriKind : Enum {
public int value__
public UriKind RelativeOrAbsolute
public UriKind Absolute
public UriKind Relative
}
public System.UriParser : object {
private UriSyntaxFlags SchemeOnlyFlags
private Dictionary`2<string, UriParser> m_Table
private Dictionary`2<string, UriParser> m_TempTable
private UriSyntaxFlags m_Flags
private UriSyntaxFlags modreq(System.Runtime.CompilerServices.IsVolatile) m_UpdatableFlags
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_UpdatableFlagsUsed
private UriSyntaxFlags c_UpdatableFlags
private int m_Port
private string m_Scheme
internal int NoDefaultPort
private int c_InitialTableSize
internal UriParser HttpUri
internal UriParser HttpsUri
internal UriParser WsUri
internal UriParser WssUri
internal UriParser FtpUri
internal UriParser FileUri
internal UriParser GopherUri
internal UriParser NntpUri
internal UriParser NewsUri
internal UriParser MailToUri
internal UriParser UuidUri
internal UriParser TelnetUri
internal UriParser LdapUri
internal UriParser NetTcpUri
internal UriParser NetPipeUri
internal UriParser VsMacrosUri
private UriQuirksVersion s_QuirksVersion
private int c_MaxCapacity
private UriSyntaxFlags UnknownV1SyntaxFlags
private UriSyntaxFlags HttpSyntaxFlags
private UriSyntaxFlags FtpSyntaxFlags
private UriSyntaxFlags FileSyntaxFlags
private UriSyntaxFlags VsmacrosSyntaxFlags
private UriSyntaxFlags GopherSyntaxFlags
private UriSyntaxFlags NewsSyntaxFlags
private UriSyntaxFlags NntpSyntaxFlags
private UriSyntaxFlags TelnetSyntaxFlags
private UriSyntaxFlags LdapSyntaxFlags
private UriSyntaxFlags MailtoSyntaxFlags
private UriSyntaxFlags NetPipeSyntaxFlags
private UriSyntaxFlags NetTcpSyntaxFlags
internal string SchemeName
internal int DefaultPort
internal bool ShouldUseLegacyV2Quirks
internal UriSyntaxFlags Flags
internal bool IsSimple
internal string get_SchemeName()
internal int get_DefaultPort()
protected UriParser OnNewUri()
protected void OnRegister(string schemeName, int defaultPort)
protected void InitializeAndValidate(Uri uri, UriFormatException& parsingError)
protected string Resolve(Uri baseUri, Uri relativeUri, UriFormatException& parsingError)
protected bool IsBaseOf(Uri baseUri, Uri relativeUri)
protected string GetComponents(Uri uri, UriComponents components, UriFormat format)
protected bool IsWellFormedOriginalString(Uri uri)
public void Register(UriParser uriParser, string schemeName, int defaultPort)
public bool IsKnownScheme(string schemeName)
internal bool get_ShouldUseLegacyV2Quirks()
internal UriSyntaxFlags get_Flags()
internal bool NotAny(UriSyntaxFlags flags)
internal bool InFact(UriSyntaxFlags flags)
internal bool IsAllSet(UriSyntaxFlags flags)
private bool IsFullMatch(UriSyntaxFlags flags, UriSyntaxFlags expected)
internal void .ctor(UriSyntaxFlags flags)
private void FetchSyntax(UriParser syntax, string lwrCaseSchemeName, int defaultPort)
internal UriParser FindOrFetchAsUnknownV1Syntax(string lwrCaseScheme)
internal UriParser GetSyntax(string lwrCaseScheme)
internal bool get_IsSimple()
internal void CheckSetIsSimpleFlag()
internal void SetUpdatableFlags(UriSyntaxFlags flags)
internal UriParser InternalOnNewUri()
internal void InternalValidate(Uri thisUri, UriFormatException& parsingError)
internal string InternalResolve(Uri thisBaseUri, Uri uriLink, UriFormatException& parsingError)
internal bool InternalIsBaseOf(Uri thisBaseUri, Uri uriLink)
internal string InternalGetComponents(Uri thisUri, UriComponents uriComponents, UriFormat uriFormat)
internal bool InternalIsWellFormedOriginalString(Uri thisUri)
}
public System.UriPartial : Enum {
public int value__
public UriPartial Scheme
public UriPartial Authority
public UriPartial Path
public UriPartial Query
}
internal System.UriSyntaxFlags : Enum {
public int value__
public UriSyntaxFlags None
public UriSyntaxFlags MustHaveAuthority
public UriSyntaxFlags OptionalAuthority
public UriSyntaxFlags MayHaveUserInfo
public UriSyntaxFlags MayHavePort
public UriSyntaxFlags MayHavePath
public UriSyntaxFlags MayHaveQuery
public UriSyntaxFlags MayHaveFragment
public UriSyntaxFlags AllowEmptyHost
public UriSyntaxFlags AllowUncHost
public UriSyntaxFlags AllowDnsHost
public UriSyntaxFlags AllowIPv4Host
public UriSyntaxFlags AllowIPv6Host
public UriSyntaxFlags AllowAnInternetHost
public UriSyntaxFlags AllowAnyOtherHost
public UriSyntaxFlags FileLikeUri
public UriSyntaxFlags MailToLikeUri
public UriSyntaxFlags V1_UnknownUri
public UriSyntaxFlags SimpleUserSyntax
public UriSyntaxFlags BuiltInSyntax
public UriSyntaxFlags ParserSchemeOnly
public UriSyntaxFlags AllowDOSPath
public UriSyntaxFlags PathIsRooted
public UriSyntaxFlags ConvertPathSlashes
public UriSyntaxFlags CompressPath
public UriSyntaxFlags CanonicalizeAsFilePath
public UriSyntaxFlags UnEscapeDotsAndSlashes
public UriSyntaxFlags AllowIdn
public UriSyntaxFlags AllowIriParsing
}
public System.UriTypeConverter : TypeConverter {
private bool CanConvert(Type type)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool IsValid(ITypeDescriptorContext context, object value)
}
public System.Web.AspNetHostingPermission : CodeAccessPermission {
private int version
private AspNetHostingPermissionLevel _level
public AspNetHostingPermissionLevel Level
public void .ctor(AspNetHostingPermissionLevel level)
public void .ctor(PermissionState state)
public AspNetHostingPermissionLevel get_Level()
public void set_Level(AspNetHostingPermissionLevel value)
public bool IsUnrestricted()
public IPermission Copy()
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
private bool IsEmpty()
private AspNetHostingPermission Cast(IPermission target)
}
public System.Web.AspNetHostingPermissionAttribute : CodeAccessSecurityAttribute {
private AspNetHostingPermissionLevel _level
public AspNetHostingPermissionLevel Level
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
public AspNetHostingPermissionLevel get_Level()
public void set_Level(AspNetHostingPermissionLevel value)
}
public System.Web.AspNetHostingPermissionLevel : Enum {
public int value__
public AspNetHostingPermissionLevel None
public AspNetHostingPermissionLevel Minimal
public AspNetHostingPermissionLevel Low
public AspNetHostingPermissionLevel Medium
public AspNetHostingPermissionLevel High
public AspNetHostingPermissionLevel Unrestricted
}
public System.Web.HttpUtility : object {
public void HtmlAttributeEncode(string s, TextWriter output)
public string HtmlAttributeEncode(string s)
public string UrlDecode(string str)
private Char[] GetChars(MemoryStream b, Encoding e)
private void WriteCharBytes(IList buf, char ch, Encoding e)
public string UrlDecode(string str, Encoding e)
public string UrlDecode(Byte[] bytes, Encoding e)
private int GetInt(byte b)
private int GetChar(Byte[] bytes, int offset, int length)
private int GetChar(string str, int offset, int length)
public string UrlDecode(Byte[] bytes, int offset, int count, Encoding e)
public Byte[] UrlDecodeToBytes(Byte[] bytes)
public Byte[] UrlDecodeToBytes(string str)
public Byte[] UrlDecodeToBytes(string str, Encoding e)
public Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count)
public string UrlEncode(string str)
public string UrlEncode(string str, Encoding e)
public string UrlEncode(Byte[] bytes)
public string UrlEncode(Byte[] bytes, int offset, int count)
public Byte[] UrlEncodeToBytes(string str)
public Byte[] UrlEncodeToBytes(string str, Encoding e)
public Byte[] UrlEncodeToBytes(Byte[] bytes)
public Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count)
public string UrlEncodeUnicode(string str)
public Byte[] UrlEncodeUnicodeToBytes(string str)
public string HtmlDecode(string s)
public void HtmlDecode(string s, TextWriter output)
public string HtmlEncode(string s)
public void HtmlEncode(string s, TextWriter output)
public string HtmlEncode(object value)
public string JavaScriptStringEncode(string value)
public string JavaScriptStringEncode(string value, bool addDoubleQuotes)
public string UrlPathEncode(string str)
public NameValueCollection ParseQueryString(string query)
public NameValueCollection ParseQueryString(string query, Encoding encoding)
internal void ParseQueryString(string query, Encoding encoding, NameValueCollection result)
}
internal System.Web.Util.Helpers : object {
public CultureInfo InvariantCulture
}
public System.Web.Util.HttpEncoder : object {
private Char[] hexChars
private object entitiesLock
private SortedDictionary`2<string, char> entities
private Lazy`1<HttpEncoder> defaultEncoder
private Lazy`1<HttpEncoder> currentEncoderLazy
private HttpEncoder currentEncoder
private IDictionary`2<string, char> Entities
public HttpEncoder Current
public HttpEncoder Default
private IDictionary`2<string, char> get_Entities()
public HttpEncoder get_Current()
public void set_Current(HttpEncoder value)
public HttpEncoder get_Default()
protected internal void HeaderNameValueEncode(string headerName, string headerValue, String& encodedHeaderName, String& encodedHeaderValue)
private void StringBuilderAppend(string s, StringBuilder& sb)
private string EncodeHeaderString(string input)
protected internal void HtmlAttributeEncode(string value, TextWriter output)
protected internal void HtmlDecode(string value, TextWriter output)
protected internal void HtmlEncode(string value, TextWriter output)
protected internal Byte[] UrlEncode(Byte[] bytes, int offset, int count)
private HttpEncoder GetCustomEncoderFromConfig()
protected internal string UrlPathEncode(string value)
internal Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count)
internal string HtmlEncode(string s)
internal string HtmlAttributeEncode(string s)
internal string HtmlDecode(string s)
internal bool NotEncoded(char c)
internal void UrlEncodeChar(char c, Stream result, bool isUnicode)
internal void UrlPathEncodeChar(char c, Stream result)
private void InitEntities()
protected internal string JavaScriptStringEncode(string value)
}
public System.Windows.Input.ICommand {
public bool CanExecute(object parameter)
public void Execute(object parameter)
public void add_CanExecuteChanged(EventHandler value)
public void remove_CanExecuteChanged(EventHandler value)
}
public System.Windows.Markup.ValueSerializerAttribute : Attribute {
private Type _valueSerializerType
private string _valueSerializerTypeName
public Type ValueSerializerType
public string ValueSerializerTypeName
public void .ctor(Type valueSerializerType)
public void .ctor(string valueSerializerTypeName)
public Type get_ValueSerializerType()
public string get_ValueSerializerTypeName()
}
internal Unity.ThrowStub : ObjectDisposedException {
public void ThrowNotSupportedException()
}
