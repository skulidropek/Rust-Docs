internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public string FxVersion
public string VsVersion
public string FxFileVersion
public string VsFileVersion
public string AssemblyI18N
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_Core
}
internal Locale : object {
public string GetText(string msg)
public string GetText(string fmt, Object[] args)
}
public Microsoft.CSharp.CSharpCodeProvider : CodeDomProvider {
private IDictionary`2<string, string> providerOptions
public string FileExtension
public void .ctor(IDictionary`2<string, string> providerOptions)
public string get_FileExtension()
public ICodeCompiler CreateCompiler()
public ICodeGenerator CreateGenerator()
public TypeConverter GetConverter(Type Type)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
}
internal Microsoft.VisualBasic.VBCodeCompiler : VBCodeGenerator {
private string windowsMonoPath
private string windowsvbncPath
public CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e)
public CompilerResults CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
public CompilerResults CompileAssemblyFromFile(CompilerParameters options, string fileName)
public CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames)
public CompilerResults CompileAssemblyFromSource(CompilerParameters options, string source)
public CompilerResults CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources)
private string BuildArgs(CompilerParameters options, String[] fileNames)
private CompilerError CreateErrorFromString(string error_string)
private string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension, bool keepFile)
private string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension)
private CompilerResults CompileFromFileBatch(CompilerParameters options, String[] fileNames)
private CompilerResults CompileFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
private CompilerResults CompileFromSourceBatch(CompilerParameters options, String[] sources)
}
internal Microsoft.VisualBasic.VBCodeGenerator : CodeGenerator {
private String[] Keywords
private Dictionary`2<string, int> <>f__switch$map2
protected string NullToken
protected string get_NullToken()
protected void ContinueOnNewLine(string st)
protected void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
protected void GenerateArrayCreateExpression(CodeArrayCreateExpression expression)
protected void GenerateBaseReferenceExpression(CodeBaseReferenceExpression expression)
protected void GenerateCastExpression(CodeCastExpression expression)
private bool AsBool(object datavalue)
private string OnOff(bool datavalue)
protected void GenerateCompileUnitStart(CodeCompileUnit compileUnit)
protected void GenerateCompileUnit(CodeCompileUnit compileUnit)
protected void GenerateDelegateCreateExpression(CodeDelegateCreateExpression expression)
protected void GenerateFieldReferenceExpression(CodeFieldReferenceExpression expression)
protected void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression expression)
protected void GenerateVariableReferenceExpression(CodeVariableReferenceExpression expression)
protected void GenerateIndexerExpression(CodeIndexerExpression expression)
protected void GenerateArrayIndexerExpression(CodeArrayIndexerExpression expression)
protected void GenerateSnippetExpression(CodeSnippetExpression expression)
protected void GenerateMethodInvokeExpression(CodeMethodInvokeExpression expression)
protected void GenerateMethodReferenceExpression(CodeMethodReferenceExpression expression)
protected void GenerateEventReferenceExpression(CodeEventReferenceExpression expression)
protected void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression expression)
protected void GenerateObjectCreateExpression(CodeObjectCreateExpression expression)
protected void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
protected void GeneratePrimitiveExpression(CodePrimitiveExpression e)
protected void GenerateSingleFloatValue(float s)
protected void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression expression)
protected void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression expression)
protected void GenerateThisReferenceExpression(CodeThisReferenceExpression expression)
protected void GenerateExpressionStatement(CodeExpressionStatement statement)
protected void GenerateIterationStatement(CodeIterationStatement statement)
protected void GenerateThrowExceptionStatement(CodeThrowExceptionStatement statement)
protected void GenerateComment(CodeComment comment)
protected void GenerateMethodReturnStatement(CodeMethodReturnStatement statement)
protected void GenerateConditionStatement(CodeConditionStatement statement)
protected void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement statement)
protected void GenerateAssignStatement(CodeAssignStatement statement)
protected void GenerateAttachEventStatement(CodeAttachEventStatement statement)
protected void GenerateRemoveEventStatement(CodeRemoveEventStatement statement)
protected void GenerateGotoStatement(CodeGotoStatement statement)
protected void GenerateLabeledStatement(CodeLabeledStatement statement)
protected void GenerateTypeOfExpression(CodeTypeOfExpression e)
protected void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement statement)
protected void GenerateLinePragmaStart(CodeLinePragma linePragma)
protected void GenerateLinePragmaEnd(CodeLinePragma linePragma)
protected void GenerateEvent(CodeMemberEvent eventRef, CodeTypeDeclaration declaration)
protected void GenerateField(CodeMemberField field)
protected void GenerateSnippetMember(CodeSnippetTypeMember member)
protected void GenerateEntryPointMethod(CodeEntryPointMethod method, CodeTypeDeclaration declaration)
protected void GenerateMethod(CodeMemberMethod method, CodeTypeDeclaration declaration)
protected void GenerateProperty(CodeMemberProperty property, CodeTypeDeclaration declaration)
protected void GenerateConstructor(CodeConstructor constructor, CodeTypeDeclaration declaration)
protected void GenerateTypeConstructor(CodeTypeConstructor constructor)
protected void GenerateTypeStart(CodeTypeDeclaration declaration)
protected void GenerateTypeEnd(CodeTypeDeclaration declaration)
protected void GenerateNamespace(CodeNamespace ns)
protected void GenerateNamespaceStart(CodeNamespace ns)
protected void GenerateNamespaceEnd(CodeNamespace ns)
protected void GenerateNamespaceImport(CodeNamespaceImport import)
protected void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
protected void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
private void OutputAttributes(CodeAttributeDeclarationCollection attributes, string prefix, LineHandling lineHandling)
protected void OutputAttributeArgument(CodeAttributeArgument argument)
private void OutputAttributeDeclaration(CodeAttributeDeclaration attribute)
protected void OutputDirection(FieldDirection direction)
protected void OutputFieldScopeModifier(MemberAttributes attributes)
private void OutputImplementationTypes(CodeTypeReferenceCollection implementationTypes, string member)
protected void OutputMemberAccessModifier(MemberAttributes attributes)
private void OutputVTableModifier(MemberAttributes attributes)
protected void OutputMemberScopeModifier(MemberAttributes attributes)
protected void OutputOperator(CodeBinaryOperatorType op)
private void OutputTypeAttributes(CodeTypeDeclaration declaration)
private void OutputTypeParameters(CodeTypeParameterCollection parameters)
private void OutputTypeParameterConstraints(CodeTypeParameter parameter)
protected void OutputTypeNamePair(CodeTypeReference typeRef, string name)
protected void OutputType(CodeTypeReference type)
protected string QuoteSnippetString(string value)
private void GenerateMemberReferenceExpression(CodeExpression targetObject, string memberName)
protected string CreateEscapedIdentifier(string value)
protected string CreateValidIdentifier(string value)
protected string GetTypeOutput(CodeTypeReference type)
protected bool IsValidIdentifier(string identifier)
protected bool Supports(GeneratorSupport supports)
private bool IsOverloaded(CodeMemberProperty property, CodeTypeDeclaration type)
private bool IsOverloaded(CodeMemberMethod method, CodeTypeDeclaration type)
private string GetEventName(CodeMemberEvent evt)
private string GetMethodName(CodeMemberMethod method)
private string GetPropertyName(CodeMemberProperty property)
private bool IsAbstract(MemberAttributes attributes)
}
public Microsoft.VisualBasic.VBCodeProvider : CodeDomProvider {
public string FileExtension
public LanguageOptions LanguageOptions
public void .ctor(IDictionary`2<string, string> providerOptions)
public string get_FileExtension()
public LanguageOptions get_LanguageOptions()
public ICodeCompiler CreateCompiler()
public ICodeGenerator CreateGenerator()
public TypeConverter GetConverter(Type type)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
}
public Microsoft.Win32.IntranetZoneCredentialPolicy : object {
public bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule)
}
public Microsoft.Win32.PowerModeChangedEventArgs : EventArgs {
private PowerModes mymode
public PowerModes Mode
public void .ctor(PowerModes mode)
public PowerModes get_Mode()
}
public Microsoft.Win32.PowerModeChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PowerModeChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, PowerModeChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.PowerModes : Enum {
public int value__
public PowerModes Resume
public PowerModes StatusChange
public PowerModes Suspend
}
public Microsoft.Win32.SessionEndedEventArgs : EventArgs {
private SessionEndReasons myreason
public SessionEndReasons Reason
public void .ctor(SessionEndReasons reason)
public SessionEndReasons get_Reason()
}
public Microsoft.Win32.SessionEndedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SessionEndedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SessionEndedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.SessionEndingEventArgs : EventArgs {
private SessionEndReasons myreason
private bool mycancel
public SessionEndReasons Reason
public bool Cancel
public void .ctor(SessionEndReasons reason)
public SessionEndReasons get_Reason()
public bool get_Cancel()
public void set_Cancel(bool value)
}
public Microsoft.Win32.SessionEndingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SessionEndingEventArgs e)
public IAsyncResult BeginInvoke(object sender, SessionEndingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.SessionEndReasons : Enum {
public int value__
public SessionEndReasons Logoff
public SessionEndReasons SystemShutdown
}
public Microsoft.Win32.SessionSwitchEventArgs : EventArgs {
private SessionSwitchReason reason
public SessionSwitchReason Reason
public void .ctor(SessionSwitchReason reason)
public SessionSwitchReason get_Reason()
}
public Microsoft.Win32.SessionSwitchEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SessionSwitchEventArgs e)
public IAsyncResult BeginInvoke(object sender, SessionSwitchEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.SessionSwitchReason : Enum {
public int value__
public SessionSwitchReason ConsoleConnect
public SessionSwitchReason ConsoleDisconnect
public SessionSwitchReason RemoteConnect
public SessionSwitchReason RemoteDisconnect
public SessionSwitchReason SessionLogon
public SessionSwitchReason SessionLogoff
public SessionSwitchReason SessionLock
public SessionSwitchReason SessionUnlock
public SessionSwitchReason SessionRemoteControl
}
public Microsoft.Win32.SystemEvents : object {
private Hashtable TimerStore
private TimerElapsedEventHandler TimerElapsed
public void add_DisplaySettingsChanged(EventHandler value)
public void remove_DisplaySettingsChanged(EventHandler value)
public void add_DisplaySettingsChanging(EventHandler value)
public void remove_DisplaySettingsChanging(EventHandler value)
public void add_EventsThreadShutdown(EventHandler value)
public void remove_EventsThreadShutdown(EventHandler value)
public void add_InstalledFontsChanged(EventHandler value)
public void remove_InstalledFontsChanged(EventHandler value)
public void add_LowMemory(EventHandler value)
public void remove_LowMemory(EventHandler value)
public void add_PaletteChanged(EventHandler value)
public void remove_PaletteChanged(EventHandler value)
public void add_PowerModeChanged(PowerModeChangedEventHandler value)
public void remove_PowerModeChanged(PowerModeChangedEventHandler value)
public void add_SessionEnded(SessionEndedEventHandler value)
public void remove_SessionEnded(SessionEndedEventHandler value)
public void add_SessionEnding(SessionEndingEventHandler value)
public void remove_SessionEnding(SessionEndingEventHandler value)
public void add_SessionSwitch(SessionSwitchEventHandler value)
public void remove_SessionSwitch(SessionSwitchEventHandler value)
public void add_TimeChanged(EventHandler value)
public void remove_TimeChanged(EventHandler value)
public void add_TimerElapsed(TimerElapsedEventHandler value)
public void remove_TimerElapsed(TimerElapsedEventHandler value)
public void add_UserPreferenceChanged(UserPreferenceChangedEventHandler value)
public void remove_UserPreferenceChanged(UserPreferenceChangedEventHandler value)
public void add_UserPreferenceChanging(UserPreferenceChangingEventHandler value)
public void remove_UserPreferenceChanging(UserPreferenceChangingEventHandler value)
public IntPtr CreateTimer(int interval)
public void KillTimer(IntPtr timerId)
private void InternalTimerElapsed(object e, ElapsedEventArgs args)
public void InvokeOnEventsThread(Delegate method)
}
public Microsoft.Win32.TimerElapsedEventArgs : EventArgs {
private IntPtr mytimerId
public IntPtr TimerId
public void .ctor(IntPtr timerId)
public IntPtr get_TimerId()
}
public Microsoft.Win32.TimerElapsedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, TimerElapsedEventArgs e)
public IAsyncResult BeginInvoke(object sender, TimerElapsedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.UserPreferenceCategory : Enum {
public int value__
public UserPreferenceCategory Accessibility
public UserPreferenceCategory Color
public UserPreferenceCategory Desktop
public UserPreferenceCategory General
public UserPreferenceCategory Icon
public UserPreferenceCategory Keyboard
public UserPreferenceCategory Menu
public UserPreferenceCategory Mouse
public UserPreferenceCategory Policy
public UserPreferenceCategory Power
public UserPreferenceCategory Screensaver
public UserPreferenceCategory Window
public UserPreferenceCategory Locale
public UserPreferenceCategory VisualStyle
}
public Microsoft.Win32.UserPreferenceChangedEventArgs : EventArgs {
private UserPreferenceCategory mycategory
public UserPreferenceCategory Category
public void .ctor(UserPreferenceCategory category)
public UserPreferenceCategory get_Category()
}
public Microsoft.Win32.UserPreferenceChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UserPreferenceChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UserPreferenceChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public Microsoft.Win32.UserPreferenceChangingEventArgs : EventArgs {
private UserPreferenceCategory mycategory
public UserPreferenceCategory Category
public void .ctor(UserPreferenceCategory category)
public UserPreferenceCategory get_Category()
}
public Microsoft.Win32.UserPreferenceChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UserPreferenceChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, UserPreferenceChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal Mono.Audio.AlsaDevice : AudioDevice {
private IntPtr handle
public void .ctor(string name)
private int snd_pcm_open(IntPtr& handle, string pcm_name, int stream, int mode)
private int snd_pcm_close(IntPtr handle)
private int snd_pcm_drain(IntPtr handle)
private int snd_pcm_writei(IntPtr handle, Byte[] buf, int size)
private int snd_pcm_set_params(IntPtr handle, int format, int access, int channels, int rate, int soft_resample, int latency)
protected void Finalize()
public void Dispose()
protected void Dispose(bool disposing)
public bool SetFormat(AudioFormat format, int channels, int rate)
public int PlaySample(Byte[] buffer, int num_frames)
public void Wait()
}
internal Mono.Audio.AuData : AudioData {
private Stream stream
private short channels
private ushort frame_divider
private int sample_rate
private int data_len
private AudioFormat format
public int Channels
public int Rate
public AudioFormat Format
public void .ctor(Stream data)
public void Play(AudioDevice dev)
public int get_Channels()
public int get_Rate()
public AudioFormat get_Format()
}
internal Mono.Audio.AudioData : object {
protected int buffer_size
private bool stopped
public int Channels
public int Rate
public AudioFormat Format
public bool IsStopped
public int get_Channels()
public int get_Rate()
public AudioFormat get_Format()
public void Setup(AudioDevice dev)
public void Play(AudioDevice dev)
public bool get_IsStopped()
public void set_IsStopped(bool value)
}
internal Mono.Audio.AudioDevice : object {
private AudioDevice TryAlsa(string name)
public AudioDevice CreateDevice(string name)
public bool SetFormat(AudioFormat format, int channels, int rate)
public int PlaySample(Byte[] buffer, int num_frames)
public void Wait()
}
internal Mono.Audio.AudioFormat : Enum {
public int value__
public AudioFormat S8
public AudioFormat U8
public AudioFormat S16_LE
public AudioFormat S16_BE
public AudioFormat U16_LE
public AudioFormat U16_BE
public AudioFormat S24_LE
public AudioFormat S24_BE
public AudioFormat U24_LE
public AudioFormat U24_BE
public AudioFormat S32_LE
public AudioFormat S32_BE
public AudioFormat U32_LE
public AudioFormat U32_BE
public AudioFormat FLOAT_LE
public AudioFormat FLOAT_BE
public AudioFormat FLOAT64_LE
public AudioFormat FLOAT64_BE
public AudioFormat IEC958_SUBFRAME_LE
public AudioFormat IEC958_SUBFRAME_BE
public AudioFormat MU_LAW
public AudioFormat A_LAW
public AudioFormat IMA_ADPCM
public AudioFormat MPEG
public AudioFormat GSM
}
internal Mono.Audio.WavData : AudioData {
private Stream stream
private short channels
private ushort frame_divider
private int sample_rate
private int data_len
private AudioFormat format
public int Channels
public int Rate
public AudioFormat Format
public void .ctor(Stream data)
public void Play(AudioDevice dev)
public int get_Channels()
public int get_Rate()
public AudioFormat get_Format()
}
internal Mono.Audio.Win32SoundPlayer : object {
private Byte[] _buffer
private bool _disposed
public Stream Stream
public void .ctor(Stream s)
private bool PlaySound(Byte[] ptrToSound, UIntPtr hmod, SoundFlags flags)
public void set_Stream(Stream value)
public void Dispose()
protected void Finalize()
protected void Dispose(bool disposing)
public void Play()
public void PlayLooping()
public void PlaySync()
public void Stop()
}
internal Mono.CSharp.CSharpCodeCompiler : CSharpCodeGenerator {
private string windowsMcsPath
private string windowsMonoPath
private Mutex mcsOutMutex
private StringCollection mcsOutput
private Dictionary`2<string, int> <>f__switch$map1
public void .ctor(IDictionary`2<string, string> providerOptions)
public CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e)
public CompilerResults CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
public CompilerResults CompileAssemblyFromFile(CompilerParameters options, string fileName)
public CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames)
public CompilerResults CompileAssemblyFromSource(CompilerParameters options, string source)
public CompilerResults CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources)
private CompilerResults CompileFromFileBatch(CompilerParameters options, String[] fileNames)
private void McsStderrDataReceived(object sender, DataReceivedEventArgs args)
private string BuildArgs(CompilerParameters options, String[] fileNames, IDictionary`2<string, string> providerOptions)
private CompilerError CreateErrorFromString(string error_string)
private string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension, bool keepFile)
private string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension)
private CompilerResults CompileFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
private CompilerResults CompileFromSourceBatch(CompilerParameters options, String[] sources)
}
internal Mono.CSharp.CSharpCodeGenerator : CodeGenerator {
private IDictionary`2<string, string> providerOptions
private bool dont_write_semicolon
private Hashtable keywordsTable
private String[] keywords
private Dictionary`2<string, int> <>f__switch$map0
protected IDictionary`2<string, string> ProviderOptions
protected string NullToken
public void .ctor(IDictionary`2<string, string> providerOptions)
protected IDictionary`2<string, string> get_ProviderOptions()
protected string get_NullToken()
protected void GenerateArrayCreateExpression(CodeArrayCreateExpression expression)
protected void GenerateBaseReferenceExpression(CodeBaseReferenceExpression expression)
protected void GenerateCastExpression(CodeCastExpression expression)
protected void GenerateCompileUnitStart(CodeCompileUnit compileUnit)
protected void GenerateCompileUnit(CodeCompileUnit compileUnit)
protected void GenerateDefaultValueExpression(CodeDefaultValueExpression e)
protected void GenerateDelegateCreateExpression(CodeDelegateCreateExpression expression)
protected void GenerateFieldReferenceExpression(CodeFieldReferenceExpression expression)
protected void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression expression)
protected void GenerateVariableReferenceExpression(CodeVariableReferenceExpression expression)
protected void GenerateIndexerExpression(CodeIndexerExpression expression)
protected void GenerateArrayIndexerExpression(CodeArrayIndexerExpression expression)
protected void GenerateSnippetExpression(CodeSnippetExpression expression)
protected void GenerateMethodInvokeExpression(CodeMethodInvokeExpression expression)
protected void GenerateMethodReferenceExpression(CodeMethodReferenceExpression expression)
protected void GenerateEventReferenceExpression(CodeEventReferenceExpression expression)
protected void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression expression)
protected void GenerateObjectCreateExpression(CodeObjectCreateExpression expression)
protected void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression expression)
protected void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression expression)
protected void GenerateThisReferenceExpression(CodeThisReferenceExpression expression)
protected void GenerateExpressionStatement(CodeExpressionStatement statement)
protected void GenerateIterationStatement(CodeIterationStatement statement)
protected void GenerateThrowExceptionStatement(CodeThrowExceptionStatement statement)
protected void GenerateComment(CodeComment comment)
protected void GenerateMethodReturnStatement(CodeMethodReturnStatement statement)
protected void GenerateConditionStatement(CodeConditionStatement statement)
protected void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement statement)
protected void GenerateAssignStatement(CodeAssignStatement statement)
protected void GenerateAttachEventStatement(CodeAttachEventStatement statement)
protected void GenerateRemoveEventStatement(CodeRemoveEventStatement statement)
protected void GenerateGotoStatement(CodeGotoStatement statement)
protected void GenerateLabeledStatement(CodeLabeledStatement statement)
protected void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement statement)
protected void GenerateLinePragmaStart(CodeLinePragma linePragma)
protected void GenerateLinePragmaEnd(CodeLinePragma linePragma)
protected void GenerateEvent(CodeMemberEvent eventRef, CodeTypeDeclaration declaration)
protected void GenerateField(CodeMemberField field)
protected void GenerateSnippetMember(CodeSnippetTypeMember member)
protected void GenerateEntryPointMethod(CodeEntryPointMethod method, CodeTypeDeclaration declaration)
protected void GenerateMethod(CodeMemberMethod method, CodeTypeDeclaration declaration)
private bool IsAbstract(MemberAttributes attributes)
protected void GenerateProperty(CodeMemberProperty property, CodeTypeDeclaration declaration)
protected void GenerateConstructor(CodeConstructor constructor, CodeTypeDeclaration declaration)
protected void GenerateTypeConstructor(CodeTypeConstructor constructor)
protected void GenerateTypeStart(CodeTypeDeclaration declaration)
protected void GenerateTypeEnd(CodeTypeDeclaration declaration)
protected void GenerateNamespaceStart(CodeNamespace ns)
protected void GenerateNamespaceEnd(CodeNamespace ns)
protected void GenerateNamespaceImport(CodeNamespaceImport import)
protected void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
protected void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
private void OutputStartBrace()
private void OutputAttributes(CodeAttributeDeclarationCollection attributes, string prefix, bool inline)
private void OutputAttributeDeclaration(CodeAttributeDeclaration attribute)
protected void OutputType(CodeTypeReference type)
private void OutputVTableModifier(MemberAttributes attributes)
protected void OutputFieldScopeModifier(MemberAttributes attributes)
protected void OutputMemberAccessModifier(MemberAttributes attributes)
protected void OutputMemberScopeModifier(MemberAttributes attributes)
private void OutputTypeAttributes(CodeTypeDeclaration declaration)
protected string QuoteSnippetString(string value)
protected void GeneratePrimitiveExpression(CodePrimitiveExpression e)
private void GenerateCharValue(char c)
protected void GenerateSingleFloatValue(float f)
protected void GenerateDecimalValue(decimal d)
protected void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
protected void GenerateTypeOfExpression(CodeTypeOfExpression e)
protected string CreateEscapedIdentifier(string value)
protected string CreateValidIdentifier(string value)
protected string GetTypeOutput(CodeTypeReference type)
private string DetermineTypeOutput(CodeTypeReference type)
private bool is_identifier_start_character(char c)
private bool is_identifier_part_character(char c)
protected bool IsValidIdentifier(string identifier)
protected bool Supports(GeneratorSupport supports)
protected void GenerateDirectives(CodeDirectiveCollection directives)
private void GenerateCodeChecksumPragma(CodeChecksumPragma pragma)
private void GenerateCodeRegionDirective(CodeRegionDirective region)
private void GenerateGenericsParameters(CodeTypeParameterCollection parameters)
private void GenerateGenericsConstraints(CodeTypeParameterCollection parameters)
private string GetTypeArguments(CodeTypeReferenceCollection collection)
private void OutputTypeArguments(CodeTypeReferenceCollection typeArguments, StringBuilder sb, int count)
private string GetSafeName(string id)
private void FillKeywordTable()
}
internal Mono.Http.NtlmClient : object {
private Hashtable cache
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
internal Mono.Http.NtlmSession : object {
private MessageBase message
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
}
internal Mono.Security.X509.OSX509Certificates : object {
public string SecurityLibrary
public string CoreFoundationLibrary
private IntPtr sslsecpolicy
private IntPtr SecCertificateCreateWithData(IntPtr allocator, IntPtr nsdataRef)
private int SecTrustCreateWithCertificates(IntPtr certOrCertArray, IntPtr policies, IntPtr& sectrustref)
private IntPtr SecPolicyCreateSSL(int server, IntPtr cfStringHostname)
private int SecTrustEvaluate(IntPtr secTrustRef, SecTrustResult& secTrustResultTime)
private IntPtr CFDataCreate(IntPtr allocator, Byte* bytes, IntPtr length)
private void CFRelease(IntPtr handle)
private IntPtr CFArrayCreate(IntPtr allocator, IntPtr values, IntPtr numValues, IntPtr callbacks)
private IntPtr MakeCFData(Byte[] data)
private IntPtr FromIntPtrs(IntPtr[] values)
public SecTrustResult TrustEvaluateSsl(X509CertificateCollection certificates)
private SecTrustResult _TrustEvaluateSsl(X509CertificateCollection certificates)
}
public System.CodeDom.CodeArgumentReferenceExpression : CodeExpression {
private string parameterName
public string ParameterName
public void .ctor(string name)
public string get_ParameterName()
public void set_ParameterName(string value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeArrayCreateExpression : CodeExpression {
private CodeTypeReference createType
private CodeExpressionCollection initializers
private CodeExpression sizeExpression
private int size
public CodeTypeReference CreateType
public CodeExpressionCollection Initializers
public CodeExpression SizeExpression
public int Size
public void .ctor(CodeTypeReference createType, CodeExpression size)
public void .ctor(CodeTypeReference createType, CodeExpression[] initializers)
public void .ctor(CodeTypeReference createType, int size)
public void .ctor(string createType, CodeExpression size)
public void .ctor(string createType, CodeExpression[] initializers)
public void .ctor(string createType, int size)
public void .ctor(Type createType, CodeExpression size)
public void .ctor(Type createType, CodeExpression[] initializers)
public void .ctor(Type createType, int size)
public CodeTypeReference get_CreateType()
public void set_CreateType(CodeTypeReference value)
public CodeExpressionCollection get_Initializers()
public CodeExpression get_SizeExpression()
public void set_SizeExpression(CodeExpression value)
public int get_Size()
public void set_Size(int value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeArrayIndexerExpression : CodeExpression {
private CodeExpressionCollection indices
private CodeExpression targetObject
public CodeExpressionCollection Indices
public CodeExpression TargetObject
public void .ctor(CodeExpression targetObject, CodeExpression[] indices)
public CodeExpressionCollection get_Indices()
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeAssignStatement : CodeStatement {
private CodeExpression left
private CodeExpression right
public CodeExpression Left
public CodeExpression Right
public void .ctor(CodeExpression left, CodeExpression right)
public CodeExpression get_Left()
public void set_Left(CodeExpression value)
public CodeExpression get_Right()
public void set_Right(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeAttachEventStatement : CodeStatement {
private CodeEventReferenceExpression eventRef
private CodeExpression listener
public CodeEventReferenceExpression Event
public CodeExpression Listener
public void .ctor(CodeEventReferenceExpression eventRef, CodeExpression listener)
public void .ctor(CodeExpression targetObject, string eventName, CodeExpression listener)
public CodeEventReferenceExpression get_Event()
public void set_Event(CodeEventReferenceExpression value)
public CodeExpression get_Listener()
public void set_Listener(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeAttributeArgument : object {
private string name
private CodeExpression value
public string Name
public CodeExpression Value
public void .ctor(CodeExpression value)
public void .ctor(string name, CodeExpression value)
public string get_Name()
public void set_Name(string value)
public CodeExpression get_Value()
public void set_Value(CodeExpression value)
}
public System.CodeDom.CodeAttributeArgumentCollection : CollectionBase {
public CodeAttributeArgument Item
public void .ctor(CodeAttributeArgument[] value)
public void .ctor(CodeAttributeArgumentCollection value)
public CodeAttributeArgument get_Item(int index)
public void set_Item(int index, CodeAttributeArgument value)
public int Add(CodeAttributeArgument value)
public void AddRange(CodeAttributeArgument[] value)
public void AddRange(CodeAttributeArgumentCollection value)
public bool Contains(CodeAttributeArgument value)
public void CopyTo(CodeAttributeArgument[] array, int index)
public int IndexOf(CodeAttributeArgument value)
public void Insert(int index, CodeAttributeArgument value)
public void Remove(CodeAttributeArgument value)
}
public System.CodeDom.CodeAttributeDeclaration : object {
private string name
private CodeAttributeArgumentCollection arguments
private CodeTypeReference attribute
public CodeAttributeArgumentCollection Arguments
public string Name
public CodeTypeReference AttributeType
public void .ctor(string name)
public void .ctor(string name, CodeAttributeArgument[] arguments)
public void .ctor(CodeTypeReference attributeType)
public void .ctor(CodeTypeReference attributeType, CodeAttributeArgument[] arguments)
public CodeAttributeArgumentCollection get_Arguments()
public string get_Name()
public void set_Name(string value)
public CodeTypeReference get_AttributeType()
}
public System.CodeDom.CodeAttributeDeclarationCollection : CollectionBase {
public CodeAttributeDeclaration Item
public void .ctor(CodeAttributeDeclaration[] value)
public void .ctor(CodeAttributeDeclarationCollection value)
public CodeAttributeDeclaration get_Item(int index)
public void set_Item(int index, CodeAttributeDeclaration value)
public int Add(CodeAttributeDeclaration value)
public void AddRange(CodeAttributeDeclaration[] value)
public void AddRange(CodeAttributeDeclarationCollection value)
public bool Contains(CodeAttributeDeclaration value)
public void CopyTo(CodeAttributeDeclaration[] array, int index)
public int IndexOf(CodeAttributeDeclaration value)
public void Insert(int index, CodeAttributeDeclaration value)
public void Remove(CodeAttributeDeclaration value)
}
public System.CodeDom.CodeBaseReferenceExpression : CodeExpression {
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeBinaryOperatorExpression : CodeExpression {
private CodeExpression left
private CodeExpression right
private CodeBinaryOperatorType op
public CodeExpression Left
public CodeBinaryOperatorType Operator
public CodeExpression Right
public void .ctor(CodeExpression left, CodeBinaryOperatorType op, CodeExpression right)
public CodeExpression get_Left()
public void set_Left(CodeExpression value)
public CodeBinaryOperatorType get_Operator()
public void set_Operator(CodeBinaryOperatorType value)
public CodeExpression get_Right()
public void set_Right(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeBinaryOperatorType : Enum {
public int value__
public CodeBinaryOperatorType Add
public CodeBinaryOperatorType Subtract
public CodeBinaryOperatorType Multiply
public CodeBinaryOperatorType Divide
public CodeBinaryOperatorType Modulus
public CodeBinaryOperatorType Assign
public CodeBinaryOperatorType IdentityInequality
public CodeBinaryOperatorType IdentityEquality
public CodeBinaryOperatorType ValueEquality
public CodeBinaryOperatorType BitwiseOr
public CodeBinaryOperatorType BitwiseAnd
public CodeBinaryOperatorType BooleanOr
public CodeBinaryOperatorType BooleanAnd
public CodeBinaryOperatorType LessThan
public CodeBinaryOperatorType LessThanOrEqual
public CodeBinaryOperatorType GreaterThan
public CodeBinaryOperatorType GreaterThanOrEqual
}
public System.CodeDom.CodeCastExpression : CodeExpression {
private CodeTypeReference targetType
private CodeExpression expression
public CodeExpression Expression
public CodeTypeReference TargetType
public void .ctor(CodeTypeReference targetType, CodeExpression expression)
public void .ctor(string targetType, CodeExpression expression)
public void .ctor(Type targetType, CodeExpression expression)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
public CodeTypeReference get_TargetType()
public void set_TargetType(CodeTypeReference value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeCatchClause : object {
private CodeTypeReference catchExceptionType
private string localName
private CodeStatementCollection statements
public CodeTypeReference CatchExceptionType
public string LocalName
public CodeStatementCollection Statements
public void .ctor(string localName)
public void .ctor(string localName, CodeTypeReference catchExceptionType)
public void .ctor(string localName, CodeTypeReference catchExceptionType, CodeStatement[] statements)
public CodeTypeReference get_CatchExceptionType()
public void set_CatchExceptionType(CodeTypeReference value)
public string get_LocalName()
public void set_LocalName(string value)
public CodeStatementCollection get_Statements()
}
public System.CodeDom.CodeCatchClauseCollection : CollectionBase {
public CodeCatchClause Item
public void .ctor(CodeCatchClause[] value)
public void .ctor(CodeCatchClauseCollection value)
public CodeCatchClause get_Item(int index)
public void set_Item(int index, CodeCatchClause value)
public int Add(CodeCatchClause value)
public void AddRange(CodeCatchClause[] value)
public void AddRange(CodeCatchClauseCollection value)
public bool Contains(CodeCatchClause value)
public void CopyTo(CodeCatchClause[] array, int index)
public int IndexOf(CodeCatchClause value)
public void Insert(int index, CodeCatchClause value)
public void Remove(CodeCatchClause value)
}
public System.CodeDom.CodeChecksumPragma : CodeDirective {
private string fileName
private Guid checksumAlgorithmId
private Byte[] checksumData
public Guid ChecksumAlgorithmId
public Byte[] ChecksumData
public string FileName
public void .ctor(string fileName, Guid checksumAlgorithmId, Byte[] checksumData)
public Guid get_ChecksumAlgorithmId()
public void set_ChecksumAlgorithmId(Guid value)
public Byte[] get_ChecksumData()
public void set_ChecksumData(Byte[] value)
public string get_FileName()
public void set_FileName(string value)
}
public System.CodeDom.CodeComment : CodeObject {
private bool docComment
private string text
public bool DocComment
public string Text
public void .ctor(string text)
public void .ctor(string text, bool docComment)
public bool get_DocComment()
public void set_DocComment(bool value)
public string get_Text()
public void set_Text(string value)
}
public System.CodeDom.CodeCommentStatement : CodeStatement {
private CodeComment comment
public CodeComment Comment
public void .ctor(CodeComment comment)
public void .ctor(string text)
public void .ctor(string text, bool docComment)
public CodeComment get_Comment()
public void set_Comment(CodeComment value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeCommentStatementCollection : CollectionBase {
public CodeCommentStatement Item
public void .ctor(CodeCommentStatement[] value)
public void .ctor(CodeCommentStatementCollection value)
public CodeCommentStatement get_Item(int index)
public void set_Item(int index, CodeCommentStatement value)
public int Add(CodeCommentStatement value)
public void AddRange(CodeCommentStatement[] value)
public void AddRange(CodeCommentStatementCollection value)
public bool Contains(CodeCommentStatement value)
public void CopyTo(CodeCommentStatement[] array, int index)
public int IndexOf(CodeCommentStatement value)
public void Insert(int index, CodeCommentStatement value)
public void Remove(CodeCommentStatement value)
}
public System.CodeDom.CodeCompileUnit : CodeObject {
private CodeAttributeDeclarationCollection attributes
private CodeNamespaceCollection namespaces
private StringCollection assemblies
private CodeDirectiveCollection startDirectives
private CodeDirectiveCollection endDirectives
public CodeAttributeDeclarationCollection AssemblyCustomAttributes
public CodeNamespaceCollection Namespaces
public StringCollection ReferencedAssemblies
public CodeDirectiveCollection StartDirectives
public CodeDirectiveCollection EndDirectives
public CodeAttributeDeclarationCollection get_AssemblyCustomAttributes()
public CodeNamespaceCollection get_Namespaces()
public StringCollection get_ReferencedAssemblies()
public CodeDirectiveCollection get_StartDirectives()
public CodeDirectiveCollection get_EndDirectives()
}
public System.CodeDom.CodeConditionStatement : CodeStatement {
private CodeExpression condition
private CodeStatementCollection trueStatements
private CodeStatementCollection falseStatements
public CodeExpression Condition
public CodeStatementCollection FalseStatements
public CodeStatementCollection TrueStatements
public void .ctor(CodeExpression condition, CodeStatement[] trueStatements)
public void .ctor(CodeExpression condition, CodeStatement[] trueStatements, CodeStatement[] falseStatements)
public CodeExpression get_Condition()
public void set_Condition(CodeExpression value)
public CodeStatementCollection get_FalseStatements()
public CodeStatementCollection get_TrueStatements()
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeConstructor : CodeMemberMethod {
private CodeExpressionCollection baseConstructorArgs
private CodeExpressionCollection chainedConstructorArgs
public CodeExpressionCollection BaseConstructorArgs
public CodeExpressionCollection ChainedConstructorArgs
public CodeExpressionCollection get_BaseConstructorArgs()
public CodeExpressionCollection get_ChainedConstructorArgs()
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeDefaultValueExpression : CodeExpression {
private CodeTypeReference type
public CodeTypeReference Type
public void .ctor(CodeTypeReference type)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeDelegateCreateExpression : CodeExpression {
private CodeTypeReference delegateType
private string methodName
private CodeExpression targetObject
public CodeTypeReference DelegateType
public string MethodName
public CodeExpression TargetObject
public void .ctor(CodeTypeReference delegateType, CodeExpression targetObject, string methodName)
public CodeTypeReference get_DelegateType()
public void set_DelegateType(CodeTypeReference value)
public string get_MethodName()
public void set_MethodName(string value)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeDelegateInvokeExpression : CodeExpression {
private CodeExpressionCollection parameters
private CodeExpression targetObject
public CodeExpressionCollection Parameters
public CodeExpression TargetObject
public void .ctor(CodeExpression targetObject)
public void .ctor(CodeExpression targetObject, CodeExpression[] parameters)
public CodeExpressionCollection get_Parameters()
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeDirectionExpression : CodeExpression {
private FieldDirection direction
private CodeExpression expression
public FieldDirection Direction
public CodeExpression Expression
public void .ctor(FieldDirection direction, CodeExpression expression)
public FieldDirection get_Direction()
public void set_Direction(FieldDirection value)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeDirectiveCollection : CollectionBase {
public CodeDirective Item
public void .ctor(CodeDirective[] value)
public void .ctor(CodeDirectiveCollection value)
public CodeDirective get_Item(int index)
public void set_Item(int index, CodeDirective value)
public int Add(CodeDirective value)
public void AddRange(CodeDirective[] value)
public void AddRange(CodeDirectiveCollection value)
public bool Contains(CodeDirective value)
public void CopyTo(CodeDirective[] array, int index)
public int IndexOf(CodeDirective value)
public void Insert(int index, CodeDirective value)
public void Remove(CodeDirective value)
}
public System.CodeDom.CodeEntryPointMethod : CodeMemberMethod {
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeEventReferenceExpression : CodeExpression {
private string eventName
private CodeExpression targetObject
public string EventName
public CodeExpression TargetObject
public void .ctor(CodeExpression targetObject, string eventName)
public string get_EventName()
public void set_EventName(string value)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeExpressionCollection : CollectionBase {
public CodeExpression Item
public void .ctor(CodeExpression[] value)
public void .ctor(CodeExpressionCollection value)
public CodeExpression get_Item(int index)
public void set_Item(int index, CodeExpression value)
public int Add(CodeExpression value)
public void AddRange(CodeExpression[] value)
public void AddRange(CodeExpressionCollection value)
public bool Contains(CodeExpression value)
public void CopyTo(CodeExpression[] array, int index)
public int IndexOf(CodeExpression value)
public void Insert(int index, CodeExpression value)
public void Remove(CodeExpression value)
}
public System.CodeDom.CodeExpressionStatement : CodeStatement {
private CodeExpression expression
public CodeExpression Expression
public void .ctor(CodeExpression expression)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeFieldReferenceExpression : CodeExpression {
private CodeExpression targetObject
private string fieldName
public string FieldName
public CodeExpression TargetObject
public void .ctor(CodeExpression targetObject, string fieldName)
public string get_FieldName()
public void set_FieldName(string value)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeGotoStatement : CodeStatement {
private string label
public string Label
public void .ctor(string label)
public string get_Label()
public void set_Label(string value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeIndexerExpression : CodeExpression {
private CodeExpression targetObject
private CodeExpressionCollection indices
public CodeExpressionCollection Indices
public CodeExpression TargetObject
public void .ctor(CodeExpression targetObject, CodeExpression[] indices)
public CodeExpressionCollection get_Indices()
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeIterationStatement : CodeStatement {
private CodeStatement incrementStatement
private CodeStatement initStatement
private CodeStatementCollection statements
private CodeExpression testExpression
public CodeStatement IncrementStatement
public CodeStatement InitStatement
public CodeStatementCollection Statements
public CodeExpression TestExpression
public void .ctor(CodeStatement initStatement, CodeExpression testExpression, CodeStatement incrementStatement, CodeStatement[] statements)
public CodeStatement get_IncrementStatement()
public void set_IncrementStatement(CodeStatement value)
public CodeStatement get_InitStatement()
public void set_InitStatement(CodeStatement value)
public CodeStatementCollection get_Statements()
public CodeExpression get_TestExpression()
public void set_TestExpression(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeLabeledStatement : CodeStatement {
private string label
private CodeStatement statement
public string Label
public CodeStatement Statement
public void .ctor(string label)
public void .ctor(string label, CodeStatement statement)
public string get_Label()
public void set_Label(string value)
public CodeStatement get_Statement()
public void set_Statement(CodeStatement value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeLinePragma : object {
private string fileName
private int lineNumber
public string FileName
public int LineNumber
public void .ctor(string fileName, int lineNumber)
public string get_FileName()
public void set_FileName(string value)
public int get_LineNumber()
public void set_LineNumber(int value)
}
public System.CodeDom.CodeMemberEvent : CodeTypeMember {
private CodeTypeReferenceCollection implementationTypes
private CodeTypeReference privateImplementationType
private CodeTypeReference type
public CodeTypeReferenceCollection ImplementationTypes
public CodeTypeReference PrivateImplementationType
public CodeTypeReference Type
public CodeTypeReferenceCollection get_ImplementationTypes()
public CodeTypeReference get_PrivateImplementationType()
public void set_PrivateImplementationType(CodeTypeReference value)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeMemberField : CodeTypeMember {
private CodeExpression initExpression
private CodeTypeReference type
public CodeExpression InitExpression
public CodeTypeReference Type
public void .ctor(CodeTypeReference type, string name)
public void .ctor(string type, string name)
public void .ctor(Type type, string name)
public CodeExpression get_InitExpression()
public void set_InitExpression(CodeExpression value)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeMemberMethod : CodeTypeMember {
private CodeTypeReferenceCollection implementationTypes
private CodeParameterDeclarationExpressionCollection parameters
private CodeTypeReference privateImplements
private CodeTypeReference returnType
private CodeStatementCollection statements
private CodeAttributeDeclarationCollection returnAttributes
private int populated
private CodeTypeParameterCollection typeParameters
private EventHandler PopulateImplementationTypes
private EventHandler PopulateParameters
private EventHandler PopulateStatements
public CodeTypeReferenceCollection ImplementationTypes
public CodeParameterDeclarationExpressionCollection Parameters
public CodeTypeReference PrivateImplementationType
public CodeTypeReference ReturnType
public CodeStatementCollection Statements
public CodeAttributeDeclarationCollection ReturnTypeCustomAttributes
public CodeTypeParameterCollection TypeParameters
public void add_PopulateImplementationTypes(EventHandler value)
public void remove_PopulateImplementationTypes(EventHandler value)
public void add_PopulateParameters(EventHandler value)
public void remove_PopulateParameters(EventHandler value)
public void add_PopulateStatements(EventHandler value)
public void remove_PopulateStatements(EventHandler value)
public CodeTypeReferenceCollection get_ImplementationTypes()
public CodeParameterDeclarationExpressionCollection get_Parameters()
public CodeTypeReference get_PrivateImplementationType()
public void set_PrivateImplementationType(CodeTypeReference value)
public CodeTypeReference get_ReturnType()
public void set_ReturnType(CodeTypeReference value)
public CodeStatementCollection get_Statements()
public CodeAttributeDeclarationCollection get_ReturnTypeCustomAttributes()
public CodeTypeParameterCollection get_TypeParameters()
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeMemberProperty : CodeTypeMember {
private CodeStatementCollection getStatements
private bool hasGet
private bool hasSet
private CodeTypeReferenceCollection implementationTypes
private CodeParameterDeclarationExpressionCollection parameters
private CodeTypeReference privateImplementationType
private CodeStatementCollection setStatements
private CodeTypeReference type
public CodeStatementCollection GetStatements
public bool HasGet
public bool HasSet
public CodeTypeReferenceCollection ImplementationTypes
public CodeParameterDeclarationExpressionCollection Parameters
public CodeTypeReference PrivateImplementationType
public CodeStatementCollection SetStatements
public CodeTypeReference Type
public CodeStatementCollection get_GetStatements()
public bool get_HasGet()
public void set_HasGet(bool value)
public bool get_HasSet()
public void set_HasSet(bool value)
public CodeTypeReferenceCollection get_ImplementationTypes()
public CodeParameterDeclarationExpressionCollection get_Parameters()
public CodeTypeReference get_PrivateImplementationType()
public void set_PrivateImplementationType(CodeTypeReference value)
public CodeStatementCollection get_SetStatements()
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeMethodInvokeExpression : CodeExpression {
private CodeMethodReferenceExpression method
private CodeExpressionCollection parameters
public CodeMethodReferenceExpression Method
public CodeExpressionCollection Parameters
public void .ctor(CodeMethodReferenceExpression method, CodeExpression[] parameters)
public void .ctor(CodeExpression targetObject, string methodName, CodeExpression[] parameters)
public CodeMethodReferenceExpression get_Method()
public void set_Method(CodeMethodReferenceExpression value)
public CodeExpressionCollection get_Parameters()
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeMethodReferenceExpression : CodeExpression {
private string methodName
private CodeExpression targetObject
private CodeTypeReferenceCollection typeArguments
public string MethodName
public CodeExpression TargetObject
public CodeTypeReferenceCollection TypeArguments
public void .ctor(CodeExpression targetObject, string methodName)
public void .ctor(CodeExpression targetObject, string methodName, CodeTypeReference[] typeParameters)
public string get_MethodName()
public void set_MethodName(string value)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
public CodeTypeReferenceCollection get_TypeArguments()
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeMethodReturnStatement : CodeStatement {
private CodeExpression expression
public CodeExpression Expression
public void .ctor(CodeExpression expression)
public CodeExpression get_Expression()
public void set_Expression(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeNamespace : CodeObject {
private CodeCommentStatementCollection comments
private CodeNamespaceImportCollection imports
private CodeNamespaceCollection namespaces
private CodeTypeDeclarationCollection classes
private string name
private int populated
private EventHandler PopulateComments
private EventHandler PopulateImports
private EventHandler PopulateTypes
public CodeCommentStatementCollection Comments
public CodeNamespaceImportCollection Imports
public string Name
public CodeTypeDeclarationCollection Types
public void .ctor(string name)
public void add_PopulateComments(EventHandler value)
public void remove_PopulateComments(EventHandler value)
public void add_PopulateImports(EventHandler value)
public void remove_PopulateImports(EventHandler value)
public void add_PopulateTypes(EventHandler value)
public void remove_PopulateTypes(EventHandler value)
public CodeCommentStatementCollection get_Comments()
public CodeNamespaceImportCollection get_Imports()
public string get_Name()
public void set_Name(string value)
public CodeTypeDeclarationCollection get_Types()
}
public System.CodeDom.CodeNamespaceCollection : CollectionBase {
public CodeNamespace Item
public void .ctor(CodeNamespace[] value)
public void .ctor(CodeNamespaceCollection value)
public CodeNamespace get_Item(int index)
public void set_Item(int index, CodeNamespace value)
public int Add(CodeNamespace value)
public void AddRange(CodeNamespace[] value)
public void AddRange(CodeNamespaceCollection value)
public bool Contains(CodeNamespace value)
public void CopyTo(CodeNamespace[] array, int index)
public int IndexOf(CodeNamespace value)
public void Insert(int index, CodeNamespace value)
public void Remove(CodeNamespace value)
}
public System.CodeDom.CodeNamespaceImport : CodeObject {
private CodeLinePragma linePragma
private string nameSpace
public CodeLinePragma LinePragma
public string Namespace
public void .ctor(string nameSpace)
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public string get_Namespace()
public void set_Namespace(string value)
}
public System.CodeDom.CodeNamespaceImportCollection : object {
private Hashtable keys
private ArrayList data
private int System.Collections.ICollection.Count
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
public int Count
public CodeNamespaceImport Item
private int System.Collections.ICollection.get_Count()
private void System.Collections.IList.Clear()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public CodeNamespaceImport get_Item(int index)
public void set_Item(int index, CodeNamespaceImport value)
public void Add(CodeNamespaceImport value)
public void AddRange(CodeNamespaceImport[] value)
public void Clear()
public IEnumerator GetEnumerator()
}
public System.CodeDom.CodeObject : object {
private IDictionary userData
public IDictionary UserData
public IDictionary get_UserData()
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeObjectCreateExpression : CodeExpression {
private CodeTypeReference createType
private CodeExpressionCollection parameters
public CodeTypeReference CreateType
public CodeExpressionCollection Parameters
public void .ctor(CodeTypeReference createType, CodeExpression[] parameters)
public void .ctor(string createType, CodeExpression[] parameters)
public void .ctor(Type createType, CodeExpression[] parameters)
public CodeTypeReference get_CreateType()
public void set_CreateType(CodeTypeReference value)
public CodeExpressionCollection get_Parameters()
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeParameterDeclarationExpression : CodeExpression {
private CodeAttributeDeclarationCollection customAttributes
private FieldDirection direction
private string name
private CodeTypeReference type
public CodeAttributeDeclarationCollection CustomAttributes
public FieldDirection Direction
public string Name
public CodeTypeReference Type
public void .ctor(CodeTypeReference type, string name)
public void .ctor(string type, string name)
public void .ctor(Type type, string name)
public CodeAttributeDeclarationCollection get_CustomAttributes()
public void set_CustomAttributes(CodeAttributeDeclarationCollection value)
public FieldDirection get_Direction()
public void set_Direction(FieldDirection value)
public string get_Name()
public void set_Name(string value)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeParameterDeclarationExpressionCollection : CollectionBase {
public CodeParameterDeclarationExpression Item
public void .ctor(CodeParameterDeclarationExpression[] value)
public void .ctor(CodeParameterDeclarationExpressionCollection value)
public CodeParameterDeclarationExpression get_Item(int index)
public void set_Item(int index, CodeParameterDeclarationExpression value)
public int Add(CodeParameterDeclarationExpression value)
public void AddRange(CodeParameterDeclarationExpression[] value)
public void AddRange(CodeParameterDeclarationExpressionCollection value)
public bool Contains(CodeParameterDeclarationExpression value)
public void CopyTo(CodeParameterDeclarationExpression[] array, int index)
public int IndexOf(CodeParameterDeclarationExpression value)
public void Insert(int index, CodeParameterDeclarationExpression value)
public void Remove(CodeParameterDeclarationExpression value)
}
public System.CodeDom.CodePrimitiveExpression : CodeExpression {
private object value
public object Value
public void .ctor(object value)
public object get_Value()
public void set_Value(object value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodePropertyReferenceExpression : CodeExpression {
private CodeExpression targetObject
private string propertyName
public string PropertyName
public CodeExpression TargetObject
public void .ctor(CodeExpression targetObject, string propertyName)
public string get_PropertyName()
public void set_PropertyName(string value)
public CodeExpression get_TargetObject()
public void set_TargetObject(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodePropertySetValueReferenceExpression : CodeExpression {
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeRegionDirective : CodeDirective {
private CodeRegionMode regionMode
private string regionText
public CodeRegionMode RegionMode
public string RegionText
public void .ctor(CodeRegionMode regionMode, string regionText)
public CodeRegionMode get_RegionMode()
public void set_RegionMode(CodeRegionMode value)
public string get_RegionText()
public void set_RegionText(string value)
}
public System.CodeDom.CodeRegionMode : Enum {
public int value__
public CodeRegionMode None
public CodeRegionMode Start
public CodeRegionMode End
}
public System.CodeDom.CodeRemoveEventStatement : CodeStatement {
private CodeEventReferenceExpression eventRef
private CodeExpression listener
public CodeEventReferenceExpression Event
public CodeExpression Listener
public void .ctor(CodeEventReferenceExpression eventRef, CodeExpression listener)
public void .ctor(CodeExpression targetObject, string eventName, CodeExpression listener)
public CodeEventReferenceExpression get_Event()
public void set_Event(CodeEventReferenceExpression value)
public CodeExpression get_Listener()
public void set_Listener(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeSnippetCompileUnit : CodeCompileUnit {
private CodeLinePragma linePragma
private string value
public CodeLinePragma LinePragma
public string Value
public void .ctor(string value)
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public string get_Value()
public void set_Value(string value)
}
public System.CodeDom.CodeSnippetExpression : CodeExpression {
private string value
public string Value
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeSnippetStatement : CodeStatement {
private string value
public string Value
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
}
public System.CodeDom.CodeSnippetTypeMember : CodeTypeMember {
private string text
public string Text
public void .ctor(string text)
public string get_Text()
public void set_Text(string value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeStatement : CodeObject {
private CodeLinePragma linePragma
private CodeDirectiveCollection endDirectives
private CodeDirectiveCollection startDirectives
public CodeLinePragma LinePragma
public CodeDirectiveCollection EndDirectives
public CodeDirectiveCollection StartDirectives
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public CodeDirectiveCollection get_EndDirectives()
public CodeDirectiveCollection get_StartDirectives()
}
public System.CodeDom.CodeStatementCollection : CollectionBase {
public CodeStatement Item
public void .ctor(CodeStatement[] value)
public void .ctor(CodeStatementCollection value)
public CodeStatement get_Item(int index)
public void set_Item(int index, CodeStatement value)
public int Add(CodeStatement value)
public int Add(CodeExpression value)
public void AddRange(CodeStatement[] value)
public void AddRange(CodeStatementCollection value)
public bool Contains(CodeStatement value)
public void CopyTo(CodeStatement[] array, int index)
public int IndexOf(CodeStatement value)
public void Insert(int index, CodeStatement value)
public void Remove(CodeStatement value)
}
public System.CodeDom.CodeThisReferenceExpression : CodeExpression {
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeThrowExceptionStatement : CodeStatement {
private CodeExpression toThrow
public CodeExpression ToThrow
public void .ctor(CodeExpression toThrow)
public CodeExpression get_ToThrow()
public void set_ToThrow(CodeExpression value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeTryCatchFinallyStatement : CodeStatement {
private CodeStatementCollection tryStatements
private CodeStatementCollection finallyStatements
private CodeCatchClauseCollection catchClauses
public CodeStatementCollection FinallyStatements
public CodeStatementCollection TryStatements
public CodeCatchClauseCollection CatchClauses
public void .ctor(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses)
public void .ctor(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses, CodeStatement[] finallyStatements)
public CodeStatementCollection get_FinallyStatements()
public CodeStatementCollection get_TryStatements()
public CodeCatchClauseCollection get_CatchClauses()
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeTypeConstructor : CodeMemberMethod {
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeTypeDeclaration : CodeTypeMember {
private CodeTypeReferenceCollection baseTypes
private CodeTypeMemberCollection members
private TypeAttributes attributes
private bool isEnum
private bool isStruct
private int populated
private bool isPartial
private CodeTypeParameterCollection typeParameters
private EventHandler PopulateBaseTypes
private EventHandler PopulateMembers
public CodeTypeReferenceCollection BaseTypes
public bool IsClass
public bool IsEnum
public bool IsInterface
public bool IsStruct
public CodeTypeMemberCollection Members
public TypeAttributes TypeAttributes
public bool IsPartial
public CodeTypeParameterCollection TypeParameters
public void .ctor(string name)
public void add_PopulateBaseTypes(EventHandler value)
public void remove_PopulateBaseTypes(EventHandler value)
public void add_PopulateMembers(EventHandler value)
public void remove_PopulateMembers(EventHandler value)
public CodeTypeReferenceCollection get_BaseTypes()
public bool get_IsClass()
public void set_IsClass(bool value)
public bool get_IsEnum()
public void set_IsEnum(bool value)
public bool get_IsInterface()
public void set_IsInterface(bool value)
public bool get_IsStruct()
public void set_IsStruct(bool value)
public CodeTypeMemberCollection get_Members()
public TypeAttributes get_TypeAttributes()
public void set_TypeAttributes(TypeAttributes value)
public bool get_IsPartial()
public void set_IsPartial(bool value)
public CodeTypeParameterCollection get_TypeParameters()
}
public System.CodeDom.CodeTypeDeclarationCollection : CollectionBase {
public CodeTypeDeclaration Item
public void .ctor(CodeTypeDeclaration[] value)
public void .ctor(CodeTypeDeclarationCollection value)
public CodeTypeDeclaration get_Item(int index)
public void set_Item(int index, CodeTypeDeclaration value)
public int Add(CodeTypeDeclaration value)
public void AddRange(CodeTypeDeclaration[] value)
public void AddRange(CodeTypeDeclarationCollection value)
public bool Contains(CodeTypeDeclaration value)
public void CopyTo(CodeTypeDeclaration[] array, int index)
public int IndexOf(CodeTypeDeclaration value)
public void Insert(int index, CodeTypeDeclaration value)
public void Remove(CodeTypeDeclaration value)
}
public System.CodeDom.CodeTypeDelegate : CodeTypeDeclaration {
private CodeParameterDeclarationExpressionCollection parameters
private CodeTypeReference returnType
public CodeParameterDeclarationExpressionCollection Parameters
public CodeTypeReference ReturnType
public void .ctor(string name)
public CodeParameterDeclarationExpressionCollection get_Parameters()
public CodeTypeReference get_ReturnType()
public void set_ReturnType(CodeTypeReference value)
}
public System.CodeDom.CodeTypeMember : CodeObject {
private string name
private MemberAttributes attributes
private CodeCommentStatementCollection comments
private CodeAttributeDeclarationCollection customAttributes
private CodeLinePragma linePragma
private CodeDirectiveCollection endDirectives
private CodeDirectiveCollection startDirectives
public MemberAttributes Attributes
public CodeCommentStatementCollection Comments
public CodeAttributeDeclarationCollection CustomAttributes
public CodeLinePragma LinePragma
public string Name
public CodeDirectiveCollection EndDirectives
public CodeDirectiveCollection StartDirectives
public MemberAttributes get_Attributes()
public void set_Attributes(MemberAttributes value)
public CodeCommentStatementCollection get_Comments()
public CodeAttributeDeclarationCollection get_CustomAttributes()
public void set_CustomAttributes(CodeAttributeDeclarationCollection value)
public CodeLinePragma get_LinePragma()
public void set_LinePragma(CodeLinePragma value)
public string get_Name()
public void set_Name(string value)
public CodeDirectiveCollection get_EndDirectives()
public CodeDirectiveCollection get_StartDirectives()
}
public System.CodeDom.CodeTypeMemberCollection : CollectionBase {
public CodeTypeMember Item
public void .ctor(CodeTypeMember[] value)
public void .ctor(CodeTypeMemberCollection value)
public CodeTypeMember get_Item(int index)
public void set_Item(int index, CodeTypeMember value)
public int Add(CodeTypeMember value)
public void AddRange(CodeTypeMember[] value)
public void AddRange(CodeTypeMemberCollection value)
public bool Contains(CodeTypeMember value)
public void CopyTo(CodeTypeMember[] array, int index)
public int IndexOf(CodeTypeMember value)
public void Insert(int index, CodeTypeMember value)
public void Remove(CodeTypeMember value)
}
public System.CodeDom.CodeTypeOfExpression : CodeExpression {
private CodeTypeReference type
public CodeTypeReference Type
public void .ctor(CodeTypeReference type)
public void .ctor(string type)
public void .ctor(Type type)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeTypeParameter : CodeObject {
private CodeTypeReferenceCollection constraints
private CodeAttributeDeclarationCollection customAttributes
private bool hasConstructorConstraint
private string name
public CodeTypeReferenceCollection Constraints
public CodeAttributeDeclarationCollection CustomAttributes
public bool HasConstructorConstraint
public string Name
public void .ctor(string name)
public CodeTypeReferenceCollection get_Constraints()
public CodeAttributeDeclarationCollection get_CustomAttributes()
public bool get_HasConstructorConstraint()
public void set_HasConstructorConstraint(bool value)
public string get_Name()
public void set_Name(string value)
}
public System.CodeDom.CodeTypeParameterCollection : CollectionBase {
public CodeTypeParameter Item
public void .ctor(CodeTypeParameter[] value)
public void .ctor(CodeTypeParameterCollection value)
public int Add(CodeTypeParameter value)
public void Add(string value)
public void AddRange(CodeTypeParameter[] value)
public void AddRange(CodeTypeParameterCollection value)
public bool Contains(CodeTypeParameter value)
public void CopyTo(CodeTypeParameter[] array, int index)
public int IndexOf(CodeTypeParameter value)
public void Insert(int index, CodeTypeParameter value)
public void Remove(CodeTypeParameter value)
public CodeTypeParameter get_Item(int index)
public void set_Item(int index, CodeTypeParameter value)
}
public System.CodeDom.CodeTypeReference : CodeObject {
private string baseType
private CodeTypeReference arrayElementType
private int arrayRank
private bool isInterface
private bool needsFixup
private CodeTypeReferenceCollection typeArguments
private CodeTypeReferenceOptions referenceOptions
public CodeTypeReference ArrayElementType
public int ArrayRank
public string BaseType
internal bool IsInterface
public CodeTypeReferenceOptions Options
public CodeTypeReferenceCollection TypeArguments
public void .ctor(string baseType)
public void .ctor(Type baseType)
public void .ctor(CodeTypeReference arrayElementType, int arrayRank)
public void .ctor(string baseType, int arrayRank)
public void .ctor(CodeTypeParameter typeParameter)
public void .ctor(string typeName, CodeTypeReferenceOptions referenceOptions)
public void .ctor(Type type, CodeTypeReferenceOptions referenceOptions)
public void .ctor(string typeName, CodeTypeReference[] typeArguments)
public CodeTypeReference get_ArrayElementType()
public void set_ArrayElementType(CodeTypeReference value)
public int get_ArrayRank()
public void set_ArrayRank(int value)
public string get_BaseType()
public void set_BaseType(string value)
internal bool get_IsInterface()
private void Parse(string baseType)
public CodeTypeReferenceOptions get_Options()
public void set_Options(CodeTypeReferenceOptions value)
public CodeTypeReferenceCollection get_TypeArguments()
}
public System.CodeDom.CodeTypeReferenceCollection : CollectionBase {
public CodeTypeReference Item
public void .ctor(CodeTypeReference[] value)
public void .ctor(CodeTypeReferenceCollection value)
public CodeTypeReference get_Item(int index)
public void set_Item(int index, CodeTypeReference value)
public int Add(CodeTypeReference value)
public void Add(string value)
public void Add(Type value)
public void AddRange(CodeTypeReference[] value)
public void AddRange(CodeTypeReferenceCollection value)
public bool Contains(CodeTypeReference value)
public void CopyTo(CodeTypeReference[] array, int index)
public int IndexOf(CodeTypeReference value)
public void Insert(int index, CodeTypeReference value)
public void Remove(CodeTypeReference value)
}
public System.CodeDom.CodeTypeReferenceExpression : CodeExpression {
private CodeTypeReference type
public CodeTypeReference Type
public void .ctor(CodeTypeReference type)
public void .ctor(string type)
public void .ctor(Type type)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeTypeReferenceOptions : Enum {
public int value__
public CodeTypeReferenceOptions GlobalReference
public CodeTypeReferenceOptions GenericTypeParameter
}
public System.CodeDom.CodeVariableDeclarationStatement : CodeStatement {
private CodeExpression initExpression
private CodeTypeReference type
private string name
public CodeExpression InitExpression
public string Name
public CodeTypeReference Type
public void .ctor(CodeTypeReference type, string name)
public void .ctor(string type, string name)
public void .ctor(Type type, string name)
public void .ctor(CodeTypeReference type, string name, CodeExpression initExpression)
public void .ctor(string type, string name, CodeExpression initExpression)
public void .ctor(Type type, string name, CodeExpression initExpression)
public CodeExpression get_InitExpression()
public void set_InitExpression(CodeExpression value)
public string get_Name()
public void set_Name(string value)
public CodeTypeReference get_Type()
public void set_Type(CodeTypeReference value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.CodeVariableReferenceExpression : CodeExpression {
private string variableName
public string VariableName
public void .ctor(string variableName)
public string get_VariableName()
public void set_VariableName(string value)
internal void Accept(ICodeDomVisitor visitor)
}
public System.CodeDom.Compiler.CodeCompiler : CodeGenerator {
protected string CompilerName
protected string FileExtension
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source)
private CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources)
protected string get_CompilerName()
protected string get_FileExtension()
protected string CmdArgsFromParameters(CompilerParameters options)
protected CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e)
protected CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea)
protected CompilerResults FromFile(CompilerParameters options, string fileName)
protected CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames)
protected CompilerResults FromSource(CompilerParameters options, string source)
protected CompilerResults FromSourceBatch(CompilerParameters options, String[] sources)
private CompilerResults Compile(CompilerParameters options, String[] fileNames, bool keepFiles)
protected string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs)
protected string JoinStringArray(String[] sa, string separator)
protected void ProcessCompilerOutputLine(CompilerResults results, string line)
}
internal System.CodeDom.Compiler.CodeDomConfigurationHandler : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty compilersProp
private CompilerCollection default_compilers
public CompilerCollection Compilers
public CompilerInfo[] CompilerInfos
protected ConfigurationPropertyCollection Properties
protected void InitializeDefault()
protected void PostDeserialize()
protected object GetRuntimeObject()
public CompilerCollection get_Compilers()
public CompilerInfo[] get_CompilerInfos()
protected ConfigurationPropertyCollection get_Properties()
}
public System.CodeDom.Compiler.CodeDomProvider : Component {
public string FileExtension
public LanguageOptions LanguageOptions
private CodeDomConfigurationHandler Config
public string get_FileExtension()
public LanguageOptions get_LanguageOptions()
public ICodeCompiler CreateCompiler()
public ICodeGenerator CreateGenerator()
public ICodeGenerator CreateGenerator(string fileName)
public ICodeGenerator CreateGenerator(TextWriter output)
public ICodeParser CreateParser()
public TypeConverter GetConverter(Type type)
public CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit[] compilationUnits)
public CompilerResults CompileAssemblyFromFile(CompilerParameters options, String[] fileNames)
public CompilerResults CompileAssemblyFromSource(CompilerParameters options, String[] fileNames)
public string CreateEscapedIdentifier(string value)
public CodeDomProvider CreateProvider(string language)
public string CreateValidIdentifier(string value)
public void GenerateCodeFromCompileUnit(CodeCompileUnit compileUnit, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromExpression(CodeExpression expression, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromNamespace(CodeNamespace codeNamespace, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromStatement(CodeStatement statement, TextWriter writer, CodeGeneratorOptions options)
public void GenerateCodeFromType(CodeTypeDeclaration codeType, TextWriter writer, CodeGeneratorOptions options)
public CompilerInfo[] GetAllCompilerInfo()
public CompilerInfo GetCompilerInfo(string language)
public string GetLanguageFromExtension(string extension)
public string GetTypeOutput(CodeTypeReference type)
public bool IsDefinedExtension(string extension)
public bool IsDefinedLanguage(string language)
public bool IsValidIdentifier(string value)
public CodeCompileUnit Parse(TextReader codeStream)
public bool Supports(GeneratorSupport supports)
private CodeDomConfigurationHandler get_Config()
private Exception GetNotImplemented()
}
public System.CodeDom.Compiler.CodeGenerator : object {
private IndentedTextWriter output
private CodeGeneratorOptions options
private CodeTypeMember currentMember
private CodeTypeDeclaration currentType
private Visitor visitor
private Type[] memberTypes
protected CodeTypeDeclaration CurrentClass
protected CodeTypeMember CurrentMember
protected string CurrentMemberName
protected string CurrentTypeName
protected int Indent
protected bool IsCurrentClass
protected bool IsCurrentDelegate
protected bool IsCurrentEnum
protected bool IsCurrentInterface
protected bool IsCurrentStruct
protected string NullToken
protected CodeGeneratorOptions Options
protected TextWriter Output
private string System.CodeDom.Compiler.ICodeGenerator.CreateEscapedIdentifier(string value)
private string System.CodeDom.Compiler.ICodeGenerator.CreateValidIdentifier(string value)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit compileUnit, TextWriter output, CodeGeneratorOptions options)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression expression, TextWriter output, CodeGeneratorOptions options)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace ns, TextWriter output, CodeGeneratorOptions options)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement statement, TextWriter output, CodeGeneratorOptions options)
private void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration type, TextWriter output, CodeGeneratorOptions options)
private string System.CodeDom.Compiler.ICodeGenerator.GetTypeOutput(CodeTypeReference type)
private bool System.CodeDom.Compiler.ICodeGenerator.IsValidIdentifier(string value)
private bool System.CodeDom.Compiler.ICodeGenerator.Supports(GeneratorSupport value)
private void System.CodeDom.Compiler.ICodeGenerator.ValidateIdentifier(string value)
protected CodeTypeDeclaration get_CurrentClass()
protected CodeTypeMember get_CurrentMember()
protected string get_CurrentMemberName()
protected string get_CurrentTypeName()
protected int get_Indent()
protected void set_Indent(int value)
protected bool get_IsCurrentClass()
protected bool get_IsCurrentDelegate()
protected bool get_IsCurrentEnum()
protected bool get_IsCurrentInterface()
protected bool get_IsCurrentStruct()
protected string get_NullToken()
protected CodeGeneratorOptions get_Options()
protected TextWriter get_Output()
protected void ContinueOnNewLine(string st)
protected void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e)
protected void GenerateArrayCreateExpression(CodeArrayCreateExpression e)
protected void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e)
protected void GenerateAssignStatement(CodeAssignStatement s)
protected void GenerateAttachEventStatement(CodeAttachEventStatement s)
protected void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
protected void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
protected void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e)
protected void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e)
protected void GenerateCastExpression(CodeCastExpression e)
public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options)
protected void GenerateComment(CodeComment comment)
protected void GenerateCommentStatement(CodeCommentStatement statement)
protected void GenerateCommentStatements(CodeCommentStatementCollection statements)
protected void GenerateCompileUnit(CodeCompileUnit compileUnit)
protected void GenerateCompileUnitEnd(CodeCompileUnit compileUnit)
protected void GenerateCompileUnitStart(CodeCompileUnit compileUnit)
protected void GenerateConditionStatement(CodeConditionStatement s)
protected void GenerateConstructor(CodeConstructor x, CodeTypeDeclaration d)
protected void GenerateDecimalValue(decimal d)
protected void GenerateDefaultValueExpression(CodeDefaultValueExpression e)
protected void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e)
protected void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e)
protected void GenerateDirectionExpression(CodeDirectionExpression e)
protected void GenerateDoubleValue(double d)
protected void GenerateEntryPointMethod(CodeEntryPointMethod m, CodeTypeDeclaration d)
protected void GenerateEvent(CodeMemberEvent ev, CodeTypeDeclaration d)
protected void GenerateEventReferenceExpression(CodeEventReferenceExpression e)
protected void GenerateExpression(CodeExpression e)
protected void GenerateExpressionStatement(CodeExpressionStatement statement)
protected void GenerateField(CodeMemberField f)
protected void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e)
protected void GenerateGotoStatement(CodeGotoStatement statement)
protected void GenerateIndexerExpression(CodeIndexerExpression e)
protected void GenerateIterationStatement(CodeIterationStatement s)
protected void GenerateLabeledStatement(CodeLabeledStatement statement)
protected void GenerateLinePragmaStart(CodeLinePragma p)
protected void GenerateLinePragmaEnd(CodeLinePragma p)
protected void GenerateMethod(CodeMemberMethod m, CodeTypeDeclaration d)
protected void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e)
protected void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e)
protected void GenerateMethodReturnStatement(CodeMethodReturnStatement e)
protected void GenerateNamespace(CodeNamespace ns)
protected void GenerateNamespaceStart(CodeNamespace ns)
protected void GenerateNamespaceEnd(CodeNamespace ns)
protected void GenerateNamespaceImport(CodeNamespaceImport i)
protected void GenerateNamespaceImports(CodeNamespace e)
protected void GenerateNamespaces(CodeCompileUnit e)
protected void GenerateObjectCreateExpression(CodeObjectCreateExpression e)
protected void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
protected void GeneratePrimitiveExpression(CodePrimitiveExpression e)
protected void GenerateProperty(CodeMemberProperty p, CodeTypeDeclaration d)
protected void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e)
protected void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e)
protected void GenerateRemoveEventStatement(CodeRemoveEventStatement statement)
protected void GenerateSingleFloatValue(float s)
protected void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e)
protected void GenerateSnippetExpression(CodeSnippetExpression e)
protected void GenerateSnippetMember(CodeSnippetTypeMember m)
protected void GenerateSnippetStatement(CodeSnippetStatement s)
protected void GenerateStatement(CodeStatement s)
protected void GenerateStatements(CodeStatementCollection c)
protected void GenerateThisReferenceExpression(CodeThisReferenceExpression e)
protected void GenerateThrowExceptionStatement(CodeThrowExceptionStatement s)
protected void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement s)
protected void GenerateTypeEnd(CodeTypeDeclaration declaration)
protected void GenerateTypeConstructor(CodeTypeConstructor constructor)
protected void GenerateTypeOfExpression(CodeTypeOfExpression e)
protected void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e)
protected void GenerateTypes(CodeNamespace e)
protected void GenerateTypeStart(CodeTypeDeclaration declaration)
protected void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e)
protected void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e)
protected void OutputAttributeArgument(CodeAttributeArgument argument)
private void OutputAttributeDeclaration(CodeAttributeDeclaration attribute)
protected void OutputAttributeDeclarations(CodeAttributeDeclarationCollection attributes)
protected void OutputDirection(FieldDirection direction)
protected void OutputExpressionList(CodeExpressionCollection expressions)
protected void OutputExpressionList(CodeExpressionCollection expressions, bool newLineBetweenItems)
protected void OutputFieldScopeModifier(MemberAttributes attributes)
protected void OutputIdentifier(string ident)
protected void OutputMemberAccessModifier(MemberAttributes attributes)
protected void OutputMemberScopeModifier(MemberAttributes attributes)
protected void OutputOperator(CodeBinaryOperatorType op)
protected void OutputParameters(CodeParameterDeclarationExpressionCollection parameters)
protected void OutputType(CodeTypeReference t)
protected void OutputTypeAttributes(TypeAttributes attributes, bool isStruct, bool isEnum)
protected void OutputTypeNamePair(CodeTypeReference type, string name)
protected string QuoteSnippetString(string value)
protected string CreateEscapedIdentifier(string value)
protected string CreateValidIdentifier(string value)
private void InitOutput(TextWriter output, CodeGeneratorOptions options)
private void GenerateType(CodeTypeDeclaration type)
protected string GetTypeOutput(CodeTypeReference type)
protected bool IsValidIdentifier(string value)
public bool IsValidLanguageIndependentIdentifier(string value)
protected bool Supports(GeneratorSupport supports)
protected void ValidateIdentifier(string value)
public void ValidateIdentifiers(CodeObject e)
protected void GenerateDirectives(CodeDirectiveCollection directives)
}
public System.CodeDom.Compiler.CodeGeneratorOptions : object {
private IDictionary properties
public bool BlankLinesBetweenMembers
public string BracingStyle
public bool ElseOnClosing
public string IndentString
public object Item
public bool VerbatimOrder
public bool get_BlankLinesBetweenMembers()
public void set_BlankLinesBetweenMembers(bool value)
public string get_BracingStyle()
public void set_BracingStyle(string value)
public bool get_ElseOnClosing()
public void set_ElseOnClosing(bool value)
public string get_IndentString()
public void set_IndentString(string value)
public object get_Item(string index)
public void set_Item(string index, object value)
public bool get_VerbatimOrder()
public void set_VerbatimOrder(bool value)
}
public System.CodeDom.Compiler.CodeParser : object {
public CodeCompileUnit Parse(TextReader codeStream)
}
internal System.CodeDom.Compiler.Compiler : ConfigurationElement {
private ConfigurationProperty compilerOptionsProp
private ConfigurationProperty extensionProp
private ConfigurationProperty languageProp
private ConfigurationProperty typeProp
private ConfigurationProperty warningLevelProp
private ConfigurationProperty providerOptionsProp
private ConfigurationPropertyCollection properties
public string CompilerOptions
public string Extension
public string Language
public string Type
public int WarningLevel
public CompilerProviderOptionsCollection ProviderOptions
public Dictionary`2<string, string> ProviderOptionsDictionary
protected ConfigurationPropertyCollection Properties
public void .ctor(string compilerOptions, string extension, string language, string type, int warningLevel)
public string get_CompilerOptions()
internal void set_CompilerOptions(string value)
public string get_Extension()
internal void set_Extension(string value)
public string get_Language()
internal void set_Language(string value)
public string get_Type()
internal void set_Type(string value)
public int get_WarningLevel()
internal void set_WarningLevel(int value)
public CompilerProviderOptionsCollection get_ProviderOptions()
internal void set_ProviderOptions(CompilerProviderOptionsCollection value)
public Dictionary`2<string, string> get_ProviderOptionsDictionary()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.CodeDom.Compiler.CompilerCollection : ConfigurationElementCollection {
private ConfigurationPropertyCollection properties
private List`1<CompilerInfo> compiler_infos
private Dictionary`2<string, CompilerInfo> compiler_languages
private Dictionary`2<string, CompilerInfo> compiler_extensions
protected bool ThrowOnDuplicate
public String[] AllKeys
public ConfigurationElementCollectionType CollectionType
protected string ElementName
protected ConfigurationPropertyCollection Properties
public Compiler Item
public CompilerInfo Item
public CompilerInfo[] CompilerInfos
private void AddCompilerInfo(CompilerInfo ci)
private void AddCompilerInfo(Compiler compiler)
protected void BaseAdd(ConfigurationElement element)
protected bool get_ThrowOnDuplicate()
protected ConfigurationElement CreateNewElement()
public CompilerInfo GetCompilerInfoForLanguage(string language)
public CompilerInfo GetCompilerInfoForExtension(string extension)
public string GetLanguageFromExtension(string extension)
public Compiler Get(int index)
public Compiler Get(string language)
protected object GetElementKey(ConfigurationElement element)
public string GetKey(int index)
public String[] get_AllKeys()
public ConfigurationElementCollectionType get_CollectionType()
protected string get_ElementName()
protected ConfigurationPropertyCollection get_Properties()
public Compiler get_Item(int index)
public CompilerInfo get_Item(string language)
public CompilerInfo[] get_CompilerInfos()
}
public System.CodeDom.Compiler.CompilerError : object {
private string fileName
private int line
private int column
private string errorNumber
private string errorText
private bool isWarning
public int Line
public int Column
public string ErrorNumber
public string ErrorText
public bool IsWarning
public string FileName
public void .ctor(string fileName, int line, int column, string errorNumber, string errorText)
public string ToString()
public int get_Line()
public void set_Line(int value)
public int get_Column()
public void set_Column(int value)
public string get_ErrorNumber()
public void set_ErrorNumber(string value)
public string get_ErrorText()
public void set_ErrorText(string value)
public bool get_IsWarning()
public void set_IsWarning(bool value)
public string get_FileName()
public void set_FileName(string value)
}
public System.CodeDom.Compiler.CompilerErrorCollection : CollectionBase {
public CompilerError Item
public bool HasErrors
public bool HasWarnings
public void .ctor(CompilerErrorCollection value)
public void .ctor(CompilerError[] value)
public int Add(CompilerError value)
public void AddRange(CompilerError[] value)
public void AddRange(CompilerErrorCollection value)
public bool Contains(CompilerError value)
public void CopyTo(CompilerError[] array, int index)
public int IndexOf(CompilerError value)
public void Insert(int index, CompilerError value)
public void Remove(CompilerError value)
public CompilerError get_Item(int index)
public void set_Item(int index, CompilerError value)
public bool get_HasErrors()
public bool get_HasWarnings()
}
public System.CodeDom.Compiler.CompilerInfo : object {
internal string Languages
internal string Extensions
internal string TypeName
internal int WarningLevel
internal string CompilerOptions
internal Dictionary`2<string, string> ProviderOptions
private bool inited
private Type type
public Type CodeDomProviderType
public bool IsCodeDomProviderTypeValid
internal void Init()
public Type get_CodeDomProviderType()
public bool get_IsCodeDomProviderTypeValid()
public CompilerParameters CreateDefaultCompilerParameters()
public CodeDomProvider CreateProvider()
public bool Equals(object o)
public int GetHashCode()
public String[] GetExtensions()
public String[] GetLanguages()
}
public System.CodeDom.Compiler.CompilerParameters : object {
private string compilerOptions
private Evidence evidence
private bool generateExecutable
private bool generateInMemory
private bool includeDebugInformation
private string mainClass
private string outputAssembly
private StringCollection referencedAssemblies
private TempFileCollection tempFiles
private bool treatWarningsAsErrors
private IntPtr userToken
private int warningLevel
private string win32Resource
private StringCollection embedded_resources
private StringCollection linked_resources
public string CompilerOptions
public Evidence Evidence
public bool GenerateExecutable
public bool GenerateInMemory
public bool IncludeDebugInformation
public string MainClass
public string OutputAssembly
public StringCollection ReferencedAssemblies
public TempFileCollection TempFiles
public bool TreatWarningsAsErrors
public IntPtr UserToken
public int WarningLevel
public string Win32Resource
public StringCollection EmbeddedResources
public StringCollection LinkedResources
public void .ctor(String[] assemblyNames)
public void .ctor(String[] assemblyNames, string output)
public void .ctor(String[] assemblyNames, string output, bool includeDebugInfo)
public string get_CompilerOptions()
public void set_CompilerOptions(string value)
public Evidence get_Evidence()
public void set_Evidence(Evidence value)
public bool get_GenerateExecutable()
public void set_GenerateExecutable(bool value)
public bool get_GenerateInMemory()
public void set_GenerateInMemory(bool value)
public bool get_IncludeDebugInformation()
public void set_IncludeDebugInformation(bool value)
public string get_MainClass()
public void set_MainClass(string value)
public string get_OutputAssembly()
public void set_OutputAssembly(string value)
public StringCollection get_ReferencedAssemblies()
public TempFileCollection get_TempFiles()
public void set_TempFiles(TempFileCollection value)
public bool get_TreatWarningsAsErrors()
public void set_TreatWarningsAsErrors(bool value)
public IntPtr get_UserToken()
public void set_UserToken(IntPtr value)
public int get_WarningLevel()
public void set_WarningLevel(int value)
public string get_Win32Resource()
public void set_Win32Resource(string value)
public StringCollection get_EmbeddedResources()
public StringCollection get_LinkedResources()
}
internal System.CodeDom.Compiler.CompilerProviderOption : ConfigurationElement {
private ConfigurationProperty nameProp
private ConfigurationProperty valueProp
private ConfigurationPropertyCollection properties
public string Name
public string Value
protected ConfigurationPropertyCollection Properties
public string get_Name()
public void set_Name(string value)
public string get_Value()
public void set_Value(string value)
protected ConfigurationPropertyCollection get_Properties()
}
internal System.CodeDom.Compiler.CompilerProviderOptionsCollection : ConfigurationElementCollection {
private ConfigurationPropertyCollection properties
public String[] AllKeys
protected string ElementName
protected ConfigurationPropertyCollection Properties
public Dictionary`2<string, string> ProviderOptions
public CompilerProviderOption Item
public CompilerProviderOption Item
protected ConfigurationElement CreateNewElement()
public CompilerProviderOption Get(int index)
public CompilerProviderOption Get(string name)
protected object GetElementKey(ConfigurationElement element)
public string GetKey(int index)
public String[] get_AllKeys()
protected string get_ElementName()
protected ConfigurationPropertyCollection get_Properties()
public Dictionary`2<string, string> get_ProviderOptions()
public CompilerProviderOption get_Item(int index)
public CompilerProviderOption get_Item(string name)
}
public System.CodeDom.Compiler.CompilerResults : object {
private Assembly compiledAssembly
private CompilerErrorCollection errors
private Evidence evidence
private int nativeCompilerReturnValue
private StringCollection output
private string pathToAssembly
private TempFileCollection tempFiles
public Assembly CompiledAssembly
public CompilerErrorCollection Errors
public Evidence Evidence
public int NativeCompilerReturnValue
public StringCollection Output
public string PathToAssembly
public TempFileCollection TempFiles
public void .ctor(TempFileCollection tempFiles)
public Assembly get_CompiledAssembly()
public void set_CompiledAssembly(Assembly value)
public CompilerErrorCollection get_Errors()
public Evidence get_Evidence()
public void set_Evidence(Evidence value)
public int get_NativeCompilerReturnValue()
public void set_NativeCompilerReturnValue(int value)
public StringCollection get_Output()
internal void set_Output(StringCollection value)
public string get_PathToAssembly()
public void set_PathToAssembly(string value)
public TempFileCollection get_TempFiles()
public void set_TempFiles(TempFileCollection value)
}
public System.CodeDom.Compiler.Executor : object {
public void ExecWait(string cmd, TempFileCollection tempFiles)
public int ExecWaitWithCapture(IntPtr userToken, string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName)
public int ExecWaitWithCapture(IntPtr userToken, string cmd, TempFileCollection tempFiles, String& outputName, String& errorName)
public int ExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName)
public int ExecWaitWithCapture(string cmd, TempFileCollection tempFiles, String& outputName, String& errorName)
private int InternalExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName)
}
public System.CodeDom.Compiler.GeneratedCodeAttribute : Attribute {
private string tool
private string version
public string Tool
public string Version
public void .ctor(string tool, string version)
public string get_Tool()
public string get_Version()
}
public System.CodeDom.Compiler.GeneratorSupport : Enum {
public int value__
public GeneratorSupport ArraysOfArrays
public GeneratorSupport EntryPointMethod
public GeneratorSupport GotoStatements
public GeneratorSupport MultidimensionalArrays
public GeneratorSupport StaticConstructors
public GeneratorSupport TryCatchStatements
public GeneratorSupport ReturnTypeAttributes
public GeneratorSupport DeclareValueTypes
public GeneratorSupport DeclareEnums
public GeneratorSupport DeclareDelegates
public GeneratorSupport DeclareInterfaces
public GeneratorSupport DeclareEvents
public GeneratorSupport AssemblyAttributes
public GeneratorSupport ParameterAttributes
public GeneratorSupport ReferenceParameters
public GeneratorSupport ChainedConstructorArguments
public GeneratorSupport NestedTypes
public GeneratorSupport MultipleInterfaceMembers
public GeneratorSupport PublicStaticMembers
public GeneratorSupport ComplexExpressions
public GeneratorSupport Win32Resources
public GeneratorSupport Resources
public GeneratorSupport PartialTypes
public GeneratorSupport GenericTypeReference
public GeneratorSupport GenericTypeDeclaration
public GeneratorSupport DeclareIndexerProperties
}
public System.CodeDom.Compiler.ICodeCompiler {
public CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit compilationUnit)
public CompilerResults CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] batch)
public CompilerResults CompileAssemblyFromFile(CompilerParameters options, string fileName)
public CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, String[] batch)
public CompilerResults CompileAssemblyFromSource(CompilerParameters options, string source)
public CompilerResults CompileAssemblyFromSourceBatch(CompilerParameters options, String[] batch)
}
public System.CodeDom.Compiler.ICodeGenerator {
public string CreateEscapedIdentifier(string value)
public string CreateValidIdentifier(string value)
public void GenerateCodeFromCompileUnit(CodeCompileUnit compileUnit, TextWriter output, CodeGeneratorOptions options)
public void GenerateCodeFromExpression(CodeExpression expression, TextWriter output, CodeGeneratorOptions options)
public void GenerateCodeFromNamespace(CodeNamespace ns, TextWriter output, CodeGeneratorOptions options)
public void GenerateCodeFromStatement(CodeStatement statement, TextWriter output, CodeGeneratorOptions options)
public void GenerateCodeFromType(CodeTypeDeclaration typeDeclaration, TextWriter output, CodeGeneratorOptions options)
public string GetTypeOutput(CodeTypeReference type)
public bool IsValidIdentifier(string value)
public bool Supports(GeneratorSupport supports)
public void ValidateIdentifier(string value)
}
public System.CodeDom.Compiler.ICodeParser {
public CodeCompileUnit Parse(TextReader codeStream)
}
public System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
public string DefaultTabString
private TextWriter writer
private string tabString
private int indent
private bool newline
public Encoding Encoding
public int Indent
public TextWriter InnerWriter
public string NewLine
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string tabString)
public Encoding get_Encoding()
public int get_Indent()
public void set_Indent(int value)
public TextWriter get_InnerWriter()
public string get_NewLine()
public void set_NewLine(string value)
public void Close()
public void Flush()
public void Write(bool value)
public void Write(char value)
public void Write(Char[] value)
public void Write(double value)
public void Write(int value)
public void Write(long value)
public void Write(object value)
public void Write(float value)
public void Write(string value)
public void Write(string format, object arg)
public void Write(string format, Object[] args)
public void Write(Char[] buffer, int index, int count)
public void Write(string format, object arg0, object arg1)
public void WriteLine()
public void WriteLine(bool value)
public void WriteLine(char value)
public void WriteLine(Char[] value)
public void WriteLine(double value)
public void WriteLine(int value)
public void WriteLine(long value)
public void WriteLine(object value)
public void WriteLine(float value)
public void WriteLine(string value)
public void WriteLine(UInt32 value)
public void WriteLine(string format, object arg)
public void WriteLine(string format, Object[] args)
public void WriteLine(Char[] buffer, int index, int count)
public void WriteLine(string format, object arg0, object arg1)
public void WriteLineNoTabs(string value)
protected void OutputTabs()
}
public System.CodeDom.Compiler.LanguageOptions : Enum {
public int value__
public LanguageOptions None
public LanguageOptions CaseInsensitive
}
public System.CodeDom.Compiler.TempFileCollection : object {
private Hashtable filehash
private string tempdir
private bool keepfiles
private string basepath
private Random rnd
private string ownTempDir
private int System.Collections.ICollection.Count
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
public string BasePath
public int Count
public bool KeepFiles
public string TempDir
public void .ctor(string tempDir)
public void .ctor(string tempDir, bool keepFiles)
private int System.Collections.ICollection.get_Count()
private void System.Collections.ICollection.CopyTo(Array array, int start)
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
private void System.IDisposable.Dispose()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public string get_BasePath()
private string GetOwnTempDir()
public int get_Count()
public bool get_KeepFiles()
public void set_KeepFiles(bool value)
public string get_TempDir()
public string AddExtension(string fileExtension)
public string AddExtension(string fileExtension, bool keepFile)
public void AddFile(string fileName, bool keepFile)
public void CopyTo(String[] fileNames, int start)
public void Delete()
public IEnumerator GetEnumerator()
protected void Dispose(bool disposing)
protected void Finalize()
private int mkdir(string olpath, UInt32 mode)
}
public System.CodeDom.FieldDirection : Enum {
public int value__
public FieldDirection In
public FieldDirection Out
public FieldDirection Ref
}
internal System.CodeDom.ICodeDomVisitor {
public void Visit(CodeArgumentReferenceExpression o)
public void Visit(CodeArrayCreateExpression o)
public void Visit(CodeArrayIndexerExpression o)
public void Visit(CodeBaseReferenceExpression o)
public void Visit(CodeBinaryOperatorExpression o)
public void Visit(CodeCastExpression o)
public void Visit(CodeDefaultValueExpression o)
public void Visit(CodeDelegateCreateExpression o)
public void Visit(CodeDelegateInvokeExpression o)
public void Visit(CodeDirectionExpression o)
public void Visit(CodeEventReferenceExpression o)
public void Visit(CodeFieldReferenceExpression o)
public void Visit(CodeIndexerExpression o)
public void Visit(CodeMethodInvokeExpression o)
public void Visit(CodeMethodReferenceExpression o)
public void Visit(CodeObjectCreateExpression o)
public void Visit(CodeParameterDeclarationExpression o)
public void Visit(CodePrimitiveExpression o)
public void Visit(CodePropertyReferenceExpression o)
public void Visit(CodePropertySetValueReferenceExpression o)
public void Visit(CodeSnippetExpression o)
public void Visit(CodeThisReferenceExpression o)
public void Visit(CodeTypeOfExpression o)
public void Visit(CodeTypeReferenceExpression o)
public void Visit(CodeVariableReferenceExpression o)
public void Visit(CodeAssignStatement o)
public void Visit(CodeAttachEventStatement o)
public void Visit(CodeCommentStatement o)
public void Visit(CodeConditionStatement o)
public void Visit(CodeExpressionStatement o)
public void Visit(CodeGotoStatement o)
public void Visit(CodeIterationStatement o)
public void Visit(CodeLabeledStatement o)
public void Visit(CodeMethodReturnStatement o)
public void Visit(CodeRemoveEventStatement o)
public void Visit(CodeThrowExceptionStatement o)
public void Visit(CodeTryCatchFinallyStatement o)
public void Visit(CodeVariableDeclarationStatement o)
public void Visit(CodeConstructor o)
public void Visit(CodeEntryPointMethod o)
public void Visit(CodeMemberEvent o)
public void Visit(CodeMemberField o)
public void Visit(CodeMemberMethod o)
public void Visit(CodeMemberProperty o)
public void Visit(CodeSnippetTypeMember o)
public void Visit(CodeTypeConstructor o)
}
public System.CodeDom.MemberAttributes : Enum {
public int value__
public MemberAttributes Abstract
public MemberAttributes Final
public MemberAttributes Static
public MemberAttributes Override
public MemberAttributes Const
public MemberAttributes ScopeMask
public MemberAttributes New
public MemberAttributes VTableMask
public MemberAttributes Overloaded
public MemberAttributes Assembly
public MemberAttributes FamilyAndAssembly
public MemberAttributes Family
public MemberAttributes FamilyOrAssembly
public MemberAttributes Private
public MemberAttributes Public
public MemberAttributes AccessMask
}
public System.Collections.Generic.LinkedList`1 : object {
private string DataArrayKey
private string VersionKey
private UInt32 count
private UInt32 version
private object syncRoot
internal LinkedListNode`1<T> first
internal SerializationInfo si
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public int Count
public LinkedListNode`1<T> First
public LinkedListNode`1<T> Last
public void .ctor(IEnumerable`1<T> collection)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Collections.Generic.ICollection<T>.Add(T value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void VerifyReferencedNode(LinkedListNode`1<T> node)
private void VerifyBlankNode(LinkedListNode`1<T> newNode)
public LinkedListNode`1<T> AddAfter(LinkedListNode`1<T> node, T value)
public void AddAfter(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode)
public LinkedListNode`1<T> AddBefore(LinkedListNode`1<T> node, T value)
public void AddBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode)
public void AddFirst(LinkedListNode`1<T> node)
public LinkedListNode`1<T> AddFirst(T value)
public LinkedListNode`1<T> AddLast(T value)
public void AddLast(LinkedListNode`1<T> node)
public void Clear()
public bool Contains(T value)
public void CopyTo(T[] array, int index)
public LinkedListNode`1<T> Find(T value)
public LinkedListNode`1<T> FindLast(T value)
public Enumerator<T> GetEnumerator()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
public bool Remove(T value)
public void Remove(LinkedListNode`1<T> node)
public void RemoveFirst()
public void RemoveLast()
public int get_Count()
public LinkedListNode`1<T> get_First()
public LinkedListNode`1<T> get_Last()
}
public System.Collections.Generic.LinkedListNode`1 : object {
private T item
private LinkedList`1<T> container
internal LinkedListNode`1<T> forward
internal LinkedListNode`1<T> back
public LinkedList`1<T> List
public LinkedListNode`1<T> Next
public LinkedListNode`1<T> Previous
public T Value
public void .ctor(T value)
internal void .ctor(LinkedList`1<T> list, T value)
internal void .ctor(LinkedList`1<T> list, T value, LinkedListNode`1<T> previousNode, LinkedListNode`1<T> nextNode)
internal void Detach()
internal void SelfReference(LinkedList`1<T> list)
internal void InsertBetween(LinkedListNode`1<T> previousNode, LinkedListNode`1<T> nextNode, LinkedList`1<T> list)
public LinkedList`1<T> get_List()
public LinkedListNode`1<T> get_Next()
public LinkedListNode`1<T> get_Previous()
public T get_Value()
public void set_Value(T value)
}
public System.Collections.Generic.Queue`1 : object {
private T[] _array
private int _head
private int _tail
private int _size
private int _version
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public int Count
public void .ctor(int count)
public void .ctor(IEnumerable`1<T> collection)
private void System.Collections.ICollection.CopyTo(Array array, int idx)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int idx)
public T Dequeue()
public T Peek()
public void Enqueue(T item)
public T[] ToArray()
public void TrimExcess()
private void SetCapacity(int new_size)
public int get_Count()
public Enumerator<T> GetEnumerator()
}
internal System.Collections.Generic.RBTree : object {
private Node root
private object hlp
private UInt32 version
private List`1<Node> cached_path
public int Count
public Node Item
public void .ctor(object hlp)
private IEnumerator`1<Node> System.Collections.Generic.IEnumerable<System.Collections.Generic.RBTree.Node>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private List`1<Node> alloc_path()
private void release_path(List`1<Node> path)
public void Clear()
public Node Intern(T key, Node new_node)
public Node Remove(T key)
public Node Lookup(T key)
public int get_Count()
public Node get_Item(int index)
public NodeEnumerator GetEnumerator()
private int find_key(T key, List`1<Node> path)
private Node do_insert(int in_tree_cmp, Node current, List`1<Node> path)
private Node do_remove(List`1<Node> path)
private void rebalance_insert(List`1<Node> path)
private void rebalance_delete(List`1<Node> path)
private void rebalance_insert__rotate_final(int curpos, List`1<Node> path)
private void rebalance_delete__rotate_final(int curpos, List`1<Node> path)
private int ensure_sibling_black(int curpos, List`1<Node> path)
private void node_reparent(Node orig_parent, Node orig, UInt32 orig_size, Node updated)
private Node right_most(Node current, Node sibling, List`1<Node> path)
}
public System.Collections.Generic.SortedDictionary`2 : object {
private RBTree tree
private NodeHelper<TKey, TValue> hlp
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private object System.Collections.IDictionary.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public IComparer`1<TKey> Comparer
public int Count
public TValue Item
public KeyCollection<TKey, TValue> Keys
public ValueCollection<TKey, TValue> Values
public void .ctor(IComparer`1<TKey> comparer)
public void .ctor(IDictionary`2<TKey, TValue> dic)
public void .ctor(IDictionary`2<TKey, TValue> dic, IComparer`1<TKey> comparer)
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys()
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item)
private void System.Collections.IDictionary.Add(object key, object value)
private bool System.Collections.IDictionary.Contains(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private ICollection System.Collections.IDictionary.get_Keys()
private void System.Collections.IDictionary.Remove(object key)
private ICollection System.Collections.IDictionary.get_Values()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator()
public IComparer`1<TKey> get_Comparer()
public int get_Count()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public KeyCollection<TKey, TValue> get_Keys()
public ValueCollection<TKey, TValue> get_Values()
public void Add(TKey key, TValue value)
public void Clear()
public bool ContainsKey(TKey key)
public bool ContainsValue(TValue value)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public Enumerator<TKey, TValue> GetEnumerator()
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
private TKey ToKey(object key)
private TValue ToValue(object value)
}
public System.Collections.Generic.SortedList`2 : object {
private int INITIAL_SIZE
private int inUse
private int modificationCount
private KeyValuePair`2[] table
private IComparer`1<TKey> comparer
private int defaultCapacity
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private object System.Collections.IDictionary.Item
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
public int Count
public TValue Item
public int Capacity
public IList`1<TKey> Keys
public IList`1<TValue> Values
public IComparer`1<TKey> Comparer
public void .ctor(int capacity)
public void .ctor(int capacity, IComparer`1<TKey> comparer)
public void .ctor(IComparer`1<TKey> comparer)
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public void .ctor(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private ICollection System.Collections.IDictionary.get_Keys()
private ICollection System.Collections.IDictionary.get_Values()
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys()
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair)
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.IDictionary.Add(object key, object value)
private bool System.Collections.IDictionary.Contains(object key)
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private void System.Collections.IDictionary.Remove(object key)
private void System.Collections.ICollection.CopyTo(Array array, int arrayIndex)
public int get_Count()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public int get_Capacity()
public void set_Capacity(int value)
public IList`1<TKey> get_Keys()
public IList`1<TValue> get_Values()
public IComparer`1<TKey> get_Comparer()
public void Add(TKey key, TValue value)
public bool ContainsKey(TKey key)
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
public bool Remove(TKey key)
public void Clear()
public void RemoveAt(int index)
public int IndexOfKey(TKey key)
public int IndexOfValue(TValue value)
public bool ContainsValue(TValue value)
public void TrimExcess()
public bool TryGetValue(TKey key, TValue& value)
private void EnsureCapacity(int n, int free)
private void PutImpl(TKey key, TValue value, bool overwrite)
private void Init(IComparer`1<TKey> comparer, int capacity, bool forceSize)
private void CopyToArray(Array arr, int i, EnumeratorMode<TKey, TValue> mode)
private int Find(TKey key)
private TKey ToKey(object key)
private TValue ToValue(object value)
internal TKey KeyAt(int index)
internal TValue ValueAt(int index)
}
public System.Collections.Generic.Stack`1 : object {
private int INITIAL_SIZE
private T[] _array
private int _size
private int _version
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public int Count
public void .ctor(int count)
public void .ctor(IEnumerable`1<T> collection)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array dest, int idx)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Clear()
public bool Contains(T t)
public void CopyTo(T[] dest, int idx)
public T Peek()
public T Pop()
public void Push(T t)
public T[] ToArray()
public void TrimExcess()
public int get_Count()
public Enumerator<T> GetEnumerator()
}
public System.Collections.Specialized.BitVector32 : ValueType {
private int bits
public int Data
public int Item
public bool Item
public void .ctor(BitVector32 source)
public void .ctor(int init)
public int get_Data()
public int get_Item(Section section)
public void set_Item(Section section, int value)
public bool get_Item(int mask)
public void set_Item(int mask, bool value)
public int CreateMask()
public int CreateMask(int prev)
public Section CreateSection(short maxValue)
public Section CreateSection(short maxValue, Section previous)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
public string ToString(BitVector32 value)
private int HighestSetBit(int i)
}
public System.Collections.Specialized.CollectionsUtil : object {
public Hashtable CreateCaseInsensitiveHashtable()
public Hashtable CreateCaseInsensitiveHashtable(IDictionary d)
public Hashtable CreateCaseInsensitiveHashtable(int capacity)
public SortedList CreateCaseInsensitiveSortedList()
}
public System.Collections.Specialized.HybridDictionary : object {
private int switchAfter
private bool caseInsensitive
private Hashtable hashtable
private ListDictionary list
private IDictionary inner
public int Count
public bool IsFixedSize
public bool IsReadOnly
public bool IsSynchronized
public object Item
public ICollection Keys
public object SyncRoot
public ICollection Values
public void .ctor(bool caseInsensitive)
public void .ctor(int initialSize)
public void .ctor(int initialSize, bool caseInsensitive)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IDictionary get_inner()
public int get_Count()
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Keys()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void CopyTo(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
public void Remove(object key)
private void Switch()
}
public System.Collections.Specialized.IOrderedDictionary {
public object Item
public IDictionaryEnumerator GetEnumerator()
public void Insert(int idx, object key, object value)
public void RemoveAt(int idx)
public object get_Item(int idx)
public void set_Item(int idx, object value)
}
public System.Collections.Specialized.ListDictionary : object {
private int count
private int version
private DictionaryNode head
private IComparer comparer
public int Count
public bool IsSynchronized
public object SyncRoot
public bool IsFixedSize
public bool IsReadOnly
public object Item
public ICollection Keys
public ICollection Values
public void .ctor(IComparer comparer)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private DictionaryNode FindEntry(object key)
private DictionaryNode FindEntry(object key, DictionaryNode& prev)
private void AddImpl(object key, object value, DictionaryNode prev)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Keys()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public IDictionaryEnumerator GetEnumerator()
public void Remove(object key)
}
public System.Collections.Specialized.NameObjectCollectionBase : object {
private Hashtable m_ItemsContainer
private _Item m_NullKeyItem
private ArrayList m_ItemsArray
private IHashCodeProvider m_hashprovider
private IComparer m_comparer
private int m_defCapacity
private bool m_readonly
private SerializationInfo infoCopy
private KeysCollection keyscoll
private IEqualityComparer equality_comparer
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
internal IEqualityComparer EqualityComparer
internal IComparer Comparer
internal IHashCodeProvider HashCodeProvider
public KeysCollection Keys
public int Count
protected bool IsReadOnly
protected void .ctor(int capacity)
internal void .ctor(IEqualityComparer equalityComparer, IComparer comparer, IHashCodeProvider hcp)
protected void .ctor(IEqualityComparer equalityComparer)
protected void .ctor(IHashCodeProvider hashProvider, IComparer comparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
protected void .ctor(int capacity, IEqualityComparer equalityComparer)
protected void .ctor(int capacity, IHashCodeProvider hashProvider, IComparer comparer)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
internal IEqualityComparer get_EqualityComparer()
internal IComparer get_Comparer()
internal IHashCodeProvider get_HashCodeProvider()
private void Init()
public KeysCollection get_Keys()
public IEnumerator GetEnumerator()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public int get_Count()
public void OnDeserialization(object sender)
protected bool get_IsReadOnly()
protected void set_IsReadOnly(bool value)
protected void BaseAdd(string name, object value)
protected void BaseClear()
protected object BaseGet(int index)
protected object BaseGet(string name)
protected String[] BaseGetAllKeys()
protected Object[] BaseGetAllValues()
protected Object[] BaseGetAllValues(Type type)
protected string BaseGetKey(int index)
protected bool BaseHasKeys()
protected void BaseRemove(string name)
protected void BaseRemoveAt(int index)
protected void BaseSet(int index, object value)
protected void BaseSet(string name, object value)
private _Item FindFirstMatchedItem(string name)
internal bool Equals(string s1, string s2)
}
public System.Collections.Specialized.NameValueCollection : NameObjectCollectionBase {
private String[] cachedAllKeys
private String[] cachedAll
public String[] AllKeys
public string Item
public string Item
public void .ctor(int capacity)
public void .ctor(NameValueCollection col)
public void .ctor(IHashCodeProvider hashProvider, IComparer comparer)
public void .ctor(int capacity, NameValueCollection col)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(int capacity, IHashCodeProvider hashProvider, IComparer comparer)
public void .ctor(IEqualityComparer equalityComparer)
public void .ctor(int capacity, IEqualityComparer equalityComparer)
public String[] get_AllKeys()
public string get_Item(int index)
public string get_Item(string name)
public void set_Item(string name, string value)
public void Add(NameValueCollection c)
public void Add(string name, string val)
public void Clear()
public void CopyTo(Array dest, int index)
private void RefreshCachedAll()
public string Get(int index)
public string Get(string name)
private string AsSingleString(ArrayList values)
public string GetKey(int index)
public String[] GetValues(int index)
public String[] GetValues(string name)
private String[] AsStringArray(ArrayList values)
public bool HasKeys()
public void Remove(string name)
public void Set(string name, string value)
protected void InvalidateCachedArrays()
}
public System.Collections.Specialized.OrderedDictionary : object {
private ArrayList list
private Hashtable hash
private bool readOnly
private int initialCapacity
private SerializationInfo serializationInfo
private IEqualityComparer comparer
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IDictionary.IsFixedSize
public int Count
public bool IsReadOnly
public object Item
public object Item
public ICollection Keys
public ICollection Values
public void .ctor(int capacity)
public void .ctor(IEqualityComparer equalityComparer)
public void .ctor(int capacity, IEqualityComparer equalityComparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.IDictionary.get_IsFixedSize()
protected void OnDeserialization(object sender)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public int get_Count()
public void CopyTo(Array array, int index)
public bool get_IsReadOnly()
public object get_Item(object key)
public void set_Item(object key, object value)
public object get_Item(int index)
public void set_Item(int index, object value)
public ICollection get_Keys()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public IDictionaryEnumerator GetEnumerator()
public void Remove(object key)
private int FindListEntry(object key)
private void WriteCheck()
public OrderedDictionary AsReadOnly()
public void Insert(int index, object key, object value)
public void RemoveAt(int index)
}
internal System.Collections.Specialized.ProcessStringDictionary : StringDictionary {
private Hashtable table
public int Count
public bool IsSynchronized
public string Item
public ICollection Keys
public ICollection Values
public object SyncRoot
public int get_Count()
public bool get_IsSynchronized()
public string get_Item(string key)
public void set_Item(string key, string value)
public ICollection get_Keys()
public ICollection get_Values()
public object get_SyncRoot()
public void Add(string key, string value)
public void Clear()
public bool ContainsKey(string key)
public bool ContainsValue(string value)
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string key)
}
public System.Collections.Specialized.StringCollection : object {
private ArrayList data
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.IList.IsFixedSize
private object System.Collections.IList.Item
public string Item
public int Count
public bool IsReadOnly
public bool IsSynchronized
public object SyncRoot
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.IList.get_IsFixedSize()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public string get_Item(int index)
public void set_Item(int index, string value)
public int get_Count()
public int Add(string value)
public void AddRange(String[] value)
public void Clear()
public bool Contains(string value)
public void CopyTo(String[] array, int index)
public StringEnumerator GetEnumerator()
public int IndexOf(string value)
public void Insert(int index, string value)
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public void Remove(string value)
public void RemoveAt(int index)
public object get_SyncRoot()
}
public System.Collections.Specialized.StringDictionary : object {
private Hashtable contents
public int Count
public bool IsSynchronized
public string Item
public ICollection Keys
public ICollection Values
public object SyncRoot
public int get_Count()
public bool get_IsSynchronized()
public string get_Item(string key)
public void set_Item(string key, string value)
public ICollection get_Keys()
public ICollection get_Values()
public object get_SyncRoot()
public void Add(string key, string value)
public void Clear()
public bool ContainsKey(string key)
public bool ContainsValue(string value)
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string key)
}
public System.Collections.Specialized.StringEnumerator : object {
private IEnumerator enumerable
public string Current
internal void .ctor(StringCollection coll)
public string get_Current()
public bool MoveNext()
public void Reset()
}
public System.ComponentModel.AddingNewEventArgs : EventArgs {
private object obj
public object NewObject
public void .ctor(object newObject)
public object get_NewObject()
public void set_NewObject(object value)
}
public System.ComponentModel.AddingNewEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AddingNewEventArgs e)
public IAsyncResult BeginInvoke(object sender, AddingNewEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.AmbientValueAttribute : Attribute {
private object AmbientValue
public object Value
public void .ctor(bool value)
public void .ctor(byte value)
public void .ctor(char value)
public void .ctor(double value)
public void .ctor(short value)
public void .ctor(int value)
public void .ctor(long value)
public void .ctor(object value)
public void .ctor(float value)
public void .ctor(string value)
public void .ctor(Type type, string value)
public object get_Value()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.ArrayConverter : CollectionConverter {
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.AsyncCompletedEventArgs : EventArgs {
private Exception _error
private bool _cancelled
private object _userState
public bool Cancelled
public Exception Error
public object UserState
public void .ctor(Exception error, bool cancelled, object userState)
protected void RaiseExceptionIfNecessary()
public bool get_Cancelled()
public Exception get_Error()
public object get_UserState()
}
public System.ComponentModel.AsyncCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AsyncCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.AsyncOperation : object {
private SynchronizationContext ctx
private object state
private bool done
public SynchronizationContext SynchronizationContext
public object UserSuppliedState
internal void .ctor(SynchronizationContext ctx, object state)
protected void Finalize()
public SynchronizationContext get_SynchronizationContext()
public object get_UserSuppliedState()
public void OperationCompleted()
public void Post(SendOrPostCallback d, object arg)
public void PostOperationCompleted(SendOrPostCallback d, object arg)
}
public System.ComponentModel.AsyncOperationManager : object {
public SynchronizationContext SynchronizationContext
public SynchronizationContext get_SynchronizationContext()
public void set_SynchronizationContext(SynchronizationContext value)
public AsyncOperation CreateOperation(object userSuppliedState)
}
public System.ComponentModel.AttributeCollection : object {
private ArrayList attrList
public AttributeCollection Empty
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private int System.Collections.ICollection.Count
public int Count
public Attribute Item
public Attribute Item
internal void .ctor(ArrayList attributes)
public void .ctor(Attribute[] attributes)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private int System.Collections.ICollection.get_Count()
public AttributeCollection FromExisting(AttributeCollection existing, Attribute[] newAttributes)
public bool Contains(Attribute attr)
public bool Contains(Attribute[] attributes)
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public bool Matches(Attribute attr)
public bool Matches(Attribute[] attributes)
protected Attribute GetDefaultAttribute(Type attributeType)
public int get_Count()
public Attribute get_Item(Type type)
public Attribute get_Item(int index)
}
public System.ComponentModel.AttributeProviderAttribute : Attribute {
private string type_name
private string property_name
public string PropertyName
public string TypeName
public void .ctor(Type type)
public void .ctor(string typeName, string propertyName)
public void .ctor(string typeName)
public string get_PropertyName()
public string get_TypeName()
}
public System.ComponentModel.BackgroundWorker : Component {
private AsyncOperation async
private bool cancel_pending
private bool report_progress
private bool support_cancel
private DoWorkEventHandler DoWork
private ProgressChangedEventHandler ProgressChanged
private RunWorkerCompletedEventHandler RunWorkerCompleted
public bool CancellationPending
public bool IsBusy
public bool WorkerReportsProgress
public bool WorkerSupportsCancellation
public void add_DoWork(DoWorkEventHandler value)
public void remove_DoWork(DoWorkEventHandler value)
public void add_ProgressChanged(ProgressChangedEventHandler value)
public void remove_ProgressChanged(ProgressChangedEventHandler value)
public void add_RunWorkerCompleted(RunWorkerCompletedEventHandler value)
public void remove_RunWorkerCompleted(RunWorkerCompletedEventHandler value)
public bool get_CancellationPending()
public bool get_IsBusy()
public bool get_WorkerReportsProgress()
public void set_WorkerReportsProgress(bool value)
public bool get_WorkerSupportsCancellation()
public void set_WorkerSupportsCancellation(bool value)
public void CancelAsync()
public void ReportProgress(int percentProgress)
public void ReportProgress(int percentProgress, object userState)
public void RunWorkerAsync()
private void ProcessWorker(object argument, AsyncOperation async, SendOrPostCallback callback)
private void CompleteWorker(object state)
public void RunWorkerAsync(object argument)
protected void OnDoWork(DoWorkEventArgs e)
protected void OnProgressChanged(ProgressChangedEventArgs e)
protected void OnRunWorkerCompleted(RunWorkerCompletedEventArgs e)
private void <ReportProgress>m__0(object o)
private void <CompleteWorker>m__1(object darg)
}
public System.ComponentModel.BaseNumberConverter : TypeConverter {
internal Type InnerType
internal bool SupportHex
internal bool get_SupportHex()
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type t)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
internal object ConvertFromString(string value, int fromBase)
}
public System.ComponentModel.BindableAttribute : Attribute {
private bool bindable
private BindingDirection direction
public BindableAttribute No
public BindableAttribute Yes
public BindableAttribute Default
public BindingDirection Direction
public bool Bindable
public void .ctor(BindableSupport flags)
public void .ctor(bool bindable)
public void .ctor(bool bindable, BindingDirection direction)
public void .ctor(BindableSupport flags, BindingDirection direction)
public BindingDirection get_Direction()
public bool get_Bindable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.BindableSupport : Enum {
public int value__
public BindableSupport No
public BindableSupport Yes
public BindableSupport Default
}
public System.ComponentModel.BindingDirection : Enum {
public int value__
public BindingDirection OneWay
public BindingDirection TwoWay
}
public System.ComponentModel.BindingList`1 : Collection`1<T> {
private bool allow_edit
private bool allow_remove
private bool allow_new
private bool allow_new_set
private bool raise_list_changed_events
private bool type_has_default_ctor
private bool type_raises_item_changed_events
private bool add_pending
private int pending_add_index
private AddingNewEventHandler AddingNew
private ListChangedEventHandler ListChanged
private bool System.ComponentModel.IBindingList.IsSorted
private ListSortDirection System.ComponentModel.IBindingList.SortDirection
private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty
private bool System.ComponentModel.IBindingList.AllowEdit
private bool System.ComponentModel.IBindingList.AllowNew
private bool System.ComponentModel.IBindingList.AllowRemove
private bool System.ComponentModel.IBindingList.SupportsChangeNotification
private bool System.ComponentModel.IBindingList.SupportsSearching
private bool System.ComponentModel.IBindingList.SupportsSorting
private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents
public bool AllowEdit
public bool AllowNew
public bool AllowRemove
protected bool IsSortedCore
public bool RaiseListChangedEvents
protected ListSortDirection SortDirectionCore
protected PropertyDescriptor SortPropertyCore
protected bool SupportsChangeNotificationCore
protected bool SupportsSearchingCore
protected bool SupportsSortingCore
public void .ctor(IList`1<T> list)
public void add_AddingNew(AddingNewEventHandler value)
public void remove_AddingNew(AddingNewEventHandler value)
public void add_ListChanged(ListChangedEventHandler value)
public void remove_ListChanged(ListChangedEventHandler value)
private void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor index)
private object System.ComponentModel.IBindingList.AddNew()
private void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)
private int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key)
private void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property)
private void System.ComponentModel.IBindingList.RemoveSort()
private bool System.ComponentModel.IBindingList.get_IsSorted()
private ListSortDirection System.ComponentModel.IBindingList.get_SortDirection()
private PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty()
private bool System.ComponentModel.IBindingList.get_AllowEdit()
private bool System.ComponentModel.IBindingList.get_AllowNew()
private bool System.ComponentModel.IBindingList.get_AllowRemove()
private bool System.ComponentModel.IBindingList.get_SupportsChangeNotification()
private bool System.ComponentModel.IBindingList.get_SupportsSearching()
private bool System.ComponentModel.IBindingList.get_SupportsSorting()
private bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents()
private void CheckType()
public bool get_AllowEdit()
public void set_AllowEdit(bool value)
public bool get_AllowNew()
public void set_AllowNew(bool value)
public bool get_AllowRemove()
public void set_AllowRemove(bool value)
protected bool get_IsSortedCore()
public bool get_RaiseListChangedEvents()
public void set_RaiseListChangedEvents(bool value)
protected ListSortDirection get_SortDirectionCore()
protected PropertyDescriptor get_SortPropertyCore()
protected bool get_SupportsChangeNotificationCore()
protected bool get_SupportsSearchingCore()
protected bool get_SupportsSortingCore()
public T AddNew()
protected object AddNewCore()
protected void ApplySortCore(PropertyDescriptor prop, ListSortDirection direction)
public void CancelNew(int itemIndex)
protected void ClearItems()
public void EndNew(int itemIndex)
protected int FindCore(PropertyDescriptor prop, object key)
protected void InsertItem(int index, T item)
protected void OnAddingNew(AddingNewEventArgs e)
protected void OnListChanged(ListChangedEventArgs e)
protected void RemoveItem(int index)
protected void RemoveSortCore()
public void ResetBindings()
public void ResetItem(int position)
protected void SetItem(int index, T item)
}
public System.ComponentModel.BooleanConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.BrowsableAttribute : Attribute {
private bool browsable
public BrowsableAttribute Default
public BrowsableAttribute No
public BrowsableAttribute Yes
public bool Browsable
public void .ctor(bool browsable)
public bool get_Browsable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ByteConverter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
internal object ConvertFromString(string value, int fromBase)
}
public System.ComponentModel.CancelEventArgs : EventArgs {
private bool cancel
public bool Cancel
public void .ctor(bool cancel)
public bool get_Cancel()
public void set_Cancel(bool value)
}
public System.ComponentModel.CancelEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, CancelEventArgs e)
public IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.CategoryAttribute : Attribute {
private string category
private bool IsLocalized
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) action
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) appearance
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) behaviour
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) data
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) def
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) design
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) drag_drop
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) focus
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) format
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) key
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) layout
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) mouse
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) window_style
private CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) async
private object lockobj
public CategoryAttribute Action
public CategoryAttribute Appearance
public CategoryAttribute Asynchronous
public CategoryAttribute Behavior
public CategoryAttribute Data
public CategoryAttribute Default
public CategoryAttribute Design
public CategoryAttribute DragDrop
public CategoryAttribute Focus
public CategoryAttribute Format
public CategoryAttribute Key
public CategoryAttribute Layout
public CategoryAttribute Mouse
public CategoryAttribute WindowStyle
public string Category
public void .ctor(string category)
public CategoryAttribute get_Action()
public CategoryAttribute get_Appearance()
public CategoryAttribute get_Asynchronous()
public CategoryAttribute get_Behavior()
public CategoryAttribute get_Data()
public CategoryAttribute get_Default()
public CategoryAttribute get_Design()
public CategoryAttribute get_DragDrop()
public CategoryAttribute get_Focus()
public CategoryAttribute get_Format()
public CategoryAttribute get_Key()
public CategoryAttribute get_Layout()
public CategoryAttribute get_Mouse()
public CategoryAttribute get_WindowStyle()
protected string GetLocalizedString(string value)
public string get_Category()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.CharConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.CollectionChangeAction : Enum {
public int value__
public CollectionChangeAction Add
public CollectionChangeAction Remove
public CollectionChangeAction Refresh
}
public System.ComponentModel.CollectionChangeEventArgs : EventArgs {
private CollectionChangeAction changeAction
private object theElement
public CollectionChangeAction Action
public object Element
public void .ctor(CollectionChangeAction action, object element)
public CollectionChangeAction get_Action()
public object get_Element()
}
public System.ComponentModel.CollectionChangeEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, CollectionChangeEventArgs e)
public IAsyncResult BeginInvoke(object sender, CollectionChangeEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.CollectionConverter : TypeConverter {
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.ComplexBindingPropertiesAttribute : Attribute {
private string data_source
private string data_member
public ComplexBindingPropertiesAttribute Default
public string DataMember
public string DataSource
public void .ctor(string dataSource, string dataMember)
public void .ctor(string dataSource)
public string get_DataMember()
public string get_DataSource()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.Component : MarshalByRefObject {
private EventHandlerList event_handlers
private ISite mySite
private object disposedEvent
protected bool CanRaiseEvents
public ISite Site
public IContainer Container
protected bool DesignMode
protected EventHandlerList Events
public void add_Disposed(EventHandler value)
public void remove_Disposed(EventHandler value)
protected bool get_CanRaiseEvents()
public ISite get_Site()
public void set_Site(ISite value)
public IContainer get_Container()
protected bool get_DesignMode()
protected EventHandlerList get_Events()
protected void Finalize()
public void Dispose()
protected void Dispose(bool release_all)
protected object GetService(Type service)
public string ToString()
}
public System.ComponentModel.ComponentCollection : ReadOnlyCollectionBase {
public IComponent Item
public IComponent Item
public void .ctor(IComponent[] components)
public IComponent get_Item(int index)
public IComponent get_Item(string name)
public void CopyTo(IComponent[] array, int index)
}
public System.ComponentModel.ComponentConverter : ReferenceConverter {
public void .ctor(Type type)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.ComponentEditor : object {
public bool EditComponent(object component)
public bool EditComponent(ITypeDescriptorContext context, object component)
}
internal System.ComponentModel.ComponentInfo : Info {
private IComponent _component
private EventDescriptorCollection _events
private PropertyDescriptorCollection _properties
public void .ctor(IComponent component)
public AttributeCollection GetAttributes()
public EventDescriptorCollection GetEvents()
public PropertyDescriptorCollection GetProperties()
}
public System.ComponentModel.ComponentResourceManager : ResourceManager {
public void .ctor(Type t)
public void ApplyResources(object value, string objectName)
public void ApplyResources(object value, string objectName, CultureInfo culture)
private void BuildResources(CultureInfo culture, Hashtable resources)
}
public System.ComponentModel.Container : object {
private List`1<IComponent> c
public ComponentCollection Components
public ComponentCollection get_Components()
public void Add(IComponent component)
public void Add(IComponent component, string name)
protected void ValidateName(IComponent component, string name)
protected ISite CreateSite(IComponent component, string name)
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
protected object GetService(Type service)
public void Remove(IComponent component)
private void Remove(IComponent component, bool unsite)
protected void RemoveWithoutUnsiting(IComponent component)
}
public System.ComponentModel.ContainerFilterService : object {
public ComponentCollection FilterComponents(ComponentCollection components)
}
public System.ComponentModel.CultureInfoConverter : TypeConverter {
private StandardValuesCollection _standardValues
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.CustomTypeDescriptor : object {
private ICustomTypeDescriptor _parent
protected void .ctor(ICustomTypeDescriptor parent)
public AttributeCollection GetAttributes()
public string GetClassName()
public string GetComponentName()
public TypeConverter GetConverter()
public EventDescriptor GetDefaultEvent()
public PropertyDescriptor GetDefaultProperty()
public object GetEditor(Type editorBaseType)
public EventDescriptorCollection GetEvents()
public EventDescriptorCollection GetEvents(Attribute[] attributes)
public PropertyDescriptorCollection GetProperties()
public PropertyDescriptorCollection GetProperties(Attribute[] attributes)
public object GetPropertyOwner(PropertyDescriptor pd)
}
public System.ComponentModel.DataObjectAttribute : Attribute {
public DataObjectAttribute DataObject
public DataObjectAttribute Default
public DataObjectAttribute NonDataObject
private bool _isDataObject
public bool IsDataObject
public void .ctor(bool isDataObject)
public bool get_IsDataObject()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DataObjectFieldAttribute : Attribute {
private bool primary_key
private bool is_identity
private bool is_nullable
private int length
public bool IsIdentity
public bool IsNullable
public int Length
public bool PrimaryKey
public void .ctor(bool primaryKey)
public void .ctor(bool primaryKey, bool isIdentity)
public void .ctor(bool primaryKey, bool isIdentity, bool isNullable)
public void .ctor(bool primaryKey, bool isIdentity, bool isNullable, int length)
public bool get_IsIdentity()
public bool get_IsNullable()
public int get_Length()
public bool get_PrimaryKey()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DataObjectMethodAttribute : Attribute {
private DataObjectMethodType _methodType
private bool _isDefault
public DataObjectMethodType MethodType
public bool IsDefault
public void .ctor(DataObjectMethodType methodType)
public void .ctor(DataObjectMethodType methodType, bool isDefault)
public DataObjectMethodType get_MethodType()
public bool get_IsDefault()
public bool Match(object obj)
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DataObjectMethodType : Enum {
public int value__
public DataObjectMethodType Fill
public DataObjectMethodType Select
public DataObjectMethodType Update
public DataObjectMethodType Insert
public DataObjectMethodType Delete
}
public System.ComponentModel.DateTimeConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.DecimalConverter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
}
public System.ComponentModel.DefaultBindingPropertyAttribute : Attribute {
public DefaultBindingPropertyAttribute Default
private string name
public string Name
public void .ctor(string name)
public bool Equals(object obj)
public int GetHashCode()
public string get_Name()
}
public System.ComponentModel.DefaultEventAttribute : Attribute {
private string eventName
public DefaultEventAttribute Default
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object o)
public int GetHashCode()
}
public System.ComponentModel.DefaultPropertyAttribute : Attribute {
private string property_name
public DefaultPropertyAttribute Default
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object o)
public int GetHashCode()
}
public System.ComponentModel.DefaultValueAttribute : Attribute {
private object DefaultValue
public object Value
public void .ctor(bool value)
public void .ctor(byte value)
public void .ctor(char value)
public void .ctor(double value)
public void .ctor(short value)
public void .ctor(int value)
public void .ctor(long value)
public void .ctor(object value)
public void .ctor(float value)
public void .ctor(string value)
public void .ctor(Type type, string value)
public object get_Value()
protected void SetValue(object value)
public bool Equals(object obj)
public int GetHashCode()
}
internal System.ComponentModel.DerivedPropertyDescriptor : PropertyDescriptor {
private bool readOnly
private Type componentType
private Type propertyType
private PropertyInfo prop
public Type ComponentType
public bool IsReadOnly
public Type PropertyType
protected void .ctor(string name, Attribute[] attrs)
public void .ctor(string name, Attribute[] attrs, int dummy)
public void SetReadOnly(bool value)
public void SetComponentType(Type type)
public void SetPropertyType(Type type)
public object GetValue(object component)
public void SetValue(object component, object value)
public void ResetValue(object component)
public bool CanResetValue(object component)
public bool ShouldSerializeValue(object component)
public Type get_ComponentType()
public bool get_IsReadOnly()
public Type get_PropertyType()
}
public System.ComponentModel.DescriptionAttribute : Attribute {
private string desc
public DescriptionAttribute Default
public string Description
protected string DescriptionValue
public void .ctor(string name)
public string get_Description()
protected string get_DescriptionValue()
protected void set_DescriptionValue(string value)
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.Design.ActiveDesignerEventArgs : EventArgs {
private IDesignerHost oldDesigner
private IDesignerHost newDesigner
public IDesignerHost NewDesigner
public IDesignerHost OldDesigner
public void .ctor(IDesignerHost oldDesigner, IDesignerHost newDesigner)
public IDesignerHost get_NewDesigner()
public IDesignerHost get_OldDesigner()
}
public System.ComponentModel.Design.ActiveDesignerEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ActiveDesignerEventArgs e)
public IAsyncResult BeginInvoke(object sender, ActiveDesignerEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.CheckoutException : ExternalException {
public CheckoutException Canceled
public void .ctor(string message)
public void .ctor(string message, int errorCode)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.Design.CommandID : object {
private int cID
private Guid guid
public Guid Guid
public int ID
public void .ctor(Guid menuGroup, int commandID)
public Guid get_Guid()
public int get_ID()
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public System.ComponentModel.Design.ComponentChangedEventArgs : EventArgs {
private object component
private MemberDescriptor member
private object oldValue
private object newValue
public object Component
public MemberDescriptor Member
public object NewValue
public object OldValue
public void .ctor(object component, MemberDescriptor member, object oldValue, object newValue)
public object get_Component()
public MemberDescriptor get_Member()
public object get_NewValue()
public object get_OldValue()
}
public System.ComponentModel.Design.ComponentChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.ComponentChangingEventArgs : EventArgs {
private object component
private MemberDescriptor member
public object Component
public MemberDescriptor Member
public void .ctor(object component, MemberDescriptor member)
public object get_Component()
public MemberDescriptor get_Member()
}
public System.ComponentModel.Design.ComponentChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.ComponentEventArgs : EventArgs {
private IComponent icomp
public IComponent Component
public void .ctor(IComponent component)
public IComponent get_Component()
}
public System.ComponentModel.Design.ComponentEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.ComponentRenameEventArgs : EventArgs {
private object component
private string oldName
private string newName
public object Component
public string NewName
public string OldName
public void .ctor(object component, string oldName, string newName)
public object get_Component()
public string get_NewName()
public string get_OldName()
}
public System.ComponentModel.Design.ComponentRenameEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ComponentRenameEventArgs e)
public IAsyncResult BeginInvoke(object sender, ComponentRenameEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.DesignerCollection : object {
private ArrayList designers
private int System.Collections.ICollection.Count
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public int Count
public IDesignerHost Item
public void .ctor(IDesignerHost[] designers)
public void .ctor(IList designers)
private int System.Collections.ICollection.get_Count()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
public int get_Count()
public IDesignerHost get_Item(int index)
public IEnumerator GetEnumerator()
}
public System.ComponentModel.Design.DesignerEventArgs : EventArgs {
private IDesignerHost host
public IDesignerHost Designer
public void .ctor(IDesignerHost host)
public IDesignerHost get_Designer()
}
public System.ComponentModel.Design.DesignerEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DesignerEventArgs e)
public IAsyncResult BeginInvoke(object sender, DesignerEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.DesignerOptionService : object {
private DesignerOptionCollection _options
public DesignerOptionCollection Options
private object System.ComponentModel.Design.IDesignerOptionService.GetOptionValue(string pageName, string valueName)
private void System.ComponentModel.Design.IDesignerOptionService.SetOptionValue(string pageName, string valueName, object value)
protected DesignerOptionCollection CreateOptionCollection(DesignerOptionCollection parent, string name, object value)
protected bool ShowDialog(DesignerOptionCollection options, object optionObject)
protected void PopulateOptionCollection(DesignerOptionCollection options)
public DesignerOptionCollection get_Options()
private PropertyDescriptor GetOptionProperty(string pageName, string valueName)
}
public System.ComponentModel.Design.DesignerTransaction : object {
private string description
private bool committed
private bool canceled
public bool Canceled
public bool Committed
public string Description
protected void .ctor(string description)
private void System.IDisposable.Dispose()
protected void Dispose(bool disposing)
protected void OnCancel()
protected void OnCommit()
public void Cancel()
public void Commit()
public bool get_Canceled()
public bool get_Committed()
public string get_Description()
protected void Finalize()
}
public System.ComponentModel.Design.DesignerTransactionCloseEventArgs : EventArgs {
private bool commit
private bool last_transaction
public bool LastTransaction
public bool TransactionCommitted
public void .ctor(bool commit, bool lastTransaction)
public void .ctor(bool commit)
public bool get_LastTransaction()
public bool get_TransactionCommitted()
}
public System.ComponentModel.Design.DesignerTransactionCloseEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DesignerTransactionCloseEventArgs e)
public IAsyncResult BeginInvoke(object sender, DesignerTransactionCloseEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.DesignerVerb : MenuCommand {
private string text
private string description
public string Text
public string Description
public void .ctor(string text, EventHandler handler)
public void .ctor(string text, EventHandler handler, CommandID startCommandID)
public string get_Text()
public string get_Description()
public void set_Description(string value)
public string ToString()
}
public System.ComponentModel.Design.DesignerVerbCollection : CollectionBase {
public DesignerVerb Item
public void .ctor(DesignerVerb[] value)
public DesignerVerb get_Item(int index)
public void set_Item(int index, DesignerVerb value)
public int Add(DesignerVerb value)
public void AddRange(DesignerVerb[] value)
public void AddRange(DesignerVerbCollection value)
public bool Contains(DesignerVerb value)
public void CopyTo(DesignerVerb[] array, int index)
public int IndexOf(DesignerVerb value)
public void Insert(int index, DesignerVerb value)
protected void OnClear()
protected void OnInsert(int index, object value)
protected void OnRemove(int index, object value)
protected void OnSet(int index, object oldValue, object newValue)
protected void OnValidate(object value)
public void Remove(DesignerVerb value)
}
public System.ComponentModel.Design.DesigntimeLicenseContext : LicenseContext {
internal Hashtable keys
public LicenseUsageMode UsageMode
public string GetSavedLicenseKey(Type type, Assembly resourceAssembly)
public void SetSavedLicenseKey(Type type, string key)
public LicenseUsageMode get_UsageMode()
}
public System.ComponentModel.Design.DesigntimeLicenseContextSerializer : object {
public void Serialize(Stream o, string cryptoKey, DesigntimeLicenseContext context)
}
public System.ComponentModel.Design.HelpContextType : Enum {
public int value__
public HelpContextType Ambient
public HelpContextType Window
public HelpContextType Selection
public HelpContextType ToolWindowSelection
}
public System.ComponentModel.Design.HelpKeywordAttribute : Attribute {
public HelpKeywordAttribute Default
private string contextKeyword
public string HelpKeyword
public void .ctor(string keyword)
public void .ctor(Type t)
public bool Equals(object other)
public int GetHashCode()
public bool IsDefaultAttribute()
public string get_HelpKeyword()
}
public System.ComponentModel.Design.HelpKeywordType : Enum {
public int value__
public HelpKeywordType F1Keyword
public HelpKeywordType GeneralKeyword
public HelpKeywordType FilterKeyword
}
public System.ComponentModel.Design.IComponentChangeService {
public void add_ComponentAdded(ComponentEventHandler value)
public void remove_ComponentAdded(ComponentEventHandler value)
public void add_ComponentAdding(ComponentEventHandler value)
public void remove_ComponentAdding(ComponentEventHandler value)
public void add_ComponentChanged(ComponentChangedEventHandler value)
public void remove_ComponentChanged(ComponentChangedEventHandler value)
public void add_ComponentChanging(ComponentChangingEventHandler value)
public void remove_ComponentChanging(ComponentChangingEventHandler value)
public void add_ComponentRemoved(ComponentEventHandler value)
public void remove_ComponentRemoved(ComponentEventHandler value)
public void add_ComponentRemoving(ComponentEventHandler value)
public void remove_ComponentRemoving(ComponentEventHandler value)
public void add_ComponentRename(ComponentRenameEventHandler value)
public void remove_ComponentRename(ComponentRenameEventHandler value)
public void OnComponentChanged(object component, MemberDescriptor member, object oldValue, object newValue)
public void OnComponentChanging(object component, MemberDescriptor member)
}
public System.ComponentModel.Design.IComponentDiscoveryService {
public ICollection GetComponentTypes(IDesignerHost designerHost, Type baseType)
}
public System.ComponentModel.Design.IComponentInitializer {
public void InitializeExistingComponent(IDictionary defaultValues)
public void InitializeNewComponent(IDictionary defaultValues)
}
public System.ComponentModel.Design.IDesigner {
public IComponent Component
public DesignerVerbCollection Verbs
public IComponent get_Component()
public DesignerVerbCollection get_Verbs()
public void DoDefaultAction()
public void Initialize(IComponent component)
}
public System.ComponentModel.Design.IDesignerEventService {
public IDesignerHost ActiveDesigner
public DesignerCollection Designers
public void add_ActiveDesignerChanged(ActiveDesignerEventHandler value)
public void remove_ActiveDesignerChanged(ActiveDesignerEventHandler value)
public void add_DesignerCreated(DesignerEventHandler value)
public void remove_DesignerCreated(DesignerEventHandler value)
public void add_DesignerDisposed(DesignerEventHandler value)
public void remove_DesignerDisposed(DesignerEventHandler value)
public void add_SelectionChanged(EventHandler value)
public void remove_SelectionChanged(EventHandler value)
public IDesignerHost get_ActiveDesigner()
public DesignerCollection get_Designers()
}
public System.ComponentModel.Design.IDesignerFilter {
public void PostFilterAttributes(IDictionary attributes)
public void PostFilterEvents(IDictionary events)
public void PostFilterProperties(IDictionary properties)
public void PreFilterAttributes(IDictionary attributes)
public void PreFilterEvents(IDictionary events)
public void PreFilterProperties(IDictionary properties)
}
public System.ComponentModel.Design.IDesignerHost {
public IContainer Container
public bool InTransaction
public bool Loading
public IComponent RootComponent
public string RootComponentClassName
public string TransactionDescription
public void add_Activated(EventHandler value)
public void remove_Activated(EventHandler value)
public void add_Deactivated(EventHandler value)
public void remove_Deactivated(EventHandler value)
public void add_LoadComplete(EventHandler value)
public void remove_LoadComplete(EventHandler value)
public void add_TransactionClosed(DesignerTransactionCloseEventHandler value)
public void remove_TransactionClosed(DesignerTransactionCloseEventHandler value)
public void add_TransactionClosing(DesignerTransactionCloseEventHandler value)
public void remove_TransactionClosing(DesignerTransactionCloseEventHandler value)
public void add_TransactionOpened(EventHandler value)
public void remove_TransactionOpened(EventHandler value)
public void add_TransactionOpening(EventHandler value)
public void remove_TransactionOpening(EventHandler value)
public IContainer get_Container()
public bool get_InTransaction()
public bool get_Loading()
public IComponent get_RootComponent()
public string get_RootComponentClassName()
public string get_TransactionDescription()
public void Activate()
public IComponent CreateComponent(Type componentClass)
public IComponent CreateComponent(Type componentClass, string name)
public DesignerTransaction CreateTransaction()
public DesignerTransaction CreateTransaction(string description)
public void DestroyComponent(IComponent component)
public IDesigner GetDesigner(IComponent component)
public Type GetType(string typeName)
}
public System.ComponentModel.Design.IDesignerOptionService {
public object GetOptionValue(string pageName, string valueName)
public void SetOptionValue(string pageName, string valueName, object value)
}
public System.ComponentModel.Design.IDictionaryService {
public object GetKey(object value)
public object GetValue(object key)
public void SetValue(object key, object value)
}
public System.ComponentModel.Design.IEventBindingService {
public string CreateUniqueMethodName(IComponent component, EventDescriptor e)
public ICollection GetCompatibleMethods(EventDescriptor e)
public EventDescriptor GetEvent(PropertyDescriptor property)
public PropertyDescriptorCollection GetEventProperties(EventDescriptorCollection events)
public PropertyDescriptor GetEventProperty(EventDescriptor e)
public bool ShowCode()
public bool ShowCode(int lineNumber)
public bool ShowCode(IComponent component, EventDescriptor e)
}
public System.ComponentModel.Design.IExtenderListService {
public IExtenderProvider[] GetExtenderProviders()
}
public System.ComponentModel.Design.IExtenderProviderService {
public void AddExtenderProvider(IExtenderProvider provider)
public void RemoveExtenderProvider(IExtenderProvider provider)
}
public System.ComponentModel.Design.IHelpService {
public void AddContextAttribute(string name, string value, HelpKeywordType keywordType)
public void ClearContextAttributes()
public IHelpService CreateLocalContext(HelpContextType contextType)
public void RemoveContextAttribute(string name, string value)
public void RemoveLocalContext(IHelpService localContext)
public void ShowHelpFromKeyword(string helpKeyword)
public void ShowHelpFromUrl(string helpUrl)
}
public System.ComponentModel.Design.IInheritanceService {
public void AddInheritedComponents(IComponent component, IContainer container)
public InheritanceAttribute GetInheritanceAttribute(IComponent component)
}
public System.ComponentModel.Design.IMenuCommandService {
public DesignerVerbCollection Verbs
public DesignerVerbCollection get_Verbs()
public void AddCommand(MenuCommand command)
public void AddVerb(DesignerVerb verb)
public MenuCommand FindCommand(CommandID commandID)
public bool GlobalInvoke(CommandID commandID)
public void RemoveCommand(MenuCommand command)
public void RemoveVerb(DesignerVerb verb)
public void ShowContextMenu(CommandID menuID, int x, int y)
}
public System.ComponentModel.Design.IReferenceService {
public IComponent GetComponent(object reference)
public string GetName(object reference)
public object GetReference(string name)
public Object[] GetReferences()
public Object[] GetReferences(Type baseType)
}
public System.ComponentModel.Design.IResourceService {
public IResourceReader GetResourceReader(CultureInfo info)
public IResourceWriter GetResourceWriter(CultureInfo info)
}
public System.ComponentModel.Design.IRootDesigner {
public ViewTechnology[] SupportedTechnologies
public ViewTechnology[] get_SupportedTechnologies()
public object GetView(ViewTechnology technology)
}
public System.ComponentModel.Design.ISelectionService {
public object PrimarySelection
public int SelectionCount
public void add_SelectionChanged(EventHandler value)
public void remove_SelectionChanged(EventHandler value)
public void add_SelectionChanging(EventHandler value)
public void remove_SelectionChanging(EventHandler value)
public bool GetComponentSelected(object component)
public ICollection GetSelectedComponents()
public void SetSelectedComponents(ICollection components, SelectionTypes selectionType)
public void SetSelectedComponents(ICollection components)
public object get_PrimarySelection()
public int get_SelectionCount()
}
public System.ComponentModel.Design.IServiceContainer {
public void AddService(Type serviceType, object serviceInstance)
public void AddService(Type serviceType, ServiceCreatorCallback callback)
public void AddService(Type serviceType, object serviceInstance, bool promote)
public void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote)
public void RemoveService(Type serviceType)
public void RemoveService(Type serviceType, bool promote)
}
public System.ComponentModel.Design.ITreeDesigner {
public ICollection Children
public IDesigner Parent
public ICollection get_Children()
public IDesigner get_Parent()
}
public System.ComponentModel.Design.ITypeDescriptorFilterService {
public bool FilterAttributes(IComponent component, IDictionary attributes)
public bool FilterEvents(IComponent component, IDictionary events)
public bool FilterProperties(IComponent component, IDictionary properties)
}
public System.ComponentModel.Design.ITypeDiscoveryService {
public ICollection GetTypes(Type baseType, bool excludeGlobalTypes)
}
public System.ComponentModel.Design.ITypeResolutionService {
public Assembly GetAssembly(AssemblyName name)
public Assembly GetAssembly(AssemblyName name, bool throwOnError)
public string GetPathOfAssembly(AssemblyName name)
public Type GetType(string name)
public Type GetType(string name, bool throwOnError)
public Type GetType(string name, bool throwOnError, bool ignoreCase)
public void ReferenceAssembly(AssemblyName name)
}
public System.ComponentModel.Design.MenuCommand : object {
private EventHandler handler
private CommandID command
private bool ischecked
private bool enabled
private bool issupported
private bool visible
private Hashtable properties
private EventHandler CommandChanged
public bool Checked
public CommandID CommandID
public bool Enabled
public int OleStatus
public IDictionary Properties
public bool Supported
public bool Visible
public void .ctor(EventHandler handler, CommandID command)
public void add_CommandChanged(EventHandler value)
public void remove_CommandChanged(EventHandler value)
public bool get_Checked()
public void set_Checked(bool value)
public CommandID get_CommandID()
public bool get_Enabled()
public void set_Enabled(bool value)
public int get_OleStatus()
public IDictionary get_Properties()
public bool get_Supported()
public void set_Supported(bool value)
public bool get_Visible()
public void set_Visible(bool value)
public void Invoke()
public void Invoke(object arg)
protected void OnCommandChanged(EventArgs e)
public string ToString()
}
internal System.ComponentModel.Design.RuntimeLicenseContext : LicenseContext {
private Hashtable extraassemblies
private Hashtable keys
private void LoadKeys()
private void LoadAssemblyLicenses(Hashtable targetkeys, Assembly asm)
public string GetSavedLicenseKey(Type type, Assembly resourceAssembly)
public void SetSavedLicenseKey(Type type, string key)
}
public System.ComponentModel.Design.SelectionTypes : Enum {
public int value__
public SelectionTypes Auto
public SelectionTypes Normal
public SelectionTypes Replace
public SelectionTypes MouseDown
public SelectionTypes MouseUp
public SelectionTypes Click
public SelectionTypes Primary
public SelectionTypes Valid
public SelectionTypes Toggle
public SelectionTypes Add
public SelectionTypes Remove
}
public System.ComponentModel.Design.Serialization.ComponentSerializationService : object {
public SerializationStore CreateStore()
public ICollection Deserialize(SerializationStore store)
public ICollection Deserialize(SerializationStore store, IContainer container)
public SerializationStore LoadStore(Stream stream)
public void Serialize(SerializationStore store, object value)
public void SerializeAbsolute(SerializationStore store, object value)
public void SerializeMember(SerializationStore store, object owningObject, MemberDescriptor member)
public void SerializeMemberAbsolute(SerializationStore store, object owningObject, MemberDescriptor member)
public void DeserializeTo(SerializationStore store, IContainer container)
public void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes)
public void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes, bool applyDefaults)
}
public System.ComponentModel.Design.Serialization.ContextStack : object {
private ArrayList _contextList
public object Current
public object Item
public object Item
public object get_Current()
public object get_Item(Type type)
public object get_Item(int level)
public object Pop()
public void Push(object context)
public void Append(object context)
}
public System.ComponentModel.Design.Serialization.DefaultSerializationProviderAttribute : Attribute {
private string _providerTypeName
public string ProviderTypeName
public void .ctor(string providerTypeName)
public void .ctor(Type providerType)
public string get_ProviderTypeName()
}
public System.ComponentModel.Design.Serialization.DesignerLoader : object {
public bool Loading
public bool get_Loading()
public void BeginLoad(IDesignerLoaderHost host)
public void Dispose()
public void Flush()
}
public System.ComponentModel.Design.Serialization.DesignerSerializerAttribute : Attribute {
private string serializerTypeName
private string baseSerializerTypeName
public string SerializerBaseTypeName
public string SerializerTypeName
public object TypeId
public void .ctor(string serializerTypeName, string baseSerializerTypeName)
public void .ctor(string serializerTypeName, Type baseSerializerType)
public void .ctor(Type serializerType, Type baseSerializerType)
public string get_SerializerBaseTypeName()
public string get_SerializerTypeName()
public object get_TypeId()
}
public System.ComponentModel.Design.Serialization.IDesignerLoaderHost {
public void EndLoad(string baseClassName, bool successful, ICollection errorCollection)
public void Reload()
}
public System.ComponentModel.Design.Serialization.IDesignerLoaderService {
public void AddLoadDependency()
public void DependentLoadComplete(bool successful, ICollection errorCollection)
public bool Reload()
}
public System.ComponentModel.Design.Serialization.IDesignerSerializationManager {
public ContextStack Context
public PropertyDescriptorCollection Properties
public void add_ResolveName(ResolveNameEventHandler value)
public void remove_ResolveName(ResolveNameEventHandler value)
public void add_SerializationComplete(EventHandler value)
public void remove_SerializationComplete(EventHandler value)
public ContextStack get_Context()
public PropertyDescriptorCollection get_Properties()
public void AddSerializationProvider(IDesignerSerializationProvider provider)
public object CreateInstance(Type type, ICollection arguments, string name, bool addToContainer)
public object GetInstance(string name)
public string GetName(object value)
public object GetSerializer(Type objectType, Type serializerType)
public Type GetType(string typeName)
public void RemoveSerializationProvider(IDesignerSerializationProvider provider)
public void ReportError(object errorInformation)
public void SetName(object instance, string name)
}
public System.ComponentModel.Design.Serialization.IDesignerSerializationProvider {
public object GetSerializer(IDesignerSerializationManager manager, object currentSerializer, Type objectType, Type serializerType)
}
public System.ComponentModel.Design.Serialization.IDesignerSerializationService {
public ICollection Deserialize(object serializationData)
public object Serialize(ICollection objects)
}
public System.ComponentModel.Design.Serialization.INameCreationService {
public string CreateName(IContainer container, Type dataType)
public bool IsValidName(string name)
public void ValidateName(string name)
}
public System.ComponentModel.Design.Serialization.InstanceDescriptor : object {
private MemberInfo member
private ICollection arguments
private bool isComplete
public ICollection Arguments
public bool IsComplete
public MemberInfo MemberInfo
public void .ctor(MemberInfo member, ICollection arguments)
public void .ctor(MemberInfo member, ICollection arguments, bool isComplete)
private void ValidateMember(MemberInfo member, ICollection arguments)
public ICollection get_Arguments()
public bool get_IsComplete()
public MemberInfo get_MemberInfo()
public object Invoke()
}
public System.ComponentModel.Design.Serialization.MemberRelationship : ValueType {
public MemberRelationship Empty
private object _owner
private MemberDescriptor _member
public bool IsEmpty
public object Owner
public MemberDescriptor Member
public void .ctor(object owner, MemberDescriptor member)
public bool get_IsEmpty()
public object get_Owner()
public MemberDescriptor get_Member()
public int GetHashCode()
public bool Equals(object o)
public bool op_Equality(MemberRelationship left, MemberRelationship right)
public bool op_Inequality(MemberRelationship left, MemberRelationship right)
}
public System.ComponentModel.Design.Serialization.MemberRelationshipService : object {
private Hashtable _relations
public MemberRelationship Item
public MemberRelationship Item
public bool SupportsRelationship(MemberRelationship source, MemberRelationship relationship)
protected MemberRelationship GetRelationship(MemberRelationship source)
protected void SetRelationship(MemberRelationship source, MemberRelationship relationship)
public MemberRelationship get_Item(object owner, MemberDescriptor member)
public void set_Item(object owner, MemberDescriptor member, MemberRelationship value)
public MemberRelationship get_Item(MemberRelationship source)
public void set_Item(MemberRelationship source, MemberRelationship value)
}
public System.ComponentModel.Design.Serialization.ResolveNameEventArgs : EventArgs {
private string name
private object value
public string Name
public object Value
public void .ctor(string name)
public string get_Name()
public object get_Value()
public void set_Value(object value)
}
public System.ComponentModel.Design.Serialization.ResolveNameEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ResolveNameEventArgs e)
public IAsyncResult BeginInvoke(object sender, ResolveNameEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.Serialization.RootDesignerSerializerAttribute : Attribute {
private string serializer
private string baseserializer
private bool reload
public bool Reloadable
public string SerializerBaseTypeName
public string SerializerTypeName
public object TypeId
public void .ctor(string serializerTypeName, string baseSerializerTypeName, bool reloadable)
public void .ctor(string serializerTypeName, Type baseSerializerType, bool reloadable)
public void .ctor(Type serializerType, Type baseSerializerType, bool reloadable)
public bool get_Reloadable()
public string get_SerializerBaseTypeName()
public string get_SerializerTypeName()
public object get_TypeId()
}
public System.ComponentModel.Design.Serialization.SerializationStore : object {
public ICollection Errors
private void System.IDisposable.Dispose()
public ICollection get_Errors()
public void Close()
public void Save(Stream stream)
protected void Dispose(bool disposing)
}
public System.ComponentModel.Design.ServiceContainer : object {
private IServiceProvider parentProvider
private Hashtable services
private bool _disposed
private Hashtable Services
protected Type[] DefaultServices
public void .ctor(IServiceProvider parentProvider)
private Hashtable get_Services()
public void AddService(Type serviceType, object serviceInstance)
public void AddService(Type serviceType, ServiceCreatorCallback callback)
public void AddService(Type serviceType, object serviceInstance, bool promote)
public void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote)
public void RemoveService(Type serviceType)
public void RemoveService(Type serviceType, bool promote)
public object GetService(Type serviceType)
protected Type[] get_DefaultServices()
public void Dispose()
protected void Dispose(bool disposing)
}
public System.ComponentModel.Design.ServiceCreatorCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(IServiceContainer container, Type serviceType)
public IAsyncResult BeginInvoke(IServiceContainer container, Type serviceType, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
public System.ComponentModel.Design.StandardCommands : object {
public CommandID AlignBottom
public CommandID AlignHorizontalCenters
public CommandID AlignLeft
public CommandID AlignRight
public CommandID AlignToGrid
public CommandID AlignTop
public CommandID AlignVerticalCenters
public CommandID ArrangeBottom
public CommandID ArrangeIcons
public CommandID ArrangeRight
public CommandID BringForward
public CommandID BringToFront
public CommandID CenterHorizontally
public CommandID CenterVertically
public CommandID Copy
public CommandID Cut
public CommandID Delete
public CommandID F1Help
public CommandID Group
public CommandID HorizSpaceConcatenate
public CommandID HorizSpaceDecrease
public CommandID HorizSpaceIncrease
public CommandID HorizSpaceMakeEqual
public CommandID LineupIcons
public CommandID LockControls
public CommandID MultiLevelRedo
public CommandID MultiLevelUndo
public CommandID Paste
public CommandID Properties
public CommandID PropertiesWindow
public CommandID Redo
public CommandID Replace
public CommandID SelectAll
public CommandID SendBackward
public CommandID SendToBack
public CommandID ShowGrid
public CommandID ShowLargeIcons
public CommandID SizeToControl
public CommandID SizeToControlHeight
public CommandID SizeToControlWidth
public CommandID SizeToFit
public CommandID SizeToGrid
public CommandID SnapToGrid
public CommandID TabOrder
public CommandID Undo
public CommandID Ungroup
public CommandID VerbFirst
public CommandID VerbLast
public CommandID VertSpaceConcatenate
public CommandID VertSpaceDecrease
public CommandID VertSpaceIncrease
public CommandID VertSpaceMakeEqual
public CommandID ViewGrid
public CommandID DocumentOutline
public CommandID ViewCode
}
public System.ComponentModel.Design.StandardToolWindows : object {
public Guid ObjectBrowser
public Guid OutputWindow
public Guid ProjectExplorer
public Guid PropertyBrowser
public Guid RelatedLinks
public Guid ServerExplorer
public Guid TaskList
public Guid Toolbox
}
public System.ComponentModel.Design.ViewTechnology : Enum {
public int value__
public ViewTechnology Passthrough
public ViewTechnology WindowsForms
public ViewTechnology Default
}
public System.ComponentModel.DesignerAttribute : Attribute {
private string name
private string basetypename
public string DesignerBaseTypeName
public string DesignerTypeName
public object TypeId
public void .ctor(string designerTypeName)
public void .ctor(Type designerType)
public void .ctor(string designerTypeName, Type designerBaseType)
public void .ctor(Type designerType, Type designerBaseType)
public void .ctor(string designerTypeName, string designerBaseTypeName)
public string get_DesignerBaseTypeName()
public string get_DesignerTypeName()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.DesignerCategoryAttribute : Attribute {
private string category
public DesignerCategoryAttribute Component
public DesignerCategoryAttribute Form
public DesignerCategoryAttribute Generic
public DesignerCategoryAttribute Default
public object TypeId
public string Category
public void .ctor(string category)
public object get_TypeId()
public string get_Category()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DesignerSerializationVisibility : Enum {
public int value__
public DesignerSerializationVisibility Hidden
public DesignerSerializationVisibility Visible
public DesignerSerializationVisibility Content
}
public System.ComponentModel.DesignerSerializationVisibilityAttribute : Attribute {
private DesignerSerializationVisibility visibility
public DesignerSerializationVisibilityAttribute Default
public DesignerSerializationVisibilityAttribute Content
public DesignerSerializationVisibilityAttribute Hidden
public DesignerSerializationVisibilityAttribute Visible
public DesignerSerializationVisibility Visibility
public void .ctor(DesignerSerializationVisibility vis)
public DesignerSerializationVisibility get_Visibility()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DesignOnlyAttribute : Attribute {
private bool design_only
public DesignOnlyAttribute Default
public DesignOnlyAttribute No
public DesignOnlyAttribute Yes
public bool IsDesignOnly
public void .ctor(bool design_only)
public bool get_IsDesignOnly()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DesignTimeVisibleAttribute : Attribute {
private bool visible
public DesignTimeVisibleAttribute Default
public DesignTimeVisibleAttribute No
public DesignTimeVisibleAttribute Yes
public bool Visible
public void .ctor(bool visible)
public bool get_Visible()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.DisplayNameAttribute : Attribute {
public DisplayNameAttribute Default
private string attributeDisplayName
public string DisplayName
protected string DisplayNameValue
public void .ctor(string displayName)
public bool IsDefaultAttribute()
public int GetHashCode()
public bool Equals(object obj)
public string get_DisplayName()
protected string get_DisplayNameValue()
protected void set_DisplayNameValue(string value)
}
public System.ComponentModel.DoubleConverter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
}
public System.ComponentModel.DoWorkEventArgs : CancelEventArgs {
private object arg
private object result
public object Argument
public object Result
public void .ctor(object argument)
public object get_Argument()
public object get_Result()
public void set_Result(object value)
}
public System.ComponentModel.DoWorkEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DoWorkEventArgs e)
public IAsyncResult BeginInvoke(object sender, DoWorkEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.EditorAttribute : Attribute {
private string name
private string basename
public string EditorBaseTypeName
public string EditorTypeName
public object TypeId
public void .ctor(string typeName, string baseTypeName)
public void .ctor(string typeName, Type baseType)
public void .ctor(Type type, Type baseType)
public string get_EditorBaseTypeName()
public string get_EditorTypeName()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.EditorBrowsableAttribute : Attribute {
private EditorBrowsableState state
public EditorBrowsableState State
public void .ctor(EditorBrowsableState state)
public EditorBrowsableState get_State()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.EditorBrowsableState : Enum {
public int value__
public EditorBrowsableState Always
public EditorBrowsableState Never
public EditorBrowsableState Advanced
}
public System.ComponentModel.EnumConverter : TypeConverter {
private Type type
private StandardValuesCollection stdValues
protected IComparer Comparer
protected Type EnumType
protected StandardValuesCollection Values
private bool IsFlags
public void .ctor(Type type)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public bool IsValid(ITypeDescriptorContext context, object value)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
protected IComparer get_Comparer()
protected Type get_EnumType()
protected StandardValuesCollection get_Values()
protected void set_Values(StandardValuesCollection value)
private ArgumentException CreateValueNotValidException(object value)
private bool get_IsFlags()
}
public System.ComponentModel.EventDescriptor : MemberDescriptor {
public Type ComponentType
public Type EventType
public bool IsMulticast
protected void .ctor(MemberDescriptor desc)
protected void .ctor(MemberDescriptor desc, Attribute[] attrs)
protected void .ctor(string str, Attribute[] attrs)
public void AddEventHandler(object component, Delegate value)
public void RemoveEventHandler(object component, Delegate value)
public Type get_ComponentType()
public Type get_EventType()
public bool get_IsMulticast()
}
public System.ComponentModel.EventDescriptorCollection : object {
private ArrayList eventList
private bool isReadOnly
public EventDescriptorCollection Empty
private int System.Collections.ICollection.Count
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public int Count
public EventDescriptor Item
public EventDescriptor Item
internal void .ctor(ArrayList list)
public void .ctor(EventDescriptor[] events)
public void .ctor(EventDescriptor[] events, bool readOnly)
private void System.Collections.IList.Clear()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.IList.RemoveAt(int index)
private int System.Collections.ICollection.get_Count()
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
public int Add(EventDescriptor value)
public void Clear()
public bool Contains(EventDescriptor value)
public EventDescriptor Find(string name, bool ignoreCase)
public IEnumerator GetEnumerator()
public int IndexOf(EventDescriptor value)
public void Insert(int index, EventDescriptor value)
public void Remove(EventDescriptor value)
public void RemoveAt(int index)
public EventDescriptorCollection Sort()
public EventDescriptorCollection Sort(IComparer comparer)
public EventDescriptorCollection Sort(String[] order)
public EventDescriptorCollection Sort(String[] order, IComparer comparer)
protected void InternalSort(IComparer comparer)
protected void InternalSort(String[] order)
private ArrayList ExtractItems(String[] names)
private EventDescriptorCollection CloneCollection()
internal EventDescriptorCollection Filter(Attribute[] attributes)
public int get_Count()
public EventDescriptor get_Item(string name)
public EventDescriptor get_Item(int index)
}
public System.ComponentModel.EventHandlerList : object {
private ListEntry entries
private Delegate null_entry
public Delegate Item
public Delegate get_Item(object key)
public void set_Item(object key, Delegate value)
public void AddHandler(object key, Delegate value)
public void AddHandlers(EventHandlerList listToAddFrom)
public void RemoveHandler(object key, Delegate value)
public void Dispose()
private ListEntry FindEntry(object key)
}
public System.ComponentModel.ExpandableObjectConverter : TypeConverter {
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.ExtenderProvidedPropertyAttribute : Attribute {
private PropertyDescriptor extender
private IExtenderProvider extenderProvider
private Type receiver
public PropertyDescriptor ExtenderProperty
public IExtenderProvider Provider
public Type ReceiverType
internal ExtenderProvidedPropertyAttribute CreateAttribute(PropertyDescriptor extenderProperty, IExtenderProvider provider, Type receiverType)
public PropertyDescriptor get_ExtenderProperty()
public IExtenderProvider get_Provider()
public Type get_ReceiverType()
public bool IsDefaultAttribute()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.GuidConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.HandledEventArgs : EventArgs {
private bool handled
public bool Handled
public void .ctor(bool defaultHandledValue)
public bool get_Handled()
public void set_Handled(bool value)
}
public System.ComponentModel.HandledEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, HandledEventArgs e)
public IAsyncResult BeginInvoke(object sender, HandledEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.IBindingList {
public bool AllowEdit
public bool AllowNew
public bool AllowRemove
public bool IsSorted
public ListSortDirection SortDirection
public PropertyDescriptor SortProperty
public bool SupportsChangeNotification
public bool SupportsSearching
public bool SupportsSorting
public void add_ListChanged(ListChangedEventHandler value)
public void remove_ListChanged(ListChangedEventHandler value)
public void AddIndex(PropertyDescriptor property)
public object AddNew()
public void ApplySort(PropertyDescriptor property, ListSortDirection direction)
public int Find(PropertyDescriptor property, object key)
public void RemoveIndex(PropertyDescriptor property)
public void RemoveSort()
public bool get_AllowEdit()
public bool get_AllowNew()
public bool get_AllowRemove()
public bool get_IsSorted()
public ListSortDirection get_SortDirection()
public PropertyDescriptor get_SortProperty()
public bool get_SupportsChangeNotification()
public bool get_SupportsSearching()
public bool get_SupportsSorting()
}
public System.ComponentModel.IBindingListView {
public string Filter
public ListSortDescriptionCollection SortDescriptions
public bool SupportsAdvancedSorting
public bool SupportsFiltering
public string get_Filter()
public void set_Filter(string value)
public ListSortDescriptionCollection get_SortDescriptions()
public bool get_SupportsAdvancedSorting()
public bool get_SupportsFiltering()
public void ApplySort(ListSortDescriptionCollection sorts)
public void RemoveFilter()
}
public System.ComponentModel.ICancelAddNew {
public void CancelNew(int itemIndex)
public void EndNew(int itemIndex)
}
public System.ComponentModel.IChangeTracking {
public bool IsChanged
public bool get_IsChanged()
public void AcceptChanges()
}
public System.ComponentModel.IComNativeDescriptorHandler {
public AttributeCollection GetAttributes(object component)
public string GetClassName(object component)
public TypeConverter GetConverter(object component)
public EventDescriptor GetDefaultEvent(object component)
public PropertyDescriptor GetDefaultProperty(object component)
public object GetEditor(object component, Type baseEditorType)
public EventDescriptorCollection GetEvents(object component)
public EventDescriptorCollection GetEvents(object component, Attribute[] attributes)
public string GetName(object component)
public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes)
public object GetPropertyValue(object component, int dispid, Boolean& success)
public object GetPropertyValue(object component, string propertyName, Boolean& success)
}
public System.ComponentModel.IComponent {
public ISite Site
public void add_Disposed(EventHandler value)
public void remove_Disposed(EventHandler value)
public ISite get_Site()
public void set_Site(ISite value)
}
public System.ComponentModel.IContainer {
public ComponentCollection Components
public ComponentCollection get_Components()
public void Add(IComponent component)
public void Add(IComponent component, string name)
public void Remove(IComponent component)
}
public System.ComponentModel.ICustomTypeDescriptor {
public AttributeCollection GetAttributes()
public string GetClassName()
public string GetComponentName()
public TypeConverter GetConverter()
public EventDescriptor GetDefaultEvent()
public PropertyDescriptor GetDefaultProperty()
public object GetEditor(Type editorBaseType)
public EventDescriptorCollection GetEvents()
public EventDescriptorCollection GetEvents(Attribute[] arr)
public PropertyDescriptorCollection GetProperties()
public PropertyDescriptorCollection GetProperties(Attribute[] arr)
public object GetPropertyOwner(PropertyDescriptor pd)
}
public System.ComponentModel.IDataErrorInfo {
public string Error
public string Item
public string get_Error()
public string get_Item(string columnName)
}
public System.ComponentModel.IEditableObject {
public void BeginEdit()
public void CancelEdit()
public void EndEdit()
}
public System.ComponentModel.IExtenderProvider {
public bool CanExtend(object extendee)
}
public System.ComponentModel.IIntellisenseBuilder {
public string Name
public string get_Name()
public bool Show(string language, string value, String& newValue)
}
public System.ComponentModel.IListSource {
public bool ContainsListCollection
public IList GetList()
public bool get_ContainsListCollection()
}
public System.ComponentModel.ImmutableObjectAttribute : Attribute {
private bool immutable
public ImmutableObjectAttribute Default
public ImmutableObjectAttribute No
public ImmutableObjectAttribute Yes
public bool Immutable
public void .ctor(bool immutable)
public bool get_Immutable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.INestedContainer {
public IComponent Owner
public IComponent get_Owner()
}
public System.ComponentModel.INestedSite {
public string FullName
public string get_FullName()
}
internal System.ComponentModel.Info : object {
private Type _infoType
private EventDescriptor _defaultEvent
private bool _gotDefaultEvent
private PropertyDescriptor _defaultProperty
private bool _gotDefaultProperty
private AttributeCollection _attributes
public Type InfoType
public void .ctor(Type infoType)
public AttributeCollection GetAttributes()
public EventDescriptorCollection GetEvents()
public PropertyDescriptorCollection GetProperties()
public Type get_InfoType()
public EventDescriptorCollection GetEvents(Attribute[] attributes)
public PropertyDescriptorCollection GetProperties(Attribute[] attributes)
public EventDescriptor GetDefaultEvent()
public PropertyDescriptor GetDefaultProperty()
protected AttributeCollection GetAttributes(IComponent comp)
}
public System.ComponentModel.InheritanceAttribute : Attribute {
private InheritanceLevel level
public InheritanceAttribute Default
public InheritanceAttribute Inherited
public InheritanceAttribute InheritedReadOnly
public InheritanceAttribute NotInherited
public InheritanceLevel InheritanceLevel
public void .ctor(InheritanceLevel inheritanceLevel)
public InheritanceLevel get_InheritanceLevel()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
public string ToString()
}
public System.ComponentModel.InheritanceLevel : Enum {
public int value__
public InheritanceLevel Inherited
public InheritanceLevel InheritedReadOnly
public InheritanceLevel NotInherited
}
public System.ComponentModel.InitializationEventAttribute : Attribute {
private string eventName
public string EventName
public void .ctor(string eventName)
public string get_EventName()
}
public System.ComponentModel.INotifyPropertyChanged {
public void add_PropertyChanged(PropertyChangedEventHandler value)
public void remove_PropertyChanged(PropertyChangedEventHandler value)
}
public System.ComponentModel.INotifyPropertyChanging {
public void add_PropertyChanging(PropertyChangingEventHandler value)
public void remove_PropertyChanging(PropertyChangingEventHandler value)
}
public System.ComponentModel.InstallerTypeAttribute : Attribute {
private Type installer
public Type InstallerType
public void .ctor(string typeName)
public void .ctor(Type installerType)
public Type get_InstallerType()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.InstanceCreationEditor : object {
public string Text
public string get_Text()
public object CreateInstance(ITypeDescriptorContext context, Type type)
}
public System.ComponentModel.Int16Converter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
internal object ConvertFromString(string value, int fromBase)
}
public System.ComponentModel.Int32Converter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
internal object ConvertFromString(string value, int fromBase)
}
public System.ComponentModel.Int64Converter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
internal object ConvertFromString(string value, int fromBase)
}
public System.ComponentModel.InvalidAsynchronousStateException : ArgumentException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.InvalidEnumArgumentException : ArgumentException {
public void .ctor(string message)
public void .ctor(string argumentName, int invalidValue, Type enumClass)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.IRaiseItemChangedEvents {
public bool RaisesItemChangedEvents
public bool get_RaisesItemChangedEvents()
}
public System.ComponentModel.IRevertibleChangeTracking {
public void RejectChanges()
}
public System.ComponentModel.ISite {
public IComponent Component
public IContainer Container
public bool DesignMode
public string Name
public IComponent get_Component()
public IContainer get_Container()
public bool get_DesignMode()
public string get_Name()
public void set_Name(string value)
}
public System.ComponentModel.ISupportInitialize {
public void BeginInit()
public void EndInit()
}
public System.ComponentModel.ISupportInitializeNotification {
public bool IsInitialized
public void add_Initialized(EventHandler value)
public void remove_Initialized(EventHandler value)
public bool get_IsInitialized()
}
public System.ComponentModel.ISynchronizeInvoke {
public bool InvokeRequired
public bool get_InvokeRequired()
public IAsyncResult BeginInvoke(Delegate method, Object[] args)
public object EndInvoke(IAsyncResult result)
public object Invoke(Delegate method, Object[] args)
}
public System.ComponentModel.ITypeDescriptorContext {
public IContainer Container
public object Instance
public PropertyDescriptor PropertyDescriptor
public IContainer get_Container()
public object get_Instance()
public PropertyDescriptor get_PropertyDescriptor()
public void OnComponentChanged()
public bool OnComponentChanging()
}
public System.ComponentModel.ITypedList {
public PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors)
public string GetListName(PropertyDescriptor[] listAccessors)
}
public System.ComponentModel.License : object {
public string LicenseKey
public string get_LicenseKey()
public void Dispose()
}
public System.ComponentModel.LicenseContext : object {
public LicenseUsageMode UsageMode
public string GetSavedLicenseKey(Type type, Assembly resourceAssembly)
public object GetService(Type type)
public void SetSavedLicenseKey(Type type, string key)
public LicenseUsageMode get_UsageMode()
}
public System.ComponentModel.LicenseException : SystemException {
private Type type
public Type LicensedType
public void .ctor(Type type)
public void .ctor(Type type, object instance)
public void .ctor(Type type, object instance, string message)
public void .ctor(Type type, object instance, string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Type get_LicensedType()
}
public System.ComponentModel.LicenseManager : object {
private LicenseContext mycontext
private object contextLockUser
private object lockObject
public LicenseContext CurrentContext
public LicenseUsageMode UsageMode
public LicenseContext get_CurrentContext()
public void set_CurrentContext(LicenseContext value)
public LicenseUsageMode get_UsageMode()
public object CreateWithContext(Type type, LicenseContext creationContext)
public object CreateWithContext(Type type, LicenseContext creationContext, Object[] args)
public bool IsLicensed(Type type)
public bool IsValid(Type type)
public bool IsValid(Type type, object instance, License& license)
public void LockContext(object contextUser)
public void UnlockContext(object contextUser)
public void Validate(Type type)
public License Validate(Type type, object instance)
private bool privateGetLicense(Type type, object instance, bool allowExceptions, License& license)
}
public System.ComponentModel.LicenseProvider : object {
public License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions)
}
public System.ComponentModel.LicenseProviderAttribute : Attribute {
private Type Provider
public LicenseProviderAttribute Default
public Type LicenseProvider
public object TypeId
public void .ctor(string typeName)
public void .ctor(Type type)
public Type get_LicenseProvider()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.LicenseUsageMode : Enum {
public int value__
public LicenseUsageMode Designtime
public LicenseUsageMode Runtime
}
internal System.ComponentModel.LicFileLicense : License {
private string _key
public string LicenseKey
public void .ctor(string key)
public string get_LicenseKey()
public void Dispose()
}
public System.ComponentModel.LicFileLicenseProvider : LicenseProvider {
public License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions)
protected string GetKey(Type type)
protected bool IsKeyValid(string key, Type type)
}
public System.ComponentModel.ListBindableAttribute : Attribute {
public ListBindableAttribute Default
public ListBindableAttribute No
public ListBindableAttribute Yes
private bool bindable
public bool ListBindable
public void .ctor(bool listBindable)
public void .ctor(BindableSupport flags)
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
public bool get_ListBindable()
}
public System.ComponentModel.ListChangedEventArgs : EventArgs {
private ListChangedType changedType
private int oldIndex
private int newIndex
private PropertyDescriptor propDesc
public ListChangedType ListChangedType
public int OldIndex
public int NewIndex
public PropertyDescriptor PropertyDescriptor
public void .ctor(ListChangedType listChangedType, int newIndex)
public void .ctor(ListChangedType listChangedType, PropertyDescriptor propDesc)
public void .ctor(ListChangedType listChangedType, int newIndex, int oldIndex)
public void .ctor(ListChangedType listChangedType, int newIndex, PropertyDescriptor propDesc)
public ListChangedType get_ListChangedType()
public int get_OldIndex()
public int get_NewIndex()
public PropertyDescriptor get_PropertyDescriptor()
}
public System.ComponentModel.ListChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ListChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ListChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.ListChangedType : Enum {
public int value__
public ListChangedType Reset
public ListChangedType ItemAdded
public ListChangedType ItemDeleted
public ListChangedType ItemMoved
public ListChangedType ItemChanged
public ListChangedType PropertyDescriptorAdded
public ListChangedType PropertyDescriptorDeleted
public ListChangedType PropertyDescriptorChanged
}
internal System.ComponentModel.ListEntry : object {
public object key
public Delegate value
public ListEntry next
}
public System.ComponentModel.ListSortDescription : object {
private PropertyDescriptor propertyDescriptor
private ListSortDirection sortDirection
public PropertyDescriptor PropertyDescriptor
public ListSortDirection SortDirection
public void .ctor(PropertyDescriptor propertyDescriptor, ListSortDirection sortDirection)
public PropertyDescriptor get_PropertyDescriptor()
public void set_PropertyDescriptor(PropertyDescriptor value)
public ListSortDirection get_SortDirection()
public void set_SortDirection(ListSortDirection value)
}
public System.ComponentModel.ListSortDescriptionCollection : object {
private ArrayList list
private object System.Collections.IList.Item
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IList.IsReadOnly
public int Count
public ListSortDescription Item
public void .ctor(ListSortDescription[] sorts)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.IList.get_IsReadOnly()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
public int get_Count()
public ListSortDescription get_Item(int index)
public void set_Item(int index, ListSortDescription value)
public bool Contains(object value)
public void CopyTo(Array array, int index)
public int IndexOf(object value)
}
public System.ComponentModel.ListSortDirection : Enum {
public int value__
public ListSortDirection Ascending
public ListSortDirection Descending
}
public System.ComponentModel.LocalizableAttribute : Attribute {
private bool localizable
public LocalizableAttribute Default
public LocalizableAttribute No
public LocalizableAttribute Yes
public bool IsLocalizable
public void .ctor(bool localizable)
public bool get_IsLocalizable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.LookupBindingPropertiesAttribute : Attribute {
private string data_source
private string display_member
private string value_member
private string lookup_member
public LookupBindingPropertiesAttribute Default
public string DataSource
public string DisplayMember
public string LookupMember
public string ValueMember
public void .ctor(string dataSource, string displayMember, string valueMember, string lookupMember)
public int GetHashCode()
public bool Equals(object obj)
public string get_DataSource()
public string get_DisplayMember()
public string get_LookupMember()
public string get_ValueMember()
}
public System.ComponentModel.MarshalByValueComponent : object {
private EventHandlerList eventList
private ISite mySite
private object disposedEvent
public IContainer Container
public bool DesignMode
public ISite Site
protected EventHandlerList Events
public void add_Disposed(EventHandler value)
public void remove_Disposed(EventHandler value)
public void Dispose()
protected void Dispose(bool disposing)
protected void Finalize()
public object GetService(Type service)
public IContainer get_Container()
public bool get_DesignMode()
public ISite get_Site()
public void set_Site(ISite value)
public string ToString()
protected EventHandlerList get_Events()
}
public System.ComponentModel.MaskedTextProvider : object {
private bool allow_prompt_as_input
private bool ascii_only
private CultureInfo culture
private bool include_literals
private bool include_prompt
private bool is_password
private string mask
private char password_char
private char prompt_char
private bool reset_on_prompt
private bool reset_on_space
private bool skip_literals
private EditPosition[] edit_positions
private char default_prompt_char
private char default_password_char
public bool AllowPromptAsInput
public bool AsciiOnly
public int AssignedEditPositionCount
public int AvailableEditPositionCount
public CultureInfo Culture
public char DefaultPasswordChar
public int EditPositionCount
public IEnumerator EditPositions
public bool IncludeLiterals
public bool IncludePrompt
public int InvalidIndex
public bool IsPassword
public char Item
public int LastAssignedPosition
public int Length
public string Mask
public bool MaskCompleted
public bool MaskFull
public char PasswordChar
public char PromptChar
public bool ResetOnPrompt
public bool ResetOnSpace
public bool SkipLiterals
public void .ctor(string mask)
public void .ctor(string mask, bool restrictToAscii)
public void .ctor(string mask, CultureInfo culture)
public void .ctor(string mask, char passwordChar, bool allowPromptAsInput)
public void .ctor(string mask, CultureInfo culture, bool restrictToAscii)
public void .ctor(string mask, CultureInfo culture, char passwordChar, bool allowPromptAsInput)
public void .ctor(string mask, CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii)
private void SetMask(string mask)
private EditPosition[] ClonePositions()
private bool AddInternal(string str_input, Int32& testPosition, MaskedTextResultHint& resultHint, bool only_test)
private bool AddInternal(char input, Int32& testPosition, MaskedTextResultHint& resultHint, bool check_available_positions_first, bool check_escape_char_first)
private bool VerifyStringInternal(string input, Int32& testPosition, MaskedTextResultHint& resultHint, int startIndex, bool only_test)
private bool VerifyCharInternal(char input, int position, MaskedTextResultHint& hint, bool only_test)
private bool IsInsertableString(string str_input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
private bool ShiftPositionsRight(EditPosition[] edit_positions, int start, Int32& testPosition, MaskedTextResultHint& resultHint)
private bool ReplaceInternal(string input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint, bool only_test, bool dont_remove_at_end)
private bool ReplaceInternal(EditPosition[] edit_positions, char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint, bool only_test)
private bool RemoveAtInternal(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint, bool only_testing)
private bool InsertAtInternal(string str_input, int position, Int32& testPosition, MaskedTextResultHint& resultHint, bool only_testing)
public bool Add(char input)
public bool Add(string input)
public bool Add(char input, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Add(string input, Int32& testPosition, MaskedTextResultHint& resultHint)
public void Clear()
public void Clear(MaskedTextResultHint& resultHint)
public object Clone()
public int FindAssignedEditPositionFrom(int position, bool direction)
public int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction)
public int FindEditPositionFrom(int position, bool direction)
public int FindEditPositionInRange(int startPosition, int endPosition, bool direction)
public int FindNonEditPositionFrom(int position, bool direction)
public int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction)
public int FindUnassignedEditPositionFrom(int position, bool direction)
public int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction)
public bool GetOperationResultFromHint(MaskedTextResultHint hint)
public bool InsertAt(char input, int position)
public bool InsertAt(string input, int position)
public bool InsertAt(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool InsertAt(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool IsAvailablePosition(int position)
public bool IsEditPosition(int position)
public bool IsValidInputChar(char c)
public bool IsValidMaskChar(char c)
public bool IsValidPasswordChar(char c)
public bool Remove()
public bool Remove(Int32& testPosition, MaskedTextResultHint& resultHint)
public bool RemoveAt(int position)
public bool RemoveAt(int startPosition, int endPosition)
public bool RemoveAt(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(char input, int position)
public bool Replace(string input, int position)
public bool Replace(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(char input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Replace(string input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool Set(string input)
public bool Set(string input, Int32& testPosition, MaskedTextResultHint& resultHint)
public string ToDisplayString()
public string ToString()
public string ToString(bool ignorePasswordChar)
public string ToString(bool includePrompt, bool includeLiterals)
public string ToString(int startPosition, int length)
public string ToString(bool ignorePasswordChar, int startPosition, int length)
public string ToString(bool includePrompt, bool includeLiterals, int startPosition, int length)
public string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length)
public bool VerifyChar(char input, int position, MaskedTextResultHint& hint)
public bool VerifyEscapeChar(char input, int position)
public bool VerifyString(string input)
public bool VerifyString(string input, Int32& testPosition, MaskedTextResultHint& resultHint)
public bool get_AllowPromptAsInput()
public bool get_AsciiOnly()
public int get_AssignedEditPositionCount()
public int get_AvailableEditPositionCount()
public CultureInfo get_Culture()
public char get_DefaultPasswordChar()
public int get_EditPositionCount()
public IEnumerator get_EditPositions()
public bool get_IncludeLiterals()
public void set_IncludeLiterals(bool value)
public bool get_IncludePrompt()
public void set_IncludePrompt(bool value)
public int get_InvalidIndex()
public bool get_IsPassword()
public void set_IsPassword(bool value)
public char get_Item(int index)
public int get_LastAssignedPosition()
public int get_Length()
public string get_Mask()
public bool get_MaskCompleted()
public bool get_MaskFull()
public char get_PasswordChar()
public void set_PasswordChar(char value)
public char get_PromptChar()
public void set_PromptChar(char value)
public bool get_ResetOnPrompt()
public void set_ResetOnPrompt(bool value)
public bool get_ResetOnSpace()
public void set_ResetOnSpace(bool value)
public bool get_SkipLiterals()
public void set_SkipLiterals(bool value)
}
public System.ComponentModel.MaskedTextResultHint : Enum {
public int value__
public MaskedTextResultHint PositionOutOfRange
public MaskedTextResultHint NonEditPosition
public MaskedTextResultHint UnavailableEditPosition
public MaskedTextResultHint PromptCharNotAllowed
public MaskedTextResultHint InvalidInput
public MaskedTextResultHint SignedDigitExpected
public MaskedTextResultHint LetterExpected
public MaskedTextResultHint DigitExpected
public MaskedTextResultHint AlphanumericCharacterExpected
public MaskedTextResultHint AsciiCharacterExpected
public MaskedTextResultHint Unknown
public MaskedTextResultHint CharacterEscaped
public MaskedTextResultHint NoEffect
public MaskedTextResultHint SideEffect
public MaskedTextResultHint Success
}
public System.ComponentModel.MemberDescriptor : object {
private string name
private Attribute[] attrs
private AttributeCollection attrCollection
private IComparer default_comparer
protected Attribute[] AttributeArray
public AttributeCollection Attributes
public string Category
public string Description
public bool DesignTimeOnly
public string DisplayName
public string Name
public bool IsBrowsable
protected int NameHashCode
internal IComparer DefaultComparer
protected void .ctor(string name, Attribute[] attrs)
protected void .ctor(MemberDescriptor reference, Attribute[] attrs)
protected void .ctor(string name)
protected void .ctor(MemberDescriptor reference)
protected Attribute[] get_AttributeArray()
protected void set_AttributeArray(Attribute[] value)
protected void FillAttributes(IList attributeList)
public AttributeCollection get_Attributes()
protected AttributeCollection CreateAttributeCollection()
public string get_Category()
public string get_Description()
public bool get_DesignTimeOnly()
public string get_DisplayName()
public string get_Name()
public bool get_IsBrowsable()
protected int get_NameHashCode()
public int GetHashCode()
public bool Equals(object obj)
protected ISite GetSite(object component)
protected object GetInvokee(Type componentClass, object component)
protected object GetInvocationTarget(Type type, object instance)
protected MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType)
protected MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType, bool publicOnly)
internal IComparer get_DefaultComparer()
}
public System.ComponentModel.MergablePropertyAttribute : Attribute {
private bool mergable
public MergablePropertyAttribute Default
public MergablePropertyAttribute No
public MergablePropertyAttribute Yes
public bool AllowMerge
public void .ctor(bool allowMerge)
public bool get_AllowMerge()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.MultilineStringConverter : TypeConverter {
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.NestedContainer : Container {
private IComponent _owner
public IComponent Owner
protected string OwnerName
public void .ctor(IComponent owner)
public IComponent get_Owner()
protected string get_OwnerName()
protected ISite CreateSite(IComponent component, string name)
protected object GetService(Type service)
protected void Dispose(bool disposing)
private void OnOwnerDisposed(object sender, EventArgs e)
}
public System.ComponentModel.NotifyParentPropertyAttribute : Attribute {
private bool notifyParent
public NotifyParentPropertyAttribute Default
public NotifyParentPropertyAttribute No
public NotifyParentPropertyAttribute Yes
public bool NotifyParent
public void .ctor(bool notifyParent)
public bool get_NotifyParent()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.NullableConverter : TypeConverter {
private Type nullableType
private Type underlyingType
private TypeConverter underlyingTypeConverter
public Type NullableType
public Type UnderlyingType
public TypeConverter UnderlyingTypeConverter
public void .ctor(Type nullableType)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
public bool GetCreateInstanceSupported(ITypeDescriptorContext context)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported(ITypeDescriptorContext context)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public bool IsValid(ITypeDescriptorContext context, object value)
public Type get_NullableType()
public Type get_UnderlyingType()
public TypeConverter get_UnderlyingTypeConverter()
}
public System.ComponentModel.ParenthesizePropertyNameAttribute : Attribute {
private bool parenthesis
public ParenthesizePropertyNameAttribute Default
public bool NeedParenthesis
public void .ctor(bool needParenthesis)
public bool get_NeedParenthesis()
public bool Equals(object o)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.PasswordPropertyTextAttribute : Attribute {
public PasswordPropertyTextAttribute Default
public PasswordPropertyTextAttribute No
public PasswordPropertyTextAttribute Yes
private bool _password
public bool Password
public void .ctor(bool password)
public bool get_Password()
public bool Equals(object o)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ProgressChangedEventArgs : EventArgs {
private int progress
private object state
public int ProgressPercentage
public object UserState
public void .ctor(int progressPercentage, object userState)
public int get_ProgressPercentage()
public object get_UserState()
}
public System.ComponentModel.ProgressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ProgressChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ProgressChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyChangedEventArgs : EventArgs {
private string propertyName
public string PropertyName
public void .ctor(string name)
public string get_PropertyName()
}
public System.ComponentModel.PropertyChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PropertyChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyChangingEventArgs : EventArgs {
private string name
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
}
public System.ComponentModel.PropertyChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PropertyChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, PropertyChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.PropertyDescriptor : MemberDescriptor {
private TypeConverter converter
private Hashtable notifiers
public Type ComponentType
public TypeConverter Converter
public bool IsLocalizable
public bool IsReadOnly
public Type PropertyType
public bool SupportsChangeEvents
public DesignerSerializationVisibility SerializationVisibility
protected void .ctor(MemberDescriptor reference)
protected void .ctor(MemberDescriptor reference, Attribute[] attrs)
protected void .ctor(string name, Attribute[] attrs)
public Type get_ComponentType()
public TypeConverter get_Converter()
public bool get_IsLocalizable()
public bool get_IsReadOnly()
public Type get_PropertyType()
public bool get_SupportsChangeEvents()
public DesignerSerializationVisibility get_SerializationVisibility()
public void AddValueChanged(object component, EventHandler handler)
public void RemoveValueChanged(object component, EventHandler handler)
protected void FillAttributes(IList attributeList)
protected object GetInvocationTarget(Type type, object instance)
protected internal EventHandler GetValueChangedHandler(object component)
protected void OnValueChanged(object component, EventArgs e)
public object GetValue(object component)
public void SetValue(object component, object value)
public void ResetValue(object component)
public bool CanResetValue(object component)
public bool ShouldSerializeValue(object component)
protected object CreateInstance(Type type)
public bool Equals(object obj)
public PropertyDescriptorCollection GetChildProperties()
public PropertyDescriptorCollection GetChildProperties(object instance)
public PropertyDescriptorCollection GetChildProperties(Attribute[] filter)
public int GetHashCode()
public PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter)
public object GetEditor(Type editorBaseType)
protected Type GetTypeFromName(string typeName)
}
public System.ComponentModel.PropertyDescriptorCollection : object {
public PropertyDescriptorCollection Empty
private ArrayList properties
private bool readOnly
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private bool System.Collections.IList.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private int System.Collections.ICollection.Count
private object System.Collections.ICollection.SyncRoot
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private object System.Collections.IDictionary.Item
private object System.Collections.IList.Item
public int Count
public PropertyDescriptor Item
public PropertyDescriptor Item
public void .ctor(PropertyDescriptor[] properties)
public void .ctor(PropertyDescriptor[] properties, bool readOnly)
private int System.Collections.IList.Add(object value)
private void System.Collections.IDictionary.Add(object key, object value)
private void System.Collections.IList.Clear()
private void System.Collections.IDictionary.Clear()
private bool System.Collections.IList.Contains(object value)
private bool System.Collections.IDictionary.Contains(object value)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IDictionary.Remove(object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private bool System.Collections.IList.get_IsReadOnly()
private bool System.Collections.ICollection.get_IsSynchronized()
private int System.Collections.ICollection.get_Count()
private object System.Collections.ICollection.get_SyncRoot()
private ICollection System.Collections.IDictionary.get_Keys()
private ICollection System.Collections.IDictionary.get_Values()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public int Add(PropertyDescriptor value)
public void Clear()
public bool Contains(PropertyDescriptor value)
public void CopyTo(Array array, int index)
public PropertyDescriptor Find(string name, bool ignoreCase)
public IEnumerator GetEnumerator()
public int IndexOf(PropertyDescriptor value)
public void Insert(int index, PropertyDescriptor value)
public void Remove(PropertyDescriptor value)
public void RemoveAt(int index)
private PropertyDescriptorCollection CloneCollection()
public PropertyDescriptorCollection Sort()
public PropertyDescriptorCollection Sort(IComparer comparer)
public PropertyDescriptorCollection Sort(String[] order)
public PropertyDescriptorCollection Sort(String[] order, IComparer comparer)
protected void InternalSort(IComparer ic)
protected void InternalSort(String[] order)
private ArrayList ExtractItems(String[] names)
internal PropertyDescriptorCollection Filter(Attribute[] attributes)
public int get_Count()
public PropertyDescriptor get_Item(string s)
public PropertyDescriptor get_Item(int index)
}
public System.ComponentModel.PropertyTabAttribute : Attribute {
private Type[] tabs
private PropertyTabScope[] scopes
public Type[] TabClasses
public PropertyTabScope[] TabScopes
protected String[] TabClassNames
public void .ctor(string tabClassName)
public void .ctor(Type tabClass)
public void .ctor(string tabClassName, PropertyTabScope tabScope)
public void .ctor(Type tabClass, PropertyTabScope tabScope)
public Type[] get_TabClasses()
public PropertyTabScope[] get_TabScopes()
protected String[] get_TabClassNames()
public bool Equals(object other)
public bool Equals(PropertyTabAttribute other)
public int GetHashCode()
protected void InitializeArrays(String[] tabClassNames, PropertyTabScope[] tabScopes)
protected void InitializeArrays(Type[] tabClasses, PropertyTabScope[] tabScopes)
private Type GetTypeFromName(string typeName)
}
public System.ComponentModel.PropertyTabScope : Enum {
public int value__
public PropertyTabScope Static
public PropertyTabScope Global
public PropertyTabScope Document
public PropertyTabScope Component
}
public System.ComponentModel.ProvidePropertyAttribute : Attribute {
private string Property
private string Receiver
public string PropertyName
public string ReceiverTypeName
public object TypeId
public void .ctor(string propertyName, string receiverTypeName)
public void .ctor(string propertyName, Type receiverType)
public string get_PropertyName()
public string get_ReceiverTypeName()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
}
public System.ComponentModel.ReadOnlyAttribute : Attribute {
private bool read_only
public ReadOnlyAttribute No
public ReadOnlyAttribute Yes
public ReadOnlyAttribute Default
public bool IsReadOnly
public void .ctor(bool read_only)
public bool get_IsReadOnly()
public int GetHashCode()
public bool Equals(object o)
public bool IsDefaultAttribute()
}
public System.ComponentModel.RecommendedAsConfigurableAttribute : Attribute {
private bool recommendedAsConfigurable
public RecommendedAsConfigurableAttribute Default
public RecommendedAsConfigurableAttribute No
public RecommendedAsConfigurableAttribute Yes
public bool RecommendedAsConfigurable
public void .ctor(bool recommendedAsConfigurable)
public bool get_RecommendedAsConfigurable()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ReferenceConverter : TypeConverter {
private Type reference_type
public void .ctor(Type type)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
protected bool IsValueAllowed(ITypeDescriptorContext context, object value)
}
internal System.ComponentModel.ReflectionEventDescriptor : EventDescriptor {
private Type _eventType
private Type _componentType
private EventInfo _eventInfo
private MethodInfo add_method
private MethodInfo remove_method
public Type ComponentType
public Type EventType
public bool IsMulticast
public void .ctor(EventInfo eventInfo)
public void .ctor(Type componentType, EventDescriptor oldEventDescriptor, Attribute[] attrs)
public void .ctor(Type componentType, string name, Type type, Attribute[] attrs)
private EventInfo GetEventInfo()
public void AddEventHandler(object component, Delegate value)
public void RemoveEventHandler(object component, Delegate value)
public Type get_ComponentType()
public Type get_EventType()
public bool get_IsMulticast()
}
internal System.ComponentModel.ReflectionPropertyDescriptor : PropertyDescriptor {
private PropertyInfo _member
private Type _componentType
private Type _propertyType
private PropertyInfo getter
private PropertyInfo setter
private bool accessors_inited
public Type ComponentType
public bool IsReadOnly
public Type PropertyType
public void .ctor(Type componentType, PropertyDescriptor oldPropertyDescriptor, Attribute[] attributes)
public void .ctor(Type componentType, string name, Type type, Attribute[] attributes)
public void .ctor(PropertyInfo info)
private PropertyInfo GetPropertyInfo()
public Type get_ComponentType()
public bool get_IsReadOnly()
public Type get_PropertyType()
protected void FillAttributes(IList attributeList)
public object GetValue(object component)
private DesignerTransaction CreateTransaction(object obj, string description)
private void EndTransaction(object obj, DesignerTransaction tran, object oldValue, object newValue, bool commit)
private void InitAccessors()
public void SetValue(object component, object value)
private MethodInfo FindPropertyMethod(object o, string method_name)
public void ResetValue(object component)
public bool CanResetValue(object component)
public bool ShouldSerializeValue(object component)
}
public System.ComponentModel.RefreshEventArgs : EventArgs {
private object component
private Type type
public object ComponentChanged
public Type TypeChanged
public void .ctor(object componentChanged)
public void .ctor(Type typeChanged)
public object get_ComponentChanged()
public Type get_TypeChanged()
}
public System.ComponentModel.RefreshEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(RefreshEventArgs e)
public IAsyncResult BeginInvoke(RefreshEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.RefreshProperties : Enum {
public int value__
public RefreshProperties All
public RefreshProperties None
public RefreshProperties Repaint
}
public System.ComponentModel.RefreshPropertiesAttribute : Attribute {
private RefreshProperties refresh
public RefreshPropertiesAttribute All
public RefreshPropertiesAttribute Default
public RefreshPropertiesAttribute Repaint
public RefreshProperties RefreshProperties
public void .ctor(RefreshProperties refresh)
public RefreshProperties get_RefreshProperties()
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.RunInstallerAttribute : Attribute {
public RunInstallerAttribute Yes
public RunInstallerAttribute No
public RunInstallerAttribute Default
private bool runInstaller
public bool RunInstaller
public void .ctor(bool runInstaller)
public bool Equals(object obj)
public int GetHashCode()
public bool IsDefaultAttribute()
public bool get_RunInstaller()
}
public System.ComponentModel.RunWorkerCompletedEventArgs : AsyncCompletedEventArgs {
private object result
public object Result
public object UserState
public void .ctor(object result, Exception error, bool cancelled)
public object get_Result()
public object get_UserState()
}
public System.ComponentModel.RunWorkerCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, RunWorkerCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, RunWorkerCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ComponentModel.SByteConverter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
internal object ConvertFromString(string value, int fromBase)
}
public System.ComponentModel.SettingsBindableAttribute : Attribute {
public SettingsBindableAttribute Yes
public SettingsBindableAttribute No
private bool bindable
public bool Bindable
public void .ctor(bool bindable)
public bool get_Bindable()
public int GetHashCode()
public bool Equals(object obj)
}
public System.ComponentModel.SingleConverter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
}
public System.ComponentModel.StringConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
}
public System.ComponentModel.SyntaxCheck : object {
public bool CheckMachineName(string value)
public bool CheckPath(string value)
public bool CheckRootedPath(string value)
}
public System.ComponentModel.TimeSpanConverter : TypeConverter {
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
}
public System.ComponentModel.ToolboxItemAttribute : Attribute {
private string defaultItemType
public ToolboxItemAttribute Default
public ToolboxItemAttribute None
private Type itemType
private string itemTypeName
public Type ToolboxItemType
public string ToolboxItemTypeName
public void .ctor(bool defaultType)
public void .ctor(string toolboxItemName)
public void .ctor(Type toolboxItemType)
public Type get_ToolboxItemType()
public string get_ToolboxItemTypeName()
public bool Equals(object o)
public int GetHashCode()
public bool IsDefaultAttribute()
}
public System.ComponentModel.ToolboxItemFilterAttribute : Attribute {
private string Filter
private ToolboxItemFilterType ItemFilterType
public string FilterString
public ToolboxItemFilterType FilterType
public object TypeId
public void .ctor(string filterString)
public void .ctor(string filterString, ToolboxItemFilterType filterType)
public string get_FilterString()
public ToolboxItemFilterType get_FilterType()
public object get_TypeId()
public bool Equals(object obj)
public int GetHashCode()
public bool Match(object obj)
public string ToString()
}
public System.ComponentModel.ToolboxItemFilterType : Enum {
public int value__
public ToolboxItemFilterType Allow
public ToolboxItemFilterType Custom
public ToolboxItemFilterType Prevent
public ToolboxItemFilterType Require
}
public System.ComponentModel.TypeConverter : object {
public bool CanConvertFrom(Type sourceType)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(Type destinationType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(object o)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertFromInvariantString(string text)
public object ConvertFromInvariantString(ITypeDescriptorContext context, string text)
public object ConvertFromString(string text)
public object ConvertFromString(ITypeDescriptorContext context, string text)
public object ConvertFromString(ITypeDescriptorContext context, CultureInfo culture, string text)
public object ConvertTo(object value, Type destinationType)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public string ConvertToInvariantString(object value)
public string ConvertToInvariantString(ITypeDescriptorContext context, object value)
public string ConvertToString(object value)
public string ConvertToString(ITypeDescriptorContext context, object value)
public string ConvertToString(ITypeDescriptorContext context, CultureInfo culture, object value)
protected Exception GetConvertFromException(object value)
protected Exception GetConvertToException(object value, Type destinationType)
public object CreateInstance(IDictionary propertyValues)
public object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
public bool GetCreateInstanceSupported()
public bool GetCreateInstanceSupported(ITypeDescriptorContext context)
public PropertyDescriptorCollection GetProperties(object value)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value)
public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
public bool GetPropertiesSupported()
public bool GetPropertiesSupported(ITypeDescriptorContext context)
public ICollection GetStandardValues()
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive()
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported()
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
public bool IsValid(object value)
public bool IsValid(ITypeDescriptorContext context, object value)
protected PropertyDescriptorCollection SortProperties(PropertyDescriptorCollection props, String[] names)
}
public System.ComponentModel.TypeConverterAttribute : Attribute {
public TypeConverterAttribute Default
private string converter_type
public string ConverterTypeName
public void .ctor(string typeName)
public void .ctor(Type type)
public bool Equals(object obj)
public int GetHashCode()
public string get_ConverterTypeName()
}
public System.ComponentModel.TypeDescriptionProvider : object {
private EmptyCustomTypeDescriptor _emptyCustomTypeDescriptor
private TypeDescriptionProvider _parent
protected void .ctor(TypeDescriptionProvider parent)
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
public IDictionary GetCache(object instance)
public ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance)
public string GetFullComponentName(object component)
public Type GetReflectionType(object instance)
public Type GetReflectionType(Type objectType)
public Type GetReflectionType(Type objectType, object instance)
public ICustomTypeDescriptor GetTypeDescriptor(object instance)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType)
public ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance)
}
public System.ComponentModel.TypeDescriptionProviderAttribute : Attribute {
private string typeName
public string TypeName
public void .ctor(string typeName)
public void .ctor(Type type)
public string get_TypeName()
}
public System.ComponentModel.TypeDescriptor : object {
private object creatingDefaultConverters
private ArrayList defaultConverters
private IComNativeDescriptorHandler descriptorHandler
private Hashtable componentTable
private Hashtable typeTable
private Hashtable editors
private object typeDescriptionProvidersLock
private Dictionary`2<Type, LinkedList`1<TypeDescriptionProvider>> typeDescriptionProviders
private object componentDescriptionProvidersLock
private Dictionary`2<WeakObjectWrapper, LinkedList`1<TypeDescriptionProvider>> componentDescriptionProviders
private EventHandler onDispose
private RefreshEventHandler Refreshed
public Type ComObjectType
private ArrayList DefaultConverters
public IComNativeDescriptorHandler ComNativeDescriptorHandler
public void add_Refreshed(RefreshEventHandler value)
public void remove_Refreshed(RefreshEventHandler value)
public Type get_ComObjectType()
public TypeDescriptionProvider AddAttributes(object instance, Attribute[] attributes)
public TypeDescriptionProvider AddAttributes(Type type, Attribute[] attributes)
public void AddProvider(TypeDescriptionProvider provider, object instance)
public void AddProvider(TypeDescriptionProvider provider, Type type)
public object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args)
public void AddEditorTable(Type editorBaseType, Hashtable table)
public IDesigner CreateDesigner(IComponent component, Type designerBaseType)
public EventDescriptor CreateEvent(Type componentType, string name, Type type, Attribute[] attributes)
public EventDescriptor CreateEvent(Type componentType, EventDescriptor oldEventDescriptor, Attribute[] attributes)
public PropertyDescriptor CreateProperty(Type componentType, string name, Type type, Attribute[] attributes)
public PropertyDescriptor CreateProperty(Type componentType, PropertyDescriptor oldPropertyDescriptor, Attribute[] attributes)
public AttributeCollection GetAttributes(Type componentType)
public AttributeCollection GetAttributes(object component)
public AttributeCollection GetAttributes(object component, bool noCustomTypeDesc)
public string GetClassName(object component)
public string GetClassName(object component, bool noCustomTypeDesc)
public string GetComponentName(object component)
public string GetComponentName(object component, bool noCustomTypeDesc)
public string GetFullComponentName(object component)
public string GetClassName(Type componentType)
public TypeConverter GetConverter(object component)
public TypeConverter GetConverter(object component, bool noCustomTypeDesc)
private ArrayList get_DefaultConverters()
public TypeConverter GetConverter(Type type)
private Type FindDefaultConverterType(Type type)
public EventDescriptor GetDefaultEvent(Type componentType)
public EventDescriptor GetDefaultEvent(object component)
public EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc)
public PropertyDescriptor GetDefaultProperty(Type componentType)
public PropertyDescriptor GetDefaultProperty(object component)
public PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc)
internal object CreateEditor(Type t, Type componentType)
private object FindEditorInTable(Type componentType, Type editorBaseType, Hashtable table)
public object GetEditor(Type componentType, Type editorBaseType)
public object GetEditor(object component, Type editorBaseType)
public object GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc)
public EventDescriptorCollection GetEvents(object component)
public EventDescriptorCollection GetEvents(Type componentType)
public EventDescriptorCollection GetEvents(object component, Attribute[] attributes)
public EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc)
public EventDescriptorCollection GetEvents(Type componentType, Attribute[] attributes)
public EventDescriptorCollection GetEvents(object component, Attribute[] attributes, bool noCustomTypeDesc)
public PropertyDescriptorCollection GetProperties(object component)
public PropertyDescriptorCollection GetProperties(Type componentType)
public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes)
public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes, bool noCustomTypeDesc)
public PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc)
public PropertyDescriptorCollection GetProperties(Type componentType, Attribute[] attributes)
public TypeDescriptionProvider GetProvider(object instance)
public TypeDescriptionProvider GetProvider(Type type)
public Type GetReflectionType(object instance)
public Type GetReflectionType(Type type)
public void CreateAssociation(object primary, object secondary)
public object GetAssociation(Type type, object primary)
public void RemoveAssociation(object primary, object secondary)
public void RemoveAssociations(object primary)
public void RemoveProvider(TypeDescriptionProvider provider, object instance)
public void RemoveProvider(TypeDescriptionProvider provider, Type type)
private void RemoveProvider(TypeDescriptionProvider provider, LinkedList`1<TypeDescriptionProvider> plist)
public void SortDescriptorArray(IList infos)
public IComNativeDescriptorHandler get_ComNativeDescriptorHandler()
public void set_ComNativeDescriptorHandler(IComNativeDescriptorHandler value)
public void Refresh(Assembly assembly)
public void Refresh(Module module)
public void Refresh(object component)
public void Refresh(Type type)
private void OnComponentDisposed(object sender, EventArgs args)
internal ComponentInfo GetComponentInfo(IComponent com)
internal TypeInfo GetTypeInfo(Type type)
private Type GetTypeFromName(IComponent component, string typeName)
}
internal System.ComponentModel.TypeInfo : Info {
private EventDescriptorCollection _events
private PropertyDescriptorCollection _properties
public void .ctor(Type t)
public AttributeCollection GetAttributes()
public EventDescriptorCollection GetEvents()
public PropertyDescriptorCollection GetProperties()
}
public System.ComponentModel.TypeListConverter : TypeConverter {
private Type[] types
protected void .ctor(Type[] types)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
public bool GetStandardValuesExclusive(ITypeDescriptorContext context)
public bool GetStandardValuesSupported(ITypeDescriptorContext context)
}
public System.ComponentModel.UInt16Converter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
internal object ConvertFromString(string value, int fromBase)
}
public System.ComponentModel.UInt32Converter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
internal object ConvertFromString(string value, int fromBase)
}
public System.ComponentModel.UInt64Converter : BaseNumberConverter {
internal bool SupportHex
internal bool get_SupportHex()
internal string ConvertToString(object value, NumberFormatInfo format)
internal object ConvertFromString(string value, NumberFormatInfo format)
internal object ConvertFromString(string value, int fromBase)
}
public System.ComponentModel.WarningException : SystemException {
private string helpUrl
private string helpTopic
public string HelpTopic
public string HelpUrl
public void .ctor(string message)
public void .ctor(string message, string helpUrl)
public void .ctor(string message, string helpUrl, string helpTopic)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string get_HelpTopic()
public string get_HelpUrl()
}
internal System.ComponentModel.WeakObjectWrapper : object {
private int <TargetHashCode>k__BackingField
private WeakReference <Weak>k__BackingField
public int TargetHashCode
public WeakReference Weak
public void .ctor(object target)
public int get_TargetHashCode()
private void set_TargetHashCode(int value)
public WeakReference get_Weak()
private void set_Weak(WeakReference value)
}
internal System.ComponentModel.WeakObjectWrapperComparer : EqualityComparer`1<WeakObjectWrapper> {
public bool Equals(WeakObjectWrapper x, WeakObjectWrapper y)
public int GetHashCode(WeakObjectWrapper obj)
}
public System.ComponentModel.Win32Exception : ExternalException {
private int native_error_code
public int NativeErrorCode
public void .ctor(int error)
public void .ctor(int error, string message)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_NativeErrorCode()
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal string W32ErrorMessage(int error_code)
}
internal System.Configuration.AllowDefinition : Enum {
public int value__
public AllowDefinition Everywhere
public AllowDefinition MachineOnly
public AllowDefinition MachineToApplication
}
public System.Configuration.ApplicationSettingsBase : SettingsBase {
private string settingsKey
private SettingsContext context
private SettingsPropertyCollection properties
private ISettingsProviderService providerService
private SettingsPropertyValueCollection propertyValues
private SettingsProviderCollection providers
private PropertyChangedEventHandler PropertyChanged
private SettingChangingEventHandler SettingChanging
private SettingsLoadedEventHandler SettingsLoaded
private SettingsSavingEventHandler SettingsSaving
public SettingsContext Context
public object Item
public SettingsPropertyCollection Properties
public SettingsPropertyValueCollection PropertyValues
public SettingsProviderCollection Providers
public string SettingsKey
protected void .ctor(IComponent owner)
protected void .ctor(string settingsKey)
protected void .ctor(IComponent owner, string settingsKey)
public void add_PropertyChanged(PropertyChangedEventHandler value)
public void remove_PropertyChanged(PropertyChangedEventHandler value)
public void add_SettingChanging(SettingChangingEventHandler value)
public void remove_SettingChanging(SettingChangingEventHandler value)
public void add_SettingsLoaded(SettingsLoadedEventHandler value)
public void remove_SettingsLoaded(SettingsLoadedEventHandler value)
public void add_SettingsSaving(SettingsSavingEventHandler value)
public void remove_SettingsSaving(SettingsSavingEventHandler value)
public object GetPreviousVersion(string propertyName)
public void Reload()
public void Reset()
public void Save()
public void Upgrade()
protected void OnPropertyChanged(object sender, PropertyChangedEventArgs e)
protected void OnSettingChanging(object sender, SettingChangingEventArgs e)
protected void OnSettingsLoaded(object sender, SettingsLoadedEventArgs e)
protected void OnSettingsSaving(object sender, CancelEventArgs e)
public SettingsContext get_Context()
private void CacheValuesByProvider(SettingsProvider provider)
private void InitializeSettings(SettingsPropertyCollection settings)
private object GetPropertyValue(string propertyName)
public object get_Item(string propertyName)
public void set_Item(string propertyName, object value)
public SettingsPropertyCollection get_Properties()
private void CreateSettingsProperty(PropertyInfo prop, SettingsPropertyCollection properties, LocalFileSettingsProvider& local_provider)
public SettingsPropertyValueCollection get_PropertyValues()
public SettingsProviderCollection get_Providers()
public string get_SettingsKey()
public void set_SettingsKey(string value)
}
public System.Configuration.AppSettingsReader : object {
private NameValueCollection appSettings
public object GetValue(string key, Type type)
}
public System.Configuration.ClientSettingsSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty settings_prop
public SettingElementCollection Settings
protected ConfigurationPropertyCollection Properties
public SettingElementCollection get_Settings()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Configuration.ConfigHelper : object {
internal IDictionary GetDictionary(IDictionary prev, XmlNode region, string nameAtt, string valueAtt)
internal ConfigNameValueCollection GetNameValueCollection(NameValueCollection prev, XmlNode region, string nameAtt, string valueAtt)
private CollectionWrapper GoGetThem(CollectionWrapper result, XmlNode region, string nameAtt, string valueAtt)
}
internal System.Configuration.ConfigNameValueCollection : NameValueCollection {
private bool modified
public bool IsModified
public void .ctor(ConfigNameValueCollection col)
public void .ctor(IHashCodeProvider hashProvider, IComparer comparer)
public void ResetModified()
public bool get_IsModified()
public void Set(string name, string value)
}
internal System.Configuration.ConfigurationData : object {
private ConfigurationData parent
private Hashtable factories
private object removedMark
private object emptyMark
private Hashtable pending
private string fileName
private object groupMark
private Hashtable cache
private Hashtable FileCache
public void .ctor(ConfigurationData parent)
private Hashtable get_FileCache()
public bool Load(string fileName)
public bool LoadString(string data)
private object GetHandler(string sectionName)
private object CreateNewHandler(string sectionName, SectionData section)
private XmlDocument GetInnerDoc(XmlDocument doc, int i, String[] sectionPath)
private XmlDocument GetDocumentForSection(string sectionName)
private object GetConfigInternal(string sectionName)
public object GetConfig(string sectionName)
private object LookForFactory(string key)
private bool InitRead(XmlTextReader reader)
private void MoveToNextElement(XmlTextReader reader)
private void ReadSection(XmlTextReader reader, string sectionName)
private void ReadRemoveSection(XmlTextReader reader, string sectionName)
private void ReadSectionGroup(XmlTextReader reader, string configSection)
private void ReadSections(XmlTextReader reader, string configSection)
private void StorePending(string name, XmlTextReader reader)
private void ReadConfigFile(XmlTextReader reader)
private void ThrowException(string text, XmlTextReader reader)
}
public System.Configuration.ConfigurationException : SystemException {
private string filename
private int line
public string BareMessage
public string Filename
public int Line
public string Message
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string message, XmlNode node)
public void .ctor(string message, Exception inner, XmlNode node)
public void .ctor(string message, string filename, int line)
public void .ctor(string message, Exception inner, string filename, int line)
public string get_BareMessage()
public string get_Filename()
public int get_Line()
public string get_Message()
public string GetXmlNodeFilename(XmlNode node)
public int GetXmlNodeLineNumber(XmlNode node)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Configuration.ConfigurationSettings : object {
private IConfigurationSystem config
private object lockobj
public NameValueCollection AppSettings
public object GetConfig(string sectionName)
public NameValueCollection get_AppSettings()
internal IConfigurationSystem ChangeConfigurationSystem(IConfigurationSystem newSystem)
}
public System.Configuration.ConfigXmlDocument : XmlDocument {
private XmlTextReader reader
private string fileName
private int lineNumber
private string System.Configuration.Internal.IConfigErrorInfo.Filename
private int System.Configuration.Internal.IConfigErrorInfo.LineNumber
private string System.Configuration.IConfigXmlNode.Filename
private int System.Configuration.IConfigXmlNode.LineNumber
public string Filename
public int LineNumber
private string System.Configuration.Internal.IConfigErrorInfo.get_Filename()
private int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber()
private string System.Configuration.IConfigXmlNode.get_Filename()
private int System.Configuration.IConfigXmlNode.get_LineNumber()
public XmlAttribute CreateAttribute(string prefix, string localName, string namespaceUri)
public XmlCDataSection CreateCDataSection(string data)
public XmlComment CreateComment(string comment)
public XmlElement CreateElement(string prefix, string localName, string namespaceUri)
public XmlSignificantWhitespace CreateSignificantWhitespace(string data)
public XmlText CreateTextNode(string text)
public XmlWhitespace CreateWhitespace(string data)
public void Load(string filename)
public void LoadSingleElement(string filename, XmlTextReader sourceReader)
public string get_Filename()
public int get_LineNumber()
}
internal System.Configuration.CustomizableFileSettingsProvider : SettingsProvider {
private Type webConfigurationFileMapType
private string userRoamingPath
private string userLocalPath
private string userRoamingPathPrevVersion
private string userLocalPathPrevVersion
private string userRoamingName
private string userLocalName
private string userRoamingBasePath
private string userLocalBasePath
private string CompanyName
private string ProductName
private string ForceVersion
private String[] ProductVersion
private bool isVersionMajor
private bool isVersionMinor
private bool isVersionBuild
private bool isVersionRevision
private bool isCompany
private bool isProduct
private bool isEvidence
private bool userDefine
private UserConfigLocationOption userConfig
private string app_name
private ExeConfigurationFileMap exeMapCurrent
private ExeConfigurationFileMap exeMapPrev
private SettingsPropertyValueCollection values
internal string UserRoamingFullPath
internal string UserLocalFullPath
public string PrevUserRoamingFullPath
public string PrevUserLocalFullPath
public string UserRoamingPath
public string UserLocalPath
public string UserRoamingName
public string UserLocalName
public UserConfigLocationOption UserConfigSelector
public bool IsVersionMajor
public bool IsVersionMinor
public bool IsVersionBuild
public bool IsVersionRevision
public bool IsCompany
public bool IsEvidence
public string Name
public string ApplicationName
public void Initialize(string name, NameValueCollection config)
internal string get_UserRoamingFullPath()
internal string get_UserLocalFullPath()
public string get_PrevUserRoamingFullPath()
public string get_PrevUserLocalFullPath()
public string get_UserRoamingPath()
public string get_UserLocalPath()
public string get_UserRoamingName()
public string get_UserLocalName()
public UserConfigLocationOption get_UserConfigSelector()
public void set_UserConfigSelector(UserConfigLocationOption value)
public bool get_IsVersionMajor()
public void set_IsVersionMajor(bool value)
public bool get_IsVersionMinor()
public void set_IsVersionMinor(bool value)
public bool get_IsVersionBuild()
public void set_IsVersionBuild(bool value)
public bool get_IsVersionRevision()
public void set_IsVersionRevision(bool value)
public bool get_IsCompany()
public void set_IsCompany(bool value)
public bool get_IsEvidence()
public void set_IsEvidence(bool value)
private string GetCompanyName()
private string GetProductName()
private string GetEvidenceHash()
private string GetProductVersion()
private void CreateUserConfigPath()
private string PrevVersionPath(string dirName, string currentVersion)
public bool SetUserRoamingPath(string configPath)
public bool SetUserLocalPath(string configPath)
private bool CheckFileName(string configFile)
public bool SetUserRoamingFileName(string configFile)
public bool SetUserLocalFileName(string configFile)
public bool SetCompanyName(string companyName)
public bool SetProductName(string productName)
public bool SetVersion(int major)
public bool SetVersion(int major, int minor)
public bool SetVersion(int major, int minor, int build)
public bool SetVersion(int major, int minor, int build, int revision)
public bool SetVersion(string forceVersion)
private bool CheckPath(string configPath)
public string get_Name()
public string get_ApplicationName()
public void set_ApplicationName(string value)
private void SaveProperties(ExeConfigurationFileMap exeMap, SettingsPropertyValueCollection collection, ConfigurationUserLevel level, SettingsContext context, bool checkUserLevel)
private void LoadPropertyValue(SettingsPropertyCollection collection, SettingElement element, bool allowOverwrite)
private void LoadProperties(ExeConfigurationFileMap exeMap, SettingsPropertyCollection collection, ConfigurationUserLevel level, string sectionGroupName, bool allowOverwrite, string groupName)
public void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection)
public SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection)
private void CreateExeMap()
public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property)
public void Reset(SettingsContext context)
public void Upgrade(SettingsContext context, SettingsPropertyCollection properties)
public void setCreate()
}
internal System.Configuration.DefaultConfig : object {
private DefaultConfig instance
private ConfigurationData config
public DefaultConfig GetInstance()
public object GetConfig(string sectionName)
public void Init()
private string get_bundled_machine_config()
internal string GetBundledMachineConfig()
private string get_machine_config_path()
internal string GetMachineConfigPath()
private string GetAppConfigPath()
}
public System.Configuration.DefaultSettingValueAttribute : Attribute {
private string value
public string Value
public void .ctor(string value)
public string get_Value()
}
public System.Configuration.DictionarySectionHandler : object {
protected string KeyAttributeName
protected string ValueAttributeName
public object Create(object parent, object context, XmlNode section)
protected string get_KeyAttributeName()
protected string get_ValueAttributeName()
}
public System.Configuration.IApplicationSettingsProvider {
public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property)
public void Reset(SettingsContext context)
public void Upgrade(SettingsContext context, SettingsPropertyCollection properties)
}
public System.Configuration.IConfigurationSectionHandler {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Configuration.IConfigurationSystem {
public object GetConfig(string configKey)
public void Init()
}
internal System.Configuration.IConfigXmlNode {
public string Filename
public int LineNumber
public string get_Filename()
public int get_LineNumber()
}
public System.Configuration.IdnElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty enabled_prop
public UriIdnScope Enabled
protected ConfigurationPropertyCollection Properties
public UriIdnScope get_Enabled()
public void set_Enabled(UriIdnScope value)
protected ConfigurationPropertyCollection get_Properties()
public bool Equals(object o)
public int GetHashCode()
}
public System.Configuration.IgnoreSectionHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Configuration.IPersistComponentSettings {
public bool SaveSettings
public string SettingsKey
public bool get_SaveSettings()
public void set_SaveSettings(bool value)
public string get_SettingsKey()
public void set_SettingsKey(string value)
public void LoadComponentSettings()
public void ResetComponentSettings()
public void SaveComponentSettings()
}
public System.Configuration.IriParsingElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty enabled_prop
public bool Enabled
protected ConfigurationPropertyCollection Properties
public bool get_Enabled()
public void set_Enabled(bool value)
protected ConfigurationPropertyCollection get_Properties()
public bool Equals(object o)
public int GetHashCode()
}
public System.Configuration.ISettingsProviderService {
public SettingsProvider GetSettingsProvider(SettingsProperty property)
}
public System.Configuration.LocalFileSettingsProvider : SettingsProvider {
private CustomizableFileSettingsProvider impl
public string ApplicationName
public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property)
public SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection properties)
public void Initialize(string name, NameValueCollection values)
public void Reset(SettingsContext context)
public void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection values)
public void Upgrade(SettingsContext context, SettingsPropertyCollection properties)
public string get_ApplicationName()
public void set_ApplicationName(string value)
}
public System.Configuration.NameValueFileSectionHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Configuration.NameValueSectionHandler : object {
protected string KeyAttributeName
protected string ValueAttributeName
public object Create(object parent, object context, XmlNode section)
protected string get_KeyAttributeName()
protected string get_ValueAttributeName()
}
internal System.Configuration.SectionData : object {
public string SectionName
public string TypeName
public bool AllowLocation
public AllowDefinition AllowDefinition
public string FileName
public bool RequirePermission
public void .ctor(string sectionName, string typeName, bool allowLocation, AllowDefinition allowDefinition, bool requirePermission)
}
public System.Configuration.SettingChangingEventArgs : CancelEventArgs {
private string settingName
private string settingClass
private string settingKey
private object newValue
public string SettingName
public string SettingClass
public string SettingKey
public object NewValue
public void .ctor(string settingName, string settingClass, string settingKey, object newValue, bool cancel)
public string get_SettingName()
public string get_SettingClass()
public string get_SettingKey()
public object get_NewValue()
}
public System.Configuration.SettingChangingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SettingChangingEventArgs e)
public IAsyncResult BeginInvoke(object sender, SettingChangingEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Configuration.SettingElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty name_prop
private ConfigurationProperty serialize_as_prop
private ConfigurationProperty value_prop
public string Name
public SettingValueElement Value
public SettingsSerializeAs SerializeAs
protected ConfigurationPropertyCollection Properties
public void .ctor(string name, SettingsSerializeAs serializeAs)
public string get_Name()
public void set_Name(string value)
public SettingValueElement get_Value()
public void set_Value(SettingValueElement value)
public SettingsSerializeAs get_SerializeAs()
public void set_SerializeAs(SettingsSerializeAs value)
protected ConfigurationPropertyCollection get_Properties()
public bool Equals(object o)
public int GetHashCode()
}
public System.Configuration.SettingElementCollection : ConfigurationElementCollection {
public ConfigurationElementCollectionType CollectionType
protected string ElementName
public void Add(SettingElement element)
public void Clear()
public SettingElement Get(string elementKey)
public void Remove(SettingElement element)
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public ConfigurationElementCollectionType get_CollectionType()
protected string get_ElementName()
}
public System.Configuration.SettingsAttributeDictionary : Hashtable {
public void .ctor(SettingsAttributeDictionary attributes)
}
public System.Configuration.SettingsBase : object {
private bool sync
private SettingsContext context
private SettingsPropertyCollection properties
private SettingsProviderCollection providers
private SettingsPropertyValueCollection values
public SettingsContext Context
public bool IsSynchronized
public object Item
public SettingsPropertyCollection Properties
public SettingsPropertyValueCollection PropertyValues
public SettingsProviderCollection Providers
public void Initialize(SettingsContext context, SettingsPropertyCollection properties, SettingsProviderCollection providers)
public void Save()
private void SaveCore()
public SettingsBase Synchronized(SettingsBase settingsBase)
public SettingsContext get_Context()
public bool get_IsSynchronized()
public object get_Item(string propertyName)
public void set_Item(string propertyName, object value)
public SettingsPropertyCollection get_Properties()
public SettingsPropertyValueCollection get_PropertyValues()
public SettingsProviderCollection get_Providers()
private object GetPropertyValue(string propertyName)
private void SetPropertyValue(string propertyName, object value)
}
public System.Configuration.SettingsContext : Hashtable {
private ApplicationSettingsBase current
internal ApplicationSettingsBase CurrentSettings
internal ApplicationSettingsBase get_CurrentSettings()
internal void set_CurrentSettings(ApplicationSettingsBase value)
}
public System.Configuration.SettingsDescriptionAttribute : Attribute {
private string desc
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Configuration.SettingsGroupDescriptionAttribute : Attribute {
private string desc
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Configuration.SettingsGroupNameAttribute : Attribute {
private string group_name
public string GroupName
public void .ctor(string groupName)
public string get_GroupName()
}
public System.Configuration.SettingsLoadedEventArgs : EventArgs {
private SettingsProvider provider
public SettingsProvider Provider
public void .ctor(SettingsProvider provider)
public SettingsProvider get_Provider()
}
public System.Configuration.SettingsLoadedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SettingsLoadedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SettingsLoadedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Configuration.SettingsManageability : Enum {
public int value__
public SettingsManageability Roaming
}
public System.Configuration.SettingsManageabilityAttribute : Attribute {
private SettingsManageability manageability
public SettingsManageability Manageability
public void .ctor(SettingsManageability manageability)
public SettingsManageability get_Manageability()
}
public System.Configuration.SettingsProperty : object {
private string name
private Type propertyType
private SettingsProvider provider
private bool isReadOnly
private object defaultValue
private SettingsSerializeAs serializeAs
private SettingsAttributeDictionary attributes
private bool throwOnErrorDeserializing
private bool throwOnErrorSerializing
public SettingsAttributeDictionary Attributes
public object DefaultValue
public bool IsReadOnly
public string Name
public Type PropertyType
public SettingsProvider Provider
public SettingsSerializeAs SerializeAs
public bool ThrowOnErrorDeserializing
public bool ThrowOnErrorSerializing
public void .ctor(SettingsProperty propertyToCopy)
public void .ctor(string name)
public void .ctor(string name, Type propertyType, SettingsProvider provider, bool isReadOnly, object defaultValue, SettingsSerializeAs serializeAs, SettingsAttributeDictionary attributes, bool throwOnErrorDeserializing, bool throwOnErrorSerializing)
public SettingsAttributeDictionary get_Attributes()
public object get_DefaultValue()
public void set_DefaultValue(object value)
public bool get_IsReadOnly()
public void set_IsReadOnly(bool value)
public string get_Name()
public void set_Name(string value)
public Type get_PropertyType()
public void set_PropertyType(Type value)
public SettingsProvider get_Provider()
public void set_Provider(SettingsProvider value)
public SettingsSerializeAs get_SerializeAs()
public void set_SerializeAs(SettingsSerializeAs value)
public bool get_ThrowOnErrorDeserializing()
public void set_ThrowOnErrorDeserializing(bool value)
public bool get_ThrowOnErrorSerializing()
public void set_ThrowOnErrorSerializing(bool value)
}
public System.Configuration.SettingsPropertyCollection : object {
private Hashtable items
private bool isReadOnly
public int Count
public bool IsSynchronized
public SettingsProperty Item
public object SyncRoot
public void Add(SettingsProperty property)
public void Clear()
public object Clone()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string name)
public void SetReadOnly()
protected void OnAdd(SettingsProperty property)
protected void OnAddComplete(SettingsProperty property)
protected void OnClear()
protected void OnClearComplete()
protected void OnRemove(SettingsProperty property)
protected void OnRemoveComplete(SettingsProperty property)
public int get_Count()
public bool get_IsSynchronized()
public SettingsProperty get_Item(string name)
public object get_SyncRoot()
}
public System.Configuration.SettingsPropertyIsReadOnlyException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Configuration.SettingsPropertyNotFoundException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Configuration.SettingsPropertyValue : object {
private SettingsProperty property
private object propertyValue
private object serializedValue
private bool needSerializedValue
private bool needPropertyValue
private bool dirty
private bool defaulted
private bool deserialized
public bool Deserialized
public bool IsDirty
public string Name
public SettingsProperty Property
public object PropertyValue
public object SerializedValue
public bool UsingDefaultValue
public void .ctor(SettingsProperty property)
public bool get_Deserialized()
public void set_Deserialized(bool value)
public bool get_IsDirty()
public void set_IsDirty(bool value)
public string get_Name()
public SettingsProperty get_Property()
public object get_PropertyValue()
public void set_PropertyValue(object value)
public object get_SerializedValue()
public void set_SerializedValue(object value)
public bool get_UsingDefaultValue()
internal object Reset()
private object GetDeserializedDefaultValue()
private object GetDeserializedValue(object serializedValue)
}
public System.Configuration.SettingsPropertyValueCollection : object {
private Hashtable items
private bool isReadOnly
public int Count
public bool IsSynchronized
public SettingsPropertyValue Item
public object SyncRoot
public void Add(SettingsPropertyValue property)
internal void Add(SettingsPropertyValueCollection vals)
public void Clear()
public object Clone()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public void Remove(string name)
public void SetReadOnly()
public int get_Count()
public bool get_IsSynchronized()
public SettingsPropertyValue get_Item(string name)
public object get_SyncRoot()
}
public System.Configuration.SettingsPropertyWrongTypeException : Exception {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Configuration.SettingsProvider : ProviderBase {
public string ApplicationName
public SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection)
public void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection)
public string get_ApplicationName()
public void set_ApplicationName(string value)
}
public System.Configuration.SettingsProviderAttribute : Attribute {
private string providerTypeName
public string ProviderTypeName
public void .ctor(string providerTypeName)
public void .ctor(Type providerType)
public string get_ProviderTypeName()
}
public System.Configuration.SettingsProviderCollection : ProviderCollection {
public SettingsProvider Item
public void Add(ProviderBase provider)
public SettingsProvider get_Item(string name)
}
public System.Configuration.SettingsSavingEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, CancelEventArgs e)
public IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Configuration.SettingsSerializeAs : Enum {
public int value__
public SettingsSerializeAs String
public SettingsSerializeAs Xml
public SettingsSerializeAs Binary
public SettingsSerializeAs ProviderSpecific
}
public System.Configuration.SettingsSerializeAsAttribute : Attribute {
private SettingsSerializeAs serializeAs
public SettingsSerializeAs SerializeAs
public void .ctor(SettingsSerializeAs serializeAs)
public SettingsSerializeAs get_SerializeAs()
}
public System.Configuration.SettingValueElement : ConfigurationElement {
private XmlNode node
protected ConfigurationPropertyCollection Properties
public XmlNode ValueXml
protected ConfigurationPropertyCollection get_Properties()
public XmlNode get_ValueXml()
public void set_ValueXml(XmlNode value)
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
public bool Equals(object settingValue)
public int GetHashCode()
protected bool IsModified()
protected void Reset(ConfigurationElement parentElement)
protected void ResetModified()
protected bool SerializeToXmlElement(XmlWriter writer, string elementName)
protected void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode)
}
public System.Configuration.SingleTagSectionHandler : object {
public object Create(object parent, object context, XmlNode section)
}
public System.Configuration.SpecialSetting : Enum {
public int value__
public SpecialSetting ConnectionString
public SpecialSetting WebServiceUrl
}
public System.Configuration.SpecialSettingAttribute : Attribute {
private SpecialSetting setting
public SpecialSetting SpecialSetting
public void .ctor(SpecialSetting setting)
public SpecialSetting get_SpecialSetting()
}
public System.Configuration.UriSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty idn_prop
private ConfigurationProperty iriParsing_prop
public IdnElement Idn
public IriParsingElement IriParsing
protected ConfigurationPropertyCollection Properties
public IdnElement get_Idn()
public IriParsingElement get_IriParsing()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Configuration.UserConfigLocationOption : Enum {
public UInt32 value__
public UserConfigLocationOption Product
public UserConfigLocationOption Product_VersionMajor
public UserConfigLocationOption Product_VersionMinor
public UserConfigLocationOption Product_VersionBuild
public UserConfigLocationOption Product_VersionRevision
public UserConfigLocationOption Company_Product
public UserConfigLocationOption Company_Product_VersionMajor
public UserConfigLocationOption Company_Product_VersionMinor
public UserConfigLocationOption Company_Product_VersionBuild
public UserConfigLocationOption Company_Product_VersionRevision
public UserConfigLocationOption Evidence
public UserConfigLocationOption Other
}
internal System.DefaultUriParser : UriParser {
public void .ctor(string scheme)
}
internal System.Diagnostics.AlphabeticalEnumConverter : EnumConverter {
public void .ctor(Type type)
public StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
}
public System.Diagnostics.BooleanSwitch : Switch {
public bool Enabled
public void .ctor(string displayName, string description)
public void .ctor(string displayName, string description, string defaultSwitchValue)
public bool get_Enabled()
public void set_Enabled(bool value)
protected void OnValueChanged()
}
public System.Diagnostics.ConsoleTraceListener : TextWriterTraceListener {
public void .ctor(bool useErrorStream)
internal void .ctor(string data)
}
public System.Diagnostics.CorrelationManager : object {
private Guid activity
private Stack op_stack
public Guid ActivityId
public Stack LogicalOperationStack
public Guid get_ActivityId()
public void set_ActivityId(Guid value)
public Stack get_LogicalOperationStack()
public void StartLogicalOperation()
public void StartLogicalOperation(object operationId)
public void StopLogicalOperation()
}
public System.Diagnostics.CounterCreationData : object {
private string help
private string name
private PerformanceCounterType type
public string CounterHelp
public string CounterName
public PerformanceCounterType CounterType
public void .ctor(string counterName, string counterHelp, PerformanceCounterType counterType)
public string get_CounterHelp()
public void set_CounterHelp(string value)
public string get_CounterName()
public void set_CounterName(string value)
public PerformanceCounterType get_CounterType()
public void set_CounterType(PerformanceCounterType value)
}
public System.Diagnostics.CounterCreationDataCollection : CollectionBase {
public CounterCreationData Item
public void .ctor(CounterCreationData[] value)
public void .ctor(CounterCreationDataCollection value)
public CounterCreationData get_Item(int index)
public void set_Item(int index, CounterCreationData value)
public int Add(CounterCreationData value)
public void AddRange(CounterCreationData[] value)
public void AddRange(CounterCreationDataCollection value)
public bool Contains(CounterCreationData value)
public void CopyTo(CounterCreationData[] array, int index)
public int IndexOf(CounterCreationData value)
public void Insert(int index, CounterCreationData value)
protected void OnValidate(object value)
public void Remove(CounterCreationData value)
}
public System.Diagnostics.CounterSample : ValueType {
private long rawValue
private long baseValue
private long counterFrequency
private long systemFrequency
private long timeStamp
private long timeStamp100nSec
private long counterTimeStamp
private PerformanceCounterType counterType
public CounterSample Empty
public long BaseValue
public long CounterFrequency
public long CounterTimeStamp
public PerformanceCounterType CounterType
public long RawValue
public long SystemFrequency
public long TimeStamp
public long TimeStamp100nSec
public void .ctor(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType)
public void .ctor(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType, long counterTimeStamp)
public long get_BaseValue()
public long get_CounterFrequency()
public long get_CounterTimeStamp()
public PerformanceCounterType get_CounterType()
public long get_RawValue()
public long get_SystemFrequency()
public long get_TimeStamp()
public long get_TimeStamp100nSec()
public float Calculate(CounterSample counterSample)
public float Calculate(CounterSample counterSample, CounterSample nextCounterSample)
public bool Equals(object obj)
public bool Equals(CounterSample other)
public int GetHashCode()
public bool op_Equality(CounterSample obj1, CounterSample obj2)
public bool op_Inequality(CounterSample obj1, CounterSample obj2)
}
public System.Diagnostics.CounterSampleCalculator : object {
public float ComputeCounterValue(CounterSample newSample)
public float ComputeCounterValue(CounterSample oldSample, CounterSample newSample)
}
public System.Diagnostics.DataReceivedEventArgs : EventArgs {
private string data
public string Data
internal void .ctor(string data)
public string get_Data()
}
public System.Diagnostics.DataReceivedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DataReceivedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DataReceivedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Diagnostics.Debug : object {
public bool AutoFlush
public int IndentLevel
public int IndentSize
public TraceListenerCollection Listeners
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public TraceListenerCollection get_Listeners()
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Close()
public void Fail(string message)
public void Fail(string message, string detailMessage)
public void Flush()
public void Indent()
public void Unindent()
public void Write(object value)
public void Write(string message)
public void Write(object value, string category)
public void Write(string message, string category)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value, string category)
public void WriteIf(bool condition, string message, string category)
public void WriteLine(object value)
public void WriteLine(string message)
public void WriteLine(object value, string category)
public void WriteLine(string message, string category)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message, string category)
public void Print(string message)
public void Print(string format, Object[] args)
}
public System.Diagnostics.DefaultTraceListener : TraceListener {
private string ConsoleOutTrace
private string ConsoleErrorTrace
private bool OnWin32
private string MonoTracePrefix
private string MonoTraceFile
private string logFileName
private bool assertUiEnabled
private Dictionary`2<string, int> <>f__switch$map3
private Dictionary`2<string, int> <>f__switch$map4
public bool AssertUiEnabled
public string LogFileName
private string GetPrefix(string var, string target)
public bool get_AssertUiEnabled()
public void set_AssertUiEnabled(bool value)
public string get_LogFileName()
public void set_LogFileName(string value)
public void Fail(string message)
public void Fail(string message, string detailMessage)
private DialogResult ProcessUI(string message, string detailMessage)
private void WriteWindowsDebugString(string message)
private void WriteDebugString(string message)
private void WriteMonoTrace(string message)
private void WritePrefix()
private void WriteImpl(string message)
private void WriteLogFile(string message, string logFile)
private void WriteLogFileImpl(string message, string logFile)
public void Write(string message)
public void WriteLine(string message)
}
public System.Diagnostics.DelimitedListTraceListener : TextWriterTraceListener {
private String[] attributes
private string delimiter
public string Delimiter
public void .ctor(string fileName)
public void .ctor(string fileName, string name)
public void .ctor(Stream stream)
public void .ctor(Stream stream, string name)
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string name)
public string get_Delimiter()
public void set_Delimiter(string value)
protected internal String[] GetSupportedAttributes()
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
private void TraceCore(TraceEventCache c, string source, TraceEventType eventType, int id, string message, Object[] data)
private bool IsTarget(TraceEventCache c, TraceOptions opt)
private string FormatData(Object[] data)
}
internal System.Diagnostics.DiagnosticsConfiguration : object {
private object settings
public IDictionary Settings
public IDictionary get_Settings()
}
public System.Diagnostics.DiagnosticsConfigurationHandler : object {
private TraceImplSettings configValues
private IDictionary elementHandlers
private Dictionary`2<string, int> <>f__switch$map5
private Dictionary`2<string, int> <>f__switch$map6
private Dictionary`2<string, int> <>f__switch$map7
public object Create(object parent, object configContext, XmlNode section)
private void AddAssertNode(IDictionary d, XmlNode node)
private void AddSwitchesNode(IDictionary d, XmlNode node)
private object GetSwitchValue(string name, string value)
private void AddTraceNode(IDictionary d, XmlNode node)
private void AddTraceAttributes(IDictionary d, XmlNode node)
private TraceListenerCollection GetSharedListeners(IDictionary d)
private void AddSourcesNode(IDictionary d, XmlNode node)
private void AddTraceSource(IDictionary d, Hashtable sources, XmlNode node)
private void AddTraceListeners(IDictionary d, XmlNode listenersNode, TraceListenerCollection listeners)
private void AddTraceListener(IDictionary d, XmlNode child, XmlAttributeCollection attributes, TraceListenerCollection listeners)
private void RemoveTraceListener(string name)
private string GetAttribute(XmlAttributeCollection attrs, string attr, bool required, XmlNode node)
private void ValidateAttribute(string attribute, string value, XmlNode node)
private void ValidateInvalidAttributes(XmlAttributeCollection c, XmlNode node)
private void ThrowMissingAttribute(string attribute, XmlNode node)
private void ThrowUnrecognizedNode(XmlNode node)
private void ThrowUnrecognizedElement(XmlNode node)
private void ThrowUnrecognizedAttribute(string attribute, XmlNode node)
}
public System.Diagnostics.EntryWrittenEventArgs : EventArgs {
private EventLogEntry entry
public EventLogEntry Entry
public void .ctor(EventLogEntry entry)
public EventLogEntry get_Entry()
}
public System.Diagnostics.EntryWrittenEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, EntryWrittenEventArgs e)
public IAsyncResult BeginInvoke(object sender, EntryWrittenEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Diagnostics.EventInstance : object {
private int _categoryId
private EventLogEntryType _entryType
private long _instanceId
public int CategoryId
public EventLogEntryType EntryType
public long InstanceId
public void .ctor(long instanceId, int categoryId)
public void .ctor(long instanceId, int categoryId, EventLogEntryType entryType)
public int get_CategoryId()
public void set_CategoryId(int value)
public EventLogEntryType get_EntryType()
public void set_EntryType(EventLogEntryType value)
public long get_InstanceId()
public void set_InstanceId(long value)
}
public System.Diagnostics.EventLog : Component {
internal string LOCAL_FILE_IMPL
private string WIN32_IMPL
private string NULL_IMPL
internal string EVENTLOG_TYPE_VAR
private string source
private string logName
private string machineName
private bool doRaiseEvents
private ISynchronizeInvoke synchronizingObject
private EventLogImpl Impl
private EntryWrittenEventHandler EntryWritten
private Dictionary`2<string, int> <>f__switch$map8
public bool EnableRaisingEvents
public EventLogEntryCollection Entries
public string Log
public string LogDisplayName
public string MachineName
public string Source
public ISynchronizeInvoke SynchronizingObject
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
private bool Win32EventLogEnabled
private string EventLogImplType
public void .ctor(string logName)
public void .ctor(string logName, string machineName)
public void .ctor(string logName, string machineName, string source)
public void add_EntryWritten(EntryWrittenEventHandler value)
public void remove_EntryWritten(EntryWrittenEventHandler value)
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
public EventLogEntryCollection get_Entries()
public string get_Log()
public void set_Log(string value)
public string get_LogDisplayName()
public string get_MachineName()
public void set_MachineName(string value)
public string get_Source()
public void set_Source(string value)
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
public void BeginInit()
public void Clear()
public void Close()
internal void Reset()
public void CreateEventSource(string source, string logName)
public void CreateEventSource(string source, string logName, string machineName)
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source)
public void DeleteEventSource(string source, string machineName)
protected void Dispose(bool disposing)
public void EndInit()
public bool Exists(string logName)
public bool Exists(string logName, string machineName)
public EventLog[] GetEventLogs()
public EventLog[] GetEventLogs(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source)
public bool SourceExists(string source, string machineName)
public void WriteEntry(string message)
public void WriteEntry(string message, EventLogEntryType type)
public void WriteEntry(string message, EventLogEntryType type, int eventID)
public void WriteEntry(string message, EventLogEntryType type, int eventID, short category)
public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, Byte[] rawData)
public void WriteEntry(string source, string message)
public void WriteEntry(string source, string message, EventLogEntryType type)
public void WriteEntry(string source, string message, EventLogEntryType type, int eventID)
public void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category)
public void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category, Byte[] rawData)
public void WriteEvent(EventInstance instance, Object[] values)
public void WriteEvent(EventInstance instance, Byte[] data, Object[] values)
public void WriteEvent(string source, EventInstance instance, Object[] values)
public void WriteEvent(string source, EventInstance instance, Byte[] data, Object[] values)
internal void OnEntryWritten(EventLogEntry newEntry)
internal string GetLogName()
private EventLogImpl CreateEventLogImpl(string logName, string machineName, string source)
private EventLogImpl CreateEventLogImpl(EventLog eventLog)
private bool get_Win32EventLogEnabled()
private string get_EventLogImplType()
private void WriteEntry(String[] replacementStrings, EventLogEntryType type, long instanceID, short category, Byte[] rawData)
private void ValidateEventID(long instanceID)
internal int GetEventID(long instanceID)
}
public System.Diagnostics.EventLogEntry : Component {
private string category
private short categoryNumber
private Byte[] data
private EventLogEntryType entryType
private int eventID
private int index
private string machineName
private string message
private String[] replacementStrings
private string source
private DateTime timeGenerated
private DateTime timeWritten
private string userName
private long instanceId
public string Category
public short CategoryNumber
public Byte[] Data
public EventLogEntryType EntryType
public int EventID
public int Index
public long InstanceId
public string MachineName
public string Message
public String[] ReplacementStrings
public string Source
public DateTime TimeGenerated
public DateTime TimeWritten
public string UserName
internal void .ctor(string category, short categoryNumber, int index, int eventID, string source, string message, string userName, string machineName, EventLogEntryType entryType, DateTime timeGenerated, DateTime timeWritten, Byte[] data, String[] replacementStrings, long instanceId)
private void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public string get_Category()
public short get_CategoryNumber()
public Byte[] get_Data()
public EventLogEntryType get_EntryType()
public int get_EventID()
public int get_Index()
public long get_InstanceId()
public string get_MachineName()
public string get_Message()
public String[] get_ReplacementStrings()
public string get_Source()
public DateTime get_TimeGenerated()
public DateTime get_TimeWritten()
public string get_UserName()
public bool Equals(EventLogEntry otherEntry)
}
public System.Diagnostics.EventLogEntryCollection : object {
private EventLogImpl _impl
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public int Count
public EventLogEntry Item
internal void .ctor(EventLogImpl impl)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private void System.Collections.ICollection.CopyTo(Array array, int index)
public int get_Count()
public EventLogEntry get_Item(int index)
public void CopyTo(EventLogEntry[] eventLogEntries, int index)
public IEnumerator GetEnumerator()
}
public System.Diagnostics.EventLogEntryType : Enum {
public int value__
public EventLogEntryType Error
public EventLogEntryType Warning
public EventLogEntryType Information
public EventLogEntryType SuccessAudit
public EventLogEntryType FailureAudit
}
internal System.Diagnostics.EventLogImpl : object {
private EventLog _coreEventLog
protected EventLog CoreEventLog
public int EntryCount
public EventLogEntry Item
public string LogDisplayName
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
protected void .ctor(EventLog coreEventLog)
protected EventLog get_CoreEventLog()
public int get_EntryCount()
public EventLogEntry get_Item(int index)
public string get_LogDisplayName()
public EventLogEntry[] GetEntries()
public void DisableNotification()
public void EnableNotification()
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void EndInit()
public bool Exists(string logName, string machineName)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
public EventLog[] GetEventLogs(string machineName)
protected string GetLogDisplayName()
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
protected string FormatMessage(string source, UInt32 messageID, String[] replacementStrings)
protected String[] GetLogNames(string machineName)
protected void ValidateCustomerLogName(string logName, string machineName)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
}
public System.Diagnostics.EventLogPermission : ResourcePermissionBase {
private EventLogPermissionEntryCollection innerCollection
public EventLogPermissionEntryCollection PermissionEntries
public void .ctor(EventLogPermissionEntry[] permissionAccessEntries)
public void .ctor(PermissionState state)
public void .ctor(EventLogPermissionAccess permissionAccess, string machineName)
public EventLogPermissionEntryCollection get_PermissionEntries()
private void SetUp()
internal ResourcePermissionBaseEntry[] GetEntries()
internal void ClearEntries()
internal void Add(object obj)
internal void Remove(object obj)
}
public System.Diagnostics.EventLogPermissionAccess : Enum {
public int value__
public EventLogPermissionAccess None
public EventLogPermissionAccess Browse
public EventLogPermissionAccess Instrument
public EventLogPermissionAccess Audit
public EventLogPermissionAccess Write
public EventLogPermissionAccess Administer
}
public System.Diagnostics.EventLogPermissionAttribute : CodeAccessSecurityAttribute {
private string machineName
private EventLogPermissionAccess permissionAccess
public string MachineName
public EventLogPermissionAccess PermissionAccess
public void .ctor(SecurityAction action)
public string get_MachineName()
public void set_MachineName(string value)
public EventLogPermissionAccess get_PermissionAccess()
public void set_PermissionAccess(EventLogPermissionAccess value)
public IPermission CreatePermission()
}
public System.Diagnostics.EventLogPermissionEntry : object {
private EventLogPermissionAccess permissionAccess
private string machineName
public string MachineName
public EventLogPermissionAccess PermissionAccess
public void .ctor(EventLogPermissionAccess permissionAccess, string machineName)
public string get_MachineName()
public EventLogPermissionAccess get_PermissionAccess()
internal ResourcePermissionBaseEntry CreateResourcePermissionBaseEntry()
}
public System.Diagnostics.EventLogPermissionEntryCollection : CollectionBase {
private EventLogPermission owner
public EventLogPermissionEntry Item
internal void .ctor(EventLogPermission owner)
public EventLogPermissionEntry get_Item(int index)
public void set_Item(int index, EventLogPermissionEntry value)
public int Add(EventLogPermissionEntry value)
public void AddRange(EventLogPermissionEntry[] value)
public void AddRange(EventLogPermissionEntryCollection value)
public bool Contains(EventLogPermissionEntry value)
public void CopyTo(EventLogPermissionEntry[] array, int index)
public int IndexOf(EventLogPermissionEntry value)
public void Insert(int index, EventLogPermissionEntry value)
protected void OnClear()
protected void OnInsert(int index, object value)
protected void OnRemove(int index, object value)
protected void OnSet(int index, object oldValue, object newValue)
public void Remove(EventLogPermissionEntry value)
}
public System.Diagnostics.EventLogTraceListener : TraceListener {
private EventLog event_log
private string name
public EventLog EventLog
public string Name
public void .ctor(EventLog eventLog)
public void .ctor(string source)
public EventLog get_EventLog()
public void set_EventLog(EventLog value)
public string get_Name()
public void set_Name(string value)
public void Close()
protected void Dispose(bool disposing)
public void Write(string message)
public void WriteLine(string message)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
}
public System.Diagnostics.EventSourceCreationData : object {
private string _source
private string _logName
private string _machineName
private string _messageResourceFile
private string _parameterResourceFile
private string _categoryResourceFile
private int _categoryCount
public int CategoryCount
public string CategoryResourceFile
public string LogName
public string MachineName
public string MessageResourceFile
public string ParameterResourceFile
public string Source
public void .ctor(string source, string logName)
internal void .ctor(string source, string logName, string machineName)
public int get_CategoryCount()
public void set_CategoryCount(int value)
public string get_CategoryResourceFile()
public void set_CategoryResourceFile(string value)
public string get_LogName()
public void set_LogName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public string get_MessageResourceFile()
public void set_MessageResourceFile(string value)
public string get_ParameterResourceFile()
public void set_ParameterResourceFile(string value)
public string get_Source()
public void set_Source(string value)
}
public System.Diagnostics.EventTypeFilter : TraceFilter {
private SourceLevels event_type
public SourceLevels EventType
public void .ctor(SourceLevels eventType)
public SourceLevels get_EventType()
public void set_EventType(SourceLevels value)
public bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data)
}
public System.Diagnostics.FileVersionInfo : object {
private string comments
private string companyname
private string filedescription
private string filename
private string fileversion
private string internalname
private string language
private string legalcopyright
private string legaltrademarks
private string originalfilename
private string privatebuild
private string productname
private string productversion
private string specialbuild
private bool isdebug
private bool ispatched
private bool isprerelease
private bool isprivatebuild
private bool isspecialbuild
private int filemajorpart
private int fileminorpart
private int filebuildpart
private int fileprivatepart
private int productmajorpart
private int productminorpart
private int productbuildpart
private int productprivatepart
public string Comments
public string CompanyName
public int FileBuildPart
public string FileDescription
public int FileMajorPart
public int FileMinorPart
public string FileName
public int FilePrivatePart
public string FileVersion
public string InternalName
public bool IsDebug
public bool IsPatched
public bool IsPreRelease
public bool IsPrivateBuild
public bool IsSpecialBuild
public string Language
public string LegalCopyright
public string LegalTrademarks
public string OriginalFilename
public string PrivateBuild
public int ProductBuildPart
public int ProductMajorPart
public int ProductMinorPart
public string ProductName
public int ProductPrivatePart
public string ProductVersion
public string SpecialBuild
public string get_Comments()
public string get_CompanyName()
public int get_FileBuildPart()
public string get_FileDescription()
public int get_FileMajorPart()
public int get_FileMinorPart()
public string get_FileName()
public int get_FilePrivatePart()
public string get_FileVersion()
public string get_InternalName()
public bool get_IsDebug()
public bool get_IsPatched()
public bool get_IsPreRelease()
public bool get_IsPrivateBuild()
public bool get_IsSpecialBuild()
public string get_Language()
public string get_LegalCopyright()
public string get_LegalTrademarks()
public string get_OriginalFilename()
public string get_PrivateBuild()
public int get_ProductBuildPart()
public int get_ProductMajorPart()
public int get_ProductMinorPart()
public string get_ProductName()
public int get_ProductPrivatePart()
public string get_ProductVersion()
public string get_SpecialBuild()
private void GetVersionInfo_internal(string fileName)
public FileVersionInfo GetVersionInfo(string fileName)
private void AppendFormat(StringBuilder sb, string format, Object[] args)
public string ToString()
}
public System.Diagnostics.ICollectData {
public void CloseData()
public void CollectData(int id, IntPtr valueName, IntPtr data, int totalBytes, IntPtr& res)
}
public System.Diagnostics.InstanceData : object {
private string instanceName
private CounterSample sample
public string InstanceName
public long RawValue
public CounterSample Sample
public void .ctor(string instanceName, CounterSample sample)
public string get_InstanceName()
public long get_RawValue()
public CounterSample get_Sample()
}
public System.Diagnostics.InstanceDataCollection : DictionaryBase {
private string counterName
public string CounterName
public InstanceData Item
public ICollection Keys
public ICollection Values
public void .ctor(string counterName)
private void CheckNull(object value, string name)
public string get_CounterName()
public InstanceData get_Item(string instanceName)
public ICollection get_Keys()
public ICollection get_Values()
public bool Contains(string instanceName)
public void CopyTo(InstanceData[] instances, int index)
}
public System.Diagnostics.InstanceDataCollectionCollection : DictionaryBase {
public InstanceDataCollection Item
public ICollection Keys
public ICollection Values
private void CheckNull(object value, string name)
public InstanceDataCollection get_Item(string counterName)
public ICollection get_Keys()
public ICollection get_Values()
public bool Contains(string counterName)
public void CopyTo(InstanceDataCollection[] counters, int index)
}
internal System.Diagnostics.LocalFileEventLog : EventLogImpl {
private string DateFormat
private object lockObject
private FileSystemWatcher file_watcher
private int last_notification_index
private bool _notifying
private bool RunningOnUnix
private string EventLogStore
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
public void .ctor(EventLog coreEventLog)
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void DisableNotification()
public void EnableNotification()
public void EndInit()
public bool Exists(string logName, string machineName)
protected string FormatMessage(string source, UInt32 eventID, String[] replacementStrings)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
protected string GetLogDisplayName()
protected String[] GetLogNames(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
private string FindSourceDirectory(string source)
private bool get_RunningOnUnix()
private string FindLogStore(string logName)
private string get_EventLogStore()
private int GetLatestIndex()
private void ModifyAccessPermissions(string path, string permissions)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
private void <EnableNotification>m__2(object o, FileSystemEventArgs e)
}
public System.Diagnostics.MonitoringDescriptionAttribute : DescriptionAttribute {
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.Diagnostics.NullEventLog : EventLogImpl {
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
public void .ctor(EventLog coreEventLog)
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void DisableNotification()
public void EnableNotification()
public void EndInit()
public bool Exists(string logName, string machineName)
protected string FormatMessage(string source, UInt32 messageID, String[] replacementStrings)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
protected string GetLogDisplayName()
protected String[] GetLogNames(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
}
public System.Diagnostics.OverflowAction : Enum {
public int value__
public OverflowAction DoNotOverwrite
public OverflowAction OverwriteAsNeeded
public OverflowAction OverwriteOlder
}
public System.Diagnostics.PerformanceCounter : Component {
private string categoryName
private string counterName
private string instanceName
private string machineName
private IntPtr impl
private PerformanceCounterType type
private CounterSample old_sample
private bool readOnly
private bool valid_old
private bool changed
private bool is_custom
private PerformanceCounterInstanceLifetime lifetime
public int DefaultFileMappingSize
public string CategoryName
public string CounterHelp
public string CounterName
public PerformanceCounterType CounterType
public PerformanceCounterInstanceLifetime InstanceLifetime
public string InstanceName
public string MachineName
public long RawValue
public bool ReadOnly
public void .ctor(string categoryName, string counterName)
public void .ctor(string categoryName, string counterName, bool readOnly)
public void .ctor(string categoryName, string counterName, string instanceName)
public void .ctor(string categoryName, string counterName, string instanceName, bool readOnly)
public void .ctor(string categoryName, string counterName, string instanceName, string machineName)
private IntPtr GetImpl(string category, string counter, string instance, string machine, PerformanceCounterType& ctype, Boolean& custom)
private bool GetSample(IntPtr impl, bool only_value, CounterSample& sample)
private long UpdateValue(IntPtr impl, bool do_incr, long value)
private void FreeData(IntPtr impl)
private void UpdateInfo()
public string get_CategoryName()
public void set_CategoryName(string value)
public string get_CounterHelp()
public string get_CounterName()
public void set_CounterName(string value)
public PerformanceCounterType get_CounterType()
public PerformanceCounterInstanceLifetime get_InstanceLifetime()
public void set_InstanceLifetime(PerformanceCounterInstanceLifetime value)
public string get_InstanceName()
public void set_InstanceName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public long get_RawValue()
public void set_RawValue(long value)
public bool get_ReadOnly()
public void set_ReadOnly(bool value)
public void BeginInit()
public void EndInit()
public void Close()
public void CloseSharedResources()
public long Decrement()
protected void Dispose(bool disposing)
public long Increment()
public long IncrementBy(long value)
public CounterSample NextSample()
public float NextValue()
public void RemoveInstance()
}
public System.Diagnostics.PerformanceCounterCategory : object {
private string categoryName
private string machineName
private PerformanceCounterCategoryType type
public string CategoryHelp
public string CategoryName
public string MachineName
public PerformanceCounterCategoryType CategoryType
public void .ctor(string categoryName)
public void .ctor(string categoryName, string machineName)
private bool CategoryDelete(string name)
private string CategoryHelpInternal(string category, string machine)
private bool CounterCategoryExists(string counter, string category, string machine)
private bool Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationData[] items)
private int InstanceExistsInternal(string instance, string category, string machine)
private String[] GetCategoryNames(string machine)
private String[] GetCounterNames(string category, string machine)
private String[] GetInstanceNames(string category, string machine)
private void CheckCategory(string categoryName)
public string get_CategoryHelp()
public string get_CategoryName()
public void set_CategoryName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public PerformanceCounterCategoryType get_CategoryType()
public bool CounterExists(string counterName)
public bool CounterExists(string counterName, string categoryName)
public bool CounterExists(string counterName, string categoryName, string machineName)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, CounterCreationDataCollection counterData)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, string counterName, string counterHelp)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData)
public PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp)
public void Delete(string categoryName)
public bool Exists(string categoryName)
public bool Exists(string categoryName, string machineName)
public PerformanceCounterCategory[] GetCategories()
public PerformanceCounterCategory[] GetCategories(string machineName)
public PerformanceCounter[] GetCounters()
public PerformanceCounter[] GetCounters(string instanceName)
public String[] GetInstanceNames()
public bool InstanceExists(string instanceName)
public bool InstanceExists(string instanceName, string categoryName)
public bool InstanceExists(string instanceName, string categoryName, string machineName)
public InstanceDataCollectionCollection ReadCategory()
}
public System.Diagnostics.PerformanceCounterCategoryType : Enum {
public int value__
public PerformanceCounterCategoryType SingleInstance
public PerformanceCounterCategoryType MultiInstance
public PerformanceCounterCategoryType Unknown
}
public System.Diagnostics.PerformanceCounterInstanceLifetime : Enum {
public int value__
public PerformanceCounterInstanceLifetime Global
public PerformanceCounterInstanceLifetime Process
}
public System.Diagnostics.PerformanceCounterManager : object {
private void System.Diagnostics.ICollectData.CloseData()
private void System.Diagnostics.ICollectData.CollectData(int callIdx, IntPtr valueNamePtr, IntPtr dataPtr, int totalBytes, IntPtr& res)
}
public System.Diagnostics.PerformanceCounterPermission : ResourcePermissionBase {
private PerformanceCounterPermissionEntryCollection innerCollection
public PerformanceCounterPermissionEntryCollection PermissionEntries
public void .ctor(PerformanceCounterPermissionEntry[] permissionAccessEntries)
public void .ctor(PermissionState state)
public void .ctor(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName)
public PerformanceCounterPermissionEntryCollection get_PermissionEntries()
private void SetUp()
internal ResourcePermissionBaseEntry[] GetEntries()
internal void ClearEntries()
internal void Add(object obj)
internal void Remove(object obj)
}
public System.Diagnostics.PerformanceCounterPermissionAccess : Enum {
public int value__
public PerformanceCounterPermissionAccess None
public PerformanceCounterPermissionAccess Browse
public PerformanceCounterPermissionAccess Read
public PerformanceCounterPermissionAccess Write
public PerformanceCounterPermissionAccess Instrument
public PerformanceCounterPermissionAccess Administer
}
public System.Diagnostics.PerformanceCounterPermissionAttribute : CodeAccessSecurityAttribute {
private string categoryName
private string machineName
private PerformanceCounterPermissionAccess permissionAccess
public string CategoryName
public string MachineName
public PerformanceCounterPermissionAccess PermissionAccess
public void .ctor(SecurityAction action)
public string get_CategoryName()
public void set_CategoryName(string value)
public string get_MachineName()
public void set_MachineName(string value)
public PerformanceCounterPermissionAccess get_PermissionAccess()
public void set_PermissionAccess(PerformanceCounterPermissionAccess value)
public IPermission CreatePermission()
}
public System.Diagnostics.PerformanceCounterPermissionEntry : object {
private PerformanceCounterPermissionAccess All
private PerformanceCounterPermissionAccess permissionAccess
private string machineName
private string categoryName
public string CategoryName
public string MachineName
public PerformanceCounterPermissionAccess PermissionAccess
public void .ctor(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName)
public string get_CategoryName()
public string get_MachineName()
public PerformanceCounterPermissionAccess get_PermissionAccess()
internal ResourcePermissionBaseEntry CreateResourcePermissionBaseEntry()
}
public System.Diagnostics.PerformanceCounterPermissionEntryCollection : CollectionBase {
private PerformanceCounterPermission owner
public PerformanceCounterPermissionEntry Item
internal void .ctor(PerformanceCounterPermission owner)
internal void .ctor(ResourcePermissionBaseEntry[] entries)
public PerformanceCounterPermissionEntry get_Item(int index)
public void set_Item(int index, PerformanceCounterPermissionEntry value)
public int Add(PerformanceCounterPermissionEntry value)
public void AddRange(PerformanceCounterPermissionEntry[] value)
public void AddRange(PerformanceCounterPermissionEntryCollection value)
public bool Contains(PerformanceCounterPermissionEntry value)
public void CopyTo(PerformanceCounterPermissionEntry[] array, int index)
public int IndexOf(PerformanceCounterPermissionEntry value)
public void Insert(int index, PerformanceCounterPermissionEntry value)
protected void OnClear()
protected void OnInsert(int index, object value)
protected void OnRemove(int index, object value)
protected void OnSet(int index, object oldValue, object newValue)
public void Remove(PerformanceCounterPermissionEntry value)
}
public System.Diagnostics.PerformanceCounterType : Enum {
public int value__
public PerformanceCounterType NumberOfItemsHEX32
public PerformanceCounterType NumberOfItemsHEX64
public PerformanceCounterType NumberOfItems32
public PerformanceCounterType NumberOfItems64
public PerformanceCounterType CounterDelta32
public PerformanceCounterType CounterDelta64
public PerformanceCounterType SampleCounter
public PerformanceCounterType CountPerTimeInterval32
public PerformanceCounterType CountPerTimeInterval64
public PerformanceCounterType RateOfCountsPerSecond32
public PerformanceCounterType RateOfCountsPerSecond64
public PerformanceCounterType RawFraction
public PerformanceCounterType CounterTimer
public PerformanceCounterType Timer100Ns
public PerformanceCounterType SampleFraction
public PerformanceCounterType CounterTimerInverse
public PerformanceCounterType Timer100NsInverse
public PerformanceCounterType CounterMultiTimer
public PerformanceCounterType CounterMultiTimer100Ns
public PerformanceCounterType CounterMultiTimerInverse
public PerformanceCounterType CounterMultiTimer100NsInverse
public PerformanceCounterType AverageTimer32
public PerformanceCounterType ElapsedTime
public PerformanceCounterType AverageCount64
public PerformanceCounterType SampleBase
public PerformanceCounterType AverageBase
public PerformanceCounterType RawBase
public PerformanceCounterType CounterMultiBase
}
public System.Diagnostics.Process : Component {
private IntPtr process_handle
private int pid
private bool enableRaisingEvents
private bool already_waiting
private ISynchronizeInvoke synchronizingObject
private EventHandler exited_event
private IntPtr stdout_rd
private IntPtr stderr_rd
private ProcessModuleCollection module_collection
private string process_name
private StreamReader error_stream
private StreamWriter input_stream
private StreamReader output_stream
private ProcessStartInfo start_info
private AsyncModes async_mode
private bool output_canceled
private bool error_canceled
private ProcessAsyncReader async_output
private ProcessAsyncReader async_error
private bool disposed
private DataReceivedEventHandler OutputDataReceived
private DataReceivedEventHandler ErrorDataReceived
public int BasePriority
public bool EnableRaisingEvents
public int ExitCode
public DateTime ExitTime
public IntPtr Handle
public int HandleCount
public bool HasExited
public int Id
public string MachineName
public ProcessModule MainModule
public IntPtr MainWindowHandle
public string MainWindowTitle
public IntPtr MaxWorkingSet
public IntPtr MinWorkingSet
public ProcessModuleCollection Modules
public int NonpagedSystemMemorySize
public int PagedMemorySize
public int PagedSystemMemorySize
public int PeakPagedMemorySize
public int PeakVirtualMemorySize
public int PeakWorkingSet
public long NonpagedSystemMemorySize64
public long PagedMemorySize64
public long PagedSystemMemorySize64
public long PeakPagedMemorySize64
public long PeakVirtualMemorySize64
public long PeakWorkingSet64
public bool PriorityBoostEnabled
public ProcessPriorityClass PriorityClass
public int PrivateMemorySize
public int SessionId
public TimeSpan PrivilegedProcessorTime
public string ProcessName
public IntPtr ProcessorAffinity
public bool Responding
public StreamReader StandardError
public StreamWriter StandardInput
public StreamReader StandardOutput
public ProcessStartInfo StartInfo
public DateTime StartTime
public ISynchronizeInvoke SynchronizingObject
public ProcessThreadCollection Threads
public TimeSpan TotalProcessorTime
public TimeSpan UserProcessorTime
public int VirtualMemorySize
public int WorkingSet
public long PrivateMemorySize64
public long VirtualMemorySize64
public long WorkingSet64
private bool IsWindows
private void .ctor(IntPtr handle, int id)
public void add_OutputDataReceived(DataReceivedEventHandler value)
public void remove_OutputDataReceived(DataReceivedEventHandler value)
public void add_ErrorDataReceived(DataReceivedEventHandler value)
public void remove_ErrorDataReceived(DataReceivedEventHandler value)
public void add_Exited(EventHandler value)
public void remove_Exited(EventHandler value)
public int get_BasePriority()
private void StartExitCallbackIfNeeded()
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
private int ExitCode_internal(IntPtr handle)
public int get_ExitCode()
private long ExitTime_internal(IntPtr handle)
public DateTime get_ExitTime()
public IntPtr get_Handle()
public int get_HandleCount()
public bool get_HasExited()
public int get_Id()
public string get_MachineName()
public ProcessModule get_MainModule()
public IntPtr get_MainWindowHandle()
public string get_MainWindowTitle()
private bool GetWorkingSet_internal(IntPtr handle, Int32& min, Int32& max)
private bool SetWorkingSet_internal(IntPtr handle, int min, int max, bool use_min)
public IntPtr get_MaxWorkingSet()
public void set_MaxWorkingSet(IntPtr value)
public IntPtr get_MinWorkingSet()
public void set_MinWorkingSet(IntPtr value)
private ProcessModule[] GetModules_internal(IntPtr handle)
public ProcessModuleCollection get_Modules()
private long GetProcessData(int pid, int data_type, Int32& error)
public int get_NonpagedSystemMemorySize()
public int get_PagedMemorySize()
public int get_PagedSystemMemorySize()
public int get_PeakPagedMemorySize()
public int get_PeakVirtualMemorySize()
public int get_PeakWorkingSet()
public long get_NonpagedSystemMemorySize64()
public long get_PagedMemorySize64()
public long get_PagedSystemMemorySize64()
public long get_PeakPagedMemorySize64()
public long get_PeakVirtualMemorySize64()
public long get_PeakWorkingSet64()
public bool get_PriorityBoostEnabled()
public void set_PriorityBoostEnabled(bool value)
public ProcessPriorityClass get_PriorityClass()
public void set_PriorityClass(ProcessPriorityClass value)
private int GetPriorityClass(IntPtr handle, Int32& error)
private bool SetPriorityClass(IntPtr handle, int priority, Int32& error)
public int get_PrivateMemorySize()
public int get_SessionId()
private long Times(IntPtr handle, int type)
public TimeSpan get_PrivilegedProcessorTime()
private string ProcessName_internal(IntPtr handle)
public string get_ProcessName()
public IntPtr get_ProcessorAffinity()
public void set_ProcessorAffinity(IntPtr value)
public bool get_Responding()
public StreamReader get_StandardError()
public StreamWriter get_StandardInput()
public StreamReader get_StandardOutput()
public ProcessStartInfo get_StartInfo()
public void set_StartInfo(ProcessStartInfo value)
private long StartTime_internal(IntPtr handle)
public DateTime get_StartTime()
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public ProcessThreadCollection get_Threads()
public TimeSpan get_TotalProcessorTime()
public TimeSpan get_UserProcessorTime()
public int get_VirtualMemorySize()
public int get_WorkingSet()
public long get_PrivateMemorySize64()
public long get_VirtualMemorySize64()
public long get_WorkingSet64()
public void Close()
private bool Kill_internal(IntPtr handle, int signo)
private bool Close(int signo)
public bool CloseMainWindow()
public void EnterDebugMode()
private IntPtr GetProcess_internal(int pid)
private int GetPid_internal()
public Process GetCurrentProcess()
public Process GetProcessById(int processId)
public Process GetProcessById(int processId, string machineName)
private Int32[] GetProcesses_internal()
public Process[] GetProcesses()
public Process[] GetProcesses(string machineName)
public Process[] GetProcessesByName(string processName)
public Process[] GetProcessesByName(string processName, string machineName)
public void Kill()
public void LeaveDebugMode()
public void Refresh()
private bool ShellExecuteEx_internal(ProcessStartInfo startInfo, ProcInfo& proc_info)
private bool CreateProcess_internal(ProcessStartInfo startInfo, IntPtr stdin, IntPtr stdout, IntPtr stderr, ProcInfo& proc_info)
private bool Start_shell(ProcessStartInfo startInfo, Process process)
private bool Start_noshell(ProcessStartInfo startInfo, Process process)
private void FillUserInfo(ProcessStartInfo startInfo, ProcInfo& proc_info)
private bool Start_common(ProcessStartInfo startInfo, Process process)
public bool Start()
public Process Start(ProcessStartInfo startInfo)
public Process Start(string fileName)
public Process Start(string fileName, string arguments)
public Process Start(string fileName, string username, SecureString password, string domain)
public Process Start(string fileName, string arguments, string username, SecureString password, string domain)
public string ToString()
private bool WaitForExit_internal(IntPtr handle, int ms)
public void WaitForExit()
public bool WaitForExit(int milliseconds)
private bool WaitForInputIdle_internal(IntPtr handle, int ms)
public bool WaitForInputIdle()
public bool WaitForInputIdle(int milliseconds)
private bool IsLocalMachine(string machineName)
private void OnOutputDataReceived(string str)
private void OnErrorDataReceived(string str)
public void BeginOutputReadLine()
public void CancelOutputRead()
public void BeginErrorReadLine()
public void CancelErrorRead()
private void Process_free_internal(IntPtr handle)
protected void Dispose(bool disposing)
protected void Finalize()
private void CBOnExit(object state, bool unused)
protected void OnExited()
private bool get_IsWindows()
}
public System.Diagnostics.ProcessModule : Component {
private IntPtr baseaddr
private IntPtr entryaddr
private string filename
private FileVersionInfo version_info
private int memory_size
private string modulename
public IntPtr BaseAddress
public IntPtr EntryPointAddress
public string FileName
public FileVersionInfo FileVersionInfo
public int ModuleMemorySize
public string ModuleName
internal void .ctor(IntPtr baseaddr, IntPtr entryaddr, string filename, FileVersionInfo version_info, int memory_size, string modulename)
public IntPtr get_BaseAddress()
public IntPtr get_EntryPointAddress()
public string get_FileName()
public FileVersionInfo get_FileVersionInfo()
public int get_ModuleMemorySize()
public string get_ModuleName()
public string ToString()
}
public System.Diagnostics.ProcessModuleCollection : ReadOnlyCollectionBase {
public ProcessModule Item
public void .ctor(ProcessModule[] processModules)
public ProcessModule get_Item(int index)
public bool Contains(ProcessModule module)
public void CopyTo(ProcessModule[] array, int index)
public int IndexOf(ProcessModule module)
}
public System.Diagnostics.ProcessPriorityClass : Enum {
public int value__
public ProcessPriorityClass AboveNormal
public ProcessPriorityClass BelowNormal
public ProcessPriorityClass High
public ProcessPriorityClass Idle
public ProcessPriorityClass Normal
public ProcessPriorityClass RealTime
}
public System.Diagnostics.ProcessStartInfo : object {
private string arguments
private IntPtr error_dialog_parent_handle
private string filename
private string verb
private string working_directory
private ProcessStringDictionary envVars
private bool create_no_window
private bool error_dialog
private bool redirect_standard_error
private bool redirect_standard_input
private bool redirect_standard_output
private bool use_shell_execute
private ProcessWindowStyle window_style
private Encoding encoding_stderr
private Encoding encoding_stdout
private string username
private string domain
private SecureString password
private bool load_user_profile
private String[] empty
public string Arguments
public bool CreateNoWindow
public StringDictionary EnvironmentVariables
internal bool HaveEnvVars
public bool ErrorDialog
public IntPtr ErrorDialogParentHandle
public string FileName
public bool RedirectStandardError
public bool RedirectStandardInput
public bool RedirectStandardOutput
public Encoding StandardErrorEncoding
public Encoding StandardOutputEncoding
public bool UseShellExecute
public string Verb
public String[] Verbs
public ProcessWindowStyle WindowStyle
public string WorkingDirectory
public bool LoadUserProfile
public string UserName
public string Domain
public SecureString Password
public void .ctor(string filename)
public void .ctor(string filename, string arguments)
public string get_Arguments()
public void set_Arguments(string value)
public bool get_CreateNoWindow()
public void set_CreateNoWindow(bool value)
public StringDictionary get_EnvironmentVariables()
internal bool get_HaveEnvVars()
public bool get_ErrorDialog()
public void set_ErrorDialog(bool value)
public IntPtr get_ErrorDialogParentHandle()
public void set_ErrorDialogParentHandle(IntPtr value)
public string get_FileName()
public void set_FileName(string value)
public bool get_RedirectStandardError()
public void set_RedirectStandardError(bool value)
public bool get_RedirectStandardInput()
public void set_RedirectStandardInput(bool value)
public bool get_RedirectStandardOutput()
public void set_RedirectStandardOutput(bool value)
public Encoding get_StandardErrorEncoding()
public void set_StandardErrorEncoding(Encoding value)
public Encoding get_StandardOutputEncoding()
public void set_StandardOutputEncoding(Encoding value)
public bool get_UseShellExecute()
public void set_UseShellExecute(bool value)
public string get_Verb()
public void set_Verb(string value)
public String[] get_Verbs()
public ProcessWindowStyle get_WindowStyle()
public void set_WindowStyle(ProcessWindowStyle value)
public string get_WorkingDirectory()
public void set_WorkingDirectory(string value)
public bool get_LoadUserProfile()
public void set_LoadUserProfile(bool value)
public string get_UserName()
public void set_UserName(string value)
public string get_Domain()
public void set_Domain(string value)
public SecureString get_Password()
public void set_Password(SecureString value)
}
public System.Diagnostics.ProcessThread : Component {
public int BasePriority
public int CurrentPriority
public int Id
public int IdealProcessor
public bool PriorityBoostEnabled
public ThreadPriorityLevel PriorityLevel
public TimeSpan PrivilegedProcessorTime
public IntPtr ProcessorAffinity
public IntPtr StartAddress
public DateTime StartTime
public ThreadState ThreadState
public TimeSpan TotalProcessorTime
public TimeSpan UserProcessorTime
public ThreadWaitReason WaitReason
public int get_BasePriority()
public int get_CurrentPriority()
public int get_Id()
public void set_IdealProcessor(int value)
public bool get_PriorityBoostEnabled()
public void set_PriorityBoostEnabled(bool value)
public ThreadPriorityLevel get_PriorityLevel()
public void set_PriorityLevel(ThreadPriorityLevel value)
public TimeSpan get_PrivilegedProcessorTime()
public void set_ProcessorAffinity(IntPtr value)
public IntPtr get_StartAddress()
public DateTime get_StartTime()
public ThreadState get_ThreadState()
public TimeSpan get_TotalProcessorTime()
public TimeSpan get_UserProcessorTime()
public ThreadWaitReason get_WaitReason()
public void ResetIdealProcessor()
}
public System.Diagnostics.ProcessThreadCollection : ReadOnlyCollectionBase {
public ProcessThread Item
public void .ctor(ProcessThread[] processThreads)
internal ProcessThreadCollection GetEmpty()
public ProcessThread get_Item(int index)
public int Add(ProcessThread thread)
public bool Contains(ProcessThread thread)
public void CopyTo(ProcessThread[] array, int index)
public int IndexOf(ProcessThread thread)
public void Insert(int index, ProcessThread thread)
public void Remove(ProcessThread thread)
}
public System.Diagnostics.ProcessWindowStyle : Enum {
public int value__
public ProcessWindowStyle Hidden
public ProcessWindowStyle Maximized
public ProcessWindowStyle Minimized
public ProcessWindowStyle Normal
}
public System.Diagnostics.SourceFilter : TraceFilter {
private string source
public string Source
public void .ctor(string source)
public string get_Source()
public void set_Source(string value)
public bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data)
}
public System.Diagnostics.SourceLevels : Enum {
public int value__
public SourceLevels Off
public SourceLevels Critical
public SourceLevels Error
public SourceLevels Warning
public SourceLevels Information
public SourceLevels Verbose
public SourceLevels ActivityTracing
public SourceLevels All
}
public System.Diagnostics.SourceSwitch : Switch {
private string description
public SourceLevels Level
public void .ctor(string displayName)
public void .ctor(string displayName, string defaultSwitchValue)
public SourceLevels get_Level()
public void set_Level(SourceLevels value)
public bool ShouldTrace(TraceEventType eventType)
protected void OnValueChanged()
}
public System.Diagnostics.Stopwatch : object {
public long Frequency
public bool IsHighResolution
private long elapsed
private long started
private bool is_running
public TimeSpan Elapsed
public long ElapsedMilliseconds
public long ElapsedTicks
public bool IsRunning
public long GetTimestamp()
public Stopwatch StartNew()
public TimeSpan get_Elapsed()
public long get_ElapsedMilliseconds()
public long get_ElapsedTicks()
public bool get_IsRunning()
public void Reset()
public void Start()
public void Stop()
}
public System.Diagnostics.Switch : object {
private string name
private string description
private int switchSetting
private string value
private string defaultSwitchValue
private bool initialized
private StringDictionary attributes
public string Description
public string DisplayName
protected int SwitchSetting
public StringDictionary Attributes
protected string Value
protected void .ctor(string displayName, string description)
protected void .ctor(string displayName, string description, string defaultSwitchValue)
public string get_Description()
public string get_DisplayName()
protected int get_SwitchSetting()
protected void set_SwitchSetting(int value)
public StringDictionary get_Attributes()
protected string get_Value()
protected void set_Value(string value)
protected internal String[] GetSupportedAttributes()
protected void OnValueChanged()
private void GetConfigFileSetting()
protected void OnSwitchSettingChanged()
}
public System.Diagnostics.SwitchAttribute : Attribute {
private string name
private string desc
private Type type
public string SwitchName
public string SwitchDescription
public Type SwitchType
public void .ctor(string switchName, Type switchType)
public SwitchAttribute[] GetAll(Assembly assembly)
public string get_SwitchName()
public void set_SwitchName(string value)
public string get_SwitchDescription()
public void set_SwitchDescription(string value)
public Type get_SwitchType()
public void set_SwitchType(Type value)
}
public System.Diagnostics.SwitchLevelAttribute : Attribute {
private Type type
public Type SwitchLevelType
public void .ctor(Type switchLevelType)
public Type get_SwitchLevelType()
public void set_SwitchLevelType(Type value)
}
public System.Diagnostics.TextWriterTraceListener : TraceListener {
private TextWriter writer
public TextWriter Writer
public void .ctor(Stream stream)
public void .ctor(string fileName)
public void .ctor(TextWriter writer)
public void .ctor(Stream stream, string name)
public void .ctor(string fileName, string name)
public void .ctor(TextWriter writer, string name)
public TextWriter get_Writer()
public void set_Writer(TextWriter value)
public void Close()
protected void Dispose(bool disposing)
public void Flush()
public void Write(string message)
public void WriteLine(string message)
}
public System.Diagnostics.ThreadPriorityLevel : Enum {
public int value__
public ThreadPriorityLevel AboveNormal
public ThreadPriorityLevel BelowNormal
public ThreadPriorityLevel Highest
public ThreadPriorityLevel Idle
public ThreadPriorityLevel Lowest
public ThreadPriorityLevel Normal
public ThreadPriorityLevel TimeCritical
}
public System.Diagnostics.ThreadState : Enum {
public int value__
public ThreadState Initialized
public ThreadState Ready
public ThreadState Running
public ThreadState Standby
public ThreadState Terminated
public ThreadState Transition
public ThreadState Unknown
public ThreadState Wait
}
public System.Diagnostics.ThreadWaitReason : Enum {
public int value__
public ThreadWaitReason EventPairHigh
public ThreadWaitReason EventPairLow
public ThreadWaitReason ExecutionDelay
public ThreadWaitReason Executive
public ThreadWaitReason FreePage
public ThreadWaitReason LpcReceive
public ThreadWaitReason LpcReply
public ThreadWaitReason PageIn
public ThreadWaitReason PageOut
public ThreadWaitReason Suspended
public ThreadWaitReason SystemAllocation
public ThreadWaitReason Unknown
public ThreadWaitReason UserRequest
public ThreadWaitReason VirtualMemory
}
public System.Diagnostics.Trace : object {
public bool AutoFlush
public int IndentLevel
public int IndentSize
public TraceListenerCollection Listeners
public CorrelationManager CorrelationManager
public bool UseGlobalLock
public void Refresh()
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public TraceListenerCollection get_Listeners()
public CorrelationManager get_CorrelationManager()
public bool get_UseGlobalLock()
public void set_UseGlobalLock(bool value)
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Close()
public void Fail(string message)
public void Fail(string message, string detailMessage)
public void Flush()
public void Indent()
public void Unindent()
public void Write(object value)
public void Write(string message)
public void Write(object value, string category)
public void Write(string message, string category)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value, string category)
public void WriteIf(bool condition, string message, string category)
public void WriteLine(object value)
public void WriteLine(string message)
public void WriteLine(object value, string category)
public void WriteLine(string message, string category)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message, string category)
private void DoTrace(string kind, Assembly report, string message)
public void TraceError(string message)
public void TraceError(string message, Object[] args)
public void TraceInformation(string message)
public void TraceInformation(string message, Object[] args)
public void TraceWarning(string message)
public void TraceWarning(string message, Object[] args)
}
public System.Diagnostics.TraceEventCache : object {
private DateTime started
private CorrelationManager manager
private string callstack
private string thread
private int process
private long timestamp
public string Callstack
public DateTime DateTime
public Stack LogicalOperationStack
public int ProcessId
public string ThreadId
public long Timestamp
public string get_Callstack()
public DateTime get_DateTime()
public Stack get_LogicalOperationStack()
public int get_ProcessId()
public string get_ThreadId()
public long get_Timestamp()
}
public System.Diagnostics.TraceEventType : Enum {
public int value__
public TraceEventType Critical
public TraceEventType Error
public TraceEventType Warning
public TraceEventType Information
public TraceEventType Verbose
public TraceEventType Start
public TraceEventType Stop
public TraceEventType Suspend
public TraceEventType Resume
public TraceEventType Transfer
}
public System.Diagnostics.TraceFilter : object {
public bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data)
}
internal System.Diagnostics.TraceImpl : object {
private object initLock
private bool autoFlush
private int indentLevel
private int indentSize
private TraceListenerCollection listeners
private bool use_global_lock
private CorrelationManager correlation_manager
public bool AutoFlush
public int IndentLevel
public int IndentSize
public TraceListenerCollection Listeners
private object ListenersSyncRoot
public CorrelationManager CorrelationManager
public bool UseGlobalLock
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public TraceListenerCollection get_Listeners()
private object get_ListenersSyncRoot()
public CorrelationManager get_CorrelationManager()
public bool get_UseGlobalLock()
public void set_UseGlobalLock(bool value)
private void InitOnce()
public void Assert(bool condition)
public void Assert(bool condition, string message)
public void Assert(bool condition, string message, string detailMessage)
public void Close()
public void Fail(string message)
public void Fail(string message, string detailMessage)
public void Flush()
public void Indent()
public void Unindent()
public void Write(object value)
public void Write(string message)
public void Write(object value, string category)
public void Write(string message, string category)
public void WriteIf(bool condition, object value)
public void WriteIf(bool condition, string message)
public void WriteIf(bool condition, object value, string category)
public void WriteIf(bool condition, string message, string category)
public void WriteLine(object value)
public void WriteLine(string message)
public void WriteLine(object value, string category)
public void WriteLine(string message, string category)
public void WriteLineIf(bool condition, object value)
public void WriteLineIf(bool condition, string message)
public void WriteLineIf(bool condition, object value, string category)
public void WriteLineIf(bool condition, string message, string category)
}
internal System.Diagnostics.TraceImplSettings : object {
public string Key
public bool AutoFlush
public int IndentLevel
public int IndentSize
public TraceListenerCollection Listeners
}
public System.Diagnostics.TraceLevel : Enum {
public int value__
public TraceLevel Off
public TraceLevel Error
public TraceLevel Warning
public TraceLevel Info
public TraceLevel Verbose
}
public System.Diagnostics.TraceListener : MarshalByRefObject {
private int indentLevel
private int indentSize
private StringDictionary attributes
private TraceFilter filter
private TraceOptions options
private string name
private bool needIndent
public int IndentLevel
public int IndentSize
public string Name
protected bool NeedIndent
public bool IsThreadSafe
public StringDictionary Attributes
public TraceFilter Filter
public TraceOptions TraceOutputOptions
protected void .ctor(string name)
public int get_IndentLevel()
public void set_IndentLevel(int value)
public int get_IndentSize()
public void set_IndentSize(int value)
public string get_Name()
public void set_Name(string value)
protected bool get_NeedIndent()
protected void set_NeedIndent(bool value)
public bool get_IsThreadSafe()
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
public void Fail(string message)
public void Fail(string message, string detailMessage)
public void Flush()
public void Write(object o)
public void Write(string message)
public void Write(object o, string category)
public void Write(string message, string category)
protected void WriteIndent()
public void WriteLine(object o)
public void WriteLine(string message)
public void WriteLine(object o, string category)
public void WriteLine(string message, string category)
internal string FormatArray(ICollection list, string joiner)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
public void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId)
protected internal String[] GetSupportedAttributes()
public StringDictionary get_Attributes()
public TraceFilter get_Filter()
public void set_Filter(TraceFilter value)
public TraceOptions get_TraceOutputOptions()
public void set_TraceOutputOptions(TraceOptions value)
}
public System.Diagnostics.TraceListenerCollection : object {
private ArrayList listeners
private object System.Collections.IList.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
public int Count
public TraceListener Item
public TraceListener Item
internal void .ctor(bool addDefault)
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
public int get_Count()
public TraceListener get_Item(string name)
public TraceListener get_Item(int index)
public void set_Item(int index, TraceListener value)
public int Add(TraceListener listener)
internal void Add(TraceListener listener, TraceImplSettings settings)
private void InitializeListener(TraceListener listener)
private void InitializeRange(IList listeners)
public void AddRange(TraceListener[] value)
public void AddRange(TraceListenerCollection value)
public void Clear()
public bool Contains(TraceListener listener)
public void CopyTo(TraceListener[] listeners, int index)
public IEnumerator GetEnumerator()
public int IndexOf(TraceListener listener)
public void Insert(int index, TraceListener listener)
public void Remove(string name)
public void Remove(TraceListener listener)
public void RemoveAt(int index)
}
public System.Diagnostics.TraceOptions : Enum {
public int value__
public TraceOptions None
public TraceOptions LogicalOperationStack
public TraceOptions DateTime
public TraceOptions Timestamp
public TraceOptions ProcessId
public TraceOptions ThreadId
public TraceOptions Callstack
}
public System.Diagnostics.TraceSource : object {
private SourceSwitch source_switch
private TraceListenerCollection listeners
public StringDictionary Attributes
public TraceListenerCollection Listeners
public string Name
public SourceSwitch Switch
public void .ctor(string name)
public void .ctor(string name, SourceLevels sourceLevels)
public StringDictionary get_Attributes()
public TraceListenerCollection get_Listeners()
public string get_Name()
public SourceSwitch get_Switch()
public void set_Switch(SourceSwitch value)
public void Close()
public void Flush()
public void TraceData(TraceEventType eventType, int id, object data)
public void TraceData(TraceEventType eventType, int id, Object[] data)
public void TraceEvent(TraceEventType eventType, int id)
public void TraceEvent(TraceEventType eventType, int id, string message)
public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args)
public void TraceInformation(string format)
public void TraceInformation(string format, Object[] args)
public void TraceTransfer(int id, string message, Guid relatedActivityId)
protected String[] GetSupportedAttributes()
}
internal System.Diagnostics.TraceSourceInfo : object {
private string name
private SourceLevels levels
private TraceListenerCollection listeners
public string Name
public SourceLevels Levels
public TraceListenerCollection Listeners
public void .ctor(string name, SourceLevels levels)
internal void .ctor(string name, SourceLevels levels, TraceImplSettings settings)
public string get_Name()
public SourceLevels get_Levels()
public TraceListenerCollection get_Listeners()
}
public System.Diagnostics.TraceSwitch : Switch {
public TraceLevel Level
public bool TraceError
public bool TraceWarning
public bool TraceInfo
public bool TraceVerbose
public void .ctor(string displayName, string description)
public void .ctor(string displayName, string description, string defaultSwitchValue)
public TraceLevel get_Level()
public void set_Level(TraceLevel value)
public bool get_TraceError()
public bool get_TraceWarning()
public bool get_TraceInfo()
public bool get_TraceVerbose()
protected void OnSwitchSettingChanged()
protected void OnValueChanged()
}
internal System.Diagnostics.Win32EventLog : EventLogImpl {
private int MESSAGE_NOT_FOUND
private ManualResetEvent _notifyResetEvent
private IntPtr _readHandle
private Thread _notifyThread
private int _lastEntryWritten
private bool _notifying
private int OldestEventLogEntry
private IntPtr ReadHandle
public OverflowAction OverflowAction
public int MinimumRetentionDays
public long MaximumKilobytes
public void .ctor(EventLog coreEventLog)
public void BeginInit()
public void Clear()
public void Close()
public void CreateEventSource(EventSourceCreationData sourceData)
public void Delete(string logName, string machineName)
public void DeleteEventSource(string source, string machineName)
public void Dispose(bool disposing)
public void EndInit()
public bool Exists(string logName, string machineName)
protected string FormatMessage(string source, UInt32 messageID, String[] replacementStrings)
private string FormatCategory(string source, int category)
protected int GetEntryCount()
protected EventLogEntry GetEntry(int index)
protected string GetLogDisplayName()
protected String[] GetLogNames(string machineName)
public string LogNameFromSourceName(string source, string machineName)
public bool SourceExists(string source, string machineName)
public void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData)
private void UpdateLogRegistry(RegistryKey logKey)
private void UpdateSourceRegistry(RegistryKey sourceKey, EventSourceCreationData data)
private string GetLogName(RegistryKey logKey)
private void ReadEventLog(int index, Byte[] buffer, Int32& bytesRead, Int32& minBufferNeeded)
private RegistryKey GetEventLogKey(string machineName, bool writable)
private RegistryKey FindSourceKeyByName(string source, string machineName, bool writable)
private RegistryKey FindLogKeyByName(string logName, string machineName, bool writable)
private RegistryKey FindLogKeyBySource(string source, string machineName, bool writable)
private int get_OldestEventLogEntry()
private void CloseEventLog(IntPtr hEventLog)
private void DeregisterEventSource(IntPtr hEventLog)
private string LookupAccountSid(string machineName, Byte[] sid)
private string FetchMessage(string msgDll, UInt32 messageID, String[] replacementStrings)
private String[] GetMessageResourceDlls(string source, string valueName)
private IntPtr get_ReadHandle()
private IntPtr RegisterEventSource()
public void DisableNotification()
public void EnableNotification()
private void NotifyEventThread()
public OverflowAction get_OverflowAction()
public int get_MinimumRetentionDays()
public long get_MaximumKilobytes()
public void set_MaximumKilobytes(long value)
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays)
public void RegisterDisplayName(string resourceFile, long resourceId)
}
public System.Diagnostics.XmlWriterTraceListener : TextWriterTraceListener {
private string e2e_ns
private string sys_ns
private string default_name
private XmlWriter w
public void .ctor(string filename)
public void .ctor(string filename, string name)
public void .ctor(Stream stream)
public void .ctor(Stream writer, string name)
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, string name)
public void Close()
public void Fail(string message, string detailMessage)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)
public void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
public void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args)
public void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId)
public void Write(string message)
public void WriteLine(string message)
private void TraceCore(TraceEventCache eventCache, string source, TraceEventType eventType, int id, bool hasRelatedActivity, Guid relatedActivity, int level, bool wrapData, Object[] data)
}
public System.GenericUriParser : UriParser {
public void .ctor(GenericUriParserOptions options)
}
public System.GenericUriParserOptions : Enum {
public int value__
public GenericUriParserOptions Default
public GenericUriParserOptions GenericAuthority
public GenericUriParserOptions AllowEmptyAuthority
public GenericUriParserOptions NoUserInfo
public GenericUriParserOptions NoPort
public GenericUriParserOptions NoQuery
public GenericUriParserOptions NoFragment
public GenericUriParserOptions DontConvertPathBackslashes
public GenericUriParserOptions DontCompressPath
public GenericUriParserOptions DontUnescapePathDotsAndSlashes
public GenericUriParserOptions Idn
public GenericUriParserOptions IriParsing
}
public System.IO.Compression.CompressionMode : Enum {
public int value__
public CompressionMode Decompress
public CompressionMode Compress
}
public System.IO.Compression.DeflateStream : Stream {
private int BufferSize
private string LIBNAME
private Stream base_stream
private CompressionMode mode
private bool leaveOpen
private bool disposed
private UnmanagedReadOrWrite feeder
private IntPtr z_stream
private Byte[] io_buffer
private GCHandle data
public Stream BaseStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(Stream compressedStream, CompressionMode mode)
public void .ctor(Stream compressedStream, CompressionMode mode, bool leaveOpen)
internal void .ctor(Stream compressedStream, CompressionMode mode, bool leaveOpen, bool gzip)
protected void Dispose(bool disposing)
private int UnmanagedRead(IntPtr buffer, int length, IntPtr data)
private int UnmanagedRead(IntPtr buffer, int length)
private int UnmanagedWrite(IntPtr buffer, int length, IntPtr data)
private int UnmanagedWrite(IntPtr buffer, int length)
private int ReadInternal(Byte[] array, int offset, int count)
public int Read(Byte[] dest, int dest_offset, int count)
private void WriteInternal(Byte[] array, int offset, int count)
public void Write(Byte[] src, int src_offset, int count)
private void CheckResult(int result, string where)
public void Flush()
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public int EndRead(IAsyncResult async_result)
public void EndWrite(IAsyncResult async_result)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public Stream get_BaseStream()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
private IntPtr CreateZStream(CompressionMode compress, bool gzip, UnmanagedReadOrWrite feeder, IntPtr data)
private int CloseZStream(IntPtr stream)
private int Flush(IntPtr stream)
private int ReadZStream(IntPtr stream, IntPtr buffer, int length)
private int WriteZStream(IntPtr stream, IntPtr buffer, int length)
}
public System.IO.Compression.GZipStream : Stream {
private DeflateStream deflateStream
public Stream BaseStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(Stream compressedStream, CompressionMode mode)
public void .ctor(Stream compressedStream, CompressionMode mode, bool leaveOpen)
protected void Dispose(bool disposing)
public int Read(Byte[] dest, int dest_offset, int count)
public void Write(Byte[] src, int src_offset, int count)
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public int EndRead(IAsyncResult async_result)
public void EndWrite(IAsyncResult async_result)
public Stream get_BaseStream()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
}
internal System.IO.DefaultWatcher : object {
private DefaultWatcher instance
private Thread thread
private Hashtable watches
private String[] NoStringsArray
public bool GetInstance(IFileWatcher& watcher)
public void StartDispatching(FileSystemWatcher fsw)
public void StopDispatching(FileSystemWatcher fsw)
private void Monitor()
private bool UpdateDataAndDispatch(DefaultWatcherData data, bool dispatch)
private void DispatchEvents(FileSystemWatcher fsw, FileAction action, string filename)
private void DoFiles(DefaultWatcherData data, string directory, bool dispatch)
private FileData CreateFileData(string directory, string filename)
}
internal System.IO.DefaultWatcherData : object {
public FileSystemWatcher FSW
public string Directory
public string FileMask
public bool IncludeSubdirs
public bool Enabled
public bool NoWildcards
public DateTime DisabledTime
public Hashtable Files
}
public System.IO.ErrorEventArgs : EventArgs {
private Exception exception
public void .ctor(Exception exception)
public Exception GetException()
}
public System.IO.ErrorEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ErrorEventArgs e)
public IAsyncResult BeginInvoke(object sender, ErrorEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.IO.FAMCodes : Enum {
public int value__
public FAMCodes Changed
public FAMCodes Deleted
public FAMCodes StartExecuting
public FAMCodes StopExecuting
public FAMCodes Created
public FAMCodes Moved
public FAMCodes Acknowledge
public FAMCodes Exists
public FAMCodes EndExist
}
internal System.IO.FAMConnection : ValueType {
public int FD
public IntPtr opaque
}
internal System.IO.FAMData : object {
public FileSystemWatcher FSW
public string Directory
public string FileMask
public bool IncludeSubdirs
public bool Enabled
public FAMRequest Request
public Hashtable SubDirs
}
internal System.IO.FAMRequest : ValueType {
public int ReqNum
}
internal System.IO.FAMWatcher : object {
private NotifyFilters changed
private bool failed
private FAMWatcher instance
private Hashtable watches
private Hashtable requests
private FAMConnection conn
private Thread thread
private bool stop
private bool use_gamin
public bool GetInstance(IFileWatcher& watcher, bool gamin)
public void StartDispatching(FileSystemWatcher fsw)
private void StartMonitoringDirectory(FAMData data, bool justcreated)
public void StopDispatching(FileSystemWatcher fsw)
private void StopMonitoringDirectory(FAMData data)
private void Monitor()
private void ProcessEvents()
protected void Finalize()
private int FAMOpen(FAMConnection& fc)
private int FAMClose(FAMConnection& fc)
private int FAMMonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data)
private int FAMCancelMonitor(FAMConnection& fc, FAMRequest& fr)
private int FAMPending(FAMConnection& fc)
private int fam_Open(FAMConnection& fc)
private int fam_Close(FAMConnection& fc)
private int fam_MonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data)
private int fam_CancelMonitor(FAMConnection& fc, FAMRequest& fr)
private int fam_Pending(FAMConnection& fc)
private int gamin_Open(FAMConnection& fc)
private int gamin_Close(FAMConnection& fc)
private int gamin_MonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data)
private int gamin_CancelMonitor(FAMConnection& fc, FAMRequest& fr)
private int gamin_Pending(FAMConnection& fc)
private int InternalFAMNextEvent(FAMConnection& fc, String& filename, Int32& code, Int32& reqnum)
}
internal System.IO.FileAction : Enum {
public int value__
public FileAction Added
public FileAction Removed
public FileAction Modified
public FileAction RenamedOldName
public FileAction RenamedNewName
}
internal System.IO.FileData : object {
public string Directory
public FileAttributes Attributes
public bool NotExists
public DateTime CreationTime
public DateTime LastWriteTime
}
public System.IO.FileSystemEventArgs : EventArgs {
private WatcherChangeTypes changeType
private string directory
private string name
public WatcherChangeTypes ChangeType
public string FullPath
public string Name
public void .ctor(WatcherChangeTypes changeType, string directory, string name)
internal void SetName(string name)
public WatcherChangeTypes get_ChangeType()
public string get_FullPath()
public string get_Name()
}
public System.IO.FileSystemEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, FileSystemEventArgs e)
public IAsyncResult BeginInvoke(object sender, FileSystemEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.FileSystemWatcher : Component {
private bool enableRaisingEvents
private string filter
private bool includeSubdirectories
private int internalBufferSize
private NotifyFilters notifyFilter
private string path
private string fullpath
private ISynchronizeInvoke synchronizingObject
private WaitForChangedResult lastData
private bool waiting
private SearchPattern2 pattern
private bool disposed
private string mangledFilter
private IFileWatcher watcher
private object lockobj
private FileSystemEventHandler Changed
private FileSystemEventHandler Created
private FileSystemEventHandler Deleted
private ErrorEventHandler Error
private RenamedEventHandler Renamed
internal bool Waiting
internal string MangledFilter
internal SearchPattern2 Pattern
internal string FullPath
public bool EnableRaisingEvents
public string Filter
public bool IncludeSubdirectories
public int InternalBufferSize
public NotifyFilters NotifyFilter
public string Path
public ISite Site
public ISynchronizeInvoke SynchronizingObject
public void .ctor(string path)
public void .ctor(string path, string filter)
public void add_Changed(FileSystemEventHandler value)
public void remove_Changed(FileSystemEventHandler value)
public void add_Created(FileSystemEventHandler value)
public void remove_Created(FileSystemEventHandler value)
public void add_Deleted(FileSystemEventHandler value)
public void remove_Deleted(FileSystemEventHandler value)
public void add_Error(ErrorEventHandler value)
public void remove_Error(ErrorEventHandler value)
public void add_Renamed(RenamedEventHandler value)
public void remove_Renamed(RenamedEventHandler value)
private void InitWatcher()
private void ShowWatcherInfo()
internal bool get_Waiting()
internal void set_Waiting(bool value)
internal string get_MangledFilter()
internal SearchPattern2 get_Pattern()
internal string get_FullPath()
public bool get_EnableRaisingEvents()
public void set_EnableRaisingEvents(bool value)
public string get_Filter()
public void set_Filter(string value)
public bool get_IncludeSubdirectories()
public void set_IncludeSubdirectories(bool value)
public int get_InternalBufferSize()
public void set_InternalBufferSize(int value)
public NotifyFilters get_NotifyFilter()
public void set_NotifyFilter(NotifyFilters value)
public string get_Path()
public void set_Path(string value)
public ISite get_Site()
public void set_Site(ISite value)
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public void BeginInit()
protected void Dispose(bool disposing)
protected void Finalize()
public void EndInit()
private void RaiseEvent(Delegate ev, EventArgs arg, EventType evtype)
protected void OnChanged(FileSystemEventArgs e)
protected void OnCreated(FileSystemEventArgs e)
protected void OnDeleted(FileSystemEventArgs e)
protected void OnError(ErrorEventArgs e)
protected void OnRenamed(RenamedEventArgs e)
public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType)
public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout)
internal void DispatchEvents(FileAction act, string filename, RenamedEventArgs& renamed)
private void Start()
private void Stop()
private int InternalSupportsFSW()
}
internal System.IO.IFileWatcher {
public void StartDispatching(FileSystemWatcher fsw)
public void StopDispatching(FileSystemWatcher fsw)
}
internal System.IO.InotifyData : object {
public FileSystemWatcher FSW
public string Directory
public int Watch
}
internal System.IO.InotifyEvent : ValueType {
public InotifyEvent Default
public int WatchDescriptor
public InotifyMask Mask
public string Name
public string ToString()
}
internal System.IO.InotifyMask : Enum {
public UInt32 value__
public InotifyMask Access
public InotifyMask Modify
public InotifyMask Attrib
public InotifyMask CloseWrite
public InotifyMask CloseNoWrite
public InotifyMask Open
public InotifyMask MovedFrom
public InotifyMask MovedTo
public InotifyMask Create
public InotifyMask Delete
public InotifyMask DeleteSelf
public InotifyMask MoveSelf
public InotifyMask BaseEvents
public InotifyMask Umount
public InotifyMask Overflow
public InotifyMask Ignored
public InotifyMask OnlyDir
public InotifyMask DontFollow
public InotifyMask AddMask
public InotifyMask Directory
public InotifyMask OneShot
}
internal System.IO.InotifyWatcher : object {
private bool failed
private InotifyWatcher instance
private Hashtable watches
private Hashtable requests
private IntPtr FD
private Thread thread
private bool stop
private InotifyMask Interesting
public bool GetInstance(IFileWatcher& watcher, bool gamin)
public void StartDispatching(FileSystemWatcher fsw)
private void AppendRequestData(InotifyData data)
private bool RemoveRequestData(InotifyData data)
private InotifyMask GetMaskFromFilters(NotifyFilters filters)
private void StartMonitoringDirectory(InotifyData data, bool justcreated)
public void StopDispatching(FileSystemWatcher fsw)
private void StopMonitoringDirectory(InotifyData data)
private void Monitor()
private int ReadEvent(Byte[] source, int off, int size, InotifyEvent& evt)
private IEnumerable GetEnumerator(object source)
private void ProcessEvents(Byte[] buffer, int length)
private int AddDirectoryWatch(IntPtr fd, string directory, InotifyMask mask)
internal int Close(IntPtr fd)
private int ReadFromFD(IntPtr fd, Byte[] buffer, IntPtr length)
private IntPtr GetInotifyInstance()
private int AddWatch(IntPtr fd, string name, InotifyMask mask)
private IntPtr RemoveWatch(IntPtr fd, int wd)
}
public System.IO.InternalBufferOverflowException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.IO.InvalidDataException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
private void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.IODescriptionAttribute : DescriptionAttribute {
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.IO.kevent : ValueType {
public int ident
public short filter
public ushort flags
public UInt32 fflags
public int data
public IntPtr udata
public void Dispose()
}
internal System.IO.KeventData : object {
public FileSystemWatcher FSW
public string Directory
public string FileMask
public bool IncludeSubdirs
public bool Enabled
public Hashtable DirEntries
public kevent ev
}
internal System.IO.KeventFileData : object {
public FileSystemInfo fsi
public DateTime LastAccessTime
public DateTime LastWriteTime
public void .ctor(FileSystemInfo fsi, DateTime LastAccessTime, DateTime LastWriteTime)
}
internal System.IO.KeventWatcher : object {
private bool failed
private KeventWatcher instance
private Hashtable watches
private Hashtable requests
private Thread thread
private int conn
private bool stop
public bool GetInstance(IFileWatcher& watcher)
public void StartDispatching(FileSystemWatcher fsw)
private void StartMonitoringDirectory(KeventData data)
public void StopDispatching(FileSystemWatcher fsw)
private void StopMonitoringDirectory(KeventData data)
private void Monitor()
private void ProcessEvent(kevent ev)
private void PostEvent(string filename, FileSystemWatcher fsw, FileAction fa, FileSystemInfo changedFsi)
private int open(string path, int flags, int mode_t)
private int close(int fd)
private int kqueue()
private int kevent(int kqueue, kevent& ev, int nchanges, kevent& evtlist, int nevents, timespec& ts)
}
internal System.IO.MonoIO : object {
public IntPtr ConsoleOutput
public IntPtr ConsoleInput
public IntPtr ConsoleError
public bool Close(IntPtr handle, MonoIOError& error)
public IntPtr get_ConsoleOutput()
public IntPtr get_ConsoleInput()
public IntPtr get_ConsoleError()
public bool CreatePipe(IntPtr& read_handle, IntPtr& write_handle)
public bool DuplicateHandle(IntPtr source_process_handle, IntPtr source_handle, IntPtr target_process_handle, IntPtr& target_handle, int access, int inherit, int options)
public int GetTempPath(String& path)
}
internal System.IO.MonoIOError : Enum {
public int value__
public MonoIOError ERROR_SUCCESS
public MonoIOError ERROR_INVALID_FUNCTION
public MonoIOError ERROR_FILE_NOT_FOUND
public MonoIOError ERROR_PATH_NOT_FOUND
public MonoIOError ERROR_TOO_MANY_OPEN_FILES
public MonoIOError ERROR_ACCESS_DENIED
public MonoIOError ERROR_INVALID_HANDLE
public MonoIOError ERROR_ARENA_TRASHED
public MonoIOError ERROR_NOT_ENOUGH_MEMORY
public MonoIOError ERROR_INVALID_BLOCK
public MonoIOError ERROR_BAD_ENVIRONMENT
public MonoIOError ERROR_BAD_FORMAT
public MonoIOError ERROR_INVALID_ACCESS
public MonoIOError ERROR_INVALID_DATA
public MonoIOError ERROR_OUTOFMEMORY
public MonoIOError ERROR_INVALID_DRIVE
public MonoIOError ERROR_CURRENT_DIRECTORY
public MonoIOError ERROR_NOT_SAME_DEVICE
public MonoIOError ERROR_NO_MORE_FILES
public MonoIOError ERROR_WRITE_PROTECT
public MonoIOError ERROR_BAD_UNIT
public MonoIOError ERROR_NOT_READY
public MonoIOError ERROR_BAD_COMMAND
public MonoIOError ERROR_CRC
public MonoIOError ERROR_BAD_LENGTH
public MonoIOError ERROR_SEEK
public MonoIOError ERROR_NOT_DOS_DISK
public MonoIOError ERROR_SECTOR_NOT_FOUND
public MonoIOError ERROR_OUT_OF_PAPER
public MonoIOError ERROR_WRITE_FAULT
public MonoIOError ERROR_READ_FAULT
public MonoIOError ERROR_GEN_FAILURE
public MonoIOError ERROR_SHARING_VIOLATION
public MonoIOError ERROR_LOCK_VIOLATION
public MonoIOError ERROR_WRONG_DISK
public MonoIOError ERROR_SHARING_BUFFER_EXCEEDED
public MonoIOError ERROR_HANDLE_EOF
public MonoIOError ERROR_HANDLE_DISK_FULL
public MonoIOError ERROR_NOT_SUPPORTED
public MonoIOError ERROR_REM_NOT_LIST
public MonoIOError ERROR_DUP_NAME
public MonoIOError ERROR_BAD_NETPATH
public MonoIOError ERROR_NETWORK_BUSY
public MonoIOError ERROR_DEV_NOT_EXIST
public MonoIOError ERROR_TOO_MANY_CMDS
public MonoIOError ERROR_ADAP_HDW_ERR
public MonoIOError ERROR_BAD_NET_RESP
public MonoIOError ERROR_UNEXP_NET_ERR
public MonoIOError ERROR_BAD_REM_ADAP
public MonoIOError ERROR_PRINTQ_FULL
public MonoIOError ERROR_NO_SPOOL_SPACE
public MonoIOError ERROR_PRINT_CANCELLED
public MonoIOError ERROR_NETNAME_DELETED
public MonoIOError ERROR_NETWORK_ACCESS_DENIED
public MonoIOError ERROR_BAD_DEV_TYPE
public MonoIOError ERROR_BAD_NET_NAME
public MonoIOError ERROR_TOO_MANY_NAMES
public MonoIOError ERROR_TOO_MANY_SESS
public MonoIOError ERROR_SHARING_PAUSED
public MonoIOError ERROR_REQ_NOT_ACCEP
public MonoIOError ERROR_REDIR_PAUSED
public MonoIOError ERROR_FILE_EXISTS
public MonoIOError ERROR_CANNOT_MAKE
public MonoIOError ERROR_FAIL_I24
public MonoIOError ERROR_OUT_OF_STRUCTURES
public MonoIOError ERROR_ALREADY_ASSIGNED
public MonoIOError ERROR_INVALID_PASSWORD
public MonoIOError ERROR_INVALID_PARAMETER
public MonoIOError ERROR_NET_WRITE_FAULT
public MonoIOError ERROR_NO_PROC_SLOTS
public MonoIOError ERROR_TOO_MANY_SEMAPHORES
public MonoIOError ERROR_EXCL_SEM_ALREADY_OWNED
public MonoIOError ERROR_SEM_IS_SET
public MonoIOError ERROR_TOO_MANY_SEM_REQUESTS
public MonoIOError ERROR_INVALID_AT_INTERRUPT_TIME
public MonoIOError ERROR_SEM_OWNER_DIED
public MonoIOError ERROR_SEM_USER_LIMIT
public MonoIOError ERROR_DISK_CHANGE
public MonoIOError ERROR_DRIVE_LOCKED
public MonoIOError ERROR_BROKEN_PIPE
public MonoIOError ERROR_OPEN_FAILED
public MonoIOError ERROR_BUFFER_OVERFLOW
public MonoIOError ERROR_DISK_FULL
public MonoIOError ERROR_NO_MORE_SEARCH_HANDLES
public MonoIOError ERROR_INVALID_TARGET_HANDLE
public MonoIOError ERROR_INVALID_CATEGORY
public MonoIOError ERROR_INVALID_VERIFY_SWITCH
public MonoIOError ERROR_BAD_DRIVER_LEVEL
public MonoIOError ERROR_CALL_NOT_IMPLEMENTED
public MonoIOError ERROR_SEM_TIMEOUT
public MonoIOError ERROR_INSUFFICIENT_BUFFER
public MonoIOError ERROR_INVALID_NAME
public MonoIOError ERROR_INVALID_LEVEL
public MonoIOError ERROR_NO_VOLUME_LABEL
public MonoIOError ERROR_MOD_NOT_FOUND
public MonoIOError ERROR_PROC_NOT_FOUND
public MonoIOError ERROR_WAIT_NO_CHILDREN
public MonoIOError ERROR_CHILD_NOT_COMPLETE
public MonoIOError ERROR_DIRECT_ACCESS_HANDLE
public MonoIOError ERROR_NEGATIVE_SEEK
public MonoIOError ERROR_SEEK_ON_DEVICE
public MonoIOError ERROR_IS_JOIN_TARGET
public MonoIOError ERROR_IS_JOINED
public MonoIOError ERROR_IS_SUBSTED
public MonoIOError ERROR_NOT_JOINED
public MonoIOError ERROR_NOT_SUBSTED
public MonoIOError ERROR_JOIN_TO_JOIN
public MonoIOError ERROR_SUBST_TO_SUBST
public MonoIOError ERROR_JOIN_TO_SUBST
public MonoIOError ERROR_SUBST_TO_JOIN
public MonoIOError ERROR_BUSY_DRIVE
public MonoIOError ERROR_SAME_DRIVE
public MonoIOError ERROR_DIR_NOT_ROOT
public MonoIOError ERROR_DIR_NOT_EMPTY
public MonoIOError ERROR_IS_SUBST_PATH
public MonoIOError ERROR_IS_JOIN_PATH
public MonoIOError ERROR_PATH_BUSY
public MonoIOError ERROR_IS_SUBST_TARGET
public MonoIOError ERROR_SYSTEM_TRACE
public MonoIOError ERROR_INVALID_EVENT_COUNT
public MonoIOError ERROR_TOO_MANY_MUXWAITERS
public MonoIOError ERROR_INVALID_LIST_FORMAT
public MonoIOError ERROR_LABEL_TOO_LONG
public MonoIOError ERROR_TOO_MANY_TCBS
public MonoIOError ERROR_SIGNAL_REFUSED
public MonoIOError ERROR_DISCARDED
public MonoIOError ERROR_NOT_LOCKED
public MonoIOError ERROR_BAD_THREADID_ADDR
public MonoIOError ERROR_BAD_ARGUMENTS
public MonoIOError ERROR_BAD_PATHNAME
public MonoIOError ERROR_SIGNAL_PENDING
public MonoIOError ERROR_MAX_THRDS_REACHED
public MonoIOError ERROR_LOCK_FAILED
public MonoIOError ERROR_BUSY
public MonoIOError ERROR_CANCEL_VIOLATION
public MonoIOError ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
public MonoIOError ERROR_INVALID_SEGMENT_NUMBER
public MonoIOError ERROR_INVALID_ORDINAL
public MonoIOError ERROR_ALREADY_EXISTS
public MonoIOError ERROR_INVALID_FLAG_NUMBER
public MonoIOError ERROR_SEM_NOT_FOUND
public MonoIOError ERROR_INVALID_STARTING_CODESEG
public MonoIOError ERROR_INVALID_STACKSEG
public MonoIOError ERROR_INVALID_MODULETYPE
public MonoIOError ERROR_INVALID_EXE_SIGNATURE
public MonoIOError ERROR_EXE_MARKED_INVALID
public MonoIOError ERROR_BAD_EXE_FORMAT
public MonoIOError ERROR_ITERATED_DATA_EXCEEDS_64k
public MonoIOError ERROR_INVALID_MINALLOCSIZE
public MonoIOError ERROR_DYNLINK_FROM_INVALID_RING
public MonoIOError ERROR_IOPL_NOT_ENABLED
public MonoIOError ERROR_INVALID_SEGDPL
public MonoIOError ERROR_AUTODATASEG_EXCEEDS_64k
public MonoIOError ERROR_RING2SEG_MUST_BE_MOVABLE
public MonoIOError ERROR_RELOC_CHAIN_XEEDS_SEGLIM
public MonoIOError ERROR_INFLOOP_IN_RELOC_CHAIN
public MonoIOError ERROR_ENVVAR_NOT_FOUND
public MonoIOError ERROR_NO_SIGNAL_SENT
public MonoIOError ERROR_FILENAME_EXCED_RANGE
public MonoIOError ERROR_RING2_STACK_IN_USE
public MonoIOError ERROR_META_EXPANSION_TOO_LONG
public MonoIOError ERROR_INVALID_SIGNAL_NUMBER
public MonoIOError ERROR_THREAD_1_INACTIVE
public MonoIOError ERROR_LOCKED
public MonoIOError ERROR_TOO_MANY_MODULES
public MonoIOError ERROR_NESTING_NOT_ALLOWED
public MonoIOError ERROR_EXE_MACHINE_TYPE_MISMATCH
public MonoIOError ERROR_BAD_PIPE
public MonoIOError ERROR_PIPE_BUSY
public MonoIOError ERROR_NO_DATA
public MonoIOError ERROR_PIPE_NOT_CONNECTED
public MonoIOError ERROR_MORE_DATA
public MonoIOError ERROR_VC_DISCONNECTED
public MonoIOError ERROR_INVALID_EA_NAME
public MonoIOError ERROR_EA_LIST_INCONSISTENT
public MonoIOError WAIT_TIMEOUT
public MonoIOError ERROR_NO_MORE_ITEMS
public MonoIOError ERROR_CANNOT_COPY
public MonoIOError ERROR_DIRECTORY
public MonoIOError ERROR_EAS_DIDNT_FIT
public MonoIOError ERROR_EA_FILE_CORRUPT
public MonoIOError ERROR_EA_TABLE_FULL
public MonoIOError ERROR_INVALID_EA_HANDLE
public MonoIOError ERROR_EAS_NOT_SUPPORTED
public MonoIOError ERROR_NOT_OWNER
public MonoIOError ERROR_TOO_MANY_POSTS
public MonoIOError ERROR_PARTIAL_COPY
public MonoIOError ERROR_OPLOCK_NOT_GRANTED
public MonoIOError ERROR_INVALID_OPLOCK_PROTOCOL
public MonoIOError ERROR_DISK_TOO_FRAGMENTED
public MonoIOError ERROR_DELETE_PENDING
public MonoIOError ERROR_MR_MID_NOT_FOUND
public MonoIOError ERROR_INVALID_ADDRESS
public MonoIOError ERROR_ARITHMETIC_OVERFLOW
public MonoIOError ERROR_PIPE_CONNECTED
public MonoIOError ERROR_PIPE_LISTENING
public MonoIOError ERROR_EA_ACCESS_DENIED
public MonoIOError ERROR_OPERATION_ABORTED
public MonoIOError ERROR_IO_INCOMPLETE
public MonoIOError ERROR_IO_PENDING
public MonoIOError ERROR_NOACCESS
public MonoIOError ERROR_SWAPERROR
public MonoIOError ERROR_STACK_OVERFLOW
public MonoIOError ERROR_INVALID_MESSAGE
public MonoIOError ERROR_CAN_NOT_COMPLETE
public MonoIOError ERROR_INVALID_FLAGS
public MonoIOError ERROR_UNRECOGNIZED_VOLUME
public MonoIOError ERROR_FILE_INVALID
public MonoIOError ERROR_FULLSCREEN_MODE
public MonoIOError ERROR_NO_TOKEN
public MonoIOError ERROR_BADDB
public MonoIOError ERROR_BADKEY
public MonoIOError ERROR_CANTOPEN
public MonoIOError ERROR_CANTREAD
public MonoIOError ERROR_CANTWRITE
public MonoIOError ERROR_REGISTRY_RECOVERED
public MonoIOError ERROR_REGISTRY_CORRUPT
public MonoIOError ERROR_REGISTRY_IO_FAILED
public MonoIOError ERROR_NOT_REGISTRY_FILE
public MonoIOError ERROR_KEY_DELETED
public MonoIOError ERROR_NO_LOG_SPACE
public MonoIOError ERROR_KEY_HAS_CHILDREN
public MonoIOError ERROR_CHILD_MUST_BE_VOLATILE
public MonoIOError ERROR_NOTIFY_ENUM_DIR
public MonoIOError ERROR_DEPENDENT_SERVICES_RUNNING
public MonoIOError ERROR_INVALID_SERVICE_CONTROL
public MonoIOError ERROR_SERVICE_REQUEST_TIMEOUT
public MonoIOError ERROR_SERVICE_NO_THREAD
public MonoIOError ERROR_SERVICE_DATABASE_LOCKED
public MonoIOError ERROR_SERVICE_ALREADY_RUNNING
public MonoIOError ERROR_INVALID_SERVICE_ACCOUNT
public MonoIOError ERROR_SERVICE_DISABLED
public MonoIOError ERROR_CIRCULAR_DEPENDENCY
public MonoIOError ERROR_SERVICE_DOES_NOT_EXIST
public MonoIOError ERROR_SERVICE_CANNOT_ACCEPT_CTRL
public MonoIOError ERROR_SERVICE_NOT_ACTIVE
public MonoIOError ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
public MonoIOError ERROR_EXCEPTION_IN_SERVICE
public MonoIOError ERROR_DATABASE_DOES_NOT_EXIST
public MonoIOError ERROR_SERVICE_SPECIFIC_ERROR
public MonoIOError ERROR_PROCESS_ABORTED
public MonoIOError ERROR_SERVICE_DEPENDENCY_FAIL
public MonoIOError ERROR_SERVICE_LOGON_FAILED
public MonoIOError ERROR_SERVICE_START_HANG
public MonoIOError ERROR_INVALID_SERVICE_LOCK
public MonoIOError ERROR_SERVICE_MARKED_FOR_DELETE
public MonoIOError ERROR_SERVICE_EXISTS
public MonoIOError ERROR_ALREADY_RUNNING_LKG
public MonoIOError ERROR_SERVICE_DEPENDENCY_DELETED
public MonoIOError ERROR_BOOT_ALREADY_ACCEPTED
public MonoIOError ERROR_SERVICE_NEVER_STARTED
public MonoIOError ERROR_DUPLICATE_SERVICE_NAME
public MonoIOError ERROR_DIFFERENT_SERVICE_ACCOUNT
public MonoIOError ERROR_CANNOT_DETECT_DRIVER_FAILURE
public MonoIOError ERROR_CANNOT_DETECT_PROCESS_ABORT
public MonoIOError ERROR_NO_RECOVERY_PROGRAM
public MonoIOError ERROR_SERVICE_NOT_IN_EXE
public MonoIOError ERROR_NOT_SAFEBOOT_SERVICE
public MonoIOError ERROR_END_OF_MEDIA
public MonoIOError ERROR_FILEMARK_DETECTED
public MonoIOError ERROR_BEGINNING_OF_MEDIA
public MonoIOError ERROR_SETMARK_DETECTED
public MonoIOError ERROR_NO_DATA_DETECTED
public MonoIOError ERROR_PARTITION_FAILURE
public MonoIOError ERROR_INVALID_BLOCK_LENGTH
public MonoIOError ERROR_DEVICE_NOT_PARTITIONED
public MonoIOError ERROR_UNABLE_TO_LOCK_MEDIA
public MonoIOError ERROR_UNABLE_TO_UNLOAD_MEDIA
public MonoIOError ERROR_MEDIA_CHANGED
public MonoIOError ERROR_BUS_RESET
public MonoIOError ERROR_NO_MEDIA_IN_DRIVE
public MonoIOError ERROR_NO_UNICODE_TRANSLATION
public MonoIOError ERROR_DLL_INIT_FAILED
public MonoIOError ERROR_SHUTDOWN_IN_PROGRESS
public MonoIOError ERROR_NO_SHUTDOWN_IN_PROGRESS
public MonoIOError ERROR_IO_DEVICE
public MonoIOError ERROR_SERIAL_NO_DEVICE
public MonoIOError ERROR_IRQ_BUSY
public MonoIOError ERROR_MORE_WRITES
public MonoIOError ERROR_COUNTER_TIMEOUT
public MonoIOError ERROR_FLOPPY_ID_MARK_NOT_FOUND
public MonoIOError ERROR_FLOPPY_WRONG_CYLINDER
public MonoIOError ERROR_FLOPPY_UNKNOWN_ERROR
public MonoIOError ERROR_FLOPPY_BAD_REGISTERS
public MonoIOError ERROR_DISK_RECALIBRATE_FAILED
public MonoIOError ERROR_DISK_OPERATION_FAILED
public MonoIOError ERROR_DISK_RESET_FAILED
public MonoIOError ERROR_EOM_OVERFLOW
public MonoIOError ERROR_NOT_ENOUGH_SERVER_MEMORY
public MonoIOError ERROR_POSSIBLE_DEADLOCK
public MonoIOError ERROR_MAPPED_ALIGNMENT
public MonoIOError ERROR_SET_POWER_STATE_VETOED
public MonoIOError ERROR_SET_POWER_STATE_FAILED
public MonoIOError ERROR_TOO_MANY_LINKS
public MonoIOError ERROR_OLD_WIN_VERSION
public MonoIOError ERROR_APP_WRONG_OS
public MonoIOError ERROR_SINGLE_INSTANCE_APP
public MonoIOError ERROR_RMODE_APP
public MonoIOError ERROR_INVALID_DLL
public MonoIOError ERROR_NO_ASSOCIATION
public MonoIOError ERROR_DDE_FAIL
public MonoIOError ERROR_DLL_NOT_FOUND
public MonoIOError ERROR_NO_MORE_USER_HANDLES
public MonoIOError ERROR_MESSAGE_SYNC_ONLY
public MonoIOError ERROR_SOURCE_ELEMENT_EMPTY
public MonoIOError ERROR_DESTINATION_ELEMENT_FULL
public MonoIOError ERROR_ILLEGAL_ELEMENT_ADDRESS
public MonoIOError ERROR_MAGAZINE_NOT_PRESENT
public MonoIOError ERROR_DEVICE_REINITIALIZATION_NEEDED
public MonoIOError ERROR_DEVICE_REQUIRES_CLEANING
public MonoIOError ERROR_DEVICE_DOOR_OPEN
public MonoIOError ERROR_DEVICE_NOT_CONNECTED
public MonoIOError ERROR_NOT_FOUND
public MonoIOError ERROR_NO_MATCH
public MonoIOError ERROR_SET_NOT_FOUND
public MonoIOError ERROR_POINT_NOT_FOUND
public MonoIOError ERROR_NO_TRACKING_SERVICE
public MonoIOError ERROR_NO_VOLUME_ID
public MonoIOError ERROR_UNABLE_TO_REMOVE_REPLACED
public MonoIOError ERROR_UNABLE_TO_MOVE_REPLACEMENT
public MonoIOError ERROR_UNABLE_TO_MOVE_REPLACEMENT_2
public MonoIOError ERROR_JOURNAL_DELETE_IN_PROGRESS
public MonoIOError ERROR_JOURNAL_NOT_ACTIVE
public MonoIOError ERROR_POTENTIAL_FILE_FOUND
public MonoIOError ERROR_JOURNAL_ENTRY_DELETED
public MonoIOError ERROR_BAD_DEVICE
public MonoIOError ERROR_CONNECTION_UNAVAIL
public MonoIOError ERROR_DEVICE_ALREADY_REMEMBERED
public MonoIOError ERROR_NO_NET_OR_BAD_PATH
public MonoIOError ERROR_BAD_PROVIDER
public MonoIOError ERROR_CANNOT_OPEN_PROFILE
public MonoIOError ERROR_BAD_PROFILE
public MonoIOError ERROR_NOT_CONTAINER
public MonoIOError ERROR_EXTENDED_ERROR
public MonoIOError ERROR_INVALID_GROUPNAME
public MonoIOError ERROR_INVALID_COMPUTERNAME
public MonoIOError ERROR_INVALID_EVENTNAME
public MonoIOError ERROR_INVALID_DOMAINNAME
public MonoIOError ERROR_INVALID_SERVICENAME
public MonoIOError ERROR_INVALID_NETNAME
public MonoIOError ERROR_INVALID_SHARENAME
public MonoIOError ERROR_INVALID_PASSWORDNAME
public MonoIOError ERROR_INVALID_MESSAGENAME
public MonoIOError ERROR_INVALID_MESSAGEDEST
public MonoIOError ERROR_SESSION_CREDENTIAL_CONFLICT
public MonoIOError ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
public MonoIOError ERROR_DUP_DOMAINNAME
public MonoIOError ERROR_NO_NETWORK
public MonoIOError ERROR_CANCELLED
public MonoIOError ERROR_USER_MAPPED_FILE
public MonoIOError ERROR_CONNECTION_REFUSED
public MonoIOError ERROR_GRACEFUL_DISCONNECT
public MonoIOError ERROR_ADDRESS_ALREADY_ASSOCIATED
public MonoIOError ERROR_ADDRESS_NOT_ASSOCIATED
public MonoIOError ERROR_CONNECTION_INVALID
public MonoIOError ERROR_CONNECTION_ACTIVE
public MonoIOError ERROR_NETWORK_UNREACHABLE
public MonoIOError ERROR_HOST_UNREACHABLE
public MonoIOError ERROR_PROTOCOL_UNREACHABLE
public MonoIOError ERROR_PORT_UNREACHABLE
public MonoIOError ERROR_REQUEST_ABORTED
public MonoIOError ERROR_CONNECTION_ABORTED
public MonoIOError ERROR_RETRY
public MonoIOError ERROR_CONNECTION_COUNT_LIMIT
public MonoIOError ERROR_LOGIN_TIME_RESTRICTION
public MonoIOError ERROR_LOGIN_WKSTA_RESTRICTION
public MonoIOError ERROR_INCORRECT_ADDRESS
public MonoIOError ERROR_ALREADY_REGISTERED
public MonoIOError ERROR_SERVICE_NOT_FOUND
public MonoIOError ERROR_NOT_AUTHENTICATED
public MonoIOError ERROR_NOT_LOGGED_ON
public MonoIOError ERROR_CONTINUE
public MonoIOError ERROR_ALREADY_INITIALIZED
public MonoIOError ERROR_NO_MORE_DEVICES
public MonoIOError ERROR_NO_SUCH_SITE
public MonoIOError ERROR_DOMAIN_CONTROLLER_EXISTS
public MonoIOError ERROR_ONLY_IF_CONNECTED
public MonoIOError ERROR_OVERRIDE_NOCHANGES
public MonoIOError ERROR_BAD_USER_PROFILE
public MonoIOError ERROR_NOT_SUPPORTED_ON_SBS
public MonoIOError ERROR_SERVER_SHUTDOWN_IN_PROGRESS
public MonoIOError ERROR_HOST_DOWN
public MonoIOError ERROR_NON_ACCOUNT_SID
public MonoIOError ERROR_NON_DOMAIN_SID
public MonoIOError ERROR_APPHELP_BLOCK
public MonoIOError ERROR_ACCESS_DISABLED_BY_POLICY
public MonoIOError ERROR_REG_NAT_CONSUMPTION
public MonoIOError ERROR_CSCSHARE_OFFLINE
public MonoIOError ERROR_PKINIT_FAILURE
public MonoIOError ERROR_SMARTCARD_SUBSYSTEM_FAILURE
public MonoIOError ERROR_DOWNGRADE_DETECTED
public MonoIOError SEC_E_SMARTCARD_CERT_REVOKED
public MonoIOError SEC_E_ISSUING_CA_UNTRUSTED
public MonoIOError SEC_E_REVOCATION_OFFLINE_C
public MonoIOError SEC_E_PKINIT_CLIENT_FAILUR
public MonoIOError SEC_E_SMARTCARD_CERT_EXPIRED
public MonoIOError ERROR_MACHINE_LOCKED
public MonoIOError ERROR_CALLBACK_SUPPLIED_INVALID_DATA
public MonoIOError ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED
public MonoIOError ERROR_DRIVER_BLOCKED
public MonoIOError ERROR_INVALID_IMPORT_OF_NON_DLL
public MonoIOError ERROR_NOT_ALL_ASSIGNED
public MonoIOError ERROR_SOME_NOT_MAPPED
public MonoIOError ERROR_NO_QUOTAS_FOR_ACCOUNT
public MonoIOError ERROR_LOCAL_USER_SESSION_KEY
public MonoIOError ERROR_NULL_LM_PASSWORD
public MonoIOError ERROR_UNKNOWN_REVISION
public MonoIOError ERROR_REVISION_MISMATCH
public MonoIOError ERROR_INVALID_OWNER
public MonoIOError ERROR_INVALID_PRIMARY_GROUP
public MonoIOError ERROR_NO_IMPERSONATION_TOKEN
public MonoIOError ERROR_CANT_DISABLE_MANDATORY
public MonoIOError ERROR_NO_LOGON_SERVERS
public MonoIOError ERROR_NO_SUCH_LOGON_SESSION
public MonoIOError ERROR_NO_SUCH_PRIVILEGE
public MonoIOError ERROR_PRIVILEGE_NOT_HELD
public MonoIOError ERROR_INVALID_ACCOUNT_NAME
public MonoIOError ERROR_USER_EXISTS
public MonoIOError ERROR_NO_SUCH_USER
public MonoIOError ERROR_GROUP_EXISTS
public MonoIOError ERROR_NO_SUCH_GROUP
public MonoIOError ERROR_MEMBER_IN_GROUP
public MonoIOError ERROR_MEMBER_NOT_IN_GROUP
public MonoIOError ERROR_LAST_ADMIN
public MonoIOError ERROR_WRONG_PASSWORD
public MonoIOError ERROR_ILL_FORMED_PASSWORD
public MonoIOError ERROR_PASSWORD_RESTRICTION
public MonoIOError ERROR_LOGON_FAILURE
public MonoIOError ERROR_ACCOUNT_RESTRICTION
public MonoIOError ERROR_INVALID_LOGON_HOURS
public MonoIOError ERROR_INVALID_WORKSTATION
public MonoIOError ERROR_PASSWORD_EXPIRED
public MonoIOError ERROR_ACCOUNT_DISABLED
public MonoIOError ERROR_NONE_MAPPED
public MonoIOError ERROR_TOO_MANY_LUIDS_REQUESTED
public MonoIOError ERROR_LUIDS_EXHAUSTED
public MonoIOError ERROR_INVALID_SUB_AUTHORITY
public MonoIOError ERROR_INVALID_ACL
public MonoIOError ERROR_INVALID_SID
public MonoIOError ERROR_INVALID_SECURITY_DESCR
public MonoIOError ERROR_BAD_INHERITANCE_ACL
public MonoIOError ERROR_SERVER_DISABLED
public MonoIOError ERROR_SERVER_NOT_DISABLED
public MonoIOError ERROR_INVALID_ID_AUTHORITY
public MonoIOError ERROR_ALLOTTED_SPACE_EXCEEDED
public MonoIOError ERROR_INVALID_GROUP_ATTRIBUTES
public MonoIOError ERROR_BAD_IMPERSONATION_LEVEL
public MonoIOError ERROR_CANT_OPEN_ANONYMOUS
public MonoIOError ERROR_BAD_VALIDATION_CLASS
public MonoIOError ERROR_BAD_TOKEN_TYPE
public MonoIOError ERROR_NO_SECURITY_ON_OBJECT
public MonoIOError ERROR_CANT_ACCESS_DOMAIN_INFO
public MonoIOError ERROR_INVALID_SERVER_STATE
public MonoIOError ERROR_INVALID_DOMAIN_STATE
public MonoIOError ERROR_INVALID_DOMAIN_ROLE
public MonoIOError ERROR_NO_SUCH_DOMAIN
public MonoIOError ERROR_DOMAIN_EXISTS
public MonoIOError ERROR_DOMAIN_LIMIT_EXCEEDED
public MonoIOError ERROR_INTERNAL_DB_CORRUPTION
public MonoIOError ERROR_INTERNAL_ERROR
public MonoIOError ERROR_GENERIC_NOT_MAPPED
public MonoIOError ERROR_BAD_DESCRIPTOR_FORMAT
public MonoIOError ERROR_NOT_LOGON_PROCESS
public MonoIOError ERROR_LOGON_SESSION_EXISTS
public MonoIOError ERROR_NO_SUCH_PACKAGE
public MonoIOError ERROR_BAD_LOGON_SESSION_STATE
public MonoIOError ERROR_LOGON_SESSION_COLLISION
public MonoIOError ERROR_INVALID_LOGON_TYPE
public MonoIOError ERROR_CANNOT_IMPERSONATE
public MonoIOError ERROR_RXACT_INVALID_STATE
public MonoIOError ERROR_RXACT_COMMIT_FAILURE
public MonoIOError ERROR_SPECIAL_ACCOUNT
public MonoIOError ERROR_SPECIAL_GROUP
public MonoIOError ERROR_SPECIAL_USER
public MonoIOError ERROR_MEMBERS_PRIMARY_GROUP
public MonoIOError ERROR_TOKEN_ALREADY_IN_USE
public MonoIOError ERROR_NO_SUCH_ALIAS
public MonoIOError ERROR_MEMBER_NOT_IN_ALIAS
public MonoIOError ERROR_MEMBER_IN_ALIAS
public MonoIOError ERROR_ALIAS_EXISTS
public MonoIOError ERROR_LOGON_NOT_GRANTED
public MonoIOError ERROR_TOO_MANY_SECRETS
public MonoIOError ERROR_SECRET_TOO_LONG
public MonoIOError ERROR_INTERNAL_DB_ERROR
public MonoIOError ERROR_TOO_MANY_CONTEXT_IDS
public MonoIOError ERROR_LOGON_TYPE_NOT_GRANTED
public MonoIOError ERROR_NT_CROSS_ENCRYPTION_REQUIRED
public MonoIOError ERROR_NO_SUCH_MEMBER
public MonoIOError ERROR_INVALID_MEMBER
public MonoIOError ERROR_TOO_MANY_SIDS
public MonoIOError ERROR_LM_CROSS_ENCRYPTION_REQUIRED
public MonoIOError ERROR_NO_INHERITANCE
public MonoIOError ERROR_FILE_CORRUPT
public MonoIOError ERROR_DISK_CORRUPT
public MonoIOError ERROR_NO_USER_SESSION_KEY
public MonoIOError ERROR_LICENSE_QUOTA_EXCEEDED
public MonoIOError ERROR_WRONG_TARGET_NAME
public MonoIOError ERROR_MUTUAL_AUTH_FAILED
public MonoIOError ERROR_TIME_SKEW
public MonoIOError ERROR_CURRENT_DOMAIN_NOT_ALLOWED
public MonoIOError ERROR_INVALID_WINDOW_HANDLE
public MonoIOError ERROR_INVALID_MENU_HANDLE
public MonoIOError ERROR_INVALID_CURSOR_HANDLE
public MonoIOError ERROR_INVALID_ACCEL_HANDLE
public MonoIOError ERROR_INVALID_HOOK_HANDLE
public MonoIOError ERROR_INVALID_DWP_HANDLE
public MonoIOError ERROR_TLW_WITH_WSCHILD
public MonoIOError ERROR_CANNOT_FIND_WND_CLASS
public MonoIOError ERROR_WINDOW_OF_OTHER_THREAD
public MonoIOError ERROR_HOTKEY_ALREADY_REGISTERED
public MonoIOError ERROR_CLASS_ALREADY_EXISTS
public MonoIOError ERROR_CLASS_DOES_NOT_EXIST
public MonoIOError ERROR_CLASS_HAS_WINDOWS
public MonoIOError ERROR_INVALID_INDEX
public MonoIOError ERROR_INVALID_ICON_HANDLE
public MonoIOError ERROR_PRIVATE_DIALOG_INDEX
public MonoIOError ERROR_LISTBOX_ID_NOT_FOUND
public MonoIOError ERROR_NO_WILDCARD_CHARACTERS
public MonoIOError ERROR_CLIPBOARD_NOT_OPEN
public MonoIOError ERROR_HOTKEY_NOT_REGISTERED
public MonoIOError ERROR_WINDOW_NOT_DIALOG
public MonoIOError ERROR_CONTROL_ID_NOT_FOUND
public MonoIOError ERROR_INVALID_COMBOBOX_MESSAGE
public MonoIOError ERROR_WINDOW_NOT_COMBOBOX
public MonoIOError ERROR_INVALID_EDIT_HEIGHT
public MonoIOError ERROR_DC_NOT_FOUND
public MonoIOError ERROR_INVALID_HOOK_FILTER
public MonoIOError ERROR_INVALID_FILTER_PROC
public MonoIOError ERROR_HOOK_NEEDS_HMOD
public MonoIOError ERROR_GLOBAL_ONLY_HOOK
public MonoIOError ERROR_JOURNAL_HOOK_SET
public MonoIOError ERROR_HOOK_NOT_INSTALLED
public MonoIOError ERROR_INVALID_LB_MESSAGE
public MonoIOError ERROR_SETCOUNT_ON_BAD_LB
public MonoIOError ERROR_LB_WITHOUT_TABSTOPS
public MonoIOError ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
public MonoIOError ERROR_CHILD_WINDOW_MENU
public MonoIOError ERROR_NO_SYSTEM_MENU
public MonoIOError ERROR_INVALID_MSGBOX_STYLE
public MonoIOError ERROR_INVALID_SPI_VALUE
public MonoIOError ERROR_SCREEN_ALREADY_LOCKED
public MonoIOError ERROR_HWNDS_HAVE_DIFF_PARENT
public MonoIOError ERROR_NOT_CHILD_WINDOW
public MonoIOError ERROR_INVALID_GW_COMMAND
public MonoIOError ERROR_INVALID_THREAD_ID
public MonoIOError ERROR_NON_MDICHILD_WINDOW
public MonoIOError ERROR_POPUP_ALREADY_ACTIVE
public MonoIOError ERROR_NO_SCROLLBARS
public MonoIOError ERROR_INVALID_SCROLLBAR_RANGE
public MonoIOError ERROR_INVALID_SHOWWIN_COMMAND
public MonoIOError ERROR_NO_SYSTEM_RESOURCES
public MonoIOError ERROR_NONPAGED_SYSTEM_RESOURCES
public MonoIOError ERROR_PAGED_SYSTEM_RESOURCES
public MonoIOError ERROR_WORKING_SET_QUOTA
public MonoIOError ERROR_PAGEFILE_QUOTA
public MonoIOError ERROR_COMMITMENT_LIMIT
public MonoIOError ERROR_MENU_ITEM_NOT_FOUND
public MonoIOError ERROR_INVALID_KEYBOARD_HANDLE
public MonoIOError ERROR_HOOK_TYPE_NOT_ALLOWED
public MonoIOError ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION
public MonoIOError ERROR_TIMEOUT
public MonoIOError ERROR_INVALID_MONITOR_HANDLE
public MonoIOError ERROR_EVENTLOG_FILE_CORRUPT
public MonoIOError ERROR_EVENTLOG_CANT_START
public MonoIOError ERROR_LOG_FILE_FULL
public MonoIOError ERROR_EVENTLOG_FILE_CHANGED
public MonoIOError ERROR_INSTALL_SERVICE_FAILURE
public MonoIOError ERROR_INSTALL_USEREXIT
public MonoIOError ERROR_INSTALL_FAILURE
public MonoIOError ERROR_INSTALL_SUSPEND
public MonoIOError ERROR_UNKNOWN_PRODUCT
public MonoIOError ERROR_UNKNOWN_FEATURE
public MonoIOError ERROR_UNKNOWN_COMPONENT
public MonoIOError ERROR_UNKNOWN_PROPERTY
public MonoIOError ERROR_INVALID_HANDLE_STATE
public MonoIOError ERROR_BAD_CONFIGURATION
public MonoIOError ERROR_INDEX_ABSENT
public MonoIOError ERROR_INSTALL_SOURCE_ABSENT
public MonoIOError ERROR_INSTALL_PACKAGE_VERSION
public MonoIOError ERROR_PRODUCT_UNINSTALLED
public MonoIOError ERROR_BAD_QUERY_SYNTAX
public MonoIOError ERROR_INVALID_FIELD
public MonoIOError ERROR_DEVICE_REMOVED
public MonoIOError ERROR_INSTALL_ALREADY_RUNNING
public MonoIOError ERROR_INSTALL_PACKAGE_OPEN_FAILED
public MonoIOError ERROR_INSTALL_PACKAGE_INVALID
public MonoIOError ERROR_INSTALL_UI_FAILURE
public MonoIOError ERROR_INSTALL_LOG_FAILURE
public MonoIOError ERROR_INSTALL_LANGUAGE_UNSUPPORTED
public MonoIOError ERROR_INSTALL_TRANSFORM_FAILURE
public MonoIOError ERROR_INSTALL_PACKAGE_REJECTED
public MonoIOError ERROR_FUNCTION_NOT_CALLED
public MonoIOError ERROR_FUNCTION_FAILED
public MonoIOError ERROR_INVALID_TABLE
public MonoIOError ERROR_DATATYPE_MISMATCH
public MonoIOError ERROR_UNSUPPORTED_TYPE
public MonoIOError ERROR_CREATE_FAILED
public MonoIOError ERROR_INSTALL_TEMP_UNWRITABLE
public MonoIOError ERROR_INSTALL_PLATFORM_UNSUPPORTED
public MonoIOError ERROR_INSTALL_NOTUSED
public MonoIOError ERROR_PATCH_PACKAGE_OPEN_FAILED
public MonoIOError ERROR_PATCH_PACKAGE_INVALID
public MonoIOError ERROR_PATCH_PACKAGE_UNSUPPORTED
public MonoIOError ERROR_PRODUCT_VERSION
public MonoIOError ERROR_INVALID_COMMAND_LINE
public MonoIOError ERROR_INSTALL_REMOTE_DISALLOWED
public MonoIOError ERROR_SUCCESS_REBOOT_INITIATED
public MonoIOError ERROR_PATCH_TARGET_NOT_FOUND
public MonoIOError ERROR_PATCH_PACKAGE_REJECTED
public MonoIOError ERROR_INSTALL_TRANSFORM_REJECTED
public MonoIOError RPC_S_INVALID_STRING_BINDING
public MonoIOError RPC_S_WRONG_KIND_OF_BINDING
public MonoIOError RPC_S_INVALID_BINDING
public MonoIOError RPC_S_PROTSEQ_NOT_SUPPORTED
public MonoIOError RPC_S_INVALID_RPC_PROTSEQ
public MonoIOError RPC_S_INVALID_STRING_UUID
public MonoIOError RPC_S_INVALID_ENDPOINT_FORMAT
public MonoIOError RPC_S_INVALID_NET_ADDR
public MonoIOError RPC_S_NO_ENDPOINT_FOUND
public MonoIOError RPC_S_INVALID_TIMEOUT
public MonoIOError RPC_S_OBJECT_NOT_FOUND
public MonoIOError RPC_S_ALREADY_REGISTERED
public MonoIOError RPC_S_TYPE_ALREADY_REGISTERED
public MonoIOError RPC_S_ALREADY_LISTENING
public MonoIOError RPC_S_NO_PROTSEQS_REGISTERED
public MonoIOError RPC_S_NOT_LISTENING
public MonoIOError RPC_S_UNKNOWN_MGR_TYPE
public MonoIOError RPC_S_UNKNOWN_IF
public MonoIOError RPC_S_NO_BINDINGS
public MonoIOError RPC_S_NO_PROTSEQS
public MonoIOError RPC_S_CANT_CREATE_ENDPOINT
public MonoIOError RPC_S_OUT_OF_RESOURCES
public MonoIOError RPC_S_SERVER_UNAVAILABLE
public MonoIOError RPC_S_SERVER_TOO_BUSY
public MonoIOError RPC_S_INVALID_NETWORK_OPTIONS
public MonoIOError RPC_S_NO_CALL_ACTIVE
public MonoIOError RPC_S_CALL_FAILED
public MonoIOError RPC_S_CALL_FAILED_DNE
public MonoIOError RPC_S_PROTOCOL_ERROR
public MonoIOError RPC_S_UNSUPPORTED_TRANS_SYN
public MonoIOError RPC_S_UNSUPPORTED_TYPE
public MonoIOError RPC_S_INVALID_TAG
public MonoIOError RPC_S_INVALID_BOUND
public MonoIOError RPC_S_NO_ENTRY_NAME
public MonoIOError RPC_S_INVALID_NAME_SYNTAX
public MonoIOError RPC_S_UNSUPPORTED_NAME_SYNTAX
public MonoIOError RPC_S_UUID_NO_ADDRESS
public MonoIOError RPC_S_DUPLICATE_ENDPOINT
public MonoIOError RPC_S_UNKNOWN_AUTHN_TYPE
public MonoIOError RPC_S_MAX_CALLS_TOO_SMALL
public MonoIOError RPC_S_STRING_TOO_LONG
public MonoIOError RPC_S_PROTSEQ_NOT_FOUND
public MonoIOError RPC_S_PROCNUM_OUT_OF_RANGE
public MonoIOError RPC_S_BINDING_HAS_NO_AUTH
public MonoIOError RPC_S_UNKNOWN_AUTHN_SERVICE
public MonoIOError RPC_S_UNKNOWN_AUTHN_LEVEL
public MonoIOError RPC_S_INVALID_AUTH_IDENTITY
public MonoIOError RPC_S_UNKNOWN_AUTHZ_SERVICE
public MonoIOError EPT_S_INVALID_ENTRY
public MonoIOError EPT_S_CANT_PERFORM_OP
public MonoIOError EPT_S_NOT_REGISTERED
public MonoIOError RPC_S_NOTHING_TO_EXPORT
public MonoIOError RPC_S_INCOMPLETE_NAME
public MonoIOError RPC_S_INVALID_VERS_OPTION
public MonoIOError RPC_S_NO_MORE_MEMBERS
public MonoIOError RPC_S_NOT_ALL_OBJS_UNEXPORTED
public MonoIOError RPC_S_INTERFACE_NOT_FOUND
public MonoIOError RPC_S_ENTRY_ALREADY_EXISTS
public MonoIOError RPC_S_ENTRY_NOT_FOUND
public MonoIOError RPC_S_NAME_SERVICE_UNAVAILABLE
public MonoIOError RPC_S_INVALID_NAF_ID
public MonoIOError RPC_S_CANNOT_SUPPORT
public MonoIOError RPC_S_NO_CONTEXT_AVAILABLE
public MonoIOError RPC_S_INTERNAL_ERROR
public MonoIOError RPC_S_ZERO_DIVIDE
public MonoIOError RPC_S_ADDRESS_ERROR
public MonoIOError RPC_S_FP_DIV_ZERO
public MonoIOError RPC_S_FP_UNDERFLOW
public MonoIOError RPC_S_FP_OVERFLOW
public MonoIOError RPC_X_NO_MORE_ENTRIES
public MonoIOError RPC_X_SS_CHAR_TRANS_OPEN_FAIL
public MonoIOError RPC_X_SS_CHAR_TRANS_SHORT_FILE
public MonoIOError RPC_X_SS_IN_NULL_CONTEXT
public MonoIOError RPC_X_SS_CONTEXT_DAMAGED
public MonoIOError RPC_X_SS_HANDLES_MISMATCH
public MonoIOError RPC_X_SS_CANNOT_GET_CALL_HANDLE
public MonoIOError RPC_X_NULL_REF_POINTER
public MonoIOError RPC_X_ENUM_VALUE_OUT_OF_RANGE
public MonoIOError RPC_X_BYTE_COUNT_TOO_SMALL
public MonoIOError RPC_X_BAD_STUB_DATA
public MonoIOError ERROR_INVALID_USER_BUFFER
public MonoIOError ERROR_UNRECOGNIZED_MEDIA
public MonoIOError ERROR_NO_TRUST_LSA_SECRET
public MonoIOError ERROR_NO_TRUST_SAM_ACCOUNT
public MonoIOError ERROR_TRUSTED_DOMAIN_FAILURE
public MonoIOError ERROR_TRUSTED_RELATIONSHIP_FAILURE
public MonoIOError ERROR_TRUST_FAILURE
public MonoIOError RPC_S_CALL_IN_PROGRESS
public MonoIOError ERROR_NETLOGON_NOT_STARTED
public MonoIOError ERROR_ACCOUNT_EXPIRED
public MonoIOError ERROR_REDIRECTOR_HAS_OPEN_HANDLES
public MonoIOError ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
public MonoIOError ERROR_UNKNOWN_PORT
public MonoIOError ERROR_UNKNOWN_PRINTER_DRIVER
public MonoIOError ERROR_UNKNOWN_PRINTPROCESSOR
public MonoIOError ERROR_INVALID_SEPARATOR_FILE
public MonoIOError ERROR_INVALID_PRIORITY
public MonoIOError ERROR_INVALID_PRINTER_NAME
public MonoIOError ERROR_PRINTER_ALREADY_EXISTS
public MonoIOError ERROR_INVALID_PRINTER_COMMAND
public MonoIOError ERROR_INVALID_DATATYPE
public MonoIOError ERROR_INVALID_ENVIRONMENT
public MonoIOError RPC_S_NO_MORE_BINDINGS
public MonoIOError ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
public MonoIOError ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
public MonoIOError ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
public MonoIOError ERROR_DOMAIN_TRUST_INCONSISTENT
public MonoIOError ERROR_SERVER_HAS_OPEN_HANDLES
public MonoIOError ERROR_RESOURCE_DATA_NOT_FOUND
public MonoIOError ERROR_RESOURCE_TYPE_NOT_FOUND
public MonoIOError ERROR_RESOURCE_NAME_NOT_FOUND
public MonoIOError ERROR_RESOURCE_LANG_NOT_FOUND
public MonoIOError ERROR_NOT_ENOUGH_QUOTA
public MonoIOError RPC_S_NO_INTERFACES
public MonoIOError RPC_S_CALL_CANCELLED
public MonoIOError RPC_S_BINDING_INCOMPLETE
public MonoIOError RPC_S_COMM_FAILURE
public MonoIOError RPC_S_UNSUPPORTED_AUTHN_LEVEL
public MonoIOError RPC_S_NO_PRINC_NAME
public MonoIOError RPC_S_NOT_RPC_ERROR
public MonoIOError RPC_S_UUID_LOCAL_ONLY
public MonoIOError RPC_S_SEC_PKG_ERROR
public MonoIOError RPC_S_NOT_CANCELLED
public MonoIOError RPC_X_INVALID_ES_ACTION
public MonoIOError RPC_X_WRONG_ES_VERSION
public MonoIOError RPC_X_WRONG_STUB_VERSION
public MonoIOError RPC_X_INVALID_PIPE_OBJECT
public MonoIOError RPC_X_WRONG_PIPE_ORDER
public MonoIOError RPC_X_WRONG_PIPE_VERSION
public MonoIOError RPC_S_GROUP_MEMBER_NOT_FOUND
public MonoIOError EPT_S_CANT_CREATE
public MonoIOError RPC_S_INVALID_OBJECT
public MonoIOError ERROR_INVALID_TIME
public MonoIOError ERROR_INVALID_FORM_NAME
public MonoIOError ERROR_INVALID_FORM_SIZE
public MonoIOError ERROR_ALREADY_WAITING
public MonoIOError ERROR_PRINTER_DELETED
public MonoIOError ERROR_INVALID_PRINTER_STATE
public MonoIOError ERROR_PASSWORD_MUST_CHANGE
public MonoIOError ERROR_DOMAIN_CONTROLLER_NOT_FOUND
public MonoIOError ERROR_ACCOUNT_LOCKED_OUT
public MonoIOError OR_INVALID_OXID
public MonoIOError OR_INVALID_OID
public MonoIOError OR_INVALID_SET
public MonoIOError RPC_S_SEND_INCOMPLETE
public MonoIOError RPC_S_INVALID_ASYNC_HANDLE
public MonoIOError RPC_S_INVALID_ASYNC_CALL
public MonoIOError RPC_X_PIPE_CLOSED
public MonoIOError RPC_X_PIPE_DISCIPLINE_ERROR
public MonoIOError RPC_X_PIPE_EMPTY
public MonoIOError ERROR_NO_SITENAME
public MonoIOError ERROR_CANT_ACCESS_FILE
public MonoIOError ERROR_CANT_RESOLVE_FILENAME
public MonoIOError RPC_S_ENTRY_TYPE_MISMATCH
public MonoIOError RPC_S_NOT_ALL_OBJS_EXPORTED
public MonoIOError RPC_S_INTERFACE_NOT_EXPORTED
public MonoIOError RPC_S_PROFILE_NOT_ADDED
public MonoIOError RPC_S_PRF_ELT_NOT_ADDED
public MonoIOError RPC_S_PRF_ELT_NOT_REMOVED
public MonoIOError RPC_S_GRP_ELT_NOT_ADDED
public MonoIOError RPC_S_GRP_ELT_NOT_REMOVED
public MonoIOError ERROR_KM_DRIVER_BLOCKED
public MonoIOError ERROR_CONTEXT_EXPIRED
public MonoIOError ERROR_INVALID_PIXEL_FORMAT
public MonoIOError ERROR_BAD_DRIVER
public MonoIOError ERROR_INVALID_WINDOW_STYLE
public MonoIOError ERROR_METAFILE_NOT_SUPPORTED
public MonoIOError ERROR_TRANSFORM_NOT_SUPPORTED
public MonoIOError ERROR_CLIPPING_NOT_SUPPORTED
public MonoIOError ERROR_INVALID_CMM
public MonoIOError ERROR_INVALID_PROFILE
public MonoIOError ERROR_TAG_NOT_FOUND
public MonoIOError ERROR_TAG_NOT_PRESENT
public MonoIOError ERROR_DUPLICATE_TAG
public MonoIOError ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE
public MonoIOError ERROR_PROFILE_NOT_FOUND
public MonoIOError ERROR_INVALID_COLORSPACE
public MonoIOError ERROR_ICM_NOT_ENABLED
public MonoIOError ERROR_DELETING_ICM_XFORM
public MonoIOError ERROR_INVALID_TRANSFORM
public MonoIOError ERROR_COLORSPACE_MISMATCH
public MonoIOError ERROR_INVALID_COLORINDEX
public MonoIOError ERROR_CONNECTED_OTHER_PASSWORD
public MonoIOError ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT
public MonoIOError ERROR_BAD_USERNAME
public MonoIOError ERROR_NOT_CONNECTED
public MonoIOError ERROR_OPEN_FILES
public MonoIOError ERROR_ACTIVE_CONNECTIONS
public MonoIOError ERROR_DEVICE_IN_USE
public MonoIOError ERROR_UNKNOWN_PRINT_MONITOR
public MonoIOError ERROR_PRINTER_DRIVER_IN_USE
public MonoIOError ERROR_SPOOL_FILE_NOT_FOUND
public MonoIOError ERROR_SPL_NO_STARTDOC
public MonoIOError ERROR_SPL_NO_ADDJOB
public MonoIOError ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
public MonoIOError ERROR_PRINT_MONITOR_ALREADY_INSTALLED
public MonoIOError ERROR_INVALID_PRINT_MONITOR
public MonoIOError ERROR_PRINT_MONITOR_IN_USE
public MonoIOError ERROR_PRINTER_HAS_JOBS_QUEUED
public MonoIOError ERROR_SUCCESS_REBOOT_REQUIRED
public MonoIOError ERROR_SUCCESS_RESTART_REQUIRED
public MonoIOError ERROR_PRINTER_NOT_FOUND
public MonoIOError ERROR_PRINTER_DRIVER_WARNED
public MonoIOError ERROR_PRINTER_DRIVER_BLOCKED
public MonoIOError ERROR_WINS_INTERNAL
public MonoIOError ERROR_CAN_NOT_DEL_LOCAL_WINS
public MonoIOError ERROR_STATIC_INIT
public MonoIOError ERROR_INC_BACKUP
public MonoIOError ERROR_FULL_BACKUP
public MonoIOError ERROR_REC_NON_EXISTENT
public MonoIOError ERROR_RPL_NOT_ALLOWED
public MonoIOError ERROR_DHCP_ADDRESS_CONFLICT
public MonoIOError ERROR_WMI_GUID_NOT_FOUND
public MonoIOError ERROR_WMI_INSTANCE_NOT_FOUND
public MonoIOError ERROR_WMI_ITEMID_NOT_FOUND
public MonoIOError ERROR_WMI_TRY_AGAIN
public MonoIOError ERROR_WMI_DP_NOT_FOUND
public MonoIOError ERROR_WMI_UNRESOLVED_INSTANCE_REF
public MonoIOError ERROR_WMI_ALREADY_ENABLED
public MonoIOError ERROR_WMI_GUID_DISCONNECTED
public MonoIOError ERROR_WMI_SERVER_UNAVAILABLE
public MonoIOError ERROR_WMI_DP_FAILED
public MonoIOError ERROR_WMI_INVALID_MOF
public MonoIOError ERROR_WMI_INVALID_REGINFO
public MonoIOError ERROR_WMI_ALREADY_DISABLED
public MonoIOError ERROR_WMI_READ_ONLY
public MonoIOError ERROR_WMI_SET_FAILURE
public MonoIOError ERROR_INVALID_MEDIA
public MonoIOError ERROR_INVALID_LIBRARY
public MonoIOError ERROR_INVALID_MEDIA_POOL
public MonoIOError ERROR_DRIVE_MEDIA_MISMATCH
public MonoIOError ERROR_MEDIA_OFFLINE
public MonoIOError ERROR_LIBRARY_OFFLINE
public MonoIOError ERROR_EMPTY
public MonoIOError ERROR_NOT_EMPTY
public MonoIOError ERROR_MEDIA_UNAVAILABLE
public MonoIOError ERROR_RESOURCE_DISABLED
public MonoIOError ERROR_INVALID_CLEANER
public MonoIOError ERROR_UNABLE_TO_CLEAN
public MonoIOError ERROR_OBJECT_NOT_FOUND
public MonoIOError ERROR_DATABASE_FAILURE
public MonoIOError ERROR_DATABASE_FULL
public MonoIOError ERROR_MEDIA_INCOMPATIBLE
public MonoIOError ERROR_RESOURCE_NOT_PRESENT
public MonoIOError ERROR_INVALID_OPERATION
public MonoIOError ERROR_MEDIA_NOT_AVAILABLE
public MonoIOError ERROR_DEVICE_NOT_AVAILABLE
public MonoIOError ERROR_REQUEST_REFUSED
public MonoIOError ERROR_INVALID_DRIVE_OBJECT
public MonoIOError ERROR_LIBRARY_FULL
public MonoIOError ERROR_MEDIUM_NOT_ACCESSIBLE
public MonoIOError ERROR_UNABLE_TO_LOAD_MEDIUM
public MonoIOError ERROR_UNABLE_TO_INVENTORY_DRIVE
public MonoIOError ERROR_UNABLE_TO_INVENTORY_SLOT
public MonoIOError ERROR_UNABLE_TO_INVENTORY_TRANSPORT
public MonoIOError ERROR_TRANSPORT_FULL
public MonoIOError ERROR_CONTROLLING_IEPORT
public MonoIOError ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA
public MonoIOError ERROR_CLEANER_SLOT_SET
public MonoIOError ERROR_CLEANER_SLOT_NOT_SET
public MonoIOError ERROR_CLEANER_CARTRIDGE_SPENT
public MonoIOError ERROR_UNEXPECTED_OMID
public MonoIOError ERROR_CANT_DELETE_LAST_ITEM
public MonoIOError ERROR_MESSAGE_EXCEEDS_MAX_SIZE
public MonoIOError ERROR_VOLUME_CONTAINS_SYS_FILES
public MonoIOError ERROR_INDIGENOUS_TYPE
public MonoIOError ERROR_NO_SUPPORTING_DRIVES
public MonoIOError ERROR_CLEANER_CARTRIDGE_INSTALLED
public MonoIOError ERROR_FILE_OFFLINE
public MonoIOError ERROR_REMOTE_STORAGE_NOT_ACTIVE
public MonoIOError ERROR_REMOTE_STORAGE_MEDIA_ERROR
public MonoIOError ERROR_NOT_A_REPARSE_POINT
public MonoIOError ERROR_REPARSE_ATTRIBUTE_CONFLICT
public MonoIOError ERROR_INVALID_REPARSE_DATA
public MonoIOError ERROR_REPARSE_TAG_INVALID
public MonoIOError ERROR_REPARSE_TAG_MISMATCH
public MonoIOError ERROR_VOLUME_NOT_SIS_ENABLED
public MonoIOError ERROR_DEPENDENT_RESOURCE_EXISTS
public MonoIOError ERROR_DEPENDENCY_NOT_FOUND
public MonoIOError ERROR_DEPENDENCY_ALREADY_EXISTS
public MonoIOError ERROR_RESOURCE_NOT_ONLINE
public MonoIOError ERROR_HOST_NODE_NOT_AVAILABLE
public MonoIOError ERROR_RESOURCE_NOT_AVAILABLE
public MonoIOError ERROR_RESOURCE_NOT_FOUND
public MonoIOError ERROR_SHUTDOWN_CLUSTER
public MonoIOError ERROR_CANT_EVICT_ACTIVE_NODE
public MonoIOError ERROR_OBJECT_ALREADY_EXISTS
public MonoIOError ERROR_OBJECT_IN_LIST
public MonoIOError ERROR_GROUP_NOT_AVAILABLE
public MonoIOError ERROR_GROUP_NOT_FOUND
public MonoIOError ERROR_GROUP_NOT_ONLINE
public MonoIOError ERROR_HOST_NODE_NOT_RESOURCE_OWNER
public MonoIOError ERROR_HOST_NODE_NOT_GROUP_OWNER
public MonoIOError ERROR_RESMON_CREATE_FAILED
public MonoIOError ERROR_RESMON_ONLINE_FAILED
public MonoIOError ERROR_RESOURCE_ONLINE
public MonoIOError ERROR_QUORUM_RESOURCE
public MonoIOError ERROR_NOT_QUORUM_CAPABLE
public MonoIOError ERROR_CLUSTER_SHUTTING_DOWN
public MonoIOError ERROR_INVALID_STATE
public MonoIOError ERROR_RESOURCE_PROPERTIES_STORED
public MonoIOError ERROR_NOT_QUORUM_CLASS
public MonoIOError ERROR_CORE_RESOURCE
public MonoIOError ERROR_QUORUM_RESOURCE_ONLINE_FAILED
public MonoIOError ERROR_QUORUMLOG_OPEN_FAILED
public MonoIOError ERROR_CLUSTERLOG_CORRUPT
public MonoIOError ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE
public MonoIOError ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE
public MonoIOError ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND
public MonoIOError ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE
public MonoIOError ERROR_QUORUM_OWNER_ALIVE
public MonoIOError ERROR_NETWORK_NOT_AVAILABLE
public MonoIOError ERROR_NODE_NOT_AVAILABLE
public MonoIOError ERROR_ALL_NODES_NOT_AVAILABLE
public MonoIOError ERROR_RESOURCE_FAILED
public MonoIOError ERROR_CLUSTER_INVALID_NODE
public MonoIOError ERROR_CLUSTER_NODE_EXISTS
public MonoIOError ERROR_CLUSTER_JOIN_IN_PROGRESS
public MonoIOError ERROR_CLUSTER_NODE_NOT_FOUND
public MonoIOError ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND
public MonoIOError ERROR_CLUSTER_NETWORK_EXISTS
public MonoIOError ERROR_CLUSTER_NETWORK_NOT_FOUND
public MonoIOError ERROR_CLUSTER_NETINTERFACE_EXISTS
public MonoIOError ERROR_CLUSTER_NETINTERFACE_NOT_FOUND
public MonoIOError ERROR_CLUSTER_INVALID_REQUEST
public MonoIOError ERROR_CLUSTER_INVALID_NETWORK_PROVIDER
public MonoIOError ERROR_CLUSTER_NODE_DOWN
public MonoIOError ERROR_CLUSTER_NODE_UNREACHABLE
public MonoIOError ERROR_CLUSTER_NODE_NOT_MEMBER
public MonoIOError ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS
public MonoIOError ERROR_CLUSTER_INVALID_NETWORK
public MonoIOError ERROR_CLUSTER_NODE_UP
public MonoIOError ERROR_CLUSTER_IPADDR_IN_USE
public MonoIOError ERROR_CLUSTER_NODE_NOT_PAUSED
public MonoIOError ERROR_CLUSTER_NO_SECURITY_CONTEXT
public MonoIOError ERROR_CLUSTER_NETWORK_NOT_INTERNAL
public MonoIOError ERROR_CLUSTER_NODE_ALREADY_UP
public MonoIOError ERROR_CLUSTER_NODE_ALREADY_DOWN
public MonoIOError ERROR_CLUSTER_NETWORK_ALREADY_ONLINE
public MonoIOError ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE
public MonoIOError ERROR_CLUSTER_NODE_ALREADY_MEMBER
public MonoIOError ERROR_CLUSTER_LAST_INTERNAL_NETWORK
public MonoIOError ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS
public MonoIOError ERROR_INVALID_OPERATION_ON_QUORUM
public MonoIOError ERROR_DEPENDENCY_NOT_ALLOWED
public MonoIOError ERROR_CLUSTER_NODE_PAUSED
public MonoIOError ERROR_NODE_CANT_HOST_RESOURCE
public MonoIOError ERROR_CLUSTER_NODE_NOT_READY
public MonoIOError ERROR_CLUSTER_NODE_SHUTTING_DOWN
public MonoIOError ERROR_CLUSTER_JOIN_ABORTED
public MonoIOError ERROR_CLUSTER_INCOMPATIBLE_VERSIONS
public MonoIOError ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED
public MonoIOError ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED
public MonoIOError ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND
public MonoIOError ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED
public MonoIOError ERROR_CLUSTER_RESNAME_NOT_FOUND
public MonoIOError ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED
public MonoIOError ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST
public MonoIOError ERROR_CLUSTER_DATABASE_SEQMISMATCH
public MonoIOError ERROR_RESMON_INVALID_STATE
public MonoIOError ERROR_CLUSTER_GUM_NOT_LOCKER
public MonoIOError ERROR_QUORUM_DISK_NOT_FOUND
public MonoIOError ERROR_DATABASE_BACKUP_CORRUPT
public MonoIOError ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT
public MonoIOError ERROR_RESOURCE_PROPERTY_UNCHANGEABLE
public MonoIOError ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE
public MonoIOError ERROR_CLUSTER_QUORUMLOG_NOT_FOUND
public MonoIOError ERROR_CLUSTER_MEMBERSHIP_HALT
public MonoIOError ERROR_CLUSTER_INSTANCE_ID_MISMATCH
public MonoIOError ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP
public MonoIOError ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH
public MonoIOError ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP
public MonoIOError ERROR_CLUSTER_PARAMETER_MISMATCH
public MonoIOError ERROR_NODE_CANNOT_BE_CLUSTERED
public MonoIOError ERROR_CLUSTER_WRONG_OS_VERSION
public MonoIOError ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME
public MonoIOError ERROR_ENCRYPTION_FAILED
public MonoIOError ERROR_DECRYPTION_FAILED
public MonoIOError ERROR_FILE_ENCRYPTED
public MonoIOError ERROR_NO_RECOVERY_POLICY
public MonoIOError ERROR_NO_EFS
public MonoIOError ERROR_WRONG_EFS
public MonoIOError ERROR_NO_USER_KEYS
public MonoIOError ERROR_FILE_NOT_ENCRYPTED
public MonoIOError ERROR_NOT_EXPORT_FORMAT
public MonoIOError ERROR_FILE_READ_ONLY
public MonoIOError ERROR_DIR_EFS_DISALLOWED
public MonoIOError ERROR_EFS_SERVER_NOT_TRUSTED
public MonoIOError ERROR_BAD_RECOVERY_POLICY
public MonoIOError ERROR_EFS_ALG_BLOB_TOO_BIG
public MonoIOError ERROR_VOLUME_NOT_SUPPORT_EFS
public MonoIOError ERROR_EFS_DISABLED
public MonoIOError ERROR_EFS_VERSION_NOT_SUPPORT
public MonoIOError ERROR_NO_BROWSER_SERVERS_FOUND
public MonoIOError SCHED_E_SERVICE_NOT_LOCALSYSTEM
public MonoIOError ERROR_CTX_WINSTATION_NAME_INVALID
public MonoIOError ERROR_CTX_INVALID_PD
public MonoIOError ERROR_CTX_PD_NOT_FOUND
public MonoIOError ERROR_CTX_WD_NOT_FOUND
public MonoIOError ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY
public MonoIOError ERROR_CTX_SERVICE_NAME_COLLISION
public MonoIOError ERROR_CTX_CLOSE_PENDING
public MonoIOError ERROR_CTX_NO_OUTBUF
public MonoIOError ERROR_CTX_MODEM_INF_NOT_FOUND
public MonoIOError ERROR_CTX_INVALID_MODEMNAME
public MonoIOError ERROR_CTX_MODEM_RESPONSE_ERROR
public MonoIOError ERROR_CTX_MODEM_RESPONSE_TIMEOUT
public MonoIOError ERROR_CTX_MODEM_RESPONSE_NO_CARRIER
public MonoIOError ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE
public MonoIOError ERROR_CTX_MODEM_RESPONSE_BUSY
public MonoIOError ERROR_CTX_MODEM_RESPONSE_VOICE
public MonoIOError ERROR_CTX_TD_ERROR
public MonoIOError ERROR_CTX_WINSTATION_NOT_FOUND
public MonoIOError ERROR_CTX_WINSTATION_ALREADY_EXISTS
public MonoIOError ERROR_CTX_WINSTATION_BUSY
public MonoIOError ERROR_CTX_BAD_VIDEO_MODE
public MonoIOError ERROR_CTX_GRAPHICS_INVALID
public MonoIOError ERROR_CTX_LOGON_DISABLED
public MonoIOError ERROR_CTX_NOT_CONSOLE
public MonoIOError ERROR_CTX_CLIENT_QUERY_TIMEOUT
public MonoIOError ERROR_CTX_CONSOLE_DISCONNECT
public MonoIOError ERROR_CTX_CONSOLE_CONNECT
public MonoIOError ERROR_CTX_SHADOW_DENIED
public MonoIOError ERROR_CTX_WINSTATION_ACCESS_DENIED
public MonoIOError ERROR_CTX_INVALID_WD
public MonoIOError ERROR_CTX_SHADOW_INVALID
public MonoIOError ERROR_CTX_SHADOW_DISABLED
public MonoIOError ERROR_CTX_CLIENT_LICENSE_IN_USE
public MonoIOError ERROR_CTX_CLIENT_LICENSE_NOT_SET
public MonoIOError ERROR_CTX_LICENSE_NOT_AVAILABLE
public MonoIOError ERROR_CTX_LICENSE_CLIENT_INVALID
public MonoIOError ERROR_CTX_LICENSE_EXPIRED
public MonoIOError ERROR_CTX_SHADOW_NOT_RUNNING
public MonoIOError ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE
public MonoIOError FRS_ERR_INVALID_API_SEQUENCE
public MonoIOError FRS_ERR_STARTING_SERVICE
public MonoIOError FRS_ERR_STOPPING_SERVICE
public MonoIOError FRS_ERR_INTERNAL_API
public MonoIOError FRS_ERR_INTERNAL
public MonoIOError FRS_ERR_SERVICE_COMM
public MonoIOError FRS_ERR_INSUFFICIENT_PRIV
public MonoIOError FRS_ERR_AUTHENTICATION
public MonoIOError FRS_ERR_PARENT_INSUFFICIENT_PRIV
public MonoIOError FRS_ERR_PARENT_AUTHENTICATION
public MonoIOError FRS_ERR_CHILD_TO_PARENT_COMM
public MonoIOError FRS_ERR_PARENT_TO_CHILD_COMM
public MonoIOError FRS_ERR_SYSVOL_POPULATE
public MonoIOError FRS_ERR_SYSVOL_POPULATE_TIMEOUT
public MonoIOError FRS_ERR_SYSVOL_IS_BUSY
public MonoIOError FRS_ERR_SYSVOL_DEMOTE
public MonoIOError FRS_ERR_INVALID_SERVICE_PARAMETER
public MonoIOError ERROR_DS_NOT_INSTALLED
public MonoIOError ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY
public MonoIOError ERROR_DS_NO_ATTRIBUTE_OR_VALUE
public MonoIOError ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
public MonoIOError ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED
public MonoIOError ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS
public MonoIOError ERROR_DS_BUSY
public MonoIOError ERROR_DS_UNAVAILABLE
public MonoIOError ERROR_DS_NO_RIDS_ALLOCATED
public MonoIOError ERROR_DS_NO_MORE_RIDS
public MonoIOError ERROR_DS_INCORRECT_ROLE_OWNER
public MonoIOError ERROR_DS_RIDMGR_INIT_ERROR
public MonoIOError ERROR_DS_OBJ_CLASS_VIOLATION
public MonoIOError ERROR_DS_CANT_ON_NON_LEAF
public MonoIOError ERROR_DS_CANT_ON_RDN
public MonoIOError ERROR_DS_CANT_MOD_OBJ_CLASS
public MonoIOError ERROR_DS_CROSS_DOM_MOVE_ERROR
public MonoIOError ERROR_DS_GC_NOT_AVAILABLE
public MonoIOError ERROR_SHARED_POLICY
public MonoIOError ERROR_POLICY_OBJECT_NOT_FOUND
public MonoIOError ERROR_POLICY_ONLY_IN_DS
public MonoIOError ERROR_PROMOTION_ACTIVE
public MonoIOError ERROR_NO_PROMOTION_ACTIVE
public MonoIOError ERROR_DS_OPERATIONS_ERROR
public MonoIOError ERROR_DS_PROTOCOL_ERROR
public MonoIOError ERROR_DS_TIMELIMIT_EXCEEDED
public MonoIOError ERROR_DS_SIZELIMIT_EXCEEDED
public MonoIOError ERROR_DS_ADMIN_LIMIT_EXCEEDED
public MonoIOError ERROR_DS_COMPARE_FALSE
public MonoIOError ERROR_DS_COMPARE_TRUE
public MonoIOError ERROR_DS_AUTH_METHOD_NOT_SUPPORTED
public MonoIOError ERROR_DS_STRONG_AUTH_REQUIRED
public MonoIOError ERROR_DS_INAPPROPRIATE_AUTH
public MonoIOError ERROR_DS_AUTH_UNKNOWN
public MonoIOError ERROR_DS_REFERRAL
public MonoIOError ERROR_DS_UNAVAILABLE_CRIT_EXTENSION
public MonoIOError ERROR_DS_CONFIDENTIALITY_REQUIRED
public MonoIOError ERROR_DS_INAPPROPRIATE_MATCHING
public MonoIOError ERROR_DS_CONSTRAINT_VIOLATION
public MonoIOError ERROR_DS_NO_SUCH_OBJECT
public MonoIOError ERROR_DS_ALIAS_PROBLEM
public MonoIOError ERROR_DS_INVALID_DN_SYNTAX
public MonoIOError ERROR_DS_IS_LEAF
public MonoIOError ERROR_DS_ALIAS_DEREF_PROBLEM
public MonoIOError ERROR_DS_UNWILLING_TO_PERFORM
public MonoIOError ERROR_DS_LOOP_DETECT
public MonoIOError ERROR_DS_NAMING_VIOLATION
public MonoIOError ERROR_DS_OBJECT_RESULTS_TOO_LARGE
public MonoIOError ERROR_DS_AFFECTS_MULTIPLE_DSAS
public MonoIOError ERROR_DS_SERVER_DOWN
public MonoIOError ERROR_DS_LOCAL_ERROR
public MonoIOError ERROR_DS_ENCODING_ERROR
public MonoIOError ERROR_DS_DECODING_ERROR
public MonoIOError ERROR_DS_FILTER_UNKNOWN
public MonoIOError ERROR_DS_PARAM_ERROR
public MonoIOError ERROR_DS_NOT_SUPPORTED
public MonoIOError ERROR_DS_NO_RESULTS_RETURNED
public MonoIOError ERROR_DS_CONTROL_NOT_FOUND
public MonoIOError ERROR_DS_CLIENT_LOOP
public MonoIOError ERROR_DS_REFERRAL_LIMIT_EXCEEDED
public MonoIOError ERROR_DS_SORT_CONTROL_MISSING
public MonoIOError ERROR_DS_OFFSET_RANGE_ERROR
public MonoIOError ERROR_DS_ROOT_MUST_BE_NC
public MonoIOError ERROR_DS_ADD_REPLICA_INHIBITED
public MonoIOError ERROR_DS_ATT_NOT_DEF_IN_SCHEMA
public MonoIOError ERROR_DS_MAX_OBJ_SIZE_EXCEEDED
public MonoIOError ERROR_DS_OBJ_STRING_NAME_EXISTS
public MonoIOError ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA
public MonoIOError ERROR_DS_RDN_DOESNT_MATCH_SCHEMA
public MonoIOError ERROR_DS_NO_REQUESTED_ATTS_FOUND
public MonoIOError ERROR_DS_USER_BUFFER_TO_SMALL
public MonoIOError ERROR_DS_ATT_IS_NOT_ON_OBJ
public MonoIOError ERROR_DS_ILLEGAL_MOD_OPERATION
public MonoIOError ERROR_DS_OBJ_TOO_LARGE
public MonoIOError ERROR_DS_BAD_INSTANCE_TYPE
public MonoIOError ERROR_DS_MASTERDSA_REQUIRED
public MonoIOError ERROR_DS_OBJECT_CLASS_REQUIRED
public MonoIOError ERROR_DS_MISSING_REQUIRED_ATT
public MonoIOError ERROR_DS_ATT_NOT_DEF_FOR_CLASS
public MonoIOError ERROR_DS_ATT_ALREADY_EXISTS
public MonoIOError ERROR_DS_CANT_ADD_ATT_VALUES
public MonoIOError ERROR_DS_SINGLE_VALUE_CONSTRAINT
public MonoIOError ERROR_DS_RANGE_CONSTRAINT
public MonoIOError ERROR_DS_ATT_VAL_ALREADY_EXISTS
public MonoIOError ERROR_DS_CANT_REM_MISSING_ATT
public MonoIOError ERROR_DS_CANT_REM_MISSING_ATT_VAL
public MonoIOError ERROR_DS_ROOT_CANT_BE_SUBREF
public MonoIOError ERROR_DS_NO_CHAINING
public MonoIOError ERROR_DS_NO_CHAINED_EVAL
public MonoIOError ERROR_DS_NO_PARENT_OBJECT
public MonoIOError ERROR_DS_PARENT_IS_AN_ALIAS
public MonoIOError ERROR_DS_CANT_MIX_MASTER_AND_REPS
public MonoIOError ERROR_DS_CHILDREN_EXIST
public MonoIOError ERROR_DS_OBJ_NOT_FOUND
public MonoIOError ERROR_DS_ALIASED_OBJ_MISSING
public MonoIOError ERROR_DS_BAD_NAME_SYNTAX
public MonoIOError ERROR_DS_ALIAS_POINTS_TO_ALIAS
public MonoIOError ERROR_DS_CANT_DEREF_ALIAS
public MonoIOError ERROR_DS_OUT_OF_SCOPE
public MonoIOError ERROR_DS_OBJECT_BEING_REMOVED
public MonoIOError ERROR_DS_CANT_DELETE_DSA_OBJ
public MonoIOError ERROR_DS_GENERIC_ERROR
public MonoIOError ERROR_DS_DSA_MUST_BE_INT_MASTER
public MonoIOError ERROR_DS_CLASS_NOT_DSA
public MonoIOError ERROR_DS_INSUFF_ACCESS_RIGHTS
public MonoIOError ERROR_DS_ILLEGAL_SUPERIOR
public MonoIOError ERROR_DS_ATTRIBUTE_OWNED_BY_SAM
public MonoIOError ERROR_DS_NAME_TOO_MANY_PARTS
public MonoIOError ERROR_DS_NAME_TOO_LONG
public MonoIOError ERROR_DS_NAME_VALUE_TOO_LONG
public MonoIOError ERROR_DS_NAME_UNPARSEABLE
public MonoIOError ERROR_DS_NAME_TYPE_UNKNOWN
public MonoIOError ERROR_DS_NOT_AN_OBJECT
public MonoIOError ERROR_DS_SEC_DESC_TOO_SHORT
public MonoIOError ERROR_DS_SEC_DESC_INVALID
public MonoIOError ERROR_DS_NO_DELETED_NAME
public MonoIOError ERROR_DS_SUBREF_MUST_HAVE_PARENT
public MonoIOError ERROR_DS_NCNAME_MUST_BE_NC
public MonoIOError ERROR_DS_CANT_ADD_SYSTEM_ONLY
public MonoIOError ERROR_DS_CLASS_MUST_BE_CONCRETE
public MonoIOError ERROR_DS_INVALID_DMD
public MonoIOError ERROR_DS_OBJ_GUID_EXISTS
public MonoIOError ERROR_DS_NOT_ON_BACKLINK
public MonoIOError ERROR_DS_NO_CROSSREF_FOR_NC
public MonoIOError ERROR_DS_SHUTTING_DOWN
public MonoIOError ERROR_DS_UNKNOWN_OPERATION
public MonoIOError ERROR_DS_INVALID_ROLE_OWNER
public MonoIOError ERROR_DS_COULDNT_CONTACT_FSMO
public MonoIOError ERROR_DS_CROSS_NC_DN_RENAME
public MonoIOError ERROR_DS_CANT_MOD_SYSTEM_ONLY
public MonoIOError ERROR_DS_REPLICATOR_ONLY
public MonoIOError ERROR_DS_OBJ_CLASS_NOT_DEFINED
public MonoIOError ERROR_DS_OBJ_CLASS_NOT_SUBCLASS
public MonoIOError ERROR_DS_NAME_REFERENCE_INVALID
public MonoIOError ERROR_DS_CROSS_REF_EXISTS
public MonoIOError ERROR_DS_CANT_DEL_MASTER_CROSSREF
public MonoIOError ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD
public MonoIOError ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX
public MonoIOError ERROR_DS_DUP_RDN
public MonoIOError ERROR_DS_DUP_OID
public MonoIOError ERROR_DS_DUP_MAPI_ID
public MonoIOError ERROR_DS_DUP_SCHEMA_ID_GUID
public MonoIOError ERROR_DS_DUP_LDAP_DISPLAY_NAME
public MonoIOError ERROR_DS_SEMANTIC_ATT_TEST
public MonoIOError ERROR_DS_SYNTAX_MISMATCH
public MonoIOError ERROR_DS_EXISTS_IN_MUST_HAVE
public MonoIOError ERROR_DS_EXISTS_IN_MAY_HAVE
public MonoIOError ERROR_DS_NONEXISTENT_MAY_HAVE
public MonoIOError ERROR_DS_NONEXISTENT_MUST_HAVE
public MonoIOError ERROR_DS_AUX_CLS_TEST_FAIL
public MonoIOError ERROR_DS_NONEXISTENT_POSS_SUP
public MonoIOError ERROR_DS_SUB_CLS_TEST_FAIL
public MonoIOError ERROR_DS_BAD_RDN_ATT_ID_SYNTAX
public MonoIOError ERROR_DS_EXISTS_IN_AUX_CLS
public MonoIOError ERROR_DS_EXISTS_IN_SUB_CLS
public MonoIOError ERROR_DS_EXISTS_IN_POSS_SUP
public MonoIOError ERROR_DS_RECALCSCHEMA_FAILED
public MonoIOError ERROR_DS_TREE_DELETE_NOT_FINISHED
public MonoIOError ERROR_DS_CANT_DELETE
public MonoIOError ERROR_DS_ATT_SCHEMA_REQ_ID
public MonoIOError ERROR_DS_BAD_ATT_SCHEMA_SYNTAX
public MonoIOError ERROR_DS_CANT_CACHE_ATT
public MonoIOError ERROR_DS_CANT_CACHE_CLASS
public MonoIOError ERROR_DS_CANT_REMOVE_ATT_CACHE
public MonoIOError ERROR_DS_CANT_REMOVE_CLASS_CACHE
public MonoIOError ERROR_DS_CANT_RETRIEVE_DN
public MonoIOError ERROR_DS_MISSING_SUPREF
public MonoIOError ERROR_DS_CANT_RETRIEVE_INSTANCE
public MonoIOError ERROR_DS_CODE_INCONSISTENCY
public MonoIOError ERROR_DS_DATABASE_ERROR
public MonoIOError ERROR_DS_GOVERNSID_MISSING
public MonoIOError ERROR_DS_MISSING_EXPECTED_ATT
public MonoIOError ERROR_DS_NCNAME_MISSING_CR_REF
public MonoIOError ERROR_DS_SECURITY_CHECKING_ERROR
public MonoIOError ERROR_DS_SCHEMA_NOT_LOADED
public MonoIOError ERROR_DS_SCHEMA_ALLOC_FAILED
public MonoIOError ERROR_DS_ATT_SCHEMA_REQ_SYNTAX
public MonoIOError ERROR_DS_GCVERIFY_ERROR
public MonoIOError ERROR_DS_DRA_SCHEMA_MISMATCH
public MonoIOError ERROR_DS_CANT_FIND_DSA_OBJ
public MonoIOError ERROR_DS_CANT_FIND_EXPECTED_NC
public MonoIOError ERROR_DS_CANT_FIND_NC_IN_CACHE
public MonoIOError ERROR_DS_CANT_RETRIEVE_CHILD
public MonoIOError ERROR_DS_SECURITY_ILLEGAL_MODIFY
public MonoIOError ERROR_DS_CANT_REPLACE_HIDDEN_REC
public MonoIOError ERROR_DS_BAD_HIERARCHY_FILE
public MonoIOError ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED
public MonoIOError ERROR_DS_CONFIG_PARAM_MISSING
public MonoIOError ERROR_DS_COUNTING_AB_INDICES_FAILED
public MonoIOError ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED
public MonoIOError ERROR_DS_INTERNAL_FAILURE
public MonoIOError ERROR_DS_UNKNOWN_ERROR
public MonoIOError ERROR_DS_ROOT_REQUIRES_CLASS_TOP
public MonoIOError ERROR_DS_REFUSING_FSMO_ROLES
public MonoIOError ERROR_DS_MISSING_FSMO_SETTINGS
public MonoIOError ERROR_DS_UNABLE_TO_SURRENDER_ROLES
public MonoIOError ERROR_DS_DRA_GENERIC
public MonoIOError ERROR_DS_DRA_INVALID_PARAMETER
public MonoIOError ERROR_DS_DRA_BUSY
public MonoIOError ERROR_DS_DRA_BAD_DN
public MonoIOError ERROR_DS_DRA_BAD_NC
public MonoIOError ERROR_DS_DRA_DN_EXISTS
public MonoIOError ERROR_DS_DRA_INTERNAL_ERROR
public MonoIOError ERROR_DS_DRA_INCONSISTENT_DIT
public MonoIOError ERROR_DS_DRA_CONNECTION_FAILED
public MonoIOError ERROR_DS_DRA_BAD_INSTANCE_TYPE
public MonoIOError ERROR_DS_DRA_OUT_OF_MEM
public MonoIOError ERROR_DS_DRA_MAIL_PROBLEM
public MonoIOError ERROR_DS_DRA_REF_ALREADY_EXISTS
public MonoIOError ERROR_DS_DRA_REF_NOT_FOUND
public MonoIOError ERROR_DS_DRA_OBJ_IS_REP_SOURCE
public MonoIOError ERROR_DS_DRA_DB_ERROR
public MonoIOError ERROR_DS_DRA_NO_REPLICA
public MonoIOError ERROR_DS_DRA_ACCESS_DENIED
public MonoIOError ERROR_DS_DRA_NOT_SUPPORTED
public MonoIOError ERROR_DS_DRA_RPC_CANCELLED
public MonoIOError ERROR_DS_DRA_SOURCE_DISABLED
public MonoIOError ERROR_DS_DRA_SINK_DISABLED
public MonoIOError ERROR_DS_DRA_NAME_COLLISION
public MonoIOError ERROR_DS_DRA_SOURCE_REINSTALLED
public MonoIOError ERROR_DS_DRA_MISSING_PARENT
public MonoIOError ERROR_DS_DRA_PREEMPTED
public MonoIOError ERROR_DS_DRA_ABANDON_SYNC
public MonoIOError ERROR_DS_DRA_SHUTDOWN
public MonoIOError ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET
public MonoIOError ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA
public MonoIOError ERROR_DS_DRA_EXTN_CONNECTION_FAILED
public MonoIOError ERROR_DS_INSTALL_SCHEMA_MISMATCH
public MonoIOError ERROR_DS_DUP_LINK_ID
public MonoIOError ERROR_DS_NAME_ERROR_RESOLVING
public MonoIOError ERROR_DS_NAME_ERROR_NOT_FOUND
public MonoIOError ERROR_DS_NAME_ERROR_NOT_UNIQUE
public MonoIOError ERROR_DS_NAME_ERROR_NO_MAPPING
public MonoIOError ERROR_DS_NAME_ERROR_DOMAIN_ONLY
public MonoIOError ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
public MonoIOError ERROR_DS_CONSTRUCTED_ATT_MOD
public MonoIOError ERROR_DS_WRONG_OM_OBJ_CLASS
public MonoIOError ERROR_DS_DRA_REPL_PENDING
public MonoIOError ERROR_DS_DS_REQUIRED
public MonoIOError ERROR_DS_INVALID_LDAP_DISPLAY_NAME
public MonoIOError ERROR_DS_NON_BASE_SEARCH
public MonoIOError ERROR_DS_CANT_RETRIEVE_ATTS
public MonoIOError ERROR_DS_BACKLINK_WITHOUT_LINK
public MonoIOError ERROR_DS_EPOCH_MISMATCH
public MonoIOError ERROR_DS_SRC_NAME_MISMATCH
public MonoIOError ERROR_DS_SRC_AND_DST_NC_IDENTICAL
public MonoIOError ERROR_DS_DST_NC_MISMATCH
public MonoIOError ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC
public MonoIOError ERROR_DS_SRC_GUID_MISMATCH
public MonoIOError ERROR_DS_CANT_MOVE_DELETED_OBJECT
public MonoIOError ERROR_DS_PDC_OPERATION_IN_PROGRESS
public MonoIOError ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD
public MonoIOError ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION
public MonoIOError ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS
public MonoIOError ERROR_DS_NC_MUST_HAVE_NC_PARENT
public MonoIOError ERROR_DS_DST_DOMAIN_NOT_NATIVE
public MonoIOError ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER
public MonoIOError ERROR_DS_CANT_MOVE_ACCOUNT_GROUP
public MonoIOError ERROR_DS_CANT_MOVE_RESOURCE_GROUP
public MonoIOError ERROR_DS_INVALID_SEARCH_FLAG
public MonoIOError ERROR_DS_NO_TREE_DELETE_ABOVE_NC
public MonoIOError ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE
public MonoIOError ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE
public MonoIOError ERROR_DS_SAM_INIT_FAILURE
public MonoIOError ERROR_DS_SENSITIVE_GROUP_VIOLATION
public MonoIOError ERROR_DS_CANT_MOD_PRIMARYGROUPID
public MonoIOError ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD
public MonoIOError ERROR_DS_NONSAFE_SCHEMA_CHANGE
public MonoIOError ERROR_DS_SCHEMA_UPDATE_DISALLOWED
public MonoIOError ERROR_DS_CANT_CREATE_UNDER_SCHEMA
public MonoIOError ERROR_DS_INSTALL_NO_SRC_SCH_VERSION
public MonoIOError ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE
public MonoIOError ERROR_DS_INVALID_GROUP_TYPE
public MonoIOError ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN
public MonoIOError ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN
public MonoIOError ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER
public MonoIOError ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER
public MonoIOError ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER
public MonoIOError ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER
public MonoIOError ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER
public MonoIOError ERROR_DS_HAVE_PRIMARY_MEMBERS
public MonoIOError ERROR_DS_STRING_SD_CONVERSION_FAILED
public MonoIOError ERROR_DS_NAMING_MASTER_GC
public MonoIOError ERROR_DS_LOOKUP_FAILURE
public MonoIOError ERROR_DS_COULDNT_UPDATE_SPNS
public MonoIOError ERROR_DS_CANT_RETRIEVE_SD
public MonoIOError ERROR_DS_KEY_NOT_UNIQUE
public MonoIOError ERROR_DS_WRONG_LINKED_ATT_SYNTAX
public MonoIOError ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD
public MonoIOError ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY
public MonoIOError ERROR_DS_CANT_START
public MonoIOError ERROR_DS_INIT_FAILURE
public MonoIOError ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION
public MonoIOError ERROR_DS_SOURCE_DOMAIN_IN_FOREST
public MonoIOError ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST
public MonoIOError ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED
public MonoIOError ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN
public MonoIOError ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER
public MonoIOError ERROR_DS_SRC_SID_EXISTS_IN_FOREST
public MonoIOError ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH
public MonoIOError ERROR_SAM_INIT_FAILURE
public MonoIOError ERROR_DS_DRA_SCHEMA_INFO_SHIP
public MonoIOError ERROR_DS_DRA_SCHEMA_CONFLICT
public MonoIOError ERROR_DS_DRA_EARLIER_SCHEMA_CONLICT
public MonoIOError ERROR_DS_DRA_OBJ_NC_MISMATCH
public MonoIOError ERROR_DS_NC_STILL_HAS_DSAS
public MonoIOError ERROR_DS_GC_REQUIRED
public MonoIOError ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY
public MonoIOError ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS
public MonoIOError ERROR_DS_CANT_ADD_TO_GC
public MonoIOError ERROR_DS_NO_CHECKPOINT_WITH_PDC
public MonoIOError ERROR_DS_SOURCE_AUDITING_NOT_ENABLED
public MonoIOError ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC
public MonoIOError ERROR_DS_INVALID_NAME_FOR_SPN
public MonoIOError ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS
public MonoIOError ERROR_DS_UNICODEPWD_NOT_IN_QUOTES
public MonoIOError ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED
public MonoIOError ERROR_DS_MUST_BE_RUN_ON_DST_DC
public MonoIOError ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER
public MonoIOError ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ
public MonoIOError ERROR_DS_INIT_FAILURE_CONSOLE
public MonoIOError ERROR_DS_SAM_INIT_FAILURE_CONSOLE
public MonoIOError ERROR_DS_FOREST_VERSION_TOO_HIGH
public MonoIOError ERROR_DS_DOMAIN_VERSION_TOO_HIGH
public MonoIOError ERROR_DS_FOREST_VERSION_TOO_LOW
public MonoIOError ERROR_DS_DOMAIN_VERSION_TOO_LOW
public MonoIOError ERROR_DS_INCOMPATIBLE_VERSION
public MonoIOError ERROR_DS_LOW_DSA_VERSION
public MonoIOError ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN
public MonoIOError ERROR_DS_NOT_SUPPORTED_SORT_ORDER
public MonoIOError ERROR_DS_NAME_NOT_UNIQUE
public MonoIOError ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4
public MonoIOError ERROR_DS_OUT_OF_VERSION_STORE
public MonoIOError ERROR_DS_INCOMPATIBLE_CONTROLS_USED
public MonoIOError ERROR_DS_NO_REF_DOMAIN
public MonoIOError ERROR_DS_RESERVED_LINK_ID
public MonoIOError ERROR_DS_LINK_ID_NOT_AVAILABLE
public MonoIOError ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER
public MonoIOError ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE
public MonoIOError ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC
public MonoIOError ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG
public MonoIOError ERROR_DS_MODIFYDN_WRONG_GRANDPARENT
public MonoIOError ERROR_DS_NAME_ERROR_TRUST_REFERRAL
public MonoIOError ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER
public MonoIOError ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD
public MonoIOError ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE
public MonoIOError ERROR_DS_THREAD_LIMIT_EXCEEDED
public MonoIOError ERROR_DS_NOT_CLOSEST
public MonoIOError ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF
public MonoIOError ERROR_DS_SINGLE_USER_MODE_FAILED
public MonoIOError ERROR_DS_NTDSCRIPT_SYNTAX_ERROR
public MonoIOError ERROR_DS_NTDSCRIPT_PROCESS_ERROR
public MonoIOError ERROR_DS_DIFFERENT_REPL_EPOCHS
public MonoIOError ERROR_DS_DRS_EXTENSIONS_CHANGED
public MonoIOError ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR
public MonoIOError ERROR_DS_NO_MSDS_INTID
public MonoIOError ERROR_DS_DUP_MSDS_INTID
public MonoIOError ERROR_DS_EXISTS_IN_RDNATTID
public MonoIOError ERROR_DS_AUTHORIZATION_FAILED
public MonoIOError ERROR_DS_INVALID_SCRIPT
public MonoIOError ERROR_DS_REMOTE_CROSSREF_OP_FAILED
public MonoIOError DNS_ERROR_RCODE_FORMAT_ERROR
public MonoIOError DNS_ERROR_RCODE_SERVER_FAILURE
public MonoIOError DNS_ERROR_RCODE_NAME_ERROR
public MonoIOError DNS_ERROR_RCODE_NOT_IMPLEMENTED
public MonoIOError DNS_ERROR_RCODE_REFUSED
public MonoIOError DNS_ERROR_RCODE_YXDOMAIN
public MonoIOError DNS_ERROR_RCODE_YXRRSET
public MonoIOError DNS_ERROR_RCODE_NXRRSET
public MonoIOError DNS_ERROR_RCODE_NOTAUTH
public MonoIOError DNS_ERROR_RCODE_NOTZONE
public MonoIOError DNS_ERROR_RCODE_BADSIG
public MonoIOError DNS_ERROR_RCODE_BADKEY
public MonoIOError DNS_ERROR_RCODE_BADTIME
public MonoIOError DNS_INFO_NO_RECORDS
public MonoIOError DNS_ERROR_BAD_PACKET
public MonoIOError DNS_ERROR_NO_PACKET
public MonoIOError DNS_ERROR_RCODE
public MonoIOError DNS_ERROR_UNSECURE_PACKET
public MonoIOError DNS_ERROR_INVALID_TYPE
public MonoIOError DNS_ERROR_INVALID_IP_ADDRESS
public MonoIOError DNS_ERROR_INVALID_PROPERTY
public MonoIOError DNS_ERROR_TRY_AGAIN_LATER
public MonoIOError DNS_ERROR_NOT_UNIQUE
public MonoIOError DNS_ERROR_NON_RFC_NAME
public MonoIOError DNS_STATUS_FQDN
public MonoIOError DNS_STATUS_DOTTED_NAME
public MonoIOError DNS_STATUS_SINGLE_PART_NAME
public MonoIOError DNS_ERROR_INVALID_NAME_CHAR
public MonoIOError DNS_ERROR_NUMERIC_NAME
public MonoIOError DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER
public MonoIOError DNS_ERROR_ZONE_DOES_NOT_EXIST
public MonoIOError DNS_ERROR_NO_ZONE_INFO
public MonoIOError DNS_ERROR_INVALID_ZONE_OPERATION
public MonoIOError DNS_ERROR_ZONE_CONFIGURATION_ERROR
public MonoIOError DNS_ERROR_ZONE_HAS_NO_SOA_RECORD
public MonoIOError DNS_ERROR_ZONE_HAS_NO_NS_RECORDS
public MonoIOError DNS_ERROR_ZONE_LOCKED
public MonoIOError DNS_ERROR_ZONE_CREATION_FAILED
public MonoIOError DNS_ERROR_ZONE_ALREADY_EXISTS
public MonoIOError DNS_ERROR_AUTOZONE_ALREADY_EXISTS
public MonoIOError DNS_ERROR_INVALID_ZONE_TYPE
public MonoIOError DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP
public MonoIOError DNS_ERROR_ZONE_NOT_SECONDARY
public MonoIOError DNS_ERROR_NEED_SECONDARY_ADDRESSES
public MonoIOError DNS_ERROR_WINS_INIT_FAILED
public MonoIOError DNS_ERROR_NEED_WINS_SERVERS
public MonoIOError DNS_ERROR_NBSTAT_INIT_FAILED
public MonoIOError DNS_ERROR_SOA_DELETE_INVALID
public MonoIOError DNS_ERROR_FORWARDER_ALREADY_EXISTS
public MonoIOError DNS_ERROR_ZONE_REQUIRES_MASTER_IP
public MonoIOError DNS_ERROR_ZONE_IS_SHUTDOWN
public MonoIOError DNS_ERROR_PRIMARY_REQUIRES_DATAFILE
public MonoIOError DNS_ERROR_INVALID_DATAFILE_NAME
public MonoIOError DNS_ERROR_DATAFILE_OPEN_FAILURE
public MonoIOError DNS_ERROR_FILE_WRITEBACK_FAILED
public MonoIOError DNS_ERROR_DATAFILE_PARSING
public MonoIOError DNS_ERROR_RECORD_DOES_NOT_EXIST
public MonoIOError DNS_ERROR_RECORD_FORMAT
public MonoIOError DNS_ERROR_NODE_CREATION_FAILED
public MonoIOError DNS_ERROR_UNKNOWN_RECORD_TYPE
public MonoIOError DNS_ERROR_RECORD_TIMED_OUT
public MonoIOError DNS_ERROR_NAME_NOT_IN_ZONE
public MonoIOError DNS_ERROR_CNAME_LOOP
public MonoIOError DNS_ERROR_NODE_IS_CNAME
public MonoIOError DNS_ERROR_CNAME_COLLISION
public MonoIOError DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT
public MonoIOError DNS_ERROR_RECORD_ALREADY_EXISTS
public MonoIOError DNS_ERROR_SECONDARY_DATA
public MonoIOError DNS_ERROR_NO_CREATE_CACHE_DATA
public MonoIOError DNS_ERROR_NAME_DOES_NOT_EXIST
public MonoIOError DNS_WARNING_PTR_CREATE_FAILED
public MonoIOError DNS_WARNING_DOMAIN_UNDELETED
public MonoIOError DNS_ERROR_DS_UNAVAILABLE
public MonoIOError DNS_ERROR_DS_ZONE_ALREADY_EXISTS
public MonoIOError DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE
public MonoIOError DNS_INFO_AXFR_COMPLETE
public MonoIOError DNS_ERROR_AXFR
public MonoIOError DNS_INFO_ADDED_LOCAL_WINS
public MonoIOError DNS_STATUS_CONTINUE_NEEDED
public MonoIOError DNS_ERROR_NO_TCPIP
public MonoIOError DNS_ERROR_NO_DNS_SERVERS
public MonoIOError DNS_ERROR_DP_DOES_NOT_EXIST
public MonoIOError DNS_ERROR_DP_ALREADY_EXISTS
public MonoIOError DNS_ERROR_DP_NOT_ENLISTED
public MonoIOError DNS_ERROR_DP_ALREADY_ENLISTED
public MonoIOError WSAEINTR
public MonoIOError WSAEBADF
public MonoIOError WSAEACCES
public MonoIOError WSAEFAULT
public MonoIOError WSAEINVAL
public MonoIOError WSAEMFILE
public MonoIOError WSAEWOULDBLOCK
public MonoIOError WSAEINPROGRESS
public MonoIOError WSAEALREADY
public MonoIOError WSAENOTSOCK
public MonoIOError WSAEDESTADDRREQ
public MonoIOError WSAEMSGSIZE
public MonoIOError WSAEPROTOTYPE
public MonoIOError WSAENOPROTOOPT
public MonoIOError WSAEPROTONOSUPPORT
public MonoIOError WSAESOCKTNOSUPPORT
public MonoIOError WSAEOPNOTSUPP
public MonoIOError WSAEPFNOSUPPORT
public MonoIOError WSAEAFNOSUPPORT
public MonoIOError WSAEADDRINUSE
public MonoIOError WSAEADDRNOTAVAIL
public MonoIOError WSAENETDOWN
public MonoIOError WSAENETUNREACH
public MonoIOError WSAENETRESET
public MonoIOError WSAECONNABORTED
public MonoIOError WSAECONNRESET
public MonoIOError WSAENOBUFS
public MonoIOError WSAEISCONN
public MonoIOError WSAENOTCONN
public MonoIOError WSAESHUTDOWN
public MonoIOError WSAETOOMANYREFS
public MonoIOError WSAETIMEDOUT
public MonoIOError WSAECONNREFUSED
public MonoIOError WSAELOOP
public MonoIOError WSAENAMETOOLONG
public MonoIOError WSAEHOSTDOWN
public MonoIOError WSAEHOSTUNREACH
public MonoIOError WSAENOTEMPTY
public MonoIOError WSAEPROCLIM
public MonoIOError WSAEUSERS
public MonoIOError WSAEDQUOT
public MonoIOError WSAESTALE
public MonoIOError WSAEREMOTE
public MonoIOError WSASYSNOTREADY
public MonoIOError WSAVERNOTSUPPORTED
public MonoIOError WSANOTINITIALISED
public MonoIOError WSAEDISCON
public MonoIOError WSAENOMORE
public MonoIOError WSAECANCELLED
public MonoIOError WSAEINVALIDPROCTABLE
public MonoIOError WSAEINVALIDPROVIDER
public MonoIOError WSAEPROVIDERFAILEDINIT
public MonoIOError WSASYSCALLFAILURE
public MonoIOError WSASERVICE_NOT_FOUND
public MonoIOError WSATYPE_NOT_FOUND
public MonoIOError WSA_E_NO_MORE
public MonoIOError WSA_E_CANCELLED
public MonoIOError WSAEREFUSED
public MonoIOError WSAHOST_NOT_FOUND
public MonoIOError WSATRY_AGAIN
public MonoIOError WSANO_RECOVERY
public MonoIOError WSANO_DATA
public MonoIOError WSA_QOS_RECEIVERS
public MonoIOError WSA_QOS_SENDERS
public MonoIOError WSA_QOS_NO_SENDERS
public MonoIOError WSA_QOS_NO_RECEIVERS
public MonoIOError WSA_QOS_REQUEST_CONFIRMED
public MonoIOError WSA_QOS_ADMISSION_FAILURE
public MonoIOError WSA_QOS_POLICY_FAILURE
public MonoIOError WSA_QOS_BAD_STYLE
public MonoIOError WSA_QOS_BAD_OBJECT
public MonoIOError WSA_QOS_TRAFFIC_CTRL_ERROR
public MonoIOError WSA_QOS_GENERIC_ERROR
public MonoIOError WSA_QOS_ESERVICETYPE
public MonoIOError WSA_QOS_EFLOWSPEC
public MonoIOError WSA_QOS_EPROVSPECBUF
public MonoIOError WSA_QOS_EFILTERSTYLE
public MonoIOError WSA_QOS_EFILTERTYPE
public MonoIOError WSA_QOS_EFILTERCOUNT
public MonoIOError WSA_QOS_EOBJLENGTH
public MonoIOError WSA_QOS_EFLOWCOUNT
public MonoIOError WSA_QOS_EUNKNOWNPSOBJ
public MonoIOError WSA_QOS_EPOLICYOBJ
public MonoIOError WSA_QOS_EFLOWDESC
public MonoIOError WSA_QOS_EPSFLOWSPEC
public MonoIOError WSA_QOS_EPSFILTERSPEC
public MonoIOError WSA_QOS_ESDMODEOBJ
public MonoIOError WSA_QOS_ESHAPERATEOBJ
public MonoIOError WSA_QOS_RESERVED_PETYPE
public MonoIOError ERROR_IPSEC_QM_POLICY_EXISTS
public MonoIOError ERROR_IPSEC_QM_POLICY_NOT_FOUND
public MonoIOError ERROR_IPSEC_QM_POLICY_IN_USE
public MonoIOError ERROR_IPSEC_MM_POLICY_EXISTS
public MonoIOError ERROR_IPSEC_MM_POLICY_NOT_FOUND
public MonoIOError ERROR_IPSEC_MM_POLICY_IN_USE
public MonoIOError ERROR_IPSEC_MM_FILTER_EXISTS
public MonoIOError ERROR_IPSEC_MM_FILTER_NOT_FOUND
public MonoIOError ERROR_IPSEC_TRANSPORT_FILTER_EXISTS
public MonoIOError ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND
public MonoIOError ERROR_IPSEC_MM_AUTH_EXISTS
public MonoIOError ERROR_IPSEC_MM_AUTH_NOT_FOUND
public MonoIOError ERROR_IPSEC_MM_AUTH_IN_USE
public MonoIOError ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND
public MonoIOError ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND
public MonoIOError ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND
public MonoIOError ERROR_IPSEC_TUNNEL_FILTER_EXISTS
public MonoIOError ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND
public MonoIOError ERROR_IPSEC_MM_FILTER_PENDING_DELETION
public MonoIOError ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION
public MonoIOError ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION
public MonoIOError ERROR_IPSEC_MM_POLICY_PENDING_DELETION
public MonoIOError ERROR_IPSEC_MM_AUTH_PENDING_DELETION
public MonoIOError ERROR_IPSEC_QM_POLICY_PENDING_DELETION
public MonoIOError ERROR_IPSEC_IKE_AUTH_FAIL
public MonoIOError ERROR_IPSEC_IKE_ATTRIB_FAIL
public MonoIOError ERROR_IPSEC_IKE_NEGOTIATION_PENDING
public MonoIOError ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR
public MonoIOError ERROR_IPSEC_IKE_TIMED_OUT
public MonoIOError ERROR_IPSEC_IKE_NO_CERT
public MonoIOError ERROR_IPSEC_IKE_SA_DELETED
public MonoIOError ERROR_IPSEC_IKE_SA_REAPED
public MonoIOError ERROR_IPSEC_IKE_MM_ACQUIRE_DROP
public MonoIOError ERROR_IPSEC_IKE_QM_ACQUIRE_DROP
public MonoIOError ERROR_IPSEC_IKE_QUEUE_DROP_MM
public MonoIOError ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM
public MonoIOError ERROR_IPSEC_IKE_DROP_NO_RESPONSE
public MonoIOError ERROR_IPSEC_IKE_MM_DELAY_DROP
public MonoIOError ERROR_IPSEC_IKE_QM_DELAY_DROP
public MonoIOError ERROR_IPSEC_IKE_ERROR
public MonoIOError ERROR_IPSEC_IKE_CRL_FAILED
public MonoIOError ERROR_IPSEC_IKE_INVALID_KEY_USAGE
public MonoIOError ERROR_IPSEC_IKE_INVALID_CERT_TYPE
public MonoIOError ERROR_IPSEC_IKE_NO_PRIVATE_KEY
public MonoIOError ERROR_IPSEC_IKE_DH_FAIL
public MonoIOError ERROR_IPSEC_IKE_INVALID_HEADER
public MonoIOError ERROR_IPSEC_IKE_NO_POLICY
public MonoIOError ERROR_IPSEC_IKE_INVALID_SIGNATURE
public MonoIOError ERROR_IPSEC_IKE_KERBEROS_ERROR
public MonoIOError ERROR_IPSEC_IKE_NO_PUBLIC_KEY
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_SA
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_PROP
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_TRANS
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_KE
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_ID
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_CERT
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_HASH
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_SIG
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_NONCE
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_DELETE
public MonoIOError ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR
public MonoIOError ERROR_IPSEC_IKE_INVALID_PAYLOAD
public MonoIOError ERROR_IPSEC_IKE_LOAD_SOFT_SA
public MonoIOError ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN
public MonoIOError ERROR_IPSEC_IKE_INVALID_COOKIE
public MonoIOError ERROR_IPSEC_IKE_NO_PEER_CERT
public MonoIOError ERROR_IPSEC_IKE_PEER_CRL_FAILED
public MonoIOError ERROR_IPSEC_IKE_POLICY_CHANGE
public MonoIOError ERROR_IPSEC_IKE_NO_MM_POLICY
public MonoIOError ERROR_IPSEC_IKE_NOTCBPRIV
public MonoIOError ERROR_IPSEC_IKE_SECLOADFAIL
public MonoIOError ERROR_IPSEC_IKE_FAILSSPINIT
public MonoIOError ERROR_IPSEC_IKE_FAILQUERYSSP
public MonoIOError ERROR_IPSEC_IKE_SRVACQFAIL
public MonoIOError ERROR_IPSEC_IKE_SRVQUERYCRED
public MonoIOError ERROR_IPSEC_IKE_GETSPIFAIL
public MonoIOError ERROR_IPSEC_IKE_INVALID_FILTER
public MonoIOError ERROR_IPSEC_IKE_OUT_OF_MEMORY
public MonoIOError ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED
public MonoIOError ERROR_IPSEC_IKE_INVALID_POLICY
public MonoIOError ERROR_IPSEC_IKE_UNKNOWN_DOI
public MonoIOError ERROR_IPSEC_IKE_INVALID_SITUATION
public MonoIOError ERROR_IPSEC_IKE_DH_FAILURE
public MonoIOError ERROR_IPSEC_IKE_INVALID_GROUP
public MonoIOError ERROR_IPSEC_IKE_ENCRYPT
public MonoIOError ERROR_IPSEC_IKE_DECRYPT
public MonoIOError ERROR_IPSEC_IKE_POLICY_MATCH
public MonoIOError ERROR_IPSEC_IKE_UNSUPPORTED_ID
public MonoIOError ERROR_IPSEC_IKE_INVALID_HASH
public MonoIOError ERROR_IPSEC_IKE_INVALID_HASH_ALG
public MonoIOError ERROR_IPSEC_IKE_INVALID_HASH_SIZE
public MonoIOError ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG
public MonoIOError ERROR_IPSEC_IKE_INVALID_AUTH_ALG
public MonoIOError ERROR_IPSEC_IKE_INVALID_SIG
public MonoIOError ERROR_IPSEC_IKE_LOAD_FAILED
public MonoIOError ERROR_IPSEC_IKE_RPC_DELETE
public MonoIOError ERROR_IPSEC_IKE_BENIGN_REINIT
public MonoIOError ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY
public MonoIOError ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN
public MonoIOError ERROR_IPSEC_IKE_MM_LIMIT
public MonoIOError ERROR_IPSEC_IKE_NEGOTIATION_DISABLED
public MonoIOError ERROR_IPSEC_IKE_NEG_STATUS_END
public MonoIOError ERROR_SXS_SECTION_NOT_FOUND
public MonoIOError ERROR_SXS_CANT_GEN_ACTCTX
public MonoIOError ERROR_SXS_INVALID_ACTCTXDATA_FORMAT
public MonoIOError ERROR_SXS_ASSEMBLY_NOT_FOUND
public MonoIOError ERROR_SXS_MANIFEST_FORMAT_ERROR
public MonoIOError ERROR_SXS_MANIFEST_PARSE_ERROR
public MonoIOError ERROR_SXS_ACTIVATION_CONTEXT_DISABLED
public MonoIOError ERROR_SXS_KEY_NOT_FOUND
public MonoIOError ERROR_SXS_VERSION_CONFLICT
public MonoIOError ERROR_SXS_WRONG_SECTION_TYPE
public MonoIOError ERROR_SXS_THREAD_QUERIES_DISABLED
public MonoIOError ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET
public MonoIOError ERROR_SXS_UNKNOWN_ENCODING_GROUP
public MonoIOError ERROR_SXS_UNKNOWN_ENCODING
public MonoIOError ERROR_SXS_INVALID_XML_NAMESPACE_URI
public MonoIOError ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED
public MonoIOError ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED
public MonoIOError ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE
public MonoIOError ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE
public MonoIOError ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE
public MonoIOError ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT
public MonoIOError ERROR_SXS_DUPLICATE_DLL_NAME
public MonoIOError ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME
public MonoIOError ERROR_SXS_DUPLICATE_CLSID
public MonoIOError ERROR_SXS_DUPLICATE_IID
public MonoIOError ERROR_SXS_DUPLICATE_TLBID
public MonoIOError ERROR_SXS_DUPLICATE_PROGID
public MonoIOError ERROR_SXS_DUPLICATE_ASSEMBLY_NAME
public MonoIOError ERROR_SXS_FILE_HASH_MISMATCH
public MonoIOError ERROR_SXS_POLICY_PARSE_ERROR
public MonoIOError ERROR_SXS_XML_E_MISSINGQUOTE
public MonoIOError ERROR_SXS_XML_E_COMMENTSYNTAX
public MonoIOError ERROR_SXS_XML_E_BADSTARTNAMECHAR
public MonoIOError ERROR_SXS_XML_E_BADNAMECHAR
public MonoIOError ERROR_SXS_XML_E_BADCHARINSTRING
public MonoIOError ERROR_SXS_XML_E_XMLDECLSYNTAX
public MonoIOError ERROR_SXS_XML_E_BADCHARDATA
public MonoIOError ERROR_SXS_XML_E_MISSINGWHITESPACE
public MonoIOError ERROR_SXS_XML_E_EXPECTINGTAGEND
public MonoIOError ERROR_SXS_XML_E_MISSINGSEMICOLON
public MonoIOError ERROR_SXS_XML_E_UNBALANCEDPAREN
public MonoIOError ERROR_SXS_XML_E_INTERNALERROR
public MonoIOError ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE
public MonoIOError ERROR_SXS_XML_E_INCOMPLETE_ENCODING
public MonoIOError ERROR_SXS_XML_E_MISSING_PAREN
public MonoIOError ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE
public MonoIOError ERROR_SXS_XML_E_MULTIPLE_COLONS
public MonoIOError ERROR_SXS_XML_E_INVALID_DECIMAL
public MonoIOError ERROR_SXS_XML_E_INVALID_HEXIDECIMAL
public MonoIOError ERROR_SXS_XML_E_INVALID_UNICODE
public MonoIOError ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK
public MonoIOError ERROR_SXS_XML_E_UNEXPECTEDENDTAG
public MonoIOError ERROR_SXS_XML_E_UNCLOSEDTAG
public MonoIOError ERROR_SXS_XML_E_DUPLICATEATTRIBUTE
public MonoIOError ERROR_SXS_XML_E_MULTIPLEROOTS
public MonoIOError ERROR_SXS_XML_E_INVALIDATROOTLEVEL
public MonoIOError ERROR_SXS_XML_E_BADXMLDECL
public MonoIOError ERROR_SXS_XML_E_MISSINGROOT
public MonoIOError ERROR_SXS_XML_E_UNEXPECTEDEOF
public MonoIOError ERROR_SXS_XML_E_BADPEREFINSUBSET
public MonoIOError ERROR_SXS_XML_E_UNCLOSEDSTARTTAG
public MonoIOError ERROR_SXS_XML_E_UNCLOSEDENDTAG
public MonoIOError ERROR_SXS_XML_E_UNCLOSEDSTRING
public MonoIOError ERROR_SXS_XML_E_UNCLOSEDCOMMENT
public MonoIOError ERROR_SXS_XML_E_UNCLOSEDDECL
public MonoIOError ERROR_SXS_XML_E_UNCLOSEDCDATA
public MonoIOError ERROR_SXS_XML_E_RESERVEDNAMESPACE
public MonoIOError ERROR_SXS_XML_E_INVALIDENCODING
public MonoIOError ERROR_SXS_XML_E_INVALIDSWITCH
public MonoIOError ERROR_SXS_XML_E_BADXMLCASE
public MonoIOError ERROR_SXS_XML_E_INVALID_STANDALONE
public MonoIOError ERROR_SXS_XML_E_UNEXPECTED_STANDALONE
public MonoIOError ERROR_SXS_XML_E_INVALID_VERSION
public MonoIOError ERROR_SXS_XML_E_MISSINGEQUALS
public MonoIOError ERROR_SXS_PROTECTION_RECOVERY_FAILED
public MonoIOError ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT
public MonoIOError ERROR_SXS_PROTECTION_CATALOG_NOT_VALID
public MonoIOError ERROR_SXS_UNTRANSLATABLE_HRESULT
public MonoIOError ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING
public MonoIOError ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE
public MonoIOError ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME
}
internal System.IO.MonoSyncFileStream : FileStream {
public void .ctor(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public void EndWrite(IAsyncResult asyncResult)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public int EndRead(IAsyncResult asyncResult)
}
public System.IO.NotifyFilters : Enum {
public int value__
public NotifyFilters Attributes
public NotifyFilters CreationTime
public NotifyFilters DirectoryName
public NotifyFilters FileName
public NotifyFilters LastAccess
public NotifyFilters LastWrite
public NotifyFilters Security
public NotifyFilters Size
}
internal System.IO.NullFileWatcher : object {
private IFileWatcher instance
public void StartDispatching(FileSystemWatcher fsw)
public void StopDispatching(FileSystemWatcher fsw)
public bool GetInstance(IFileWatcher& watcher)
}
internal System.IO.ParentInotifyData : object {
public bool IncludeSubdirs
public bool Enabled
public ArrayList children
public InotifyData data
}
internal System.IO.Ports.CommStat : object {
public UInt32 flags
public UInt32 BytesIn
public UInt32 BytesOut
}
internal System.IO.Ports.DCB : object {
private int fOutxCtsFlow
private int fOutX
private int fInX
private int fRtsControl2
public int dcb_length
public int baud_rate
public int flags
public short w_reserved
public short xon_lim
public short xoff_lim
public byte byte_size
public byte parity
public byte stop_bits
public byte xon_char
public byte xoff_char
public byte error_char
public byte eof_char
public byte evt_char
public short w_reserved1
public void SetValues(int baud_rate, Parity parity, int byte_size, StopBits sb, Handshake hs)
}
public System.IO.Ports.Handshake : Enum {
public int value__
public Handshake None
public Handshake XOnXOff
public Handshake RequestToSend
public Handshake RequestToSendXOnXOff
}
internal System.IO.Ports.ISerialStream {
public int BytesToRead
public int BytesToWrite
public int ReadTimeout
public int WriteTimeout
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
public void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits sb, Handshake hs)
public void DiscardInBuffer()
public void DiscardOutBuffer()
public SerialSignal GetSignals()
public void SetSignal(SerialSignal signal, bool value)
public void SetBreakState(bool value)
public void Close()
public int get_BytesToRead()
public int get_BytesToWrite()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
}
public System.IO.Ports.Parity : Enum {
public int value__
public Parity None
public Parity Odd
public Parity Even
public Parity Mark
public Parity Space
}
public System.IO.Ports.SerialData : Enum {
public int value__
public SerialData Chars
public SerialData Eof
}
public System.IO.Ports.SerialDataReceivedEventArgs : EventArgs {
private SerialData eventType
public SerialData EventType
internal void .ctor(SerialData eventType)
public SerialData get_EventType()
}
public System.IO.Ports.SerialDataReceivedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SerialDataReceivedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SerialDataReceivedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Ports.SerialError : Enum {
public int value__
public SerialError RXOver
public SerialError Overrun
public SerialError RXParity
public SerialError Frame
public SerialError TXFull
}
public System.IO.Ports.SerialErrorReceivedEventArgs : EventArgs {
private SerialError eventType
public SerialError EventType
internal void .ctor(SerialError eventType)
public SerialError get_EventType()
}
public System.IO.Ports.SerialErrorReceivedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SerialErrorReceivedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SerialErrorReceivedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Ports.SerialPinChange : Enum {
public int value__
public SerialPinChange CtsChanged
public SerialPinChange DsrChanged
public SerialPinChange CDChanged
public SerialPinChange Break
public SerialPinChange Ring
}
public System.IO.Ports.SerialPinChangedEventArgs : EventArgs {
private SerialPinChange eventType
public SerialPinChange EventType
internal void .ctor(SerialPinChange eventType)
public SerialPinChange get_EventType()
}
public System.IO.Ports.SerialPinChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, SerialPinChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, SerialPinChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.IO.Ports.SerialPort : Component {
public int InfiniteTimeout
private int DefaultReadBufferSize
private int DefaultWriteBufferSize
private int DefaultBaudRate
private int DefaultDataBits
private Parity DefaultParity
private StopBits DefaultStopBits
private bool is_open
private int baud_rate
private Parity parity
private StopBits stop_bits
private Handshake handshake
private int data_bits
private bool break_state
private bool dtr_enable
private bool rts_enable
private ISerialStream stream
private Encoding encoding
private string new_line
private string port_name
private int read_timeout
private int write_timeout
private int readBufferSize
private int writeBufferSize
private object error_received
private object data_received
private object pin_changed
public Stream BaseStream
public int BaudRate
public bool BreakState
public int BytesToRead
public int BytesToWrite
public bool CDHolding
public bool CtsHolding
public int DataBits
public bool DiscardNull
public bool DsrHolding
public bool DtrEnable
public Encoding Encoding
public Handshake Handshake
public bool IsOpen
public string NewLine
public Parity Parity
public byte ParityReplace
public string PortName
public int ReadBufferSize
public int ReadTimeout
public int ReceivedBytesThreshold
public bool RtsEnable
public StopBits StopBits
public int WriteBufferSize
public int WriteTimeout
private bool IsWindows
public void .ctor(IContainer container)
public void .ctor(string portName)
public void .ctor(string portName, int baudRate)
public void .ctor(string portName, int baudRate, Parity parity)
public void .ctor(string portName, int baudRate, Parity parity, int dataBits)
public void .ctor(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits)
public void add_ErrorReceived(SerialErrorReceivedEventHandler value)
public void remove_ErrorReceived(SerialErrorReceivedEventHandler value)
public void add_PinChanged(SerialPinChangedEventHandler value)
public void remove_PinChanged(SerialPinChangedEventHandler value)
public void add_DataReceived(SerialDataReceivedEventHandler value)
public void remove_DataReceived(SerialDataReceivedEventHandler value)
private string GetDefaultPortName()
public Stream get_BaseStream()
public int get_BaudRate()
public void set_BaudRate(int value)
public bool get_BreakState()
public void set_BreakState(bool value)
public int get_BytesToRead()
public int get_BytesToWrite()
public bool get_CDHolding()
public bool get_CtsHolding()
public int get_DataBits()
public void set_DataBits(int value)
public bool get_DiscardNull()
public void set_DiscardNull(bool value)
public bool get_DsrHolding()
public bool get_DtrEnable()
public void set_DtrEnable(bool value)
public Encoding get_Encoding()
public void set_Encoding(Encoding value)
public Handshake get_Handshake()
public void set_Handshake(Handshake value)
public bool get_IsOpen()
public string get_NewLine()
public void set_NewLine(string value)
public Parity get_Parity()
public void set_Parity(Parity value)
public byte get_ParityReplace()
public void set_ParityReplace(byte value)
public string get_PortName()
public void set_PortName(string value)
public int get_ReadBufferSize()
public void set_ReadBufferSize(int value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_ReceivedBytesThreshold()
public void set_ReceivedBytesThreshold(int value)
public bool get_RtsEnable()
public void set_RtsEnable(bool value)
public StopBits get_StopBits()
public void set_StopBits(StopBits value)
public int get_WriteBufferSize()
public void set_WriteBufferSize(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public void Close()
protected void Dispose(bool disposing)
public void DiscardInBuffer()
public void DiscardOutBuffer()
public String[] GetPortNames()
private bool get_IsWindows()
public void Open()
public int Read(Byte[] buffer, int offset, int count)
public int Read(Char[] buffer, int offset, int count)
internal int read_byte()
public int ReadByte()
public int ReadChar()
public string ReadExisting()
public string ReadLine()
public string ReadTo(string value)
public void Write(string str)
public void Write(Byte[] buffer, int offset, int count)
public void Write(Char[] buffer, int offset, int count)
public void WriteLine(string str)
private void CheckOpen()
internal void OnErrorReceived(SerialErrorReceivedEventArgs args)
internal void OnDataReceived(SerialDataReceivedEventArgs args)
internal void OnDataReceived(SerialPinChangedEventArgs args)
}
internal System.IO.Ports.SerialPortStream : Stream {
private int fd
private int read_timeout
private int write_timeout
private bool disposed
public bool CanRead
public bool CanSeek
public bool CanWrite
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
public int BytesToRead
public int BytesToWrite
public void .ctor(string portName, int baudRate, int dataBits, Parity parity, StopBits stopBits, bool dtrEnable, bool rtsEnable, Handshake handshake, int readTimeout, int writeTimeout, int readBufferSize, int writeBufferSize)
private void System.IDisposable.Dispose()
private int open_serial(string portName)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
private int read_serial(int fd, Byte[] buffer, int offset, int count)
private bool poll_serial(int fd, Int32& error, int timeout)
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
private int write_serial(int fd, Byte[] buffer, int offset, int count, int timeout)
public void Write(Byte[] buffer, int offset, int count)
protected void Dispose(bool disposing)
private int close_serial(int fd)
public void Close()
protected void Finalize()
private void CheckDisposed()
private bool set_attributes(int fd, int baudRate, Parity parity, int dataBits, StopBits stopBits, Handshake handshake)
public void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits sb, Handshake hs)
private int get_bytes_in_buffer(int fd, int input)
public int get_BytesToRead()
public int get_BytesToWrite()
private void discard_buffer(int fd, bool inputBuffer)
public void DiscardInBuffer()
public void DiscardOutBuffer()
private SerialSignal get_signals(int fd, Int32& error)
public SerialSignal GetSignals()
private int set_signal(int fd, SerialSignal signal, bool value)
public void SetSignal(SerialSignal signal, bool value)
private int breakprop(int fd)
public void SetBreakState(bool value)
private IntPtr strerror(int errnum)
private void ThrowIOException()
}
internal System.IO.Ports.SerialSignal : Enum {
public int value__
public SerialSignal None
public SerialSignal Cd
public SerialSignal Cts
public SerialSignal Dsr
public SerialSignal Dtr
public SerialSignal Rts
}
public System.IO.Ports.StopBits : Enum {
public int value__
public StopBits None
public StopBits One
public StopBits Two
public StopBits OnePointFive
}
internal System.IO.Ports.Timeouts : object {
public UInt32 MaxDWord
public UInt32 ReadIntervalTimeout
public UInt32 ReadTotalTimeoutMultiplier
public UInt32 ReadTotalTimeoutConstant
public UInt32 WriteTotalTimeoutMultiplier
public UInt32 WriteTotalTimeoutConstant
public void .ctor(int read_timeout, int write_timeout)
public void SetValues(int read_timeout, int write_timeout)
}
internal System.IO.Ports.WinSerialStream : Stream {
private UInt32 GenericRead
private UInt32 GenericWrite
private UInt32 OpenExisting
private UInt32 FileFlagOverlapped
private UInt32 PurgeRxClear
private UInt32 PurgeTxClear
private UInt32 WinInfiniteTimeout
private UInt32 FileIOPending
private UInt32 SetRts
private UInt32 ClearRts
private UInt32 SetDtr
private UInt32 ClearDtr
private UInt32 SetBreak
private UInt32 ClearBreak
private UInt32 CtsOn
private UInt32 DsrOn
private UInt32 RsldOn
private UInt32 EvRxChar
private UInt32 EvCts
private UInt32 EvDsr
private UInt32 EvRlsd
private UInt32 EvBreak
private UInt32 EvErr
private UInt32 EvRing
private int handle
private int read_timeout
private int write_timeout
private bool disposed
private IntPtr write_overlapped
private IntPtr read_overlapped
private ManualResetEvent read_event
private ManualResetEvent write_event
private Timeouts timeouts
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public int ReadTimeout
public int WriteTimeout
public long Length
public long Position
public int BytesToRead
public int BytesToWrite
public void .ctor(string port_name, int baud_rate, int data_bits, Parity parity, StopBits sb, bool dtr_enable, bool rts_enable, Handshake hs, int read_timeout, int write_timeout, int read_buffer_size, int write_buffer_size)
private void System.IDisposable.Dispose()
private int CreateFile(string port_name, UInt32 desired_access, UInt32 share_mode, UInt32 security_attrs, UInt32 creation, UInt32 flags, UInt32 template)
private bool SetupComm(int handle, int read_buffer_size, int write_buffer_size)
private bool PurgeComm(int handle, UInt32 flags)
private bool SetCommTimeouts(int handle, Timeouts timeouts)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
private bool CloseHandle(int handle)
protected void Dispose(bool disposing)
public void Close()
protected void Finalize()
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
private bool ReadFile(int handle, Byte* buffer, int bytes_to_read, Int32& bytes_read, IntPtr overlapped)
private bool GetOverlappedResult(int handle, IntPtr overlapped, Int32& bytes_transfered, bool wait)
public int Read(Byte[] buffer, int offset, int count)
private bool WriteFile(int handle, Byte* buffer, int bytes_to_write, Int32& bytes_written, IntPtr overlapped)
public void Write(Byte[] buffer, int offset, int count)
private bool GetCommState(int handle, DCB dcb)
private bool SetCommState(int handle, DCB dcb)
public void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits bits, Handshake hs)
private void ReportIOError(string optional_arg)
private void CheckDisposed()
public void DiscardInBuffer()
public void DiscardOutBuffer()
private bool ClearCommError(int handle, UInt32& errors, CommStat& stat)
public int get_BytesToRead()
public int get_BytesToWrite()
private bool GetCommModemStatus(int handle, UInt32& flags)
public SerialSignal GetSignals()
private bool EscapeCommFunction(int handle, UInt32 flags)
public void SetSignal(SerialSignal signal, bool value)
public void SetBreakState(bool value)
}
public System.IO.RenamedEventArgs : FileSystemEventArgs {
private string oldName
private string oldFullPath
public string OldFullPath
public string OldName
public void .ctor(WatcherChangeTypes changeType, string directory, string name, string oldName)
public string get_OldFullPath()
public string get_OldName()
}
public System.IO.RenamedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, RenamedEventArgs e)
public IAsyncResult BeginInvoke(object sender, RenamedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.IO.SearchPattern2 : object {
private Op ops
private bool ignore
private bool hasWildcard
private string pattern
internal Char[] WildcardChars
internal Char[] InvalidChars
public bool HasWildcard
public void .ctor(string pattern)
public void .ctor(string pattern, bool ignore)
public bool IsMatch(string text, bool ignorecase)
public bool IsMatch(string text)
public bool get_HasWildcard()
private void Compile(string pattern)
private bool Match(Op op, string text, int ptr)
}
internal System.IO.timespec : ValueType {
public int tv_sec
public int tv_usec
}
public System.IO.WaitForChangedResult : ValueType {
private WatcherChangeTypes changeType
private string name
private string oldName
private bool timedOut
public WatcherChangeTypes ChangeType
public string Name
public string OldName
public bool TimedOut
public WatcherChangeTypes get_ChangeType()
public void set_ChangeType(WatcherChangeTypes value)
public string get_Name()
public void set_Name(string value)
public string get_OldName()
public void set_OldName(string value)
public bool get_TimedOut()
public void set_TimedOut(bool value)
}
public System.IO.WatcherChangeTypes : Enum {
public int value__
public WatcherChangeTypes All
public WatcherChangeTypes Changed
public WatcherChangeTypes Created
public WatcherChangeTypes Deleted
public WatcherChangeTypes Renamed
}
internal System.IO.WindowsWatcher : object {
public bool GetInstance(IFileWatcher& watcher)
public void StartDispatching(FileSystemWatcher fsw)
public void StopDispatching(FileSystemWatcher fsw)
}
internal System.IUriData {
public string AbsolutePath
public string AbsoluteUri
public string AbsoluteUri_SafeUnescaped
public string Authority
public string Fragment
public string Host
public string PathAndQuery
public string StrongPort
public string Query
public string UserInfo
public string get_AbsolutePath()
public string get_AbsoluteUri()
public string get_AbsoluteUri_SafeUnescaped()
public string get_Authority()
public string get_Fragment()
public string get_Host()
public string get_PathAndQuery()
public string get_StrongPort()
public string get_Query()
public string get_UserInfo()
}
public System.Media.SoundPlayer : Component {
private string sound_location
private Stream audiostream
private object tag
private MemoryStream mstream
private bool load_completed
private int load_timeout
private AudioDevice adev
private AudioData adata
private bool stopped
private Win32SoundPlayer win32_player
private bool use_win32_player
private AsyncCompletedEventHandler LoadCompleted
private EventHandler SoundLocationChanged
private EventHandler StreamChanged
public bool IsLoadCompleted
public int LoadTimeout
public string SoundLocation
public Stream Stream
public object Tag
public void .ctor(Stream stream)
public void .ctor(string soundLocation)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext context)
public void add_LoadCompleted(AsyncCompletedEventHandler value)
public void remove_LoadCompleted(AsyncCompletedEventHandler value)
public void add_SoundLocationChanged(EventHandler value)
public void remove_SoundLocationChanged(EventHandler value)
public void add_StreamChanged(EventHandler value)
public void remove_StreamChanged(EventHandler value)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private void LoadFromStream(Stream s)
private void LoadFromUri(string location)
public void Load()
private void AsyncFinished(IAsyncResult ar)
public void LoadAsync()
protected void OnLoadCompleted(AsyncCompletedEventArgs e)
protected void OnSoundLocationChanged(EventArgs e)
protected void OnStreamChanged(EventArgs e)
private void Start()
public void Play()
private void PlayLoop()
public void PlayLooping()
public void PlaySync()
public void Stop()
public bool get_IsLoadCompleted()
public int get_LoadTimeout()
public void set_LoadTimeout(int value)
public string get_SoundLocation()
public void set_SoundLocation(string value)
public Stream get_Stream()
public void set_Stream(Stream value)
public object get_Tag()
public void set_Tag(object value)
}
public System.Media.SystemSound : object {
private Stream resource
internal void .ctor(string tag)
public void Play()
}
public System.Media.SystemSounds : object {
public SystemSound Asterisk
public SystemSound Beep
public SystemSound Exclamation
public SystemSound Hand
public SystemSound Question
public SystemSound get_Asterisk()
public SystemSound get_Beep()
public SystemSound get_Exclamation()
public SystemSound get_Hand()
public SystemSound get_Question()
}
internal System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoExtensionAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoInternalNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoLimitationAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoNotSupportedAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoTODOAttribute : Attribute {
private string comment
public string Comment
public void .ctor(string comment)
public string get_Comment()
}
public System.Net.AuthenticationManager : object {
private ArrayList modules
private object locker
private ICredentialPolicy credential_policy
public ICredentialPolicy CredentialPolicy
public StringDictionary CustomTargetNameDictionary
public IEnumerator RegisteredModules
private void EnsureModules()
public ICredentialPolicy get_CredentialPolicy()
public void set_CredentialPolicy(ICredentialPolicy value)
private Exception GetMustImplement()
public StringDictionary get_CustomTargetNameDictionary()
public IEnumerator get_RegisteredModules()
internal void Clear()
public Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials)
private Authorization DoAuthenticate(string challenge, WebRequest request, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest request, ICredentials credentials)
public void Register(IAuthenticationModule authenticationModule)
public void Unregister(IAuthenticationModule authenticationModule)
public void Unregister(string authenticationScheme)
private void DoUnregister(string authenticationScheme, bool throwEx)
}
public System.Net.AuthenticationSchemes : Enum {
public int value__
public AuthenticationSchemes None
public AuthenticationSchemes Digest
public AuthenticationSchemes Negotiate
public AuthenticationSchemes Ntlm
public AuthenticationSchemes IntegratedWindowsAuthentication
public AuthenticationSchemes Basic
public AuthenticationSchemes Anonymous
}
public System.Net.AuthenticationSchemeSelector : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public AuthenticationSchemes Invoke(HttpListenerRequest httpRequest)
public IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object)
public AuthenticationSchemes EndInvoke(IAsyncResult result)
}
public System.Net.Authorization : object {
private string token
private bool complete
private string connectionGroupId
private String[] protectionRealm
private IAuthenticationModule module
public string Message
public bool Complete
public string ConnectionGroupId
public String[] ProtectionRealm
internal IAuthenticationModule Module
public bool MutuallyAuthenticated
public void .ctor(string token)
public void .ctor(string token, bool complete)
public void .ctor(string token, bool complete, string connectionGroupId)
public string get_Message()
public bool get_Complete()
public string get_ConnectionGroupId()
public String[] get_ProtectionRealm()
public void set_ProtectionRealm(String[] value)
internal IAuthenticationModule get_Module()
internal void set_Module(IAuthenticationModule value)
private Exception GetMustImplement()
public bool get_MutuallyAuthenticated()
public void set_MutuallyAuthenticated(bool value)
}
internal System.Net.BasicClient : object {
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
private Byte[] GetBytes(string str)
private Authorization InternalAuthenticate(WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
public System.Net.BindIPEndPoint : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public IPEndPoint Invoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount)
public IAsyncResult BeginInvoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount, AsyncCallback callback, object object)
public IPEndPoint EndInvoke(IAsyncResult result)
}
public System.Net.Cache.HttpCacheAgeControl : Enum {
public int value__
public HttpCacheAgeControl None
public HttpCacheAgeControl MinFresh
public HttpCacheAgeControl MaxAge
public HttpCacheAgeControl MaxAgeAndMinFresh
public HttpCacheAgeControl MaxStale
public HttpCacheAgeControl MaxAgeAndMaxStale
}
public System.Net.Cache.HttpRequestCacheLevel : Enum {
public int value__
public HttpRequestCacheLevel Default
public HttpRequestCacheLevel BypassCache
public HttpRequestCacheLevel CacheOnly
public HttpRequestCacheLevel CacheIfAvailable
public HttpRequestCacheLevel Revalidate
public HttpRequestCacheLevel Reload
public HttpRequestCacheLevel NoCacheNoStore
public HttpRequestCacheLevel CacheOrNextCacheOnly
public HttpRequestCacheLevel Refresh
}
public System.Net.Cache.HttpRequestCachePolicy : RequestCachePolicy {
private DateTime cacheSyncDate
private HttpRequestCacheLevel level
private TimeSpan maxAge
private TimeSpan maxStale
private TimeSpan minFresh
public DateTime CacheSyncDate
public HttpRequestCacheLevel Level
public TimeSpan MaxAge
public TimeSpan MaxStale
public TimeSpan MinFresh
public void .ctor(DateTime cacheSyncDate)
public void .ctor(HttpRequestCacheLevel level)
public void .ctor(HttpCacheAgeControl cacheAgeControl, TimeSpan ageOrFreshOrStale)
public void .ctor(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale)
public void .ctor(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale, DateTime cacheSyncDate)
public DateTime get_CacheSyncDate()
public HttpRequestCacheLevel get_Level()
public TimeSpan get_MaxAge()
public TimeSpan get_MaxStale()
public TimeSpan get_MinFresh()
public string ToString()
}
public System.Net.Cache.RequestCacheLevel : Enum {
public int value__
public RequestCacheLevel Default
public RequestCacheLevel BypassCache
public RequestCacheLevel CacheOnly
public RequestCacheLevel CacheIfAvailable
public RequestCacheLevel Revalidate
public RequestCacheLevel Reload
public RequestCacheLevel NoCacheNoStore
}
public System.Net.Cache.RequestCachePolicy : object {
private RequestCacheLevel level
public RequestCacheLevel Level
public void .ctor(RequestCacheLevel level)
public RequestCacheLevel get_Level()
public string ToString()
}
internal System.Net.ChunkedInputStream : RequestStream {
private bool disposed
private ChunkStream decoder
private HttpListenerContext context
private bool no_more_data
public ChunkStream Decoder
public void .ctor(HttpListenerContext context, Stream stream, Byte[] buffer, int offset, int length)
public ChunkStream get_Decoder()
public void set_Decoder(ChunkStream value)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
private void OnRead(IAsyncResult base_ares)
public int EndRead(IAsyncResult ares)
public void Close()
}
internal System.Net.ChunkStream : object {
internal WebHeaderCollection headers
private int chunkSize
private int chunkRead
private State state
private StringBuilder saved
private bool sawCR
private bool gotit
private int trailerState
private ArrayList chunks
public bool WantMore
public int ChunkLeft
public void .ctor(Byte[] buffer, int offset, int size, WebHeaderCollection headers)
public void .ctor(WebHeaderCollection headers)
public void ResetBuffer()
public void WriteAndReadBack(Byte[] buffer, int offset, int size, Int32& read)
public int Read(Byte[] buffer, int offset, int size)
private int ReadFromChunks(Byte[] buffer, int offset, int size)
public void Write(Byte[] buffer, int offset, int size)
private void InternalWrite(Byte[] buffer, Int32& offset, int size)
public bool get_WantMore()
public int get_ChunkLeft()
private State ReadBody(Byte[] buffer, Int32& offset, int size)
private State GetChunkSize(Byte[] buffer, Int32& offset, int size)
private string RemoveChunkExtension(string input)
private State ReadCRLF(Byte[] buffer, Int32& offset, int size)
private State ReadTrailer(Byte[] buffer, Int32& offset, int size)
private void ThrowProtocolViolation(string message)
}
public System.Net.Configuration.AuthenticationModuleElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty typeProp
protected ConfigurationPropertyCollection Properties
public string Type
public void .ctor(string typeName)
protected ConfigurationPropertyCollection get_Properties()
public string get_Type()
public void set_Type(string value)
}
public System.Net.Configuration.AuthenticationModuleElementCollection : ConfigurationElementCollection {
public AuthenticationModuleElement Item
public AuthenticationModuleElement Item
public AuthenticationModuleElement get_Item(int index)
public void set_Item(int index, AuthenticationModuleElement value)
public AuthenticationModuleElement get_Item(string name)
public void set_Item(string name, AuthenticationModuleElement value)
public void Add(AuthenticationModuleElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(AuthenticationModuleElement element)
public void Remove(AuthenticationModuleElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
public System.Net.Configuration.AuthenticationModulesSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty authenticationModulesProp
protected ConfigurationPropertyCollection Properties
public AuthenticationModuleElementCollection AuthenticationModules
protected ConfigurationPropertyCollection get_Properties()
public AuthenticationModuleElementCollection get_AuthenticationModules()
protected void PostDeserialize()
protected void InitializeDefault()
}
public System.Net.Configuration.BypassElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty addressProp
public string Address
protected ConfigurationPropertyCollection Properties
public void .ctor(string address)
public string get_Address()
public void set_Address(string value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.BypassElementCollection : ConfigurationElementCollection {
public BypassElement Item
public BypassElement Item
protected bool ThrowOnDuplicate
public BypassElement get_Item(int index)
public void set_Item(int index, BypassElement value)
public BypassElement get_Item(string name)
public void set_Item(string name, BypassElement value)
protected bool get_ThrowOnDuplicate()
public void Add(BypassElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(BypassElement element)
public void Remove(BypassElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
internal System.Net.Configuration.ConnectionManagementData : object {
private int defaultMaxConnections
private Hashtable data
public Hashtable Data
public void .ctor(object parent)
public void Add(string address, string nconns)
public void Add(string address, int nconns)
public void Remove(string address)
public void Clear()
public UInt32 GetMaxConnections(string hostOrIP)
public Hashtable get_Data()
}
public System.Net.Configuration.ConnectionManagementElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty addressProp
private ConfigurationProperty maxConnectionProp
public string Address
public int MaxConnection
protected ConfigurationPropertyCollection Properties
public void .ctor(string address, int maxConnection)
public string get_Address()
public void set_Address(string value)
public int get_MaxConnection()
public void set_MaxConnection(int value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.ConnectionManagementElementCollection : ConfigurationElementCollection {
public ConnectionManagementElement Item
public ConnectionManagementElement Item
public ConnectionManagementElement get_Item(int index)
public void set_Item(int index, ConnectionManagementElement value)
public ConnectionManagementElement get_Item(string name)
public void set_Item(string name, ConnectionManagementElement value)
public void Add(ConnectionManagementElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(ConnectionManagementElement element)
public void Remove(ConnectionManagementElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
internal System.Net.Configuration.ConnectionManagementHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Net.Configuration.ConnectionManagementSection : ConfigurationSection {
private ConfigurationProperty connectionManagementProp
private ConfigurationPropertyCollection properties
public ConnectionManagementElementCollection ConnectionManagement
protected ConfigurationPropertyCollection Properties
public ConnectionManagementElementCollection get_ConnectionManagement()
protected ConfigurationPropertyCollection get_Properties()
}
internal System.Net.Configuration.DefaultProxyHandler : object {
public object Create(object parent, object configContext, XmlNode section)
private void FillByPassList(XmlNode node, WebProxy proxy)
}
public System.Net.Configuration.DefaultProxySection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty bypassListProp
private ConfigurationProperty enabledProp
private ConfigurationProperty moduleProp
private ConfigurationProperty proxyProp
private ConfigurationProperty useDefaultCredentialsProp
public BypassElementCollection BypassList
public bool Enabled
public ModuleElement Module
public ProxyElement Proxy
public bool UseDefaultCredentials
protected ConfigurationPropertyCollection Properties
public BypassElementCollection get_BypassList()
public bool get_Enabled()
public void set_Enabled(bool value)
public ModuleElement get_Module()
public ProxyElement get_Proxy()
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
protected void Reset(ConfigurationElement parentElement)
}
public System.Net.Configuration.FtpCachePolicyElement : ConfigurationElement {
private ConfigurationProperty policyLevelProp
private ConfigurationPropertyCollection properties
public RequestCacheLevel PolicyLevel
protected ConfigurationPropertyCollection Properties
public RequestCacheLevel get_PolicyLevel()
public void set_PolicyLevel(RequestCacheLevel value)
protected ConfigurationPropertyCollection get_Properties()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
protected void Reset(ConfigurationElement parentElement)
}
internal System.Net.Configuration.HandlersUtil : object {
internal string ExtractAttributeValue(string attKey, XmlNode node)
internal string ExtractAttributeValue(string attKey, XmlNode node, bool optional)
internal void ThrowException(string msg, XmlNode node)
}
public System.Net.Configuration.HttpCachePolicyElement : ConfigurationElement {
private ConfigurationProperty maximumAgeProp
private ConfigurationProperty maximumStaleProp
private ConfigurationProperty minimumFreshProp
private ConfigurationProperty policyLevelProp
private ConfigurationPropertyCollection properties
public TimeSpan MaximumAge
public TimeSpan MaximumStale
public TimeSpan MinimumFresh
public HttpRequestCacheLevel PolicyLevel
protected ConfigurationPropertyCollection Properties
public TimeSpan get_MaximumAge()
public void set_MaximumAge(TimeSpan value)
public TimeSpan get_MaximumStale()
public void set_MaximumStale(TimeSpan value)
public TimeSpan get_MinimumFresh()
public void set_MinimumFresh(TimeSpan value)
public HttpRequestCacheLevel get_PolicyLevel()
public void set_PolicyLevel(HttpRequestCacheLevel value)
protected ConfigurationPropertyCollection get_Properties()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
protected void Reset(ConfigurationElement parentElement)
}
public System.Net.Configuration.HttpWebRequestElement : ConfigurationElement {
private ConfigurationProperty maximumErrorResponseLengthProp
private ConfigurationProperty maximumResponseHeadersLengthProp
private ConfigurationProperty maximumUnauthorizedUploadLengthProp
private ConfigurationProperty useUnsafeHeaderParsingProp
private ConfigurationPropertyCollection properties
public int MaximumErrorResponseLength
public int MaximumResponseHeadersLength
public int MaximumUnauthorizedUploadLength
public bool UseUnsafeHeaderParsing
protected ConfigurationPropertyCollection Properties
public int get_MaximumErrorResponseLength()
public void set_MaximumErrorResponseLength(int value)
public int get_MaximumResponseHeadersLength()
public void set_MaximumResponseHeadersLength(int value)
public int get_MaximumUnauthorizedUploadLength()
public void set_MaximumUnauthorizedUploadLength(int value)
public bool get_UseUnsafeHeaderParsing()
public void set_UseUnsafeHeaderParsing(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
}
public System.Net.Configuration.Ipv6Element : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty enabledProp
public bool Enabled
protected ConfigurationPropertyCollection Properties
public bool get_Enabled()
public void set_Enabled(bool value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.MailSettingsSectionGroup : ConfigurationSectionGroup {
public SmtpSection Smtp
public SmtpSection get_Smtp()
}
public System.Net.Configuration.ModuleElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty typeProp
protected ConfigurationPropertyCollection Properties
public string Type
protected ConfigurationPropertyCollection get_Properties()
public string get_Type()
public void set_Type(string value)
}
internal System.Net.Configuration.NetAuthenticationModuleHandler : object {
public object Create(object parent, object configContext, XmlNode section)
private IAuthenticationModule CreateInstance(string typeName, XmlNode node)
}
internal System.Net.Configuration.NetConfigurationHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Net.Configuration.NetSectionGroup : ConfigurationSectionGroup {
public AuthenticationModulesSection AuthenticationModules
public ConnectionManagementSection ConnectionManagement
public DefaultProxySection DefaultProxy
public MailSettingsSectionGroup MailSettings
public RequestCachingSection RequestCaching
public SettingsSection Settings
public WebRequestModulesSection WebRequestModules
public AuthenticationModulesSection get_AuthenticationModules()
public ConnectionManagementSection get_ConnectionManagement()
public DefaultProxySection get_DefaultProxy()
public MailSettingsSectionGroup get_MailSettings()
public RequestCachingSection get_RequestCaching()
public SettingsSection get_Settings()
public WebRequestModulesSection get_WebRequestModules()
public NetSectionGroup GetSectionGroup(Configuration config)
}
public System.Net.Configuration.PerformanceCountersElement : ConfigurationElement {
private ConfigurationProperty enabledProp
private ConfigurationPropertyCollection properties
public bool Enabled
protected ConfigurationPropertyCollection Properties
public bool get_Enabled()
public void set_Enabled(bool value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.ProxyElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty autoDetectProp
private ConfigurationProperty bypassOnLocalProp
private ConfigurationProperty proxyAddressProp
private ConfigurationProperty scriptLocationProp
private ConfigurationProperty useSystemDefaultProp
public AutoDetectValues AutoDetect
public BypassOnLocalValues BypassOnLocal
public Uri ProxyAddress
public Uri ScriptLocation
public UseSystemDefaultValues UseSystemDefault
protected ConfigurationPropertyCollection Properties
public AutoDetectValues get_AutoDetect()
public void set_AutoDetect(AutoDetectValues value)
public BypassOnLocalValues get_BypassOnLocal()
public void set_BypassOnLocal(BypassOnLocalValues value)
public Uri get_ProxyAddress()
public void set_ProxyAddress(Uri value)
public Uri get_ScriptLocation()
public void set_ScriptLocation(Uri value)
public UseSystemDefaultValues get_UseSystemDefault()
public void set_UseSystemDefault(UseSystemDefaultValues value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.RequestCachingSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty defaultFtpCachePolicyProp
private ConfigurationProperty defaultHttpCachePolicyProp
private ConfigurationProperty defaultPolicyLevelProp
private ConfigurationProperty disableAllCachingProp
private ConfigurationProperty isPrivateCacheProp
private ConfigurationProperty unspecifiedMaximumAgeProp
public FtpCachePolicyElement DefaultFtpCachePolicy
public HttpCachePolicyElement DefaultHttpCachePolicy
public RequestCacheLevel DefaultPolicyLevel
public bool DisableAllCaching
public bool IsPrivateCache
public TimeSpan UnspecifiedMaximumAge
protected ConfigurationPropertyCollection Properties
public FtpCachePolicyElement get_DefaultFtpCachePolicy()
public HttpCachePolicyElement get_DefaultHttpCachePolicy()
public RequestCacheLevel get_DefaultPolicyLevel()
public void set_DefaultPolicyLevel(RequestCacheLevel value)
public bool get_DisableAllCaching()
public void set_DisableAllCaching(bool value)
public bool get_IsPrivateCache()
public void set_IsPrivateCache(bool value)
public TimeSpan get_UnspecifiedMaximumAge()
public void set_UnspecifiedMaximumAge(TimeSpan value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
protected void DeserializeElement(XmlReader reader, bool serializeCollectionKey)
}
public System.Net.Configuration.ServicePointManagerElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty checkCertificateNameProp
private ConfigurationProperty checkCertificateRevocationListProp
private ConfigurationProperty dnsRefreshTimeoutProp
private ConfigurationProperty enableDnsRoundRobinProp
private ConfigurationProperty expect100ContinueProp
private ConfigurationProperty useNagleAlgorithmProp
public bool CheckCertificateName
public bool CheckCertificateRevocationList
public int DnsRefreshTimeout
public bool EnableDnsRoundRobin
public bool Expect100Continue
public bool UseNagleAlgorithm
protected ConfigurationPropertyCollection Properties
public bool get_CheckCertificateName()
public void set_CheckCertificateName(bool value)
public bool get_CheckCertificateRevocationList()
public void set_CheckCertificateRevocationList(bool value)
public int get_DnsRefreshTimeout()
public void set_DnsRefreshTimeout(int value)
public bool get_EnableDnsRoundRobin()
public void set_EnableDnsRoundRobin(bool value)
public bool get_Expect100Continue()
public void set_Expect100Continue(bool value)
public bool get_UseNagleAlgorithm()
public void set_UseNagleAlgorithm(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
}
public System.Net.Configuration.SettingsSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty httpWebRequestProp
private ConfigurationProperty ipv6Prop
private ConfigurationProperty performanceCountersProp
private ConfigurationProperty servicePointManagerProp
private ConfigurationProperty webProxyScriptProp
private ConfigurationProperty socketProp
public HttpWebRequestElement HttpWebRequest
public Ipv6Element Ipv6
public PerformanceCountersElement PerformanceCounters
public ServicePointManagerElement ServicePointManager
public SocketElement Socket
public WebProxyScriptElement WebProxyScript
protected ConfigurationPropertyCollection Properties
public HttpWebRequestElement get_HttpWebRequest()
public Ipv6Element get_Ipv6()
public PerformanceCountersElement get_PerformanceCounters()
public ServicePointManagerElement get_ServicePointManager()
public SocketElement get_Socket()
public WebProxyScriptElement get_WebProxyScript()
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.SmtpNetworkElement : ConfigurationElement {
public bool DefaultCredentials
public string Host
public string Password
public int Port
public string UserName
protected ConfigurationPropertyCollection Properties
public bool get_DefaultCredentials()
public void set_DefaultCredentials(bool value)
public string get_Host()
public void set_Host(string value)
public string get_Password()
public void set_Password(string value)
public int get_Port()
public void set_Port(int value)
public string get_UserName()
public void set_UserName(string value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
}
public System.Net.Configuration.SmtpSection : ConfigurationSection {
public SmtpDeliveryMethod DeliveryMethod
public string From
public SmtpNetworkElement Network
public SmtpSpecifiedPickupDirectoryElement SpecifiedPickupDirectory
protected ConfigurationPropertyCollection Properties
public SmtpDeliveryMethod get_DeliveryMethod()
public void set_DeliveryMethod(SmtpDeliveryMethod value)
public string get_From()
public void set_From(string value)
public SmtpNetworkElement get_Network()
public SmtpSpecifiedPickupDirectoryElement get_SpecifiedPickupDirectory()
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.SmtpSpecifiedPickupDirectoryElement : ConfigurationElement {
private ConfigurationProperty pickupDirectoryLocationProp
private ConfigurationPropertyCollection properties
public string PickupDirectoryLocation
protected ConfigurationPropertyCollection Properties
public string get_PickupDirectoryLocation()
public void set_PickupDirectoryLocation(string value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.SocketElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty alwaysUseCompletionPortsForAcceptProp
private ConfigurationProperty alwaysUseCompletionPortsForConnectProp
public bool AlwaysUseCompletionPortsForAccept
public bool AlwaysUseCompletionPortsForConnect
protected ConfigurationPropertyCollection Properties
public bool get_AlwaysUseCompletionPortsForAccept()
public void set_AlwaysUseCompletionPortsForAccept(bool value)
public bool get_AlwaysUseCompletionPortsForConnect()
public void set_AlwaysUseCompletionPortsForConnect(bool value)
protected ConfigurationPropertyCollection get_Properties()
protected void PostDeserialize()
}
public System.Net.Configuration.WebProxyScriptElement : ConfigurationElement {
private ConfigurationProperty downloadTimeoutProp
private ConfigurationPropertyCollection properties
public TimeSpan DownloadTimeout
protected ConfigurationPropertyCollection Properties
protected void PostDeserialize()
public TimeSpan get_DownloadTimeout()
public void set_DownloadTimeout(TimeSpan value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.WebRequestModuleElement : ConfigurationElement {
private ConfigurationPropertyCollection properties
private ConfigurationProperty prefixProp
private ConfigurationProperty typeProp
public string Prefix
public Type Type
protected ConfigurationPropertyCollection Properties
public void .ctor(string prefix, string type)
public void .ctor(string prefix, Type type)
public string get_Prefix()
public void set_Prefix(string value)
public Type get_Type()
public void set_Type(Type value)
protected ConfigurationPropertyCollection get_Properties()
}
public System.Net.Configuration.WebRequestModuleElementCollection : ConfigurationElementCollection {
public WebRequestModuleElement Item
public WebRequestModuleElement Item
public WebRequestModuleElement get_Item(int index)
public void set_Item(int index, WebRequestModuleElement value)
public WebRequestModuleElement get_Item(string name)
public void set_Item(string name, WebRequestModuleElement value)
public void Add(WebRequestModuleElement element)
public void Clear()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
public int IndexOf(WebRequestModuleElement element)
public void Remove(WebRequestModuleElement element)
public void Remove(string name)
public void RemoveAt(int index)
}
internal System.Net.Configuration.WebRequestModuleHandler : object {
public object Create(object parent, object configContext, XmlNode section)
}
public System.Net.Configuration.WebRequestModulesSection : ConfigurationSection {
private ConfigurationPropertyCollection properties
private ConfigurationProperty webRequestModulesProp
protected ConfigurationPropertyCollection Properties
public WebRequestModuleElementCollection WebRequestModules
protected ConfigurationPropertyCollection get_Properties()
public WebRequestModuleElementCollection get_WebRequestModules()
protected void PostDeserialize()
protected void InitializeDefault()
}
internal System.Net.ConnectionModes : Enum {
public int value__
public ConnectionModes Single
public ConnectionModes Persistent
public ConnectionModes Pipeline
public ConnectionModes Mux
}
public System.Net.Cookie : object {
private string comment
private Uri commentUri
private bool discard
private string domain
private DateTime expires
private bool httpOnly
private string name
private string path
private string port
private Int32[] ports
private bool secure
private DateTime timestamp
private string val
private int version
private Char[] reservedCharsName
private Char[] portSeparators
private string tspecials
private bool exact_domain
public string Comment
public Uri CommentUri
public bool Discard
public string Domain
internal bool ExactDomain
public bool Expired
public DateTime Expires
public bool HttpOnly
public string Name
public string Path
public string Port
internal Int32[] Ports
public bool Secure
public DateTime TimeStamp
public string Value
public int Version
public void .ctor(string name, string value)
public void .ctor(string name, string value, string path)
public void .ctor(string name, string value, string path, string domain)
public string get_Comment()
public void set_Comment(string value)
public Uri get_CommentUri()
public void set_CommentUri(Uri value)
public bool get_Discard()
public void set_Discard(bool value)
public string get_Domain()
public void set_Domain(string value)
internal bool get_ExactDomain()
internal void set_ExactDomain(bool value)
public bool get_Expired()
public void set_Expired(bool value)
public DateTime get_Expires()
public void set_Expires(DateTime value)
public bool get_HttpOnly()
public void set_HttpOnly(bool value)
public string get_Name()
public void set_Name(string value)
public string get_Path()
public void set_Path(string value)
public string get_Port()
public void set_Port(string value)
internal Int32[] get_Ports()
public bool get_Secure()
public void set_Secure(bool value)
public DateTime get_TimeStamp()
public string get_Value()
public void set_Value(string value)
public int get_Version()
public void set_Version(int value)
public bool Equals(object obj)
public int GetHashCode()
private int hash(int i, int j, int k, int l, int m)
public string ToString()
internal string ToString(Uri uri)
internal string ToClientString()
private string QuotedString(string value)
private bool IsToken(string value)
private bool IsNullOrEmpty(string s)
}
public System.Net.CookieCollection : object {
private List`1<Cookie> list
private CookieCollectionComparer Comparer
internal IList`1<Cookie> List
public int Count
public bool IsSynchronized
public object SyncRoot
public bool IsReadOnly
public Cookie Item
public Cookie Item
internal IList`1<Cookie> get_List()
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public void CopyTo(Cookie[] array, int index)
public IEnumerator GetEnumerator()
public bool get_IsReadOnly()
public void Add(Cookie cookie)
internal void Sort()
private int SearchCookie(Cookie cookie)
public void Add(CookieCollection cookies)
public Cookie get_Item(int index)
public Cookie get_Item(string name)
}
public System.Net.CookieContainer : object {
public int DefaultCookieLengthLimit
public int DefaultCookieLimit
public int DefaultPerDomainCookieLimit
private int capacity
private int perDomainCapacity
private int maxCookieSize
private CookieCollection cookies
private Dictionary`2<string, int> <>f__switch$map9
public int Count
public int Capacity
public int MaxCookieSize
public int PerDomainCapacity
public void .ctor(int capacity)
public void .ctor(int capacity, int perDomainCapacity, int maxCookieSize)
public int get_Count()
public int get_Capacity()
public void set_Capacity(int value)
public int get_MaxCookieSize()
public void set_MaxCookieSize(int value)
public int get_PerDomainCapacity()
public void set_PerDomainCapacity(int value)
public void Add(Cookie cookie)
private void AddCookie(Cookie cookie)
private int CountDomain(string domain)
private void RemoveOldest(string domain)
private void CheckExpiration()
public void Add(CookieCollection cookies)
private void Cook(Uri uri, Cookie cookie)
public void Add(Uri uri, Cookie cookie)
public void Add(Uri uri, CookieCollection cookies)
public string GetCookieHeader(Uri uri)
private bool CheckDomain(string domain, string host, bool exact)
public CookieCollection GetCookies(Uri uri)
public void SetCookies(Uri uri, string cookieHeader)
private Cookie Parse(string s)
private bool IsNullOrEmpty(string s)
}
public System.Net.CookieException : FormatException {
internal void .ctor(string msg)
internal void .ctor(string msg, Exception e)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.Net.CookieParser : object {
private string header
private int pos
private int length
public void .ctor(string header)
public void .ctor(string header, int position)
public bool GetNextNameValue(String& name, String& val)
private string GetCookieName()
private string GetCookieValue()
}
public System.Net.CredentialCache : object {
private NetworkCredential empty
private Hashtable cache
private Hashtable cacheForHost
public ICredentials DefaultCredentials
public NetworkCredential DefaultNetworkCredentials
public ICredentials get_DefaultCredentials()
public NetworkCredential get_DefaultNetworkCredentials()
public NetworkCredential GetCredential(Uri uriPrefix, string authType)
public IEnumerator GetEnumerator()
public void Add(Uri uriPrefix, string authType, NetworkCredential cred)
public void Remove(Uri uriPrefix, string authType)
public NetworkCredential GetCredential(string host, int port, string authenticationType)
public void Add(string host, int port, string authenticationType, NetworkCredential credential)
public void Remove(string host, int port, string authenticationType)
}
public System.Net.DecompressionMethods : Enum {
public int value__
public DecompressionMethods None
public DecompressionMethods GZip
public DecompressionMethods Deflate
}
internal System.Net.DefaultCertificatePolicy : object {
public bool CheckValidationResult(ServicePoint point, X509Certificate certificate, WebRequest request, int certificateProblem)
}
internal System.Net.DigestClient : object {
private Hashtable cache
private Hashtable Cache
public string AuthenticationType
public bool CanPreAuthenticate
private Hashtable get_Cache()
private void CheckExpired(int count)
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
internal System.Net.DigestHeaderParser : object {
private string header
private int length
private int pos
private String[] keywords
private String[] values
public string Realm
public string Opaque
public string Nonce
public string Algorithm
public string QOP
public void .ctor(string header)
public string get_Realm()
public string get_Opaque()
public string get_Nonce()
public string get_Algorithm()
public string get_QOP()
public bool Parse()
private void SkipWhitespace()
private string GetKey()
private bool GetKeywordAndValue(String& key, String& value)
}
internal System.Net.DigestSession : object {
private RandomNumberGenerator rng
private DateTime lastUse
private int _nc
private HashAlgorithm hash
private DigestHeaderParser parser
private string _cnonce
public string Algorithm
public string Realm
public string Nonce
public string Opaque
public string QOP
public string CNonce
public DateTime LastUse
public string get_Algorithm()
public string get_Realm()
public string get_Nonce()
public string get_Opaque()
public string get_QOP()
public string get_CNonce()
public bool Parse(string challenge)
private string HashToHexString(string toBeHashed)
private string HA1(string username, string password)
private string HA2(HttpWebRequest webRequest)
private string Response(string username, string password, HttpWebRequest webRequest)
public Authorization Authenticate(WebRequest webRequest, ICredentials credentials)
public DateTime get_LastUse()
}
public System.Net.Dns : object {
public IAsyncResult BeginGetHostByName(string hostName, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginResolve(string hostName, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginGetHostAddresses(string hostNameOrAddress, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginGetHostEntry(string hostNameOrAddress, AsyncCallback requestCallback, object stateObject)
public IAsyncResult BeginGetHostEntry(IPAddress address, AsyncCallback requestCallback, object stateObject)
public IPHostEntry EndGetHostByName(IAsyncResult asyncResult)
public IPHostEntry EndResolve(IAsyncResult asyncResult)
public IPAddress[] EndGetHostAddresses(IAsyncResult asyncResult)
public IPHostEntry EndGetHostEntry(IAsyncResult asyncResult)
private bool GetHostByName_internal(string host, String& h_name, String[]& h_aliases, String[]& h_addr_list)
private bool GetHostByAddr_internal(string addr, String& h_name, String[]& h_aliases, String[]& h_addr_list)
private bool GetHostName_internal(String& h_name)
private IPHostEntry hostent_to_IPHostEntry(string h_name, String[] h_aliases, String[] h_addrlist)
public IPHostEntry GetHostByAddress(IPAddress address)
public IPHostEntry GetHostByAddress(string address)
private IPHostEntry GetHostByAddressFromString(string address, bool parse)
public IPHostEntry GetHostEntry(string hostNameOrAddress)
public IPHostEntry GetHostEntry(IPAddress address)
public IPAddress[] GetHostAddresses(string hostNameOrAddress)
public IPHostEntry GetHostByName(string hostName)
public string GetHostName()
public IPHostEntry Resolve(string hostName)
}
public System.Net.DnsPermission : CodeAccessPermission {
private int version
private bool m_noRestriction
public void .ctor(PermissionState state)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public void FromXml(SecurityElement securityElement)
public IPermission Union(IPermission target)
private bool IsEmpty()
private DnsPermission Cast(IPermission target)
}
public System.Net.DnsPermissionAttribute : CodeAccessSecurityAttribute {
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
}
public System.Net.DownloadDataCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] result
public Byte[] Result
internal void .ctor(Byte[] result, Exception error, bool cancelled, object userState)
public Byte[] get_Result()
}
public System.Net.DownloadDataCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DownloadDataCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DownloadDataCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.DownloadProgressChangedEventArgs : ProgressChangedEventArgs {
private long received
private long total
public long BytesReceived
public long TotalBytesToReceive
internal void .ctor(long bytesReceived, long totalBytesToReceive, object userState)
public long get_BytesReceived()
public long get_TotalBytesToReceive()
}
public System.Net.DownloadProgressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DownloadProgressChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DownloadProgressChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.DownloadStringCompletedEventArgs : AsyncCompletedEventArgs {
private string result
public string Result
internal void .ctor(string result, Exception error, bool cancelled, object userState)
public string get_Result()
}
public System.Net.DownloadStringCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, DownloadStringCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, DownloadStringCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.EndPoint : object {
public AddressFamily AddressFamily
public AddressFamily get_AddressFamily()
public EndPoint Create(SocketAddress address)
public SocketAddress Serialize()
private Exception NotImplemented()
}
internal System.Net.EndPointListener : object {
private IPEndPoint endpoint
private Socket sock
private Hashtable prefixes
private ArrayList unhandled
private ArrayList all
private X509Certificate2 cert
private AsymmetricAlgorithm key
private bool secure
public void .ctor(IPAddress addr, int port, bool secure)
private void LoadCertificateAndKey(IPAddress addr, int port)
private void OnAccept(IAsyncResult ares)
public bool BindContext(HttpListenerContext context)
public void UnbindContext(HttpListenerContext context)
private HttpListener SearchListener(string host, Uri uri, ListenerPrefix& prefix)
private HttpListener MatchFromList(string host, string path, ArrayList list, ListenerPrefix& prefix)
private void AddSpecial(ArrayList coll, ListenerPrefix prefix)
private void RemoveSpecial(ArrayList coll, ListenerPrefix prefix)
private void CheckIfRemove()
public void Close()
public void AddPrefix(ListenerPrefix prefix, HttpListener listener)
public void RemovePrefix(ListenerPrefix prefix, HttpListener listener)
}
internal System.Net.EndPointManager : object {
private Hashtable ip_to_endpoints
public void AddListener(HttpListener listener)
public void AddPrefix(string prefix, HttpListener listener)
private void AddPrefixInternal(string p, HttpListener listener)
private EndPointListener GetEPListener(IPAddress addr, int port, HttpListener listener, bool secure)
public void RemoveEndPoint(EndPointListener epl, IPEndPoint ep)
public void RemoveListener(HttpListener listener)
public void RemovePrefix(string prefix, HttpListener listener)
private void RemovePrefixInternal(string prefix, HttpListener listener)
}
public System.Net.EndpointPermission : object {
private Char[] dot_char
private string hostname
private int port
private TransportType transport
private bool resolved
private bool hasWildcard
private IPAddress[] addresses
public string Hostname
public int Port
public TransportType Transport
internal void .ctor(string hostname, int port, TransportType transport)
public string get_Hostname()
public int get_Port()
public TransportType get_Transport()
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
internal bool IsSubsetOf(EndpointPermission perm)
private bool IsSubsetOf(string addr1, string addr2)
internal EndpointPermission Intersect(EndpointPermission perm)
private string IntersectHostname(EndpointPermission perm)
private string Intersect(string addr1, string addr2)
private int ToNumber(string value)
internal void Resolve()
internal void UndoResolve()
}
public System.Net.FileWebRequest : WebRequest {
private Uri uri
private WebHeaderCollection webHeaders
private ICredentials credentials
private string connectionGroup
private long contentLength
private FileAccess fileAccess
private string method
private IWebProxy proxy
private bool preAuthenticate
private int timeout
private Stream requestStream
private FileWebResponse webResponse
private AutoResetEvent requestEndEvent
private bool requesting
private bool asyncResponding
public string ConnectionGroupName
public long ContentLength
public string ContentType
public ICredentials Credentials
public WebHeaderCollection Headers
public string Method
public bool PreAuthenticate
public IWebProxy Proxy
public Uri RequestUri
public int Timeout
public bool UseDefaultCredentials
internal void .ctor(Uri uri)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public long get_ContentLength()
public void set_ContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public WebHeaderCollection get_Headers()
public string get_Method()
public void set_Method(string value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public Uri get_RequestUri()
public int get_Timeout()
public void set_Timeout(int value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
private Exception GetMustImplement()
public void Abort()
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public Stream GetRequestStream()
internal Stream GetRequestStreamInternal()
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public WebResponse GetResponse()
private WebResponse GetResponseInternal()
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal void Close()
}
internal System.Net.FileWebRequestCreator : object {
public WebRequest Create(Uri uri)
}
public System.Net.FileWebResponse : WebResponse {
private Uri responseUri
private FileStream fileStream
private long contentLength
private WebHeaderCollection webHeaders
private bool disposed
public long ContentLength
public string ContentType
public WebHeaderCollection Headers
public Uri ResponseUri
internal void .ctor(Uri responseUri, FileStream fileStream)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.IDisposable.Dispose()
public long get_ContentLength()
public string get_ContentType()
public WebHeaderCollection get_Headers()
public Uri get_ResponseUri()
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public Stream GetResponseStream()
protected void Finalize()
public void Close()
private void Dispose(bool disposing)
private void CheckDisposed()
}
internal System.Net.FtpAsyncResult : object {
private FtpWebResponse response
private ManualResetEvent waitHandle
private Exception exception
private AsyncCallback callback
private Stream stream
private object state
private bool completed
private bool synch
private object locker
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
internal bool GotException
internal Exception Exception
internal FtpWebResponse Response
internal Stream Stream
public void .ctor(AsyncCallback callback, object state)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
internal bool get_GotException()
internal Exception get_Exception()
internal FtpWebResponse get_Response()
internal void set_Response(FtpWebResponse value)
internal Stream get_Stream()
internal void set_Stream(Stream value)
internal void WaitUntilComplete()
internal bool WaitUntilComplete(int timeout, bool exitContext)
internal void SetCompleted(bool synch, Exception exc, FtpWebResponse response)
internal void SetCompleted(bool synch, FtpWebResponse response)
internal void SetCompleted(bool synch, Exception exc)
internal void DoCallback()
internal void Reset()
}
internal System.Net.FtpDataStream : Stream {
private FtpWebRequest request
private Stream networkStream
private bool disposed
private bool isRead
private int totalRead
public bool CanRead
public bool CanWrite
public bool CanSeek
public long Length
public long Position
internal Stream NetworkStream
internal void .ctor(FtpWebRequest request, Stream stream, bool isRead)
private void System.IDisposable.Dispose()
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
internal Stream get_NetworkStream()
public void Close()
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
private int ReadInternal(Byte[] buffer, int offset, int size)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
public int EndRead(IAsyncResult asyncResult)
public int Read(Byte[] buffer, int offset, int size)
private void WriteInternal(Byte[] buffer, int offset, int size)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
public void EndWrite(IAsyncResult asyncResult)
public void Write(Byte[] buffer, int offset, int size)
protected void Finalize()
protected void Dispose(bool disposing)
private void CheckDisposed()
}
internal System.Net.FtpRequestCreator : object {
public WebRequest Create(Uri uri)
}
internal System.Net.FtpStatus : object {
private FtpStatusCode statusCode
private string statusDescription
public FtpStatusCode StatusCode
public string StatusDescription
public void .ctor(FtpStatusCode statusCode, string statusDescription)
public FtpStatusCode get_StatusCode()
public string get_StatusDescription()
}
public System.Net.FtpStatusCode : Enum {
public int value__
public FtpStatusCode Undefined
public FtpStatusCode RestartMarker
public FtpStatusCode ServiceTemporarilyNotAvailable
public FtpStatusCode DataAlreadyOpen
public FtpStatusCode OpeningData
public FtpStatusCode CommandOK
public FtpStatusCode CommandExtraneous
public FtpStatusCode DirectoryStatus
public FtpStatusCode FileStatus
public FtpStatusCode SystemType
public FtpStatusCode SendUserCommand
public FtpStatusCode ClosingControl
public FtpStatusCode ClosingData
public FtpStatusCode EnteringPassive
public FtpStatusCode LoggedInProceed
public FtpStatusCode ServerWantsSecureSession
public FtpStatusCode FileActionOK
public FtpStatusCode PathnameCreated
public FtpStatusCode SendPasswordCommand
public FtpStatusCode NeedLoginAccount
public FtpStatusCode FileCommandPending
public FtpStatusCode ServiceNotAvailable
public FtpStatusCode CantOpenData
public FtpStatusCode ConnectionClosed
public FtpStatusCode ActionNotTakenFileUnavailableOrBusy
public FtpStatusCode ActionAbortedLocalProcessingError
public FtpStatusCode ActionNotTakenInsufficientSpace
public FtpStatusCode CommandSyntaxError
public FtpStatusCode ArgumentSyntaxError
public FtpStatusCode CommandNotImplemented
public FtpStatusCode BadCommandSequence
public FtpStatusCode NotLoggedIn
public FtpStatusCode AccountNeeded
public FtpStatusCode ActionNotTakenFileUnavailable
public FtpStatusCode ActionAbortedUnknownPageType
public FtpStatusCode FileActionAborted
public FtpStatusCode ActionNotTakenFilenameNotAllowed
}
public System.Net.FtpWebRequest : WebRequest {
private string ChangeDir
private string UserCommand
private string PasswordCommand
private string TypeCommand
private string PassiveCommand
private string PortCommand
private string AbortCommand
private string AuthCommand
private string RestCommand
private string RenameFromCommand
private string RenameToCommand
private string QuitCommand
private string EOL
private Uri requestUri
private string file_name
private ServicePoint servicePoint
private Stream origDataStream
private Stream dataStream
private Stream controlStream
private StreamReader controlReader
private NetworkCredential credentials
private IPHostEntry hostEntry
private IPEndPoint localEndPoint
private IWebProxy proxy
private int timeout
private int rwTimeout
private long offset
private bool binary
private bool enableSsl
private bool usePassive
private bool keepAlive
private string method
private string renameTo
private object locker
private RequestState requestState
private FtpAsyncResult asyncResult
private FtpWebResponse ftpResponse
private Stream requestStream
private string initial_path
private String[] supportedCommands
private RemoteCertificateValidationCallback callback
private RemoteCertificateValidationCallback <>f__am$cache1C
private Dictionary`2<string, int> <>f__switch$mapA
private Dictionary`2<string, int> <>f__switch$mapB
public X509CertificateCollection ClientCertificates
public string ConnectionGroupName
public string ContentType
public long ContentLength
public long ContentOffset
public ICredentials Credentials
public RequestCachePolicy DefaultCachePolicy
public bool EnableSsl
public WebHeaderCollection Headers
public bool KeepAlive
public string Method
public bool PreAuthenticate
public IWebProxy Proxy
public int ReadWriteTimeout
public string RenameTo
public Uri RequestUri
public ServicePoint ServicePoint
public bool UsePassive
public bool UseDefaultCredentials
public bool UseBinary
public int Timeout
private string DataType
private RequestState State
internal void .ctor(Uri uri)
private Exception GetMustImplement()
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public string get_ContentType()
public void set_ContentType(string value)
public long get_ContentLength()
public void set_ContentLength(long value)
public long get_ContentOffset()
public void set_ContentOffset(long value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public RequestCachePolicy get_DefaultCachePolicy()
public void set_DefaultCachePolicy(RequestCachePolicy value)
public bool get_EnableSsl()
public void set_EnableSsl(bool value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public string get_Method()
public void set_Method(string value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public int get_ReadWriteTimeout()
public void set_ReadWriteTimeout(int value)
public string get_RenameTo()
public void set_RenameTo(string value)
public Uri get_RequestUri()
public ServicePoint get_ServicePoint()
public bool get_UsePassive()
public void set_UsePassive(bool value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public bool get_UseBinary()
public void set_UseBinary(bool value)
public int get_Timeout()
public void set_Timeout(int value)
private string get_DataType()
private RequestState get_State()
private void set_State(RequestState value)
public void Abort()
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public WebResponse GetResponse()
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public Stream GetRequestStream()
private ServicePoint GetServicePoint()
private void ResolveHost()
private void ProcessRequest()
private void SetType()
private string GetRemoteFolderPath(Uri uri)
private void CWDAndSetFileName(Uri uri)
private void ProcessMethod()
private void CloseControlConnection()
internal void CloseDataConnection()
private void CloseConnection()
private void ProcessSimpleMethod()
private void UploadData()
private void DownloadData()
private void CheckRequestStarted()
private void OpenControlConnection()
private string GetInitialPath(FtpStatus status)
private Socket SetupPassiveConnection(string statusDescription)
private Exception CreateExceptionFromResponse(FtpStatus status)
internal void SetTransferCompleted()
internal void OperationCompleted()
private void SetCompleteWithError(Exception exc)
private Socket InitDataConnection()
private void OpenDataConnection()
private void Authenticate()
private FtpStatus SendCommand(string command, String[] parameters)
private FtpStatus SendCommand(bool waitResponse, string command, String[] parameters)
internal FtpStatus ServiceNotAvailable()
internal FtpStatus GetResponseStatus()
private void InitiateSecureConnection(Stream& stream)
internal bool ChangeToSSLSocket(Stream& stream)
private bool InFinalState()
private bool InProgress()
internal void CheckIfAborted()
private void CheckFinalState()
private bool <callback>m__3(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
}
public System.Net.FtpWebResponse : WebResponse {
private Stream stream
private Uri uri
private FtpStatusCode statusCode
private DateTime lastModified
private string bannerMessage
private string welcomeMessage
private string exitMessage
private string statusDescription
private string method
private bool disposed
private FtpWebRequest request
internal long contentLength
public long ContentLength
public WebHeaderCollection Headers
public Uri ResponseUri
public DateTime LastModified
public string BannerMessage
public string WelcomeMessage
public string ExitMessage
public FtpStatusCode StatusCode
public string StatusDescription
internal Stream Stream
internal void .ctor(FtpWebRequest request, Uri uri, string method, bool keepAlive)
internal void .ctor(FtpWebRequest request, Uri uri, string method, FtpStatusCode statusCode, string statusDescription)
internal void .ctor(FtpWebRequest request, Uri uri, string method, FtpStatus status)
public long get_ContentLength()
public WebHeaderCollection get_Headers()
public Uri get_ResponseUri()
public DateTime get_LastModified()
internal void set_LastModified(DateTime value)
public string get_BannerMessage()
internal void set_BannerMessage(string value)
public string get_WelcomeMessage()
internal void set_WelcomeMessage(string value)
public string get_ExitMessage()
internal void set_ExitMessage(string value)
public FtpStatusCode get_StatusCode()
private void set_StatusCode(FtpStatusCode value)
public string get_StatusDescription()
private void set_StatusDescription(string value)
public void Close()
public Stream GetResponseStream()
internal void set_Stream(Stream value)
internal Stream get_Stream()
internal void UpdateStatus(FtpStatus status)
private void CheckDisposed()
internal bool IsFinal()
}
public System.Net.GlobalProxySelection : object {
public IWebProxy Select
public IWebProxy get_Select()
public void set_Select(IWebProxy value)
public IWebProxy GetEmptyWebProxy()
}
internal System.Net.HttpConnection : object {
private int BufferSize
private Socket sock
private Stream stream
private EndPointListener epl
private MemoryStream ms
private Byte[] buffer
private HttpListenerContext context
private StringBuilder current_line
private ListenerPrefix prefix
private RequestStream i_stream
private ResponseStream o_stream
private bool chunked
private int chunked_uses
private bool context_bound
private bool secure
private AsymmetricAlgorithm key
private InputState input_state
private LineState line_state
private int position
public int ChunkedUses
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public bool IsSecure
public ListenerPrefix Prefix
public void .ctor(Socket sock, EndPointListener epl, bool secure, X509Certificate2 cert, AsymmetricAlgorithm key)
private AsymmetricAlgorithm OnPVKSelection(X509Certificate certificate, string targetHost)
private void Init()
public int get_ChunkedUses()
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
public bool get_IsSecure()
public ListenerPrefix get_Prefix()
public void set_Prefix(ListenerPrefix value)
public void BeginReadRequest()
public RequestStream GetRequestStream(bool chunked, long contentlength)
public ResponseStream GetResponseStream()
private void OnRead(IAsyncResult ares)
private bool ProcessInput(MemoryStream ms)
private string ReadLine(Byte[] buffer, int offset, int len, Int32& used)
public void SendError(string msg, int status)
public void SendError()
private void Unbind()
public void Close()
private void CloseSocket()
internal void Close(bool force_close)
}
public System.Net.HttpContinueDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(int StatusCode, WebHeaderCollection httpHeaders)
public IAsyncResult BeginInvoke(int StatusCode, WebHeaderCollection httpHeaders, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.HttpListener : object {
private AuthenticationSchemes auth_schemes
private HttpListenerPrefixCollection prefixes
private AuthenticationSchemeSelector auth_selector
private string realm
private bool ignore_write_exceptions
private bool unsafe_ntlm_auth
private bool listening
private bool disposed
private Hashtable registry
private ArrayList ctx_queue
private ArrayList wait_queue
public AuthenticationSchemes AuthenticationSchemes
public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate
public bool IgnoreWriteExceptions
public bool IsListening
public bool IsSupported
public HttpListenerPrefixCollection Prefixes
public string Realm
public bool UnsafeConnectionNtlmAuthentication
private void System.IDisposable.Dispose()
public AuthenticationSchemes get_AuthenticationSchemes()
public void set_AuthenticationSchemes(AuthenticationSchemes value)
public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate()
public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value)
public bool get_IgnoreWriteExceptions()
public void set_IgnoreWriteExceptions(bool value)
public bool get_IsListening()
public bool get_IsSupported()
public HttpListenerPrefixCollection get_Prefixes()
public string get_Realm()
public void set_Realm(string value)
public bool get_UnsafeConnectionNtlmAuthentication()
public void set_UnsafeConnectionNtlmAuthentication(bool value)
public void Abort()
public void Close()
private void Close(bool force)
private void Cleanup(bool close_existing)
public IAsyncResult BeginGetContext(AsyncCallback callback, object state)
public HttpListenerContext EndGetContext(IAsyncResult asyncResult)
internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerContext context)
public HttpListenerContext GetContext()
public void Start()
public void Stop()
internal void CheckDisposed()
private HttpListenerContext GetContextFromQueue()
internal void RegisterContext(HttpListenerContext context)
internal void UnregisterContext(HttpListenerContext context)
}
public System.Net.HttpListenerBasicIdentity : GenericIdentity {
private string password
public string Password
public void .ctor(string username, string password)
public string get_Password()
}
public System.Net.HttpListenerContext : object {
private HttpListenerRequest request
private HttpListenerResponse response
private IPrincipal user
private HttpConnection cnc
private string error
private int err_status
internal HttpListener Listener
internal int ErrorStatus
internal string ErrorMessage
internal bool HaveError
internal HttpConnection Connection
public HttpListenerRequest Request
public HttpListenerResponse Response
public IPrincipal User
internal void .ctor(HttpConnection cnc)
internal int get_ErrorStatus()
internal void set_ErrorStatus(int value)
internal string get_ErrorMessage()
internal void set_ErrorMessage(string value)
internal bool get_HaveError()
internal HttpConnection get_Connection()
public HttpListenerRequest get_Request()
public HttpListenerResponse get_Response()
public IPrincipal get_User()
internal void ParseAuthentication(AuthenticationSchemes expectedSchemes)
internal IPrincipal ParseBasicAuthentication(string authData)
}
public System.Net.HttpListenerException : Win32Exception {
public int ErrorCode
public void .ctor(int errorCode)
public void .ctor(int errorCode, string message)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public int get_ErrorCode()
}
public System.Net.HttpListenerPrefixCollection : object {
private List`1<string> prefixes
private HttpListener listener
public int Count
public bool IsReadOnly
public bool IsSynchronized
internal void .ctor(HttpListener listener)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public void Add(string uriPrefix)
public void Clear()
public bool Contains(string uriPrefix)
public void CopyTo(String[] array, int offset)
public void CopyTo(Array array, int offset)
public IEnumerator`1<string> GetEnumerator()
public bool Remove(string uriPrefix)
}
public System.Net.HttpListenerRequest : object {
private String[] accept_types
private Encoding content_encoding
private long content_length
private bool cl_set
private CookieCollection cookies
private WebHeaderCollection headers
private string method
private Stream input_stream
private Version version
private NameValueCollection query_string
private string raw_url
private Guid identifier
private Uri url
private Uri referrer
private String[] user_languages
private HttpListenerContext context
private bool is_chunked
private Byte[] _100continue
private String[] no_body_methods
private Char[] separators
private Dictionary`2<string, int> <>f__switch$mapC
public String[] AcceptTypes
public int ClientCertificateError
public Encoding ContentEncoding
public long ContentLength64
public string ContentType
public CookieCollection Cookies
public bool HasEntityBody
public NameValueCollection Headers
public string HttpMethod
public Stream InputStream
public bool IsAuthenticated
public bool IsLocal
public bool IsSecureConnection
public bool KeepAlive
public IPEndPoint LocalEndPoint
public Version ProtocolVersion
public NameValueCollection QueryString
public string RawUrl
public IPEndPoint RemoteEndPoint
public Guid RequestTraceIdentifier
public Uri Url
public Uri UrlReferrer
public string UserAgent
public string UserHostAddress
public string UserHostName
public String[] UserLanguages
internal void .ctor(HttpListenerContext context)
internal void SetRequestLine(string req)
private void CreateQueryString(string query)
internal void FinishInitialization()
internal string Unquote(string str)
internal void AddHeader(string header)
internal bool FlushInput()
public String[] get_AcceptTypes()
public int get_ClientCertificateError()
public Encoding get_ContentEncoding()
public long get_ContentLength64()
public string get_ContentType()
public CookieCollection get_Cookies()
public bool get_HasEntityBody()
public NameValueCollection get_Headers()
public string get_HttpMethod()
public Stream get_InputStream()
public bool get_IsAuthenticated()
public bool get_IsLocal()
public bool get_IsSecureConnection()
public bool get_KeepAlive()
public IPEndPoint get_LocalEndPoint()
public Version get_ProtocolVersion()
public NameValueCollection get_QueryString()
public string get_RawUrl()
public IPEndPoint get_RemoteEndPoint()
public Guid get_RequestTraceIdentifier()
public Uri get_Url()
public Uri get_UrlReferrer()
public string get_UserAgent()
public string get_UserHostAddress()
public string get_UserHostName()
public String[] get_UserLanguages()
public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state)
public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult)
public X509Certificate2 GetClientCertificate()
}
public System.Net.HttpListenerResponse : object {
private bool disposed
private Encoding content_encoding
private long content_length
private bool cl_set
private string content_type
private CookieCollection cookies
private WebHeaderCollection headers
private bool keep_alive
private ResponseStream output_stream
private Version version
private string location
private int status_code
private string status_description
private bool chunked
private HttpListenerContext context
internal bool HeadersSent
private bool force_close_chunked
internal bool ForceCloseChunked
public Encoding ContentEncoding
public long ContentLength64
public string ContentType
public CookieCollection Cookies
public WebHeaderCollection Headers
public bool KeepAlive
public Stream OutputStream
public Version ProtocolVersion
public string RedirectLocation
public bool SendChunked
public int StatusCode
public string StatusDescription
internal void .ctor(HttpListenerContext context)
private void System.IDisposable.Dispose()
internal bool get_ForceCloseChunked()
public Encoding get_ContentEncoding()
public void set_ContentEncoding(Encoding value)
public long get_ContentLength64()
public void set_ContentLength64(long value)
public string get_ContentType()
public void set_ContentType(string value)
public CookieCollection get_Cookies()
public void set_Cookies(CookieCollection value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public Stream get_OutputStream()
public Version get_ProtocolVersion()
public void set_ProtocolVersion(Version value)
public string get_RedirectLocation()
public void set_RedirectLocation(string value)
public bool get_SendChunked()
public void set_SendChunked(bool value)
public int get_StatusCode()
public void set_StatusCode(int value)
internal string GetStatusDescription(int code)
public string get_StatusDescription()
public void set_StatusDescription(string value)
public void Abort()
public void AddHeader(string name, string value)
public void AppendCookie(Cookie cookie)
public void AppendHeader(string name, string value)
private void Close(bool force)
public void Close()
public void Close(Byte[] responseEntity, bool willBlock)
public void CopyFrom(HttpListenerResponse templateResponse)
public void Redirect(string url)
private bool FindCookie(Cookie cookie)
internal void SendHeaders(bool closing, MemoryStream ms)
public void SetCookie(Cookie cookie)
}
internal System.Net.HttpRequestCreator : object {
public WebRequest Create(Uri uri)
}
public System.Net.HttpRequestHeader : Enum {
public int value__
public HttpRequestHeader CacheControl
public HttpRequestHeader Connection
public HttpRequestHeader Date
public HttpRequestHeader KeepAlive
public HttpRequestHeader Pragma
public HttpRequestHeader Trailer
public HttpRequestHeader TransferEncoding
public HttpRequestHeader Upgrade
public HttpRequestHeader Via
public HttpRequestHeader Warning
public HttpRequestHeader Allow
public HttpRequestHeader ContentLength
public HttpRequestHeader ContentType
public HttpRequestHeader ContentEncoding
public HttpRequestHeader ContentLanguage
public HttpRequestHeader ContentLocation
public HttpRequestHeader ContentMd5
public HttpRequestHeader ContentRange
public HttpRequestHeader Expires
public HttpRequestHeader LastModified
public HttpRequestHeader Accept
public HttpRequestHeader AcceptCharset
public HttpRequestHeader AcceptEncoding
public HttpRequestHeader AcceptLanguage
public HttpRequestHeader Authorization
public HttpRequestHeader Cookie
public HttpRequestHeader Expect
public HttpRequestHeader From
public HttpRequestHeader Host
public HttpRequestHeader IfMatch
public HttpRequestHeader IfModifiedSince
public HttpRequestHeader IfNoneMatch
public HttpRequestHeader IfRange
public HttpRequestHeader IfUnmodifiedSince
public HttpRequestHeader MaxForwards
public HttpRequestHeader ProxyAuthorization
public HttpRequestHeader Referer
public HttpRequestHeader Range
public HttpRequestHeader Te
public HttpRequestHeader Translate
public HttpRequestHeader UserAgent
}
public System.Net.HttpResponseHeader : Enum {
public int value__
public HttpResponseHeader CacheControl
public HttpResponseHeader Connection
public HttpResponseHeader Date
public HttpResponseHeader KeepAlive
public HttpResponseHeader Pragma
public HttpResponseHeader Trailer
public HttpResponseHeader TransferEncoding
public HttpResponseHeader Upgrade
public HttpResponseHeader Via
public HttpResponseHeader Warning
public HttpResponseHeader Allow
public HttpResponseHeader ContentLength
public HttpResponseHeader ContentType
public HttpResponseHeader ContentEncoding
public HttpResponseHeader ContentLanguage
public HttpResponseHeader ContentLocation
public HttpResponseHeader ContentMd5
public HttpResponseHeader ContentRange
public HttpResponseHeader Expires
public HttpResponseHeader LastModified
public HttpResponseHeader AcceptRanges
public HttpResponseHeader Age
public HttpResponseHeader ETag
public HttpResponseHeader Location
public HttpResponseHeader ProxyAuthenticate
public HttpResponseHeader RetryAfter
public HttpResponseHeader Server
public HttpResponseHeader SetCookie
public HttpResponseHeader Vary
public HttpResponseHeader WwwAuthenticate
}
public System.Net.HttpStatusCode : Enum {
public int value__
public HttpStatusCode Continue
public HttpStatusCode SwitchingProtocols
public HttpStatusCode OK
public HttpStatusCode Created
public HttpStatusCode Accepted
public HttpStatusCode NonAuthoritativeInformation
public HttpStatusCode NoContent
public HttpStatusCode ResetContent
public HttpStatusCode PartialContent
public HttpStatusCode MultipleChoices
public HttpStatusCode Ambiguous
public HttpStatusCode MovedPermanently
public HttpStatusCode Moved
public HttpStatusCode Found
public HttpStatusCode Redirect
public HttpStatusCode SeeOther
public HttpStatusCode RedirectMethod
public HttpStatusCode NotModified
public HttpStatusCode UseProxy
public HttpStatusCode Unused
public HttpStatusCode TemporaryRedirect
public HttpStatusCode RedirectKeepVerb
public HttpStatusCode BadRequest
public HttpStatusCode Unauthorized
public HttpStatusCode PaymentRequired
public HttpStatusCode Forbidden
public HttpStatusCode NotFound
public HttpStatusCode MethodNotAllowed
public HttpStatusCode NotAcceptable
public HttpStatusCode ProxyAuthenticationRequired
public HttpStatusCode RequestTimeout
public HttpStatusCode Conflict
public HttpStatusCode Gone
public HttpStatusCode LengthRequired
public HttpStatusCode PreconditionFailed
public HttpStatusCode RequestEntityTooLarge
public HttpStatusCode RequestUriTooLong
public HttpStatusCode UnsupportedMediaType
public HttpStatusCode RequestedRangeNotSatisfiable
public HttpStatusCode ExpectationFailed
public HttpStatusCode InternalServerError
public HttpStatusCode NotImplemented
public HttpStatusCode BadGateway
public HttpStatusCode ServiceUnavailable
public HttpStatusCode GatewayTimeout
public HttpStatusCode HttpVersionNotSupported
}
internal System.Net.HttpStreamAsyncResult : object {
private object locker
private ManualResetEvent handle
private bool completed
internal Byte[] Buffer
internal int Offset
internal int Count
internal AsyncCallback Callback
internal object State
internal int SynchRead
internal Exception Error
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public void Complete(Exception e)
public void Complete()
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
}
internal System.Net.HttpUtility : object {
public string UrlDecode(string s)
private Char[] GetChars(MemoryStream b, Encoding e)
public string UrlDecode(string s, Encoding e)
}
public System.Net.HttpVersion : object {
public Version Version10
public Version Version11
}
public System.Net.HttpWebRequest : WebRequest {
private Uri requestUri
private Uri actualUri
private bool hostChanged
private bool allowAutoRedirect
private bool allowBuffering
private X509CertificateCollection certificates
private string connectionGroup
private long contentLength
private HttpContinueDelegate continueDelegate
private CookieContainer cookieContainer
private ICredentials credentials
private bool haveResponse
private bool haveRequest
private bool requestSent
private WebHeaderCollection webHeaders
private bool keepAlive
private int maxAutoRedirect
private string mediaType
private string method
private string initialMethod
private bool pipelined
private bool preAuthenticate
private bool usedPreAuth
private Version version
private Version actualVersion
private IWebProxy proxy
private bool sendChunked
private ServicePoint servicePoint
private int timeout
private WebConnectionStream writeStream
private HttpWebResponse webResponse
private WebAsyncResult asyncWrite
private WebAsyncResult asyncRead
private EventHandler abortHandler
private int aborted
private bool gotRequestStream
private int redirects
private bool expectContinue
private bool authCompleted
private Byte[] bodyBuffer
private int bodyBufferLength
private bool getResponseCalled
private Exception saved_exc
private object locker
private bool is_ntlm_auth
private bool finished_reading
internal WebConnection WebConnection
private DecompressionMethods auto_decomp
private int maxResponseHeadersLength
private int defaultMaxResponseHeadersLength
private int readWriteTimeout
private bool unsafe_auth_blah
internal bool UsesNtlmAuthentication
public string Accept
public Uri Address
public bool AllowAutoRedirect
public bool AllowWriteStreamBuffering
public DecompressionMethods AutomaticDecompression
internal bool InternalAllowBuffering
public X509CertificateCollection ClientCertificates
public string Connection
public string ConnectionGroupName
public long ContentLength
internal long InternalContentLength
public string ContentType
public HttpContinueDelegate ContinueDelegate
public CookieContainer CookieContainer
public ICredentials Credentials
public RequestCachePolicy DefaultCachePolicy
public int DefaultMaximumErrorResponseLength
public string Expect
public bool HaveResponse
public WebHeaderCollection Headers
public DateTime IfModifiedSince
public bool KeepAlive
public int MaximumAutomaticRedirections
public int MaximumResponseHeadersLength
public int DefaultMaximumResponseHeadersLength
public int ReadWriteTimeout
public string MediaType
public string Method
public bool Pipelined
public bool PreAuthenticate
public Version ProtocolVersion
public IWebProxy Proxy
public string Referer
public Uri RequestUri
public bool SendChunked
public ServicePoint ServicePoint
public int Timeout
public string TransferEncoding
public bool UseDefaultCredentials
public string UserAgent
public bool UnsafeAuthenticatedConnectionSharing
internal bool GotRequestStream
internal bool ExpectContinue
internal Uri AuthUri
internal bool ProxyQuery
internal bool FinishedReading
internal bool Aborted
internal void .ctor(Uri uri)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal bool get_UsesNtlmAuthentication()
public string get_Accept()
public void set_Accept(string value)
public Uri get_Address()
public bool get_AllowAutoRedirect()
public void set_AllowAutoRedirect(bool value)
public bool get_AllowWriteStreamBuffering()
public void set_AllowWriteStreamBuffering(bool value)
private Exception GetMustImplement()
public DecompressionMethods get_AutomaticDecompression()
public void set_AutomaticDecompression(DecompressionMethods value)
internal bool get_InternalAllowBuffering()
public X509CertificateCollection get_ClientCertificates()
public void set_ClientCertificates(X509CertificateCollection value)
public string get_Connection()
public void set_Connection(string value)
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public long get_ContentLength()
public void set_ContentLength(long value)
internal void set_InternalContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public HttpContinueDelegate get_ContinueDelegate()
public void set_ContinueDelegate(HttpContinueDelegate value)
public CookieContainer get_CookieContainer()
public void set_CookieContainer(CookieContainer value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public RequestCachePolicy get_DefaultCachePolicy()
public void set_DefaultCachePolicy(RequestCachePolicy value)
public int get_DefaultMaximumErrorResponseLength()
public void set_DefaultMaximumErrorResponseLength(int value)
public string get_Expect()
public void set_Expect(string value)
public bool get_HaveResponse()
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public DateTime get_IfModifiedSince()
public void set_IfModifiedSince(DateTime value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public int get_MaximumAutomaticRedirections()
public void set_MaximumAutomaticRedirections(int value)
public int get_MaximumResponseHeadersLength()
public void set_MaximumResponseHeadersLength(int value)
public int get_DefaultMaximumResponseHeadersLength()
public void set_DefaultMaximumResponseHeadersLength(int value)
public int get_ReadWriteTimeout()
public void set_ReadWriteTimeout(int value)
public string get_MediaType()
public void set_MediaType(string value)
public string get_Method()
public void set_Method(string value)
public bool get_Pipelined()
public void set_Pipelined(bool value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public Version get_ProtocolVersion()
public void set_ProtocolVersion(Version value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public string get_Referer()
public void set_Referer(string value)
public Uri get_RequestUri()
public bool get_SendChunked()
public void set_SendChunked(bool value)
public ServicePoint get_ServicePoint()
public int get_Timeout()
public void set_Timeout(int value)
public string get_TransferEncoding()
public void set_TransferEncoding(string value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public string get_UserAgent()
public void set_UserAgent(string value)
public bool get_UnsafeAuthenticatedConnectionSharing()
public void set_UnsafeAuthenticatedConnectionSharing(bool value)
internal bool get_GotRequestStream()
internal bool get_ExpectContinue()
internal void set_ExpectContinue(bool value)
internal Uri get_AuthUri()
internal bool get_ProxyQuery()
internal ServicePoint GetServicePoint()
public void AddRange(int range)
public void AddRange(int from, int to)
public void AddRange(string rangeSpecifier, int range)
public void AddRange(string rangeSpecifier, int from, int to)
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public Stream GetRequestStream()
private void CheckIfForceWrite()
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public WebResponse GetResponse()
internal bool get_FinishedReading()
internal void set_FinishedReading(bool value)
internal bool get_Aborted()
public void Abort()
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void CheckRequestStarted()
internal void DoContinueDelegate(int statusCode, WebHeaderCollection headers)
private bool Redirect(WebAsyncResult result, HttpStatusCode code)
private string GetHeaders()
private void DoPreAuthenticate()
internal void SetWriteStreamError(WebExceptionStatus status, Exception exc)
internal void SendRequestHeaders(bool propagate_error)
internal void SetWriteStream(WebConnectionStream stream)
internal void SetResponseError(WebExceptionStatus status, Exception e, string where)
private void CheckSendError(WebConnectionData data)
private void HandleNtlmAuth(WebAsyncResult r)
internal void SetResponseData(WebConnectionData data)
private bool CheckAuthorization(WebResponse response, HttpStatusCode code)
private bool CheckFinalStatus(WebAsyncResult result)
}
public System.Net.HttpWebResponse : WebResponse {
private Uri uri
private WebHeaderCollection webHeaders
private CookieCollection cookieCollection
private string method
private Version version
private HttpStatusCode statusCode
private string statusDescription
private long contentLength
private string contentType
private CookieContainer cookie_container
private bool disposed
private Stream stream
private String[] cookieExpiresFormats
private Dictionary`2<string, int> <>f__switch$mapD
public string CharacterSet
public string ContentEncoding
public long ContentLength
public string ContentType
public CookieCollection Cookies
public WebHeaderCollection Headers
public bool IsMutuallyAuthenticated
public DateTime LastModified
public string Method
public Version ProtocolVersion
public Uri ResponseUri
public string Server
public HttpStatusCode StatusCode
public string StatusDescription
internal void .ctor(Uri uri, string method, WebConnectionData data, CookieContainer container)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.IDisposable.Dispose()
public string get_CharacterSet()
public string get_ContentEncoding()
public long get_ContentLength()
public string get_ContentType()
public CookieCollection get_Cookies()
public void set_Cookies(CookieCollection value)
public WebHeaderCollection get_Headers()
private Exception GetMustImplement()
public bool get_IsMutuallyAuthenticated()
public DateTime get_LastModified()
public string get_Method()
public Version get_ProtocolVersion()
public Uri get_ResponseUri()
public string get_Server()
public HttpStatusCode get_StatusCode()
public string get_StatusDescription()
public string GetResponseHeader(string headerName)
internal void ReadAll()
public Stream GetResponseStream()
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void Close()
private void Dispose(bool disposing)
private void CheckDisposed()
private void FillCookies()
private void SetCookie(string header)
private void SetCookie2(string cookies_str)
private DateTime TryParseCookieExpires(string value)
}
public System.Net.IAuthenticationModule {
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest request, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
public System.Net.ICertificatePolicy {
public bool CheckValidationResult(ServicePoint srvPoint, X509Certificate certificate, WebRequest request, int certificateProblem)
}
public System.Net.ICredentialPolicy {
public bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule)
}
public System.Net.ICredentials {
public NetworkCredential GetCredential(Uri uri, string authType)
}
public System.Net.ICredentialsByHost {
public NetworkCredential GetCredential(string host, int port, string authType)
}
public System.Net.IPAddress : object {
private long m_Address
private AddressFamily m_Family
private UInt16[] m_Numbers
private long m_ScopeId
public IPAddress Any
public IPAddress Broadcast
public IPAddress Loopback
public IPAddress None
public IPAddress IPv6Any
public IPAddress IPv6Loopback
public IPAddress IPv6None
private int m_HashCode
public long Address
internal long InternalIPv4Address
public bool IsIPv6LinkLocal
public bool IsIPv6SiteLocal
public bool IsIPv6Multicast
public long ScopeId
public AddressFamily AddressFamily
public void .ctor(long addr)
public void .ctor(Byte[] address)
public void .ctor(Byte[] address, long scopeId)
internal void .ctor(UInt16[] address, long scopeId)
private short SwapShort(short number)
private int SwapInt(int number)
private long SwapLong(long number)
public short HostToNetworkOrder(short host)
public int HostToNetworkOrder(int host)
public long HostToNetworkOrder(long host)
public short NetworkToHostOrder(short network)
public int NetworkToHostOrder(int network)
public long NetworkToHostOrder(long network)
public IPAddress Parse(string ipString)
public bool TryParse(string ipString, IPAddress& address)
private IPAddress ParseIPV4(string ip)
private IPAddress ParseIPV6(string ip)
public long get_Address()
public void set_Address(long value)
internal long get_InternalIPv4Address()
public bool get_IsIPv6LinkLocal()
public bool get_IsIPv6SiteLocal()
public bool get_IsIPv6Multicast()
public long get_ScopeId()
public void set_ScopeId(long value)
public Byte[] GetAddressBytes()
public AddressFamily get_AddressFamily()
public bool IsLoopback(IPAddress addr)
public string ToString()
private string ToString(long addr)
public bool Equals(object other)
public int GetHashCode()
private int Hash(int i, int j, int k, int l)
}
public System.Net.IPEndPoint : EndPoint {
public int MaxPort
public int MinPort
private IPAddress address
private int port
public IPAddress Address
public AddressFamily AddressFamily
public int Port
public void .ctor(IPAddress address, int port)
public void .ctor(long iaddr, int port)
public IPAddress get_Address()
public void set_Address(IPAddress value)
public AddressFamily get_AddressFamily()
public int get_Port()
public void set_Port(int value)
public EndPoint Create(SocketAddress socketAddress)
public SocketAddress Serialize()
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
public System.Net.IPHostEntry : object {
private IPAddress[] addressList
private String[] aliases
private string hostName
public IPAddress[] AddressList
public String[] Aliases
public string HostName
public IPAddress[] get_AddressList()
public void set_AddressList(IPAddress[] value)
public String[] get_Aliases()
public void set_Aliases(String[] value)
public string get_HostName()
public void set_HostName(string value)
}
internal System.Net.IPv6Address : object {
private UInt16[] address
private int prefixLength
private long scopeId
public IPv6Address Loopback
public IPv6Address Unspecified
public UInt16[] Address
public int PrefixLength
public long ScopeId
public ushort Item
public AddressFamily AddressFamily
public void .ctor(UInt16[] addr)
public void .ctor(UInt16[] addr, int prefixLength)
public void .ctor(UInt16[] addr, int prefixLength, int scopeId)
public IPv6Address Parse(string ipString)
private int Fill(UInt16[] addr, string ipString)
private bool TryParse(string prefix, Int32& res)
public bool TryParse(string ipString, IPv6Address& result)
public UInt16[] get_Address()
public int get_PrefixLength()
public long get_ScopeId()
public void set_ScopeId(long value)
public ushort get_Item(int index)
public AddressFamily get_AddressFamily()
public bool IsLoopback(IPv6Address addr)
private ushort SwapUShort(ushort number)
private int AsIPv4Int()
public bool IsIPv4Compatible()
public bool IsIPv4Mapped()
public string ToString()
public string ToString(bool fullLength)
public bool Equals(object other)
public int GetHashCode()
private int Hash(int i, int j, int k, int l)
}
public System.Net.IWebProxy {
public ICredentials Credentials
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public Uri GetProxy(Uri destination)
public bool IsBypassed(Uri host)
}
public System.Net.IWebProxyScript {
public void Close()
public bool Load(Uri scriptLocation, string Script, Type helperType)
public string Run(string url, string host)
}
public System.Net.IWebRequestCreate {
public WebRequest Create(Uri uri)
}
internal System.Net.ListenerAsyncResult : object {
private ManualResetEvent handle
private bool synch
private bool completed
private AsyncCallback cb
private object state
private Exception exception
private HttpListenerContext context
private object locker
private ListenerAsyncResult forward
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public void .ctor(AsyncCallback cb, object state)
internal void Complete(string error)
private void InvokeCallback(object o)
internal void Complete(HttpListenerContext context)
internal void Complete(HttpListenerContext context, bool synch)
internal HttpListenerContext GetContext()
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
}
internal System.Net.ListenerPrefix : object {
private string original
private string host
private ushort port
private string path
private bool secure
private IPAddress[] addresses
public HttpListener Listener
public IPAddress[] Addresses
public bool Secure
public string Host
public int Port
public string Path
public void .ctor(string prefix)
public string ToString()
public IPAddress[] get_Addresses()
public void set_Addresses(IPAddress[] value)
public bool get_Secure()
public string get_Host()
public int get_Port()
public string get_Path()
public bool Equals(object o)
public int GetHashCode()
private void Parse(string uri)
public void CheckUri(string uri)
}
public System.Net.Mail.AlternateView : AttachmentBase {
private Uri baseUri
private LinkedResourceCollection linkedResources
public Uri BaseUri
public LinkedResourceCollection LinkedResources
public void .ctor(string fileName)
public void .ctor(string fileName, ContentType contentType)
public void .ctor(string fileName, string mediaType)
public void .ctor(Stream contentStream)
public void .ctor(Stream contentStream, string mediaType)
public void .ctor(Stream contentStream, ContentType contentType)
public Uri get_BaseUri()
public void set_BaseUri(Uri value)
public LinkedResourceCollection get_LinkedResources()
public AlternateView CreateAlternateViewFromString(string content)
public AlternateView CreateAlternateViewFromString(string content, ContentType contentType)
public AlternateView CreateAlternateViewFromString(string content, Encoding encoding, string mediaType)
protected void Dispose(bool disposing)
}
public System.Net.Mail.AlternateViewCollection : Collection`1<AlternateView> {
public void Dispose()
protected void ClearItems()
protected void InsertItem(int index, AlternateView item)
protected void RemoveItem(int index)
protected void SetItem(int index, AlternateView item)
}
public System.Net.Mail.Attachment : AttachmentBase {
private ContentDisposition contentDisposition
private Encoding nameEncoding
public ContentDisposition ContentDisposition
public string Name
public Encoding NameEncoding
public void .ctor(string fileName)
public void .ctor(string fileName, string mediaType)
public void .ctor(string fileName, ContentType contentType)
public void .ctor(Stream contentStream, ContentType contentType)
public void .ctor(Stream contentStream, string name)
public void .ctor(Stream contentStream, string name, string mediaType)
public ContentDisposition get_ContentDisposition()
public string get_Name()
public void set_Name(string value)
public Encoding get_NameEncoding()
public void set_NameEncoding(Encoding value)
public Attachment CreateAttachmentFromString(string content, ContentType contentType)
public Attachment CreateAttachmentFromString(string content, string name)
public Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType)
private void InitName(string fileName)
}
public System.Net.Mail.AttachmentBase : object {
private string id
private ContentType contentType
private Stream contentStream
private TransferEncoding transferEncoding
public string ContentId
public Stream ContentStream
public ContentType ContentType
public TransferEncoding TransferEncoding
protected void .ctor(Stream contentStream)
protected void .ctor(Stream contentStream, ContentType contentType)
protected void .ctor(Stream contentStream, string mediaType)
protected void .ctor(string fileName)
protected void .ctor(string fileName, ContentType contentType)
protected void .ctor(string fileName, string mediaType)
public string get_ContentId()
public void set_ContentId(string value)
public Stream get_ContentStream()
public ContentType get_ContentType()
public void set_ContentType(ContentType value)
public TransferEncoding get_TransferEncoding()
public void set_TransferEncoding(TransferEncoding value)
public void Dispose()
protected void Dispose(bool disposing)
}
public System.Net.Mail.AttachmentCollection : Collection`1<Attachment> {
public void Dispose()
protected void ClearItems()
protected void InsertItem(int index, Attachment item)
protected void RemoveItem(int index)
protected void SetItem(int index, Attachment item)
}
internal System.Net.Mail.CCredentialsByHost : object {
private string userName
private string password
public void .ctor(string userName, string password)
public NetworkCredential GetCredential(string host, int port, string authenticationType)
}
public System.Net.Mail.DeliveryNotificationOptions : Enum {
public int value__
public DeliveryNotificationOptions None
public DeliveryNotificationOptions OnSuccess
public DeliveryNotificationOptions OnFailure
public DeliveryNotificationOptions Delay
public DeliveryNotificationOptions Never
}
public System.Net.Mail.LinkedResource : AttachmentBase {
private Uri contentLink
public Uri ContentLink
public void .ctor(string fileName)
public void .ctor(string fileName, ContentType contentType)
public void .ctor(string fileName, string mediaType)
public void .ctor(Stream contentStream)
public void .ctor(Stream contentStream, ContentType contentType)
public void .ctor(Stream contentStream, string mediaType)
public Uri get_ContentLink()
public void set_ContentLink(Uri value)
public LinkedResource CreateLinkedResourceFromString(string content)
public LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType)
public LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType)
}
public System.Net.Mail.LinkedResourceCollection : Collection`1<LinkedResource> {
public void Dispose()
private void Dispose(bool disposing)
protected void ClearItems()
protected void InsertItem(int index, LinkedResource item)
protected void RemoveItem(int index)
protected void SetItem(int index, LinkedResource item)
}
public System.Net.Mail.MailAddress : object {
private string address
private string displayName
public string Address
public string DisplayName
public string Host
public string User
public void .ctor(string address)
public void .ctor(string address, string displayName)
public void .ctor(string address, string displayName, Encoding displayNameEncoding)
public string get_Address()
public string get_DisplayName()
public string get_Host()
public string get_User()
public bool Equals(object obj)
private bool Equals(MailAddress other)
public int GetHashCode()
public string ToString()
private FormatException CreateFormatException()
}
public System.Net.Mail.MailAddressCollection : Collection`1<MailAddress> {
public void Add(string addresses)
protected void InsertItem(int index, MailAddress item)
protected void SetItem(int index, MailAddress item)
public string ToString()
}
public System.Net.Mail.MailMessage : object {
private AlternateViewCollection alternateViews
private AttachmentCollection attachments
private MailAddressCollection bcc
private MailAddressCollection replyTo
private string body
private MailPriority priority
private MailAddress sender
private DeliveryNotificationOptions deliveryNotificationOptions
private MailAddressCollection cc
private MailAddress from
private NameValueCollection headers
private MailAddressCollection to
private string subject
private Encoding subjectEncoding
private Encoding bodyEncoding
private Encoding headersEncoding
private bool isHtml
public AlternateViewCollection AlternateViews
public AttachmentCollection Attachments
public MailAddressCollection Bcc
public string Body
internal ContentType BodyContentType
internal TransferEncoding ContentTransferEncoding
public Encoding BodyEncoding
public MailAddressCollection CC
public DeliveryNotificationOptions DeliveryNotificationOptions
public MailAddress From
public NameValueCollection Headers
public bool IsBodyHtml
public MailPriority Priority
internal Encoding HeadersEncoding
internal MailAddressCollection ReplyToList
public MailAddress ReplyTo
public MailAddress Sender
public string Subject
public Encoding SubjectEncoding
public MailAddressCollection To
public void .ctor(MailAddress from, MailAddress to)
public void .ctor(string from, string to)
public void .ctor(string from, string to, string subject, string body)
public AlternateViewCollection get_AlternateViews()
public AttachmentCollection get_Attachments()
public MailAddressCollection get_Bcc()
public string get_Body()
public void set_Body(string value)
internal ContentType get_BodyContentType()
internal TransferEncoding get_ContentTransferEncoding()
public Encoding get_BodyEncoding()
public void set_BodyEncoding(Encoding value)
public MailAddressCollection get_CC()
public DeliveryNotificationOptions get_DeliveryNotificationOptions()
public void set_DeliveryNotificationOptions(DeliveryNotificationOptions value)
public MailAddress get_From()
public void set_From(MailAddress value)
public NameValueCollection get_Headers()
public bool get_IsBodyHtml()
public void set_IsBodyHtml(bool value)
public MailPriority get_Priority()
public void set_Priority(MailPriority value)
internal Encoding get_HeadersEncoding()
internal void set_HeadersEncoding(Encoding value)
internal MailAddressCollection get_ReplyToList()
public MailAddress get_ReplyTo()
public void set_ReplyTo(MailAddress value)
public MailAddress get_Sender()
public void set_Sender(MailAddress value)
public string get_Subject()
public void set_Subject(string value)
public Encoding get_SubjectEncoding()
public void set_SubjectEncoding(Encoding value)
public MailAddressCollection get_To()
public void Dispose()
protected void Dispose(bool disposing)
private Encoding GuessEncoding(string s)
}
public System.Net.Mail.MailPriority : Enum {
public int value__
public MailPriority Normal
public MailPriority Low
public MailPriority High
}
public System.Net.Mail.SendCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AsyncCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.Mail.SmtpAccess : Enum {
public int value__
public SmtpAccess None
public SmtpAccess Connect
public SmtpAccess ConnectToUnrestrictedPort
}
public System.Net.Mail.SmtpClient : object {
private string host
private int port
private int timeout
private ICredentialsByHost credentials
private string pickupDirectoryLocation
private SmtpDeliveryMethod deliveryMethod
private bool enableSsl
private X509CertificateCollection clientCertificates
private TcpClient client
private Stream stream
private StreamWriter writer
private StreamReader reader
private int boundaryIndex
private MailAddress defaultFrom
private MailMessage messageInProcess
private BackgroundWorker worker
private object user_async_state
private AuthMechs authMechs
private Mutex mutex
private RemoteCertificateValidationCallback callback
private SendCompletedEventHandler SendCompleted
private string <TargetName>k__BackingField
private RemoteCertificateValidationCallback <>f__am$cache16
private Dictionary`2<string, int> <>f__switch$mapE
public X509CertificateCollection ClientCertificates
private string TargetName
public ICredentialsByHost Credentials
public SmtpDeliveryMethod DeliveryMethod
public bool EnableSsl
public string Host
public string PickupDirectoryLocation
public int Port
public ServicePoint ServicePoint
public int Timeout
public bool UseDefaultCredentials
public void .ctor(string host)
public void .ctor(string host, int port)
public void add_SendCompleted(SendCompletedEventHandler value)
public void remove_SendCompleted(SendCompletedEventHandler value)
public X509CertificateCollection get_ClientCertificates()
private string get_TargetName()
private void set_TargetName(string value)
public ICredentialsByHost get_Credentials()
public void set_Credentials(ICredentialsByHost value)
public SmtpDeliveryMethod get_DeliveryMethod()
public void set_DeliveryMethod(SmtpDeliveryMethod value)
public bool get_EnableSsl()
public void set_EnableSsl(bool value)
public string get_Host()
public void set_Host(string value)
public string get_PickupDirectoryLocation()
public void set_PickupDirectoryLocation(string value)
public int get_Port()
public void set_Port(int value)
public ServicePoint get_ServicePoint()
public int get_Timeout()
public void set_Timeout(int value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
private void CheckState()
private string EncodeAddress(MailAddress address)
private string EncodeAddresses(MailAddressCollection addresses)
private string EncodeSubjectRFC2047(MailMessage message)
private string EncodeBody(MailMessage message)
private string EncodeBody(AlternateView av)
private void EndSection(string section)
private string GenerateBoundary()
private string GenerateBoundary(int index)
private bool IsError(SmtpResponse status)
protected void OnSendCompleted(AsyncCompletedEventArgs e)
private void CheckCancellation()
private SmtpResponse Read()
private void ResetExtensions()
private void ParseExtensions(string extens)
public void Send(MailMessage message)
private void SendInternal(MailMessage message)
private void SendToFile(MailMessage message)
private void SendCore(MailMessage message)
public void Send(string from, string to, string subject, string body)
private void SendDot()
private void SendData(string data)
public void SendAsync(MailMessage message, object userToken)
public void SendAsync(string from, string to, string subject, string body, object userToken)
public void SendAsyncCancel()
private void AddPriorityHeader(MailMessage message)
private void SendSimpleBody(MailMessage message)
private void SendBodylessSingleAlternate(AlternateView av)
private void SendWithoutAttachments(MailMessage message, string boundary, bool attachmentExists)
private void SendWithAttachments(MailMessage message)
private void SendBodyWithAlternateViews(MailMessage message, string boundary, bool attachmentExists)
private void SendLinkedResources(MailMessage message, LinkedResourceCollection resources, string boundary)
private void SendAttachments(MailMessage message, Attachment body, string boundary)
private SmtpResponse SendCommand(string command)
private void SendHeader(string name, string value)
private void StartSection(string section, ContentType sectionContentType)
private void StartSection(string section, ContentType sectionContentType, TransferEncoding transferEncoding)
private void StartSection(string section, ContentType sectionContentType, TransferEncoding transferEncoding, LinkedResource lr)
private void StartSection(string section, ContentType sectionContentType, TransferEncoding transferEncoding, ContentDisposition contentDisposition)
private string ToQuotedPrintable(string input, Encoding enc)
private string ToQuotedPrintable(Byte[] bytes)
private string GetTransferEncodingName(TransferEncoding encoding)
private void InitiateSecureConnection()
private void Authenticate()
private void Authenticate(string Username, string Password)
private bool <callback>m__4(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
}
public System.Net.Mail.SmtpDeliveryMethod : Enum {
public int value__
public SmtpDeliveryMethod Network
public SmtpDeliveryMethod SpecifiedPickupDirectory
public SmtpDeliveryMethod PickupDirectoryFromIis
}
public System.Net.Mail.SmtpException : Exception {
private SmtpStatusCode statusCode
public SmtpStatusCode StatusCode
public void .ctor(SmtpStatusCode statusCode)
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(SmtpStatusCode statusCode, string message)
public void .ctor(string message, Exception innerException)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public SmtpStatusCode get_StatusCode()
public void set_StatusCode(SmtpStatusCode value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Net.Mail.SmtpFailedRecipientException : SmtpException {
private string failedRecipient
public string FailedRecipient
public void .ctor(string message)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void .ctor(SmtpStatusCode statusCode, string failedRecipient)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string failedRecipient, Exception innerException)
public void .ctor(SmtpStatusCode statusCode, string failedRecipient, string serverResponse)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public string get_FailedRecipient()
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Net.Mail.SmtpFailedRecipientsException : SmtpFailedRecipientException {
private SmtpFailedRecipientException[] innerExceptions
public SmtpFailedRecipientException[] InnerExceptions
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, SmtpFailedRecipientException[] innerExceptions)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public SmtpFailedRecipientException[] get_InnerExceptions()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Net.Mail.SmtpPermission : CodeAccessPermission {
private int version
private bool unrestricted
private SmtpAccess access
public SmtpAccess Access
public void .ctor(bool unrestricted)
public void .ctor(PermissionState state)
public void .ctor(SmtpAccess access)
public SmtpAccess get_Access()
public void AddPermission(SmtpAccess access)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public void FromXml(SecurityElement securityElement)
public IPermission Union(IPermission target)
private bool IsEmpty()
private SmtpPermission Cast(IPermission target)
}
public System.Net.Mail.SmtpPermissionAttribute : CodeAccessSecurityAttribute {
private string access
private Dictionary`2<string, int> <>f__switch$mapF
public string Access
public void .ctor(SecurityAction action)
public string get_Access()
public void set_Access(string value)
private SmtpAccess GetSmtpAccess()
public IPermission CreatePermission()
}
public System.Net.Mail.SmtpStatusCode : Enum {
public int value__
public SmtpStatusCode BadCommandSequence
public SmtpStatusCode CannotVerifyUserWillAttemptDelivery
public SmtpStatusCode ClientNotPermitted
public SmtpStatusCode CommandNotImplemented
public SmtpStatusCode CommandParameterNotImplemented
public SmtpStatusCode CommandUnrecognized
public SmtpStatusCode ExceededStorageAllocation
public SmtpStatusCode GeneralFailure
public SmtpStatusCode HelpMessage
public SmtpStatusCode InsufficientStorage
public SmtpStatusCode LocalErrorInProcessing
public SmtpStatusCode MailboxBusy
public SmtpStatusCode MailboxNameNotAllowed
public SmtpStatusCode MailboxUnavailable
public SmtpStatusCode Ok
public SmtpStatusCode ServiceClosingTransmissionChannel
public SmtpStatusCode ServiceNotAvailable
public SmtpStatusCode ServiceReady
public SmtpStatusCode StartMailInput
public SmtpStatusCode SyntaxError
public SmtpStatusCode SystemStatus
public SmtpStatusCode TransactionFailed
public SmtpStatusCode UserNotLocalTryAlternatePath
public SmtpStatusCode UserNotLocalWillForward
public SmtpStatusCode MustIssueStartTlsFirst
}
public System.Net.Mime.ContentDisposition : object {
private string rfc822
private string dispositionType
private StringDictionary parameters
public DateTime CreationDate
public string DispositionType
public string FileName
public bool Inline
public DateTime ModificationDate
public StringDictionary Parameters
public DateTime ReadDate
public long Size
public void .ctor(string disposition)
private void Parse(string pair)
public DateTime get_CreationDate()
public void set_CreationDate(DateTime value)
public string get_DispositionType()
public void set_DispositionType(string value)
public string get_FileName()
public void set_FileName(string value)
public bool get_Inline()
public void set_Inline(bool value)
public DateTime get_ModificationDate()
public void set_ModificationDate(DateTime value)
public StringDictionary get_Parameters()
public DateTime get_ReadDate()
public void set_ReadDate(DateTime value)
public long get_Size()
public void set_Size(long value)
public bool Equals(object obj)
private bool Equals(ContentDisposition other)
public int GetHashCode()
public string ToString()
}
public System.Net.Mime.ContentType : object {
private Encoding utf8unmarked
private string mediaType
private StringDictionary parameters
private Char[] especials
private Encoding UTF8Unmarked
public string Boundary
public string CharSet
public string MediaType
public string Name
public StringDictionary Parameters
public void .ctor(string contentType)
private void Parse(string pair)
private Encoding get_UTF8Unmarked()
public string get_Boundary()
public void set_Boundary(string value)
public string get_CharSet()
public void set_CharSet(string value)
public string get_MediaType()
public void set_MediaType(string value)
public string get_Name()
public void set_Name(string value)
public StringDictionary get_Parameters()
public bool Equals(object obj)
private bool Equals(ContentType other)
public int GetHashCode()
public string ToString()
private string WrapIfEspecialsExist(string s)
internal Encoding GuessEncoding(string s)
internal TransferEncoding GuessTransferEncoding(Encoding enc)
internal string To2047(Byte[] bytes)
internal string EncodeSubjectRFC2047(string s, Encoding enc)
}
public System.Net.Mime.DispositionTypeNames : object {
public string Attachment
public string Inline
}
public System.Net.Mime.TransferEncoding : Enum {
public int value__
public TransferEncoding QuotedPrintable
public TransferEncoding Base64
public TransferEncoding SevenBit
public TransferEncoding Unknown
}
internal System.Net.MonoHttpDate : object {
private string rfc1123_date
private string rfc850_date
private string asctime_date
private String[] formats
internal DateTime Parse(string dateStr)
}
internal System.Net.NetConfig : object {
internal bool ipv6Enabled
internal int MaxResponseHeadersLength
private object System.ICloneable.Clone()
}
public System.Net.NetworkAccess : Enum {
public int value__
public NetworkAccess Accept
public NetworkAccess Connect
}
public System.Net.NetworkCredential : object {
private string userName
private string password
private string domain
public string Domain
public string UserName
public string Password
public void .ctor(string userName, string password)
public void .ctor(string userName, string password, string domain)
public string get_Domain()
public void set_Domain(string value)
public string get_UserName()
public void set_UserName(string value)
public string get_Password()
public void set_Password(string value)
public NetworkCredential GetCredential(Uri uri, string authType)
public NetworkCredential GetCredential(string host, int port, string authenticationType)
}
internal System.Net.NetworkInformation.AlignmentUnion : ValueType {
public ulong Alignment
public int Length
public int IfIndex
}
public System.Net.NetworkInformation.DuplicateAddressDetectionState : Enum {
public int value__
public DuplicateAddressDetectionState Invalid
public DuplicateAddressDetectionState Tentative
public DuplicateAddressDetectionState Duplicate
public DuplicateAddressDetectionState Deprecated
public DuplicateAddressDetectionState Preferred
}
public System.Net.NetworkInformation.GatewayIPAddressInformation : object {
public IPAddress Address
public IPAddress get_Address()
}
public System.Net.NetworkInformation.GatewayIPAddressInformationCollection : object {
private List`1<GatewayIPAddressInformation> list
public int Count
public bool IsReadOnly
public GatewayIPAddressInformation Item
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(GatewayIPAddressInformation address)
public void Clear()
public bool Contains(GatewayIPAddressInformation address)
public void CopyTo(GatewayIPAddressInformation[] array, int offset)
public IEnumerator`1<GatewayIPAddressInformation> GetEnumerator()
public bool Remove(GatewayIPAddressInformation address)
public int get_Count()
public bool get_IsReadOnly()
public GatewayIPAddressInformation get_Item(int index)
}
internal System.Net.NetworkInformation.GatewayIPAddressInformationImpl : GatewayIPAddressInformation {
private IPAddress address
public IPAddress Address
public void .ctor(IPAddress address)
public IPAddress get_Address()
}
public System.Net.NetworkInformation.IcmpV4Statistics : object {
public long AddressMaskRepliesReceived
public long AddressMaskRepliesSent
public long AddressMaskRequestsReceived
public long AddressMaskRequestsSent
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MessagesReceived
public long MessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long SourceQuenchesReceived
public long SourceQuenchesSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long TimestampRepliesReceived
public long TimestampRepliesSent
public long TimestampRequestsReceived
public long TimestampRequestsSent
public long get_AddressMaskRepliesReceived()
public long get_AddressMaskRepliesSent()
public long get_AddressMaskRequestsReceived()
public long get_AddressMaskRequestsSent()
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_SourceQuenchesReceived()
public long get_SourceQuenchesSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
public long get_TimestampRepliesReceived()
public long get_TimestampRepliesSent()
public long get_TimestampRequestsReceived()
public long get_TimestampRequestsSent()
}
internal System.Net.NetworkInformation.IcmpV6MessageTypes : object {
public int DestinationUnreachable
public int PacketTooBig
public int TimeExceeded
public int ParameterProblem
public int EchoRequest
public int EchoReply
public int GroupMembershipQuery
public int GroupMembershipReport
public int GroupMembershipReduction
public int RouterSolicitation
public int RouterAdvertisement
public int NeighborSolicitation
public int NeighborAdvertisement
public int Redirect
public int RouterRenumbering
}
public System.Net.NetworkInformation.IcmpV6Statistics : object {
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MembershipQueriesReceived
public long MembershipQueriesSent
public long MembershipReductionsReceived
public long MembershipReductionsSent
public long MembershipReportsReceived
public long MembershipReportsSent
public long MessagesReceived
public long MessagesSent
public long NeighborAdvertisementsReceived
public long NeighborAdvertisementsSent
public long NeighborSolicitsReceived
public long NeighborSolicitsSent
public long PacketTooBigMessagesReceived
public long PacketTooBigMessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long RouterAdvertisementsReceived
public long RouterAdvertisementsSent
public long RouterSolicitsReceived
public long RouterSolicitsSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MembershipQueriesReceived()
public long get_MembershipQueriesSent()
public long get_MembershipReductionsReceived()
public long get_MembershipReductionsSent()
public long get_MembershipReportsReceived()
public long get_MembershipReportsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_NeighborAdvertisementsReceived()
public long get_NeighborAdvertisementsSent()
public long get_NeighborSolicitsReceived()
public long get_NeighborSolicitsSent()
public long get_PacketTooBigMessagesReceived()
public long get_PacketTooBigMessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_RouterAdvertisementsReceived()
public long get_RouterAdvertisementsSent()
public long get_RouterSolicitsReceived()
public long get_RouterSolicitsSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
}
internal System.Net.NetworkInformation.ifa_ifu : ValueType {
public IntPtr ifu_broadaddr
public IntPtr ifu_dstaddr
}
internal System.Net.NetworkInformation.ifaddrs : ValueType {
public IntPtr ifa_next
public string ifa_name
public UInt32 ifa_flags
public IntPtr ifa_addr
public IntPtr ifa_netmask
public ifa_ifu ifa_ifu
public IntPtr ifa_data
}
internal System.Net.NetworkInformation.in6_addr : ValueType {
public Byte[] u6_addr8
}
public System.Net.NetworkInformation.IPAddressCollection : object {
private IList`1<IPAddress> list
public int Count
public bool IsReadOnly
public IPAddress Item
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
internal void SetReadOnly()
public void Add(IPAddress address)
public void Clear()
public bool Contains(IPAddress address)
public void CopyTo(IPAddress[] array, int offset)
public IEnumerator`1<IPAddress> GetEnumerator()
public bool Remove(IPAddress address)
public int get_Count()
public bool get_IsReadOnly()
public IPAddress get_Item(int index)
}
public System.Net.NetworkInformation.IPAddressInformation : object {
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
}
public System.Net.NetworkInformation.IPAddressInformationCollection : object {
private List`1<IPAddressInformation> list
public int Count
public bool IsReadOnly
public IPAddressInformation Item
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(IPAddressInformation address)
public void Clear()
public bool Contains(IPAddressInformation address)
public void CopyTo(IPAddressInformation[] array, int offset)
public IEnumerator`1<IPAddressInformation> GetEnumerator()
public bool Remove(IPAddressInformation address)
public int get_Count()
public bool get_IsReadOnly()
public IPAddressInformation get_Item(int index)
}
internal System.Net.NetworkInformation.IPAddressInformationImpl : IPAddressInformation {
private IPAddress address
private bool is_dns_eligible
private bool is_transient
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public void .ctor(IPAddress address, bool isDnsEligible, bool isTransient)
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
}
internal System.Net.NetworkInformation.IPAddressInformationImplCollection : IPAddressInformationCollection {
public IPAddressInformationImplCollection Empty
private bool is_readonly
public bool IsReadOnly
private void .ctor(bool isReadOnly)
public bool get_IsReadOnly()
public IPAddressInformationCollection Win32FromAnycast(IntPtr ptr)
public IPAddressInformationImplCollection LinuxFromAnycast(IList`1<IPAddress> addresses)
}
public System.Net.NetworkInformation.IPGlobalProperties : object {
public string DhcpScopeName
public string DomainName
public string HostName
public bool IsWinsProxy
public NetBiosNodeType NodeType
public IPGlobalProperties GetIPGlobalProperties()
public TcpConnectionInformation[] GetActiveTcpConnections()
public IPEndPoint[] GetActiveTcpListeners()
public IPEndPoint[] GetActiveUdpListeners()
public IcmpV4Statistics GetIcmpV4Statistics()
public IcmpV6Statistics GetIcmpV6Statistics()
public IPGlobalStatistics GetIPv4GlobalStatistics()
public IPGlobalStatistics GetIPv6GlobalStatistics()
public TcpStatistics GetTcpIPv4Statistics()
public TcpStatistics GetTcpIPv6Statistics()
public UdpStatistics GetUdpIPv4Statistics()
public UdpStatistics GetUdpIPv6Statistics()
public string get_DhcpScopeName()
public string get_DomainName()
public string get_HostName()
public bool get_IsWinsProxy()
public NetBiosNodeType get_NodeType()
}
public System.Net.NetworkInformation.IPGlobalStatistics : object {
public int DefaultTtl
public bool ForwardingEnabled
public int NumberOfInterfaces
public int NumberOfIPAddresses
public int NumberOfRoutes
public long OutputPacketRequests
public long OutputPacketRoutingDiscards
public long OutputPacketsDiscarded
public long OutputPacketsWithNoRoute
public long PacketFragmentFailures
public long PacketReassembliesRequired
public long PacketReassemblyFailures
public long PacketReassemblyTimeout
public long PacketsFragmented
public long PacketsReassembled
public long ReceivedPackets
public long ReceivedPacketsDelivered
public long ReceivedPacketsDiscarded
public long ReceivedPacketsForwarded
public long ReceivedPacketsWithAddressErrors
public long ReceivedPacketsWithHeadersErrors
public long ReceivedPacketsWithUnknownProtocol
public int get_DefaultTtl()
public bool get_ForwardingEnabled()
public int get_NumberOfInterfaces()
public int get_NumberOfIPAddresses()
public int get_NumberOfRoutes()
public long get_OutputPacketRequests()
public long get_OutputPacketRoutingDiscards()
public long get_OutputPacketsDiscarded()
public long get_OutputPacketsWithNoRoute()
public long get_PacketFragmentFailures()
public long get_PacketReassembliesRequired()
public long get_PacketReassemblyFailures()
public long get_PacketReassemblyTimeout()
public long get_PacketsFragmented()
public long get_PacketsReassembled()
public long get_ReceivedPackets()
public long get_ReceivedPacketsDelivered()
public long get_ReceivedPacketsDiscarded()
public long get_ReceivedPacketsForwarded()
public long get_ReceivedPacketsWithAddressErrors()
public long get_ReceivedPacketsWithHeadersErrors()
public long get_ReceivedPacketsWithUnknownProtocol()
}
public System.Net.NetworkInformation.IPInterfaceProperties : object {
public IPAddressInformationCollection AnycastAddresses
public IPAddressCollection DhcpServerAddresses
public IPAddressCollection DnsAddresses
public string DnsSuffix
public GatewayIPAddressInformationCollection GatewayAddresses
public bool IsDnsEnabled
public bool IsDynamicDnsEnabled
public MulticastIPAddressInformationCollection MulticastAddresses
public UnicastIPAddressInformationCollection UnicastAddresses
public IPAddressCollection WinsServersAddresses
public IPv4InterfaceProperties GetIPv4Properties()
public IPv6InterfaceProperties GetIPv6Properties()
public IPAddressInformationCollection get_AnycastAddresses()
public IPAddressCollection get_DhcpServerAddresses()
public IPAddressCollection get_DnsAddresses()
public string get_DnsSuffix()
public GatewayIPAddressInformationCollection get_GatewayAddresses()
public bool get_IsDnsEnabled()
public bool get_IsDynamicDnsEnabled()
public MulticastIPAddressInformationCollection get_MulticastAddresses()
public UnicastIPAddressInformationCollection get_UnicastAddresses()
public IPAddressCollection get_WinsServersAddresses()
}
public System.Net.NetworkInformation.IPStatus : Enum {
public int value__
public IPStatus Unknown
public IPStatus Success
public IPStatus DestinationNetworkUnreachable
public IPStatus DestinationHostUnreachable
public IPStatus DestinationProhibited
public IPStatus DestinationProtocolUnreachable
public IPStatus DestinationPortUnreachable
public IPStatus NoResources
public IPStatus BadOption
public IPStatus HardwareError
public IPStatus PacketTooBig
public IPStatus TimedOut
public IPStatus BadRoute
public IPStatus TtlExpired
public IPStatus TtlReassemblyTimeExceeded
public IPStatus ParameterProblem
public IPStatus SourceQuench
public IPStatus BadDestination
public IPStatus DestinationUnreachable
public IPStatus TimeExceeded
public IPStatus BadHeader
public IPStatus UnrecognizedNextHeader
public IPStatus IcmpError
public IPStatus DestinationScopeMismatch
}
public System.Net.NetworkInformation.IPv4InterfaceProperties : object {
public int Index
public bool IsAutomaticPrivateAddressingActive
public bool IsAutomaticPrivateAddressingEnabled
public bool IsDhcpEnabled
public bool IsForwardingEnabled
public int Mtu
public bool UsesWins
public int get_Index()
public bool get_IsAutomaticPrivateAddressingActive()
public bool get_IsAutomaticPrivateAddressingEnabled()
public bool get_IsDhcpEnabled()
public bool get_IsForwardingEnabled()
public int get_Mtu()
public bool get_UsesWins()
}
public System.Net.NetworkInformation.IPv4InterfaceStatistics : object {
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
public System.Net.NetworkInformation.IPv6InterfaceProperties : object {
public int Index
public int Mtu
public int get_Index()
public int get_Mtu()
}
internal System.Net.NetworkInformation.LinuxArpHardware : Enum {
public int value__
public LinuxArpHardware ETHER
public LinuxArpHardware EETHER
public LinuxArpHardware PRONET
public LinuxArpHardware ATM
public LinuxArpHardware SLIP
public LinuxArpHardware PPP
public LinuxArpHardware LOOPBACK
public LinuxArpHardware FDDI
public LinuxArpHardware TUNNEL
public LinuxArpHardware TUNNEL6
}
internal System.Net.NetworkInformation.LinuxGatewayIPAddressInformationCollection : GatewayIPAddressInformationCollection {
public LinuxGatewayIPAddressInformationCollection Empty
private bool is_readonly
public bool IsReadOnly
private void .ctor(bool isReadOnly)
public void .ctor(IPAddressCollection col)
public bool get_IsReadOnly()
}
internal System.Net.NetworkInformation.LinuxIPInterfaceProperties : UnixIPInterfaceProperties {
public void .ctor(LinuxNetworkInterface iface, List`1<IPAddress> addresses)
public IPv4InterfaceProperties GetIPv4Properties()
}
internal System.Net.NetworkInformation.LinuxIPv4InterfaceProperties : UnixIPv4InterfaceProperties {
public bool IsForwardingEnabled
public int Mtu
public void .ctor(LinuxNetworkInterface iface)
public bool get_IsForwardingEnabled()
public int get_Mtu()
}
internal System.Net.NetworkInformation.LinuxIPv4InterfaceStatistics : IPv4InterfaceStatistics {
private LinuxNetworkInterface linux
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public void .ctor(LinuxNetworkInterface parent)
private long Read(string file)
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
internal System.Net.NetworkInformation.LinuxNetworkInterface : UnixNetworkInterface {
private int AF_INET
private int AF_INET6
private int AF_PACKET
private NetworkInterfaceType type
private string iface_path
private string iface_operstate_path
private string iface_flags_path
private Dictionary`2<string, int> <>f__switch$map12
internal string IfacePath
public OperationalStatus OperationalStatus
public bool SupportsMulticast
private void .ctor(string name)
internal string get_IfacePath()
private void InitializeInterfaceAddresses()
private int GetInterfaceAddresses(IntPtr& ifap)
private void FreeInterfaceAddresses(IntPtr ifap)
public NetworkInterface[] ImplGetAllNetworkInterfaces()
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public OperationalStatus get_OperationalStatus()
public bool get_SupportsMulticast()
}
internal System.Net.NetworkInformation.LinuxUnicastIPAddressInformation : UnicastIPAddressInformation {
private IPAddress address
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public IPAddress IPv4Mask
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public void .ctor(IPAddress address)
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public IPAddress get_IPv4Mask()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
}
internal System.Net.NetworkInformation.MacOsArpHardware : Enum {
public int value__
public MacOsArpHardware ETHER
public MacOsArpHardware ATM
public MacOsArpHardware SLIP
public MacOsArpHardware PPP
public MacOsArpHardware LOOPBACK
public MacOsArpHardware FDDI
}
internal System.Net.NetworkInformation.MacOsIPInterfaceProperties : UnixIPInterfaceProperties {
public void .ctor(MacOsNetworkInterface iface, List`1<IPAddress> addresses)
public IPv4InterfaceProperties GetIPv4Properties()
}
internal System.Net.NetworkInformation.MacOsIPv4InterfaceProperties : UnixIPv4InterfaceProperties {
public bool IsForwardingEnabled
public int Mtu
public void .ctor(MacOsNetworkInterface iface)
public bool get_IsForwardingEnabled()
public int get_Mtu()
}
internal System.Net.NetworkInformation.MacOsIPv4InterfaceStatistics : IPv4InterfaceStatistics {
private MacOsNetworkInterface macos
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public void .ctor(MacOsNetworkInterface parent)
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
internal System.Net.NetworkInformation.MacOsNetworkInterface : UnixNetworkInterface {
private int AF_INET
private int AF_INET6
private int AF_LINK
public OperationalStatus OperationalStatus
public bool SupportsMulticast
private void .ctor(string name)
private int getifaddrs(IntPtr& ifap)
private void freeifaddrs(IntPtr ifap)
public NetworkInterface[] ImplGetAllNetworkInterfaces()
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public OperationalStatus get_OperationalStatus()
public bool get_SupportsMulticast()
}
internal System.Net.NetworkInformation.MacOsStructs.ifaddrs : ValueType {
public IntPtr ifa_next
public string ifa_name
public UInt32 ifa_flags
public IntPtr ifa_addr
public IntPtr ifa_netmask
public IntPtr ifa_dstaddr
public IntPtr ifa_data
}
internal System.Net.NetworkInformation.MacOsStructs.in6_addr : ValueType {
public Byte[] u6_addr8
}
internal System.Net.NetworkInformation.MacOsStructs.sockaddr : ValueType {
public byte sa_len
public byte sa_family
}
internal System.Net.NetworkInformation.MacOsStructs.sockaddr_dl : ValueType {
public byte sdl_len
public byte sdl_family
public ushort sdl_index
public byte sdl_type
public byte sdl_nlen
public byte sdl_alen
public byte sdl_slen
public Byte[] sdl_data
}
internal System.Net.NetworkInformation.MacOsStructs.sockaddr_in : ValueType {
public byte sin_len
public byte sin_family
public ushort sin_port
public UInt32 sin_addr
}
internal System.Net.NetworkInformation.MacOsStructs.sockaddr_in6 : ValueType {
public byte sin6_len
public byte sin6_family
public ushort sin6_port
public UInt32 sin6_flowinfo
public in6_addr sin6_addr
public UInt32 sin6_scope_id
}
internal System.Net.NetworkInformation.MibIcmpV4Statistics : IcmpV4Statistics {
private StringDictionary dic
public long AddressMaskRepliesReceived
public long AddressMaskRepliesSent
public long AddressMaskRequestsReceived
public long AddressMaskRequestsSent
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MessagesReceived
public long MessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long SourceQuenchesReceived
public long SourceQuenchesSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long TimestampRepliesReceived
public long TimestampRepliesSent
public long TimestampRequestsReceived
public long TimestampRequestsSent
public void .ctor(StringDictionary dic)
private long Get(string name)
public long get_AddressMaskRepliesReceived()
public long get_AddressMaskRepliesSent()
public long get_AddressMaskRequestsReceived()
public long get_AddressMaskRequestsSent()
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_SourceQuenchesReceived()
public long get_SourceQuenchesSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
public long get_TimestampRepliesReceived()
public long get_TimestampRepliesSent()
public long get_TimestampRequestsReceived()
public long get_TimestampRequestsSent()
}
internal System.Net.NetworkInformation.MibIcmpV6Statistics : IcmpV6Statistics {
private StringDictionary dic
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MembershipQueriesReceived
public long MembershipQueriesSent
public long MembershipReductionsReceived
public long MembershipReductionsSent
public long MembershipReportsReceived
public long MembershipReportsSent
public long MessagesReceived
public long MessagesSent
public long NeighborAdvertisementsReceived
public long NeighborAdvertisementsSent
public long NeighborSolicitsReceived
public long NeighborSolicitsSent
public long PacketTooBigMessagesReceived
public long PacketTooBigMessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long RouterAdvertisementsReceived
public long RouterAdvertisementsSent
public long RouterSolicitsReceived
public long RouterSolicitsSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public void .ctor(StringDictionary dic)
private long Get(string name)
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MembershipQueriesReceived()
public long get_MembershipQueriesSent()
public long get_MembershipReductionsReceived()
public long get_MembershipReductionsSent()
public long get_MembershipReportsReceived()
public long get_MembershipReportsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_NeighborAdvertisementsReceived()
public long get_NeighborAdvertisementsSent()
public long get_NeighborSolicitsReceived()
public long get_NeighborSolicitsSent()
public long get_PacketTooBigMessagesReceived()
public long get_PacketTooBigMessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_RouterAdvertisementsReceived()
public long get_RouterAdvertisementsSent()
public long get_RouterSolicitsReceived()
public long get_RouterSolicitsSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
}
internal System.Net.NetworkInformation.MibIPGlobalProperties : IPGlobalProperties {
public string ProcDir
public string CompatProcDir
public string StatisticsFile
public string StatisticsFileIPv6
public string TcpFile
public string Tcp6File
public string UdpFile
public string Udp6File
private Char[] wsChars
public string DhcpScopeName
public string DomainName
public string HostName
public bool IsWinsProxy
public NetBiosNodeType NodeType
public void .ctor(string procDir)
private int gethostname(Byte[] name, int len)
private int getdomainname(Byte[] name, int len)
private StringDictionary GetProperties4(string item)
private StringDictionary GetProperties6(string item)
private Exception CreateException(string file, string msg)
private IPEndPoint[] GetLocalAddresses(List`1<String[]> list)
private IPEndPoint ToEndpoint(string s)
private void GetRows(string file, List`1<String[]> list)
public TcpConnectionInformation[] GetActiveTcpConnections()
public IPEndPoint[] GetActiveTcpListeners()
public IPEndPoint[] GetActiveUdpListeners()
public IcmpV4Statistics GetIcmpV4Statistics()
public IcmpV6Statistics GetIcmpV6Statistics()
public IPGlobalStatistics GetIPv4GlobalStatistics()
public IPGlobalStatistics GetIPv6GlobalStatistics()
public TcpStatistics GetTcpIPv4Statistics()
public TcpStatistics GetTcpIPv6Statistics()
public UdpStatistics GetUdpIPv4Statistics()
public UdpStatistics GetUdpIPv6Statistics()
public string get_DhcpScopeName()
public string get_DomainName()
public string get_HostName()
public bool get_IsWinsProxy()
public NetBiosNodeType get_NodeType()
}
internal System.Net.NetworkInformation.MibIPGlobalStatistics : IPGlobalStatistics {
private StringDictionary dic
public int DefaultTtl
public bool ForwardingEnabled
public int NumberOfInterfaces
public int NumberOfIPAddresses
public int NumberOfRoutes
public long OutputPacketRequests
public long OutputPacketRoutingDiscards
public long OutputPacketsDiscarded
public long OutputPacketsWithNoRoute
public long PacketFragmentFailures
public long PacketReassembliesRequired
public long PacketReassemblyFailures
public long PacketReassemblyTimeout
public long PacketsFragmented
public long PacketsReassembled
public long ReceivedPackets
public long ReceivedPacketsDelivered
public long ReceivedPacketsDiscarded
public long ReceivedPacketsForwarded
public long ReceivedPacketsWithAddressErrors
public long ReceivedPacketsWithHeadersErrors
public long ReceivedPacketsWithUnknownProtocol
public void .ctor(StringDictionary dic)
private long Get(string name)
public int get_DefaultTtl()
public bool get_ForwardingEnabled()
public int get_NumberOfInterfaces()
public int get_NumberOfIPAddresses()
public int get_NumberOfRoutes()
public long get_OutputPacketRequests()
public long get_OutputPacketRoutingDiscards()
public long get_OutputPacketsDiscarded()
public long get_OutputPacketsWithNoRoute()
public long get_PacketFragmentFailures()
public long get_PacketReassembliesRequired()
public long get_PacketReassemblyFailures()
public long get_PacketReassemblyTimeout()
public long get_PacketsFragmented()
public long get_PacketsReassembled()
public long get_ReceivedPackets()
public long get_ReceivedPacketsDelivered()
public long get_ReceivedPacketsDiscarded()
public long get_ReceivedPacketsForwarded()
public long get_ReceivedPacketsWithAddressErrors()
public long get_ReceivedPacketsWithHeadersErrors()
public long get_ReceivedPacketsWithUnknownProtocol()
}
internal System.Net.NetworkInformation.MibTcpStatistics : TcpStatistics {
private StringDictionary dic
public long ConnectionsAccepted
public long ConnectionsInitiated
public long CumulativeConnections
public long CurrentConnections
public long ErrorsReceived
public long FailedConnectionAttempts
public long MaximumConnections
public long MaximumTransmissionTimeout
public long MinimumTransmissionTimeout
public long ResetConnections
public long ResetsSent
public long SegmentsReceived
public long SegmentsResent
public long SegmentsSent
public void .ctor(StringDictionary dic)
private long Get(string name)
public long get_ConnectionsAccepted()
public long get_ConnectionsInitiated()
public long get_CumulativeConnections()
public long get_CurrentConnections()
public long get_ErrorsReceived()
public long get_FailedConnectionAttempts()
public long get_MaximumConnections()
public long get_MaximumTransmissionTimeout()
public long get_MinimumTransmissionTimeout()
public long get_ResetConnections()
public long get_ResetsSent()
public long get_SegmentsReceived()
public long get_SegmentsResent()
public long get_SegmentsSent()
}
internal System.Net.NetworkInformation.MibUdpStatistics : UdpStatistics {
private StringDictionary dic
public long DatagramsReceived
public long DatagramsSent
public long IncomingDatagramsDiscarded
public long IncomingDatagramsWithErrors
public int UdpListeners
public void .ctor(StringDictionary dic)
private long Get(string name)
public long get_DatagramsReceived()
public long get_DatagramsSent()
public long get_IncomingDatagramsDiscarded()
public long get_IncomingDatagramsWithErrors()
public int get_UdpListeners()
}
public System.Net.NetworkInformation.MulticastIPAddressInformation : IPAddressInformation {
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
}
public System.Net.NetworkInformation.MulticastIPAddressInformationCollection : object {
private List`1<MulticastIPAddressInformation> list
public int Count
public bool IsReadOnly
public MulticastIPAddressInformation Item
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(MulticastIPAddressInformation address)
public void Clear()
public bool Contains(MulticastIPAddressInformation address)
public void CopyTo(MulticastIPAddressInformation[] array, int offset)
public IEnumerator`1<MulticastIPAddressInformation> GetEnumerator()
public bool Remove(MulticastIPAddressInformation address)
public int get_Count()
public bool get_IsReadOnly()
public MulticastIPAddressInformation get_Item(int index)
}
internal System.Net.NetworkInformation.MulticastIPAddressInformationImpl : MulticastIPAddressInformation {
private IPAddress address
private bool is_dns_eligible
private bool is_transient
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public void .ctor(IPAddress address, bool isDnsEligible, bool isTransient)
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
}
internal System.Net.NetworkInformation.MulticastIPAddressInformationImplCollection : MulticastIPAddressInformationCollection {
public MulticastIPAddressInformationImplCollection Empty
private bool is_readonly
public bool IsReadOnly
private void .ctor(bool isReadOnly)
public bool get_IsReadOnly()
public MulticastIPAddressInformationCollection Win32FromMulticast(IntPtr ptr)
public MulticastIPAddressInformationImplCollection LinuxFromList(List`1<IPAddress> addresses)
}
public System.Net.NetworkInformation.NetBiosNodeType : Enum {
public int value__
public NetBiosNodeType Unknown
public NetBiosNodeType Broadcast
public NetBiosNodeType Peer2Peer
public NetBiosNodeType Mixed
public NetBiosNodeType Hybrid
}
public System.Net.NetworkInformation.NetworkAddressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, EventArgs e)
public IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.NetworkInformation.NetworkAvailabilityChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, NetworkAvailabilityEventArgs e)
public IAsyncResult BeginInvoke(object sender, NetworkAvailabilityEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.NetworkInformation.NetworkAvailabilityEventArgs : EventArgs {
private bool available
public bool IsAvailable
internal void .ctor(bool available)
public bool get_IsAvailable()
}
public System.Net.NetworkInformation.NetworkChange : object {
private NetworkAddressChangedEventHandler NetworkAddressChanged
private NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged
public void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value)
public void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
public void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value)
}
public System.Net.NetworkInformation.NetworkInformationAccess : Enum {
public int value__
public NetworkInformationAccess None
public NetworkInformationAccess Read
public NetworkInformationAccess Ping
}
public System.Net.NetworkInformation.NetworkInformationException : Win32Exception {
private int error_code
public int ErrorCode
public void .ctor(int errorCode)
protected void .ctor(SerializationInfo info, StreamingContext context)
public int get_ErrorCode()
}
public System.Net.NetworkInformation.NetworkInformationPermission : CodeAccessPermission {
private int version
public NetworkInformationAccess Access
public void .ctor(PermissionState state)
public void .ctor(NetworkInformationAccess access)
public void AddPermission(NetworkInformationAccess access)
public IPermission Copy()
public void FromXml(SecurityElement securityElement)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission target)
public NetworkInformationAccess get_Access()
}
public System.Net.NetworkInformation.NetworkInformationPermissionAttribute : CodeAccessSecurityAttribute {
private string access
private Dictionary`2<string, int> <>f__switch$map10
private Dictionary`2<string, int> <>f__switch$map11
public string Access
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
public string get_Access()
public void set_Access(string value)
}
public System.Net.NetworkInformation.NetworkInterface : object {
private Version windowsVer51
internal bool runningOnUnix
public int LoopbackInterfaceIndex
public string Description
public string Id
public bool IsReceiveOnly
public string Name
public NetworkInterfaceType NetworkInterfaceType
public OperationalStatus OperationalStatus
public long Speed
public bool SupportsMulticast
private int uname(IntPtr buf)
public NetworkInterface[] GetAllNetworkInterfaces()
public bool GetIsNetworkAvailable()
internal string ReadLine(string path)
public int get_LoopbackInterfaceIndex()
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public PhysicalAddress GetPhysicalAddress()
public bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
public string get_Description()
public string get_Id()
public bool get_IsReceiveOnly()
public string get_Name()
public NetworkInterfaceType get_NetworkInterfaceType()
public OperationalStatus get_OperationalStatus()
public long get_Speed()
public bool get_SupportsMulticast()
}
public System.Net.NetworkInformation.NetworkInterfaceComponent : Enum {
public int value__
public NetworkInterfaceComponent IPv4
public NetworkInterfaceComponent IPv6
}
public System.Net.NetworkInformation.NetworkInterfaceType : Enum {
public int value__
public NetworkInterfaceType Unknown
public NetworkInterfaceType Ethernet
public NetworkInterfaceType TokenRing
public NetworkInterfaceType Fddi
public NetworkInterfaceType BasicIsdn
public NetworkInterfaceType PrimaryIsdn
public NetworkInterfaceType Ppp
public NetworkInterfaceType Loopback
public NetworkInterfaceType Ethernet3Megabit
public NetworkInterfaceType Slip
public NetworkInterfaceType Atm
public NetworkInterfaceType GenericModem
public NetworkInterfaceType FastEthernetT
public NetworkInterfaceType Isdn
public NetworkInterfaceType FastEthernetFx
public NetworkInterfaceType Wireless80211
public NetworkInterfaceType AsymmetricDsl
public NetworkInterfaceType RateAdaptDsl
public NetworkInterfaceType SymmetricDsl
public NetworkInterfaceType VeryHighSpeedDsl
public NetworkInterfaceType IPOverAtm
public NetworkInterfaceType GigabitEthernet
public NetworkInterfaceType Tunnel
public NetworkInterfaceType MultiRateSymmetricDsl
public NetworkInterfaceType HighPerformanceSerialBus
}
public System.Net.NetworkInformation.OperationalStatus : Enum {
public int value__
public OperationalStatus Up
public OperationalStatus Down
public OperationalStatus Testing
public OperationalStatus Unknown
public OperationalStatus Dormant
public OperationalStatus NotPresent
public OperationalStatus LowerLayerDown
}
public System.Net.NetworkInformation.PhysicalAddress : object {
private int numberOfBytes
public PhysicalAddress None
private Byte[] bytes
public void .ctor(Byte[] address)
internal PhysicalAddress ParseEthernet(string address)
public PhysicalAddress Parse(string address)
private byte GetValue(char c)
public bool Equals(object comparand)
public int GetHashCode()
public Byte[] GetAddressBytes()
public string ToString()
}
public System.Net.NetworkInformation.Ping : Component {
private int DefaultCount
private int default_timeout
private int identifier
private UInt32 linux_cap_version
private String[] PingBinPaths
private string PingBinPath
private Byte[] default_buffer
private bool canSendPrivileged
private BackgroundWorker worker
private object user_async_state
private PingCompletedEventHandler PingCompleted
public void add_PingCompleted(PingCompletedEventHandler value)
public void remove_PingCompleted(PingCompletedEventHandler value)
private void System.IDisposable.Dispose()
private int capget(cap_user_header_t& header, cap_user_data_t& data)
private void CheckLinuxCapabilities()
protected void OnPingCompleted(PingCompletedEventArgs e)
public PingReply Send(IPAddress address)
public PingReply Send(IPAddress address, int timeout)
public PingReply Send(IPAddress address, int timeout, Byte[] buffer)
public PingReply Send(string hostNameOrAddress)
public PingReply Send(string hostNameOrAddress, int timeout)
public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer)
public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options)
private IPAddress GetNonLoopbackIP()
public PingReply Send(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
private PingReply SendPrivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
private PingReply SendUnprivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options)
public void SendAsync(IPAddress address, int timeout, Byte[] buffer, object userToken)
public void SendAsync(IPAddress address, int timeout, object userToken)
public void SendAsync(IPAddress address, object userToken)
public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, object userToken)
public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options, object userToken)
public void SendAsync(string hostNameOrAddress, int timeout, object userToken)
public void SendAsync(string hostNameOrAddress, object userToken)
public void SendAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options, object userToken)
public void SendAsyncCancel()
private string BuildPingArgs(IPAddress address, int timeout, PingOptions options)
}
public System.Net.NetworkInformation.PingCompletedEventArgs : AsyncCompletedEventArgs {
private PingReply reply
public PingReply Reply
internal void .ctor(Exception ex, bool cancelled, object userState, PingReply reply)
public PingReply get_Reply()
}
public System.Net.NetworkInformation.PingCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, PingCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, PingCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.NetworkInformation.PingException : InvalidOperationException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Net.NetworkInformation.PingOptions : object {
private int ttl
private bool dont_fragment
public bool DontFragment
public int Ttl
public void .ctor(int ttl, bool dontFragment)
public bool get_DontFragment()
public void set_DontFragment(bool value)
public int get_Ttl()
public void set_Ttl(int value)
}
public System.Net.NetworkInformation.PingReply : object {
private IPAddress address
private Byte[] buffer
private PingOptions options
private long rtt
private IPStatus status
public IPAddress Address
public Byte[] Buffer
public PingOptions Options
public long RoundtripTime
public IPStatus Status
internal void .ctor(IPAddress address, Byte[] buffer, PingOptions options, long roundtripTime, IPStatus status)
public IPAddress get_Address()
public Byte[] get_Buffer()
public PingOptions get_Options()
public long get_RoundtripTime()
public IPStatus get_Status()
}
public System.Net.NetworkInformation.PrefixOrigin : Enum {
public int value__
public PrefixOrigin Other
public PrefixOrigin Manual
public PrefixOrigin WellKnown
public PrefixOrigin Dhcp
public PrefixOrigin RouterAdvertisement
}
internal System.Net.NetworkInformation.sockaddr_in : ValueType {
public ushort sin_family
public ushort sin_port
public UInt32 sin_addr
}
internal System.Net.NetworkInformation.sockaddr_in6 : ValueType {
public ushort sin6_family
public ushort sin6_port
public UInt32 sin6_flowinfo
public in6_addr sin6_addr
public UInt32 sin6_scope_id
}
internal System.Net.NetworkInformation.sockaddr_ll : ValueType {
public ushort sll_family
public ushort sll_protocol
public int sll_ifindex
public ushort sll_hatype
public byte sll_pkttype
public byte sll_halen
public Byte[] sll_addr
}
public System.Net.NetworkInformation.SuffixOrigin : Enum {
public int value__
public SuffixOrigin Other
public SuffixOrigin Manual
public SuffixOrigin WellKnown
public SuffixOrigin OriginDhcp
public SuffixOrigin LinkLayerAddress
public SuffixOrigin Random
}
public System.Net.NetworkInformation.TcpConnectionInformation : object {
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public TcpState State
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
public TcpState get_State()
}
internal System.Net.NetworkInformation.TcpConnectionInformationImpl : TcpConnectionInformation {
private IPEndPoint local
private IPEndPoint remote
private TcpState state
public IPEndPoint LocalEndPoint
public IPEndPoint RemoteEndPoint
public TcpState State
public void .ctor(IPEndPoint local, IPEndPoint remote, TcpState state)
public IPEndPoint get_LocalEndPoint()
public IPEndPoint get_RemoteEndPoint()
public TcpState get_State()
}
public System.Net.NetworkInformation.TcpState : Enum {
public int value__
public TcpState Unknown
public TcpState Closed
public TcpState Listen
public TcpState SynSent
public TcpState SynReceived
public TcpState Established
public TcpState FinWait1
public TcpState FinWait2
public TcpState CloseWait
public TcpState Closing
public TcpState LastAck
public TcpState TimeWait
public TcpState DeleteTcb
}
public System.Net.NetworkInformation.TcpStatistics : object {
public long ConnectionsAccepted
public long ConnectionsInitiated
public long CumulativeConnections
public long CurrentConnections
public long ErrorsReceived
public long FailedConnectionAttempts
public long MaximumConnections
public long MaximumTransmissionTimeout
public long MinimumTransmissionTimeout
public long ResetConnections
public long ResetsSent
public long SegmentsReceived
public long SegmentsResent
public long SegmentsSent
public long get_ConnectionsAccepted()
public long get_ConnectionsInitiated()
public long get_CumulativeConnections()
public long get_CurrentConnections()
public long get_ErrorsReceived()
public long get_FailedConnectionAttempts()
public long get_MaximumConnections()
public long get_MaximumTransmissionTimeout()
public long get_MinimumTransmissionTimeout()
public long get_ResetConnections()
public long get_ResetsSent()
public long get_SegmentsReceived()
public long get_SegmentsResent()
public long get_SegmentsSent()
}
public System.Net.NetworkInformation.UdpStatistics : object {
public long DatagramsReceived
public long DatagramsSent
public long IncomingDatagramsDiscarded
public long IncomingDatagramsWithErrors
public int UdpListeners
public long get_DatagramsReceived()
public long get_DatagramsSent()
public long get_IncomingDatagramsDiscarded()
public long get_IncomingDatagramsWithErrors()
public int get_UdpListeners()
}
public System.Net.NetworkInformation.UnicastIPAddressInformation : IPAddressInformation {
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public IPAddress IPv4Mask
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public IPAddress get_IPv4Mask()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
}
public System.Net.NetworkInformation.UnicastIPAddressInformationCollection : object {
private List`1<UnicastIPAddressInformation> list
public int Count
public bool IsReadOnly
public UnicastIPAddressInformation Item
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(UnicastIPAddressInformation address)
public void Clear()
public bool Contains(UnicastIPAddressInformation address)
public void CopyTo(UnicastIPAddressInformation[] array, int offset)
public IEnumerator`1<UnicastIPAddressInformation> GetEnumerator()
public bool Remove(UnicastIPAddressInformation address)
public int get_Count()
public bool get_IsReadOnly()
public UnicastIPAddressInformation get_Item(int index)
}
internal System.Net.NetworkInformation.UnicastIPAddressInformationImplCollection : UnicastIPAddressInformationCollection {
public UnicastIPAddressInformationImplCollection Empty
private bool is_readonly
public bool IsReadOnly
private void .ctor(bool isReadOnly)
public bool get_IsReadOnly()
public UnicastIPAddressInformationCollection Win32FromUnicast(int ifIndex, IntPtr ptr)
public UnicastIPAddressInformationCollection LinuxFromList(List`1<IPAddress> addresses)
}
internal System.Net.NetworkInformation.UnixIPInterfaceProperties : IPInterfaceProperties {
protected IPv4InterfaceProperties ipv4iface_properties
protected UnixNetworkInterface iface
private List`1<IPAddress> addresses
private IPAddressCollection dns_servers
private IPAddressCollection gateways
private string dns_suffix
private DateTime last_parse
private Regex ns
private Regex search
public IPAddressInformationCollection AnycastAddresses
public IPAddressCollection DhcpServerAddresses
public IPAddressCollection DnsAddresses
public string DnsSuffix
public GatewayIPAddressInformationCollection GatewayAddresses
public bool IsDnsEnabled
public bool IsDynamicDnsEnabled
public MulticastIPAddressInformationCollection MulticastAddresses
public UnicastIPAddressInformationCollection UnicastAddresses
public IPAddressCollection WinsServersAddresses
public void .ctor(UnixNetworkInterface iface, List`1<IPAddress> addresses)
public IPv6InterfaceProperties GetIPv6Properties()
private void ParseRouteInfo(string iface)
private void ParseResolvConf()
public IPAddressInformationCollection get_AnycastAddresses()
public IPAddressCollection get_DhcpServerAddresses()
public IPAddressCollection get_DnsAddresses()
public string get_DnsSuffix()
public GatewayIPAddressInformationCollection get_GatewayAddresses()
public bool get_IsDnsEnabled()
public bool get_IsDynamicDnsEnabled()
public MulticastIPAddressInformationCollection get_MulticastAddresses()
public UnicastIPAddressInformationCollection get_UnicastAddresses()
public IPAddressCollection get_WinsServersAddresses()
}
internal System.Net.NetworkInformation.UnixIPv4InterfaceProperties : IPv4InterfaceProperties {
protected UnixNetworkInterface iface
public int Index
public bool IsAutomaticPrivateAddressingActive
public bool IsAutomaticPrivateAddressingEnabled
public bool IsDhcpEnabled
public bool UsesWins
public void .ctor(UnixNetworkInterface iface)
public int get_Index()
public bool get_IsAutomaticPrivateAddressingActive()
public bool get_IsAutomaticPrivateAddressingEnabled()
public bool get_IsDhcpEnabled()
public bool get_UsesWins()
}
internal System.Net.NetworkInformation.UnixNetworkInterface : NetworkInterface {
protected IPv4InterfaceStatistics ipv4stats
protected IPInterfaceProperties ipproperties
private string name
private int index
protected List`1<IPAddress> addresses
private Byte[] macAddress
private NetworkInterfaceType type
public string Description
public string Id
public bool IsReceiveOnly
public string Name
public NetworkInterfaceType NetworkInterfaceType
public long Speed
internal void .ctor(string name)
private int if_nametoindex(string ifname)
public int IfNameToIndex(string ifname)
internal void AddAddress(IPAddress address)
internal void SetLinkLayerInfo(int index, Byte[] macAddress, NetworkInterfaceType type)
public PhysicalAddress GetPhysicalAddress()
public bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
public string get_Description()
public string get_Id()
public bool get_IsReceiveOnly()
public string get_Name()
public NetworkInterfaceType get_NetworkInterfaceType()
public long get_Speed()
}
internal System.Net.NetworkInformation.Win32_FIXED_INFO : object {
private int MAX_HOSTNAME_LEN
private int MAX_DOMAIN_NAME_LEN
private int MAX_SCOPE_ID_LEN
private Win32_FIXED_INFO fixed_info
public string HostName
public string DomainName
public IntPtr CurrentDnsServer
public Win32_IP_ADDR_STRING DnsServerList
public NetBiosNodeType NodeType
public string ScopeId
public UInt32 EnableRouting
public UInt32 EnableProxy
public UInt32 EnableDns
public Win32_FIXED_INFO Instance
private int GetNetworkParams(Byte[] bytes, Int32& size)
public Win32_FIXED_INFO get_Instance()
private Win32_FIXED_INFO GetInstance()
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_ADDRESSES : object {
private int MAX_ADAPTER_ADDRESS_LENGTH
private int IP_ADAPTER_DDNS_ENABLED
private int IP_ADAPTER_RECEIVE_ONLY
private int IP_ADAPTER_NO_MULTICAST
public AlignmentUnion Alignment
public IntPtr Next
public string AdapterName
public IntPtr FirstUnicastAddress
public IntPtr FirstAnycastAddress
public IntPtr FirstMulticastAddress
public IntPtr FirstDnsServerAddress
public string DnsSuffix
public string Description
public string FriendlyName
public Byte[] PhysicalAddress
public UInt32 PhysicalAddressLength
public UInt32 Flags
public UInt32 Mtu
public NetworkInterfaceType IfType
public OperationalStatus OperStatus
public int Ipv6IfIndex
public UInt32[] ZoneIndices
public bool DdnsEnabled
public bool IsReceiveOnly
public bool NoMulticast
public bool get_DdnsEnabled()
public bool get_IsReceiveOnly()
public bool get_NoMulticast()
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_ANYCAST_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_DNS_SERVER_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_INFO : object {
private int MAX_ADAPTER_NAME_LENGTH
private int MAX_ADAPTER_DESCRIPTION_LENGTH
private int MAX_ADAPTER_ADDRESS_LENGTH
public IntPtr Next
public int ComboIndex
public string AdapterName
public string Description
public UInt32 AddressLength
public Byte[] Address
public UInt32 Index
public UInt32 Type
public UInt32 DhcpEnabled
public IntPtr CurrentIpAddress
public Win32_IP_ADDR_STRING IpAddressList
public Win32_IP_ADDR_STRING GatewayList
public Win32_IP_ADDR_STRING DhcpServer
public bool HaveWins
public Win32_IP_ADDR_STRING PrimaryWinsServer
public Win32_IP_ADDR_STRING SecondaryWinsServer
public long LeaseObtained
public long LeaseExpires
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_MULTICAST_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
}
internal System.Net.NetworkInformation.Win32_IP_ADAPTER_UNICAST_ADDRESS : ValueType {
public Win32LengthFlagsUnion LengthFlags
public IntPtr Next
public Win32_SOCKET_ADDRESS Address
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public DuplicateAddressDetectionState DadState
public UInt32 ValidLifetime
public UInt32 PreferredLifetime
public UInt32 LeaseLifetime
public byte OnLinkPrefixLength
}
internal System.Net.NetworkInformation.Win32_IP_ADDR_STRING : ValueType {
public IntPtr Next
public string IpAddress
public string IpMask
public UInt32 Context
}
internal System.Net.NetworkInformation.Win32_IP_PER_ADAPTER_INFO : object {
public UInt32 AutoconfigEnabled
public UInt32 AutoconfigActive
public IntPtr CurrentDnsServer
public Win32_IP_ADDR_STRING DnsServerList
}
internal System.Net.NetworkInformation.Win32_MIB_ICMP_EX : ValueType {
public Win32_MIBICMPSTATS_EX InStats
public Win32_MIBICMPSTATS_EX OutStats
}
internal System.Net.NetworkInformation.Win32_MIB_IFROW : ValueType {
private int MAX_INTERFACE_NAME_LEN
private int MAXLEN_PHYSADDR
private int MAXLEN_IFDESCR
public Char[] Name
public int Index
public NetworkInterfaceType Type
public int Mtu
public UInt32 Speed
public int PhysAddrLen
public Byte[] PhysAddr
public UInt32 AdminStatus
public UInt32 OperStatus
public UInt32 LastChange
public int InOctets
public int InUcastPkts
public int InNUcastPkts
public int InDiscards
public int InErrors
public int InUnknownProtos
public int OutOctets
public int OutUcastPkts
public int OutNUcastPkts
public int OutDiscards
public int OutErrors
public int OutQLen
public int DescrLen
public Byte[] Descr
}
internal System.Net.NetworkInformation.Win32_MIB_IPSTATS : ValueType {
public int Forwarding
public int DefaultTTL
public UInt32 InReceives
public UInt32 InHdrErrors
public UInt32 InAddrErrors
public UInt32 ForwDatagrams
public UInt32 InUnknownProtos
public UInt32 InDiscards
public UInt32 InDelivers
public UInt32 OutRequests
public UInt32 RoutingDiscards
public UInt32 OutDiscards
public UInt32 OutNoRoutes
public UInt32 ReasmTimeout
public UInt32 ReasmReqds
public UInt32 ReasmOks
public UInt32 ReasmFails
public UInt32 FragOks
public UInt32 FragFails
public UInt32 FragCreates
public int NumIf
public int NumAddr
public int NumRoutes
}
internal System.Net.NetworkInformation.Win32_MIB_TCPSTATS : ValueType {
public UInt32 RtoAlgorithm
public UInt32 RtoMin
public UInt32 RtoMax
public UInt32 MaxConn
public UInt32 ActiveOpens
public UInt32 PassiveOpens
public UInt32 AttemptFails
public UInt32 EstabResets
public UInt32 CurrEstab
public UInt32 InSegs
public UInt32 OutSegs
public UInt32 RetransSegs
public UInt32 InErrs
public UInt32 OutRsts
public UInt32 NumConns
}
internal System.Net.NetworkInformation.Win32_MIB_UDPSTATS : ValueType {
public UInt32 InDatagrams
public UInt32 NoPorts
public UInt32 InErrors
public UInt32 OutDatagrams
public int NumAddrs
}
internal System.Net.NetworkInformation.Win32_MIBICMPINFO : ValueType {
public Win32_MIBICMPSTATS InStats
public Win32_MIBICMPSTATS OutStats
}
internal System.Net.NetworkInformation.Win32_MIBICMPSTATS : ValueType {
public UInt32 Msgs
public UInt32 Errors
public UInt32 DestUnreachs
public UInt32 TimeExcds
public UInt32 ParmProbs
public UInt32 SrcQuenchs
public UInt32 Redirects
public UInt32 Echos
public UInt32 EchoReps
public UInt32 Timestamps
public UInt32 TimestampReps
public UInt32 AddrMasks
public UInt32 AddrMaskReps
}
internal System.Net.NetworkInformation.Win32_MIBICMPSTATS_EX : ValueType {
public UInt32 Msgs
public UInt32 Errors
public UInt32[] Counts
}
internal System.Net.NetworkInformation.Win32_SOCKADDR : ValueType {
public ushort AddressFamily
public Byte[] AddressData
}
internal System.Net.NetworkInformation.Win32_SOCKET_ADDRESS : ValueType {
private int AF_INET6
public IntPtr Sockaddr
public int SockaddrLength
public IPAddress GetIPAddress()
}
internal System.Net.NetworkInformation.Win32GatewayIPAddressInformationCollection : GatewayIPAddressInformationCollection {
public Win32GatewayIPAddressInformationCollection Empty
private bool is_readonly
public bool IsReadOnly
private void .ctor(bool isReadOnly)
public void .ctor(Win32_IP_ADDR_STRING[] al)
private void AddSubsequently(IntPtr head)
public bool get_IsReadOnly()
}
internal System.Net.NetworkInformation.Win32IcmpV4Statistics : IcmpV4Statistics {
private Win32_MIBICMPSTATS iin
private Win32_MIBICMPSTATS iout
public long AddressMaskRepliesReceived
public long AddressMaskRepliesSent
public long AddressMaskRequestsReceived
public long AddressMaskRequestsSent
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MessagesReceived
public long MessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long SourceQuenchesReceived
public long SourceQuenchesSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public long TimestampRepliesReceived
public long TimestampRepliesSent
public long TimestampRequestsReceived
public long TimestampRequestsSent
public void .ctor(Win32_MIBICMPINFO info)
public long get_AddressMaskRepliesReceived()
public long get_AddressMaskRepliesSent()
public long get_AddressMaskRequestsReceived()
public long get_AddressMaskRequestsSent()
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_SourceQuenchesReceived()
public long get_SourceQuenchesSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
public long get_TimestampRepliesReceived()
public long get_TimestampRepliesSent()
public long get_TimestampRequestsReceived()
public long get_TimestampRequestsSent()
}
internal System.Net.NetworkInformation.Win32IcmpV6Statistics : IcmpV6Statistics {
private Win32_MIBICMPSTATS_EX iin
private Win32_MIBICMPSTATS_EX iout
public long DestinationUnreachableMessagesReceived
public long DestinationUnreachableMessagesSent
public long EchoRepliesReceived
public long EchoRepliesSent
public long EchoRequestsReceived
public long EchoRequestsSent
public long ErrorsReceived
public long ErrorsSent
public long MembershipQueriesReceived
public long MembershipQueriesSent
public long MembershipReductionsReceived
public long MembershipReductionsSent
public long MembershipReportsReceived
public long MembershipReportsSent
public long MessagesReceived
public long MessagesSent
public long NeighborAdvertisementsReceived
public long NeighborAdvertisementsSent
public long NeighborSolicitsReceived
public long NeighborSolicitsSent
public long PacketTooBigMessagesReceived
public long PacketTooBigMessagesSent
public long ParameterProblemsReceived
public long ParameterProblemsSent
public long RedirectsReceived
public long RedirectsSent
public long RouterAdvertisementsReceived
public long RouterAdvertisementsSent
public long RouterSolicitsReceived
public long RouterSolicitsSent
public long TimeExceededMessagesReceived
public long TimeExceededMessagesSent
public void .ctor(Win32_MIB_ICMP_EX info)
public long get_DestinationUnreachableMessagesReceived()
public long get_DestinationUnreachableMessagesSent()
public long get_EchoRepliesReceived()
public long get_EchoRepliesSent()
public long get_EchoRequestsReceived()
public long get_EchoRequestsSent()
public long get_ErrorsReceived()
public long get_ErrorsSent()
public long get_MembershipQueriesReceived()
public long get_MembershipQueriesSent()
public long get_MembershipReductionsReceived()
public long get_MembershipReductionsSent()
public long get_MembershipReportsReceived()
public long get_MembershipReportsSent()
public long get_MessagesReceived()
public long get_MessagesSent()
public long get_NeighborAdvertisementsReceived()
public long get_NeighborAdvertisementsSent()
public long get_NeighborSolicitsReceived()
public long get_NeighborSolicitsSent()
public long get_PacketTooBigMessagesReceived()
public long get_PacketTooBigMessagesSent()
public long get_ParameterProblemsReceived()
public long get_ParameterProblemsSent()
public long get_RedirectsReceived()
public long get_RedirectsSent()
public long get_RouterAdvertisementsReceived()
public long get_RouterAdvertisementsSent()
public long get_RouterSolicitsReceived()
public long get_RouterSolicitsSent()
public long get_TimeExceededMessagesReceived()
public long get_TimeExceededMessagesSent()
}
internal System.Net.NetworkInformation.Win32IPAddressCollection : IPAddressCollection {
public Win32IPAddressCollection Empty
private bool is_readonly
public bool IsReadOnly
public void .ctor(IntPtr[] heads)
public void .ctor(Win32_IP_ADDR_STRING[] al)
public Win32IPAddressCollection FromAnycast(IntPtr ptr)
public Win32IPAddressCollection FromDnsServer(IntPtr ptr)
private void AddSubsequentlyString(IntPtr head)
public bool get_IsReadOnly()
}
internal System.Net.NetworkInformation.Win32IPGlobalProperties : IPGlobalProperties {
public int AF_INET
public int AF_INET6
public string DhcpScopeName
public string DomainName
public string HostName
public bool IsWinsProxy
public NetBiosNodeType NodeType
private void FillTcpTable(List`1& tab4, List`1& tab6)
private bool IsListenerState(TcpState state)
public TcpConnectionInformation[] GetActiveTcpConnections()
public IPEndPoint[] GetActiveTcpListeners()
public IPEndPoint[] GetActiveUdpListeners()
public IcmpV4Statistics GetIcmpV4Statistics()
public IcmpV6Statistics GetIcmpV6Statistics()
public IPGlobalStatistics GetIPv4GlobalStatistics()
public IPGlobalStatistics GetIPv6GlobalStatistics()
public TcpStatistics GetTcpIPv4Statistics()
public TcpStatistics GetTcpIPv6Statistics()
public UdpStatistics GetUdpIPv4Statistics()
public UdpStatistics GetUdpIPv6Statistics()
public string get_DhcpScopeName()
public string get_DomainName()
public string get_HostName()
public bool get_IsWinsProxy()
public NetBiosNodeType get_NodeType()
private int GetTcpTable(Byte[] pTcpTable, Int32& pdwSize, bool bOrder)
private int GetTcp6Table(Byte[] TcpTable, Int32& SizePointer, bool Order)
private int GetUdpTable(Byte[] pUdpTable, Int32& pdwSize, bool bOrder)
private int GetUdp6Table(Byte[] Udp6Table, Int32& SizePointer, bool Order)
private int GetTcpStatisticsEx(Win32_MIB_TCPSTATS& pStats, int dwFamily)
private int GetUdpStatisticsEx(Win32_MIB_UDPSTATS& pStats, int dwFamily)
private int GetIcmpStatistics(Win32_MIBICMPINFO& pStats, int dwFamily)
private int GetIcmpStatisticsEx(Win32_MIB_ICMP_EX& pStats, int dwFamily)
private int GetIPStatisticsEx(Win32_MIB_IPSTATS& pStats, int dwFamily)
}
internal System.Net.NetworkInformation.Win32IPGlobalStatistics : IPGlobalStatistics {
private Win32_MIB_IPSTATS info
public int DefaultTtl
public bool ForwardingEnabled
public int NumberOfInterfaces
public int NumberOfIPAddresses
public int NumberOfRoutes
public long OutputPacketRequests
public long OutputPacketRoutingDiscards
public long OutputPacketsDiscarded
public long OutputPacketsWithNoRoute
public long PacketFragmentFailures
public long PacketReassembliesRequired
public long PacketReassemblyFailures
public long PacketReassemblyTimeout
public long PacketsFragmented
public long PacketsReassembled
public long ReceivedPackets
public long ReceivedPacketsDelivered
public long ReceivedPacketsDiscarded
public long ReceivedPacketsForwarded
public long ReceivedPacketsWithAddressErrors
public long ReceivedPacketsWithHeadersErrors
public long ReceivedPacketsWithUnknownProtocol
public void .ctor(Win32_MIB_IPSTATS info)
public int get_DefaultTtl()
public bool get_ForwardingEnabled()
public int get_NumberOfInterfaces()
public int get_NumberOfIPAddresses()
public int get_NumberOfRoutes()
public long get_OutputPacketRequests()
public long get_OutputPacketRoutingDiscards()
public long get_OutputPacketsDiscarded()
public long get_OutputPacketsWithNoRoute()
public long get_PacketFragmentFailures()
public long get_PacketReassembliesRequired()
public long get_PacketReassemblyFailures()
public long get_PacketReassemblyTimeout()
public long get_PacketsFragmented()
public long get_PacketsReassembled()
public long get_ReceivedPackets()
public long get_ReceivedPacketsDelivered()
public long get_ReceivedPacketsDiscarded()
public long get_ReceivedPacketsForwarded()
public long get_ReceivedPacketsWithAddressErrors()
public long get_ReceivedPacketsWithHeadersErrors()
public long get_ReceivedPacketsWithUnknownProtocol()
}
internal System.Net.NetworkInformation.Win32IPInterfaceProperties2 : IPInterfaceProperties {
private Win32_IP_ADAPTER_ADDRESSES addr
private Win32_MIB_IFROW mib4
private Win32_MIB_IFROW mib6
public IPAddressInformationCollection AnycastAddresses
public IPAddressCollection DhcpServerAddresses
public IPAddressCollection DnsAddresses
public string DnsSuffix
public GatewayIPAddressInformationCollection GatewayAddresses
public bool IsDnsEnabled
public bool IsDynamicDnsEnabled
public MulticastIPAddressInformationCollection MulticastAddresses
public UnicastIPAddressInformationCollection UnicastAddresses
public IPAddressCollection WinsServersAddresses
public void .ctor(Win32_IP_ADAPTER_ADDRESSES addr, Win32_MIB_IFROW mib4, Win32_MIB_IFROW mib6)
public IPv4InterfaceProperties GetIPv4Properties()
public IPv6InterfaceProperties GetIPv6Properties()
public IPAddressInformationCollection get_AnycastAddresses()
public IPAddressCollection get_DhcpServerAddresses()
public IPAddressCollection get_DnsAddresses()
public string get_DnsSuffix()
public GatewayIPAddressInformationCollection get_GatewayAddresses()
public bool get_IsDnsEnabled()
public bool get_IsDynamicDnsEnabled()
public MulticastIPAddressInformationCollection get_MulticastAddresses()
public UnicastIPAddressInformationCollection get_UnicastAddresses()
public IPAddressCollection get_WinsServersAddresses()
}
internal System.Net.NetworkInformation.Win32IPv4InterfaceProperties : IPv4InterfaceProperties {
private Win32_IP_ADAPTER_INFO ainfo
private Win32_IP_PER_ADAPTER_INFO painfo
private Win32_MIB_IFROW mib
public int Index
public bool IsAutomaticPrivateAddressingActive
public bool IsAutomaticPrivateAddressingEnabled
public bool IsDhcpEnabled
public bool IsForwardingEnabled
public int Mtu
public bool UsesWins
public void .ctor(Win32_IP_ADAPTER_INFO ainfo, Win32_MIB_IFROW mib)
private int GetPerAdapterInfo(int IfIndex, Win32_IP_PER_ADAPTER_INFO pPerAdapterInfo, Int32& pOutBufLen)
public int get_Index()
public bool get_IsAutomaticPrivateAddressingActive()
public bool get_IsAutomaticPrivateAddressingEnabled()
public bool get_IsDhcpEnabled()
public bool get_IsForwardingEnabled()
public int get_Mtu()
public bool get_UsesWins()
}
internal System.Net.NetworkInformation.Win32IPv4InterfaceStatistics : IPv4InterfaceStatistics {
private Win32_MIB_IFROW info
public long BytesReceived
public long BytesSent
public long IncomingPacketsDiscarded
public long IncomingPacketsWithErrors
public long IncomingUnknownProtocolPackets
public long NonUnicastPacketsReceived
public long NonUnicastPacketsSent
public long OutgoingPacketsDiscarded
public long OutgoingPacketsWithErrors
public long OutputQueueLength
public long UnicastPacketsReceived
public long UnicastPacketsSent
public void .ctor(Win32_MIB_IFROW info)
public long get_BytesReceived()
public long get_BytesSent()
public long get_IncomingPacketsDiscarded()
public long get_IncomingPacketsWithErrors()
public long get_IncomingUnknownProtocolPackets()
public long get_NonUnicastPacketsReceived()
public long get_NonUnicastPacketsSent()
public long get_OutgoingPacketsDiscarded()
public long get_OutgoingPacketsWithErrors()
public long get_OutputQueueLength()
public long get_UnicastPacketsReceived()
public long get_UnicastPacketsSent()
}
internal System.Net.NetworkInformation.Win32IPv6InterfaceProperties : IPv6InterfaceProperties {
private Win32_MIB_IFROW mib
public int Index
public int Mtu
public void .ctor(Win32_MIB_IFROW mib)
public int get_Index()
public int get_Mtu()
}
internal System.Net.NetworkInformation.Win32LengthFlagsUnion : ValueType {
private int IP_ADAPTER_ADDRESS_DNS_ELIGIBLE
private int IP_ADAPTER_ADDRESS_TRANSIENT
public UInt32 Length
public UInt32 Flags
public bool IsDnsEligible
public bool IsTransient
public bool get_IsDnsEligible()
public bool get_IsTransient()
}
internal System.Net.NetworkInformation.Win32NetworkInterface2 : NetworkInterface {
private Win32_IP_ADAPTER_ADDRESSES addr
private Win32_MIB_IFROW mib4
private Win32_MIB_IFROW mib6
private Win32IPv4InterfaceStatistics ip4stats
private IPInterfaceProperties ip_if_props
public string Description
public string Id
public bool IsReceiveOnly
public string Name
public NetworkInterfaceType NetworkInterfaceType
public OperationalStatus OperationalStatus
public long Speed
public bool SupportsMulticast
private void .ctor(Win32_IP_ADAPTER_ADDRESSES addr)
private int GetAdaptersInfo(Byte[] info, Int32& size)
private int GetAdaptersAddresses(UInt32 family, UInt32 flags, IntPtr reserved, Byte[] info, Int32& size)
private int GetIfEntry(Win32_MIB_IFROW& row)
public NetworkInterface[] ImplGetAllNetworkInterfaces()
public Win32_IP_ADAPTER_INFO GetAdapterInfoByIndex(int index)
private Win32_IP_ADAPTER_INFO[] GetAdaptersInfo()
private Win32_IP_ADAPTER_ADDRESSES[] GetAdaptersAddresses()
public IPInterfaceProperties GetIPProperties()
public IPv4InterfaceStatistics GetIPv4Statistics()
public PhysicalAddress GetPhysicalAddress()
public bool Supports(NetworkInterfaceComponent networkInterfaceComponent)
public string get_Description()
public string get_Id()
public bool get_IsReceiveOnly()
public string get_Name()
public NetworkInterfaceType get_NetworkInterfaceType()
public OperationalStatus get_OperationalStatus()
public long get_Speed()
public bool get_SupportsMulticast()
}
internal System.Net.NetworkInformation.Win32TcpStatistics : TcpStatistics {
private Win32_MIB_TCPSTATS info
public long ConnectionsAccepted
public long ConnectionsInitiated
public long CumulativeConnections
public long CurrentConnections
public long ErrorsReceived
public long FailedConnectionAttempts
public long MaximumConnections
public long MaximumTransmissionTimeout
public long MinimumTransmissionTimeout
public long ResetConnections
public long ResetsSent
public long SegmentsReceived
public long SegmentsResent
public long SegmentsSent
public void .ctor(Win32_MIB_TCPSTATS info)
public long get_ConnectionsAccepted()
public long get_ConnectionsInitiated()
public long get_CumulativeConnections()
public long get_CurrentConnections()
public long get_ErrorsReceived()
public long get_FailedConnectionAttempts()
public long get_MaximumConnections()
public long get_MaximumTransmissionTimeout()
public long get_MinimumTransmissionTimeout()
public long get_ResetConnections()
public long get_ResetsSent()
public long get_SegmentsReceived()
public long get_SegmentsResent()
public long get_SegmentsSent()
}
internal System.Net.NetworkInformation.Win32UdpStatistics : UdpStatistics {
private Win32_MIB_UDPSTATS info
public long DatagramsReceived
public long DatagramsSent
public long IncomingDatagramsDiscarded
public long IncomingDatagramsWithErrors
public int UdpListeners
public void .ctor(Win32_MIB_UDPSTATS info)
public long get_DatagramsReceived()
public long get_DatagramsSent()
public long get_IncomingDatagramsDiscarded()
public long get_IncomingDatagramsWithErrors()
public int get_UdpListeners()
}
internal System.Net.NetworkInformation.Win32UnicastIPAddressInformation : UnicastIPAddressInformation {
private int if_index
private Win32_IP_ADAPTER_UNICAST_ADDRESS info
public IPAddress Address
public bool IsDnsEligible
public bool IsTransient
public long AddressPreferredLifetime
public long AddressValidLifetime
public long DhcpLeaseLifetime
public DuplicateAddressDetectionState DuplicateAddressDetectionState
public IPAddress IPv4Mask
public PrefixOrigin PrefixOrigin
public SuffixOrigin SuffixOrigin
public void .ctor(int ifIndex, Win32_IP_ADAPTER_UNICAST_ADDRESS info)
public IPAddress get_Address()
public bool get_IsDnsEligible()
public bool get_IsTransient()
public long get_AddressPreferredLifetime()
public long get_AddressValidLifetime()
public long get_DhcpLeaseLifetime()
public DuplicateAddressDetectionState get_DuplicateAddressDetectionState()
public IPAddress get_IPv4Mask()
public PrefixOrigin get_PrefixOrigin()
public SuffixOrigin get_SuffixOrigin()
}
internal System.Net.NtlmClient : object {
private IAuthenticationModule authObject
public string AuthenticationType
public bool CanPreAuthenticate
public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials)
public Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials)
public string get_AuthenticationType()
public bool get_CanPreAuthenticate()
}
public System.Net.OpenReadCompletedEventArgs : AsyncCompletedEventArgs {
private Stream result
public Stream Result
internal void .ctor(Stream result, Exception error, bool cancelled, object userState)
public Stream get_Result()
}
public System.Net.OpenReadCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, OpenReadCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, OpenReadCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.OpenWriteCompletedEventArgs : AsyncCompletedEventArgs {
private Stream result
public Stream Result
internal void .ctor(Stream result, Exception error, bool cancelled, object userState)
public Stream get_Result()
}
public System.Net.OpenWriteCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, OpenWriteCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, OpenWriteCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.ProtocolViolationException : InvalidOperationException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
internal System.Net.ReadState : Enum {
public int value__
public ReadState None
public ReadState Status
public ReadState Headers
public ReadState Content
}
internal System.Net.RequestStream : Stream {
private Byte[] buffer
private int offset
private int length
private long remaining_body
private bool disposed
private Stream stream
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
internal void .ctor(Stream stream, Byte[] buffer, int offset, int length)
internal void .ctor(Stream stream, Byte[] buffer, int offset, int length, long contentlength)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Close()
public void Flush()
private int FillFromBuffer(Byte[] buffer, int off, int count)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public int EndRead(IAsyncResult ares)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public void EndWrite(IAsyncResult async_result)
}
internal System.Net.ResponseStream : Stream {
private HttpListenerResponse response
private bool ignore_errors
private bool disposed
private bool trailer_sent
private Stream stream
private Byte[] crlf
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
internal void .ctor(Stream stream, HttpListenerResponse response, bool ignore_errors)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Close()
private MemoryStream GetHeaders(bool closing)
public void Flush()
private Byte[] GetChunkSizeBytes(int size, bool final)
internal void InternalWrite(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public void EndWrite(IAsyncResult ares)
public int Read(Byte[] buffer, int offset, int count)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state)
public int EndRead(IAsyncResult ares)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
}
public System.Net.Security.AuthenticatedStream : Stream {
private Stream innerStream
private bool leaveStreamOpen
protected Stream InnerStream
public bool IsAuthenticated
public bool IsEncrypted
public bool IsMutuallyAuthenticated
public bool IsServer
public bool IsSigned
public bool LeaveInnerStreamOpen
protected void .ctor(Stream innerStream, bool leaveInnerStreamOpen)
protected Stream get_InnerStream()
public bool get_IsAuthenticated()
public bool get_IsEncrypted()
public bool get_IsMutuallyAuthenticated()
public bool get_IsServer()
public bool get_IsSigned()
public bool get_LeaveInnerStreamOpen()
protected void Dispose(bool disposing)
}
public System.Net.Security.AuthenticationLevel : Enum {
public int value__
public AuthenticationLevel None
public AuthenticationLevel MutualAuthRequested
public AuthenticationLevel MutualAuthRequired
}
public System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers)
public IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object)
public X509Certificate EndInvoke(IAsyncResult result)
}
public System.Net.Security.NegotiateStream : AuthenticatedStream {
private int readTimeout
private int writeTimeout
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public TokenImpersonationLevel ImpersonationLevel
public bool IsAuthenticated
public bool IsEncrypted
public bool IsMutuallyAuthenticated
public bool IsServer
public bool IsSigned
public long Length
public long Position
public int ReadTimeout
public IIdentity RemoteIdentity
public int WriteTimeout
public void .ctor(Stream innerStream)
public void .ctor(Stream innerStream, bool leaveStreamOpen)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public TokenImpersonationLevel get_ImpersonationLevel()
public bool get_IsAuthenticated()
public bool get_IsEncrypted()
public bool get_IsMutuallyAuthenticated()
public bool get_IsServer()
public bool get_IsSigned()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public IIdentity get_RemoteIdentity()
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public IAsyncResult BeginAuthenticateAsClient(AsyncCallback callback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(AsyncCallback callback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void AuthenticateAsClient()
public void AuthenticateAsClient(NetworkCredential credential, string targetName)
public void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
public void AuthenticateAsServer()
public void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel)
protected void Dispose(bool disposing)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public int EndRead(IAsyncResult asyncResult)
public void EndAuthenticateAsServer(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
}
public System.Net.Security.ProtectionLevel : Enum {
public int value__
public ProtectionLevel None
public ProtectionLevel Sign
public ProtectionLevel EncryptAndSign
}
public System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
public IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Net.Security.SslPolicyErrors : Enum {
public int value__
public SslPolicyErrors None
public SslPolicyErrors RemoteCertificateNotAvailable
public SslPolicyErrors RemoteCertificateNameMismatch
public SslPolicyErrors RemoteCertificateChainErrors
}
public System.Net.Security.SslStream : AuthenticatedStream {
private SslStreamBase ssl_stream
private RemoteCertificateValidationCallback validation_callback
private LocalCertificateSelectionCallback selection_callback
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public long Length
public long Position
public bool IsAuthenticated
public bool IsEncrypted
public bool IsMutuallyAuthenticated
public bool IsServer
public bool IsSigned
public int ReadTimeout
public int WriteTimeout
public bool CheckCertRevocationStatus
public CipherAlgorithmType CipherAlgorithm
public int CipherStrength
public HashAlgorithmType HashAlgorithm
public int HashStrength
public ExchangeAlgorithmType KeyExchangeAlgorithm
public int KeyExchangeStrength
public X509Certificate LocalCertificate
public X509Certificate RemoteCertificate
public SslProtocols SslProtocol
public void .ctor(Stream innerStream)
public void .ctor(Stream innerStream, bool leaveStreamOpen)
public void .ctor(Stream innerStream, bool leaveStreamOpen, RemoteCertificateValidationCallback certValidationCallback)
public void .ctor(Stream innerStream, bool leaveStreamOpen, RemoteCertificateValidationCallback certValidationCallback, LocalCertificateSelectionCallback certSelectionCallback)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_IsAuthenticated()
public bool get_IsEncrypted()
public bool get_IsMutuallyAuthenticated()
public bool get_IsServer()
public bool get_IsSigned()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public bool get_CheckCertRevocationStatus()
public CipherAlgorithmType get_CipherAlgorithm()
public int get_CipherStrength()
public HashAlgorithmType get_HashAlgorithm()
public int get_HashStrength()
public ExchangeAlgorithmType get_KeyExchangeAlgorithm()
public int get_KeyExchangeStrength()
public X509Certificate get_LocalCertificate()
public X509Certificate get_RemoteCertificate()
public SslProtocols get_SslProtocol()
private X509Certificate OnCertificateSelection(X509CertificateCollection clientCerts, X509Certificate serverCert, string targetHost, X509CertificateCollection serverRequestedCerts)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols sslProtocolType, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback callback, object asyncState)
public IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols sslProtocolType, bool checkCertificateRevocation, AsyncCallback callback, object asyncState)
private SecurityProtocolType GetMonoSslProtocol(SslProtocols ms)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
public void AuthenticateAsClient(string targetHost)
public void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols sslProtocolType, bool checkCertificateRevocation)
public void AuthenticateAsServer(X509Certificate serverCertificate)
public void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols sslProtocolType, bool checkCertificateRevocation)
protected void Dispose(bool disposing)
public void EndAuthenticateAsClient(IAsyncResult asyncResult)
public void EndAuthenticateAsServer(IAsyncResult asyncResult)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer)
private void CheckConnectionAuthenticated()
}
public System.Net.SecurityProtocolType : Enum {
public int value__
public SecurityProtocolType Ssl3
public SecurityProtocolType Tls
}
public System.Net.ServicePoint : object {
private Uri uri
private int connectionLimit
private int maxIdleTime
private int currentConnections
private DateTime idleSince
private Version protocolVersion
private X509Certificate certificate
private X509Certificate clientCertificate
private IPHostEntry host
private bool usesProxy
private Hashtable groups
private bool sendContinue
private bool useConnect
private object locker
private object hostE
private bool useNagle
private BindIPEndPoint endPointCallback
public Uri Address
public BindIPEndPoint BindIPEndPointDelegate
public X509Certificate Certificate
public X509Certificate ClientCertificate
public int ConnectionLeaseTimeout
public int ConnectionLimit
public string ConnectionName
public int CurrentConnections
public DateTime IdleSince
public int MaxIdleTime
public Version ProtocolVersion
public int ReceiveBufferSize
public bool SupportsPipelining
public bool Expect100Continue
public bool UseNagleAlgorithm
internal bool SendContinue
internal bool UsesProxy
internal bool UseConnect
internal bool AvailableForRecycling
internal Hashtable Groups
internal IPHostEntry HostEntry
internal void .ctor(Uri uri, int connectionLimit, int maxIdleTime)
public Uri get_Address()
private Exception GetMustImplement()
public BindIPEndPoint get_BindIPEndPointDelegate()
public void set_BindIPEndPointDelegate(BindIPEndPoint value)
public X509Certificate get_Certificate()
public X509Certificate get_ClientCertificate()
public int get_ConnectionLeaseTimeout()
public void set_ConnectionLeaseTimeout(int value)
public int get_ConnectionLimit()
public void set_ConnectionLimit(int value)
public string get_ConnectionName()
public int get_CurrentConnections()
public DateTime get_IdleSince()
internal void set_IdleSince(DateTime value)
public int get_MaxIdleTime()
public void set_MaxIdleTime(int value)
public Version get_ProtocolVersion()
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public bool get_SupportsPipelining()
public bool get_Expect100Continue()
public void set_Expect100Continue(bool value)
public bool get_UseNagleAlgorithm()
public void set_UseNagleAlgorithm(bool value)
internal bool get_SendContinue()
internal void set_SendContinue(bool value)
internal bool get_UsesProxy()
internal void set_UsesProxy(bool value)
internal bool get_UseConnect()
internal void set_UseConnect(bool value)
internal bool get_AvailableForRecycling()
internal Hashtable get_Groups()
internal IPHostEntry get_HostEntry()
internal void SetVersion(Version version)
private WebConnectionGroup GetConnectionGroup(string name)
internal EventHandler SendRequest(HttpWebRequest request, string groupName)
public bool CloseConnectionGroup(string connectionGroupName)
internal void IncrementConnection()
internal void DecrementConnection()
internal void SetCertificates(X509Certificate client, X509Certificate server)
internal bool CallEndPointDelegate(Socket sock, IPEndPoint remote)
}
public System.Net.ServicePointManager : object {
public int DefaultNonPersistentConnectionLimit
public int DefaultPersistentConnectionLimit
private string configKey
private HybridDictionary servicePoints
private ICertificatePolicy policy
private int defaultConnectionLimit
private int maxServicePointIdleTime
private int maxServicePoints
private bool _checkCRL
private SecurityProtocolType _securityProtocol
private bool expectContinue
private bool useNagle
private RemoteCertificateValidationCallback server_cert_cb
private ConnectionManagementData manager
public ICertificatePolicy CertificatePolicy
public bool CheckCertificateRevocationList
public int DefaultConnectionLimit
public int DnsRefreshTimeout
public bool EnableDnsRoundRobin
public int MaxServicePointIdleTime
public int MaxServicePoints
public SecurityProtocolType SecurityProtocol
public RemoteCertificateValidationCallback ServerCertificateValidationCallback
public bool Expect100Continue
public bool UseNagleAlgorithm
public ICertificatePolicy get_CertificatePolicy()
public void set_CertificatePolicy(ICertificatePolicy value)
public bool get_CheckCertificateRevocationList()
public void set_CheckCertificateRevocationList(bool value)
public int get_DefaultConnectionLimit()
public void set_DefaultConnectionLimit(int value)
private Exception GetMustImplement()
public int get_DnsRefreshTimeout()
public void set_DnsRefreshTimeout(int value)
public bool get_EnableDnsRoundRobin()
public void set_EnableDnsRoundRobin(bool value)
public int get_MaxServicePointIdleTime()
public void set_MaxServicePointIdleTime(int value)
public int get_MaxServicePoints()
public void set_MaxServicePoints(int value)
public SecurityProtocolType get_SecurityProtocol()
public void set_SecurityProtocol(SecurityProtocolType value)
public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback()
public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value)
public bool get_Expect100Continue()
public void set_Expect100Continue(bool value)
public bool get_UseNagleAlgorithm()
public void set_UseNagleAlgorithm(bool value)
public ServicePoint FindServicePoint(Uri address)
public ServicePoint FindServicePoint(string uriString, IWebProxy proxy)
public ServicePoint FindServicePoint(Uri address, IWebProxy proxy)
internal void RecycleServicePoints()
}
public System.Net.SocketAddress : object {
private Byte[] data
public AddressFamily Family
public int Size
public byte Item
public void .ctor(AddressFamily family, int size)
public void .ctor(AddressFamily family)
public AddressFamily get_Family()
public int get_Size()
public byte get_Item(int offset)
public void set_Item(int offset, byte value)
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
public System.Net.SocketPermission : CodeAccessPermission {
public int AllPorts
private ArrayList m_acceptList
private ArrayList m_connectList
private bool m_noRestriction
public IEnumerator AcceptList
public IEnumerator ConnectList
public void .ctor(PermissionState state)
public void .ctor(NetworkAccess access, TransportType transport, string hostName, int portNumber)
public IEnumerator get_AcceptList()
public IEnumerator get_ConnectList()
public void AddPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber)
public IPermission Copy()
public IPermission Intersect(IPermission target)
private bool IntersectEmpty(SocketPermission permission)
private void Intersect(ArrayList list1, ArrayList list2, ArrayList result)
public bool IsSubsetOf(IPermission target)
private bool IsSubsetOf(ArrayList list1, ArrayList list2)
public bool IsUnrestricted()
public SecurityElement ToXml()
private void ToXml(SecurityElement root, string childName, IEnumerator enumerator)
public void FromXml(SecurityElement securityElement)
private void FromXml(ArrayList endpoints, NetworkAccess access)
public IPermission Union(IPermission target)
}
public System.Net.SocketPermissionAttribute : CodeAccessSecurityAttribute {
private string m_access
private string m_host
private string m_port
private string m_transport
public string Access
public string Host
public string Port
public string Transport
public void .ctor(SecurityAction action)
public string get_Access()
public void set_Access(string value)
public string get_Host()
public void set_Host(string value)
public string get_Port()
public void set_Port(string value)
public string get_Transport()
public void set_Transport(string value)
public IPermission CreatePermission()
internal void AlreadySet(string property)
}
public System.Net.Sockets.AddressFamily : Enum {
public int value__
public AddressFamily Unknown
public AddressFamily Unspecified
public AddressFamily Unix
public AddressFamily InterNetwork
public AddressFamily ImpLink
public AddressFamily Pup
public AddressFamily Chaos
public AddressFamily NS
public AddressFamily Ipx
public AddressFamily Iso
public AddressFamily Osi
public AddressFamily Ecma
public AddressFamily DataKit
public AddressFamily Ccitt
public AddressFamily Sna
public AddressFamily DecNet
public AddressFamily DataLink
public AddressFamily Lat
public AddressFamily HyperChannel
public AddressFamily AppleTalk
public AddressFamily NetBios
public AddressFamily VoiceView
public AddressFamily FireFox
public AddressFamily Banyan
public AddressFamily Atm
public AddressFamily InterNetworkV6
public AddressFamily Cluster
public AddressFamily Ieee12844
public AddressFamily Irda
public AddressFamily NetworkDesigners
public AddressFamily Max
}
public System.Net.Sockets.IOControlCode : Enum {
public long value__
public IOControlCode AbsorbRouterAlert
public IOControlCode AddMulticastGroupOnInterface
public IOControlCode AddressListChange
public IOControlCode AddressListQuery
public IOControlCode AddressListSort
public IOControlCode AssociateHandle
public IOControlCode AsyncIO
public IOControlCode BindToInterface
public IOControlCode DataToRead
public IOControlCode DeleteMulticastGroupFromInterface
public IOControlCode EnableCircularQueuing
public IOControlCode Flush
public IOControlCode GetBroadcastAddress
public IOControlCode GetExtensionFunctionPointer
public IOControlCode GetGroupQos
public IOControlCode GetQos
public IOControlCode KeepAliveValues
public IOControlCode LimitBroadcasts
public IOControlCode MulticastInterface
public IOControlCode MulticastScope
public IOControlCode MultipointLoopback
public IOControlCode NamespaceChange
public IOControlCode NonBlockingIO
public IOControlCode OobDataRead
public IOControlCode QueryTargetPnpHandle
public IOControlCode ReceiveAll
public IOControlCode ReceiveAllIgmpMulticast
public IOControlCode ReceiveAllMulticast
public IOControlCode RoutingInterfaceChange
public IOControlCode RoutingInterfaceQuery
public IOControlCode SetGroupQos
public IOControlCode SetQos
public IOControlCode TranslateHandle
public IOControlCode UnicastInterface
}
public System.Net.Sockets.IPPacketInformation : ValueType {
private IPAddress address
private int iface
public IPAddress Address
public int Interface
internal void .ctor(IPAddress address, int iface)
public IPAddress get_Address()
public int get_Interface()
public bool Equals(object comparand)
public int GetHashCode()
public bool op_Equality(IPPacketInformation p1, IPPacketInformation p2)
public bool op_Inequality(IPPacketInformation p1, IPPacketInformation p2)
}
public System.Net.Sockets.IPv6MulticastOption : object {
private IPAddress group
private long ifIndex
public IPAddress Group
public long InterfaceIndex
public void .ctor(IPAddress group)
public void .ctor(IPAddress group, long ifindex)
public IPAddress get_Group()
public void set_Group(IPAddress value)
public long get_InterfaceIndex()
public void set_InterfaceIndex(long value)
}
public System.Net.Sockets.LingerOption : object {
private bool enabled
private int seconds
public bool Enabled
public int LingerTime
public void .ctor(bool enable, int secs)
public bool get_Enabled()
public void set_Enabled(bool value)
public int get_LingerTime()
public void set_LingerTime(int value)
}
public System.Net.Sockets.MulticastOption : object {
private IPAddress group
private IPAddress local
private int iface_index
public IPAddress Group
public IPAddress LocalAddress
public int InterfaceIndex
public void .ctor(IPAddress group)
public void .ctor(IPAddress group, int interfaceIndex)
public void .ctor(IPAddress group, IPAddress mcint)
public IPAddress get_Group()
public void set_Group(IPAddress value)
public IPAddress get_LocalAddress()
public void set_LocalAddress(IPAddress value)
public int get_InterfaceIndex()
public void set_InterfaceIndex(int value)
}
public System.Net.Sockets.NetworkStream : Stream {
private FileAccess access
private Socket socket
private bool owns_socket
private bool readable
private bool writeable
private bool disposed
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public bool DataAvailable
public long Length
public long Position
protected bool Readable
public int ReadTimeout
protected Socket Socket
protected bool Writeable
public int WriteTimeout
public void .ctor(Socket socket)
public void .ctor(Socket socket, bool owns_socket)
public void .ctor(Socket socket, FileAccess access)
public void .ctor(Socket socket, FileAccess access, bool owns_socket)
private void System.IDisposable.Dispose()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
public bool get_DataAvailable()
public long get_Length()
public long get_Position()
public void set_Position(long value)
protected bool get_Readable()
protected void set_Readable(bool value)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
protected Socket get_Socket()
protected bool get_Writeable()
protected void set_Writeable(bool value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state)
protected void Finalize()
public void Close(int timeout)
private void OnTimeoutClose(object source, ElapsedEventArgs e)
protected void Dispose(bool disposing)
public int EndRead(IAsyncResult ar)
public void EndWrite(IAsyncResult ar)
public void Flush()
public int Read(Byte[] buffer, int offset, int size)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int size)
private void CheckDisposed()
}
public System.Net.Sockets.ProtocolFamily : Enum {
public int value__
public ProtocolFamily Unknown
public ProtocolFamily Unspecified
public ProtocolFamily Unix
public ProtocolFamily InterNetwork
public ProtocolFamily ImpLink
public ProtocolFamily Pup
public ProtocolFamily Chaos
public ProtocolFamily Ipx
public ProtocolFamily Iso
public ProtocolFamily Ecma
public ProtocolFamily DataKit
public ProtocolFamily Ccitt
public ProtocolFamily Sna
public ProtocolFamily DecNet
public ProtocolFamily DataLink
public ProtocolFamily Lat
public ProtocolFamily HyperChannel
public ProtocolFamily AppleTalk
public ProtocolFamily NetBios
public ProtocolFamily VoiceView
public ProtocolFamily FireFox
public ProtocolFamily Banyan
public ProtocolFamily Atm
public ProtocolFamily InterNetworkV6
public ProtocolFamily Cluster
public ProtocolFamily Ieee12844
public ProtocolFamily Irda
public ProtocolFamily NetworkDesigners
public ProtocolFamily Max
public ProtocolFamily NS
public ProtocolFamily Osi
}
public System.Net.Sockets.ProtocolType : Enum {
public int value__
public ProtocolType IP
public ProtocolType Icmp
public ProtocolType Igmp
public ProtocolType Ggp
public ProtocolType Tcp
public ProtocolType Pup
public ProtocolType Udp
public ProtocolType Idp
public ProtocolType IPv6
public ProtocolType ND
public ProtocolType Raw
public ProtocolType Unspecified
public ProtocolType Ipx
public ProtocolType Spx
public ProtocolType SpxII
public ProtocolType Unknown
public ProtocolType IPv4
public ProtocolType IPv6RoutingHeader
public ProtocolType IPv6FragmentHeader
public ProtocolType IPSecEncapsulatingSecurityPayload
public ProtocolType IPSecAuthenticationHeader
public ProtocolType IcmpV6
public ProtocolType IPv6NoNextHeader
public ProtocolType IPv6DestinationOptions
public ProtocolType IPv6HopByHopOptions
}
public System.Net.Sockets.SelectMode : Enum {
public int value__
public SelectMode SelectRead
public SelectMode SelectWrite
public SelectMode SelectError
}
public System.Net.Sockets.SendPacketsElement : object {
private Byte[] <Buffer>k__BackingField
private int <Count>k__BackingField
private bool <EndOfPacket>k__BackingField
private string <FilePath>k__BackingField
private int <Offset>k__BackingField
public Byte[] Buffer
public int Count
public bool EndOfPacket
public string FilePath
public int Offset
public void .ctor(Byte[] buffer)
public void .ctor(Byte[] buffer, int offset, int count)
public void .ctor(Byte[] buffer, int offset, int count, bool endOfPacket)
public void .ctor(string filepath)
public void .ctor(string filepath, int offset, int count)
public void .ctor(string filepath, int offset, int count, bool endOfPacket)
public Byte[] get_Buffer()
private void set_Buffer(Byte[] value)
public int get_Count()
private void set_Count(int value)
public bool get_EndOfPacket()
private void set_EndOfPacket(bool value)
public string get_FilePath()
private void set_FilePath(string value)
public int get_Offset()
private void set_Offset(int value)
}
public System.Net.Sockets.Socket : object {
private Queue readQ
private Queue writeQ
private bool islistening
private bool useoverlappedIO
private int MinListenPort
private int MaxListenPort
private int ipv4Supported
private int ipv6Supported
private int linger_timeout
private IntPtr socket
private AddressFamily address_family
private SocketType socket_type
private ProtocolType protocol_type
internal bool blocking
private Thread blocking_thread
private bool isbound
private int current_bind_count
private int max_bind_count
private bool connected
private bool closed
internal bool disposed
internal EndPoint seed_endpoint
private MethodInfo check_socket_policy
public int Available
public bool DontFragment
public bool EnableBroadcast
public bool ExclusiveAddressUse
public bool IsBound
public LingerOption LingerState
public bool MulticastLoopback
public bool UseOnlyOverlappedIO
public IntPtr Handle
public EndPoint LocalEndPoint
public SocketType SocketType
public int SendTimeout
public int ReceiveTimeout
public bool SupportsIPv4
public bool SupportsIPv6
public bool OSSupportsIPv6
public AddressFamily AddressFamily
public bool Blocking
public bool Connected
public ProtocolType ProtocolType
public bool NoDelay
public int ReceiveBufferSize
public int SendBufferSize
public short Ttl
public EndPoint RemoteEndPoint
private void .ctor(AddressFamily family, SocketType type, ProtocolType proto, IntPtr sock)
public void .ctor(SocketInformation socketInformation)
public void .ctor(AddressFamily family, SocketType type, ProtocolType proto)
private void System.IDisposable.Dispose()
private void AddSockets(ArrayList sockets, IList list, string name)
private void Select_internal(Socket[]& sockets, int microSeconds, Int32& error)
public void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds)
private void SocketDefaults()
private int Available_internal(IntPtr socket, Int32& error)
public int get_Available()
public bool get_DontFragment()
public void set_DontFragment(bool value)
public bool get_EnableBroadcast()
public void set_EnableBroadcast(bool value)
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public bool get_IsBound()
public LingerOption get_LingerState()
public void set_LingerState(LingerOption value)
public bool get_MulticastLoopback()
public void set_MulticastLoopback(bool value)
public bool get_UseOnlyOverlappedIO()
public void set_UseOnlyOverlappedIO(bool value)
public IntPtr get_Handle()
private SocketAddress LocalEndPoint_internal(IntPtr socket, Int32& error)
public EndPoint get_LocalEndPoint()
public SocketType get_SocketType()
public int get_SendTimeout()
public void set_SendTimeout(int value)
public int get_ReceiveTimeout()
public void set_ReceiveTimeout(int value)
public bool AcceptAsync(SocketAsyncEventArgs e)
private IntPtr Accept_internal(IntPtr sock, Int32& error, bool blocking)
public Socket Accept()
internal void Accept(Socket acceptSocket)
public IAsyncResult BeginAccept(AsyncCallback callback, object state)
public IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, object state)
public IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(EndPoint end_point, AsyncCallback callback, object state)
internal IAsyncResult BeginConnect(EndPoint end_point, AsyncCallback callback, object state, bool bypassSocketSecurity)
public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(string host, int port, AsyncCallback callback, object state)
public IAsyncResult BeginDisconnect(bool reuseSocket, AsyncCallback callback, object state)
public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socket_flags, AsyncCallback callback, object state)
public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags flags, SocketError& error, AsyncCallback callback, object state)
public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
public IAsyncResult BeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socket_flags, EndPoint& remote_end, AsyncCallback callback, object state)
public IAsyncResult BeginReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state)
public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socket_flags, AsyncCallback callback, object state)
public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state)
public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state)
public IAsyncResult BeginSendFile(string fileName, AsyncCallback callback, object state)
public IAsyncResult BeginSendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags, AsyncCallback callback, object state)
public IAsyncResult BeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socket_flags, EndPoint remote_end, AsyncCallback callback, object state)
private void Bind_internal(IntPtr sock, SocketAddress sa, Int32& error)
public void Bind(EndPoint local_end)
public bool ConnectAsync(SocketAsyncEventArgs e)
public void Connect(IPAddress address, int port)
public void Connect(IPAddress[] addresses, int port)
public void Connect(string host, int port)
public bool DisconnectAsync(SocketAsyncEventArgs e)
private void Disconnect_internal(IntPtr sock, bool reuse, Int32& error)
public void Disconnect(bool reuseSocket)
public SocketInformation DuplicateAndClose(int targetProcessId)
public Socket EndAccept(IAsyncResult result)
public Socket EndAccept(Byte[]& buffer, IAsyncResult asyncResult)
public Socket EndAccept(Byte[]& buffer, Int32& bytesTransferred, IAsyncResult asyncResult)
public void EndConnect(IAsyncResult result)
public void EndDisconnect(IAsyncResult asyncResult)
public int EndReceive(IAsyncResult result)
public int EndReceive(IAsyncResult asyncResult, SocketError& errorCode)
public int EndReceiveFrom(IAsyncResult result, EndPoint& end_point)
public int EndReceiveMessageFrom(IAsyncResult asyncResult, SocketFlags& socketFlags, EndPoint& endPoint, IPPacketInformation& ipPacketInformation)
public int EndSend(IAsyncResult result)
public int EndSend(IAsyncResult asyncResult, SocketError& errorCode)
public void EndSendFile(IAsyncResult asyncResult)
private Exception InvalidAsyncOp(string method)
public int EndSendTo(IAsyncResult result)
private void GetSocketOption_arr_internal(IntPtr socket, SocketOptionLevel level, SocketOptionName name, Byte[]& byte_val, Int32& error)
public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue)
public Byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int length)
private int WSAIoctl(IntPtr sock, int ioctl_code, Byte[] input, Byte[] output, Int32& error)
public int IOControl(int ioctl_code, Byte[] in_value, Byte[] out_value)
public int IOControl(IOControlCode ioControlCode, Byte[] optionInValue, Byte[] optionOutValue)
private void Listen_internal(IntPtr sock, int backlog, Int32& error)
public void Listen(int backlog)
public bool Poll(int time_us, SelectMode mode)
public int Receive(Byte[] buffer)
public int Receive(Byte[] buffer, SocketFlags flags)
public int Receive(Byte[] buffer, int size, SocketFlags flags)
public int Receive(Byte[] buffer, int offset, int size, SocketFlags flags)
public int Receive(Byte[] buffer, int offset, int size, SocketFlags flags, SocketError& error)
private int Receive_internal(IntPtr sock, WSABUF[] bufarray, SocketFlags flags, Int32& error)
public int Receive(IList`1<ArraySegment`1<byte>> buffers)
public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode)
public bool ReceiveFromAsync(SocketAsyncEventArgs e)
public int ReceiveFrom(Byte[] buffer, EndPoint& remoteEP)
public int ReceiveFrom(Byte[] buffer, SocketFlags flags, EndPoint& remoteEP)
public int ReceiveFrom(Byte[] buffer, int size, SocketFlags flags, EndPoint& remoteEP)
private int RecvFrom_internal(IntPtr sock, Byte[] buffer, int offset, int count, SocketFlags flags, SocketAddress& sockaddr, Int32& error)
public int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags flags, EndPoint& remoteEP)
internal int ReceiveFrom_nochecks(Byte[] buf, int offset, int size, SocketFlags flags, EndPoint& remote_end)
internal int ReceiveFrom_nochecks_exc(Byte[] buf, int offset, int size, SocketFlags flags, EndPoint& remote_end, bool throwOnError, Int32& error)
public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e)
public int ReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags& socketFlags, EndPoint& remoteEP, IPPacketInformation& ipPacketInformation)
public bool SendPacketsAsync(SocketAsyncEventArgs e)
public int Send(Byte[] buf)
public int Send(Byte[] buf, SocketFlags flags)
public int Send(Byte[] buf, int size, SocketFlags flags)
public int Send(Byte[] buf, int offset, int size, SocketFlags flags)
public int Send(Byte[] buf, int offset, int size, SocketFlags flags, SocketError& error)
private int Send_internal(IntPtr sock, WSABUF[] bufarray, SocketFlags flags, Int32& error)
public int Send(IList`1<ArraySegment`1<byte>> buffers)
public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags)
public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode)
private bool SendFile(IntPtr sock, string filename, Byte[] pre_buffer, Byte[] post_buffer, TransmitFileOptions flags)
public void SendFile(string fileName)
public void SendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags)
public bool SendToAsync(SocketAsyncEventArgs e)
public int SendTo(Byte[] buffer, EndPoint remote_end)
public int SendTo(Byte[] buffer, SocketFlags flags, EndPoint remote_end)
public int SendTo(Byte[] buffer, int size, SocketFlags flags, EndPoint remote_end)
private int SendTo_internal_real(IntPtr sock, Byte[] buffer, int offset, int count, SocketFlags flags, SocketAddress sa, Int32& error)
private int SendTo_internal(IntPtr sock, Byte[] buffer, int offset, int count, SocketFlags flags, SocketAddress sa, Int32& error)
public int SendTo(Byte[] buffer, int offset, int size, SocketFlags flags, EndPoint remote_end)
internal int SendTo_nochecks(Byte[] buffer, int offset, int size, SocketFlags flags, EndPoint remote_end)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue)
internal void CheckProtocolSupport()
public bool get_SupportsIPv4()
public bool get_SupportsIPv6()
public bool get_OSSupportsIPv6()
private IntPtr Socket_internal(AddressFamily family, SocketType type, ProtocolType proto, Int32& error)
protected void Finalize()
public AddressFamily get_AddressFamily()
private void Blocking_internal(IntPtr socket, bool block, Int32& error)
public bool get_Blocking()
public void set_Blocking(bool value)
public bool get_Connected()
internal void set_Connected(bool value)
public ProtocolType get_ProtocolType()
public bool get_NoDelay()
public void set_NoDelay(bool value)
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public int get_SendBufferSize()
public void set_SendBufferSize(int value)
public short get_Ttl()
public void set_Ttl(short value)
private SocketAddress RemoteEndPoint_internal(IntPtr socket, Int32& error)
public EndPoint get_RemoteEndPoint()
private void Linger(IntPtr handle)
protected void Dispose(bool explicitDisposing)
private void Close_internal(IntPtr socket, Int32& error)
public void Close()
public void Close(int timeout)
private void Connect_internal_real(IntPtr sock, SocketAddress sa, Int32& error)
private void Connect_internal(IntPtr sock, SocketAddress sa, Int32& error)
private void Connect_internal(IntPtr sock, SocketAddress sa, Int32& error, bool requireSocketPolicyFile)
internal bool CheckEndPoint(SocketAddress sa)
private MethodInfo GetUnityCrossDomainHelperMethod(string methodname)
public void Connect(EndPoint remoteEP)
internal void Connect(EndPoint remoteEP, bool requireSocketPolicy)
public bool ReceiveAsync(SocketAsyncEventArgs e)
public bool SendAsync(SocketAsyncEventArgs e)
private bool Poll_internal(IntPtr socket, SelectMode mode, int timeout, Int32& error)
internal bool Poll(int time_us, SelectMode mode, Int32& socket_error)
private int Receive_internal(IntPtr sock, Byte[] buffer, int offset, int count, SocketFlags flags, Int32& error)
internal int Receive_nochecks(Byte[] buf, int offset, int size, SocketFlags flags, SocketError& error)
private void GetSocketOption_obj_internal(IntPtr socket, SocketOptionLevel level, SocketOptionName name, Object& obj_val, Int32& error)
private int Send_internal(IntPtr sock, Byte[] buf, int offset, int count, SocketFlags flags, Int32& error)
internal int Send_nochecks(Byte[] buf, int offset, int size, SocketFlags flags, SocketError& error)
public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName)
private void Shutdown_internal(IntPtr socket, SocketShutdown how, Int32& error)
public void Shutdown(SocketShutdown how)
private void SetSocketOption_internal(IntPtr socket, SocketOptionLevel level, SocketOptionName name, object obj_val, Byte[] byte_val, int int_val, Int32& error)
public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue)
private void ThrowIfUpd()
}
public System.Net.Sockets.SocketAsyncEventArgs : EventArgs {
private IList`1<ArraySegment`1<byte>> _bufferList
private Socket curSocket
private EventHandler`1<SocketAsyncEventArgs> Completed
private Socket <AcceptSocket>k__BackingField
private Byte[] <Buffer>k__BackingField
private int <BytesTransferred>k__BackingField
private int <Count>k__BackingField
private bool <DisconnectReuseSocket>k__BackingField
private SocketAsyncOperation <LastOperation>k__BackingField
private int <Offset>k__BackingField
private EndPoint <RemoteEndPoint>k__BackingField
private IPPacketInformation <ReceiveMessageFromPacketInfo>k__BackingField
private SendPacketsElement[] <SendPacketsElements>k__BackingField
private TransmitFileOptions <SendPacketsFlags>k__BackingField
private int <SendPacketsSendSize>k__BackingField
private SocketError <SocketError>k__BackingField
private SocketFlags <SocketFlags>k__BackingField
private object <UserToken>k__BackingField
public Socket AcceptSocket
public Byte[] Buffer
public IList`1<ArraySegment`1<byte>> BufferList
public int BytesTransferred
public int Count
public bool DisconnectReuseSocket
public SocketAsyncOperation LastOperation
public int Offset
public EndPoint RemoteEndPoint
public IPPacketInformation ReceiveMessageFromPacketInfo
public SendPacketsElement[] SendPacketsElements
public TransmitFileOptions SendPacketsFlags
public int SendPacketsSendSize
public SocketError SocketError
public SocketFlags SocketFlags
public object UserToken
public void add_Completed(EventHandler`1<SocketAsyncEventArgs> value)
public void remove_Completed(EventHandler`1<SocketAsyncEventArgs> value)
public Socket get_AcceptSocket()
public void set_AcceptSocket(Socket value)
public Byte[] get_Buffer()
private void set_Buffer(Byte[] value)
public IList`1<ArraySegment`1<byte>> get_BufferList()
public void set_BufferList(IList`1<ArraySegment`1<byte>> value)
public int get_BytesTransferred()
private void set_BytesTransferred(int value)
public int get_Count()
private void set_Count(int value)
public bool get_DisconnectReuseSocket()
public void set_DisconnectReuseSocket(bool value)
public SocketAsyncOperation get_LastOperation()
private void set_LastOperation(SocketAsyncOperation value)
public int get_Offset()
private void set_Offset(int value)
public EndPoint get_RemoteEndPoint()
public void set_RemoteEndPoint(EndPoint value)
public IPPacketInformation get_ReceiveMessageFromPacketInfo()
private void set_ReceiveMessageFromPacketInfo(IPPacketInformation value)
public SendPacketsElement[] get_SendPacketsElements()
public void set_SendPacketsElements(SendPacketsElement[] value)
public TransmitFileOptions get_SendPacketsFlags()
public void set_SendPacketsFlags(TransmitFileOptions value)
public int get_SendPacketsSendSize()
public void set_SendPacketsSendSize(int value)
public SocketError get_SocketError()
public void set_SocketError(SocketError value)
public SocketFlags get_SocketFlags()
public void set_SocketFlags(SocketFlags value)
public object get_UserToken()
public void set_UserToken(object value)
protected void Finalize()
private void Dispose(bool disposing)
public void Dispose()
protected void OnCompleted(SocketAsyncEventArgs e)
public void SetBuffer(int offset, int count)
public void SetBuffer(Byte[] buffer, int offset, int count)
private void SetBufferInternal(Byte[] buffer, int offset, int count)
private void ReceiveCallback()
private void ConnectCallback()
private SocketError TryConnect(EndPoint endpoint)
private void SendCallback()
private void AcceptCallback()
private void DisconnectCallback()
private void ReceiveFromCallback()
private void SendToCallback()
internal void DoOperation(SocketAsyncOperation operation, Socket socket)
}
public System.Net.Sockets.SocketAsyncOperation : Enum {
public int value__
public SocketAsyncOperation None
public SocketAsyncOperation Accept
public SocketAsyncOperation Connect
public SocketAsyncOperation Disconnect
public SocketAsyncOperation Receive
public SocketAsyncOperation ReceiveFrom
public SocketAsyncOperation ReceiveMessageFrom
public SocketAsyncOperation Send
public SocketAsyncOperation SendPackets
public SocketAsyncOperation SendTo
}
public System.Net.Sockets.SocketError : Enum {
public int value__
public SocketError AccessDenied
public SocketError AddressAlreadyInUse
public SocketError AddressFamilyNotSupported
public SocketError AddressNotAvailable
public SocketError AlreadyInProgress
public SocketError ConnectionAborted
public SocketError ConnectionRefused
public SocketError ConnectionReset
public SocketError DestinationAddressRequired
public SocketError Disconnecting
public SocketError Fault
public SocketError HostDown
public SocketError HostNotFound
public SocketError HostUnreachable
public SocketError InProgress
public SocketError Interrupted
public SocketError InvalidArgument
public SocketError IOPending
public SocketError IsConnected
public SocketError MessageSize
public SocketError NetworkDown
public SocketError NetworkReset
public SocketError NetworkUnreachable
public SocketError NoBufferSpaceAvailable
public SocketError NoData
public SocketError NoRecovery
public SocketError NotConnected
public SocketError NotInitialized
public SocketError NotSocket
public SocketError OperationAborted
public SocketError OperationNotSupported
public SocketError ProcessLimit
public SocketError ProtocolFamilyNotSupported
public SocketError ProtocolNotSupported
public SocketError ProtocolOption
public SocketError ProtocolType
public SocketError Shutdown
public SocketError SocketError
public SocketError SocketNotSupported
public SocketError Success
public SocketError SystemNotReady
public SocketError TimedOut
public SocketError TooManyOpenSockets
public SocketError TryAgain
public SocketError TypeNotFound
public SocketError VersionNotSupported
public SocketError WouldBlock
}
public System.Net.Sockets.SocketException : Win32Exception {
public int ErrorCode
public SocketError SocketErrorCode
public string Message
public void .ctor(int error)
protected void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(int error, string message)
private int WSAGetLastError_internal()
public int get_ErrorCode()
public SocketError get_SocketErrorCode()
public string get_Message()
}
public System.Net.Sockets.SocketFlags : Enum {
public int value__
public SocketFlags None
public SocketFlags OutOfBand
public SocketFlags Peek
public SocketFlags DontRoute
public SocketFlags MaxIOVectorLength
public SocketFlags Truncated
public SocketFlags ControlDataTruncated
public SocketFlags Broadcast
public SocketFlags Multicast
public SocketFlags Partial
}
public System.Net.Sockets.SocketInformation : ValueType {
private SocketInformationOptions options
private Byte[] protocol_info
public SocketInformationOptions Options
public Byte[] ProtocolInformation
public SocketInformationOptions get_Options()
public void set_Options(SocketInformationOptions value)
public Byte[] get_ProtocolInformation()
public void set_ProtocolInformation(Byte[] value)
}
public System.Net.Sockets.SocketInformationOptions : Enum {
public int value__
public SocketInformationOptions NonBlocking
public SocketInformationOptions Connected
public SocketInformationOptions Listening
public SocketInformationOptions UseOnlyOverlappedIO
}
public System.Net.Sockets.SocketOptionLevel : Enum {
public int value__
public SocketOptionLevel Socket
public SocketOptionLevel IP
public SocketOptionLevel IPv6
public SocketOptionLevel Tcp
public SocketOptionLevel Udp
}
public System.Net.Sockets.SocketOptionName : Enum {
public int value__
public SocketOptionName Debug
public SocketOptionName AcceptConnection
public SocketOptionName ReuseAddress
public SocketOptionName KeepAlive
public SocketOptionName DontRoute
public SocketOptionName Broadcast
public SocketOptionName UseLoopback
public SocketOptionName Linger
public SocketOptionName OutOfBandInline
public SocketOptionName DontLinger
public SocketOptionName ExclusiveAddressUse
public SocketOptionName SendBuffer
public SocketOptionName ReceiveBuffer
public SocketOptionName SendLowWater
public SocketOptionName ReceiveLowWater
public SocketOptionName SendTimeout
public SocketOptionName ReceiveTimeout
public SocketOptionName Error
public SocketOptionName Type
public SocketOptionName MaxConnections
public SocketOptionName IPOptions
public SocketOptionName HeaderIncluded
public SocketOptionName TypeOfService
public SocketOptionName IpTimeToLive
public SocketOptionName MulticastInterface
public SocketOptionName MulticastTimeToLive
public SocketOptionName MulticastLoopback
public SocketOptionName AddMembership
public SocketOptionName DropMembership
public SocketOptionName DontFragment
public SocketOptionName AddSourceMembership
public SocketOptionName DropSourceMembership
public SocketOptionName BlockSource
public SocketOptionName UnblockSource
public SocketOptionName PacketInformation
public SocketOptionName NoDelay
public SocketOptionName BsdUrgent
public SocketOptionName Expedited
public SocketOptionName NoChecksum
public SocketOptionName ChecksumCoverage
public SocketOptionName HopLimit
public SocketOptionName UpdateAcceptContext
public SocketOptionName UpdateConnectContext
}
internal System.Net.Sockets.SocketPolicyClient : object {
private string policy_request
private int session
private void Log(string msg)
private Stream GetPolicyStreamForIP(string ip, int policyport, int timeout)
}
public System.Net.Sockets.SocketShutdown : Enum {
public int value__
public SocketShutdown Receive
public SocketShutdown Send
public SocketShutdown Both
}
public System.Net.Sockets.SocketType : Enum {
public int value__
public SocketType Stream
public SocketType Dgram
public SocketType Raw
public SocketType Rdm
public SocketType Seqpacket
public SocketType Unknown
}
public System.Net.Sockets.TcpClient : object {
private NetworkStream stream
private bool active
private Socket client
private bool disposed
private Properties values
private int recv_timeout
private int send_timeout
private int recv_buffer_size
private int send_buffer_size
private LingerOption linger_state
private bool no_delay
protected bool Active
public Socket Client
public int Available
public bool Connected
public bool ExclusiveAddressUse
public LingerOption LingerState
public bool NoDelay
public int ReceiveBufferSize
public int ReceiveTimeout
public int SendBufferSize
public int SendTimeout
public void .ctor(AddressFamily family)
public void .ctor(IPEndPoint local_end_point)
public void .ctor(string hostname, int port)
private void System.IDisposable.Dispose()
private void Init(AddressFamily family)
protected bool get_Active()
protected void set_Active(bool value)
public Socket get_Client()
public void set_Client(Socket value)
public int get_Available()
public bool get_Connected()
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
internal void SetTcpClient(Socket s)
public LingerOption get_LingerState()
public void set_LingerState(LingerOption value)
public bool get_NoDelay()
public void set_NoDelay(bool value)
public int get_ReceiveBufferSize()
public void set_ReceiveBufferSize(int value)
public int get_ReceiveTimeout()
public void set_ReceiveTimeout(int value)
public int get_SendBufferSize()
public void set_SendBufferSize(int value)
public int get_SendTimeout()
public void set_SendTimeout(int value)
public void Close()
public void Connect(IPEndPoint remote_end_point)
public void Connect(IPAddress address, int port)
private void SetOptions()
public void Connect(string hostname, int port)
public void Connect(IPAddress[] ipAddresses, int port)
public void EndConnect(IAsyncResult asyncResult)
public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback callback, object state)
public IAsyncResult BeginConnect(string host, int port, AsyncCallback callback, object state)
protected void Dispose(bool disposing)
protected void Finalize()
public NetworkStream GetStream()
private void CheckDisposed()
}
public System.Net.Sockets.TcpListener : object {
private bool active
private Socket server
private EndPoint savedEP
protected bool Active
public EndPoint LocalEndpoint
public Socket Server
public bool ExclusiveAddressUse
public void .ctor(int port)
public void .ctor(IPEndPoint local_end_point)
public void .ctor(IPAddress listen_ip, int port)
private void Init(AddressFamily family, EndPoint ep)
protected bool get_Active()
public EndPoint get_LocalEndpoint()
public Socket get_Server()
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public Socket AcceptSocket()
public TcpClient AcceptTcpClient()
protected void Finalize()
public bool Pending()
public void Start()
public void Start(int backlog)
public IAsyncResult BeginAcceptSocket(AsyncCallback callback, object state)
public IAsyncResult BeginAcceptTcpClient(AsyncCallback callback, object state)
public Socket EndAcceptSocket(IAsyncResult asyncResult)
public TcpClient EndAcceptTcpClient(IAsyncResult asyncResult)
public void Stop()
}
public System.Net.Sockets.TransmitFileOptions : Enum {
public int value__
public TransmitFileOptions UseDefaultWorkerThread
public TransmitFileOptions Disconnect
public TransmitFileOptions ReuseSocket
public TransmitFileOptions WriteBehind
public TransmitFileOptions UseSystemThread
public TransmitFileOptions UseKernelApc
}
public System.Net.Sockets.UdpClient : object {
private bool disposed
private bool active
private Socket socket
private AddressFamily family
private Byte[] recvbuffer
protected bool Active
public Socket Client
public int Available
public bool DontFragment
public bool EnableBroadcast
public bool ExclusiveAddressUse
public bool MulticastLoopback
public short Ttl
public void .ctor(AddressFamily family)
public void .ctor(int port)
public void .ctor(IPEndPoint localEP)
public void .ctor(int port, AddressFamily family)
public void .ctor(string hostname, int port)
private void System.IDisposable.Dispose()
private void InitSocket(EndPoint localEP)
public void Close()
private void DoConnect(IPEndPoint endPoint)
public void Connect(IPEndPoint endPoint)
public void Connect(IPAddress addr, int port)
public void Connect(string hostname, int port)
public void DropMulticastGroup(IPAddress multicastAddr)
public void DropMulticastGroup(IPAddress multicastAddr, int ifindex)
public void JoinMulticastGroup(IPAddress multicastAddr)
public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr)
public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive)
public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress)
public Byte[] Receive(IPEndPoint& remoteEP)
private int DoSend(Byte[] dgram, int bytes, IPEndPoint endPoint)
public int Send(Byte[] dgram, int bytes)
public int Send(Byte[] dgram, int bytes, IPEndPoint endPoint)
public int Send(Byte[] dgram, int bytes, string hostname, int port)
private Byte[] CutArray(Byte[] orig, int length)
private IAsyncResult DoBeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, object state)
public IAsyncResult BeginSend(Byte[] datagram, int bytes, AsyncCallback requestCallback, object state)
public IAsyncResult BeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, object state)
public IAsyncResult BeginSend(Byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state)
public int EndSend(IAsyncResult asyncResult)
public IAsyncResult BeginReceive(AsyncCallback callback, object state)
public Byte[] EndReceive(IAsyncResult asyncResult, IPEndPoint& remoteEP)
protected bool get_Active()
protected void set_Active(bool value)
public Socket get_Client()
public void set_Client(Socket value)
public int get_Available()
public bool get_DontFragment()
public void set_DontFragment(bool value)
public bool get_EnableBroadcast()
public void set_EnableBroadcast(bool value)
public bool get_ExclusiveAddressUse()
public void set_ExclusiveAddressUse(bool value)
public bool get_MulticastLoopback()
public void set_MulticastLoopback(bool value)
public short get_Ttl()
public void set_Ttl(short value)
protected void Dispose(bool disposing)
protected void Finalize()
private void CheckDisposed()
}
public System.Net.TransportType : Enum {
public int value__
public TransportType Udp
public TransportType Connectionless
public TransportType Tcp
public TransportType ConnectionOriented
public TransportType All
}
public System.Net.UploadDataCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] result
public Byte[] Result
internal void .ctor(Byte[] result, Exception error, bool cancelled, object userState)
public Byte[] get_Result()
}
public System.Net.UploadDataCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadDataCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadDataCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadFileCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] result
public Byte[] Result
internal void .ctor(Byte[] result, Exception error, bool cancelled, object userState)
public Byte[] get_Result()
}
public System.Net.UploadFileCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadFileCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadFileCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadProgressChangedEventArgs : ProgressChangedEventArgs {
private long received
private long sent
private long total_recv
private long total_send
public long BytesReceived
public long TotalBytesToReceive
public long BytesSent
public long TotalBytesToSend
internal void .ctor(long bytesReceived, long totalBytesToReceive, long bytesSent, long totalBytesToSend, int progressPercentage, object userState)
public long get_BytesReceived()
public long get_TotalBytesToReceive()
public long get_BytesSent()
public long get_TotalBytesToSend()
}
public System.Net.UploadProgressChangedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadProgressChangedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadProgressChangedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadStringCompletedEventArgs : AsyncCompletedEventArgs {
private string result
public string Result
internal void .ctor(string result, Exception error, bool cancelled, object userState)
public string get_Result()
}
public System.Net.UploadStringCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadStringCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadStringCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Net.UploadValuesCompletedEventArgs : AsyncCompletedEventArgs {
private Byte[] result
public Byte[] Result
internal void .ctor(Byte[] result, Exception error, bool cancelled, object userState)
public Byte[] get_Result()
}
public System.Net.UploadValuesCompletedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UploadValuesCompletedEventArgs e)
public IAsyncResult BeginInvoke(object sender, UploadValuesCompletedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Net.WebAsyncResult : object {
private ManualResetEvent handle
private bool synch
private bool isCompleted
private AsyncCallback cb
private object state
private int nbytes
private IAsyncResult innerAsyncResult
private bool callbackDone
private Exception exc
private HttpWebResponse response
private Stream writeStream
private Byte[] buffer
private int offset
private int size
private object locker
public bool EndCalled
public bool AsyncWriteAll
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
internal bool GotException
internal Exception Exception
internal int NBytes
internal IAsyncResult InnerAsyncResult
internal Stream WriteStream
internal HttpWebResponse Response
internal Byte[] Buffer
internal int Offset
internal int Size
public void .ctor(AsyncCallback cb, object state)
public void .ctor(HttpWebRequest request, AsyncCallback cb, object state)
public void .ctor(AsyncCallback cb, object state, Byte[] buffer, int offset, int size)
internal void SetCompleted(bool synch, Exception e)
internal void Reset()
internal void SetCompleted(bool synch, int nbytes)
internal void SetCompleted(bool synch, Stream writeStream)
internal void SetCompleted(bool synch, HttpWebResponse response)
internal void DoCallback()
internal void WaitUntilComplete()
internal bool WaitUntilComplete(int timeout, bool exitContext)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
internal bool get_GotException()
internal Exception get_Exception()
internal int get_NBytes()
internal void set_NBytes(int value)
internal IAsyncResult get_InnerAsyncResult()
internal void set_InnerAsyncResult(IAsyncResult value)
internal Stream get_WriteStream()
internal HttpWebResponse get_Response()
internal Byte[] get_Buffer()
internal int get_Offset()
internal int get_Size()
}
public System.Net.WebClient : Component {
private string urlEncodedCType
private Byte[] hexBytes
private ICredentials credentials
private WebHeaderCollection headers
private WebHeaderCollection responseHeaders
private Uri baseAddress
private string baseString
private NameValueCollection queryString
private bool is_busy
private bool async
private Thread async_thread
private Encoding encoding
private IWebProxy proxy
private DownloadDataCompletedEventHandler DownloadDataCompleted
private AsyncCompletedEventHandler DownloadFileCompleted
private DownloadProgressChangedEventHandler DownloadProgressChanged
private DownloadStringCompletedEventHandler DownloadStringCompleted
private OpenReadCompletedEventHandler OpenReadCompleted
private OpenWriteCompletedEventHandler OpenWriteCompleted
private UploadDataCompletedEventHandler UploadDataCompleted
private UploadFileCompletedEventHandler UploadFileCompleted
private UploadProgressChangedEventHandler UploadProgressChanged
private UploadStringCompletedEventHandler UploadStringCompleted
private UploadValuesCompletedEventHandler UploadValuesCompleted
public string BaseAddress
public RequestCachePolicy CachePolicy
public bool UseDefaultCredentials
public ICredentials Credentials
public WebHeaderCollection Headers
public NameValueCollection QueryString
public WebHeaderCollection ResponseHeaders
public Encoding Encoding
public IWebProxy Proxy
public bool IsBusy
public void add_DownloadDataCompleted(DownloadDataCompletedEventHandler value)
public void remove_DownloadDataCompleted(DownloadDataCompletedEventHandler value)
public void add_DownloadFileCompleted(AsyncCompletedEventHandler value)
public void remove_DownloadFileCompleted(AsyncCompletedEventHandler value)
public void add_DownloadProgressChanged(DownloadProgressChangedEventHandler value)
public void remove_DownloadProgressChanged(DownloadProgressChangedEventHandler value)
public void add_DownloadStringCompleted(DownloadStringCompletedEventHandler value)
public void remove_DownloadStringCompleted(DownloadStringCompletedEventHandler value)
public void add_OpenReadCompleted(OpenReadCompletedEventHandler value)
public void remove_OpenReadCompleted(OpenReadCompletedEventHandler value)
public void add_OpenWriteCompleted(OpenWriteCompletedEventHandler value)
public void remove_OpenWriteCompleted(OpenWriteCompletedEventHandler value)
public void add_UploadDataCompleted(UploadDataCompletedEventHandler value)
public void remove_UploadDataCompleted(UploadDataCompletedEventHandler value)
public void add_UploadFileCompleted(UploadFileCompletedEventHandler value)
public void remove_UploadFileCompleted(UploadFileCompletedEventHandler value)
public void add_UploadProgressChanged(UploadProgressChangedEventHandler value)
public void remove_UploadProgressChanged(UploadProgressChangedEventHandler value)
public void add_UploadStringCompleted(UploadStringCompletedEventHandler value)
public void remove_UploadStringCompleted(UploadStringCompletedEventHandler value)
public void add_UploadValuesCompleted(UploadValuesCompletedEventHandler value)
public void remove_UploadValuesCompleted(UploadValuesCompletedEventHandler value)
public string get_BaseAddress()
public void set_BaseAddress(string value)
private Exception GetMustImplement()
public RequestCachePolicy get_CachePolicy()
public void set_CachePolicy(RequestCachePolicy value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public NameValueCollection get_QueryString()
public void set_QueryString(NameValueCollection value)
public WebHeaderCollection get_ResponseHeaders()
public Encoding get_Encoding()
public void set_Encoding(Encoding value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public bool get_IsBusy()
private void CheckBusy()
private void SetBusy()
public Byte[] DownloadData(string address)
public Byte[] DownloadData(Uri address)
private Byte[] DownloadDataCore(Uri address, object userToken)
public void DownloadFile(string address, string fileName)
public void DownloadFile(Uri address, string fileName)
private void DownloadFileCore(Uri address, string fileName, object userToken)
public Stream OpenRead(string address)
public Stream OpenRead(Uri address)
public Stream OpenWrite(string address)
public Stream OpenWrite(string address, string method)
public Stream OpenWrite(Uri address)
public Stream OpenWrite(Uri address, string method)
private string DetermineMethod(Uri address, string method, bool is_upload)
public Byte[] UploadData(string address, Byte[] data)
public Byte[] UploadData(string address, string method, Byte[] data)
public Byte[] UploadData(Uri address, Byte[] data)
public Byte[] UploadData(Uri address, string method, Byte[] data)
private Byte[] UploadDataCore(Uri address, string method, Byte[] data, object userToken)
public Byte[] UploadFile(string address, string fileName)
public Byte[] UploadFile(Uri address, string fileName)
public Byte[] UploadFile(string address, string method, string fileName)
public Byte[] UploadFile(Uri address, string method, string fileName)
private Byte[] UploadFileCore(Uri address, string method, string fileName, object userToken)
public Byte[] UploadValues(string address, NameValueCollection data)
public Byte[] UploadValues(string address, string method, NameValueCollection data)
public Byte[] UploadValues(Uri address, NameValueCollection data)
public Byte[] UploadValues(Uri address, string method, NameValueCollection data)
private Byte[] UploadValuesCore(Uri uri, string method, NameValueCollection data, object userToken)
public string DownloadString(string address)
public string DownloadString(Uri address)
public string UploadString(string address, string data)
public string UploadString(string address, string method, string data)
public string UploadString(Uri address, string data)
public string UploadString(Uri address, string method, string data)
private Uri CreateUri(string address)
private Uri CreateUri(Uri address)
private string GetQueryString(bool add_qmark)
private Uri MakeUri(string path)
private WebRequest SetupRequest(Uri uri)
private WebRequest SetupRequest(Uri uri, string method, bool is_upload)
private Byte[] ReadAll(Stream stream, int length, object userToken)
private string UrlEncode(string str)
private void UrlEncodeAndWrite(Stream stream, Byte[] bytes)
public void CancelAsync()
private void CompleteAsync()
public void DownloadDataAsync(Uri address)
public void DownloadDataAsync(Uri address, object userToken)
public void DownloadFileAsync(Uri address, string fileName)
public void DownloadFileAsync(Uri address, string fileName, object userToken)
public void DownloadStringAsync(Uri address)
public void DownloadStringAsync(Uri address, object userToken)
public void OpenReadAsync(Uri address)
public void OpenReadAsync(Uri address, object userToken)
public void OpenWriteAsync(Uri address)
public void OpenWriteAsync(Uri address, string method)
public void OpenWriteAsync(Uri address, string method, object userToken)
public void UploadDataAsync(Uri address, Byte[] data)
public void UploadDataAsync(Uri address, string method, Byte[] data)
public void UploadDataAsync(Uri address, string method, Byte[] data, object userToken)
public void UploadFileAsync(Uri address, string fileName)
public void UploadFileAsync(Uri address, string method, string fileName)
public void UploadFileAsync(Uri address, string method, string fileName, object userToken)
public void UploadStringAsync(Uri address, string data)
public void UploadStringAsync(Uri address, string method, string data)
public void UploadStringAsync(Uri address, string method, string data, object userToken)
public void UploadValuesAsync(Uri address, NameValueCollection values)
public void UploadValuesAsync(Uri address, string method, NameValueCollection values)
public void UploadValuesAsync(Uri address, string method, NameValueCollection values, object userToken)
protected void OnDownloadDataCompleted(DownloadDataCompletedEventArgs args)
protected void OnDownloadFileCompleted(AsyncCompletedEventArgs args)
protected void OnDownloadProgressChanged(DownloadProgressChangedEventArgs e)
protected void OnDownloadStringCompleted(DownloadStringCompletedEventArgs args)
protected void OnOpenReadCompleted(OpenReadCompletedEventArgs args)
protected void OnOpenWriteCompleted(OpenWriteCompletedEventArgs args)
protected void OnUploadDataCompleted(UploadDataCompletedEventArgs args)
protected void OnUploadFileCompleted(UploadFileCompletedEventArgs args)
protected void OnUploadProgressChanged(UploadProgressChangedEventArgs e)
protected void OnUploadStringCompleted(UploadStringCompletedEventArgs args)
protected void OnUploadValuesCompleted(UploadValuesCompletedEventArgs args)
protected WebResponse GetWebResponse(WebRequest request, IAsyncResult result)
protected WebRequest GetWebRequest(Uri address)
protected WebResponse GetWebResponse(WebRequest request)
private void <DownloadDataAsync>m__D(object state)
private void <DownloadFileAsync>m__E(object state)
private void <DownloadStringAsync>m__F(object state)
private void <OpenReadAsync>m__10(object state)
private void <OpenWriteAsync>m__11(object state)
private void <UploadDataAsync>m__12(object state)
private void <UploadFileAsync>m__13(object state)
private void <UploadStringAsync>m__14(object state)
private void <UploadValuesAsync>m__15(object state)
}
internal System.Net.WebConnection : object {
private ServicePoint sPoint
private Stream nstream
private Socket socket
private object socketLock
private WebExceptionStatus status
private WaitCallback initConn
private bool keepAlive
private Byte[] buffer
private AsyncCallback readDoneDelegate
private EventHandler abortHandler
private AbortHelper abortHelper
private ReadState readState
internal WebConnectionData Data
private bool chunkedRead
private ChunkStream chunkStream
private Queue queue
private bool reused
private int position
private bool busy
private HttpWebRequest priority_request
private NetworkCredential ntlm_credentials
private bool ntlm_authenticated
private bool unsafe_sharing
private bool ssl
private bool certsAvailable
private Exception connect_exception
private object classLock
private Type sslStream
private PropertyInfo piClient
private PropertyInfo piServer
private PropertyInfo piTrustFailure
private MethodInfo method_GetSecurityPolicyFromNonMainThread
internal bool Busy
internal bool Connected
internal HttpWebRequest PriorityRequest
internal bool NtlmAuthenticated
internal NetworkCredential NtlmCredential
internal bool UnsafeAuthenticatedConnectionSharing
public void .ctor(WebConnectionGroup group, ServicePoint sPoint)
private bool CanReuse()
private void LoggedThrow(Exception e)
internal Stream DownloadPolicy(string url, string proxy)
private void CheckUnityWebSecurity(HttpWebRequest request)
private void Connect(HttpWebRequest request)
private void EnsureSSLStreamAvailable()
private bool CreateTunnel(HttpWebRequest request, Stream stream, Byte[]& buffer)
private WebHeaderCollection ReadHeaders(HttpWebRequest request, Stream stream, Byte[]& retBuffer, Int32& status)
private bool CreateStream(HttpWebRequest request)
private void HandleError(WebExceptionStatus st, Exception e, string where)
private void ReadDone(IAsyncResult result)
private bool ExpectContent(int statusCode)
internal void GetCertificates()
internal void InitRead(object state)
private int GetResponse(Byte[] buffer, int max)
private void InitConnection(object state)
internal EventHandler SendRequest(HttpWebRequest request)
private void SendNext()
internal void NextRead()
private bool ReadLine(Byte[] buffer, Int32& start, int max, String& output)
internal IAsyncResult BeginRead(HttpWebRequest request, Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
internal int EndRead(HttpWebRequest request, IAsyncResult result)
private int EnsureRead(Byte[] buffer, int offset, int size)
private bool CompleteChunkedRead()
internal IAsyncResult BeginWrite(HttpWebRequest request, Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
internal void EndWrite2(HttpWebRequest request, IAsyncResult result)
internal bool EndWrite(HttpWebRequest request, IAsyncResult result)
internal int Read(HttpWebRequest request, Byte[] buffer, int offset, int size)
internal bool Write(HttpWebRequest request, Byte[] buffer, int offset, int size, String& err_msg)
internal void Close(bool sendNext)
private void Abort(object sender, EventArgs args)
internal void ResetNtlm()
internal bool get_Busy()
internal bool get_Connected()
internal void set_PriorityRequest(HttpWebRequest value)
internal bool get_NtlmAuthenticated()
internal void set_NtlmAuthenticated(bool value)
internal NetworkCredential get_NtlmCredential()
internal void set_NtlmCredential(NetworkCredential value)
internal bool get_UnsafeAuthenticatedConnectionSharing()
internal void set_UnsafeAuthenticatedConnectionSharing(bool value)
}
internal System.Net.WebConnectionData : object {
public HttpWebRequest request
public int StatusCode
public string StatusDescription
public WebHeaderCollection Headers
public Version Version
public Stream stream
public string Challenge
public void Init()
}
internal System.Net.WebConnectionGroup : object {
private ServicePoint sPoint
private string name
private ArrayList connections
private Random rnd
private Queue queue
public string Name
internal Queue Queue
public void .ctor(ServicePoint sPoint, string name)
public void Close()
public WebConnection GetConnection(HttpWebRequest request)
private void PrepareSharingNtlm(WebConnection cnc, HttpWebRequest request)
private WebConnection CreateOrReuseConnection(HttpWebRequest request)
public string get_Name()
internal Queue get_Queue()
}
internal System.Net.WebConnectionStream : Stream {
private Byte[] crlf
private bool isRead
private WebConnection cnc
private HttpWebRequest request
private Byte[] readBuffer
private int readBufferOffset
private int readBufferSize
private int contentLength
private int totalRead
private long totalWritten
private bool nextReadCalled
private int pendingReads
private int pendingWrites
private ManualResetEvent pending
private bool allowBuffering
private bool sendChunked
private MemoryStream writeBuffer
private bool requestWritten
private Byte[] headers
private bool disposed
private bool headersSent
private object locker
private bool initRead
private bool read_eof
private bool complete_request_written
private int read_timeout
private int write_timeout
internal HttpWebRequest Request
internal WebConnection Connection
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
internal bool CompleteRequestWritten
internal bool SendChunked
internal Byte[] ReadBuffer
internal int ReadBufferOffset
internal int ReadBufferSize
internal Byte[] WriteBuffer
internal int WriteBufferLength
internal bool RequestWritten
public bool CanSeek
public bool CanRead
public bool CanWrite
public long Length
public long Position
public void .ctor(WebConnection cnc)
public void .ctor(WebConnection cnc, HttpWebRequest request)
private bool IsNtlmAuth()
internal void CheckResponseInBuffer()
internal HttpWebRequest get_Request()
internal WebConnection get_Connection()
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
internal bool get_CompleteRequestWritten()
internal void set_SendChunked(bool value)
internal void set_ReadBuffer(Byte[] value)
internal void set_ReadBufferOffset(int value)
internal void set_ReadBufferSize(int value)
internal Byte[] get_WriteBuffer()
internal int get_WriteBufferLength()
internal void ForceCompletion()
internal void CheckComplete()
internal void ReadAll()
private void WriteCallbackWrapper(IAsyncResult r)
private void ReadCallbackWrapper(IAsyncResult r)
public int Read(Byte[] buffer, int offset, int size)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
public int EndRead(IAsyncResult r)
private void WriteRequestAsyncCB(IAsyncResult r)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback cb, object state)
private void CheckWriteOverflow(long contentLength, long totalWritten, long size)
public void EndWrite(IAsyncResult r)
public void Write(Byte[] buffer, int offset, int size)
public void Flush()
internal void SetHeaders(Byte[] buffer)
internal bool get_RequestWritten()
private IAsyncResult WriteRequestAsync(AsyncCallback cb, object state)
private void WriteHeaders()
internal void WriteRequest()
internal void InternalClose()
public void Close()
internal void KillBuffer()
public long Seek(long a, SeekOrigin b)
public void SetLength(long a)
public bool get_CanSeek()
public bool get_CanRead()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
}
public System.Net.WebException : InvalidOperationException {
private WebResponse response
private WebExceptionStatus status
public WebResponse Response
public WebExceptionStatus Status
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, WebExceptionStatus status)
internal void .ctor(string message, Exception innerException, WebExceptionStatus status)
public void .ctor(string message, Exception innerException, WebExceptionStatus status, WebResponse response)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public WebResponse get_Response()
public WebExceptionStatus get_Status()
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Net.WebExceptionStatus : Enum {
public int value__
public WebExceptionStatus Success
public WebExceptionStatus NameResolutionFailure
public WebExceptionStatus ConnectFailure
public WebExceptionStatus ReceiveFailure
public WebExceptionStatus SendFailure
public WebExceptionStatus PipelineFailure
public WebExceptionStatus RequestCanceled
public WebExceptionStatus ProtocolError
public WebExceptionStatus ConnectionClosed
public WebExceptionStatus TrustFailure
public WebExceptionStatus SecureChannelFailure
public WebExceptionStatus ServerProtocolViolation
public WebExceptionStatus KeepAliveFailure
public WebExceptionStatus Pending
public WebExceptionStatus Timeout
public WebExceptionStatus ProxyNameResolutionFailure
public WebExceptionStatus UnknownError
public WebExceptionStatus MessageLengthLimitExceeded
public WebExceptionStatus CacheEntryNotFound
public WebExceptionStatus RequestProhibitedByCachePolicy
public WebExceptionStatus RequestProhibitedByProxy
}
public System.Net.WebHeaderCollection : NameValueCollection {
private Hashtable restricted
private Hashtable multiValue
private Dictionary`2<string, bool> restricted_response
private bool internallyCreated
private Boolean[] allowed_chars
public String[] AllKeys
public int Count
public KeysCollection Keys
public string Item
public string Item
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
internal void .ctor(bool internallyCreated)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void Add(string header)
public void Add(string name, string value)
protected void AddWithoutValidate(string headerName, string headerValue)
public String[] GetValues(string header)
public String[] GetValues(int index)
public bool IsRestricted(string headerName)
public bool IsRestricted(string headerName, bool response)
public void OnDeserialization(object sender)
public void Remove(string name)
public void Set(string name, string value)
public Byte[] ToByteArray()
internal string ToStringMultiValue()
public string ToString()
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public String[] get_AllKeys()
public int get_Count()
public KeysCollection get_Keys()
public string Get(int index)
public string Get(string name)
public string GetKey(int index)
public void Add(HttpRequestHeader header, string value)
public void Remove(HttpRequestHeader header)
public void Set(HttpRequestHeader header, string value)
public void Add(HttpResponseHeader header, string value)
public void Remove(HttpResponseHeader header)
public void Set(HttpResponseHeader header, string value)
private string RequestHeaderToString(HttpRequestHeader value)
public string get_Item(HttpRequestHeader hrh)
public void set_Item(HttpRequestHeader hrh, string value)
private string ResponseHeaderToString(HttpResponseHeader value)
public string get_Item(HttpResponseHeader hrh)
public void set_Item(HttpResponseHeader hrh, string value)
public void Clear()
public IEnumerator GetEnumerator()
internal void SetInternal(string header)
internal void SetInternal(string name, string value)
internal void RemoveAndAdd(string name, string value)
internal void RemoveInternal(string name)
internal bool IsMultiValue(string headerName)
internal bool IsHeaderValue(string value)
internal bool IsHeaderName(string name)
}
public System.Net.WebPermission : CodeAccessPermission {
private ArrayList m_acceptList
private ArrayList m_connectList
private bool m_noRestriction
public IEnumerator AcceptList
public IEnumerator ConnectList
public void .ctor(PermissionState state)
public void .ctor(NetworkAccess access, string uriString)
public void .ctor(NetworkAccess access, Regex uriRegex)
public IEnumerator get_AcceptList()
public IEnumerator get_ConnectList()
public void AddPermission(NetworkAccess access, string uriString)
public void AddPermission(NetworkAccess access, Regex uriRegex)
internal void AddPermission(NetworkAccess access, WebPermissionInfo info)
public IPermission Copy()
public IPermission Intersect(IPermission target)
private bool IntersectEmpty(WebPermission permission)
private void Intersect(ArrayList list1, ArrayList list2, ArrayList result)
public bool IsSubsetOf(IPermission target)
private bool IsSubsetOf(ArrayList list1, ArrayList list2)
public bool IsUnrestricted()
public SecurityElement ToXml()
private void ToXml(SecurityElement root, string childName, IEnumerator enumerator)
public void FromXml(SecurityElement securityElement)
private void FromXml(ArrayList endpoints, NetworkAccess access)
public IPermission Union(IPermission target)
}
public System.Net.WebPermissionAttribute : CodeAccessSecurityAttribute {
private object m_accept
private object m_connect
public string Accept
public string AcceptPattern
public string Connect
public string ConnectPattern
public void .ctor(SecurityAction action)
public string get_Accept()
public void set_Accept(string value)
public string get_AcceptPattern()
public void set_AcceptPattern(string value)
public string get_Connect()
public void set_Connect(string value)
public string get_ConnectPattern()
public void set_ConnectPattern(string value)
public IPermission CreatePermission()
internal void AlreadySet(string parameter, string property)
}
internal System.Net.WebPermissionInfo : object {
private WebPermissionInfoType _type
private object _info
public string Info
public void .ctor(WebPermissionInfoType type, string info)
public void .ctor(Regex regex)
public string get_Info()
}
internal System.Net.WebPermissionInfoType : Enum {
public int value__
public WebPermissionInfoType InfoString
public WebPermissionInfoType InfoUnexecutedRegex
public WebPermissionInfoType InfoRegex
}
public System.Net.WebProxy : object {
private Uri address
private bool bypassOnLocal
private ArrayList bypassList
private ICredentials credentials
private bool useDefaultCredentials
public Uri Address
public ArrayList BypassArrayList
public String[] BypassList
public bool BypassProxyOnLocal
public ICredentials Credentials
public bool UseDefaultCredentials
public void .ctor(string address)
public void .ctor(Uri address)
public void .ctor(string address, bool bypassOnLocal)
public void .ctor(string host, int port)
public void .ctor(Uri address, bool bypassOnLocal)
public void .ctor(string address, bool bypassOnLocal, String[] bypassList)
public void .ctor(Uri address, bool bypassOnLocal, String[] bypassList)
public void .ctor(string address, bool bypassOnLocal, String[] bypassList, ICredentials credentials)
public void .ctor(Uri address, bool bypassOnLocal, String[] bypassList, ICredentials credentials)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public Uri get_Address()
public void set_Address(Uri value)
public ArrayList get_BypassArrayList()
public String[] get_BypassList()
public void set_BypassList(String[] value)
public bool get_BypassProxyOnLocal()
public void set_BypassProxyOnLocal(bool value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public WebProxy GetDefaultProxy()
public Uri GetProxy(Uri destination)
public bool IsBypassed(Uri host)
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void CheckBypassList()
private Uri ToUri(string address)
}
public System.Net.WebRequest : MarshalByRefObject {
private HybridDictionary prefixes
private bool isDefaultWebProxySet
private IWebProxy defaultWebProxy
private AuthenticationLevel authentication_level
private object lockobj
public AuthenticationLevel AuthenticationLevel
public RequestCachePolicy CachePolicy
public string ConnectionGroupName
public long ContentLength
public string ContentType
public ICredentials Credentials
public RequestCachePolicy DefaultCachePolicy
public WebHeaderCollection Headers
public TokenImpersonationLevel ImpersonationLevel
public string Method
public bool PreAuthenticate
public IWebProxy Proxy
public Uri RequestUri
public int Timeout
public bool UseDefaultCredentials
public IWebProxy DefaultWebProxy
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void AddDynamicPrefix(string protocol, string implementor)
private Exception GetMustImplement()
public AuthenticationLevel get_AuthenticationLevel()
public void set_AuthenticationLevel(AuthenticationLevel value)
public RequestCachePolicy get_CachePolicy()
public void set_CachePolicy(RequestCachePolicy value)
public string get_ConnectionGroupName()
public void set_ConnectionGroupName(string value)
public long get_ContentLength()
public void set_ContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public ICredentials get_Credentials()
public void set_Credentials(ICredentials value)
public RequestCachePolicy get_DefaultCachePolicy()
public void set_DefaultCachePolicy(RequestCachePolicy value)
public WebHeaderCollection get_Headers()
public void set_Headers(WebHeaderCollection value)
public TokenImpersonationLevel get_ImpersonationLevel()
public void set_ImpersonationLevel(TokenImpersonationLevel value)
public string get_Method()
public void set_Method(string value)
public bool get_PreAuthenticate()
public void set_PreAuthenticate(bool value)
public IWebProxy get_Proxy()
public void set_Proxy(IWebProxy value)
public Uri get_RequestUri()
public int get_Timeout()
public void set_Timeout(int value)
public bool get_UseDefaultCredentials()
public void set_UseDefaultCredentials(bool value)
public IWebProxy get_DefaultWebProxy()
public void set_DefaultWebProxy(IWebProxy value)
private IWebProxy GetDefaultWebProxy()
public void Abort()
public IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state)
public IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
public WebRequest Create(string requestUriString)
public WebRequest Create(Uri requestUri)
public WebRequest CreateDefault(Uri requestUri)
public Stream EndGetRequestStream(IAsyncResult asyncResult)
public WebResponse EndGetResponse(IAsyncResult asyncResult)
public Stream GetRequestStream()
public WebResponse GetResponse()
public IWebProxy GetSystemWebProxy()
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public bool RegisterPrefix(string prefix, IWebRequestCreate creator)
private IWebRequestCreate GetCreator(string prefix)
internal void ClearPrefixes()
internal void RemovePrefix(string prefix)
internal void AddPrefix(string prefix, string typeName)
internal void AddPrefix(string prefix, Type type)
}
public System.Net.WebResponse : MarshalByRefObject {
public long ContentLength
public string ContentType
public WebHeaderCollection Headers
public bool IsFromCache
public bool IsMutuallyAuthenticated
public Uri ResponseUri
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
private void System.IDisposable.Dispose()
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
public long get_ContentLength()
public void set_ContentLength(long value)
public string get_ContentType()
public void set_ContentType(string value)
public WebHeaderCollection get_Headers()
private Exception GetMustImplement()
public bool get_IsFromCache()
public bool get_IsMutuallyAuthenticated()
public Uri get_ResponseUri()
public void Close()
public Stream GetResponseStream()
protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Runtime.InteropServices.ComTypes.ADVF : Enum {
public int value__
public ADVF ADVF_NODATA
public ADVF ADVF_PRIMEFIRST
public ADVF ADVF_ONLYONCE
public ADVF ADVFCACHE_NOHANDLER
public ADVF ADVFCACHE_FORCEBUILTIN
public ADVF ADVFCACHE_ONSAVE
public ADVF ADVF_DATAONSTOP
}
public System.Runtime.InteropServices.ComTypes.DATADIR : Enum {
public int value__
public DATADIR DATADIR_GET
public DATADIR DATADIR_SET
}
public System.Runtime.InteropServices.ComTypes.DVASPECT : Enum {
public int value__
public DVASPECT DVASPECT_CONTENT
public DVASPECT DVASPECT_THUMBNAIL
public DVASPECT DVASPECT_ICON
public DVASPECT DVASPECT_DOCPRINT
}
public System.Runtime.InteropServices.ComTypes.FORMATETC : ValueType {
public short cfFormat
public DVASPECT dwAspect
public int lindex
public IntPtr ptd
public TYMED tymed
}
public System.Runtime.InteropServices.ComTypes.IAdviseSink {
public void OnClose()
public void OnDataChange(FORMATETC& format, STGMEDIUM& stgmedium)
public void OnRename(IMoniker moniker)
public void OnSave()
public void OnViewChange(int aspect, int index)
}
public System.Runtime.InteropServices.ComTypes.IDataObject {
public int DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink adviseSink, Int32& connection)
public void DUnadvise(int connection)
public int EnumDAdvise(IEnumSTATDATA& enumAdvise)
public IEnumFORMATETC EnumFormatEtc(DATADIR direction)
public int GetCanonicalFormatEtc(FORMATETC& formatIn, FORMATETC& formatOut)
public void GetData(FORMATETC& format, STGMEDIUM& medium)
public void GetDataHere(FORMATETC& format, STGMEDIUM& medium)
public int QueryGetData(FORMATETC& format)
public void SetData(FORMATETC& formatIn, STGMEDIUM& medium, bool release)
}
public System.Runtime.InteropServices.ComTypes.IEnumFORMATETC {
public void Clone(IEnumFORMATETC& newEnum)
public int Next(int celt, FORMATETC[] rgelt, Int32[] pceltFetched)
public int Reset()
public int Skip(int celt)
}
public System.Runtime.InteropServices.ComTypes.IEnumSTATDATA {
public void Clone(IEnumSTATDATA& newEnum)
public int Next(int celt, STATDATA[] rgelt, Int32[] pceltFetched)
public int Reset()
public int Skip(int celt)
}
public System.Runtime.InteropServices.ComTypes.STATDATA : ValueType {
public ADVF advf
public IAdviseSink advSink
public int connection
public FORMATETC formatetc
}
public System.Runtime.InteropServices.ComTypes.STGMEDIUM : ValueType {
public object pUnkForRelease
public TYMED tymed
public IntPtr unionmember
}
public System.Runtime.InteropServices.ComTypes.TYMED : Enum {
public int value__
public TYMED TYMED_HGLOBAL
public TYMED TYMED_FILE
public TYMED TYMED_ISTREAM
public TYMED TYMED_ISTORAGE
public TYMED TYMED_GDI
public TYMED TYMED_MFPICT
public TYMED TYMED_ENHMF
public TYMED TYMED_NULL
}
public System.Runtime.InteropServices.DefaultParameterValueAttribute : Attribute {
private object value
public object Value
public void .ctor(object value)
public object get_Value()
}
public System.Runtime.InteropServices.HandleCollector : object {
private int count
private int init
private int max
private string name
private DateTime previous_collection
public int Count
public int InitialThreshold
public int MaximumThreshold
public string Name
public void .ctor(string name, int initialThreshold)
public void .ctor(string name, int initialThreshold, int maximumThreshold)
public int get_Count()
public int get_InitialThreshold()
public int get_MaximumThreshold()
public string get_Name()
public void Add()
public void Remove()
}
public System.Security.AccessControl.SemaphoreAccessRule : AccessRule {
private SemaphoreRights semaphoreRights
public SemaphoreRights SemaphoreRights
public void .ctor(IdentityReference identity, SemaphoreRights semaphoreRights, AccessControlType type)
public void .ctor(string identity, SemaphoreRights semaphoreRights, AccessControlType type)
public SemaphoreRights get_SemaphoreRights()
}
public System.Security.AccessControl.SemaphoreAuditRule : AuditRule {
private SemaphoreRights semaphoreRights
public SemaphoreRights SemaphoreRights
public void .ctor(IdentityReference identity, SemaphoreRights semaphoreRights, AuditFlags flags)
public SemaphoreRights get_SemaphoreRights()
}
public System.Security.AccessControl.SemaphoreRights : Enum {
public int value__
public SemaphoreRights Modify
public SemaphoreRights Delete
public SemaphoreRights ReadPermissions
public SemaphoreRights ChangePermissions
public SemaphoreRights TakeOwnership
public SemaphoreRights Synchronize
public SemaphoreRights FullControl
}
public System.Security.AccessControl.SemaphoreSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public void .ctor(string name, AccessControlSections includesections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(SemaphoreAccessRule rule)
public void AddAuditRule(SemaphoreAuditRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public bool RemoveAccessRule(SemaphoreAccessRule rule)
public void RemoveAccessRuleAll(SemaphoreAccessRule rule)
public void RemoveAccessRuleSpecific(SemaphoreAccessRule rule)
public bool RemoveAuditRule(SemaphoreAuditRule rule)
public void RemoveAuditRuleAll(SemaphoreAuditRule rule)
public void RemoveAuditRuleSpecific(SemaphoreAuditRule rule)
public void ResetAccessRule(SemaphoreAccessRule rule)
public void SetAccessRule(SemaphoreAccessRule rule)
public void SetAuditRule(SemaphoreAuditRule rule)
}
public System.Security.Authentication.AuthenticationException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Security.Authentication.CipherAlgorithmType : Enum {
public int value__
public CipherAlgorithmType None
public CipherAlgorithmType Aes
public CipherAlgorithmType Aes128
public CipherAlgorithmType Aes192
public CipherAlgorithmType Aes256
public CipherAlgorithmType Des
public CipherAlgorithmType Rc2
public CipherAlgorithmType Rc4
public CipherAlgorithmType TripleDes
}
public System.Security.Authentication.ExchangeAlgorithmType : Enum {
public int value__
public ExchangeAlgorithmType None
public ExchangeAlgorithmType DiffieHellman
public ExchangeAlgorithmType RsaKeyX
public ExchangeAlgorithmType RsaSign
}
public System.Security.Authentication.HashAlgorithmType : Enum {
public int value__
public HashAlgorithmType None
public HashAlgorithmType Md5
public HashAlgorithmType Sha1
}
public System.Security.Authentication.InvalidCredentialException : AuthenticationException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Security.Authentication.SslProtocols : Enum {
public int value__
public SslProtocols None
public SslProtocols Ssl2
public SslProtocols Ssl3
public SslProtocols Tls
public SslProtocols Default
}
internal System.Security.Cryptography.AsnDecodeStatus : Enum {
public int value__
public AsnDecodeStatus NotDecoded
public AsnDecodeStatus Ok
public AsnDecodeStatus BadAsn
public AsnDecodeStatus BadTag
public AsnDecodeStatus BadLength
public AsnDecodeStatus InformationNotAvailable
}
public System.Security.Cryptography.AsnEncodedData : object {
internal Oid _oid
internal Byte[] _raw
private Dictionary`2<string, int> <>f__switch$map13
public Oid Oid
public Byte[] RawData
public void .ctor(string oid, Byte[] rawData)
public void .ctor(Oid oid, Byte[] rawData)
public void .ctor(AsnEncodedData asnEncodedData)
public void .ctor(Byte[] rawData)
public Oid get_Oid()
public void set_Oid(Oid value)
public Byte[] get_RawData()
public void set_RawData(Byte[] value)
public void CopyFrom(AsnEncodedData asnEncodedData)
public string Format(bool multiLine)
internal string ToString(bool multiLine)
internal string Default(bool multiLine)
internal string BasicConstraintsExtension(bool multiLine)
internal string EnhancedKeyUsageExtension(bool multiLine)
internal string KeyUsageExtension(bool multiLine)
internal string SubjectKeyIdentifierExtension(bool multiLine)
internal string SubjectAltName(bool multiLine)
internal string NetscapeCertType(bool multiLine)
}
public System.Security.Cryptography.AsnEncodedDataCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public AsnEncodedData Item
public object SyncRoot
public void .ctor(AsnEncodedData asnEncodedData)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsSynchronized()
public AsnEncodedData get_Item(int index)
public object get_SyncRoot()
public int Add(AsnEncodedData asnEncodedData)
public void CopyTo(AsnEncodedData[] array, int index)
public AsnEncodedDataEnumerator GetEnumerator()
public void Remove(AsnEncodedData asnEncodedData)
}
public System.Security.Cryptography.AsnEncodedDataEnumerator : object {
private AsnEncodedDataCollection _collection
private int _position
private object System.Collections.IEnumerator.Current
public AsnEncodedData Current
internal void .ctor(AsnEncodedDataCollection collection)
private object System.Collections.IEnumerator.get_Current()
public AsnEncodedData get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.Oid : object {
internal string oidRSA
internal string nameRSA
internal string oidPkcs7Data
internal string namePkcs7Data
internal string oidPkcs9ContentType
internal string namePkcs9ContentType
internal string oidPkcs9MessageDigest
internal string namePkcs9MessageDigest
internal string oidPkcs9SigningTime
internal string namePkcs9SigningTime
internal string oidMd5
internal string nameMd5
internal string oid3Des
internal string name3Des
internal string oidSha1
internal string nameSha1
internal string oidSubjectAltName
internal string nameSubjectAltName
internal string oidNetscapeCertType
internal string nameNetscapeCertType
private string _value
private string _name
private Dictionary`2<string, int> <>f__switch$map14
private Dictionary`2<string, int> <>f__switch$map15
public string FriendlyName
public string Value
public void .ctor(string oid)
public void .ctor(string value, string friendlyName)
public void .ctor(Oid oid)
public string get_FriendlyName()
public void set_FriendlyName(string value)
public string get_Value()
public void set_Value(string value)
private string GetName(string oid)
private string GetValue(string name)
}
public System.Security.Cryptography.OidCollection : object {
private ArrayList _list
private bool _readOnly
public int Count
public bool IsSynchronized
public Oid Item
public Oid Item
public object SyncRoot
internal bool ReadOnly
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsSynchronized()
public Oid get_Item(int index)
public Oid get_Item(string oid)
public object get_SyncRoot()
public int Add(Oid oid)
public void CopyTo(Oid[] array, int index)
public OidEnumerator GetEnumerator()
internal bool get_ReadOnly()
internal void set_ReadOnly(bool value)
internal OidCollection ReadOnlyCopy()
}
public System.Security.Cryptography.OidEnumerator : object {
private OidCollection _collection
private int _position
private object System.Collections.IEnumerator.Current
public Oid Current
internal void .ctor(OidCollection collection)
private object System.Collections.IEnumerator.get_Current()
public Oid get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
public int value__
public OpenFlags ReadOnly
public OpenFlags ReadWrite
public OpenFlags MaxAllowed
public OpenFlags OpenExistingOnly
public OpenFlags IncludeArchived
}
public System.Security.Cryptography.X509Certificates.PublicKey : object {
private string rsaOid
private string dsaOid
private AsymmetricAlgorithm _key
private AsnEncodedData _keyValue
private AsnEncodedData _params
private Oid _oid
private Dictionary`2<string, int> <>f__switch$map16
public AsnEncodedData EncodedKeyValue
public AsnEncodedData EncodedParameters
public AsymmetricAlgorithm Key
public Oid Oid
public void .ctor(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue)
internal void .ctor(X509Certificate certificate)
public AsnEncodedData get_EncodedKeyValue()
public AsnEncodedData get_EncodedParameters()
public AsymmetricAlgorithm get_Key()
public Oid get_Oid()
private Byte[] GetUnsignedBigInteger(Byte[] integer)
internal DSA DecodeDSA(Byte[] rawPublicKey, Byte[] rawParameters)
internal RSA DecodeRSA(Byte[] rawPublicKey)
}
public System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
public int value__
public StoreLocation CurrentUser
public StoreLocation LocalMachine
}
public System.Security.Cryptography.X509Certificates.StoreName : Enum {
public int value__
public StoreName AddressBook
public StoreName AuthRoot
public StoreName CertificateAuthority
public StoreName Disallowed
public StoreName My
public StoreName Root
public StoreName TrustedPeople
public StoreName TrustedPublisher
}
public System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
private X500DistinguishedNameFlags AllFlags
private string name
public string Name
public void .ctor(AsnEncodedData encodedDistinguishedName)
public void .ctor(Byte[] encodedDistinguishedName)
public void .ctor(string distinguishedName)
public void .ctor(string distinguishedName, X500DistinguishedNameFlags flag)
public void .ctor(X500DistinguishedName distinguishedName)
public string get_Name()
public string Decode(X500DistinguishedNameFlags flag)
public string Format(bool multiLine)
private string GetSeparator(X500DistinguishedNameFlags flag)
private void DecodeRawData()
private string Canonize(string s)
internal bool AreEqual(X500DistinguishedName name1, X500DistinguishedName name2)
}
public System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
public int value__
public X500DistinguishedNameFlags None
public X500DistinguishedNameFlags Reversed
public X500DistinguishedNameFlags UseSemicolons
public X500DistinguishedNameFlags DoNotUsePlusSign
public X500DistinguishedNameFlags DoNotUseQuotes
public X500DistinguishedNameFlags UseCommas
public X500DistinguishedNameFlags UseNewLines
public X500DistinguishedNameFlags UseUTF8Encoding
public X500DistinguishedNameFlags UseT61Encoding
public X500DistinguishedNameFlags ForceUTF8Encoding
}
public System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
internal string oid
internal string friendlyName
private bool _certificateAuthority
private bool _hasPathLengthConstraint
private int _pathLengthConstraint
private AsnDecodeStatus _status
public bool CertificateAuthority
public bool HasPathLengthConstraint
public int PathLengthConstraint
public void .ctor(AsnEncodedData encodedBasicConstraints, bool critical)
public void .ctor(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical)
public bool get_CertificateAuthority()
public bool get_HasPathLengthConstraint()
public int get_PathLengthConstraint()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
private bool _archived
private X509ExtensionCollection _extensions
private string _name
private string _serial
private PublicKey _publicKey
private X500DistinguishedName issuer_name
private X500DistinguishedName subject_name
private Oid signature_algorithm
private X509Certificate _cert
private string empty_error
private Byte[] commonName
private Byte[] email
private Byte[] signedData
public bool Archived
public X509ExtensionCollection Extensions
public string FriendlyName
public bool HasPrivateKey
public X500DistinguishedName IssuerName
public DateTime NotAfter
public DateTime NotBefore
public AsymmetricAlgorithm PrivateKey
public PublicKey PublicKey
public Byte[] RawData
public string SerialNumber
public Oid SignatureAlgorithm
public X500DistinguishedName SubjectName
public string Thumbprint
public int Version
internal X509Certificate MonoCertificate
public void .ctor(Byte[] rawData)
public void .ctor(Byte[] rawData, string password)
public void .ctor(Byte[] rawData, SecureString password)
public void .ctor(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(string fileName)
public void .ctor(string fileName, string password)
public void .ctor(string fileName, SecureString password)
public void .ctor(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(IntPtr handle)
public void .ctor(X509Certificate certificate)
public bool get_Archived()
public void set_Archived(bool value)
public X509ExtensionCollection get_Extensions()
public string get_FriendlyName()
public void set_FriendlyName(string value)
public bool get_HasPrivateKey()
public X500DistinguishedName get_IssuerName()
public DateTime get_NotAfter()
public DateTime get_NotBefore()
public AsymmetricAlgorithm get_PrivateKey()
public void set_PrivateKey(AsymmetricAlgorithm value)
public PublicKey get_PublicKey()
public Byte[] get_RawData()
public string get_SerialNumber()
public Oid get_SignatureAlgorithm()
public X500DistinguishedName get_SubjectName()
public string get_Thumbprint()
public int get_Version()
public string GetNameInfo(X509NameType nameType, bool forIssuer)
private ASN1 Find(Byte[] oid, ASN1 dn)
private string GetValueAsString(ASN1 pair)
private void ImportPkcs12(Byte[] rawData, string password)
public void Import(Byte[] rawData)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName)
public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
private Byte[] Load(string fileName)
public void Reset()
public string ToString()
public string ToString(bool verbose)
private void AppendBuffer(StringBuilder sb, Byte[] buffer)
public bool Verify()
public X509ContentType GetCertContentType(Byte[] rawData)
public X509ContentType GetCertContentType(string fileName)
internal X509Certificate get_MonoCertificate()
}
public System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
public X509Certificate2 Item
public void .ctor(X509Certificate2Collection certificates)
public void .ctor(X509Certificate2 certificate)
public void .ctor(X509Certificate2[] certificates)
public X509Certificate2 get_Item(int index)
public void set_Item(int index, X509Certificate2 value)
public int Add(X509Certificate2 certificate)
public void AddRange(X509Certificate2[] certificates)
public void AddRange(X509Certificate2Collection certificates)
public bool Contains(X509Certificate2 certificate)
public Byte[] Export(X509ContentType contentType)
public Byte[] Export(X509ContentType contentType, string password)
public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly)
public X509Certificate2Enumerator GetEnumerator()
public void Import(Byte[] rawData)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName)
public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void Insert(int index, X509Certificate2 certificate)
public void Remove(X509Certificate2 certificate)
public void RemoveRange(X509Certificate2[] certificates)
public void RemoveRange(X509Certificate2Collection certificates)
}
public System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
private IEnumerator enumerator
private object System.Collections.IEnumerator.Current
public X509Certificate2 Current
internal void .ctor(X509Certificate2Collection collection)
private object System.Collections.IEnumerator.get_Current()
private bool System.Collections.IEnumerator.MoveNext()
private void System.Collections.IEnumerator.Reset()
public X509Certificate2 get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
public X509Certificate Item
public void .ctor(X509Certificate[] value)
public void .ctor(X509CertificateCollection value)
public X509Certificate get_Item(int index)
public void set_Item(int index, X509Certificate value)
public int Add(X509Certificate value)
public void AddRange(X509Certificate[] value)
public void AddRange(X509CertificateCollection value)
public bool Contains(X509Certificate value)
public void CopyTo(X509Certificate[] array, int index)
public X509CertificateEnumerator GetEnumerator()
public int GetHashCode()
public int IndexOf(X509Certificate value)
public void Insert(int index, X509Certificate value)
public void Remove(X509Certificate value)
private bool Compare(Byte[] array1, Byte[] array2)
}
public System.Security.Cryptography.X509Certificates.X509Chain : object {
private StoreLocation location
private X509ChainElementCollection elements
private X509ChainPolicy policy
private X509ChainStatus[] status
private X509ChainStatus[] Empty
private int max_path_length
private X500DistinguishedName working_issuer_name
private AsymmetricAlgorithm working_public_key
private X509ChainElement bce_restriction
private X509Store roots
private X509Store cas
private X509Certificate2Collection collection
private Dictionary`2<string, int> <>f__switch$map17
private Dictionary`2<string, int> <>f__switch$map18
private Dictionary`2<string, int> <>f__switch$map19
public IntPtr ChainContext
public X509ChainElementCollection ChainElements
public X509ChainPolicy ChainPolicy
public X509ChainStatus[] ChainStatus
private X509Store Roots
private X509Store CertificateAuthorities
private X509Certificate2Collection CertificateCollection
public void .ctor(bool useMachineContext)
public void .ctor(IntPtr chainContext)
public IntPtr get_ChainContext()
public X509ChainElementCollection get_ChainElements()
public X509ChainPolicy get_ChainPolicy()
public void set_ChainPolicy(X509ChainPolicy value)
public X509ChainStatus[] get_ChainStatus()
public bool Build(X509Certificate2 certificate)
public void Reset()
public X509Chain Create()
private X509Store get_Roots()
private X509Store get_CertificateAuthorities()
private X509Certificate2Collection get_CertificateCollection()
private X509ChainStatusFlags BuildChainFrom(X509Certificate2 certificate)
private X509Certificate2 SelectBestFromCollection(X509Certificate2 child, X509Certificate2Collection c)
private X509Certificate2 FindParent(X509Certificate2 certificate)
private bool IsChainComplete(X509Certificate2 certificate)
private bool IsSelfIssued(X509Certificate2 certificate)
private void ValidateChain(X509ChainStatusFlags flag)
private void Process(int n)
private void PrepareForNextCertificate(int n)
private void WrapUp()
private void ProcessCertificateExtensions(X509ChainElement element)
private bool IsSignedWith(X509Certificate2 signed, AsymmetricAlgorithm pubkey)
private string GetSubjectKeyIdentifier(X509Certificate2 certificate)
private string GetAuthorityKeyIdentifier(X509Certificate2 certificate)
private string GetAuthorityKeyIdentifier(X509Crl crl)
private string GetAuthorityKeyIdentifier(X509Extension ext)
private void CheckRevocationOnChain(X509ChainStatusFlags flag)
private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, int ca, bool online)
private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, X509Certificate2 ca_cert, bool online)
private X509Crl FindCrl(X509Certificate2 caCertificate)
private bool ProcessCrlExtensions(X509Crl crl)
private bool ProcessCrlEntryExtensions(X509CrlEntry entry)
}
public System.Security.Cryptography.X509Certificates.X509ChainElement : object {
private X509Certificate2 certificate
private X509ChainStatus[] status
private string info
private X509ChainStatusFlags compressed_status_flags
public X509Certificate2 Certificate
public X509ChainStatus[] ChainElementStatus
public string Information
internal X509ChainStatusFlags StatusFlags
internal void .ctor(X509Certificate2 certificate)
public X509Certificate2 get_Certificate()
public X509ChainStatus[] get_ChainElementStatus()
public string get_Information()
internal X509ChainStatusFlags get_StatusFlags()
internal void set_StatusFlags(X509ChainStatusFlags value)
private int Count(X509ChainStatusFlags flags)
private void Set(X509ChainStatus[] status, Int32& position, X509ChainStatusFlags flags, X509ChainStatusFlags mask)
internal void UncompressFlags()
}
public System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public X509ChainElement Item
public object SyncRoot
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsSynchronized()
public X509ChainElement get_Item(int index)
public object get_SyncRoot()
public void CopyTo(X509ChainElement[] array, int index)
public X509ChainElementEnumerator GetEnumerator()
internal void Add(X509Certificate2 certificate)
internal void Clear()
internal bool Contains(X509Certificate2 certificate)
}
public System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
private IEnumerator enumerator
private object System.Collections.IEnumerator.Current
public X509ChainElement Current
internal void .ctor(IEnumerable enumerable)
private object System.Collections.IEnumerator.get_Current()
public X509ChainElement get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
private OidCollection apps
private OidCollection cert
private X509Certificate2Collection store
private X509RevocationFlag rflag
private X509RevocationMode mode
private TimeSpan timeout
private X509VerificationFlags vflags
private DateTime vtime
public OidCollection ApplicationPolicy
public OidCollection CertificatePolicy
public X509Certificate2Collection ExtraStore
public X509RevocationFlag RevocationFlag
public X509RevocationMode RevocationMode
public TimeSpan UrlRetrievalTimeout
public X509VerificationFlags VerificationFlags
public DateTime VerificationTime
public OidCollection get_ApplicationPolicy()
public OidCollection get_CertificatePolicy()
public X509Certificate2Collection get_ExtraStore()
public X509RevocationFlag get_RevocationFlag()
public void set_RevocationFlag(X509RevocationFlag value)
public X509RevocationMode get_RevocationMode()
public void set_RevocationMode(X509RevocationMode value)
public TimeSpan get_UrlRetrievalTimeout()
public void set_UrlRetrievalTimeout(TimeSpan value)
public X509VerificationFlags get_VerificationFlags()
public void set_VerificationFlags(X509VerificationFlags value)
public DateTime get_VerificationTime()
public void set_VerificationTime(DateTime value)
public void Reset()
}
public System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
private X509ChainStatusFlags status
private string info
public X509ChainStatusFlags Status
public string StatusInformation
internal void .ctor(X509ChainStatusFlags flag)
public X509ChainStatusFlags get_Status()
public void set_Status(X509ChainStatusFlags value)
public string get_StatusInformation()
public void set_StatusInformation(string value)
internal string GetInformation(X509ChainStatusFlags flags)
}
public System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
public int value__
public X509ChainStatusFlags NoError
public X509ChainStatusFlags NotTimeValid
public X509ChainStatusFlags NotTimeNested
public X509ChainStatusFlags Revoked
public X509ChainStatusFlags NotSignatureValid
public X509ChainStatusFlags NotValidForUsage
public X509ChainStatusFlags UntrustedRoot
public X509ChainStatusFlags RevocationStatusUnknown
public X509ChainStatusFlags Cyclic
public X509ChainStatusFlags InvalidExtension
public X509ChainStatusFlags InvalidPolicyConstraints
public X509ChainStatusFlags InvalidBasicConstraints
public X509ChainStatusFlags InvalidNameConstraints
public X509ChainStatusFlags HasNotSupportedNameConstraint
public X509ChainStatusFlags HasNotDefinedNameConstraint
public X509ChainStatusFlags HasNotPermittedNameConstraint
public X509ChainStatusFlags HasExcludedNameConstraint
public X509ChainStatusFlags PartialChain
public X509ChainStatusFlags CtlNotTimeValid
public X509ChainStatusFlags CtlNotSignatureValid
public X509ChainStatusFlags CtlNotValidForUsage
public X509ChainStatusFlags OfflineRevocation
public X509ChainStatusFlags NoIssuanceChainPolicy
}
public System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
internal string oid
internal string friendlyName
private OidCollection _enhKeyUsage
private AsnDecodeStatus _status
private Dictionary`2<string, int> <>f__switch$map1A
public OidCollection EnhancedKeyUsages
public void .ctor(AsnEncodedData encodedEnhancedKeyUsages, bool critical)
public void .ctor(OidCollection enhancedKeyUsages, bool critical)
public OidCollection get_EnhancedKeyUsages()
public void CopyFrom(AsnEncodedData asnEncodedData)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
private bool _critical
public bool Critical
public void .ctor(AsnEncodedData encodedExtension, bool critical)
public void .ctor(Oid oid, Byte[] rawData, bool critical)
public void .ctor(string oid, Byte[] rawData, bool critical)
public bool get_Critical()
public void set_Critical(bool value)
public void CopyFrom(AsnEncodedData asnEncodedData)
internal string FormatUnkownData(Byte[] data)
}
public System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public object SyncRoot
public X509Extension Item
public X509Extension Item
internal void .ctor(X509Certificate cert)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public X509Extension get_Item(int index)
public X509Extension get_Item(string oid)
public int Add(X509Extension extension)
public void CopyTo(X509Extension[] array, int index)
public X509ExtensionEnumerator GetEnumerator()
}
public System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
private IEnumerator enumerator
private object System.Collections.IEnumerator.Current
public X509Extension Current
internal void .ctor(ArrayList list)
private object System.Collections.IEnumerator.get_Current()
public X509Extension get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Cryptography.X509Certificates.X509FindType : Enum {
public int value__
public X509FindType FindByThumbprint
public X509FindType FindBySubjectName
public X509FindType FindBySubjectDistinguishedName
public X509FindType FindByIssuerName
public X509FindType FindByIssuerDistinguishedName
public X509FindType FindBySerialNumber
public X509FindType FindByTimeValid
public X509FindType FindByTimeNotYetValid
public X509FindType FindByTimeExpired
public X509FindType FindByTemplateName
public X509FindType FindByApplicationPolicy
public X509FindType FindByCertificatePolicy
public X509FindType FindByExtension
public X509FindType FindByKeyUsage
public X509FindType FindBySubjectKeyIdentifier
}
public System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
public int value__
public X509IncludeOption None
public X509IncludeOption ExcludeRoot
public X509IncludeOption EndCertOnly
public X509IncludeOption WholeChain
}
public System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
internal string oid
internal string friendlyName
internal X509KeyUsageFlags all
private X509KeyUsageFlags _keyUsages
private AsnDecodeStatus _status
public X509KeyUsageFlags KeyUsages
public void .ctor(AsnEncodedData encodedKeyUsage, bool critical)
public void .ctor(X509KeyUsageFlags keyUsages, bool critical)
public X509KeyUsageFlags get_KeyUsages()
public void CopyFrom(AsnEncodedData encodedData)
internal X509KeyUsageFlags GetValidFlags(X509KeyUsageFlags flags)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
public int value__
public X509KeyUsageFlags None
public X509KeyUsageFlags EncipherOnly
public X509KeyUsageFlags CrlSign
public X509KeyUsageFlags KeyCertSign
public X509KeyUsageFlags KeyAgreement
public X509KeyUsageFlags DataEncipherment
public X509KeyUsageFlags KeyEncipherment
public X509KeyUsageFlags NonRepudiation
public X509KeyUsageFlags DigitalSignature
public X509KeyUsageFlags DecipherOnly
}
public System.Security.Cryptography.X509Certificates.X509NameType : Enum {
public int value__
public X509NameType SimpleName
public X509NameType EmailName
public X509NameType UpnName
public X509NameType DnsName
public X509NameType DnsFromAlternativeName
public X509NameType UrlName
}
public System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
public int value__
public X509RevocationFlag EndCertificateOnly
public X509RevocationFlag EntireChain
public X509RevocationFlag ExcludeRoot
}
public System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
public int value__
public X509RevocationMode NoCheck
public X509RevocationMode Online
public X509RevocationMode Offline
}
public System.Security.Cryptography.X509Certificates.X509Store : object {
private string _name
private StoreLocation _location
private X509Certificate2Collection list
private OpenFlags _flags
private X509Store store
private Dictionary`2<string, int> <>f__switch$map1B
public X509Certificate2Collection Certificates
public StoreLocation Location
public string Name
private X509Stores Factory
private bool IsOpen
private bool IsReadOnly
internal X509Store Store
public IntPtr StoreHandle
public void .ctor(string storeName)
public void .ctor(StoreName storeName)
public void .ctor(StoreLocation storeLocation)
public void .ctor(StoreName storeName, StoreLocation storeLocation)
public void .ctor(IntPtr storeHandle)
public void .ctor(string storeName, StoreLocation storeLocation)
public X509Certificate2Collection get_Certificates()
public StoreLocation get_Location()
public string get_Name()
private X509Stores get_Factory()
private bool get_IsOpen()
private bool get_IsReadOnly()
internal X509Store get_Store()
public IntPtr get_StoreHandle()
public void Add(X509Certificate2 certificate)
public void AddRange(X509Certificate2Collection certificates)
public void Close()
public void Open(OpenFlags flags)
public void Remove(X509Certificate2 certificate)
public void RemoveRange(X509Certificate2Collection certificates)
private bool Exists(X509Certificate2 certificate)
}
public System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
internal string oid
internal string friendlyName
private Byte[] _subjectKeyIdentifier
private string _ski
private AsnDecodeStatus _status
public string SubjectKeyIdentifier
public void .ctor(AsnEncodedData encodedSubjectKeyIdentifier, bool critical)
public void .ctor(Byte[] subjectKeyIdentifier, bool critical)
public void .ctor(string subjectKeyIdentifier, bool critical)
public void .ctor(PublicKey key, bool critical)
public void .ctor(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical)
public string get_SubjectKeyIdentifier()
public void CopyFrom(AsnEncodedData encodedData)
internal byte FromHexChar(char c)
internal byte FromHexChars(char c1, char c2)
internal Byte[] FromHex(string hex)
internal AsnDecodeStatus Decode(Byte[] extension)
internal Byte[] Encode()
internal string ToString(bool multiLine)
}
public System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
public int value__
public X509SubjectKeyIdentifierHashAlgorithm Sha1
public X509SubjectKeyIdentifierHashAlgorithm ShortSha1
public X509SubjectKeyIdentifierHashAlgorithm CapiSha1
}
public System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
public int value__
public X509VerificationFlags NoFlag
public X509VerificationFlags IgnoreNotTimeValid
public X509VerificationFlags IgnoreCtlNotTimeValid
public X509VerificationFlags IgnoreNotTimeNested
public X509VerificationFlags IgnoreInvalidBasicConstraints
public X509VerificationFlags AllowUnknownCertificateAuthority
public X509VerificationFlags IgnoreWrongUsage
public X509VerificationFlags IgnoreInvalidName
public X509VerificationFlags IgnoreInvalidPolicy
public X509VerificationFlags IgnoreEndRevocationUnknown
public X509VerificationFlags IgnoreCtlSignerRevocationUnknown
public X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown
public X509VerificationFlags IgnoreRootRevocationUnknown
public X509VerificationFlags AllFlags
}
internal System.Security.Permissions.PermissionHelper : object {
internal SecurityElement Element(Type type, int version)
internal PermissionState CheckPermissionState(PermissionState state, bool allowUnrestricted)
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
internal bool IsUnrestricted(SecurityElement se)
internal void ThrowInvalidPermission(IPermission target, Type expected)
}
public System.Security.Permissions.ResourcePermissionBase : CodeAccessPermission {
private int version
public string Any
public string Local
private ArrayList _list
private bool _unrestricted
private Type _type
private String[] _tags
private Char[] invalidChars
protected Type PermissionAccessType
protected String[] TagNames
protected void .ctor(PermissionState state)
protected Type get_PermissionAccessType()
protected void set_PermissionAccessType(Type value)
protected String[] get_TagNames()
protected void set_TagNames(String[] value)
protected void AddPermissionAccess(ResourcePermissionBaseEntry entry)
protected void Clear()
public IPermission Copy()
public void FromXml(SecurityElement securityElement)
protected ResourcePermissionBaseEntry[] GetPermissionEntries()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
protected void RemovePermissionAccess(ResourcePermissionBaseEntry entry)
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private bool IsEmpty()
private ResourcePermissionBase Cast(IPermission target)
internal void CheckEntry(ResourcePermissionBaseEntry entry)
internal bool Equals(ResourcePermissionBaseEntry entry1, ResourcePermissionBaseEntry entry2)
internal bool Exists(ResourcePermissionBaseEntry entry)
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
internal void ValidateMachineName(string name)
internal ResourcePermissionBase CreateFromType(Type type, bool unrestricted)
}
public System.Security.Permissions.ResourcePermissionBaseEntry : object {
private int permissionAccess
private String[] permissionAccessPath
public int PermissionAccess
public String[] PermissionAccessPath
public void .ctor(int permissionAccess, String[] permissionAccessPath)
public int get_PermissionAccess()
public String[] get_PermissionAccessPath()
}
public System.Security.Permissions.StorePermission : CodeAccessPermission {
private int version
private StorePermissionFlags _flags
public StorePermissionFlags Flags
public void .ctor(PermissionState state)
public void .ctor(StorePermissionFlags flags)
public StorePermissionFlags get_Flags()
public void set_Flags(StorePermissionFlags value)
public bool IsUnrestricted()
public IPermission Copy()
public IPermission Intersect(IPermission target)
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement e)
public SecurityElement ToXml()
private StorePermission Cast(IPermission target)
}
public System.Security.Permissions.StorePermissionAttribute : CodeAccessSecurityAttribute {
private StorePermissionFlags _flags
public StorePermissionFlags Flags
public bool AddToStore
public bool CreateStore
public bool DeleteStore
public bool EnumerateCertificates
public bool EnumerateStores
public bool OpenStore
public bool RemoveFromStore
public void .ctor(SecurityAction action)
public StorePermissionFlags get_Flags()
public void set_Flags(StorePermissionFlags value)
public bool get_AddToStore()
public void set_AddToStore(bool value)
public bool get_CreateStore()
public void set_CreateStore(bool value)
public bool get_DeleteStore()
public void set_DeleteStore(bool value)
public bool get_EnumerateCertificates()
public void set_EnumerateCertificates(bool value)
public bool get_EnumerateStores()
public void set_EnumerateStores(bool value)
public bool get_OpenStore()
public void set_OpenStore(bool value)
public bool get_RemoveFromStore()
public void set_RemoveFromStore(bool value)
public IPermission CreatePermission()
}
public System.Security.Permissions.StorePermissionFlags : Enum {
public int value__
public StorePermissionFlags NoFlags
public StorePermissionFlags CreateStore
public StorePermissionFlags DeleteStore
public StorePermissionFlags EnumerateStores
public StorePermissionFlags OpenStore
public StorePermissionFlags AddToStore
public StorePermissionFlags RemoveFromStore
public StorePermissionFlags EnumerateCertificates
public StorePermissionFlags AllFlags
}
internal System.SRDescriptionAttribute : DescriptionAttribute {
private bool isReplaced
public string Description
public void .ctor(string description)
public string get_Description()
}
internal System.Text.RegularExpressions.BaseMachine : object {
protected bool needs_groups_or_captures
public string Replace(Regex regex, string input, string replacement, int count, int startat)
public String[] Split(Regex regex, string input, int count, int startat)
public Match Scan(Regex regex, string text, int start, int end)
public string Result(string replacement, Match match)
internal string LTRReplace(Regex regex, string input, MatchAppendEvaluator evaluator, int count, int startat)
internal string LTRReplace(Regex regex, string input, MatchAppendEvaluator evaluator, int count, int startat, bool needs_groups_or_captures)
internal string RTLReplace(Regex regex, string input, MatchEvaluator evaluator, int count, int startat)
}
public System.Text.RegularExpressions.Capture : object {
internal int index
internal int length
internal string text
public int Index
public int Length
public string Value
internal string Text
internal void .ctor(string text)
internal void .ctor(string text, int index, int length)
public int get_Index()
public int get_Length()
public string get_Value()
public string ToString()
internal string get_Text()
}
public System.Text.RegularExpressions.CaptureCollection : object {
private Capture[] list
public int Count
public bool IsReadOnly
public bool IsSynchronized
public Capture Item
public object SyncRoot
internal void .ctor(int n)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public Capture get_Item(int i)
internal void SetValue(Capture cap, int i)
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
}
internal System.Text.RegularExpressions.Category : Enum {
public ushort value__
public Category None
public Category Any
public Category AnySingleline
public Category Word
public Category Digit
public Category WhiteSpace
public Category EcmaAny
public Category EcmaAnySingleline
public Category EcmaWord
public Category EcmaDigit
public Category EcmaWhiteSpace
public Category UnicodeL
public Category UnicodeM
public Category UnicodeN
public Category UnicodeZ
public Category UnicodeP
public Category UnicodeS
public Category UnicodeC
public Category UnicodeLu
public Category UnicodeLl
public Category UnicodeLt
public Category UnicodeLm
public Category UnicodeLo
public Category UnicodeMn
public Category UnicodeMe
public Category UnicodeMc
public Category UnicodeNd
public Category UnicodeNl
public Category UnicodeNo
public Category UnicodeZs
public Category UnicodeZl
public Category UnicodeZp
public Category UnicodePd
public Category UnicodePs
public Category UnicodePi
public Category UnicodePe
public Category UnicodePf
public Category UnicodePc
public Category UnicodePo
public Category UnicodeSm
public Category UnicodeSc
public Category UnicodeSk
public Category UnicodeSo
public Category UnicodeCc
public Category UnicodeCf
public Category UnicodeCo
public Category UnicodeCs
public Category UnicodeCn
public Category UnicodeBasicLatin
public Category UnicodeLatin1Supplement
public Category UnicodeLatinExtendedA
public Category UnicodeLatinExtendedB
public Category UnicodeIPAExtensions
public Category UnicodeSpacingModifierLetters
public Category UnicodeCombiningDiacriticalMarks
public Category UnicodeGreek
public Category UnicodeCyrillic
public Category UnicodeArmenian
public Category UnicodeHebrew
public Category UnicodeArabic
public Category UnicodeSyriac
public Category UnicodeThaana
public Category UnicodeDevanagari
public Category UnicodeBengali
public Category UnicodeGurmukhi
public Category UnicodeGujarati
public Category UnicodeOriya
public Category UnicodeTamil
public Category UnicodeTelugu
public Category UnicodeKannada
public Category UnicodeMalayalam
public Category UnicodeSinhala
public Category UnicodeThai
public Category UnicodeLao
public Category UnicodeTibetan
public Category UnicodeMyanmar
public Category UnicodeGeorgian
public Category UnicodeHangulJamo
public Category UnicodeEthiopic
public Category UnicodeCherokee
public Category UnicodeUnifiedCanadianAboriginalSyllabics
public Category UnicodeOgham
public Category UnicodeRunic
public Category UnicodeKhmer
public Category UnicodeMongolian
public Category UnicodeLatinExtendedAdditional
public Category UnicodeGreekExtended
public Category UnicodeGeneralPunctuation
public Category UnicodeSuperscriptsandSubscripts
public Category UnicodeCurrencySymbols
public Category UnicodeCombiningMarksforSymbols
public Category UnicodeLetterlikeSymbols
public Category UnicodeNumberForms
public Category UnicodeArrows
public Category UnicodeMathematicalOperators
public Category UnicodeMiscellaneousTechnical
public Category UnicodeControlPictures
public Category UnicodeOpticalCharacterRecognition
public Category UnicodeEnclosedAlphanumerics
public Category UnicodeBoxDrawing
public Category UnicodeBlockElements
public Category UnicodeGeometricShapes
public Category UnicodeMiscellaneousSymbols
public Category UnicodeDingbats
public Category UnicodeBraillePatterns
public Category UnicodeCJKRadicalsSupplement
public Category UnicodeKangxiRadicals
public Category UnicodeIdeographicDescriptionCharacters
public Category UnicodeCJKSymbolsandPunctuation
public Category UnicodeHiragana
public Category UnicodeKatakana
public Category UnicodeBopomofo
public Category UnicodeHangulCompatibilityJamo
public Category UnicodeKanbun
public Category UnicodeBopomofoExtended
public Category UnicodeEnclosedCJKLettersandMonths
public Category UnicodeCJKCompatibility
public Category UnicodeCJKUnifiedIdeographsExtensionA
public Category UnicodeCJKUnifiedIdeographs
public Category UnicodeYiSyllables
public Category UnicodeYiRadicals
public Category UnicodeHangulSyllables
public Category UnicodeHighSurrogates
public Category UnicodeHighPrivateUseSurrogates
public Category UnicodeLowSurrogates
public Category UnicodePrivateUse
public Category UnicodeCJKCompatibilityIdeographs
public Category UnicodeAlphabeticPresentationForms
public Category UnicodeArabicPresentationFormsA
public Category UnicodeCombiningHalfMarks
public Category UnicodeCJKCompatibilityForms
public Category UnicodeSmallFormVariants
public Category UnicodeArabicPresentationFormsB
public Category UnicodeSpecials
public Category UnicodeHalfwidthandFullwidthForms
public Category UnicodeOldItalic
public Category UnicodeGothic
public Category UnicodeDeseret
public Category UnicodeByzantineMusicalSymbols
public Category UnicodeMusicalSymbols
public Category UnicodeMathematicalAlphanumericSymbols
public Category UnicodeCJKUnifiedIdeographsExtensionB
public Category UnicodeCJKCompatibilityIdeographsSupplement
public Category UnicodeTags
public Category LastValue
}
internal System.Text.RegularExpressions.CategoryUtils : object {
public Category CategoryFromName(string name)
public bool IsCategory(Category cat, char c)
private bool IsCategory(UnicodeCategory uc, char c)
}
internal System.Text.RegularExpressions.CILCompiler : RxCompiler {
private DynamicMethod[] eval_methods
private Boolean[] eval_methods_defined
private Dictionary`2<int, int> generic_ops
private Dictionary`2<int, int> op_flags
private Dictionary`2<int, Label> labels
private FieldInfo fi_str
private FieldInfo fi_string_start
private FieldInfo fi_string_end
private FieldInfo fi_program
private FieldInfo fi_marks
private FieldInfo fi_groups
private FieldInfo fi_deep
private FieldInfo fi_stack
private FieldInfo fi_mark_start
private FieldInfo fi_mark_end
private FieldInfo fi_mark_index
private MethodInfo mi_stack_get_count
private MethodInfo mi_stack_set_count
private MethodInfo mi_stack_push
private MethodInfo mi_stack_pop
private MethodInfo mi_set_start_of_match
private MethodInfo mi_is_word_char
private MethodInfo mi_reset_groups
private MethodInfo mi_checkpoint
private MethodInfo mi_backtrack
private MethodInfo mi_open
private MethodInfo mi_close
private MethodInfo mi_get_last_defined
private MethodInfo mi_mark_get_index
private MethodInfo mi_mark_get_length
public bool trace_compile
private LocalBuilder local_textinfo
private IMachineFactory System.Text.RegularExpressions.ICompiler.GetMachineFactory()
private DynamicMethod GetEvalMethod(Byte[] program, int pc)
private MethodInfo GetMethod(Type t, string name, MethodInfo& cached)
private MethodInfo GetMethod(string name, MethodInfo& cached)
private int ReadInt(Byte[] code, int pc)
private OpFlags MakeFlags(bool negate, bool ignore, bool reverse, bool lazy)
private void EmitGenericOp(RxOp op, bool negate, bool ignore, bool reverse, bool lazy)
public void EmitOp(RxOp op, bool negate, bool ignore, bool reverse)
public void EmitOpIgnoreReverse(RxOp op, bool ignore, bool reverse)
public void EmitOpNegateReverse(RxOp op, bool negate, bool reverse)
private DynamicMethod CreateEvalMethod(Byte[] program, int pc)
private int ReadShort(Byte[] program, int pc)
private Label CreateLabelForPC(ILGenerator ilgen, int pc)
private int GetILOffset(ILGenerator ilgen)
private DynamicMethod EmitEvalMethodBody(DynamicMethod m, ILGenerator ilgen, Frame frame, Byte[] program, int pc, int end_pc, bool one_op, bool no_bump, Int32& out_pc)
}
internal System.Text.RegularExpressions.Disassembler : object {
public void DisassemblePattern(UInt16[] image)
public void DisassembleBlock(UInt16[] image, int pc, int depth)
public string DisassembleOp(UInt16[] image, int pc)
private string ReadString(UInt16[] image, int pc)
private string FormatAddress(int pc)
private string FormatSet(UInt16[] image, int pc)
private string FormatChar(char c)
}
internal System.Text.RegularExpressions.EvalDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(RxInterpreter interp, int strpos, Int32& strpos_result)
public IAsyncResult BeginInvoke(RxInterpreter interp, int strpos, Int32& strpos_result, AsyncCallback callback, object object)
public bool EndInvoke(Int32& strpos_result, IAsyncResult result)
}
internal System.Text.RegularExpressions.FactoryCache : object {
private int capacity
private Hashtable factories
private MRUList mru_list
public int Capacity
public void .ctor(int capacity)
public void Add(string pattern, RegexOptions options, IMachineFactory factory)
private void Cleanup()
public IMachineFactory Lookup(string pattern, RegexOptions options)
public int get_Capacity()
public void set_Capacity(int value)
}
public System.Text.RegularExpressions.Group : Capture {
internal Group Fail
private bool success
private CaptureCollection captures
public CaptureCollection Captures
public bool Success
internal void .ctor(string text, int index, int length, int n_caps)
internal void .ctor(string text, int index, int length)
public Group Synchronized(Group inner)
public CaptureCollection get_Captures()
public bool get_Success()
}
public System.Text.RegularExpressions.GroupCollection : object {
private Group[] list
private int gap
public int Count
public bool IsReadOnly
public bool IsSynchronized
public Group Item
public Group Item
public object SyncRoot
internal void .ctor(int n, int gap)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public Group get_Item(int i)
internal void SetValue(Group g, int i)
public Group get_Item(string groupName)
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
}
internal System.Text.RegularExpressions.ICompiler {
public void Reset()
public IMachineFactory GetMachineFactory()
public void EmitFalse()
public void EmitTrue()
public void EmitCharacter(char c, bool negate, bool ignore, bool reverse)
public void EmitCategory(Category cat, bool negate, bool reverse)
public void EmitNotCategory(Category cat, bool negate, bool reverse)
public void EmitRange(char lo, char hi, bool negate, bool ignore, bool reverse)
public void EmitSet(char lo, BitArray set, bool negate, bool ignore, bool reverse)
public void EmitString(string str, bool ignore, bool reverse)
public void EmitPosition(Position pos)
public void EmitOpen(int gid)
public void EmitClose(int gid)
public void EmitBalanceStart(int gid, int balance, bool capture, LinkRef tail)
public void EmitBalance()
public void EmitReference(int gid, bool ignore, bool reverse)
public void EmitIfDefined(int gid, LinkRef tail)
public void EmitSub(LinkRef tail)
public void EmitTest(LinkRef yes, LinkRef tail)
public void EmitBranch(LinkRef next)
public void EmitJump(LinkRef target)
public void EmitRepeat(int min, int max, bool lazy, LinkRef until)
public void EmitUntil(LinkRef repeat)
public void EmitIn(LinkRef tail)
public void EmitInfo(int count, int min, int max)
public void EmitFastRepeat(int min, int max, bool lazy, LinkRef tail)
public void EmitAnchor(bool reverse, int offset, LinkRef tail)
public void EmitBranchEnd()
public void EmitAlternationEnd()
public LinkRef NewLink()
public void ResolveLink(LinkRef link)
}
internal System.Text.RegularExpressions.IMachine {
public Match Scan(Regex regex, string text, int start, int end)
public String[] Split(Regex regex, string input, int count, int startat)
public string Replace(Regex regex, string input, string replacement, int count, int startat)
public string Result(string replacement, Match match)
}
internal System.Text.RegularExpressions.IMachineFactory {
public IDictionary Mapping
public int GroupCount
public int Gap
public String[] NamesMapping
public IMachine NewInstance()
public IDictionary get_Mapping()
public void set_Mapping(IDictionary value)
public int get_GroupCount()
public int get_Gap()
public void set_Gap(int value)
public String[] get_NamesMapping()
public void set_NamesMapping(String[] value)
}
internal System.Text.RegularExpressions.Interpreter : BaseMachine {
private UInt16[] program
private int program_start
private string text
private int text_end
private int group_count
private int match_min
private QuickSearch qs
private int scan_ptr
private RepeatContext repeat
private RepeatContext fast
private IntStack stack
private RepeatContext deep
private Mark[] marks
private int mark_start
private int mark_end
private Int32[] groups
public void .ctor(UInt16[] program)
private int ReadProgramCount(int ptr)
public Match Scan(Regex regex, string text, int start, int end)
private void Reset()
private bool Eval(Mode mode, Int32& ref_ptr, int pc)
private bool EvalChar(Mode mode, Int32& ptr, Int32& pc, bool multi)
private bool TryMatch(Int32& ref_ptr, int pc)
private bool IsPosition(Position pos, int ptr)
private bool IsWordChar(char c)
private string GetString(int pc)
private void Open(int gid, int ptr)
private void Close(int gid, int ptr)
private bool Balance(int gid, int balance_gid, bool capture, int ptr)
private int Checkpoint()
private void Backtrack(int cp)
private void ResetGroups()
private int GetLastDefined(int gid)
private int CreateMark(int previous)
private void GetGroupInfo(int gid, Int32& first_mark_index, Int32& n_caps)
private void PopulateGroup(Group g, int first_mark_index, int n_caps)
private Match GenerateMatch(Regex regex)
}
internal System.Text.RegularExpressions.InterpreterFactory : object {
private IDictionary mapping
private UInt16[] pattern
private String[] namesMapping
private int gap
public int GroupCount
public int Gap
public IDictionary Mapping
public String[] NamesMapping
public void .ctor(UInt16[] pattern)
public IMachine NewInstance()
public int get_GroupCount()
public int get_Gap()
public void set_Gap(int value)
public IDictionary get_Mapping()
public void set_Mapping(IDictionary value)
public String[] get_NamesMapping()
public void set_NamesMapping(String[] value)
}
internal System.Text.RegularExpressions.Interval : ValueType {
public int low
public int high
public bool contiguous
public Interval Empty
public Interval Entire
public bool IsDiscontiguous
public bool IsSingleton
public bool IsRange
public bool IsEmpty
public int Size
public void .ctor(int low, int high)
public Interval get_Empty()
public Interval get_Entire()
public bool get_IsDiscontiguous()
public bool get_IsSingleton()
public bool get_IsRange()
public bool get_IsEmpty()
public int get_Size()
public bool IsDisjoint(Interval i)
public bool IsAdjacent(Interval i)
public bool Contains(Interval i)
public bool Contains(int i)
public bool Intersects(Interval i)
public void Merge(Interval i)
public void Intersect(Interval i)
public int CompareTo(object o)
public string ToString()
}
internal System.Text.RegularExpressions.IntervalCollection : object {
private ArrayList intervals
public Interval Item
public int Count
public bool IsSynchronized
public object SyncRoot
public Interval get_Item(int i)
public void set_Item(int i, Interval value)
public void Add(Interval i)
public void Clear()
public void Sort()
public void Normalize()
public IntervalCollection GetMetaCollection(CostDelegate cost_del)
private void Optimize(int begin, int end, IntervalCollection meta, CostDelegate cost_del)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
}
internal System.Text.RegularExpressions.LinkStack : LinkRef {
private Stack stack
public void Push()
public bool Pop()
protected object GetCurrent()
protected void SetCurrent(object l)
}
internal System.Text.RegularExpressions.Mark : ValueType {
public int Start
public int End
public int Previous
public bool IsDefined
public int Index
public int Length
public bool get_IsDefined()
public int get_Index()
public int get_Length()
}
public System.Text.RegularExpressions.Match : Group {
private Regex regex
private IMachine machine
private int text_length
private GroupCollection groups
private Match empty
public Match Empty
public GroupCollection Groups
internal Regex Regex
internal void .ctor(Regex regex, IMachine machine, string text, int text_length, int n_groups, int index, int length)
internal void .ctor(Regex regex, IMachine machine, string text, int text_length, int n_groups, int index, int length, int n_caps)
public Match get_Empty()
public Match Synchronized(Match inner)
public GroupCollection get_Groups()
public Match NextMatch()
public string Result(string replacement)
internal Regex get_Regex()
}
public System.Text.RegularExpressions.MatchCollection : object {
private Match current
private ArrayList list
public int Count
public bool IsReadOnly
public bool IsSynchronized
public Match Item
public object SyncRoot
private ICollection FullList
internal void .ctor(Match start)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public Match get_Item(int i)
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
private bool TryToGet(int i)
private ICollection get_FullList()
}
public System.Text.RegularExpressions.MatchEvaluator : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public string Invoke(Match match)
public IAsyncResult BeginInvoke(Match match, AsyncCallback callback, object object)
public string EndInvoke(IAsyncResult result)
}
internal System.Text.RegularExpressions.MRUList : object {
private Node head
private Node tail
public void Use(object o)
public object Evict()
}
internal System.Text.RegularExpressions.OpCode : Enum {
public ushort value__
public OpCode False
public OpCode True
public OpCode Position
public OpCode String
public OpCode Reference
public OpCode Character
public OpCode Category
public OpCode NotCategory
public OpCode Range
public OpCode Set
public OpCode In
public OpCode Open
public OpCode Close
public OpCode Balance
public OpCode BalanceStart
public OpCode IfDefined
public OpCode Sub
public OpCode Test
public OpCode Branch
public OpCode Jump
public OpCode Repeat
public OpCode Until
public OpCode FastRepeat
public OpCode Anchor
public OpCode Info
}
internal System.Text.RegularExpressions.OpFlags : Enum {
public ushort value__
public OpFlags None
public OpFlags Negate
public OpFlags IgnoreCase
public OpFlags RightToLeft
public OpFlags Lazy
}
internal System.Text.RegularExpressions.PatternCompiler : object {
private ArrayList pgm
private int CurrentAddress
public ushort EncodeOp(OpCode op, OpFlags flags)
public void DecodeOp(ushort word, OpCode& op, OpFlags& flags)
public void Reset()
public IMachineFactory GetMachineFactory()
public void EmitFalse()
public void EmitTrue()
private void EmitCount(int count)
public void EmitCharacter(char c, bool negate, bool ignore, bool reverse)
public void EmitCategory(Category cat, bool negate, bool reverse)
public void EmitNotCategory(Category cat, bool negate, bool reverse)
public void EmitRange(char lo, char hi, bool negate, bool ignore, bool reverse)
public void EmitSet(char lo, BitArray set, bool negate, bool ignore, bool reverse)
public void EmitString(string str, bool ignore, bool reverse)
public void EmitPosition(Position pos)
public void EmitOpen(int gid)
public void EmitClose(int gid)
public void EmitBalanceStart(int gid, int balance, bool capture, LinkRef tail)
public void EmitBalance()
public void EmitReference(int gid, bool ignore, bool reverse)
public void EmitIfDefined(int gid, LinkRef tail)
public void EmitSub(LinkRef tail)
public void EmitTest(LinkRef yes, LinkRef tail)
public void EmitBranch(LinkRef next)
public void EmitJump(LinkRef target)
public void EmitRepeat(int min, int max, bool lazy, LinkRef until)
public void EmitUntil(LinkRef repeat)
public void EmitFastRepeat(int min, int max, bool lazy, LinkRef tail)
public void EmitIn(LinkRef tail)
public void EmitAnchor(bool reverse, int offset, LinkRef tail)
public void EmitInfo(int count, int min, int max)
public LinkRef NewLink()
public void ResolveLink(LinkRef lref)
public void EmitBranchEnd()
public void EmitAlternationEnd()
private OpFlags MakeFlags(bool negate, bool ignore, bool reverse, bool lazy)
private void Emit(OpCode op)
private void Emit(OpCode op, OpFlags flags)
private void Emit(ushort word)
private int get_CurrentAddress()
private void BeginLink(LinkRef lref)
private void EmitLink(LinkRef lref)
}
internal System.Text.RegularExpressions.Position : Enum {
public ushort value__
public Position Any
public Position Start
public Position StartOfString
public Position StartOfLine
public Position StartOfScan
public Position End
public Position EndOfString
public Position EndOfLine
public Position Boundary
public Position NonBoundary
}
internal System.Text.RegularExpressions.QuickSearch : object {
private string str
private int len
private bool ignore
private bool reverse
private Byte[] shift
private Hashtable shiftExtended
private int THRESHOLD
public string String
public int Length
public bool IgnoreCase
public void .ctor(string str, bool ignore)
public void .ctor(string str, bool ignore, bool reverse)
public string get_String()
public int get_Length()
public bool get_IgnoreCase()
public int Search(string text, int start, int end)
private void SetupShiftTable()
private int GetShiftDistance(char c)
private char GetChar(char c)
}
public System.Text.RegularExpressions.Regex : object {
private FactoryCache cache
private bool old_rx
private IMachineFactory machineFactory
private IDictionary mapping
private int group_count
private int gap
private bool refsInitialized
private String[] group_names
private Int32[] group_numbers
protected internal string pattern
protected internal RegexOptions roptions
protected internal Hashtable capnames
protected internal Hashtable caps
protected internal RegexRunnerFactory factory
protected internal int capsize
protected internal String[] capslist
public int CacheSize
public RegexOptions Options
public bool RightToLeft
internal int GroupCount
internal int Gap
private Int32[] GroupNumbers
public void .ctor(string pattern)
public void .ctor(string pattern, RegexOptions options)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public void CompileToAssembly(RegexCompilationInfo[] regexes, AssemblyName aname)
public void CompileToAssembly(RegexCompilationInfo[] regexes, AssemblyName aname, CustomAttributeBuilder[] attribs)
public void CompileToAssembly(RegexCompilationInfo[] regexes, AssemblyName aname, CustomAttributeBuilder[] attribs, string resourceFile)
public string Escape(string str)
public string Unescape(string str)
public bool IsMatch(string input, string pattern)
public bool IsMatch(string input, string pattern, RegexOptions options)
public Match Match(string input, string pattern)
public Match Match(string input, string pattern, RegexOptions options)
public MatchCollection Matches(string input, string pattern)
public MatchCollection Matches(string input, string pattern, RegexOptions options)
public string Replace(string input, string pattern, MatchEvaluator evaluator)
public string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options)
public string Replace(string input, string pattern, string replacement)
public string Replace(string input, string pattern, string replacement, RegexOptions options)
public String[] Split(string input, string pattern)
public String[] Split(string input, string pattern, RegexOptions options)
public int get_CacheSize()
public void set_CacheSize(int value)
private void validate_options(RegexOptions options)
private void Init()
private void InitNewRegex()
private IMachineFactory CreateMachineFactory(string pattern, RegexOptions options)
public RegexOptions get_Options()
public bool get_RightToLeft()
public String[] GetGroupNames()
public Int32[] GetGroupNumbers()
public string GroupNameFromNumber(int i)
public int GroupNumberFromName(string name)
internal int GetGroupIndex(int number)
private int default_startat(string input)
public bool IsMatch(string input)
public bool IsMatch(string input, int startat)
public Match Match(string input)
public Match Match(string input, int startat)
public Match Match(string input, int startat, int length)
public MatchCollection Matches(string input)
public MatchCollection Matches(string input, int startat)
public string Replace(string input, MatchEvaluator evaluator)
public string Replace(string input, MatchEvaluator evaluator, int count)
public string Replace(string input, MatchEvaluator evaluator, int count, int startat)
public string Replace(string input, string replacement)
public string Replace(string input, string replacement, int count)
public string Replace(string input, string replacement, int count, int startat)
public String[] Split(string input)
public String[] Split(string input, int count)
public String[] Split(string input, int count, int startat)
protected void InitializeReferences()
protected bool UseOptionC()
protected bool UseOptionR()
public string ToString()
internal int get_GroupCount()
internal int get_Gap()
private IMachine CreateMachine()
private String[] GetGroupNamesArray(int groupCount, IDictionary mapping)
private Int32[] get_GroupNumbers()
}
public System.Text.RegularExpressions.RegexCompilationInfo : object {
private string pattern
private string name
private string nspace
private RegexOptions options
private bool isPublic
public bool IsPublic
public string Name
public string Namespace
public RegexOptions Options
public string Pattern
public void .ctor(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic)
public bool get_IsPublic()
public void set_IsPublic(bool value)
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public RegexOptions get_Options()
public void set_Options(RegexOptions value)
public string get_Pattern()
public void set_Pattern(string value)
}
public System.Text.RegularExpressions.RegexOptions : Enum {
public int value__
public RegexOptions None
public RegexOptions IgnoreCase
public RegexOptions Multiline
public RegexOptions ExplicitCapture
public RegexOptions Compiled
public RegexOptions Singleline
public RegexOptions IgnorePatternWhitespace
public RegexOptions RightToLeft
public RegexOptions ECMAScript
public RegexOptions CultureInvariant
}
public System.Text.RegularExpressions.RegexRunner : object {
protected internal Int32[] runcrawl
protected internal int runcrawlpos
protected internal Match runmatch
protected internal Regex runregex
protected internal Int32[] runstack
protected internal int runstackpos
protected internal string runtext
protected internal int runtextbeg
protected internal int runtextend
protected internal int runtextpos
protected internal int runtextstart
protected internal Int32[] runtrack
protected internal int runtrackcount
protected internal int runtrackpos
protected bool FindFirstChar()
protected void Go()
protected void InitTrackCount()
protected void Capture(int capnum, int start, int end)
protected bool CharInClass(char ch, string charClass)
protected bool CharInSet(char ch, string set, string category)
protected void Crawl(int i)
protected int Crawlpos()
protected void DoubleCrawl()
protected void DoubleStack()
protected void DoubleTrack()
protected void EnsureStorage()
protected bool IsBoundary(int index, int startpos, int endpos)
protected bool IsECMABoundary(int index, int startpos, int endpos)
protected bool IsMatched(int cap)
protected int MatchIndex(int cap)
protected int MatchLength(int cap)
protected int Popcrawl()
protected void TransferCapture(int capnum, int uncapnum, int start, int end)
protected void Uncapture()
protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick)
}
public System.Text.RegularExpressions.RegexRunnerFactory : object {
protected internal RegexRunner CreateInstance()
}
internal System.Text.RegularExpressions.ReplacementEvaluator : object {
private Regex regex
private int n_pieces
private Int32[] pieces
private string replacement
public bool NeedsGroupsOrCaptures
public void .ctor(Regex regex, string replacement)
public string Evaluate(string replacement, Match match)
public string Evaluate(Match match)
public void EvaluateAppend(Match match, StringBuilder sb)
public bool get_NeedsGroupsOrCaptures()
private void Ensure(int size)
private void AddFromReplacement(int start, int end)
private void AddInt(int i)
private void Compile()
private int CompileTerm(Int32& ptr)
}
internal System.Text.RegularExpressions.RxCompiler : object {
protected Byte[] program
protected int curpos
private void MakeRoom(int bytes)
private void Emit(byte val)
private void Emit(RxOp opcode)
private void Emit(ushort val)
private void Emit(int val)
private void BeginLink(LinkRef lref)
private void EmitLink(LinkRef lref)
public void Reset()
public IMachineFactory GetMachineFactory()
public void EmitFalse()
public void EmitTrue()
public void EmitOp(RxOp op, bool negate, bool ignore, bool reverse)
public void EmitOpIgnoreReverse(RxOp op, bool ignore, bool reverse)
public void EmitOpNegateReverse(RxOp op, bool negate, bool reverse)
public void EmitCharacter(char c, bool negate, bool ignore, bool reverse)
private void EmitUniCat(UnicodeCategory cat, bool negate, bool reverse)
private void EmitCatGeneral(Category cat, bool negate, bool reverse)
public void EmitCategory(Category cat, bool negate, bool reverse)
public void EmitNotCategory(Category cat, bool negate, bool reverse)
public void EmitRange(char lo, char hi, bool negate, bool ignore, bool reverse)
public void EmitSet(char lo, BitArray set, bool negate, bool ignore, bool reverse)
public void EmitString(string str, bool ignore, bool reverse)
public void EmitPosition(Position pos)
public void EmitOpen(int gid)
public void EmitClose(int gid)
public void EmitBalanceStart(int gid, int balance, bool capture, LinkRef tail)
public void EmitBalance()
public void EmitReference(int gid, bool ignore, bool reverse)
public void EmitIfDefined(int gid, LinkRef tail)
public void EmitSub(LinkRef tail)
public void EmitTest(LinkRef yes, LinkRef tail)
public void EmitBranch(LinkRef next)
public void EmitJump(LinkRef target)
public void EmitIn(LinkRef tail)
public void EmitRepeat(int min, int max, bool lazy, LinkRef until)
public void EmitUntil(LinkRef repeat)
public void EmitInfo(int count, int min, int max)
public void EmitFastRepeat(int min, int max, bool lazy, LinkRef tail)
public void EmitAnchor(bool reverse, int offset, LinkRef tail)
public void EmitBranchEnd()
public void EmitAlternationEnd()
public LinkRef NewLink()
public void ResolveLink(LinkRef link)
}
internal System.Text.RegularExpressions.RxInterpreter : BaseMachine {
private Byte[] program
private string str
private int string_start
private int string_end
private int group_count
private Int32[] groups
private EvalDelegate eval_del
private Mark[] marks
private int mark_start
private int mark_end
private IntStack stack
private RepeatContext repeat
private RepeatContext deep
public bool trace_rx
public void .ctor(Byte[] program, EvalDelegate eval_del)
private int ReadInt(Byte[] code, int pc)
public Match Scan(Regex regex, string text, int start, int end)
private void Open(int gid, int ptr)
private void Close(int gid, int ptr)
private bool Balance(int gid, int balance_gid, bool capture, int ptr)
private int Checkpoint()
private void Backtrack(int cp)
private void ResetGroups()
private int GetLastDefined(int gid)
private int CreateMark(int previous)
private void GetGroupInfo(int gid, Int32& first_mark_index, Int32& n_caps)
private void PopulateGroup(Group g, int first_mark_index, int n_caps)
private Match GenerateMatch(Regex regex)
internal void SetStartOfMatch(int pos)
private bool IsWordChar(char c)
private bool EvalByteCode(int pc, int strpos, Int32& strpos_result)
}
internal System.Text.RegularExpressions.RxInterpreterFactory : object {
private IDictionary mapping
private Byte[] program
private EvalDelegate eval_del
private String[] namesMapping
private int gap
public int GroupCount
public int Gap
public IDictionary Mapping
public String[] NamesMapping
public void .ctor(Byte[] program, EvalDelegate eval_del)
public IMachine NewInstance()
public int get_GroupCount()
public int get_Gap()
public void set_Gap(int value)
public IDictionary get_Mapping()
public void set_Mapping(IDictionary value)
public String[] get_NamesMapping()
public void set_NamesMapping(String[] value)
}
internal System.Text.RegularExpressions.RxLinkRef : LinkRef {
public Int32[] offsets
public int current
public void PushInstructionBase(int offset)
public void PushOffsetPosition(int offset)
}
internal System.Text.RegularExpressions.RxOp : Enum {
public byte value__
public RxOp Info
public RxOp False
public RxOp True
public RxOp AnyPosition
public RxOp StartOfString
public RxOp StartOfLine
public RxOp StartOfScan
public RxOp EndOfString
public RxOp EndOfLine
public RxOp End
public RxOp WordBoundary
public RxOp NoWordBoundary
public RxOp String
public RxOp StringIgnoreCase
public RxOp StringReverse
public RxOp StringIgnoreCaseReverse
public RxOp UnicodeString
public RxOp UnicodeStringIgnoreCase
public RxOp UnicodeStringReverse
public RxOp UnicodeStringIgnoreCaseReverse
public RxOp Char
public RxOp NoChar
public RxOp CharIgnoreCase
public RxOp NoCharIgnoreCase
public RxOp CharReverse
public RxOp NoCharReverse
public RxOp CharIgnoreCaseReverse
public RxOp NoCharIgnoreCaseReverse
public RxOp Range
public RxOp NoRange
public RxOp RangeIgnoreCase
public RxOp NoRangeIgnoreCase
public RxOp RangeReverse
public RxOp NoRangeReverse
public RxOp RangeIgnoreCaseReverse
public RxOp NoRangeIgnoreCaseReverse
public RxOp Bitmap
public RxOp NoBitmap
public RxOp BitmapIgnoreCase
public RxOp NoBitmapIgnoreCase
public RxOp BitmapReverse
public RxOp NoBitmapReverse
public RxOp BitmapIgnoreCaseReverse
public RxOp NoBitmapIgnoreCaseReverse
public RxOp UnicodeChar
public RxOp NoUnicodeChar
public RxOp UnicodeCharIgnoreCase
public RxOp NoUnicodeCharIgnoreCase
public RxOp UnicodeCharReverse
public RxOp NoUnicodeCharReverse
public RxOp UnicodeCharIgnoreCaseReverse
public RxOp NoUnicodeCharIgnoreCaseReverse
public RxOp UnicodeRange
public RxOp NoUnicodeRange
public RxOp UnicodeRangeIgnoreCase
public RxOp NoUnicodeRangeIgnoreCase
public RxOp UnicodeRangeReverse
public RxOp NoUnicodeRangeReverse
public RxOp UnicodeRangeIgnoreCaseReverse
public RxOp NoUnicodeRangeIgnoreCaseReverse
public RxOp UnicodeBitmap
public RxOp NoUnicodeBitmap
public RxOp UnicodeBitmapIgnoreCase
public RxOp NoUnicodeBitmapIgnoreCase
public RxOp UnicodeBitmapReverse
public RxOp NoUnicodeBitmapReverse
public RxOp UnicodeBitmapIgnoreCaseReverse
public RxOp NoUnicodeBitmapIgnoreCaseReverse
public RxOp CategoryAny
public RxOp NoCategoryAny
public RxOp CategoryAnyReverse
public RxOp NoCategoryAnyReverse
public RxOp CategoryAnySingleline
public RxOp NoCategoryAnySingleline
public RxOp CategoryAnySinglelineReverse
public RxOp NoCategoryAnySinglelineReverse
public RxOp CategoryDigit
public RxOp NoCategoryDigit
public RxOp CategoryDigitReverse
public RxOp NoCategoryDigitReverse
public RxOp CategoryWord
public RxOp NoCategoryWord
public RxOp CategoryWordReverse
public RxOp NoCategoryWordReverse
public RxOp CategoryWhiteSpace
public RxOp NoCategoryWhiteSpace
public RxOp CategoryWhiteSpaceReverse
public RxOp NoCategoryWhiteSpaceReverse
public RxOp CategoryEcmaWord
public RxOp NoCategoryEcmaWord
public RxOp CategoryEcmaWordReverse
public RxOp NoCategoryEcmaWordReverse
public RxOp CategoryEcmaWhiteSpace
public RxOp NoCategoryEcmaWhiteSpace
public RxOp CategoryEcmaWhiteSpaceReverse
public RxOp NoCategoryEcmaWhiteSpaceReverse
public RxOp CategoryUnicode
public RxOp NoCategoryUnicode
public RxOp CategoryUnicodeReverse
public RxOp NoCategoryUnicodeReverse
public RxOp CategoryUnicodeLetter
public RxOp NoCategoryUnicodeLetter
public RxOp CategoryUnicodeLetterReverse
public RxOp NoCategoryUnicodeLetterReverse
public RxOp CategoryUnicodeMark
public RxOp NoCategoryUnicodeMark
public RxOp CategoryUnicodeMarkReverse
public RxOp NoCategoryUnicodeMarkReverse
public RxOp CategoryUnicodeNumber
public RxOp NoCategoryUnicodeNumber
public RxOp CategoryUnicodeNumberReverse
public RxOp NoCategoryUnicodeNumberReverse
public RxOp CategoryUnicodeSeparator
public RxOp NoCategoryUnicodeSeparator
public RxOp CategoryUnicodeSeparatorReverse
public RxOp NoCategoryUnicodeSeparatorReverse
public RxOp CategoryUnicodePunctuation
public RxOp NoCategoryUnicodePunctuation
public RxOp CategoryUnicodePunctuationReverse
public RxOp NoCategoryUnicodePunctuationReverse
public RxOp CategoryUnicodeSymbol
public RxOp NoCategoryUnicodeSymbol
public RxOp CategoryUnicodeSymbolReverse
public RxOp NoCategoryUnicodeSymbolReverse
public RxOp CategoryUnicodeSpecials
public RxOp NoCategoryUnicodeSpecials
public RxOp CategoryUnicodeSpecialsReverse
public RxOp NoCategoryUnicodeSpecialsReverse
public RxOp CategoryUnicodeOther
public RxOp NoCategoryUnicodeOther
public RxOp CategoryUnicodeOtherReverse
public RxOp NoCategoryUnicodeOtherReverse
public RxOp CategoryGeneral
public RxOp NoCategoryGeneral
public RxOp CategoryGeneralReverse
public RxOp NoCategoryGeneralReverse
public RxOp Reference
public RxOp ReferenceIgnoreCase
public RxOp ReferenceReverse
public RxOp ReferenceIgnoreCaseReverse
public RxOp OpenGroup
public RxOp CloseGroup
public RxOp BalanceStart
public RxOp Balance
public RxOp IfDefined
public RxOp Jump
public RxOp SubExpression
public RxOp Test
public RxOp Branch
public RxOp TestCharGroup
public RxOp Anchor
public RxOp AnchorReverse
public RxOp Repeat
public RxOp RepeatLazy
public RxOp Until
public RxOp FastRepeat
public RxOp FastRepeatLazy
public RxOp RepeatInfinite
public RxOp RepeatInfiniteLazy
}
internal System.Text.RegularExpressions.Syntax.Alternation : CompositeExpression {
public ExpressionCollection Alternatives
public ExpressionCollection get_Alternatives()
public void AddAlternative(Expression e)
public void Compile(ICompiler cmp, bool reverse)
public void GetWidth(Int32& min, Int32& max)
}
internal System.Text.RegularExpressions.Syntax.AnchorInfo : object {
private Expression expr
private Position pos
private int offset
private string str
private int width
private bool ignore
public Expression Expression
public int Offset
public int Width
public int Length
public bool IsUnknownWidth
public bool IsComplete
public string Substring
public bool IgnoreCase
public Position Position
public bool IsSubstring
public bool IsPosition
public void .ctor(Expression expr, int width)
public void .ctor(Expression expr, int offset, int width, string str, bool ignore)
public void .ctor(Expression expr, int offset, int width, Position pos)
public Expression get_Expression()
public int get_Offset()
public int get_Width()
public int get_Length()
public bool get_IsUnknownWidth()
public bool get_IsComplete()
public string get_Substring()
public bool get_IgnoreCase()
public Position get_Position()
public bool get_IsSubstring()
public bool get_IsPosition()
public Interval GetInterval()
public Interval GetInterval(int start)
}
internal System.Text.RegularExpressions.Syntax.Assertion : CompositeExpression {
public Expression TrueExpression
public Expression FalseExpression
public Expression get_TrueExpression()
public void set_TrueExpression(Expression value)
public Expression get_FalseExpression()
public void set_FalseExpression(Expression value)
public void GetWidth(Int32& min, Int32& max)
}
internal System.Text.RegularExpressions.Syntax.BackslashNumber : Reference {
private string literal
private bool ecma
public void .ctor(bool ignore, bool ecma)
public bool ResolveReference(string num_str, Hashtable groups)
public void Compile(ICompiler cmp, bool reverse)
}
internal System.Text.RegularExpressions.Syntax.BalancingGroup : CapturingGroup {
private CapturingGroup balance
public CapturingGroup Balance
public CapturingGroup get_Balance()
public void set_Balance(CapturingGroup value)
public void Compile(ICompiler cmp, bool reverse)
}
internal System.Text.RegularExpressions.Syntax.CaptureAssertion : Assertion {
private ExpressionAssertion alternate
private CapturingGroup group
private Literal literal
public CapturingGroup CapturingGroup
private ExpressionAssertion Alternate
public void .ctor(Literal l)
public CapturingGroup get_CapturingGroup()
public void set_CapturingGroup(CapturingGroup value)
public void Compile(ICompiler cmp, bool reverse)
public bool IsComplex()
private ExpressionAssertion get_Alternate()
}
internal System.Text.RegularExpressions.Syntax.CapturingGroup : Group {
private int gid
private string name
public int Index
public string Name
public bool IsNamed
public int get_Index()
public void set_Index(int value)
public string get_Name()
public void set_Name(string value)
public bool get_IsNamed()
public void Compile(ICompiler cmp, bool reverse)
public bool IsComplex()
public int CompareTo(object other)
}
internal System.Text.RegularExpressions.Syntax.CharacterClass : Expression {
private int distance_between_upper_and_lower_case
private Interval upper_case_characters
private bool negate
private bool ignore
private BitArray pos_cats
private BitArray neg_cats
private IntervalCollection intervals
public bool Negate
public bool IgnoreCase
public void .ctor(bool negate, bool ignore)
public void .ctor(Category cat, bool negate)
public bool get_Negate()
public void set_Negate(bool value)
public bool get_IgnoreCase()
public void set_IgnoreCase(bool value)
public void AddCategory(Category cat, bool negate)
public void AddCharacter(char c)
public void AddRange(char lo, char hi)
public void Compile(ICompiler cmp, bool reverse)
public void GetWidth(Int32& min, Int32& max)
public bool IsComplex()
private double GetIntervalCost(Interval i)
}
internal System.Text.RegularExpressions.Syntax.CompositeExpression : Expression {
private ExpressionCollection expressions
protected ExpressionCollection Expressions
protected ExpressionCollection get_Expressions()
protected void GetWidth(Int32& min, Int32& max, int count)
public bool IsComplex()
}
internal System.Text.RegularExpressions.Syntax.Expression : object {
public void Compile(ICompiler cmp, bool reverse)
public void GetWidth(Int32& min, Int32& max)
public int GetFixedWidth()
public AnchorInfo GetAnchorInfo(bool reverse)
public bool IsComplex()
}
internal System.Text.RegularExpressions.Syntax.ExpressionAssertion : Assertion {
private bool reverse
private bool negate
public bool Reverse
public bool Negate
public Expression TestExpression
public bool get_Reverse()
public void set_Reverse(bool value)
public bool get_Negate()
public void set_Negate(bool value)
public Expression get_TestExpression()
public void set_TestExpression(Expression value)
public void Compile(ICompiler cmp, bool reverse)
public bool IsComplex()
}
internal System.Text.RegularExpressions.Syntax.ExpressionCollection : CollectionBase {
public Expression Item
public void Add(Expression e)
public Expression get_Item(int i)
public void set_Item(int i, Expression value)
protected void OnValidate(object o)
}
internal System.Text.RegularExpressions.Syntax.Group : CompositeExpression {
public Expression Expression
public Expression get_Expression()
public void set_Expression(Expression value)
public void AppendExpression(Expression e)
public void Compile(ICompiler cmp, bool reverse)
public void GetWidth(Int32& min, Int32& max)
public AnchorInfo GetAnchorInfo(bool reverse)
}
internal System.Text.RegularExpressions.Syntax.Literal : Expression {
private string str
private bool ignore
public string String
public bool IgnoreCase
public void .ctor(string str, bool ignore)
public string get_String()
public void set_String(string value)
public bool get_IgnoreCase()
public void set_IgnoreCase(bool value)
public void CompileLiteral(string str, ICompiler cmp, bool ignore, bool reverse)
public void Compile(ICompiler cmp, bool reverse)
public void GetWidth(Int32& min, Int32& max)
public AnchorInfo GetAnchorInfo(bool reverse)
public bool IsComplex()
}
internal System.Text.RegularExpressions.Syntax.NonBacktrackingGroup : Group {
public void Compile(ICompiler cmp, bool reverse)
public bool IsComplex()
}
internal System.Text.RegularExpressions.Syntax.Parser : object {
private string pattern
private int ptr
private ArrayList caps
private Hashtable refs
private int num_groups
private int gap
public int ParseDecimal(string str, Int32& ptr)
public int ParseOctal(string str, Int32& ptr)
public int ParseHex(string str, Int32& ptr, int digits)
public int ParseNumber(string str, Int32& ptr, int b, int min, int max)
public string ParseName(string str, Int32& ptr)
public string Escape(string str)
public string Unescape(string str)
public RegularExpression ParseRegularExpression(string pattern, RegexOptions options)
public int GetMapping(Hashtable mapping)
private void ParseGroup(Group group, RegexOptions options, Assertion assertion)
private Expression ParseGroupingConstruct(RegexOptions& options)
private bool ParseAssertionType(ExpressionAssertion assertion)
private void ParseOptions(RegexOptions& options, bool negate)
private Expression ParseCharacterClass(RegexOptions options)
private bool ParseRepetitionBounds(Int32& min, Int32& max, RegexOptions options)
private Category ParseUnicodeCategory()
private Expression ParseSpecial(RegexOptions options)
private int ParseEscape()
private string ParseName()
private bool IsNameChar(char c)
private int ParseNumber(int b, int min, int max)
private int ParseDigit(char c, int b, int n)
private void ConsumeWhitespace(bool ignore)
private string ParseString(string pattern)
private void ResolveReferences()
private void HandleExplicitNumericGroups(ArrayList explicit_numeric_groups)
private bool IsIgnoreCase(RegexOptions options)
private bool IsMultiline(RegexOptions options)
private bool IsExplicitCapture(RegexOptions options)
private bool IsSingleline(RegexOptions options)
private bool IsIgnorePatternWhitespace(RegexOptions options)
private bool IsECMAScript(RegexOptions options)
private ArgumentException NewParseException(string msg)
}
internal System.Text.RegularExpressions.Syntax.PositionAssertion : Expression {
private Position pos
public Position Position
public void .ctor(Position pos)
public Position get_Position()
public void set_Position(Position value)
public void Compile(ICompiler cmp, bool reverse)
public void GetWidth(Int32& min, Int32& max)
public bool IsComplex()
public AnchorInfo GetAnchorInfo(bool revers)
}
internal System.Text.RegularExpressions.Syntax.Reference : Expression {
private CapturingGroup group
private bool ignore
public CapturingGroup CapturingGroup
public bool IgnoreCase
public void .ctor(bool ignore)
public CapturingGroup get_CapturingGroup()
public void set_CapturingGroup(CapturingGroup value)
public bool get_IgnoreCase()
public void set_IgnoreCase(bool value)
public void Compile(ICompiler cmp, bool reverse)
public void GetWidth(Int32& min, Int32& max)
public bool IsComplex()
}
internal System.Text.RegularExpressions.Syntax.RegularExpression : Group {
private int group_count
public int GroupCount
public int get_GroupCount()
public void set_GroupCount(int value)
public void Compile(ICompiler cmp, bool reverse)
}
internal System.Text.RegularExpressions.Syntax.Repetition : CompositeExpression {
private int min
private int max
private bool lazy
public Expression Expression
public int Minimum
public int Maximum
public bool Lazy
public void .ctor(int min, int max, bool lazy)
public Expression get_Expression()
public void set_Expression(Expression value)
public int get_Minimum()
public void set_Minimum(int value)
public int get_Maximum()
public void set_Maximum(int value)
public bool get_Lazy()
public void set_Lazy(bool value)
public void Compile(ICompiler cmp, bool reverse)
public void GetWidth(Int32& min, Int32& max)
public AnchorInfo GetAnchorInfo(bool reverse)
}
public System.Threading.Semaphore : WaitHandle {
private void .ctor(IntPtr handle)
public void .ctor(int initialCount, int maximumCount)
public void .ctor(int initialCount, int maximumCount, string name)
public void .ctor(int initialCount, int maximumCount, string name, Boolean& createdNew)
public void .ctor(int initialCount, int maximumCount, string name, Boolean& createdNew, SemaphoreSecurity semaphoreSecurity)
private IntPtr CreateSemaphore_internal(int initialCount, int maximumCount, string name, Boolean& createdNew)
private int ReleaseSemaphore_internal(IntPtr handle, int releaseCount, Boolean& fail)
private IntPtr OpenSemaphore_internal(string name, SemaphoreRights rights, MonoIOError& error)
public SemaphoreSecurity GetAccessControl()
public int Release()
public int Release(int releaseCount)
public void SetAccessControl(SemaphoreSecurity semaphoreSecurity)
public Semaphore OpenExisting(string name)
public Semaphore OpenExisting(string name, SemaphoreRights rights)
}
public System.Threading.SemaphoreFullException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.ThreadExceptionEventArgs : EventArgs {
private Exception exception
public Exception Exception
public void .ctor(Exception t)
public Exception get_Exception()
}
public System.Threading.ThreadExceptionEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ThreadExceptionEventArgs e)
public IAsyncResult BeginInvoke(object sender, ThreadExceptionEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Timers.ElapsedEventArgs : EventArgs {
private DateTime time
public DateTime SignalTime
internal void .ctor(DateTime time)
public DateTime get_SignalTime()
}
public System.Timers.ElapsedEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ElapsedEventArgs e)
public IAsyncResult BeginInvoke(object sender, ElapsedEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Timers.Timer : Component {
private double interval
private bool autoReset
private Timer timer
private object _lock
private ISynchronizeInvoke so
private ElapsedEventHandler Elapsed
public bool AutoReset
public bool Enabled
public double Interval
public ISite Site
public ISynchronizeInvoke SynchronizingObject
public void .ctor(double interval)
public void add_Elapsed(ElapsedEventHandler value)
public void remove_Elapsed(ElapsedEventHandler value)
public bool get_AutoReset()
public void set_AutoReset(bool value)
public bool get_Enabled()
public void set_Enabled(bool value)
public double get_Interval()
public void set_Interval(double value)
public ISite get_Site()
public void set_Site(ISite value)
public ISynchronizeInvoke get_SynchronizingObject()
public void set_SynchronizingObject(ISynchronizeInvoke value)
public void BeginInit()
public void Close()
public void EndInit()
public void Start()
public void Stop()
protected void Dispose(bool disposing)
private void Callback(object state)
}
public System.Timers.TimersDescriptionAttribute : DescriptionAttribute {
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Uri : object {
private int MaxUriLength
private bool isUnixFilePath
private string source
private string scheme
private string host
private int port
private string path
private string query
private string fragment
private string userinfo
private bool isUnc
private bool isOpaquePart
private bool isAbsoluteUri
private String[] segments
private bool userEscaped
private string cachedAbsoluteUri
private string cachedToString
private string cachedLocalPath
private int cachedHashCode
private string hexUpperChars
public string SchemeDelimiter
public string UriSchemeFile
public string UriSchemeFtp
public string UriSchemeGopher
public string UriSchemeHttp
public string UriSchemeHttps
public string UriSchemeMailto
public string UriSchemeNews
public string UriSchemeNntp
public string UriSchemeNetPipe
public string UriSchemeNetTcp
private UriScheme[] schemes
private UriParser parser
private Dictionary`2<string, int> <>f__switch$map1C
private Dictionary`2<string, int> <>f__switch$map1D
private Dictionary`2<string, int> <>f__switch$map1E
private Dictionary`2<string, int> <>f__switch$map1F
private Dictionary`2<string, int> <>f__switch$map20
public string AbsolutePath
public string AbsoluteUri
public string Authority
public string Fragment
public string Host
public UriHostNameType HostNameType
public bool IsDefaultPort
public bool IsFile
public bool IsLoopback
public bool IsUnc
public string LocalPath
public string PathAndQuery
public int Port
public string Query
public string Scheme
public String[] Segments
public bool UserEscaped
public string UserInfo
public string DnsSafeHost
public bool IsAbsoluteUri
public string OriginalString
private UriParser Parser
public void .ctor(string uriString)
protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext)
public void .ctor(string uriString, UriKind uriKind)
private void .ctor(string uriString, UriKind uriKind, Boolean& success)
public void .ctor(Uri baseUri, Uri relativeUri)
public void .ctor(string uriString, bool dontEscape)
public void .ctor(Uri baseUri, string relativeUri)
public void .ctor(Uri baseUri, string relativeUri, bool dontEscape)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private void Merge(Uri baseUri, string relativeUri)
public string get_AbsolutePath()
public string get_AbsoluteUri()
public string get_Authority()
public string get_Fragment()
public string get_Host()
public UriHostNameType get_HostNameType()
public bool get_IsDefaultPort()
public bool get_IsFile()
public bool get_IsLoopback()
public bool get_IsUnc()
public string get_LocalPath()
public string get_PathAndQuery()
public int get_Port()
public string get_Query()
public string get_Scheme()
public String[] get_Segments()
public bool get_UserEscaped()
public string get_UserInfo()
public string get_DnsSafeHost()
public bool get_IsAbsoluteUri()
public string get_OriginalString()
public UriHostNameType CheckHostName(string name)
internal bool IsIPv4Address(string name)
internal bool IsDomainAddress(string name)
protected void Canonicalize()
protected void CheckSecurity()
public bool CheckSchemeName(string schemeName)
private bool IsAlpha(char c)
public bool Equals(object comparant)
private bool InternalEquals(Uri uri)
public int GetHashCode()
public string GetLeftPart(UriPartial part)
public int FromHex(char digit)
public string HexEscape(char character)
public char HexUnescape(string pattern, Int32& index)
public bool IsHexDigit(char digit)
public bool IsHexEncoding(string pattern, int index)
public Uri MakeRelativeUri(Uri uri)
public string MakeRelative(Uri toUri)
private void AppendQueryAndFragment(String& result)
public string ToString()
protected void GetObjectData(SerializationInfo info, StreamingContext context)
protected void Escape()
protected string EscapeString(string str)
internal string EscapeString(string str, bool escapeReserved, bool escapeHex, bool escapeBrackets)
protected void Parse()
private void ParseUri(UriKind kind)
protected string Unescape(string str)
internal string Unescape(string str, bool excludeSpecial)
private void ParseAsWindowsUNC(string uriString)
private string ParseAsWindowsAbsoluteFilePath(string uriString)
private void ParseAsUnixAbsoluteFilePath(string uriString)
private void Parse(UriKind kind, string uriString)
private string ParseNoExceptions(UriKind kind, string uriString)
private bool CompactEscaped(string scheme)
private string Reduce(string path, bool compact_escaped)
private char HexUnescapeMultiByte(string pattern, Int32& index, Char& surrogate)
internal string GetSchemeDelimiter(string scheme)
internal int GetDefaultPort(string scheme)
private string GetOpaqueWiseSchemeDelimiter()
protected bool IsBadFileSystemCharacter(char ch)
protected bool IsExcludedCharacter(char ch)
internal bool MaybeUri(string s)
private bool IsPredefinedScheme(string scheme)
protected bool IsReservedCharacter(char ch)
private UriParser get_Parser()
private void set_Parser(UriParser value)
public string GetComponents(UriComponents components, UriFormat format)
public bool IsBaseOf(Uri uri)
public bool IsWellFormedOriginalString()
public int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType)
private bool NeedToEscapeDataChar(char b)
public string EscapeDataString(string stringToEscape)
private bool NeedToEscapeUriChar(char b)
public string EscapeUriString(string stringToEscape)
public bool IsWellFormedUriString(string uriString, UriKind uriKind)
public bool TryCreate(string uriString, UriKind uriKind, Uri& result)
public bool TryCreate(Uri baseUri, string relativeUri, Uri& result)
public bool TryCreate(Uri baseUri, Uri relativeUri, Uri& result)
public string UnescapeDataString(string stringToUnescape)
private int GetInt(byte b)
private int GetChar(string str, int offset, int length)
private Char[] GetChars(MemoryStream b, Encoding e)
private void EnsureAbsoluteUri()
public bool op_Equality(Uri u1, Uri u2)
public bool op_Inequality(Uri u1, Uri u2)
}
public System.UriBuilder : object {
private string scheme
private string host
private int port
private string path
private string query
private string fragment
private string username
private string password
private Uri uri
private bool modified
public string Fragment
public string Host
public string Password
public string Path
public int Port
public string Query
public string Scheme
public Uri Uri
public string UserName
public void .ctor(string uri)
public void .ctor(Uri uri)
public void .ctor(string schemeName, string hostName)
public void .ctor(string scheme, string host, int portNumber)
public void .ctor(string scheme, string host, int port, string pathValue)
public void .ctor(string scheme, string host, int port, string pathValue, string extraValue)
public string get_Fragment()
public void set_Fragment(string value)
public string get_Host()
public void set_Host(string value)
public string get_Password()
public void set_Password(string value)
public string get_Path()
public void set_Path(string value)
public int get_Port()
public void set_Port(int value)
public string get_Query()
public void set_Query(string value)
public string get_Scheme()
public void set_Scheme(string value)
public Uri get_Uri()
public string get_UserName()
public void set_UserName(string value)
public bool Equals(object rparam)
public int GetHashCode()
public string ToString()
}
public System.UriComponents : Enum {
public int value__
public UriComponents Scheme
public UriComponents UserInfo
public UriComponents Host
public UriComponents Port
public UriComponents Path
public UriComponents Query
public UriComponents Fragment
public UriComponents StrongPort
public UriComponents KeepDelimiter
public UriComponents HostAndPort
public UriComponents StrongAuthority
public UriComponents AbsoluteUri
public UriComponents PathAndQuery
public UriComponents HttpRequestUrl
public UriComponents SchemeAndServer
public UriComponents SerializationInfoString
}
internal System.UriData : object {
private Uri uri
private UriParser parser
private string absolute_path
private string absolute_uri
private string absolute_uri_unescaped
private string authority
private string fragment
private string host
private string path_and_query
private string strong_port
private string query
private string user_info
public string AbsolutePath
public string AbsoluteUri
public string AbsoluteUri_SafeUnescaped
public string Authority
public string Fragment
public string Host
public string PathAndQuery
public string StrongPort
public string Query
public string UserInfo
public void .ctor(Uri uri, UriParser parser)
private string Lookup(String& cache, UriComponents components)
private string Lookup(String& cache, UriComponents components, UriFormat format)
public string get_AbsolutePath()
public string get_AbsoluteUri()
public string get_AbsoluteUri_SafeUnescaped()
public string get_Authority()
public string get_Fragment()
public string get_Host()
public string get_PathAndQuery()
public string get_StrongPort()
public string get_Query()
public string get_UserInfo()
}
public System.UriFormat : Enum {
public int value__
public UriFormat UriEscaped
public UriFormat Unescaped
public UriFormat SafeUnescaped
}
public System.UriFormatException : FormatException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.UriHostNameType : Enum {
public int value__
public UriHostNameType Unknown
public UriHostNameType Basic
public UriHostNameType Dns
public UriHostNameType IPv4
public UriHostNameType IPv6
}
public System.UriIdnScope : Enum {
public int value__
public UriIdnScope None
public UriIdnScope AllExceptIntranet
public UriIdnScope All
}
public System.UriKind : Enum {
public int value__
public UriKind RelativeOrAbsolute
public UriKind Absolute
public UriKind Relative
}
public System.UriParser : object {
private object lock_object
private Hashtable table
internal string scheme_name
private int default_port
private Regex uri_regex
private Regex auth_regex
internal string SchemeName
internal int DefaultPort
private Match ParseAuthority(Group g)
protected internal string GetComponents(Uri uri, UriComponents components, UriFormat format)
protected internal void InitializeAndValidate(Uri uri, UriFormatException& parsingError)
protected internal bool IsBaseOf(Uri baseUri, Uri relativeUri)
protected internal bool IsWellFormedOriginalString(Uri uri)
protected internal UriParser OnNewUri()
protected void OnRegister(string schemeName, int defaultPort)
protected internal string Resolve(Uri baseUri, Uri relativeUri, UriFormatException& parsingError)
internal string get_SchemeName()
internal void set_SchemeName(string value)
internal int get_DefaultPort()
internal void set_DefaultPort(int value)
private string IgnoreFirstCharIf(string s, char c)
private string Format(string s, UriFormat format)
private void CreateDefaults()
public bool IsKnownScheme(string schemeName)
private void InternalRegister(Hashtable table, UriParser uriParser, string schemeName, int defaultPort)
public void Register(UriParser uriParser, string schemeName, int defaultPort)
internal UriParser GetParser(string schemeName)
}
public System.UriPartial : Enum {
public int value__
public UriPartial Scheme
public UriPartial Authority
public UriPartial Path
public UriPartial Query
}
public System.UriTypeConverter : TypeConverter {
private bool CanConvert(Type type)
public bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
public bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
public object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
public object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
public bool IsValid(ITypeDescriptorContext context, object value)
}
public System.Web.AspNetHostingPermission : CodeAccessPermission {
private int version
private AspNetHostingPermissionLevel _level
public AspNetHostingPermissionLevel Level
public void .ctor(AspNetHostingPermissionLevel level)
public void .ctor(PermissionState state)
public AspNetHostingPermissionLevel get_Level()
public void set_Level(AspNetHostingPermissionLevel value)
public bool IsUnrestricted()
public IPermission Copy()
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
private bool IsEmpty()
private AspNetHostingPermission Cast(IPermission target)
}
public System.Web.AspNetHostingPermissionAttribute : CodeAccessSecurityAttribute {
private AspNetHostingPermissionLevel _level
public AspNetHostingPermissionLevel Level
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
public AspNetHostingPermissionLevel get_Level()
public void set_Level(AspNetHostingPermissionLevel value)
}
public System.Web.AspNetHostingPermissionLevel : Enum {
public int value__
public AspNetHostingPermissionLevel None
public AspNetHostingPermissionLevel Minimal
public AspNetHostingPermissionLevel Low
public AspNetHostingPermissionLevel Medium
public AspNetHostingPermissionLevel High
public AspNetHostingPermissionLevel Unrestricted
}
