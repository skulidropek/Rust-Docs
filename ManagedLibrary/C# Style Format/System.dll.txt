internal static class Internal.Cryptography.OidLookup : object {
    private static ConcurrentDictionary`2<string, string> s_lateBoundOidToFriendlyName;
    private static ConcurrentDictionary`2<string, string> s_lateBoundFriendlyNameToOid;
    private static Dictionary`2<string, string> s_friendlyNameToOid;
    private static Dictionary`2<string, string> s_oidToFriendlyName;
    private static Dictionary`2<string, string> s_compatOids;
    private static OidLookup();
    private static bool ShouldUseCache(OidGroup oidGroup);
    private static string NativeOidToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups);
    private static string NativeFriendlyNameToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups);
    public static string ToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups);
    public static string ToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups);
}
internal static class Internal.Cryptography.Oids : object {
    public static string CommonName;
    public static string Organization;
    public static string OrganizationalUnit;
    public static string BasicConstraints;
    public static string SubjectKeyIdentifier;
    public static string SubjectAltName;
    public static string IssuerAltName;
    public static string KeyUsage;
    public static string BasicConstraints2;
    public static string CrlDistributionPoints;
    public static string CertPolicies;
    public static string AnyCertPolicy;
    public static string CertPolicyMappings;
    public static string CertPolicyConstraints;
    public static string EnhancedKeyUsage;
    public static string InhibitAnyPolicyExtension;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string EccCurveSecp384r1;
    public static string EccCurveSecp521r1;
    public static string Ecc;
    public static string EccCurveSecp256r1;
    public static string ECDsaSha256;
    public static string ECDsaSha384;
    public static string ECDsaSha512;
    public static string RsaRsa;
    public static string Mgf1;
    public static string RsaSsaPss;
    public static string RsaPkcs1Sha256;
    public static string RsaPkcs1Sha384;
    public static string RsaPkcs1Sha512;
    public static string Pkcs9ExtensionRequest;
    public static string DsaDsa;
    public static string EmailAddress;
    public static string EnrollCertTypeExtension;
    public static string UserPrincipalName;
    public static string CertificateTemplate;
    public static string ApplicationCertPolicies;
    public static string AuthorityInformationAccess;
    public static string CertificateAuthorityIssuers;
}
internal class Internal.Cryptography.Pal.CertificateData : ValueType {
    internal Byte[] RawData;
    internal Byte[] SubjectPublicKeyInfo;
    internal int Version;
    internal Byte[] SerialNumber;
    internal AlgorithmIdentifier TbsSignature;
    internal X500DistinguishedName Issuer;
    internal DateTime NotBefore;
    internal DateTime NotAfter;
    internal X500DistinguishedName Subject;
    internal AlgorithmIdentifier PublicKeyAlgorithm;
    internal Byte[] PublicKey;
    internal Byte[] IssuerUniqueId;
    internal Byte[] SubjectUniqueId;
    internal List`1<X509Extension> Extensions;
    internal AlgorithmIdentifier SignatureAlgorithm;
    internal Byte[] SignatureValue;
    internal CertificateData(Byte[] rawData);
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    private static string GetSimpleNameInfo(X500DistinguishedName name);
    private static string FindAltNameMatch(Byte[] extensionBytes, GeneralNameType matchType, string otherOid);
    [IteratorStateMachineAttribute("Internal.Cryptography.Pal.CertificateData/<ReadReverseRdns>d__21")]
private static IEnumerable`1<KeyValuePair`2<string, string>> ReadReverseRdns(X500DistinguishedName name);
}
internal enum Internal.Cryptography.Pal.GeneralNameType : Enum {
    public int value__;
    public static GeneralNameType OtherName;
    public static GeneralNameType Rfc822Name;
    public static GeneralNameType Email;
    public static GeneralNameType DnsName;
    public static GeneralNameType X400Address;
    public static GeneralNameType DirectoryName;
    public static GeneralNameType EdiPartyName;
    public static GeneralNameType UniformResourceIdentifier;
    public static GeneralNameType IPAddress;
    public static GeneralNameType RegisteredId;
}
internal static class Interop : object {
}
internal class Microsoft.CSharp.CSharpCodeGenerator : object {
    private static Char[] s_periodArray;
    private ExposedTabStringIndentedTextWriter _output;
    private CodeGeneratorOptions _options;
    private CodeTypeDeclaration _currentClass;
    private CodeTypeMember _currentMember;
    private bool _inNestedBinary;
    private IDictionary`2<string, string> _provOptions;
    private static int ParameterMultilineThreshold;
    private static int MaxLineLength;
    private static GeneratorSupport LanguageSupport;
    private static String[][] s_keywords;
    private bool _generatingForLoop;
    private static string ErrorRegexPattern;
    private static Regex RelatedSymbolsRegex;
    private string FileExtension { get; }
    private string CompilerName { get; }
    private string CurrentTypeName { get; }
    private int Indent { get; private set; }
    private bool IsCurrentInterface { get; }
    private bool IsCurrentClass { get; }
    private bool IsCurrentStruct { get; }
    private bool IsCurrentEnum { get; }
    private bool IsCurrentDelegate { get; }
    private string NullToken { get; }
    private CodeGeneratorOptions Options { get; }
    private TextWriter Output { get; }
    internal CSharpCodeGenerator(IDictionary`2<string, string> providerOptions);
    private static CSharpCodeGenerator();
    private string get_FileExtension();
    private string get_CompilerName();
    private string get_CurrentTypeName();
    private int get_Indent();
    private void set_Indent(int value);
    private bool get_IsCurrentInterface();
    private bool get_IsCurrentClass();
    private bool get_IsCurrentStruct();
    private bool get_IsCurrentEnum();
    private bool get_IsCurrentDelegate();
    private string get_NullToken();
    private CodeGeneratorOptions get_Options();
    private TextWriter get_Output();
    private string QuoteSnippetStringCStyle(string value);
    private string QuoteSnippetStringVerbatimStyle(string value);
    private string QuoteSnippetString(string value);
    private void ContinueOnNewLine(string st);
    private void OutputIdentifier(string ident);
    private void OutputType(CodeTypeReference typeRef);
    private void GenerateArrayCreateExpression(CodeArrayCreateExpression e);
    private void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e);
    private void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e);
    private void GenerateCastExpression(CodeCastExpression e);
    public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
    private void GenerateDefaultValueExpression(CodeDefaultValueExpression e);
    private void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e);
    private void GenerateEvents(CodeTypeDeclaration e);
    private void GenerateFields(CodeTypeDeclaration e);
    private void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e);
    private void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e);
    private void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e);
    private void GenerateIndexerExpression(CodeIndexerExpression e);
    private void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e);
    private void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e);
    private void GenerateSnippetExpression(CodeSnippetExpression e);
    private void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e);
    private void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e);
    private bool GetUserData(CodeObject e, string property, bool defaultValue);
    private void GenerateNamespace(CodeNamespace e);
    private void GenerateStatement(CodeStatement e);
    private void GenerateStatements(CodeStatementCollection stmts);
    private void GenerateNamespaceImports(CodeNamespace e);
    private void GenerateEventReferenceExpression(CodeEventReferenceExpression e);
    private void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e);
    private void GenerateObjectCreateExpression(CodeObjectCreateExpression e);
    private void GeneratePrimitiveExpression(CodePrimitiveExpression e);
    private void GeneratePrimitiveExpressionBase(CodePrimitiveExpression e);
    private void GeneratePrimitiveChar(char c);
    private void AppendEscapedChar(StringBuilder b, char value);
    private void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e);
    private void GenerateThisReferenceExpression(CodeThisReferenceExpression e);
    private void GenerateExpressionStatement(CodeExpressionStatement e);
    private void GenerateIterationStatement(CodeIterationStatement e);
    private void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e);
    private void GenerateComment(CodeComment e);
    private void GenerateCommentStatement(CodeCommentStatement e);
    private void GenerateCommentStatements(CodeCommentStatementCollection e);
    private void GenerateMethodReturnStatement(CodeMethodReturnStatement e);
    private void GenerateConditionStatement(CodeConditionStatement e);
    private void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e);
    private void GenerateAssignStatement(CodeAssignStatement e);
    private void GenerateAttachEventStatement(CodeAttachEventStatement e);
    private void GenerateRemoveEventStatement(CodeRemoveEventStatement e);
    private void GenerateSnippetStatement(CodeSnippetStatement e);
    private void GenerateGotoStatement(CodeGotoStatement e);
    private void GenerateLabeledStatement(CodeLabeledStatement e);
    private void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e);
    private void GenerateLinePragmaStart(CodeLinePragma e);
    private void GenerateLinePragmaEnd(CodeLinePragma e);
    private void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c);
    private void GenerateExpression(CodeExpression e);
    private void GenerateField(CodeMemberField e);
    private void GenerateSnippetMember(CodeSnippetTypeMember e);
    private void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e);
    private void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c);
    private void GenerateMethods(CodeTypeDeclaration e);
    private void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c);
    private void GenerateProperties(CodeTypeDeclaration e);
    private void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c);
    private void GenerateSingleFloatValue(float s);
    private void GenerateDoubleValue(double d);
    private void GenerateDecimalValue(decimal d);
    private void OutputVTableModifier(MemberAttributes attributes);
    private void OutputMemberAccessModifier(MemberAttributes attributes);
    private void OutputMemberScopeModifier(MemberAttributes attributes);
    private void OutputOperator(CodeBinaryOperatorType op);
    private void OutputFieldScopeModifier(MemberAttributes attributes);
    private void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e);
    private void GenerateConstructors(CodeTypeDeclaration e);
    private void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c);
    private void GenerateTypeConstructor(CodeTypeConstructor e);
    private void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e);
    private void GenerateTypeOfExpression(CodeTypeOfExpression e);
    private void GenerateType(CodeTypeDeclaration e);
    private void GenerateTypes(CodeNamespace e);
    private void GenerateTypeStart(CodeTypeDeclaration e);
    private void GenerateTypeMember(CodeTypeMember member, CodeTypeDeclaration declaredType);
    private void GenerateTypeConstructors(CodeTypeDeclaration e);
    private void GenerateSnippetMembers(CodeTypeDeclaration e);
    private void GenerateNestedTypes(CodeTypeDeclaration e);
    private void GenerateNamespaces(CodeCompileUnit e);
    private void OutputAttributeArgument(CodeAttributeArgument arg);
    private void OutputDirection(FieldDirection dir);
    private void OutputExpressionList(CodeExpressionCollection expressions);
    private void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems);
    private void OutputParameters(CodeParameterDeclarationExpressionCollection parameters);
    private void OutputTypeNamePair(CodeTypeReference typeRef, string name);
    private void OutputTypeParameters(CodeTypeParameterCollection typeParameters);
    private void OutputTypeParameterConstraints(CodeTypeParameterCollection typeParameters);
    private void OutputTypeAttributes(CodeTypeDeclaration e);
    private void GenerateTypeEnd(CodeTypeDeclaration e);
    private void GenerateNamespaceStart(CodeNamespace e);
    private void GenerateCompileUnit(CodeCompileUnit e);
    private void GenerateCompileUnitStart(CodeCompileUnit e);
    private void GenerateCompileUnitEnd(CodeCompileUnit e);
    private void GenerateDirectionExpression(CodeDirectionExpression e);
    private void GenerateDirectives(CodeDirectiveCollection directives);
    private void GenerateChecksumPragma(CodeChecksumPragma checksumPragma);
    private void GenerateCodeRegionDirective(CodeRegionDirective regionDirective);
    private void GenerateNamespaceEnd(CodeNamespace e);
    private void GenerateNamespaceImport(CodeNamespaceImport e);
    private void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes);
    private void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes);
    private void GenerateAttributes(CodeAttributeDeclarationCollection attributes);
    private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix);
    private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix, bool inLine);
    public sealed virtual bool Supports(GeneratorSupport support);
    public sealed virtual bool IsValidIdentifier(string value);
    public sealed virtual void ValidateIdentifier(string value);
    public sealed virtual string CreateValidIdentifier(string name);
    public sealed virtual string CreateEscapedIdentifier(string name);
    private string GetBaseTypeOutput(CodeTypeReference typeRef, bool preferBuiltInTypes);
    private string GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments);
    private void GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments, int start, int length, StringBuilder sb);
    public sealed virtual string GetTypeOutput(CodeTypeReference typeRef);
    private void OutputStartingBrace();
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea);
    private CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e);
    private CompilerResults FromFile(CompilerParameters options, string fileName);
    private CompilerResults FromSource(CompilerParameters options, string source);
    private CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea);
    private void ResolveReferencedAssemblies(CompilerParameters options, CodeCompileUnit e);
    private CompilerResults FromSourceBatch(CompilerParameters options, String[] sources);
    private static string JoinStringArray(String[] sa, string separator);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o);
    private CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames);
    private static string BuildArgs(CompilerParameters options, String[] fileNames, IDictionary`2<string, string> providerOptions);
    private static CompilerError CreateErrorFromString(string error_string);
    private static string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension, bool keepFile);
}
public class Microsoft.CSharp.CSharpCodeProvider : CodeDomProvider {
    private CSharpCodeGenerator _generator;
    public string FileExtension { get; }
    public CSharpCodeProvider(IDictionary`2<string, string> providerOptions);
    public virtual string get_FileExtension();
    [ObsoleteAttribute("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class.")]
public virtual ICodeGenerator CreateGenerator();
    [ObsoleteAttribute("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class.")]
public virtual ICodeCompiler CreateCompiler();
    public virtual TypeConverter GetConverter(Type type);
    public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
}
internal class Microsoft.CSharp.CSharpMemberAttributeConverter : CSharpModifierAttributeConverter {
    [CompilerGeneratedAttribute]
private static CSharpMemberAttributeConverter <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Values>k__BackingField;
    public static CSharpMemberAttributeConverter Default { get; }
    protected String[] Names { get; }
    protected Object[] Values { get; }
    protected object DefaultValue { get; }
    private static CSharpMemberAttributeConverter();
    [CompilerGeneratedAttribute]
public static CSharpMemberAttributeConverter get_Default();
    [CompilerGeneratedAttribute]
protected virtual String[] get_Names();
    [CompilerGeneratedAttribute]
protected virtual Object[] get_Values();
    protected virtual object get_DefaultValue();
}
internal abstract class Microsoft.CSharp.CSharpModifierAttributeConverter : TypeConverter {
    protected Object[] Values { get; }
    protected String[] Names { get; }
    protected object DefaultValue { get; }
    protected abstract virtual Object[] get_Values();
    protected abstract virtual String[] get_Names();
    protected abstract virtual object get_DefaultValue();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
}
internal class Microsoft.CSharp.CSharpTypeAttributeConverter : CSharpModifierAttributeConverter {
    [CompilerGeneratedAttribute]
private static CSharpTypeAttributeConverter <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Values>k__BackingField;
    public static CSharpTypeAttributeConverter Default { get; }
    protected String[] Names { get; }
    protected Object[] Values { get; }
    protected object DefaultValue { get; }
    private static CSharpTypeAttributeConverter();
    [CompilerGeneratedAttribute]
public static CSharpTypeAttributeConverter get_Default();
    [CompilerGeneratedAttribute]
protected virtual String[] get_Names();
    [CompilerGeneratedAttribute]
protected virtual Object[] get_Values();
    protected virtual object get_DefaultValue();
}
internal class Microsoft.VisualBasic.VBCodeGenerator : CodeCompiler {
    private static Char[] s_periodArray;
    private static int MaxLineLength;
    private static GeneratorSupport LanguageSupport;
    private int _statementDepth;
    private IDictionary`2<string, string> _provOptions;
    private static String[][] s_keywords;
    protected string FileExtension { get; }
    protected string CompilerName { get; }
    private bool IsCurrentModule { get; }
    protected string NullToken { get; }
    internal VBCodeGenerator(IDictionary`2<string, string> providerOptions);
    private static VBCodeGenerator();
    protected virtual string get_FileExtension();
    protected virtual string get_CompilerName();
    private bool get_IsCurrentModule();
    protected virtual string get_NullToken();
    private void EnsureInDoubleQuotes(Boolean& fInDoubleQuotes, StringBuilder b);
    private void EnsureNotInDoubleQuotes(Boolean& fInDoubleQuotes, StringBuilder b);
    protected virtual string QuoteSnippetString(string value);
    private static void AppendEscapedChar(StringBuilder b, char value);
    protected virtual void ProcessCompilerOutputLine(CompilerResults results, string line);
    protected virtual string CmdArgsFromParameters(CompilerParameters options);
    protected virtual void OutputAttributeArgument(CodeAttributeArgument arg);
    private void OutputAttributes(CodeAttributeDeclarationCollection attributes, bool inLine);
    private void OutputAttributes(CodeAttributeDeclarationCollection attributes, bool inLine, string prefix, bool closingLine);
    protected virtual void OutputDirection(FieldDirection dir);
    protected virtual void GenerateDefaultValueExpression(CodeDefaultValueExpression e);
    protected virtual void GenerateDirectionExpression(CodeDirectionExpression e);
    protected virtual void OutputFieldScopeModifier(MemberAttributes attributes);
    protected virtual void OutputMemberAccessModifier(MemberAttributes attributes);
    private void OutputVTableModifier(MemberAttributes attributes);
    protected virtual void OutputMemberScopeModifier(MemberAttributes attributes);
    protected virtual void OutputOperator(CodeBinaryOperatorType op);
    private void GenerateNotIsNullExpression(CodeExpression e);
    protected virtual void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e);
    protected virtual string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs);
    protected virtual void OutputIdentifier(string ident);
    protected virtual void OutputType(CodeTypeReference typeRef);
    private void OutputTypeAttributes(CodeTypeDeclaration e);
    protected virtual void OutputTypeNamePair(CodeTypeReference typeRef, string name);
    private string GetArrayPostfix(CodeTypeReference typeRef);
    private void OutputArrayPostfix(CodeTypeReference typeRef);
    protected virtual void GenerateIterationStatement(CodeIterationStatement e);
    protected virtual void GeneratePrimitiveExpression(CodePrimitiveExpression e);
    protected virtual void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e);
    protected virtual void GenerateArrayCreateExpression(CodeArrayCreateExpression e);
    protected virtual void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e);
    protected virtual void GenerateCastExpression(CodeCastExpression e);
    protected virtual void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e);
    protected virtual void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e);
    protected virtual void GenerateSingleFloatValue(float s);
    protected virtual void GenerateDoubleValue(double d);
    protected virtual void GenerateDecimalValue(decimal d);
    protected virtual void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e);
    protected virtual void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e);
    protected virtual void GenerateIndexerExpression(CodeIndexerExpression e);
    protected virtual void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e);
    protected virtual void GenerateSnippetExpression(CodeSnippetExpression e);
    protected virtual void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e);
    protected virtual void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e);
    protected virtual void GenerateEventReferenceExpression(CodeEventReferenceExpression e);
    private void GenerateFormalEventReferenceExpression(CodeEventReferenceExpression e);
    protected virtual void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e);
    protected virtual void GenerateObjectCreateExpression(CodeObjectCreateExpression e);
    protected virtual void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e);
    protected virtual void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e);
    protected virtual void GenerateThisReferenceExpression(CodeThisReferenceExpression e);
    protected virtual void GenerateExpressionStatement(CodeExpressionStatement e);
    private bool IsDocComment(CodeCommentStatement comment);
    protected virtual void GenerateCommentStatements(CodeCommentStatementCollection e);
    protected virtual void GenerateComment(CodeComment e);
    protected virtual void GenerateMethodReturnStatement(CodeMethodReturnStatement e);
    protected virtual void GenerateConditionStatement(CodeConditionStatement e);
    protected virtual void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e);
    protected virtual void GenerateAssignStatement(CodeAssignStatement e);
    protected virtual void GenerateAttachEventStatement(CodeAttachEventStatement e);
    protected virtual void GenerateRemoveEventStatement(CodeRemoveEventStatement e);
    protected virtual void GenerateSnippetStatement(CodeSnippetStatement e);
    protected virtual void GenerateGotoStatement(CodeGotoStatement e);
    protected virtual void GenerateLabeledStatement(CodeLabeledStatement e);
    protected virtual void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e);
    protected virtual void GenerateLinePragmaStart(CodeLinePragma e);
    protected virtual void GenerateLinePragmaEnd(CodeLinePragma e);
    protected virtual void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c);
    protected virtual void GenerateField(CodeMemberField e);
    private bool MethodIsOverloaded(CodeMemberMethod e, CodeTypeDeclaration c);
    protected virtual void GenerateSnippetMember(CodeSnippetTypeMember e);
    protected virtual void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c);
    protected virtual void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c);
    private bool PropertyIsOverloaded(CodeMemberProperty e, CodeTypeDeclaration c);
    protected virtual void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c);
    protected virtual void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e);
    protected virtual void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c);
    protected virtual void GenerateTypeConstructor(CodeTypeConstructor e);
    protected virtual void GenerateTypeOfExpression(CodeTypeOfExpression e);
    protected virtual void GenerateTypeStart(CodeTypeDeclaration e);
    private void OutputTypeParameters(CodeTypeParameterCollection typeParameters);
    private void OutputTypeParameterConstraints(CodeTypeParameter typeParameter);
    protected virtual void GenerateTypeEnd(CodeTypeDeclaration e);
    protected virtual void GenerateNamespace(CodeNamespace e);
    private bool AllowLateBound(CodeCompileUnit e);
    private bool RequireVariableDeclaration(CodeCompileUnit e);
    private bool GetUserData(CodeObject e, string property, bool defaultValue);
    protected virtual void GenerateCompileUnitStart(CodeCompileUnit e);
    protected virtual void GenerateCompileUnit(CodeCompileUnit e);
    protected virtual void GenerateDirectives(CodeDirectiveCollection directives);
    private void GenerateChecksumPragma(CodeChecksumPragma checksumPragma);
    private void GenerateCodeRegionDirective(CodeRegionDirective regionDirective);
    protected virtual void GenerateNamespaceStart(CodeNamespace e);
    protected virtual void GenerateNamespaceEnd(CodeNamespace e);
    protected virtual void GenerateNamespaceImport(CodeNamespaceImport e);
    protected virtual void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes);
    protected virtual void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes);
    public static bool IsKeyword(string value);
    protected virtual bool Supports(GeneratorSupport support);
    protected virtual bool IsValidIdentifier(string value);
    protected virtual string CreateValidIdentifier(string name);
    protected virtual string CreateEscapedIdentifier(string name);
    private string GetBaseTypeOutput(CodeTypeReference typeRef, bool preferBuiltInTypes);
    private string GetTypeOutputWithoutArrayPostFix(CodeTypeReference typeRef);
    private string GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments);
    private void GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments, int start, int length, StringBuilder sb);
    protected virtual string GetTypeOutput(CodeTypeReference typeRef);
    protected virtual void ContinueOnNewLine(string st);
    private bool IsGeneratingStatements();
    private void GenerateVBStatements(CodeStatementCollection stms);
    protected virtual CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames);
    private static string BuildArgs(CompilerParameters options, String[] fileNames);
    private static CompilerError CreateErrorFromString(string error_string);
    private static string GetTempFileNameWithExtension(TempFileCollection temp_files, string extension, bool keepFile);
}
public class Microsoft.VisualBasic.VBCodeProvider : CodeDomProvider {
    private VBCodeGenerator _generator;
    public string FileExtension { get; }
    public LanguageOptions LanguageOptions { get; }
    public VBCodeProvider(IDictionary`2<string, string> providerOptions);
    public virtual string get_FileExtension();
    public virtual LanguageOptions get_LanguageOptions();
    [ObsoleteAttribute("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class.")]
public virtual ICodeGenerator CreateGenerator();
    [ObsoleteAttribute("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class.")]
public virtual ICodeCompiler CreateCompiler();
    public virtual TypeConverter GetConverter(Type type);
    public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
}
internal class Microsoft.VisualBasic.VBMemberAttributeConverter : VBModifierAttributeConverter {
    [CompilerGeneratedAttribute]
private static VBMemberAttributeConverter <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Values>k__BackingField;
    public static VBMemberAttributeConverter Default { get; }
    protected String[] Names { get; }
    protected Object[] Values { get; }
    protected object DefaultValue { get; }
    private static VBMemberAttributeConverter();
    [CompilerGeneratedAttribute]
public static VBMemberAttributeConverter get_Default();
    [CompilerGeneratedAttribute]
protected virtual String[] get_Names();
    [CompilerGeneratedAttribute]
protected virtual Object[] get_Values();
    protected virtual object get_DefaultValue();
}
internal abstract class Microsoft.VisualBasic.VBModifierAttributeConverter : TypeConverter {
    protected Object[] Values { get; }
    protected String[] Names { get; }
    protected object DefaultValue { get; }
    protected abstract virtual Object[] get_Values();
    protected abstract virtual String[] get_Names();
    protected abstract virtual object get_DefaultValue();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
}
internal class Microsoft.VisualBasic.VBTypeAttributeConverter : VBModifierAttributeConverter {
    [CompilerGeneratedAttribute]
private static VBTypeAttributeConverter <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Values>k__BackingField;
    public static VBTypeAttributeConverter Default { get; }
    protected String[] Names { get; }
    protected Object[] Values { get; }
    protected object DefaultValue { get; }
    private static VBTypeAttributeConverter();
    [CompilerGeneratedAttribute]
public static VBTypeAttributeConverter get_Default();
    [CompilerGeneratedAttribute]
protected virtual String[] get_Names();
    [CompilerGeneratedAttribute]
protected virtual Object[] get_Values();
    protected virtual object get_DefaultValue();
}
public class Microsoft.Win32.IntranetZoneCredentialPolicy : object {
    public virtual bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authModule);
}
internal static class Microsoft.Win32.NativeMethods : object {
    public static int E_ABORT;
    public static int PROCESS_TERMINATE;
    public static int PROCESS_CREATE_THREAD;
    public static int PROCESS_SET_SESSIONID;
    public static int PROCESS_VM_OPERATION;
    public static int PROCESS_VM_READ;
    public static int PROCESS_VM_WRITE;
    public static int PROCESS_DUP_HANDLE;
    public static int PROCESS_CREATE_PROCESS;
    public static int PROCESS_SET_QUOTA;
    public static int PROCESS_SET_INFORMATION;
    public static int PROCESS_QUERY_INFORMATION;
    public static int PROCESS_QUERY_LIMITED_INFORMATION;
    public static int STANDARD_RIGHTS_REQUIRED;
    public static int SYNCHRONIZE;
    public static int PROCESS_ALL_ACCESS;
    public static int DUPLICATE_CLOSE_SOURCE;
    public static int DUPLICATE_SAME_ACCESS;
    public static int STILL_ACTIVE;
    public static int WAIT_OBJECT_0;
    public static int WAIT_FAILED;
    public static int WAIT_TIMEOUT;
    public static int WAIT_ABANDONED;
    public static int WAIT_ABANDONED_0;
    public static int ERROR_FILE_NOT_FOUND;
    public static int ERROR_PATH_NOT_FOUND;
    public static int ERROR_ACCESS_DENIED;
    public static int ERROR_INVALID_HANDLE;
    public static int ERROR_SHARING_VIOLATION;
    public static int ERROR_INVALID_NAME;
    public static int ERROR_ALREADY_EXISTS;
    public static int ERROR_FILENAME_EXCED_RANGE;
    public static bool DuplicateHandle(HandleRef hSourceProcessHandle, SafeHandle hSourceHandle, HandleRef hTargetProcess, SafeWaitHandle& targetHandle, int dwDesiredAccess, bool bInheritHandle, int dwOptions);
    public static bool DuplicateHandle(HandleRef hSourceProcessHandle, HandleRef hSourceHandle, HandleRef hTargetProcess, SafeProcessHandle& targetHandle, int dwDesiredAccess, bool bInheritHandle, int dwOptions);
    public static IntPtr GetCurrentProcess();
    public static bool GetExitCodeProcess(IntPtr processHandle, Int32& exitCode);
    public static bool GetExitCodeProcess(SafeProcessHandle processHandle, Int32& exitCode);
    public static bool TerminateProcess(IntPtr processHandle, int exitCode);
    public static bool TerminateProcess(SafeProcessHandle processHandle, int exitCode);
    public static int WaitForInputIdle(IntPtr handle, int milliseconds);
    public static int WaitForInputIdle(SafeProcessHandle handle, int milliseconds);
    public static bool GetProcessWorkingSetSize(IntPtr handle, IntPtr& min, IntPtr& max);
    public static bool GetProcessWorkingSetSize(SafeProcessHandle handle, IntPtr& min, IntPtr& max);
    public static bool SetProcessWorkingSetSize(IntPtr handle, IntPtr min, IntPtr max);
    public static bool SetProcessWorkingSetSize(SafeProcessHandle handle, IntPtr min, IntPtr max);
    public static bool GetProcessTimes(IntPtr handle, Int64& creation, Int64& exit, Int64& kernel, Int64& user);
    public static bool GetProcessTimes(SafeProcessHandle handle, Int64& creation, Int64& exit, Int64& kernel, Int64& user);
    public static int GetCurrentProcessId();
    public static int GetPriorityClass(IntPtr handle);
    public static int GetPriorityClass(SafeProcessHandle handle);
    public static bool SetPriorityClass(IntPtr handle, int priorityClass);
    public static bool SetPriorityClass(SafeProcessHandle handle, int priorityClass);
    public static bool CloseProcess(IntPtr handle);
}
public class Microsoft.Win32.PowerModeChangedEventArgs : EventArgs {
    private PowerModes mymode;
    public PowerModes Mode { get; }
    public PowerModeChangedEventArgs(PowerModes mode);
    public PowerModes get_Mode();
}
public class Microsoft.Win32.PowerModeChangedEventHandler : MulticastDelegate {
    public PowerModeChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PowerModeChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PowerModeChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.Win32.PowerModes : Enum {
    public int value__;
    public static PowerModes Resume;
    public static PowerModes StatusChange;
    public static PowerModes Suspend;
}
[SuppressUnmanagedCodeSecurityAttribute]
public class Microsoft.Win32.SafeHandles.SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeProcessHandle InvalidHandle;
    internal SafeProcessHandle(IntPtr handle);
    public SafeProcessHandle(IntPtr existingHandle, bool ownsHandle);
    private static SafeProcessHandle();
    internal void InitialSetHandle(IntPtr h);
    protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeX509ChainHandle(IntPtr handle);
    [MonoTODOAttribute]
protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SessionEndedEventArgs : EventArgs {
    private SessionEndReasons myreason;
    public SessionEndReasons Reason { get; }
    public SessionEndedEventArgs(SessionEndReasons reason);
    public SessionEndReasons get_Reason();
}
public class Microsoft.Win32.SessionEndedEventHandler : MulticastDelegate {
    public SessionEndedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SessionEndedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SessionEndedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Win32.SessionEndingEventArgs : EventArgs {
    private SessionEndReasons myreason;
    private bool mycancel;
    public SessionEndReasons Reason { get; }
    public bool Cancel { get; public set; }
    public SessionEndingEventArgs(SessionEndReasons reason);
    public SessionEndReasons get_Reason();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class Microsoft.Win32.SessionEndingEventHandler : MulticastDelegate {
    public SessionEndingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SessionEndingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SessionEndingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.Win32.SessionEndReasons : Enum {
    public int value__;
    public static SessionEndReasons Logoff;
    public static SessionEndReasons SystemShutdown;
}
public class Microsoft.Win32.SessionSwitchEventArgs : EventArgs {
    private SessionSwitchReason reason;
    public SessionSwitchReason Reason { get; }
    public SessionSwitchEventArgs(SessionSwitchReason reason);
    public SessionSwitchReason get_Reason();
}
public class Microsoft.Win32.SessionSwitchEventHandler : MulticastDelegate {
    public SessionSwitchEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SessionSwitchEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SessionSwitchEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.Win32.SessionSwitchReason : Enum {
    public int value__;
    public static SessionSwitchReason ConsoleConnect;
    public static SessionSwitchReason ConsoleDisconnect;
    public static SessionSwitchReason RemoteConnect;
    public static SessionSwitchReason RemoteDisconnect;
    public static SessionSwitchReason SessionLogon;
    public static SessionSwitchReason SessionLogoff;
    public static SessionSwitchReason SessionLock;
    public static SessionSwitchReason SessionUnlock;
    public static SessionSwitchReason SessionRemoteControl;
}
public class Microsoft.Win32.SystemEvents : object {
    private static Hashtable TimerStore;
    [CompilerGeneratedAttribute]
private static TimerElapsedEventHandler TimerElapsed;
    private static SystemEvents();
    public static IntPtr CreateTimer(int interval);
    public static void KillTimer(IntPtr timerId);
    private static void InternalTimerElapsed(object e, ElapsedEventArgs args);
    [MonoTODOAttribute]
public static void InvokeOnEventsThread(Delegate method);
    public static void add_DisplaySettingsChanged(EventHandler value);
    public static void remove_DisplaySettingsChanged(EventHandler value);
    public static void add_DisplaySettingsChanging(EventHandler value);
    public static void remove_DisplaySettingsChanging(EventHandler value);
    public static void add_EventsThreadShutdown(EventHandler value);
    public static void remove_EventsThreadShutdown(EventHandler value);
    public static void add_InstalledFontsChanged(EventHandler value);
    public static void remove_InstalledFontsChanged(EventHandler value);
    public static void add_LowMemory(EventHandler value);
    public static void remove_LowMemory(EventHandler value);
    public static void add_PaletteChanged(EventHandler value);
    public static void remove_PaletteChanged(EventHandler value);
    public static void add_PowerModeChanged(PowerModeChangedEventHandler value);
    public static void remove_PowerModeChanged(PowerModeChangedEventHandler value);
    public static void add_SessionEnded(SessionEndedEventHandler value);
    public static void remove_SessionEnded(SessionEndedEventHandler value);
    public static void add_SessionEnding(SessionEndingEventHandler value);
    public static void remove_SessionEnding(SessionEndingEventHandler value);
    public static void add_SessionSwitch(SessionSwitchEventHandler value);
    public static void remove_SessionSwitch(SessionSwitchEventHandler value);
    public static void add_TimeChanged(EventHandler value);
    public static void remove_TimeChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static void add_TimerElapsed(TimerElapsedEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_TimerElapsed(TimerElapsedEventHandler value);
    public static void add_UserPreferenceChanged(UserPreferenceChangedEventHandler value);
    public static void remove_UserPreferenceChanged(UserPreferenceChangedEventHandler value);
    public static void add_UserPreferenceChanging(UserPreferenceChangingEventHandler value);
    public static void remove_UserPreferenceChanging(UserPreferenceChangingEventHandler value);
}
public class Microsoft.Win32.TimerElapsedEventArgs : EventArgs {
    private IntPtr mytimerId;
    public IntPtr TimerId { get; }
    public TimerElapsedEventArgs(IntPtr timerId);
    public IntPtr get_TimerId();
}
public class Microsoft.Win32.TimerElapsedEventHandler : MulticastDelegate {
    public TimerElapsedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TimerElapsedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TimerElapsedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.Win32.UserPreferenceCategory : Enum {
    public int value__;
    public static UserPreferenceCategory Accessibility;
    public static UserPreferenceCategory Color;
    public static UserPreferenceCategory Desktop;
    public static UserPreferenceCategory General;
    public static UserPreferenceCategory Icon;
    public static UserPreferenceCategory Keyboard;
    public static UserPreferenceCategory Menu;
    public static UserPreferenceCategory Mouse;
    public static UserPreferenceCategory Policy;
    public static UserPreferenceCategory Power;
    public static UserPreferenceCategory Screensaver;
    public static UserPreferenceCategory Window;
    public static UserPreferenceCategory Locale;
    public static UserPreferenceCategory VisualStyle;
}
public class Microsoft.Win32.UserPreferenceChangedEventArgs : EventArgs {
    private UserPreferenceCategory mycategory;
    public UserPreferenceCategory Category { get; }
    public UserPreferenceChangedEventArgs(UserPreferenceCategory category);
    public UserPreferenceCategory get_Category();
}
public class Microsoft.Win32.UserPreferenceChangedEventHandler : MulticastDelegate {
    public UserPreferenceChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UserPreferenceChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UserPreferenceChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Win32.UserPreferenceChangingEventArgs : EventArgs {
    private UserPreferenceCategory mycategory;
    public UserPreferenceCategory Category { get; }
    public UserPreferenceChangingEventArgs(UserPreferenceCategory category);
    public UserPreferenceCategory get_Category();
}
public class Microsoft.Win32.UserPreferenceChangingEventHandler : MulticastDelegate {
    public UserPreferenceChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UserPreferenceChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UserPreferenceChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Mono.Audio.AlsaDevice : AudioDevice {
    private IntPtr handle;
    private IntPtr hw_param;
    private IntPtr sw_param;
    public AlsaDevice(string name);
    private static int snd_pcm_open(IntPtr& handle, string pcm_name, int stream, int mode);
    private static int snd_pcm_close(IntPtr handle);
    private static int snd_pcm_drain(IntPtr handle);
    private static int snd_pcm_writei(IntPtr handle, Byte[] buf, int size);
    private static int snd_pcm_set_params(IntPtr handle, int format, int access, int channels, int rate, int soft_resample, int latency);
    private static int snd_pcm_state(IntPtr handle);
    private static int snd_pcm_prepare(IntPtr handle);
    private static int snd_pcm_hw_params(IntPtr handle, IntPtr param);
    private static int snd_pcm_hw_params_malloc(IntPtr& param);
    private static void snd_pcm_hw_params_free(IntPtr param);
    private static int snd_pcm_hw_params_any(IntPtr handle, IntPtr param);
    private static int snd_pcm_hw_params_set_access(IntPtr handle, IntPtr param, int access);
    private static int snd_pcm_hw_params_set_format(IntPtr handle, IntPtr param, int format);
    private static int snd_pcm_hw_params_set_channels(IntPtr handle, IntPtr param, UInt32 channel);
    private static int snd_pcm_hw_params_set_rate_near(IntPtr handle, IntPtr param, UInt32& rate, Int32& dir);
    private static int snd_pcm_hw_params_set_period_time_near(IntPtr handle, IntPtr param, UInt32& period, Int32& dir);
    private static int snd_pcm_hw_params_get_period_size(IntPtr param, UInt32& period, Int32& dir);
    private static int snd_pcm_hw_params_set_buffer_size_near(IntPtr handle, IntPtr param, UInt32& buff_size);
    private static int snd_pcm_hw_params_get_buffer_time_max(IntPtr param, UInt32& buffer_time, Int32& dir);
    private static int snd_pcm_hw_params_set_buffer_time_near(IntPtr handle, IntPtr param, UInt32& BufferTime, Int32& dir);
    private static int snd_pcm_hw_params_get_buffer_size(IntPtr param, UInt32& BufferSize);
    private static int snd_pcm_sw_params(IntPtr handle, IntPtr param);
    private static int snd_pcm_sw_params_malloc(IntPtr& param);
    private static void snd_pcm_sw_params_free(IntPtr param);
    private static int snd_pcm_sw_params_current(IntPtr handle, IntPtr param);
    private static int snd_pcm_sw_params_set_avail_min(IntPtr handle, IntPtr param, UInt32 frames);
    private static int snd_pcm_sw_params_set_start_threshold(IntPtr handle, IntPtr param, UInt32 StartThreshold);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool SetFormat(AudioFormat format, int channels, int rate);
    public virtual int PlaySample(Byte[] buffer, int num_frames);
    public virtual int XRunRecovery(int err);
    public virtual void Wait();
}
internal class Mono.Audio.AuData : AudioData {
    private Stream stream;
    private short channels;
    private ushort frame_divider;
    private int sample_rate;
    private int data_len;
    private AudioFormat format;
    public int Channels { get; }
    public int Rate { get; }
    public AudioFormat Format { get; }
    public AuData(Stream data);
    public virtual void Play(AudioDevice dev);
    public virtual int get_Channels();
    public virtual int get_Rate();
    public virtual AudioFormat get_Format();
}
internal abstract class Mono.Audio.AudioData : object {
    protected static int buffer_size;
    private bool stopped;
    public int Channels { get; }
    public int Rate { get; }
    public AudioFormat Format { get; }
    public bool IsStopped { get; public set; }
    public abstract virtual int get_Channels();
    public abstract virtual int get_Rate();
    public abstract virtual AudioFormat get_Format();
    public virtual void Setup(AudioDevice dev);
    public abstract virtual void Play(AudioDevice dev);
    public virtual bool get_IsStopped();
    public virtual void set_IsStopped(bool value);
}
internal class Mono.Audio.AudioDevice : object {
    protected UInt32 chunk_size;
    public UInt32 ChunkSize { get; }
    private static AudioDevice TryAlsa(string name);
    public static AudioDevice CreateDevice(string name);
    public virtual bool SetFormat(AudioFormat format, int channels, int rate);
    public virtual int PlaySample(Byte[] buffer, int num_frames);
    public virtual int XRunRecovery(int err);
    public virtual void Wait();
    public UInt32 get_ChunkSize();
}
internal enum Mono.Audio.AudioFormat : Enum {
    public int value__;
    public static AudioFormat S8;
    public static AudioFormat U8;
    public static AudioFormat S16_LE;
    public static AudioFormat S16_BE;
    public static AudioFormat U16_LE;
    public static AudioFormat U16_BE;
    public static AudioFormat S24_LE;
    public static AudioFormat S24_BE;
    public static AudioFormat U24_LE;
    public static AudioFormat U24_BE;
    public static AudioFormat S32_LE;
    public static AudioFormat S32_BE;
    public static AudioFormat U32_LE;
    public static AudioFormat U32_BE;
    public static AudioFormat FLOAT_LE;
    public static AudioFormat FLOAT_BE;
    public static AudioFormat FLOAT64_LE;
    public static AudioFormat FLOAT64_BE;
    public static AudioFormat IEC958_SUBFRAME_LE;
    public static AudioFormat IEC958_SUBFRAME_BE;
    public static AudioFormat MU_LAW;
    public static AudioFormat A_LAW;
    public static AudioFormat IMA_ADPCM;
    public static AudioFormat MPEG;
    public static AudioFormat GSM;
}
internal class Mono.Audio.WavData : AudioData {
    private Stream stream;
    private short channels;
    private ushort frame_divider;
    private int sample_rate;
    private int data_len;
    private long data_offset;
    private AudioFormat format;
    public int Channels { get; }
    public int Rate { get; }
    public AudioFormat Format { get; }
    public WavData(Stream data);
    public virtual void Play(AudioDevice dev);
    public virtual int get_Channels();
    public virtual int get_Rate();
    public virtual AudioFormat get_Format();
}
internal class Mono.Audio.Win32SoundPlayer : object {
    private Byte[] _buffer;
    private bool _disposed;
    unknown Stream Stream {public set; }
    public Win32SoundPlayer(Stream s);
    private static bool PlaySound(Byte[] ptrToSound, UIntPtr hmod, SoundFlags flags);
    public void set_Stream(Stream value);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public void Play();
    public void PlayLooping();
    public void PlaySync();
    public void Stop();
}
internal interface Mono.Btls.IMonoBtlsBioMono {
    public abstract virtual int Read(Byte[] buffer, int offset, int size, Boolean& wantMore);
    public abstract virtual bool Write(Byte[] buffer, int offset, int size);
    public abstract virtual void Flush();
    public abstract virtual void Close();
}
internal class Mono.Btls.MonoBtlsBio : MonoBtlsObject {
    protected internal BoringBioHandle Handle { get; }
    internal MonoBtlsBio(BoringBioHandle handle);
    protected internal BoringBioHandle get_Handle();
    public static MonoBtlsBio CreateMonoStream(Stream stream);
    private static int mono_btls_bio_read(IntPtr bio, IntPtr data, int len);
    private static int mono_btls_bio_write(IntPtr bio, IntPtr data, int len);
    private static int mono_btls_bio_flush(IntPtr bio);
    private static int mono_btls_bio_indent(IntPtr bio, UInt32 indent, UInt32 max_indent);
    private static int mono_btls_bio_hexdump(IntPtr bio, IntPtr data, int len, UInt32 indent);
    private static void mono_btls_bio_print_errors(IntPtr bio);
    private static void mono_btls_bio_free(IntPtr handle);
    public int Read(Byte[] buffer, int offset, int size);
    public int Write(Byte[] buffer, int offset, int size);
    public int Flush();
    public int Indent(UInt32 indent, UInt32 max_indent);
    public int HexDump(Byte[] buffer, UInt32 indent);
    public void PrintErrors();
}
internal class Mono.Btls.MonoBtlsBioMemory : MonoBtlsBio {
    private static IntPtr mono_btls_bio_mem_new();
    private static int mono_btls_bio_mem_get_data(IntPtr handle, IntPtr& data);
    public Byte[] GetData();
}
internal class Mono.Btls.MonoBtlsBioMono : MonoBtlsBio {
    private GCHandle handle;
    private IntPtr instance;
    private BioReadFunc readFunc;
    private BioWriteFunc writeFunc;
    private BioControlFunc controlFunc;
    private IntPtr readFuncPtr;
    private IntPtr writeFuncPtr;
    private IntPtr controlFuncPtr;
    private IMonoBtlsBioMono backend;
    public MonoBtlsBioMono(IMonoBtlsBioMono backend);
    public static MonoBtlsBioMono CreateStream(Stream stream, bool ownsStream);
    public static MonoBtlsBioMono CreateString(StringWriter writer);
    private static IntPtr mono_btls_bio_mono_new();
    private static void mono_btls_bio_mono_initialize(IntPtr handle, IntPtr instance, IntPtr readFunc, IntPtr writeFunc, IntPtr controlFunc);
    private long Control(ControlCommand command, long arg);
    private int OnRead(IntPtr data, int dataLength, Int32& wantMore);
    [MonoPInvokeCallbackAttribute("Mono.Btls.MonoBtlsBioMono/BioReadFunc")]
private static int OnRead(IntPtr instance, IntPtr data, int dataLength, Int32& wantMore);
    private int OnWrite(IntPtr data, int dataLength);
    [MonoPInvokeCallbackAttribute("Mono.Btls.MonoBtlsBioMono/BioWriteFunc")]
private static int OnWrite(IntPtr instance, IntPtr data, int dataLength);
    [MonoPInvokeCallbackAttribute("Mono.Btls.MonoBtlsBioMono/BioControlFunc")]
private static long Control(IntPtr instance, ControlCommand command, long arg);
    protected virtual void Close();
}
internal class Mono.Btls.MonoBtlsContext : MobileTlsContext {
    private X509Certificate2 remoteCertificate;
    private X509Certificate clientCertificate;
    private X509CertificateImplBtls nativeServerCertificate;
    private X509CertificateImplBtls nativeClientCertificate;
    private MonoBtlsSslCtx ctx;
    private MonoBtlsSsl ssl;
    private MonoBtlsBio bio;
    private MonoBtlsBio errbio;
    private MonoTlsConnectionInfo connectionInfo;
    private bool certificateValidated;
    private bool isAuthenticated;
    private bool connected;
    public MonoBtlsProvider Provider { get; }
    public bool CanRenegotiate { get; }
    public bool HasContext { get; }
    public bool IsAuthenticated { get; }
    public MonoTlsConnectionInfo ConnectionInfo { get; }
    internal bool IsRemoteCertificateAvailable { get; }
    internal X509Certificate LocalClientCertificate { get; }
    public X509Certificate2 RemoteCertificate { get; }
    public TlsProtocols NegotiatedProtocol { get; }
    public MonoBtlsContext(MobileAuthenticatedStream parent, MonoSslAuthenticationOptions options);
    private static X509CertificateImplBtls GetPrivateCertificate(X509Certificate certificate);
    public MonoBtlsProvider get_Provider();
    private int VerifyCallback(MonoBtlsX509StoreCtx storeCtx);
    private int SelectCallback(String[] acceptableIssuers);
    private int ServerNameCallback();
    public virtual void StartHandshake();
    private void SetPrivateCertificate(X509CertificateImplBtls privateCert);
    private static Exception GetException(MonoBtlsSslError status);
    public virtual bool ProcessHandshake();
    private MonoBtlsSslError DoProcessHandshake();
    public virtual void FinishHandshake();
    private void InitializeConnection();
    private void GetPeerCertificate();
    private void InitializeSession();
    private static TlsProtocols GetProtocol(TlsProtocolCode protocol);
    public virtual void Flush();
    public virtual ValueTuple`2<int, bool> Read(Byte[] buffer, int offset, int size);
    public virtual ValueTuple`2<int, bool> Write(Byte[] buffer, int offset, int size);
    public virtual bool get_CanRenegotiate();
    public virtual void Renegotiate();
    public virtual void Shutdown();
    public virtual bool PendingRenegotiation();
    private void Dispose(T& disposable);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override int Mono.Btls.IMonoBtlsBioMono.Read(Byte[] buffer, int offset, int size, Boolean& wantMore);
    private sealed virtual override bool Mono.Btls.IMonoBtlsBioMono.Write(Byte[] buffer, int offset, int size);
    private sealed virtual override void Mono.Btls.IMonoBtlsBioMono.Flush();
    private sealed virtual override void Mono.Btls.IMonoBtlsBioMono.Close();
    public virtual bool get_HasContext();
    public virtual bool get_IsAuthenticated();
    public virtual MonoTlsConnectionInfo get_ConnectionInfo();
    internal virtual bool get_IsRemoteCertificateAvailable();
    internal virtual X509Certificate get_LocalClientCertificate();
    public virtual X509Certificate2 get_RemoteCertificate();
    public virtual TlsProtocols get_NegotiatedProtocol();
}
internal static class Mono.Btls.MonoBtlsError : object {
    private static int mono_btls_error_peek_error();
    private static int mono_btls_error_get_error();
    private static void mono_btls_error_clear_error();
    private static int mono_btls_error_peek_error_line(IntPtr& file, Int32& line);
    private static int mono_btls_error_get_error_line(IntPtr& file, Int32& line);
    private static void mono_btls_error_get_error_string_n(int error, IntPtr buf, int len);
    private static int mono_btls_error_get_reason(int error);
    public static int PeekError();
    public static int GetError();
    public static void ClearError();
    public static string GetErrorString(int error);
    public static int PeekError(String& file, Int32& line);
    public static int GetError(String& file, Int32& line);
    public static int GetErrorReason(int error);
}
internal class Mono.Btls.MonoBtlsException : Exception {
    public MonoBtlsException(MonoBtlsSslError error);
    public MonoBtlsException(string message);
    public MonoBtlsException(string format, Object[] args);
}
internal class Mono.Btls.MonoBtlsKey : MonoBtlsObject {
    internal BoringKeyHandle Handle { get; }
    public bool IsRsa { get; }
    internal MonoBtlsKey(BoringKeyHandle handle);
    private static IntPtr mono_btls_key_new();
    private static void mono_btls_key_free(IntPtr handle);
    private static IntPtr mono_btls_key_up_ref(IntPtr handle);
    private static int mono_btls_key_get_bytes(IntPtr handle, IntPtr& data, Int32& size, int include_private_bits);
    private static int mono_btls_key_get_bits(IntPtr handle);
    private static int mono_btls_key_is_rsa(IntPtr handle);
    private static int mono_btls_key_assign_rsa_private_key(IntPtr handle, Byte[] der, int der_length);
    internal BoringKeyHandle get_Handle();
    public Byte[] GetBytes(bool include_private_bits);
    public bool get_IsRsa();
    public MonoBtlsKey Copy();
    public static MonoBtlsKey CreateFromRSAPrivateKey(RSA privateKey);
}
internal abstract class Mono.Btls.MonoBtlsObject : object {
    internal static string BTLS_DYLIB;
    private MonoBtlsHandle handle;
    private Exception lastError;
    internal MonoBtlsHandle Handle { get; }
    public bool IsValid { get; }
    internal MonoBtlsObject(MonoBtlsHandle handle);
    internal MonoBtlsHandle get_Handle();
    public bool get_IsValid();
    protected void CheckThrow();
    protected Exception SetException(Exception ex);
    protected void CheckError(bool ok, string callerName);
    protected void CheckError(int ret, string callerName);
    protected internal void CheckLastError(string callerName);
    private static void mono_btls_free(IntPtr data);
    protected void FreeDataPtr(IntPtr data);
    protected virtual void Close();
    protected void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal class Mono.Btls.MonoBtlsPkcs12 : MonoBtlsObject {
    private MonoBtlsKey privateKey;
    internal BoringPkcs12Handle Handle { get; }
    public int Count { get; }
    public bool HasPrivateKey { get; }
    internal MonoBtlsPkcs12(BoringPkcs12Handle handle);
    internal BoringPkcs12Handle get_Handle();
    private static void mono_btls_pkcs12_free(IntPtr handle);
    private static IntPtr mono_btls_pkcs12_new();
    private static int mono_btls_pkcs12_get_count(IntPtr handle);
    private static IntPtr mono_btls_pkcs12_get_cert(IntPtr Handle, int index);
    private static int mono_btls_pkcs12_add_cert(IntPtr chain, IntPtr x509);
    private static int mono_btls_pkcs12_import(IntPtr chain, Void* data, int len, SafePasswordHandle password);
    private static int mono_btls_pkcs12_has_private_key(IntPtr pkcs12);
    private static IntPtr mono_btls_pkcs12_get_private_key(IntPtr pkcs12);
    public int get_Count();
    public MonoBtlsX509 GetCertificate(int index);
    public void AddCertificate(MonoBtlsX509 x509);
    public void Import(Byte[] buffer, SafePasswordHandle password);
    public bool get_HasPrivateKey();
    public MonoBtlsKey GetPrivateKey();
}
internal class Mono.Btls.MonoBtlsProvider : MobileTlsProvider {
    public Guid ID { get; }
    public string Name { get; }
    public bool SupportsSslStream { get; }
    public bool SupportsMonoExtensions { get; }
    public bool SupportsConnectionInfo { get; }
    internal bool SupportsCleanShutdown { get; }
    public SslProtocols SupportedProtocols { get; }
    internal bool HasNativeCertificates { get; }
    public virtual Guid get_ID();
    public virtual string get_Name();
    public virtual bool get_SupportsSslStream();
    public virtual bool get_SupportsMonoExtensions();
    public virtual bool get_SupportsConnectionInfo();
    internal virtual bool get_SupportsCleanShutdown();
    public virtual SslProtocols get_SupportedProtocols();
    internal virtual MobileAuthenticatedStream CreateSslStream(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings);
    internal virtual bool get_HasNativeCertificates();
    internal X509Certificate2Impl GetNativeCertificate(Byte[] data, string password, X509KeyStorageFlags flags);
    internal X509Certificate2Impl GetNativeCertificate(X509Certificate certificate);
    internal X509Certificate2Impl GetNativeCertificate(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags flags);
    internal static MonoBtlsX509VerifyParam GetVerifyParam(MonoTlsSettings settings, string targetHost, bool serverMode);
    internal virtual bool ValidateCertificate(ChainValidationHelper validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain& chain, SslPolicyErrors& errors, Int32& status11);
    internal static bool ValidateCertificate(MonoBtlsX509Chain chain, MonoBtlsX509VerifyParam param);
    private void CheckValidationResult(ChainValidationHelper validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain chain, MonoBtlsX509StoreCtx storeCtx, bool success, SslPolicyErrors& errors, Int32& status11);
    internal static X509ChainStatusFlags MapVerifyErrorToChainStatus(MonoBtlsX509Error code);
    internal static void SetupCertificateStore(MonoBtlsX509Store store, MonoTlsSettings settings, bool server);
    private static void SetupDefaultCertificateStore(MonoBtlsX509Store store);
    private static void AddUserStore(MonoBtlsX509Store store);
    private static void AddMachineStore(MonoBtlsX509Store store);
    private static void AddTrustedRoots(MonoBtlsX509Store store, MonoTlsSettings settings, bool server);
    public static string GetSystemStoreLocation();
    public static X509Certificate2 CreateCertificate(Byte[] data, MonoBtlsX509Format format);
    public static X509Certificate2 CreateCertificate(Byte[] data, string password, bool disallowFallback);
    public static X509Certificate2 CreateCertificate(MonoBtlsX509 x509);
    public static X509Chain CreateChain();
    public static X509Chain GetManagedChain(MonoBtlsX509Chain chain);
    public static MonoBtlsX509 GetBtlsCertificate(X509Certificate certificate);
    public static MonoBtlsX509Chain GetNativeChain(X509CertificateCollection certificates);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class Mono.Btls.MonoBtlsSelectCallback : MulticastDelegate {
    public MonoBtlsSelectCallback(object object, IntPtr method);
    public virtual int Invoke(String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class Mono.Btls.MonoBtlsServerNameCallback : MulticastDelegate {
    public MonoBtlsServerNameCallback(object object, IntPtr method);
    public virtual int Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class Mono.Btls.MonoBtlsSsl : MonoBtlsObject {
    private MonoBtlsBio bio;
    private PrintErrorsCallbackFunc printErrorsFunc;
    private IntPtr printErrorsFuncPtr;
    internal BoringSslHandle Handle { get; }
    public MonoBtlsSsl(MonoBtlsSslCtx ctx);
    private static void mono_btls_ssl_destroy(IntPtr handle);
    private static IntPtr mono_btls_ssl_new(IntPtr handle);
    private static int mono_btls_ssl_use_certificate(IntPtr handle, IntPtr x509);
    private static int mono_btls_ssl_use_private_key(IntPtr handle, IntPtr key);
    private static int mono_btls_ssl_add_chain_certificate(IntPtr handle, IntPtr x509);
    private static int mono_btls_ssl_accept(IntPtr handle);
    private static int mono_btls_ssl_connect(IntPtr handle);
    private static int mono_btls_ssl_handshake(IntPtr handle);
    private static void mono_btls_ssl_close(IntPtr handle);
    private static int mono_btls_ssl_shutdown(IntPtr handle);
    private static void mono_btls_ssl_set_quiet_shutdown(IntPtr handle, int mode);
    private static void mono_btls_ssl_set_bio(IntPtr handle, IntPtr bio);
    private static int mono_btls_ssl_read(IntPtr handle, IntPtr data, int len);
    private static int mono_btls_ssl_write(IntPtr handle, IntPtr data, int len);
    private static int mono_btls_ssl_get_error(IntPtr handle, int ret_code);
    private static int mono_btls_ssl_get_version(IntPtr handle);
    private static void mono_btls_ssl_set_min_version(IntPtr handle, int version);
    private static void mono_btls_ssl_set_max_version(IntPtr handle, int version);
    private static int mono_btls_ssl_get_cipher(IntPtr handle);
    private static int mono_btls_ssl_get_ciphers(IntPtr handle, IntPtr& data);
    private static IntPtr mono_btls_ssl_get_peer_certificate(IntPtr handle);
    private static int mono_btls_ssl_set_cipher_list(IntPtr handle, IntPtr str);
    private static void mono_btls_ssl_print_errors_cb(IntPtr func, IntPtr ctx);
    private static int mono_btls_ssl_set_verify_param(IntPtr handle, IntPtr param);
    private static int mono_btls_ssl_set_server_name(IntPtr handle, IntPtr name);
    private static IntPtr mono_btls_ssl_get_server_name(IntPtr handle);
    private static void mono_btls_ssl_set_renegotiate_mode(IntPtr handle, int mode);
    private static int mono_btls_ssl_renegotiate_pending(IntPtr handle);
    private static BoringSslHandle Create_internal(MonoBtlsSslCtx ctx);
    internal BoringSslHandle get_Handle();
    public void SetBio(MonoBtlsBio bio);
    private Exception ThrowError(string callerName);
    private MonoBtlsSslError GetError(int ret_code);
    public void SetCertificate(MonoBtlsX509 x509);
    public void SetPrivateKey(MonoBtlsKey key);
    public void AddIntermediateCertificate(MonoBtlsX509 x509);
    public MonoBtlsSslError Accept();
    public MonoBtlsSslError Connect();
    public MonoBtlsSslError Handshake();
    [MonoPInvokeCallbackAttribute("Mono.Btls.MonoBtlsSsl/PrintErrorsCallbackFunc")]
private static int PrintErrorsCallback(IntPtr str, IntPtr len, IntPtr ctx);
    public string GetErrors();
    public void PrintErrors();
    public MonoBtlsSslError Read(IntPtr data, Int32& dataSize);
    public MonoBtlsSslError Write(IntPtr data, Int32& dataSize);
    public int GetVersion();
    public void SetMinVersion(int version);
    public void SetMaxVersion(int version);
    public int GetCipher();
    public Int16[] GetCiphers();
    public void SetCipherList(string str);
    public MonoBtlsX509 GetPeerCertificate();
    public void SetVerifyParam(MonoBtlsX509VerifyParam param);
    public void SetServerName(string name);
    public string GetServerName();
    public void Shutdown();
    public void SetQuietShutdown();
    protected virtual void Close();
    public void SetRenegotiateMode(MonoBtlsSslRenegotiateMode mode);
    public bool RenegotiatePending();
}
internal class Mono.Btls.MonoBtlsSslCtx : MonoBtlsObject {
    private NativeVerifyFunc verifyFunc;
    private NativeSelectFunc selectFunc;
    private NativeServerNameFunc serverNameFunc;
    private IntPtr verifyFuncPtr;
    private IntPtr selectFuncPtr;
    private IntPtr serverNameFuncPtr;
    private MonoBtlsVerifyCallback verifyCallback;
    private MonoBtlsSelectCallback selectCallback;
    private MonoBtlsServerNameCallback serverNameCallback;
    private MonoBtlsX509Store store;
    private GCHandle instance;
    private IntPtr instancePtr;
    internal BoringSslCtxHandle Handle { get; }
    public MonoBtlsX509Store CertificateStore { get; }
    internal MonoBtlsSslCtx(BoringSslCtxHandle handle);
    internal BoringSslCtxHandle get_Handle();
    private static IntPtr mono_btls_ssl_ctx_new();
    private static int mono_btls_ssl_ctx_free(IntPtr handle);
    private static IntPtr mono_btls_ssl_ctx_up_ref(IntPtr handle);
    private static void mono_btls_ssl_ctx_initialize(IntPtr handle, IntPtr instance);
    private static void mono_btls_ssl_ctx_set_debug_bio(IntPtr handle, IntPtr bio);
    private static void mono_btls_ssl_ctx_set_cert_verify_callback(IntPtr handle, IntPtr func, int cert_required);
    private static void mono_btls_ssl_ctx_set_cert_select_callback(IntPtr handle, IntPtr func);
    private static void mono_btls_ssl_ctx_set_min_version(IntPtr handle, int version);
    private static void mono_btls_ssl_ctx_set_max_version(IntPtr handle, int version);
    private static int mono_btls_ssl_ctx_is_cipher_supported(IntPtr handle, short value);
    private static int mono_btls_ssl_ctx_set_ciphers(IntPtr handle, int count, IntPtr data, int allow_unsupported);
    private static int mono_btls_ssl_ctx_set_verify_param(IntPtr handle, IntPtr param);
    private static int mono_btls_ssl_ctx_set_client_ca_list(IntPtr handle, int count, IntPtr sizes, IntPtr data);
    private static void mono_btls_ssl_ctx_set_server_name_callback(IntPtr handle, IntPtr func);
    internal MonoBtlsSslCtx Copy();
    public MonoBtlsX509Store get_CertificateStore();
    private int VerifyCallback(bool preverify_ok, MonoBtlsX509StoreCtx ctx);
    [MonoPInvokeCallbackAttribute("Mono.Btls.MonoBtlsSslCtx/NativeVerifyFunc")]
private static int NativeVerifyCallback(IntPtr instance, int preverify_ok, IntPtr store_ctx);
    [MonoPInvokeCallbackAttribute("Mono.Btls.MonoBtlsSslCtx/NativeSelectFunc")]
private static int NativeSelectCallback(IntPtr instance, int count, IntPtr sizes, IntPtr data);
    private static String[] CopyIssuers(int count, IntPtr sizesPtr, IntPtr dataPtr);
    public void SetDebugBio(MonoBtlsBio bio);
    public void SetVerifyCallback(MonoBtlsVerifyCallback callback, bool client_cert_required);
    public void SetSelectCallback(MonoBtlsSelectCallback callback);
    public void SetMinVersion(int version);
    public void SetMaxVersion(int version);
    public bool IsCipherSupported(short value);
    public void SetCiphers(Int16[] ciphers, bool allow_unsupported);
    public void SetVerifyParam(MonoBtlsX509VerifyParam param);
    public void SetClientCertificateIssuers(String[] acceptableIssuers);
    public void SetServerNameCallback(MonoBtlsServerNameCallback callback);
    [MonoPInvokeCallbackAttribute("Mono.Btls.MonoBtlsSslCtx/NativeServerNameFunc")]
private static int NativeServerNameCallback(IntPtr instance);
    protected virtual void Close();
}
internal enum Mono.Btls.MonoBtlsSslError : Enum {
    public int value__;
    public static MonoBtlsSslError None;
    public static MonoBtlsSslError Ssl;
    public static MonoBtlsSslError WantRead;
    public static MonoBtlsSslError WantWrite;
    public static MonoBtlsSslError WantX509Lookup;
    public static MonoBtlsSslError Syscall;
    public static MonoBtlsSslError ZeroReturn;
    public static MonoBtlsSslError WantConnect;
    public static MonoBtlsSslError WantAccept;
    public static MonoBtlsSslError WantChannelIdLookup;
    public static MonoBtlsSslError PendingSession;
    public static MonoBtlsSslError PendingCertificate;
    public static MonoBtlsSslError WantPrivateKeyOperation;
}
[FlagsAttribute]
internal enum Mono.Btls.MonoBtlsSslRenegotiateMode : Enum {
    public int value__;
    public static MonoBtlsSslRenegotiateMode NEVER;
    public static MonoBtlsSslRenegotiateMode ONCE;
    public static MonoBtlsSslRenegotiateMode FREELY;
    public static MonoBtlsSslRenegotiateMode IGNORE;
}
internal class Mono.Btls.MonoBtlsStream : MobileAuthenticatedStream {
    public MonoBtlsStream(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MobileTlsProvider provider);
    protected virtual MobileTlsContext CreateContext(MonoSslAuthenticationOptions options);
}
internal static class Mono.Btls.MonoBtlsUtils : object {
    private static Byte[] emailOid;
    private static X500DistinguishedNameFlags AllFlags;
    private static MonoBtlsUtils();
    public static bool Compare(Byte[] a, Byte[] b);
    private static bool AppendEntry(StringBuilder sb, MonoBtlsX509Name name, int index, string separator, bool quotes);
    private static string GetSeparator(X500DistinguishedNameFlags flag);
    public static string FormatName(MonoBtlsX509Name name, X500DistinguishedNameFlags flag);
    public static string FormatName(MonoBtlsX509Name name, bool reversed, string separator, bool quotes);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class Mono.Btls.MonoBtlsVerifyCallback : MulticastDelegate {
    public MonoBtlsVerifyCallback(object object, IntPtr method);
    public virtual int Invoke(MonoBtlsX509StoreCtx ctx);
    public virtual IAsyncResult BeginInvoke(MonoBtlsX509StoreCtx ctx, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class Mono.Btls.MonoBtlsX509 : MonoBtlsObject {
    internal BoringX509Handle Handle { get; }
    internal MonoBtlsX509(BoringX509Handle handle);
    internal BoringX509Handle get_Handle();
    private static IntPtr mono_btls_x509_up_ref(IntPtr handle);
    private static IntPtr mono_btls_x509_from_data(IntPtr data, int len, MonoBtlsX509Format format);
    private static IntPtr mono_btls_x509_get_subject_name(IntPtr handle);
    private static IntPtr mono_btls_x509_get_issuer_name(IntPtr handle);
    private static int mono_btls_x509_get_subject_name_string(IntPtr handle, IntPtr buffer, int size);
    private static int mono_btls_x509_get_issuer_name_string(IntPtr handle, IntPtr buffer, int size);
    private static int mono_btls_x509_get_raw_data(IntPtr handle, IntPtr bio, MonoBtlsX509Format format);
    private static int mono_btls_x509_cmp(IntPtr a, IntPtr b);
    private static int mono_btls_x509_get_hash(IntPtr handle, IntPtr& data);
    private static long mono_btls_x509_get_not_before(IntPtr handle);
    private static long mono_btls_x509_get_not_after(IntPtr handle);
    private static int mono_btls_x509_get_public_key(IntPtr handle, IntPtr bio);
    private static int mono_btls_x509_get_serial_number(IntPtr handle, IntPtr data, int size, int mono_style);
    private static int mono_btls_x509_get_version(IntPtr handle);
    private static int mono_btls_x509_get_signature_algorithm(IntPtr handle, IntPtr buffer, int size);
    private static int mono_btls_x509_get_public_key_asn1(IntPtr handle, IntPtr oid, int oid_size, IntPtr& data, Int32& size);
    private static int mono_btls_x509_get_public_key_parameters(IntPtr handle, IntPtr oid, int oid_size, IntPtr& data, Int32& size);
    private static IntPtr mono_btls_x509_get_pubkey(IntPtr handle);
    private static int mono_btls_x509_get_subject_key_identifier(IntPtr handle, IntPtr& data, Int32& size);
    private static int mono_btls_x509_print(IntPtr handle, IntPtr bio);
    private static void mono_btls_x509_free(IntPtr handle);
    private static IntPtr mono_btls_x509_dup(IntPtr handle);
    private static int mono_btls_x509_add_trust_object(IntPtr handle, MonoBtlsX509Purpose purpose);
    private static int mono_btls_x509_add_reject_object(IntPtr handle, MonoBtlsX509Purpose purpose);
    private static int mono_btls_x509_add_explicit_trust(IntPtr handle, MonoBtlsX509TrustKind kind);
    internal MonoBtlsX509 Copy();
    internal MonoBtlsX509 Duplicate();
    public static MonoBtlsX509 LoadFromData(Byte[] buffer, MonoBtlsX509Format format);
    public MonoBtlsX509Name GetSubjectName();
    public string GetSubjectNameString();
    public long GetSubjectNameHash();
    public MonoBtlsX509Name GetIssuerName();
    public string GetIssuerNameString();
    public Byte[] GetRawData(MonoBtlsX509Format format);
    public void GetRawData(MonoBtlsBio bio, MonoBtlsX509Format format);
    public static int Compare(MonoBtlsX509 a, MonoBtlsX509 b);
    public Byte[] GetCertHash();
    public DateTime GetNotBefore();
    public DateTime GetNotAfter();
    public Byte[] GetPublicKeyData();
    public Byte[] GetSerialNumber(bool mono_style);
    public int GetVersion();
    public string GetSignatureAlgorithm();
    public AsnEncodedData GetPublicKeyAsn1();
    public AsnEncodedData GetPublicKeyParameters();
    public Byte[] GetSubjectKeyIdentifier();
    public MonoBtlsKey GetPublicKey();
    public void Print(MonoBtlsBio bio);
    public void ExportAsPEM(MonoBtlsBio bio, bool includeHumanReadableForm);
    public void AddTrustObject(MonoBtlsX509Purpose purpose);
    public void AddRejectObject(MonoBtlsX509Purpose purpose);
    public void AddExplicitTrust(MonoBtlsX509TrustKind kind);
}
internal class Mono.Btls.MonoBtlsX509Chain : MonoBtlsObject {
    internal BoringX509ChainHandle Handle { get; }
    public int Count { get; }
    internal MonoBtlsX509Chain(BoringX509ChainHandle handle);
    internal BoringX509ChainHandle get_Handle();
    private static IntPtr mono_btls_x509_chain_new();
    private static int mono_btls_x509_chain_get_count(IntPtr handle);
    private static IntPtr mono_btls_x509_chain_get_cert(IntPtr Handle, int index);
    private static int mono_btls_x509_chain_add_cert(IntPtr chain, IntPtr x509);
    private static IntPtr mono_btls_x509_chain_up_ref(IntPtr handle);
    private static void mono_btls_x509_chain_free(IntPtr handle);
    public int get_Count();
    public MonoBtlsX509 GetCertificate(int index);
    public void Dump();
    public void AddCertificate(MonoBtlsX509 x509);
    internal MonoBtlsX509Chain Copy();
}
internal class Mono.Btls.MonoBtlsX509Crl : MonoBtlsObject {
    internal BoringX509CrlHandle Handle { get; }
    internal MonoBtlsX509Crl(BoringX509CrlHandle handle);
    internal BoringX509CrlHandle get_Handle();
    private static IntPtr mono_btls_x509_crl_ref(IntPtr handle);
    private static IntPtr mono_btls_x509_crl_from_data(IntPtr data, int len, MonoBtlsX509Format format);
    private static IntPtr mono_btls_x509_crl_get_by_cert(IntPtr handle, IntPtr x509);
    private static IntPtr mono_btls_x509_crl_get_by_serial(IntPtr handle, Void* serial, int len);
    private static int mono_btls_x509_crl_get_revoked_count(IntPtr handle);
    private static IntPtr mono_btls_x509_crl_get_revoked(IntPtr handle, int index);
    private static long mono_btls_x509_crl_get_last_update(IntPtr handle);
    private static long mono_btls_x509_crl_get_next_update(IntPtr handle);
    private static long mono_btls_x509_crl_get_version(IntPtr handle);
    private static IntPtr mono_btls_x509_crl_get_issuer(IntPtr handle);
    private static void mono_btls_x509_crl_free(IntPtr handle);
    public static MonoBtlsX509Crl LoadFromData(Byte[] buffer, MonoBtlsX509Format format);
    public MonoBtlsX509Revoked GetByCert(MonoBtlsX509 x509);
    public MonoBtlsX509Revoked GetBySerial(Byte[] serial);
    public int GetRevokedCount();
    public MonoBtlsX509Revoked GetRevoked(int index);
    public DateTime GetLastUpdate();
    public DateTime GetNextUpdate();
    public long GetVersion();
    public MonoBtlsX509Name GetIssuerName();
}
internal enum Mono.Btls.MonoBtlsX509Error : Enum {
    public int value__;
    public static MonoBtlsX509Error OK;
    public static MonoBtlsX509Error UNABLE_TO_GET_ISSUER_CERT;
    public static MonoBtlsX509Error UNABLE_TO_GET_CRL;
    public static MonoBtlsX509Error UNABLE_TO_DECRYPT_CERT_SIGNATURE;
    public static MonoBtlsX509Error UNABLE_TO_DECRYPT_CRL_SIGNATURE;
    public static MonoBtlsX509Error UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
    public static MonoBtlsX509Error CERT_SIGNATURE_FAILURE;
    public static MonoBtlsX509Error CRL_SIGNATURE_FAILURE;
    public static MonoBtlsX509Error CERT_NOT_YET_VALID;
    public static MonoBtlsX509Error CERT_HAS_EXPIRED;
    public static MonoBtlsX509Error CRL_NOT_YET_VALID;
    public static MonoBtlsX509Error CRL_HAS_EXPIRED;
    public static MonoBtlsX509Error ERROR_IN_CERT_NOT_BEFORE_FIELD;
    public static MonoBtlsX509Error ERROR_IN_CERT_NOT_AFTER_FIELD;
    public static MonoBtlsX509Error ERROR_IN_CRL_LAST_UPDATE_FIELD;
    public static MonoBtlsX509Error ERROR_IN_CRL_NEXT_UPDATE_FIELD;
    public static MonoBtlsX509Error OUT_OF_MEM;
    public static MonoBtlsX509Error DEPTH_ZERO_SELF_SIGNED_CERT;
    public static MonoBtlsX509Error SELF_SIGNED_CERT_IN_CHAIN;
    public static MonoBtlsX509Error UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
    public static MonoBtlsX509Error UNABLE_TO_VERIFY_LEAF_SIGNATURE;
    public static MonoBtlsX509Error CERT_CHAIN_TOO_LONG;
    public static MonoBtlsX509Error CERT_REVOKED;
    public static MonoBtlsX509Error INVALID_CA;
    public static MonoBtlsX509Error PATH_LENGTH_EXCEEDED;
    public static MonoBtlsX509Error INVALID_PURPOSE;
    public static MonoBtlsX509Error CERT_UNTRUSTED;
    public static MonoBtlsX509Error CERT_REJECTED;
    public static MonoBtlsX509Error SUBJECT_ISSUER_MISMATCH;
    public static MonoBtlsX509Error AKID_SKID_MISMATCH;
    public static MonoBtlsX509Error AKID_ISSUER_SERIAL_MISMATCH;
    public static MonoBtlsX509Error KEYUSAGE_NO_CERTSIGN;
    public static MonoBtlsX509Error UNABLE_TO_GET_CRL_ISSUER;
    public static MonoBtlsX509Error UNHANDLED_CRITICAL_EXTENSION;
    public static MonoBtlsX509Error KEYUSAGE_NO_CRL_SIGN;
    public static MonoBtlsX509Error UNHANDLED_CRITICAL_CRL_EXTENSION;
    public static MonoBtlsX509Error INVALID_NON_CA;
    public static MonoBtlsX509Error PROXY_PATH_LENGTH_EXCEEDED;
    public static MonoBtlsX509Error KEYUSAGE_NO_DIGITAL_SIGNATURE;
    public static MonoBtlsX509Error PROXY_CERTIFICATES_NOT_ALLOWED;
    public static MonoBtlsX509Error INVALID_EXTENSION;
    public static MonoBtlsX509Error INVALID_POLICY_EXTENSION;
    public static MonoBtlsX509Error NO_EXPLICIT_POLICY;
    public static MonoBtlsX509Error DIFFERENT_CRL_SCOPE;
    public static MonoBtlsX509Error UNSUPPORTED_EXTENSION_FEATURE;
    public static MonoBtlsX509Error UNNESTED_RESOURCE;
    public static MonoBtlsX509Error PERMITTED_VIOLATION;
    public static MonoBtlsX509Error EXCLUDED_VIOLATION;
    public static MonoBtlsX509Error SUBTREE_MINMAX;
    public static MonoBtlsX509Error UNSUPPORTED_CONSTRAINT_TYPE;
    public static MonoBtlsX509Error UNSUPPORTED_CONSTRAINT_SYNTAX;
    public static MonoBtlsX509Error UNSUPPORTED_NAME_SYNTAX;
    public static MonoBtlsX509Error CRL_PATH_VALIDATION_ERROR;
    public static MonoBtlsX509Error SUITE_B_INVALID_VERSION;
    public static MonoBtlsX509Error SUITE_B_INVALID_ALGORITHM;
    public static MonoBtlsX509Error SUITE_B_INVALID_CURVE;
    public static MonoBtlsX509Error SUITE_B_INVALID_SIGNATURE_ALGORITHM;
    public static MonoBtlsX509Error SUITE_B_LOS_NOT_ALLOWED;
    public static MonoBtlsX509Error SUITE_B_CANNOT_SIGN_P_384_WITH_P_256;
    public static MonoBtlsX509Error HOSTNAME_MISMATCH;
    public static MonoBtlsX509Error EMAIL_MISMATCH;
    public static MonoBtlsX509Error IP_ADDRESS_MISMATCH;
    public static MonoBtlsX509Error APPLICATION_VERIFICATION;
}
internal class Mono.Btls.MonoBtlsX509Exception : Exception {
    [CompilerGeneratedAttribute]
private MonoBtlsX509Error <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public MonoBtlsX509Error ErrorCode { get; private set; }
    public string ErrorMessage { get; private set; }
    public MonoBtlsX509Exception(MonoBtlsX509Error code, string message);
    [CompilerGeneratedAttribute]
public MonoBtlsX509Error get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(MonoBtlsX509Error value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
private void set_ErrorMessage(string value);
    public virtual string ToString();
}
internal enum Mono.Btls.MonoBtlsX509FileType : Enum {
    public int value__;
    public static MonoBtlsX509FileType PEM;
    public static MonoBtlsX509FileType ASN1;
    public static MonoBtlsX509FileType DEFAULT;
}
internal enum Mono.Btls.MonoBtlsX509Format : Enum {
    public int value__;
    public static MonoBtlsX509Format DER;
    public static MonoBtlsX509Format PEM;
}
internal class Mono.Btls.MonoBtlsX509Lookup : MonoBtlsObject {
    private MonoBtlsX509Store store;
    private MonoBtlsX509LookupType type;
    private List`1<MonoBtlsX509LookupMono> monoLookups;
    internal BoringX509LookupHandle Handle { get; }
    internal MonoBtlsX509Lookup(MonoBtlsX509Store store, MonoBtlsX509LookupType type);
    internal BoringX509LookupHandle get_Handle();
    private static IntPtr mono_btls_x509_lookup_new(IntPtr store, MonoBtlsX509LookupType type);
    private static int mono_btls_x509_lookup_load_file(IntPtr handle, IntPtr file, MonoBtlsX509FileType type);
    private static int mono_btls_x509_lookup_add_dir(IntPtr handle, IntPtr dir, MonoBtlsX509FileType type);
    private static int mono_btls_x509_lookup_add_mono(IntPtr handle, IntPtr monoLookup);
    private static int mono_btls_x509_lookup_init(IntPtr handle);
    private static int mono_btls_x509_lookup_shutdown(IntPtr handle);
    private static IntPtr mono_btls_x509_lookup_by_subject(IntPtr handle, IntPtr name);
    private static IntPtr mono_btls_x509_lookup_by_fingerprint(IntPtr handle, IntPtr bytes, int len);
    private static void mono_btls_x509_lookup_free(IntPtr handle);
    private static IntPtr mono_btls_x509_lookup_peek_lookup(IntPtr handle);
    private static BoringX509LookupHandle Create_internal(MonoBtlsX509Store store, MonoBtlsX509LookupType type);
    internal IntPtr GetNativeLookup();
    public void LoadFile(string file, MonoBtlsX509FileType type);
    public void AddDirectory(string dir, MonoBtlsX509FileType type);
    internal void AddMono(MonoBtlsX509LookupMono monoLookup);
    public void Initialize();
    public void Shutdown();
    public MonoBtlsX509 LookupBySubject(MonoBtlsX509Name name);
    public MonoBtlsX509 LookupByFingerPrint(Byte[] fingerprint);
    internal void AddCertificate(MonoBtlsX509 certificate);
    protected virtual void Close();
}
internal abstract class Mono.Btls.MonoBtlsX509LookupMono : MonoBtlsObject {
    private GCHandle gch;
    private IntPtr instance;
    private BySubjectFunc bySubjectFunc;
    private IntPtr bySubjectFuncPtr;
    private MonoBtlsX509Lookup lookup;
    internal BoringX509LookupMonoHandle Handle { get; }
    internal BoringX509LookupMonoHandle get_Handle();
    private static IntPtr mono_btls_x509_lookup_mono_new();
    private static void mono_btls_x509_lookup_mono_init(IntPtr handle, IntPtr instance, IntPtr by_subject_func);
    private static int mono_btls_x509_lookup_mono_free(IntPtr handle);
    internal void Install(MonoBtlsX509Lookup lookup);
    protected void AddCertificate(MonoBtlsX509 certificate);
    protected abstract virtual MonoBtlsX509 OnGetBySubject(MonoBtlsX509Name name);
    [MonoPInvokeCallbackAttribute("Mono.Btls.MonoBtlsX509LookupMono/BySubjectFunc")]
private static int OnGetBySubject(IntPtr instance, IntPtr name_ptr, IntPtr& x509_ptr);
    protected virtual void Close();
}
internal class Mono.Btls.MonoBtlsX509LookupMonoCollection : MonoBtlsX509LookupMono {
    private Int64[] hashes;
    private MonoBtlsX509[] certificates;
    private X509CertificateCollection collection;
    private MonoBtlsX509TrustKind trust;
    internal MonoBtlsX509LookupMonoCollection(X509CertificateCollection collection, MonoBtlsX509TrustKind trust);
    private void Initialize();
    protected virtual MonoBtlsX509 OnGetBySubject(MonoBtlsX509Name name);
    protected virtual void Close();
}
internal enum Mono.Btls.MonoBtlsX509LookupType : Enum {
    public int value__;
    public static MonoBtlsX509LookupType UNKNOWN;
    public static MonoBtlsX509LookupType FILE;
    public static MonoBtlsX509LookupType HASH_DIR;
    public static MonoBtlsX509LookupType MONO;
}
internal class Mono.Btls.MonoBtlsX509Name : MonoBtlsObject {
    internal BoringX509NameHandle Handle { get; }
    internal MonoBtlsX509Name(BoringX509NameHandle handle);
    private static int mono_btls_x509_name_print_bio(IntPtr handle, IntPtr bio);
    private static int mono_btls_x509_name_print_string(IntPtr handle, IntPtr buffer, int size);
    private static int mono_btls_x509_name_get_raw_data(IntPtr handle, IntPtr& buffer, int use_canon_enc);
    private static long mono_btls_x509_name_hash(IntPtr handle);
    private static long mono_btls_x509_name_hash_old(IntPtr handle);
    private static int mono_btls_x509_name_get_entry_count(IntPtr handle);
    private static MonoBtlsX509NameEntryType mono_btls_x509_name_get_entry_type(IntPtr name, int index);
    private static int mono_btls_x509_name_get_entry_oid(IntPtr name, int index, IntPtr buffer, int size);
    private static int mono_btls_x509_name_get_entry_oid_data(IntPtr name, int index, IntPtr& data);
    private static int mono_btls_x509_name_get_entry_value(IntPtr name, int index, Int32& tag, IntPtr& str);
    private static IntPtr mono_btls_x509_name_from_data(Void* data, int len, int use_canon_enc);
    private static void mono_btls_x509_name_free(IntPtr handle);
    internal BoringX509NameHandle get_Handle();
    public string GetString();
    public void PrintBio(MonoBtlsBio bio);
    public Byte[] GetRawData(bool use_canon_enc);
    public long GetHash();
    public long GetHashOld();
    public int GetEntryCount();
    public MonoBtlsX509NameEntryType GetEntryType(int index);
    public string GetEntryOid(int index);
    public Byte[] GetEntryOidData(int index);
    public string GetEntryValue(int index, Int32& tag);
    public static MonoBtlsX509Name CreateFromData(Byte[] data, bool use_canon_enc);
}
internal enum Mono.Btls.MonoBtlsX509NameEntryType : Enum {
    public int value__;
    public static MonoBtlsX509NameEntryType Unknown;
    public static MonoBtlsX509NameEntryType CountryName;
    public static MonoBtlsX509NameEntryType OrganizationName;
    public static MonoBtlsX509NameEntryType OrganizationalUnitName;
    public static MonoBtlsX509NameEntryType CommonName;
    public static MonoBtlsX509NameEntryType LocalityName;
    public static MonoBtlsX509NameEntryType StateOrProvinceName;
    public static MonoBtlsX509NameEntryType StreetAddress;
    public static MonoBtlsX509NameEntryType SerialNumber;
    public static MonoBtlsX509NameEntryType DomainComponent;
    public static MonoBtlsX509NameEntryType UserId;
    public static MonoBtlsX509NameEntryType Email;
    public static MonoBtlsX509NameEntryType DnQualifier;
    public static MonoBtlsX509NameEntryType Title;
    public static MonoBtlsX509NameEntryType Surname;
    public static MonoBtlsX509NameEntryType GivenName;
    public static MonoBtlsX509NameEntryType Initial;
}
internal enum Mono.Btls.MonoBtlsX509Purpose : Enum {
    public int value__;
    public static MonoBtlsX509Purpose SSL_CLIENT;
    public static MonoBtlsX509Purpose SSL_SERVER;
    public static MonoBtlsX509Purpose NS_SSL_SERVER;
    public static MonoBtlsX509Purpose SMIME_SIGN;
    public static MonoBtlsX509Purpose SMIME_ENCRYPT;
    public static MonoBtlsX509Purpose CRL_SIGN;
    public static MonoBtlsX509Purpose ANY;
    public static MonoBtlsX509Purpose OCSP_HELPER;
    public static MonoBtlsX509Purpose TIMESTAMP_SIGN;
}
internal class Mono.Btls.MonoBtlsX509Revoked : MonoBtlsObject {
    internal BoringX509RevokedHandle Handle { get; }
    internal MonoBtlsX509Revoked(BoringX509RevokedHandle handle);
    internal BoringX509RevokedHandle get_Handle();
    private static int mono_btls_x509_revoked_get_serial_number(IntPtr handle, IntPtr data, int size);
    private static long mono_btls_x509_revoked_get_revocation_date(IntPtr handle);
    private static int mono_btls_x509_revoked_get_reason(IntPtr handle);
    private static int mono_btls_x509_revoked_get_sequence(IntPtr handle);
    private static void mono_btls_x509_revoked_free(IntPtr handle);
    public Byte[] GetSerialNumber();
    public DateTime GetRevocationDate();
    public int GetReason();
    public int GetSequence();
}
internal class Mono.Btls.MonoBtlsX509Store : MonoBtlsObject {
    private Dictionary`2<IntPtr, MonoBtlsX509Lookup> lookupHash;
    internal BoringX509StoreHandle Handle { get; }
    internal MonoBtlsX509Store(IntPtr store_ctx);
    internal MonoBtlsX509Store(BoringSslCtxHandle ctx);
    internal BoringX509StoreHandle get_Handle();
    private static IntPtr mono_btls_x509_store_new();
    private static IntPtr mono_btls_x509_store_from_ctx(IntPtr ctx);
    private static IntPtr mono_btls_x509_store_from_ssl_ctx(IntPtr handle);
    private static int mono_btls_x509_store_load_locations(IntPtr handle, IntPtr file, IntPtr path);
    private static int mono_btls_x509_store_set_default_paths(IntPtr handle);
    private static int mono_btls_x509_store_add_cert(IntPtr handle, IntPtr x509);
    private static int mono_btls_x509_store_get_count(IntPtr handle);
    private static void mono_btls_x509_store_free(IntPtr handle);
    public void LoadLocations(string file, string path);
    public void SetDefaultPaths();
    private static BoringX509StoreHandle Create_internal();
    private static BoringX509StoreHandle Create_internal(IntPtr store_ctx);
    private static BoringX509StoreHandle Create_internal(BoringSslCtxHandle ctx);
    public void AddCertificate(MonoBtlsX509 x509);
    public int GetCount();
    internal void AddTrustedRoots();
    public MonoBtlsX509Lookup AddLookup(MonoBtlsX509LookupType type);
    public void AddDirectoryLookup(string dir, MonoBtlsX509FileType type);
    public void AddFileLookup(string file, MonoBtlsX509FileType type);
    public void AddCollection(X509CertificateCollection collection, MonoBtlsX509TrustKind trust);
    protected virtual void Close();
}
internal class Mono.Btls.MonoBtlsX509StoreCtx : MonoBtlsObject {
    private Nullable`1<int> verifyResult;
    internal BoringX509StoreCtxHandle Handle { get; }
    public int VerifyResult { get; }
    internal MonoBtlsX509StoreCtx(int preverify_ok, IntPtr store_ctx);
    internal MonoBtlsX509StoreCtx(BoringX509StoreCtxHandle ptr, Nullable`1<int> verifyResult);
    internal BoringX509StoreCtxHandle get_Handle();
    private static IntPtr mono_btls_x509_store_ctx_new();
    private static IntPtr mono_btls_x509_store_ctx_from_ptr(IntPtr ctx);
    private static MonoBtlsX509Error mono_btls_x509_store_ctx_get_error(IntPtr handle, IntPtr& error_string);
    private static int mono_btls_x509_store_ctx_get_error_depth(IntPtr handle);
    private static IntPtr mono_btls_x509_store_ctx_get_chain(IntPtr handle);
    private static int mono_btls_x509_store_ctx_init(IntPtr handle, IntPtr store, IntPtr chain);
    private static int mono_btls_x509_store_ctx_set_param(IntPtr handle, IntPtr param);
    private static int mono_btls_x509_store_ctx_verify_cert(IntPtr handle);
    private static IntPtr mono_btls_x509_store_ctx_get_by_subject(IntPtr handle, IntPtr name);
    private static IntPtr mono_btls_x509_store_ctx_get_current_cert(IntPtr handle);
    private static IntPtr mono_btls_x509_store_ctx_get_current_issuer(IntPtr handle);
    private static IntPtr mono_btls_x509_store_ctx_get_verify_param(IntPtr handle);
    private static IntPtr mono_btls_x509_store_ctx_get_untrusted(IntPtr handle);
    private static IntPtr mono_btls_x509_store_ctx_up_ref(IntPtr handle);
    private static void mono_btls_x509_store_ctx_free(IntPtr handle);
    private static BoringX509StoreCtxHandle Create_internal(IntPtr store_ctx);
    public MonoBtlsX509Error GetError();
    public int GetErrorDepth();
    public MonoBtlsX509Exception GetException();
    public MonoBtlsX509Chain GetChain();
    public MonoBtlsX509Chain GetUntrusted();
    public void Initialize(MonoBtlsX509Store store, MonoBtlsX509Chain chain);
    public void SetVerifyParam(MonoBtlsX509VerifyParam param);
    public int get_VerifyResult();
    public int Verify();
    public MonoBtlsX509 LookupBySubject(MonoBtlsX509Name name);
    public MonoBtlsX509 GetCurrentCertificate();
    public MonoBtlsX509 GetCurrentIssuer();
    public MonoBtlsX509VerifyParam GetVerifyParam();
    public MonoBtlsX509StoreCtx Copy();
}
internal static class Mono.Btls.MonoBtlsX509StoreManager : object {
    private static bool initialized;
    private static string machineTrustedRootPath;
    private static string machineIntermediateCAPath;
    private static string machineUntrustedPath;
    private static string userTrustedRootPath;
    private static string userIntermediateCAPath;
    private static string userUntrustedPath;
    private static void Initialize();
    private static void DoInitialize();
    public static bool HasStore(MonoBtlsX509StoreType type);
    public static string GetStorePath(MonoBtlsX509StoreType type);
}
internal enum Mono.Btls.MonoBtlsX509StoreType : Enum {
    public int value__;
    public static MonoBtlsX509StoreType Custom;
    public static MonoBtlsX509StoreType MachineTrustedRoots;
    public static MonoBtlsX509StoreType MachineIntermediateCA;
    public static MonoBtlsX509StoreType MachineUntrusted;
    public static MonoBtlsX509StoreType UserTrustedRoots;
    public static MonoBtlsX509StoreType UserIntermediateCA;
    public static MonoBtlsX509StoreType UserUntrusted;
}
[FlagsAttribute]
internal enum Mono.Btls.MonoBtlsX509TrustKind : Enum {
    public int value__;
    public static MonoBtlsX509TrustKind DEFAULT;
    public static MonoBtlsX509TrustKind TRUST_CLIENT;
    public static MonoBtlsX509TrustKind TRUST_SERVER;
    public static MonoBtlsX509TrustKind TRUST_ALL;
    public static MonoBtlsX509TrustKind REJECT_CLIENT;
    public static MonoBtlsX509TrustKind REJECT_SERVER;
    public static MonoBtlsX509TrustKind REJECT_ALL;
}
[FlagsAttribute]
internal enum Mono.Btls.MonoBtlsX509VerifyFlags : Enum {
    public int value__;
    public static MonoBtlsX509VerifyFlags DEFAULT;
    public static MonoBtlsX509VerifyFlags CRL_CHECK;
    public static MonoBtlsX509VerifyFlags CRL_CHECK_ALL;
    public static MonoBtlsX509VerifyFlags X509_STRIC;
}
internal class Mono.Btls.MonoBtlsX509VerifyParam : MonoBtlsObject {
    internal BoringX509VerifyParamHandle Handle { get; }
    public bool CanModify { get; }
    internal MonoBtlsX509VerifyParam(BoringX509VerifyParamHandle handle);
    internal BoringX509VerifyParamHandle get_Handle();
    private static IntPtr mono_btls_x509_verify_param_new();
    private static IntPtr mono_btls_x509_verify_param_copy(IntPtr handle);
    private static IntPtr mono_btls_x509_verify_param_lookup(IntPtr name);
    private static int mono_btls_x509_verify_param_can_modify(IntPtr param);
    private static int mono_btls_x509_verify_param_set_name(IntPtr handle, IntPtr name);
    private static int mono_btls_x509_verify_param_set_host(IntPtr handle, IntPtr name, int namelen);
    private static int mono_btls_x509_verify_param_add_host(IntPtr handle, IntPtr name, int namelen);
    private static ulong mono_btls_x509_verify_param_get_flags(IntPtr handle);
    private static int mono_btls_x509_verify_param_set_flags(IntPtr handle, ulong flags);
    private static MonoBtlsX509VerifyFlags mono_btls_x509_verify_param_get_mono_flags(IntPtr handle);
    private static int mono_btls_x509_verify_param_set_mono_flags(IntPtr handle, MonoBtlsX509VerifyFlags flags);
    private static int mono_btls_x509_verify_param_set_purpose(IntPtr handle, MonoBtlsX509Purpose purpose);
    private static int mono_btls_x509_verify_param_get_depth(IntPtr handle);
    private static int mono_btls_x509_verify_param_set_depth(IntPtr handle, int depth);
    private static int mono_btls_x509_verify_param_set_time(IntPtr handle, long time);
    private static IntPtr mono_btls_x509_verify_param_get_peername(IntPtr handle);
    private static void mono_btls_x509_verify_param_free(IntPtr handle);
    public MonoBtlsX509VerifyParam Copy();
    public static MonoBtlsX509VerifyParam GetSslClient();
    public static MonoBtlsX509VerifyParam GetSslServer();
    public static MonoBtlsX509VerifyParam Lookup(string name, bool fail);
    public bool get_CanModify();
    private void WantToModify();
    public void SetName(string name);
    public void SetHost(string name);
    public void AddHost(string name);
    public ulong GetFlags();
    public void SetFlags(ulong flags);
    public MonoBtlsX509VerifyFlags GetMonoFlags();
    public void SetMonoFlags(MonoBtlsX509VerifyFlags flags);
    public void SetPurpose(MonoBtlsX509Purpose purpose);
    public int GetDepth();
    public void SetDepth(int depth);
    public void SetTime(DateTime time);
    public string GetPeerName();
}
internal class Mono.Btls.X509CertificateImplBtls : X509Certificate2ImplUnix {
    private MonoBtlsX509 x509;
    private MonoBtlsKey nativePrivateKey;
    private X509CertificateImplCollection intermediateCerts;
    private PublicKey publicKey;
    public bool IsValid { get; }
    public IntPtr Handle { get; }
    internal MonoBtlsX509 X509 { get; }
    internal MonoBtlsKey NativePrivateKey { get; }
    internal X509CertificateImplCollection IntermediateCertificates { get; }
    internal X509Certificate2Impl FallbackImpl { get; }
    public bool HasPrivateKey { get; }
    public AsymmetricAlgorithm PrivateKey { get; public set; }
    public PublicKey PublicKey { get; }
    internal X509CertificateImplBtls(MonoBtlsX509 x509);
    private X509CertificateImplBtls(X509CertificateImplBtls other);
    internal X509CertificateImplBtls(Byte[] data, MonoBtlsX509Format format);
    internal X509CertificateImplBtls(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public virtual bool get_IsValid();
    public virtual IntPtr get_Handle();
    public virtual IntPtr GetNativeAppleCertificate();
    internal MonoBtlsX509 get_X509();
    internal MonoBtlsKey get_NativePrivateKey();
    public virtual X509CertificateImpl Clone();
    public virtual bool Equals(X509CertificateImpl other, Boolean& result);
    protected virtual Byte[] GetRawCertData();
    internal virtual X509CertificateImplCollection get_IntermediateCertificates();
    protected virtual void Dispose(bool disposing);
    internal virtual X509Certificate2Impl get_FallbackImpl();
    public virtual bool get_HasPrivateKey();
    public virtual AsymmetricAlgorithm get_PrivateKey();
    public virtual void set_PrivateKey(AsymmetricAlgorithm value);
    public virtual RSA GetRSAPrivateKey();
    public virtual DSA GetDSAPrivateKey();
    public virtual PublicKey get_PublicKey();
    private void Import(Byte[] data);
    private void ImportPkcs12(Byte[] data, SafePasswordHandle password);
    private void ImportAuthenticode(Byte[] data);
    public virtual bool Verify(X509Certificate2 thisCertificate);
    public virtual void Reset();
}
internal class Mono.Btls.X509ChainImplBtls : X509ChainImpl {
    private MonoBtlsX509StoreCtx storeCtx;
    private MonoBtlsX509Chain chain;
    private MonoBtlsX509Chain untrustedChain;
    private X509ChainElementCollection elements;
    private X509Certificate2Collection untrusted;
    private X509Certificate2[] certificates;
    private X509ChainPolicy policy;
    private List`1<X509ChainStatus> chainStatusList;
    public bool IsValid { get; }
    public IntPtr Handle { get; }
    internal MonoBtlsX509Chain Chain { get; }
    internal MonoBtlsX509StoreCtx StoreCtx { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    internal X509ChainImplBtls(MonoBtlsX509Chain chain);
    internal X509ChainImplBtls(MonoBtlsX509StoreCtx storeCtx);
    public virtual bool get_IsValid();
    public virtual IntPtr get_Handle();
    internal MonoBtlsX509Chain get_Chain();
    internal MonoBtlsX509StoreCtx get_StoreCtx();
    public virtual X509ChainElementCollection get_ChainElements();
    public virtual X509ChainPolicy get_ChainPolicy();
    public virtual void set_ChainPolicy(X509ChainPolicy value);
    public virtual X509ChainStatus[] get_ChainStatus();
    public virtual void AddStatus(X509ChainStatusFlags errorCode);
    public virtual bool Build(X509Certificate2 certificate);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
}
internal class Mono.Btls.X509PalImplBtls : X509PalImpl {
    [CompilerGeneratedAttribute]
private MonoBtlsProvider <Provider>k__BackingField;
    private MonoBtlsProvider Provider { get; }
    public X509PalImplBtls(MonoTlsProvider provider);
    [CompilerGeneratedAttribute]
private MonoBtlsProvider get_Provider();
    public virtual X509CertificateImpl Import(Byte[] data);
    public virtual X509Certificate2Impl Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public virtual X509Certificate2Impl Import(X509Certificate cert);
}
[DefaultMemberAttribute("Item")]
internal class Mono.CFArray : CFObject {
    private static IntPtr kCFTypeArrayCallbacks;
    public int Count { get; }
    public IntPtr Item { get; }
    public CFArray(IntPtr handle, bool own);
    private static CFArray();
    private static IntPtr CFArrayCreate(IntPtr allocator, IntPtr values, IntPtr numValues, IntPtr callbacks);
    public static CFArray FromNativeObjects(INativeObject[] values);
    public static IntPtr Create(IntPtr[] values);
    internal static CFArray CreateArray(IntPtr[] values);
    public static CFArray CreateArray(INativeObject[] values);
    public static IntPtr Create(INativeObject[] values);
    private static IntPtr CFArrayGetCount(IntPtr handle);
    public int get_Count();
    private static IntPtr CFArrayGetValueAtIndex(IntPtr handle, IntPtr index);
    public IntPtr get_Item(int index);
    public static T[] ArrayFromHandle(IntPtr handle, Func`2<IntPtr, T> creation);
}
internal class Mono.CFBoolean : object {
    private IntPtr handle;
    public static CFBoolean True;
    public static CFBoolean False;
    public IntPtr Handle { get; }
    public bool Value { get; }
    private static CFBoolean();
    internal CFBoolean(IntPtr handle, bool owns);
    protected virtual override void Finalize();
    public sealed virtual IntPtr get_Handle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static bool op_Implicit(CFBoolean value);
    public static CFBoolean op_Explicit(bool value);
    public static CFBoolean FromBoolean(bool value);
    private static bool CFBooleanGetValue(IntPtr boolean);
    public bool get_Value();
    public static bool GetValue(IntPtr boolean);
}
[DefaultMemberAttribute("Item")]
internal class Mono.CFData : CFObject {
    public IntPtr Length { get; }
    public IntPtr Bytes { get; }
    public byte Item { get; public set; }
    public CFData(IntPtr handle, bool own);
    private static IntPtr CFDataCreate(IntPtr allocator, IntPtr bytes, IntPtr length);
    public static CFData FromData(Byte[] buffer);
    public static CFData FromData(IntPtr buffer, IntPtr length);
    public IntPtr get_Length();
    internal static IntPtr CFDataGetLength(IntPtr theData);
    internal static IntPtr CFDataGetBytePtr(IntPtr theData);
    public IntPtr get_Bytes();
    public byte get_Item(long idx);
    public void set_Item(long idx, byte value);
}
internal class Mono.CFDate : object {
    private IntPtr handle;
    public IntPtr Handle { get; }
    internal CFDate(IntPtr handle, bool owns);
    protected virtual override void Finalize();
    private static IntPtr CFDateCreate(IntPtr allocator, double at);
    public static CFDate Create(DateTime date);
    public sealed virtual IntPtr get_Handle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[DefaultMemberAttribute("Item")]
internal class Mono.CFDictionary : CFObject {
    private static IntPtr KeyCallbacks;
    private static IntPtr ValueCallbacks;
    public IntPtr Item { get; }
    private static CFDictionary();
    public CFDictionary(IntPtr handle, bool own);
    public static CFDictionary FromObjectAndKey(IntPtr obj, IntPtr key);
    public static CFDictionary FromKeysAndObjects(IList`1<Tuple`2<IntPtr, IntPtr>> items);
    private static IntPtr CFDictionaryCreate(IntPtr allocator, IntPtr[] keys, IntPtr[] vals, IntPtr len, IntPtr keyCallbacks, IntPtr valCallbacks);
    private static IntPtr CFDictionaryGetValue(IntPtr handle, IntPtr key);
    private static IntPtr CFDictionaryCreateCopy(IntPtr allocator, IntPtr handle);
    public CFDictionary Copy();
    public CFMutableDictionary MutableCopy();
    private static IntPtr CFDictionaryCreateMutableCopy(IntPtr allocator, IntPtr capacity, IntPtr theDict);
    public IntPtr GetValue(IntPtr key);
    public IntPtr get_Item(IntPtr key);
}
internal class Mono.CFMutableDictionary : CFDictionary {
    public CFMutableDictionary(IntPtr handle, bool own);
    public void SetValue(IntPtr key, IntPtr val);
    public static CFMutableDictionary Create();
    private static void CFDictionarySetValue(IntPtr handle, IntPtr key, IntPtr val);
    private static IntPtr CFDictionaryCreateMutable(IntPtr allocator, IntPtr capacity, IntPtr keyCallback, IntPtr valueCallbacks);
}
internal class Mono.CFNumber : CFObject {
    public CFNumber(IntPtr handle, bool own);
    private static bool CFNumberGetValue(IntPtr handle, IntPtr type, Boolean& value);
    public static bool AsBool(IntPtr handle);
    public static bool op_Implicit(CFNumber number);
    private static bool CFNumberGetValue(IntPtr handle, IntPtr type, Int32& value);
    public static int AsInt32(IntPtr handle);
    private static IntPtr CFNumberCreate(IntPtr allocator, IntPtr theType, IntPtr valuePtr);
    public static CFNumber FromInt32(int number);
    public static int op_Implicit(CFNumber number);
}
internal class Mono.CFObject : object {
    public static string CoreFoundationLibrary;
    private static string SystemLibrary;
    [CompilerGeneratedAttribute]
private IntPtr <Handle>k__BackingField;
    public IntPtr Handle { get; private set; }
    public CFObject(IntPtr handle, bool own);
    public static IntPtr dlopen(string path, int mode);
    private static IntPtr dlsym(IntPtr handle, string symbol);
    public static void dlclose(IntPtr handle);
    public static IntPtr GetIndirect(IntPtr handle, string symbol);
    public static CFString GetStringConstant(IntPtr handle, string symbol);
    public static IntPtr GetIntPtr(IntPtr handle, string symbol);
    public static IntPtr GetCFObjectHandle(IntPtr handle, string symbol);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(IntPtr value);
    internal static IntPtr CFRetain(IntPtr handle);
    private void Retain();
    internal static void CFRelease(IntPtr handle);
    private void Release();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class Mono.CFRange : ValueType {
    public IntPtr Location;
    public IntPtr Length;
    public CFRange(int loc, int len);
}
internal class Mono.CFString : CFObject {
    private string str;
    public int Length { get; }
    public CFString(IntPtr handle, bool own);
    private static IntPtr CFStringCreateWithCharacters(IntPtr alloc, IntPtr chars, IntPtr length);
    public static CFString Create(string value);
    private static IntPtr CFStringGetLength(IntPtr handle);
    public int get_Length();
    private static int CFStringCompare(IntPtr theString1, IntPtr theString2, int compareOptions);
    public static int Compare(IntPtr string1, IntPtr string2, int compareOptions);
    private static IntPtr CFStringGetCharactersPtr(IntPtr handle);
    private static IntPtr CFStringGetCharacters(IntPtr handle, CFRange range, IntPtr buffer);
    public static string AsString(IntPtr handle);
    public virtual string ToString();
    public static string op_Implicit(CFString str);
    public static CFString op_Implicit(string str);
}
internal class Mono.CFType : object {
    public static IntPtr GetTypeID(IntPtr typeRef);
}
internal class Mono.Http.NtlmClient : object {
    private static ConditionalWeakTable`2<HttpWebRequest, NtlmSession> cache;
    public string AuthenticationType { get; }
    public bool CanPreAuthenticate { get; }
    private static NtlmClient();
    public sealed virtual Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
    public sealed virtual Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool get_CanPreAuthenticate();
}
internal class Mono.Http.NtlmSession : object {
    private MessageBase message;
    public Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
}
internal static class Mono.Net.CFNetwork : object {
    public static string CFNetworkLibrary;
    private static object lock_obj;
    private static Queue`1<GetProxyData> get_proxy_queue;
    private static AutoResetEvent proxy_event;
    private static CFNetwork();
    private static IntPtr CFNetworkCopyProxiesForAutoConfigurationScriptSequential(IntPtr proxyAutoConfigurationScript, IntPtr targetURL, IntPtr& error);
    private static IntPtr CFNetworkExecuteProxyAutoConfigurationURL(IntPtr proxyAutoConfigURL, IntPtr targetURL, CFProxyAutoConfigurationResultCallback cb, CFStreamClientContext& clientContext);
    private static void CFNetworkCopyProxiesForAutoConfigurationScriptThread();
    private static IntPtr CFNetworkCopyProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, IntPtr targetURL, IntPtr& error);
    private static CFArray CopyProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, CFUrl targetURL);
    public static CFProxy[] GetProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, CFUrl targetURL);
    public static CFProxy[] GetProxiesForAutoConfigurationScript(IntPtr proxyAutoConfigurationScript, Uri targetUri);
    public static CFProxy[] ExecuteProxyAutoConfigurationURL(IntPtr proxyAutoConfigURL, Uri targetURL);
    private static IntPtr CFNetworkCopyProxiesForURL(IntPtr url, IntPtr proxySettings);
    private static CFArray CopyProxiesForURL(CFUrl url, CFDictionary proxySettings);
    public static CFProxy[] GetProxiesForURL(CFUrl url, CFProxySettings proxySettings);
    public static CFProxy[] GetProxiesForUri(Uri uri, CFProxySettings proxySettings);
    private static IntPtr CFNetworkCopySystemProxySettings();
    public static CFProxySettings GetSystemProxySettings();
    public static IWebProxy GetDefaultProxy();
}
internal class Mono.Net.CFProxy : object {
    private static IntPtr kCFProxyAutoConfigurationJavaScriptKey;
    private static IntPtr kCFProxyAutoConfigurationURLKey;
    private static IntPtr kCFProxyHostNameKey;
    private static IntPtr kCFProxyPasswordKey;
    private static IntPtr kCFProxyPortNumberKey;
    private static IntPtr kCFProxyTypeKey;
    private static IntPtr kCFProxyUsernameKey;
    private static IntPtr kCFProxyTypeAutoConfigurationURL;
    private static IntPtr kCFProxyTypeAutoConfigurationJavaScript;
    private static IntPtr kCFProxyTypeFTP;
    private static IntPtr kCFProxyTypeHTTP;
    private static IntPtr kCFProxyTypeHTTPS;
    private static IntPtr kCFProxyTypeSOCKS;
    private CFDictionary settings;
    public IntPtr AutoConfigurationJavaScript { get; }
    public IntPtr AutoConfigurationUrl { get; }
    public string HostName { get; }
    public string Password { get; }
    public int Port { get; }
    public CFProxyType ProxyType { get; }
    public string Username { get; }
    private static CFProxy();
    internal CFProxy(CFDictionary settings);
    private static CFProxyType CFProxyTypeToEnum(IntPtr type);
    public IntPtr get_AutoConfigurationJavaScript();
    public IntPtr get_AutoConfigurationUrl();
    public string get_HostName();
    public string get_Password();
    public int get_Port();
    public CFProxyType get_ProxyType();
    public string get_Username();
}
internal class Mono.Net.CFProxySettings : object {
    private static IntPtr kCFNetworkProxiesHTTPEnable;
    private static IntPtr kCFNetworkProxiesHTTPPort;
    private static IntPtr kCFNetworkProxiesHTTPProxy;
    private static IntPtr kCFNetworkProxiesProxyAutoConfigEnable;
    private static IntPtr kCFNetworkProxiesProxyAutoConfigJavaScript;
    private static IntPtr kCFNetworkProxiesProxyAutoConfigURLString;
    private CFDictionary settings;
    public CFDictionary Dictionary { get; }
    public bool HTTPEnable { get; }
    public int HTTPPort { get; }
    public string HTTPProxy { get; }
    public bool ProxyAutoConfigEnable { get; }
    public string ProxyAutoConfigJavaScript { get; }
    public string ProxyAutoConfigURLString { get; }
    private static CFProxySettings();
    public CFProxySettings(CFDictionary settings);
    public CFDictionary get_Dictionary();
    public bool get_HTTPEnable();
    public int get_HTTPPort();
    public string get_HTTPProxy();
    public bool get_ProxyAutoConfigEnable();
    public string get_ProxyAutoConfigJavaScript();
    public string get_ProxyAutoConfigURLString();
}
internal enum Mono.Net.CFProxyType : Enum {
    public int value__;
    public static CFProxyType None;
    public static CFProxyType AutoConfigurationUrl;
    public static CFProxyType AutoConfigurationJavaScript;
    public static CFProxyType FTP;
    public static CFProxyType HTTP;
    public static CFProxyType HTTPS;
    public static CFProxyType SOCKS;
}
internal class Mono.Net.CFRunLoop : CFObject {
    public static CFRunLoop CurrentRunLoop { get; }
    public CFRunLoop(IntPtr handle, bool own);
    private static void CFRunLoopAddSource(IntPtr rl, IntPtr source, IntPtr mode);
    private static void CFRunLoopRemoveSource(IntPtr rl, IntPtr source, IntPtr mode);
    private static int CFRunLoopRunInMode(IntPtr mode, double seconds, bool returnAfterSourceHandled);
    private static IntPtr CFRunLoopGetCurrent();
    private static void CFRunLoopStop(IntPtr rl);
    public static CFRunLoop get_CurrentRunLoop();
    public void AddSource(IntPtr source, CFString mode);
    public void RemoveSource(IntPtr source, CFString mode);
    public int RunInMode(CFString mode, double seconds, bool returnAfterSourceHandled);
    public void Stop();
}
internal class Mono.Net.CFStreamClientContext : ValueType {
    public IntPtr Version;
    public IntPtr Info;
    public IntPtr Retain;
    public IntPtr Release;
    public IntPtr CopyDescription;
}
internal class Mono.Net.CFUrl : CFObject {
    public CFUrl(IntPtr handle, bool own);
    private static IntPtr CFURLCreateWithString(IntPtr allocator, IntPtr str, IntPtr baseURL);
    public static CFUrl Create(string absolute);
}
internal enum Mono.Net.Dns.DnsClass : Enum {
    public ushort value__;
    public static DnsClass Internet;
    public static DnsClass IN;
    public static DnsClass CSNET;
    public static DnsClass CS;
    public static DnsClass CHAOS;
    public static DnsClass CH;
    public static DnsClass Hesiod;
    public static DnsClass HS;
}
internal class Mono.Net.Dns.DnsHeader : object {
    public static int DnsHeaderLength;
    private ArraySegment`1<byte> bytes;
    public ushort ID { get; public set; }
    public bool IsQuery { get; public set; }
    public DnsOpCode OpCode { get; public set; }
    public bool AuthoritativeAnswer { get; public set; }
    public bool Truncation { get; public set; }
    public bool RecursionDesired { get; public set; }
    public bool RecursionAvailable { get; public set; }
    public int ZReserved { get; public set; }
    public DnsRCode RCode { get; public set; }
    public ushort QuestionCount { get; public set; }
    public ushort AnswerCount { get; public set; }
    public ushort AuthorityCount { get; public set; }
    public ushort AdditionalCount { get; public set; }
    public DnsHeader(Byte[] bytes);
    public DnsHeader(Byte[] bytes, int offset);
    public DnsHeader(ArraySegment`1<byte> segment);
    public void Clear();
    public ushort get_ID();
    public void set_ID(ushort value);
    public bool get_IsQuery();
    public void set_IsQuery(bool value);
    public DnsOpCode get_OpCode();
    public void set_OpCode(DnsOpCode value);
    public bool get_AuthoritativeAnswer();
    public void set_AuthoritativeAnswer(bool value);
    public bool get_Truncation();
    public void set_Truncation(bool value);
    public bool get_RecursionDesired();
    public void set_RecursionDesired(bool value);
    public bool get_RecursionAvailable();
    public void set_RecursionAvailable(bool value);
    public int get_ZReserved();
    public void set_ZReserved(int value);
    public DnsRCode get_RCode();
    public void set_RCode(DnsRCode value);
    private static ushort GetUInt16(Byte[] bytes, int offset);
    private static void SetUInt16(Byte[] bytes, int offset, ushort val);
    public ushort get_QuestionCount();
    public void set_QuestionCount(ushort value);
    public ushort get_AnswerCount();
    public void set_AnswerCount(ushort value);
    public ushort get_AuthorityCount();
    public void set_AuthorityCount(ushort value);
    public ushort get_AdditionalCount();
    public void set_AdditionalCount(ushort value);
    public virtual string ToString();
}
internal enum Mono.Net.Dns.DnsOpCode : Enum {
    public byte value__;
    public static DnsOpCode Query;
    [ObsoleteAttribute]
public static DnsOpCode IQuery;
    public static DnsOpCode Status;
    public static DnsOpCode Notify;
    public static DnsOpCode Update;
}
internal abstract class Mono.Net.Dns.DnsPacket : object {
    protected Byte[] packet;
    protected int position;
    protected DnsHeader header;
    public Byte[] Packet { get; }
    public int Length { get; }
    public DnsHeader Header { get; }
    protected DnsPacket(int length);
    protected DnsPacket(Byte[] buffer, int length);
    public Byte[] get_Packet();
    public int get_Length();
    public DnsHeader get_Header();
    protected void WriteUInt16(ushort v);
    protected void WriteStringBytes(string str, int offset, int count);
    protected void WriteLabel(string str, int offset, int count);
    protected void WriteDnsName(string name);
    protected internal string ReadName(Int32& offset);
    protected internal static string ReadName(Byte[] buffer, Int32& offset);
    protected internal ushort ReadUInt16(Int32& offset);
    protected internal int ReadInt32(Int32& offset);
}
internal enum Mono.Net.Dns.DnsQClass : Enum {
    public ushort value__;
    public static DnsQClass Internet;
    public static DnsQClass IN;
    public static DnsQClass CSNET;
    public static DnsQClass CS;
    public static DnsQClass CHAOS;
    public static DnsQClass CH;
    public static DnsQClass Hesiod;
    public static DnsQClass HS;
    public static DnsQClass None;
    public static DnsQClass Any;
}
internal enum Mono.Net.Dns.DnsQType : Enum {
    public ushort value__;
    public static DnsQType A;
    public static DnsQType NS;
    [ObsoleteAttribute]
public static DnsQType MD;
    [ObsoleteAttribute]
public static DnsQType MF;
    public static DnsQType CNAME;
    public static DnsQType SOA;
    [ObsoleteAttribute]
public static DnsQType MB;
    [ObsoleteAttribute]
public static DnsQType MG;
    [ObsoleteAttribute]
public static DnsQType MR;
    [ObsoleteAttribute]
public static DnsQType NULL;
    [ObsoleteAttribute]
public static DnsQType WKS;
    public static DnsQType PTR;
    [ObsoleteAttribute]
public static DnsQType HINFO;
    [ObsoleteAttribute]
public static DnsQType MINFO;
    public static DnsQType MX;
    public static DnsQType TXT;
    [ObsoleteAttribute]
public static DnsQType RP;
    public static DnsQType AFSDB;
    [ObsoleteAttribute]
public static DnsQType X25;
    [ObsoleteAttribute]
public static DnsQType ISDN;
    [ObsoleteAttribute]
public static DnsQType RT;
    [ObsoleteAttribute]
public static DnsQType NSAP;
    [ObsoleteAttribute]
public static DnsQType NSAPPTR;
    public static DnsQType SIG;
    public static DnsQType KEY;
    [ObsoleteAttribute]
public static DnsQType PX;
    [ObsoleteAttribute]
public static DnsQType GPOS;
    public static DnsQType AAAA;
    public static DnsQType LOC;
    [ObsoleteAttribute]
public static DnsQType NXT;
    [ObsoleteAttribute]
public static DnsQType EID;
    [ObsoleteAttribute]
public static DnsQType NIMLOC;
    public static DnsQType SRV;
    [ObsoleteAttribute]
public static DnsQType ATMA;
    public static DnsQType NAPTR;
    public static DnsQType KX;
    public static DnsQType CERT;
    [ObsoleteAttribute]
public static DnsQType A6;
    public static DnsQType DNAME;
    [ObsoleteAttribute]
public static DnsQType SINK;
    public static DnsQType OPT;
    [ObsoleteAttribute]
public static DnsQType APL;
    public static DnsQType DS;
    public static DnsQType SSHFP;
    public static DnsQType IPSECKEY;
    public static DnsQType RRSIG;
    public static DnsQType NSEC;
    public static DnsQType DNSKEY;
    public static DnsQType DHCID;
    public static DnsQType NSEC3;
    public static DnsQType NSEC3PARAM;
    public static DnsQType HIP;
    public static DnsQType NINFO;
    public static DnsQType RKEY;
    public static DnsQType TALINK;
    public static DnsQType SPF;
    [ObsoleteAttribute]
public static DnsQType UINFO;
    [ObsoleteAttribute]
public static DnsQType UID;
    [ObsoleteAttribute]
public static DnsQType GID;
    [ObsoleteAttribute]
public static DnsQType UNSPEC;
    public static DnsQType TKEY;
    public static DnsQType TSIG;
    public static DnsQType IXFR;
    public static DnsQType AXFR;
    [ObsoleteAttribute]
public static DnsQType MAILB;
    [ObsoleteAttribute]
public static DnsQType MAILA;
    public static DnsQType ALL;
    public static DnsQType URI;
    public static DnsQType TA;
    public static DnsQType DLV;
}
internal class Mono.Net.Dns.DnsQuery : DnsPacket {
    public DnsQuery(string name, DnsQType qtype, DnsQClass qclass);
}
internal class Mono.Net.Dns.DnsQuestion : object {
    private string name;
    private DnsQType type;
    private DnsQClass _class;
    public string Name { get; }
    public DnsQType Type { get; }
    public DnsQClass Class { get; }
    internal int Init(DnsPacket packet, int offset);
    public string get_Name();
    public DnsQType get_Type();
    public DnsQClass get_Class();
    public virtual string ToString();
}
internal enum Mono.Net.Dns.DnsRCode : Enum {
    public ushort value__;
    public static DnsRCode NoError;
    public static DnsRCode FormErr;
    public static DnsRCode ServFail;
    public static DnsRCode NXDomain;
    public static DnsRCode NotImp;
    public static DnsRCode Refused;
    public static DnsRCode YXDomain;
    public static DnsRCode YXRRSet;
    public static DnsRCode NXRRSet;
    public static DnsRCode NotAuth;
    public static DnsRCode NotZone;
    public static DnsRCode BadVers;
    public static DnsRCode BadSig;
    public static DnsRCode BadKey;
    public static DnsRCode BadTime;
    public static DnsRCode BadMode;
    public static DnsRCode BadName;
    public static DnsRCode BadAlg;
    public static DnsRCode BadTrunc;
}
internal class Mono.Net.Dns.DnsResourceRecord : object {
    private string name;
    private DnsType type;
    private DnsClass klass;
    private int ttl;
    private ushort rdlength;
    private ArraySegment`1<byte> m_rdata;
    public string Name { get; }
    public DnsType Type { get; }
    public DnsClass Class { get; }
    public int Ttl { get; }
    public ArraySegment`1<byte> Data { get; }
    internal void CopyFrom(DnsResourceRecord rr);
    internal static DnsResourceRecord CreateFromBuffer(DnsPacket packet, int size, Int32& offset);
    public string get_Name();
    public DnsType get_Type();
    public DnsClass get_Class();
    public int get_Ttl();
    public ArraySegment`1<byte> get_Data();
    public virtual string ToString();
}
internal class Mono.Net.Dns.DnsResourceRecordA : DnsResourceRecordIPAddress {
    internal DnsResourceRecordA(DnsResourceRecord rr);
}
internal class Mono.Net.Dns.DnsResourceRecordAAAA : DnsResourceRecordIPAddress {
    internal DnsResourceRecordAAAA(DnsResourceRecord rr);
}
internal class Mono.Net.Dns.DnsResourceRecordCName : DnsResourceRecord {
    private string cname;
    public string CName { get; }
    internal DnsResourceRecordCName(DnsResourceRecord rr);
    public string get_CName();
    public virtual string ToString();
}
internal abstract class Mono.Net.Dns.DnsResourceRecordIPAddress : DnsResourceRecord {
    private IPAddress address;
    public IPAddress Address { get; }
    internal DnsResourceRecordIPAddress(DnsResourceRecord rr, int address_size);
    public virtual string ToString();
    public IPAddress get_Address();
}
internal class Mono.Net.Dns.DnsResourceRecordPTR : DnsResourceRecord {
    private string dname;
    public string DName { get; }
    internal DnsResourceRecordPTR(DnsResourceRecord rr);
    public string get_DName();
    public virtual string ToString();
}
internal class Mono.Net.Dns.DnsResponse : DnsPacket {
    private static ReadOnlyCollection`1<DnsResourceRecord> EmptyRR;
    private static ReadOnlyCollection`1<DnsQuestion> EmptyQS;
    private ReadOnlyCollection`1<DnsQuestion> question;
    private ReadOnlyCollection`1<DnsResourceRecord> answer;
    private ReadOnlyCollection`1<DnsResourceRecord> authority;
    private ReadOnlyCollection`1<DnsResourceRecord> additional;
    private int offset;
    public DnsResponse(Byte[] buffer, int length);
    private static DnsResponse();
    public void Reset();
    private ReadOnlyCollection`1<DnsResourceRecord> GetRRs(int count);
    private ReadOnlyCollection`1<DnsQuestion> GetQuestions(int count);
    public ReadOnlyCollection`1<DnsQuestion> GetQuestions();
    public ReadOnlyCollection`1<DnsResourceRecord> GetAnswers();
    public ReadOnlyCollection`1<DnsResourceRecord> GetAuthority();
    public ReadOnlyCollection`1<DnsResourceRecord> GetAdditional();
    public virtual string ToString();
}
internal enum Mono.Net.Dns.DnsType : Enum {
    public ushort value__;
    public static DnsType A;
    public static DnsType NS;
    [ObsoleteAttribute]
public static DnsType MD;
    [ObsoleteAttribute]
public static DnsType MF;
    public static DnsType CNAME;
    public static DnsType SOA;
    [ObsoleteAttribute]
public static DnsType MB;
    [ObsoleteAttribute]
public static DnsType MG;
    [ObsoleteAttribute]
public static DnsType MR;
    [ObsoleteAttribute]
public static DnsType NULL;
    [ObsoleteAttribute]
public static DnsType WKS;
    public static DnsType PTR;
    [ObsoleteAttribute]
public static DnsType HINFO;
    [ObsoleteAttribute]
public static DnsType MINFO;
    public static DnsType MX;
    public static DnsType TXT;
    [ObsoleteAttribute]
public static DnsType RP;
    public static DnsType AFSDB;
    [ObsoleteAttribute]
public static DnsType X25;
    [ObsoleteAttribute]
public static DnsType ISDN;
    [ObsoleteAttribute]
public static DnsType RT;
    [ObsoleteAttribute]
public static DnsType NSAP;
    [ObsoleteAttribute]
public static DnsType NSAPPTR;
    public static DnsType SIG;
    public static DnsType KEY;
    [ObsoleteAttribute]
public static DnsType PX;
    [ObsoleteAttribute]
public static DnsType GPOS;
    public static DnsType AAAA;
    public static DnsType LOC;
    [ObsoleteAttribute]
public static DnsType NXT;
    [ObsoleteAttribute]
public static DnsType EID;
    [ObsoleteAttribute]
public static DnsType NIMLOC;
    public static DnsType SRV;
    [ObsoleteAttribute]
public static DnsType ATMA;
    public static DnsType NAPTR;
    public static DnsType KX;
    public static DnsType CERT;
    [ObsoleteAttribute]
public static DnsType A6;
    public static DnsType DNAME;
    [ObsoleteAttribute]
public static DnsType SINK;
    public static DnsType OPT;
    [ObsoleteAttribute]
public static DnsType APL;
    public static DnsType DS;
    public static DnsType SSHFP;
    public static DnsType IPSECKEY;
    public static DnsType RRSIG;
    public static DnsType NSEC;
    public static DnsType DNSKEY;
    public static DnsType DHCID;
    public static DnsType NSEC3;
    public static DnsType NSEC3PARAM;
    public static DnsType HIP;
    public static DnsType NINFO;
    public static DnsType RKEY;
    public static DnsType TALINK;
    public static DnsType SPF;
    [ObsoleteAttribute]
public static DnsType UINFO;
    [ObsoleteAttribute]
public static DnsType UID;
    [ObsoleteAttribute]
public static DnsType GID;
    [ObsoleteAttribute]
public static DnsType UNSPEC;
    public static DnsType TKEY;
    public static DnsType TSIG;
    public static DnsType IXFR;
    public static DnsType AXFR;
    [ObsoleteAttribute]
public static DnsType MAILB;
    [ObsoleteAttribute]
public static DnsType MAILA;
    public static DnsType URI;
    public static DnsType TA;
    public static DnsType DLV;
}
internal static class Mono.Net.Dns.DnsUtil : object {
    public static bool IsValidDnsName(string name);
    public static int GetEncodedLength(string name);
    public static int GetNameLength(Byte[] buffer);
    public static int GetNameLength(Byte[] buffer, int offset);
    public static string ReadName(Byte[] buffer, Int32& offset);
}
internal enum Mono.Net.Dns.ResolverAsyncOperation : Enum {
    public int value__;
    public static ResolverAsyncOperation None;
    public static ResolverAsyncOperation GetHostEntry;
    public static ResolverAsyncOperation GetHostAddresses;
}
internal enum Mono.Net.Dns.ResolverError : Enum {
    public int value__;
    public static ResolverError NoError;
    public static ResolverError FormatError;
    public static ResolverError ServerFailure;
    public static ResolverError NameError;
    public static ResolverError NotImplemented;
    public static ResolverError Refused;
    public static ResolverError ResponseHeaderError;
    public static ResolverError ResponseFormatError;
    public static ResolverError Timeout;
}
internal class Mono.Net.Dns.SimpleResolver : object {
    private static String[] EmptyStrings;
    private static IPAddress[] EmptyAddresses;
    private IPEndPoint[] endpoints;
    private Socket client;
    private Dictionary`2<int, SimpleResolverEventArgs> queries;
    private AsyncCallback receive_cb;
    private TimerCallback timeout_cb;
    private bool disposed;
    private static SimpleResolver();
    private sealed virtual override void System.IDisposable.Dispose();
    public void Close();
    private void GetLocalHost(SimpleResolverEventArgs args);
    public bool GetHostAddressesAsync(SimpleResolverEventArgs args);
    public bool GetHostEntryAsync(SimpleResolverEventArgs args);
    private bool AddQuery(DnsQuery query, SimpleResolverEventArgs args);
    private static DnsQuery GetQuery(string host, DnsQType q, DnsQClass c);
    private void SendAQuery(SimpleResolverEventArgs args, bool add_it);
    private void SendAQuery(SimpleResolverEventArgs args, string host, bool add_it);
    private static string GetPTRName(IPAddress address);
    private void SendPTRQuery(SimpleResolverEventArgs args, bool add_it);
    private void SendQuery(SimpleResolverEventArgs args, DnsQuery query, bool add_it);
    private Byte[] GetFreshBuffer();
    private void FreeBuffer(Byte[] buffer);
    private void InitSocket();
    private void BeginReceive();
    private void OnTimeout(object obj);
    private void OnReceive(IAsyncResult ares);
    private void ProcessResponse(SimpleResolverEventArgs args, DnsResponse response, EndPoint server_ep);
    private void InitFromSystem();
}
internal class Mono.Net.Dns.SimpleResolverEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventHandler`1<SimpleResolverEventArgs> Completed;
    [CompilerGeneratedAttribute]
private ResolverError <ResolverError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public ResolverAsyncOperation LastOperation;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private IPHostEntry <HostEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private object <UserToken>k__BackingField;
    internal ushort QueryID;
    internal ushort Retries;
    internal Timer Timer;
    internal IPAddress PTRAddress;
    public ResolverError ResolverError { get; public set; }
    public string ErrorMessage { get; public set; }
    public string HostName { get; public set; }
    public IPHostEntry HostEntry { get; internal set; }
    public object UserToken { get; public set; }
    [CompilerGeneratedAttribute]
public void add_Completed(EventHandler`1<SimpleResolverEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Completed(EventHandler`1<SimpleResolverEventArgs> value);
    [CompilerGeneratedAttribute]
public ResolverError get_ResolverError();
    [CompilerGeneratedAttribute]
public void set_ResolverError(ResolverError value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public string get_HostName();
    [CompilerGeneratedAttribute]
public void set_HostName(string value);
    [CompilerGeneratedAttribute]
public IPHostEntry get_HostEntry();
    [CompilerGeneratedAttribute]
internal void set_HostEntry(IPHostEntry value);
    [CompilerGeneratedAttribute]
public object get_UserToken();
    [CompilerGeneratedAttribute]
public void set_UserToken(object value);
    internal void Reset(ResolverAsyncOperation op);
    protected internal void OnCompleted(object sender);
}
internal class Mono.Net.Security.AsyncHandshakeRequest : AsyncProtocolRequest {
    public AsyncHandshakeRequest(MobileAuthenticatedStream parent, bool sync);
    protected virtual AsyncOperationStatus Run(AsyncOperationStatus status);
}
internal enum Mono.Net.Security.AsyncOperationStatus : Enum {
    public int value__;
    public static AsyncOperationStatus Initialize;
    public static AsyncOperationStatus Continue;
    public static AsyncOperationStatus ReadDone;
    public static AsyncOperationStatus Complete;
}
internal abstract class Mono.Net.Security.AsyncProtocolRequest : object {
    [CompilerGeneratedAttribute]
private MobileAuthenticatedStream <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UserResult>k__BackingField;
    private int Started;
    private int RequestedSize;
    private int WriteRequested;
    private object locker;
    private static int next_id;
    public MobileAuthenticatedStream Parent { get; }
    public bool RunSynchronously { get; }
    public int ID { get; }
    public string Name { get; }
    public int UserResult { get; protected set; }
    public AsyncProtocolRequest(MobileAuthenticatedStream parent, bool sync);
    [CompilerGeneratedAttribute]
public MobileAuthenticatedStream get_Parent();
    [CompilerGeneratedAttribute]
public bool get_RunSynchronously();
    public int get_ID();
    public string get_Name();
    [CompilerGeneratedAttribute]
public int get_UserResult();
    [CompilerGeneratedAttribute]
protected void set_UserResult(int value);
    [ConditionalAttribute("MONO_TLS_DEBUG")]
protected void Debug(string message, Object[] args);
    internal void RequestRead(int size);
    internal void RequestWrite();
    [AsyncStateMachineAttribute("Mono.Net.Security.AsyncProtocolRequest/<StartOperation>d__23")]
internal Task`1<AsyncProtocolResult> StartOperation(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Mono.Net.Security.AsyncProtocolRequest/<ProcessOperation>d__24")]
private Task ProcessOperation(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Mono.Net.Security.AsyncProtocolRequest/<InnerRead>d__25")]
private Task`1<Nullable`1<int>> InnerRead(CancellationToken cancellationToken);
    protected abstract virtual AsyncOperationStatus Run(AsyncOperationStatus status);
    public virtual string ToString();
}
internal class Mono.Net.Security.AsyncProtocolResult : object {
    [CompilerGeneratedAttribute]
private int <UserResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionDispatchInfo <Error>k__BackingField;
    public int UserResult { get; }
    public ExceptionDispatchInfo Error { get; }
    public AsyncProtocolResult(int result);
    public AsyncProtocolResult(ExceptionDispatchInfo error);
    [CompilerGeneratedAttribute]
public int get_UserResult();
    [CompilerGeneratedAttribute]
public ExceptionDispatchInfo get_Error();
}
internal abstract class Mono.Net.Security.AsyncReadOrWriteRequest : AsyncProtocolRequest {
    [CompilerGeneratedAttribute]
private BufferOffsetSize <UserBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentSize>k__BackingField;
    protected BufferOffsetSize UserBuffer { get; }
    protected int CurrentSize { get; protected set; }
    public AsyncReadOrWriteRequest(MobileAuthenticatedStream parent, bool sync, Byte[] buffer, int offset, int size);
    [CompilerGeneratedAttribute]
protected BufferOffsetSize get_UserBuffer();
    [CompilerGeneratedAttribute]
protected int get_CurrentSize();
    [CompilerGeneratedAttribute]
protected void set_CurrentSize(int value);
    public virtual string ToString();
}
internal class Mono.Net.Security.AsyncReadRequest : AsyncReadOrWriteRequest {
    public AsyncReadRequest(MobileAuthenticatedStream parent, bool sync, Byte[] buffer, int offset, int size);
    protected virtual AsyncOperationStatus Run(AsyncOperationStatus status);
}
internal class Mono.Net.Security.AsyncRenegotiateRequest : AsyncProtocolRequest {
    public AsyncRenegotiateRequest(MobileAuthenticatedStream parent);
    protected virtual AsyncOperationStatus Run(AsyncOperationStatus status);
}
internal class Mono.Net.Security.AsyncShutdownRequest : AsyncProtocolRequest {
    public AsyncShutdownRequest(MobileAuthenticatedStream parent);
    protected virtual AsyncOperationStatus Run(AsyncOperationStatus status);
}
internal class Mono.Net.Security.AsyncWriteRequest : AsyncReadOrWriteRequest {
    public AsyncWriteRequest(MobileAuthenticatedStream parent, bool sync, Byte[] buffer, int offset, int size);
    protected virtual AsyncOperationStatus Run(AsyncOperationStatus status);
}
internal class Mono.Net.Security.BufferOffsetSize : object {
    public Byte[] Buffer;
    public int Offset;
    public int Size;
    public int TotalBytes;
    public bool Complete;
    public int EndOffset { get; }
    public int Remaining { get; }
    public BufferOffsetSize(Byte[] buffer, int offset, int size);
    public int get_EndOffset();
    public int get_Remaining();
    public virtual string ToString();
}
internal class Mono.Net.Security.BufferOffsetSize2 : BufferOffsetSize {
    public int InitialSize;
    public BufferOffsetSize2(int size);
    public void Reset();
    public void MakeRoom(int size);
    public void AppendData(Byte[] buffer, int offset, int size);
}
internal class Mono.Net.Security.ChainValidationHelper : object {
    private WeakReference`1<SslStream> owner;
    private MonoTlsSettings settings;
    private MobileTlsProvider provider;
    private ServerCertValidationCallback certValidationCallback;
    private LocalCertSelectionCallback certSelectionCallback;
    private MonoTlsStream tlsStream;
    private HttpWebRequest request;
    public MonoTlsProvider Provider { get; }
    public MonoTlsSettings Settings { get; }
    public bool HasCertificateSelectionCallback { get; }
    private ChainValidationHelper(SslStream owner, MobileTlsProvider provider, MonoTlsSettings settings, bool cloneSettings, MonoTlsStream stream);
    internal static ChainValidationHelper GetInternalValidator(SslStream owner, MobileTlsProvider provider, MonoTlsSettings settings);
    internal static ICertificateValidator GetDefaultValidator(MonoTlsSettings settings);
    internal static ChainValidationHelper Create(MobileTlsProvider provider, MonoTlsSettings& settings, MonoTlsStream stream);
    private static ServerCertValidationCallback GetValidationCallback(MonoTlsSettings settings);
    private static X509Certificate DefaultSelectionCallback(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public MonoTlsProvider get_Provider();
    public sealed virtual MonoTlsSettings get_Settings();
    public bool get_HasCertificateSelectionCallback();
    public sealed virtual bool SelectClientCertificate(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, X509Certificate& clientCertificate);
    internal X509Certificate SelectClientCertificate(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    internal bool ValidateClientCertificate(X509Certificate certificate, MonoSslPolicyErrors errors);
    public sealed virtual ValidationResult ValidateCertificate(string host, bool serverMode, X509CertificateCollection certs);
    public ValidationResult ValidateCertificate(string host, bool serverMode, X509Certificate leaf, X509Chain chain);
    private ValidationResult ValidateChain(string host, bool server, X509Certificate leaf, X509Chain chain, X509CertificateCollection certs, SslPolicyErrors errors);
    private ValidationResult ValidateChain(string host, bool server, X509Certificate leaf, X509Chain& chain, X509CertificateCollection certs, SslPolicyErrors errors);
    private bool InvokeCallback(X509Certificate leaf, X509Chain chain, SslPolicyErrors errors);
    private bool InvokeSystemValidator(string targetHost, bool serverMode, X509CertificateCollection certificates, X509Chain chain, MonoSslPolicyErrors& xerrors, Int32& status11);
}
internal abstract class Mono.Net.Security.MobileAuthenticatedStream : AuthenticatedStream {
    private MobileTlsContext xobileTlsContext;
    private ExceptionDispatchInfo lastException;
    private AsyncProtocolRequest asyncHandshakeRequest;
    private AsyncProtocolRequest asyncReadRequest;
    private AsyncProtocolRequest asyncWriteRequest;
    private BufferOffsetSize2 readBuffer;
    private BufferOffsetSize2 writeBuffer;
    private object ioLock;
    private int closeRequested;
    private bool shutdown;
    private Operation operation;
    private static int uniqueNameInteger;
    [CompilerGeneratedAttribute]
private SslStream <SslStream>k__BackingField;
    [CompilerGeneratedAttribute]
private MonoTlsSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private MobileTlsProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    private static int nextId;
    internal int ID;
    public SslStream SslStream { get; }
    public MonoTlsSettings Settings { get; }
    public MobileTlsProvider Provider { get; }
    private MonoTlsProvider Mono.Security.Interface.IMonoSslStream.Provider { get; }
    internal bool HasContext { get; }
    internal string TargetHost { get; private set; }
    public AuthenticatedStream AuthenticatedStream { get; }
    public bool CanRenegotiate { get; }
    public bool IsServer { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public SslProtocols SslProtocol { get; }
    public X509Certificate RemoteCertificate { get; }
    public X509Certificate LocalCertificate { get; }
    public X509Certificate InternalLocalCertificate { get; }
    public TransportContext TransportContext { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int CipherStrength { get; }
    public int HashStrength { get; }
    public int KeyExchangeStrength { get; }
    public bool CheckCertRevocationStatus { get; }
    public MobileAuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MobileTlsProvider provider);
    private static MobileAuthenticatedStream();
    [CompilerGeneratedAttribute]
public sealed virtual SslStream get_SslStream();
    [CompilerGeneratedAttribute]
public MonoTlsSettings get_Settings();
    [CompilerGeneratedAttribute]
public MobileTlsProvider get_Provider();
    private sealed virtual override MonoTlsProvider Mono.Security.Interface.IMonoSslStream.get_Provider();
    internal bool get_HasContext();
    [CompilerGeneratedAttribute]
internal string get_TargetHost();
    [CompilerGeneratedAttribute]
private void set_TargetHost(string value);
    internal void CheckThrow(bool authSuccessCheck, bool shutdownCheck);
    internal static Exception GetSSPIException(Exception e);
    internal static Exception GetIOException(Exception e, string message);
    internal static Exception GetRenegotiationException(string message);
    internal static Exception GetInternalError();
    internal static Exception GetInvalidNestedCallException();
    internal ExceptionDispatchInfo SetException(Exception e);
    public void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public sealed virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsClientAsync(IMonoSslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken);
    public sealed virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsServerAsync(IMonoSslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken);
    public sealed virtual Task ShutdownAsync();
    public sealed virtual AuthenticatedStream get_AuthenticatedStream();
    [AsyncStateMachineAttribute("Mono.Net.Security.MobileAuthenticatedStream/<ProcessAuthentication>d__48")]
private Task ProcessAuthentication(bool runSynchronously, MonoSslAuthenticationOptions options, CancellationToken cancellationToken);
    protected abstract virtual MobileTlsContext CreateContext(MonoSslAuthenticationOptions options);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public sealed virtual bool get_CanRenegotiate();
    public sealed virtual Task RenegotiateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Mono.Net.Security.MobileAuthenticatedStream/<StartOperation>d__57")]
private Task`1<int> StartOperation(OperationType type, AsyncProtocolRequest asyncRequest, CancellationToken cancellationToken);
    [ConditionalAttribute("MONO_TLS_DEBUG")]
protected internal void Debug(string format, Object[] args);
    [ConditionalAttribute("MONO_TLS_DEBUG")]
protected internal void Debug(string message);
    internal int InternalRead(Byte[] buffer, int offset, int size, Boolean& outWantMore);
    private ValueTuple`2<int, bool> InternalRead(AsyncProtocolRequest asyncRequest, BufferOffsetSize internalBuffer, Byte[] buffer, int offset, int size);
    internal bool InternalWrite(Byte[] buffer, int offset, int size);
    private bool InternalWrite(AsyncProtocolRequest asyncRequest, BufferOffsetSize2 internalBuffer, Byte[] buffer, int offset, int size);
    [AsyncStateMachineAttribute("Mono.Net.Security.MobileAuthenticatedStream/<InnerRead>d__66")]
internal Task`1<int> InnerRead(bool sync, int requestedSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Mono.Net.Security.MobileAuthenticatedStream/<InnerWrite>d__67")]
internal Task InnerWrite(bool sync, CancellationToken cancellationToken);
    internal AsyncOperationStatus ProcessHandshake(AsyncOperationStatus status, bool renegotiate);
    internal ValueTuple`2<int, bool> ProcessRead(BufferOffsetSize userBuffer);
    internal ValueTuple`2<int, bool> ProcessWrite(BufferOffsetSize userBuffer);
    internal AsyncOperationStatus ProcessShutdown(AsyncOperationStatus status);
    public virtual bool get_IsServer();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public sealed virtual SslProtocols get_SslProtocol();
    public sealed virtual X509Certificate get_RemoteCertificate();
    public sealed virtual X509Certificate get_LocalCertificate();
    public sealed virtual X509Certificate get_InternalLocalCertificate();
    public sealed virtual MonoTlsConnectionInfo GetConnectionInfo();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public sealed virtual TransportContext get_TransportContext();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public sealed virtual CipherAlgorithmType get_CipherAlgorithm();
    public sealed virtual HashAlgorithmType get_HashAlgorithm();
    public sealed virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public sealed virtual int get_CipherStrength();
    public sealed virtual int get_HashStrength();
    public sealed virtual int get_KeyExchangeStrength();
    public sealed virtual bool get_CheckCertRevocationStatus();
    [CompilerGeneratedAttribute]
private void <InnerWrite>b__67_0();
}
internal abstract class Mono.Net.Security.MobileTlsContext : object {
    private ChainValidationHelper certificateValidator;
    [CompilerGeneratedAttribute]
private MonoSslAuthenticationOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private MobileAuthenticatedStream <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AskForClientCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <EnabledProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <LocalServerCertificate>k__BackingField;
    internal MonoSslAuthenticationOptions Options { get; }
    internal MobileAuthenticatedStream Parent { get; }
    public MonoTlsSettings Settings { get; }
    public MonoTlsProvider Provider { get; }
    public bool HasContext { get; }
    public bool IsAuthenticated { get; }
    public bool IsServer { get; }
    internal string TargetHost { get; }
    protected string ServerName { get; }
    protected bool AskForClientCertificate { get; }
    protected SslProtocols EnabledProtocols { get; }
    protected X509CertificateCollection ClientCertificates { get; }
    internal bool AllowRenegotiation { get; }
    public MonoTlsConnectionInfo ConnectionInfo { get; }
    internal X509Certificate LocalServerCertificate { get; private set; }
    internal bool IsRemoteCertificateAvailable { get; }
    internal X509Certificate LocalClientCertificate { get; }
    public X509Certificate2 RemoteCertificate { get; }
    public TlsProtocols NegotiatedProtocol { get; }
    public bool CanRenegotiate { get; }
    protected MobileTlsContext(MobileAuthenticatedStream parent, MonoSslAuthenticationOptions options);
    [CompilerGeneratedAttribute]
internal MonoSslAuthenticationOptions get_Options();
    [CompilerGeneratedAttribute]
internal MobileAuthenticatedStream get_Parent();
    public MonoTlsSettings get_Settings();
    public MonoTlsProvider get_Provider();
    [ConditionalAttribute("MONO_TLS_DEBUG")]
protected void Debug(string message, Object[] args);
    public abstract virtual bool get_HasContext();
    public abstract virtual bool get_IsAuthenticated();
    [CompilerGeneratedAttribute]
public bool get_IsServer();
    [CompilerGeneratedAttribute]
internal string get_TargetHost();
    [CompilerGeneratedAttribute]
protected string get_ServerName();
    [CompilerGeneratedAttribute]
protected bool get_AskForClientCertificate();
    [CompilerGeneratedAttribute]
protected SslProtocols get_EnabledProtocols();
    [CompilerGeneratedAttribute]
protected X509CertificateCollection get_ClientCertificates();
    internal bool get_AllowRenegotiation();
    protected void GetProtocolVersions(Nullable`1& min, Nullable`1& max);
    public abstract virtual void StartHandshake();
    public abstract virtual bool ProcessHandshake();
    public abstract virtual void FinishHandshake();
    public abstract virtual MonoTlsConnectionInfo get_ConnectionInfo();
    [CompilerGeneratedAttribute]
internal X509Certificate get_LocalServerCertificate();
    [CompilerGeneratedAttribute]
private void set_LocalServerCertificate(X509Certificate value);
    internal abstract virtual bool get_IsRemoteCertificateAvailable();
    internal abstract virtual X509Certificate get_LocalClientCertificate();
    public abstract virtual X509Certificate2 get_RemoteCertificate();
    public abstract virtual TlsProtocols get_NegotiatedProtocol();
    public abstract virtual void Flush();
    public abstract virtual ValueTuple`2<int, bool> Read(Byte[] buffer, int offset, int count);
    public abstract virtual ValueTuple`2<int, bool> Write(Byte[] buffer, int offset, int count);
    public abstract virtual void Shutdown();
    public abstract virtual bool PendingRenegotiation();
    protected bool ValidateCertificate(X509Certificate2 leaf, X509Chain chain);
    protected bool ValidateCertificate(X509Certificate2Collection certificates);
    protected X509Certificate SelectServerCertificate(string serverIdentity);
    protected X509Certificate SelectClientCertificate(String[] acceptableIssuers);
    public abstract virtual bool get_CanRenegotiate();
    public abstract virtual void Renegotiate();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
internal abstract class Mono.Net.Security.MobileTlsProvider : MonoTlsProvider {
    public sealed virtual IMonoSslStream CreateSslStream(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings);
    internal abstract virtual MobileAuthenticatedStream CreateSslStream(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings);
    internal abstract virtual bool ValidateCertificate(ChainValidationHelper validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain& chain, SslPolicyErrors& errors, Int32& status11);
}
internal abstract class Mono.Net.Security.MonoSslAuthenticationOptions : object {
    [CompilerGeneratedAttribute]
private ServerCertSelectionCallback <ServerCertSelectionDelegate>k__BackingField;
    public bool ServerMode { get; }
    public bool AllowRenegotiation { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public string TargetHost { get; public set; }
    public X509Certificate ServerCertificate { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public bool ClientCertificateRequired { get; public set; }
    internal ServerCertSelectionCallback ServerCertSelectionDelegate { get; internal set; }
    public abstract virtual bool get_ServerMode();
    public abstract virtual bool get_AllowRenegotiation();
    public abstract virtual void set_AllowRenegotiation(bool value);
    public abstract virtual RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    public abstract virtual void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public abstract virtual SslProtocols get_EnabledSslProtocols();
    public abstract virtual void set_EnabledSslProtocols(SslProtocols value);
    public abstract virtual EncryptionPolicy get_EncryptionPolicy();
    public abstract virtual void set_EncryptionPolicy(EncryptionPolicy value);
    public abstract virtual X509RevocationMode get_CertificateRevocationCheckMode();
    public abstract virtual void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public abstract virtual string get_TargetHost();
    public abstract virtual void set_TargetHost(string value);
    public abstract virtual X509Certificate get_ServerCertificate();
    public abstract virtual void set_ServerCertificate(X509Certificate value);
    public abstract virtual X509CertificateCollection get_ClientCertificates();
    public abstract virtual void set_ClientCertificates(X509CertificateCollection value);
    public abstract virtual bool get_ClientCertificateRequired();
    public abstract virtual void set_ClientCertificateRequired(bool value);
    [CompilerGeneratedAttribute]
internal ServerCertSelectionCallback get_ServerCertSelectionDelegate();
    [CompilerGeneratedAttribute]
internal void set_ServerCertSelectionDelegate(ServerCertSelectionCallback value);
}
internal class Mono.Net.Security.MonoSslClientAuthenticationOptions : MonoSslAuthenticationOptions {
    [CompilerGeneratedAttribute]
private SslClientAuthenticationOptions <Options>k__BackingField;
    public SslClientAuthenticationOptions Options { get; }
    public bool ServerMode { get; }
    public bool AllowRenegotiation { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public LocalCertificateSelectionCallback LocalCertificateSelectionCallback { get; public set; }
    public string TargetHost { get; public set; }
    public bool ClientCertificateRequired { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public X509Certificate ServerCertificate { get; public set; }
    public MonoSslClientAuthenticationOptions(SslClientAuthenticationOptions options);
    [CompilerGeneratedAttribute]
public SslClientAuthenticationOptions get_Options();
    public virtual bool get_ServerMode();
    public virtual bool get_AllowRenegotiation();
    public virtual void set_AllowRenegotiation(bool value);
    public virtual RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    public virtual void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public virtual X509RevocationMode get_CertificateRevocationCheckMode();
    public virtual void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public virtual EncryptionPolicy get_EncryptionPolicy();
    public virtual void set_EncryptionPolicy(EncryptionPolicy value);
    public virtual SslProtocols get_EnabledSslProtocols();
    public virtual void set_EnabledSslProtocols(SslProtocols value);
    public sealed virtual LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback();
    public sealed virtual void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    public virtual string get_TargetHost();
    public virtual void set_TargetHost(string value);
    public virtual bool get_ClientCertificateRequired();
    public virtual void set_ClientCertificateRequired(bool value);
    public virtual X509CertificateCollection get_ClientCertificates();
    public virtual void set_ClientCertificates(X509CertificateCollection value);
    public virtual X509Certificate get_ServerCertificate();
    public virtual void set_ServerCertificate(X509Certificate value);
}
internal class Mono.Net.Security.MonoSslServerAuthenticationOptions : MonoSslAuthenticationOptions {
    [CompilerGeneratedAttribute]
private SslServerAuthenticationOptions <Options>k__BackingField;
    public SslServerAuthenticationOptions Options { get; }
    public bool ServerMode { get; }
    public bool AllowRenegotiation { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public bool ClientCertificateRequired { get; public set; }
    public ServerCertificateSelectionCallback ServerCertificateSelectionCallback { get; public set; }
    private MonoServerCertificateSelectionCallback Mono.Security.Interface.IMonoSslServerAuthenticationOptions.ServerCertificateSelectionCallback { get; private set; }
    public string TargetHost { get; public set; }
    public X509Certificate ServerCertificate { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public MonoSslServerAuthenticationOptions(SslServerAuthenticationOptions options);
    [CompilerGeneratedAttribute]
public SslServerAuthenticationOptions get_Options();
    public virtual bool get_ServerMode();
    public virtual bool get_AllowRenegotiation();
    public virtual void set_AllowRenegotiation(bool value);
    public virtual RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    public virtual void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public virtual X509RevocationMode get_CertificateRevocationCheckMode();
    public virtual void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public virtual EncryptionPolicy get_EncryptionPolicy();
    public virtual void set_EncryptionPolicy(EncryptionPolicy value);
    public virtual SslProtocols get_EnabledSslProtocols();
    public virtual void set_EnabledSslProtocols(SslProtocols value);
    public virtual bool get_ClientCertificateRequired();
    public virtual void set_ClientCertificateRequired(bool value);
    public ServerCertificateSelectionCallback get_ServerCertificateSelectionCallback();
    public void set_ServerCertificateSelectionCallback(ServerCertificateSelectionCallback value);
    private sealed virtual override MonoServerCertificateSelectionCallback Mono.Security.Interface.IMonoSslServerAuthenticationOptions.get_ServerCertificateSelectionCallback();
    private sealed virtual override void Mono.Security.Interface.IMonoSslServerAuthenticationOptions.set_ServerCertificateSelectionCallback(MonoServerCertificateSelectionCallback value);
    public virtual string get_TargetHost();
    public virtual void set_TargetHost(string value);
    public virtual X509Certificate get_ServerCertificate();
    public virtual void set_ServerCertificate(X509Certificate value);
    public virtual X509CertificateCollection get_ClientCertificates();
    public virtual void set_ClientCertificates(X509CertificateCollection value);
}
internal static class Mono.Net.Security.MonoTlsProviderFactory : object {
    private static object locker;
    private static bool initialized;
    private static MobileTlsProvider defaultProvider;
    private static Dictionary`2<string, Tuple`2<Guid, string>> providerRegistration;
    private static Dictionary`2<Guid, MobileTlsProvider> providerCache;
    private static bool enableDebug;
    internal static Guid UnityTlsId;
    internal static Guid AppleTlsId;
    internal static Guid BtlsId;
    internal static bool IsInitialized { get; }
    private static MonoTlsProviderFactory();
    internal static MobileTlsProvider GetProviderInternal();
    internal static void InitializeInternal();
    internal static void InitializeInternal(string provider);
    private static Type LookupProviderType(string name, bool throwOnError);
    private static MobileTlsProvider LookupProvider(string name, bool throwOnError);
    [ConditionalAttribute("MONO_TLS_DEBUG")]
private static void InitializeDebug();
    [ConditionalAttribute("MONO_TLS_DEBUG")]
internal static void Debug(string message, Object[] args);
    private static void InitializeProviderRegistration();
    private static void PopulateUnityProviders();
    private static void PopulateProviders();
    internal static bool IsBtlsSupported();
    private static MobileTlsProvider CreateDefaultProviderImpl();
    internal static MobileTlsProvider GetProvider();
    internal static bool IsProviderSupported(string name);
    internal static MobileTlsProvider GetProvider(string name);
    internal static bool get_IsInitialized();
    internal static void Initialize();
    internal static void Initialize(string provider);
}
internal class Mono.Net.Security.MonoTlsStream : object {
    private MobileTlsProvider provider;
    private NetworkStream networkStream;
    private HttpWebRequest request;
    private MonoTlsSettings settings;
    private SslStream sslStream;
    private object sslStreamLock;
    private WebExceptionStatus status;
    [CompilerGeneratedAttribute]
private bool <CertificateValidationFailed>k__BackingField;
    internal HttpWebRequest Request { get; }
    internal SslStream SslStream { get; }
    internal WebExceptionStatus ExceptionStatus { get; }
    internal bool CertificateValidationFailed { get; internal set; }
    public MonoTlsStream(HttpWebRequest request, NetworkStream networkStream);
    internal HttpWebRequest get_Request();
    internal SslStream get_SslStream();
    internal WebExceptionStatus get_ExceptionStatus();
    [CompilerGeneratedAttribute]
internal bool get_CertificateValidationFailed();
    [CompilerGeneratedAttribute]
internal void set_CertificateValidationFailed(bool value);
    [AsyncStateMachineAttribute("Mono.Net.Security.MonoTlsStream/<CreateStream>d__18")]
internal Task`1<Stream> CreateStream(WebConnectionTunnel tunnel, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void CloseSslStream();
}
internal static class Mono.Net.Security.NoReflectionHelper : object {
    internal static bool IsInitialized { get; }
    internal static object GetDefaultValidator(object settings);
    internal static object GetProvider();
    internal static bool get_IsInitialized();
    internal static void Initialize();
    internal static void Initialize(string provider);
    internal static HttpWebRequest CreateHttpsRequest(Uri requestUri, object provider, object settings);
    internal static object CreateHttpListener(object certificate, object provider, object settings);
    internal static object GetMonoSslStream(SslStream stream);
    internal static object GetMonoSslStream(HttpListenerContext context);
    internal static bool IsProviderSupported(string name);
    internal static object GetProvider(string name);
}
internal static class Mono.Net.Security.Private.CallbackHelpers : object {
    internal static MonoRemoteCertificateValidationCallback PublicToMono(RemoteCertificateValidationCallback callback);
    internal static MonoRemoteCertificateValidationCallback InternalToMono(RemoteCertValidationCallback callback);
    internal static RemoteCertificateValidationCallback InternalToPublic(string hostname, RemoteCertValidationCallback callback);
    internal static MonoLocalCertificateSelectionCallback InternalToMono(LocalCertSelectionCallback callback);
    internal static LocalCertificateSelectionCallback MonoToPublic(MonoLocalCertificateSelectionCallback callback);
    internal static RemoteCertValidationCallback MonoToInternal(MonoRemoteCertificateValidationCallback callback);
    internal static LocalCertSelectionCallback MonoToInternal(MonoLocalCertificateSelectionCallback callback);
    internal static ServerCertificateSelectionCallback MonoToPublic(MonoServerCertificateSelectionCallback callback);
    internal static MonoServerCertificateSelectionCallback PublicToMono(ServerCertificateSelectionCallback callback);
}
internal class Mono.Net.Security.ServerCertValidationCallbackWrapper : MulticastDelegate {
    public ServerCertValidationCallbackWrapper(object object, IntPtr method);
    public virtual bool Invoke(ServerCertValidationCallback callback, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(ServerCertValidationCallback callback, X509Certificate certificate, X509Chain chain, MonoSslPolicyErrors sslPolicyErrors, AsyncCallback __callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class Mono.Net.Security.SystemCertificateValidator : object {
    private static bool is_macosx;
    private static X509RevocationMode revocation_mode;
    private static X509KeyUsageFlags s_flags;
    private static SystemCertificateValidator();
    public static X509Chain CreateX509Chain(X509CertificateCollection certs);
    private static bool BuildX509Chain(X509CertificateCollection certs, X509Chain chain, SslPolicyErrors& errors, Int32& status11);
    private static bool CheckUsage(X509CertificateCollection certs, string host, SslPolicyErrors& errors, Int32& status11);
    private static bool EvaluateSystem(X509CertificateCollection certs, X509CertificateCollection anchors, string host, X509Chain chain, SslPolicyErrors& errors, Int32& status11);
    public static bool Evaluate(MonoTlsSettings settings, string host, X509CertificateCollection certs, X509Chain chain, SslPolicyErrors& errors, Int32& status11);
    internal static bool NeedsChain(MonoTlsSettings settings);
    private static int GetStatusFromChain(X509Chain chain);
    private static SslPolicyErrors GetErrorsFromChain(X509Chain chain);
    private static bool CheckCertificateUsage(X509Certificate2 cert);
    private static bool CheckServerIdentity(X509Certificate2 cert, string targetHost);
    private static bool CheckDomainName(string subjectName, string targetHost);
    private static bool Match(string hostname, string pattern);
}
internal class Mono.SystemCertificateProvider : object {
    private static MonoTlsProvider provider;
    private static int initialized;
    private static X509PalImpl x509pal;
    private static object syncRoot;
    public MonoTlsProvider Provider { get; }
    public X509PalImpl X509Pal { get; }
    private static SystemCertificateProvider();
    public MonoTlsProvider get_Provider();
    private static X509PalImpl GetX509Pal();
    private static void EnsureInitialized();
    public X509PalImpl get_X509Pal();
    public sealed virtual X509CertificateImpl Import(Byte[] data, CertificateImportFlags importFlags);
    private sealed virtual override X509CertificateImpl Mono.ISystemCertificateProvider.Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags, CertificateImportFlags importFlags);
    public X509Certificate2Impl Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags, CertificateImportFlags importFlags);
    private sealed virtual override X509CertificateImpl Mono.ISystemCertificateProvider.Import(X509Certificate cert, CertificateImportFlags importFlags);
    public X509Certificate2Impl Import(X509Certificate cert, CertificateImportFlags importFlags);
}
internal class Mono.SystemDependencyProvider : object {
    private static SystemDependencyProvider instance;
    private static object syncRoot;
    [CompilerGeneratedAttribute]
private SystemCertificateProvider <CertificateProvider>k__BackingField;
    public static SystemDependencyProvider Instance { get; }
    private ISystemCertificateProvider Mono.ISystemDependencyProvider.CertificateProvider { get; }
    public SystemCertificateProvider CertificateProvider { get; }
    public X509PalImpl X509Pal { get; }
    private static SystemDependencyProvider();
    public static SystemDependencyProvider get_Instance();
    internal static void Initialize();
    private sealed virtual override ISystemCertificateProvider Mono.ISystemDependencyProvider.get_CertificateProvider();
    [CompilerGeneratedAttribute]
public SystemCertificateProvider get_CertificateProvider();
    public X509PalImpl get_X509Pal();
}
internal static class Mono.Unity.CertHelper : object {
    public static void AddCertificatesToNativeChain(unitytls_x509list* nativeCertificateChain, X509CertificateCollection certificates, unitytls_errorstate* errorState);
    public static void AddCertificateToNativeChain(unitytls_x509list* nativeCertificateChain, X509Certificate certificate, unitytls_errorstate* errorState);
}
internal static class Mono.Unity.Debug : object {
    public static void CheckAndThrow(unitytls_errorstate errorState, string context, AlertDescription defaultAlert);
    public static void CheckAndThrow(unitytls_errorstate errorState, unitytls_x509verify_result verifyResult, string context, AlertDescription defaultAlert);
}
internal static class Mono.Unity.UnityTls : object {
    private static unitytls_interface_struct marshalledInterface;
    public static bool IsSupported { get; }
    public static unitytls_interface_struct NativeInterface { get; }
    private static IntPtr GetUnityTlsInterface();
    public static bool get_IsSupported();
    public static unitytls_interface_struct get_NativeInterface();
}
internal class Mono.Unity.UnityTlsContext : MobileTlsContext {
    private static bool ActivateTracing;
    private unitytls_tlsctx* tlsContext;
    private unitytls_x509list* requestedClientCertChain;
    private unitytls_key* requestedClientKey;
    private unitytls_tlsctx_read_callback readCallback;
    private unitytls_tlsctx_write_callback writeCallback;
    private unitytls_tlsctx_trace_callback traceCallback;
    private unitytls_tlsctx_certificate_callback certificateCallback;
    private unitytls_tlsctx_x509verify_callback verifyCallback;
    private X509Certificate localClientCertificate;
    private X509Certificate2 remoteCertificate;
    private MonoTlsConnectionInfo connectioninfo;
    private bool isAuthenticated;
    private bool hasContext;
    private bool closedGraceful;
    private Byte[] writeBuffer;
    private Byte[] readBuffer;
    private GCHandle handle;
    private Exception lastException;
    public bool HasContext { get; }
    public bool IsAuthenticated { get; }
    public MonoTlsConnectionInfo ConnectionInfo { get; }
    internal bool IsRemoteCertificateAvailable { get; }
    internal X509Certificate LocalClientCertificate { get; }
    public X509Certificate2 RemoteCertificate { get; }
    public TlsProtocols NegotiatedProtocol { get; }
    public bool CanRenegotiate { get; }
    public UnityTlsContext(MobileAuthenticatedStream parent, MonoSslAuthenticationOptions options);
    private static void ExtractNativeKeyAndChainFromManagedCertificate(X509Certificate cert, unitytls_errorstate* errorState, unitytls_x509list*& nativeCertChain, unitytls_key*& nativeKey);
    public virtual bool get_HasContext();
    public virtual bool get_IsAuthenticated();
    public virtual MonoTlsConnectionInfo get_ConnectionInfo();
    internal virtual bool get_IsRemoteCertificateAvailable();
    internal virtual X509Certificate get_LocalClientCertificate();
    public virtual X509Certificate2 get_RemoteCertificate();
    public virtual TlsProtocols get_NegotiatedProtocol();
    public virtual void Flush();
    public virtual ValueTuple`2<int, bool> Read(Byte[] buffer, int offset, int count);
    public virtual ValueTuple`2<int, bool> Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRenegotiate();
    public virtual void Renegotiate();
    public virtual bool PendingRenegotiation();
    public virtual void Shutdown();
    protected virtual void Dispose(bool disposing);
    public virtual void StartHandshake();
    public virtual bool ProcessHandshake();
    public virtual void FinishHandshake();
    [MonoPInvokeCallbackAttribute("Mono.Unity.UnityTls/unitytls_tlsctx_write_callback")]
private static IntPtr WriteCallback(Void* userData, Byte* data, IntPtr bufferLen, unitytls_errorstate* errorState);
    private IntPtr WriteCallback(Byte* data, IntPtr bufferLen, unitytls_errorstate* errorState);
    [MonoPInvokeCallbackAttribute("Mono.Unity.UnityTls/unitytls_tlsctx_read_callback")]
private static IntPtr ReadCallback(Void* userData, Byte* buffer, IntPtr bufferLen, unitytls_errorstate* errorState);
    private IntPtr ReadCallback(Byte* buffer, IntPtr bufferLen, unitytls_errorstate* errorState);
    [MonoPInvokeCallbackAttribute("Mono.Unity.UnityTls/unitytls_tlsctx_x509verify_callback")]
private static unitytls_x509verify_result VerifyCallback(Void* userData, unitytls_x509list_ref chain, unitytls_errorstate* errorState);
    private unitytls_x509verify_result VerifyCallback(unitytls_x509list_ref chain, unitytls_errorstate* errorState);
    [MonoPInvokeCallbackAttribute("Mono.Unity.UnityTls/unitytls_tlsctx_certificate_callback")]
private static void CertificateCallback(Void* userData, unitytls_tlsctx* ctx, Byte* cn, IntPtr cnLen, unitytls_x509name* caList, IntPtr caListLen, unitytls_x509list_ref* chain, unitytls_key_ref* key, unitytls_errorstate* errorState);
    private void CertificateCallback(unitytls_tlsctx* ctx, Byte* cn, IntPtr cnLen, unitytls_x509name* caList, IntPtr caListLen, unitytls_x509list_ref* chain, unitytls_key_ref* key, unitytls_errorstate* errorState);
    [MonoPInvokeCallbackAttribute("Mono.Unity.UnityTls/unitytls_tlsctx_trace_callback")]
private static void TraceCallback(Void* userData, unitytls_tlsctx* ctx, Byte* traceMessage, IntPtr traceMessageLen);
}
internal static class Mono.Unity.UnityTlsConversions : object {
    public static unitytls_protocol GetMinProtocol(SslProtocols protocols);
    public static unitytls_protocol GetMaxProtocol(SslProtocols protocols);
    public static TlsProtocols ConvertProtocolVersion(unitytls_protocol protocol);
    public static AlertDescription VerifyResultToAlertDescription(unitytls_x509verify_result verifyResult, AlertDescription defaultAlert);
    public static SslPolicyErrors VerifyResultToPolicyErrror(unitytls_x509verify_result verifyResult);
    public static X509ChainStatusFlags VerifyResultToChainStatus(unitytls_x509verify_result verifyResult);
}
internal class Mono.Unity.UnityTlsProvider : MobileTlsProvider {
    public string Name { get; }
    public Guid ID { get; }
    public bool SupportsSslStream { get; }
    public bool SupportsMonoExtensions { get; }
    public bool SupportsConnectionInfo { get; }
    internal bool SupportsCleanShutdown { get; }
    public SslProtocols SupportedProtocols { get; }
    public virtual string get_Name();
    public virtual Guid get_ID();
    public virtual bool get_SupportsSslStream();
    public virtual bool get_SupportsMonoExtensions();
    public virtual bool get_SupportsConnectionInfo();
    internal virtual bool get_SupportsCleanShutdown();
    public virtual SslProtocols get_SupportedProtocols();
    internal virtual MobileAuthenticatedStream CreateSslStream(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings);
    [MonoPInvokeCallbackAttribute("Mono.Unity.UnityTls/unitytls_x509verify_callback")]
private static unitytls_x509verify_result x509verify_callback(Void* userData, unitytls_x509_ref cert, unitytls_x509verify_result result, unitytls_errorstate* errorState);
    internal virtual bool ValidateCertificate(ChainValidationHelper validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain& chain, SslPolicyErrors& errors, Int32& status11);
}
internal class Mono.Unity.UnityTlsStream : MobileAuthenticatedStream {
    public UnityTlsStream(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MobileTlsProvider provider);
    protected virtual MobileTlsContext CreateContext(MonoSslAuthenticationOptions options);
}
internal class Mono.Unity.X509ChainImplUnityTls : X509ChainImpl {
    private X509ChainElementCollection elements;
    private unitytls_x509list* ownedList;
    private unitytls_x509list_ref nativeCertificateChain;
    private X509ChainPolicy policy;
    private List`1<X509ChainStatus> chainStatusList;
    private bool reverseOrder;
    public bool IsValid { get; }
    public IntPtr Handle { get; }
    internal unitytls_x509list_ref NativeCertificateChain { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    internal X509ChainImplUnityTls(unitytls_x509list_ref nativeCertificateChain, bool reverseOrder);
    internal X509ChainImplUnityTls(unitytls_x509list* ownedList, unitytls_errorstate* errorState, bool reverseOrder);
    public virtual bool get_IsValid();
    public virtual IntPtr get_Handle();
    internal unitytls_x509list_ref get_NativeCertificateChain();
    public virtual X509ChainElementCollection get_ChainElements();
    public virtual void AddStatus(X509ChainStatusFlags error);
    public virtual X509ChainPolicy get_ChainPolicy();
    public virtual void set_ChainPolicy(X509ChainPolicy value);
    public virtual X509ChainStatus[] get_ChainStatus();
    public virtual bool Build(X509Certificate2 certificate);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
}
[ConditionalAttribute("FULL_AOT_RUNTIME")]
[ConditionalAttribute("UNITY")]
[AttributeUsageAttribute("64")]
[ConditionalAttribute("MONOTOUCH")]
internal class Mono.Util.MonoPInvokeCallbackAttribute : Attribute {
    public MonoPInvokeCallbackAttribute(Type t);
}
internal static class Mono.X509Pal : object {
    public static X509PalImpl Instance { get; }
    public static X509PalImpl get_Instance();
}
internal abstract class Mono.X509PalImpl : object {
    private static Byte[] signedData;
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    private static X509PalImpl();
    public abstract virtual X509CertificateImpl Import(Byte[] data);
    public abstract virtual X509Certificate2Impl Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public abstract virtual X509Certificate2Impl Import(X509Certificate cert);
    private static Byte[] PEM(string type, Byte[] data);
    protected static Byte[] ConvertData(Byte[] data);
    internal X509Certificate2Impl ImportFallback(Byte[] data);
    internal X509Certificate2Impl ImportFallback(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public bool get_SupportsLegacyBasicConstraintsExtension();
    public X509ContentType GetCertContentType(Byte[] rawData);
    public X509ContentType GetCertContentType(string fileName);
}
internal class Mono.X509PalImplMono : X509PalImpl {
    public virtual X509CertificateImpl Import(Byte[] data);
    public virtual X509Certificate2Impl Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public virtual X509Certificate2Impl Import(X509Certificate cert);
}
internal interface ObjCRuntimeInternal.INativeObject {
    public IntPtr Handle { get; }
    public abstract virtual IntPtr get_Handle();
}
[ExtensionAttribute]
internal static class ObjCRuntimeInternal.NativeObjectHelper : object {
    [ExtensionAttribute]
public static IntPtr GetHandle(INativeObject self);
}
public class System.CodeDom.CodeArgumentReferenceExpression : CodeExpression {
    private string _parameterName;
    public string ParameterName { get; public set; }
    public CodeArgumentReferenceExpression(string parameterName);
    public string get_ParameterName();
    public void set_ParameterName(string value);
}
public class System.CodeDom.CodeArrayCreateExpression : CodeExpression {
    private CodeExpressionCollection _initializers;
    private CodeTypeReference _createType;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeExpression <SizeExpression>k__BackingField;
    public CodeTypeReference CreateType { get; public set; }
    public CodeExpressionCollection Initializers { get; }
    public int Size { get; public set; }
    public CodeExpression SizeExpression { get; public set; }
    public CodeArrayCreateExpression(CodeTypeReference createType, CodeExpression[] initializers);
    public CodeArrayCreateExpression(string createType, CodeExpression[] initializers);
    public CodeArrayCreateExpression(Type createType, CodeExpression[] initializers);
    public CodeArrayCreateExpression(CodeTypeReference createType, int size);
    public CodeArrayCreateExpression(string createType, int size);
    public CodeArrayCreateExpression(Type createType, int size);
    public CodeArrayCreateExpression(CodeTypeReference createType, CodeExpression size);
    public CodeArrayCreateExpression(string createType, CodeExpression size);
    public CodeArrayCreateExpression(Type createType, CodeExpression size);
    public CodeTypeReference get_CreateType();
    public void set_CreateType(CodeTypeReference value);
    public CodeExpressionCollection get_Initializers();
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public CodeExpression get_SizeExpression();
    [CompilerGeneratedAttribute]
public void set_SizeExpression(CodeExpression value);
}
public class System.CodeDom.CodeArrayIndexerExpression : CodeExpression {
    private CodeExpressionCollection _indices;
    [CompilerGeneratedAttribute]
private CodeExpression <TargetObject>k__BackingField;
    public CodeExpression TargetObject { get; public set; }
    public CodeExpressionCollection Indices { get; }
    public CodeArrayIndexerExpression(CodeExpression targetObject, CodeExpression[] indices);
    [CompilerGeneratedAttribute]
public CodeExpression get_TargetObject();
    [CompilerGeneratedAttribute]
public void set_TargetObject(CodeExpression value);
    public CodeExpressionCollection get_Indices();
}
public class System.CodeDom.CodeAssignStatement : CodeStatement {
    [CompilerGeneratedAttribute]
private CodeExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeExpression <Right>k__BackingField;
    public CodeExpression Left { get; public set; }
    public CodeExpression Right { get; public set; }
    public CodeAssignStatement(CodeExpression left, CodeExpression right);
    [CompilerGeneratedAttribute]
public CodeExpression get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(CodeExpression value);
    [CompilerGeneratedAttribute]
public CodeExpression get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(CodeExpression value);
}
public class System.CodeDom.CodeAttachEventStatement : CodeStatement {
    private CodeEventReferenceExpression _eventRef;
    [CompilerGeneratedAttribute]
private CodeExpression <Listener>k__BackingField;
    public CodeEventReferenceExpression Event { get; public set; }
    public CodeExpression Listener { get; public set; }
    public CodeAttachEventStatement(CodeEventReferenceExpression eventRef, CodeExpression listener);
    public CodeAttachEventStatement(CodeExpression targetObject, string eventName, CodeExpression listener);
    public CodeEventReferenceExpression get_Event();
    public void set_Event(CodeEventReferenceExpression value);
    [CompilerGeneratedAttribute]
public CodeExpression get_Listener();
    [CompilerGeneratedAttribute]
public void set_Listener(CodeExpression value);
}
public class System.CodeDom.CodeAttributeArgument : object {
    private string _name;
    [CompilerGeneratedAttribute]
private CodeExpression <Value>k__BackingField;
    public string Name { get; public set; }
    public CodeExpression Value { get; public set; }
    public CodeAttributeArgument(CodeExpression value);
    public CodeAttributeArgument(string name, CodeExpression value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public CodeExpression get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(CodeExpression value);
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeAttributeArgumentCollection : CollectionBase {
    public CodeAttributeArgument Item { get; public set; }
    public CodeAttributeArgumentCollection(CodeAttributeArgumentCollection value);
    public CodeAttributeArgumentCollection(CodeAttributeArgument[] value);
    public CodeAttributeArgument get_Item(int index);
    public void set_Item(int index, CodeAttributeArgument value);
    public int Add(CodeAttributeArgument value);
    public void AddRange(CodeAttributeArgument[] value);
    public void AddRange(CodeAttributeArgumentCollection value);
    public bool Contains(CodeAttributeArgument value);
    public void CopyTo(CodeAttributeArgument[] array, int index);
    public int IndexOf(CodeAttributeArgument value);
    public void Insert(int index, CodeAttributeArgument value);
    public void Remove(CodeAttributeArgument value);
}
public class System.CodeDom.CodeAttributeDeclaration : object {
    private string _name;
    private CodeAttributeArgumentCollection _arguments;
    private CodeTypeReference _attributeType;
    public string Name { get; public set; }
    public CodeAttributeArgumentCollection Arguments { get; }
    public CodeTypeReference AttributeType { get; }
    public CodeAttributeDeclaration(string name);
    public CodeAttributeDeclaration(string name, CodeAttributeArgument[] arguments);
    public CodeAttributeDeclaration(CodeTypeReference attributeType);
    public CodeAttributeDeclaration(CodeTypeReference attributeType, CodeAttributeArgument[] arguments);
    public string get_Name();
    public void set_Name(string value);
    public CodeAttributeArgumentCollection get_Arguments();
    public CodeTypeReference get_AttributeType();
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeAttributeDeclarationCollection : CollectionBase {
    public CodeAttributeDeclaration Item { get; public set; }
    public CodeAttributeDeclarationCollection(CodeAttributeDeclarationCollection value);
    public CodeAttributeDeclarationCollection(CodeAttributeDeclaration[] value);
    public CodeAttributeDeclaration get_Item(int index);
    public void set_Item(int index, CodeAttributeDeclaration value);
    public int Add(CodeAttributeDeclaration value);
    public void AddRange(CodeAttributeDeclaration[] value);
    public void AddRange(CodeAttributeDeclarationCollection value);
    public bool Contains(CodeAttributeDeclaration value);
    public void CopyTo(CodeAttributeDeclaration[] array, int index);
    public int IndexOf(CodeAttributeDeclaration value);
    public void Insert(int index, CodeAttributeDeclaration value);
    public void Remove(CodeAttributeDeclaration value);
}
public class System.CodeDom.CodeBaseReferenceExpression : CodeExpression {
}
public class System.CodeDom.CodeBinaryOperatorExpression : CodeExpression {
    [CompilerGeneratedAttribute]
private CodeExpression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeBinaryOperatorType <Operator>k__BackingField;
    public CodeExpression Right { get; public set; }
    public CodeExpression Left { get; public set; }
    public CodeBinaryOperatorType Operator { get; public set; }
    public CodeBinaryOperatorExpression(CodeExpression left, CodeBinaryOperatorType op, CodeExpression right);
    [CompilerGeneratedAttribute]
public CodeExpression get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(CodeExpression value);
    [CompilerGeneratedAttribute]
public CodeExpression get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(CodeExpression value);
    [CompilerGeneratedAttribute]
public CodeBinaryOperatorType get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(CodeBinaryOperatorType value);
}
public enum System.CodeDom.CodeBinaryOperatorType : Enum {
    public int value__;
    public static CodeBinaryOperatorType Add;
    public static CodeBinaryOperatorType Subtract;
    public static CodeBinaryOperatorType Multiply;
    public static CodeBinaryOperatorType Divide;
    public static CodeBinaryOperatorType Modulus;
    public static CodeBinaryOperatorType Assign;
    public static CodeBinaryOperatorType IdentityInequality;
    public static CodeBinaryOperatorType IdentityEquality;
    public static CodeBinaryOperatorType ValueEquality;
    public static CodeBinaryOperatorType BitwiseOr;
    public static CodeBinaryOperatorType BitwiseAnd;
    public static CodeBinaryOperatorType BooleanOr;
    public static CodeBinaryOperatorType BooleanAnd;
    public static CodeBinaryOperatorType LessThan;
    public static CodeBinaryOperatorType LessThanOrEqual;
    public static CodeBinaryOperatorType GreaterThan;
    public static CodeBinaryOperatorType GreaterThanOrEqual;
}
public class System.CodeDom.CodeCastExpression : CodeExpression {
    private CodeTypeReference _targetType;
    [CompilerGeneratedAttribute]
private CodeExpression <Expression>k__BackingField;
    public CodeTypeReference TargetType { get; public set; }
    public CodeExpression Expression { get; public set; }
    public CodeCastExpression(CodeTypeReference targetType, CodeExpression expression);
    public CodeCastExpression(string targetType, CodeExpression expression);
    public CodeCastExpression(Type targetType, CodeExpression expression);
    public CodeTypeReference get_TargetType();
    public void set_TargetType(CodeTypeReference value);
    [CompilerGeneratedAttribute]
public CodeExpression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(CodeExpression value);
}
public class System.CodeDom.CodeCatchClause : object {
    private CodeStatementCollection _statements;
    private CodeTypeReference _catchExceptionType;
    private string _localName;
    public string LocalName { get; public set; }
    public CodeTypeReference CatchExceptionType { get; public set; }
    public CodeStatementCollection Statements { get; }
    public CodeCatchClause(string localName);
    public CodeCatchClause(string localName, CodeTypeReference catchExceptionType);
    public CodeCatchClause(string localName, CodeTypeReference catchExceptionType, CodeStatement[] statements);
    public string get_LocalName();
    public void set_LocalName(string value);
    public CodeTypeReference get_CatchExceptionType();
    public void set_CatchExceptionType(CodeTypeReference value);
    public CodeStatementCollection get_Statements();
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeCatchClauseCollection : CollectionBase {
    public CodeCatchClause Item { get; public set; }
    public CodeCatchClauseCollection(CodeCatchClauseCollection value);
    public CodeCatchClauseCollection(CodeCatchClause[] value);
    public CodeCatchClause get_Item(int index);
    public void set_Item(int index, CodeCatchClause value);
    public int Add(CodeCatchClause value);
    public void AddRange(CodeCatchClause[] value);
    public void AddRange(CodeCatchClauseCollection value);
    public bool Contains(CodeCatchClause value);
    public void CopyTo(CodeCatchClause[] array, int index);
    public int IndexOf(CodeCatchClause value);
    public void Insert(int index, CodeCatchClause value);
    public void Remove(CodeCatchClause value);
}
public class System.CodeDom.CodeChecksumPragma : CodeDirective {
    private string _fileName;
    [CompilerGeneratedAttribute]
private Guid <ChecksumAlgorithmId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ChecksumData>k__BackingField;
    public string FileName { get; public set; }
    public Guid ChecksumAlgorithmId { get; public set; }
    public Byte[] ChecksumData { get; public set; }
    public CodeChecksumPragma(string fileName, Guid checksumAlgorithmId, Byte[] checksumData);
    public string get_FileName();
    public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public Guid get_ChecksumAlgorithmId();
    [CompilerGeneratedAttribute]
public void set_ChecksumAlgorithmId(Guid value);
    [CompilerGeneratedAttribute]
public Byte[] get_ChecksumData();
    [CompilerGeneratedAttribute]
public void set_ChecksumData(Byte[] value);
}
public class System.CodeDom.CodeComment : CodeObject {
    private string _text;
    [CompilerGeneratedAttribute]
private bool <DocComment>k__BackingField;
    public bool DocComment { get; public set; }
    public string Text { get; public set; }
    public CodeComment(string text);
    public CodeComment(string text, bool docComment);
    [CompilerGeneratedAttribute]
public bool get_DocComment();
    [CompilerGeneratedAttribute]
public void set_DocComment(bool value);
    public string get_Text();
    public void set_Text(string value);
}
public class System.CodeDom.CodeCommentStatement : CodeStatement {
    [CompilerGeneratedAttribute]
private CodeComment <Comment>k__BackingField;
    public CodeComment Comment { get; public set; }
    public CodeCommentStatement(CodeComment comment);
    public CodeCommentStatement(string text);
    public CodeCommentStatement(string text, bool docComment);
    [CompilerGeneratedAttribute]
public CodeComment get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(CodeComment value);
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeCommentStatementCollection : CollectionBase {
    public CodeCommentStatement Item { get; public set; }
    public CodeCommentStatementCollection(CodeCommentStatementCollection value);
    public CodeCommentStatementCollection(CodeCommentStatement[] value);
    public CodeCommentStatement get_Item(int index);
    public void set_Item(int index, CodeCommentStatement value);
    public int Add(CodeCommentStatement value);
    public void AddRange(CodeCommentStatement[] value);
    public void AddRange(CodeCommentStatementCollection value);
    public bool Contains(CodeCommentStatement value);
    public void CopyTo(CodeCommentStatement[] array, int index);
    public int IndexOf(CodeCommentStatement value);
    public void Insert(int index, CodeCommentStatement value);
    public void Remove(CodeCommentStatement value);
}
public class System.CodeDom.CodeCompileUnit : CodeObject {
    private StringCollection _assemblies;
    private CodeAttributeDeclarationCollection _attributes;
    private CodeDirectiveCollection _startDirectives;
    private CodeDirectiveCollection _endDirectives;
    [CompilerGeneratedAttribute]
private CodeNamespaceCollection <Namespaces>k__BackingField;
    public CodeNamespaceCollection Namespaces { get; }
    public StringCollection ReferencedAssemblies { get; }
    public CodeAttributeDeclarationCollection AssemblyCustomAttributes { get; }
    public CodeDirectiveCollection StartDirectives { get; }
    public CodeDirectiveCollection EndDirectives { get; }
    [CompilerGeneratedAttribute]
public CodeNamespaceCollection get_Namespaces();
    public StringCollection get_ReferencedAssemblies();
    public CodeAttributeDeclarationCollection get_AssemblyCustomAttributes();
    public CodeDirectiveCollection get_StartDirectives();
    public CodeDirectiveCollection get_EndDirectives();
}
public class System.CodeDom.CodeConditionStatement : CodeStatement {
    [CompilerGeneratedAttribute]
private CodeExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStatementCollection <TrueStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStatementCollection <FalseStatements>k__BackingField;
    public CodeExpression Condition { get; public set; }
    public CodeStatementCollection TrueStatements { get; }
    public CodeStatementCollection FalseStatements { get; }
    public CodeConditionStatement(CodeExpression condition, CodeStatement[] trueStatements);
    public CodeConditionStatement(CodeExpression condition, CodeStatement[] trueStatements, CodeStatement[] falseStatements);
    [CompilerGeneratedAttribute]
public CodeExpression get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(CodeExpression value);
    [CompilerGeneratedAttribute]
public CodeStatementCollection get_TrueStatements();
    [CompilerGeneratedAttribute]
public CodeStatementCollection get_FalseStatements();
}
public class System.CodeDom.CodeConstructor : CodeMemberMethod {
    [CompilerGeneratedAttribute]
private CodeExpressionCollection <BaseConstructorArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeExpressionCollection <ChainedConstructorArgs>k__BackingField;
    public CodeExpressionCollection BaseConstructorArgs { get; }
    public CodeExpressionCollection ChainedConstructorArgs { get; }
    [CompilerGeneratedAttribute]
public CodeExpressionCollection get_BaseConstructorArgs();
    [CompilerGeneratedAttribute]
public CodeExpressionCollection get_ChainedConstructorArgs();
}
public class System.CodeDom.CodeDefaultValueExpression : CodeExpression {
    private CodeTypeReference _type;
    public CodeTypeReference Type { get; public set; }
    public CodeDefaultValueExpression(CodeTypeReference type);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
}
public class System.CodeDom.CodeDelegateCreateExpression : CodeExpression {
    private CodeTypeReference _delegateType;
    private string _methodName;
    [CompilerGeneratedAttribute]
private CodeExpression <TargetObject>k__BackingField;
    public CodeTypeReference DelegateType { get; public set; }
    public CodeExpression TargetObject { get; public set; }
    public string MethodName { get; public set; }
    public CodeDelegateCreateExpression(CodeTypeReference delegateType, CodeExpression targetObject, string methodName);
    public CodeTypeReference get_DelegateType();
    public void set_DelegateType(CodeTypeReference value);
    [CompilerGeneratedAttribute]
public CodeExpression get_TargetObject();
    [CompilerGeneratedAttribute]
public void set_TargetObject(CodeExpression value);
    public string get_MethodName();
    public void set_MethodName(string value);
}
public class System.CodeDom.CodeDelegateInvokeExpression : CodeExpression {
    [CompilerGeneratedAttribute]
private CodeExpression <TargetObject>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeExpressionCollection <Parameters>k__BackingField;
    public CodeExpression TargetObject { get; public set; }
    public CodeExpressionCollection Parameters { get; }
    public CodeDelegateInvokeExpression(CodeExpression targetObject);
    public CodeDelegateInvokeExpression(CodeExpression targetObject, CodeExpression[] parameters);
    [CompilerGeneratedAttribute]
public CodeExpression get_TargetObject();
    [CompilerGeneratedAttribute]
public void set_TargetObject(CodeExpression value);
    [CompilerGeneratedAttribute]
public CodeExpressionCollection get_Parameters();
}
public class System.CodeDom.CodeDirectionExpression : CodeExpression {
    [CompilerGeneratedAttribute]
private CodeExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldDirection <Direction>k__BackingField;
    public CodeExpression Expression { get; public set; }
    public FieldDirection Direction { get; public set; }
    public CodeDirectionExpression(FieldDirection direction, CodeExpression expression);
    [CompilerGeneratedAttribute]
public CodeExpression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(CodeExpression value);
    [CompilerGeneratedAttribute]
public FieldDirection get_Direction();
    [CompilerGeneratedAttribute]
public void set_Direction(FieldDirection value);
}
public class System.CodeDom.CodeDirective : CodeObject {
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeDirectiveCollection : CollectionBase {
    public CodeDirective Item { get; public set; }
    public CodeDirectiveCollection(CodeDirectiveCollection value);
    public CodeDirectiveCollection(CodeDirective[] value);
    public CodeDirective get_Item(int index);
    public void set_Item(int index, CodeDirective value);
    public int Add(CodeDirective value);
    public void AddRange(CodeDirective[] value);
    public void AddRange(CodeDirectiveCollection value);
    public bool Contains(CodeDirective value);
    public void CopyTo(CodeDirective[] array, int index);
    public int IndexOf(CodeDirective value);
    public void Insert(int index, CodeDirective value);
    public void Remove(CodeDirective value);
}
public class System.CodeDom.CodeEntryPointMethod : CodeMemberMethod {
}
public class System.CodeDom.CodeEventReferenceExpression : CodeExpression {
    private string _eventName;
    [CompilerGeneratedAttribute]
private CodeExpression <TargetObject>k__BackingField;
    public CodeExpression TargetObject { get; public set; }
    public string EventName { get; public set; }
    public CodeEventReferenceExpression(CodeExpression targetObject, string eventName);
    [CompilerGeneratedAttribute]
public CodeExpression get_TargetObject();
    [CompilerGeneratedAttribute]
public void set_TargetObject(CodeExpression value);
    public string get_EventName();
    public void set_EventName(string value);
}
public class System.CodeDom.CodeExpression : CodeObject {
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeExpressionCollection : CollectionBase {
    public CodeExpression Item { get; public set; }
    public CodeExpressionCollection(CodeExpressionCollection value);
    public CodeExpressionCollection(CodeExpression[] value);
    public CodeExpression get_Item(int index);
    public void set_Item(int index, CodeExpression value);
    public int Add(CodeExpression value);
    public void AddRange(CodeExpression[] value);
    public void AddRange(CodeExpressionCollection value);
    public bool Contains(CodeExpression value);
    public void CopyTo(CodeExpression[] array, int index);
    public int IndexOf(CodeExpression value);
    public void Insert(int index, CodeExpression value);
    public void Remove(CodeExpression value);
}
public class System.CodeDom.CodeExpressionStatement : CodeStatement {
    [CompilerGeneratedAttribute]
private CodeExpression <Expression>k__BackingField;
    public CodeExpression Expression { get; public set; }
    public CodeExpressionStatement(CodeExpression expression);
    [CompilerGeneratedAttribute]
public CodeExpression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(CodeExpression value);
}
public class System.CodeDom.CodeFieldReferenceExpression : CodeExpression {
    private string _fieldName;
    [CompilerGeneratedAttribute]
private CodeExpression <TargetObject>k__BackingField;
    public CodeExpression TargetObject { get; public set; }
    public string FieldName { get; public set; }
    public CodeFieldReferenceExpression(CodeExpression targetObject, string fieldName);
    [CompilerGeneratedAttribute]
public CodeExpression get_TargetObject();
    [CompilerGeneratedAttribute]
public void set_TargetObject(CodeExpression value);
    public string get_FieldName();
    public void set_FieldName(string value);
}
public class System.CodeDom.CodeGotoStatement : CodeStatement {
    private string _label;
    public string Label { get; public set; }
    public CodeGotoStatement(string label);
    public string get_Label();
    public void set_Label(string value);
}
public class System.CodeDom.CodeIndexerExpression : CodeExpression {
    private CodeExpressionCollection _indices;
    [CompilerGeneratedAttribute]
private CodeExpression <TargetObject>k__BackingField;
    public CodeExpression TargetObject { get; public set; }
    public CodeExpressionCollection Indices { get; }
    public CodeIndexerExpression(CodeExpression targetObject, CodeExpression[] indices);
    [CompilerGeneratedAttribute]
public CodeExpression get_TargetObject();
    [CompilerGeneratedAttribute]
public void set_TargetObject(CodeExpression value);
    public CodeExpressionCollection get_Indices();
}
public class System.CodeDom.CodeIterationStatement : CodeStatement {
    [CompilerGeneratedAttribute]
private CodeStatement <InitStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeExpression <TestExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStatement <IncrementStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStatementCollection <Statements>k__BackingField;
    public CodeStatement InitStatement { get; public set; }
    public CodeExpression TestExpression { get; public set; }
    public CodeStatement IncrementStatement { get; public set; }
    public CodeStatementCollection Statements { get; }
    public CodeIterationStatement(CodeStatement initStatement, CodeExpression testExpression, CodeStatement incrementStatement, CodeStatement[] statements);
    [CompilerGeneratedAttribute]
public CodeStatement get_InitStatement();
    [CompilerGeneratedAttribute]
public void set_InitStatement(CodeStatement value);
    [CompilerGeneratedAttribute]
public CodeExpression get_TestExpression();
    [CompilerGeneratedAttribute]
public void set_TestExpression(CodeExpression value);
    [CompilerGeneratedAttribute]
public CodeStatement get_IncrementStatement();
    [CompilerGeneratedAttribute]
public void set_IncrementStatement(CodeStatement value);
    [CompilerGeneratedAttribute]
public CodeStatementCollection get_Statements();
}
public class System.CodeDom.CodeLabeledStatement : CodeStatement {
    private string _label;
    [CompilerGeneratedAttribute]
private CodeStatement <Statement>k__BackingField;
    public string Label { get; public set; }
    public CodeStatement Statement { get; public set; }
    public CodeLabeledStatement(string label);
    public CodeLabeledStatement(string label, CodeStatement statement);
    public string get_Label();
    public void set_Label(string value);
    [CompilerGeneratedAttribute]
public CodeStatement get_Statement();
    [CompilerGeneratedAttribute]
public void set_Statement(CodeStatement value);
}
public class System.CodeDom.CodeLinePragma : object {
    private string _fileName;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    public string FileName { get; public set; }
    public int LineNumber { get; public set; }
    public CodeLinePragma(string fileName, int lineNumber);
    public string get_FileName();
    public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
}
public class System.CodeDom.CodeMemberEvent : CodeTypeMember {
    private CodeTypeReference _type;
    private CodeTypeReferenceCollection _implementationTypes;
    [CompilerGeneratedAttribute]
private CodeTypeReference <PrivateImplementationType>k__BackingField;
    public CodeTypeReference Type { get; public set; }
    public CodeTypeReference PrivateImplementationType { get; public set; }
    public CodeTypeReferenceCollection ImplementationTypes { get; }
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
    [CompilerGeneratedAttribute]
public CodeTypeReference get_PrivateImplementationType();
    [CompilerGeneratedAttribute]
public void set_PrivateImplementationType(CodeTypeReference value);
    public CodeTypeReferenceCollection get_ImplementationTypes();
}
public class System.CodeDom.CodeMemberField : CodeTypeMember {
    private CodeTypeReference _type;
    [CompilerGeneratedAttribute]
private CodeExpression <InitExpression>k__BackingField;
    public CodeTypeReference Type { get; public set; }
    public CodeExpression InitExpression { get; public set; }
    public CodeMemberField(CodeTypeReference type, string name);
    public CodeMemberField(string type, string name);
    public CodeMemberField(Type type, string name);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
    [CompilerGeneratedAttribute]
public CodeExpression get_InitExpression();
    [CompilerGeneratedAttribute]
public void set_InitExpression(CodeExpression value);
}
public class System.CodeDom.CodeMemberMethod : CodeTypeMember {
    private CodeParameterDeclarationExpressionCollection _parameters;
    private CodeStatementCollection _statements;
    private CodeTypeReference _returnType;
    private CodeTypeReferenceCollection _implementationTypes;
    private CodeAttributeDeclarationCollection _returnAttributes;
    private CodeTypeParameterCollection _typeParameters;
    private int _populated;
    private static int ParametersCollection;
    private static int StatementsCollection;
    private static int ImplTypesCollection;
    [CompilerGeneratedAttribute]
private EventHandler PopulateParameters;
    [CompilerGeneratedAttribute]
private EventHandler PopulateStatements;
    [CompilerGeneratedAttribute]
private EventHandler PopulateImplementationTypes;
    [CompilerGeneratedAttribute]
private CodeTypeReference <PrivateImplementationType>k__BackingField;
    public CodeTypeReference ReturnType { get; public set; }
    public CodeStatementCollection Statements { get; }
    public CodeParameterDeclarationExpressionCollection Parameters { get; }
    public CodeTypeReference PrivateImplementationType { get; public set; }
    public CodeTypeReferenceCollection ImplementationTypes { get; }
    public CodeAttributeDeclarationCollection ReturnTypeCustomAttributes { get; }
    public CodeTypeParameterCollection TypeParameters { get; }
    [CompilerGeneratedAttribute]
public void add_PopulateParameters(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateParameters(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateStatements(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateStatements(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateImplementationTypes(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateImplementationTypes(EventHandler value);
    public CodeTypeReference get_ReturnType();
    public void set_ReturnType(CodeTypeReference value);
    public CodeStatementCollection get_Statements();
    public CodeParameterDeclarationExpressionCollection get_Parameters();
    [CompilerGeneratedAttribute]
public CodeTypeReference get_PrivateImplementationType();
    [CompilerGeneratedAttribute]
public void set_PrivateImplementationType(CodeTypeReference value);
    public CodeTypeReferenceCollection get_ImplementationTypes();
    public CodeAttributeDeclarationCollection get_ReturnTypeCustomAttributes();
    public CodeTypeParameterCollection get_TypeParameters();
}
public class System.CodeDom.CodeMemberProperty : CodeTypeMember {
    private CodeTypeReference _type;
    private bool _hasGet;
    private bool _hasSet;
    private CodeTypeReferenceCollection _implementationTypes;
    [CompilerGeneratedAttribute]
private CodeTypeReference <PrivateImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStatementCollection <GetStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStatementCollection <SetStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeParameterDeclarationExpressionCollection <Parameters>k__BackingField;
    public CodeTypeReference PrivateImplementationType { get; public set; }
    public CodeTypeReferenceCollection ImplementationTypes { get; }
    public CodeTypeReference Type { get; public set; }
    public bool HasGet { get; public set; }
    public bool HasSet { get; public set; }
    public CodeStatementCollection GetStatements { get; }
    public CodeStatementCollection SetStatements { get; }
    public CodeParameterDeclarationExpressionCollection Parameters { get; }
    [CompilerGeneratedAttribute]
public CodeTypeReference get_PrivateImplementationType();
    [CompilerGeneratedAttribute]
public void set_PrivateImplementationType(CodeTypeReference value);
    public CodeTypeReferenceCollection get_ImplementationTypes();
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
    public bool get_HasGet();
    public void set_HasGet(bool value);
    public bool get_HasSet();
    public void set_HasSet(bool value);
    [CompilerGeneratedAttribute]
public CodeStatementCollection get_GetStatements();
    [CompilerGeneratedAttribute]
public CodeStatementCollection get_SetStatements();
    [CompilerGeneratedAttribute]
public CodeParameterDeclarationExpressionCollection get_Parameters();
}
public class System.CodeDom.CodeMethodInvokeExpression : CodeExpression {
    private CodeMethodReferenceExpression _method;
    [CompilerGeneratedAttribute]
private CodeExpressionCollection <Parameters>k__BackingField;
    public CodeMethodReferenceExpression Method { get; public set; }
    public CodeExpressionCollection Parameters { get; }
    public CodeMethodInvokeExpression(CodeMethodReferenceExpression method, CodeExpression[] parameters);
    public CodeMethodInvokeExpression(CodeExpression targetObject, string methodName, CodeExpression[] parameters);
    public CodeMethodReferenceExpression get_Method();
    public void set_Method(CodeMethodReferenceExpression value);
    [CompilerGeneratedAttribute]
public CodeExpressionCollection get_Parameters();
}
public class System.CodeDom.CodeMethodReferenceExpression : CodeExpression {
    private string _methodName;
    private CodeTypeReferenceCollection _typeArguments;
    [CompilerGeneratedAttribute]
private CodeExpression <TargetObject>k__BackingField;
    public CodeExpression TargetObject { get; public set; }
    public string MethodName { get; public set; }
    public CodeTypeReferenceCollection TypeArguments { get; }
    public CodeMethodReferenceExpression(CodeExpression targetObject, string methodName);
    public CodeMethodReferenceExpression(CodeExpression targetObject, string methodName, CodeTypeReference[] typeParameters);
    [CompilerGeneratedAttribute]
public CodeExpression get_TargetObject();
    [CompilerGeneratedAttribute]
public void set_TargetObject(CodeExpression value);
    public string get_MethodName();
    public void set_MethodName(string value);
    public CodeTypeReferenceCollection get_TypeArguments();
}
public class System.CodeDom.CodeMethodReturnStatement : CodeStatement {
    [CompilerGeneratedAttribute]
private CodeExpression <Expression>k__BackingField;
    public CodeExpression Expression { get; public set; }
    public CodeMethodReturnStatement(CodeExpression expression);
    [CompilerGeneratedAttribute]
public CodeExpression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(CodeExpression value);
}
public class System.CodeDom.CodeNamespace : CodeObject {
    private string _name;
    private CodeNamespaceImportCollection _imports;
    private CodeCommentStatementCollection _comments;
    private CodeTypeDeclarationCollection _classes;
    private int _populated;
    private static int ImportsCollection;
    private static int CommentsCollection;
    private static int TypesCollection;
    [CompilerGeneratedAttribute]
private EventHandler PopulateComments;
    [CompilerGeneratedAttribute]
private EventHandler PopulateImports;
    [CompilerGeneratedAttribute]
private EventHandler PopulateTypes;
    public CodeTypeDeclarationCollection Types { get; }
    public CodeNamespaceImportCollection Imports { get; }
    public string Name { get; public set; }
    public CodeCommentStatementCollection Comments { get; }
    public CodeNamespace(string name);
    [CompilerGeneratedAttribute]
public void add_PopulateComments(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateComments(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateImports(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateImports(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateTypes(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateTypes(EventHandler value);
    public CodeTypeDeclarationCollection get_Types();
    public CodeNamespaceImportCollection get_Imports();
    public string get_Name();
    public void set_Name(string value);
    public CodeCommentStatementCollection get_Comments();
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeNamespaceCollection : CollectionBase {
    public CodeNamespace Item { get; public set; }
    public CodeNamespaceCollection(CodeNamespaceCollection value);
    public CodeNamespaceCollection(CodeNamespace[] value);
    public CodeNamespace get_Item(int index);
    public void set_Item(int index, CodeNamespace value);
    public int Add(CodeNamespace value);
    public void AddRange(CodeNamespace[] value);
    public void AddRange(CodeNamespaceCollection value);
    public bool Contains(CodeNamespace value);
    public void CopyTo(CodeNamespace[] array, int index);
    public int IndexOf(CodeNamespace value);
    public void Insert(int index, CodeNamespace value);
    public void Remove(CodeNamespace value);
}
public class System.CodeDom.CodeNamespaceImport : CodeObject {
    private string _nameSpace;
    [CompilerGeneratedAttribute]
private CodeLinePragma <LinePragma>k__BackingField;
    public CodeLinePragma LinePragma { get; public set; }
    public string Namespace { get; public set; }
    public CodeNamespaceImport(string nameSpace);
    [CompilerGeneratedAttribute]
public CodeLinePragma get_LinePragma();
    [CompilerGeneratedAttribute]
public void set_LinePragma(CodeLinePragma value);
    public string get_Namespace();
    public void set_Namespace(string value);
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeNamespaceImportCollection : object {
    private ArrayList _data;
    private Dictionary`2<string, CodeNamespaceImport> _keys;
    public CodeNamespaceImport Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public CodeNamespaceImport get_Item(int index);
    public void set_Item(int index, CodeNamespaceImport value);
    public int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public void Add(CodeNamespaceImport value);
    public void AddRange(CodeNamespaceImport[] value);
    public void Clear();
    private void SyncKeys();
    public IEnumerator GetEnumerator();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
public class System.CodeDom.CodeObject : object {
    private IDictionary _userData;
    public IDictionary UserData { get; }
    public IDictionary get_UserData();
}
public class System.CodeDom.CodeObjectCreateExpression : CodeExpression {
    private CodeTypeReference _createType;
    [CompilerGeneratedAttribute]
private CodeExpressionCollection <Parameters>k__BackingField;
    public CodeTypeReference CreateType { get; public set; }
    public CodeExpressionCollection Parameters { get; }
    public CodeObjectCreateExpression(CodeTypeReference createType, CodeExpression[] parameters);
    public CodeObjectCreateExpression(string createType, CodeExpression[] parameters);
    public CodeObjectCreateExpression(Type createType, CodeExpression[] parameters);
    public CodeTypeReference get_CreateType();
    public void set_CreateType(CodeTypeReference value);
    [CompilerGeneratedAttribute]
public CodeExpressionCollection get_Parameters();
}
public class System.CodeDom.CodeParameterDeclarationExpression : CodeExpression {
    private CodeTypeReference _type;
    private string _name;
    private CodeAttributeDeclarationCollection _customAttributes;
    [CompilerGeneratedAttribute]
private FieldDirection <Direction>k__BackingField;
    public CodeAttributeDeclarationCollection CustomAttributes { get; public set; }
    public FieldDirection Direction { get; public set; }
    public CodeTypeReference Type { get; public set; }
    public string Name { get; public set; }
    public CodeParameterDeclarationExpression(CodeTypeReference type, string name);
    public CodeParameterDeclarationExpression(string type, string name);
    public CodeParameterDeclarationExpression(Type type, string name);
    public CodeAttributeDeclarationCollection get_CustomAttributes();
    public void set_CustomAttributes(CodeAttributeDeclarationCollection value);
    [CompilerGeneratedAttribute]
public FieldDirection get_Direction();
    [CompilerGeneratedAttribute]
public void set_Direction(FieldDirection value);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
    public string get_Name();
    public void set_Name(string value);
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeParameterDeclarationExpressionCollection : CollectionBase {
    public CodeParameterDeclarationExpression Item { get; public set; }
    public CodeParameterDeclarationExpressionCollection(CodeParameterDeclarationExpressionCollection value);
    public CodeParameterDeclarationExpressionCollection(CodeParameterDeclarationExpression[] value);
    public CodeParameterDeclarationExpression get_Item(int index);
    public void set_Item(int index, CodeParameterDeclarationExpression value);
    public int Add(CodeParameterDeclarationExpression value);
    public void AddRange(CodeParameterDeclarationExpression[] value);
    public void AddRange(CodeParameterDeclarationExpressionCollection value);
    public bool Contains(CodeParameterDeclarationExpression value);
    public void CopyTo(CodeParameterDeclarationExpression[] array, int index);
    public int IndexOf(CodeParameterDeclarationExpression value);
    public void Insert(int index, CodeParameterDeclarationExpression value);
    public void Remove(CodeParameterDeclarationExpression value);
}
public class System.CodeDom.CodePrimitiveExpression : CodeExpression {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; public set; }
    public CodePrimitiveExpression(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public class System.CodeDom.CodePropertyReferenceExpression : CodeExpression {
    private string _propertyName;
    [CompilerGeneratedAttribute]
private CodeExpression <TargetObject>k__BackingField;
    public CodeExpression TargetObject { get; public set; }
    public string PropertyName { get; public set; }
    public CodePropertyReferenceExpression(CodeExpression targetObject, string propertyName);
    [CompilerGeneratedAttribute]
public CodeExpression get_TargetObject();
    [CompilerGeneratedAttribute]
public void set_TargetObject(CodeExpression value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
}
public class System.CodeDom.CodePropertySetValueReferenceExpression : CodeExpression {
}
public class System.CodeDom.CodeRegionDirective : CodeDirective {
    private string _regionText;
    [CompilerGeneratedAttribute]
private CodeRegionMode <RegionMode>k__BackingField;
    public string RegionText { get; public set; }
    public CodeRegionMode RegionMode { get; public set; }
    public CodeRegionDirective(CodeRegionMode regionMode, string regionText);
    public string get_RegionText();
    public void set_RegionText(string value);
    [CompilerGeneratedAttribute]
public CodeRegionMode get_RegionMode();
    [CompilerGeneratedAttribute]
public void set_RegionMode(CodeRegionMode value);
}
public enum System.CodeDom.CodeRegionMode : Enum {
    public int value__;
    public static CodeRegionMode None;
    public static CodeRegionMode Start;
    public static CodeRegionMode End;
}
public class System.CodeDom.CodeRemoveEventStatement : CodeStatement {
    private CodeEventReferenceExpression _eventRef;
    [CompilerGeneratedAttribute]
private CodeExpression <Listener>k__BackingField;
    public CodeEventReferenceExpression Event { get; public set; }
    public CodeExpression Listener { get; public set; }
    public CodeRemoveEventStatement(CodeEventReferenceExpression eventRef, CodeExpression listener);
    public CodeRemoveEventStatement(CodeExpression targetObject, string eventName, CodeExpression listener);
    public CodeEventReferenceExpression get_Event();
    public void set_Event(CodeEventReferenceExpression value);
    [CompilerGeneratedAttribute]
public CodeExpression get_Listener();
    [CompilerGeneratedAttribute]
public void set_Listener(CodeExpression value);
}
public class System.CodeDom.CodeSnippetCompileUnit : CodeCompileUnit {
    private string _value;
    [CompilerGeneratedAttribute]
private CodeLinePragma <LinePragma>k__BackingField;
    public string Value { get; public set; }
    public CodeLinePragma LinePragma { get; public set; }
    public CodeSnippetCompileUnit(string value);
    public string get_Value();
    public void set_Value(string value);
    [CompilerGeneratedAttribute]
public CodeLinePragma get_LinePragma();
    [CompilerGeneratedAttribute]
public void set_LinePragma(CodeLinePragma value);
}
public class System.CodeDom.CodeSnippetExpression : CodeExpression {
    private string _value;
    public string Value { get; public set; }
    public CodeSnippetExpression(string value);
    public string get_Value();
    public void set_Value(string value);
}
public class System.CodeDom.CodeSnippetStatement : CodeStatement {
    private string _value;
    public string Value { get; public set; }
    public CodeSnippetStatement(string value);
    public string get_Value();
    public void set_Value(string value);
}
public class System.CodeDom.CodeSnippetTypeMember : CodeTypeMember {
    private string _text;
    public string Text { get; public set; }
    public CodeSnippetTypeMember(string text);
    public string get_Text();
    public void set_Text(string value);
}
public class System.CodeDom.CodeStatement : CodeObject {
    private CodeDirectiveCollection _startDirectives;
    private CodeDirectiveCollection _endDirectives;
    [CompilerGeneratedAttribute]
private CodeLinePragma <LinePragma>k__BackingField;
    public CodeLinePragma LinePragma { get; public set; }
    public CodeDirectiveCollection StartDirectives { get; }
    public CodeDirectiveCollection EndDirectives { get; }
    [CompilerGeneratedAttribute]
public CodeLinePragma get_LinePragma();
    [CompilerGeneratedAttribute]
public void set_LinePragma(CodeLinePragma value);
    public CodeDirectiveCollection get_StartDirectives();
    public CodeDirectiveCollection get_EndDirectives();
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeStatementCollection : CollectionBase {
    public CodeStatement Item { get; public set; }
    public CodeStatementCollection(CodeStatementCollection value);
    public CodeStatementCollection(CodeStatement[] value);
    public CodeStatement get_Item(int index);
    public void set_Item(int index, CodeStatement value);
    public int Add(CodeStatement value);
    public int Add(CodeExpression value);
    public void AddRange(CodeStatement[] value);
    public void AddRange(CodeStatementCollection value);
    public bool Contains(CodeStatement value);
    public void CopyTo(CodeStatement[] array, int index);
    public int IndexOf(CodeStatement value);
    public void Insert(int index, CodeStatement value);
    public void Remove(CodeStatement value);
}
public class System.CodeDom.CodeThisReferenceExpression : CodeExpression {
}
public class System.CodeDom.CodeThrowExceptionStatement : CodeStatement {
    [CompilerGeneratedAttribute]
private CodeExpression <ToThrow>k__BackingField;
    public CodeExpression ToThrow { get; public set; }
    public CodeThrowExceptionStatement(CodeExpression toThrow);
    [CompilerGeneratedAttribute]
public CodeExpression get_ToThrow();
    [CompilerGeneratedAttribute]
public void set_ToThrow(CodeExpression value);
}
public class System.CodeDom.CodeTryCatchFinallyStatement : CodeStatement {
    [CompilerGeneratedAttribute]
private CodeStatementCollection <TryStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCatchClauseCollection <CatchClauses>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStatementCollection <FinallyStatements>k__BackingField;
    public CodeStatementCollection TryStatements { get; }
    public CodeCatchClauseCollection CatchClauses { get; }
    public CodeStatementCollection FinallyStatements { get; }
    public CodeTryCatchFinallyStatement(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses);
    public CodeTryCatchFinallyStatement(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses, CodeStatement[] finallyStatements);
    [CompilerGeneratedAttribute]
public CodeStatementCollection get_TryStatements();
    [CompilerGeneratedAttribute]
public CodeCatchClauseCollection get_CatchClauses();
    [CompilerGeneratedAttribute]
public CodeStatementCollection get_FinallyStatements();
}
public class System.CodeDom.CodeTypeConstructor : CodeMemberMethod {
}
public class System.CodeDom.CodeTypeDeclaration : CodeTypeMember {
    private CodeTypeReferenceCollection _baseTypes;
    private CodeTypeMemberCollection _members;
    private bool _isEnum;
    private bool _isStruct;
    private int _populated;
    private static int BaseTypesCollection;
    private static int MembersCollection;
    private CodeTypeParameterCollection _typeParameters;
    [CompilerGeneratedAttribute]
private EventHandler PopulateBaseTypes;
    [CompilerGeneratedAttribute]
private EventHandler PopulateMembers;
    [CompilerGeneratedAttribute]
private TypeAttributes <TypeAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPartial>k__BackingField;
    public TypeAttributes TypeAttributes { get; public set; }
    public CodeTypeReferenceCollection BaseTypes { get; }
    public bool IsClass { get; public set; }
    public bool IsStruct { get; public set; }
    public bool IsEnum { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsPartial { get; public set; }
    public CodeTypeMemberCollection Members { get; }
    public CodeTypeParameterCollection TypeParameters { get; }
    public CodeTypeDeclaration(string name);
    [CompilerGeneratedAttribute]
public void add_PopulateBaseTypes(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateBaseTypes(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateMembers(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateMembers(EventHandler value);
    [CompilerGeneratedAttribute]
public TypeAttributes get_TypeAttributes();
    [CompilerGeneratedAttribute]
public void set_TypeAttributes(TypeAttributes value);
    public CodeTypeReferenceCollection get_BaseTypes();
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsStruct();
    public void set_IsStruct(bool value);
    public bool get_IsEnum();
    public void set_IsEnum(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPartial();
    [CompilerGeneratedAttribute]
public void set_IsPartial(bool value);
    public CodeTypeMemberCollection get_Members();
    public CodeTypeParameterCollection get_TypeParameters();
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeTypeDeclarationCollection : CollectionBase {
    public CodeTypeDeclaration Item { get; public set; }
    public CodeTypeDeclarationCollection(CodeTypeDeclarationCollection value);
    public CodeTypeDeclarationCollection(CodeTypeDeclaration[] value);
    public CodeTypeDeclaration get_Item(int index);
    public void set_Item(int index, CodeTypeDeclaration value);
    public int Add(CodeTypeDeclaration value);
    public void AddRange(CodeTypeDeclaration[] value);
    public void AddRange(CodeTypeDeclarationCollection value);
    public bool Contains(CodeTypeDeclaration value);
    public void CopyTo(CodeTypeDeclaration[] array, int index);
    public int IndexOf(CodeTypeDeclaration value);
    public void Insert(int index, CodeTypeDeclaration value);
    public void Remove(CodeTypeDeclaration value);
}
public class System.CodeDom.CodeTypeDelegate : CodeTypeDeclaration {
    private CodeTypeReference _returnType;
    [CompilerGeneratedAttribute]
private CodeParameterDeclarationExpressionCollection <Parameters>k__BackingField;
    public CodeTypeReference ReturnType { get; public set; }
    public CodeParameterDeclarationExpressionCollection Parameters { get; }
    public CodeTypeDelegate(string name);
    public CodeTypeReference get_ReturnType();
    public void set_ReturnType(CodeTypeReference value);
    [CompilerGeneratedAttribute]
public CodeParameterDeclarationExpressionCollection get_Parameters();
}
public class System.CodeDom.CodeTypeMember : CodeObject {
    private string _name;
    private CodeAttributeDeclarationCollection _customAttributes;
    private CodeDirectiveCollection _startDirectives;
    private CodeDirectiveCollection _endDirectives;
    [CompilerGeneratedAttribute]
private MemberAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeLinePragma <LinePragma>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCommentStatementCollection <Comments>k__BackingField;
    public string Name { get; public set; }
    public MemberAttributes Attributes { get; public set; }
    public CodeAttributeDeclarationCollection CustomAttributes { get; public set; }
    public CodeLinePragma LinePragma { get; public set; }
    public CodeCommentStatementCollection Comments { get; }
    public CodeDirectiveCollection StartDirectives { get; }
    public CodeDirectiveCollection EndDirectives { get; }
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public MemberAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(MemberAttributes value);
    public CodeAttributeDeclarationCollection get_CustomAttributes();
    public void set_CustomAttributes(CodeAttributeDeclarationCollection value);
    [CompilerGeneratedAttribute]
public CodeLinePragma get_LinePragma();
    [CompilerGeneratedAttribute]
public void set_LinePragma(CodeLinePragma value);
    [CompilerGeneratedAttribute]
public CodeCommentStatementCollection get_Comments();
    public CodeDirectiveCollection get_StartDirectives();
    public CodeDirectiveCollection get_EndDirectives();
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeTypeMemberCollection : CollectionBase {
    public CodeTypeMember Item { get; public set; }
    public CodeTypeMemberCollection(CodeTypeMemberCollection value);
    public CodeTypeMemberCollection(CodeTypeMember[] value);
    public CodeTypeMember get_Item(int index);
    public void set_Item(int index, CodeTypeMember value);
    public int Add(CodeTypeMember value);
    public void AddRange(CodeTypeMember[] value);
    public void AddRange(CodeTypeMemberCollection value);
    public bool Contains(CodeTypeMember value);
    public void CopyTo(CodeTypeMember[] array, int index);
    public int IndexOf(CodeTypeMember value);
    public void Insert(int index, CodeTypeMember value);
    public void Remove(CodeTypeMember value);
}
public class System.CodeDom.CodeTypeOfExpression : CodeExpression {
    private CodeTypeReference _type;
    public CodeTypeReference Type { get; public set; }
    public CodeTypeOfExpression(CodeTypeReference type);
    public CodeTypeOfExpression(string type);
    public CodeTypeOfExpression(Type type);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
}
public class System.CodeDom.CodeTypeParameter : CodeObject {
    private string _name;
    private CodeAttributeDeclarationCollection _customAttributes;
    private CodeTypeReferenceCollection _constraints;
    [CompilerGeneratedAttribute]
private bool <HasConstructorConstraint>k__BackingField;
    public string Name { get; public set; }
    public CodeTypeReferenceCollection Constraints { get; }
    public CodeAttributeDeclarationCollection CustomAttributes { get; }
    public bool HasConstructorConstraint { get; public set; }
    public CodeTypeParameter(string name);
    public string get_Name();
    public void set_Name(string value);
    public CodeTypeReferenceCollection get_Constraints();
    public CodeAttributeDeclarationCollection get_CustomAttributes();
    [CompilerGeneratedAttribute]
public bool get_HasConstructorConstraint();
    [CompilerGeneratedAttribute]
public void set_HasConstructorConstraint(bool value);
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeTypeParameterCollection : CollectionBase {
    public CodeTypeParameter Item { get; public set; }
    public CodeTypeParameterCollection(CodeTypeParameterCollection value);
    public CodeTypeParameterCollection(CodeTypeParameter[] value);
    public CodeTypeParameter get_Item(int index);
    public void set_Item(int index, CodeTypeParameter value);
    public int Add(CodeTypeParameter value);
    public void Add(string value);
    public void AddRange(CodeTypeParameter[] value);
    public void AddRange(CodeTypeParameterCollection value);
    public bool Contains(CodeTypeParameter value);
    public void CopyTo(CodeTypeParameter[] array, int index);
    public int IndexOf(CodeTypeParameter value);
    public void Insert(int index, CodeTypeParameter value);
    public void Remove(CodeTypeParameter value);
}
public class System.CodeDom.CodeTypeReference : CodeObject {
    private string _baseType;
    private bool _isInterface;
    private CodeTypeReferenceCollection _typeArguments;
    private bool _needsFixup;
    [CompilerGeneratedAttribute]
private CodeTypeReference <ArrayElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArrayRank>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeTypeReferenceOptions <Options>k__BackingField;
    public CodeTypeReference ArrayElementType { get; public set; }
    public int ArrayRank { get; public set; }
    internal int NestedArrayDepth { get; }
    public string BaseType { get; public set; }
    public CodeTypeReferenceOptions Options { get; public set; }
    public CodeTypeReferenceCollection TypeArguments { get; }
    internal bool IsInterface { get; }
    public CodeTypeReference(Type type);
    public CodeTypeReference(Type type, CodeTypeReferenceOptions codeTypeReferenceOption);
    public CodeTypeReference(string typeName, CodeTypeReferenceOptions codeTypeReferenceOption);
    public CodeTypeReference(string typeName);
    public CodeTypeReference(string typeName, CodeTypeReference[] typeArguments);
    public CodeTypeReference(CodeTypeParameter typeParameter);
    public CodeTypeReference(string baseType, int rank);
    public CodeTypeReference(CodeTypeReference arrayType, int rank);
    private void InitializeFromType(Type type);
    private void Initialize(string typeName);
    private void Initialize(string typeName, CodeTypeReferenceOptions options);
    [CompilerGeneratedAttribute]
public CodeTypeReference get_ArrayElementType();
    [CompilerGeneratedAttribute]
public void set_ArrayElementType(CodeTypeReference value);
    [CompilerGeneratedAttribute]
public int get_ArrayRank();
    [CompilerGeneratedAttribute]
public void set_ArrayRank(int value);
    internal int get_NestedArrayDepth();
    public string get_BaseType();
    public void set_BaseType(string value);
    [CompilerGeneratedAttribute]
public CodeTypeReferenceOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(CodeTypeReferenceOptions value);
    public CodeTypeReferenceCollection get_TypeArguments();
    internal bool get_IsInterface();
    private string RipOffAssemblyInformationFromTypeName(string typeName);
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.CodeTypeReferenceCollection : CollectionBase {
    public CodeTypeReference Item { get; public set; }
    public CodeTypeReferenceCollection(CodeTypeReferenceCollection value);
    public CodeTypeReferenceCollection(CodeTypeReference[] value);
    public CodeTypeReference get_Item(int index);
    public void set_Item(int index, CodeTypeReference value);
    public int Add(CodeTypeReference value);
    public void Add(string value);
    public void Add(Type value);
    public void AddRange(CodeTypeReference[] value);
    public void AddRange(CodeTypeReferenceCollection value);
    public bool Contains(CodeTypeReference value);
    public void CopyTo(CodeTypeReference[] array, int index);
    public int IndexOf(CodeTypeReference value);
    public void Insert(int index, CodeTypeReference value);
    public void Remove(CodeTypeReference value);
}
public class System.CodeDom.CodeTypeReferenceExpression : CodeExpression {
    private CodeTypeReference _type;
    public CodeTypeReference Type { get; public set; }
    public CodeTypeReferenceExpression(CodeTypeReference type);
    public CodeTypeReferenceExpression(string type);
    public CodeTypeReferenceExpression(Type type);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
}
[FlagsAttribute]
public enum System.CodeDom.CodeTypeReferenceOptions : Enum {
    public int value__;
    public static CodeTypeReferenceOptions GlobalReference;
    public static CodeTypeReferenceOptions GenericTypeParameter;
}
public class System.CodeDom.CodeVariableDeclarationStatement : CodeStatement {
    private CodeTypeReference _type;
    private string _name;
    [CompilerGeneratedAttribute]
private CodeExpression <InitExpression>k__BackingField;
    public CodeExpression InitExpression { get; public set; }
    public string Name { get; public set; }
    public CodeTypeReference Type { get; public set; }
    public CodeVariableDeclarationStatement(CodeTypeReference type, string name);
    public CodeVariableDeclarationStatement(string type, string name);
    public CodeVariableDeclarationStatement(Type type, string name);
    public CodeVariableDeclarationStatement(CodeTypeReference type, string name, CodeExpression initExpression);
    public CodeVariableDeclarationStatement(string type, string name, CodeExpression initExpression);
    public CodeVariableDeclarationStatement(Type type, string name, CodeExpression initExpression);
    [CompilerGeneratedAttribute]
public CodeExpression get_InitExpression();
    [CompilerGeneratedAttribute]
public void set_InitExpression(CodeExpression value);
    public string get_Name();
    public void set_Name(string value);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
}
public class System.CodeDom.CodeVariableReferenceExpression : CodeExpression {
    private string _variableName;
    public string VariableName { get; public set; }
    public CodeVariableReferenceExpression(string variableName);
    public string get_VariableName();
    public void set_VariableName(string value);
}
public abstract class System.CodeDom.Compiler.CodeCompiler : CodeGenerator {
    protected string FileExtension { get; }
    protected string CompilerName { get; }
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea);
    protected abstract virtual string get_FileExtension();
    protected abstract virtual string get_CompilerName();
    protected virtual CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e);
    protected virtual CompilerResults FromFile(CompilerParameters options, string fileName);
    protected virtual CompilerResults FromSource(CompilerParameters options, string source);
    protected virtual CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea);
    private void ResolveReferencedAssemblies(CompilerParameters options, CodeCompileUnit e);
    protected virtual CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames);
    protected abstract virtual void ProcessCompilerOutputLine(CompilerResults results, string line);
    protected abstract virtual string CmdArgsFromParameters(CompilerParameters options);
    protected virtual string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs);
    protected virtual CompilerResults FromSourceBatch(CompilerParameters options, String[] sources);
    protected static string JoinStringArray(String[] sa, string separator);
}
internal class System.CodeDom.Compiler.CodeDomConfigurationHandler : ConfigurationSection {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty compilersProp;
    private static CompilerCollection default_compilers;
    [ConfigurationPropertyAttribute("compilers")]
public CompilerCollection Compilers { get; }
    public CompilerInfo[] CompilerInfos { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static CodeDomConfigurationHandler();
    protected virtual void InitializeDefault();
    [MonoTODOAttribute]
protected virtual void PostDeserialize();
    protected virtual object GetRuntimeObject();
    public CompilerCollection get_Compilers();
    public CompilerInfo[] get_CompilerInfos();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public abstract class System.CodeDom.Compiler.CodeDomProvider : Component {
    private static Dictionary`2<string, CompilerInfo> s_compilerLanguages;
    private static Dictionary`2<string, CompilerInfo> s_compilerExtensions;
    private static List`1<CompilerInfo> s_allCompilerInfo;
    public string FileExtension { get; }
    public LanguageOptions LanguageOptions { get; }
    private static CodeDomProvider();
    private static void AddCompilerInfo(CompilerInfo compilerInfo);
    public static CodeDomProvider CreateProvider(string language, IDictionary`2<string, string> providerOptions);
    public static CodeDomProvider CreateProvider(string language);
    public static string GetLanguageFromExtension(string extension);
    public static bool IsDefinedLanguage(string language);
    public static bool IsDefinedExtension(string extension);
    public static CompilerInfo GetCompilerInfo(string language);
    private static CompilerInfo GetCompilerInfoForLanguageNoThrow(string language);
    private static CompilerInfo GetCompilerInfoForExtensionNoThrow(string extension);
    public static CompilerInfo[] GetAllCompilerInfo();
    public virtual string get_FileExtension();
    public virtual LanguageOptions get_LanguageOptions();
    [ObsoleteAttribute("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")]
public abstract virtual ICodeGenerator CreateGenerator();
    public virtual ICodeGenerator CreateGenerator(TextWriter output);
    public virtual ICodeGenerator CreateGenerator(string fileName);
    [ObsoleteAttribute("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")]
public abstract virtual ICodeCompiler CreateCompiler();
    [ObsoleteAttribute("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")]
public virtual ICodeParser CreateParser();
    public virtual TypeConverter GetConverter(Type type);
    public virtual CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit[] compilationUnits);
    public virtual CompilerResults CompileAssemblyFromFile(CompilerParameters options, String[] fileNames);
    public virtual CompilerResults CompileAssemblyFromSource(CompilerParameters options, String[] sources);
    public virtual bool IsValidIdentifier(string value);
    public virtual string CreateEscapedIdentifier(string value);
    public virtual string CreateValidIdentifier(string value);
    public virtual string GetTypeOutput(CodeTypeReference type);
    public virtual bool Supports(GeneratorSupport generatorSupport);
    public virtual void GenerateCodeFromExpression(CodeExpression expression, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromStatement(CodeStatement statement, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromNamespace(CodeNamespace codeNamespace, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromCompileUnit(CodeCompileUnit compileUnit, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromType(CodeTypeDeclaration codeType, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
    public virtual CodeCompileUnit Parse(TextReader codeStream);
    private ICodeCompiler CreateCompilerHelper();
    private ICodeGenerator CreateGeneratorHelper();
    private ICodeParser CreateParserHelper();
}
public abstract class System.CodeDom.Compiler.CodeGenerator : object {
    private static int ParameterMultilineThreshold;
    private ExposedTabStringIndentedTextWriter _output;
    private CodeGeneratorOptions _options;
    private CodeTypeDeclaration _currentClass;
    private CodeTypeMember _currentMember;
    private bool _inNestedBinary;
    protected CodeTypeDeclaration CurrentClass { get; }
    protected string CurrentTypeName { get; }
    protected CodeTypeMember CurrentMember { get; }
    protected string CurrentMemberName { get; }
    protected bool IsCurrentInterface { get; }
    protected bool IsCurrentClass { get; }
    protected bool IsCurrentStruct { get; }
    protected bool IsCurrentEnum { get; }
    protected bool IsCurrentDelegate { get; }
    protected int Indent { get; protected set; }
    protected string NullToken { get; }
    protected TextWriter Output { get; }
    protected CodeGeneratorOptions Options { get; }
    protected CodeTypeDeclaration get_CurrentClass();
    protected string get_CurrentTypeName();
    protected CodeTypeMember get_CurrentMember();
    protected string get_CurrentMemberName();
    protected bool get_IsCurrentInterface();
    protected bool get_IsCurrentClass();
    protected bool get_IsCurrentStruct();
    protected bool get_IsCurrentEnum();
    protected bool get_IsCurrentDelegate();
    protected int get_Indent();
    protected void set_Indent(int value);
    protected abstract virtual string get_NullToken();
    protected TextWriter get_Output();
    protected CodeGeneratorOptions get_Options();
    private void GenerateType(CodeTypeDeclaration e);
    protected virtual void GenerateDirectives(CodeDirectiveCollection directives);
    private void GenerateTypeMember(CodeTypeMember member, CodeTypeDeclaration declaredType);
    private void GenerateTypeConstructors(CodeTypeDeclaration e);
    protected void GenerateNamespaces(CodeCompileUnit e);
    protected void GenerateTypes(CodeNamespace e);
    private sealed virtual override bool System.CodeDom.Compiler.ICodeGenerator.Supports(GeneratorSupport support);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o);
    public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
    private sealed virtual override bool System.CodeDom.Compiler.ICodeGenerator.IsValidIdentifier(string value);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.ValidateIdentifier(string value);
    private sealed virtual override string System.CodeDom.Compiler.ICodeGenerator.CreateEscapedIdentifier(string value);
    private sealed virtual override string System.CodeDom.Compiler.ICodeGenerator.CreateValidIdentifier(string value);
    private sealed virtual override string System.CodeDom.Compiler.ICodeGenerator.GetTypeOutput(CodeTypeReference type);
    private void GenerateConstructors(CodeTypeDeclaration e);
    private void GenerateEvents(CodeTypeDeclaration e);
    protected void GenerateExpression(CodeExpression e);
    private void GenerateFields(CodeTypeDeclaration e);
    private void GenerateSnippetMembers(CodeTypeDeclaration e);
    protected virtual void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e);
    private void GenerateMethods(CodeTypeDeclaration e);
    private void GenerateNestedTypes(CodeTypeDeclaration e);
    protected virtual void GenerateCompileUnit(CodeCompileUnit e);
    protected virtual void GenerateNamespace(CodeNamespace e);
    protected void GenerateNamespaceImports(CodeNamespace e);
    private void GenerateProperties(CodeTypeDeclaration e);
    protected void GenerateStatement(CodeStatement e);
    protected void GenerateStatements(CodeStatementCollection stmts);
    protected virtual void OutputAttributeDeclarations(CodeAttributeDeclarationCollection attributes);
    protected virtual void OutputAttributeArgument(CodeAttributeArgument arg);
    protected virtual void OutputDirection(FieldDirection dir);
    protected virtual void OutputFieldScopeModifier(MemberAttributes attributes);
    protected virtual void OutputMemberAccessModifier(MemberAttributes attributes);
    protected virtual void OutputMemberScopeModifier(MemberAttributes attributes);
    protected abstract virtual void OutputType(CodeTypeReference typeRef);
    protected virtual void OutputTypeAttributes(TypeAttributes attributes, bool isStruct, bool isEnum);
    protected virtual void OutputTypeNamePair(CodeTypeReference typeRef, string name);
    protected virtual void OutputIdentifier(string ident);
    protected virtual void OutputExpressionList(CodeExpressionCollection expressions);
    protected virtual void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems);
    protected virtual void OutputOperator(CodeBinaryOperatorType op);
    protected virtual void OutputParameters(CodeParameterDeclarationExpressionCollection parameters);
    protected abstract virtual void GenerateArrayCreateExpression(CodeArrayCreateExpression e);
    protected abstract virtual void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e);
    protected virtual void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e);
    protected virtual void ContinueOnNewLine(string st);
    protected abstract virtual void GenerateCastExpression(CodeCastExpression e);
    protected abstract virtual void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e);
    protected abstract virtual void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e);
    protected abstract virtual void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e);
    protected abstract virtual void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e);
    protected abstract virtual void GenerateIndexerExpression(CodeIndexerExpression e);
    protected abstract virtual void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e);
    protected abstract virtual void GenerateSnippetExpression(CodeSnippetExpression e);
    protected abstract virtual void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e);
    protected abstract virtual void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e);
    protected abstract virtual void GenerateEventReferenceExpression(CodeEventReferenceExpression e);
    protected abstract virtual void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e);
    protected abstract virtual void GenerateObjectCreateExpression(CodeObjectCreateExpression e);
    protected virtual void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e);
    protected virtual void GenerateDirectionExpression(CodeDirectionExpression e);
    protected virtual void GeneratePrimitiveExpression(CodePrimitiveExpression e);
    protected virtual void GenerateSingleFloatValue(float s);
    protected virtual void GenerateDoubleValue(double d);
    protected virtual void GenerateDecimalValue(decimal d);
    protected virtual void GenerateDefaultValueExpression(CodeDefaultValueExpression e);
    protected abstract virtual void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e);
    protected abstract virtual void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e);
    protected abstract virtual void GenerateThisReferenceExpression(CodeThisReferenceExpression e);
    protected virtual void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e);
    protected virtual void GenerateTypeOfExpression(CodeTypeOfExpression e);
    protected abstract virtual void GenerateExpressionStatement(CodeExpressionStatement e);
    protected abstract virtual void GenerateIterationStatement(CodeIterationStatement e);
    protected abstract virtual void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e);
    protected virtual void GenerateCommentStatement(CodeCommentStatement e);
    protected virtual void GenerateCommentStatements(CodeCommentStatementCollection e);
    protected abstract virtual void GenerateComment(CodeComment e);
    protected abstract virtual void GenerateMethodReturnStatement(CodeMethodReturnStatement e);
    protected abstract virtual void GenerateConditionStatement(CodeConditionStatement e);
    protected abstract virtual void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e);
    protected abstract virtual void GenerateAssignStatement(CodeAssignStatement e);
    protected abstract virtual void GenerateAttachEventStatement(CodeAttachEventStatement e);
    protected abstract virtual void GenerateRemoveEventStatement(CodeRemoveEventStatement e);
    protected abstract virtual void GenerateGotoStatement(CodeGotoStatement e);
    protected abstract virtual void GenerateLabeledStatement(CodeLabeledStatement e);
    protected virtual void GenerateSnippetStatement(CodeSnippetStatement e);
    protected abstract virtual void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e);
    protected abstract virtual void GenerateLinePragmaStart(CodeLinePragma e);
    protected abstract virtual void GenerateLinePragmaEnd(CodeLinePragma e);
    protected abstract virtual void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateField(CodeMemberField e);
    protected abstract virtual void GenerateSnippetMember(CodeSnippetTypeMember e);
    protected abstract virtual void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateTypeConstructor(CodeTypeConstructor e);
    protected abstract virtual void GenerateTypeStart(CodeTypeDeclaration e);
    protected abstract virtual void GenerateTypeEnd(CodeTypeDeclaration e);
    protected virtual void GenerateCompileUnitStart(CodeCompileUnit e);
    protected virtual void GenerateCompileUnitEnd(CodeCompileUnit e);
    protected abstract virtual void GenerateNamespaceStart(CodeNamespace e);
    protected abstract virtual void GenerateNamespaceEnd(CodeNamespace e);
    protected abstract virtual void GenerateNamespaceImport(CodeNamespaceImport e);
    protected abstract virtual void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes);
    protected abstract virtual void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes);
    protected abstract virtual bool Supports(GeneratorSupport support);
    protected abstract virtual bool IsValidIdentifier(string value);
    protected virtual void ValidateIdentifier(string value);
    protected abstract virtual string CreateEscapedIdentifier(string value);
    protected abstract virtual string CreateValidIdentifier(string value);
    protected abstract virtual string GetTypeOutput(CodeTypeReference value);
    protected abstract virtual string QuoteSnippetString(string value);
    public static bool IsValidLanguageIndependentIdentifier(string value);
    internal static bool IsValidLanguageIndependentTypeName(string value);
    public static void ValidateIdentifiers(CodeObject e);
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.Compiler.CodeGeneratorOptions : object {
    private IDictionary _options;
    public object Item { get; public set; }
    public string IndentString { get; public set; }
    public string BracingStyle { get; public set; }
    public bool ElseOnClosing { get; public set; }
    public bool BlankLinesBetweenMembers { get; public set; }
    public bool VerbatimOrder { get; public set; }
    public object get_Item(string index);
    public void set_Item(string index, object value);
    public string get_IndentString();
    public void set_IndentString(string value);
    public string get_BracingStyle();
    public void set_BracingStyle(string value);
    public bool get_ElseOnClosing();
    public void set_ElseOnClosing(bool value);
    public bool get_BlankLinesBetweenMembers();
    public void set_BlankLinesBetweenMembers(bool value);
    public bool get_VerbatimOrder();
    public void set_VerbatimOrder(bool value);
}
public abstract class System.CodeDom.Compiler.CodeParser : object {
    public abstract virtual CodeCompileUnit Parse(TextReader codeStream);
}
internal class System.CodeDom.Compiler.CodeValidator : object {
    private static Char[] s_newLineChars;
    private CodeTypeDeclaration _currentClass;
    private bool IsCurrentInterface { get; }
    private bool IsCurrentEnum { get; }
    private bool IsCurrentDelegate { get; }
    private static CodeValidator();
    internal void ValidateIdentifiers(CodeObject e);
    private void ValidateTypeMember(CodeTypeMember e);
    private void ValidateCodeCompileUnit(CodeCompileUnit e);
    private void ValidateSnippetCompileUnit(CodeSnippetCompileUnit e);
    private void ValidateCompileUnitStart(CodeCompileUnit e);
    private void ValidateCompileUnitEnd(CodeCompileUnit e);
    private void ValidateNamespaces(CodeCompileUnit e);
    private void ValidateNamespace(CodeNamespace e);
    private static void ValidateNamespaceStart(CodeNamespace e);
    private void ValidateNamespaceImports(CodeNamespace e);
    private static void ValidateNamespaceImport(CodeNamespaceImport e);
    private void ValidateAttributes(CodeAttributeDeclarationCollection attributes);
    private void ValidateAttributeArgument(CodeAttributeArgument arg);
    private void ValidateTypes(CodeNamespace e);
    private void ValidateTypeDeclaration(CodeTypeDeclaration e);
    private void ValidateTypeMembers(CodeTypeDeclaration e);
    private void ValidateTypeParameters(CodeTypeParameterCollection parameters);
    private void ValidateTypeParameter(CodeTypeParameter e);
    private void ValidateField(CodeMemberField e);
    private void ValidateConstructor(CodeConstructor e);
    private void ValidateProperty(CodeMemberProperty e);
    private void ValidateMemberMethod(CodeMemberMethod e);
    private void ValidateTypeConstructor(CodeTypeConstructor e);
    private void ValidateMethod(CodeMemberMethod e);
    private void ValidateSnippetMember(CodeSnippetTypeMember e);
    private void ValidateTypeStart(CodeTypeDeclaration e);
    private void ValidateCommentStatements(CodeCommentStatementCollection e);
    private void ValidateCommentStatement(CodeCommentStatement e);
    private void ValidateComment(CodeComment e);
    private void ValidateStatement(CodeStatement e);
    private void ValidateStatements(CodeStatementCollection stmts);
    private void ValidateExpressionStatement(CodeExpressionStatement e);
    private void ValidateIterationStatement(CodeIterationStatement e);
    private void ValidateThrowExceptionStatement(CodeThrowExceptionStatement e);
    private void ValidateMethodReturnStatement(CodeMethodReturnStatement e);
    private void ValidateConditionStatement(CodeConditionStatement e);
    private void ValidateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e);
    private void ValidateAssignStatement(CodeAssignStatement e);
    private void ValidateAttachEventStatement(CodeAttachEventStatement e);
    private void ValidateRemoveEventStatement(CodeRemoveEventStatement e);
    private static void ValidateGotoStatement(CodeGotoStatement e);
    private void ValidateLabeledStatement(CodeLabeledStatement e);
    private void ValidateVariableDeclarationStatement(CodeVariableDeclarationStatement e);
    private void ValidateLinePragmaStart(CodeLinePragma e);
    private void ValidateEvent(CodeMemberEvent e);
    private void ValidateParameters(CodeParameterDeclarationExpressionCollection parameters);
    private void ValidateSnippetStatement(CodeSnippetStatement e);
    private void ValidateExpressionList(CodeExpressionCollection expressions);
    private static void ValidateTypeReference(CodeTypeReference e);
    private static void ValidateTypeReferences(CodeTypeReferenceCollection refs);
    private static void ValidateArity(CodeTypeReference e);
    private static void ValidateTypeName(object e, string propertyName, string typeName);
    private static void ValidateIdentifier(object e, string propertyName, string identifier);
    private void ValidateExpression(CodeExpression e);
    private void ValidateArrayCreateExpression(CodeArrayCreateExpression e);
    private void ValidateBaseReferenceExpression(CodeBaseReferenceExpression e);
    private void ValidateBinaryOperatorExpression(CodeBinaryOperatorExpression e);
    private void ValidateCastExpression(CodeCastExpression e);
    private static void ValidateDefaultValueExpression(CodeDefaultValueExpression e);
    private void ValidateDelegateCreateExpression(CodeDelegateCreateExpression e);
    private void ValidateFieldReferenceExpression(CodeFieldReferenceExpression e);
    private static void ValidateArgumentReferenceExpression(CodeArgumentReferenceExpression e);
    private static void ValidateVariableReferenceExpression(CodeVariableReferenceExpression e);
    private void ValidateIndexerExpression(CodeIndexerExpression e);
    private void ValidateArrayIndexerExpression(CodeArrayIndexerExpression e);
    private void ValidateSnippetExpression(CodeSnippetExpression e);
    private void ValidateMethodInvokeExpression(CodeMethodInvokeExpression e);
    private void ValidateMethodReferenceExpression(CodeMethodReferenceExpression e);
    private void ValidateEventReferenceExpression(CodeEventReferenceExpression e);
    private void ValidateDelegateInvokeExpression(CodeDelegateInvokeExpression e);
    private void ValidateObjectCreateExpression(CodeObjectCreateExpression e);
    private void ValidateParameterDeclarationExpression(CodeParameterDeclarationExpression e);
    private void ValidateDirectionExpression(CodeDirectionExpression e);
    private void ValidatePrimitiveExpression(CodePrimitiveExpression e);
    private void ValidatePropertyReferenceExpression(CodePropertyReferenceExpression e);
    private void ValidatePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e);
    private void ValidateThisReferenceExpression(CodeThisReferenceExpression e);
    private static void ValidateTypeOfExpression(CodeTypeOfExpression e);
    private static void ValidateCodeDirectives(CodeDirectiveCollection e);
    private static void ValidateCodeDirective(CodeDirective e);
    private static void ValidateChecksumPragma(CodeChecksumPragma e);
    private static void ValidateRegionDirective(CodeRegionDirective e);
    private bool get_IsCurrentInterface();
    private bool get_IsCurrentEnum();
    private bool get_IsCurrentDelegate();
}
internal class System.CodeDom.Compiler.Compiler : ConfigurationElement {
    private static ConfigurationProperty compilerOptionsProp;
    private static ConfigurationProperty extensionProp;
    private static ConfigurationProperty languageProp;
    private static ConfigurationProperty typeProp;
    private static ConfigurationProperty warningLevelProp;
    private static ConfigurationProperty providerOptionsProp;
    private static ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("compilerOptions")]
public string CompilerOptions { get; internal set; }
    [ConfigurationPropertyAttribute("extension")]
public string Extension { get; internal set; }
    [ConfigurationPropertyAttribute("language")]
public string Language { get; internal set; }
    [ConfigurationPropertyAttribute("type")]
public string Type { get; internal set; }
    [IntegerValidatorAttribute]
[ConfigurationPropertyAttribute("warningLevel")]
public int WarningLevel { get; internal set; }
    [ConfigurationPropertyAttribute("")]
public CompilerProviderOptionsCollection ProviderOptions { get; internal set; }
    public Dictionary`2<string, string> ProviderOptionsDictionary { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static Compiler();
    public Compiler(string compilerOptions, string extension, string language, string type, int warningLevel);
    public string get_CompilerOptions();
    internal void set_CompilerOptions(string value);
    public string get_Extension();
    internal void set_Extension(string value);
    public string get_Language();
    internal void set_Language(string value);
    public string get_Type();
    internal void set_Type(string value);
    public int get_WarningLevel();
    internal void set_WarningLevel(int value);
    public CompilerProviderOptionsCollection get_ProviderOptions();
    internal void set_ProviderOptions(CompilerProviderOptionsCollection value);
    public Dictionary`2<string, string> get_ProviderOptionsDictionary();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.CodeDom.Compiler.Compiler")]
[DefaultMemberAttribute("Item")]
internal class System.CodeDom.Compiler.CompilerCollection : ConfigurationElementCollection {
    private static string defaultCompilerVersion;
    private static ConfigurationPropertyCollection properties;
    private static List`1<CompilerInfo> compiler_infos;
    private static Dictionary`2<string, CompilerInfo> compiler_languages;
    private static Dictionary`2<string, CompilerInfo> compiler_extensions;
    protected bool ThrowOnDuplicate { get; }
    public String[] AllKeys { get; }
    public ConfigurationElementCollectionType CollectionType { get; }
    protected string ElementName { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public Compiler Item { get; }
    public CompilerInfo Item { get; }
    public CompilerInfo[] CompilerInfos { get; }
    private static CompilerCollection();
    private static void AddCompilerInfo(CompilerInfo ci);
    private static void AddCompilerInfo(Compiler compiler);
    protected virtual void BaseAdd(ConfigurationElement element);
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual ConfigurationElement CreateNewElement();
    public CompilerInfo GetCompilerInfoForLanguage(string language);
    public CompilerInfo GetCompilerInfoForExtension(string extension);
    public string GetLanguageFromExtension(string extension);
    public Compiler Get(int index);
    public Compiler Get(string language);
    protected virtual object GetElementKey(ConfigurationElement element);
    public string GetKey(int index);
    public String[] get_AllKeys();
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual string get_ElementName();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public Compiler get_Item(int index);
    public CompilerInfo get_Item(string language);
    public CompilerInfo[] get_CompilerInfos();
}
public class System.CodeDom.Compiler.CompilerError : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWarning>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public int Line { get; public set; }
    public int Column { get; public set; }
    public string ErrorNumber { get; public set; }
    public string ErrorText { get; public set; }
    public bool IsWarning { get; public set; }
    public string FileName { get; public set; }
    private string WarningString { get; }
    public CompilerError(string fileName, int line, int column, string errorNumber, string errorText);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    [CompilerGeneratedAttribute]
public string get_ErrorNumber();
    [CompilerGeneratedAttribute]
public void set_ErrorNumber(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorText();
    [CompilerGeneratedAttribute]
public void set_ErrorText(string value);
    [CompilerGeneratedAttribute]
public bool get_IsWarning();
    [CompilerGeneratedAttribute]
public void set_IsWarning(bool value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    public virtual string ToString();
    private string get_WarningString();
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.Compiler.CompilerErrorCollection : CollectionBase {
    public CompilerError Item { get; public set; }
    public bool HasErrors { get; }
    public bool HasWarnings { get; }
    public CompilerErrorCollection(CompilerErrorCollection value);
    public CompilerErrorCollection(CompilerError[] value);
    public CompilerError get_Item(int index);
    public void set_Item(int index, CompilerError value);
    public int Add(CompilerError value);
    public void AddRange(CompilerError[] value);
    public void AddRange(CompilerErrorCollection value);
    public bool Contains(CompilerError value);
    public void CopyTo(CompilerError[] array, int index);
    public bool get_HasErrors();
    public bool get_HasWarnings();
    public int IndexOf(CompilerError value);
    public void Insert(int index, CompilerError value);
    public void Remove(CompilerError value);
}
public class System.CodeDom.Compiler.CompilerInfo : object {
    internal IDictionary`2<string, string> _providerOptions;
    internal string _codeDomProviderTypeName;
    internal CompilerParameters _compilerParams;
    internal String[] _compilerLanguages;
    internal String[] _compilerExtensions;
    private Type _type;
    public Type CodeDomProviderType { get; }
    public bool IsCodeDomProviderTypeValid { get; }
    internal CompilerParameters CompilerParams { get; }
    internal IDictionary`2<string, string> ProviderOptions { get; }
    internal CompilerInfo(CompilerParameters compilerParams, string codeDomProviderTypeName, String[] compilerLanguages, String[] compilerExtensions);
    internal CompilerInfo(CompilerParameters compilerParams, string codeDomProviderTypeName);
    public String[] GetLanguages();
    public String[] GetExtensions();
    public Type get_CodeDomProviderType();
    public bool get_IsCodeDomProviderTypeValid();
    public CodeDomProvider CreateProvider();
    public CodeDomProvider CreateProvider(IDictionary`2<string, string> providerOptions);
    public CompilerParameters CreateDefaultCompilerParameters();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    private CompilerParameters CloneCompilerParameters();
    private String[] CloneCompilerLanguages();
    private String[] CloneCompilerExtensions();
    internal CompilerParameters get_CompilerParams();
    internal IDictionary`2<string, string> get_ProviderOptions();
}
public class System.CodeDom.Compiler.CompilerParameters : object {
    private Evidence _evidence;
    private StringCollection _assemblyNames;
    private StringCollection _embeddedResources;
    private StringCollection _linkedResources;
    private TempFileCollection _tempFiles;
    [CompilerGeneratedAttribute]
private string <CoreAssemblyFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateExecutable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateInMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MainClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDebugInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatWarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompilerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Win32Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <UserToken>k__BackingField;
    [ObsoleteAttribute("CAS policy is obsolete and will be removed in a future release of the .NET Framework. Please see http://go2.microsoft.com/fwlink/?LinkId=131738 for more information.")]
public Evidence Evidence { get; public set; }
    public string CoreAssemblyFileName { get; public set; }
    public bool GenerateExecutable { get; public set; }
    public bool GenerateInMemory { get; public set; }
    public StringCollection ReferencedAssemblies { get; }
    public string MainClass { get; public set; }
    public string OutputAssembly { get; public set; }
    public TempFileCollection TempFiles { get; public set; }
    public bool IncludeDebugInformation { get; public set; }
    public bool TreatWarningsAsErrors { get; public set; }
    public int WarningLevel { get; public set; }
    public string CompilerOptions { get; public set; }
    public string Win32Resource { get; public set; }
    public StringCollection EmbeddedResources { get; }
    public StringCollection LinkedResources { get; }
    public IntPtr UserToken { get; public set; }
    public CompilerParameters(String[] assemblyNames);
    public CompilerParameters(String[] assemblyNames, string outputName);
    public CompilerParameters(String[] assemblyNames, string outputName, bool includeDebugInformation);
    public Evidence get_Evidence();
    public void set_Evidence(Evidence value);
    [CompilerGeneratedAttribute]
public string get_CoreAssemblyFileName();
    [CompilerGeneratedAttribute]
public void set_CoreAssemblyFileName(string value);
    [CompilerGeneratedAttribute]
public bool get_GenerateExecutable();
    [CompilerGeneratedAttribute]
public void set_GenerateExecutable(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateInMemory();
    [CompilerGeneratedAttribute]
public void set_GenerateInMemory(bool value);
    public StringCollection get_ReferencedAssemblies();
    [CompilerGeneratedAttribute]
public string get_MainClass();
    [CompilerGeneratedAttribute]
public void set_MainClass(string value);
    [CompilerGeneratedAttribute]
public string get_OutputAssembly();
    [CompilerGeneratedAttribute]
public void set_OutputAssembly(string value);
    public TempFileCollection get_TempFiles();
    public void set_TempFiles(TempFileCollection value);
    [CompilerGeneratedAttribute]
public bool get_IncludeDebugInformation();
    [CompilerGeneratedAttribute]
public void set_IncludeDebugInformation(bool value);
    [CompilerGeneratedAttribute]
public bool get_TreatWarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_TreatWarningsAsErrors(bool value);
    [CompilerGeneratedAttribute]
public int get_WarningLevel();
    [CompilerGeneratedAttribute]
public void set_WarningLevel(int value);
    [CompilerGeneratedAttribute]
public string get_CompilerOptions();
    [CompilerGeneratedAttribute]
public void set_CompilerOptions(string value);
    [CompilerGeneratedAttribute]
public string get_Win32Resource();
    [CompilerGeneratedAttribute]
public void set_Win32Resource(string value);
    public StringCollection get_EmbeddedResources();
    public StringCollection get_LinkedResources();
    [CompilerGeneratedAttribute]
public IntPtr get_UserToken();
    [CompilerGeneratedAttribute]
public void set_UserToken(IntPtr value);
}
internal class System.CodeDom.Compiler.CompilerProviderOption : ConfigurationElement {
    private static ConfigurationProperty nameProp;
    private static ConfigurationProperty valueProp;
    private static ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("value")]
public string Value { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static CompilerProviderOption();
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.CodeDom.Compiler.CompilerProviderOption")]
[DefaultMemberAttribute("Item")]
internal class System.CodeDom.Compiler.CompilerProviderOptionsCollection : ConfigurationElementCollection {
    private static ConfigurationPropertyCollection properties;
    public String[] AllKeys { get; }
    protected string ElementName { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public Dictionary`2<string, string> ProviderOptions { get; }
    public CompilerProviderOption Item { get; }
    public CompilerProviderOption Item { get; }
    private static CompilerProviderOptionsCollection();
    protected virtual ConfigurationElement CreateNewElement();
    public CompilerProviderOption Get(int index);
    public CompilerProviderOption Get(string name);
    protected virtual object GetElementKey(ConfigurationElement element);
    public string GetKey(int index);
    public String[] get_AllKeys();
    protected virtual string get_ElementName();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public Dictionary`2<string, string> get_ProviderOptions();
    public CompilerProviderOption get_Item(int index);
    public CompilerProviderOption get_Item(string name);
}
public class System.CodeDom.Compiler.CompilerResults : object {
    private Evidence _evidence;
    private CompilerErrorCollection _errors;
    private StringCollection _output;
    private Assembly _compiledAssembly;
    private TempFileCollection _tempFiles;
    [CompilerGeneratedAttribute]
private string <PathToAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NativeCompilerReturnValue>k__BackingField;
    [ObsoleteAttribute("CAS policy is obsolete and will be removed in a future release of the .NET Framework. Please see http://go2.microsoft.com/fwlink/?LinkId=131738 for more information.")]
public Evidence Evidence { get; public set; }
    public TempFileCollection TempFiles { get; public set; }
    public Assembly CompiledAssembly { get; public set; }
    public CompilerErrorCollection Errors { get; }
    public StringCollection Output { get; }
    public string PathToAssembly { get; public set; }
    public int NativeCompilerReturnValue { get; public set; }
    public CompilerResults(TempFileCollection tempFiles);
    public Evidence get_Evidence();
    public void set_Evidence(Evidence value);
    public TempFileCollection get_TempFiles();
    public void set_TempFiles(TempFileCollection value);
    public Assembly get_CompiledAssembly();
    public void set_CompiledAssembly(Assembly value);
    public CompilerErrorCollection get_Errors();
    public StringCollection get_Output();
    [CompilerGeneratedAttribute]
public string get_PathToAssembly();
    [CompilerGeneratedAttribute]
public void set_PathToAssembly(string value);
    [CompilerGeneratedAttribute]
public int get_NativeCompilerReturnValue();
    [CompilerGeneratedAttribute]
public void set_NativeCompilerReturnValue(int value);
}
public static class System.CodeDom.Compiler.Executor : object {
    public static void ExecWait(string cmd, TempFileCollection tempFiles);
    public static int ExecWaitWithCapture(IntPtr userToken, string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName);
    public static int ExecWaitWithCapture(IntPtr userToken, string cmd, TempFileCollection tempFiles, String& outputName, String& errorName);
    public static int ExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName);
    public static int ExecWaitWithCapture(string cmd, TempFileCollection tempFiles, String& outputName, String& errorName);
    private static int InternalExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName);
}
internal class System.CodeDom.Compiler.ExposedTabStringIndentedTextWriter : IndentedTextWriter {
    [CompilerGeneratedAttribute]
private string <TabString>k__BackingField;
    internal string TabString { get; }
    public ExposedTabStringIndentedTextWriter(TextWriter writer, string tabString);
    internal void InternalOutputTabs();
    [CompilerGeneratedAttribute]
internal string get_TabString();
}
[AttributeUsageAttribute("32767")]
public class System.CodeDom.Compiler.GeneratedCodeAttribute : Attribute {
    private string tool;
    private string version;
    public string Tool { get; }
    public string Version { get; }
    public GeneratedCodeAttribute(string tool, string version);
    public string get_Tool();
    public string get_Version();
}
[FlagsAttribute]
public enum System.CodeDom.Compiler.GeneratorSupport : Enum {
    public int value__;
    public static GeneratorSupport ArraysOfArrays;
    public static GeneratorSupport EntryPointMethod;
    public static GeneratorSupport GotoStatements;
    public static GeneratorSupport MultidimensionalArrays;
    public static GeneratorSupport StaticConstructors;
    public static GeneratorSupport TryCatchStatements;
    public static GeneratorSupport ReturnTypeAttributes;
    public static GeneratorSupport DeclareValueTypes;
    public static GeneratorSupport DeclareEnums;
    public static GeneratorSupport DeclareDelegates;
    public static GeneratorSupport DeclareInterfaces;
    public static GeneratorSupport DeclareEvents;
    public static GeneratorSupport AssemblyAttributes;
    public static GeneratorSupport ParameterAttributes;
    public static GeneratorSupport ReferenceParameters;
    public static GeneratorSupport ChainedConstructorArguments;
    public static GeneratorSupport NestedTypes;
    public static GeneratorSupport MultipleInterfaceMembers;
    public static GeneratorSupport PublicStaticMembers;
    public static GeneratorSupport ComplexExpressions;
    public static GeneratorSupport Win32Resources;
    public static GeneratorSupport Resources;
    public static GeneratorSupport PartialTypes;
    public static GeneratorSupport GenericTypeReference;
    public static GeneratorSupport GenericTypeDeclaration;
    public static GeneratorSupport DeclareIndexerProperties;
}
public interface System.CodeDom.Compiler.ICodeCompiler {
    public abstract virtual CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit compilationUnit);
    public abstract virtual CompilerResults CompileAssemblyFromFile(CompilerParameters options, string fileName);
    public abstract virtual CompilerResults CompileAssemblyFromSource(CompilerParameters options, string source);
    public abstract virtual CompilerResults CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] compilationUnits);
    public abstract virtual CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames);
    public abstract virtual CompilerResults CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources);
}
public interface System.CodeDom.Compiler.ICodeGenerator {
    public abstract virtual bool IsValidIdentifier(string value);
    public abstract virtual void ValidateIdentifier(string value);
    public abstract virtual string CreateEscapedIdentifier(string value);
    public abstract virtual string CreateValidIdentifier(string value);
    public abstract virtual string GetTypeOutput(CodeTypeReference type);
    public abstract virtual bool Supports(GeneratorSupport supports);
    public abstract virtual void GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o);
    public abstract virtual void GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o);
    public abstract virtual void GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o);
    public abstract virtual void GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o);
    public abstract virtual void GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o);
}
public interface System.CodeDom.Compiler.ICodeParser {
    public abstract virtual CodeCompileUnit Parse(TextReader codeStream);
}
internal class System.CodeDom.Compiler.Indentation : object {
    private ExposedTabStringIndentedTextWriter _writer;
    private int _indent;
    private string _s;
    internal string IndentationString { get; }
    internal Indentation(ExposedTabStringIndentedTextWriter writer, int indent);
    internal string get_IndentationString();
}
public class System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
    private TextWriter _writer;
    private string _tabString;
    private int _indentLevel;
    private bool _tabsPending;
    public static string DefaultTabString;
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    public int Indent { get; public set; }
    public TextWriter InnerWriter { get; }
    public IndentedTextWriter(TextWriter writer);
    public IndentedTextWriter(TextWriter writer, string tabString);
    public virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public int get_Indent();
    public void set_Indent(int value);
    public TextWriter get_InnerWriter();
    public virtual void Close();
    public virtual void Flush();
    protected virtual void OutputTabs();
    public virtual void Write(string s);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(float value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    public void WriteLineNoTabs(string s);
    public virtual void WriteLine(string s);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
}
[FlagsAttribute]
public enum System.CodeDom.Compiler.LanguageOptions : Enum {
    public int value__;
    public static LanguageOptions None;
    public static LanguageOptions CaseInsensitive;
}
public class System.CodeDom.Compiler.TempFileCollection : object {
    private string _basePath;
    private string _tempDir;
    private Hashtable _files;
    [CompilerGeneratedAttribute]
private bool <KeepFiles>k__BackingField;
    public int Count { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public string TempDir { get; }
    public string BasePath { get; }
    public bool KeepFiles { get; public set; }
    public TempFileCollection(string tempDir);
    public TempFileCollection(string tempDir, bool keepFiles);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public string AddExtension(string fileExtension);
    public string AddExtension(string fileExtension, bool keepFile);
    public void AddFile(string fileName, bool keepFile);
    public IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int start);
    public void CopyTo(String[] fileNames, int start);
    public int get_Count();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public string get_TempDir();
    public string get_BasePath();
    private void EnsureTempNameCreated();
    [CompilerGeneratedAttribute]
public bool get_KeepFiles();
    [CompilerGeneratedAttribute]
public void set_KeepFiles(bool value);
    private bool KeepFile(string fileName);
    public void Delete();
    internal void Delete(string fileName);
    internal void SafeDelete();
}
public enum System.CodeDom.FieldDirection : Enum {
    public int value__;
    public static FieldDirection In;
    public static FieldDirection Out;
    public static FieldDirection Ref;
}
public enum System.CodeDom.MemberAttributes : Enum {
    public int value__;
    public static MemberAttributes Abstract;
    public static MemberAttributes Final;
    public static MemberAttributes Static;
    public static MemberAttributes Override;
    public static MemberAttributes Const;
    public static MemberAttributes New;
    public static MemberAttributes Overloaded;
    public static MemberAttributes Assembly;
    public static MemberAttributes FamilyAndAssembly;
    public static MemberAttributes Family;
    public static MemberAttributes FamilyOrAssembly;
    public static MemberAttributes Private;
    public static MemberAttributes Public;
    public static MemberAttributes AccessMask;
    public static MemberAttributes ScopeMask;
    public static MemberAttributes VTableMask;
}
[DebuggerDisplayAttribute("Count = {Count}, Type = {_collection}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.BlockingCollectionDebugView`1")]
public class System.Collections.Concurrent.BlockingCollection`1 : object {
    private IProducerConsumerCollection`1<T> _collection;
    private int _boundedCapacity;
    private static int NON_BOUNDED;
    private SemaphoreSlim _freeNodes;
    private SemaphoreSlim _occupiedNodes;
    private bool _isDisposed;
    private CancellationTokenSource _consumersCancellationTokenSource;
    private CancellationTokenSource _producersCancellationTokenSource;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _currentAdders;
    private static int COMPLETE_ADDING_ON_MASK;
    public int BoundedCapacity { get; }
    public bool IsAddingCompleted { get; }
    public bool IsCompleted { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private static bool IsSTAThread { get; }
    public BlockingCollection`1(int boundedCapacity);
    public BlockingCollection`1(IProducerConsumerCollection`1<T> collection, int boundedCapacity);
    public BlockingCollection`1(IProducerConsumerCollection`1<T> collection);
    public int get_BoundedCapacity();
    public bool get_IsAddingCompleted();
    public bool get_IsCompleted();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private void Initialize(IProducerConsumerCollection`1<T> collection, int boundedCapacity, int collectionCount);
    public void Add(T item);
    public void Add(T item, CancellationToken cancellationToken);
    public bool TryAdd(T item);
    public bool TryAdd(T item, TimeSpan timeout);
    public bool TryAdd(T item, int millisecondsTimeout);
    public bool TryAdd(T item, int millisecondsTimeout, CancellationToken cancellationToken);
    private bool TryAddWithNoTimeValidation(T item, int millisecondsTimeout, CancellationToken cancellationToken);
    public T Take();
    public T Take(CancellationToken cancellationToken);
    public bool TryTake(T& item);
    public bool TryTake(T& item, TimeSpan timeout);
    public bool TryTake(T& item, int millisecondsTimeout);
    public bool TryTake(T& item, int millisecondsTimeout, CancellationToken cancellationToken);
    private bool TryTakeWithNoTimeValidation(T& item, int millisecondsTimeout, CancellationToken cancellationToken, CancellationTokenSource combinedTokenSource);
    public static int AddToAny(BlockingCollection`1[] collections, T item);
    public static int AddToAny(BlockingCollection`1[] collections, T item, CancellationToken cancellationToken);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, TimeSpan timeout);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout, CancellationToken cancellationToken);
    private static int TryAddToAnyCore(BlockingCollection`1[] collections, T item, int millisecondsTimeout, CancellationToken externalCancellationToken);
    private static int TryAddToAnyFast(BlockingCollection`1[] collections, T item);
    private static List`1<WaitHandle> GetHandles(BlockingCollection`1[] collections, CancellationToken externalCancellationToken, bool isAddOperation, CancellationToken[]& cancellationTokens);
    private static int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout);
    public static int TakeFromAny(BlockingCollection`1[] collections, T& item);
    public static int TakeFromAny(BlockingCollection`1[] collections, T& item, CancellationToken cancellationToken);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, TimeSpan timeout);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, CancellationToken cancellationToken);
    private static int TryTakeFromAnyCore(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, bool isTakeOperation, CancellationToken externalCancellationToken);
    private static int TryTakeFromAnyCoreSlow(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, bool isTakeOperation, CancellationToken externalCancellationToken);
    public void CompleteAdding();
    private void CancelWaitingConsumers();
    private void CancelWaitingProducers();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public IEnumerable`1<T> GetConsumingEnumerable();
    [IteratorStateMachineAttribute("System.Collections.Concurrent.BlockingCollection`1/<GetConsumingEnumerable>d__68")]
public IEnumerable`1<T> GetConsumingEnumerable(CancellationToken cancellationToken);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static void ValidateCollectionsArray(BlockingCollection`1[] collections, bool isAddOperation);
    private static bool get_IsSTAThread();
    private static void ValidateTimeout(TimeSpan timeout);
    private static void ValidateMillisecondsTimeout(int millisecondsTimeout);
    private void CheckDisposed();
}
internal class System.Collections.Concurrent.BlockingCollectionDebugView`1 : object {
    private BlockingCollection`1<T> _blockingCollection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public BlockingCollectionDebugView`1(BlockingCollection`1<T> collection);
    public T[] get_Items();
}
[EventSourceAttribute]
internal class System.Collections.Concurrent.CDSCollectionETWBCLProvider : EventSource {
    public static CDSCollectionETWBCLProvider Log;
    private static EventKeywords ALL_KEYWORDS;
    private static int CONCURRENTSTACK_FASTPUSHFAILED_ID;
    private static int CONCURRENTSTACK_FASTPOPFAILED_ID;
    private static int CONCURRENTDICTIONARY_ACQUIRINGALLLOCKS_ID;
    private static int CONCURRENTBAG_TRYTAKESTEALS_ID;
    private static int CONCURRENTBAG_TRYPEEKSTEALS_ID;
    private static CDSCollectionETWBCLProvider();
    [EventAttribute("1")]
public void ConcurrentStack_FastPushFailed(int spinCount);
    [EventAttribute("2")]
public void ConcurrentStack_FastPopFailed(int spinCount);
    [EventAttribute("3")]
public void ConcurrentDictionary_AcquiringAllLocks(int numOfBuckets);
    [EventAttribute("4")]
public void ConcurrentBag_TryTakeSteals();
    [EventAttribute("5")]
public void ConcurrentBag_TryPeekSteals();
}
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Concurrent.ConcurrentBag`1 : object {
    private ThreadLocal`1<WorkStealingQueue<T>> _locals;
    private WorkStealingQueue modreq(System.Runtime.CompilerServices.IsVolatile) _workStealingQueues;
    private long _emptyToNonEmptyListTransitionCount;
    public int Count { get; }
    private int DangerousCount { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object GlobalQueuesLock { get; }
    public ConcurrentBag`1(IEnumerable`1<T> collection);
    public void Add(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    public sealed virtual bool TryTake(T& result);
    public bool TryPeek(T& result);
    private WorkStealingQueue<T> GetCurrentThreadWorkStealingQueue(bool forceCreate);
    private WorkStealingQueue<T> CreateWorkStealingQueueForCurrentThread();
    private WorkStealingQueue<T> GetUnownedWorkStealingQueue();
    private bool TrySteal(T& result, bool take);
    private bool TryStealFromTo(WorkStealingQueue<T> startInclusive, WorkStealingQueue<T> endExclusive, T& result, bool take);
    public sealed virtual void CopyTo(T[] array, int index);
    private int CopyFromEachQueueToArray(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual T[] ToArray();
    public void Clear();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private int get_DangerousCount();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private object get_GlobalQueuesLock();
    private void FreezeBag(Boolean& lockTaken);
    private void UnfreezeBag(bool lockTaken);
}
internal class System.Collections.Generic.BidirectionalDictionary`2 : object {
    private Dictionary`2<T1, T2> _forward;
    private Dictionary`2<T2, T1> _backward;
    public int Count { get; }
    public BidirectionalDictionary`2(int capacity);
    public int get_Count();
    public void Add(T1 item1, T2 item2);
    public bool TryGetForward(T1 item1, T2& item2);
    public bool TryGetBackward(T2 item2, T1& item1);
    public Enumerator<T1, T2> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<T1, T2>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T1,T2>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Collections.Generic.BitHelper : object {
    private static byte MarkedBitFlag;
    private static byte IntSize;
    private int _length;
    private Int32* _arrayPtr;
    private Int32[] _array;
    private bool _useStackAlloc;
    internal BitHelper(Int32* bitArrayPtr, int length);
    internal BitHelper(Int32[] bitArray, int length);
    internal void MarkBit(int bitPosition);
    internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
internal class System.Collections.Generic.CollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public CollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.DictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public DictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal class System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal class System.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
public interface System.Collections.Generic.ISet`1 {
    public abstract virtual bool Add(T item);
    public abstract virtual void UnionWith(IEnumerable`1<T> other);
    public abstract virtual void IntersectWith(IEnumerable`1<T> other);
    public abstract virtual void ExceptWith(IEnumerable`1<T> other);
    public abstract virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.LinkedList`1 : object {
    internal LinkedListNode`1<T> head;
    internal int count;
    internal int version;
    private object _syncRoot;
    private SerializationInfo _siInfo;
    private static string VersionName;
    private static string CountName;
    private static string ValuesName;
    public int Count { get; }
    public LinkedListNode`1<T> First { get; }
    public LinkedListNode`1<T> Last { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public LinkedList`1(IEnumerable`1<T> collection);
    protected LinkedList`1(SerializationInfo info, StreamingContext context);
    public sealed virtual int get_Count();
    public LinkedListNode`1<T> get_First();
    public LinkedListNode`1<T> get_Last();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    public LinkedListNode`1<T> AddAfter(LinkedListNode`1<T> node, T value);
    public void AddAfter(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    public LinkedListNode`1<T> AddBefore(LinkedListNode`1<T> node, T value);
    public void AddBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    public LinkedListNode`1<T> AddFirst(T value);
    public void AddFirst(LinkedListNode`1<T> node);
    public LinkedListNode`1<T> AddLast(T value);
    public void AddLast(LinkedListNode`1<T> node);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public LinkedListNode`1<T> Find(T value);
    public LinkedListNode`1<T> FindLast(T value);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public sealed virtual bool Remove(T value);
    public void Remove(LinkedListNode`1<T> node);
    public void RemoveFirst();
    public void RemoveLast();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    private void InternalInsertNodeBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    private void InternalInsertNodeToEmptyList(LinkedListNode`1<T> newNode);
    internal void InternalRemoveNode(LinkedListNode`1<T> node);
    internal void ValidateNewNode(LinkedListNode`1<T> node);
    internal void ValidateNode(LinkedListNode`1<T> node);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Collections.Generic.LinkedListNode`1 : object {
    internal LinkedList`1<T> list;
    internal LinkedListNode`1<T> next;
    internal LinkedListNode`1<T> prev;
    internal T item;
    public LinkedList`1<T> List { get; }
    public LinkedListNode`1<T> Next { get; }
    public LinkedListNode`1<T> Previous { get; }
    public T Value { get; public set; }
    public LinkedListNode`1(T value);
    internal LinkedListNode`1(LinkedList`1<T> list, T value);
    public LinkedList`1<T> get_List();
    public LinkedListNode`1<T> get_Next();
    public LinkedListNode`1<T> get_Previous();
    public T get_Value();
    public void set_Value(T value);
    internal void Invalidate();
}
internal enum System.Collections.Generic.NodeColor : Enum {
    public byte value__;
    public static NodeColor Black;
    public static NodeColor Red;
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DefaultMemberAttribute("Item")]
public class System.Collections.Generic.SortedDictionary`2 : object {
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    private TreeSet`1<KeyValuePair`2<TKey, TValue>> _set;
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public IComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    public SortedDictionary`2(IComparer`1<TKey> comparer);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public IComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
public class System.Collections.Generic.SortedList`2 : object {
    private TKey[] keys;
    private TValue[] values;
    private int _size;
    private int version;
    private IComparer`1<TKey> comparer;
    private KeyList<TKey, TValue> keyList;
    private ValueList<TKey, TValue> valueList;
    private object _syncRoot;
    private static int DefaultCapacity;
    private static int MaxArrayLength;
    public int Capacity { get; public set; }
    public IComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public IList`1<TKey> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public IList`1<TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TValue Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public SortedList`2(int capacity);
    public SortedList`2(IComparer`1<TKey> comparer);
    public SortedList`2(int capacity, IComparer`1<TKey> comparer);
    public SortedList`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedList`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public int get_Capacity();
    public void set_Capacity(int value);
    public IComparer`1<TKey> get_Comparer();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual int get_Count();
    public IList`1<TKey> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public IList`1<TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private KeyList<TKey, TValue> GetKeyListHelper();
    private ValueList<TKey, TValue> GetValueListHelper();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private void EnsureCapacity(int min);
    private TValue GetByIndex(int index);
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private TKey GetKey(int index);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public int IndexOfKey(TKey key);
    public int IndexOfValue(TValue value);
    private void Insert(int index, TKey key, TValue value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public void RemoveAt(int index);
    public sealed virtual bool Remove(TKey key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public void TrimExcess();
    private static bool IsCompatibleKey(object key);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
public class System.Collections.Generic.SortedSet`1 : object {
    private Node<T> root;
    private IComparer`1<T> comparer;
    private int count;
    private int version;
    private object _syncRoot;
    private SerializationInfo siInfo;
    private static string ComparerName;
    private static string CountName;
    private static string ItemsName;
    private static string VersionName;
    private static string TreeName;
    private static string NodeValueName;
    private static string EnumStartName;
    private static string ReverseName;
    private static string EnumVersionName;
    private static string MinName;
    private static string MaxName;
    private static string LowerBoundActiveName;
    private static string UpperBoundActiveName;
    internal static int StackAllocThreshold;
    public int Count { get; }
    public IComparer`1<T> Comparer { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Min { get; }
    internal T MinInternal { get; }
    public T Max { get; }
    internal T MaxInternal { get; }
    public SortedSet`1(IComparer`1<T> comparer);
    public SortedSet`1(IEnumerable`1<T> collection);
    public SortedSet`1(IEnumerable`1<T> collection, IComparer`1<T> comparer);
    protected SortedSet`1(SerializationInfo info, StreamingContext context);
    private void AddAllElements(IEnumerable`1<T> collection);
    private void RemoveAllElements(IEnumerable`1<T> collection);
    private bool ContainsAllElements(IEnumerable`1<T> collection);
    internal virtual bool InOrderTreeWalk(TreeWalkPredicate`1<T> action);
    internal virtual bool BreadthFirstTreeWalk(TreeWalkPredicate`1<T> action);
    public sealed virtual int get_Count();
    public IComparer`1<T> get_Comparer();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal virtual void VersionCheck();
    internal virtual bool IsWithinRange(T item);
    public sealed virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    internal virtual bool AddIfNotPresent(T item);
    public sealed virtual bool Remove(T item);
    internal virtual bool DoRemove(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int index);
    public void CopyTo(T[] array, int index, int count);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void InsertionBalance(Node<T> current, Node& parent, Node<T> grandParent, Node<T> greatGrandParent);
    private void ReplaceChildOrRoot(Node<T> parent, Node<T> child, Node<T> newChild);
    private void ReplaceNode(Node<T> match, Node<T> parentOfMatch, Node<T> successor, Node<T> parentOfSuccessor);
    internal virtual Node<T> FindNode(T item);
    internal virtual int InternalIndexOf(T item);
    internal Node<T> FindRange(T from, T to);
    internal Node<T> FindRange(T from, T to, bool lowerBoundActive, bool upperBoundActive);
    internal void UpdateVersion();
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer();
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer(IEqualityComparer`1<T> memberEqualityComparer);
    internal static bool SortedSetEquals(SortedSet`1<T> set1, SortedSet`1<T> set2, IComparer`1<T> comparer);
    private bool HasEqualComparer(SortedSet`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    private static Node<T> ConstructRootFromSortedArray(T[] arr, int startIndex, int endIndex, Node<T> redNode);
    public virtual void IntersectWith(IEnumerable`1<T> other);
    internal virtual void IntersectWithEnumerable(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    private void SymmetricExceptWithSameComparer(SortedSet`1<T> other);
    private void SymmetricExceptWithSameComparer(T[] other, int count);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    private bool IsSubsetOfSortedSetWithSameComparer(SortedSet`1<T> asSorted);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    public int RemoveWhere(Predicate`1<T> match);
    public T get_Min();
    internal virtual T get_MinInternal();
    public T get_Max();
    internal virtual T get_MaxInternal();
    [IteratorStateMachineAttribute("System.Collections.Generic.SortedSet`1/<Reverse>d__94")]
public IEnumerable`1<T> Reverse();
    public virtual SortedSet`1<T> GetViewBetween(T lowerValue, T upperValue);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    protected virtual void OnDeserialization(object sender);
    public bool TryGetValue(T equalValue, T& actualValue);
    private static int Log2(int value);
}
internal class System.Collections.Generic.SortedSetEqualityComparer`1 : object {
    private IComparer`1<T> _comparer;
    private IEqualityComparer`1<T> _memberEqualityComparer;
    public SortedSetEqualityComparer`1(IEqualityComparer`1<T> memberEqualityComparer);
    private SortedSetEqualityComparer`1(IComparer`1<T> comparer, IEqualityComparer`1<T> memberEqualityComparer);
    public sealed virtual bool Equals(SortedSet`1<T> x, SortedSet`1<T> y);
    public sealed virtual int GetHashCode(SortedSet`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum System.Collections.Generic.TreeRotation : Enum {
    public byte value__;
    public static TreeRotation Left;
    public static TreeRotation LeftRight;
    public static TreeRotation Right;
    public static TreeRotation RightLeft;
}
internal class System.Collections.Generic.TreeSet`1 : SortedSet`1<T> {
    public TreeSet`1(IComparer`1<T> comparer);
    public TreeSet`1(SerializationInfo siInfo, StreamingContext context);
    internal virtual bool AddIfNotPresent(T item);
}
internal class System.Collections.Generic.TreeWalkPredicate`1 : MulticastDelegate {
    public TreeWalkPredicate`1(object object, IntPtr method);
    public virtual bool Invoke(Node<T> node);
    public virtual IAsyncResult BeginInvoke(Node<T> node, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ValueListBuilder`1 : ValueType {
    private Span`1<T> _span;
    private T[] _arrayFromPool;
    private int _pos;
    public int Length { get; }
    public T& Item { get; }
    public ValueListBuilder`1(Span`1<T> initialSpan);
    public int get_Length();
    public T& get_Item(int index);
    public void Append(T item);
    public ReadOnlySpan`1<T> AsSpan();
    public void Dispose();
    private void Grow();
    public T Pop();
}
[ExtensionAttribute]
internal static class System.Collections.HashtableExtensions : object {
    [ExtensionAttribute]
public static bool TryGetValue(Hashtable table, object key, T& value);
}
internal static class System.Collections.ObjectModel.EventArgsCache : object {
    internal static PropertyChangedEventArgs CountPropertyChanged;
    internal static PropertyChangedEventArgs IndexerPropertyChanged;
    internal static NotifyCollectionChangedEventArgs ResetCollectionChanged;
    private static EventArgsCache();
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.CollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.ObjectModel.ObservableCollection`1 : Collection`1<T> {
    private SimpleMonitor<T> _monitor;
    private int _blockReentrancyCount;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public ObservableCollection`1(IEnumerable`1<T> collection);
    public ObservableCollection`1(List`1<T> list);
    private static List`1<T> CreateCopy(IEnumerable`1<T> collection, string paramName);
    public void Move(int oldIndex, int newIndex);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, T item);
    protected virtual void SetItem(int index, T item);
    protected virtual void MoveItem(int oldIndex, int newIndex);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    protected IDisposable BlockReentrancy();
    protected void CheckReentrancy();
    private void OnCountPropertyChanged();
    private void OnIndexerPropertyChanged();
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index, int oldIndex);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object oldItem, object newItem, int index);
    private void OnCollectionReset();
    private SimpleMonitor<T> EnsureMonitorInitialized();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.CollectionDebugView`1")]
public class System.Collections.ObjectModel.ReadOnlyObservableCollection`1 : ReadOnlyCollection`1<T> {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public ReadOnlyObservableCollection`1(ObservableCollection`1<T> list);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs args);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs args);
    private void HandleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void HandlePropertyChanged(object sender, PropertyChangedEventArgs e);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.BitVector32 : ValueType {
    private UInt32 _data;
    public bool Item { get; public set; }
    public int Item { get; public set; }
    public int Data { get; }
    public BitVector32(int data);
    public BitVector32(BitVector32 value);
    public bool get_Item(int bit);
    public void set_Item(int bit, bool value);
    public int get_Item(Section section);
    public void set_Item(Section section, int value);
    public int get_Data();
    private static short CountBitsSet(short mask);
    public static int CreateMask();
    public static int CreateMask(int previous);
    private static short CreateMaskFromHighValue(short highValue);
    public static Section CreateSection(short maxValue);
    public static Section CreateSection(short maxValue, Section previous);
    private static Section CreateSectionHelper(short maxValue, short priorMask, short priorOffset);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static string ToString(BitVector32 value);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Specialized.CaseSensitiveStringDictionary : StringDictionary {
    public string Item { get; public set; }
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual void Add(string key, string value);
    public virtual bool ContainsKey(string key);
    public virtual void Remove(string key);
}
public class System.Collections.Specialized.CollectionsUtil : object {
    public static Hashtable CreateCaseInsensitiveHashtable();
    public static Hashtable CreateCaseInsensitiveHashtable(int capacity);
    public static Hashtable CreateCaseInsensitiveHashtable(IDictionary d);
    public static SortedList CreateCaseInsensitiveSortedList();
}
internal class System.Collections.Specialized.CompatibleComparer : object {
    private IComparer _comparer;
    private static IComparer modreq(System.Runtime.CompilerServices.IsVolatile) defaultComparer;
    private IHashCodeProvider _hcp;
    private static IHashCodeProvider modreq(System.Runtime.CompilerServices.IsVolatile) defaultHashProvider;
    public IComparer Comparer { get; }
    public IHashCodeProvider HashCodeProvider { get; }
    public static IComparer DefaultComparer { get; }
    public static IHashCodeProvider DefaultHashCodeProvider { get; }
    internal CompatibleComparer(IComparer comparer, IHashCodeProvider hashCodeProvider);
    public sealed virtual bool Equals(object a, object b);
    public sealed virtual int GetHashCode(object obj);
    public IComparer get_Comparer();
    public IHashCodeProvider get_HashCodeProvider();
    public static IComparer get_DefaultComparer();
    public static IHashCodeProvider get_DefaultHashCodeProvider();
}
internal static class System.Collections.Specialized.FixedStringLookup : object {
    internal static bool Contains(String[][] lookupTable, string value, bool ignoreCase);
    private static bool Contains(String[] array, string value, bool ignoreCase);
    private static bool FindCharacter(String[] array, char value, int pos, Int32& min, Int32& max);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Specialized.GenericAdapter : object {
    private StringDictionary m_stringDictionary;
    private ICollectionToGenericCollectionAdapter _values;
    private ICollectionToGenericCollectionAdapter _keys;
    public int Count { get; }
    public string Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<string> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.IsReadOnly { get; }
    internal GenericAdapter(StringDictionary stringDictionary);
    public sealed virtual void Add(string key, string value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Clear();
    public sealed virtual int get_Count();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, String& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Add(KeyValuePair`2<string, string> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Contains(KeyValuePair`2<string, string> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Remove(KeyValuePair`2<string, string> item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Collections.Specialized.GenericAdapter/<GetEnumerator>d__25")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.HybridDictionary : object {
    private static int CutoverPoint;
    private static int InitialHashtableSize;
    private static int FixedSizeCutoverPoint;
    private ListDictionary list;
    private Hashtable hashtable;
    private bool caseInsensitive;
    public object Item { get; public set; }
    private ListDictionary List { get; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public HybridDictionary(int initialSize);
    public HybridDictionary(bool caseInsensitive);
    public HybridDictionary(int initialSize, bool caseInsensitive);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    private ListDictionary get_List();
    private void ChangeOver();
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
public interface System.Collections.Specialized.INotifyCollectionChanged {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Specialized.IOrderedDictionary {
    public object Item { get; public set; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Insert(int index, object key, object value);
    public abstract virtual void RemoveAt(int index);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.ListDictionary : object {
    private DictionaryNode head;
    private int version;
    private int count;
    private IComparer comparer;
    private object _syncRoot;
    public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public ListDictionary(IComparer comparer);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
public abstract class System.Collections.Specialized.NameObjectCollectionBase : object {
    private static string ReadOnlyName;
    private static string CountName;
    private static string ComparerName;
    private static string HashCodeProviderName;
    private static string KeysName;
    private static string ValuesName;
    private static string KeyComparerName;
    private static string VersionName;
    private bool _readOnly;
    private ArrayList _entriesArray;
    private IEqualityComparer _keyComparer;
    private Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _entriesTable;
    private NameObjectEntry modreq(System.Runtime.CompilerServices.IsVolatile) _nullKeyEntry;
    private KeysCollection _keys;
    private SerializationInfo _serializationInfo;
    private int _version;
    private object _syncRoot;
    private static StringComparer defaultComparer;
    internal IEqualityComparer Comparer { get; internal set; }
    protected bool IsReadOnly { get; protected set; }
    public int Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public KeysCollection Keys { get; }
    protected NameObjectCollectionBase(IEqualityComparer equalityComparer);
    protected NameObjectCollectionBase(int capacity, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use NameObjectCollectionBase(IEqualityComparer) instead.")]
protected NameObjectCollectionBase(IHashCodeProvider hashProvider, IComparer comparer);
    [ObsoleteAttribute("Please use NameObjectCollectionBase(Int32, IEqualityComparer) instead.")]
protected NameObjectCollectionBase(int capacity, IHashCodeProvider hashProvider, IComparer comparer);
    protected NameObjectCollectionBase(int capacity);
    internal NameObjectCollectionBase(DBNull dummy);
    protected NameObjectCollectionBase(SerializationInfo info, StreamingContext context);
    private static NameObjectCollectionBase();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    private void Reset();
    private void Reset(int capacity);
    private NameObjectEntry FindEntry(string key);
    internal IEqualityComparer get_Comparer();
    internal void set_Comparer(IEqualityComparer value);
    protected bool get_IsReadOnly();
    protected void set_IsReadOnly(bool value);
    protected bool BaseHasKeys();
    protected void BaseAdd(string name, object value);
    protected void BaseRemove(string name);
    protected void BaseRemoveAt(int index);
    protected void BaseClear();
    protected object BaseGet(string name);
    protected void BaseSet(string name, object value);
    protected object BaseGet(int index);
    protected string BaseGetKey(int index);
    protected void BaseSet(int index, object value);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    protected String[] BaseGetAllKeys();
    protected Object[] BaseGetAllValues();
    protected Object[] BaseGetAllValues(Type type);
    public virtual KeysCollection get_Keys();
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.NameValueCollection : NameObjectCollectionBase {
    private String[] _all;
    private String[] _allKeys;
    public string Item { get; public set; }
    public string Item { get; }
    public String[] AllKeys { get; }
    public NameValueCollection(NameValueCollection col);
    [ObsoleteAttribute("Please use NameValueCollection(IEqualityComparer) instead.")]
public NameValueCollection(IHashCodeProvider hashProvider, IComparer comparer);
    public NameValueCollection(int capacity);
    public NameValueCollection(IEqualityComparer equalityComparer);
    public NameValueCollection(int capacity, IEqualityComparer equalityComparer);
    public NameValueCollection(int capacity, NameValueCollection col);
    [ObsoleteAttribute("Please use NameValueCollection(Int32, IEqualityComparer) instead.")]
public NameValueCollection(int capacity, IHashCodeProvider hashProvider, IComparer comparer);
    protected NameValueCollection(SerializationInfo info, StreamingContext context);
    internal NameValueCollection(DBNull dummy);
    protected void InvalidateCachedArrays();
    private static string GetAsOneString(ArrayList list);
    private static String[] GetAsStringArray(ArrayList list);
    public void Add(NameValueCollection c);
    public virtual void Clear();
    public void CopyTo(Array dest, int index);
    public bool HasKeys();
    internal virtual bool InternalHasKeys();
    public virtual void Add(string name, string value);
    public virtual string Get(string name);
    public virtual String[] GetValues(string name);
    public virtual void Set(string name, string value);
    public virtual void Remove(string name);
    public string get_Item(string name);
    public void set_Item(string name, string value);
    public virtual string Get(int index);
    public virtual String[] GetValues(int index);
    public virtual string GetKey(int index);
    public string get_Item(int index);
    public virtual String[] get_AllKeys();
}
public enum System.Collections.Specialized.NotifyCollectionChangedAction : Enum {
    public int value__;
    public static NotifyCollectionChangedAction Add;
    public static NotifyCollectionChangedAction Remove;
    public static NotifyCollectionChangedAction Replace;
    public static NotifyCollectionChangedAction Move;
    public static NotifyCollectionChangedAction Reset;
}
public class System.Collections.Specialized.NotifyCollectionChangedEventArgs : EventArgs {
    private NotifyCollectionChangedAction _action;
    private IList _newItems;
    private IList _oldItems;
    private int _newStartingIndex;
    private int _oldStartingIndex;
    public NotifyCollectionChangedAction Action { get; }
    public IList NewItems { get; }
    public IList OldItems { get; }
    public int NewStartingIndex { get; }
    public int OldStartingIndex { get; }
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex);
    private void InitializeAddOrRemove(NotifyCollectionChangedAction action, IList changedItems, int startingIndex);
    private void InitializeAdd(NotifyCollectionChangedAction action, IList newItems, int newStartingIndex);
    private void InitializeRemove(NotifyCollectionChangedAction action, IList oldItems, int oldStartingIndex);
    private void InitializeMoveOrReplace(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex, int oldStartingIndex);
    public NotifyCollectionChangedAction get_Action();
    public IList get_NewItems();
    public IList get_OldItems();
    public int get_NewStartingIndex();
    public int get_OldStartingIndex();
}
public class System.Collections.Specialized.NotifyCollectionChangedEventHandler : MulticastDelegate {
    public NotifyCollectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.OrderedDictionary : object {
    private ArrayList _objectsArray;
    private Hashtable _objectsTable;
    private int _initialCapacity;
    private IEqualityComparer _comparer;
    private bool _readOnly;
    private object _syncRoot;
    private SerializationInfo _siInfo;
    private static string KeyComparerName;
    private static string ArrayListName;
    private static string ReadOnlyName;
    private static string InitCapacityName;
    public int Count { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public ICollection Keys { get; }
    private ArrayList objectsArray { get; }
    private Hashtable objectsTable { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object Item { get; public set; }
    public object Item { get; public set; }
    public ICollection Values { get; }
    public OrderedDictionary(int capacity);
    public OrderedDictionary(IEqualityComparer comparer);
    public OrderedDictionary(int capacity, IEqualityComparer comparer);
    private OrderedDictionary(OrderedDictionary dictionary);
    protected OrderedDictionary(SerializationInfo info, StreamingContext context);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual ICollection get_Keys();
    private ArrayList get_objectsArray();
    private Hashtable get_objectsTable();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public OrderedDictionary AsReadOnly();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    private int IndexOfKey(object key);
    public sealed virtual void Insert(int index, object key, object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Remove(object key);
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    protected virtual void OnDeserialization(object sender);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Specialized.ReadOnlyList : object {
    private IList _list;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public object SyncRoot { get; }
    internal ReadOnlyList(IList list);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual object get_SyncRoot();
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.StringCollection : object {
    private ArrayList data;
    public string Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public string get_Item(int index);
    public void set_Item(int index, string value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public int Add(string value);
    public void AddRange(String[] value);
    public sealed virtual void Clear();
    public bool Contains(string value);
    public void CopyTo(String[] array, int index);
    public StringEnumerator GetEnumerator();
    public int IndexOf(string value);
    public void Insert(int index, string value);
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(string value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.StringDictionary : object {
    internal Hashtable contents;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public string Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual ICollection get_Keys();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Values();
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual bool ContainsKey(string key);
    public virtual bool ContainsValue(string value);
    public virtual void CopyTo(Array array, int index);
    public virtual IEnumerator GetEnumerator();
    public virtual void Remove(string key);
    internal void ReplaceHashtable(Hashtable useThisHashtableInstead);
    internal IDictionary`2<string, string> AsGenericDictionary();
}
public class System.Collections.Specialized.StringEnumerator : object {
    private IEnumerator _baseEnumerator;
    private IEnumerable _temp;
    public string Current { get; }
    internal StringEnumerator(StringCollection mappings);
    public string get_Current();
    public bool MoveNext();
    public void Reset();
}
public class System.ComponentModel.AddingNewEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <NewObject>k__BackingField;
    public object NewObject { get; public set; }
    public AddingNewEventArgs(object newObject);
    [CompilerGeneratedAttribute]
public object get_NewObject();
    [CompilerGeneratedAttribute]
public void set_NewObject(object value);
}
public class System.ComponentModel.AddingNewEventHandler : MulticastDelegate {
    public AddingNewEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AddingNewEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AddingNewEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.AmbientValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public AmbientValueAttribute(Type type, string value);
    public AmbientValueAttribute(char value);
    public AmbientValueAttribute(byte value);
    public AmbientValueAttribute(short value);
    public AmbientValueAttribute(int value);
    public AmbientValueAttribute(long value);
    public AmbientValueAttribute(float value);
    public AmbientValueAttribute(double value);
    public AmbientValueAttribute(bool value);
    public AmbientValueAttribute(string value);
    public AmbientValueAttribute(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.ComponentModel.ArrayConverter : CollectionConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
internal class System.ComponentModel.ArraySubsetEnumerator : object {
    private Array array;
    private int total;
    private int current;
    public object Current { get; }
    public ArraySubsetEnumerator(Array array, int count);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
public class System.ComponentModel.AsyncCompletedEventArgs : EventArgs {
    private Exception error;
    private bool cancelled;
    private object userState;
    [SRDescriptionAttribute("True if operation was cancelled.")]
public bool Cancelled { get; }
    [SRDescriptionAttribute("Exception that occurred during operation.  Null if no error.")]
public Exception Error { get; }
    [SRDescriptionAttribute("User-supplied state to identify operation.")]
public object UserState { get; }
    public AsyncCompletedEventArgs(Exception error, bool cancelled, object userState);
    public bool get_Cancelled();
    public Exception get_Error();
    public object get_UserState();
    protected void RaiseExceptionIfNecessary();
}
public class System.ComponentModel.AsyncCompletedEventHandler : MulticastDelegate {
    public AsyncCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.AsyncOperation : object {
    private SynchronizationContext _syncContext;
    private object _userSuppliedState;
    private bool _alreadyCompleted;
    public object UserSuppliedState { get; }
    public SynchronizationContext SynchronizationContext { get; }
    private AsyncOperation(object userSuppliedState, SynchronizationContext syncContext);
    protected virtual override void Finalize();
    public object get_UserSuppliedState();
    public SynchronizationContext get_SynchronizationContext();
    public void Post(SendOrPostCallback d, object arg);
    public void PostOperationCompleted(SendOrPostCallback d, object arg);
    public void OperationCompleted();
    private void PostCore(SendOrPostCallback d, object arg, bool markCompleted);
    private void OperationCompletedCore();
    private void VerifyNotCompleted();
    private void VerifyDelegateNotNull(SendOrPostCallback d);
    internal static AsyncOperation CreateOperation(object userSuppliedState, SynchronizationContext syncContext);
}
public static class System.ComponentModel.AsyncOperationManager : object {
    [EditorBrowsableAttribute("2")]
public static SynchronizationContext SynchronizationContext { get; public set; }
    public static AsyncOperation CreateOperation(object userSuppliedState);
    public static SynchronizationContext get_SynchronizationContext();
    public static void set_SynchronizationContext(SynchronizationContext value);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.AttributeCollection : object {
    public static AttributeCollection Empty;
    private static Hashtable s_defaultAttributes;
    private Attribute[] _attributes;
    private static object s_internalSyncObject;
    private static int FOUND_TYPES_LIMIT;
    private AttributeEntry[] _foundAttributeTypes;
    private int _index;
    protected Attribute[] Attributes { get; }
    public int Count { get; }
    public Attribute Item { get; }
    public Attribute Item { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private int System.Collections.ICollection.Count { get; }
    public AttributeCollection(Attribute[] attributes);
    private static AttributeCollection();
    public static AttributeCollection FromExisting(AttributeCollection existing, Attribute[] newAttributes);
    protected virtual Attribute[] get_Attributes();
    public int get_Count();
    public virtual Attribute get_Item(int index);
    public virtual Attribute get_Item(Type attributeType);
    public bool Contains(Attribute attribute);
    public bool Contains(Attribute[] attributes);
    protected Attribute GetDefaultAttribute(Type attributeType);
    public IEnumerator GetEnumerator();
    public bool Matches(Attribute attribute);
    public bool Matches(Attribute[] attributes);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.AttributeProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string TypeName { get; }
    public string PropertyName { get; }
    public AttributeProviderAttribute(string typeName);
    public AttributeProviderAttribute(string typeName, string propertyName);
    public AttributeProviderAttribute(Type type);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_PropertyName();
}
[DefaultEventAttribute("DoWork")]
public class System.ComponentModel.BackgroundWorker : Component {
    private bool _canCancelWorker;
    private bool _workerReportsProgress;
    private bool _cancellationPending;
    private bool _isRunning;
    private AsyncOperation _asyncOperation;
    private SendOrPostCallback _operationCompleted;
    private SendOrPostCallback _progressReporter;
    [CompilerGeneratedAttribute]
private DoWorkEventHandler DoWork;
    [CompilerGeneratedAttribute]
private ProgressChangedEventHandler ProgressChanged;
    [CompilerGeneratedAttribute]
private RunWorkerCompletedEventHandler RunWorkerCompleted;
    public bool CancellationPending { get; }
    public bool IsBusy { get; }
    public bool WorkerReportsProgress { get; public set; }
    public bool WorkerSupportsCancellation { get; public set; }
    private void AsyncOperationCompleted(object arg);
    public bool get_CancellationPending();
    public void CancelAsync();
    [CompilerGeneratedAttribute]
public void add_DoWork(DoWorkEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DoWork(DoWorkEventHandler value);
    public bool get_IsBusy();
    protected virtual void OnDoWork(DoWorkEventArgs e);
    protected virtual void OnRunWorkerCompleted(RunWorkerCompletedEventArgs e);
    protected virtual void OnProgressChanged(ProgressChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(ProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(ProgressChangedEventHandler value);
    private void ProgressReporter(object arg);
    public void ReportProgress(int percentProgress);
    public void ReportProgress(int percentProgress, object userState);
    public void RunWorkerAsync();
    public void RunWorkerAsync(object argument);
    [CompilerGeneratedAttribute]
public void add_RunWorkerCompleted(RunWorkerCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RunWorkerCompleted(RunWorkerCompletedEventHandler value);
    public bool get_WorkerReportsProgress();
    public void set_WorkerReportsProgress(bool value);
    public bool get_WorkerSupportsCancellation();
    public void set_WorkerSupportsCancellation(bool value);
    private void WorkerThreadStart(object argument);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <RunWorkerAsync>b__27_0(object arg);
}
public abstract class System.ComponentModel.BaseNumberConverter : TypeConverter {
    internal bool AllowHex { get; }
    internal Type TargetType { get; }
    internal virtual bool get_AllowHex();
    internal abstract virtual Type get_TargetType();
    internal abstract virtual object FromString(string value, int radix);
    internal abstract virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal abstract virtual string ToString(object value, NumberFormatInfo formatInfo);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.BindableAttribute : Attribute {
    public static BindableAttribute Yes;
    public static BindableAttribute No;
    public static BindableAttribute Default;
    private bool _isDefault;
    [CompilerGeneratedAttribute]
private bool <Bindable>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingDirection <Direction>k__BackingField;
    public bool Bindable { get; }
    public BindingDirection Direction { get; }
    public BindableAttribute(bool bindable);
    public BindableAttribute(bool bindable, BindingDirection direction);
    public BindableAttribute(BindableSupport flags);
    public BindableAttribute(BindableSupport flags, BindingDirection direction);
    private static BindableAttribute();
    [CompilerGeneratedAttribute]
public bool get_Bindable();
    [CompilerGeneratedAttribute]
public BindingDirection get_Direction();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public enum System.ComponentModel.BindableSupport : Enum {
    public int value__;
    public static BindableSupport No;
    public static BindableSupport Yes;
    public static BindableSupport Default;
}
public enum System.ComponentModel.BindingDirection : Enum {
    public int value__;
    public static BindingDirection OneWay;
    public static BindingDirection TwoWay;
}
public class System.ComponentModel.BindingList`1 : Collection`1<T> {
    private int addNewPos;
    private bool raiseListChangedEvents;
    private bool raiseItemChangedEvents;
    private PropertyDescriptorCollection _itemTypeProperties;
    private PropertyChangedEventHandler _propertyChangedEventHandler;
    private AddingNewEventHandler _onAddingNew;
    private ListChangedEventHandler _onListChanged;
    private int _lastChangeIndex;
    private bool allowNew;
    private bool allowEdit;
    private bool allowRemove;
    private bool userSetAllowNew;
    private bool ItemTypeHasDefaultConstructor { get; }
    public bool RaiseListChangedEvents { get; public set; }
    private bool AddingNewHandled { get; }
    public bool AllowNew { get; public set; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    public bool AllowEdit { get; public set; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    public bool AllowRemove { get; public set; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    protected bool SupportsChangeNotificationCore { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    protected bool SupportsSearchingCore { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    protected bool SupportsSortingCore { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    protected bool IsSortedCore { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    protected PropertyDescriptor SortPropertyCore { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    protected ListSortDirection SortDirectionCore { get; }
    private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents { get; }
    public BindingList`1(IList`1<T> list);
    private void Initialize();
    private bool get_ItemTypeHasDefaultConstructor();
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    private object FireAddingNew();
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    public bool get_RaiseListChangedEvents();
    public void set_RaiseListChangedEvents(bool value);
    public void ResetBindings();
    public void ResetItem(int position);
    private void FireListChanged(ListChangedType type, int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    public virtual void CancelNew(int itemIndex);
    public virtual void EndNew(int itemIndex);
    public T AddNew();
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private bool get_AddingNewHandled();
    protected virtual object AddNewCore();
    public bool get_AllowNew();
    public void set_AllowNew(bool value);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    public bool get_AllowEdit();
    public void set_AllowEdit(bool value);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    public bool get_AllowRemove();
    public void set_AllowRemove(bool value);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    protected virtual bool get_SupportsChangeNotificationCore();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    protected virtual bool get_SupportsSearchingCore();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    protected virtual bool get_SupportsSortingCore();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    protected virtual bool get_IsSortedCore();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    protected virtual PropertyDescriptor get_SortPropertyCore();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    protected virtual ListSortDirection get_SortDirectionCore();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor prop, ListSortDirection direction);
    protected virtual void ApplySortCore(PropertyDescriptor prop, ListSortDirection direction);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    protected virtual void RemoveSortCore();
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor prop, object key);
    protected virtual int FindCore(PropertyDescriptor prop, object key);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor prop);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor prop);
    private void HookPropertyChanged(T item);
    private void UnhookPropertyChanged(T item);
    private void Child_PropertyChanged(object sender, PropertyChangedEventArgs e);
    private sealed virtual override bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents();
}
public class System.ComponentModel.BooleanConverter : TypeConverter {
    private static StandardValuesCollection modreq(System.Runtime.CompilerServices.IsVolatile) s_values;
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.BrowsableAttribute : Attribute {
    public static BrowsableAttribute Yes;
    public static BrowsableAttribute No;
    public static BrowsableAttribute Default;
    [CompilerGeneratedAttribute]
private bool <Browsable>k__BackingField;
    public bool Browsable { get; }
    public BrowsableAttribute(bool browsable);
    private static BrowsableAttribute();
    [CompilerGeneratedAttribute]
public bool get_Browsable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ByteConverter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.CancelEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <Cancel>k__BackingField;
    public bool Cancel { get; public set; }
    public CancelEventArgs(bool cancel);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class System.ComponentModel.CancelEventHandler : MulticastDelegate {
    public CancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.CategoryAttribute : Attribute {
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) appearance;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) asynchronous;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) behavior;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) data;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) design;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) action;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) format;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) layout;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) mouse;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) key;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) focus;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) windowStyle;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) dragDrop;
    private static CategoryAttribute modreq(System.Runtime.CompilerServices.IsVolatile) defAttr;
    private bool localized;
    private string categoryValue;
    public static CategoryAttribute Action { get; }
    public static CategoryAttribute Appearance { get; }
    public static CategoryAttribute Asynchronous { get; }
    public static CategoryAttribute Behavior { get; }
    public static CategoryAttribute Data { get; }
    public static CategoryAttribute Default { get; }
    public static CategoryAttribute Design { get; }
    public static CategoryAttribute DragDrop { get; }
    public static CategoryAttribute Focus { get; }
    public static CategoryAttribute Format { get; }
    public static CategoryAttribute Key { get; }
    public static CategoryAttribute Layout { get; }
    public static CategoryAttribute Mouse { get; }
    public static CategoryAttribute WindowStyle { get; }
    public string Category { get; }
    public CategoryAttribute(string category);
    public static CategoryAttribute get_Action();
    public static CategoryAttribute get_Appearance();
    public static CategoryAttribute get_Asynchronous();
    public static CategoryAttribute get_Behavior();
    public static CategoryAttribute get_Data();
    public static CategoryAttribute get_Default();
    public static CategoryAttribute get_Design();
    public static CategoryAttribute get_DragDrop();
    public static CategoryAttribute get_Focus();
    public static CategoryAttribute get_Format();
    public static CategoryAttribute get_Key();
    public static CategoryAttribute get_Layout();
    public static CategoryAttribute get_Mouse();
    public static CategoryAttribute get_WindowStyle();
    public string get_Category();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual string GetLocalizedString(string value);
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.CharConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public enum System.ComponentModel.CollectionChangeAction : Enum {
    public int value__;
    public static CollectionChangeAction Add;
    public static CollectionChangeAction Remove;
    public static CollectionChangeAction Refresh;
}
public class System.ComponentModel.CollectionChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private CollectionChangeAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Element>k__BackingField;
    public CollectionChangeAction Action { get; }
    public object Element { get; }
    public CollectionChangeEventArgs(CollectionChangeAction action, object element);
    [CompilerGeneratedAttribute]
public virtual CollectionChangeAction get_Action();
    [CompilerGeneratedAttribute]
public virtual object get_Element();
}
public class System.ComponentModel.CollectionChangeEventHandler : MulticastDelegate {
    public CollectionChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CollectionChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CollectionChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.CollectionConverter : TypeConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.ComplexBindingPropertiesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DataSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DataMember>k__BackingField;
    public static ComplexBindingPropertiesAttribute Default;
    public string DataSource { get; }
    public string DataMember { get; }
    public ComplexBindingPropertiesAttribute(string dataSource);
    public ComplexBindingPropertiesAttribute(string dataSource, string dataMember);
    private static ComplexBindingPropertiesAttribute();
    [CompilerGeneratedAttribute]
public string get_DataSource();
    [CompilerGeneratedAttribute]
public string get_DataMember();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class System.ComponentModel.CompModSwitches : object {
    private static BooleanSwitch modreq(System.Runtime.CompilerServices.IsVolatile) commonDesignerServices;
    private static TraceSwitch modreq(System.Runtime.CompilerServices.IsVolatile) eventLog;
    public static BooleanSwitch CommonDesignerServices { get; }
    public static TraceSwitch EventLog { get; }
    public static BooleanSwitch get_CommonDesignerServices();
    public static TraceSwitch get_EventLog();
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
[DesignerCategoryAttribute("Component")]
public class System.ComponentModel.Component : MarshalByRefObject {
    private static object EventDisposed;
    private ISite site;
    private EventHandlerList events;
    protected bool CanRaiseEvents { get; }
    internal bool CanRaiseEventsInternal { get; }
    protected EventHandlerList Events { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ISite Site { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IContainer Container { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
protected bool DesignMode { get; }
    private static Component();
    protected virtual override void Finalize();
    protected virtual bool get_CanRaiseEvents();
    internal bool get_CanRaiseEventsInternal();
    public sealed virtual void add_Disposed(EventHandler value);
    public sealed virtual void remove_Disposed(EventHandler value);
    protected EventHandlerList get_Events();
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public IContainer get_Container();
    protected virtual object GetService(Type service);
    protected bool get_DesignMode();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.ComponentCollection : ReadOnlyCollectionBase {
    public IComponent Item { get; }
    public IComponent Item { get; }
    public ComponentCollection(IComponent[] components);
    public virtual IComponent get_Item(string name);
    public virtual IComponent get_Item(int index);
    public void CopyTo(IComponent[] array, int index);
}
public class System.ComponentModel.ComponentConverter : ReferenceConverter {
    public ComponentConverter(Type type);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public abstract class System.ComponentModel.ComponentEditor : object {
    public bool EditComponent(object component);
    public abstract virtual bool EditComponent(ITypeDescriptorContext context, object component);
}
public class System.ComponentModel.ComponentResourceManager : ResourceManager {
    private Hashtable _resourceSets;
    private CultureInfo _neutralResourcesCulture;
    private CultureInfo NeutralResourcesCulture { get; }
    public ComponentResourceManager(Type t);
    private CultureInfo get_NeutralResourcesCulture();
    public void ApplyResources(object value, string objectName);
    public virtual void ApplyResources(object value, string objectName, CultureInfo culture);
    private SortedList`2<string, object> FillResources(CultureInfo culture, ResourceSet& resourceSet);
}
public class System.ComponentModel.Container : object {
    private ISite[] sites;
    private int siteCount;
    private ComponentCollection components;
    private ContainerFilterService filter;
    private bool checkedFilter;
    private object syncObj;
    public ComponentCollection Components { get; }
    protected virtual override void Finalize();
    public virtual void Add(IComponent component);
    public virtual void Add(IComponent component, string name);
    protected virtual ISite CreateSite(IComponent component, string name);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual object GetService(Type service);
    public virtual ComponentCollection get_Components();
    public virtual void Remove(IComponent component);
    private void Remove(IComponent component, bool preserveSite);
    protected void RemoveWithoutUnsiting(IComponent component);
    protected virtual void ValidateName(IComponent component, string name);
}
public abstract class System.ComponentModel.ContainerFilterService : object {
    public virtual ComponentCollection FilterComponents(ComponentCollection components);
}
public class System.ComponentModel.CultureInfoConverter : TypeConverter {
    private StandardValuesCollection _values;
    private static string DefaultInvariantCultureString;
    private string DefaultCultureString { get; }
    private string get_DefaultCultureString();
    protected virtual string GetCultureName(CultureInfo culture);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public abstract class System.ComponentModel.CustomTypeDescriptor : object {
    private ICustomTypeDescriptor _parent;
    protected CustomTypeDescriptor(ICustomTypeDescriptor parent);
    public virtual AttributeCollection GetAttributes();
    public virtual string GetClassName();
    public virtual string GetComponentName();
    public virtual TypeConverter GetConverter();
    public virtual EventDescriptor GetDefaultEvent();
    public virtual PropertyDescriptor GetDefaultProperty();
    public virtual object GetEditor(Type editorBaseType);
    public virtual EventDescriptorCollection GetEvents();
    public virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public virtual PropertyDescriptorCollection GetProperties();
    public virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public virtual object GetPropertyOwner(PropertyDescriptor pd);
}
public class System.ComponentModel.DataErrorsChangedEventArgs : EventArgs {
    private string _propertyName;
    public string PropertyName { get; }
    public DataErrorsChangedEventArgs(string propertyName);
    public virtual string get_PropertyName();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DataObjectAttribute : Attribute {
    public static DataObjectAttribute DataObject;
    public static DataObjectAttribute NonDataObject;
    public static DataObjectAttribute Default;
    [CompilerGeneratedAttribute]
private bool <IsDataObject>k__BackingField;
    public bool IsDataObject { get; }
    public DataObjectAttribute(bool isDataObject);
    private static DataObjectAttribute();
    [CompilerGeneratedAttribute]
public bool get_IsDataObject();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.DataObjectFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrimaryKey>k__BackingField;
    public bool IsIdentity { get; }
    public bool IsNullable { get; }
    public int Length { get; }
    public bool PrimaryKey { get; }
    public DataObjectFieldAttribute(bool primaryKey);
    public DataObjectFieldAttribute(bool primaryKey, bool isIdentity);
    public DataObjectFieldAttribute(bool primaryKey, bool isIdentity, bool isNullable);
    public DataObjectFieldAttribute(bool primaryKey, bool isIdentity, bool isNullable, int length);
    [CompilerGeneratedAttribute]
public bool get_IsIdentity();
    [CompilerGeneratedAttribute]
public bool get_IsNullable();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public bool get_PrimaryKey();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("64")]
public class System.ComponentModel.DataObjectMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private DataObjectMethodType <MethodType>k__BackingField;
    public bool IsDefault { get; }
    public DataObjectMethodType MethodType { get; }
    public DataObjectMethodAttribute(DataObjectMethodType methodType);
    public DataObjectMethodAttribute(DataObjectMethodType methodType, bool isDefault);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public DataObjectMethodType get_MethodType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool Match(object obj);
}
public enum System.ComponentModel.DataObjectMethodType : Enum {
    public int value__;
    public static DataObjectMethodType Fill;
    public static DataObjectMethodType Select;
    public static DataObjectMethodType Update;
    public static DataObjectMethodType Insert;
    public static DataObjectMethodType Delete;
}
public class System.ComponentModel.DateTimeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ComponentModel.DateTimeOffsetConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ComponentModel.DecimalConverter : BaseNumberConverter {
    internal bool AllowHex { get; }
    internal Type TargetType { get; }
    internal virtual bool get_AllowHex();
    internal virtual Type get_TargetType();
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DefaultBindingPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static DefaultBindingPropertyAttribute Default;
    public string Name { get; }
    public DefaultBindingPropertyAttribute(string name);
    private static DefaultBindingPropertyAttribute();
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DefaultEventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static DefaultEventAttribute Default;
    public string Name { get; }
    public DefaultEventAttribute(string name);
    private static DefaultEventAttribute();
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DefaultPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static DefaultPropertyAttribute Default;
    public string Name { get; }
    public DefaultPropertyAttribute(string name);
    private static DefaultPropertyAttribute();
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    private object _value;
    private static object s_convertFromInvariantString;
    public object Value { get; }
    public DefaultValueAttribute(Type type, string value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(string value);
    public DefaultValueAttribute(object value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(sbyte value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ushort value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(UInt32 value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ulong value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__TryConvertFromInvariantString|2_0(Type typeToConvert, string stringValue, Object& conversionResult);
}
internal class System.ComponentModel.DelegatingTypeDescriptionProvider : TypeDescriptionProvider {
    private Type _type;
    internal TypeDescriptionProvider Provider { get; }
    internal DelegatingTypeDescriptionProvider(Type type);
    internal TypeDescriptionProvider get_Provider();
    public virtual object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    public virtual IDictionary GetCache(object instance);
    public virtual string GetFullComponentName(object component);
    public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
    protected internal virtual IExtenderProvider[] GetExtenderProviders(object instance);
    public virtual Type GetReflectionType(Type objectType, object instance);
    public virtual Type GetRuntimeType(Type objectType);
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
    public virtual bool IsSupportedType(Type type);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DescriptionAttribute : Attribute {
    public static DescriptionAttribute Default;
    [CompilerGeneratedAttribute]
private string <DescriptionValue>k__BackingField;
    public string Description { get; }
    protected string DescriptionValue { get; protected set; }
    public DescriptionAttribute(string description);
    private static DescriptionAttribute();
    public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected string get_DescriptionValue();
    [CompilerGeneratedAttribute]
protected void set_DescriptionValue(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.Design.ActiveDesignerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IDesignerHost <OldDesigner>k__BackingField;
    [CompilerGeneratedAttribute]
private IDesignerHost <NewDesigner>k__BackingField;
    public IDesignerHost OldDesigner { get; }
    public IDesignerHost NewDesigner { get; }
    public ActiveDesignerEventArgs(IDesignerHost oldDesigner, IDesignerHost newDesigner);
    [CompilerGeneratedAttribute]
public IDesignerHost get_OldDesigner();
    [CompilerGeneratedAttribute]
public IDesignerHost get_NewDesigner();
}
public class System.ComponentModel.Design.ActiveDesignerEventHandler : MulticastDelegate {
    public ActiveDesignerEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ActiveDesignerEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ActiveDesignerEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.CheckoutException : ExternalException {
    private static int E_ABORT;
    public static CheckoutException Canceled;
    public CheckoutException(string message);
    public CheckoutException(string message, int errorCode);
    protected CheckoutException(SerializationInfo info, StreamingContext context);
    public CheckoutException(string message, Exception innerException);
    private static CheckoutException();
}
public class System.ComponentModel.Design.CommandID : object {
    [CompilerGeneratedAttribute]
private int <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    public int ID { get; }
    public Guid Guid { get; }
    public CommandID(Guid menuGroup, int commandID);
    [CompilerGeneratedAttribute]
public virtual int get_ID();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual Guid get_Guid();
    public virtual string ToString();
}
public class System.ComponentModel.Design.ComponentChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberDescriptor <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private object <NewValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OldValue>k__BackingField;
    public object Component { get; }
    public MemberDescriptor Member { get; }
    public object NewValue { get; }
    public object OldValue { get; }
    public ComponentChangedEventArgs(object component, MemberDescriptor member, object oldValue, object newValue);
    [CompilerGeneratedAttribute]
public object get_Component();
    [CompilerGeneratedAttribute]
public MemberDescriptor get_Member();
    [CompilerGeneratedAttribute]
public object get_NewValue();
    [CompilerGeneratedAttribute]
public object get_OldValue();
}
public class System.ComponentModel.Design.ComponentChangedEventHandler : MulticastDelegate {
    public ComponentChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.ComponentChangingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberDescriptor <Member>k__BackingField;
    public object Component { get; }
    public MemberDescriptor Member { get; }
    public ComponentChangingEventArgs(object component, MemberDescriptor member);
    [CompilerGeneratedAttribute]
public object get_Component();
    [CompilerGeneratedAttribute]
public MemberDescriptor get_Member();
}
public class System.ComponentModel.Design.ComponentChangingEventHandler : MulticastDelegate {
    public ComponentChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.ComponentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IComponent <Component>k__BackingField;
    public IComponent Component { get; }
    public ComponentEventArgs(IComponent component);
    [CompilerGeneratedAttribute]
public virtual IComponent get_Component();
}
public class System.ComponentModel.Design.ComponentEventHandler : MulticastDelegate {
    public ComponentEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.ComponentRenameEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    public object Component { get; }
    public string OldName { get; }
    public string NewName { get; }
    public ComponentRenameEventArgs(object component, string oldName, string newName);
    [CompilerGeneratedAttribute]
public object get_Component();
    [CompilerGeneratedAttribute]
public virtual string get_OldName();
    [CompilerGeneratedAttribute]
public virtual string get_NewName();
}
public class System.ComponentModel.Design.ComponentRenameEventHandler : MulticastDelegate {
    public ComponentRenameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentRenameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentRenameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.Design.DesignerCollection : object {
    private IList _designers;
    public int Count { get; }
    public IDesignerHost Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public DesignerCollection(IDesignerHost[] designers);
    public DesignerCollection(IList designers);
    public int get_Count();
    public virtual IDesignerHost get_Item(int index);
    public IEnumerator GetEnumerator();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.ComponentModel.Design.DesignerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IDesignerHost <Designer>k__BackingField;
    public IDesignerHost Designer { get; }
    public DesignerEventArgs(IDesignerHost host);
    [CompilerGeneratedAttribute]
public IDesignerHost get_Designer();
}
public class System.ComponentModel.Design.DesignerEventHandler : MulticastDelegate {
    public DesignerEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DesignerEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DesignerEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.ComponentModel.Design.DesignerOptionService : object {
    private DesignerOptionCollection _options;
    public DesignerOptionCollection Options { get; }
    public DesignerOptionCollection get_Options();
    protected DesignerOptionCollection CreateOptionCollection(DesignerOptionCollection parent, string name, object value);
    private PropertyDescriptor GetOptionProperty(string pageName, string valueName);
    protected virtual void PopulateOptionCollection(DesignerOptionCollection options);
    protected virtual bool ShowDialog(DesignerOptionCollection options, object optionObject);
    private sealed virtual override object System.ComponentModel.Design.IDesignerOptionService.GetOptionValue(string pageName, string valueName);
    private sealed virtual override void System.ComponentModel.Design.IDesignerOptionService.SetOptionValue(string pageName, string valueName, object value);
}
public abstract class System.ComponentModel.Design.DesignerTransaction : object {
    private bool _suppressedFinalization;
    [CompilerGeneratedAttribute]
private bool <Canceled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Committed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public bool Canceled { get; private set; }
    public bool Committed { get; private set; }
    public string Description { get; }
    protected DesignerTransaction(string description);
    [CompilerGeneratedAttribute]
public bool get_Canceled();
    [CompilerGeneratedAttribute]
private void set_Canceled(bool value);
    [CompilerGeneratedAttribute]
public bool get_Committed();
    [CompilerGeneratedAttribute]
private void set_Committed(bool value);
    [CompilerGeneratedAttribute]
public string get_Description();
    public void Cancel();
    public void Commit();
    protected abstract virtual void OnCancel();
    protected abstract virtual void OnCommit();
    protected virtual override void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.ComponentModel.Design.DesignerTransactionCloseEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <TransactionCommitted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LastTransaction>k__BackingField;
    public bool TransactionCommitted { get; }
    public bool LastTransaction { get; }
    [ObsoleteAttribute("This constructor is obsolete. Use DesignerTransactionCloseEventArgs(bool, bool) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public DesignerTransactionCloseEventArgs(bool commit);
    public DesignerTransactionCloseEventArgs(bool commit, bool lastTransaction);
    [CompilerGeneratedAttribute]
public bool get_TransactionCommitted();
    [CompilerGeneratedAttribute]
public bool get_LastTransaction();
}
public class System.ComponentModel.Design.DesignerTransactionCloseEventHandler : MulticastDelegate {
    public DesignerTransactionCloseEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DesignerTransactionCloseEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DesignerTransactionCloseEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.DesignerVerb : MenuCommand {
    public string Description { get; public set; }
    public string Text { get; }
    public DesignerVerb(string text, EventHandler handler);
    public DesignerVerb(string text, EventHandler handler, CommandID startCommandID);
    public string get_Description();
    public void set_Description(string value);
    public string get_Text();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.Design.DesignerVerbCollection : CollectionBase {
    public DesignerVerb Item { get; public set; }
    public DesignerVerbCollection(DesignerVerb[] value);
    public DesignerVerb get_Item(int index);
    public void set_Item(int index, DesignerVerb value);
    public int Add(DesignerVerb value);
    public void AddRange(DesignerVerb[] value);
    public void AddRange(DesignerVerbCollection value);
    public void Insert(int index, DesignerVerb value);
    public int IndexOf(DesignerVerb value);
    public bool Contains(DesignerVerb value);
    public void Remove(DesignerVerb value);
    public void CopyTo(DesignerVerb[] array, int index);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnClear();
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnValidate(object value);
}
public class System.ComponentModel.Design.DesigntimeLicenseContext : LicenseContext {
    internal Hashtable savedLicenseKeys;
    public LicenseUsageMode UsageMode { get; }
    public virtual LicenseUsageMode get_UsageMode();
    public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly);
    public virtual void SetSavedLicenseKey(Type type, string key);
}
public class System.ComponentModel.Design.DesigntimeLicenseContextSerializer : object {
    public static void Serialize(Stream o, string cryptoKey, DesigntimeLicenseContext context);
    internal static void Deserialize(Stream o, string cryptoKey, RuntimeLicenseContext context);
}
public enum System.ComponentModel.Design.HelpContextType : Enum {
    public int value__;
    public static HelpContextType Ambient;
    public static HelpContextType Window;
    public static HelpContextType Selection;
    public static HelpContextType ToolWindowSelection;
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.Design.HelpKeywordAttribute : Attribute {
    public static HelpKeywordAttribute Default;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    public string HelpKeyword { get; }
    public HelpKeywordAttribute(string keyword);
    public HelpKeywordAttribute(Type t);
    private static HelpKeywordAttribute();
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public enum System.ComponentModel.Design.HelpKeywordType : Enum {
    public int value__;
    public static HelpKeywordType F1Keyword;
    public static HelpKeywordType GeneralKeyword;
    public static HelpKeywordType FilterKeyword;
}
public interface System.ComponentModel.Design.IComponentChangeService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentAdded(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentAdded(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentAdding(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentAdding(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentChanged(ComponentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentChanged(ComponentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentChanging(ComponentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentChanging(ComponentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRemoved(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRemoved(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRemoving(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRemoving(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRename(ComponentRenameEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRename(ComponentRenameEventHandler value);
    public abstract virtual void OnComponentChanged(object component, MemberDescriptor member, object oldValue, object newValue);
    public abstract virtual void OnComponentChanging(object component, MemberDescriptor member);
}
public interface System.ComponentModel.Design.IComponentDiscoveryService {
    public abstract virtual ICollection GetComponentTypes(IDesignerHost designerHost, Type baseType);
}
public interface System.ComponentModel.Design.IComponentInitializer {
    public abstract virtual void InitializeExistingComponent(IDictionary defaultValues);
    public abstract virtual void InitializeNewComponent(IDictionary defaultValues);
}
public interface System.ComponentModel.Design.IDesigner {
    public IComponent Component { get; }
    public DesignerVerbCollection Verbs { get; }
    public abstract virtual IComponent get_Component();
    public abstract virtual DesignerVerbCollection get_Verbs();
    public abstract virtual void DoDefaultAction();
    public abstract virtual void Initialize(IComponent component);
}
public interface System.ComponentModel.Design.IDesignerEventService {
    public IDesignerHost ActiveDesigner { get; }
    public DesignerCollection Designers { get; }
    public abstract virtual IDesignerHost get_ActiveDesigner();
    public abstract virtual DesignerCollection get_Designers();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ActiveDesignerChanged(ActiveDesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ActiveDesignerChanged(ActiveDesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DesignerCreated(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DesignerCreated(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DesignerDisposed(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DesignerDisposed(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectionChanged(EventHandler value);
}
public interface System.ComponentModel.Design.IDesignerFilter {
    public abstract virtual void PostFilterAttributes(IDictionary attributes);
    public abstract virtual void PostFilterEvents(IDictionary events);
    public abstract virtual void PostFilterProperties(IDictionary properties);
    public abstract virtual void PreFilterAttributes(IDictionary attributes);
    public abstract virtual void PreFilterEvents(IDictionary events);
    public abstract virtual void PreFilterProperties(IDictionary properties);
}
public interface System.ComponentModel.Design.IDesignerHost {
    public bool Loading { get; }
    public bool InTransaction { get; }
    public IContainer Container { get; }
    public IComponent RootComponent { get; }
    public string RootComponentClassName { get; }
    public string TransactionDescription { get; }
    public abstract virtual bool get_Loading();
    public abstract virtual bool get_InTransaction();
    public abstract virtual IContainer get_Container();
    public abstract virtual IComponent get_RootComponent();
    public abstract virtual string get_RootComponentClassName();
    public abstract virtual string get_TransactionDescription();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LoadComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LoadComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionClosed(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionClosed(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionClosing(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionClosing(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionOpening(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionOpening(EventHandler value);
    public abstract virtual void Activate();
    public abstract virtual IComponent CreateComponent(Type componentClass);
    public abstract virtual IComponent CreateComponent(Type componentClass, string name);
    public abstract virtual DesignerTransaction CreateTransaction();
    public abstract virtual DesignerTransaction CreateTransaction(string description);
    public abstract virtual void DestroyComponent(IComponent component);
    public abstract virtual IDesigner GetDesigner(IComponent component);
    public abstract virtual Type GetType(string typeName);
}
public interface System.ComponentModel.Design.IDesignerHostTransactionState {
    public bool IsClosingTransaction { get; }
    public abstract virtual bool get_IsClosingTransaction();
}
public interface System.ComponentModel.Design.IDesignerOptionService {
    public abstract virtual object GetOptionValue(string pageName, string valueName);
    public abstract virtual void SetOptionValue(string pageName, string valueName, object value);
}
public interface System.ComponentModel.Design.IDictionaryService {
    public abstract virtual object GetKey(object value);
    public abstract virtual object GetValue(object key);
    public abstract virtual void SetValue(object key, object value);
}
public interface System.ComponentModel.Design.IEventBindingService {
    public abstract virtual string CreateUniqueMethodName(IComponent component, EventDescriptor e);
    public abstract virtual ICollection GetCompatibleMethods(EventDescriptor e);
    public abstract virtual EventDescriptor GetEvent(PropertyDescriptor property);
    public abstract virtual PropertyDescriptorCollection GetEventProperties(EventDescriptorCollection events);
    public abstract virtual PropertyDescriptor GetEventProperty(EventDescriptor e);
    public abstract virtual bool ShowCode();
    public abstract virtual bool ShowCode(int lineNumber);
    public abstract virtual bool ShowCode(IComponent component, EventDescriptor e);
}
public interface System.ComponentModel.Design.IExtenderListService {
    public abstract virtual IExtenderProvider[] GetExtenderProviders();
}
public interface System.ComponentModel.Design.IExtenderProviderService {
    public abstract virtual void AddExtenderProvider(IExtenderProvider provider);
    public abstract virtual void RemoveExtenderProvider(IExtenderProvider provider);
}
public interface System.ComponentModel.Design.IHelpService {
    public abstract virtual void AddContextAttribute(string name, string value, HelpKeywordType keywordType);
    public abstract virtual void ClearContextAttributes();
    public abstract virtual IHelpService CreateLocalContext(HelpContextType contextType);
    public abstract virtual void RemoveContextAttribute(string name, string value);
    public abstract virtual void RemoveLocalContext(IHelpService localContext);
    public abstract virtual void ShowHelpFromKeyword(string helpKeyword);
    public abstract virtual void ShowHelpFromUrl(string helpUrl);
}
public interface System.ComponentModel.Design.IInheritanceService {
    public abstract virtual void AddInheritedComponents(IComponent component, IContainer container);
    public abstract virtual InheritanceAttribute GetInheritanceAttribute(IComponent component);
}
public interface System.ComponentModel.Design.IMenuCommandService {
    public DesignerVerbCollection Verbs { get; }
    public abstract virtual DesignerVerbCollection get_Verbs();
    public abstract virtual void AddCommand(MenuCommand command);
    public abstract virtual void AddVerb(DesignerVerb verb);
    public abstract virtual MenuCommand FindCommand(CommandID commandID);
    public abstract virtual bool GlobalInvoke(CommandID commandID);
    public abstract virtual void RemoveCommand(MenuCommand command);
    public abstract virtual void RemoveVerb(DesignerVerb verb);
    public abstract virtual void ShowContextMenu(CommandID menuID, int x, int y);
}
public interface System.ComponentModel.Design.IReferenceService {
    public abstract virtual IComponent GetComponent(object reference);
    public abstract virtual object GetReference(string name);
    public abstract virtual string GetName(object reference);
    public abstract virtual Object[] GetReferences();
    public abstract virtual Object[] GetReferences(Type baseType);
}
public interface System.ComponentModel.Design.IResourceService {
    public abstract virtual IResourceReader GetResourceReader(CultureInfo info);
    public abstract virtual IResourceWriter GetResourceWriter(CultureInfo info);
}
public interface System.ComponentModel.Design.IRootDesigner {
    public ViewTechnology[] SupportedTechnologies { get; }
    public abstract virtual ViewTechnology[] get_SupportedTechnologies();
    public abstract virtual object GetView(ViewTechnology technology);
}
public interface System.ComponentModel.Design.ISelectionService {
    public object PrimarySelection { get; }
    public int SelectionCount { get; }
    public abstract virtual object get_PrimarySelection();
    public abstract virtual int get_SelectionCount();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectionChanging(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectionChanging(EventHandler value);
    public abstract virtual bool GetComponentSelected(object component);
    public abstract virtual ICollection GetSelectedComponents();
    public abstract virtual void SetSelectedComponents(ICollection components);
    public abstract virtual void SetSelectedComponents(ICollection components, SelectionTypes selectionType);
}
public interface System.ComponentModel.Design.IServiceContainer {
    public abstract virtual void AddService(Type serviceType, object serviceInstance);
    public abstract virtual void AddService(Type serviceType, object serviceInstance, bool promote);
    public abstract virtual void AddService(Type serviceType, ServiceCreatorCallback callback);
    public abstract virtual void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote);
    public abstract virtual void RemoveService(Type serviceType);
    public abstract virtual void RemoveService(Type serviceType, bool promote);
}
public interface System.ComponentModel.Design.ITreeDesigner {
    public ICollection Children { get; }
    public IDesigner Parent { get; }
    public abstract virtual ICollection get_Children();
    public abstract virtual IDesigner get_Parent();
}
public interface System.ComponentModel.Design.ITypeDescriptorFilterService {
    public abstract virtual bool FilterAttributes(IComponent component, IDictionary attributes);
    public abstract virtual bool FilterEvents(IComponent component, IDictionary events);
    public abstract virtual bool FilterProperties(IComponent component, IDictionary properties);
}
public interface System.ComponentModel.Design.ITypeDiscoveryService {
    public abstract virtual ICollection GetTypes(Type baseType, bool excludeGlobalTypes);
}
public interface System.ComponentModel.Design.ITypeResolutionService {
    public abstract virtual Assembly GetAssembly(AssemblyName name);
    public abstract virtual Assembly GetAssembly(AssemblyName name, bool throwOnError);
    public abstract virtual Type GetType(string name);
    public abstract virtual Type GetType(string name, bool throwOnError);
    public abstract virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public abstract virtual void ReferenceAssembly(AssemblyName name);
    public abstract virtual string GetPathOfAssembly(AssemblyName name);
}
public class System.ComponentModel.Design.MenuCommand : object {
    private EventHandler _execHandler;
    private int _status;
    private IDictionary _properties;
    private static int ENABLED;
    private static int INVISIBLE;
    private static int CHECKED;
    private static int SUPPORTED;
    [CompilerGeneratedAttribute]
private EventHandler CommandChanged;
    [CompilerGeneratedAttribute]
private CommandID <CommandID>k__BackingField;
    public bool Checked { get; public set; }
    public bool Enabled { get; public set; }
    public IDictionary Properties { get; }
    public bool Supported { get; public set; }
    public bool Visible { get; public set; }
    public CommandID CommandID { get; }
    public int OleStatus { get; }
    public MenuCommand(EventHandler handler, CommandID command);
    public virtual bool get_Checked();
    public virtual void set_Checked(bool value);
    public virtual bool get_Enabled();
    public virtual void set_Enabled(bool value);
    private void SetStatus(int mask, bool value);
    public virtual IDictionary get_Properties();
    public virtual bool get_Supported();
    public virtual void set_Supported(bool value);
    public virtual bool get_Visible();
    public virtual void set_Visible(bool value);
    [CompilerGeneratedAttribute]
public void add_CommandChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CommandChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual CommandID get_CommandID();
    public virtual void Invoke();
    public virtual void Invoke(object arg);
    public virtual int get_OleStatus();
    protected virtual void OnCommandChanged(EventArgs e);
    public virtual string ToString();
}
internal class System.ComponentModel.Design.RuntimeLicenseContext : LicenseContext {
    private static TraceSwitch s_runtimeLicenseContextSwitch;
    private static int ReadBlock;
    internal Hashtable savedLicenseKeys;
    private static RuntimeLicenseContext();
    private string GetLocalPath(string fileName);
    public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly);
    private Stream CaseInsensitiveManifestResourceStreamLookup(Assembly satellite, string name);
}
[FlagsAttribute]
public enum System.ComponentModel.Design.SelectionTypes : Enum {
    public int value__;
    public static SelectionTypes Auto;
    [ObsoleteAttribute("This value has been deprecated. Use SelectionTypes.Auto instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes Normal;
    public static SelectionTypes Replace;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes MouseDown;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes MouseUp;
    [ObsoleteAttribute("This value has been deprecated. Use SelectionTypes.Primary instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes Click;
    public static SelectionTypes Primary;
    public static SelectionTypes Toggle;
    public static SelectionTypes Add;
    public static SelectionTypes Remove;
    [ObsoleteAttribute("This value has been deprecated. Use Enum class methods to determine valid values, or use a type converter. http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes Valid;
}
public abstract class System.ComponentModel.Design.Serialization.ComponentSerializationService : object {
    public abstract virtual SerializationStore CreateStore();
    public abstract virtual SerializationStore LoadStore(Stream stream);
    public abstract virtual void Serialize(SerializationStore store, object value);
    public abstract virtual void SerializeAbsolute(SerializationStore store, object value);
    public abstract virtual void SerializeMember(SerializationStore store, object owningObject, MemberDescriptor member);
    public abstract virtual void SerializeMemberAbsolute(SerializationStore store, object owningObject, MemberDescriptor member);
    public abstract virtual ICollection Deserialize(SerializationStore store);
    public abstract virtual ICollection Deserialize(SerializationStore store, IContainer container);
    public abstract virtual void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes, bool applyDefaults);
    public void DeserializeTo(SerializationStore store, IContainer container);
    public void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.Design.Serialization.ContextStack : object {
    private ArrayList _contextStack;
    public object Current { get; }
    public object Item { get; }
    public object Item { get; }
    public object get_Current();
    public object get_Item(int level);
    public object get_Item(Type type);
    public void Append(object context);
    public object Pop();
    public void Push(object context);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.Design.Serialization.DefaultSerializationProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ProviderTypeName>k__BackingField;
    public string ProviderTypeName { get; }
    public DefaultSerializationProviderAttribute(Type providerType);
    public DefaultSerializationProviderAttribute(string providerTypeName);
    [CompilerGeneratedAttribute]
public string get_ProviderTypeName();
}
public abstract class System.ComponentModel.Design.Serialization.DesignerLoader : object {
    public bool Loading { get; }
    public virtual bool get_Loading();
    public abstract virtual void BeginLoad(IDesignerLoaderHost host);
    public abstract virtual void Dispose();
    public virtual void Flush();
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.Design.Serialization.DesignerSerializerAttribute : Attribute {
    private string _typeId;
    [CompilerGeneratedAttribute]
private string <SerializerTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializerBaseTypeName>k__BackingField;
    public string SerializerTypeName { get; }
    public string SerializerBaseTypeName { get; }
    public object TypeId { get; }
    public DesignerSerializerAttribute(Type serializerType, Type baseSerializerType);
    public DesignerSerializerAttribute(string serializerTypeName, Type baseSerializerType);
    public DesignerSerializerAttribute(string serializerTypeName, string baseSerializerTypeName);
    [CompilerGeneratedAttribute]
public string get_SerializerTypeName();
    [CompilerGeneratedAttribute]
public string get_SerializerBaseTypeName();
    public virtual object get_TypeId();
}
public interface System.ComponentModel.Design.Serialization.IDesignerLoaderHost {
    public abstract virtual void EndLoad(string baseClassName, bool successful, ICollection errorCollection);
    public abstract virtual void Reload();
}
public interface System.ComponentModel.Design.Serialization.IDesignerLoaderHost2 {
    public bool IgnoreErrorsDuringReload { get; public set; }
    public bool CanReloadWithErrors { get; public set; }
    public abstract virtual bool get_IgnoreErrorsDuringReload();
    public abstract virtual void set_IgnoreErrorsDuringReload(bool value);
    public abstract virtual bool get_CanReloadWithErrors();
    public abstract virtual void set_CanReloadWithErrors(bool value);
}
public interface System.ComponentModel.Design.Serialization.IDesignerLoaderService {
    public abstract virtual void AddLoadDependency();
    public abstract virtual void DependentLoadComplete(bool successful, ICollection errorCollection);
    public abstract virtual bool Reload();
}
public interface System.ComponentModel.Design.Serialization.IDesignerSerializationManager {
    public ContextStack Context { get; }
    public PropertyDescriptorCollection Properties { get; }
    public abstract virtual ContextStack get_Context();
    public abstract virtual PropertyDescriptorCollection get_Properties();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResolveName(ResolveNameEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResolveName(ResolveNameEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SerializationComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SerializationComplete(EventHandler value);
    public abstract virtual void AddSerializationProvider(IDesignerSerializationProvider provider);
    public abstract virtual object CreateInstance(Type type, ICollection arguments, string name, bool addToContainer);
    public abstract virtual object GetInstance(string name);
    public abstract virtual string GetName(object value);
    public abstract virtual object GetSerializer(Type objectType, Type serializerType);
    public abstract virtual Type GetType(string typeName);
    public abstract virtual void RemoveSerializationProvider(IDesignerSerializationProvider provider);
    public abstract virtual void ReportError(object errorInformation);
    public abstract virtual void SetName(object instance, string name);
}
public interface System.ComponentModel.Design.Serialization.IDesignerSerializationProvider {
    public abstract virtual object GetSerializer(IDesignerSerializationManager manager, object currentSerializer, Type objectType, Type serializerType);
}
public interface System.ComponentModel.Design.Serialization.IDesignerSerializationService {
    public abstract virtual ICollection Deserialize(object serializationData);
    public abstract virtual object Serialize(ICollection objects);
}
public interface System.ComponentModel.Design.Serialization.INameCreationService {
    public abstract virtual string CreateName(IContainer container, Type dataType);
    public abstract virtual bool IsValidName(string name);
    public abstract virtual void ValidateName(string name);
}
public class System.ComponentModel.Design.Serialization.InstanceDescriptor : object {
    [CompilerGeneratedAttribute]
private ICollection <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    public ICollection Arguments { get; }
    public bool IsComplete { get; }
    public MemberInfo MemberInfo { get; }
    public InstanceDescriptor(MemberInfo member, ICollection arguments);
    public InstanceDescriptor(MemberInfo member, ICollection arguments, bool isComplete);
    [CompilerGeneratedAttribute]
public ICollection get_Arguments();
    [CompilerGeneratedAttribute]
public bool get_IsComplete();
    [CompilerGeneratedAttribute]
public MemberInfo get_MemberInfo();
    public object Invoke();
}
[IsReadOnlyAttribute]
public class System.ComponentModel.Design.Serialization.MemberRelationship : ValueType {
    public static MemberRelationship Empty;
    [CompilerGeneratedAttribute]
private MemberDescriptor <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Owner>k__BackingField;
    public bool IsEmpty { get; }
    public MemberDescriptor Member { get; }
    public object Owner { get; }
    public MemberRelationship(object owner, MemberDescriptor member);
    private static MemberRelationship();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public MemberDescriptor get_Member();
    [CompilerGeneratedAttribute]
public object get_Owner();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberRelationship left, MemberRelationship right);
    public static bool op_Inequality(MemberRelationship left, MemberRelationship right);
}
[DefaultMemberAttribute("Item")]
public abstract class System.ComponentModel.Design.Serialization.MemberRelationshipService : object {
    private Dictionary`2<RelationshipEntry, RelationshipEntry> _relationships;
    public MemberRelationship Item { get; public set; }
    public MemberRelationship Item { get; public set; }
    public MemberRelationship get_Item(MemberRelationship source);
    public void set_Item(MemberRelationship source, MemberRelationship value);
    public MemberRelationship get_Item(object sourceOwner, MemberDescriptor sourceMember);
    public void set_Item(object sourceOwner, MemberDescriptor sourceMember, MemberRelationship value);
    protected virtual MemberRelationship GetRelationship(MemberRelationship source);
    protected virtual void SetRelationship(MemberRelationship source, MemberRelationship relationship);
    public abstract virtual bool SupportsRelationship(MemberRelationship source, MemberRelationship relationship);
}
public class System.ComponentModel.Design.Serialization.ResolveNameEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Name { get; }
    public object Value { get; public set; }
    public ResolveNameEventArgs(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public class System.ComponentModel.Design.Serialization.ResolveNameEventHandler : MulticastDelegate {
    public ResolveNameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ResolveNameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveNameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("This attribute has been deprecated. Use DesignerSerializerAttribute instead.  For example, to specify a root designer for CodeDom, use DesignerSerializerAttribute(...,typeof(TypeCodeDomSerializer)).  https://go.microsoft.com/fwlink/?linkid=14202")]
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.Design.Serialization.RootDesignerSerializerAttribute : Attribute {
    private string _typeId;
    [CompilerGeneratedAttribute]
private bool <Reloadable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializerTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializerBaseTypeName>k__BackingField;
    public bool Reloadable { get; }
    public string SerializerTypeName { get; }
    public string SerializerBaseTypeName { get; }
    public object TypeId { get; }
    public RootDesignerSerializerAttribute(Type serializerType, Type baseSerializerType, bool reloadable);
    public RootDesignerSerializerAttribute(string serializerTypeName, Type baseSerializerType, bool reloadable);
    public RootDesignerSerializerAttribute(string serializerTypeName, string baseSerializerTypeName, bool reloadable);
    [CompilerGeneratedAttribute]
public bool get_Reloadable();
    [CompilerGeneratedAttribute]
public string get_SerializerTypeName();
    [CompilerGeneratedAttribute]
public string get_SerializerBaseTypeName();
    public virtual object get_TypeId();
}
public abstract class System.ComponentModel.Design.Serialization.SerializationStore : object {
    public ICollection Errors { get; }
    public abstract virtual ICollection get_Errors();
    public abstract virtual void Close();
    public abstract virtual void Save(Stream stream);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.ComponentModel.Design.ServiceContainer : object {
    private ServiceCollection`1<object> _services;
    private IServiceProvider _parentProvider;
    private static Type[] s_defaultServices;
    private static TraceSwitch s_TRACESERVICE;
    private IServiceContainer Container { get; }
    protected Type[] DefaultServices { get; }
    private ServiceCollection`1<object> Services { get; }
    public ServiceContainer(IServiceProvider parentProvider);
    private static ServiceContainer();
    private IServiceContainer get_Container();
    protected virtual Type[] get_DefaultServices();
    private ServiceCollection`1<object> get_Services();
    public sealed virtual void AddService(Type serviceType, object serviceInstance);
    public virtual void AddService(Type serviceType, object serviceInstance, bool promote);
    public sealed virtual void AddService(Type serviceType, ServiceCreatorCallback callback);
    public virtual void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual object GetService(Type serviceType);
    public sealed virtual void RemoveService(Type serviceType);
    public virtual void RemoveService(Type serviceType, bool promote);
}
public class System.ComponentModel.Design.ServiceCreatorCallback : MulticastDelegate {
    public ServiceCreatorCallback(object object, IntPtr method);
    public virtual object Invoke(IServiceContainer container, Type serviceType);
    public virtual IAsyncResult BeginInvoke(IServiceContainer container, Type serviceType, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.StandardCommands : object {
    private static Guid s_standardCommandSet;
    private static Guid s_ndpCommandSet;
    private static int cmdidDesignerVerbFirst;
    private static int cmdidDesignerVerbLast;
    private static int cmdidArrangeIcons;
    private static int cmdidLineupIcons;
    private static int cmdidShowLargeIcons;
    public static CommandID AlignBottom;
    public static CommandID AlignHorizontalCenters;
    public static CommandID AlignLeft;
    public static CommandID AlignRight;
    public static CommandID AlignToGrid;
    public static CommandID AlignTop;
    public static CommandID AlignVerticalCenters;
    public static CommandID ArrangeBottom;
    public static CommandID ArrangeRight;
    public static CommandID BringForward;
    public static CommandID BringToFront;
    public static CommandID CenterHorizontally;
    public static CommandID CenterVertically;
    public static CommandID ViewCode;
    public static CommandID DocumentOutline;
    public static CommandID Copy;
    public static CommandID Cut;
    public static CommandID Delete;
    public static CommandID Group;
    public static CommandID HorizSpaceConcatenate;
    public static CommandID HorizSpaceDecrease;
    public static CommandID HorizSpaceIncrease;
    public static CommandID HorizSpaceMakeEqual;
    public static CommandID Paste;
    public static CommandID Properties;
    public static CommandID Redo;
    public static CommandID MultiLevelRedo;
    public static CommandID SelectAll;
    public static CommandID SendBackward;
    public static CommandID SendToBack;
    public static CommandID SizeToControl;
    public static CommandID SizeToControlHeight;
    public static CommandID SizeToControlWidth;
    public static CommandID SizeToFit;
    public static CommandID SizeToGrid;
    public static CommandID SnapToGrid;
    public static CommandID TabOrder;
    public static CommandID Undo;
    public static CommandID MultiLevelUndo;
    public static CommandID Ungroup;
    public static CommandID VertSpaceConcatenate;
    public static CommandID VertSpaceDecrease;
    public static CommandID VertSpaceIncrease;
    public static CommandID VertSpaceMakeEqual;
    public static CommandID ShowGrid;
    public static CommandID ViewGrid;
    public static CommandID Replace;
    public static CommandID PropertiesWindow;
    public static CommandID LockControls;
    public static CommandID F1Help;
    public static CommandID ArrangeIcons;
    public static CommandID LineupIcons;
    public static CommandID ShowLargeIcons;
    public static CommandID VerbFirst;
    public static CommandID VerbLast;
    private static StandardCommands();
}
public class System.ComponentModel.Design.StandardToolWindows : object {
    public static Guid ObjectBrowser;
    public static Guid OutputWindow;
    public static Guid ProjectExplorer;
    public static Guid PropertyBrowser;
    public static Guid RelatedLinks;
    public static Guid ServerExplorer;
    public static Guid TaskList;
    public static Guid Toolbox;
    private static StandardToolWindows();
}
public abstract class System.ComponentModel.Design.TypeDescriptionProviderService : object {
    public abstract virtual TypeDescriptionProvider GetProvider(object instance);
    public abstract virtual TypeDescriptionProvider GetProvider(Type type);
}
public enum System.ComponentModel.Design.ViewTechnology : Enum {
    public int value__;
    [ObsoleteAttribute("This value has been deprecated. Use ViewTechnology.Default instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static ViewTechnology Passthrough;
    [ObsoleteAttribute("This value has been deprecated. Use ViewTechnology.Default instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static ViewTechnology WindowsForms;
    public static ViewTechnology Default;
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.DesignerAttribute : Attribute {
    private string designerTypeName;
    private string designerBaseTypeName;
    private string typeId;
    public string DesignerBaseTypeName { get; }
    public string DesignerTypeName { get; }
    public object TypeId { get; }
    public DesignerAttribute(string designerTypeName);
    public DesignerAttribute(Type designerType);
    public DesignerAttribute(string designerTypeName, string designerBaseTypeName);
    public DesignerAttribute(string designerTypeName, Type designerBaseType);
    public DesignerAttribute(Type designerType, Type designerBaseType);
    public string get_DesignerBaseTypeName();
    public string get_DesignerTypeName();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DesignerCategoryAttribute : Attribute {
    public static DesignerCategoryAttribute Component;
    public static DesignerCategoryAttribute Default;
    public static DesignerCategoryAttribute Form;
    public static DesignerCategoryAttribute Generic;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    public string Category { get; }
    public object TypeId { get; }
    public DesignerCategoryAttribute(string category);
    private static DesignerCategoryAttribute();
    [CompilerGeneratedAttribute]
public string get_Category();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
    public virtual object get_TypeId();
}
public enum System.ComponentModel.DesignerSerializationVisibility : Enum {
    public int value__;
    public static DesignerSerializationVisibility Hidden;
    public static DesignerSerializationVisibility Visible;
    public static DesignerSerializationVisibility Content;
}
[AttributeUsageAttribute("960")]
public class System.ComponentModel.DesignerSerializationVisibilityAttribute : Attribute {
    public static DesignerSerializationVisibilityAttribute Content;
    public static DesignerSerializationVisibilityAttribute Hidden;
    public static DesignerSerializationVisibilityAttribute Visible;
    public static DesignerSerializationVisibilityAttribute Default;
    [CompilerGeneratedAttribute]
private DesignerSerializationVisibility <Visibility>k__BackingField;
    public DesignerSerializationVisibility Visibility { get; }
    public DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility visibility);
    private static DesignerSerializationVisibilityAttribute();
    [CompilerGeneratedAttribute]
public DesignerSerializationVisibility get_Visibility();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DesignOnlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsDesignOnly>k__BackingField;
    public static DesignOnlyAttribute Yes;
    public static DesignOnlyAttribute No;
    public static DesignOnlyAttribute Default;
    public bool IsDesignOnly { get; }
    public DesignOnlyAttribute(bool isDesignOnly);
    private static DesignOnlyAttribute();
    [CompilerGeneratedAttribute]
public bool get_IsDesignOnly();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.DesignTimeVisibleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Visible>k__BackingField;
    public static DesignTimeVisibleAttribute Yes;
    public static DesignTimeVisibleAttribute No;
    public static DesignTimeVisibleAttribute Default;
    public bool Visible { get; }
    public DesignTimeVisibleAttribute(bool visible);
    private static DesignTimeVisibleAttribute();
    [CompilerGeneratedAttribute]
public bool get_Visible();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("708")]
public class System.ComponentModel.DisplayNameAttribute : Attribute {
    public static DisplayNameAttribute Default;
    [CompilerGeneratedAttribute]
private string <DisplayNameValue>k__BackingField;
    public string DisplayName { get; }
    protected string DisplayNameValue { get; protected set; }
    public DisplayNameAttribute(string displayName);
    private static DisplayNameAttribute();
    public virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
protected string get_DisplayNameValue();
    [CompilerGeneratedAttribute]
protected void set_DisplayNameValue(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.DoubleConverter : BaseNumberConverter {
    internal bool AllowHex { get; }
    internal Type TargetType { get; }
    internal virtual bool get_AllowHex();
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.DoWorkEventArgs : CancelEventArgs {
    private object result;
    private object argument;
    [SRDescriptionAttribute("Argument passed into the worker handler from BackgroundWorker.RunWorkerAsync.")]
public object Argument { get; }
    [SRDescriptionAttribute("Result from the worker function.")]
public object Result { get; public set; }
    public DoWorkEventArgs(object argument);
    public object get_Argument();
    public object get_Result();
    public void set_Result(object value);
}
public class System.ComponentModel.DoWorkEventHandler : MulticastDelegate {
    public DoWorkEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DoWorkEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DoWorkEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.EditorAttribute : Attribute {
    private string _typeId;
    [CompilerGeneratedAttribute]
private string <EditorBaseTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EditorTypeName>k__BackingField;
    public string EditorBaseTypeName { get; }
    public string EditorTypeName { get; }
    public object TypeId { get; }
    public EditorAttribute(string typeName, string baseTypeName);
    public EditorAttribute(string typeName, Type baseType);
    public EditorAttribute(Type type, Type baseType);
    [CompilerGeneratedAttribute]
public string get_EditorBaseTypeName();
    [CompilerGeneratedAttribute]
public string get_EditorTypeName();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    private EditorBrowsableState browsableState;
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    public EditorBrowsableState get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
    public static EditorBrowsableState Advanced;
}
public class System.ComponentModel.EnumConverter : TypeConverter {
    private StandardValuesCollection values;
    private Type type;
    protected Type EnumType { get; }
    protected StandardValuesCollection Values { get; protected set; }
    protected IComparer Comparer { get; }
    public EnumConverter(Type type);
    protected Type get_EnumType();
    protected StandardValuesCollection get_Values();
    protected void set_Values(StandardValuesCollection value);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    protected virtual IComparer get_Comparer();
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
public abstract class System.ComponentModel.EventDescriptor : MemberDescriptor {
    public Type ComponentType { get; }
    public Type EventType { get; }
    public bool IsMulticast { get; }
    protected EventDescriptor(string name, Attribute[] attrs);
    protected EventDescriptor(MemberDescriptor descr);
    protected EventDescriptor(MemberDescriptor descr, Attribute[] attrs);
    public abstract virtual Type get_ComponentType();
    public abstract virtual Type get_EventType();
    public abstract virtual bool get_IsMulticast();
    public abstract virtual void AddEventHandler(object component, Delegate value);
    public abstract virtual void RemoveEventHandler(object component, Delegate value);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.EventDescriptorCollection : object {
    private EventDescriptor[] _events;
    private String[] _namedSort;
    private IComparer _comparer;
    private bool _eventsOwned;
    private bool _needSort;
    private bool _readOnly;
    public static EventDescriptorCollection Empty;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public EventDescriptor Item { get; }
    public EventDescriptor Item { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public EventDescriptorCollection(EventDescriptor[] events);
    public EventDescriptorCollection(EventDescriptor[] events, bool readOnly);
    private EventDescriptorCollection(EventDescriptor[] events, int eventCount, String[] namedSort, IComparer comparer);
    private static EventDescriptorCollection();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public virtual EventDescriptor get_Item(int index);
    public virtual EventDescriptor get_Item(string name);
    public int Add(EventDescriptor value);
    public void Clear();
    public bool Contains(EventDescriptor value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private void EnsureEventsOwned();
    private void EnsureSize(int sizeNeeded);
    public virtual EventDescriptor Find(string name, bool ignoreCase);
    public int IndexOf(EventDescriptor value);
    public void Insert(int index, EventDescriptor value);
    public void Remove(EventDescriptor value);
    public void RemoveAt(int index);
    public IEnumerator GetEnumerator();
    public virtual EventDescriptorCollection Sort();
    public virtual EventDescriptorCollection Sort(String[] names);
    public virtual EventDescriptorCollection Sort(String[] names, IComparer comparer);
    public virtual EventDescriptorCollection Sort(IComparer comparer);
    protected void InternalSort(String[] names);
    protected void InternalSort(IComparer sorter);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.EventHandlerList : object {
    private ListEntry _head;
    private Component _parent;
    public Delegate Item { get; public set; }
    internal EventHandlerList(Component parent);
    public Delegate get_Item(object key);
    public void set_Item(object key, Delegate value);
    public void AddHandler(object key, Delegate value);
    public void AddHandlers(EventHandlerList listToAddFrom);
    public sealed virtual void Dispose();
    private ListEntry Find(object key);
    public void RemoveHandler(object key, Delegate value);
}
public class System.ComponentModel.ExpandableObjectConverter : TypeConverter {
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
internal class System.ComponentModel.ExtendedPropertyDescriptor : PropertyDescriptor {
    private ReflectPropertyDescriptor _extenderInfo;
    private IExtenderProvider _provider;
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public string DisplayName { get; }
    public ExtendedPropertyDescriptor(ReflectPropertyDescriptor extenderInfo, Type receiverType, IExtenderProvider provider, Attribute[] attributes);
    public ExtendedPropertyDescriptor(PropertyDescriptor extender, Attribute[] attributes);
    public virtual bool CanResetValue(object comp);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual string get_DisplayName();
    public virtual object GetValue(object comp);
    public virtual void ResetValue(object comp);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object comp);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ExtenderProvidedPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private PropertyDescriptor <ExtenderProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IExtenderProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReceiverType>k__BackingField;
    public PropertyDescriptor ExtenderProperty { get; private set; }
    public IExtenderProvider Provider { get; private set; }
    public Type ReceiverType { get; private set; }
    internal static ExtenderProvidedPropertyAttribute Create(PropertyDescriptor extenderProperty, Type receiverType, IExtenderProvider provider);
    [CompilerGeneratedAttribute]
public PropertyDescriptor get_ExtenderProperty();
    [CompilerGeneratedAttribute]
private void set_ExtenderProperty(PropertyDescriptor value);
    [CompilerGeneratedAttribute]
public IExtenderProvider get_Provider();
    [CompilerGeneratedAttribute]
private void set_Provider(IExtenderProvider value);
    [CompilerGeneratedAttribute]
public Type get_ReceiverType();
    [CompilerGeneratedAttribute]
private void set_ReceiverType(Type value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.GuidConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ComponentModel.HandledEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    public bool Handled { get; public set; }
    public HandledEventArgs(bool defaultHandledValue);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
public class System.ComponentModel.HandledEventHandler : MulticastDelegate {
    public HandledEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, HandledEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, HandledEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.ComponentModel.IBindingList {
    public bool AllowNew { get; }
    public bool AllowEdit { get; }
    public bool AllowRemove { get; }
    public bool SupportsChangeNotification { get; }
    public bool SupportsSearching { get; }
    public bool SupportsSorting { get; }
    public bool IsSorted { get; }
    public PropertyDescriptor SortProperty { get; }
    public ListSortDirection SortDirection { get; }
    public abstract virtual bool get_AllowNew();
    public abstract virtual object AddNew();
    public abstract virtual bool get_AllowEdit();
    public abstract virtual bool get_AllowRemove();
    public abstract virtual bool get_SupportsChangeNotification();
    public abstract virtual bool get_SupportsSearching();
    public abstract virtual bool get_SupportsSorting();
    public abstract virtual bool get_IsSorted();
    public abstract virtual PropertyDescriptor get_SortProperty();
    public abstract virtual ListSortDirection get_SortDirection();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ListChanged(ListChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ListChanged(ListChangedEventHandler value);
    public abstract virtual void AddIndex(PropertyDescriptor property);
    public abstract virtual void ApplySort(PropertyDescriptor property, ListSortDirection direction);
    public abstract virtual int Find(PropertyDescriptor property, object key);
    public abstract virtual void RemoveIndex(PropertyDescriptor property);
    public abstract virtual void RemoveSort();
}
public interface System.ComponentModel.IBindingListView {
    public string Filter { get; public set; }
    public ListSortDescriptionCollection SortDescriptions { get; }
    public bool SupportsAdvancedSorting { get; }
    public bool SupportsFiltering { get; }
    public abstract virtual void ApplySort(ListSortDescriptionCollection sorts);
    public abstract virtual string get_Filter();
    public abstract virtual void set_Filter(string value);
    public abstract virtual ListSortDescriptionCollection get_SortDescriptions();
    public abstract virtual void RemoveFilter();
    public abstract virtual bool get_SupportsAdvancedSorting();
    public abstract virtual bool get_SupportsFiltering();
}
public interface System.ComponentModel.ICancelAddNew {
    public abstract virtual void CancelNew(int itemIndex);
    public abstract virtual void EndNew(int itemIndex);
}
public interface System.ComponentModel.IChangeTracking {
    public bool IsChanged { get; }
    public abstract virtual bool get_IsChanged();
    public abstract virtual void AcceptChanges();
}
[ObsoleteAttribute("This interface has been deprecated. Add a TypeDescriptionProvider to handle type TypeDescriptor.ComObjectType instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public interface System.ComponentModel.IComNativeDescriptorHandler {
    public abstract virtual AttributeCollection GetAttributes(object component);
    public abstract virtual string GetClassName(object component);
    public abstract virtual TypeConverter GetConverter(object component);
    public abstract virtual EventDescriptor GetDefaultEvent(object component);
    public abstract virtual PropertyDescriptor GetDefaultProperty(object component);
    public abstract virtual object GetEditor(object component, Type baseEditorType);
    public abstract virtual string GetName(object component);
    public abstract virtual EventDescriptorCollection GetEvents(object component);
    public abstract virtual EventDescriptorCollection GetEvents(object component, Attribute[] attributes);
    public abstract virtual PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes);
    public abstract virtual object GetPropertyValue(object component, string propertyName, Boolean& success);
    public abstract virtual object GetPropertyValue(object component, int dispid, Boolean& success);
}
[DesignerAttribute("System.Windows.Forms.Design.ComponentDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")]
[ComVisibleAttribute("True")]
[DesignerAttribute("System.ComponentModel.Design.ComponentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IDesigner")]
[RootDesignerSerializerAttribute("System.ComponentModel.Design.Serialization.RootCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "True")]
[TypeConverterAttribute("System.ComponentModel.ComponentConverter")]
public interface System.ComponentModel.IComponent {
    public ISite Site { get; public set; }
    public abstract virtual ISite get_Site();
    public abstract virtual void set_Site(ISite value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Disposed(EventHandler value);
}
public interface System.ComponentModel.IContainer {
    public ComponentCollection Components { get; }
    public abstract virtual void Add(IComponent component);
    public abstract virtual void Add(IComponent component, string name);
    public abstract virtual ComponentCollection get_Components();
    public abstract virtual void Remove(IComponent component);
}
public interface System.ComponentModel.ICustomTypeDescriptor {
    public abstract virtual AttributeCollection GetAttributes();
    public abstract virtual string GetClassName();
    public abstract virtual string GetComponentName();
    public abstract virtual TypeConverter GetConverter();
    public abstract virtual EventDescriptor GetDefaultEvent();
    public abstract virtual PropertyDescriptor GetDefaultProperty();
    public abstract virtual object GetEditor(Type editorBaseType);
    public abstract virtual EventDescriptorCollection GetEvents();
    public abstract virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public abstract virtual PropertyDescriptorCollection GetProperties();
    public abstract virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public abstract virtual object GetPropertyOwner(PropertyDescriptor pd);
}
[DefaultMemberAttribute("Item")]
public interface System.ComponentModel.IDataErrorInfo {
    public string Item { get; }
    public string Error { get; }
    public abstract virtual string get_Item(string columnName);
    public abstract virtual string get_Error();
}
public interface System.ComponentModel.IEditableObject {
    public abstract virtual void BeginEdit();
    public abstract virtual void EndEdit();
    public abstract virtual void CancelEdit();
}
public interface System.ComponentModel.IExtenderProvider {
    public abstract virtual bool CanExtend(object extendee);
}
public interface System.ComponentModel.IIntellisenseBuilder {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool Show(string language, string value, String& newValue);
}
[MergablePropertyAttribute("False")]
public interface System.ComponentModel.IListSource {
    public bool ContainsListCollection { get; }
    public abstract virtual bool get_ContainsListCollection();
    public abstract virtual IList GetList();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ImmutableObjectAttribute : Attribute {
    public static ImmutableObjectAttribute Yes;
    public static ImmutableObjectAttribute No;
    public static ImmutableObjectAttribute Default;
    [CompilerGeneratedAttribute]
private bool <Immutable>k__BackingField;
    public bool Immutable { get; }
    public ImmutableObjectAttribute(bool immutable);
    private static ImmutableObjectAttribute();
    [CompilerGeneratedAttribute]
public bool get_Immutable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public interface System.ComponentModel.INestedContainer {
    public IComponent Owner { get; }
    public abstract virtual IComponent get_Owner();
}
public interface System.ComponentModel.INestedSite {
    public string FullName { get; }
    public abstract virtual string get_FullName();
}
[AttributeUsageAttribute("896")]
public class System.ComponentModel.InheritanceAttribute : Attribute {
    public static InheritanceAttribute Inherited;
    public static InheritanceAttribute InheritedReadOnly;
    public static InheritanceAttribute NotInherited;
    public static InheritanceAttribute Default;
    [CompilerGeneratedAttribute]
private InheritanceLevel <InheritanceLevel>k__BackingField;
    public InheritanceLevel InheritanceLevel { get; }
    public InheritanceAttribute(InheritanceLevel inheritanceLevel);
    private static InheritanceAttribute();
    [CompilerGeneratedAttribute]
public InheritanceLevel get_InheritanceLevel();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
    public virtual string ToString();
}
public enum System.ComponentModel.InheritanceLevel : Enum {
    public int value__;
    public static InheritanceLevel Inherited;
    public static InheritanceLevel InheritedReadOnly;
    public static InheritanceLevel NotInherited;
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.InitializationEventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    public string EventName { get; }
    public InitializationEventAttribute(string eventName);
    [CompilerGeneratedAttribute]
public string get_EventName();
}
public interface System.ComponentModel.INotifyDataErrorInfo {
    public bool HasErrors { get; }
    public abstract virtual bool get_HasErrors();
    public abstract virtual IEnumerable GetErrors(string propertyName);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
}
public interface System.ComponentModel.INotifyPropertyChanged {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public interface System.ComponentModel.INotifyPropertyChanging {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.InstallerTypeAttribute : Attribute {
    private string _typeName;
    public Type InstallerType { get; }
    public InstallerTypeAttribute(Type installerType);
    public InstallerTypeAttribute(string typeName);
    public virtual Type get_InstallerType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class System.ComponentModel.InstanceCreationEditor : object {
    public string Text { get; }
    public virtual string get_Text();
    public abstract virtual object CreateInstance(ITypeDescriptorContext context, Type instanceType);
}
public class System.ComponentModel.Int16Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.Int32Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.Int64Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
internal static class System.ComponentModel.IntSecurity : object {
    public static string UnsafeGetFullPath(string fileName);
}
public class System.ComponentModel.InvalidAsynchronousStateException : ArgumentException {
    public InvalidAsynchronousStateException(string message);
    public InvalidAsynchronousStateException(string message, Exception innerException);
    protected InvalidAsynchronousStateException(SerializationInfo info, StreamingContext context);
}
public class System.ComponentModel.InvalidEnumArgumentException : ArgumentException {
    public InvalidEnumArgumentException(string message);
    public InvalidEnumArgumentException(string message, Exception innerException);
    public InvalidEnumArgumentException(string argumentName, int invalidValue, Type enumClass);
    protected InvalidEnumArgumentException(SerializationInfo info, StreamingContext context);
}
public interface System.ComponentModel.IRaiseItemChangedEvents {
    public bool RaisesItemChangedEvents { get; }
    public abstract virtual bool get_RaisesItemChangedEvents();
}
public interface System.ComponentModel.IRevertibleChangeTracking {
    public abstract virtual void RejectChanges();
}
public interface System.ComponentModel.ISite {
    public IComponent Component { get; }
    public IContainer Container { get; }
    public bool DesignMode { get; }
    public string Name { get; public set; }
    public abstract virtual IComponent get_Component();
    public abstract virtual IContainer get_Container();
    public abstract virtual bool get_DesignMode();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public interface System.ComponentModel.ISupportInitialize {
    public abstract virtual void BeginInit();
    public abstract virtual void EndInit();
}
public interface System.ComponentModel.ISupportInitializeNotification {
    public bool IsInitialized { get; }
    public abstract virtual bool get_IsInitialized();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Initialized(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Initialized(EventHandler value);
}
public interface System.ComponentModel.ISynchronizeInvoke {
    public bool InvokeRequired { get; }
    public abstract virtual bool get_InvokeRequired();
    public abstract virtual IAsyncResult BeginInvoke(Delegate method, Object[] args);
    public abstract virtual object EndInvoke(IAsyncResult result);
    public abstract virtual object Invoke(Delegate method, Object[] args);
}
public interface System.ComponentModel.ITypeDescriptorContext {
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public abstract virtual IContainer get_Container();
    public abstract virtual object get_Instance();
    public abstract virtual PropertyDescriptor get_PropertyDescriptor();
    public abstract virtual bool OnComponentChanging();
    public abstract virtual void OnComponentChanged();
}
public interface System.ComponentModel.ITypedList {
    public abstract virtual string GetListName(PropertyDescriptor[] listAccessors);
    public abstract virtual PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors);
}
public abstract class System.ComponentModel.License : object {
    public string LicenseKey { get; }
    public abstract virtual string get_LicenseKey();
    public abstract virtual void Dispose();
}
public class System.ComponentModel.LicenseContext : object {
    public LicenseUsageMode UsageMode { get; }
    public virtual LicenseUsageMode get_UsageMode();
    public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly);
    public virtual object GetService(Type type);
    public virtual void SetSavedLicenseKey(Type type, string key);
}
public class System.ComponentModel.LicenseException : SystemException {
    private Type type;
    private object instance;
    public Type LicensedType { get; }
    public LicenseException(Type type);
    public LicenseException(Type type, object instance);
    public LicenseException(Type type, object instance, string message);
    public LicenseException(Type type, object instance, string message, Exception innerException);
    protected LicenseException(SerializationInfo info, StreamingContext context);
    public Type get_LicensedType();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ComponentModel.LicenseManager : object {
    private static object s_selfLock;
    private static LicenseContext modreq(System.Runtime.CompilerServices.IsVolatile) s_context;
    private static object s_contextLockHolder;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) s_providers;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) s_providerInstances;
    private static object s_internalSyncObject;
    public static LicenseContext CurrentContext { get; public set; }
    public static LicenseUsageMode UsageMode { get; }
    private static LicenseManager();
    public static LicenseContext get_CurrentContext();
    public static void set_CurrentContext(LicenseContext value);
    public static LicenseUsageMode get_UsageMode();
    private static void CacheProvider(Type type, LicenseProvider provider);
    public static object CreateWithContext(Type type, LicenseContext creationContext);
    public static object CreateWithContext(Type type, LicenseContext creationContext, Object[] args);
    private static bool GetCachedNoLicenseProvider(Type type);
    private static LicenseProvider GetCachedProvider(Type type);
    private static LicenseProvider GetCachedProviderInstance(Type providerType);
    public static bool IsLicensed(Type type);
    public static bool IsValid(Type type);
    public static bool IsValid(Type type, object instance, License& license);
    public static void LockContext(object contextUser);
    public static void UnlockContext(object contextUser);
    private static bool ValidateInternal(Type type, object instance, bool allowExceptions, License& license);
    private static bool ValidateInternalRecursive(LicenseContext context, Type type, object instance, bool allowExceptions, License& license, String& licenseKey);
    public static void Validate(Type type);
    public static License Validate(Type type, object instance);
}
public abstract class System.ComponentModel.LicenseProvider : object {
    public abstract virtual License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.LicenseProviderAttribute : Attribute {
    public static LicenseProviderAttribute Default;
    private Type _licenseProviderType;
    private string _licenseProviderName;
    public Type LicenseProvider { get; }
    public object TypeId { get; }
    public LicenseProviderAttribute(string typeName);
    public LicenseProviderAttribute(Type type);
    private static LicenseProviderAttribute();
    public Type get_LicenseProvider();
    public virtual object get_TypeId();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.LicenseUsageMode : Enum {
    public int value__;
    public static LicenseUsageMode Runtime;
    public static LicenseUsageMode Designtime;
}
public class System.ComponentModel.LicFileLicenseProvider : LicenseProvider {
    protected virtual bool IsKeyValid(string key, Type type);
    protected virtual string GetKey(Type type);
    public virtual License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ListBindableAttribute : Attribute {
    public static ListBindableAttribute Yes;
    public static ListBindableAttribute No;
    public static ListBindableAttribute Default;
    private bool _isDefault;
    [CompilerGeneratedAttribute]
private bool <ListBindable>k__BackingField;
    public bool ListBindable { get; }
    public ListBindableAttribute(bool listBindable);
    public ListBindableAttribute(BindableSupport flags);
    private static ListBindableAttribute();
    [CompilerGeneratedAttribute]
public bool get_ListBindable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ListChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ListChangedType <ListChangedType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OldIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyDescriptor <PropertyDescriptor>k__BackingField;
    public ListChangedType ListChangedType { get; }
    public int NewIndex { get; }
    public int OldIndex { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public ListChangedEventArgs(ListChangedType listChangedType, int newIndex);
    public ListChangedEventArgs(ListChangedType listChangedType, int newIndex, PropertyDescriptor propDesc);
    public ListChangedEventArgs(ListChangedType listChangedType, PropertyDescriptor propDesc);
    public ListChangedEventArgs(ListChangedType listChangedType, int newIndex, int oldIndex);
    [CompilerGeneratedAttribute]
public ListChangedType get_ListChangedType();
    [CompilerGeneratedAttribute]
public int get_NewIndex();
    [CompilerGeneratedAttribute]
public int get_OldIndex();
    [CompilerGeneratedAttribute]
public PropertyDescriptor get_PropertyDescriptor();
}
public class System.ComponentModel.ListChangedEventHandler : MulticastDelegate {
    public ListChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ListChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ListChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ComponentModel.ListChangedType : Enum {
    public int value__;
    public static ListChangedType Reset;
    public static ListChangedType ItemAdded;
    public static ListChangedType ItemDeleted;
    public static ListChangedType ItemMoved;
    public static ListChangedType ItemChanged;
    public static ListChangedType PropertyDescriptorAdded;
    public static ListChangedType PropertyDescriptorDeleted;
    public static ListChangedType PropertyDescriptorChanged;
}
public class System.ComponentModel.ListSortDescription : object {
    [CompilerGeneratedAttribute]
private PropertyDescriptor <PropertyDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ListSortDirection <SortDirection>k__BackingField;
    public PropertyDescriptor PropertyDescriptor { get; public set; }
    public ListSortDirection SortDirection { get; public set; }
    public ListSortDescription(PropertyDescriptor property, ListSortDirection direction);
    [CompilerGeneratedAttribute]
public PropertyDescriptor get_PropertyDescriptor();
    [CompilerGeneratedAttribute]
public void set_PropertyDescriptor(PropertyDescriptor value);
    [CompilerGeneratedAttribute]
public ListSortDirection get_SortDirection();
    [CompilerGeneratedAttribute]
public void set_SortDirection(ListSortDirection value);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.ListSortDescriptionCollection : object {
    private ArrayList _sorts;
    public ListSortDescription Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ListSortDescriptionCollection(ListSortDescription[] sorts);
    public ListSortDescription get_Item(int index);
    public void set_Item(int index, ListSortDescription value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.ComponentModel.ListSortDirection : Enum {
    public int value__;
    public static ListSortDirection Ascending;
    public static ListSortDirection Descending;
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.LocalizableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsLocalizable>k__BackingField;
    public static LocalizableAttribute Yes;
    public static LocalizableAttribute No;
    public static LocalizableAttribute Default;
    public bool IsLocalizable { get; }
    public LocalizableAttribute(bool isLocalizable);
    private static LocalizableAttribute();
    [CompilerGeneratedAttribute]
public bool get_IsLocalizable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.LookupBindingPropertiesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DataSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayMember>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueMember>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LookupMember>k__BackingField;
    public static LookupBindingPropertiesAttribute Default;
    public string DataSource { get; }
    public string DisplayMember { get; }
    public string ValueMember { get; }
    public string LookupMember { get; }
    public LookupBindingPropertiesAttribute(string dataSource, string displayMember, string valueMember, string lookupMember);
    private static LookupBindingPropertiesAttribute();
    [CompilerGeneratedAttribute]
public string get_DataSource();
    [CompilerGeneratedAttribute]
public string get_DisplayMember();
    [CompilerGeneratedAttribute]
public string get_ValueMember();
    [CompilerGeneratedAttribute]
public string get_LookupMember();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeConverterAttribute("System.ComponentModel.ComponentConverter")]
[DesignerCategoryAttribute("Component")]
[DesignerAttribute("System.Windows.Forms.Design.ComponentDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")]
public class System.ComponentModel.MarshalByValueComponent : object {
    private static object s_eventDisposed;
    private ISite _site;
    private EventHandlerList _events;
    protected EventHandlerList Events { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ISite Site { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IContainer Container { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool DesignMode { get; }
    private static MarshalByValueComponent();
    protected virtual override void Finalize();
    public sealed virtual void add_Disposed(EventHandler value);
    public sealed virtual void remove_Disposed(EventHandler value);
    protected EventHandlerList get_Events();
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual IContainer get_Container();
    public virtual object GetService(Type service);
    public virtual bool get_DesignMode();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.MaskedTextProvider : object {
    private static char SPACE_CHAR;
    private static char DEFAULT_PROMPT_CHAR;
    private static char NULL_PASSWORD_CHAR;
    private static bool DEFAULT_ALLOW_PROMPT;
    private static int INVALID_INDEX;
    private static byte EDIT_ANY;
    private static byte EDIT_UNASSIGNED;
    private static byte EDIT_ASSIGNED;
    private static bool FORWARD;
    private static bool BACKWARD;
    private static int s_ASCII_ONLY;
    private static int s_ALLOW_PROMPT_AS_INPUT;
    private static int s_INCLUDE_PROMPT;
    private static int s_INCLUDE_LITERALS;
    private static int s_RESET_ON_PROMPT;
    private static int s_RESET_ON_LITERALS;
    private static int s_SKIP_SPACE;
    private static Type s_maskTextProviderType;
    private BitVector32 _flagState;
    private StringBuilder _testString;
    private int _requiredCharCount;
    private int _requiredEditChars;
    private int _optionalEditChars;
    private char _passwordChar;
    private char _promptChar;
    private List`1<CharDescriptor> _stringDescriptor;
    [CompilerGeneratedAttribute]
private int <AssignedEditPositionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Mask>k__BackingField;
    public bool AllowPromptAsInput { get; }
    public int AssignedEditPositionCount { get; private set; }
    public int AvailableEditPositionCount { get; }
    public CultureInfo Culture { get; }
    public static char DefaultPasswordChar { get; }
    public int EditPositionCount { get; }
    public IEnumerator EditPositions { get; }
    public bool IncludeLiterals { get; public set; }
    public bool IncludePrompt { get; public set; }
    public bool AsciiOnly { get; }
    public bool IsPassword { get; public set; }
    public static int InvalidIndex { get; }
    public int LastAssignedPosition { get; }
    public int Length { get; }
    public string Mask { get; }
    public bool MaskCompleted { get; }
    public bool MaskFull { get; }
    public char PasswordChar { get; public set; }
    public char PromptChar { get; public set; }
    public bool ResetOnPrompt { get; public set; }
    public bool ResetOnSpace { get; public set; }
    public bool SkipLiterals { get; public set; }
    public char Item { get; }
    public MaskedTextProvider(string mask);
    public MaskedTextProvider(string mask, bool restrictToAscii);
    public MaskedTextProvider(string mask, CultureInfo culture);
    public MaskedTextProvider(string mask, CultureInfo culture, bool restrictToAscii);
    public MaskedTextProvider(string mask, char passwordChar, bool allowPromptAsInput);
    public MaskedTextProvider(string mask, CultureInfo culture, char passwordChar, bool allowPromptAsInput);
    public MaskedTextProvider(string mask, CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);
    private static MaskedTextProvider();
    private void Initialize();
    public bool get_AllowPromptAsInput();
    [CompilerGeneratedAttribute]
public int get_AssignedEditPositionCount();
    [CompilerGeneratedAttribute]
private void set_AssignedEditPositionCount(int value);
    public int get_AvailableEditPositionCount();
    public sealed virtual object Clone();
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    public static char get_DefaultPasswordChar();
    public int get_EditPositionCount();
    public IEnumerator get_EditPositions();
    public bool get_IncludeLiterals();
    public void set_IncludeLiterals(bool value);
    public bool get_IncludePrompt();
    public void set_IncludePrompt(bool value);
    public bool get_AsciiOnly();
    public bool get_IsPassword();
    public void set_IsPassword(bool value);
    public static int get_InvalidIndex();
    public int get_LastAssignedPosition();
    public int get_Length();
    [CompilerGeneratedAttribute]
public string get_Mask();
    public bool get_MaskCompleted();
    public bool get_MaskFull();
    public char get_PasswordChar();
    public void set_PasswordChar(char value);
    public char get_PromptChar();
    public void set_PromptChar(char value);
    public bool get_ResetOnPrompt();
    public void set_ResetOnPrompt(bool value);
    public bool get_ResetOnSpace();
    public void set_ResetOnSpace(bool value);
    public bool get_SkipLiterals();
    public void set_SkipLiterals(bool value);
    public char get_Item(int index);
    public bool Add(char input);
    public bool Add(char input, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Add(string input);
    public bool Add(string input, Int32& testPosition, MaskedTextResultHint& resultHint);
    public void Clear();
    public void Clear(MaskedTextResultHint& resultHint);
    public int FindAssignedEditPositionFrom(int position, bool direction);
    public int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction);
    public int FindEditPositionFrom(int position, bool direction);
    public int FindEditPositionInRange(int startPosition, int endPosition, bool direction);
    private int FindEditPositionInRange(int startPosition, int endPosition, bool direction, byte assignedStatus);
    public int FindNonEditPositionFrom(int position, bool direction);
    public int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction);
    private int FindPositionInRange(int startPosition, int endPosition, bool direction, CharType charTypeFlags);
    public int FindUnassignedEditPositionFrom(int position, bool direction);
    public int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction);
    public static bool GetOperationResultFromHint(MaskedTextResultHint hint);
    public bool InsertAt(char input, int position);
    public bool InsertAt(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool InsertAt(string input, int position);
    public bool InsertAt(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    private bool InsertAtInt(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint, bool testOnly);
    private static bool IsAscii(char c);
    private static bool IsAciiAlphanumeric(char c);
    private static bool IsAlphanumeric(char c);
    private static bool IsAsciiLetter(char c);
    public bool IsAvailablePosition(int position);
    public bool IsEditPosition(int position);
    private static bool IsEditPosition(CharDescriptor charDescriptor);
    private static bool IsLiteralPosition(CharDescriptor charDescriptor);
    private static bool IsPrintableChar(char c);
    public static bool IsValidInputChar(char c);
    public static bool IsValidMaskChar(char c);
    public static bool IsValidPasswordChar(char c);
    public bool Remove();
    public bool Remove(Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool RemoveAt(int position);
    public bool RemoveAt(int startPosition, int endPosition);
    public bool RemoveAt(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint);
    private bool RemoveAtInt(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint, bool testOnly);
    public bool Replace(char input, int position);
    public bool Replace(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(char input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(string input, int position);
    public bool Replace(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(string input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint);
    private void ResetChar(int testPosition);
    private void ResetString(int startPosition, int endPosition);
    public bool Set(string input);
    public bool Set(string input, Int32& testPosition, MaskedTextResultHint& resultHint);
    private void SetChar(char input, int position);
    private void SetChar(char input, int position, CharDescriptor charDescriptor);
    private void SetString(string input, int testPosition);
    private bool TestChar(char input, int position, MaskedTextResultHint& resultHint);
    private bool TestEscapeChar(char input, int position);
    private bool TestEscapeChar(char input, int position, CharDescriptor charDex);
    private bool TestSetChar(char input, int position, MaskedTextResultHint& resultHint);
    private bool TestSetString(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    private bool TestString(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public string ToDisplayString();
    public virtual string ToString();
    public string ToString(bool ignorePasswordChar);
    public string ToString(int startPosition, int length);
    public string ToString(bool ignorePasswordChar, int startPosition, int length);
    public string ToString(bool includePrompt, bool includeLiterals);
    public string ToString(bool includePrompt, bool includeLiterals, int startPosition, int length);
    public string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);
    public bool VerifyChar(char input, int position, MaskedTextResultHint& hint);
    public bool VerifyEscapeChar(char input, int position);
    public bool VerifyString(string input);
    public bool VerifyString(string input, Int32& testPosition, MaskedTextResultHint& resultHint);
}
public enum System.ComponentModel.MaskedTextResultHint : Enum {
    public int value__;
    public static MaskedTextResultHint Unknown;
    public static MaskedTextResultHint CharacterEscaped;
    public static MaskedTextResultHint NoEffect;
    public static MaskedTextResultHint SideEffect;
    public static MaskedTextResultHint Success;
    public static MaskedTextResultHint AsciiCharacterExpected;
    public static MaskedTextResultHint AlphanumericCharacterExpected;
    public static MaskedTextResultHint DigitExpected;
    public static MaskedTextResultHint LetterExpected;
    public static MaskedTextResultHint SignedDigitExpected;
    public static MaskedTextResultHint InvalidInput;
    public static MaskedTextResultHint PromptCharNotAllowed;
    public static MaskedTextResultHint UnavailableEditPosition;
    public static MaskedTextResultHint NonEditPosition;
    public static MaskedTextResultHint PositionOutOfRange;
}
[ComVisibleAttribute("True")]
public abstract class System.ComponentModel.MemberDescriptor : object {
    private string name;
    private string displayName;
    private int nameHash;
    private AttributeCollection attributeCollection;
    private Attribute[] attributes;
    private Attribute[] originalAttributes;
    private bool attributesFiltered;
    private bool attributesFilled;
    private int metadataVersion;
    private string category;
    private string description;
    private object lockCookie;
    protected Attribute[] AttributeArray { get; protected set; }
    public AttributeCollection Attributes { get; }
    public string Category { get; }
    public string Description { get; }
    public bool IsBrowsable { get; }
    public string Name { get; }
    protected int NameHashCode { get; }
    public bool DesignTimeOnly { get; }
    public string DisplayName { get; }
    protected MemberDescriptor(string name);
    protected MemberDescriptor(string name, Attribute[] attributes);
    protected MemberDescriptor(MemberDescriptor descr);
    protected MemberDescriptor(MemberDescriptor oldMemberDescriptor, Attribute[] newAttributes);
    protected virtual Attribute[] get_AttributeArray();
    protected virtual void set_AttributeArray(Attribute[] value);
    public virtual AttributeCollection get_Attributes();
    public virtual string get_Category();
    public virtual string get_Description();
    public virtual bool get_IsBrowsable();
    public virtual string get_Name();
    protected virtual int get_NameHashCode();
    public virtual bool get_DesignTimeOnly();
    public virtual string get_DisplayName();
    private void CheckAttributesValid();
    protected virtual AttributeCollection CreateAttributeCollection();
    public virtual bool Equals(object obj);
    protected virtual void FillAttributes(IList attributeList);
    private void FilterAttributesIfNeeded();
    protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType);
    protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType, bool publicOnly);
    public virtual int GetHashCode();
    protected virtual object GetInvocationTarget(Type type, object instance);
    protected static ISite GetSite(object component);
    [ObsoleteAttribute("This method has been deprecated. Use GetInvocationTarget instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
protected static object GetInvokee(Type componentClass, object component);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.MergablePropertyAttribute : Attribute {
    public static MergablePropertyAttribute Yes;
    public static MergablePropertyAttribute No;
    public static MergablePropertyAttribute Default;
    [CompilerGeneratedAttribute]
private bool <AllowMerge>k__BackingField;
    public bool AllowMerge { get; }
    public MergablePropertyAttribute(bool allowMerge);
    private static MergablePropertyAttribute();
    [CompilerGeneratedAttribute]
public bool get_AllowMerge();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.MultilineStringConverter : TypeConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.ComponentModel.NestedContainer : Container {
    [CompilerGeneratedAttribute]
private IComponent <Owner>k__BackingField;
    public IComponent Owner { get; }
    protected string OwnerName { get; }
    public NestedContainer(IComponent owner);
    [CompilerGeneratedAttribute]
public sealed virtual IComponent get_Owner();
    protected virtual string get_OwnerName();
    protected virtual ISite CreateSite(IComponent component, string name);
    protected virtual void Dispose(bool disposing);
    protected virtual object GetService(Type service);
    private void OnOwnerDisposed(object sender, EventArgs e);
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.NotifyParentPropertyAttribute : Attribute {
    public static NotifyParentPropertyAttribute Yes;
    public static NotifyParentPropertyAttribute No;
    public static NotifyParentPropertyAttribute Default;
    private bool notifyParent;
    public bool NotifyParent { get; }
    public NotifyParentPropertyAttribute(bool notifyParent);
    private static NotifyParentPropertyAttribute();
    public bool get_NotifyParent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.NullableConverter : TypeConverter {
    [CompilerGeneratedAttribute]
private Type <NullableType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeConverter <UnderlyingTypeConverter>k__BackingField;
    public Type NullableType { get; }
    public Type UnderlyingType { get; }
    public TypeConverter UnderlyingTypeConverter { get; }
    public NullableConverter(Type type);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
    [CompilerGeneratedAttribute]
public Type get_NullableType();
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
public TypeConverter get_UnderlyingTypeConverter();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ParenthesizePropertyNameAttribute : Attribute {
    public static ParenthesizePropertyNameAttribute Default;
    private bool needParenthesis;
    public bool NeedParenthesis { get; }
    public ParenthesizePropertyNameAttribute(bool needParenthesis);
    private static ParenthesizePropertyNameAttribute();
    public bool get_NeedParenthesis();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.PasswordPropertyTextAttribute : Attribute {
    public static PasswordPropertyTextAttribute Yes;
    public static PasswordPropertyTextAttribute No;
    public static PasswordPropertyTextAttribute Default;
    [CompilerGeneratedAttribute]
private bool <Password>k__BackingField;
    public bool Password { get; }
    public PasswordPropertyTextAttribute(bool password);
    private static PasswordPropertyTextAttribute();
    [CompilerGeneratedAttribute]
public bool get_Password();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ProgressChangedEventArgs : EventArgs {
    private int progressPercentage;
    private object userState;
    [SRDescriptionAttribute("Percentage progress made in operation.")]
public int ProgressPercentage { get; }
    [SRDescriptionAttribute("User-supplied state to identify operation.")]
public object UserState { get; }
    public ProgressChangedEventArgs(int progressPercentage, object userState);
    public int get_ProgressPercentage();
    public object get_UserState();
}
public class System.ComponentModel.ProgressChangedEventHandler : MulticastDelegate {
    public ProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.PropertyChangedEventArgs : EventArgs {
    private string _propertyName;
    public string PropertyName { get; }
    public PropertyChangedEventArgs(string propertyName);
    public virtual string get_PropertyName();
}
public class System.ComponentModel.PropertyChangedEventHandler : MulticastDelegate {
    public PropertyChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.PropertyChangingEventArgs : EventArgs {
    private string _propertyName;
    public string PropertyName { get; }
    public PropertyChangingEventArgs(string propertyName);
    public virtual string get_PropertyName();
}
public class System.ComponentModel.PropertyChangingEventHandler : MulticastDelegate {
    public PropertyChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.ComponentModel.PropertyDescriptor : MemberDescriptor {
    private TypeConverter _converter;
    private Hashtable _valueChangedHandlers;
    private Object[] _editors;
    private Type[] _editorTypes;
    private int _editorCount;
    public Type ComponentType { get; }
    public TypeConverter Converter { get; }
    public bool IsLocalizable { get; }
    public bool IsReadOnly { get; }
    public DesignerSerializationVisibility SerializationVisibility { get; }
    public Type PropertyType { get; }
    public bool SupportsChangeEvents { get; }
    protected PropertyDescriptor(string name, Attribute[] attrs);
    protected PropertyDescriptor(MemberDescriptor descr);
    protected PropertyDescriptor(MemberDescriptor descr, Attribute[] attrs);
    public abstract virtual Type get_ComponentType();
    public virtual TypeConverter get_Converter();
    public virtual bool get_IsLocalizable();
    public abstract virtual bool get_IsReadOnly();
    public DesignerSerializationVisibility get_SerializationVisibility();
    public abstract virtual Type get_PropertyType();
    public virtual void AddValueChanged(object component, EventHandler handler);
    public abstract virtual bool CanResetValue(object component);
    public virtual bool Equals(object obj);
    protected object CreateInstance(Type type);
    protected virtual void FillAttributes(IList attributeList);
    public PropertyDescriptorCollection GetChildProperties();
    public PropertyDescriptorCollection GetChildProperties(Attribute[] filter);
    public PropertyDescriptorCollection GetChildProperties(object instance);
    public virtual PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter);
    public virtual object GetEditor(Type editorBaseType);
    public virtual int GetHashCode();
    protected virtual object GetInvocationTarget(Type type, object instance);
    protected Type GetTypeFromName(string typeName);
    public abstract virtual object GetValue(object component);
    protected virtual void OnValueChanged(object component, EventArgs e);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    protected internal EventHandler GetValueChangedHandler(object component);
    public abstract virtual void ResetValue(object component);
    public abstract virtual void SetValue(object component, object value);
    public abstract virtual bool ShouldSerializeValue(object component);
    public virtual bool get_SupportsChangeEvents();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.PropertyDescriptorCollection : object {
    public static PropertyDescriptorCollection Empty;
    private IDictionary _cachedFoundProperties;
    private bool _cachedIgnoreCase;
    private PropertyDescriptor[] _properties;
    private String[] _namedSort;
    private IComparer _comparer;
    private bool _propsOwned;
    private bool _needSort;
    private bool _readOnly;
    private object _internalSyncObject;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public PropertyDescriptor Item { get; }
    public PropertyDescriptor Item { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public PropertyDescriptorCollection(PropertyDescriptor[] properties);
    public PropertyDescriptorCollection(PropertyDescriptor[] properties, bool readOnly);
    private PropertyDescriptorCollection(PropertyDescriptor[] properties, int propCount, String[] namedSort, IComparer comparer);
    private static PropertyDescriptorCollection();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public virtual PropertyDescriptor get_Item(int index);
    public virtual PropertyDescriptor get_Item(string name);
    public int Add(PropertyDescriptor value);
    public void Clear();
    public bool Contains(PropertyDescriptor value);
    public sealed virtual void CopyTo(Array array, int index);
    private void EnsurePropsOwned();
    private void EnsureSize(int sizeNeeded);
    public virtual PropertyDescriptor Find(string name, bool ignoreCase);
    public int IndexOf(PropertyDescriptor value);
    public void Insert(int index, PropertyDescriptor value);
    public void Remove(PropertyDescriptor value);
    public void RemoveAt(int index);
    public virtual PropertyDescriptorCollection Sort();
    public virtual PropertyDescriptorCollection Sort(String[] names);
    public virtual PropertyDescriptorCollection Sort(String[] names, IComparer comparer);
    public virtual PropertyDescriptorCollection Sort(IComparer comparer);
    protected void InternalSort(String[] names);
    protected void InternalSort(IComparer sorter);
    public virtual IEnumerator GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.PropertyTabAttribute : Attribute {
    private Type[] _tabClasses;
    private String[] _tabClassNames;
    [CompilerGeneratedAttribute]
private PropertyTabScope[] <TabScopes>k__BackingField;
    public Type[] TabClasses { get; }
    protected String[] TabClassNames { get; }
    public PropertyTabScope[] TabScopes { get; private set; }
    public PropertyTabAttribute(Type tabClass);
    public PropertyTabAttribute(string tabClassName);
    public PropertyTabAttribute(Type tabClass, PropertyTabScope tabScope);
    public PropertyTabAttribute(string tabClassName, PropertyTabScope tabScope);
    public Type[] get_TabClasses();
    protected String[] get_TabClassNames();
    [CompilerGeneratedAttribute]
public PropertyTabScope[] get_TabScopes();
    [CompilerGeneratedAttribute]
private void set_TabScopes(PropertyTabScope[] value);
    public virtual bool Equals(object other);
    public bool Equals(PropertyTabAttribute other);
    public virtual int GetHashCode();
    protected void InitializeArrays(String[] tabClassNames, PropertyTabScope[] tabScopes);
    protected void InitializeArrays(Type[] tabClasses, PropertyTabScope[] tabScopes);
    private void InitializeArrays(String[] tabClassNames, Type[] tabClasses, PropertyTabScope[] tabScopes);
}
public enum System.ComponentModel.PropertyTabScope : Enum {
    public int value__;
    public static PropertyTabScope Static;
    public static PropertyTabScope Global;
    public static PropertyTabScope Document;
    public static PropertyTabScope Component;
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.ProvidePropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceiverTypeName>k__BackingField;
    public string PropertyName { get; }
    public string ReceiverTypeName { get; }
    public object TypeId { get; }
    public ProvidePropertyAttribute(string propertyName, Type receiverType);
    public ProvidePropertyAttribute(string propertyName, string receiverTypeName);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public string get_ReceiverTypeName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual object get_TypeId();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ReadOnlyAttribute : Attribute {
    public static ReadOnlyAttribute Yes;
    public static ReadOnlyAttribute No;
    public static ReadOnlyAttribute Default;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public bool IsReadOnly { get; }
    public ReadOnlyAttribute(bool isReadOnly);
    private static ReadOnlyAttribute();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("128")]
[ObsoleteAttribute("Use System.ComponentModel.SettingsBindableAttribute instead to work with the new settings model.")]
public class System.ComponentModel.RecommendedAsConfigurableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <RecommendedAsConfigurable>k__BackingField;
    public static RecommendedAsConfigurableAttribute No;
    public static RecommendedAsConfigurableAttribute Yes;
    public static RecommendedAsConfigurableAttribute Default;
    public bool RecommendedAsConfigurable { get; }
    public RecommendedAsConfigurableAttribute(bool recommendedAsConfigurable);
    private static RecommendedAsConfigurableAttribute();
    [CompilerGeneratedAttribute]
public bool get_RecommendedAsConfigurable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ReferenceConverter : TypeConverter {
    private static string s_none;
    private Type _type;
    public ReferenceConverter(Type type);
    private static ReferenceConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    protected virtual bool IsValueAllowed(ITypeDescriptorContext context, object value);
}
internal class System.ComponentModel.ReflectEventDescriptor : EventDescriptor {
    private Type _type;
    private Type _componentClass;
    private MethodInfo _addMethod;
    private MethodInfo _removeMethod;
    private EventInfo _realEvent;
    private bool _filledMethods;
    public Type ComponentType { get; }
    public Type EventType { get; }
    public bool IsMulticast { get; }
    public ReflectEventDescriptor(Type componentClass, string name, Type type, Attribute[] attributes);
    public ReflectEventDescriptor(Type componentClass, EventInfo eventInfo);
    public ReflectEventDescriptor(Type componentType, EventDescriptor oldReflectEventDescriptor, Attribute[] attributes);
    public virtual Type get_ComponentType();
    public virtual Type get_EventType();
    public virtual bool get_IsMulticast();
    public virtual void AddEventHandler(object component, Delegate value);
    protected virtual void FillAttributes(IList attributes);
    private void FillEventInfoAttribute(EventInfo realEventInfo, IList attributes);
    private void FillMethods();
    private void FillSingleMethodAttribute(MethodInfo realMethodInfo, IList attributes);
    public virtual void RemoveEventHandler(object component, Delegate value);
}
internal class System.ComponentModel.ReflectPropertyDescriptor : PropertyDescriptor {
    private static Type[] argsNone;
    private static object noValue;
    private static TraceSwitch PropDescCreateSwitch;
    private static TraceSwitch PropDescUsageSwitch;
    private static int BitDefaultValueQueried;
    private static int BitGetQueried;
    private static int BitSetQueried;
    private static int BitShouldSerializeQueried;
    private static int BitResetQueried;
    private static int BitChangedQueried;
    private static int BitIPropChangedQueried;
    private static int BitReadOnlyChecked;
    private static int BitAmbientValueQueried;
    private static int BitSetOnDemand;
    private BitVector32 state;
    private Type componentClass;
    private Type type;
    private object defaultValue;
    private object ambientValue;
    private PropertyInfo propInfo;
    private MethodInfo getMethod;
    private MethodInfo setMethod;
    private MethodInfo shouldSerializeMethod;
    private MethodInfo resetMethod;
    private EventDescriptor realChangedEvent;
    private EventDescriptor realIPropChangedEvent;
    private Type receiverType;
    private object AmbientValue { get; }
    private EventDescriptor ChangedEventValue { get; }
    private EventDescriptor IPropChangedEventValue { get; private set; }
    public Type ComponentType { get; }
    private object DefaultValue { get; }
    private MethodInfo GetMethodValue { get; }
    private bool IsExtender { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    private MethodInfo ResetMethodValue { get; }
    private MethodInfo SetMethodValue { get; }
    private MethodInfo ShouldSerializeMethodValue { get; }
    public bool SupportsChangeEvents { get; }
    public ReflectPropertyDescriptor(Type componentClass, string name, Type type, Attribute[] attributes);
    public ReflectPropertyDescriptor(Type componentClass, string name, Type type, PropertyInfo propInfo, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs);
    public ReflectPropertyDescriptor(Type componentClass, string name, Type type, Type receiverType, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs);
    public ReflectPropertyDescriptor(Type componentClass, PropertyDescriptor oldReflectPropertyDescriptor, Attribute[] attributes);
    private static ReflectPropertyDescriptor();
    private object get_AmbientValue();
    private EventDescriptor get_ChangedEventValue();
    private EventDescriptor get_IPropChangedEventValue();
    private void set_IPropChangedEventValue(EventDescriptor value);
    public virtual Type get_ComponentType();
    private object get_DefaultValue();
    private MethodInfo get_GetMethodValue();
    private bool get_IsExtender();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    private MethodInfo get_ResetMethodValue();
    private MethodInfo get_SetMethodValue();
    private MethodInfo get_ShouldSerializeMethodValue();
    public virtual void AddValueChanged(object component, EventHandler handler);
    internal bool ExtenderCanResetValue(IExtenderProvider provider, object component);
    internal Type ExtenderGetReceiverType();
    internal Type ExtenderGetType(IExtenderProvider provider);
    internal object ExtenderGetValue(IExtenderProvider provider, object component);
    internal void ExtenderResetValue(IExtenderProvider provider, object component, PropertyDescriptor notifyDesc);
    internal void ExtenderSetValue(IExtenderProvider provider, object component, object value, PropertyDescriptor notifyDesc);
    internal bool ExtenderShouldSerializeValue(IExtenderProvider provider, object component);
    public virtual bool CanResetValue(object component);
    protected virtual void FillAttributes(IList attributes);
    public virtual object GetValue(object component);
    internal void OnINotifyPropertyChanged(object component, PropertyChangedEventArgs e);
    protected virtual void OnValueChanged(object component, EventArgs e);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual bool get_SupportsChangeEvents();
}
internal class System.ComponentModel.ReflectTypeDescriptionProvider : TypeDescriptionProvider {
    private Hashtable _typeData;
    private static Type[] _typeConstructor;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _editorTables;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _intrinsicTypeConverters;
    private static object _intrinsicReferenceKey;
    private static object _intrinsicNullableKey;
    private static object _dictionaryKey;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _propertyCache;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _eventCache;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _attributeCache;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _extendedPropertyCache;
    private static Guid _extenderProviderKey;
    private static Guid _extenderPropertiesKey;
    private static Guid _extenderProviderPropertiesKey;
    private static Type[] _skipInterfaceAttributeList;
    private static object _internalSyncObject;
    internal static Guid ExtenderProviderKey { get; }
    private static Hashtable IntrinsicTypeConverters { get; }
    private static ReflectTypeDescriptionProvider();
    internal static Guid get_ExtenderProviderKey();
    [PreserveDependencyAttribute(".ctor()", "System.ComponentModel.BooleanConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.ByteConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.UInt16Converter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.UInt32Converter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.TypeConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.CultureInfoConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.DateTimeConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.DateTimeOffsetConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.DecimalConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.TimeSpanConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.GuidConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.ArrayConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.CollectionConverter")]
[PreserveDependencyAttribute(".ctor(System.Type)", "System.ComponentModel.EnumConverter")]
[PreserveDependencyAttribute(".ctor(System.Type)", "System.ComponentModel.ReferenceConverter")]
[PreserveDependencyAttribute(".ctor(System.Type)", "System.ComponentModel.NullableConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.UInt16Converter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.Int64Converter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.Int16Converter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.Int32Converter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.StringConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.DoubleConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.CharConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.SByteConverter")]
[PreserveDependencyAttribute(".ctor()", "System.ComponentModel.SingleConverter")]
private static Hashtable get_IntrinsicTypeConverters();
    internal static void AddEditorTable(Type editorBaseType, Hashtable table);
    public virtual object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    private static object CreateInstance(Type objectType, Type callingType);
    internal AttributeCollection GetAttributes(Type type);
    public virtual IDictionary GetCache(object instance);
    internal string GetClassName(Type type);
    internal string GetComponentName(Type type, object instance);
    internal TypeConverter GetConverter(Type type, object instance);
    internal EventDescriptor GetDefaultEvent(Type type, object instance);
    internal PropertyDescriptor GetDefaultProperty(Type type, object instance);
    internal object GetEditor(Type type, object instance, Type editorBaseType);
    private static Hashtable GetEditorTable(Type editorBaseType);
    internal EventDescriptorCollection GetEvents(Type type);
    internal AttributeCollection GetExtendedAttributes(object instance);
    internal string GetExtendedClassName(object instance);
    internal string GetExtendedComponentName(object instance);
    internal TypeConverter GetExtendedConverter(object instance);
    internal EventDescriptor GetExtendedDefaultEvent(object instance);
    internal PropertyDescriptor GetExtendedDefaultProperty(object instance);
    internal object GetExtendedEditor(object instance, Type editorBaseType);
    internal EventDescriptorCollection GetExtendedEvents(object instance);
    internal PropertyDescriptorCollection GetExtendedProperties(object instance);
    protected internal virtual IExtenderProvider[] GetExtenderProviders(object instance);
    private static IExtenderProvider[] GetExtenders(ICollection components, object instance, IDictionary cache);
    internal object GetExtendedPropertyOwner(object instance, PropertyDescriptor pd);
    public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
    public virtual string GetFullComponentName(object component);
    internal Type[] GetPopulatedTypes(Module module);
    internal PropertyDescriptorCollection GetProperties(Type type);
    internal object GetPropertyOwner(Type type, object instance, PropertyDescriptor pd);
    public virtual Type GetReflectionType(Type objectType, object instance);
    private ReflectedTypeData GetTypeData(Type type, bool createIfNeeded);
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
    private static Type GetTypeFromName(string typeName);
    internal bool IsPopulated(Type type);
    private static Attribute[] ReflectGetAttributes(Type type);
    internal static Attribute[] ReflectGetAttributes(MemberInfo member);
    private static EventDescriptor[] ReflectGetEvents(Type type);
    private static PropertyDescriptor[] ReflectGetExtendedProperties(IExtenderProvider provider);
    private static PropertyDescriptor[] ReflectGetProperties(Type type);
    internal void Refresh(Type type);
    private static object SearchIntrinsicTable(Hashtable table, Type callingType);
}
public class System.ComponentModel.RefreshEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <ComponentChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeChanged>k__BackingField;
    public object ComponentChanged { get; }
    public Type TypeChanged { get; }
    public RefreshEventArgs(object componentChanged);
    public RefreshEventArgs(Type typeChanged);
    [CompilerGeneratedAttribute]
public object get_ComponentChanged();
    [CompilerGeneratedAttribute]
public Type get_TypeChanged();
}
public class System.ComponentModel.RefreshEventHandler : MulticastDelegate {
    public RefreshEventHandler(object object, IntPtr method);
    public virtual void Invoke(RefreshEventArgs e);
    public virtual IAsyncResult BeginInvoke(RefreshEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ComponentModel.RefreshProperties : Enum {
    public int value__;
    public static RefreshProperties None;
    public static RefreshProperties All;
    public static RefreshProperties Repaint;
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.RefreshPropertiesAttribute : Attribute {
    public static RefreshPropertiesAttribute All;
    public static RefreshPropertiesAttribute Repaint;
    public static RefreshPropertiesAttribute Default;
    private RefreshProperties refresh;
    public RefreshProperties RefreshProperties { get; }
    public RefreshPropertiesAttribute(RefreshProperties refresh);
    private static RefreshPropertiesAttribute();
    public RefreshProperties get_RefreshProperties();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.RunInstallerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <RunInstaller>k__BackingField;
    public static RunInstallerAttribute Yes;
    public static RunInstallerAttribute No;
    public static RunInstallerAttribute Default;
    public bool RunInstaller { get; }
    public RunInstallerAttribute(bool runInstaller);
    private static RunInstallerAttribute();
    [CompilerGeneratedAttribute]
public bool get_RunInstaller();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.RunWorkerCompletedEventArgs : AsyncCompletedEventArgs {
    private object result;
    public object Result { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object UserState { get; }
    public RunWorkerCompletedEventArgs(object result, Exception error, bool cancelled);
    public object get_Result();
    public object get_UserState();
}
public class System.ComponentModel.RunWorkerCompletedEventHandler : MulticastDelegate {
    public RunWorkerCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RunWorkerCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RunWorkerCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.SByteConverter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.SettingsBindableAttribute : Attribute {
    public static SettingsBindableAttribute Yes;
    public static SettingsBindableAttribute No;
    [CompilerGeneratedAttribute]
private bool <Bindable>k__BackingField;
    public bool Bindable { get; }
    public SettingsBindableAttribute(bool bindable);
    private static SettingsBindableAttribute();
    [CompilerGeneratedAttribute]
public bool get_Bindable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.ComponentModel.SingleConverter : BaseNumberConverter {
    internal bool AllowHex { get; }
    internal Type TargetType { get; }
    internal virtual bool get_AllowHex();
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
internal class System.ComponentModel.SRCategoryAttribute : CategoryAttribute {
    public SRCategoryAttribute(string category);
}
public class System.ComponentModel.StringConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public static class System.ComponentModel.SyntaxCheck : object {
    public static bool CheckMachineName(string value);
    public static bool CheckPath(string value);
    public static bool CheckRootedPath(string value);
}
public class System.ComponentModel.TimeSpanConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ToolboxItemAttribute : Attribute {
    private Type _toolboxItemType;
    private string _toolboxItemTypeName;
    public static ToolboxItemAttribute Default;
    public static ToolboxItemAttribute None;
    public Type ToolboxItemType { get; }
    public string ToolboxItemTypeName { get; }
    public ToolboxItemAttribute(bool defaultType);
    public ToolboxItemAttribute(string toolboxItemTypeName);
    public ToolboxItemAttribute(Type toolboxItemType);
    private static ToolboxItemAttribute();
    public virtual bool IsDefaultAttribute();
    public Type get_ToolboxItemType();
    public string get_ToolboxItemTypeName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.ToolboxItemFilterAttribute : Attribute {
    private string _typeId;
    [CompilerGeneratedAttribute]
private string <FilterString>k__BackingField;
    [CompilerGeneratedAttribute]
private ToolboxItemFilterType <FilterType>k__BackingField;
    public string FilterString { get; }
    public ToolboxItemFilterType FilterType { get; }
    public object TypeId { get; }
    public ToolboxItemFilterAttribute(string filterString);
    public ToolboxItemFilterAttribute(string filterString, ToolboxItemFilterType filterType);
    [CompilerGeneratedAttribute]
public string get_FilterString();
    [CompilerGeneratedAttribute]
public ToolboxItemFilterType get_FilterType();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool Match(object obj);
    public virtual string ToString();
}
public enum System.ComponentModel.ToolboxItemFilterType : Enum {
    public int value__;
    public static ToolboxItemFilterType Allow;
    public static ToolboxItemFilterType Custom;
    public static ToolboxItemFilterType Prevent;
    public static ToolboxItemFilterType Require;
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.TypeConverter : object {
    private static string s_UseCompatibleTypeConverterBehavior;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) useCompatibleTypeConversion;
    private static bool UseCompatibleTypeConversion { get; }
    private static bool get_UseCompatibleTypeConversion();
    public bool CanConvertFrom(Type sourceType);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public bool CanConvertTo(Type destinationType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public object ConvertFrom(object value);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public object ConvertFromInvariantString(string text);
    public object ConvertFromInvariantString(ITypeDescriptorContext context, string text);
    public object ConvertFromString(string text);
    public object ConvertFromString(ITypeDescriptorContext context, string text);
    public object ConvertFromString(ITypeDescriptorContext context, CultureInfo culture, string text);
    public object ConvertTo(object value, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public string ConvertToInvariantString(object value);
    public string ConvertToInvariantString(ITypeDescriptorContext context, object value);
    public string ConvertToString(object value);
    public string ConvertToString(ITypeDescriptorContext context, object value);
    public string ConvertToString(ITypeDescriptorContext context, CultureInfo culture, object value);
    public object CreateInstance(IDictionary propertyValues);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    protected Exception GetConvertFromException(object value);
    protected Exception GetConvertToException(object value, Type destinationType);
    public bool GetCreateInstanceSupported();
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public PropertyDescriptorCollection GetProperties(object value);
    public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public bool GetPropertiesSupported();
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
    public ICollection GetStandardValues();
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public bool GetStandardValuesExclusive();
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public bool GetStandardValuesSupported();
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public bool IsValid(object value);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
    protected PropertyDescriptorCollection SortProperties(PropertyDescriptorCollection props, String[] names);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.TypeConverterAttribute : Attribute {
    public static TypeConverterAttribute Default;
    [CompilerGeneratedAttribute]
private string <ConverterTypeName>k__BackingField;
    public string ConverterTypeName { get; }
    public TypeConverterAttribute(Type type);
    public TypeConverterAttribute(string typeName);
    private static TypeConverterAttribute();
    [CompilerGeneratedAttribute]
public string get_ConverterTypeName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class System.ComponentModel.TypeDescriptionProvider : object {
    private TypeDescriptionProvider _parent;
    private EmptyCustomTypeDescriptor _emptyDescriptor;
    protected TypeDescriptionProvider(TypeDescriptionProvider parent);
    public virtual object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    public virtual IDictionary GetCache(object instance);
    public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
    protected internal virtual IExtenderProvider[] GetExtenderProviders(object instance);
    public virtual string GetFullComponentName(object component);
    public Type GetReflectionType(Type objectType);
    public Type GetReflectionType(object instance);
    public virtual Type GetReflectionType(Type objectType, object instance);
    public virtual Type GetRuntimeType(Type reflectionType);
    public ICustomTypeDescriptor GetTypeDescriptor(Type objectType);
    public ICustomTypeDescriptor GetTypeDescriptor(object instance);
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
    public virtual bool IsSupportedType(Type type);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.TypeDescriptionProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string TypeName { get; }
    public TypeDescriptionProviderAttribute(string typeName);
    public TypeDescriptionProviderAttribute(Type type);
    [CompilerGeneratedAttribute]
public string get_TypeName();
}
public class System.ComponentModel.TypeDescriptor : object {
    private static WeakHashtable _providerTable;
    private static Hashtable _providerTypeTable;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _defaultProviders;
    private static WeakHashtable modreq(System.Runtime.CompilerServices.IsVolatile) _associationTable;
    private static int _metadataVersion;
    private static int _collisionIndex;
    private static BooleanSwitch TraceDescriptor;
    private static int PIPELINE_ATTRIBUTES;
    private static int PIPELINE_PROPERTIES;
    private static int PIPELINE_EVENTS;
    private static Guid[] _pipelineInitializeKeys;
    private static Guid[] _pipelineMergeKeys;
    private static Guid[] _pipelineFilterKeys;
    private static Guid[] _pipelineAttributeFilterKeys;
    private static object _internalSyncObject;
    [CompilerGeneratedAttribute]
private static RefreshEventHandler Refreshed;
    [ObsoleteAttribute("This property has been deprecated.  Use a type description provider to supply type information for COM types instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static IComNativeDescriptorHandler ComNativeDescriptorHandler { get; public set; }
    [EditorBrowsableAttribute("2")]
public static Type ComObjectType { get; }
    [EditorBrowsableAttribute("2")]
public static Type InterfaceType { get; }
    internal static int MetadataVersion { get; }
    private static TypeDescriptor();
    public static IComNativeDescriptorHandler get_ComNativeDescriptorHandler();
    public static void set_ComNativeDescriptorHandler(IComNativeDescriptorHandler value);
    public static Type get_ComObjectType();
    public static Type get_InterfaceType();
    internal static int get_MetadataVersion();
    [CompilerGeneratedAttribute]
public static void add_Refreshed(RefreshEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_Refreshed(RefreshEventHandler value);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider AddAttributes(Type type, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider AddAttributes(object instance, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static void AddEditorTable(Type editorBaseType, Hashtable table);
    [EditorBrowsableAttribute("2")]
public static void AddProvider(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void AddProvider(TypeDescriptionProvider provider, object instance);
    [EditorBrowsableAttribute("2")]
public static void AddProviderTransparent(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void AddProviderTransparent(TypeDescriptionProvider provider, object instance);
    private static void CheckDefaultProvider(Type type);
    [EditorBrowsableAttribute("2")]
public static void CreateAssociation(object primary, object secondary);
    public static IDesigner CreateDesigner(IComponent component, Type designerBaseType);
    public static EventDescriptor CreateEvent(Type componentType, string name, Type type, Attribute[] attributes);
    public static EventDescriptor CreateEvent(Type componentType, EventDescriptor oldEventDescriptor, Attribute[] attributes);
    public static object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    public static PropertyDescriptor CreateProperty(Type componentType, string name, Type type, Attribute[] attributes);
    public static PropertyDescriptor CreateProperty(Type componentType, PropertyDescriptor oldPropertyDescriptor, Attribute[] attributes);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(Type type, AttributeCollection attributes, AttributeCollection debugAttributes);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(AttributeCollection attributes, AttributeCollection debugAttributes);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(AttributeCollection attributes, Type type);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(AttributeCollection attributes, object instance, bool noCustomTypeDesc);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(TypeConverter converter, Type type);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(TypeConverter converter, object instance, bool noCustomTypeDesc);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(EventDescriptorCollection events, Type type, Attribute[] attributes);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(EventDescriptorCollection events, object instance, Attribute[] attributes, bool noCustomTypeDesc);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(PropertyDescriptorCollection properties, Type type, Attribute[] attributes);
    [ConditionalAttribute("DEBUG")]
private static void DebugValidate(PropertyDescriptorCollection properties, object instance, Attribute[] attributes, bool noCustomTypeDesc);
    private static ArrayList FilterMembers(IList members, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static object GetAssociation(Type type, object primary);
    public static AttributeCollection GetAttributes(Type componentType);
    public static AttributeCollection GetAttributes(object component);
    [EditorBrowsableAttribute("2")]
public static AttributeCollection GetAttributes(object component, bool noCustomTypeDesc);
    internal static IDictionary GetCache(object instance);
    public static string GetClassName(object component);
    [EditorBrowsableAttribute("2")]
public static string GetClassName(object component, bool noCustomTypeDesc);
    public static string GetClassName(Type componentType);
    public static string GetComponentName(object component);
    [EditorBrowsableAttribute("2")]
public static string GetComponentName(object component, bool noCustomTypeDesc);
    public static TypeConverter GetConverter(object component);
    [EditorBrowsableAttribute("2")]
public static TypeConverter GetConverter(object component, bool noCustomTypeDesc);
    public static TypeConverter GetConverter(Type type);
    private static object ConvertFromInvariantString(Type type, string stringValue);
    public static EventDescriptor GetDefaultEvent(Type componentType);
    public static EventDescriptor GetDefaultEvent(object component);
    [EditorBrowsableAttribute("2")]
public static EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc);
    public static PropertyDescriptor GetDefaultProperty(Type componentType);
    public static PropertyDescriptor GetDefaultProperty(object component);
    [EditorBrowsableAttribute("2")]
public static PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc);
    internal static ICustomTypeDescriptor GetDescriptor(Type type, string typeName);
    internal static ICustomTypeDescriptor GetDescriptor(object component, bool noCustomTypeDesc);
    internal static ICustomTypeDescriptor GetExtendedDescriptor(object component);
    public static object GetEditor(object component, Type editorBaseType);
    [EditorBrowsableAttribute("2")]
public static object GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc);
    public static object GetEditor(Type type, Type editorBaseType);
    public static EventDescriptorCollection GetEvents(Type componentType);
    public static EventDescriptorCollection GetEvents(Type componentType, Attribute[] attributes);
    public static EventDescriptorCollection GetEvents(object component);
    [EditorBrowsableAttribute("2")]
public static EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc);
    public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes, bool noCustomTypeDesc);
    private static string GetExtenderCollisionSuffix(MemberDescriptor member);
    public static string GetFullComponentName(object component);
    private static Type GetNodeForBaseType(Type searchType);
    public static PropertyDescriptorCollection GetProperties(Type componentType);
    public static PropertyDescriptorCollection GetProperties(Type componentType, Attribute[] attributes);
    public static PropertyDescriptorCollection GetProperties(object component);
    [EditorBrowsableAttribute("2")]
public static PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc);
    public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes);
    public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes, bool noCustomTypeDesc);
    private static PropertyDescriptorCollection GetPropertiesImpl(object component, Attribute[] attributes, bool noCustomTypeDesc, bool noAttributes);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider GetProvider(Type type);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider GetProvider(object instance);
    internal static TypeDescriptionProvider GetProviderRecursive(Type type);
    [EditorBrowsableAttribute("2")]
public static Type GetReflectionType(Type type);
    [EditorBrowsableAttribute("2")]
public static Type GetReflectionType(object instance);
    private static TypeDescriptionNode NodeFor(Type type);
    private static TypeDescriptionNode NodeFor(Type type, bool createDelegator);
    private static TypeDescriptionNode NodeFor(object instance);
    private static TypeDescriptionNode NodeFor(object instance, bool createDelegator);
    private static void NodeRemove(object key, TypeDescriptionProvider provider);
    private static ICollection PipelineAttributeFilter(int pipelineType, ICollection members, Attribute[] filter, object instance, IDictionary cache);
    private static ICollection PipelineFilter(int pipelineType, ICollection members, object instance, IDictionary cache);
    private static ICollection PipelineInitialize(int pipelineType, ICollection members, IDictionary cache);
    private static ICollection PipelineMerge(int pipelineType, ICollection primary, ICollection secondary, object instance, IDictionary cache);
    private static void RaiseRefresh(object component);
    private static void RaiseRefresh(Type type);
    public static void Refresh(object component);
    private static void Refresh(object component, bool refreshReflectionProvider);
    public static void Refresh(Type type);
    public static void Refresh(Module module);
    public static void Refresh(Assembly assembly);
    [EditorBrowsableAttribute("2")]
public static void RemoveAssociation(object primary, object secondary);
    [EditorBrowsableAttribute("2")]
public static void RemoveAssociations(object primary);
    [EditorBrowsableAttribute("2")]
public static void RemoveProvider(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void RemoveProvider(TypeDescriptionProvider provider, object instance);
    [EditorBrowsableAttribute("2")]
public static void RemoveProviderTransparent(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void RemoveProviderTransparent(TypeDescriptionProvider provider, object instance);
    private static bool ShouldHideMember(MemberDescriptor member, Attribute attribute);
    public static void SortDescriptorArray(IList infos);
    [ConditionalAttribute("DEBUG")]
internal static void Trace(string message, Object[] args);
}
public abstract class System.ComponentModel.TypeListConverter : TypeConverter {
    private Type[] _types;
    private StandardValuesCollection _values;
    protected TypeListConverter(Type[] types);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public class System.ComponentModel.UInt16Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.UInt32Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.UInt64Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.WarningException : SystemException {
    [CompilerGeneratedAttribute]
private string <HelpUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpTopic>k__BackingField;
    public string HelpUrl { get; }
    public string HelpTopic { get; }
    public WarningException(string message);
    public WarningException(string message, string helpUrl);
    public WarningException(string message, Exception innerException);
    public WarningException(string message, string helpUrl, string helpTopic);
    protected WarningException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_HelpUrl();
    [CompilerGeneratedAttribute]
public string get_HelpTopic();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.ComponentModel.WeakHashtable : Hashtable {
    private static IEqualityComparer _comparer;
    private long _lastGlobalMem;
    private int _lastHashCount;
    private static WeakHashtable();
    public virtual void Clear();
    public virtual void Remove(object key);
    public void SetWeak(object key, object value);
    private void ScavengeKeys();
}
[SuppressUnmanagedCodeSecurityAttribute]
public class System.ComponentModel.Win32Exception : ExternalException {
    private int nativeErrorCode;
    private static int MAX_MESSAGE_LENGTH;
    public int NativeErrorCode { get; }
    public Win32Exception(int error);
    public Win32Exception(int error, string message);
    public Win32Exception(string message);
    public Win32Exception(string message, Exception innerException);
    protected Win32Exception(SerializationInfo info, StreamingContext context);
    public int get_NativeErrorCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static int FormatMessage(int dwFlags, IntPtr lpSource, UInt32 dwMessageId, int dwLanguageId, Char[] lpBuffer, int nSize, IntPtr[] arguments);
    internal static string GetErrorMessage(int error);
}
internal enum System.Configuration.AllowDefinition : Enum {
    public int value__;
    public static AllowDefinition Everywhere;
    public static AllowDefinition MachineOnly;
    public static AllowDefinition MachineToApplication;
}
[AttributeUsageAttribute("128")]
public class System.Configuration.ApplicationScopedSettingAttribute : SettingAttribute {
}
[DefaultMemberAttribute("Item")]
public abstract class System.Configuration.ApplicationSettingsBase : SettingsBase {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private SettingChangingEventHandler SettingChanging;
    [CompilerGeneratedAttribute]
private SettingsLoadedEventHandler SettingsLoaded;
    [CompilerGeneratedAttribute]
private SettingsSavingEventHandler SettingsSaving;
    private string settingsKey;
    private SettingsContext context;
    private SettingsPropertyCollection properties;
    private ISettingsProviderService providerService;
    private SettingsPropertyValueCollection propertyValues;
    private SettingsProviderCollection providers;
    [BrowsableAttribute("False")]
public SettingsContext Context { get; }
    [MonoTODOAttribute]
public object Item { get; public set; }
    [BrowsableAttribute("False")]
public SettingsPropertyCollection Properties { get; }
    [BrowsableAttribute("False")]
public SettingsPropertyValueCollection PropertyValues { get; }
    [BrowsableAttribute("False")]
public SettingsProviderCollection Providers { get; }
    [BrowsableAttribute("False")]
public string SettingsKey { get; public set; }
    protected ApplicationSettingsBase(IComponent owner);
    protected ApplicationSettingsBase(string settingsKey);
    protected ApplicationSettingsBase(IComponent owner, string settingsKey);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_SettingChanging(SettingChangingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SettingChanging(SettingChangingEventHandler value);
    [CompilerGeneratedAttribute]
public void add_SettingsLoaded(SettingsLoadedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SettingsLoaded(SettingsLoadedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_SettingsSaving(SettingsSavingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SettingsSaving(SettingsSavingEventHandler value);
    public object GetPreviousVersion(string propertyName);
    public void Reload();
    public void Reset();
    public virtual void Save();
    private void InternalSave();
    public virtual void Upgrade();
    private SettingsPropertyCollection GetPropertiesForProvider(SettingsProvider provider);
    protected virtual void OnPropertyChanged(object sender, PropertyChangedEventArgs e);
    protected virtual void OnSettingChanging(object sender, SettingChangingEventArgs e);
    protected virtual void OnSettingsLoaded(object sender, SettingsLoadedEventArgs e);
    protected virtual void OnSettingsSaving(object sender, CancelEventArgs e);
    public virtual SettingsContext get_Context();
    private void CacheValuesByProvider(SettingsProvider provider);
    private void InitializeSettings(SettingsPropertyCollection settings);
    private object GetPropertyValue(string propertyName);
    public virtual object get_Item(string propertyName);
    public virtual void set_Item(string propertyName, object value);
    public virtual SettingsPropertyCollection get_Properties();
    private void CreateSettingsProperty(PropertyInfo prop, SettingsPropertyCollection properties, SettingsProvider& local_provider);
    public virtual SettingsPropertyValueCollection get_PropertyValues();
    public virtual SettingsProviderCollection get_Providers();
    public string get_SettingsKey();
    public void set_SettingsKey(string value);
}
public class System.Configuration.ApplicationSettingsGroup : ConfigurationSectionGroup {
}
public class System.Configuration.AppSettingsReader : object {
    private NameValueCollection appSettings;
    public object GetValue(string key, Type type);
}
public class System.Configuration.ClientSettingsSection : ConfigurationSection {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty settings_prop;
    [ConfigurationPropertyAttribute("")]
public SettingElementCollection Settings { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static ClientSettingsSection();
    public SettingElementCollection get_Settings();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.Configuration.ConfigHelper : object {
    internal static IDictionary GetDictionary(IDictionary prev, XmlNode region, string nameAtt, string valueAtt);
    internal static ConfigNameValueCollection GetNameValueCollection(NameValueCollection prev, XmlNode region, string nameAtt, string valueAtt);
    private static CollectionWrapper GoGetThem(CollectionWrapper result, XmlNode region, string nameAtt, string valueAtt);
}
internal class System.Configuration.ConfigNameValueCollection : NameValueCollection {
    private bool modified;
    public bool IsModified { get; }
    public ConfigNameValueCollection(ConfigNameValueCollection col);
    public ConfigNameValueCollection(IHashCodeProvider hashProvider, IComparer comparer);
    public void ResetModified();
    public bool get_IsModified();
    public virtual void Set(string name, string value);
}
internal class System.Configuration.ConfigurationData : object {
    private ConfigurationData parent;
    private Hashtable factories;
    private static object removedMark;
    private static object emptyMark;
    private Hashtable pending;
    private string fileName;
    private static object groupMark;
    private Hashtable cache;
    private Hashtable FileCache { get; }
    public ConfigurationData(ConfigurationData parent);
    private static ConfigurationData();
    private Hashtable get_FileCache();
    public bool Load(string fileName);
    public bool LoadString(string data);
    private object GetHandler(string sectionName);
    private object CreateNewHandler(string sectionName, SectionData section);
    private XmlDocument GetInnerDoc(XmlDocument doc, int i, String[] sectionPath);
    private XmlDocument GetDocumentForSection(string sectionName);
    private object GetConfigInternal(string sectionName);
    public object GetConfig(string sectionName);
    private object LookForFactory(string key);
    private bool InitRead(XmlTextReader reader);
    private void MoveToNextElement(XmlTextReader reader);
    private void ReadSection(XmlTextReader reader, string sectionName);
    private void ReadRemoveSection(XmlTextReader reader, string sectionName);
    private void ReadSectionGroup(XmlTextReader reader, string configSection);
    private void ReadSections(XmlTextReader reader, string configSection);
    private void StorePending(string name, XmlTextReader reader);
    private void ReadConfigFile(XmlTextReader reader);
    private void ThrowException(string text, XmlTextReader reader);
}
public class System.Configuration.ConfigurationException : SystemException {
    private string filename;
    private int line;
    public string BareMessage { get; }
    public string Filename { get; }
    public int Line { get; }
    public string Message { get; }
    [ObsoleteAttribute("This class is obsolete.  Use System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message);
    protected ConfigurationException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This class is obsolete.  Use System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, Exception inner);
    [ObsoleteAttribute("This class is obsolete.  Use System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, XmlNode node);
    [ObsoleteAttribute("This class is obsolete.  Use System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, Exception inner, XmlNode node);
    [ObsoleteAttribute("This class is obsolete.  Use System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, string filename, int line);
    [ObsoleteAttribute("This class is obsolete.  Use System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, Exception inner, string filename, int line);
    public virtual string get_BareMessage();
    public virtual string get_Filename();
    public virtual int get_Line();
    public virtual string get_Message();
    [ObsoleteAttribute("This class is obsolete.  Use System.Configuration.ConfigurationErrorsException")]
public static string GetXmlNodeFilename(XmlNode node);
    [ObsoleteAttribute("This class is obsolete.  Use System.Configuration.ConfigurationErrorsException")]
public static int GetXmlNodeLineNumber(XmlNode node);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Configuration.ConfigurationSettings : object {
    private static IConfigurationSystem config;
    private static object lockobj;
    [ObsoleteAttribute("This property is obsolete.  Please use System.Configuration.ConfigurationManager.AppSettings")]
public static NameValueCollection AppSettings { get; }
    private static ConfigurationSettings();
    [ObsoleteAttribute("This method is obsolete, it has been replaced by System.Configuration!System.Configuration.ConfigurationManager.GetSection")]
public static object GetConfig(string sectionName);
    public static NameValueCollection get_AppSettings();
    internal static IConfigurationSystem ChangeConfigurationSystem(IConfigurationSystem newSystem);
}
public class System.Configuration.ConfigXmlDocument : XmlDocument {
    private XmlTextReader reader;
    private string fileName;
    private int lineNumber;
    public string Filename { get; }
    public int LineNumber { get; }
    private string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
    private int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
    private string System.Configuration.IConfigXmlNode.Filename { get; }
    private int System.Configuration.IConfigXmlNode.LineNumber { get; }
    public virtual XmlAttribute CreateAttribute(string prefix, string localName, string namespaceUri);
    public virtual XmlCDataSection CreateCDataSection(string data);
    public virtual XmlComment CreateComment(string data);
    public virtual XmlElement CreateElement(string prefix, string localName, string namespaceUri);
    public virtual XmlSignificantWhitespace CreateSignificantWhitespace(string data);
    public virtual XmlText CreateTextNode(string text);
    public virtual XmlWhitespace CreateWhitespace(string data);
    public virtual void Load(string filename);
    public void LoadSingleElement(string filename, XmlTextReader sourceReader);
    public string get_Filename();
    public int get_LineNumber();
    private sealed virtual override string System.Configuration.Internal.IConfigErrorInfo.get_Filename();
    private sealed virtual override int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber();
    private sealed virtual override string System.Configuration.IConfigXmlNode.get_Filename();
    private sealed virtual override int System.Configuration.IConfigXmlNode.get_LineNumber();
}
internal class System.Configuration.CustomizableFileSettingsProvider : SettingsProvider {
    private static Type webConfigurationFileMapType;
    private static string userRoamingPath;
    private static string userLocalPath;
    private static string userRoamingPathPrevVersion;
    private static string userLocalPathPrevVersion;
    private static string userRoamingName;
    private static string userLocalName;
    private static string userRoamingBasePath;
    private static string userLocalBasePath;
    private static string CompanyName;
    private static string ProductName;
    private static string ForceVersion;
    private static String[] ProductVersion;
    private static bool isVersionMajor;
    private static bool isVersionMinor;
    private static bool isVersionBuild;
    private static bool isVersionRevision;
    private static bool isCompany;
    private static bool isProduct;
    private static bool isEvidence;
    private static bool userDefine;
    private static UserConfigLocationOption userConfig;
    private string app_name;
    private ExeConfigurationFileMap exeMapCurrent;
    private ExeConfigurationFileMap exeMapPrev;
    private SettingsPropertyValueCollection values;
    internal static string UserRoamingFullPath { get; }
    internal static string UserLocalFullPath { get; }
    public static string PrevUserRoamingFullPath { get; }
    public static string PrevUserLocalFullPath { get; }
    public static string UserRoamingPath { get; }
    public static string UserLocalPath { get; }
    public static string UserRoamingName { get; }
    public static string UserLocalName { get; }
    public static UserConfigLocationOption UserConfigSelector { get; public set; }
    public static bool IsVersionMajor { get; public set; }
    public static bool IsVersionMinor { get; public set; }
    public static bool IsVersionBuild { get; public set; }
    public static bool IsVersionRevision { get; public set; }
    public static bool IsCompany { get; public set; }
    public static bool IsEvidence { get; public set; }
    public string Name { get; }
    public string ApplicationName { get; public set; }
    private static CustomizableFileSettingsProvider();
    public virtual void Initialize(string name, NameValueCollection config);
    internal static string get_UserRoamingFullPath();
    internal static string get_UserLocalFullPath();
    public static string get_PrevUserRoamingFullPath();
    public static string get_PrevUserLocalFullPath();
    public static string get_UserRoamingPath();
    public static string get_UserLocalPath();
    public static string get_UserRoamingName();
    public static string get_UserLocalName();
    public static UserConfigLocationOption get_UserConfigSelector();
    public static void set_UserConfigSelector(UserConfigLocationOption value);
    public static bool get_IsVersionMajor();
    public static void set_IsVersionMajor(bool value);
    public static bool get_IsVersionMinor();
    public static void set_IsVersionMinor(bool value);
    public static bool get_IsVersionBuild();
    public static void set_IsVersionBuild(bool value);
    public static bool get_IsVersionRevision();
    public static void set_IsVersionRevision(bool value);
    public static bool get_IsCompany();
    public static void set_IsCompany(bool value);
    public static bool get_IsEvidence();
    public static void set_IsEvidence(bool value);
    private static string GetCompanyName();
    private static string GetProductName();
    private static string GetEvidenceHash();
    private static string GetProductVersion();
    private static void CreateUserConfigPath();
    private static string PrevVersionPath(string dirName, string currentVersion);
    public static bool SetUserRoamingPath(string configPath);
    public static bool SetUserLocalPath(string configPath);
    private static bool CheckFileName(string configFile);
    public static bool SetUserRoamingFileName(string configFile);
    public static bool SetUserLocalFileName(string configFile);
    public static bool SetCompanyName(string companyName);
    public static bool SetProductName(string productName);
    public static bool SetVersion(int major);
    public static bool SetVersion(int major, int minor);
    public static bool SetVersion(int major, int minor, int build);
    public static bool SetVersion(int major, int minor, int build, int revision);
    public static bool SetVersion(string forceVersion);
    private static bool CheckPath(string configPath);
    public virtual string get_Name();
    public virtual string get_ApplicationName();
    public virtual void set_ApplicationName(string value);
    private string StripXmlHeader(string serializedValue);
    private void SaveProperties(ExeConfigurationFileMap exeMap, SettingsPropertyValueCollection collection, ConfigurationUserLevel level, SettingsContext context, bool checkUserLevel);
    private string NormalizeInvalidXmlChars(string str);
    private void LoadPropertyValue(SettingsPropertyCollection collection, SettingElement element, bool allowOverwrite);
    private void LoadProperties(ExeConfigurationFileMap exeMap, SettingsPropertyCollection collection, ConfigurationUserLevel level, string sectionGroupName, bool allowOverwrite, string groupName);
    public virtual void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection);
    public virtual SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection);
    private void CreateExeMap();
    public sealed virtual SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property);
    public sealed virtual void Reset(SettingsContext context);
    public sealed virtual void Upgrade(SettingsContext context, SettingsPropertyCollection properties);
    public static void setCreate();
}
internal class System.Configuration.DefaultConfig : object {
    private static DefaultConfig instance;
    private ConfigurationData config;
    private static DefaultConfig();
    public static DefaultConfig GetInstance();
    [ObsoleteAttribute("This method is obsolete.  Please use System.Configuration.ConfigurationManager.GetConfig")]
public sealed virtual object GetConfig(string sectionName);
    public sealed virtual void Init();
    private static string get_bundled_machine_config();
    internal static string GetBundledMachineConfig();
    private static string get_machine_config_path();
    internal static string GetMachineConfigPath();
    private static string GetAppConfigPath();
}
[AttributeUsageAttribute("128")]
public class System.Configuration.DefaultSettingValueAttribute : Attribute {
    private string value;
    public string Value { get; }
    public DefaultSettingValueAttribute(string value);
    public string get_Value();
}
public class System.Configuration.DictionarySectionHandler : object {
    protected string KeyAttributeName { get; }
    protected string ValueAttributeName { get; }
    public virtual object Create(object parent, object context, XmlNode section);
    protected virtual string get_KeyAttributeName();
    protected virtual string get_ValueAttributeName();
}
public interface System.Configuration.IApplicationSettingsProvider {
    public abstract virtual SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property);
    public abstract virtual void Reset(SettingsContext context);
    public abstract virtual void Upgrade(SettingsContext context, SettingsPropertyCollection properties);
}
public interface System.Configuration.IConfigurationSectionHandler {
    public abstract virtual object Create(object parent, object configContext, XmlNode section);
}
[ComVisibleAttribute("False")]
public interface System.Configuration.IConfigurationSystem {
    public abstract virtual object GetConfig(string configKey);
    public abstract virtual void Init();
}
internal interface System.Configuration.IConfigXmlNode {
    public string Filename { get; }
    public int LineNumber { get; }
    public abstract virtual string get_Filename();
    public abstract virtual int get_LineNumber();
}
public class System.Configuration.IdnElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty enabled_prop;
    internal static UriIdnScope EnabledDefaultValue;
    [ConfigurationPropertyAttribute("enabled")]
public UriIdnScope Enabled { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static IdnElement();
    public UriIdnScope get_Enabled();
    public void set_Enabled(UriIdnScope value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class System.Configuration.IgnoreSectionHandler : object {
    public virtual object Create(object parent, object configContext, XmlNode section);
}
public interface System.Configuration.IPersistComponentSettings {
    public bool SaveSettings { get; public set; }
    public string SettingsKey { get; public set; }
    public abstract virtual bool get_SaveSettings();
    public abstract virtual void set_SaveSettings(bool value);
    public abstract virtual string get_SettingsKey();
    public abstract virtual void set_SettingsKey(string value);
    public abstract virtual void LoadComponentSettings();
    public abstract virtual void ResetComponentSettings();
    public abstract virtual void SaveComponentSettings();
}
public class System.Configuration.IriParsingElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty enabled_prop;
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static IriParsingElement();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public interface System.Configuration.ISettingsProviderService {
    public abstract virtual SettingsProvider GetSettingsProvider(SettingsProperty property);
}
public class System.Configuration.LocalFileSettingsProvider : SettingsProvider {
    private CustomizableFileSettingsProvider impl;
    public string ApplicationName { get; public set; }
    [MonoTODOAttribute]
public sealed virtual SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property);
    [MonoTODOAttribute]
public virtual SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection properties);
    public virtual void Initialize(string name, NameValueCollection values);
    [MonoTODOAttribute]
public sealed virtual void Reset(SettingsContext context);
    [MonoTODOAttribute]
public virtual void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection values);
    [MonoTODOAttribute]
public sealed virtual void Upgrade(SettingsContext context, SettingsPropertyCollection properties);
    public virtual string get_ApplicationName();
    public virtual void set_ApplicationName(string value);
}
public class System.Configuration.NameValueFileSectionHandler : object {
    public sealed virtual object Create(object parent, object configContext, XmlNode section);
}
public class System.Configuration.NameValueSectionHandler : object {
    protected string KeyAttributeName { get; }
    protected string ValueAttributeName { get; }
    public sealed virtual object Create(object parent, object context, XmlNode section);
    protected virtual string get_KeyAttributeName();
    protected virtual string get_ValueAttributeName();
}
[AttributeUsageAttribute("128")]
public class System.Configuration.NoSettingsVersionUpgradeAttribute : Attribute {
}
internal static class System.Configuration.PrivilegedConfigurationManager : object {
    internal static ConnectionStringSettingsCollection ConnectionStrings { get; }
    internal static ConnectionStringSettingsCollection get_ConnectionStrings();
    internal static object GetSection(string sectionName);
}
public class System.Configuration.SchemeSettingElement : ConfigurationElement {
    public GenericUriParserOptions GenericUriParserOptions { get; }
    public string Name { get; }
    public GenericUriParserOptions get_GenericUriParserOptions();
    public string get_Name();
}
[ConfigurationCollectionAttribute("System.Configuration.SchemeSettingElement")]
[DefaultMemberAttribute("Item")]
public class System.Configuration.SchemeSettingElementCollection : ConfigurationElementCollection {
    public SchemeSettingElement Item { get; }
    public SchemeSettingElement get_Item(int index);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(SchemeSettingElement element);
}
internal class System.Configuration.SectionData : object {
    public string SectionName;
    public string TypeName;
    public bool AllowLocation;
    public AllowDefinition AllowDefinition;
    public string FileName;
    public bool RequirePermission;
    public SectionData(string sectionName, string typeName, bool allowLocation, AllowDefinition allowDefinition, bool requirePermission);
}
[AttributeUsageAttribute("128")]
public class System.Configuration.SettingAttribute : Attribute {
}
public class System.Configuration.SettingChangingEventArgs : CancelEventArgs {
    private string settingName;
    private string settingClass;
    private string settingKey;
    private object newValue;
    public string SettingName { get; }
    public string SettingClass { get; }
    public string SettingKey { get; }
    public object NewValue { get; }
    public SettingChangingEventArgs(string settingName, string settingClass, string settingKey, object newValue, bool cancel);
    public string get_SettingName();
    public string get_SettingClass();
    public string get_SettingKey();
    public object get_NewValue();
}
public class System.Configuration.SettingChangingEventHandler : MulticastDelegate {
    public SettingChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SettingChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SettingChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Configuration.SettingElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty name_prop;
    private static ConfigurationProperty serialize_as_prop;
    private static ConfigurationProperty value_prop;
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("value")]
public SettingValueElement Value { get; public set; }
    [ConfigurationPropertyAttribute("serializeAs")]
public SettingsSerializeAs SerializeAs { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static SettingElement();
    public SettingElement(string name, SettingsSerializeAs serializeAs);
    public string get_Name();
    public void set_Name(string value);
    public SettingValueElement get_Value();
    public void set_Value(SettingValueElement value);
    public SettingsSerializeAs get_SerializeAs();
    public void set_SerializeAs(SettingsSerializeAs value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual bool Equals(object settings);
    public virtual int GetHashCode();
}
public class System.Configuration.SettingElementCollection : ConfigurationElementCollection {
    public ConfigurationElementCollectionType CollectionType { get; }
    protected string ElementName { get; }
    public void Add(SettingElement element);
    public void Clear();
    public SettingElement Get(string elementKey);
    public void Remove(SettingElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual string get_ElementName();
}
public class System.Configuration.SettingsAttributeDictionary : Hashtable {
    public SettingsAttributeDictionary(SettingsAttributeDictionary attributes);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Configuration.SettingsBase : object {
    private bool sync;
    private SettingsContext context;
    private SettingsPropertyCollection properties;
    private SettingsProviderCollection providers;
    private SettingsPropertyValueCollection values;
    public SettingsContext Context { get; }
    [BrowsableAttribute("False")]
public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public SettingsPropertyCollection Properties { get; }
    public SettingsPropertyValueCollection PropertyValues { get; }
    public SettingsProviderCollection Providers { get; }
    public void Initialize(SettingsContext context, SettingsPropertyCollection properties, SettingsProviderCollection providers);
    public virtual void Save();
    private void SaveCore();
    public static SettingsBase Synchronized(SettingsBase settingsBase);
    public virtual SettingsContext get_Context();
    public bool get_IsSynchronized();
    public virtual object get_Item(string propertyName);
    public virtual void set_Item(string propertyName, object value);
    public virtual SettingsPropertyCollection get_Properties();
    public virtual SettingsPropertyValueCollection get_PropertyValues();
    public virtual SettingsProviderCollection get_Providers();
    private object GetPropertyValue(string propertyName);
    private void SetPropertyValue(string propertyName, object value);
}
public class System.Configuration.SettingsContext : Hashtable {
    private ApplicationSettingsBase current;
    internal ApplicationSettingsBase CurrentSettings { get; internal set; }
    internal ApplicationSettingsBase get_CurrentSettings();
    internal void set_CurrentSettings(ApplicationSettingsBase value);
}
[AttributeUsageAttribute("128")]
public class System.Configuration.SettingsDescriptionAttribute : Attribute {
    private string desc;
    public string Description { get; }
    public SettingsDescriptionAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("4")]
public class System.Configuration.SettingsGroupDescriptionAttribute : Attribute {
    private string desc;
    public string Description { get; }
    public SettingsGroupDescriptionAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("4")]
public class System.Configuration.SettingsGroupNameAttribute : Attribute {
    private string group_name;
    public string GroupName { get; }
    public SettingsGroupNameAttribute(string groupName);
    public string get_GroupName();
}
public class System.Configuration.SettingsLoadedEventArgs : EventArgs {
    private SettingsProvider provider;
    public SettingsProvider Provider { get; }
    public SettingsLoadedEventArgs(SettingsProvider provider);
    public SettingsProvider get_Provider();
}
public class System.Configuration.SettingsLoadedEventHandler : MulticastDelegate {
    public SettingsLoadedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SettingsLoadedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SettingsLoadedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Configuration.SettingsManageability : Enum {
    public int value__;
    public static SettingsManageability Roaming;
}
[AttributeUsageAttribute("132")]
public class System.Configuration.SettingsManageabilityAttribute : Attribute {
    private SettingsManageability manageability;
    public SettingsManageability Manageability { get; }
    public SettingsManageabilityAttribute(SettingsManageability manageability);
    public SettingsManageability get_Manageability();
}
public class System.Configuration.SettingsProperty : object {
    private string name;
    private Type propertyType;
    private SettingsProvider provider;
    private bool isReadOnly;
    private object defaultValue;
    private SettingsSerializeAs serializeAs;
    private SettingsAttributeDictionary attributes;
    private bool throwOnErrorDeserializing;
    private bool throwOnErrorSerializing;
    public SettingsAttributeDictionary Attributes { get; }
    public object DefaultValue { get; public set; }
    public bool IsReadOnly { get; public set; }
    public string Name { get; public set; }
    public Type PropertyType { get; public set; }
    public SettingsProvider Provider { get; public set; }
    public SettingsSerializeAs SerializeAs { get; public set; }
    public bool ThrowOnErrorDeserializing { get; public set; }
    public bool ThrowOnErrorSerializing { get; public set; }
    public SettingsProperty(SettingsProperty propertyToCopy);
    public SettingsProperty(string name);
    public SettingsProperty(string name, Type propertyType, SettingsProvider provider, bool isReadOnly, object defaultValue, SettingsSerializeAs serializeAs, SettingsAttributeDictionary attributes, bool throwOnErrorDeserializing, bool throwOnErrorSerializing);
    public virtual SettingsAttributeDictionary get_Attributes();
    public virtual object get_DefaultValue();
    public virtual void set_DefaultValue(object value);
    public virtual bool get_IsReadOnly();
    public virtual void set_IsReadOnly(bool value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual Type get_PropertyType();
    public virtual void set_PropertyType(Type value);
    public virtual SettingsProvider get_Provider();
    public virtual void set_Provider(SettingsProvider value);
    public virtual SettingsSerializeAs get_SerializeAs();
    public virtual void set_SerializeAs(SettingsSerializeAs value);
    public bool get_ThrowOnErrorDeserializing();
    public void set_ThrowOnErrorDeserializing(bool value);
    public bool get_ThrowOnErrorSerializing();
    public void set_ThrowOnErrorSerializing(bool value);
}
[DefaultMemberAttribute("Item")]
public class System.Configuration.SettingsPropertyCollection : object {
    private Hashtable items;
    private bool isReadOnly;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public SettingsProperty Item { get; }
    public object SyncRoot { get; }
    public void Add(SettingsProperty property);
    public void Clear();
    public sealed virtual object Clone();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IEnumerator GetEnumerator();
    public void Remove(string name);
    public void SetReadOnly();
    protected virtual void OnAdd(SettingsProperty property);
    protected virtual void OnAddComplete(SettingsProperty property);
    protected virtual void OnClear();
    protected virtual void OnClearComplete();
    protected virtual void OnRemove(SettingsProperty property);
    protected virtual void OnRemoveComplete(SettingsProperty property);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public SettingsProperty get_Item(string name);
    public sealed virtual object get_SyncRoot();
}
public class System.Configuration.SettingsPropertyIsReadOnlyException : Exception {
    public SettingsPropertyIsReadOnlyException(string message);
    protected SettingsPropertyIsReadOnlyException(SerializationInfo info, StreamingContext context);
    public SettingsPropertyIsReadOnlyException(string message, Exception innerException);
}
public class System.Configuration.SettingsPropertyNotFoundException : Exception {
    public SettingsPropertyNotFoundException(string message);
    protected SettingsPropertyNotFoundException(SerializationInfo info, StreamingContext context);
    public SettingsPropertyNotFoundException(string message, Exception innerException);
}
public class System.Configuration.SettingsPropertyValue : object {
    private SettingsProperty property;
    private object propertyValue;
    private object serializedValue;
    private bool needSerializedValue;
    private bool needPropertyValue;
    private bool dirty;
    private bool defaulted;
    private bool deserialized;
    public bool Deserialized { get; public set; }
    public bool IsDirty { get; public set; }
    public string Name { get; }
    public SettingsProperty Property { get; }
    public object PropertyValue { get; public set; }
    public object SerializedValue { get; public set; }
    public bool UsingDefaultValue { get; }
    public SettingsPropertyValue(SettingsProperty property);
    public bool get_Deserialized();
    public void set_Deserialized(bool value);
    public bool get_IsDirty();
    public void set_IsDirty(bool value);
    public string get_Name();
    public SettingsProperty get_Property();
    public object get_PropertyValue();
    public void set_PropertyValue(object value);
    public object get_SerializedValue();
    public void set_SerializedValue(object value);
    public bool get_UsingDefaultValue();
    internal object Reset();
    private object GetDeserializedDefaultValue();
    private object GetDeserializedValue(object serializedValue);
}
[DefaultMemberAttribute("Item")]
public class System.Configuration.SettingsPropertyValueCollection : object {
    private Hashtable items;
    private bool isReadOnly;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public SettingsPropertyValue Item { get; }
    public object SyncRoot { get; }
    public void Add(SettingsPropertyValue property);
    internal void Add(SettingsPropertyValueCollection vals);
    public void Clear();
    public sealed virtual object Clone();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IEnumerator GetEnumerator();
    public void Remove(string name);
    public void SetReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public SettingsPropertyValue get_Item(string name);
    public sealed virtual object get_SyncRoot();
}
public class System.Configuration.SettingsPropertyWrongTypeException : Exception {
    public SettingsPropertyWrongTypeException(string message);
    protected SettingsPropertyWrongTypeException(SerializationInfo info, StreamingContext context);
    public SettingsPropertyWrongTypeException(string message, Exception innerException);
}
public abstract class System.Configuration.SettingsProvider : ProviderBase {
    public string ApplicationName { get; public set; }
    public abstract virtual SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection);
    public abstract virtual void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection);
    public abstract virtual string get_ApplicationName();
    public abstract virtual void set_ApplicationName(string value);
}
[AttributeUsageAttribute("132")]
public class System.Configuration.SettingsProviderAttribute : Attribute {
    private string providerTypeName;
    public string ProviderTypeName { get; }
    public SettingsProviderAttribute(string providerTypeName);
    public SettingsProviderAttribute(Type providerType);
    public string get_ProviderTypeName();
}
[DefaultMemberAttribute("Item")]
public class System.Configuration.SettingsProviderCollection : ProviderCollection {
    public SettingsProvider Item { get; }
    public virtual void Add(ProviderBase provider);
    public SettingsProvider get_Item(string name);
}
public class System.Configuration.SettingsSavingEventHandler : MulticastDelegate {
    public SettingsSavingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Configuration.SettingsSerializeAs : Enum {
    public int value__;
    public static SettingsSerializeAs String;
    public static SettingsSerializeAs Xml;
    public static SettingsSerializeAs Binary;
    public static SettingsSerializeAs ProviderSpecific;
}
[AttributeUsageAttribute("132")]
public class System.Configuration.SettingsSerializeAsAttribute : Attribute {
    private SettingsSerializeAs serializeAs;
    public SettingsSerializeAs SerializeAs { get; }
    public SettingsSerializeAsAttribute(SettingsSerializeAs serializeAs);
    public SettingsSerializeAs get_SerializeAs();
}
public class System.Configuration.SettingValueElement : ConfigurationElement {
    private XmlNode node;
    private XmlNode original;
    [MonoTODOAttribute]
protected ConfigurationPropertyCollection Properties { get; }
    public XmlNode ValueXml { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public XmlNode get_ValueXml();
    public void set_ValueXml(XmlNode value);
    [MonoTODOAttribute]
protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    public virtual bool Equals(object settingValue);
    public virtual int GetHashCode();
    protected virtual bool IsModified();
    protected virtual void Reset(ConfigurationElement parentElement);
    protected virtual void ResetModified();
    protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    private bool HasValue(ConfigurationElement element, string propName);
    private object GetItem(ConfigurationElement element, string property);
    private bool PropertyIsElement(PropertyInformation prop);
    private bool ElementIsModified(ConfigurationElement element);
    private void ElementUnmerge(ConfigurationElement target, ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
}
public class System.Configuration.SingleTagSectionHandler : object {
    public virtual object Create(object parent, object context, XmlNode section);
}
public enum System.Configuration.SpecialSetting : Enum {
    public int value__;
    public static SpecialSetting ConnectionString;
    public static SpecialSetting WebServiceUrl;
}
[AttributeUsageAttribute("132")]
public class System.Configuration.SpecialSettingAttribute : Attribute {
    private SpecialSetting setting;
    public SpecialSetting SpecialSetting { get; }
    public SpecialSettingAttribute(SpecialSetting specialSetting);
    public SpecialSetting get_SpecialSetting();
}
public class System.Configuration.UriSection : ConfigurationSection {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty idn_prop;
    private static ConfigurationProperty iriParsing_prop;
    [ConfigurationPropertyAttribute("idn")]
public IdnElement Idn { get; }
    [ConfigurationPropertyAttribute("iriParsing")]
public IriParsingElement IriParsing { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public SchemeSettingElementCollection SchemeSettings { get; }
    private static UriSection();
    public IdnElement get_Idn();
    public IriParsingElement get_IriParsing();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public SchemeSettingElementCollection get_SchemeSettings();
}
internal enum System.Configuration.UserConfigLocationOption : Enum {
    public UInt32 value__;
    public static UserConfigLocationOption Product;
    public static UserConfigLocationOption Product_VersionMajor;
    public static UserConfigLocationOption Product_VersionMinor;
    public static UserConfigLocationOption Product_VersionBuild;
    public static UserConfigLocationOption Product_VersionRevision;
    public static UserConfigLocationOption Company_Product;
    public static UserConfigLocationOption Company_Product_VersionMajor;
    public static UserConfigLocationOption Company_Product_VersionMinor;
    public static UserConfigLocationOption Company_Product_VersionBuild;
    public static UserConfigLocationOption Company_Product_VersionRevision;
    public static UserConfigLocationOption Evidence;
    public static UserConfigLocationOption Other;
}
[AttributeUsageAttribute("128")]
public class System.Configuration.UserScopedSettingAttribute : SettingAttribute {
}
public class System.Configuration.UserSettingsGroup : ConfigurationSectionGroup {
}
internal abstract class System.CSharpHelpers : object {
    private static Dictionary`2<string, object> s_fixedStringLookup;
    private static String[][] s_keywords;
    private static CSharpHelpers();
    public static string CreateEscapedIdentifier(string name);
    public static bool IsValidLanguageIndependentIdentifier(string value);
    internal static bool IsKeyword(string value);
    internal static bool IsPrefixTwoUnderscore(string value);
    internal static bool IsValidTypeNameOrIdentifier(string value, bool isTypeName);
    internal static bool IsSpecialTypeChar(char ch, Boolean& nextMustBeStartChar);
}
internal class System.Diagnostics.AlphabeticalEnumConverter : EnumConverter {
    public AlphabeticalEnumConverter(Type type);
    [MonoTODOAttribute("Create sorted standart values")]
public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
}
internal class System.Diagnostics.AssertSection : ConfigurationElement {
    private static ConfigurationPropertyCollection _properties;
    private static ConfigurationProperty _propAssertUIEnabled;
    private static ConfigurationProperty _propLogFile;
    [ConfigurationPropertyAttribute("assertuienabled")]
public bool AssertUIEnabled { get; }
    [ConfigurationPropertyAttribute("logfilename")]
public string LogFileName { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static AssertSection();
    public bool get_AssertUIEnabled();
    public string get_LogFileName();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.Diagnostics.AssertWrapper : object {
    public static void ShowAssert(string stackTrace, StackFrame frame, string message, string detailMessage);
}
internal class System.Diagnostics.AsyncStreamReader : object {
    internal static int DefaultBufferSize;
    private static int MinBufferSize;
    private Stream stream;
    private Encoding encoding;
    private Decoder decoder;
    private Byte[] byteBuffer;
    private Char[] charBuffer;
    private int _maxCharsPerBuffer;
    private Process process;
    private UserCallBack userCallBack;
    private bool cancelOperation;
    private ManualResetEvent eofEvent;
    private Queue messageQueue;
    private StringBuilder sb;
    private bool bLastCarriageReturn;
    private int currentLinePos;
    private object syncObject;
    private IAsyncResult asyncReadResult;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    internal AsyncStreamReader(Process process, Stream stream, UserCallBack callback, Encoding encoding);
    internal AsyncStreamReader(Process process, Stream stream, UserCallBack callback, Encoding encoding, int bufferSize);
    private void Init(Process process, Stream stream, UserCallBack callback, Encoding encoding, int bufferSize);
    public virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    internal void BeginReadLine();
    internal void CancelOperation();
    private void ReadBuffer(IAsyncResult ar);
    private void GetLinesFromStringBuilder();
    private void FlushMessageQueue();
    internal void WaitUtilEOF();
}
[SwitchLevelAttribute("System.Boolean")]
public class System.Diagnostics.BooleanSwitch : Switch {
    public bool Enabled { get; public set; }
    public BooleanSwitch(string displayName, string description);
    public BooleanSwitch(string displayName, string description, string defaultSwitchValue);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    protected virtual void OnValueChanged();
}
[AttributeUsageAttribute("749")]
public class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
internal class System.Diagnostics.ConfigurationManagerInternalFactory : object {
}
public class System.Diagnostics.ConsoleTraceListener : TextWriterTraceListener {
    public ConsoleTraceListener(bool useErrorStream);
    public virtual void Close();
}
public class System.Diagnostics.CorrelationManager : object {
    private static string transactionSlotName;
    private static string activityIdSlotName;
    public Guid ActivityId { get; public set; }
    public Stack LogicalOperationStack { get; }
    public Guid get_ActivityId();
    public void set_ActivityId(Guid value);
    public Stack get_LogicalOperationStack();
    public void StartLogicalOperation(object operationId);
    public void StartLogicalOperation();
    public void StopLogicalOperation();
    private Stack GetLogicalOperationStack();
}
[TypeConverterAttribute("System.Diagnostics.Design.CounterCreationDataConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Diagnostics.CounterCreationData : object {
    private string help;
    private string name;
    private PerformanceCounterType type;
    [DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("Description of this counter.")]
public string CounterHelp { get; public set; }
    [DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("Name of this counter.")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public string CounterName { get; public set; }
    [MonitoringDescriptionAttribute("Type of this counter.")]
[DefaultValueAttribute("System.Diagnostics.PerformanceCounterType", "NumberOfItems32")]
public PerformanceCounterType CounterType { get; public set; }
    public CounterCreationData(string counterName, string counterHelp, PerformanceCounterType counterType);
    public string get_CounterHelp();
    public void set_CounterHelp(string value);
    public string get_CounterName();
    public void set_CounterName(string value);
    public PerformanceCounterType get_CounterType();
    public void set_CounterType(PerformanceCounterType value);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.CounterCreationDataCollection : CollectionBase {
    public CounterCreationData Item { get; public set; }
    public CounterCreationDataCollection(CounterCreationData[] value);
    public CounterCreationDataCollection(CounterCreationDataCollection value);
    public CounterCreationData get_Item(int index);
    public void set_Item(int index, CounterCreationData value);
    public int Add(CounterCreationData value);
    public void AddRange(CounterCreationData[] value);
    public void AddRange(CounterCreationDataCollection value);
    public bool Contains(CounterCreationData value);
    public void CopyTo(CounterCreationData[] array, int index);
    public int IndexOf(CounterCreationData value);
    public void Insert(int index, CounterCreationData value);
    protected virtual void OnValidate(object value);
    public virtual void Remove(CounterCreationData value);
}
public class System.Diagnostics.CounterSample : ValueType {
    private long rawValue;
    private long baseValue;
    private long counterFrequency;
    private long systemFrequency;
    private long timeStamp;
    private long timeStamp100nSec;
    private long counterTimeStamp;
    private PerformanceCounterType counterType;
    public static CounterSample Empty;
    public long BaseValue { get; }
    public long CounterFrequency { get; }
    public long CounterTimeStamp { get; }
    public PerformanceCounterType CounterType { get; }
    public long RawValue { get; }
    public long SystemFrequency { get; }
    public long TimeStamp { get; }
    public long TimeStamp100nSec { get; }
    public CounterSample(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType);
    public CounterSample(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType, long counterTimeStamp);
    private static CounterSample();
    public long get_BaseValue();
    public long get_CounterFrequency();
    public long get_CounterTimeStamp();
    public PerformanceCounterType get_CounterType();
    public long get_RawValue();
    public long get_SystemFrequency();
    public long get_TimeStamp();
    public long get_TimeStamp100nSec();
    public static float Calculate(CounterSample counterSample);
    public static float Calculate(CounterSample counterSample, CounterSample nextCounterSample);
    public virtual bool Equals(object o);
    public bool Equals(CounterSample sample);
    public static bool op_Equality(CounterSample a, CounterSample b);
    public static bool op_Inequality(CounterSample a, CounterSample b);
    public virtual int GetHashCode();
}
public static class System.Diagnostics.CounterSampleCalculator : object {
    public static float ComputeCounterValue(CounterSample newSample);
    [MonoTODOAttribute("What's the algorithm?")]
public static float ComputeCounterValue(CounterSample oldSample, CounterSample newSample);
}
public class System.Diagnostics.DataReceivedEventArgs : EventArgs {
    private string data;
    public string Data { get; }
    internal DataReceivedEventArgs(string data);
    public string get_Data();
}
public class System.Diagnostics.DataReceivedEventHandler : MulticastDelegate {
    public DataReceivedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataReceivedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataReceivedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Diagnostics.Debug : object {
    public static TraceListenerCollection Listeners { get; }
    public static bool AutoFlush { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    public static TraceListenerCollection get_Listeners();
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("DEBUG")]
public static void Flush();
    [ConditionalAttribute("DEBUG")]
public static void Close();
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Print(string message);
    [ConditionalAttribute("DEBUG")]
public static void Print(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
}
public class System.Diagnostics.DefaultTraceListener : TraceListener {
    private static bool OnWin32;
    private static string ConsoleOutTrace;
    private static string ConsoleErrorTrace;
    private static string MonoTracePrefix;
    private static string MonoTraceFile;
    private string logFileName;
    private bool assertUiEnabled;
    [MonoTODOAttribute("AssertUiEnabled defaults to False; should follow Environment.UserInteractive.")]
public bool AssertUiEnabled { get; public set; }
    [MonoTODOAttribute]
public string LogFileName { get; public set; }
    private static DefaultTraceListener();
    private static string GetPrefix(string var, string target);
    public bool get_AssertUiEnabled();
    public void set_AssertUiEnabled(bool value);
    public string get_LogFileName();
    public void set_LogFileName(string value);
    public virtual void Fail(string message);
    public virtual void Fail(string message, string detailMessage);
    private DialogResult ProcessUI(string message, string detailMessage);
    private static void WriteWindowsDebugString(Char* message);
    private void WriteDebugString(string message);
    private void WriteMonoTrace(string message);
    private void WritePrefix();
    private void WriteImpl(string message);
    private void WriteLogFile(string message, string logFile);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
}
public class System.Diagnostics.DelimitedListTraceListener : TextWriterTraceListener {
    private string delimiter;
    private string secondaryDelim;
    private bool initializedDelim;
    public string Delimiter { get; public set; }
    public DelimitedListTraceListener(Stream stream);
    public DelimitedListTraceListener(Stream stream, string name);
    public DelimitedListTraceListener(TextWriter writer);
    public DelimitedListTraceListener(TextWriter writer, string name);
    public DelimitedListTraceListener(string fileName);
    public DelimitedListTraceListener(string fileName, string name);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    protected internal virtual String[] GetSupportedAttributes();
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    private void WriteHeader(string source, TraceEventType eventType, int id);
    private void WriteFooter(TraceEventCache eventCache);
    private void WriteEscaped(string message);
    private void WriteStackEscaped(Stack stack);
}
internal static class System.Diagnostics.DiagnosticsConfiguration : object {
    private static SystemDiagnosticsSection modreq(System.Runtime.CompilerServices.IsVolatile) configSection;
    private static InitState modreq(System.Runtime.CompilerServices.IsVolatile) initState;
    internal static SwitchElementsCollection SwitchSettings { get; }
    internal static bool AssertUIEnabled { get; }
    internal static string ConfigFilePath { get; }
    internal static string LogFileName { get; }
    internal static bool AutoFlush { get; }
    internal static bool UseGlobalLock { get; }
    internal static int IndentSize { get; }
    internal static ListenerElementsCollection SharedListeners { get; }
    internal static SourceElementsCollection Sources { get; }
    internal static SystemDiagnosticsSection SystemDiagnosticsSection { get; }
    internal static SwitchElementsCollection get_SwitchSettings();
    internal static bool get_AssertUIEnabled();
    internal static string get_ConfigFilePath();
    internal static string get_LogFileName();
    internal static bool get_AutoFlush();
    internal static bool get_UseGlobalLock();
    internal static int get_IndentSize();
    internal static ListenerElementsCollection get_SharedListeners();
    internal static SourceElementsCollection get_Sources();
    internal static SystemDiagnosticsSection get_SystemDiagnosticsSection();
    private static SystemDiagnosticsSection GetConfigSection();
    internal static bool IsInitializing();
    internal static bool IsInitialized();
    internal static bool CanInitialize();
    internal static void Initialize();
    internal static void Refresh();
}
[ObsoleteAttribute("This class is obsoleted")]
public class System.Diagnostics.DiagnosticsConfigurationHandler : object {
    private TraceImplSettings configValues;
    private IDictionary elementHandlers;
    public virtual object Create(object parent, object configContext, XmlNode section);
    private void AddAssertNode(IDictionary d, XmlNode node);
    private void AddPerformanceCountersNode(IDictionary d, XmlNode node);
    private void AddSwitchesNode(IDictionary d, XmlNode node);
    private static object GetSwitchValue(string name, string value);
    private void AddTraceNode(IDictionary d, XmlNode node);
    private void AddTraceAttributes(IDictionary d, XmlNode node);
    private TraceListenerCollection GetSharedListeners(IDictionary d);
    private void AddSourcesNode(IDictionary d, XmlNode node);
    private void AddTraceSource(IDictionary d, Hashtable sources, XmlNode node);
    private void AddTraceListeners(IDictionary d, XmlNode listenersNode, TraceListenerCollection listeners);
    private void AddTraceListener(IDictionary d, XmlNode child, XmlAttributeCollection attributes, TraceListenerCollection listeners);
    private void RemoveTraceListener(string name);
    private string GetAttribute(XmlAttributeCollection attrs, string attr, bool required, XmlNode node);
    private void ValidateAttribute(string attribute, string value, XmlNode node);
    private void ValidateInvalidAttributes(XmlAttributeCollection c, XmlNode node);
    private void ThrowMissingAttribute(string attribute, XmlNode node);
    private void ThrowUnrecognizedNode(XmlNode node);
    private void ThrowUnrecognizedElement(XmlNode node);
    private void ThrowUnrecognizedAttribute(string attribute, XmlNode node);
}
public class System.Diagnostics.EntryWrittenEventArgs : EventArgs {
    private EventLogEntry entry;
    public EventLogEntry Entry { get; }
    public EntryWrittenEventArgs(EventLogEntry entry);
    public EventLogEntry get_Entry();
}
public class System.Diagnostics.EntryWrittenEventHandler : MulticastDelegate {
    public EntryWrittenEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EntryWrittenEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EntryWrittenEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Diagnostics.EnvironmentBlock : object {
    public static Byte[] ToByteArray(StringDictionary sd, bool unicode);
}
public class System.Diagnostics.EventInstance : object {
    private int _categoryId;
    private EventLogEntryType _entryType;
    private long _instanceId;
    public int CategoryId { get; public set; }
    public EventLogEntryType EntryType { get; public set; }
    public long InstanceId { get; public set; }
    public EventInstance(long instanceId, int categoryId);
    public EventInstance(long instanceId, int categoryId, EventLogEntryType entryType);
    public int get_CategoryId();
    public void set_CategoryId(int value);
    public EventLogEntryType get_EntryType();
    public void set_EntryType(EventLogEntryType value);
    public long get_InstanceId();
    public void set_InstanceId(long value);
}
[InstallerTypeAttribute("System.Diagnostics.EventLogInstaller")]
[MonitoringDescriptionAttribute("Represents an event log")]
[DefaultEventAttribute("EntryWritten")]
public class System.Diagnostics.EventLog : Component {
    private string source;
    private string logName;
    private string machineName;
    private bool doRaiseEvents;
    private ISynchronizeInvoke synchronizingObject;
    internal static string LOCAL_FILE_IMPL;
    private static string WIN32_IMPL;
    private static string NULL_IMPL;
    internal static string EVENTLOG_TYPE_VAR;
    private EventLogImpl Impl;
    [CompilerGeneratedAttribute]
private EntryWrittenEventHandler EntryWritten;
    [BrowsableAttribute("False")]
[DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("If enabled raises event when a log is written.")]
public bool EnableRaisingEvents { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The entries in the log.")]
public EventLogEntryCollection Entries { get; }
    [ReadOnlyAttribute("True")]
[DefaultValueAttribute("")]
[RecommendedAsConfigurableAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[MonitoringDescriptionAttribute("Name of the log that is read and written.")]
public string Log { get; public set; }
    [BrowsableAttribute("False")]
public string LogDisplayName { get; }
    [RecommendedAsConfigurableAttribute("True")]
[DefaultValueAttribute(".")]
[ReadOnlyAttribute("True")]
[MonitoringDescriptionAttribute("Name of the machine that this log get written to.")]
public string MachineName { get; public set; }
    [ReadOnlyAttribute("True")]
[DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("The application name that writes the log.")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[RecommendedAsConfigurableAttribute("True")]
public string Source { get; public set; }
    [MonitoringDescriptionAttribute("An object that synchronizes event handler calls.")]
[BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    [MonoTODOAttribute]
[BrowsableAttribute("False")]
[ComVisibleAttribute("False")]
public OverflowAction OverflowAction { get; }
    [ComVisibleAttribute("False")]
[MonoTODOAttribute]
[BrowsableAttribute("False")]
public int MinimumRetentionDays { get; }
    [MonoTODOAttribute]
[ComVisibleAttribute("False")]
[BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public long MaximumKilobytes { get; public set; }
    private static bool Win32EventLogEnabled { get; }
    private static string EventLogImplType { get; }
    public EventLog(string logName);
    public EventLog(string logName, string machineName);
    public EventLog(string logName, string machineName, string source);
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public EventLogEntryCollection get_Entries();
    public string get_Log();
    public void set_Log(string value);
    public string get_LogDisplayName();
    public string get_MachineName();
    public void set_MachineName(string value);
    public string get_Source();
    public void set_Source(string value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public OverflowAction get_OverflowAction();
    public int get_MinimumRetentionDays();
    public long get_MaximumKilobytes();
    public void set_MaximumKilobytes(long value);
    [MonoTODOAttribute]
[ComVisibleAttribute("False")]
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    [ComVisibleAttribute("False")]
[MonoTODOAttribute]
public void RegisterDisplayName(string resourceFile, long resourceId);
    public sealed virtual void BeginInit();
    public void Clear();
    public void Close();
    internal void Reset();
    public static void CreateEventSource(string source, string logName);
    [ObsoleteAttribute("use CreateEventSource(EventSourceCreationData) instead")]
public static void CreateEventSource(string source, string logName, string machineName);
    [MonoNotSupportedAttribute("remote machine is not supported")]
public static void CreateEventSource(EventSourceCreationData sourceData);
    public static void Delete(string logName);
    [MonoNotSupportedAttribute("remote machine is not supported")]
public static void Delete(string logName, string machineName);
    public static void DeleteEventSource(string source);
    [MonoNotSupportedAttribute("remote machine is not supported")]
public static void DeleteEventSource(string source, string machineName);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    public static bool Exists(string logName);
    [MonoNotSupportedAttribute("remote machine is not supported")]
public static bool Exists(string logName, string machineName);
    public static EventLog[] GetEventLogs();
    [MonoNotSupportedAttribute("remote machine is not supported")]
public static EventLog[] GetEventLogs(string machineName);
    [MonoNotSupportedAttribute("remote machine is not supported")]
public static string LogNameFromSourceName(string source, string machineName);
    public static bool SourceExists(string source);
    [MonoNotSupportedAttribute("remote machine is not supported")]
public static bool SourceExists(string source, string machineName);
    public void WriteEntry(string message);
    public void WriteEntry(string message, EventLogEntryType type);
    public void WriteEntry(string message, EventLogEntryType type, int eventID);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    public static void WriteEntry(string source, string message);
    public static void WriteEntry(string source, string message, EventLogEntryType type);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    [ComVisibleAttribute("False")]
public void WriteEvent(EventInstance instance, Object[] values);
    [ComVisibleAttribute("False")]
public void WriteEvent(EventInstance instance, Byte[] data, Object[] values);
    public static void WriteEvent(string source, EventInstance instance, Object[] values);
    public static void WriteEvent(string source, EventInstance instance, Byte[] data, Object[] values);
    internal void OnEntryWritten(EventLogEntry newEntry);
    [CompilerGeneratedAttribute]
public void add_EntryWritten(EntryWrittenEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EntryWritten(EntryWrittenEventHandler value);
    internal string GetLogName();
    private static EventLogImpl CreateEventLogImpl(string logName, string machineName, string source);
    private static EventLogImpl CreateEventLogImpl(EventLog eventLog);
    private static bool get_Win32EventLogEnabled();
    private static string get_EventLogImplType();
    private void WriteEntry(String[] replacementStrings, EventLogEntryType type, long instanceID, short category, Byte[] rawData);
    private void ValidateEventID(long instanceID);
    internal static int GetEventID(long instanceID);
}
[DesignTimeVisibleAttribute("False")]
[ToolboxItemAttribute("False")]
public class System.Diagnostics.EventLogEntry : Component {
    private string category;
    private short categoryNumber;
    private Byte[] data;
    private EventLogEntryType entryType;
    private int eventID;
    private int index;
    private string machineName;
    private string message;
    private String[] replacementStrings;
    private string source;
    private DateTime timeGenerated;
    private DateTime timeWritten;
    private string userName;
    private long instanceId;
    [MonitoringDescriptionAttribute("The category of this event entry.")]
public string Category { get; }
    [MonitoringDescriptionAttribute("An ID for the category of this event entry.")]
public short CategoryNumber { get; }
    [MonitoringDescriptionAttribute("Binary data associated with this event entry.")]
public Byte[] Data { get; }
    [MonitoringDescriptionAttribute("The type of this event entry.")]
public EventLogEntryType EntryType { get; }
    [MonitoringDescriptionAttribute("An ID number for this event entry.")]
[ObsoleteAttribute("Use InstanceId")]
public int EventID { get; }
    [MonitoringDescriptionAttribute("Sequence numer of this event entry.")]
public int Index { get; }
    [MonitoringDescriptionAttribute("The instance ID for this event entry.")]
[ComVisibleAttribute("False")]
public long InstanceId { get; }
    [MonitoringDescriptionAttribute("The Computer on which this event entry occured.")]
public string MachineName { get; }
    [MonitoringDescriptionAttribute("The message of this event entry.")]
[EditorAttribute("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public string Message { get; }
    [MonitoringDescriptionAttribute("Application strings for this event entry.")]
public String[] ReplacementStrings { get; }
    [MonitoringDescriptionAttribute("The source application of this event entry.")]
public string Source { get; }
    [MonitoringDescriptionAttribute("Generation time of this event entry.")]
public DateTime TimeGenerated { get; }
    [MonitoringDescriptionAttribute("The time at which this event entry was written to the logfile.")]
public DateTime TimeWritten { get; }
    [MonitoringDescriptionAttribute("The name of a user associated with this event entry.")]
public string UserName { get; }
    internal EventLogEntry(string category, short categoryNumber, int index, int eventID, string source, string message, string userName, string machineName, EventLogEntryType entryType, DateTime timeGenerated, DateTime timeWritten, Byte[] data, String[] replacementStrings, long instanceId);
    [MonoTODOAttribute]
private EventLogEntry(SerializationInfo info, StreamingContext context);
    public string get_Category();
    public short get_CategoryNumber();
    public Byte[] get_Data();
    public EventLogEntryType get_EntryType();
    public int get_EventID();
    public int get_Index();
    public long get_InstanceId();
    public string get_MachineName();
    public string get_Message();
    public String[] get_ReplacementStrings();
    public string get_Source();
    public DateTime get_TimeGenerated();
    public DateTime get_TimeWritten();
    public string get_UserName();
    public bool Equals(EventLogEntry otherEntry);
    [MonoTODOAttribute("Needs serialization support")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.EventLogEntryCollection : object {
    private EventLogImpl _impl;
    public int Count { get; }
    public EventLogEntry Item { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal EventLogEntryCollection(EventLogImpl impl);
    public sealed virtual int get_Count();
    public virtual EventLogEntry get_Item(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void CopyTo(EventLogEntry[] entries, int index);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
public enum System.Diagnostics.EventLogEntryType : Enum {
    public int value__;
    public static EventLogEntryType Error;
    public static EventLogEntryType Warning;
    public static EventLogEntryType Information;
    public static EventLogEntryType SuccessAudit;
    public static EventLogEntryType FailureAudit;
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Diagnostics.EventLogImpl : object {
    private EventLog _coreEventLog;
    protected EventLog CoreEventLog { get; }
    public int EntryCount { get; }
    public EventLogEntry Item { get; }
    public string LogDisplayName { get; }
    public OverflowAction OverflowAction { get; }
    public int MinimumRetentionDays { get; }
    public long MaximumKilobytes { get; public set; }
    protected EventLogImpl(EventLog coreEventLog);
    protected EventLog get_CoreEventLog();
    public int get_EntryCount();
    public EventLogEntry get_Item(int index);
    public string get_LogDisplayName();
    public EventLogEntry[] GetEntries();
    public abstract virtual void DisableNotification();
    public abstract virtual void EnableNotification();
    public abstract virtual void BeginInit();
    public abstract virtual void Clear();
    public abstract virtual void Close();
    public abstract virtual void CreateEventSource(EventSourceCreationData sourceData);
    public abstract virtual void Delete(string logName, string machineName);
    public abstract virtual void DeleteEventSource(string source, string machineName);
    public abstract virtual void Dispose(bool disposing);
    public abstract virtual void EndInit();
    public abstract virtual bool Exists(string logName, string machineName);
    protected abstract virtual int GetEntryCount();
    protected abstract virtual EventLogEntry GetEntry(int index);
    public EventLog[] GetEventLogs(string machineName);
    protected abstract virtual string GetLogDisplayName();
    public abstract virtual string LogNameFromSourceName(string source, string machineName);
    public abstract virtual bool SourceExists(string source, string machineName);
    public abstract virtual void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData);
    protected abstract virtual string FormatMessage(string source, UInt32 messageID, String[] replacementStrings);
    protected abstract virtual String[] GetLogNames(string machineName);
    protected void ValidateCustomerLogName(string logName, string machineName);
    public abstract virtual OverflowAction get_OverflowAction();
    public abstract virtual int get_MinimumRetentionDays();
    public abstract virtual long get_MaximumKilobytes();
    public abstract virtual void set_MaximumKilobytes(long value);
    public abstract virtual void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    public abstract virtual void RegisterDisplayName(string resourceFile, long resourceId);
}
[MonoTODOAttribute]
internal class System.Diagnostics.EventLogInstaller : object {
}
public class System.Diagnostics.EventLogPermission : ResourcePermissionBase {
    private EventLogPermissionEntryCollection innerCollection;
    public EventLogPermissionEntryCollection PermissionEntries { get; }
    public EventLogPermission(EventLogPermissionEntry[] permissionAccessEntries);
    public EventLogPermission(PermissionState state);
    public EventLogPermission(EventLogPermissionAccess permissionAccess, string machineName);
    public EventLogPermissionEntryCollection get_PermissionEntries();
    private void SetUp();
    internal ResourcePermissionBaseEntry[] GetEntries();
    internal void ClearEntries();
    internal void Add(object obj);
    internal void Remove(object obj);
}
[FlagsAttribute]
public enum System.Diagnostics.EventLogPermissionAccess : Enum {
    public int value__;
    public static EventLogPermissionAccess None;
    [ObsoleteAttribute]
public static EventLogPermissionAccess Browse;
    [ObsoleteAttribute]
public static EventLogPermissionAccess Instrument;
    [ObsoleteAttribute]
public static EventLogPermissionAccess Audit;
    public static EventLogPermissionAccess Write;
    public static EventLogPermissionAccess Administer;
}
[AttributeUsageAttribute("621")]
public class System.Diagnostics.EventLogPermissionAttribute : CodeAccessSecurityAttribute {
    private string machineName;
    private EventLogPermissionAccess permissionAccess;
    public string MachineName { get; public set; }
    public EventLogPermissionAccess PermissionAccess { get; public set; }
    public EventLogPermissionAttribute(SecurityAction action);
    public string get_MachineName();
    public void set_MachineName(string value);
    public EventLogPermissionAccess get_PermissionAccess();
    public void set_PermissionAccess(EventLogPermissionAccess value);
    public virtual IPermission CreatePermission();
}
public class System.Diagnostics.EventLogPermissionEntry : object {
    private EventLogPermissionAccess permissionAccess;
    private string machineName;
    public string MachineName { get; }
    public EventLogPermissionAccess PermissionAccess { get; }
    public EventLogPermissionEntry(EventLogPermissionAccess permissionAccess, string machineName);
    public string get_MachineName();
    public EventLogPermissionAccess get_PermissionAccess();
    internal ResourcePermissionBaseEntry CreateResourcePermissionBaseEntry();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.EventLogPermissionEntryCollection : CollectionBase {
    private EventLogPermission owner;
    public EventLogPermissionEntry Item { get; public set; }
    internal EventLogPermissionEntryCollection(EventLogPermission owner);
    public EventLogPermissionEntry get_Item(int index);
    public void set_Item(int index, EventLogPermissionEntry value);
    public int Add(EventLogPermissionEntry value);
    public void AddRange(EventLogPermissionEntry[] value);
    public void AddRange(EventLogPermissionEntryCollection value);
    public bool Contains(EventLogPermissionEntry value);
    public void CopyTo(EventLogPermissionEntry[] array, int index);
    public int IndexOf(EventLogPermissionEntry value);
    public void Insert(int index, EventLogPermissionEntry value);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    public void Remove(EventLogPermissionEntry value);
}
public class System.Diagnostics.EventLogTraceListener : TraceListener {
    private EventLog event_log;
    private string name;
    public EventLog EventLog { get; public set; }
    public string Name { get; public set; }
    public EventLogTraceListener(EventLog eventLog);
    public EventLogTraceListener(string source);
    public EventLog get_EventLog();
    public void set_EventLog(EventLog value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, object data);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, Object[] data);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string message);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string format, Object[] args);
}
public class System.Diagnostics.EventSourceCreationData : object {
    private string _source;
    private string _logName;
    private string _machineName;
    private string _messageResourceFile;
    private string _parameterResourceFile;
    private string _categoryResourceFile;
    private int _categoryCount;
    public int CategoryCount { get; public set; }
    public string CategoryResourceFile { get; public set; }
    public string LogName { get; public set; }
    public string MachineName { get; public set; }
    public string MessageResourceFile { get; public set; }
    public string ParameterResourceFile { get; public set; }
    public string Source { get; public set; }
    public EventSourceCreationData(string source, string logName);
    internal EventSourceCreationData(string source, string logName, string machineName);
    public int get_CategoryCount();
    public void set_CategoryCount(int value);
    public string get_CategoryResourceFile();
    public void set_CategoryResourceFile(string value);
    public string get_LogName();
    public void set_LogName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public string get_MessageResourceFile();
    public void set_MessageResourceFile(string value);
    public string get_ParameterResourceFile();
    public void set_ParameterResourceFile(string value);
    public string get_Source();
    public void set_Source(string value);
}
public class System.Diagnostics.EventTypeFilter : TraceFilter {
    private SourceLevels level;
    public SourceLevels EventType { get; public set; }
    public EventTypeFilter(SourceLevels level);
    public virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data);
    public SourceLevels get_EventType();
    public void set_EventType(SourceLevels value);
}
public class System.Diagnostics.FileVersionInfo : object {
    private string comments;
    private string companyname;
    private string filedescription;
    private string filename;
    private string fileversion;
    private string internalname;
    private string language;
    private string legalcopyright;
    private string legaltrademarks;
    private string originalfilename;
    private string privatebuild;
    private string productname;
    private string productversion;
    private string specialbuild;
    private bool isdebug;
    private bool ispatched;
    private bool isprerelease;
    private bool isprivatebuild;
    private bool isspecialbuild;
    private int filemajorpart;
    private int fileminorpart;
    private int filebuildpart;
    private int fileprivatepart;
    private int productmajorpart;
    private int productminorpart;
    private int productbuildpart;
    private int productprivatepart;
    public string Comments { get; }
    public string CompanyName { get; }
    public int FileBuildPart { get; }
    public string FileDescription { get; }
    public int FileMajorPart { get; }
    public int FileMinorPart { get; }
    public string FileName { get; }
    public int FilePrivatePart { get; }
    public string FileVersion { get; }
    public string InternalName { get; }
    public bool IsDebug { get; }
    public bool IsPatched { get; }
    public bool IsPreRelease { get; }
    public bool IsPrivateBuild { get; }
    public bool IsSpecialBuild { get; }
    public string Language { get; }
    public string LegalCopyright { get; }
    public string LegalTrademarks { get; }
    public string OriginalFilename { get; }
    public string PrivateBuild { get; }
    public int ProductBuildPart { get; }
    public int ProductMajorPart { get; }
    public int ProductMinorPart { get; }
    public string ProductName { get; }
    public int ProductPrivatePart { get; }
    public string ProductVersion { get; }
    public string SpecialBuild { get; }
    public string get_Comments();
    public string get_CompanyName();
    public int get_FileBuildPart();
    public string get_FileDescription();
    public int get_FileMajorPart();
    public int get_FileMinorPart();
    public string get_FileName();
    public int get_FilePrivatePart();
    public string get_FileVersion();
    public string get_InternalName();
    public bool get_IsDebug();
    public bool get_IsPatched();
    public bool get_IsPreRelease();
    public bool get_IsPrivateBuild();
    public bool get_IsSpecialBuild();
    public string get_Language();
    public string get_LegalCopyright();
    public string get_LegalTrademarks();
    public string get_OriginalFilename();
    public string get_PrivateBuild();
    public int get_ProductBuildPart();
    public int get_ProductMajorPart();
    public int get_ProductMinorPart();
    public string get_ProductName();
    public int get_ProductPrivatePart();
    public string get_ProductVersion();
    public string get_SpecialBuild();
    private void GetVersionInfo_icall(Char* fileName, int fileName_length);
    private void GetVersionInfo_internal(string fileName);
    public static FileVersionInfo GetVersionInfo(string fileName);
    private static void AppendFormat(StringBuilder sb, string format, Object[] args);
    public virtual string ToString();
}
internal class System.Diagnostics.FilterElement : TypedElement {
    public TraceFilter GetRuntimeObject();
    internal TraceFilter RefreshRuntimeObject(TraceFilter filter);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("73386977-D6FD-11D2-BED5-00C04F79E3AE")]
public interface System.Diagnostics.ICollectData {
    public abstract virtual void CloseData();
    public abstract virtual void CollectData(int id, IntPtr valueName, IntPtr data, int totalBytes, IntPtr& res);
}
internal enum System.Diagnostics.InitState : Enum {
    public int value__;
    public static InitState NotInitialized;
    public static InitState Initializing;
    public static InitState Initialized;
}
public class System.Diagnostics.InstanceData : object {
    private string instanceName;
    private CounterSample sample;
    public string InstanceName { get; }
    public long RawValue { get; }
    public CounterSample Sample { get; }
    public InstanceData(string instanceName, CounterSample sample);
    public string get_InstanceName();
    public long get_RawValue();
    public CounterSample get_Sample();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.InstanceDataCollection : DictionaryBase {
    private string counterName;
    public string CounterName { get; }
    public InstanceData Item { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    [ObsoleteAttribute("Use InstanceDataCollectionCollection indexer instead.")]
public InstanceDataCollection(string counterName);
    private static void CheckNull(object value, string name);
    public string get_CounterName();
    public InstanceData get_Item(string instanceName);
    public ICollection get_Keys();
    public ICollection get_Values();
    public bool Contains(string instanceName);
    public void CopyTo(InstanceData[] instances, int index);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.InstanceDataCollectionCollection : DictionaryBase {
    public InstanceDataCollection Item { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    private static void CheckNull(object value, string name);
    public InstanceDataCollection get_Item(string counterName);
    public ICollection get_Keys();
    public ICollection get_Values();
    public bool Contains(string counterName);
    public void CopyTo(InstanceDataCollection[] counters, int index);
}
internal class System.Diagnostics.ListenerElement : TypedElement {
    private static ConfigurationProperty _propFilter;
    private static ConfigurationProperty _propName;
    private static ConfigurationProperty _propOutputOpts;
    private ConfigurationProperty _propListenerTypeName;
    private bool _allowReferences;
    private Hashtable _attributes;
    internal bool _isAddedByDefault;
    public Hashtable Attributes { get; }
    [ConfigurationPropertyAttribute("filter")]
public FilterElement Filter { get; }
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("traceOutputOptions")]
public TraceOptions TraceOutputOptions { get; public set; }
    [ConfigurationPropertyAttribute("type")]
public string TypeName { get; public set; }
    private static ListenerElement();
    public ListenerElement(bool allowReferences);
    public Hashtable get_Attributes();
    public FilterElement get_Filter();
    public string get_Name();
    public void set_Name(string value);
    public TraceOptions get_TraceOutputOptions();
    public void set_TraceOutputOptions(TraceOptions value);
    public virtual string get_TypeName();
    public virtual void set_TypeName(string value);
    public virtual bool Equals(object compareTo);
    public virtual int GetHashCode();
    public TraceListener GetRuntimeObject();
    protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
    protected virtual void PreSerialize(XmlWriter writer);
    protected virtual bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    internal void ResetProperties();
    internal TraceListener RefreshRuntimeObject(TraceListener listener);
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Diagnostics.ListenerElement")]
internal class System.Diagnostics.ListenerElementsCollection : ConfigurationElementCollection {
    public ListenerElement Item { get; }
    public ConfigurationElementCollectionType CollectionType { get; }
    public ListenerElement get_Item(string name);
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public TraceListenerCollection GetRuntimeObject();
    protected virtual void InitializeDefault();
    internal void InitializeDefaultInternal();
    protected virtual void BaseAdd(ConfigurationElement element);
}
internal class System.Diagnostics.LocalFileEventLog : EventLogImpl {
    private static string DateFormat;
    private static object lockObject;
    private FileSystemWatcher file_watcher;
    private int last_notification_index;
    private bool _notifying;
    private bool RunningOnUnix { get; }
    private string EventLogStore { get; }
    public OverflowAction OverflowAction { get; }
    public int MinimumRetentionDays { get; }
    public long MaximumKilobytes { get; public set; }
    public LocalFileEventLog(EventLog coreEventLog);
    private static LocalFileEventLog();
    public virtual void BeginInit();
    public virtual void Clear();
    public virtual void Close();
    public virtual void CreateEventSource(EventSourceCreationData sourceData);
    public virtual void Delete(string logName, string machineName);
    public virtual void DeleteEventSource(string source, string machineName);
    public virtual void Dispose(bool disposing);
    public virtual void DisableNotification();
    public virtual void EnableNotification();
    public virtual void EndInit();
    public virtual bool Exists(string logName, string machineName);
    [MonoTODOAttribute("Use MessageTable from PE for lookup")]
protected virtual string FormatMessage(string source, UInt32 eventID, String[] replacementStrings);
    protected virtual int GetEntryCount();
    protected virtual EventLogEntry GetEntry(int index);
    [MonoTODOAttribute]
protected virtual string GetLogDisplayName();
    protected virtual String[] GetLogNames(string machineName);
    public virtual string LogNameFromSourceName(string source, string machineName);
    public virtual bool SourceExists(string source, string machineName);
    public virtual void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData);
    private string FindSourceDirectory(string source);
    private bool get_RunningOnUnix();
    private string FindLogStore(string logName);
    private string get_EventLogStore();
    private int GetLatestIndex();
    private static void ModifyAccessPermissions(string path, string permissions);
    public virtual OverflowAction get_OverflowAction();
    public virtual int get_MinimumRetentionDays();
    public virtual long get_MaximumKilobytes();
    public virtual void set_MaximumKilobytes(long value);
    public virtual void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    public virtual void RegisterDisplayName(string resourceFile, long resourceId);
    [CompilerGeneratedAttribute]
private void <EnableNotification>b__14_0(object o, FileSystemEventArgs e);
}
[AttributeUsageAttribute("32767")]
public class System.Diagnostics.MonitoringDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public MonitoringDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal class System.Diagnostics.NullEventLog : EventLogImpl {
    public OverflowAction OverflowAction { get; }
    public int MinimumRetentionDays { get; }
    public long MaximumKilobytes { get; public set; }
    public NullEventLog(EventLog coreEventLog);
    public virtual void BeginInit();
    public virtual void Clear();
    public virtual void Close();
    public virtual void CreateEventSource(EventSourceCreationData sourceData);
    public virtual void Delete(string logName, string machineName);
    public virtual void DeleteEventSource(string source, string machineName);
    public virtual void Dispose(bool disposing);
    public virtual void DisableNotification();
    public virtual void EnableNotification();
    public virtual void EndInit();
    public virtual bool Exists(string logName, string machineName);
    protected virtual string FormatMessage(string source, UInt32 messageID, String[] replacementStrings);
    protected virtual int GetEntryCount();
    protected virtual EventLogEntry GetEntry(int index);
    protected virtual string GetLogDisplayName();
    protected virtual String[] GetLogNames(string machineName);
    public virtual string LogNameFromSourceName(string source, string machineName);
    public virtual bool SourceExists(string source, string machineName);
    public virtual void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData);
    public virtual OverflowAction get_OverflowAction();
    public virtual int get_MinimumRetentionDays();
    public virtual long get_MaximumKilobytes();
    public virtual void set_MaximumKilobytes(long value);
    public virtual void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    public virtual void RegisterDisplayName(string resourceFile, long resourceId);
}
internal class System.Diagnostics.OrdinalCaseInsensitiveComparer : object {
    internal static OrdinalCaseInsensitiveComparer Default;
    private static OrdinalCaseInsensitiveComparer();
    public sealed virtual int Compare(object a, object b);
}
public enum System.Diagnostics.OverflowAction : Enum {
    public int value__;
    public static OverflowAction DoNotOverwrite;
    public static OverflowAction OverwriteAsNeeded;
    public static OverflowAction OverwriteOlder;
}
internal class System.Diagnostics.PerfCounterSection : ConfigurationElement {
    private static ConfigurationPropertyCollection _properties;
    private static ConfigurationProperty _propFileMappingSize;
    [ConfigurationPropertyAttribute("filemappingsize")]
public int FileMappingSize { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static PerfCounterSection();
    public int get_FileMappingSize();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[InstallerTypeAttribute("System.Diagnostics.PerformanceCounterInstaller")]
public class System.Diagnostics.PerformanceCounter : Component {
    private string categoryName;
    private string counterName;
    private string instanceName;
    private string machineName;
    private IntPtr impl;
    private PerformanceCounterType type;
    private CounterSample old_sample;
    private bool readOnly;
    private bool valid_old;
    private bool changed;
    private bool is_custom;
    private PerformanceCounterInstanceLifetime lifetime;
    [ObsoleteAttribute]
public static int DefaultFileMappingSize;
    [SRDescriptionAttribute("The category name for this performance counter.")]
[ReadOnlyAttribute("True")]
[DefaultValueAttribute("")]
[TypeConverterAttribute("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[SettingsBindableAttribute("True")]
public string CategoryName { get; public set; }
    [MonitoringDescriptionAttribute("A description describing the counter.")]
[DesignerSerializationVisibilityAttribute("0")]
[ReadOnlyAttribute("True")]
[MonoTODOAttribute]
public string CounterHelp { get; }
    [TypeConverterAttribute("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[DefaultValueAttribute("")]
[SRDescriptionAttribute("The name of this performance counter.")]
[SettingsBindableAttribute("True")]
[ReadOnlyAttribute("True")]
public string CounterName { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The type of the counter.")]
public PerformanceCounterType CounterType { get; }
    [MonoTODOAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public PerformanceCounterInstanceLifetime InstanceLifetime { get; public set; }
    [DefaultValueAttribute("")]
[ReadOnlyAttribute("True")]
[SettingsBindableAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[SRDescriptionAttribute("The instance name for this performance counter.")]
public string InstanceName { get; public set; }
    [SRDescriptionAttribute("The machine where this performance counter resides.")]
[SettingsBindableAttribute("True")]
[DefaultValueAttribute(".")]
[MonoTODOAttribute("What's the machine name format?")]
[BrowsableAttribute("False")]
public string MachineName { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The raw value of the counter.")]
public long RawValue { get; public set; }
    [BrowsableAttribute("False")]
[MonitoringDescriptionAttribute("The accessability level of the counter.")]
[DefaultValueAttribute("True")]
public bool ReadOnly { get; public set; }
    public PerformanceCounter(string categoryName, string counterName);
    public PerformanceCounter(string categoryName, string counterName, bool readOnly);
    public PerformanceCounter(string categoryName, string counterName, string instanceName);
    public PerformanceCounter(string categoryName, string counterName, string instanceName, bool readOnly);
    public PerformanceCounter(string categoryName, string counterName, string instanceName, string machineName);
    private static PerformanceCounter();
    private static IntPtr GetImpl_icall(Char* category, int category_length, Char* counter, int counter_length, Char* instance, int instance_length, PerformanceCounterType& ctype, Boolean& custom);
    private static IntPtr GetImpl(string category, string counter, string instance, PerformanceCounterType& ctype, Boolean& custom);
    private static bool GetSample(IntPtr impl, bool only_value, CounterSample& sample);
    private static long UpdateValue(IntPtr impl, bool do_incr, long value);
    private static void FreeData(IntPtr impl);
    private static bool IsValidMachine(string machine);
    private void UpdateInfo();
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_CounterHelp();
    public string get_CounterName();
    public void set_CounterName(string value);
    public PerformanceCounterType get_CounterType();
    public PerformanceCounterInstanceLifetime get_InstanceLifetime();
    public void set_InstanceLifetime(PerformanceCounterInstanceLifetime value);
    public string get_InstanceName();
    public void set_InstanceName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public long get_RawValue();
    public void set_RawValue(long value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    public void Close();
    public static void CloseSharedResources();
    public long Decrement();
    protected virtual void Dispose(bool disposing);
    public long Increment();
    [ReliabilityContractAttribute("3", "1")]
public long IncrementBy(long value);
    public CounterSample NextSample();
    public float NextValue();
    [MonoTODOAttribute]
[ReliabilityContractAttribute("3", "1")]
public void RemoveInstance();
}
public class System.Diagnostics.PerformanceCounterCategory : object {
    private string categoryName;
    private string machineName;
    private PerformanceCounterCategoryType type;
    public string CategoryHelp { get; }
    public string CategoryName { get; public set; }
    public string MachineName { get; public set; }
    public PerformanceCounterCategoryType CategoryType { get; }
    public PerformanceCounterCategory(string categoryName);
    public PerformanceCounterCategory(string categoryName, string machineName);
    private static bool CategoryDelete_icall(Char* name, int name_length);
    private static bool CategoryDelete(string name);
    private static string CategoryHelp_icall(Char* category, int category_length);
    private static string CategoryHelpInternal(string category);
    private static bool CounterCategoryExists_icall(Char* counter, int counter_length, Char* category, int category_length);
    private static bool CounterCategoryExists(string counter, string category);
    private static bool Create_icall(Char* categoryName, int categoryName_length, Char* categoryHelp, int categoryHelp_length, PerformanceCounterCategoryType categoryType, CounterCreationData[] items);
    private static bool Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationData[] items);
    private static bool InstanceExistsInternal_icall(Char* instance, int instance_length, Char* category, int category_length);
    private static bool InstanceExistsInternal(string instance, string category);
    private static String[] GetCategoryNames();
    private static String[] GetCounterNames_icall(Char* category, int category_length);
    private static String[] GetCounterNames(string category);
    private static String[] GetInstanceNames_icall(Char* category, int category_length);
    private static String[] GetInstanceNames(string category);
    private static void CheckCategory(string categoryName);
    private static bool IsValidMachine(string machine);
    public string get_CategoryHelp();
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public PerformanceCounterCategoryType get_CategoryType();
    public bool CounterExists(string counterName);
    public static bool CounterExists(string counterName, string categoryName);
    public static bool CounterExists(string counterName, string categoryName, string machineName);
    [ObsoleteAttribute("Use another overload that uses PerformanceCounterCategoryType instead")]
public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, CounterCreationDataCollection counterData);
    [ObsoleteAttribute("Use another overload that uses PerformanceCounterCategoryType instead")]
public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, string counterName, string counterHelp);
    public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData);
    public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp);
    public static void Delete(string categoryName);
    public static bool Exists(string categoryName);
    public static bool Exists(string categoryName, string machineName);
    public static PerformanceCounterCategory[] GetCategories();
    public static PerformanceCounterCategory[] GetCategories(string machineName);
    public PerformanceCounter[] GetCounters();
    public PerformanceCounter[] GetCounters(string instanceName);
    public String[] GetInstanceNames();
    public bool InstanceExists(string instanceName);
    public static bool InstanceExists(string instanceName, string categoryName);
    public static bool InstanceExists(string instanceName, string categoryName, string machineName);
    [MonoTODOAttribute]
public InstanceDataCollectionCollection ReadCategory();
}
public enum System.Diagnostics.PerformanceCounterCategoryType : Enum {
    public int value__;
    public static PerformanceCounterCategoryType SingleInstance;
    public static PerformanceCounterCategoryType MultiInstance;
    public static PerformanceCounterCategoryType Unknown;
}
internal class System.Diagnostics.PerformanceCounterInstaller : object {
}
public enum System.Diagnostics.PerformanceCounterInstanceLifetime : Enum {
    public int value__;
    public static PerformanceCounterInstanceLifetime Global;
    public static PerformanceCounterInstanceLifetime Process;
}
[ObsoleteAttribute("use PerformanceCounter")]
[MonoTODOAttribute("not implemented")]
[GuidAttribute("82840be1-d273-11d2-b94a-00600893b17a")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.PerformanceCounterManager : object {
    private sealed virtual override void System.Diagnostics.ICollectData.CloseData();
    private sealed virtual override void System.Diagnostics.ICollectData.CollectData(int callIdx, IntPtr valueNamePtr, IntPtr dataPtr, int totalBytes, IntPtr& res);
}
public class System.Diagnostics.PerformanceCounterPermission : ResourcePermissionBase {
    private PerformanceCounterPermissionEntryCollection innerCollection;
    public PerformanceCounterPermissionEntryCollection PermissionEntries { get; }
    public PerformanceCounterPermission(PerformanceCounterPermissionEntry[] permissionAccessEntries);
    public PerformanceCounterPermission(PermissionState state);
    public PerformanceCounterPermission(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName);
    public PerformanceCounterPermissionEntryCollection get_PermissionEntries();
    private void SetUp();
    internal ResourcePermissionBaseEntry[] GetEntries();
    internal void ClearEntries();
    internal void Add(object obj);
    internal void Remove(object obj);
}
[FlagsAttribute]
public enum System.Diagnostics.PerformanceCounterPermissionAccess : Enum {
    public int value__;
    public static PerformanceCounterPermissionAccess None;
    [ObsoleteAttribute]
public static PerformanceCounterPermissionAccess Browse;
    public static PerformanceCounterPermissionAccess Read;
    public static PerformanceCounterPermissionAccess Write;
    [ObsoleteAttribute]
public static PerformanceCounterPermissionAccess Instrument;
    public static PerformanceCounterPermissionAccess Administer;
}
[AttributeUsageAttribute("621")]
public class System.Diagnostics.PerformanceCounterPermissionAttribute : CodeAccessSecurityAttribute {
    private string categoryName;
    private string machineName;
    private PerformanceCounterPermissionAccess permissionAccess;
    public string CategoryName { get; public set; }
    public string MachineName { get; public set; }
    public PerformanceCounterPermissionAccess PermissionAccess { get; public set; }
    public PerformanceCounterPermissionAttribute(SecurityAction action);
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public PerformanceCounterPermissionAccess get_PermissionAccess();
    public void set_PermissionAccess(PerformanceCounterPermissionAccess value);
    public virtual IPermission CreatePermission();
}
public class System.Diagnostics.PerformanceCounterPermissionEntry : object {
    private static PerformanceCounterPermissionAccess All;
    private PerformanceCounterPermissionAccess permissionAccess;
    private string machineName;
    private string categoryName;
    public string CategoryName { get; }
    public string MachineName { get; }
    public PerformanceCounterPermissionAccess PermissionAccess { get; }
    public PerformanceCounterPermissionEntry(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName);
    public string get_CategoryName();
    public string get_MachineName();
    public PerformanceCounterPermissionAccess get_PermissionAccess();
    internal ResourcePermissionBaseEntry CreateResourcePermissionBaseEntry();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.PerformanceCounterPermissionEntryCollection : CollectionBase {
    private PerformanceCounterPermission owner;
    public PerformanceCounterPermissionEntry Item { get; public set; }
    internal PerformanceCounterPermissionEntryCollection(PerformanceCounterPermission owner);
    internal PerformanceCounterPermissionEntryCollection(ResourcePermissionBaseEntry[] entries);
    public PerformanceCounterPermissionEntry get_Item(int index);
    public void set_Item(int index, PerformanceCounterPermissionEntry value);
    public int Add(PerformanceCounterPermissionEntry value);
    public void AddRange(PerformanceCounterPermissionEntry[] value);
    public void AddRange(PerformanceCounterPermissionEntryCollection value);
    public bool Contains(PerformanceCounterPermissionEntry value);
    public void CopyTo(PerformanceCounterPermissionEntry[] array, int index);
    public int IndexOf(PerformanceCounterPermissionEntry value);
    public void Insert(int index, PerformanceCounterPermissionEntry value);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    public void Remove(PerformanceCounterPermissionEntry value);
}
[TypeConverterAttribute("System.Diagnostics.AlphabeticalEnumConverter")]
public enum System.Diagnostics.PerformanceCounterType : Enum {
    public int value__;
    public static PerformanceCounterType NumberOfItemsHEX32;
    public static PerformanceCounterType NumberOfItemsHEX64;
    public static PerformanceCounterType NumberOfItems32;
    public static PerformanceCounterType NumberOfItems64;
    public static PerformanceCounterType CounterDelta32;
    public static PerformanceCounterType CounterDelta64;
    public static PerformanceCounterType SampleCounter;
    public static PerformanceCounterType CountPerTimeInterval32;
    public static PerformanceCounterType CountPerTimeInterval64;
    public static PerformanceCounterType RateOfCountsPerSecond32;
    public static PerformanceCounterType RateOfCountsPerSecond64;
    public static PerformanceCounterType RawFraction;
    public static PerformanceCounterType CounterTimer;
    public static PerformanceCounterType Timer100Ns;
    public static PerformanceCounterType SampleFraction;
    public static PerformanceCounterType CounterTimerInverse;
    public static PerformanceCounterType Timer100NsInverse;
    public static PerformanceCounterType CounterMultiTimer;
    public static PerformanceCounterType CounterMultiTimer100Ns;
    public static PerformanceCounterType CounterMultiTimerInverse;
    public static PerformanceCounterType CounterMultiTimer100NsInverse;
    public static PerformanceCounterType AverageTimer32;
    public static PerformanceCounterType ElapsedTime;
    public static PerformanceCounterType AverageCount64;
    public static PerformanceCounterType SampleBase;
    public static PerformanceCounterType AverageBase;
    public static PerformanceCounterType RawBase;
    public static PerformanceCounterType CounterMultiBase;
}
[DefaultEventAttribute("Exited")]
[DesignerAttribute("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[MonitoringDescriptionAttribute("Provides access to local and remote processes, enabling starting and stopping of local processes.")]
[DefaultPropertyAttribute("StartInfo")]
public class System.Diagnostics.Process : Component {
    private bool haveProcessId;
    private int processId;
    private bool haveProcessHandle;
    private SafeProcessHandle m_processHandle;
    private bool isRemoteMachine;
    private string machineName;
    private int m_processAccess;
    private ProcessThreadCollection threads;
    private ProcessModuleCollection modules;
    private bool haveWorkingSetLimits;
    private IntPtr minWorkingSet;
    private IntPtr maxWorkingSet;
    private bool havePriorityClass;
    private ProcessPriorityClass priorityClass;
    private ProcessStartInfo startInfo;
    private bool watchForExit;
    private bool watchingForExit;
    private EventHandler onExited;
    private bool exited;
    private int exitCode;
    private bool signaled;
    private DateTime exitTime;
    private bool haveExitTime;
    private bool raisedOnExited;
    private RegisteredWaitHandle registeredWaitHandle;
    private WaitHandle waitHandle;
    private ISynchronizeInvoke synchronizingObject;
    private StreamReader standardOutput;
    private StreamWriter standardInput;
    private StreamReader standardError;
    private OperatingSystem operatingSystem;
    private bool disposed;
    private StreamReadMode outputStreamReadMode;
    private StreamReadMode errorStreamReadMode;
    private StreamReadMode inputStreamReadMode;
    [CompilerGeneratedAttribute]
private DataReceivedEventHandler OutputDataReceived;
    [CompilerGeneratedAttribute]
private DataReceivedEventHandler ErrorDataReceived;
    internal AsyncStreamReader output;
    internal AsyncStreamReader error;
    internal bool pendingOutputRead;
    internal bool pendingErrorRead;
    internal static TraceSwitch processTracing;
    private string process_name;
    private static ProcessModule current_main_module;
    [MonitoringDescriptionAttribute("Indicates if the process component is associated with a real process.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
private bool Associated { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The value returned from the associated process when it terminated.")]
public int ExitCode { get; }
    [MonitoringDescriptionAttribute("Indicates if the associated process has been terminated.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public bool HasExited { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The time that the associated process exited.")]
public DateTime ExitTime { get; }
    [MonitoringDescriptionAttribute("Returns the native handle for this process.   The handle is only available if the process was started using this component.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public IntPtr Handle { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public SafeProcessHandle SafeHandle { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The unique identifier for the process.")]
public int Id { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The name of the machine the running the process.")]
public string MachineName { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The maximum amount of physical memory the process has required since it was started.")]
public IntPtr MaxWorkingSet { get; public set; }
    [MonitoringDescriptionAttribute("The minimum amount of physical memory the process has required since it was started.")]
[DesignerSerializationVisibilityAttribute("0")]
public IntPtr MinWorkingSet { get; public set; }
    private OperatingSystem OperatingSystem { get; }
    [MonitoringDescriptionAttribute("The priority that the threads in the process run relative to.")]
[DesignerSerializationVisibilityAttribute("0")]
public ProcessPriorityClass PriorityClass { get; public set; }
    [MonitoringDescriptionAttribute("The amount of CPU time the process spent inside the operating system core.")]
[DesignerSerializationVisibilityAttribute("0")]
public TimeSpan PrivilegedProcessorTime { get; }
    [MonitoringDescriptionAttribute("Specifies information used to start a process.")]
[DesignerSerializationVisibilityAttribute("2")]
[BrowsableAttribute("False")]
public ProcessStartInfo StartInfo { get; public set; }
    [MonitoringDescriptionAttribute("The time at which the process was started.")]
[DesignerSerializationVisibilityAttribute("0")]
public DateTime StartTime { get; }
    [DefaultValueAttribute("")]
[BrowsableAttribute("False")]
[MonitoringDescriptionAttribute("The object used to marshal the event handler calls issued as a result of a Process exit.")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The amount of CPU time the process has used.")]
public TimeSpan TotalProcessorTime { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The amount of CPU time the process spent outside the operating system core.")]
public TimeSpan UserProcessorTime { get; }
    [MonitoringDescriptionAttribute("Whether the process component should watch for the associated process to exit, and raise the Exited event.")]
[BrowsableAttribute("False")]
[DefaultValueAttribute("False")]
public bool EnableRaisingEvents { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[MonitoringDescriptionAttribute("Standard input stream of the process.")]
public StreamWriter StandardInput { get; }
    [MonitoringDescriptionAttribute("Standard output stream of the process.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public StreamReader StandardOutput { get; }
    [MonitoringDescriptionAttribute("Standard error stream of the process.")]
[BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public StreamReader StandardError { get; }
    [MonitoringDescriptionAttribute("Base process priority.")]
[DesignerSerializationVisibilityAttribute("0")]
[MonoTODOAttribute]
public int BasePriority { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("Handles for this process.")]
[MonoTODOAttribute]
public int HandleCount { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The main module of the process.")]
[BrowsableAttribute("False")]
public ProcessModule MainModule { get; }
    [MonitoringDescriptionAttribute("The handle of the main window of the process.")]
[DesignerSerializationVisibilityAttribute("0")]
public IntPtr MainWindowHandle { get; }
    [MonitoringDescriptionAttribute("The title of the main window of the process.")]
[MonoTODOAttribute]
[DesignerSerializationVisibilityAttribute("0")]
public string MainWindowTitle { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The modules that are loaded as part of this process.")]
public ProcessModuleCollection Modules { get; }
    [MonitoringDescriptionAttribute("The number of bytes that are not pageable.")]
[ObsoleteAttribute("Use NonpagedSystemMemorySize64")]
[MonoTODOAttribute]
[DesignerSerializationVisibilityAttribute("0")]
public int NonpagedSystemMemorySize { get; }
    [ObsoleteAttribute("Use PagedMemorySize64")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The number of bytes that are paged.")]
public int PagedMemorySize { get; }
    [ObsoleteAttribute("Use PagedSystemMemorySize64")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The amount of paged system memory in bytes.")]
public int PagedSystemMemorySize { get; }
    [MonoTODOAttribute]
[ObsoleteAttribute("Use PeakPagedMemorySize64")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The maximum amount of paged memory used by this process.")]
public int PeakPagedMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The maximum amount of virtual memory used by this process.")]
[ObsoleteAttribute("Use PeakVirtualMemorySize64")]
public int PeakVirtualMemorySize { get; }
    [ObsoleteAttribute("Use PeakWorkingSet64")]
[MonitoringDescriptionAttribute("The maximum amount of system memory used by this process.")]
[DesignerSerializationVisibilityAttribute("0")]
public int PeakWorkingSet { get; }
    [ComVisibleAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The number of bytes that are not pageable.")]
[MonoTODOAttribute]
public long NonpagedSystemMemorySize64 { get; }
    [ComVisibleAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The number of bytes that are paged.")]
public long PagedMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The amount of paged system memory in bytes.")]
[ComVisibleAttribute("False")]
public long PagedSystemMemorySize64 { get; }
    [MonitoringDescriptionAttribute("The maximum amount of paged memory used by this process.")]
[DesignerSerializationVisibilityAttribute("0")]
[ComVisibleAttribute("False")]
[MonoTODOAttribute]
public long PeakPagedMemorySize64 { get; }
    [MonitoringDescriptionAttribute("The maximum amount of virtual memory used by this process.")]
[DesignerSerializationVisibilityAttribute("0")]
[ComVisibleAttribute("False")]
public long PeakVirtualMemorySize64 { get; }
    [ComVisibleAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The maximum amount of system memory used by this process.")]
public long PeakWorkingSet64 { get; }
    [MonitoringDescriptionAttribute("Process will be of higher priority while it is actively used.")]
[MonoTODOAttribute]
[DesignerSerializationVisibilityAttribute("0")]
public bool PriorityBoostEnabled { get; public set; }
    [ObsoleteAttribute("Use PrivateMemorySize64")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The amount of memory exclusively used by this process.")]
public int PrivateMemorySize { get; }
    [MonoNotSupportedAttribute("")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The session ID for this process.")]
public int SessionId { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The name of this process.")]
public string ProcessName { get; }
    [MonoTODOAttribute]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("Allowed processor that can be used by this process.")]
public IntPtr ProcessorAffinity { get; public set; }
    [MonitoringDescriptionAttribute("Is this process responsive.")]
[DesignerSerializationVisibilityAttribute("0")]
[MonoTODOAttribute]
public bool Responding { get; }
    [MonoTODOAttribute]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("The number of threads of this process.")]
public ProcessThreadCollection Threads { get; }
    [MonitoringDescriptionAttribute("The amount of virtual memory currently used for this process.")]
[DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("Use VirtualMemorySize64")]
public int VirtualMemorySize { get; }
    [MonitoringDescriptionAttribute("The amount of physical memory currently used for this process.")]
[DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("Use WorkingSet64")]
public int WorkingSet { get; }
    [ComVisibleAttribute("False")]
[MonitoringDescriptionAttribute("The amount of memory exclusively used by this process.")]
[DesignerSerializationVisibilityAttribute("0")]
public long PrivateMemorySize64 { get; }
    [MonitoringDescriptionAttribute("The amount of virtual memory currently used for this process.")]
[DesignerSerializationVisibilityAttribute("0")]
[ComVisibleAttribute("False")]
public long VirtualMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[ComVisibleAttribute("False")]
[MonitoringDescriptionAttribute("The amount of physical memory currently used for this process.")]
public long WorkingSet64 { get; }
    private static bool IsWindows { get; }
    private Process(string machineName, bool isRemoteMachine, int processId, ProcessInfo processInfo);
    private Process(SafeProcessHandle handle, int id);
    [CompilerGeneratedAttribute]
public void add_OutputDataReceived(DataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OutputDataReceived(DataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ErrorDataReceived(DataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ErrorDataReceived(DataReceivedEventHandler value);
    private bool get_Associated();
    public int get_ExitCode();
    public bool get_HasExited();
    private ProcessThreadTimes GetProcessTimes();
    public DateTime get_ExitTime();
    public IntPtr get_Handle();
    public SafeProcessHandle get_SafeHandle();
    public int get_Id();
    public string get_MachineName();
    public IntPtr get_MaxWorkingSet();
    public void set_MaxWorkingSet(IntPtr value);
    public IntPtr get_MinWorkingSet();
    public void set_MinWorkingSet(IntPtr value);
    private OperatingSystem get_OperatingSystem();
    public ProcessPriorityClass get_PriorityClass();
    public void set_PriorityClass(ProcessPriorityClass value);
    public TimeSpan get_PrivilegedProcessorTime();
    public ProcessStartInfo get_StartInfo();
    public void set_StartInfo(ProcessStartInfo value);
    public DateTime get_StartTime();
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public TimeSpan get_TotalProcessorTime();
    public TimeSpan get_UserProcessorTime();
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public StreamWriter get_StandardInput();
    public StreamReader get_StandardOutput();
    public StreamReader get_StandardError();
    public void add_Exited(EventHandler value);
    public void remove_Exited(EventHandler value);
    private void ReleaseProcessHandle(SafeProcessHandle handle);
    private void CompletionCallback(object context, bool wasSignaled);
    protected virtual void Dispose(bool disposing);
    public void Close();
    private void EnsureState(State state);
    private void EnsureWatchingForExit();
    private void EnsureWorkingSetLimits();
    public static void EnterDebugMode();
    public static void LeaveDebugMode();
    public static Process GetProcessById(int processId);
    public static Process[] GetProcessesByName(string processName);
    public static Process[] GetProcesses();
    public static Process GetCurrentProcess();
    protected void OnExited();
    private SafeProcessHandle GetProcessHandle(int access, bool throwIfExited);
    private SafeProcessHandle GetProcessHandle(int access);
    private SafeProcessHandle OpenProcessHandle();
    private SafeProcessHandle OpenProcessHandle(int access);
    public void Refresh();
    private void SetProcessHandle(SafeProcessHandle processHandle);
    private void SetProcessId(int processId);
    private void SetWorkingSetLimits(object newMin, object newMax);
    public bool Start();
    public static Process Start(string fileName, string userName, SecureString password, string domain);
    public static Process Start(string fileName, string arguments, string userName, SecureString password, string domain);
    public static Process Start(string fileName);
    public static Process Start(string fileName, string arguments);
    public static Process Start(ProcessStartInfo startInfo);
    public void Kill();
    private void StopWatchingForExit();
    public virtual string ToString();
    public bool WaitForExit(int milliseconds);
    public void WaitForExit();
    public bool WaitForInputIdle(int milliseconds);
    public bool WaitForInputIdle();
    [ComVisibleAttribute("False")]
public void BeginOutputReadLine();
    [ComVisibleAttribute("False")]
public void BeginErrorReadLine();
    [ComVisibleAttribute("False")]
public void CancelOutputRead();
    [ComVisibleAttribute("False")]
public void CancelErrorRead();
    internal void OutputReadNotifyUser(string data);
    internal void ErrorReadNotifyUser(string data);
    public int get_BasePriority();
    public int get_HandleCount();
    public ProcessModule get_MainModule();
    private static IntPtr MainWindowHandle_icall(int pid);
    public IntPtr get_MainWindowHandle();
    public string get_MainWindowTitle();
    private static void AppendArguments(StringBuilder stringBuilder, Collection`1<string> argumentList);
    private ProcessModule[] GetModules_icall(IntPtr handle);
    private ProcessModule[] GetModules_internal(SafeProcessHandle handle);
    public ProcessModuleCollection get_Modules();
    private static long GetProcessData(int pid, int data_type, Int32& error);
    public int get_NonpagedSystemMemorySize();
    public int get_PagedMemorySize();
    public int get_PagedSystemMemorySize();
    public int get_PeakPagedMemorySize();
    public int get_PeakVirtualMemorySize();
    public int get_PeakWorkingSet();
    public long get_NonpagedSystemMemorySize64();
    public long get_PagedMemorySize64();
    public long get_PagedSystemMemorySize64();
    public long get_PeakPagedMemorySize64();
    public long get_PeakVirtualMemorySize64();
    public long get_PeakWorkingSet64();
    public bool get_PriorityBoostEnabled();
    public void set_PriorityBoostEnabled(bool value);
    public int get_PrivateMemorySize();
    public int get_SessionId();
    private static string ProcessName_icall(IntPtr handle);
    private static string ProcessName_internal(SafeProcessHandle handle);
    public string get_ProcessName();
    public IntPtr get_ProcessorAffinity();
    public void set_ProcessorAffinity(IntPtr value);
    public bool get_Responding();
    public ProcessThreadCollection get_Threads();
    public int get_VirtualMemorySize();
    public int get_WorkingSet();
    public long get_PrivateMemorySize64();
    public long get_VirtualMemorySize64();
    public long get_WorkingSet64();
    public bool CloseMainWindow();
    private static IntPtr GetProcess_internal(int pid);
    [MonoTODOAttribute("There is no support for retrieving process information from a remote machine")]
public static Process GetProcessById(int processId, string machineName);
    public static Process[] GetProcessesByName(string processName, string machineName);
    private static Int32[] GetProcesses_internal();
    [MonoTODOAttribute("There is no support for retrieving process information from a remote machine")]
public static Process[] GetProcesses(string machineName);
    private static bool IsLocalMachine(string machineName);
    private static bool ShellExecuteEx_internal(ProcessStartInfo startInfo, ProcInfo& procInfo);
    private static bool CreateProcess_internal(ProcessStartInfo startInfo, IntPtr stdin, IntPtr stdout, IntPtr stderr, ProcInfo& procInfo);
    private bool StartWithShellExecuteEx(ProcessStartInfo startInfo);
    private static void CreatePipe(IntPtr& read, IntPtr& write, bool writeDirection);
    private static bool get_IsWindows();
    private bool StartWithCreateProcess(ProcessStartInfo startInfo);
    private static void FillUserInfo(ProcessStartInfo startInfo, ProcInfo& procInfo);
    private void RaiseOnExited();
}
internal class System.Diagnostics.ProcessInfo : object {
}
[DesignerAttribute("System.Diagnostics.Design.ProcessModuleDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Diagnostics.ProcessModule : Component {
    private IntPtr baseaddr;
    private IntPtr entryaddr;
    private string filename;
    private FileVersionInfo version_info;
    private int memory_size;
    private string modulename;
    [MonitoringDescriptionAttribute("The base memory address of this module")]
public IntPtr BaseAddress { get; }
    [MonitoringDescriptionAttribute("The base memory address of the entry point of this module")]
public IntPtr EntryPointAddress { get; }
    [MonitoringDescriptionAttribute("The file name of this module")]
public string FileName { get; }
    [BrowsableAttribute("False")]
public FileVersionInfo FileVersionInfo { get; }
    [MonitoringDescriptionAttribute("The memory needed by this module")]
public int ModuleMemorySize { get; }
    [MonitoringDescriptionAttribute("The name of this module")]
public string ModuleName { get; }
    internal ProcessModule(IntPtr baseaddr, IntPtr entryaddr, string filename, FileVersionInfo version_info, int memory_size, string modulename);
    public IntPtr get_BaseAddress();
    public IntPtr get_EntryPointAddress();
    public string get_FileName();
    public FileVersionInfo get_FileVersionInfo();
    public int get_ModuleMemorySize();
    public string get_ModuleName();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.ProcessModuleCollection : ReadOnlyCollectionBase {
    public ProcessModule Item { get; }
    public ProcessModuleCollection(ProcessModule[] processModules);
    public ProcessModule get_Item(int index);
    public int IndexOf(ProcessModule module);
    public bool Contains(ProcessModule module);
    public void CopyTo(ProcessModule[] array, int index);
}
public enum System.Diagnostics.ProcessPriorityClass : Enum {
    public int value__;
    public static ProcessPriorityClass AboveNormal;
    public static ProcessPriorityClass BelowNormal;
    public static ProcessPriorityClass High;
    public static ProcessPriorityClass Idle;
    public static ProcessPriorityClass Normal;
    public static ProcessPriorityClass RealTime;
}
[TypeConverterAttribute("System.ComponentModel.ExpandableObjectConverter")]
public class System.Diagnostics.ProcessStartInfo : object {
    private string fileName;
    private string arguments;
    private string directory;
    private string verb;
    private ProcessWindowStyle windowStyle;
    private bool errorDialog;
    private IntPtr errorDialogParentHandle;
    private bool useShellExecute;
    private string userName;
    private string domain;
    private SecureString password;
    private string passwordInClearText;
    private bool loadUserProfile;
    private bool redirectStandardInput;
    private bool redirectStandardOutput;
    private bool redirectStandardError;
    private Encoding standardOutputEncoding;
    private Encoding standardErrorEncoding;
    private bool createNoWindow;
    private WeakReference weakParentProcess;
    internal StringDictionary environmentVariables;
    private static String[] empty;
    private Collection`1<string> _argumentList;
    private IDictionary`2<string, string> environment;
    [CompilerGeneratedAttribute]
private Encoding <StandardInputEncoding>k__BackingField;
    public Collection`1<string> ArgumentList { get; }
    [NotifyParentPropertyAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.VerbConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("The verb to apply to the document specified by the FileName property.")]
public string Verb { get; public set; }
    [SettingsBindableAttribute("True")]
[MonitoringDescriptionAttribute("Command line arguments that will be passed to the application specified by the FileName property.")]
[DefaultValueAttribute("")]
[NotifyParentPropertyAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public string Arguments { get; public set; }
    [DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("Whether to start the process without creating a new window to contain it.")]
[NotifyParentPropertyAttribute("True")]
public bool CreateNoWindow { get; public set; }
    [MonitoringDescriptionAttribute("Set of environment variables that apply to this process and child processes.")]
[NotifyParentPropertyAttribute("True")]
[DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("2")]
[EditorAttribute("System.Diagnostics.Design.StringDictionaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public StringDictionary EnvironmentVariables { get; }
    [NotifyParentPropertyAttribute("True")]
[DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("0")]
public IDictionary`2<string, string> Environment { get; }
    [MonitoringDescriptionAttribute("Whether the process command input is read from the Process instance's StandardInput member.")]
[DefaultValueAttribute("False")]
[NotifyParentPropertyAttribute("True")]
public bool RedirectStandardInput { get; public set; }
    [DefaultValueAttribute("False")]
[NotifyParentPropertyAttribute("True")]
[MonitoringDescriptionAttribute("Whether the process output is written to the Process instance's StandardOutput member.")]
public bool RedirectStandardOutput { get; public set; }
    [DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("Whether the process's error output is written to the Process instance's StandardError member.")]
[NotifyParentPropertyAttribute("True")]
public bool RedirectStandardError { get; public set; }
    public Encoding StandardErrorEncoding { get; public set; }
    public Encoding StandardOutputEncoding { get; public set; }
    [NotifyParentPropertyAttribute("True")]
[MonitoringDescriptionAttribute("Whether to use the operating system shell to start the process.")]
[DefaultValueAttribute("True")]
public bool UseShellExecute { get; public set; }
    [NotifyParentPropertyAttribute("True")]
public string UserName { get; public set; }
    public SecureString Password { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public string PasswordInClearText { get; public set; }
    [NotifyParentPropertyAttribute("True")]
public string Domain { get; public set; }
    [NotifyParentPropertyAttribute("True")]
public bool LoadUserProfile { get; public set; }
    [SettingsBindableAttribute("True")]
[NotifyParentPropertyAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[MonitoringDescriptionAttribute("The name of the application, document or URL to start.")]
[EditorAttribute("System.Diagnostics.Design.StartFileNameEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[DefaultValueAttribute("")]
public string FileName { get; public set; }
    [SettingsBindableAttribute("True")]
[MonitoringDescriptionAttribute("The initial working directory for the process.")]
[DefaultValueAttribute("")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[NotifyParentPropertyAttribute("True")]
[EditorAttribute("System.Diagnostics.Design.WorkingDirectoryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public string WorkingDirectory { get; public set; }
    [MonitoringDescriptionAttribute("Whether to show an error dialog to the user if there is an error.")]
[NotifyParentPropertyAttribute("True")]
[DefaultValueAttribute("False")]
public bool ErrorDialog { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public IntPtr ErrorDialogParentHandle { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[MonitoringDescriptionAttribute("How the main window should be created when the process starts.")]
[NotifyParentPropertyAttribute("True")]
public ProcessWindowStyle WindowStyle { get; public set; }
    internal bool HaveEnvVars { get; }
    public Encoding StandardInputEncoding { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public String[] Verbs { get; }
    internal ProcessStartInfo(Process parent);
    public ProcessStartInfo(string fileName);
    public ProcessStartInfo(string fileName, string arguments);
    private static ProcessStartInfo();
    public Collection`1<string> get_ArgumentList();
    public string get_Verb();
    public void set_Verb(string value);
    public string get_Arguments();
    public void set_Arguments(string value);
    public bool get_CreateNoWindow();
    public void set_CreateNoWindow(bool value);
    public StringDictionary get_EnvironmentVariables();
    public IDictionary`2<string, string> get_Environment();
    public bool get_RedirectStandardInput();
    public void set_RedirectStandardInput(bool value);
    public bool get_RedirectStandardOutput();
    public void set_RedirectStandardOutput(bool value);
    public bool get_RedirectStandardError();
    public void set_RedirectStandardError(bool value);
    public Encoding get_StandardErrorEncoding();
    public void set_StandardErrorEncoding(Encoding value);
    public Encoding get_StandardOutputEncoding();
    public void set_StandardOutputEncoding(Encoding value);
    public bool get_UseShellExecute();
    public void set_UseShellExecute(bool value);
    public string get_UserName();
    public void set_UserName(string value);
    public SecureString get_Password();
    public void set_Password(SecureString value);
    public string get_PasswordInClearText();
    public void set_PasswordInClearText(string value);
    public string get_Domain();
    public void set_Domain(string value);
    public bool get_LoadUserProfile();
    public void set_LoadUserProfile(bool value);
    public string get_FileName();
    public void set_FileName(string value);
    public string get_WorkingDirectory();
    public void set_WorkingDirectory(string value);
    public bool get_ErrorDialog();
    public void set_ErrorDialog(bool value);
    public IntPtr get_ErrorDialogParentHandle();
    public void set_ErrorDialogParentHandle(IntPtr value);
    public ProcessWindowStyle get_WindowStyle();
    public void set_WindowStyle(ProcessWindowStyle value);
    internal bool get_HaveEnvVars();
    [CompilerGeneratedAttribute]
public Encoding get_StandardInputEncoding();
    [CompilerGeneratedAttribute]
public void set_StandardInputEncoding(Encoding value);
    public String[] get_Verbs();
}
[DesignerAttribute("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Diagnostics.ProcessThread : Component {
    [MonitoringDescriptionAttribute("The base priority of this thread.")]
[MonoTODOAttribute]
public int BasePriority { get; }
    [MonoTODOAttribute]
[MonitoringDescriptionAttribute("The current priority of this thread.")]
public int CurrentPriority { get; }
    [MonitoringDescriptionAttribute("The ID of this thread.")]
[MonoTODOAttribute]
public int Id { get; }
    [BrowsableAttribute("False")]
[MonoTODOAttribute]
unknown int IdealProcessor {public set; }
    [MonitoringDescriptionAttribute("Thread gets a priority boot when interactively used by a user.")]
[MonoTODOAttribute]
public bool PriorityBoostEnabled { get; public set; }
    [MonoTODOAttribute]
[MonitoringDescriptionAttribute("The priority level of this thread.")]
public ThreadPriorityLevel PriorityLevel { get; public set; }
    [MonitoringDescriptionAttribute("The amount of CPU time used in privileged mode.")]
[MonoTODOAttribute]
public TimeSpan PrivilegedProcessorTime { get; }
    [BrowsableAttribute("False")]
[MonoTODOAttribute]
unknown IntPtr ProcessorAffinity {public set; }
    [MonitoringDescriptionAttribute("The start address in memory of this thread.")]
[MonoTODOAttribute]
public IntPtr StartAddress { get; }
    [MonoTODOAttribute]
[MonitoringDescriptionAttribute("The time this thread was started.")]
public DateTime StartTime { get; }
    [MonitoringDescriptionAttribute("The current state of this thread.")]
[MonoTODOAttribute]
public ThreadState ThreadState { get; }
    [MonitoringDescriptionAttribute("The total amount of CPU time used.")]
[MonoTODOAttribute]
public TimeSpan TotalProcessorTime { get; }
    [MonoTODOAttribute]
[MonitoringDescriptionAttribute("The amount of CPU time used in user mode.")]
public TimeSpan UserProcessorTime { get; }
    [MonoTODOAttribute]
[MonitoringDescriptionAttribute("The reason why this thread is waiting.")]
public ThreadWaitReason WaitReason { get; }
    public int get_BasePriority();
    public int get_CurrentPriority();
    public int get_Id();
    public void set_IdealProcessor(int value);
    public bool get_PriorityBoostEnabled();
    public void set_PriorityBoostEnabled(bool value);
    public ThreadPriorityLevel get_PriorityLevel();
    public void set_PriorityLevel(ThreadPriorityLevel value);
    public TimeSpan get_PrivilegedProcessorTime();
    public void set_ProcessorAffinity(IntPtr value);
    public IntPtr get_StartAddress();
    public DateTime get_StartTime();
    public ThreadState get_ThreadState();
    public TimeSpan get_TotalProcessorTime();
    public TimeSpan get_UserProcessorTime();
    public ThreadWaitReason get_WaitReason();
    [MonoTODOAttribute]
public void ResetIdealProcessor();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.ProcessThreadCollection : ReadOnlyCollectionBase {
    public ProcessThread Item { get; }
    public ProcessThreadCollection(ProcessThread[] processThreads);
    public ProcessThread get_Item(int index);
    public int Add(ProcessThread thread);
    public void Insert(int index, ProcessThread thread);
    public int IndexOf(ProcessThread thread);
    public bool Contains(ProcessThread thread);
    public void Remove(ProcessThread thread);
    public void CopyTo(ProcessThread[] array, int index);
}
internal class System.Diagnostics.ProcessThreadTimes : object {
    internal long create;
    internal long exit;
    internal long kernel;
    internal long user;
    public DateTime StartTime { get; }
    public DateTime ExitTime { get; }
    public TimeSpan PrivilegedProcessorTime { get; }
    public TimeSpan UserProcessorTime { get; }
    public TimeSpan TotalProcessorTime { get; }
    public DateTime get_StartTime();
    public DateTime get_ExitTime();
    public TimeSpan get_PrivilegedProcessorTime();
    public TimeSpan get_UserProcessorTime();
    public TimeSpan get_TotalProcessorTime();
}
internal class System.Diagnostics.ProcessWaitHandle : WaitHandle {
    internal ProcessWaitHandle(SafeProcessHandle processHandle);
}
public enum System.Diagnostics.ProcessWindowStyle : Enum {
    public int value__;
    public static ProcessWindowStyle Hidden;
    public static ProcessWindowStyle Maximized;
    public static ProcessWindowStyle Minimized;
    public static ProcessWindowStyle Normal;
}
[ConfigurationCollectionAttribute("System.Diagnostics.ListenerElement")]
internal class System.Diagnostics.SharedListenerElementsCollection : ListenerElementsCollection {
    public ConfigurationElementCollectionType CollectionType { get; }
    protected string ElementName { get; }
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual string get_ElementName();
}
internal class System.Diagnostics.SourceElement : ConfigurationElement {
    private static ConfigurationPropertyCollection _properties;
    private static ConfigurationProperty _propName;
    private static ConfigurationProperty _propSwitchName;
    private static ConfigurationProperty _propSwitchValue;
    private static ConfigurationProperty _propSwitchType;
    private static ConfigurationProperty _propListeners;
    private Hashtable _attributes;
    public Hashtable Attributes { get; }
    [ConfigurationPropertyAttribute("listeners")]
public ListenerElementsCollection Listeners { get; }
    [ConfigurationPropertyAttribute("name")]
public string Name { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("switchName")]
public string SwitchName { get; }
    [ConfigurationPropertyAttribute("switchValue")]
public string SwitchValue { get; }
    [ConfigurationPropertyAttribute("switchType")]
public string SwitchType { get; }
    private static SourceElement();
    public Hashtable get_Attributes();
    public ListenerElementsCollection get_Listeners();
    public string get_Name();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_SwitchName();
    public string get_SwitchValue();
    public string get_SwitchType();
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
    protected virtual void PreSerialize(XmlWriter writer);
    protected virtual bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    internal void ResetProperties();
}
[ConfigurationCollectionAttribute("System.Diagnostics.SourceElement")]
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.SourceElementsCollection : ConfigurationElementCollection {
    public SourceElement Item { get; }
    protected string ElementName { get; }
    public ConfigurationElementCollectionType CollectionType { get; }
    public SourceElement get_Item(string name);
    protected virtual string get_ElementName();
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.Diagnostics.SourceFilter : TraceFilter {
    private string src;
    public string Source { get; public set; }
    public SourceFilter(string source);
    public virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data);
    public string get_Source();
    public void set_Source(string value);
}
[FlagsAttribute]
public enum System.Diagnostics.SourceLevels : Enum {
    public int value__;
    public static SourceLevels Off;
    public static SourceLevels Critical;
    public static SourceLevels Error;
    public static SourceLevels Warning;
    public static SourceLevels Information;
    public static SourceLevels Verbose;
    [EditorBrowsableAttribute("2")]
public static SourceLevels ActivityTracing;
    public static SourceLevels All;
}
public class System.Diagnostics.SourceSwitch : Switch {
    public SourceLevels Level { get; public set; }
    public SourceSwitch(string name);
    public SourceSwitch(string displayName, string defaultSwitchValue);
    public SourceLevels get_Level();
    public void set_Level(SourceLevels value);
    public bool ShouldTrace(TraceEventType eventType);
    protected virtual void OnValueChanged();
}
[ExtensionAttribute]
public static class System.Diagnostics.StackFrameExtensions : object {
    [ExtensionAttribute]
public static bool HasNativeImage(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasMethod(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasILOffset(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasSource(StackFrame stackFrame);
    [ExtensionAttribute]
public static IntPtr GetNativeIP(StackFrame stackFrame);
    [ExtensionAttribute]
public static IntPtr GetNativeImageBase(StackFrame stackFrame);
}
public class System.Diagnostics.Stopwatch : object {
    public static long Frequency;
    public static bool IsHighResolution;
    private long elapsed;
    private long started;
    private bool is_running;
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    public bool IsRunning { get; }
    private static Stopwatch();
    public static long GetTimestamp();
    public static Stopwatch StartNew();
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    public bool get_IsRunning();
    public void Reset();
    public void Start();
    public void Stop();
    public void Restart();
}
public abstract class System.Diagnostics.Switch : object {
    private SwitchElementsCollection switchSettings;
    private string description;
    private string displayName;
    private int switchSetting;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) initialized;
    private bool initializing;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) switchValueString;
    private StringDictionary attributes;
    private string defaultValue;
    private object m_intializedLock;
    private static List`1<WeakReference> switches;
    private static int s_LastCollectionCount;
    private object IntializedLock { get; }
    [XmlIgnoreAttribute]
public StringDictionary Attributes { get; }
    public string DisplayName { get; }
    public string Description { get; }
    protected int SwitchSetting { get; protected set; }
    protected string Value { get; protected set; }
    protected Switch(string displayName, string description);
    protected Switch(string displayName, string description, string defaultSwitchValue);
    private static Switch();
    private object get_IntializedLock();
    private static void _pruneCachedSwitches();
    public StringDictionary get_Attributes();
    public string get_DisplayName();
    public string get_Description();
    protected int get_SwitchSetting();
    protected void set_SwitchSetting(int value);
    protected string get_Value();
    protected void set_Value(string value);
    private void Initialize();
    private bool InitializeWithStatus();
    private bool InitializeConfigSettings();
    protected internal virtual String[] GetSupportedAttributes();
    protected virtual void OnSwitchSettingChanged();
    protected virtual void OnValueChanged();
    internal static void RefreshAll();
    internal void Refresh();
}
[AttributeUsageAttribute("741")]
public class System.Diagnostics.SwitchAttribute : Attribute {
    private Type type;
    private string name;
    private string description;
    public string SwitchName { get; public set; }
    public Type SwitchType { get; public set; }
    public string SwitchDescription { get; public set; }
    public SwitchAttribute(string switchName, Type switchType);
    public string get_SwitchName();
    public void set_SwitchName(string value);
    public Type get_SwitchType();
    public void set_SwitchType(Type value);
    public string get_SwitchDescription();
    public void set_SwitchDescription(string value);
    public static SwitchAttribute[] GetAll(Assembly assembly);
    private static void GetAllRecursive(Type type, ArrayList switchAttribs);
    private static void GetAllRecursive(MemberInfo member, ArrayList switchAttribs);
}
internal class System.Diagnostics.SwitchElement : ConfigurationElement {
    private static ConfigurationPropertyCollection _properties;
    private static ConfigurationProperty _propName;
    private static ConfigurationProperty _propValue;
    private Hashtable _attributes;
    public Hashtable Attributes { get; }
    [ConfigurationPropertyAttribute("name")]
public string Name { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("value")]
public string Value { get; }
    private static SwitchElement();
    public Hashtable get_Attributes();
    public string get_Name();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Value();
    protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
    protected virtual void PreSerialize(XmlWriter writer);
    protected virtual bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    internal void ResetProperties();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Diagnostics.SwitchElement")]
internal class System.Diagnostics.SwitchElementsCollection : ConfigurationElementCollection {
    public SwitchElement Item { get; }
    public ConfigurationElementCollectionType CollectionType { get; }
    public SwitchElement get_Item(string name);
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
[AttributeUsageAttribute("4")]
public class System.Diagnostics.SwitchLevelAttribute : Attribute {
    private Type type;
    public Type SwitchLevelType { get; public set; }
    public SwitchLevelAttribute(Type switchLevelType);
    public Type get_SwitchLevelType();
    public void set_SwitchLevelType(Type value);
}
internal class System.Diagnostics.SystemDiagnosticsSection : ConfigurationSection {
    private static ConfigurationPropertyCollection _properties;
    private static ConfigurationProperty _propAssert;
    private static ConfigurationProperty _propPerfCounters;
    private static ConfigurationProperty _propSources;
    private static ConfigurationProperty _propSharedListeners;
    private static ConfigurationProperty _propSwitches;
    private static ConfigurationProperty _propTrace;
    [ConfigurationPropertyAttribute("assert")]
public AssertSection Assert { get; }
    [ConfigurationPropertyAttribute("performanceCounters")]
public PerfCounterSection PerfCounters { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("sources")]
public SourceElementsCollection Sources { get; }
    [ConfigurationPropertyAttribute("sharedListeners")]
public ListenerElementsCollection SharedListeners { get; }
    [ConfigurationPropertyAttribute("switches")]
public SwitchElementsCollection Switches { get; }
    [ConfigurationPropertyAttribute("trace")]
public TraceSection Trace { get; }
    private static SystemDiagnosticsSection();
    public AssertSection get_Assert();
    public PerfCounterSection get_PerfCounters();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public SourceElementsCollection get_Sources();
    public ListenerElementsCollection get_SharedListeners();
    public SwitchElementsCollection get_Switches();
    public TraceSection get_Trace();
    protected virtual void InitializeDefault();
}
public class System.Diagnostics.TextWriterTraceListener : TraceListener {
    internal TextWriter writer;
    private string fileName;
    public TextWriter Writer { get; public set; }
    public TextWriterTraceListener(Stream stream);
    public TextWriterTraceListener(Stream stream, string name);
    public TextWriterTraceListener(TextWriter writer);
    public TextWriterTraceListener(TextWriter writer, string name);
    public TextWriterTraceListener(string fileName);
    public TextWriterTraceListener(string fileName, string name);
    public TextWriter get_Writer();
    public void set_Writer(TextWriter value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    private static Encoding GetEncodingWithFallback(Encoding encoding);
    internal bool EnsureWriter();
}
public enum System.Diagnostics.ThreadPriorityLevel : Enum {
    public int value__;
    public static ThreadPriorityLevel AboveNormal;
    public static ThreadPriorityLevel BelowNormal;
    public static ThreadPriorityLevel Highest;
    public static ThreadPriorityLevel Idle;
    public static ThreadPriorityLevel Lowest;
    public static ThreadPriorityLevel Normal;
    public static ThreadPriorityLevel TimeCritical;
}
public enum System.Diagnostics.ThreadState : Enum {
    public int value__;
    public static ThreadState Initialized;
    public static ThreadState Ready;
    public static ThreadState Running;
    public static ThreadState Standby;
    public static ThreadState Terminated;
    public static ThreadState Transition;
    public static ThreadState Unknown;
    public static ThreadState Wait;
}
public enum System.Diagnostics.ThreadWaitReason : Enum {
    public int value__;
    public static ThreadWaitReason EventPairHigh;
    public static ThreadWaitReason EventPairLow;
    public static ThreadWaitReason ExecutionDelay;
    public static ThreadWaitReason Executive;
    public static ThreadWaitReason FreePage;
    public static ThreadWaitReason LpcReceive;
    public static ThreadWaitReason LpcReply;
    public static ThreadWaitReason PageIn;
    public static ThreadWaitReason PageOut;
    public static ThreadWaitReason Suspended;
    public static ThreadWaitReason SystemAllocation;
    public static ThreadWaitReason Unknown;
    public static ThreadWaitReason UserRequest;
    public static ThreadWaitReason VirtualMemory;
}
public class System.Diagnostics.Trace : object {
    private static CorrelationManager modreq(System.Runtime.CompilerServices.IsVolatile) correlationManager;
    public static TraceListenerCollection Listeners { get; }
    public static bool AutoFlush { get; public set; }
    public static bool UseGlobalLock { get; public set; }
    public static CorrelationManager CorrelationManager { get; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    public static TraceListenerCollection get_Listeners();
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static bool get_UseGlobalLock();
    public static void set_UseGlobalLock(bool value);
    public static CorrelationManager get_CorrelationManager();
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("TRACE")]
public static void Flush();
    [ConditionalAttribute("TRACE")]
public static void Close();
    [ConditionalAttribute("TRACE")]
public static void Assert(bool condition);
    [ConditionalAttribute("TRACE")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("TRACE")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("TRACE")]
public static void Fail(string message);
    [ConditionalAttribute("TRACE")]
public static void Fail(string message, string detailMessage);
    public static void Refresh();
    [ConditionalAttribute("TRACE")]
public static void TraceInformation(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceInformation(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public static void TraceWarning(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceWarning(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public static void TraceError(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceError(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public static void Write(string message);
    [ConditionalAttribute("TRACE")]
public static void Write(object value);
    [ConditionalAttribute("TRACE")]
public static void Write(string message, string category);
    [ConditionalAttribute("TRACE")]
public static void Write(object value, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(string message);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(object value);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, string message, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("TRACE")]
public static void Indent();
    [ConditionalAttribute("TRACE")]
public static void Unindent();
}
public class System.Diagnostics.TraceEventCache : object {
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) processId;
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) processName;
    private long timeStamp;
    private DateTime dateTime;
    private string stackTrace;
    internal Guid ActivityId { get; }
    public string Callstack { get; }
    public Stack LogicalOperationStack { get; }
    public DateTime DateTime { get; }
    public int ProcessId { get; }
    public string ThreadId { get; }
    public long Timestamp { get; }
    internal Guid get_ActivityId();
    public string get_Callstack();
    public Stack get_LogicalOperationStack();
    public DateTime get_DateTime();
    public int get_ProcessId();
    public string get_ThreadId();
    public long get_Timestamp();
    private static void InitProcessInfo();
    internal static int GetProcessId();
    internal static string GetProcessName();
    internal static int GetThreadId();
}
public enum System.Diagnostics.TraceEventType : Enum {
    public int value__;
    public static TraceEventType Critical;
    public static TraceEventType Error;
    public static TraceEventType Warning;
    public static TraceEventType Information;
    public static TraceEventType Verbose;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Start;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Stop;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Suspend;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Resume;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Transfer;
}
public abstract class System.Diagnostics.TraceFilter : object {
    internal string initializeData;
    public abstract virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data);
    internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage);
    internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args);
    internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1);
}
internal class System.Diagnostics.TraceImplSettings : object {
    public static string Key;
    public bool AutoFlush;
    public int IndentSize;
    public TraceListenerCollection Listeners;
}
internal static class System.Diagnostics.TraceInternal : object {
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) appName;
    private static TraceListenerCollection modreq(System.Runtime.CompilerServices.IsVolatile) listeners;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) autoFlush;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) useGlobalLock;
    [ThreadStaticAttribute]
private static int indentLevel;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) indentSize;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) settingsInitialized;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) defaultInitialized;
    internal static object critSec;
    public static TraceListenerCollection Listeners { get; }
    internal static string AppName { get; }
    public static bool AutoFlush { get; public set; }
    public static bool UseGlobalLock { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    private static TraceInternal();
    public static TraceListenerCollection get_Listeners();
    internal static string get_AppName();
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static bool get_UseGlobalLock();
    public static void set_UseGlobalLock(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    private static void SetIndentSize(int value);
    public static void Indent();
    public static void Unindent();
    public static void Flush();
    public static void Close();
    public static void Assert(bool condition);
    public static void Assert(bool condition, string message);
    public static void Assert(bool condition, string message, string detailMessage);
    public static void Fail(string message);
    public static void Fail(string message, string detailMessage);
    private static void InitializeSettings();
    internal static void Refresh();
    public static void TraceEvent(TraceEventType eventType, int id, string format, Object[] args);
    public static void Write(string message);
    public static void Write(object value);
    public static void Write(string message, string category);
    public static void Write(object value, string category);
    public static void WriteLine(string message);
    public static void WriteLine(object value);
    public static void WriteLine(string message, string category);
    public static void WriteLine(object value, string category);
    public static void WriteIf(bool condition, string message);
    public static void WriteIf(bool condition, object value);
    public static void WriteIf(bool condition, string message, string category);
    public static void WriteIf(bool condition, object value, string category);
    public static void WriteLineIf(bool condition, string message);
    public static void WriteLineIf(bool condition, object value);
    public static void WriteLineIf(bool condition, string message, string category);
    public static void WriteLineIf(bool condition, object value, string category);
}
public enum System.Diagnostics.TraceLevel : Enum {
    public int value__;
    public static TraceLevel Off;
    public static TraceLevel Error;
    public static TraceLevel Warning;
    public static TraceLevel Info;
    public static TraceLevel Verbose;
}
public abstract class System.Diagnostics.TraceListener : MarshalByRefObject {
    private int indentLevel;
    private int indentSize;
    private TraceOptions traceOptions;
    private bool needIndent;
    private string listenerName;
    private TraceFilter filter;
    private StringDictionary attributes;
    internal string initializeData;
    public StringDictionary Attributes { get; }
    public string Name { get; public set; }
    public bool IsThreadSafe { get; }
    public int IndentLevel { get; public set; }
    public int IndentSize { get; public set; }
    [ComVisibleAttribute("False")]
public TraceFilter Filter { get; public set; }
    protected bool NeedIndent { get; protected set; }
    [ComVisibleAttribute("False")]
public TraceOptions TraceOutputOptions { get; public set; }
    protected TraceListener(string name);
    public StringDictionary get_Attributes();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual bool get_IsThreadSafe();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual void Flush();
    public int get_IndentLevel();
    public void set_IndentLevel(int value);
    public int get_IndentSize();
    public void set_IndentSize(int value);
    public TraceFilter get_Filter();
    public void set_Filter(TraceFilter value);
    protected bool get_NeedIndent();
    protected void set_NeedIndent(bool value);
    public TraceOptions get_TraceOutputOptions();
    public void set_TraceOutputOptions(TraceOptions value);
    internal void SetAttributes(Hashtable attribs);
    public virtual void Fail(string message);
    public virtual void Fail(string message, string detailMessage);
    protected internal virtual String[] GetSupportedAttributes();
    public abstract virtual void Write(string message);
    public virtual void Write(object o);
    public virtual void Write(string message, string category);
    public virtual void Write(object o, string category);
    protected virtual void WriteIndent();
    public abstract virtual void WriteLine(string message);
    public virtual void WriteLine(object o);
    public virtual void WriteLine(string message, string category);
    public virtual void WriteLine(object o, string category);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    [ComVisibleAttribute("False")]
public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
    private void WriteHeader(string source, TraceEventType eventType, int id);
    private void WriteFooter(TraceEventCache eventCache);
    internal bool IsEnabled(TraceOptions opts);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.TraceListenerCollection : object {
    private ArrayList list;
    public TraceListener Item { get; public set; }
    public TraceListener Item { get; }
    public int Count { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public TraceListener get_Item(int i);
    public void set_Item(int i, TraceListener value);
    public TraceListener get_Item(string name);
    public sealed virtual int get_Count();
    public int Add(TraceListener listener);
    public void AddRange(TraceListener[] value);
    public void AddRange(TraceListenerCollection value);
    public sealed virtual void Clear();
    public bool Contains(TraceListener listener);
    public void CopyTo(TraceListener[] listeners, int index);
    public sealed virtual IEnumerator GetEnumerator();
    internal void InitializeListener(TraceListener listener);
    public int IndexOf(TraceListener listener);
    public void Insert(int index, TraceListener listener);
    public void Remove(TraceListener listener);
    public void Remove(string name);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[FlagsAttribute]
public enum System.Diagnostics.TraceOptions : Enum {
    public int value__;
    public static TraceOptions None;
    public static TraceOptions LogicalOperationStack;
    public static TraceOptions DateTime;
    public static TraceOptions Timestamp;
    public static TraceOptions ProcessId;
    public static TraceOptions ThreadId;
    public static TraceOptions Callstack;
}
internal class System.Diagnostics.TraceSection : ConfigurationElement {
    private static ConfigurationPropertyCollection _properties;
    private static ConfigurationProperty _propListeners;
    private static ConfigurationProperty _propAutoFlush;
    private static ConfigurationProperty _propIndentSize;
    private static ConfigurationProperty _propUseGlobalLock;
    [ConfigurationPropertyAttribute("autoflush")]
public bool AutoFlush { get; }
    [ConfigurationPropertyAttribute("indentsize")]
public int IndentSize { get; }
    [ConfigurationPropertyAttribute("listeners")]
public ListenerElementsCollection Listeners { get; }
    [ConfigurationPropertyAttribute("useGlobalLock")]
public bool UseGlobalLock { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static TraceSection();
    public bool get_AutoFlush();
    public int get_IndentSize();
    public ListenerElementsCollection get_Listeners();
    public bool get_UseGlobalLock();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Diagnostics.TraceSource : object {
    private static List`1<WeakReference> tracesources;
    private static int s_LastCollectionCount;
    private SourceSwitch modreq(System.Runtime.CompilerServices.IsVolatile) internalSwitch;
    private TraceListenerCollection modreq(System.Runtime.CompilerServices.IsVolatile) listeners;
    private StringDictionary attributes;
    private SourceLevels switchLevel;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) sourceName;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initCalled;
    public StringDictionary Attributes { get; }
    public string Name { get; }
    public TraceListenerCollection Listeners { get; }
    public SourceSwitch Switch { get; public set; }
    public TraceSource(string name);
    public TraceSource(string name, SourceLevels defaultLevel);
    private static TraceSource();
    private static void _pruneCachedTraceSources();
    private void Initialize();
    private void NoConfigInit();
    public void Close();
    public void Flush();
    protected internal virtual String[] GetSupportedAttributes();
    internal static void RefreshAll();
    internal void Refresh();
    [ConditionalAttribute("TRACE")]
public void TraceEvent(TraceEventType eventType, int id);
    [ConditionalAttribute("TRACE")]
public void TraceEvent(TraceEventType eventType, int id, string message);
    [ConditionalAttribute("TRACE")]
public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public void TraceData(TraceEventType eventType, int id, object data);
    [ConditionalAttribute("TRACE")]
public void TraceData(TraceEventType eventType, int id, Object[] data);
    [ConditionalAttribute("TRACE")]
public void TraceInformation(string message);
    [ConditionalAttribute("TRACE")]
public void TraceInformation(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public void TraceTransfer(int id, string message, Guid relatedActivityId);
    private void CreateSwitch(string typename, string name);
    public StringDictionary get_Attributes();
    public string get_Name();
    public TraceListenerCollection get_Listeners();
    public SourceSwitch get_Switch();
    public void set_Switch(SourceSwitch value);
}
internal class System.Diagnostics.TraceSourceInfo : object {
    private string name;
    private SourceLevels levels;
    private TraceListenerCollection listeners;
    public string Name { get; }
    public SourceLevels Levels { get; }
    public TraceListenerCollection Listeners { get; }
    public TraceSourceInfo(string name, SourceLevels levels);
    internal TraceSourceInfo(string name, SourceLevels levels, TraceImplSettings settings);
    public string get_Name();
    public SourceLevels get_Levels();
    public TraceListenerCollection get_Listeners();
}
[SwitchLevelAttribute("System.Diagnostics.TraceLevel")]
public class System.Diagnostics.TraceSwitch : Switch {
    public TraceLevel Level { get; public set; }
    public bool TraceError { get; }
    public bool TraceWarning { get; }
    public bool TraceInfo { get; }
    public bool TraceVerbose { get; }
    public TraceSwitch(string displayName, string description);
    public TraceSwitch(string displayName, string description, string defaultSwitchValue);
    public TraceLevel get_Level();
    public void set_Level(TraceLevel value);
    public bool get_TraceError();
    public bool get_TraceWarning();
    public bool get_TraceInfo();
    public bool get_TraceVerbose();
    protected virtual void OnSwitchSettingChanged();
    protected virtual void OnValueChanged();
}
internal static class System.Diagnostics.TraceUtils : object {
    internal static object GetRuntimeObject(string className, Type baseType, string initializeData);
    internal static bool IsOwnedTL(Type type);
    internal static bool IsOwnedTextWriterTL(Type type);
    private static object ConvertToBaseTypeOrEnum(string value, Type type);
    internal static void VerifyAttributes(IDictionary attributes, String[] supportedAttributes, object parent);
}
internal class System.Diagnostics.TypedElement : ConfigurationElement {
    protected static ConfigurationProperty _propTypeName;
    protected static ConfigurationProperty _propInitData;
    protected ConfigurationPropertyCollection _properties;
    protected object _runtimeObject;
    private Type _baseType;
    [ConfigurationPropertyAttribute("initializeData")]
public string InitData { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("type")]
public string TypeName { get; public set; }
    public TypedElement(Type baseType);
    private static TypedElement();
    public string get_InitData();
    public void set_InitData(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual string get_TypeName();
    public virtual void set_TypeName(string value);
    protected object BaseGetRuntimeObject();
}
internal class System.Diagnostics.UserCallBack : MulticastDelegate {
    public UserCallBack(object object, IntPtr method);
    public virtual void Invoke(string data);
    public virtual IAsyncResult BeginInvoke(string data, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Diagnostics.Win32EventLog : EventLogImpl {
    private static int MESSAGE_NOT_FOUND;
    private ManualResetEvent _notifyResetEvent;
    private IntPtr _readHandle;
    private Thread _notifyThread;
    private int _lastEntryWritten;
    private object _eventLock;
    private int OldestEventLogEntry { get; }
    private IntPtr ReadHandle { get; }
    public OverflowAction OverflowAction { get; }
    public int MinimumRetentionDays { get; }
    public long MaximumKilobytes { get; public set; }
    public Win32EventLog(EventLog coreEventLog);
    public virtual void BeginInit();
    public virtual void Clear();
    public virtual void Close();
    public virtual void CreateEventSource(EventSourceCreationData sourceData);
    public virtual void Delete(string logName, string machineName);
    public virtual void DeleteEventSource(string source, string machineName);
    public virtual void Dispose(bool disposing);
    public virtual void EndInit();
    public virtual bool Exists(string logName, string machineName);
    [MonoTODOAttribute]
protected virtual string FormatMessage(string source, UInt32 messageID, String[] replacementStrings);
    private string FormatCategory(string source, int category);
    protected virtual int GetEntryCount();
    protected virtual EventLogEntry GetEntry(int index);
    [MonoTODOAttribute]
protected virtual string GetLogDisplayName();
    protected virtual String[] GetLogNames(string machineName);
    public virtual string LogNameFromSourceName(string source, string machineName);
    public virtual bool SourceExists(string source, string machineName);
    public virtual void WriteEntry(String[] replacementStrings, EventLogEntryType type, UInt32 instanceID, short category, Byte[] rawData);
    private static void UpdateLogRegistry(RegistryKey logKey);
    private static void UpdateSourceRegistry(RegistryKey sourceKey, EventSourceCreationData data);
    private static string GetLogName(RegistryKey logKey);
    private void ReadEventLog(int index, Byte[] buffer, Int32& bytesRead, Int32& minBufferNeeded);
    [MonoTODOAttribute("Support remote machines")]
private static RegistryKey GetEventLogKey(string machineName, bool writable);
    private static RegistryKey FindSourceKeyByName(string source, string machineName, bool writable);
    private static RegistryKey FindLogKeyByName(string logName, string machineName, bool writable);
    private static RegistryKey FindLogKeyBySource(string source, string machineName, bool writable);
    private int get_OldestEventLogEntry();
    private void CloseEventLog(IntPtr hEventLog);
    private void DeregisterEventSource(IntPtr hEventLog);
    private static string LookupAccountSid(string machineName, Byte[] sid);
    private static string FetchMessage(string msgDll, UInt32 messageID, String[] replacementStrings);
    private String[] GetMessageResourceDlls(string source, string valueName);
    private IntPtr get_ReadHandle();
    private IntPtr RegisterEventSource();
    public virtual void DisableNotification();
    public virtual void EnableNotification();
    private void NotifyEventThread(ManualResetEvent resetEvent);
    public virtual OverflowAction get_OverflowAction();
    public virtual int get_MinimumRetentionDays();
    public virtual long get_MaximumKilobytes();
    public virtual void set_MaximumKilobytes(long value);
    public virtual void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    public virtual void RegisterDisplayName(string resourceFile, long resourceId);
    [CompilerGeneratedAttribute]
private void <EnableNotification>b__44_0();
}
public class System.Diagnostics.XmlWriterTraceListener : TextWriterTraceListener {
    private static string fixedHeader;
    private string machineName;
    private StringBuilder strBldr;
    private XmlTextWriter xmlBlobWriter;
    internal bool shouldRespectFilterOnTraceTransfer;
    public XmlWriterTraceListener(Stream stream);
    public XmlWriterTraceListener(Stream stream, string name);
    public XmlWriterTraceListener(TextWriter writer);
    public XmlWriterTraceListener(TextWriter writer, string name);
    public XmlWriterTraceListener(string filename);
    public XmlWriterTraceListener(string filename, string name);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    public virtual void Fail(string message, string detailMessage);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    private void WriteData(object data);
    public virtual void Close();
    public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
    private void WriteHeader(string source, TraceEventType eventType, int id, TraceEventCache eventCache, Guid relatedActivityId);
    private void WriteHeader(string source, TraceEventType eventType, int id, TraceEventCache eventCache);
    private void WriteStartHeader(string source, TraceEventType eventType, int id, TraceEventCache eventCache);
    private void WriteEndHeader(TraceEventCache eventCache);
    private void WriteFooter(TraceEventCache eventCache);
    private void WriteEscaped(string str);
    private void InternalWrite(string message);
}
internal class System.DomainNameHelper : object {
    private static char c_DummyChar;
    internal static string Localhost;
    internal static string Loopback;
    internal static string ParseCanonicalName(string str, int start, int end, Boolean& loopback);
    internal static bool IsValid(Char* name, ushort pos, Int32& returnedEnd, Boolean& notCanonical, bool notImplicitFile);
    internal static bool IsValidByIri(Char* name, ushort pos, Int32& returnedEnd, Boolean& notCanonical, bool notImplicitFile);
    internal static string IdnEquivalent(string hostname);
    internal static string IdnEquivalent(Char* hostname, int start, int end, Boolean& allAscii, Boolean& atLeastOneValidIdn);
    internal static string IdnEquivalent(Char* hostname, int start, int end, Boolean& allAscii, String& bidiStrippedHost);
    private static bool IsIdnAce(string input, int index);
    private static bool IsIdnAce(Char* input, int index);
    internal static string UnicodeEquivalent(string idnHost, Char* hostname, int start, int end);
    internal static string UnicodeEquivalent(Char* hostname, int start, int end, Boolean& allAscii, Boolean& atLeastOneValidIdn);
    private static bool IsASCIILetterOrDigit(char character, Boolean& notCanonical);
    private static bool IsValidDomainLabelCharacter(char character, Boolean& notCanonical);
}
internal static class System.EnvironmentHelpers : object {
    internal static bool IsWindowsVistaOrAbove();
}
public class System.FileStyleUriParser : UriParser {
}
public class System.FtpStyleUriParser : UriParser {
}
public class System.GenericUriParser : UriParser {
    private static UriSyntaxFlags DefaultGenericUriParserFlags;
    public GenericUriParser(GenericUriParserOptions options);
    private static UriSyntaxFlags MapGenericParserOptions(GenericUriParserOptions options);
}
[FlagsAttribute]
public enum System.GenericUriParserOptions : Enum {
    public int value__;
    public static GenericUriParserOptions Default;
    public static GenericUriParserOptions GenericAuthority;
    public static GenericUriParserOptions AllowEmptyAuthority;
    public static GenericUriParserOptions NoUserInfo;
    public static GenericUriParserOptions NoPort;
    public static GenericUriParserOptions NoQuery;
    public static GenericUriParserOptions NoFragment;
    public static GenericUriParserOptions DontConvertPathBackslashes;
    public static GenericUriParserOptions DontCompressPath;
    public static GenericUriParserOptions DontUnescapePathDotsAndSlashes;
    public static GenericUriParserOptions Idn;
    public static GenericUriParserOptions IriParsing;
}
public class System.GopherStyleUriParser : UriParser {
}
internal static class System.HResults : object {
    internal static int Configuration;
    internal static int Xml;
    internal static int XmlSchema;
    internal static int XmlXslt;
    internal static int XmlXPath;
    internal static int Data;
    internal static int DataDeletedRowInaccessible;
    internal static int DataDuplicateName;
    internal static int DataInRowChangingEvent;
    internal static int DataInvalidConstraint;
    internal static int DataMissingPrimaryKey;
    internal static int DataNoNullAllowed;
    internal static int DataReadOnly;
    internal static int DataRowNotInTable;
    internal static int DataVersionNotFound;
    internal static int DataConstraint;
    internal static int StrongTyping;
    internal static int SqlType;
    internal static int SqlNullValue;
    internal static int SqlTruncate;
    internal static int AdapterMapping;
    internal static int DataAdapter;
    internal static int DBConcurrency;
    internal static int OperationAborted;
    internal static int InvalidUdt;
    internal static int Metadata;
    internal static int InvalidQuery;
    internal static int CommandCompilation;
    internal static int CommandExecution;
    internal static int SqlException;
    internal static int OdbcException;
    internal static int OracleException;
    internal static int ConnectionPlanException;
    internal static int NteBadKeySet;
    internal static int Win32AccessDenied;
    internal static int Win32InvalidHandle;
    internal static int License;
    internal static int InternalBufferOverflow;
    internal static int ServiceControllerTimeout;
    internal static int Install;
    internal static int EFail;
}
public class System.HttpStyleUriParser : UriParser {
}
internal class System.InvariantComparer : object {
    private CompareInfo m_compareInfo;
    internal static InvariantComparer Default;
    private static InvariantComparer();
    public sealed virtual int Compare(object a, object b);
}
internal class System.IO.ChunkedMemoryStream : Stream {
    private MemoryChunk _headChunk;
    private MemoryChunk _currentChunk;
    private static int InitialChunkDefaultSize;
    private static int MaxChunkSize;
    private int _totalLength;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private void AppendChunk(long count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
public enum System.IO.Compression.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel Optimal;
    public static CompressionLevel Fastest;
    public static CompressionLevel NoCompression;
}
public enum System.IO.Compression.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Decompress;
    public static CompressionMode Compress;
}
public class System.IO.Compression.DeflateStream : Stream {
    private Stream base_stream;
    private CompressionMode mode;
    private bool leaveOpen;
    private bool disposed;
    private DeflateStreamNative native;
    public Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DeflateStream(Stream stream, CompressionMode mode);
    public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen);
    internal DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen, int windowsBits);
    internal DeflateStream(Stream compressedStream, CompressionMode mode, bool leaveOpen, bool gzip);
    public DeflateStream(Stream stream, CompressionLevel compressionLevel);
    public DeflateStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    internal DeflateStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen, int windowsBits);
    internal DeflateStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen, bool gzip);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    private int ReadInternal(Byte[] array, int offset, int count);
    internal ValueTask`1<int> ReadAsyncMemory(Memory`1<byte> destination, CancellationToken cancellationToken);
    internal int ReadCore(Span`1<byte> destination);
    public virtual int Read(Byte[] array, int offset, int count);
    private void WriteInternal(Byte[] array, int offset, int count);
    internal ValueTask WriteAsyncMemory(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    internal void WriteCore(ReadOnlySpan`1<byte> source);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Flush();
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class System.IO.Compression.DeflateStreamNative : object {
    private static int BufferSize;
    private UnmanagedReadOrWrite feeder;
    private Stream base_stream;
    private SafeDeflateStreamHandle z_stream;
    private GCHandle data;
    private bool disposed;
    private Byte[] io_buffer;
    private Exception last_error;
    public static DeflateStreamNative Create(Stream compressedStream, CompressionMode mode, bool gzip);
    protected virtual override void Finalize();
    public void Dispose(bool disposing);
    public void Flush();
    public int ReadZStream(IntPtr buffer, int length);
    public void WriteZStream(IntPtr buffer, int length);
    [MonoPInvokeCallbackAttribute("System.IO.Compression.DeflateStreamNative/UnmanagedReadOrWrite")]
private static int UnmanagedRead(IntPtr buffer, int length, IntPtr data);
    private int UnmanagedRead(IntPtr buffer, int length);
    [MonoPInvokeCallbackAttribute("System.IO.Compression.DeflateStreamNative/UnmanagedReadOrWrite")]
private static int UnmanagedWrite(IntPtr buffer, int length, IntPtr data);
    private int UnmanagedWrite(IntPtr buffer, int length);
    private void CheckResult(int result, string where);
    private static SafeDeflateStreamHandle CreateZStream(CompressionMode compress, bool gzip, UnmanagedReadOrWrite feeder, IntPtr data);
    private static int CloseZStream(IntPtr stream);
    private static int Flush(SafeDeflateStreamHandle stream);
    private static int ReadZStream(SafeDeflateStreamHandle stream, IntPtr buffer, int length);
    private static int WriteZStream(SafeDeflateStreamHandle stream, IntPtr buffer, int length);
}
public class System.IO.Compression.GZipStream : Stream {
    private DeflateStream _deflateStream;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Stream BaseStream { get; }
    public GZipStream(Stream stream, CompressionMode mode);
    public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public GZipStream(Stream stream, CompressionLevel compressionLevel);
    public GZipStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void CopyTo(Stream destination, int bufferSize);
    protected virtual void Dispose(bool disposing);
    public Stream get_BaseStream();
    public virtual Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private void CheckDeflateStream();
    private static void ThrowStreamClosedException();
}
internal class System.IO.Compression.ZLibNative : object {
    public static int GZip_DefaultWindowBits;
}
public class System.IO.CoreFX.FileSystemWatcher : Component {
    private int _currentSession;
    private SafeFileHandle _directoryHandle;
    private NormalizedFilterCollection _filters;
    private string _directory;
    private static NotifyFilters c_defaultNotifyFilters;
    private NotifyFilters _notifyFilters;
    private bool _includeSubdirectories;
    private bool _enabled;
    private bool _initializing;
    private UInt32 _internalBufferSize;
    private bool _disposed;
    private FileSystemEventHandler _onChangedHandler;
    private FileSystemEventHandler _onCreatedHandler;
    private FileSystemEventHandler _onDeletedHandler;
    private RenamedEventHandler _onRenamedHandler;
    private ErrorEventHandler _onErrorHandler;
    private static Char[] s_wildcards;
    private static int c_notifyFiltersValidMask;
    [CompilerGeneratedAttribute]
private ISynchronizeInvoke <SynchronizingObject>k__BackingField;
    public NotifyFilters NotifyFilter { get; public set; }
    public Collection`1<string> Filters { get; }
    public bool EnableRaisingEvents { get; public set; }
    public string Filter { get; public set; }
    public bool IncludeSubdirectories { get; public set; }
    public int InternalBufferSize { get; public set; }
    public string Path { get; public set; }
    public ISite Site { get; public set; }
    public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public FileSystemWatcher(string path);
    public FileSystemWatcher(string path, string filter);
    private static FileSystemWatcher();
    private void StartRaisingEvents();
    private void StopRaisingEvents();
    private void FinalizeDispose();
    private static bool IsHandleInvalid(SafeFileHandle handle);
    private void Monitor(AsyncReadState state);
    private void ReadDirectoryChangesCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* overlappedPointer);
    private void ParseEventBufferAndNotifyForEach(Byte[] buffer);
    public NotifyFilters get_NotifyFilter();
    public void set_NotifyFilter(NotifyFilters value);
    public Collection`1<string> get_Filters();
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public string get_Filter();
    public void set_Filter(string value);
    public bool get_IncludeSubdirectories();
    public void set_IncludeSubdirectories(bool value);
    public int get_InternalBufferSize();
    public void set_InternalBufferSize(int value);
    private Byte[] AllocateBuffer();
    public string get_Path();
    public void set_Path(string value);
    public void add_Changed(FileSystemEventHandler value);
    public void remove_Changed(FileSystemEventHandler value);
    public void add_Created(FileSystemEventHandler value);
    public void remove_Created(FileSystemEventHandler value);
    public void add_Deleted(FileSystemEventHandler value);
    public void remove_Deleted(FileSystemEventHandler value);
    public void add_Error(ErrorEventHandler value);
    public void remove_Error(ErrorEventHandler value);
    public void add_Renamed(RenamedEventHandler value);
    public void remove_Renamed(RenamedEventHandler value);
    protected virtual void Dispose(bool disposing);
    private static void CheckPathValidity(string path);
    private bool MatchPattern(ReadOnlySpan`1<char> relativePath);
    private void NotifyInternalBufferOverflowEvent();
    private void NotifyRenameEventArgs(WatcherChangeTypes action, ReadOnlySpan`1<char> name, ReadOnlySpan`1<char> oldName);
    private FileSystemEventHandler GetHandler(WatcherChangeTypes changeType);
    private void NotifyFileSystemEventArgs(WatcherChangeTypes changeType, ReadOnlySpan`1<char> name);
    private void NotifyFileSystemEventArgs(WatcherChangeTypes changeType, string name);
    protected void OnChanged(FileSystemEventArgs e);
    protected void OnCreated(FileSystemEventArgs e);
    protected void OnDeleted(FileSystemEventArgs e);
    private void InvokeOn(FileSystemEventArgs e, FileSystemEventHandler handler);
    protected void OnError(ErrorEventArgs e);
    protected void OnRenamed(RenamedEventArgs e);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout);
    private void Restart();
    private void StartRaisingEventsIfNotDisposed();
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    [CompilerGeneratedAttribute]
public ISynchronizeInvoke get_SynchronizingObject();
    [CompilerGeneratedAttribute]
public void set_SynchronizingObject(ISynchronizeInvoke value);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    private bool IsSuspended();
}
internal class System.IO.CoreFXFileSystemWatcherProxy : object {
    private static IFileWatcher instance;
    private static IDictionary`2<object, FileSystemWatcher> internal_map;
    private static ConditionalWeakTable`2<object, FileSystemWatcher> external_map;
    private static IDictionary`2<object, object> event_map;
    private static int INTERRUPT_MS;
    protected void Operation(Action`4<IDictionary`2<object, FileSystemWatcher>, ConditionalWeakTable`2<object, FileSystemWatcher>, IDictionary`2<object, object>, object> map_op, Action`2<FileSystemWatcher, FileSystemWatcher> object_op, object handle, Action`2<FileSystemWatcher, FileSystemWatcher> cancel_op);
    protected void ProxyDispatch(object sender, FileAction action, FileSystemEventArgs args);
    protected void ProxyDispatchError(object sender, ErrorEventArgs args);
    public object NewWatcher(FileSystemWatcher fsw);
    public sealed virtual void StartDispatching(object handle);
    public sealed virtual void StopDispatching(object handle);
    public sealed virtual void Dispose(object handle);
    public static bool GetInstance(IFileWatcher& watcher);
}
internal class System.IO.DefaultWatcher : object {
    private static DefaultWatcher instance;
    private static Thread thread;
    private static Hashtable watches;
    private static String[] NoStringsArray;
    private static DefaultWatcher();
    public static bool GetInstance(IFileWatcher& watcher);
    public sealed virtual void StartDispatching(object handle);
    public sealed virtual void StopDispatching(object handle);
    public sealed virtual void Dispose(object handle);
    private void Monitor();
    private bool UpdateDataAndDispatch(DefaultWatcherData data, bool dispatch);
    private static void DispatchEvents(FileSystemWatcher fsw, FileAction action, string filename);
    private void DoFiles(DefaultWatcherData data, string directory, bool dispatch);
    private void IterateAndModifyFilesData(DefaultWatcherData data, string directory, bool dispatch, String[] files);
    private static FileData CreateFileData(string directory, string filename);
}
internal class System.IO.DefaultWatcherData : object {
    public FileSystemWatcher FSW;
    public string Directory;
    public string FileMask;
    public bool IncludeSubdirs;
    public bool Enabled;
    public bool NoWildcards;
    public DateTime DisabledTime;
    public object FilesLock;
    public Dictionary`2<string, FileData> Files;
}
public class System.IO.ErrorEventArgs : EventArgs {
    private Exception exception;
    public ErrorEventArgs(Exception exception);
    public virtual Exception GetException();
}
public class System.IO.ErrorEventHandler : MulticastDelegate {
    public ErrorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ErrorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ErrorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum System.IO.EventFilter : Enum {
    public short value__;
    public static EventFilter Read;
    public static EventFilter Write;
    public static EventFilter Aio;
    public static EventFilter Vnode;
    public static EventFilter Proc;
    public static EventFilter Signal;
    public static EventFilter Timer;
    public static EventFilter MachPort;
    public static EventFilter FS;
    public static EventFilter User;
    public static EventFilter VM;
}
[FlagsAttribute]
internal enum System.IO.EventFlags : Enum {
    public ushort value__;
    public static EventFlags Add;
    public static EventFlags Delete;
    public static EventFlags Enable;
    public static EventFlags Disable;
    public static EventFlags OneShot;
    public static EventFlags Clear;
    public static EventFlags Receipt;
    public static EventFlags Dispatch;
    public static EventFlags Flag0;
    public static EventFlags Flag1;
    public static EventFlags SystemFlags;
    public static EventFlags EOF;
    public static EventFlags Error;
}
internal enum System.IO.FAMCodes : Enum {
    public int value__;
    public static FAMCodes Changed;
    public static FAMCodes Deleted;
    public static FAMCodes StartExecuting;
    public static FAMCodes StopExecuting;
    public static FAMCodes Created;
    public static FAMCodes Moved;
    public static FAMCodes Acknowledge;
    public static FAMCodes Exists;
    public static FAMCodes EndExist;
}
internal class System.IO.FAMConnection : ValueType {
    public int FD;
    public IntPtr opaque;
}
internal class System.IO.FAMData : object {
    public FileSystemWatcher FSW;
    public string Directory;
    public string FileMask;
    public bool IncludeSubdirs;
    public bool Enabled;
    public FAMRequest Request;
    public Hashtable SubDirs;
}
internal class System.IO.FAMRequest : ValueType {
    public int ReqNum;
}
internal class System.IO.FAMWatcher : object {
    private static bool failed;
    private static FAMWatcher instance;
    private static Hashtable watches;
    private static Hashtable requests;
    private static FAMConnection conn;
    private static Thread thread;
    private static bool stop;
    private static bool use_gamin;
    private static NotifyFilters changed;
    public static bool GetInstance(IFileWatcher& watcher, bool gamin);
    public sealed virtual void StartDispatching(object handle);
    private static void StartMonitoringDirectory(FAMData data, bool justcreated);
    public sealed virtual void StopDispatching(object handle);
    private static void StopMonitoringDirectory(FAMData data);
    private void Monitor();
    private void ProcessEvents();
    protected virtual override void Finalize();
    private static int FAMOpen(FAMConnection& fc);
    private static int FAMClose(FAMConnection& fc);
    private static int FAMMonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data);
    private static int FAMCancelMonitor(FAMConnection& fc, FAMRequest& fr);
    private static int FAMPending(FAMConnection& fc);
    public sealed virtual void Dispose(object handle);
    private static int fam_Open(FAMConnection& fc);
    private static int fam_Close(FAMConnection& fc);
    private static int fam_MonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data);
    private static int fam_CancelMonitor(FAMConnection& fc, FAMRequest& fr);
    private static int fam_Pending(FAMConnection& fc);
    private static int gamin_Open(FAMConnection& fc);
    private static int gamin_Close(FAMConnection& fc);
    private static int gamin_MonitorDirectory(FAMConnection& fc, string filename, FAMRequest& fr, IntPtr user_data);
    private static int gamin_CancelMonitor(FAMConnection& fc, FAMRequest& fr);
    private static int gamin_Pending(FAMConnection& fc);
    private static int InternalFAMNextEvent(FAMConnection& fc, String& filename, Int32& code, Int32& reqnum);
}
internal enum System.IO.FileAction : Enum {
    public int value__;
    public static FileAction Added;
    public static FileAction Removed;
    public static FileAction Modified;
    public static FileAction RenamedOldName;
    public static FileAction RenamedNewName;
}
internal class System.IO.FileData : object {
    public string Directory;
    public FileAttributes Attributes;
    public bool NotExists;
    public DateTime CreationTime;
    public DateTime LastWriteTime;
}
public class System.IO.FileSystemEventArgs : EventArgs {
    private WatcherChangeTypes _changeType;
    private string _name;
    private string _fullPath;
    public WatcherChangeTypes ChangeType { get; }
    public string FullPath { get; }
    public string Name { get; }
    public FileSystemEventArgs(WatcherChangeTypes changeType, string directory, string name);
    internal static string Combine(string directoryPath, string name);
    public WatcherChangeTypes get_ChangeType();
    public string get_FullPath();
    public string get_Name();
}
public class System.IO.FileSystemEventHandler : MulticastDelegate {
    public FileSystemEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FileSystemEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FileSystemEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultEventAttribute("Changed")]
[IODescriptionAttribute("")]
public class System.IO.FileSystemWatcher : Component {
    private bool inited;
    private bool start_requested;
    private bool enableRaisingEvents;
    private string filter;
    private bool includeSubdirectories;
    private int internalBufferSize;
    private NotifyFilters notifyFilter;
    private string path;
    private string fullpath;
    private ISynchronizeInvoke synchronizingObject;
    private WaitForChangedResult lastData;
    private bool waiting;
    private SearchPattern2 pattern;
    private bool disposed;
    private string mangledFilter;
    private IFileWatcher watcher;
    private object watcher_handle;
    private static object lockobj;
    [CompilerGeneratedAttribute]
private FileSystemEventHandler Changed;
    [CompilerGeneratedAttribute]
private FileSystemEventHandler Created;
    [CompilerGeneratedAttribute]
private FileSystemEventHandler Deleted;
    [CompilerGeneratedAttribute]
private ErrorEventHandler Error;
    [CompilerGeneratedAttribute]
private RenamedEventHandler Renamed;
    internal bool Waiting { get; internal set; }
    internal string MangledFilter { get; }
    internal SearchPattern2 Pattern { get; }
    internal string FullPath { get; }
    [IODescriptionAttribute("Flag to indicate if this instance is active")]
[DefaultValueAttribute("False")]
public bool EnableRaisingEvents { get; public set; }
    [TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[DefaultValueAttribute("*.*")]
[IODescriptionAttribute("File name filter pattern")]
[SettingsBindableAttribute("True")]
public string Filter { get; public set; }
    [DefaultValueAttribute("False")]
[IODescriptionAttribute("Flag to indicate we want to watch subdirectories")]
public bool IncludeSubdirectories { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("8192")]
public int InternalBufferSize { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IODescriptionAttribute("Flag to indicate which change event we want to monitor")]
public NotifyFilters NotifyFilter { get; public set; }
    [DefaultValueAttribute("")]
[IODescriptionAttribute("The directory to monitor")]
[SettingsBindableAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[EditorAttribute("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public string Path { get; public set; }
    [BrowsableAttribute("False")]
public ISite Site { get; public set; }
    [DefaultValueAttribute("")]
[BrowsableAttribute("False")]
[IODescriptionAttribute("The object used to marshal the event handler calls resulting from a directory change")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public FileSystemWatcher(string path);
    public FileSystemWatcher(string path, string filter);
    private static FileSystemWatcher();
    private void InitWatcher();
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("TRACE")]
private void ShowWatcherInfo();
    internal bool get_Waiting();
    internal void set_Waiting(bool value);
    internal string get_MangledFilter();
    internal SearchPattern2 get_Pattern();
    internal string get_FullPath();
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public string get_Filter();
    public void set_Filter(string value);
    public bool get_IncludeSubdirectories();
    public void set_IncludeSubdirectories(bool value);
    public int get_InternalBufferSize();
    public void set_InternalBufferSize(int value);
    public NotifyFilters get_NotifyFilter();
    public void set_NotifyFilter(NotifyFilters value);
    public string get_Path();
    public void set_Path(string value);
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public sealed virtual void BeginInit();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void EndInit();
    private void RaiseEvent(Delegate ev, EventArgs arg, EventType evtype);
    protected void OnChanged(FileSystemEventArgs e);
    protected void OnCreated(FileSystemEventArgs e);
    protected void OnDeleted(FileSystemEventArgs e);
    protected void OnError(ErrorEventArgs e);
    protected void OnRenamed(RenamedEventArgs e);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout);
    internal void DispatchErrorEvents(ErrorEventArgs args);
    internal void DispatchEvents(FileAction act, string filename, RenamedEventArgs& renamed);
    private void Start();
    private void Stop();
    [CompilerGeneratedAttribute]
public void add_Changed(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Created(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Created(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Deleted(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Deleted(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Error(ErrorEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Error(ErrorEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Renamed(RenamedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Renamed(RenamedEventHandler value);
    private static int InternalSupportsFSW();
}
[FlagsAttribute]
internal enum System.IO.FilterFlags : Enum {
    public UInt32 value__;
    public static FilterFlags ReadPoll;
    public static FilterFlags ReadOutOfBand;
    public static FilterFlags ReadLowWaterMark;
    public static FilterFlags WriteLowWaterMark;
    public static FilterFlags NoteTrigger;
    public static FilterFlags NoteFFNop;
    public static FilterFlags NoteFFAnd;
    public static FilterFlags NoteFFOr;
    public static FilterFlags NoteFFCopy;
    public static FilterFlags NoteFFCtrlMask;
    public static FilterFlags NoteFFlagsMask;
    public static FilterFlags VNodeDelete;
    public static FilterFlags VNodeWrite;
    public static FilterFlags VNodeExtend;
    public static FilterFlags VNodeAttrib;
    public static FilterFlags VNodeLink;
    public static FilterFlags VNodeRename;
    public static FilterFlags VNodeRevoke;
    public static FilterFlags VNodeNone;
    public static FilterFlags ProcExit;
    public static FilterFlags ProcFork;
    public static FilterFlags ProcExec;
    public static FilterFlags ProcReap;
    public static FilterFlags ProcSignal;
    public static FilterFlags ProcExitStatus;
    public static FilterFlags ProcResourceEnd;
    public static FilterFlags ProcAppactive;
    public static FilterFlags ProcAppBackground;
    public static FilterFlags ProcAppNonUI;
    public static FilterFlags ProcAppInactive;
    public static FilterFlags ProcAppAllStates;
    public static FilterFlags ProcPDataMask;
    public static FilterFlags ProcControlMask;
    public static FilterFlags VMPressure;
    public static FilterFlags VMPressureTerminate;
    public static FilterFlags VMPressureSuddenTerminate;
    public static FilterFlags VMError;
    public static FilterFlags TimerSeconds;
    public static FilterFlags TimerMicroSeconds;
    public static FilterFlags TimerNanoSeconds;
    public static FilterFlags TimerAbsolute;
}
internal interface System.IO.IFileWatcher {
    public abstract virtual void StartDispatching(object fsw);
    public abstract virtual void StopDispatching(object fsw);
    public abstract virtual void Dispose(object fsw);
}
public class System.IO.InternalBufferOverflowException : SystemException {
    public InternalBufferOverflowException(string message);
    protected InternalBufferOverflowException(SerializationInfo info, StreamingContext context);
    public InternalBufferOverflowException(string message, Exception inner);
}
public class System.IO.InvalidDataException : SystemException {
    private static int Result;
    public InvalidDataException(string message);
    public InvalidDataException(string message, Exception innerException);
    private InvalidDataException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("32767")]
public class System.IO.IODescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public IODescriptionAttribute(string description);
    public virtual string get_Description();
}
internal class System.IO.kevent : ValueType {
    public UIntPtr ident;
    public EventFilter filter;
    public EventFlags flags;
    public FilterFlags fflags;
    public IntPtr data;
    public IntPtr udata;
    public sealed virtual void Dispose();
}
internal class System.IO.KeventWatcher : object {
    private static bool failed;
    private static KeventWatcher instance;
    private static Hashtable watches;
    public static bool GetInstance(IFileWatcher& watcher);
    public sealed virtual void StartDispatching(object handle);
    public sealed virtual void StopDispatching(object handle);
    public sealed virtual void Dispose(object handle);
    private static int close(int fd);
    private static int kqueue();
}
internal class System.IO.KqueueMonitor : object {
    private static bool initialized;
    private static int O_EVTONLY;
    private static int F_GETPATH;
    private static int __DARWIN_MAXPATHLEN;
    private static int EINTR;
    private static kevent[] emptyEventList;
    private int maxFds;
    private FileSystemWatcher fsw;
    private int conn;
    private Thread thread;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) requestStop;
    private AutoResetEvent startedEvent;
    private bool started;
    private bool inDispatch;
    private Exception exc;
    private object stateLock;
    private object connLock;
    private Dictionary`2<string, PathData> pathsDict;
    private Dictionary`2<int, PathData> fdsDict;
    private string fixupPath;
    private string fullPathNoLastSlash;
    public int Connection { get; }
    public KqueueMonitor(FileSystemWatcher fsw);
    private static KqueueMonitor();
    public int get_Connection();
    public sealed virtual void Dispose();
    public void Start();
    public void Stop();
    private void CleanUp();
    private void DoMonitor();
    private void Setup();
    private kevent[] CreateChangeList(List`1& FdList);
    private void Monitor();
    private PathData Add(string path, bool postEvents, List`1& fds);
    private void Remove(PathData pathData);
    private void RemoveTree(PathData pathData);
    private void UpdatePath(PathData pathData);
    private void Scan(string path, bool postEvents, List`1& fds);
    private void PostEvent(FileAction action, string path, string newPath);
    private string GetFilenameFromFd(int fd);
    private static int fcntl(int file_names_by_descriptor, int cmd, StringBuilder sb);
    private static IntPtr realpath(string pathname, StringBuilder sb);
    private static int open(string path, int flags, int mode_t);
    private static int close(int fd);
    private static int kqueue();
    private static int kevent(int kq, kevent[] ev, int nchanges, kevent[] evtlist, int nevents, timespec& time);
    private static int kevent_notimeout(Int32& kq, IntPtr ev, int nchanges, IntPtr evtlist, int nevents);
    [CompilerGeneratedAttribute]
private void <Start>b__5_0();
}
[FlagsAttribute]
public enum System.IO.NotifyFilters : Enum {
    public int value__;
    public static NotifyFilters Attributes;
    public static NotifyFilters CreationTime;
    public static NotifyFilters DirectoryName;
    public static NotifyFilters FileName;
    public static NotifyFilters LastAccess;
    public static NotifyFilters LastWrite;
    public static NotifyFilters Security;
    public static NotifyFilters Size;
}
internal class System.IO.NullFileWatcher : object {
    private static IFileWatcher instance;
    public sealed virtual void StartDispatching(object handle);
    public sealed virtual void StopDispatching(object handle);
    public sealed virtual void Dispose(object handle);
    public static bool GetInstance(IFileWatcher& watcher);
}
internal class System.IO.PathData : object {
    public string Path;
    public bool IsDirectory;
    public int Fd;
}
internal static class System.IO.PathInternal : object {
    private static bool s_isCaseSensitive;
    internal static string ExtendedDevicePathPrefix;
    internal static string UncPathPrefix;
    internal static string UncDevicePrefixToInsert;
    internal static string UncExtendedPathPrefix;
    internal static string DevicePathPrefix;
    internal static int MaxShortPath;
    internal static int DevicePrefixLength;
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static PathInternal();
    internal static StringComparison get_StringComparison();
    internal static bool get_IsCaseSensitive();
    private static bool GetIsCaseSensitive();
    internal static bool IsValidDriveChar(char value);
    private static bool EndsWithPeriodOrSpace(string path);
    internal static string EnsureExtendedPrefixIfNeeded(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(string path);
    internal static bool IsExtended(string path);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsPartiallyQualified(string path);
    internal static bool IsDirectorySeparator(char c);
}
internal class System.IO.Ports.CommStat : ValueType {
    public UInt32 flags;
    public UInt32 BytesIn;
    public UInt32 BytesOut;
}
internal class System.IO.Ports.DCB : object {
    public int dcb_length;
    public int baud_rate;
    public int flags;
    public short w_reserved;
    public short xon_lim;
    public short xoff_lim;
    public byte byte_size;
    public byte parity;
    public byte stop_bits;
    public byte xon_char;
    public byte xoff_char;
    public byte error_char;
    public byte eof_char;
    public byte evt_char;
    public short w_reserved1;
    private static int fOutxCtsFlow;
    private static int fOutX;
    private static int fInX;
    private static int fRtsControl2;
    public void SetValues(int baud_rate, Parity parity, int byte_size, StopBits sb, Handshake hs);
}
public enum System.IO.Ports.Handshake : Enum {
    public int value__;
    public static Handshake None;
    public static Handshake XOnXOff;
    public static Handshake RequestToSend;
    public static Handshake RequestToSendXOnXOff;
}
internal static class System.IO.Ports.InternalResources : object {
    internal static void EndOfFile();
    internal static string GetMessage(int errorCode);
    internal static void FileNotOpen();
    internal static void WrongAsyncResult();
    internal static void EndReadCalledTwice();
    internal static void EndWriteCalledTwice();
    internal static void WinIOError(int errorCode, string str);
    internal static int MakeHRFromErrorCode(int errorCode);
}
internal interface System.IO.Ports.ISerialStream {
    public int BytesToRead { get; }
    public int BytesToWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    public abstract virtual void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits sb, Handshake hs);
    public abstract virtual void DiscardInBuffer();
    public abstract virtual void DiscardOutBuffer();
    public abstract virtual SerialSignal GetSignals();
    public abstract virtual void SetSignal(SerialSignal signal, bool value);
    public abstract virtual void SetBreakState(bool value);
    public abstract virtual void Close();
    public abstract virtual int get_BytesToRead();
    public abstract virtual int get_BytesToWrite();
    public abstract virtual int get_ReadTimeout();
    public abstract virtual void set_ReadTimeout(int value);
    public abstract virtual int get_WriteTimeout();
    public abstract virtual void set_WriteTimeout(int value);
}
public enum System.IO.Ports.Parity : Enum {
    public int value__;
    public static Parity None;
    public static Parity Odd;
    public static Parity Even;
    public static Parity Mark;
    public static Parity Space;
}
public enum System.IO.Ports.SerialData : Enum {
    public int value__;
    public static SerialData Chars;
    public static SerialData Eof;
}
public class System.IO.Ports.SerialDataReceivedEventArgs : EventArgs {
    private SerialData eventType;
    public SerialData EventType { get; }
    internal SerialDataReceivedEventArgs(SerialData eventType);
    public SerialData get_EventType();
}
public class System.IO.Ports.SerialDataReceivedEventHandler : MulticastDelegate {
    public SerialDataReceivedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SerialDataReceivedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SerialDataReceivedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.IO.Ports.SerialError : Enum {
    public int value__;
    public static SerialError RXOver;
    public static SerialError Overrun;
    public static SerialError RXParity;
    public static SerialError Frame;
    public static SerialError TXFull;
}
public class System.IO.Ports.SerialErrorReceivedEventArgs : EventArgs {
    private SerialError eventType;
    public SerialError EventType { get; }
    internal SerialErrorReceivedEventArgs(SerialError eventType);
    public SerialError get_EventType();
}
public class System.IO.Ports.SerialErrorReceivedEventHandler : MulticastDelegate {
    public SerialErrorReceivedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SerialErrorReceivedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SerialErrorReceivedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.IO.Ports.SerialPinChange : Enum {
    public int value__;
    public static SerialPinChange CtsChanged;
    public static SerialPinChange DsrChanged;
    public static SerialPinChange CDChanged;
    public static SerialPinChange Break;
    public static SerialPinChange Ring;
}
public class System.IO.Ports.SerialPinChangedEventArgs : EventArgs {
    private SerialPinChange eventType;
    public SerialPinChange EventType { get; }
    internal SerialPinChangedEventArgs(SerialPinChange eventType);
    public SerialPinChange get_EventType();
}
public class System.IO.Ports.SerialPinChangedEventHandler : MulticastDelegate {
    public SerialPinChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SerialPinChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SerialPinChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[MonitoringDescriptionAttribute("")]
public class System.IO.Ports.SerialPort : Component {
    public static int InfiniteTimeout;
    private static int DefaultReadBufferSize;
    private static int DefaultWriteBufferSize;
    private static int DefaultBaudRate;
    private static int DefaultDataBits;
    private static Parity DefaultParity;
    private static StopBits DefaultStopBits;
    private bool is_open;
    private int baud_rate;
    private Parity parity;
    private StopBits stop_bits;
    private Handshake handshake;
    private int data_bits;
    private bool break_state;
    private bool dtr_enable;
    private bool rts_enable;
    private ISerialStream stream;
    private Encoding encoding;
    private string new_line;
    private string port_name;
    private int read_timeout;
    private int write_timeout;
    private int readBufferSize;
    private int writeBufferSize;
    private object error_received;
    private object data_received;
    private object pin_changed;
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public Stream BaseStream { get; }
    [MonitoringDescriptionAttribute("")]
[BrowsableAttribute("True")]
[DefaultValueAttribute("9600")]
public int BaudRate { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool BreakState { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int BytesToRead { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int BytesToWrite { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool CDHolding { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public bool CtsHolding { get; }
    [DefaultValueAttribute("8")]
[BrowsableAttribute("True")]
[MonitoringDescriptionAttribute("")]
public int DataBits { get; public set; }
    [DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("")]
[MonoTODOAttribute("Not implemented")]
[BrowsableAttribute("True")]
public bool DiscardNull { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public bool DsrHolding { get; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("")]
public bool DtrEnable { get; public set; }
    [MonitoringDescriptionAttribute("")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
public Encoding Encoding { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[MonitoringDescriptionAttribute("")]
public Handshake Handshake { get; public set; }
    [BrowsableAttribute("False")]
public bool IsOpen { get; }
    [BrowsableAttribute("False")]
[MonitoringDescriptionAttribute("")]
[DefaultValueAttribute("
")]
public string NewLine { get; public set; }
    [MonitoringDescriptionAttribute("")]
[BrowsableAttribute("True")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public Parity Parity { get; public set; }
    [MonoTODOAttribute("Not implemented")]
[BrowsableAttribute("True")]
[MonitoringDescriptionAttribute("")]
[DefaultValueAttribute("63")]
public byte ParityReplace { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("COM1")]
[MonitoringDescriptionAttribute("")]
public string PortName { get; public set; }
    [DefaultValueAttribute("4096")]
[MonitoringDescriptionAttribute("")]
[BrowsableAttribute("True")]
public int ReadBufferSize { get; public set; }
    [MonitoringDescriptionAttribute("")]
[BrowsableAttribute("True")]
[DefaultValueAttribute("-1")]
public int ReadTimeout { get; public set; }
    [MonitoringDescriptionAttribute("")]
[BrowsableAttribute("True")]
[MonoTODOAttribute("Not implemented")]
[DefaultValueAttribute("1")]
public int ReceivedBytesThreshold { get; public set; }
    [DefaultValueAttribute("False")]
[BrowsableAttribute("True")]
[MonitoringDescriptionAttribute("")]
public bool RtsEnable { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[BrowsableAttribute("True")]
[MonitoringDescriptionAttribute("")]
public StopBits StopBits { get; public set; }
    [MonitoringDescriptionAttribute("")]
[DefaultValueAttribute("2048")]
[BrowsableAttribute("True")]
public int WriteBufferSize { get; public set; }
    [DefaultValueAttribute("-1")]
[BrowsableAttribute("True")]
[MonitoringDescriptionAttribute("")]
public int WriteTimeout { get; public set; }
    private static bool IsWindows { get; }
    public SerialPort(IContainer container);
    public SerialPort(string portName);
    public SerialPort(string portName, int baudRate);
    public SerialPort(string portName, int baudRate, Parity parity);
    public SerialPort(string portName, int baudRate, Parity parity, int dataBits);
    public SerialPort(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits);
    private static string GetDefaultPortName();
    public Stream get_BaseStream();
    public int get_BaudRate();
    public void set_BaudRate(int value);
    public bool get_BreakState();
    public void set_BreakState(bool value);
    public int get_BytesToRead();
    public int get_BytesToWrite();
    public bool get_CDHolding();
    public bool get_CtsHolding();
    public int get_DataBits();
    public void set_DataBits(int value);
    public bool get_DiscardNull();
    public void set_DiscardNull(bool value);
    public bool get_DsrHolding();
    public bool get_DtrEnable();
    public void set_DtrEnable(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public Handshake get_Handshake();
    public void set_Handshake(Handshake value);
    public bool get_IsOpen();
    public string get_NewLine();
    public void set_NewLine(string value);
    public Parity get_Parity();
    public void set_Parity(Parity value);
    public byte get_ParityReplace();
    public void set_ParityReplace(byte value);
    public string get_PortName();
    public void set_PortName(string value);
    public int get_ReadBufferSize();
    public void set_ReadBufferSize(int value);
    public int get_ReadTimeout();
    public void set_ReadTimeout(int value);
    public int get_ReceivedBytesThreshold();
    public void set_ReceivedBytesThreshold(int value);
    public bool get_RtsEnable();
    public void set_RtsEnable(bool value);
    public StopBits get_StopBits();
    public void set_StopBits(StopBits value);
    public int get_WriteBufferSize();
    public void set_WriteBufferSize(int value);
    public int get_WriteTimeout();
    public void set_WriteTimeout(int value);
    public void Close();
    protected virtual void Dispose(bool disposing);
    public void DiscardInBuffer();
    public void DiscardOutBuffer();
    public static String[] GetPortNames();
    private static bool get_IsWindows();
    public void Open();
    public int Read(Byte[] buffer, int offset, int count);
    public int Read(Char[] buffer, int offset, int count);
    internal int read_byte();
    public int ReadByte();
    public int ReadChar();
    public string ReadExisting();
    public string ReadLine();
    public string ReadTo(string value);
    public void Write(string text);
    public void Write(Byte[] buffer, int offset, int count);
    public void Write(Char[] buffer, int offset, int count);
    public void WriteLine(string text);
    private void CheckOpen();
    internal void OnErrorReceived(SerialErrorReceivedEventArgs args);
    internal void OnDataReceived(SerialDataReceivedEventArgs args);
    internal void OnDataReceived(SerialPinChangedEventArgs args);
    public void add_ErrorReceived(SerialErrorReceivedEventHandler value);
    public void remove_ErrorReceived(SerialErrorReceivedEventHandler value);
    public void add_PinChanged(SerialPinChangedEventHandler value);
    public void remove_PinChanged(SerialPinChangedEventHandler value);
    public void add_DataReceived(SerialDataReceivedEventHandler value);
    public void remove_DataReceived(SerialDataReceivedEventHandler value);
}
internal class System.IO.Ports.SerialPortStream : Stream {
    private int fd;
    private int read_timeout;
    private int write_timeout;
    private bool disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public int BytesToRead { get; }
    public int BytesToWrite { get; }
    public SerialPortStream(string portName, int baudRate, int dataBits, Parity parity, StopBits stopBits, bool dtrEnable, bool rtsEnable, Handshake handshake, int readTimeout, int writeTimeout, int readBufferSize, int writeBufferSize);
    private static int open_serial(string portName);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    private static int read_serial(int fd, Byte[] buffer, int offset, int count);
    private static bool poll_serial(int fd, Int32& error, int timeout);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private static int write_serial(int fd, Byte[] buffer, int offset, int count, int timeout);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private static int close_serial(int fd);
    public virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual override void Finalize();
    private void CheckDisposed();
    private static bool set_attributes(int fd, int baudRate, Parity parity, int dataBits, StopBits stopBits, Handshake handshake);
    public sealed virtual void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits sb, Handshake hs);
    private static int get_bytes_in_buffer(int fd, int input);
    public sealed virtual int get_BytesToRead();
    public sealed virtual int get_BytesToWrite();
    private static int discard_buffer(int fd, bool inputBuffer);
    public sealed virtual void DiscardInBuffer();
    public sealed virtual void DiscardOutBuffer();
    private static SerialSignal get_signals(int fd, Int32& error);
    public sealed virtual SerialSignal GetSignals();
    private static int set_signal(int fd, SerialSignal signal, bool value);
    public sealed virtual void SetSignal(SerialSignal signal, bool value);
    private static int breakprop(int fd);
    public sealed virtual void SetBreakState(bool value);
    private static IntPtr strerror(int errnum);
    private static void ThrowIOException();
    private static bool is_baud_rate_legal(int baud_rate);
    private void TryBaudRate(int baudRate);
}
internal enum System.IO.Ports.SerialSignal : Enum {
    public int value__;
    public static SerialSignal None;
    public static SerialSignal Cd;
    public static SerialSignal Cts;
    public static SerialSignal Dsr;
    public static SerialSignal Dtr;
    public static SerialSignal Rts;
}
public enum System.IO.Ports.StopBits : Enum {
    public int value__;
    public static StopBits None;
    public static StopBits One;
    public static StopBits Two;
    public static StopBits OnePointFive;
}
internal class System.IO.Ports.Timeouts : object {
    public UInt32 ReadIntervalTimeout;
    public UInt32 ReadTotalTimeoutMultiplier;
    public UInt32 ReadTotalTimeoutConstant;
    public UInt32 WriteTotalTimeoutMultiplier;
    public UInt32 WriteTotalTimeoutConstant;
    public static UInt32 MaxDWord;
    public Timeouts(int read_timeout, int write_timeout);
    public void SetValues(int read_timeout, int write_timeout);
}
internal class System.IO.Ports.WinSerialStream : Stream {
    private static UInt32 GenericRead;
    private static UInt32 GenericWrite;
    private static UInt32 OpenExisting;
    private static UInt32 FileFlagOverlapped;
    private static UInt32 PurgeRxClear;
    private static UInt32 PurgeTxClear;
    private static UInt32 WinInfiniteTimeout;
    private static UInt32 FileIOPending;
    private static UInt32 SetRts;
    private static UInt32 ClearRts;
    private static UInt32 SetDtr;
    private static UInt32 ClearDtr;
    private static UInt32 SetBreak;
    private static UInt32 ClearBreak;
    private static UInt32 CtsOn;
    private static UInt32 DsrOn;
    private static UInt32 RsldOn;
    private static UInt32 EvRxChar;
    private static UInt32 EvCts;
    private static UInt32 EvDsr;
    private static UInt32 EvRlsd;
    private static UInt32 EvBreak;
    private static UInt32 EvErr;
    private static UInt32 EvRing;
    private int handle;
    private int read_timeout;
    private int write_timeout;
    private bool disposed;
    private IntPtr write_overlapped;
    private IntPtr read_overlapped;
    private ManualResetEvent read_event;
    private ManualResetEvent write_event;
    private Timeouts timeouts;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public int BytesToRead { get; }
    public int BytesToWrite { get; }
    public WinSerialStream(string port_name, int baud_rate, int data_bits, Parity parity, StopBits sb, bool dtr_enable, bool rts_enable, Handshake hs, int read_timeout, int write_timeout, int read_buffer_size, int write_buffer_size);
    private static int CreateFile(string port_name, UInt32 desired_access, UInt32 share_mode, UInt32 security_attrs, UInt32 creation, UInt32 flags, UInt32 template);
    private static bool SetupComm(int handle, int read_buffer_size, int write_buffer_size);
    private static bool PurgeComm(int handle, UInt32 flags);
    private static bool SetCommTimeouts(int handle, Timeouts timeouts);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private static bool CloseHandle(int handle);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual void Close();
    protected virtual override void Finalize();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private static bool ReadFile(int handle, Byte* buffer, int bytes_to_read, Int32& bytes_read, IntPtr overlapped);
    private static bool GetOverlappedResult(int handle, IntPtr overlapped, Int32& bytes_transfered, bool wait);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private static bool WriteFile(int handle, Byte* buffer, int bytes_to_write, Int32& bytes_written, IntPtr overlapped);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private static bool GetCommState(int handle, DCB dcb);
    private static bool SetCommState(int handle, DCB dcb);
    public sealed virtual void SetAttributes(int baud_rate, Parity parity, int data_bits, StopBits bits, Handshake hs);
    private void ReportIOError(string optional_arg);
    private void CheckDisposed();
    public sealed virtual void DiscardInBuffer();
    public sealed virtual void DiscardOutBuffer();
    private static bool ClearCommError(int handle, UInt32& errors, CommStat& stat);
    public sealed virtual int get_BytesToRead();
    public sealed virtual int get_BytesToWrite();
    private static bool GetCommModemStatus(int handle, UInt32& flags);
    public sealed virtual SerialSignal GetSignals();
    private static bool EscapeCommFunction(int handle, UInt32 flags);
    public sealed virtual void SetSignal(SerialSignal signal, bool value);
    public sealed virtual void SetBreakState(bool value);
}
internal class System.IO.ReadOnlyMemoryStream : Stream {
    private ReadOnlyMemory`1<byte> _content;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyMemoryStream(ReadOnlyMemory`1<byte> content);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private static void ValidateReadArrayArguments(Byte[] buffer, int offset, int count);
}
public class System.IO.RenamedEventArgs : FileSystemEventArgs {
    private string _oldName;
    private string _oldFullPath;
    public string OldFullPath { get; }
    public string OldName { get; }
    public RenamedEventArgs(WatcherChangeTypes changeType, string directory, string name, string oldName);
    public string get_OldFullPath();
    public string get_OldName();
}
public class System.IO.RenamedEventHandler : MulticastDelegate {
    public RenamedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RenamedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RenamedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.IO.SearchPattern2 : object {
    private Op ops;
    private bool ignore;
    private bool hasWildcard;
    private string pattern;
    internal static Char[] WildcardChars;
    internal static Char[] InvalidChars;
    public bool HasWildcard { get; }
    public SearchPattern2(string pattern);
    public SearchPattern2(string pattern, bool ignore);
    private static SearchPattern2();
    public bool IsMatch(string text, bool ignorecase);
    public bool IsMatch(string text);
    public bool get_HasWildcard();
    private void Compile(string pattern);
    private bool Match(Op op, string text, int ptr);
}
internal class System.IO.timespec : ValueType {
    public IntPtr tv_sec;
    public IntPtr tv_nsec;
}
public class System.IO.WaitForChangedResult : ValueType {
    internal static WaitForChangedResult TimedOutResult;
    [CompilerGeneratedAttribute]
private WatcherChangeTypes <ChangeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TimedOut>k__BackingField;
    public WatcherChangeTypes ChangeType { get; public set; }
    public string Name { get; public set; }
    public string OldName { get; public set; }
    public bool TimedOut { get; public set; }
    internal WaitForChangedResult(WatcherChangeTypes changeType, string name, string oldName, bool timedOut);
    private static WaitForChangedResult();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public WatcherChangeTypes get_ChangeType();
    [CompilerGeneratedAttribute]
public void set_ChangeType(WatcherChangeTypes value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public string get_OldName();
    [CompilerGeneratedAttribute]
public void set_OldName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_TimedOut();
    [CompilerGeneratedAttribute]
public void set_TimedOut(bool value);
}
[FlagsAttribute]
public enum System.IO.WatcherChangeTypes : Enum {
    public int value__;
    public static WatcherChangeTypes All;
    public static WatcherChangeTypes Changed;
    public static WatcherChangeTypes Created;
    public static WatcherChangeTypes Deleted;
    public static WatcherChangeTypes Renamed;
}
internal class System.IOAsyncCallback : MulticastDelegate {
    public IOAsyncCallback(object object, IntPtr method);
    public virtual void Invoke(IOAsyncResult ioares);
    public virtual IAsyncResult BeginInvoke(IOAsyncResult ioares, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class System.IOAsyncResult : object {
    private AsyncCallback async_callback;
    private object async_state;
    private ManualResetEvent wait_handle;
    private bool completed_synchronously;
    private bool completed;
    public AsyncCallback AsyncCallback { get; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; protected set; }
    public bool IsCompleted { get; protected set; }
    protected IOAsyncResult(AsyncCallback async_callback, object async_state);
    protected void Init(AsyncCallback async_callback, object async_state);
    public AsyncCallback get_AsyncCallback();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    protected void set_CompletedSynchronously(bool value);
    public sealed virtual bool get_IsCompleted();
    protected void set_IsCompleted(bool value);
    internal abstract virtual void CompleteDisposed();
}
internal enum System.IOOperation : Enum {
    public int value__;
    public static IOOperation Read;
    public static IOOperation Write;
}
internal static class System.IOSelector : object {
    public static void Add(IntPtr handle, IOSelectorJob job);
    public static void Remove(IntPtr handle);
}
internal class System.IOSelectorJob : object {
    private IOOperation operation;
    private IOAsyncCallback callback;
    private IOAsyncResult state;
    public IOSelectorJob(IOOperation operation, IOAsyncCallback callback, IOAsyncResult state);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    public void MarkDisposed();
}
internal static class System.IPv4AddressHelper : object {
    internal static long Invalid;
    private static long MaxIPv4Value;
    private static int Octal;
    private static int Decimal;
    private static int Hex;
    private static int NumberOfLabels;
    internal static int ParseHostNumber(ReadOnlySpan`1<char> str, int start, int end);
    internal static bool IsValid(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile, bool unknownScheme);
    private static bool ParseCanonical(ReadOnlySpan`1<char> name, Byte* numbers, int start, int end);
    internal static bool IsValidCanonical(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile);
    internal static long ParseNonCanonical(Char* name, int start, Int32& end, bool notImplicitFile);
    internal static string ParseCanonicalName(string str, int start, int end, Boolean& isLoopback);
    private static bool Parse(string name, Byte* numbers, int start, int end);
}
internal static class System.IPv6AddressHelper : object {
    private static int NumberOfLabels;
    internal static ValueTuple`2<int, int> FindCompressionRange(ReadOnlySpan`1<ushort> numbers);
    internal static bool ShouldHaveIpv4Embedded(ReadOnlySpan`1<ushort> numbers);
    internal static bool IsValidStrict(Char* name, int start, Int32& end);
    internal static void Parse(ReadOnlySpan`1<char> address, UInt16* numbers, int start, String& scopeId);
    internal static string ParseCanonicalName(string str, int start, Boolean& isLoopback, String& scopeId);
    private static bool IsLoopback(ReadOnlySpan`1<ushort> numbers);
    private static bool ShouldHaveIpv4Embedded(UInt16* numbers);
    private static bool InternalIsValid(Char* name, int start, Int32& end, bool validateStrictAddress);
    internal static bool IsValid(Char* name, int start, Int32& end);
}
internal static class System.IriHelper : object {
    internal static bool CheckIriUnicodeRange(char unicode, bool isQuery);
    internal static bool CheckIriUnicodeRange(char highSurr, char lowSurr, Boolean& surrogatePair, bool isQuery);
    internal static bool CheckIsReserved(char ch, UriComponents component);
    internal static string EscapeUnescapeIri(Char* pInput, int start, int end, UriComponents component);
}
public class System.LdapStyleUriParser : UriParser {
}
internal static class System.LocalAppContextSwitches : object {
    public static bool MemberDescriptorEqualsReturnsFalseIfEquivalent;
}
[ToolboxItemAttribute("False")]
public class System.Media.SoundPlayer : Component {
    private string sound_location;
    private Stream audiostream;
    private object tag;
    private MemoryStream mstream;
    private bool load_completed;
    private int load_timeout;
    private AudioDevice adev;
    private AudioData adata;
    private bool stopped;
    private Win32SoundPlayer win32_player;
    private static bool use_win32_player;
    [CompilerGeneratedAttribute]
private AsyncCompletedEventHandler LoadCompleted;
    [CompilerGeneratedAttribute]
private EventHandler SoundLocationChanged;
    [CompilerGeneratedAttribute]
private EventHandler StreamChanged;
    public bool IsLoadCompleted { get; }
    public int LoadTimeout { get; public set; }
    public string SoundLocation { get; public set; }
    public Stream Stream { get; public set; }
    public object Tag { get; public set; }
    private static SoundPlayer();
    public SoundPlayer(Stream stream);
    public SoundPlayer(string soundLocation);
    protected SoundPlayer(SerializationInfo serializationInfo, StreamingContext context);
    private void LoadFromStream(Stream s);
    private void LoadFromUri(string location);
    public void Load();
    private void AsyncFinished(IAsyncResult ar);
    public void LoadAsync();
    protected virtual void OnLoadCompleted(AsyncCompletedEventArgs e);
    protected virtual void OnSoundLocationChanged(EventArgs e);
    protected virtual void OnStreamChanged(EventArgs e);
    private void Start();
    public void Play();
    private void PlayLoop();
    public void PlayLooping();
    public void PlaySync();
    public void Stop();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public bool get_IsLoadCompleted();
    public int get_LoadTimeout();
    public void set_LoadTimeout(int value);
    public string get_SoundLocation();
    public void set_SoundLocation(string value);
    public Stream get_Stream();
    public void set_Stream(Stream value);
    public object get_Tag();
    public void set_Tag(object value);
    [CompilerGeneratedAttribute]
public void add_LoadCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LoadCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_SoundLocationChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SoundLocationChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StreamChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamChanged(EventHandler value);
}
public class System.Media.SystemSound : object {
    private Stream resource;
    internal SystemSound(string tag);
    public void Play();
}
public class System.Media.SystemSounds : object {
    public static SystemSound Asterisk { get; }
    public static SystemSound Beep { get; }
    public static SystemSound Exclamation { get; }
    public static SystemSound Hand { get; }
    public static SystemSound Question { get; }
    public static SystemSound get_Asterisk();
    public static SystemSound get_Beep();
    public static SystemSound get_Exclamation();
    public static SystemSound get_Hand();
    public static SystemSound get_Question();
}
internal static class System.MonoToolsLocator : object {
    public static string Mono;
    public static string McsCSharpCompiler;
    public static string VBCompiler;
    public static string AssemblyLinker;
    private static MonoToolsLocator();
    private static UInt32 GetModuleFileName(IntPtr hModule, StringBuilder lpFilename, int nSize);
}
public class System.Net.AuthenticationManager : object {
    private static ArrayList modules;
    private static object locker;
    private static ICredentialPolicy credential_policy;
    public static ICredentialPolicy CredentialPolicy { get; public set; }
    [MonoTODOAttribute]
public static StringDictionary CustomTargetNameDictionary { get; }
    public static IEnumerator RegisteredModules { get; }
    [MonoTODOAttribute]
internal static bool OSSupportsExtendedProtection { get; }
    private static AuthenticationManager();
    private static void EnsureModules();
    public static ICredentialPolicy get_CredentialPolicy();
    public static void set_CredentialPolicy(ICredentialPolicy value);
    private static Exception GetMustImplement();
    public static StringDictionary get_CustomTargetNameDictionary();
    public static IEnumerator get_RegisteredModules();
    internal static bool get_OSSupportsExtendedProtection();
    internal static void Clear();
    public static Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    private static Authorization DoAuthenticate(string challenge, WebRequest request, ICredentials credentials);
    public static Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public static void Register(IAuthenticationModule authenticationModule);
    public static void Unregister(IAuthenticationModule authenticationModule);
    public static void Unregister(string authenticationScheme);
    private static void DoUnregister(string authenticationScheme, bool throwEx);
}
[FlagsAttribute]
public enum System.Net.AuthenticationSchemes : Enum {
    public int value__;
    public static AuthenticationSchemes None;
    public static AuthenticationSchemes Digest;
    public static AuthenticationSchemes Negotiate;
    public static AuthenticationSchemes Ntlm;
    public static AuthenticationSchemes Basic;
    public static AuthenticationSchemes Anonymous;
    public static AuthenticationSchemes IntegratedWindowsAuthentication;
}
public class System.Net.AuthenticationSchemeSelector : MulticastDelegate {
    public AuthenticationSchemeSelector(object object, IntPtr method);
    public virtual AuthenticationSchemes Invoke(HttpListenerRequest httpRequest);
    public virtual IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object);
    public virtual AuthenticationSchemes EndInvoke(IAsyncResult result);
}
public class System.Net.Authorization : object {
    private string m_Message;
    private bool m_Complete;
    private String[] m_ProtectionRealm;
    private string m_ConnectionGroupId;
    private bool m_MutualAuth;
    internal string ModuleAuthenticationType;
    public string Message { get; }
    public string ConnectionGroupId { get; }
    public bool Complete { get; }
    public String[] ProtectionRealm { get; public set; }
    public bool MutuallyAuthenticated { get; public set; }
    public Authorization(string token);
    public Authorization(string token, bool finished);
    public Authorization(string token, bool finished, string connectionGroupId);
    internal Authorization(string token, bool finished, string connectionGroupId, bool mutualAuth);
    public string get_Message();
    public string get_ConnectionGroupId();
    public bool get_Complete();
    internal void SetComplete(bool complete);
    public String[] get_ProtectionRealm();
    public void set_ProtectionRealm(String[] value);
    public bool get_MutuallyAuthenticated();
    public void set_MutuallyAuthenticated(bool value);
}
internal class System.Net.AutoWebProxyScriptEngine : object {
    [CompilerGeneratedAttribute]
private Uri <AutomaticConfigurationScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutomaticallyDetectSettings>k__BackingField;
    public Uri AutomaticConfigurationScript { get; public set; }
    public bool AutomaticallyDetectSettings { get; public set; }
    public AutoWebProxyScriptEngine(WebProxy proxy, bool useRegistry);
    [CompilerGeneratedAttribute]
public Uri get_AutomaticConfigurationScript();
    [CompilerGeneratedAttribute]
public void set_AutomaticConfigurationScript(Uri value);
    [CompilerGeneratedAttribute]
public bool get_AutomaticallyDetectSettings();
    [CompilerGeneratedAttribute]
public void set_AutomaticallyDetectSettings(bool value);
    public bool GetProxies(Uri destination, IList`1& proxyList);
    public bool GetProxies(Uri destination, IList`1& proxyList, Int32& syncStatus);
    public void Close();
    public void Abort(Int32& syncStatus);
    public void CheckForChanges();
    public WebProxyData GetWebProxyData();
    private WebProxyData ReadEnvVariables();
    private static bool IsWindows();
    private WebProxyData InitializeRegistryGlobalProxy();
    private static Uri ToUri(string address);
    private static ArrayList CreateBypassList(ArrayList al);
}
internal class System.Net.Base64Stream : DelegatedStream {
    private static Byte[] s_base64DecodeMap;
    private static Byte[] s_base64EncodeMap;
    private int _lineLength;
    private Base64WriteStateInfo _writeState;
    private ReadStateInfo _readState;
    private static int SizeOfBase64EncodedChar;
    private static byte InvalidBase64Value;
    private ReadStateInfo ReadState { get; }
    internal Base64WriteStateInfo WriteState { get; }
    internal Base64Stream(Stream stream, Base64WriteStateInfo writeStateInfo);
    internal Base64Stream(Base64WriteStateInfo writeStateInfo);
    private static Base64Stream();
    private ReadStateInfo get_ReadState();
    internal Base64WriteStateInfo get_WriteState();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    internal int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF);
    public sealed virtual Stream GetStream();
    public sealed virtual string GetEncodedString();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    private void FlushInternal();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Net.BaseLoggingObject : object {
    internal virtual void EnterFunc(string funcname);
    internal virtual void LeaveFunc(string funcname);
    internal virtual void DumpArrayToConsole();
    internal virtual void PrintLine(string msg);
    internal virtual void DumpArray(bool shouldClose);
    internal virtual void DumpArrayToFile(bool shouldClose);
    internal virtual void Flush();
    internal virtual void Flush(bool close);
    internal virtual void LoggingMonitorTick();
    internal virtual void Dump(Byte[] buffer);
    internal virtual void Dump(Byte[] buffer, int length);
    internal virtual void Dump(Byte[] buffer, int offset, int length);
    internal virtual void Dump(IntPtr pBuffer, int offset, int length);
}
internal class System.Net.BasicClient : object {
    public string AuthenticationType { get; }
    public bool CanPreAuthenticate { get; }
    public sealed virtual Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
    private static Byte[] GetBytes(string str);
    private static Authorization InternalAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool get_CanPreAuthenticate();
}
public class System.Net.BindIPEndPoint : MulticastDelegate {
    public BindIPEndPoint(object object, IntPtr method);
    public virtual IPEndPoint Invoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount);
    public virtual IAsyncResult BeginInvoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount, AsyncCallback callback, object object);
    public virtual IPEndPoint EndInvoke(IAsyncResult result);
}
internal class System.Net.Blob : ValueType {
    public int cbSize;
    public int pBlobData;
}
internal class System.Net.BufferedReadStream : WebReadStream {
    private BufferOffsetSize readBuffer;
    public BufferedReadStream(WebOperation operation, Stream innerStream, BufferOffsetSize readBuffer);
    [AsyncStateMachineAttribute("System.Net.BufferedReadStream/<ProcessReadAsync>d__2")]
protected virtual Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    internal bool TryReadFromBuffer(Byte[] buffer, int offset, int size, Int32& result);
}
internal class System.Net.BufferOffsetSize : object {
    internal Byte[] Buffer;
    internal int Offset;
    internal int Size;
    internal BufferOffsetSize(Byte[] buffer, int offset, int size, bool copyBuffer);
    internal BufferOffsetSize(Byte[] buffer, bool copyBuffer);
}
internal enum System.Net.BufferType : Enum {
    public int value__;
    public static BufferType Empty;
    public static BufferType Data;
    public static BufferType Token;
    public static BufferType Parameters;
    public static BufferType Missing;
    public static BufferType Extra;
    public static BufferType Trailer;
    public static BufferType Header;
    public static BufferType Padding;
    public static BufferType Stream;
    public static BufferType ChannelBindings;
    public static BufferType TargetHost;
    public static BufferType ReadOnlyFlag;
    public static BufferType ReadOnlyWithChecksum;
}
public enum System.Net.Cache.HttpCacheAgeControl : Enum {
    public int value__;
    public static HttpCacheAgeControl None;
    public static HttpCacheAgeControl MinFresh;
    public static HttpCacheAgeControl MaxAge;
    public static HttpCacheAgeControl MaxStale;
    public static HttpCacheAgeControl MaxAgeAndMinFresh;
    public static HttpCacheAgeControl MaxAgeAndMaxStale;
}
public enum System.Net.Cache.HttpRequestCacheLevel : Enum {
    public int value__;
    public static HttpRequestCacheLevel Default;
    public static HttpRequestCacheLevel BypassCache;
    public static HttpRequestCacheLevel CacheOnly;
    public static HttpRequestCacheLevel CacheIfAvailable;
    public static HttpRequestCacheLevel Revalidate;
    public static HttpRequestCacheLevel Reload;
    public static HttpRequestCacheLevel NoCacheNoStore;
    public static HttpRequestCacheLevel CacheOrNextCacheOnly;
    public static HttpRequestCacheLevel Refresh;
}
public class System.Net.Cache.HttpRequestCachePolicy : RequestCachePolicy {
    internal static HttpRequestCachePolicy BypassCache;
    private HttpRequestCacheLevel m_Level;
    private DateTime m_LastSyncDateUtc;
    private TimeSpan m_MaxAge;
    private TimeSpan m_MinFresh;
    private TimeSpan m_MaxStale;
    public HttpRequestCacheLevel Level { get; }
    public DateTime CacheSyncDate { get; }
    internal DateTime InternalCacheSyncDateUtc { get; }
    public TimeSpan MaxAge { get; }
    public TimeSpan MinFresh { get; }
    public TimeSpan MaxStale { get; }
    public HttpRequestCachePolicy(HttpRequestCacheLevel level);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan ageOrFreshOrStale);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale);
    public HttpRequestCachePolicy(DateTime cacheSyncDate);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale, DateTime cacheSyncDate);
    private static HttpRequestCachePolicy();
    public HttpRequestCacheLevel get_Level();
    public DateTime get_CacheSyncDate();
    internal DateTime get_InternalCacheSyncDateUtc();
    public TimeSpan get_MaxAge();
    public TimeSpan get_MinFresh();
    public TimeSpan get_MaxStale();
    public virtual string ToString();
    private static RequestCacheLevel MapLevel(HttpRequestCacheLevel level);
}
internal abstract class System.Net.Cache.RequestCache : object {
    internal static Char[] LineSplits;
    private bool _IsPrivateCache;
    private bool _CanWrite;
    internal bool IsPrivateCache { get; }
    internal bool CanWrite { get; }
    protected RequestCache(bool isPrivateCache, bool canWrite);
    private static RequestCache();
    internal bool get_IsPrivateCache();
    internal bool get_CanWrite();
    internal abstract virtual Stream Retrieve(string key, RequestCacheEntry& cacheEntry);
    internal abstract virtual Stream Store(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal abstract virtual void Remove(string key);
    internal abstract virtual void Update(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal abstract virtual bool TryRetrieve(string key, RequestCacheEntry& cacheEntry, Stream& readStream);
    internal abstract virtual bool TryStore(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata, Stream& writeStream);
    internal abstract virtual bool TryRemove(string key);
    internal abstract virtual bool TryUpdate(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal abstract virtual void UnlockEntry(Stream retrieveStream);
}
internal class System.Net.Cache.RequestCacheBinding : object {
    private RequestCache m_RequestCache;
    private RequestCacheValidator m_CacheValidator;
    private RequestCachePolicy m_Policy;
    internal RequestCache Cache { get; }
    internal RequestCacheValidator Validator { get; }
    internal RequestCachePolicy Policy { get; }
    internal RequestCacheBinding(RequestCache requestCache, RequestCacheValidator cacheValidator, RequestCachePolicy policy);
    internal RequestCache get_Cache();
    internal RequestCacheValidator get_Validator();
    internal RequestCachePolicy get_Policy();
}
internal class System.Net.Cache.RequestCacheEntry : object {
    private bool m_IsPrivateEntry;
    private long m_StreamSize;
    private DateTime m_ExpiresUtc;
    private int m_HitCount;
    private DateTime m_LastAccessedUtc;
    private DateTime m_LastModifiedUtc;
    private DateTime m_LastSynchronizedUtc;
    private TimeSpan m_MaxStale;
    private int m_UsageCount;
    private bool m_IsPartialEntry;
    private StringCollection m_EntryMetadata;
    private StringCollection m_SystemMetadata;
    internal bool IsPrivateEntry { get; internal set; }
    internal long StreamSize { get; internal set; }
    internal DateTime ExpiresUtc { get; internal set; }
    internal DateTime LastAccessedUtc { get; internal set; }
    internal DateTime LastModifiedUtc { get; internal set; }
    internal DateTime LastSynchronizedUtc { get; internal set; }
    internal TimeSpan MaxStale { get; internal set; }
    internal int HitCount { get; internal set; }
    internal int UsageCount { get; internal set; }
    internal bool IsPartialEntry { get; internal set; }
    internal StringCollection EntryMetadata { get; internal set; }
    internal StringCollection SystemMetadata { get; internal set; }
    internal bool get_IsPrivateEntry();
    internal void set_IsPrivateEntry(bool value);
    internal long get_StreamSize();
    internal void set_StreamSize(long value);
    internal DateTime get_ExpiresUtc();
    internal void set_ExpiresUtc(DateTime value);
    internal DateTime get_LastAccessedUtc();
    internal void set_LastAccessedUtc(DateTime value);
    internal DateTime get_LastModifiedUtc();
    internal void set_LastModifiedUtc(DateTime value);
    internal DateTime get_LastSynchronizedUtc();
    internal void set_LastSynchronizedUtc(DateTime value);
    internal TimeSpan get_MaxStale();
    internal void set_MaxStale(TimeSpan value);
    internal int get_HitCount();
    internal void set_HitCount(int value);
    internal int get_UsageCount();
    internal void set_UsageCount(int value);
    internal bool get_IsPartialEntry();
    internal void set_IsPartialEntry(bool value);
    internal StringCollection get_EntryMetadata();
    internal void set_EntryMetadata(StringCollection value);
    internal StringCollection get_SystemMetadata();
    internal void set_SystemMetadata(StringCollection value);
    internal virtual string ToString(bool verbose);
}
public enum System.Net.Cache.RequestCacheLevel : Enum {
    public int value__;
    public static RequestCacheLevel Default;
    public static RequestCacheLevel BypassCache;
    public static RequestCacheLevel CacheOnly;
    public static RequestCacheLevel CacheIfAvailable;
    public static RequestCacheLevel Revalidate;
    public static RequestCacheLevel Reload;
    public static RequestCacheLevel NoCacheNoStore;
}
internal class System.Net.Cache.RequestCacheManager : object {
    private static RequestCachingSectionInternal modreq(System.Runtime.CompilerServices.IsVolatile) s_CacheConfigSettings;
    private static RequestCacheBinding s_BypassCacheBinding;
    private static RequestCacheBinding modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultGlobalBinding;
    private static RequestCacheBinding modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultHttpBinding;
    private static RequestCacheBinding modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultFtpBinding;
    internal static bool IsCachingEnabled { get; }
    private static RequestCacheManager();
    internal static RequestCacheBinding GetBinding(string internedScheme);
    internal static bool get_IsCachingEnabled();
    internal static void SetBinding(string uriScheme, RequestCacheBinding binding);
    private static void LoadConfigSettings();
}
public class System.Net.Cache.RequestCachePolicy : object {
    private RequestCacheLevel m_Level;
    public RequestCacheLevel Level { get; }
    public RequestCachePolicy(RequestCacheLevel level);
    public RequestCacheLevel get_Level();
    public virtual string ToString();
}
internal class System.Net.Cache.RequestCacheProtocol : object {
    public RequestCacheProtocol(object arg1, object arg2);
}
internal class System.Net.Cache.RequestCacheValidator : object {
    public object CreateValidator();
}
internal class System.Net.Cache.RequestCachingSectionInternal : object {
    public bool DisableAllCaching;
}
internal class System.Net.CachedTransportContext : TransportContext {
    private ChannelBinding binding;
    internal CachedTransportContext(ChannelBinding binding);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal class System.Net.CallbackClosure : object {
    private AsyncCallback _savedCallback;
    private ExecutionContext _savedContext;
    internal AsyncCallback AsyncCallback { get; }
    internal ExecutionContext Context { get; }
    internal CallbackClosure(ExecutionContext context, AsyncCallback callback);
    internal bool IsCompatible(AsyncCallback callback);
    internal AsyncCallback get_AsyncCallback();
    internal ExecutionContext get_Context();
}
internal class System.Net.CaseInsensitiveAscii : object {
    internal static CaseInsensitiveAscii StaticInstance;
    internal static Byte[] AsciiToLower;
    private static CaseInsensitiveAscii();
    public sealed virtual int GetHashCode(object myObject);
    public sealed virtual int Compare(object firstObject, object secondObject);
    private int FastGetHashCode(string myString);
    public sealed virtual bool Equals(object firstObject, object secondObject);
}
internal enum System.Net.CertificateEncoding : Enum {
    public int value__;
    public static CertificateEncoding Zero;
    public static CertificateEncoding X509AsnEncoding;
    public static CertificateEncoding X509NdrEncoding;
    public static CertificateEncoding Pkcs7AsnEncoding;
    public static CertificateEncoding Pkcs7NdrEncoding;
    public static CertificateEncoding AnyAsnEncoding;
}
internal enum System.Net.CertificateProblem : Enum {
    public int value__;
    public static CertificateProblem OK;
    public static CertificateProblem TrustNOSIGNATURE;
    public static CertificateProblem CertEXPIRED;
    public static CertificateProblem CertVALIDITYPERIODNESTING;
    public static CertificateProblem CertROLE;
    public static CertificateProblem CertPATHLENCONST;
    public static CertificateProblem CertCRITICAL;
    public static CertificateProblem CertPURPOSE;
    public static CertificateProblem CertISSUERCHAINING;
    public static CertificateProblem CertMALFORMED;
    public static CertificateProblem CertUNTRUSTEDROOT;
    public static CertificateProblem CertCHAINING;
    public static CertificateProblem CertREVOKED;
    public static CertificateProblem CertUNTRUSTEDTESTROOT;
    public static CertificateProblem CertREVOCATION_FAILURE;
    public static CertificateProblem CertCN_NO_MATCH;
    public static CertificateProblem CertWRONG_USAGE;
    public static CertificateProblem TrustEXPLICITDISTRUST;
    public static CertificateProblem CertUNTRUSTEDCA;
    public static CertificateProblem CertINVALIDPOLICY;
    public static CertificateProblem CertINVALIDNAME;
    public static CertificateProblem CryptNOREVOCATIONCHECK;
    public static CertificateProblem CryptREVOCATIONOFFLINE;
    public static CertificateProblem TrustSYSTEMERROR;
    public static CertificateProblem TrustNOSIGNERCERT;
    public static CertificateProblem TrustCOUNTERSIGNER;
    public static CertificateProblem TrustCERTSIGNATURE;
    public static CertificateProblem TrustTIMESTAMP;
    public static CertificateProblem TrustBADDIGEST;
    public static CertificateProblem TrustBASICCONSTRAINTS;
    public static CertificateProblem TrustFINANCIALCRITERIA;
}
internal enum System.Net.CertUsage : Enum {
    public int value__;
    public static CertUsage MatchTypeAnd;
    public static CertUsage MatchTypeOr;
}
internal enum System.Net.ChainPolicyType : Enum {
    public int value__;
    public static ChainPolicyType Base;
    public static ChainPolicyType Authenticode;
    public static ChainPolicyType Authenticode_TS;
    public static ChainPolicyType SSL;
    public static ChainPolicyType BasicConstraints;
    public static ChainPolicyType NtAuth;
}
internal class System.Net.ChunkedInputStream : RequestStream {
    private bool disposed;
    private MonoChunkParser decoder;
    private HttpListenerContext context;
    private bool no_more_data;
    public MonoChunkParser Decoder { get; public set; }
    public ChunkedInputStream(HttpListenerContext context, Stream stream, Byte[] buffer, int offset, int length);
    public MonoChunkParser get_Decoder();
    public void set_Decoder(MonoChunkParser value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state);
    private void OnRead(IAsyncResult base_ares);
    public virtual int EndRead(IAsyncResult ares);
    public virtual void Close();
}
internal class System.Net.ClosableStream : DelegatedStream {
    private EventHandler _onClose;
    private int _closed;
    internal ClosableStream(Stream stream, EventHandler onClose);
    public virtual void Close();
}
[FlagsAttribute]
internal enum System.Net.CloseExState : Enum {
    public int value__;
    public static CloseExState Normal;
    public static CloseExState Abort;
    public static CloseExState Silent;
}
internal class System.Net.CommandStream : NetworkStreamWrapper {
    private static AsyncCallback s_writeCallbackDelegate;
    private static AsyncCallback s_readCallbackDelegate;
    private bool _recoverableFailure;
    protected WebRequest _request;
    protected bool _isAsync;
    private bool _aborted;
    protected PipelineEntry[] _commands;
    protected int _index;
    private bool _doRead;
    private bool _doSend;
    private ResponseDescription _currentResponseDescription;
    protected string _abortReason;
    private static int WaitingForPipeline;
    private static int CompletedPipeline;
    private string _buffer;
    private Encoding _encoding;
    private Decoder _decoder;
    internal bool RecoverableFailure { get; }
    protected Encoding Encoding { get; protected set; }
    internal CommandStream(TcpClient client);
    private static CommandStream();
    internal virtual void Abort(Exception e);
    protected virtual void Dispose(bool disposing);
    protected void InvokeRequestCallback(object obj);
    internal bool get_RecoverableFailure();
    protected void MarkAsRecoverableFailure();
    internal Stream SubmitRequest(WebRequest request, bool isAsync, bool readInitalResponseOnConnect);
    protected virtual void ClearState();
    protected virtual PipelineEntry[] BuildCommandsList(WebRequest request);
    protected Exception GenerateException(string message, WebExceptionStatus status, Exception innerException);
    protected Exception GenerateException(FtpStatusCode code, string statusDescription, Exception innerException);
    protected void InitCommandPipeline(WebRequest request, PipelineEntry[] commands, bool isAsync);
    internal void CheckContinuePipeline();
    protected Stream ContinueCommandPipeline();
    private bool PostSendCommandProcessing(Stream& stream);
    private bool PostReadCommandProcessing(Stream& stream);
    protected virtual PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream);
    private static void ReadCallback(IAsyncResult asyncResult);
    private static void WriteCallback(IAsyncResult asyncResult);
    protected Encoding get_Encoding();
    protected void set_Encoding(Encoding value);
    protected virtual bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength);
    private ResponseDescription ReceiveCommandResponse();
    private void ReceiveCommandResponseCallback(ReceiveState state, int bytesRead);
}
internal class System.Net.Comparer : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object ol, object or);
}
public class System.Net.Configuration.AuthenticationModuleElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty typeProp;
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("type")]
public string Type { get; public set; }
    private static AuthenticationModuleElement();
    public AuthenticationModuleElement(string typeName);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Type();
    public void set_Type(string value);
}
[ConfigurationCollectionAttribute("System.Net.Configuration.AuthenticationModuleElement")]
[DefaultMemberAttribute("Item")]
public class System.Net.Configuration.AuthenticationModuleElementCollection : ConfigurationElementCollection {
    [MonoTODOAttribute]
public AuthenticationModuleElement Item { get; public set; }
    [MonoTODOAttribute]
public AuthenticationModuleElement Item { get; public set; }
    public AuthenticationModuleElement get_Item(int index);
    public void set_Item(int index, AuthenticationModuleElement value);
    public AuthenticationModuleElement get_Item(string name);
    public void set_Item(string name, AuthenticationModuleElement value);
    public void Add(AuthenticationModuleElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    [MonoTODOAttribute("argument exception?")]
protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(AuthenticationModuleElement element);
    public void Remove(AuthenticationModuleElement element);
    public void Remove(string name);
    public void RemoveAt(int index);
}
public class System.Net.Configuration.AuthenticationModulesSection : ConfigurationSection {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty authenticationModulesProp;
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public AuthenticationModuleElementCollection AuthenticationModules { get; }
    private static AuthenticationModulesSection();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public AuthenticationModuleElementCollection get_AuthenticationModules();
    [MonoTODOAttribute]
protected virtual void PostDeserialize();
    [MonoTODOAttribute]
protected virtual void InitializeDefault();
}
public class System.Net.Configuration.BypassElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty addressProp;
    [ConfigurationPropertyAttribute("address")]
public string Address { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static BypassElement();
    public BypassElement(string address);
    public string get_Address();
    public void set_Address(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.Net.Configuration.BypassElement")]
[DefaultMemberAttribute("Item")]
public class System.Net.Configuration.BypassElementCollection : ConfigurationElementCollection {
    [MonoTODOAttribute]
public BypassElement Item { get; public set; }
    public BypassElement Item { get; public set; }
    protected bool ThrowOnDuplicate { get; }
    public BypassElement get_Item(int index);
    public void set_Item(int index, BypassElement value);
    public BypassElement get_Item(string name);
    public void set_Item(string name, BypassElement value);
    protected virtual bool get_ThrowOnDuplicate();
    public void Add(BypassElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    [MonoTODOAttribute("argument exception?")]
protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(BypassElement element);
    public void Remove(BypassElement element);
    public void Remove(string name);
    public void RemoveAt(int index);
}
internal class System.Net.Configuration.ConnectionManagementData : object {
    private Hashtable data;
    private static int defaultMaxConnections;
    public Hashtable Data { get; }
    public ConnectionManagementData(object parent);
    public void Add(string address, string nconns);
    public void Add(string address, int nconns);
    public void Remove(string address);
    public void Clear();
    public UInt32 GetMaxConnections(string hostOrIP);
    public Hashtable get_Data();
}
public class System.Net.Configuration.ConnectionManagementElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty addressProp;
    private static ConfigurationProperty maxConnectionProp;
    [ConfigurationPropertyAttribute("address")]
public string Address { get; public set; }
    [ConfigurationPropertyAttribute("maxconnection")]
public int MaxConnection { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static ConnectionManagementElement();
    public ConnectionManagementElement(string address, int maxConnection);
    public string get_Address();
    public void set_Address(string value);
    public int get_MaxConnection();
    public void set_MaxConnection(int value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.Net.Configuration.ConnectionManagementElement")]
[DefaultMemberAttribute("Item")]
public class System.Net.Configuration.ConnectionManagementElementCollection : ConfigurationElementCollection {
    [MonoTODOAttribute]
public ConnectionManagementElement Item { get; public set; }
    public ConnectionManagementElement Item { get; public set; }
    public ConnectionManagementElement get_Item(int index);
    public void set_Item(int index, ConnectionManagementElement value);
    public ConnectionManagementElement get_Item(string name);
    public void set_Item(string name, ConnectionManagementElement value);
    public void Add(ConnectionManagementElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(ConnectionManagementElement element);
    public void Remove(ConnectionManagementElement element);
    public void Remove(string name);
    public void RemoveAt(int index);
}
internal class System.Net.Configuration.ConnectionManagementHandler : object {
    public virtual object Create(object parent, object configContext, XmlNode section);
}
public class System.Net.Configuration.ConnectionManagementSection : ConfigurationSection {
    private static ConfigurationProperty connectionManagementProp;
    private static ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("")]
public ConnectionManagementElementCollection ConnectionManagement { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static ConnectionManagementSection();
    public ConnectionManagementElementCollection get_ConnectionManagement();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.Net.Configuration.DefaultProxyHandler : object {
    public virtual object Create(object parent, object configContext, XmlNode section);
    private static void FillByPassList(XmlNode node, WebProxy proxy);
}
public class System.Net.Configuration.DefaultProxySection : ConfigurationSection {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty bypassListProp;
    private static ConfigurationProperty enabledProp;
    private static ConfigurationProperty moduleProp;
    private static ConfigurationProperty proxyProp;
    private static ConfigurationProperty useDefaultCredentialsProp;
    [ConfigurationPropertyAttribute("bypasslist")]
public BypassElementCollection BypassList { get; }
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    [ConfigurationPropertyAttribute("module")]
public ModuleElement Module { get; }
    [ConfigurationPropertyAttribute("proxy")]
public ProxyElement Proxy { get; }
    [ConfigurationPropertyAttribute("useDefaultCredentials")]
public bool UseDefaultCredentials { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static DefaultProxySection();
    public BypassElementCollection get_BypassList();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public ModuleElement get_Module();
    public ProxyElement get_Proxy();
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    [MonoTODOAttribute]
protected virtual void PostDeserialize();
    [MonoTODOAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
}
internal class System.Net.Configuration.DefaultProxySectionInternal : object {
    private IWebProxy webProxy;
    private static object classSyncObject;
    internal static object ClassSyncObject { get; }
    internal IWebProxy WebProxy { get; }
    private static IWebProxy GetDefaultProxy_UsingOldMonoCode();
    private static IWebProxy GetSystemWebProxy();
    internal static object get_ClassSyncObject();
    internal static DefaultProxySectionInternal GetSection();
    internal IWebProxy get_WebProxy();
}
public class System.Net.Configuration.FtpCachePolicyElement : ConfigurationElement {
    private static ConfigurationProperty policyLevelProp;
    private static ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("policyLevel")]
public RequestCacheLevel PolicyLevel { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static FtpCachePolicyElement();
    public RequestCacheLevel get_PolicyLevel();
    public void set_PolicyLevel(RequestCacheLevel value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    [MonoTODOAttribute]
protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    [MonoTODOAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
}
internal class System.Net.Configuration.HandlersUtil : object {
    internal static string ExtractAttributeValue(string attKey, XmlNode node);
    internal static string ExtractAttributeValue(string attKey, XmlNode node, bool optional);
    internal static void ThrowException(string msg, XmlNode node);
}
public class System.Net.Configuration.HttpCachePolicyElement : ConfigurationElement {
    private static ConfigurationProperty maximumAgeProp;
    private static ConfigurationProperty maximumStaleProp;
    private static ConfigurationProperty minimumFreshProp;
    private static ConfigurationProperty policyLevelProp;
    private static ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("maximumAge")]
public TimeSpan MaximumAge { get; public set; }
    [ConfigurationPropertyAttribute("maximumStale")]
public TimeSpan MaximumStale { get; public set; }
    [ConfigurationPropertyAttribute("minimumFresh")]
public TimeSpan MinimumFresh { get; public set; }
    [ConfigurationPropertyAttribute("policyLevel")]
public HttpRequestCacheLevel PolicyLevel { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static HttpCachePolicyElement();
    public TimeSpan get_MaximumAge();
    public void set_MaximumAge(TimeSpan value);
    public TimeSpan get_MaximumStale();
    public void set_MaximumStale(TimeSpan value);
    public TimeSpan get_MinimumFresh();
    public void set_MinimumFresh(TimeSpan value);
    public HttpRequestCacheLevel get_PolicyLevel();
    public void set_PolicyLevel(HttpRequestCacheLevel value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    [MonoTODOAttribute]
protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    [MonoTODOAttribute]
protected virtual void Reset(ConfigurationElement parentElement);
}
public class System.Net.Configuration.HttpListenerElement : ConfigurationElement {
    public HttpListenerTimeoutsElement Timeouts { get; }
    public bool UnescapeRequestUrl { get; }
    public HttpListenerTimeoutsElement get_Timeouts();
    public bool get_UnescapeRequestUrl();
}
public class System.Net.Configuration.HttpListenerTimeoutsElement : ConfigurationElement {
    public TimeSpan DrainEntityBody { get; }
    public TimeSpan EntityBody { get; }
    public TimeSpan HeaderWait { get; }
    public TimeSpan IdleConnection { get; }
    public long MinSendBytesPerSecond { get; }
    public TimeSpan RequestQueue { get; }
    public TimeSpan get_DrainEntityBody();
    public TimeSpan get_EntityBody();
    public TimeSpan get_HeaderWait();
    public TimeSpan get_IdleConnection();
    public long get_MinSendBytesPerSecond();
    public TimeSpan get_RequestQueue();
}
public class System.Net.Configuration.HttpWebRequestElement : ConfigurationElement {
    private static ConfigurationProperty maximumErrorResponseLengthProp;
    private static ConfigurationProperty maximumResponseHeadersLengthProp;
    private static ConfigurationProperty maximumUnauthorizedUploadLengthProp;
    private static ConfigurationProperty useUnsafeHeaderParsingProp;
    private static ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("maximumErrorResponseLength")]
public int MaximumErrorResponseLength { get; public set; }
    [ConfigurationPropertyAttribute("maximumResponseHeadersLength")]
public int MaximumResponseHeadersLength { get; public set; }
    [ConfigurationPropertyAttribute("maximumUnauthorizedUploadLength")]
public int MaximumUnauthorizedUploadLength { get; public set; }
    [ConfigurationPropertyAttribute("useUnsafeHeaderParsing")]
public bool UseUnsafeHeaderParsing { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static HttpWebRequestElement();
    public int get_MaximumErrorResponseLength();
    public void set_MaximumErrorResponseLength(int value);
    public int get_MaximumResponseHeadersLength();
    public void set_MaximumResponseHeadersLength(int value);
    public int get_MaximumUnauthorizedUploadLength();
    public void set_MaximumUnauthorizedUploadLength(int value);
    public bool get_UseUnsafeHeaderParsing();
    public void set_UseUnsafeHeaderParsing(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    [MonoTODOAttribute]
protected virtual void PostDeserialize();
}
public class System.Net.Configuration.Ipv6Element : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty enabledProp;
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static Ipv6Element();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.MailSettingsSectionGroup : ConfigurationSectionGroup {
    public SmtpSection Smtp { get; }
    public SmtpSection get_Smtp();
}
public class System.Net.Configuration.ModuleElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty typeProp;
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("type")]
public string Type { get; public set; }
    private static ModuleElement();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Type();
    public void set_Type(string value);
}
internal class System.Net.Configuration.NetAuthenticationModuleHandler : object {
    public virtual object Create(object parent, object configContext, XmlNode section);
    private static IAuthenticationModule CreateInstance(string typeName, XmlNode node);
}
internal class System.Net.Configuration.NetConfigurationHandler : object {
    public virtual object Create(object parent, object configContext, XmlNode section);
}
public class System.Net.Configuration.NetSectionGroup : ConfigurationSectionGroup {
    [ConfigurationPropertyAttribute("authenticationModules")]
public AuthenticationModulesSection AuthenticationModules { get; }
    [ConfigurationPropertyAttribute("connectionManagement")]
public ConnectionManagementSection ConnectionManagement { get; }
    [ConfigurationPropertyAttribute("defaultProxy")]
public DefaultProxySection DefaultProxy { get; }
    public MailSettingsSectionGroup MailSettings { get; }
    [ConfigurationPropertyAttribute("requestCaching")]
public RequestCachingSection RequestCaching { get; }
    [ConfigurationPropertyAttribute("settings")]
public SettingsSection Settings { get; }
    [ConfigurationPropertyAttribute("webRequestModules")]
public WebRequestModulesSection WebRequestModules { get; }
    public AuthenticationModulesSection get_AuthenticationModules();
    public ConnectionManagementSection get_ConnectionManagement();
    public DefaultProxySection get_DefaultProxy();
    public MailSettingsSectionGroup get_MailSettings();
    public RequestCachingSection get_RequestCaching();
    public SettingsSection get_Settings();
    public WebRequestModulesSection get_WebRequestModules();
    [MonoTODOAttribute]
public static NetSectionGroup GetSectionGroup(Configuration config);
}
public class System.Net.Configuration.PerformanceCountersElement : ConfigurationElement {
    private static ConfigurationProperty enabledProp;
    private static ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static PerformanceCountersElement();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.ProxyElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty autoDetectProp;
    private static ConfigurationProperty bypassOnLocalProp;
    private static ConfigurationProperty proxyAddressProp;
    private static ConfigurationProperty scriptLocationProp;
    private static ConfigurationProperty useSystemDefaultProp;
    [ConfigurationPropertyAttribute("autoDetect")]
public AutoDetectValues AutoDetect { get; public set; }
    [ConfigurationPropertyAttribute("bypassonlocal")]
public BypassOnLocalValues BypassOnLocal { get; public set; }
    [ConfigurationPropertyAttribute("proxyaddress")]
public Uri ProxyAddress { get; public set; }
    [ConfigurationPropertyAttribute("scriptLocation")]
public Uri ScriptLocation { get; public set; }
    [ConfigurationPropertyAttribute("usesystemdefault")]
public UseSystemDefaultValues UseSystemDefault { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static ProxyElement();
    public AutoDetectValues get_AutoDetect();
    public void set_AutoDetect(AutoDetectValues value);
    public BypassOnLocalValues get_BypassOnLocal();
    public void set_BypassOnLocal(BypassOnLocalValues value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public Uri get_ScriptLocation();
    public void set_ScriptLocation(Uri value);
    public UseSystemDefaultValues get_UseSystemDefault();
    public void set_UseSystemDefault(UseSystemDefaultValues value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.RequestCachingSection : ConfigurationSection {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty defaultFtpCachePolicyProp;
    private static ConfigurationProperty defaultHttpCachePolicyProp;
    private static ConfigurationProperty defaultPolicyLevelProp;
    private static ConfigurationProperty disableAllCachingProp;
    private static ConfigurationProperty isPrivateCacheProp;
    private static ConfigurationProperty unspecifiedMaximumAgeProp;
    [ConfigurationPropertyAttribute("defaultFtpCachePolicy")]
public FtpCachePolicyElement DefaultFtpCachePolicy { get; }
    [ConfigurationPropertyAttribute("defaultHttpCachePolicy")]
public HttpCachePolicyElement DefaultHttpCachePolicy { get; }
    [ConfigurationPropertyAttribute("defaultPolicyLevel")]
public RequestCacheLevel DefaultPolicyLevel { get; public set; }
    [ConfigurationPropertyAttribute("disableAllCaching")]
public bool DisableAllCaching { get; public set; }
    [ConfigurationPropertyAttribute("isPrivateCache")]
public bool IsPrivateCache { get; public set; }
    [ConfigurationPropertyAttribute("unspecifiedMaximumAge")]
public TimeSpan UnspecifiedMaximumAge { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static RequestCachingSection();
    public FtpCachePolicyElement get_DefaultFtpCachePolicy();
    public HttpCachePolicyElement get_DefaultHttpCachePolicy();
    public RequestCacheLevel get_DefaultPolicyLevel();
    public void set_DefaultPolicyLevel(RequestCacheLevel value);
    public bool get_DisableAllCaching();
    public void set_DisableAllCaching(bool value);
    public bool get_IsPrivateCache();
    public void set_IsPrivateCache(bool value);
    public TimeSpan get_UnspecifiedMaximumAge();
    public void set_UnspecifiedMaximumAge(TimeSpan value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    [MonoTODOAttribute]
protected virtual void PostDeserialize();
    [MonoTODOAttribute]
protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
}
public class System.Net.Configuration.ServicePointManagerElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty checkCertificateNameProp;
    private static ConfigurationProperty checkCertificateRevocationListProp;
    private static ConfigurationProperty dnsRefreshTimeoutProp;
    private static ConfigurationProperty enableDnsRoundRobinProp;
    private static ConfigurationProperty expect100ContinueProp;
    private static ConfigurationProperty useNagleAlgorithmProp;
    [ConfigurationPropertyAttribute("checkCertificateName")]
public bool CheckCertificateName { get; public set; }
    [ConfigurationPropertyAttribute("checkCertificateRevocationList")]
public bool CheckCertificateRevocationList { get; public set; }
    [ConfigurationPropertyAttribute("dnsRefreshTimeout")]
public int DnsRefreshTimeout { get; public set; }
    [ConfigurationPropertyAttribute("enableDnsRoundRobin")]
public bool EnableDnsRoundRobin { get; public set; }
    [ConfigurationPropertyAttribute("expect100Continue")]
public bool Expect100Continue { get; public set; }
    [ConfigurationPropertyAttribute("useNagleAlgorithm")]
public bool UseNagleAlgorithm { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    private static ServicePointManagerElement();
    public bool get_CheckCertificateName();
    public void set_CheckCertificateName(bool value);
    public bool get_CheckCertificateRevocationList();
    public void set_CheckCertificateRevocationList(bool value);
    public int get_DnsRefreshTimeout();
    public void set_DnsRefreshTimeout(int value);
    public bool get_EnableDnsRoundRobin();
    public void set_EnableDnsRoundRobin(bool value);
    public bool get_Expect100Continue();
    public void set_Expect100Continue(bool value);
    public bool get_UseNagleAlgorithm();
    public void set_UseNagleAlgorithm(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    [MonoTODOAttribute]
protected virtual void PostDeserialize();
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
}
public class System.Net.Configuration.SettingsSection : ConfigurationSection {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty httpWebRequestProp;
    private static ConfigurationProperty ipv6Prop;
    private static ConfigurationProperty performanceCountersProp;
    private static ConfigurationProperty servicePointManagerProp;
    private static ConfigurationProperty webProxyScriptProp;
    private static ConfigurationProperty socketProp;
    [ConfigurationPropertyAttribute("httpWebRequest")]
public HttpWebRequestElement HttpWebRequest { get; }
    [ConfigurationPropertyAttribute("ipv6")]
public Ipv6Element Ipv6 { get; }
    [ConfigurationPropertyAttribute("performanceCounters")]
public PerformanceCountersElement PerformanceCounters { get; }
    [ConfigurationPropertyAttribute("servicePointManager")]
public ServicePointManagerElement ServicePointManager { get; }
    [ConfigurationPropertyAttribute("socket")]
public SocketElement Socket { get; }
    [ConfigurationPropertyAttribute("webProxyScript")]
public WebProxyScriptElement WebProxyScript { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public HttpListenerElement HttpListener { get; }
    public WebUtilityElement WebUtility { get; }
    public WindowsAuthenticationElement WindowsAuthentication { get; }
    private static SettingsSection();
    public HttpWebRequestElement get_HttpWebRequest();
    public Ipv6Element get_Ipv6();
    public PerformanceCountersElement get_PerformanceCounters();
    public ServicePointManagerElement get_ServicePointManager();
    public SocketElement get_Socket();
    public WebProxyScriptElement get_WebProxyScript();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public HttpListenerElement get_HttpListener();
    public WebUtilityElement get_WebUtility();
    public WindowsAuthenticationElement get_WindowsAuthentication();
}
internal class System.Net.Configuration.SettingsSectionInternal : object {
    private static SettingsSectionInternal instance;
    internal UnicodeEncodingConformance WebUtilityUnicodeEncodingConformance;
    internal UnicodeDecodingConformance WebUtilityUnicodeDecodingConformance;
    internal bool HttpListenerUnescapeRequestUrl;
    internal IPProtectionLevel IPProtectionLevel;
    [CompilerGeneratedAttribute]
private bool <UseNagleAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expect100Continue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertificateName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DnsRefreshTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDnsRoundRobin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertificateRevocationList>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionPolicy <EncryptionPolicy>k__BackingField;
    internal static SettingsSectionInternal Section { get; }
    internal bool UseNagleAlgorithm { get; internal set; }
    internal bool Expect100Continue { get; internal set; }
    internal bool CheckCertificateName { get; private set; }
    internal int DnsRefreshTimeout { get; internal set; }
    internal bool EnableDnsRoundRobin { get; internal set; }
    internal bool CheckCertificateRevocationList { get; internal set; }
    internal EncryptionPolicy EncryptionPolicy { get; private set; }
    internal bool Ipv6Enabled { get; }
    private static SettingsSectionInternal();
    internal static SettingsSectionInternal get_Section();
    [CompilerGeneratedAttribute]
internal bool get_UseNagleAlgorithm();
    [CompilerGeneratedAttribute]
internal void set_UseNagleAlgorithm(bool value);
    [CompilerGeneratedAttribute]
internal bool get_Expect100Continue();
    [CompilerGeneratedAttribute]
internal void set_Expect100Continue(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CheckCertificateName();
    [CompilerGeneratedAttribute]
private void set_CheckCertificateName(bool value);
    [CompilerGeneratedAttribute]
internal int get_DnsRefreshTimeout();
    [CompilerGeneratedAttribute]
internal void set_DnsRefreshTimeout(int value);
    [CompilerGeneratedAttribute]
internal bool get_EnableDnsRoundRobin();
    [CompilerGeneratedAttribute]
internal void set_EnableDnsRoundRobin(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CheckCertificateRevocationList();
    [CompilerGeneratedAttribute]
internal void set_CheckCertificateRevocationList(bool value);
    [CompilerGeneratedAttribute]
internal EncryptionPolicy get_EncryptionPolicy();
    [CompilerGeneratedAttribute]
private void set_EncryptionPolicy(EncryptionPolicy value);
    internal bool get_Ipv6Enabled();
}
public class System.Net.Configuration.SmtpNetworkElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("defaultCredentials")]
public bool DefaultCredentials { get; public set; }
    [ConfigurationPropertyAttribute("host")]
public string Host { get; public set; }
    [ConfigurationPropertyAttribute("password")]
public string Password { get; public set; }
    [ConfigurationPropertyAttribute("port")]
public int Port { get; public set; }
    [ConfigurationPropertyAttribute("userName")]
public string UserName { get; public set; }
    [ConfigurationPropertyAttribute("targetName")]
public string TargetName { get; public set; }
    [ConfigurationPropertyAttribute("enableSsl")]
public bool EnableSsl { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string ClientDomain { get; public set; }
    public bool get_DefaultCredentials();
    public void set_DefaultCredentials(bool value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Password();
    public void set_Password(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_TargetName();
    public void set_TargetName(string value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual void PostDeserialize();
    public string get_ClientDomain();
    public void set_ClientDomain(string value);
}
public class System.Net.Configuration.SmtpSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("deliveryMethod")]
public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    [ConfigurationPropertyAttribute("deliveryFormat")]
public SmtpDeliveryFormat DeliveryFormat { get; public set; }
    [ConfigurationPropertyAttribute("from")]
public string From { get; public set; }
    [ConfigurationPropertyAttribute("network")]
public SmtpNetworkElement Network { get; }
    [ConfigurationPropertyAttribute("specifiedPickupDirectory")]
public SmtpSpecifiedPickupDirectoryElement SpecifiedPickupDirectory { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public SmtpDeliveryMethod get_DeliveryMethod();
    public void set_DeliveryMethod(SmtpDeliveryMethod value);
    public SmtpDeliveryFormat get_DeliveryFormat();
    public void set_DeliveryFormat(SmtpDeliveryFormat value);
    public string get_From();
    public void set_From(string value);
    public SmtpNetworkElement get_Network();
    public SmtpSpecifiedPickupDirectoryElement get_SpecifiedPickupDirectory();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.SmtpSpecifiedPickupDirectoryElement : ConfigurationElement {
    private static ConfigurationProperty pickupDirectoryLocationProp;
    private static ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("pickupDirectoryLocation")]
public string PickupDirectoryLocation { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static SmtpSpecifiedPickupDirectoryElement();
    public string get_PickupDirectoryLocation();
    public void set_PickupDirectoryLocation(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.SocketElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty alwaysUseCompletionPortsForAcceptProp;
    private static ConfigurationProperty alwaysUseCompletionPortsForConnectProp;
    [ConfigurationPropertyAttribute("alwaysUseCompletionPortsForAccept")]
public bool AlwaysUseCompletionPortsForAccept { get; public set; }
    [ConfigurationPropertyAttribute("alwaysUseCompletionPortsForConnect")]
public bool AlwaysUseCompletionPortsForConnect { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public IPProtectionLevel IPProtectionLevel { get; public set; }
    public bool get_AlwaysUseCompletionPortsForAccept();
    public void set_AlwaysUseCompletionPortsForAccept(bool value);
    public bool get_AlwaysUseCompletionPortsForConnect();
    public void set_AlwaysUseCompletionPortsForConnect(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    [MonoTODOAttribute]
protected virtual void PostDeserialize();
    public IPProtectionLevel get_IPProtectionLevel();
    public void set_IPProtectionLevel(IPProtectionLevel value);
}
public enum System.Net.Configuration.UnicodeDecodingConformance : Enum {
    public int value__;
    public static UnicodeDecodingConformance Auto;
    public static UnicodeDecodingConformance Strict;
    public static UnicodeDecodingConformance Compat;
    public static UnicodeDecodingConformance Loose;
}
public enum System.Net.Configuration.UnicodeEncodingConformance : Enum {
    public int value__;
    public static UnicodeEncodingConformance Auto;
    public static UnicodeEncodingConformance Strict;
    public static UnicodeEncodingConformance Compat;
}
public class System.Net.Configuration.WebProxyScriptElement : ConfigurationElement {
    private static ConfigurationProperty downloadTimeoutProp;
    private static ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("downloadTimeout")]
public TimeSpan DownloadTimeout { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public int AutoConfigUrlRetryInterval { get; public set; }
    private static WebProxyScriptElement();
    protected virtual void PostDeserialize();
    public TimeSpan get_DownloadTimeout();
    public void set_DownloadTimeout(TimeSpan value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public int get_AutoConfigUrlRetryInterval();
    public void set_AutoConfigUrlRetryInterval(int value);
}
public class System.Net.Configuration.WebRequestModuleElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty prefixProp;
    private static ConfigurationProperty typeProp;
    [ConfigurationPropertyAttribute("prefix")]
public string Prefix { get; public set; }
    [ConfigurationPropertyAttribute("type")]
[TypeConverterAttribute("System.ComponentModel.TypeConverter")]
public Type Type { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static WebRequestModuleElement();
    public WebRequestModuleElement(string prefix, string type);
    public WebRequestModuleElement(string prefix, Type type);
    public string get_Prefix();
    public void set_Prefix(string value);
    public Type get_Type();
    public void set_Type(Type value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.Net.Configuration.WebRequestModuleElement")]
[DefaultMemberAttribute("Item")]
public class System.Net.Configuration.WebRequestModuleElementCollection : ConfigurationElementCollection {
    [MonoTODOAttribute]
public WebRequestModuleElement Item { get; public set; }
    [MonoTODOAttribute]
public WebRequestModuleElement Item { get; public set; }
    public WebRequestModuleElement get_Item(int index);
    public void set_Item(int index, WebRequestModuleElement value);
    public WebRequestModuleElement get_Item(string name);
    public void set_Item(string name, WebRequestModuleElement value);
    public void Add(WebRequestModuleElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(WebRequestModuleElement element);
    public void Remove(WebRequestModuleElement element);
    public void Remove(string name);
    public void RemoveAt(int index);
}
internal class System.Net.Configuration.WebRequestModuleHandler : object {
    public virtual object Create(object parent, object configContext, XmlNode section);
}
public class System.Net.Configuration.WebRequestModulesSection : ConfigurationSection {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty webRequestModulesProp;
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public WebRequestModuleElementCollection WebRequestModules { get; }
    private static WebRequestModulesSection();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public WebRequestModuleElementCollection get_WebRequestModules();
    [MonoTODOAttribute]
protected virtual void PostDeserialize();
    [MonoTODOAttribute]
protected virtual void InitializeDefault();
}
public class System.Net.Configuration.WebUtilityElement : ConfigurationElement {
    public UnicodeDecodingConformance UnicodeDecodingConformance { get; public set; }
    public UnicodeEncodingConformance UnicodeEncodingConformance { get; public set; }
    public UnicodeDecodingConformance get_UnicodeDecodingConformance();
    public void set_UnicodeDecodingConformance(UnicodeDecodingConformance value);
    public UnicodeEncodingConformance get_UnicodeEncodingConformance();
    public void set_UnicodeEncodingConformance(UnicodeEncodingConformance value);
}
public class System.Net.Configuration.WindowsAuthenticationElement : ConfigurationElement {
    public int DefaultCredentialsHandleCacheSize { get; public set; }
    public int get_DefaultCredentialsHandleCacheSize();
    public void set_DefaultCredentialsHandleCacheSize(int value);
}
internal class System.Net.ContentDecodeStream : WebReadStream {
    [CompilerGeneratedAttribute]
private Stream <OriginalInnerStream>k__BackingField;
    private Stream OriginalInnerStream { get; }
    private ContentDecodeStream(WebOperation operation, Stream decodeStream, Stream originalInnerStream);
    public static ContentDecodeStream Create(WebOperation operation, Stream innerStream, Mode mode);
    [CompilerGeneratedAttribute]
private Stream get_OriginalInnerStream();
    protected virtual Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    internal virtual Task FinishReading(CancellationToken cancellationToken);
}
internal enum System.Net.ContentTypeValues : Enum {
    public int value__;
    public static ContentTypeValues ChangeCipherSpec;
    public static ContentTypeValues Alert;
    public static ContentTypeValues HandShake;
    public static ContentTypeValues AppData;
    public static ContentTypeValues Unrecognized;
}
internal enum System.Net.ContextAttribute : Enum {
    public int value__;
    public static ContextAttribute Sizes;
    public static ContextAttribute Names;
    public static ContextAttribute Lifespan;
    public static ContextAttribute DceInfo;
    public static ContextAttribute StreamSizes;
    public static ContextAttribute Authority;
    public static ContextAttribute PackageInfo;
    public static ContextAttribute NegotiationInfo;
    public static ContextAttribute UniqueBindings;
    public static ContextAttribute EndpointBindings;
    public static ContextAttribute ClientSpecifiedSpn;
    public static ContextAttribute RemoteCertificate;
    public static ContextAttribute LocalCertificate;
    public static ContextAttribute RootStore;
    public static ContextAttribute IssuerListInfoEx;
    public static ContextAttribute ConnectionInfo;
    public static ContextAttribute UiInfo;
}
internal class System.Net.ContextAwareResult : LazyAsyncResult {
    private WindowsIdentity _windowsIdentity;
    private ExecutionContext modreq(System.Runtime.CompilerServices.IsVolatile) _context;
    private object _lock;
    private StateFlags _flags;
    internal WindowsIdentity Identity { get; }
    internal ExecutionContext ContextCopy { get; }
    internal EndPoint RemoteEndPoint { get; }
    internal ContextAwareResult(object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, bool threadSafeContextCopy, object myObject, object myState, AsyncCallback myCallBack);
    private void SafeCaptureIdentity();
    internal WindowsIdentity get_Identity();
    private void CleanupInternal();
    internal ExecutionContext get_ContextCopy();
    internal object StartPostingAsyncOp();
    internal object StartPostingAsyncOp(bool lockCapture);
    internal bool FinishPostingAsyncOp();
    internal bool FinishPostingAsyncOp(CallbackClosure& closure);
    protected virtual void Cleanup();
    private bool CaptureOrComplete(ExecutionContext& cachedContext, bool returnContext);
    protected virtual void Complete(IntPtr userToken);
    private void CompleteCallback();
    internal virtual EndPoint get_RemoteEndPoint();
}
internal static class System.Net.ContextFlagsAdapterPal : object {
    private static ContextFlagMapping[] s_contextFlagMapping;
    private static ContextFlagsAdapterPal();
    internal static ContextFlagsPal GetContextFlagsPalFromInterop(ContextFlags win32Flags);
    internal static ContextFlags GetInteropFromContextFlagsPal(ContextFlagsPal flags);
}
[FlagsAttribute]
internal enum System.Net.ContextFlagsPal : Enum {
    public int value__;
    public static ContextFlagsPal None;
    public static ContextFlagsPal Delegate;
    public static ContextFlagsPal MutualAuth;
    public static ContextFlagsPal ReplayDetect;
    public static ContextFlagsPal SequenceDetect;
    public static ContextFlagsPal Confidentiality;
    public static ContextFlagsPal UseSessionKey;
    public static ContextFlagsPal AllocateMemory;
    public static ContextFlagsPal Connection;
    public static ContextFlagsPal InitExtendedError;
    public static ContextFlagsPal AcceptExtendedError;
    public static ContextFlagsPal InitStream;
    public static ContextFlagsPal AcceptStream;
    public static ContextFlagsPal InitIntegrity;
    public static ContextFlagsPal AcceptIntegrity;
    public static ContextFlagsPal InitManualCredValidation;
    public static ContextFlagsPal InitUseSuppliedCreds;
    public static ContextFlagsPal InitIdentify;
    public static ContextFlagsPal AcceptIdentify;
    public static ContextFlagsPal ProxyBindings;
    public static ContextFlagsPal AllowMissingBindings;
    public static ContextFlagsPal UnverifiedTargetName;
}
public class System.Net.Cookie : object {
    internal static int MaxSupportedVersion;
    internal static string CommentAttributeName;
    internal static string CommentUrlAttributeName;
    internal static string DiscardAttributeName;
    internal static string DomainAttributeName;
    internal static string ExpiresAttributeName;
    internal static string MaxAgeAttributeName;
    internal static string PathAttributeName;
    internal static string PortAttributeName;
    internal static string SecureAttributeName;
    internal static string VersionAttributeName;
    internal static string HttpOnlyAttributeName;
    internal static string SeparatorLiteral;
    internal static string EqualsLiteral;
    internal static string QuotesLiteral;
    internal static string SpecialAttributeLiteral;
    internal static Char[] PortSplitDelimiters;
    internal static Char[] Reserved2Name;
    internal static Char[] Reserved2Value;
    private static Comparer staticComparer;
    private string m_comment;
    private Uri m_commentUri;
    private CookieVariant m_cookieVariant;
    private bool m_discard;
    private string m_domain;
    private bool m_domain_implicit;
    private DateTime m_expires;
    private string m_name;
    private string m_path;
    private bool m_path_implicit;
    private string m_port;
    private bool m_port_implicit;
    private Int32[] m_port_list;
    private bool m_secure;
    [OptionalFieldAttribute]
private bool m_httpOnly;
    private DateTime m_timeStamp;
    private string m_value;
    private int m_version;
    private string m_domainKey;
    internal bool IsQuotedVersion;
    internal bool IsQuotedDomain;
    public string Comment { get; public set; }
    public Uri CommentUri { get; public set; }
    public bool HttpOnly { get; public set; }
    public bool Discard { get; public set; }
    public string Domain { get; public set; }
    private string _Domain { get; }
    internal bool DomainImplicit { get; internal set; }
    public bool Expired { get; public set; }
    public DateTime Expires { get; public set; }
    public string Name { get; public set; }
    public string Path { get; public set; }
    private string _Path { get; }
    internal bool Plain { get; }
    public string Port { get; public set; }
    internal Int32[] PortList { get; }
    private string _Port { get; }
    public bool Secure { get; public set; }
    public DateTime TimeStamp { get; }
    public string Value { get; public set; }
    internal CookieVariant Variant { get; internal set; }
    internal string DomainKey { get; }
    public int Version { get; public set; }
    private string _Version { get; }
    public Cookie(string name, string value);
    public Cookie(string name, string value, string path);
    public Cookie(string name, string value, string path, string domain);
    private static Cookie();
    public string get_Comment();
    public void set_Comment(string value);
    public Uri get_CommentUri();
    public void set_CommentUri(Uri value);
    public bool get_HttpOnly();
    public void set_HttpOnly(bool value);
    public bool get_Discard();
    public void set_Discard(bool value);
    public string get_Domain();
    public void set_Domain(string value);
    private string get__Domain();
    internal bool get_DomainImplicit();
    internal void set_DomainImplicit(bool value);
    public bool get_Expired();
    public void set_Expired(bool value);
    public DateTime get_Expires();
    public void set_Expires(DateTime value);
    public string get_Name();
    public void set_Name(string value);
    internal bool InternalSetName(string value);
    public string get_Path();
    public void set_Path(string value);
    private string get__Path();
    internal bool get_Plain();
    internal Cookie Clone();
    private static bool IsDomainEqualToHost(string domain, string host);
    internal bool VerifySetDefaults(CookieVariant variant, Uri uri, bool isLocalDomain, string localDomain, bool set_default, bool isThrow);
    private static bool DomainCharsTest(string name);
    public string get_Port();
    public void set_Port(string value);
    internal Int32[] get_PortList();
    private string get__Port();
    public bool get_Secure();
    public void set_Secure(bool value);
    public DateTime get_TimeStamp();
    public string get_Value();
    public void set_Value(string value);
    internal CookieVariant get_Variant();
    internal void set_Variant(CookieVariant value);
    internal string get_DomainKey();
    public int get_Version();
    public void set_Version(int value);
    private string get__Version();
    internal static IComparer GetComparer();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal string ToServerString();
}
[DefaultMemberAttribute("Item")]
public class System.Net.CookieCollection : object {
    internal int m_version;
    private ArrayList m_list;
    private DateTime m_TimeStamp;
    private bool m_has_other_versions;
    [OptionalFieldAttribute]
private bool m_IsReadOnly;
    public bool IsReadOnly { get; }
    public Cookie Item { get; }
    public Cookie Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal bool IsOtherVersionSeen { get; }
    internal CookieCollection(bool IsReadOnly);
    public bool get_IsReadOnly();
    public Cookie get_Item(int index);
    public Cookie get_Item(string name);
    public void Add(Cookie cookie);
    public void Add(CookieCollection cookies);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Cookie[] array, int index);
    internal DateTime TimeStamp(Stamp how);
    internal bool get_IsOtherVersionSeen();
    internal int InternalAdd(Cookie cookie, bool isStrict);
    internal int IndexOf(Cookie cookie);
    internal void RemoveAt(int idx);
    public sealed virtual IEnumerator GetEnumerator();
}
public class System.Net.CookieContainer : object {
    public static int DefaultCookieLimit;
    public static int DefaultPerDomainCookieLimit;
    public static int DefaultCookieLengthLimit;
    private static HeaderVariantInfo[] HeaderInfo;
    private Hashtable m_domainTable;
    private int m_maxCookieSize;
    private int m_maxCookies;
    private int m_maxCookiesPerDomain;
    private int m_count;
    private string m_fqdnMyDomain;
    public int Capacity { get; public set; }
    public int Count { get; }
    public int MaxCookieSize { get; public set; }
    public int PerDomainCapacity { get; public set; }
    public CookieContainer(int capacity);
    public CookieContainer(int capacity, int perDomainCapacity, int maxCookieSize);
    private static CookieContainer();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public int get_MaxCookieSize();
    public void set_MaxCookieSize(int value);
    public int get_PerDomainCapacity();
    public void set_PerDomainCapacity(int value);
    public void Add(Cookie cookie);
    private void AddRemoveDomain(string key, PathList value);
    internal void Add(Cookie cookie, bool throwOnError);
    private bool AgeCookies(string domain);
    private int ExpireCollection(CookieCollection cc);
    public void Add(CookieCollection cookies);
    internal bool IsLocalDomain(string host);
    public void Add(Uri uri, Cookie cookie);
    public void Add(Uri uri, CookieCollection cookies);
    internal CookieCollection CookieCutter(Uri uri, string headerName, string setCookieHeader, bool isThrow);
    public CookieCollection GetCookies(Uri uri);
    internal CookieCollection InternalGetCookies(Uri uri);
    private void BuildCookieCollectionFromDomainMatches(Uri uri, bool isSecure, int port, CookieCollection cookies, List`1<string> domainAttribute, bool matchOnlyPlainCookie);
    private void MergeUpdateCollections(CookieCollection destination, CookieCollection source, int port, bool isSecure, bool isPlainOnly);
    public string GetCookieHeader(Uri uri);
    internal string GetCookieHeader(Uri uri, String& optCookie2);
    public void SetCookies(Uri uri, string cookieHeader);
}
public class System.Net.CookieException : FormatException {
    internal CookieException(string message);
    internal CookieException(string message, Exception inner);
    protected CookieException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class System.Net.CookieParser : object {
    private CookieTokenizer m_tokenizer;
    private Cookie m_savedCookie;
    internal CookieParser(string cookieString);
    internal Cookie Get();
    internal Cookie GetServer();
    internal static string CheckQuoted(string value);
}
internal enum System.Net.CookieToken : Enum {
    public int value__;
    public static CookieToken Nothing;
    public static CookieToken NameValuePair;
    public static CookieToken Attribute;
    public static CookieToken EndToken;
    public static CookieToken EndCookie;
    public static CookieToken End;
    public static CookieToken Equals;
    public static CookieToken Comment;
    public static CookieToken CommentUrl;
    public static CookieToken CookieName;
    public static CookieToken Discard;
    public static CookieToken Domain;
    public static CookieToken Expires;
    public static CookieToken MaxAge;
    public static CookieToken Path;
    public static CookieToken Port;
    public static CookieToken Secure;
    public static CookieToken HttpOnly;
    public static CookieToken Unknown;
    public static CookieToken Version;
}
internal class System.Net.CookieTokenizer : object {
    private bool m_eofCookie;
    private int m_index;
    private int m_length;
    private string m_name;
    private bool m_quoted;
    private int m_start;
    private CookieToken m_token;
    private int m_tokenLength;
    private string m_tokenStream;
    private string m_value;
    private static RecognizedAttribute[] RecognizedAttributes;
    private static RecognizedAttribute[] RecognizedServerAttributes;
    internal bool EndOfCookie { get; internal set; }
    internal bool Eof { get; }
    internal string Name { get; internal set; }
    internal bool Quoted { get; internal set; }
    internal CookieToken Token { get; internal set; }
    internal string Value { get; internal set; }
    internal CookieTokenizer(string tokenStream);
    private static CookieTokenizer();
    internal bool get_EndOfCookie();
    internal void set_EndOfCookie(bool value);
    internal bool get_Eof();
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_Quoted();
    internal void set_Quoted(bool value);
    internal CookieToken get_Token();
    internal void set_Token(CookieToken value);
    internal string get_Value();
    internal void set_Value(string value);
    internal string Extract();
    internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals);
    internal CookieToken Next(bool first, bool parseResponseCookies);
    internal void Reset();
    internal CookieToken TokenFromName(bool parseResponseCookies);
}
internal enum System.Net.CookieVariant : Enum {
    public int value__;
    public static CookieVariant Unknown;
    public static CookieVariant Plain;
    public static CookieVariant Rfc2109;
    public static CookieVariant Rfc2965;
    public static CookieVariant Default;
}
public class System.Net.CredentialCache : object {
    private Hashtable cache;
    private Hashtable cacheForHosts;
    internal int m_version;
    private int m_NumbDefaultCredInCache;
    internal bool IsDefaultInCache { get; }
    public static ICredentials DefaultCredentials { get; }
    public static NetworkCredential DefaultNetworkCredentials { get; }
    internal bool get_IsDefaultInCache();
    public void Add(Uri uriPrefix, string authType, NetworkCredential cred);
    public void Add(string host, int port, string authenticationType, NetworkCredential credential);
    public void Remove(Uri uriPrefix, string authType);
    public void Remove(string host, int port, string authenticationType);
    public sealed virtual NetworkCredential GetCredential(Uri uriPrefix, string authType);
    public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
    public sealed virtual IEnumerator GetEnumerator();
    public static ICredentials get_DefaultCredentials();
    public static NetworkCredential get_DefaultNetworkCredentials();
}
internal class System.Net.CredentialHostKey : object {
    internal string Host;
    internal string AuthenticationType;
    internal int Port;
    private int m_HashCode;
    private bool m_ComputedHashCode;
    internal CredentialHostKey(string host, int port, string authenticationType);
    internal bool Match(string host, int port, string authenticationType);
    public virtual int GetHashCode();
    public virtual bool Equals(object comparand);
    public virtual string ToString();
}
internal class System.Net.CredentialKey : object {
    internal Uri UriPrefix;
    internal int UriPrefixLength;
    internal string AuthenticationType;
    private int m_HashCode;
    private bool m_ComputedHashCode;
    internal CredentialKey(Uri uriPrefix, string authenticationType);
    internal bool Match(Uri uri, string authenticationType);
    internal bool IsPrefix(Uri uri, Uri prefixUri);
    public virtual int GetHashCode();
    public virtual bool Equals(object comparand);
    public virtual string ToString();
}
internal enum System.Net.CredentialUse : Enum {
    public int value__;
    public static CredentialUse Inbound;
    public static CredentialUse Outbound;
    public static CredentialUse Both;
}
internal enum System.Net.DataParseStatus : Enum {
    public int value__;
    public static DataParseStatus NeedMoreData;
    public static DataParseStatus ContinueParsing;
    public static DataParseStatus Done;
    public static DataParseStatus Invalid;
    public static DataParseStatus DataTooBig;
}
[FlagsAttribute]
public enum System.Net.DecompressionMethods : Enum {
    public int value__;
    public static DecompressionMethods None;
    public static DecompressionMethods GZip;
    public static DecompressionMethods Deflate;
}
internal class System.Net.DefaultCertificatePolicy : object {
    public sealed virtual bool CheckValidationResult(ServicePoint point, X509Certificate certificate, WebRequest request, int certificateProblem);
}
internal enum System.Net.DefaultPorts : Enum {
    public int value__;
    public static DefaultPorts DEFAULT_FTP_PORT;
    public static DefaultPorts DEFAULT_GOPHER_PORT;
    public static DefaultPorts DEFAULT_HTTP_PORT;
    public static DefaultPorts DEFAULT_HTTPS_PORT;
    public static DefaultPorts DEFAULT_NNTP_PORT;
    public static DefaultPorts DEFAULT_SMTP_PORT;
    public static DefaultPorts DEFAULT_TELNET_PORT;
}
internal class System.Net.DelayedRegex : object {
    private Regex _AsRegex;
    private string _AsString;
    internal Regex AsRegex { get; }
    internal DelayedRegex(string regexString);
    internal DelayedRegex(Regex regex);
    internal Regex get_AsRegex();
    public virtual string ToString();
}
internal class System.Net.DelegatedStream : Stream {
    private Stream _stream;
    private NetworkStream _netStream;
    protected Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected DelegatedStream(Stream stream);
    protected Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class System.Net.DigestClient : object {
    private static Hashtable cache;
    private static Hashtable Cache { get; }
    public string AuthenticationType { get; }
    public bool CanPreAuthenticate { get; }
    private static DigestClient();
    private static Hashtable get_Cache();
    private static void CheckExpired(int count);
    public sealed virtual Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
    public sealed virtual Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool get_CanPreAuthenticate();
}
internal class System.Net.DigestHeaderParser : object {
    private string header;
    private int length;
    private int pos;
    private static String[] keywords;
    private String[] values;
    public string Realm { get; }
    public string Opaque { get; }
    public string Nonce { get; }
    public string Algorithm { get; }
    public string QOP { get; }
    public DigestHeaderParser(string header);
    private static DigestHeaderParser();
    public string get_Realm();
    public string get_Opaque();
    public string get_Nonce();
    public string get_Algorithm();
    public string get_QOP();
    public bool Parse();
    private void SkipWhitespace();
    private string GetKey();
    private bool GetKeywordAndValue(String& key, String& value);
}
internal class System.Net.DigestSession : object {
    private static RandomNumberGenerator rng;
    private DateTime lastUse;
    private int _nc;
    private HashAlgorithm hash;
    private DigestHeaderParser parser;
    private string _cnonce;
    public string Algorithm { get; }
    public string Realm { get; }
    public string Nonce { get; }
    public string Opaque { get; }
    public string QOP { get; }
    public string CNonce { get; }
    public DateTime LastUse { get; }
    private static DigestSession();
    public string get_Algorithm();
    public string get_Realm();
    public string get_Nonce();
    public string get_Opaque();
    public string get_QOP();
    public string get_CNonce();
    public bool Parse(string challenge);
    private string HashToHexString(string toBeHashed);
    private string HA1(string username, string password);
    private string HA2(HttpWebRequest webRequest);
    private string Response(string username, string password, HttpWebRequest webRequest);
    public Authorization Authenticate(WebRequest webRequest, ICredentials credentials);
    public DateTime get_LastUse();
}
internal class System.Net.DirectProxy : ProxyChain {
    private bool m_ProxyRetrieved;
    internal DirectProxy(Uri destination);
    protected virtual bool GetNextProxy(Uri& proxy);
}
public static class System.Net.Dns : object {
    private static bool use_mono_dns;
    private static SimpleResolver resolver;
    internal static bool UseMonoDns { get; }
    private static Dns();
    internal static bool get_UseMonoDns();
    private static void OnCompleted(object sender, SimpleResolverEventArgs e);
    private static IAsyncResult BeginAsyncCallAddresses(string host, AsyncCallback callback, object state);
    private static IAsyncResult BeginAsyncCall(string host, AsyncCallback callback, object state);
    private static IPHostEntry EndAsyncCall(DnsAsyncResult ares);
    [ObsoleteAttribute("Use BeginGetHostEntry instead")]
public static IAsyncResult BeginGetHostByName(string hostName, AsyncCallback requestCallback, object stateObject);
    [ObsoleteAttribute("Use BeginGetHostEntry instead")]
public static IAsyncResult BeginResolve(string hostName, AsyncCallback requestCallback, object stateObject);
    public static IAsyncResult BeginGetHostAddresses(string hostNameOrAddress, AsyncCallback requestCallback, object state);
    public static IAsyncResult BeginGetHostEntry(string hostNameOrAddress, AsyncCallback requestCallback, object stateObject);
    public static IAsyncResult BeginGetHostEntry(IPAddress address, AsyncCallback requestCallback, object stateObject);
    [ObsoleteAttribute("Use EndGetHostEntry instead")]
public static IPHostEntry EndGetHostByName(IAsyncResult asyncResult);
    [ObsoleteAttribute("Use EndGetHostEntry instead")]
public static IPHostEntry EndResolve(IAsyncResult asyncResult);
    public static IPAddress[] EndGetHostAddresses(IAsyncResult asyncResult);
    public static IPHostEntry EndGetHostEntry(IAsyncResult asyncResult);
    private static bool GetHostByName_icall(string host, String& h_name, String[]& h_aliases, String[]& h_addr_list, int hint);
    private static bool GetHostByAddr_icall(string addr, String& h_name, String[]& h_aliases, String[]& h_addr_list, int hint);
    private static bool GetHostName_icall(String& h_name);
    private static void Error_11001(string hostName);
    private static IPHostEntry hostent_to_IPHostEntry(string originalHostName, string h_name, String[] h_aliases, String[] h_addrlist);
    [ObsoleteAttribute("Use GetHostEntry instead")]
public static IPHostEntry GetHostByAddress(IPAddress address);
    [ObsoleteAttribute("Use GetHostEntry instead")]
public static IPHostEntry GetHostByAddress(string address);
    private static IPHostEntry GetHostByAddressFromString(string address, bool parse);
    public static IPHostEntry GetHostEntry(string hostNameOrAddress);
    public static IPHostEntry GetHostEntry(IPAddress address);
    public static IPAddress[] GetHostAddresses(string hostNameOrAddress);
    [ObsoleteAttribute("Use GetHostEntry instead")]
public static IPHostEntry GetHostByName(string hostName);
    public static string GetHostName();
    [ObsoleteAttribute("Use GetHostEntry instead")]
public static IPHostEntry Resolve(string hostName);
    public static Task`1<IPAddress[]> GetHostAddressesAsync(string hostNameOrAddress);
    public static Task`1<IPHostEntry> GetHostEntryAsync(IPAddress address);
    public static Task`1<IPHostEntry> GetHostEntryAsync(string hostNameOrAddress);
}
internal class System.Net.DnsAsyncResult : object {
    private static WaitCallback internal_cb;
    private ManualResetEvent handle;
    private bool synch;
    private bool is_completed;
    private AsyncCallback callback;
    private object state;
    private IPHostEntry entry;
    private Exception exc;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public Exception Exception { get; }
    public IPHostEntry HostEntry { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    public DnsAsyncResult(AsyncCallback cb, object state);
    private static DnsAsyncResult();
    public void SetCompleted(bool synch, IPHostEntry entry, Exception e);
    public void SetCompleted(bool synch, Exception e);
    public void SetCompleted(bool synch, IPHostEntry entry);
    private static void CB(object _this);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public Exception get_Exception();
    public IPHostEntry get_HostEntry();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
}
public class System.Net.DnsEndPoint : EndPoint {
    private string m_Host;
    private int m_Port;
    private AddressFamily m_Family;
    public string Host { get; }
    public AddressFamily AddressFamily { get; }
    public int Port { get; }
    public DnsEndPoint(string host, int port);
    public DnsEndPoint(string host, int port, AddressFamily addressFamily);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string get_Host();
    public virtual AddressFamily get_AddressFamily();
    public int get_Port();
}
public class System.Net.DnsPermission : CodeAccessPermission {
    private static int version;
    private bool m_noRestriction;
    public DnsPermission(PermissionState state);
    public virtual IPermission Copy();
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Union(IPermission target);
    private bool IsEmpty();
    private DnsPermission Cast(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Net.DnsPermissionAttribute : CodeAccessSecurityAttribute {
    public DnsPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public class System.Net.DownloadDataCompletedEventArgs : AsyncCompletedEventArgs {
    private Byte[] _result;
    public Byte[] Result { get; }
    internal DownloadDataCompletedEventArgs(Byte[] result, Exception exception, bool cancelled, object userToken);
    public Byte[] get_Result();
}
public class System.Net.DownloadDataCompletedEventHandler : MulticastDelegate {
    public DownloadDataCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DownloadDataCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DownloadDataCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.DownloadProgressChangedEventArgs : ProgressChangedEventArgs {
    [CompilerGeneratedAttribute]
private long <BytesReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalBytesToReceive>k__BackingField;
    public long BytesReceived { get; }
    public long TotalBytesToReceive { get; }
    internal DownloadProgressChangedEventArgs(int progressPercentage, object userToken, long bytesReceived, long totalBytesToReceive);
    [CompilerGeneratedAttribute]
public long get_BytesReceived();
    [CompilerGeneratedAttribute]
public long get_TotalBytesToReceive();
}
public class System.Net.DownloadProgressChangedEventHandler : MulticastDelegate {
    public DownloadProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DownloadProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DownloadProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.DownloadStringCompletedEventArgs : AsyncCompletedEventArgs {
    private string _result;
    public string Result { get; }
    internal DownloadStringCompletedEventArgs(string result, Exception exception, bool cancelled, object userToken);
    public string get_Result();
}
public class System.Net.DownloadStringCompletedEventHandler : MulticastDelegate {
    public DownloadStringCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DownloadStringCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DownloadStringCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.EmptyWebProxy : object {
    private ICredentials m_credentials;
    public ICredentials Credentials { get; public set; }
    public sealed virtual Uri GetProxy(Uri uri);
    public sealed virtual bool IsBypassed(Uri uri);
    public sealed virtual ICredentials get_Credentials();
    public sealed virtual void set_Credentials(ICredentials value);
    private sealed virtual override ProxyChain System.Net.IAutoWebProxy.GetProxies(Uri destination);
}
internal enum System.Net.Endianness : Enum {
    public int value__;
    public static Endianness Network;
    public static Endianness Native;
}
public abstract class System.Net.EndPoint : object {
    public AddressFamily AddressFamily { get; }
    public virtual AddressFamily get_AddressFamily();
    public virtual SocketAddress Serialize();
    public virtual EndPoint Create(SocketAddress socketAddress);
}
internal class System.Net.EndPointListener : object {
    private HttpListener listener;
    private IPEndPoint endpoint;
    private Socket sock;
    private Hashtable prefixes;
    private ArrayList unhandled;
    private ArrayList all;
    private X509Certificate cert;
    private bool secure;
    private Dictionary`2<HttpConnection, HttpConnection> unregistered;
    internal HttpListener Listener { get; }
    public EndPointListener(HttpListener listener, IPAddress addr, int port, bool secure);
    internal HttpListener get_Listener();
    private static void Accept(Socket socket, SocketAsyncEventArgs e, Socket& accepted);
    private static void ProcessAccept(SocketAsyncEventArgs args);
    private static void OnAccept(object sender, SocketAsyncEventArgs e);
    internal void RemoveConnection(HttpConnection conn);
    public bool BindContext(HttpListenerContext context);
    public void UnbindContext(HttpListenerContext context);
    private HttpListener SearchListener(Uri uri, ListenerPrefix& prefix);
    private HttpListener MatchFromList(string host, string path, ArrayList list, ListenerPrefix& prefix);
    private void AddSpecial(ArrayList coll, ListenerPrefix prefix);
    private bool RemoveSpecial(ArrayList coll, ListenerPrefix prefix);
    private void CheckIfRemove();
    public void Close();
    public void AddPrefix(ListenerPrefix prefix, HttpListener listener);
    public void RemovePrefix(ListenerPrefix prefix, HttpListener listener);
}
internal class System.Net.EndPointManager : object {
    private static Hashtable ip_to_endpoints;
    private static EndPointManager();
    public static void AddListener(HttpListener listener);
    public static void AddPrefix(string prefix, HttpListener listener);
    private static void AddPrefixInternal(string p, HttpListener listener);
    private static EndPointListener GetEPListener(string host, int port, HttpListener listener, bool secure);
    public static void RemoveEndPoint(EndPointListener epl, IPEndPoint ep);
    public static void RemoveListener(HttpListener listener);
    public static void RemovePrefix(string prefix, HttpListener listener);
    private static void RemovePrefixInternal(string prefix, HttpListener listener);
}
public class System.Net.EndpointPermission : object {
    private static Char[] dot_char;
    private string hostname;
    private int port;
    private TransportType transport;
    private bool resolved;
    private bool hasWildcard;
    private IPAddress[] addresses;
    public string Hostname { get; }
    public int Port { get; }
    public TransportType Transport { get; }
    internal EndpointPermission(string hostname, int port, TransportType transport);
    private static EndpointPermission();
    public string get_Hostname();
    public int get_Port();
    public TransportType get_Transport();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal bool IsSubsetOf(EndpointPermission perm);
    private bool IsSubsetOf(string addr1, string addr2);
    internal EndpointPermission Intersect(EndpointPermission perm);
    private string IntersectHostname(EndpointPermission perm);
    private string Intersect(string addr1, string addr2);
    private int ToNumber(string value);
    internal void Resolve();
    internal void UndoResolve();
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal static class System.Net.ExceptionHelper : object {
    internal static NotImplementedException MethodNotImplementedException { get; }
    internal static NotImplementedException PropertyNotImplementedException { get; }
    internal static WebException TimeoutException { get; }
    internal static NotSupportedException MethodNotSupportedException { get; }
    internal static NotSupportedException PropertyNotSupportedException { get; }
    internal static WebException IsolatedException { get; }
    internal static WebException RequestAbortedException { get; }
    internal static WebException CacheEntryNotFoundException { get; }
    internal static WebException RequestProhibitedByCachePolicyException { get; }
    internal static NotImplementedException get_MethodNotImplementedException();
    internal static NotImplementedException get_PropertyNotImplementedException();
    internal static WebException get_TimeoutException();
    internal static NotSupportedException get_MethodNotSupportedException();
    internal static NotSupportedException get_PropertyNotSupportedException();
    internal static WebException get_IsolatedException();
    internal static WebException get_RequestAbortedException();
    internal static WebException get_CacheEntryNotFoundException();
    internal static WebException get_RequestProhibitedByCachePolicyException();
}
public class System.Net.FileWebRequest : WebRequest {
    private static WaitCallback s_GetRequestStreamCallback;
    private static WaitCallback s_GetResponseCallback;
    private string m_connectionGroupName;
    private long m_contentLength;
    private ICredentials m_credentials;
    private FileAccess m_fileAccess;
    private WebHeaderCollection m_headers;
    private string m_method;
    private bool m_preauthenticate;
    private IWebProxy m_proxy;
    private ManualResetEvent m_readerEvent;
    private bool m_readPending;
    private WebResponse m_response;
    private Stream m_stream;
    private bool m_syncHint;
    private int m_timeout;
    private Uri m_uri;
    private bool m_writePending;
    private bool m_writing;
    private LazyAsyncResult m_WriteAResult;
    private LazyAsyncResult m_ReadAResult;
    private int m_Aborted;
    internal bool Aborted { get; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public int Timeout { get; public set; }
    public Uri RequestUri { get; }
    public bool UseDefaultCredentials { get; public set; }
    internal FileWebRequest(Uri uri);
    [ObsoleteAttribute("Serialization is obsoleted for this type. http://go.microsoft.com/fwlink/?linkid=14202")]
protected FileWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static FileWebRequest();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal bool get_Aborted();
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual Uri get_RequestUri();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    private bool CanGetRequestStream();
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    private static void GetRequestStreamCallback(object state);
    private static void GetResponseCallback(object state);
    internal void UnblockReader();
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual void Abort();
}
internal class System.Net.FileWebRequestCreator : object {
    public sealed virtual WebRequest Create(Uri uri);
}
public class System.Net.FileWebResponse : WebResponse {
    private static int DefaultFileStreamBufferSize;
    private static string DefaultFileContentType;
    private bool m_closed;
    private long m_contentLength;
    private FileAccess m_fileAccess;
    private WebHeaderCollection m_headers;
    private Stream m_stream;
    private Uri m_uri;
    public long ContentLength { get; }
    public string ContentType { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    public Uri ResponseUri { get; }
    internal FileWebResponse(FileWebRequest request, Uri uri, FileAccess access, bool asyncHint);
    [ObsoleteAttribute("Serialization is obsoleted for this type. http://go.microsoft.com/fwlink/?linkid=14202")]
protected FileWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
    public virtual Uri get_ResponseUri();
    private void CheckDisposed();
    public virtual void Close();
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual Stream GetResponseStream();
}
internal class System.Net.FileWebStream : FileStream {
    private FileWebRequest m_request;
    public FileWebStream(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing);
    public FileWebStream(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing, int length, bool async);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult ar);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult ar);
    private void CheckError();
}
internal class System.Net.FixedSizeReadStream : WebReadStream {
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    private long position;
    public long ContentLength { get; }
    public FixedSizeReadStream(WebOperation operation, Stream innerStream, long contentLength);
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [AsyncStateMachineAttribute("System.Net.FixedSizeReadStream/<ProcessReadAsync>d__5")]
protected virtual Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
}
internal class System.Net.FtpControlStream : CommandStream {
    private Socket _dataSocket;
    private IPEndPoint _passiveEndPoint;
    private TlsStream _tlsStream;
    private StringBuilder _bannerMessage;
    private StringBuilder _welcomeMessage;
    private StringBuilder _exitMessage;
    private WeakReference _credentials;
    private string _currentTypeSetting;
    private long _contentLength;
    private DateTime _lastModified;
    private bool _dataHandshakeStarted;
    private string _loginDirectory;
    private string _establishedServerDirectory;
    private string _requestedServerDirectory;
    private Uri _responseUri;
    private FtpLoginState _loginState;
    internal FtpStatusCode StatusCode;
    internal string StatusLine;
    private static AsyncCallback s_acceptCallbackDelegate;
    private static AsyncCallback s_connectCallbackDelegate;
    private static AsyncCallback s_SSLHandshakeCallback;
    internal NetworkCredential Credentials { get; internal set; }
    internal long ContentLength { get; }
    internal DateTime LastModified { get; }
    internal Uri ResponseUri { get; }
    internal string BannerMessage { get; }
    internal string WelcomeMessage { get; }
    internal string ExitMessage { get; }
    internal FtpControlStream(TcpClient client);
    private static FtpControlStream();
    internal NetworkCredential get_Credentials();
    internal void set_Credentials(NetworkCredential value);
    internal void AbortConnect();
    private static void AcceptCallback(IAsyncResult asyncResult);
    private static void ConnectCallback(IAsyncResult asyncResult);
    private static void SSLHandshakeCallback(IAsyncResult asyncResult);
    private PipelineInstruction QueueOrCreateFtpDataStream(Stream& stream);
    protected virtual void ClearState();
    protected virtual PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream);
    protected virtual PipelineEntry[] BuildCommandsList(WebRequest req);
    private PipelineInstruction QueueOrCreateDataConection(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream, Boolean& isSocketReady);
    private static void GetPathInfo(GetPathOption pathOption, Uri uri, String& path, String& directory, String& filename);
    private string FormatAddress(IPAddress address, int Port);
    private string FormatAddressV6(IPAddress address, int port);
    internal long get_ContentLength();
    internal DateTime get_LastModified();
    internal Uri get_ResponseUri();
    internal string get_BannerMessage();
    internal string get_WelcomeMessage();
    internal string get_ExitMessage();
    private long GetContentLengthFrom213Response(string responseString);
    private DateTime GetLastModifiedFrom213Response(string str);
    private void TryUpdateResponseUri(string str, FtpWebRequest request);
    private void TryUpdateContentLength(string str);
    private string GetLoginDirectory(string str);
    private int GetPortV4(string responseString);
    private int GetPortV6(string responseString);
    private void CreateFtpListenerSocket(FtpWebRequest request);
    private string GetPortCommandLine(FtpWebRequest request);
    private string FormatFtpCommand(string command, string parameter);
    protected Socket CreateFtpDataSocket(FtpWebRequest request, Socket templateSocket);
    protected virtual bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength);
    private TriState IsFtpDataStreamWriteable();
}
internal class System.Net.FtpDataStream : Stream {
    private FtpWebRequest _request;
    private NetworkStream _networkStream;
    private bool _writeable;
    private bool _readable;
    private bool _isFullyRead;
    private bool _closing;
    private static int DefaultCloseTimeout;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal FtpDataStream(NetworkStream networkStream, FtpWebRequest request, TriState writeOnly);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    private void CheckError();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    private void AsyncReadCallback(IAsyncResult ar);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult ar);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual void SetLength(long value);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    internal void SetSocketTimeoutOption(int timeout);
}
internal enum System.Net.FtpLoginState : Enum {
    public byte value__;
    public static FtpLoginState NotLoggedIn;
    public static FtpLoginState LoggedIn;
    public static FtpLoginState LoggedInButNeedsRelogin;
    public static FtpLoginState ReloginFailed;
}
[FlagsAttribute]
internal enum System.Net.FtpMethodFlags : Enum {
    public int value__;
    public static FtpMethodFlags None;
    public static FtpMethodFlags IsDownload;
    public static FtpMethodFlags IsUpload;
    public static FtpMethodFlags TakesParameter;
    public static FtpMethodFlags MayTakeParameter;
    public static FtpMethodFlags DoesNotTakeParameter;
    public static FtpMethodFlags ParameterIsDirectory;
    public static FtpMethodFlags ShouldParseForResponseUri;
    public static FtpMethodFlags HasHttpCommand;
    public static FtpMethodFlags MustChangeWorkingDirectoryToPath;
}
internal class System.Net.FtpMethodInfo : object {
    internal string Method;
    internal FtpOperation Operation;
    internal FtpMethodFlags Flags;
    internal string HttpCommand;
    private static FtpMethodInfo[] s_knownMethodInfo;
    internal bool IsCommandOnly { get; }
    internal bool IsUpload { get; }
    internal bool IsDownload { get; }
    internal bool ShouldParseForResponseUri { get; }
    internal FtpMethodInfo(string method, FtpOperation operation, FtpMethodFlags flags, string httpCommand);
    private static FtpMethodInfo();
    internal bool HasFlag(FtpMethodFlags flags);
    internal bool get_IsCommandOnly();
    internal bool get_IsUpload();
    internal bool get_IsDownload();
    internal bool get_ShouldParseForResponseUri();
    internal static FtpMethodInfo GetMethodInfo(string method);
}
internal enum System.Net.FtpOperation : Enum {
    public int value__;
    public static FtpOperation DownloadFile;
    public static FtpOperation ListDirectory;
    public static FtpOperation ListDirectoryDetails;
    public static FtpOperation UploadFile;
    public static FtpOperation UploadFileUnique;
    public static FtpOperation AppendFile;
    public static FtpOperation DeleteFile;
    public static FtpOperation GetDateTimestamp;
    public static FtpOperation GetFileSize;
    public static FtpOperation Rename;
    public static FtpOperation MakeDirectory;
    public static FtpOperation RemoveDirectory;
    public static FtpOperation PrintWorkingDirectory;
    public static FtpOperation Other;
}
public enum System.Net.FtpStatusCode : Enum {
    public int value__;
    public static FtpStatusCode Undefined;
    public static FtpStatusCode RestartMarker;
    public static FtpStatusCode ServiceTemporarilyNotAvailable;
    public static FtpStatusCode DataAlreadyOpen;
    public static FtpStatusCode OpeningData;
    public static FtpStatusCode CommandOK;
    public static FtpStatusCode CommandExtraneous;
    public static FtpStatusCode DirectoryStatus;
    public static FtpStatusCode FileStatus;
    public static FtpStatusCode SystemType;
    public static FtpStatusCode SendUserCommand;
    public static FtpStatusCode ClosingControl;
    public static FtpStatusCode ClosingData;
    public static FtpStatusCode EnteringPassive;
    public static FtpStatusCode LoggedInProceed;
    public static FtpStatusCode ServerWantsSecureSession;
    public static FtpStatusCode FileActionOK;
    public static FtpStatusCode PathnameCreated;
    public static FtpStatusCode SendPasswordCommand;
    public static FtpStatusCode NeedLoginAccount;
    public static FtpStatusCode FileCommandPending;
    public static FtpStatusCode ServiceNotAvailable;
    public static FtpStatusCode CantOpenData;
    public static FtpStatusCode ConnectionClosed;
    public static FtpStatusCode ActionNotTakenFileUnavailableOrBusy;
    public static FtpStatusCode ActionAbortedLocalProcessingError;
    public static FtpStatusCode ActionNotTakenInsufficientSpace;
    public static FtpStatusCode CommandSyntaxError;
    public static FtpStatusCode ArgumentSyntaxError;
    public static FtpStatusCode CommandNotImplemented;
    public static FtpStatusCode BadCommandSequence;
    public static FtpStatusCode NotLoggedIn;
    public static FtpStatusCode AccountNeeded;
    public static FtpStatusCode ActionNotTakenFileUnavailable;
    public static FtpStatusCode ActionAbortedUnknownPageType;
    public static FtpStatusCode FileActionAborted;
    public static FtpStatusCode ActionNotTakenFilenameNotAllowed;
}
public class System.Net.FtpWebRequest : WebRequest {
    private object _syncObject;
    private ICredentials _authInfo;
    private Uri _uri;
    private FtpMethodInfo _methodInfo;
    private string _renameTo;
    private bool _getRequestStreamStarted;
    private bool _getResponseStarted;
    private DateTime _startTime;
    private int _timeout;
    private int _remainingTimeout;
    private long _contentLength;
    private long _contentOffset;
    private X509CertificateCollection _clientCertificates;
    private bool _passive;
    private bool _binary;
    private string _connectionGroupName;
    private ServicePoint _servicePoint;
    private bool _async;
    private bool _aborted;
    private bool _timedOut;
    private Exception _exception;
    private Queue _timerQueue;
    private Callback _timerCallback;
    private bool _enableSsl;
    private FtpControlStream _connection;
    private Stream _stream;
    private RequestStage _requestStage;
    private bool _onceFailed;
    private WebHeaderCollection _ftpRequestHeaders;
    private FtpWebResponse _ftpWebResponse;
    private int _readWriteTimeout;
    private ContextAwareResult _writeAsyncResult;
    private LazyAsyncResult _readAsyncResult;
    private LazyAsyncResult _requestCompleteAsyncResult;
    private static NetworkCredential s_defaultFtpNetworkCredential;
    private static int s_DefaultTimeout;
    private static Queue s_DefaultTimerQueue;
    internal FtpMethodInfo MethodInfo { get; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public string Method { get; public set; }
    public string RenameTo { get; public set; }
    public ICredentials Credentials { get; public set; }
    public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    internal int RemainingTimeout { get; }
    public int ReadWriteTimeout { get; public set; }
    public long ContentOffset { get; public set; }
    public long ContentLength { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public ServicePoint ServicePoint { get; }
    internal bool Aborted { get; }
    private Queue TimerQueue { get; }
    public bool KeepAlive { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public bool UseBinary { get; public set; }
    public bool UsePassive { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public bool EnableSsl { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public string ContentType { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public bool PreAuthenticate { get; public set; }
    private bool InUse { get; }
    internal FtpWebRequest(Uri uri);
    private static FtpWebRequest();
    internal FtpMethodInfo get_MethodInfo();
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public string get_RenameTo();
    public void set_RenameTo(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    internal int get_RemainingTimeout();
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public long get_ContentOffset();
    public void set_ContentOffset(long value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public ServicePoint get_ServicePoint();
    internal bool get_Aborted();
    public virtual WebResponse GetResponse();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual Stream GetRequestStream();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    private void SubmitRequest(bool isAsync);
    private Exception TranslateConnectException(Exception e);
    [AsyncStateMachineAttribute("System.Net.FtpWebRequest/<CreateConnectionAsync>d__86")]
private void CreateConnectionAsync();
    private FtpControlStream CreateConnection();
    private Stream TimedSubmitRequestHelper(bool isAsync);
    private void TimerCallback(Timer timer, int timeNoticed, object context);
    private Queue get_TimerQueue();
    private bool AttemptedRecovery(Exception e);
    private void SetException(Exception exception);
    private void CheckError();
    internal void RequestCallback(object obj);
    private void SyncRequestCallback(object obj);
    private void AsyncRequestCallback(object obj);
    private RequestStage FinishRequestStage(RequestStage stage);
    public virtual void Abort();
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public bool get_UseBinary();
    public void set_UseBinary(bool value);
    public bool get_UsePassive();
    public void set_UsePassive(bool value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    private bool get_InUse();
    private void EnsureFtpWebResponse(Exception exception);
    internal void DataStreamClosed(CloseExState closeState);
}
internal class System.Net.FtpWebRequestCreator : object {
    public sealed virtual WebRequest Create(Uri uri);
}
public class System.Net.FtpWebResponse : WebResponse {
    internal Stream _responseStream;
    private long _contentLength;
    private Uri _responseUri;
    private FtpStatusCode _statusCode;
    private string _statusLine;
    private WebHeaderCollection _ftpRequestHeaders;
    private DateTime _lastModified;
    private string _bannerMessage;
    private string _welcomeMessage;
    private string _exitMessage;
    public long ContentLength { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    public Uri ResponseUri { get; }
    public FtpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    public DateTime LastModified { get; }
    public string BannerMessage { get; }
    public string WelcomeMessage { get; }
    public string ExitMessage { get; }
    internal FtpWebResponse(Stream responseStream, long contentLength, Uri responseUri, FtpStatusCode statusCode, string statusLine, DateTime lastModified, string bannerMessage, string welcomeMessage, string exitMessage);
    internal void UpdateStatus(FtpStatusCode statusCode, string statusLine, string exitMessage);
    public virtual Stream GetResponseStream();
    internal void SetResponseStream(Stream stream);
    public virtual void Close();
    public virtual long get_ContentLength();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
    public virtual Uri get_ResponseUri();
    public FtpStatusCode get_StatusCode();
    public string get_StatusDescription();
    public DateTime get_LastModified();
    public string get_BannerMessage();
    public string get_WelcomeMessage();
    public string get_ExitMessage();
}
internal static class System.Net.GlobalLog : object {
    private static BaseLoggingObject Logobject;
    internal static ThreadKinds CurrentThreadKind { get; }
    private static GlobalLog();
    [ReliabilityContractAttribute("1", "0")]
private static BaseLoggingObject LoggingInitialize();
    internal static ThreadKinds get_CurrentThreadKind();
    [ConditionalAttribute("DEBUG")]
[ReliabilityContractAttribute("1", "0")]
internal static void SetThreadSource(ThreadKinds source);
    [ReliabilityContractAttribute("1", "0")]
[ConditionalAttribute("DEBUG")]
internal static void ThreadContract(ThreadKinds kind, string errorMsg);
    [ReliabilityContractAttribute("1", "0")]
[ConditionalAttribute("DEBUG")]
internal static void ThreadContract(ThreadKinds kind, ThreadKinds allowedSources, string errorMsg);
    [ConditionalAttribute("TRAVE")]
public static void AddToArray(string msg);
    [ConditionalAttribute("TRAVE")]
public static void Ignore(object msg);
    [ReliabilityContractAttribute("1", "0")]
[ConditionalAttribute("TRAVE")]
public static void Print(string msg);
    [ConditionalAttribute("TRAVE")]
public static void PrintHex(string msg, object value);
    [ConditionalAttribute("TRAVE")]
public static void Enter(string func);
    [ConditionalAttribute("TRAVE")]
public static void Enter(string func, string parms);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("_FORCE_ASSERTS")]
[ReliabilityContractAttribute("1", "0")]
public static void Assert(bool condition, string messageFormat, Object[] data);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("_FORCE_ASSERTS")]
[ReliabilityContractAttribute("1", "0")]
public static void Assert(string message);
    [ConditionalAttribute("DEBUG")]
[ReliabilityContractAttribute("1", "0")]
[ConditionalAttribute("_FORCE_ASSERTS")]
public static void Assert(string message, string detailMessage);
    [ConditionalAttribute("TRAVE")]
public static void LeaveException(string func, Exception exception);
    [ConditionalAttribute("TRAVE")]
public static void Leave(string func);
    [ConditionalAttribute("TRAVE")]
public static void Leave(string func, string result);
    [ConditionalAttribute("TRAVE")]
public static void Leave(string func, int returnval);
    [ConditionalAttribute("TRAVE")]
public static void Leave(string func, bool returnval);
    [ConditionalAttribute("TRAVE")]
public static void DumpArray();
    [ConditionalAttribute("TRAVE")]
public static void Dump(Byte[] buffer);
    [ConditionalAttribute("TRAVE")]
public static void Dump(Byte[] buffer, int length);
    [ConditionalAttribute("TRAVE")]
public static void Dump(Byte[] buffer, int offset, int length);
    [ConditionalAttribute("TRAVE")]
public static void Dump(IntPtr buffer, int offset, int length);
}
[ObsoleteAttribute("This class has been deprecated. Please use WebRequest.DefaultWebProxy instead to access and set the global default proxy. Use 'null' instead of GetEmptyWebProxy. https://go.microsoft.com/fwlink/?linkid=14202")]
public class System.Net.GlobalProxySelection : object {
    public static IWebProxy Select { get; public set; }
    public static IWebProxy get_Select();
    public static void set_Select(IWebProxy value);
    public static IWebProxy GetEmptyWebProxy();
}
internal static class System.Net.GlobalSSPI : object {
    internal static SSPIInterface SSPIAuth;
    internal static SSPIInterface SSPISecureChannel;
    private static GlobalSSPI();
}
internal class System.Net.HeaderInfo : object {
    internal bool IsRequestRestricted;
    internal bool IsResponseRestricted;
    internal HeaderParser Parser;
    internal string HeaderName;
    internal bool AllowMultiValues;
    internal HeaderInfo(string name, bool requestRestricted, bool responseRestricted, bool multi, HeaderParser p);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.HeaderInfoTable : object {
    private static Hashtable HeaderHashTable;
    private static HeaderInfo UnknownHeaderInfo;
    private static HeaderParser SingleParser;
    private static HeaderParser MultiParser;
    internal HeaderInfo Item { get; }
    private static HeaderInfoTable();
    private static String[] ParseSingleValue(string value);
    private static String[] ParseMultiValue(string value);
    internal HeaderInfo get_Item(string name);
}
internal class System.Net.HeaderParser : MulticastDelegate {
    public HeaderParser(object object, IntPtr method);
    public virtual String[] Invoke(string value);
    public virtual IAsyncResult BeginInvoke(string value, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal class System.Net.HeaderVariantInfo : ValueType {
    private string m_name;
    private CookieVariant m_variant;
    internal string Name { get; }
    internal CookieVariant Variant { get; }
    internal HeaderVariantInfo(string name, CookieVariant variant);
    internal string get_Name();
    internal CookieVariant get_Variant();
}
internal class System.Net.hostent : ValueType {
    public IntPtr h_name;
    public IntPtr h_aliases;
    public short h_addrtype;
    public short h_length;
    public IntPtr h_addr_list;
}
internal class System.Net.HostHeaderString : object {
    private bool m_Converted;
    private string m_String;
    private Byte[] m_Bytes;
    internal string String { get; internal set; }
    internal int ByteCount { get; }
    internal Byte[] Bytes { get; }
    internal HostHeaderString(string s);
    private void Init(string s);
    private void Convert();
    internal string get_String();
    internal void set_String(string value);
    internal int get_ByteCount();
    internal Byte[] get_Bytes();
    internal void Copy(Byte[] destBytes, int destByteIndex);
}
internal abstract class System.Net.Http.DelegatingStream : Stream {
    private Stream _innerStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public bool CanTimeout { get; }
    public int WriteTimeout { get; public set; }
    protected DelegatingStream(Stream innerStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual bool get_CanTimeout();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
}
internal class System.Net.HttpAbortDelegate : MulticastDelegate {
    public HttpAbortDelegate(object object, IntPtr method);
    public virtual bool Invoke(HttpWebRequest request, WebException webException);
    public virtual IAsyncResult BeginInvoke(HttpWebRequest request, WebException webException, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal enum System.Net.HttpBehaviour : Enum {
    public byte value__;
    public static HttpBehaviour Unknown;
    public static HttpBehaviour HTTP10;
    public static HttpBehaviour HTTP11PartiallyCompliant;
    public static HttpBehaviour HTTP11;
}
internal class System.Net.HttpConnection : object {
    private static AsyncCallback onread_cb;
    private static int BufferSize;
    private Socket sock;
    private Stream stream;
    private EndPointListener epl;
    private MemoryStream ms;
    private Byte[] buffer;
    private HttpListenerContext context;
    private StringBuilder current_line;
    private ListenerPrefix prefix;
    private RequestStream i_stream;
    private ResponseStream o_stream;
    private bool chunked;
    private int reuses;
    private bool context_bound;
    private bool secure;
    private X509Certificate cert;
    private int s_timeout;
    private Timer timer;
    private IPEndPoint local_ep;
    private HttpListener last_listener;
    private Int32[] client_cert_errors;
    private X509Certificate2 client_cert;
    private SslStream ssl_stream;
    private InputState input_state;
    private LineState line_state;
    private int position;
    internal SslStream SslStream { get; }
    internal Int32[] ClientCertificateErrors { get; }
    internal X509Certificate2 ClientCertificate { get; }
    public bool IsClosed { get; }
    public int Reuses { get; }
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public bool IsSecure { get; }
    public ListenerPrefix Prefix { get; public set; }
    public HttpConnection(Socket sock, EndPointListener epl, bool secure, X509Certificate cert);
    private static HttpConnection();
    internal SslStream get_SslStream();
    internal Int32[] get_ClientCertificateErrors();
    internal X509Certificate2 get_ClientCertificate();
    private void Init();
    public bool get_IsClosed();
    public int get_Reuses();
    public IPEndPoint get_LocalEndPoint();
    public IPEndPoint get_RemoteEndPoint();
    public bool get_IsSecure();
    public ListenerPrefix get_Prefix();
    public void set_Prefix(ListenerPrefix value);
    private void OnTimeout(object unused);
    public void BeginReadRequest();
    public RequestStream GetRequestStream(bool chunked, long contentlength);
    public ResponseStream GetResponseStream();
    private static void OnRead(IAsyncResult ares);
    private void OnReadInternal(IAsyncResult ares);
    private void RemoveConnection();
    private bool ProcessInput(MemoryStream ms);
    private string ReadLine(Byte[] buffer, int offset, int len, Int32& used);
    public void SendError(string msg, int status);
    public void SendError();
    private void Unbind();
    public void Close();
    private void CloseSocket();
    internal void Close(bool force_close);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__24_0(object t, X509Certificate c, X509Chain ch, SslPolicyErrors e);
}
public class System.Net.HttpContinueDelegate : MulticastDelegate {
    public HttpContinueDelegate(object object, IntPtr method);
    public virtual void Invoke(int StatusCode, WebHeaderCollection httpHeaders);
    public virtual IAsyncResult BeginInvoke(int StatusCode, WebHeaderCollection httpHeaders, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Net.HttpDateParse : object {
    private static int BASE_DEC;
    private static int DATE_INDEX_DAY_OF_WEEK;
    private static int DATE_1123_INDEX_DAY;
    private static int DATE_1123_INDEX_MONTH;
    private static int DATE_1123_INDEX_YEAR;
    private static int DATE_1123_INDEX_HRS;
    private static int DATE_1123_INDEX_MINS;
    private static int DATE_1123_INDEX_SECS;
    private static int DATE_ANSI_INDEX_MONTH;
    private static int DATE_ANSI_INDEX_DAY;
    private static int DATE_ANSI_INDEX_HRS;
    private static int DATE_ANSI_INDEX_MINS;
    private static int DATE_ANSI_INDEX_SECS;
    private static int DATE_ANSI_INDEX_YEAR;
    private static int DATE_INDEX_TZ;
    private static int DATE_INDEX_LAST;
    private static int MAX_FIELD_DATE_ENTRIES;
    private static int DATE_TOKEN_JANUARY;
    private static int DATE_TOKEN_FEBRUARY;
    private static int DATE_TOKEN_Microsoft;
    private static int DATE_TOKEN_APRIL;
    private static int DATE_TOKEN_MAY;
    private static int DATE_TOKEN_JUNE;
    private static int DATE_TOKEN_JULY;
    private static int DATE_TOKEN_AUGUST;
    private static int DATE_TOKEN_SEPTEMBER;
    private static int DATE_TOKEN_OCTOBER;
    private static int DATE_TOKEN_NOVEMBER;
    private static int DATE_TOKEN_DECEMBER;
    private static int DATE_TOKEN_LAST_MONTH;
    private static int DATE_TOKEN_SUNDAY;
    private static int DATE_TOKEN_MONDAY;
    private static int DATE_TOKEN_TUESDAY;
    private static int DATE_TOKEN_WEDNESDAY;
    private static int DATE_TOKEN_THURSDAY;
    private static int DATE_TOKEN_FRIDAY;
    private static int DATE_TOKEN_SATURDAY;
    private static int DATE_TOKEN_LAST_DAY;
    private static int DATE_TOKEN_GMT;
    private static int DATE_TOKEN_LAST;
    private static int DATE_TOKEN_ERROR;
    private static char MAKE_UPPER(char c);
    private static int MapDayMonthToDword(Char[] lpszDay, int index);
    public static bool ParseHttpDate(string DateString, DateTime& dtOut);
}
internal static class System.Net.HttpKnownHeaderNames : object {
    public static string CacheControl;
    public static string Connection;
    public static string Date;
    public static string KeepAlive;
    public static string Pragma;
    public static string ProxyConnection;
    public static string Trailer;
    public static string TransferEncoding;
    public static string Upgrade;
    public static string Via;
    public static string Warning;
    public static string ContentLength;
    public static string ContentType;
    public static string ContentDisposition;
    public static string ContentEncoding;
    public static string ContentLanguage;
    public static string ContentLocation;
    public static string ContentRange;
    public static string Expires;
    public static string LastModified;
    public static string Age;
    public static string Location;
    public static string ProxyAuthenticate;
    public static string RetryAfter;
    public static string Server;
    public static string SetCookie;
    public static string SetCookie2;
    public static string Vary;
    public static string WWWAuthenticate;
    public static string Accept;
    public static string AcceptCharset;
    public static string AcceptEncoding;
    public static string AcceptLanguage;
    public static string Authorization;
    public static string Cookie;
    public static string Cookie2;
    public static string Expect;
    public static string From;
    public static string Host;
    public static string IfMatch;
    public static string IfModifiedSince;
    public static string IfNoneMatch;
    public static string IfRange;
    public static string IfUnmodifiedSince;
    public static string MaxForwards;
    public static string ProxyAuthorization;
    public static string Referer;
    public static string Range;
    public static string UserAgent;
    public static string ContentMD5;
    public static string ETag;
    public static string TE;
    public static string Allow;
    public static string AcceptRanges;
    public static string P3P;
    public static string XPoweredBy;
    public static string XAspNetVersion;
    public static string SecWebSocketKey;
    public static string SecWebSocketExtensions;
    public static string SecWebSocketAccept;
    public static string Origin;
    public static string SecWebSocketProtocol;
    public static string SecWebSocketVersion;
}
public class System.Net.HttpListener : object {
    private MonoTlsProvider tlsProvider;
    private MonoTlsSettings tlsSettings;
    private X509Certificate certificate;
    private AuthenticationSchemes auth_schemes;
    private HttpListenerPrefixCollection prefixes;
    private AuthenticationSchemeSelector auth_selector;
    private string realm;
    private bool ignore_write_exceptions;
    private bool unsafe_ntlm_auth;
    private bool listening;
    private bool disposed;
    private object _internalLock;
    private Hashtable registry;
    private ArrayList ctx_queue;
    private ArrayList wait_queue;
    private Hashtable connections;
    private ServiceNameStore defaultServiceNames;
    private ExtendedProtectionPolicy extendedProtectionPolicy;
    private ExtendedProtectionSelector extendedProtectionSelectorDelegate;
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; public set; }
    public ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; public set; }
    public bool IgnoreWriteExceptions { get; public set; }
    public bool IsListening { get; }
    public static bool IsSupported { get; }
    public HttpListenerPrefixCollection Prefixes { get; }
    [MonoTODOAttribute]
public HttpListenerTimeoutManager TimeoutManager { get; }
    [MonoTODOAttribute("not used anywhere in the implementation")]
public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    public ServiceNameCollection DefaultServiceNames { get; }
    public string Realm { get; public set; }
    [MonoTODOAttribute("Support for NTLM needs some loving.")]
public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    internal HttpListener(X509Certificate certificate, MonoTlsProvider tlsProvider, MonoTlsSettings tlsSettings);
    internal X509Certificate LoadCertificateAndKey(IPAddress addr, int port);
    internal SslStream CreateSslStream(Stream innerStream, bool ownsStream, RemoteCertificateValidationCallback callback);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate();
    public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value);
    public ExtendedProtectionSelector get_ExtendedProtectionSelectorDelegate();
    public void set_ExtendedProtectionSelectorDelegate(ExtendedProtectionSelector value);
    public bool get_IgnoreWriteExceptions();
    public void set_IgnoreWriteExceptions(bool value);
    public bool get_IsListening();
    public static bool get_IsSupported();
    public HttpListenerPrefixCollection get_Prefixes();
    public HttpListenerTimeoutManager get_TimeoutManager();
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    public ServiceNameCollection get_DefaultServiceNames();
    public string get_Realm();
    public void set_Realm(string value);
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    public void Abort();
    public void Close();
    private void Close(bool force);
    private void Cleanup(bool close_existing);
    public IAsyncResult BeginGetContext(AsyncCallback callback, object state);
    public HttpListenerContext EndGetContext(IAsyncResult asyncResult);
    internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerContext context);
    public HttpListenerContext GetContext();
    public void Start();
    public void Stop();
    private sealed virtual override void System.IDisposable.Dispose();
    public Task`1<HttpListenerContext> GetContextAsync();
    internal void CheckDisposed();
    private HttpListenerContext GetContextFromQueue();
    internal void RegisterContext(HttpListenerContext context);
    internal void UnregisterContext(HttpListenerContext context);
    internal void AddConnection(HttpConnection cnc);
    internal void RemoveConnection(HttpConnection cnc);
}
public class System.Net.HttpListenerBasicIdentity : GenericIdentity {
    private string password;
    public string Password { get; }
    public HttpListenerBasicIdentity(string username, string password);
    public virtual string get_Password();
}
public class System.Net.HttpListenerContext : object {
    private HttpListenerRequest request;
    private HttpListenerResponse response;
    private IPrincipal user;
    private HttpConnection cnc;
    private string error;
    private int err_status;
    internal HttpListener Listener;
    internal int ErrorStatus { get; internal set; }
    internal string ErrorMessage { get; internal set; }
    internal bool HaveError { get; }
    internal HttpConnection Connection { get; }
    public HttpListenerRequest Request { get; }
    public HttpListenerResponse Response { get; }
    public IPrincipal User { get; }
    internal HttpListenerContext(HttpConnection cnc);
    internal int get_ErrorStatus();
    internal void set_ErrorStatus(int value);
    internal string get_ErrorMessage();
    internal void set_ErrorMessage(string value);
    internal bool get_HaveError();
    internal HttpConnection get_Connection();
    public HttpListenerRequest get_Request();
    public HttpListenerResponse get_Response();
    public IPrincipal get_User();
    internal void ParseAuthentication(AuthenticationSchemes expectedSchemes);
    internal IPrincipal ParseBasicAuthentication(string authData);
    [MonoTODOAttribute]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol);
    [MonoTODOAttribute]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, TimeSpan keepAliveInterval);
    [MonoTODOAttribute]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval);
    [MonoTODOAttribute]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
}
public class System.Net.HttpListenerException : Win32Exception {
    public int ErrorCode { get; }
    public HttpListenerException(int errorCode);
    public HttpListenerException(int errorCode, string message);
    protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
public class System.Net.HttpListenerPrefixCollection : object {
    private List`1<string> prefixes;
    private HttpListener listener;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    internal HttpListenerPrefixCollection(HttpListener listener);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsSynchronized();
    public sealed virtual void Add(string uriPrefix);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(string uriPrefix);
    public sealed virtual void CopyTo(String[] array, int offset);
    public void CopyTo(Array array, int offset);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Remove(string uriPrefix);
}
public class System.Net.HttpListenerRequest : object {
    private String[] accept_types;
    private Encoding content_encoding;
    private long content_length;
    private bool cl_set;
    private CookieCollection cookies;
    private WebHeaderCollection headers;
    private string method;
    private Stream input_stream;
    private Version version;
    private NameValueCollection query_string;
    private string raw_url;
    private Uri url;
    private Uri referrer;
    private String[] user_languages;
    private HttpListenerContext context;
    private bool is_chunked;
    private bool ka_set;
    private bool keep_alive;
    private GCCDelegate gcc_delegate;
    private static Byte[] _100continue;
    private static Char[] separators;
    public String[] AcceptTypes { get; }
    public int ClientCertificateError { get; }
    public Encoding ContentEncoding { get; }
    public long ContentLength64 { get; }
    public string ContentType { get; }
    public CookieCollection Cookies { get; }
    public bool HasEntityBody { get; }
    public NameValueCollection Headers { get; }
    public string HttpMethod { get; }
    public Stream InputStream { get; }
    [MonoTODOAttribute("Always returns false")]
public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public bool KeepAlive { get; }
    public IPEndPoint LocalEndPoint { get; }
    public Version ProtocolVersion { get; }
    public NameValueCollection QueryString { get; }
    public string RawUrl { get; }
    public IPEndPoint RemoteEndPoint { get; }
    [MonoTODOAttribute("Always returns Guid.Empty")]
public Guid RequestTraceIdentifier { get; }
    public Uri Url { get; }
    public Uri UrlReferrer { get; }
    public string UserAgent { get; }
    public string UserHostAddress { get; }
    public string UserHostName { get; }
    public String[] UserLanguages { get; }
    [MonoTODOAttribute]
public string ServiceName { get; }
    public TransportContext TransportContext { get; }
    [MonoTODOAttribute]
public bool IsWebSocketRequest { get; }
    internal HttpListenerRequest(HttpListenerContext context);
    private static HttpListenerRequest();
    internal void SetRequestLine(string req);
    private void CreateQueryString(string query);
    private static bool MaybeUri(string s);
    private static bool IsPredefinedScheme(string scheme);
    internal bool FinishInitialization();
    internal static string Unquote(string str);
    internal void AddHeader(string header);
    internal bool FlushInput();
    public String[] get_AcceptTypes();
    public int get_ClientCertificateError();
    public Encoding get_ContentEncoding();
    public long get_ContentLength64();
    public string get_ContentType();
    public CookieCollection get_Cookies();
    public bool get_HasEntityBody();
    public NameValueCollection get_Headers();
    public string get_HttpMethod();
    public Stream get_InputStream();
    public bool get_IsAuthenticated();
    public bool get_IsLocal();
    public bool get_IsSecureConnection();
    public bool get_KeepAlive();
    public IPEndPoint get_LocalEndPoint();
    public Version get_ProtocolVersion();
    public NameValueCollection get_QueryString();
    public string get_RawUrl();
    public IPEndPoint get_RemoteEndPoint();
    public Guid get_RequestTraceIdentifier();
    public Uri get_Url();
    public Uri get_UrlReferrer();
    public string get_UserAgent();
    public string get_UserHostAddress();
    public string get_UserHostName();
    public String[] get_UserLanguages();
    public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state);
    public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult);
    public X509Certificate2 GetClientCertificate();
    public string get_ServiceName();
    public TransportContext get_TransportContext();
    public bool get_IsWebSocketRequest();
    public Task`1<X509Certificate2> GetClientCertificateAsync();
}
internal class System.Net.HttpListenerRequestUriBuilder : object {
    private static bool useCookedRequestUrl;
    private static Encoding utf8Encoding;
    private static Encoding ansiEncoding;
    private string rawUri;
    private string cookedUriScheme;
    private string cookedUriHost;
    private string cookedUriPath;
    private string cookedUriQuery;
    private StringBuilder requestUriString;
    private List`1<byte> rawOctets;
    private string rawPath;
    private Uri requestUri;
    private static HttpListenerRequestUriBuilder();
    private HttpListenerRequestUriBuilder(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    public static Uri GetRequestUri(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    private Uri Build();
    private void BuildRequestUriUsingCookedPath();
    private void BuildRequestUriUsingRawPath();
    private static Encoding GetEncoding(EncodingType type);
    private ParsingResult BuildRequestUriUsingRawPath(Encoding encoding);
    private ParsingResult ParseRawPath(Encoding encoding);
    private bool AppendUnicodeCodePointValuePercentEncoded(string codePoint);
    private bool AddPercentEncodedOctetToRawOctetsList(Encoding encoding, string escapedCharacter);
    private bool EmptyDecodeAndAppendRawOctetsList(Encoding encoding);
    private static void AppendOctetsPercentEncoded(StringBuilder target, IEnumerable`1<byte> octets);
    private static string GetOctetsAsString(IEnumerable`1<byte> octets);
    private static string GetPath(string uriString);
    private static string AddSlashToAsteriskOnlyPath(string path);
    private void LogWarning(string methodName, string message, Object[] args);
}
public class System.Net.HttpListenerResponse : object {
    private bool disposed;
    private Encoding content_encoding;
    private long content_length;
    private bool cl_set;
    private string content_type;
    private CookieCollection cookies;
    private WebHeaderCollection headers;
    private bool keep_alive;
    private ResponseStream output_stream;
    private Version version;
    private string location;
    private int status_code;
    private string status_description;
    private bool chunked;
    private HttpListenerContext context;
    internal bool HeadersSent;
    internal object headers_lock;
    private bool force_close_chunked;
    private static string tspecials;
    internal bool ForceCloseChunked { get; }
    public Encoding ContentEncoding { get; public set; }
    public long ContentLength64 { get; public set; }
    public string ContentType { get; public set; }
    public CookieCollection Cookies { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public bool KeepAlive { get; public set; }
    public Stream OutputStream { get; }
    public Version ProtocolVersion { get; public set; }
    public string RedirectLocation { get; public set; }
    public bool SendChunked { get; public set; }
    public int StatusCode { get; public set; }
    public string StatusDescription { get; public set; }
    internal HttpListenerResponse(HttpListenerContext context);
    private static HttpListenerResponse();
    internal bool get_ForceCloseChunked();
    public Encoding get_ContentEncoding();
    public void set_ContentEncoding(Encoding value);
    public long get_ContentLength64();
    public void set_ContentLength64(long value);
    public string get_ContentType();
    public void set_ContentType(string value);
    public CookieCollection get_Cookies();
    public void set_Cookies(CookieCollection value);
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public Stream get_OutputStream();
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public string get_RedirectLocation();
    public void set_RedirectLocation(string value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    public int get_StatusCode();
    public void set_StatusCode(int value);
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    private sealed virtual override void System.IDisposable.Dispose();
    public void Abort();
    public void AddHeader(string name, string value);
    public void AppendCookie(Cookie cookie);
    public void AppendHeader(string name, string value);
    private void Close(bool force);
    public void Close();
    public void Close(Byte[] responseEntity, bool willBlock);
    public void CopyFrom(HttpListenerResponse templateResponse);
    public void Redirect(string url);
    private bool FindCookie(Cookie cookie);
    internal void SendHeaders(bool closing, MemoryStream ms);
    private static string FormatHeaders(WebHeaderCollection headers);
    private static string CookieToClientString(Cookie cookie);
    private static string QuotedString(Cookie cookie, string value);
    private static bool IsToken(string value);
    public void SetCookie(Cookie cookie);
}
public class System.Net.HttpListenerTimeoutManager : object {
    [MonoTODOAttribute]
public TimeSpan EntityBody { get; public set; }
    [MonoTODOAttribute]
public TimeSpan DrainEntityBody { get; public set; }
    [MonoTODOAttribute]
public TimeSpan RequestQueue { get; public set; }
    [MonoTODOAttribute]
public TimeSpan IdleConnection { get; public set; }
    [MonoTODOAttribute]
public TimeSpan HeaderWait { get; public set; }
    [MonoTODOAttribute]
public long MinSendBytesPerSecond { get; public set; }
    public TimeSpan get_EntityBody();
    public void set_EntityBody(TimeSpan value);
    public TimeSpan get_DrainEntityBody();
    public void set_DrainEntityBody(TimeSpan value);
    public TimeSpan get_RequestQueue();
    public void set_RequestQueue(TimeSpan value);
    public TimeSpan get_IdleConnection();
    public void set_IdleConnection(TimeSpan value);
    public TimeSpan get_HeaderWait();
    public void set_HeaderWait(TimeSpan value);
    public long get_MinSendBytesPerSecond();
    public void set_MinSendBytesPerSecond(long value);
}
internal enum System.Net.HttpProcessingResult : Enum {
    public int value__;
    public static HttpProcessingResult Continue;
    public static HttpProcessingResult ReadWait;
    public static HttpProcessingResult WriteWait;
}
internal class System.Net.HttpProtocolUtils : object {
    internal static DateTime string2date(string S);
    internal static string date2string(DateTime D);
}
internal class System.Net.HttpRequestCreator : object {
    public sealed virtual WebRequest Create(Uri uri);
}
public enum System.Net.HttpRequestHeader : Enum {
    public int value__;
    public static HttpRequestHeader CacheControl;
    public static HttpRequestHeader Connection;
    public static HttpRequestHeader Date;
    public static HttpRequestHeader KeepAlive;
    public static HttpRequestHeader Pragma;
    public static HttpRequestHeader Trailer;
    public static HttpRequestHeader TransferEncoding;
    public static HttpRequestHeader Upgrade;
    public static HttpRequestHeader Via;
    public static HttpRequestHeader Warning;
    public static HttpRequestHeader Allow;
    public static HttpRequestHeader ContentLength;
    public static HttpRequestHeader ContentType;
    public static HttpRequestHeader ContentEncoding;
    public static HttpRequestHeader ContentLanguage;
    public static HttpRequestHeader ContentLocation;
    public static HttpRequestHeader ContentMd5;
    public static HttpRequestHeader ContentRange;
    public static HttpRequestHeader Expires;
    public static HttpRequestHeader LastModified;
    public static HttpRequestHeader Accept;
    public static HttpRequestHeader AcceptCharset;
    public static HttpRequestHeader AcceptEncoding;
    public static HttpRequestHeader AcceptLanguage;
    public static HttpRequestHeader Authorization;
    public static HttpRequestHeader Cookie;
    public static HttpRequestHeader Expect;
    public static HttpRequestHeader From;
    public static HttpRequestHeader Host;
    public static HttpRequestHeader IfMatch;
    public static HttpRequestHeader IfModifiedSince;
    public static HttpRequestHeader IfNoneMatch;
    public static HttpRequestHeader IfRange;
    public static HttpRequestHeader IfUnmodifiedSince;
    public static HttpRequestHeader MaxForwards;
    public static HttpRequestHeader ProxyAuthorization;
    public static HttpRequestHeader Referer;
    public static HttpRequestHeader Range;
    public static HttpRequestHeader Te;
    public static HttpRequestHeader Translate;
    public static HttpRequestHeader UserAgent;
}
public enum System.Net.HttpResponseHeader : Enum {
    public int value__;
    public static HttpResponseHeader CacheControl;
    public static HttpResponseHeader Connection;
    public static HttpResponseHeader Date;
    public static HttpResponseHeader KeepAlive;
    public static HttpResponseHeader Pragma;
    public static HttpResponseHeader Trailer;
    public static HttpResponseHeader TransferEncoding;
    public static HttpResponseHeader Upgrade;
    public static HttpResponseHeader Via;
    public static HttpResponseHeader Warning;
    public static HttpResponseHeader Allow;
    public static HttpResponseHeader ContentLength;
    public static HttpResponseHeader ContentType;
    public static HttpResponseHeader ContentEncoding;
    public static HttpResponseHeader ContentLanguage;
    public static HttpResponseHeader ContentLocation;
    public static HttpResponseHeader ContentMd5;
    public static HttpResponseHeader ContentRange;
    public static HttpResponseHeader Expires;
    public static HttpResponseHeader LastModified;
    public static HttpResponseHeader AcceptRanges;
    public static HttpResponseHeader Age;
    public static HttpResponseHeader ETag;
    public static HttpResponseHeader Location;
    public static HttpResponseHeader ProxyAuthenticate;
    public static HttpResponseHeader RetryAfter;
    public static HttpResponseHeader Server;
    public static HttpResponseHeader SetCookie;
    public static HttpResponseHeader Vary;
    public static HttpResponseHeader WwwAuthenticate;
}
public enum System.Net.HttpStatusCode : Enum {
    public int value__;
    public static HttpStatusCode Continue;
    public static HttpStatusCode SwitchingProtocols;
    public static HttpStatusCode Processing;
    public static HttpStatusCode EarlyHints;
    public static HttpStatusCode OK;
    public static HttpStatusCode Created;
    public static HttpStatusCode Accepted;
    public static HttpStatusCode NonAuthoritativeInformation;
    public static HttpStatusCode NoContent;
    public static HttpStatusCode ResetContent;
    public static HttpStatusCode PartialContent;
    public static HttpStatusCode MultiStatus;
    public static HttpStatusCode AlreadyReported;
    public static HttpStatusCode IMUsed;
    public static HttpStatusCode MultipleChoices;
    public static HttpStatusCode Ambiguous;
    public static HttpStatusCode MovedPermanently;
    public static HttpStatusCode Moved;
    public static HttpStatusCode Found;
    public static HttpStatusCode Redirect;
    public static HttpStatusCode SeeOther;
    public static HttpStatusCode RedirectMethod;
    public static HttpStatusCode NotModified;
    public static HttpStatusCode UseProxy;
    public static HttpStatusCode Unused;
    public static HttpStatusCode TemporaryRedirect;
    public static HttpStatusCode RedirectKeepVerb;
    public static HttpStatusCode PermanentRedirect;
    public static HttpStatusCode BadRequest;
    public static HttpStatusCode Unauthorized;
    public static HttpStatusCode PaymentRequired;
    public static HttpStatusCode Forbidden;
    public static HttpStatusCode NotFound;
    public static HttpStatusCode MethodNotAllowed;
    public static HttpStatusCode NotAcceptable;
    public static HttpStatusCode ProxyAuthenticationRequired;
    public static HttpStatusCode RequestTimeout;
    public static HttpStatusCode Conflict;
    public static HttpStatusCode Gone;
    public static HttpStatusCode LengthRequired;
    public static HttpStatusCode PreconditionFailed;
    public static HttpStatusCode RequestEntityTooLarge;
    public static HttpStatusCode RequestUriTooLong;
    public static HttpStatusCode UnsupportedMediaType;
    public static HttpStatusCode RequestedRangeNotSatisfiable;
    public static HttpStatusCode ExpectationFailed;
    public static HttpStatusCode MisdirectedRequest;
    public static HttpStatusCode UnprocessableEntity;
    public static HttpStatusCode Locked;
    public static HttpStatusCode FailedDependency;
    public static HttpStatusCode UpgradeRequired;
    public static HttpStatusCode PreconditionRequired;
    public static HttpStatusCode TooManyRequests;
    public static HttpStatusCode RequestHeaderFieldsTooLarge;
    public static HttpStatusCode UnavailableForLegalReasons;
    public static HttpStatusCode InternalServerError;
    public static HttpStatusCode NotImplemented;
    public static HttpStatusCode BadGateway;
    public static HttpStatusCode ServiceUnavailable;
    public static HttpStatusCode GatewayTimeout;
    public static HttpStatusCode HttpVersionNotSupported;
    public static HttpStatusCode VariantAlsoNegotiates;
    public static HttpStatusCode InsufficientStorage;
    public static HttpStatusCode LoopDetected;
    public static HttpStatusCode NotExtended;
    public static HttpStatusCode NetworkAuthenticationRequired;
}
internal static class System.Net.HttpStatusDescription : object {
    internal static string Get(HttpStatusCode code);
    internal static string Get(int code);
}
internal class System.Net.HttpStreamAsyncResult : object {
    private object locker;
    private ManualResetEvent handle;
    private bool completed;
    internal Byte[] Buffer;
    internal int Offset;
    internal int Count;
    internal AsyncCallback Callback;
    internal object State;
    internal int SynchRead;
    internal Exception Error;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    public void Complete(Exception e);
    public void Complete();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
}
internal static class System.Net.HttpSysSettings : object {
    public static bool EnableNonUtf8;
    public static bool FavorUtf8;
}
internal static class System.Net.HttpValidationHelpers : object {
    private static Char[] s_httpTrimCharacters;
    private static HttpValidationHelpers();
    internal static string CheckBadHeaderNameChars(string name);
    internal static bool ContainsNonAsciiChars(string token);
    internal static bool IsValidToken(string token);
    public static string CheckBadHeaderValueChars(string value);
    public static bool IsInvalidMethodOrHeaderString(string stringValue);
}
public class System.Net.HttpVersion : object {
    public static Version Unknown;
    public static Version Version10;
    public static Version Version11;
    public static Version Version20;
    private static HttpVersion();
}
public class System.Net.HttpWebRequest : WebRequest {
    private Uri requestUri;
    private Uri actualUri;
    private bool hostChanged;
    private bool allowAutoRedirect;
    private bool allowBuffering;
    private bool allowReadStreamBuffering;
    private X509CertificateCollection certificates;
    private string connectionGroup;
    private bool haveContentLength;
    private long contentLength;
    private HttpContinueDelegate continueDelegate;
    private CookieContainer cookieContainer;
    private ICredentials credentials;
    private bool haveResponse;
    private bool requestSent;
    private WebHeaderCollection webHeaders;
    private bool keepAlive;
    private int maxAutoRedirect;
    private string mediaType;
    private string method;
    private string initialMethod;
    private bool pipelined;
    private bool preAuthenticate;
    private bool usedPreAuth;
    private Version version;
    private bool force_version;
    private Version actualVersion;
    private IWebProxy proxy;
    private bool sendChunked;
    private ServicePoint servicePoint;
    private int timeout;
    private int continueTimeout;
    private WebRequestStream writeStream;
    private HttpWebResponse webResponse;
    private WebCompletionSource responseTask;
    private WebOperation currentOperation;
    private int aborted;
    private bool gotRequestStream;
    private int redirects;
    private bool expectContinue;
    private bool getResponseCalled;
    private object locker;
    private bool finished_reading;
    private DecompressionMethods auto_decomp;
    private int maxResponseHeadersLength;
    private static int defaultMaxResponseHeadersLength;
    private static int defaultMaximumErrorResponseLength;
    private static RequestCachePolicy defaultCachePolicy;
    private int readWriteTimeout;
    private MobileTlsProvider tlsProvider;
    private MonoTlsSettings tlsSettings;
    private ServerCertValidationCallback certValidationCallback;
    private bool hostHasPort;
    private Uri hostUri;
    private AuthorizationState auth_state;
    private AuthorizationState proxy_auth_state;
    internal Func`2<Stream, Task> ResendContentFactory;
    internal int ID;
    [CompilerGeneratedAttribute]
private bool <ThrowOnError>k__BackingField;
    private bool unsafe_auth_blah;
    [CompilerGeneratedAttribute]
private bool <ReuseConnection>k__BackingField;
    public string Accept { get; public set; }
    public Uri Address { get; internal set; }
    public bool AllowAutoRedirect { get; public set; }
    public bool AllowWriteStreamBuffering { get; public set; }
    public bool AllowReadStreamBuffering { get; public set; }
    public DecompressionMethods AutomaticDecompression { get; public set; }
    internal bool InternalAllowBuffering { get; }
    private bool MethodWithBuffer { get; }
    internal MobileTlsProvider TlsProvider { get; }
    internal MonoTlsSettings TlsSettings { get; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public string Connection { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    unknown long InternalContentLength {internal set; }
    internal bool ThrowOnError { get; internal set; }
    public string ContentType { get; public set; }
    public HttpContinueDelegate ContinueDelegate { get; public set; }
    public CookieContainer CookieContainer { get; public set; }
    public ICredentials Credentials { get; public set; }
    public DateTime Date { get; public set; }
    [MonoTODOAttribute]
public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    [MonoTODOAttribute]
public static int DefaultMaximumErrorResponseLength { get; public set; }
    public string Expect { get; public set; }
    public bool HaveResponse { get; }
    public WebHeaderCollection Headers { get; public set; }
    public string Host { get; public set; }
    public DateTime IfModifiedSince { get; public set; }
    public bool KeepAlive { get; public set; }
    public int MaximumAutomaticRedirections { get; public set; }
    [MonoTODOAttribute("Use this")]
public int MaximumResponseHeadersLength { get; public set; }
    [MonoTODOAttribute("Use this")]
public static int DefaultMaximumResponseHeadersLength { get; public set; }
    public int ReadWriteTimeout { get; public set; }
    [MonoTODOAttribute]
public int ContinueTimeout { get; public set; }
    public string MediaType { get; public set; }
    public string Method { get; public set; }
    public bool Pipelined { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public Version ProtocolVersion { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public string Referer { get; public set; }
    public Uri RequestUri { get; }
    public bool SendChunked { get; public set; }
    public ServicePoint ServicePoint { get; }
    internal ServicePoint ServicePointNoLock { get; }
    public bool SupportsCookieContainer { get; }
    public int Timeout { get; public set; }
    public string TransferEncoding { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public string UserAgent { get; public set; }
    public bool UnsafeAuthenticatedConnectionSharing { get; public set; }
    internal bool GotRequestStream { get; }
    internal bool ExpectContinue { get; internal set; }
    internal Uri AuthUri { get; }
    internal bool ProxyQuery { get; }
    internal ServerCertValidationCallback ServerCertValidationCallback { get; }
    public RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    internal bool FinishedReading { get; internal set; }
    internal bool Aborted { get; }
    internal bool ReuseConnection { get; internal set; }
    private static HttpWebRequest();
    internal HttpWebRequest(Uri uri);
    internal HttpWebRequest(Uri uri, MobileTlsProvider tlsProvider, MonoTlsSettings settings);
    [ObsoleteAttribute("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")]
protected HttpWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private void ResetAuthorization();
    private void SetSpecialHeaders(string HeaderName, string value);
    public string get_Accept();
    public void set_Accept(string value);
    public Uri get_Address();
    internal void set_Address(Uri value);
    public virtual bool get_AllowAutoRedirect();
    public virtual void set_AllowAutoRedirect(bool value);
    public virtual bool get_AllowWriteStreamBuffering();
    public virtual void set_AllowWriteStreamBuffering(bool value);
    public virtual bool get_AllowReadStreamBuffering();
    public virtual void set_AllowReadStreamBuffering(bool value);
    private static Exception GetMustImplement();
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    internal bool get_InternalAllowBuffering();
    private bool get_MethodWithBuffer();
    internal MobileTlsProvider get_TlsProvider();
    internal MonoTlsSettings get_TlsSettings();
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public string get_Connection();
    public void set_Connection(string value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    internal void set_InternalContentLength(long value);
    [CompilerGeneratedAttribute]
internal bool get_ThrowOnError();
    [CompilerGeneratedAttribute]
internal void set_ThrowOnError(bool value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public HttpContinueDelegate get_ContinueDelegate();
    public void set_ContinueDelegate(HttpContinueDelegate value);
    public virtual CookieContainer get_CookieContainer();
    public virtual void set_CookieContainer(CookieContainer value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public DateTime get_Date();
    public void set_Date(DateTime value);
    private void SetDateHeaderHelper(string headerName, DateTime dateTime);
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public static int get_DefaultMaximumErrorResponseLength();
    public static void set_DefaultMaximumErrorResponseLength(int value);
    public string get_Expect();
    public void set_Expect(string value);
    public virtual bool get_HaveResponse();
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public string get_Host();
    public void set_Host(string value);
    private bool TryGetHostUri(string hostName, Uri& hostUri);
    public DateTime get_IfModifiedSince();
    public void set_IfModifiedSince(DateTime value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public int get_MaximumAutomaticRedirections();
    public void set_MaximumAutomaticRedirections(int value);
    public int get_MaximumResponseHeadersLength();
    public void set_MaximumResponseHeadersLength(int value);
    public static int get_DefaultMaximumResponseHeadersLength();
    public static void set_DefaultMaximumResponseHeadersLength(int value);
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public int get_ContinueTimeout();
    public void set_ContinueTimeout(int value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public bool get_Pipelined();
    public void set_Pipelined(bool value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public string get_Referer();
    public void set_Referer(string value);
    public virtual Uri get_RequestUri();
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    public ServicePoint get_ServicePoint();
    internal ServicePoint get_ServicePointNoLock();
    public virtual bool get_SupportsCookieContainer();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public string get_TransferEncoding();
    public void set_TransferEncoding(string value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public bool get_UnsafeAuthenticatedConnectionSharing();
    public void set_UnsafeAuthenticatedConnectionSharing(bool value);
    internal bool get_GotRequestStream();
    internal bool get_ExpectContinue();
    internal void set_ExpectContinue(bool value);
    internal Uri get_AuthUri();
    internal bool get_ProxyQuery();
    internal ServerCertValidationCallback get_ServerCertValidationCallback();
    public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    internal ServicePoint GetServicePoint();
    public void AddRange(int range);
    public void AddRange(int from, int to);
    public void AddRange(string rangeSpecifier, int range);
    public void AddRange(string rangeSpecifier, int from, int to);
    public void AddRange(long range);
    public void AddRange(long from, long to);
    public void AddRange(string rangeSpecifier, long range);
    public void AddRange(string rangeSpecifier, long from, long to);
    private WebOperation SendRequest(bool redirecting, BufferOffsetSize writeBuffer, CancellationToken cancellationToken);
    private Task`1<Stream> MyGetRequestStreamAsync(CancellationToken cancellationToken);
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual Stream GetRequestStream();
    [MonoTODOAttribute]
public Stream GetRequestStream(TransportContext& context);
    public virtual Task`1<Stream> GetRequestStreamAsync();
    internal static Task`1<T> RunWithTimeout(Func`2<CancellationToken, Task`1<T>> func, int timeout, Action abort, Func`1<bool> aborted, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.HttpWebRequest/<RunWithTimeoutWorker>d__244`1")]
private static Task`1<T> RunWithTimeoutWorker(Task`1<T> workerTask, int timeout, Action abort, Func`1<bool> aborted, CancellationTokenSource cts);
    private Task`1<T> RunWithTimeout(Func`2<CancellationToken, Task`1<T>> func);
    [AsyncStateMachineAttribute("System.Net.HttpWebRequest/<MyGetResponseAsync>d__246")]
private Task`1<HttpWebResponse> MyGetResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.HttpWebRequest/<GetResponseFromData>d__247")]
private Task`1<ValueTuple`5<HttpWebResponse, bool, bool, BufferOffsetSize, WebOperation>> GetResponseFromData(WebResponseStream stream, CancellationToken cancellationToken);
    internal static Exception FlattenException(Exception e);
    private WebException GetWebException(Exception e);
    private static WebException GetWebException(Exception e, bool aborted);
    internal static WebException CreateRequestAbortedException();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public Stream EndGetRequestStream(IAsyncResult asyncResult, TransportContext& context);
    public virtual WebResponse GetResponse();
    internal bool get_FinishedReading();
    internal void set_FinishedReading(bool value);
    internal bool get_Aborted();
    public virtual void Abort();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private void CheckRequestStarted();
    internal void DoContinueDelegate(int statusCode, WebHeaderCollection headers);
    private void RewriteRedirectToGet();
    private bool Redirect(HttpStatusCode code, WebResponse response);
    private string GetHeaders();
    private void DoPreAuthenticate();
    internal Byte[] GetRequestHeaders();
    private ValueTuple`2<WebOperation, bool> HandleNtlmAuth(WebResponseStream stream, HttpWebResponse response, BufferOffsetSize writeBuffer, CancellationToken cancellationToken);
    private bool CheckAuthorization(WebResponse response, HttpStatusCode code);
    private ValueTuple`2<Task`1<BufferOffsetSize>, WebException> GetRewriteHandler(HttpWebResponse response, bool redirect);
    private ValueTuple`4<bool, bool, Task`1<BufferOffsetSize>, WebException> CheckFinalStatus(HttpWebResponse response);
    [CompilerGeneratedAttribute]
internal bool get_ReuseConnection();
    [CompilerGeneratedAttribute]
internal void set_ReuseConnection(bool value);
    internal static StringBuilder GenerateConnectionGroup(string connectionGroupName, bool unsafeConnectionGroup, bool isInternalGroup);
    [CompilerGeneratedAttribute]
private bool <RunWithTimeout>b__245_0();
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("System.Net.HttpWebRequest/<<GetRewriteHandler>b__274_0>d")]
private Task`1<BufferOffsetSize> <GetRewriteHandler>b__274_0();
}
public class System.Net.HttpWebResponse : WebResponse {
    private Uri uri;
    private WebHeaderCollection webHeaders;
    private CookieCollection cookieCollection;
    private string method;
    private Version version;
    private HttpStatusCode statusCode;
    private string statusDescription;
    private long contentLength;
    private string contentType;
    private CookieContainer cookie_container;
    private bool disposed;
    private Stream stream;
    public string CharacterSet { get; }
    public string ContentEncoding { get; }
    public long ContentLength { get; }
    public string ContentType { get; }
    public CookieCollection Cookies { get; public set; }
    public WebHeaderCollection Headers { get; }
    [MonoTODOAttribute]
public bool IsMutuallyAuthenticated { get; }
    public DateTime LastModified { get; }
    public string Method { get; }
    public Version ProtocolVersion { get; }
    public Uri ResponseUri { get; }
    public string Server { get; }
    public HttpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    public bool SupportsHeaders { get; }
    internal HttpWebResponse(Uri uri, string method, HttpStatusCode status, WebHeaderCollection headers);
    internal HttpWebResponse(Uri uri, string method, WebResponseStream stream, CookieContainer container);
    [ObsoleteAttribute("Serialization is obsoleted for this type", "False")]
protected HttpWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public string get_CharacterSet();
    public string get_ContentEncoding();
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public virtual CookieCollection get_Cookies();
    public virtual void set_Cookies(CookieCollection value);
    public virtual WebHeaderCollection get_Headers();
    private static Exception GetMustImplement();
    public virtual bool get_IsMutuallyAuthenticated();
    public DateTime get_LastModified();
    public virtual string get_Method();
    public Version get_ProtocolVersion();
    public virtual Uri get_ResponseUri();
    public string get_Server();
    public virtual HttpStatusCode get_StatusCode();
    public virtual string get_StatusDescription();
    public virtual bool get_SupportsHeaders();
    public string GetResponseHeader(string headerName);
    public virtual Stream GetResponseStream();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    private void CheckDisposed();
    private void FillCookies();
}
internal enum System.Net.HttpWriteMode : Enum {
    public int value__;
    public static HttpWriteMode Unknown;
    public static HttpWriteMode ContentLength;
    public static HttpWriteMode Chunked;
    public static HttpWriteMode Buffer;
    public static HttpWriteMode None;
}
public interface System.Net.IAuthenticationModule {
    public bool CanPreAuthenticate { get; }
    public string AuthenticationType { get; }
    public abstract virtual Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public abstract virtual Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public abstract virtual bool get_CanPreAuthenticate();
    public abstract virtual string get_AuthenticationType();
}
internal interface System.Net.IAutoWebProxy {
    public abstract virtual ProxyChain GetProxies(Uri destination);
}
public interface System.Net.ICertificatePolicy {
    public abstract virtual bool CheckValidationResult(ServicePoint srvPoint, X509Certificate certificate, WebRequest request, int certificateProblem);
}
internal interface System.Net.ICloseEx {
    public abstract virtual void CloseEx(CloseExState closeState);
}
public interface System.Net.ICredentialPolicy {
    public abstract virtual bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule);
}
public interface System.Net.ICredentials {
    public abstract virtual NetworkCredential GetCredential(Uri uri, string authType);
}
public interface System.Net.ICredentialsByHost {
    public abstract virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
}
internal enum System.Net.IgnoreCertProblem : Enum {
    public int value__;
    public static IgnoreCertProblem not_time_valid;
    public static IgnoreCertProblem ctl_not_time_valid;
    public static IgnoreCertProblem not_time_nested;
    public static IgnoreCertProblem invalid_basic_constraints;
    public static IgnoreCertProblem all_not_time_valid;
    public static IgnoreCertProblem allow_unknown_ca;
    public static IgnoreCertProblem wrong_usage;
    public static IgnoreCertProblem invalid_name;
    public static IgnoreCertProblem invalid_policy;
    public static IgnoreCertProblem end_rev_unknown;
    public static IgnoreCertProblem ctl_signer_rev_unknown;
    public static IgnoreCertProblem ca_rev_unknown;
    public static IgnoreCertProblem root_rev_unknown;
    public static IgnoreCertProblem all_rev_unknown;
    public static IgnoreCertProblem none;
}
internal class System.Net.InterlockedGate : ValueType {
    private int m_State;
    internal static int Open;
    internal static int Triggering;
    internal static int Triggered;
    internal static int Signaling;
    internal static int Signaled;
    internal static int Completed;
    internal void Reset();
    internal bool Trigger(bool exclusive);
    internal bool StartTriggering(bool exclusive);
    internal void FinishTriggering();
    internal bool StartSignaling(bool exclusive);
    internal void FinishSignaling();
    internal bool Complete();
}
internal class System.Net.InternalException : SystemException {
    internal InternalException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal static class System.Net.IntPtrHelper : object {
    internal static IntPtr Add(IntPtr a, int b);
    internal static long Subtract(IntPtr a, IntPtr b);
}
public class System.Net.IPAddress : object {
    public static IPAddress Any;
    public static IPAddress Loopback;
    public static IPAddress Broadcast;
    public static IPAddress None;
    internal static long LoopbackMask;
    public static IPAddress IPv6Any;
    public static IPAddress IPv6Loopback;
    public static IPAddress IPv6None;
    private UInt32 _addressOrScopeId;
    private UInt16[] _numbers;
    private string _toString;
    private int _hashCode;
    internal static int NumberOfLabels;
    private bool IsIPv4 { get; }
    private bool IsIPv6 { get; }
    private UInt32 PrivateAddress { get; private set; }
    private UInt32 PrivateScopeId { get; private set; }
    public AddressFamily AddressFamily { get; }
    public long ScopeId { get; public set; }
    public bool IsIPv6Multicast { get; }
    public bool IsIPv6LinkLocal { get; }
    public bool IsIPv6SiteLocal { get; }
    public bool IsIPv6Teredo { get; }
    public bool IsIPv4MappedToIPv6 { get; }
    [ObsoleteAttribute("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. https://go.microsoft.com/fwlink/?linkid=14202")]
public long Address { get; public set; }
    public IPAddress(long newAddress);
    public IPAddress(Byte[] address, long scopeid);
    public IPAddress(ReadOnlySpan`1<byte> address, long scopeid);
    internal IPAddress(UInt16* numbers, int numbersLength, UInt32 scopeid);
    private IPAddress(UInt16[] numbers, UInt32 scopeid);
    public IPAddress(Byte[] address);
    public IPAddress(ReadOnlySpan`1<byte> address);
    internal IPAddress(int newAddress);
    private static IPAddress();
    private bool get_IsIPv4();
    private bool get_IsIPv6();
    private UInt32 get_PrivateAddress();
    private void set_PrivateAddress(UInt32 value);
    private UInt32 get_PrivateScopeId();
    private void set_PrivateScopeId(UInt32 value);
    public static bool TryParse(string ipString, IPAddress& address);
    public static bool TryParse(ReadOnlySpan`1<char> ipSpan, IPAddress& address);
    public static IPAddress Parse(string ipString);
    public static IPAddress Parse(ReadOnlySpan`1<char> ipSpan);
    public bool TryWriteBytes(Span`1<byte> destination, Int32& bytesWritten);
    private void WriteIPv6Bytes(Span`1<byte> destination);
    private void WriteIPv4Bytes(Span`1<byte> destination);
    public Byte[] GetAddressBytes();
    public AddressFamily get_AddressFamily();
    public long get_ScopeId();
    public void set_ScopeId(long value);
    public virtual string ToString();
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public static long HostToNetworkOrder(long host);
    public static int HostToNetworkOrder(int host);
    public static short HostToNetworkOrder(short host);
    public static long NetworkToHostOrder(long network);
    public static int NetworkToHostOrder(int network);
    public static short NetworkToHostOrder(short network);
    public static bool IsLoopback(IPAddress address);
    public bool get_IsIPv6Multicast();
    public bool get_IsIPv6LinkLocal();
    public bool get_IsIPv6SiteLocal();
    public bool get_IsIPv6Teredo();
    public bool get_IsIPv4MappedToIPv6();
    public long get_Address();
    public void set_Address(long value);
    internal bool Equals(object comparandObj, bool compareScopeId);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public IPAddress MapToIPv6();
    public IPAddress MapToIPv4();
    private static Byte[] ThrowAddressNullException();
}
internal class System.Net.IPAddressParser : object {
    private static int MaxIPv4StringLength;
    internal static IPAddress Parse(ReadOnlySpan`1<char> ipSpan, bool tryParse);
    internal static string IPv4AddressToString(UInt32 address);
    internal static void IPv4AddressToString(UInt32 address, StringBuilder destination);
    internal static bool IPv4AddressToString(UInt32 address, Span`1<char> formatted, Int32& charsWritten);
    private static int IPv4AddressToStringHelper(UInt32 address, Char* addressString);
    internal static string IPv6AddressToString(UInt16[] address, UInt32 scopeId);
    internal static bool IPv6AddressToString(UInt16[] address, UInt32 scopeId, Span`1<char> destination, Int32& charsWritten);
    internal static StringBuilder IPv6AddressToStringHelper(UInt16[] address, UInt32 scopeId);
    private static void FormatIPv4AddressNumber(int number, Char* addressString, Int32& offset);
    public static bool Ipv4StringToAddress(ReadOnlySpan`1<char> ipSpan, Int64& address);
    public static bool Ipv6StringToAddress(ReadOnlySpan`1<char> ipSpan, UInt16* numbers, int numbersLength, UInt32& scope);
    private static void AppendSections(UInt16[] address, int fromInclusive, int toExclusive, StringBuilder buffer);
    private static void AppendHex(ushort value, StringBuilder buffer);
    private static UInt32 ExtractIPv4Address(UInt16[] address);
    private static ushort Reverse(ushort number);
}
internal static class System.Net.IPAddressParserStatics : object {
    public static int IPv4AddressBytes;
    public static int IPv6AddressBytes;
    public static int IPv6AddressShorts;
}
public class System.Net.IPEndPoint : EndPoint {
    public static int MinPort;
    public static int MaxPort;
    private IPAddress _address;
    private int _port;
    internal static int AnyPort;
    internal static IPEndPoint Any;
    internal static IPEndPoint IPv6Any;
    public AddressFamily AddressFamily { get; }
    public IPAddress Address { get; public set; }
    public int Port { get; public set; }
    public IPEndPoint(long address, int port);
    public IPEndPoint(IPAddress address, int port);
    private static IPEndPoint();
    public virtual AddressFamily get_AddressFamily();
    public IPAddress get_Address();
    public void set_Address(IPAddress value);
    public int get_Port();
    public void set_Port(int value);
    public virtual string ToString();
    public virtual SocketAddress Serialize();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
}
public class System.Net.IPHostEntry : object {
    private string hostName;
    private String[] aliases;
    private IPAddress[] addressList;
    internal bool isTrustedHost;
    public string HostName { get; public set; }
    public String[] Aliases { get; public set; }
    public IPAddress[] AddressList { get; public set; }
    public string get_HostName();
    public void set_HostName(string value);
    public String[] get_Aliases();
    public void set_Aliases(String[] value);
    public IPAddress[] get_AddressList();
    public void set_AddressList(IPAddress[] value);
}
internal class System.Net.IPv6AddressFormatter : ValueType {
    private UInt16[] address;
    private long scopeId;
    public IPv6AddressFormatter(UInt16[] addr, long scopeId);
    private static ushort SwapUShort(ushort number);
    private UInt32 AsIPv4Int();
    private bool IsIPv4Compatible();
    private bool IsIPv4Mapped();
    public virtual string ToString();
}
public interface System.Net.IWebProxy {
    public ICredentials Credentials { get; public set; }
    public abstract virtual Uri GetProxy(Uri destination);
    public abstract virtual bool IsBypassed(Uri host);
    public abstract virtual ICredentials get_Credentials();
    public abstract virtual void set_Credentials(ICredentials value);
}
internal interface System.Net.IWebProxyFinder {
    public bool IsValid { get; }
    public abstract virtual bool GetProxies(Uri destination, IList`1& proxyList);
    public abstract virtual void Abort();
    public abstract virtual void Reset();
    public abstract virtual bool get_IsValid();
}
public interface System.Net.IWebProxyScript {
    public abstract virtual void Close();
    public abstract virtual bool Load(Uri scriptLocation, string script, Type helperType);
    public abstract virtual string Run(string url, string host);
}
public interface System.Net.IWebRequestCreate {
    public abstract virtual WebRequest Create(Uri uri);
}
internal class System.Net.KnownHttpVerb : object {
    internal string Name;
    internal bool RequireContentBody;
    internal bool ContentBodyNotAllowed;
    internal bool ConnectRequest;
    internal bool ExpectNoContentResponse;
    private static ListDictionary NamedHeaders;
    internal static KnownHttpVerb Get;
    internal static KnownHttpVerb Connect;
    internal static KnownHttpVerb Head;
    internal static KnownHttpVerb Put;
    internal static KnownHttpVerb Post;
    internal static KnownHttpVerb MkCol;
    internal KnownHttpVerb(string name, bool requireContentBody, bool contentBodyNotAllowed, bool connectRequest, bool expectNoContentResponse);
    private static KnownHttpVerb();
    public bool Equals(KnownHttpVerb verb);
    public static KnownHttpVerb Parse(string name);
}
internal class System.Net.LazyAsyncResult : object {
    private static int c_HighBit;
    private static int c_ForceAsyncCount;
    [ThreadStaticAttribute]
private static ThreadContext t_ThreadContext;
    private object m_AsyncObject;
    private object m_AsyncState;
    private AsyncCallback m_AsyncCallback;
    private object m_Result;
    private int m_ErrorCode;
    private int m_IntCompleted;
    private bool m_EndCalled;
    private bool m_UserEvent;
    private object m_Event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    protected AsyncCallback AsyncCallback { get; protected set; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal bool EndCalled { get; internal set; }
    internal int ErrorCode { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack, object result);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    protected AsyncCallback get_AsyncCallback();
    protected void set_AsyncCallback(AsyncCallback value);
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    [ConditionalAttribute("DEBUG")]
protected void DebugProtectState(bool protect);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
    internal void InternalCleanup();
}
internal class System.Net.ListenerAsyncResult : object {
    private ManualResetEvent handle;
    private bool synch;
    private bool completed;
    private AsyncCallback cb;
    private object state;
    private Exception exception;
    private HttpListenerContext context;
    private object locker;
    private ListenerAsyncResult forward;
    internal bool EndCalled;
    internal bool InGet;
    private static WaitCallback InvokeCB;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    public ListenerAsyncResult(AsyncCallback cb, object state);
    private static ListenerAsyncResult();
    internal void Complete(Exception exc);
    private static void InvokeCallback(object o);
    internal void Complete(HttpListenerContext context);
    internal void Complete(HttpListenerContext context, bool synch);
    internal HttpListenerContext GetContext();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
}
internal class System.Net.ListenerPrefix : object {
    private string original;
    private string host;
    private ushort port;
    private string path;
    private bool secure;
    private IPAddress[] addresses;
    public HttpListener Listener;
    public IPAddress[] Addresses { get; public set; }
    public bool Secure { get; }
    public string Host { get; }
    public int Port { get; }
    public string Path { get; }
    public ListenerPrefix(string prefix);
    public virtual string ToString();
    public IPAddress[] get_Addresses();
    public void set_Addresses(IPAddress[] value);
    public bool get_Secure();
    public string get_Host();
    public int get_Port();
    public string get_Path();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private void Parse(string uri);
    public static void CheckUri(string uri);
}
internal static class System.Net.Logging : object {
    internal static bool On { get; }
    internal static TraceSource Web { get; }
    internal static TraceSource HttpListener { get; }
    internal static TraceSource Sockets { get; }
    internal static bool get_On();
    internal static TraceSource get_Web();
    internal static TraceSource get_HttpListener();
    internal static TraceSource get_Sockets();
    [ConditionalAttribute("TRACE")]
internal static void Enter(TraceSource traceSource, object obj, string method, object paramObject);
    [ConditionalAttribute("TRACE")]
internal static void Enter(TraceSource traceSource, string msg);
    [ConditionalAttribute("TRACE")]
internal static void Enter(TraceSource traceSource, string msg, string parameters);
    [ConditionalAttribute("TRACE")]
internal static void Exception(TraceSource traceSource, object obj, string method, Exception e);
    [ConditionalAttribute("TRACE")]
internal static void Exit(TraceSource traceSource, object obj, string method, object retObject);
    [ConditionalAttribute("TRACE")]
internal static void Exit(TraceSource traceSource, string msg);
    [ConditionalAttribute("TRACE")]
internal static void Exit(TraceSource traceSource, string msg, string parameters);
    [ConditionalAttribute("TRACE")]
internal static void PrintInfo(TraceSource traceSource, object obj, string method, string msg);
    [ConditionalAttribute("TRACE")]
internal static void PrintInfo(TraceSource traceSource, object obj, string msg);
    [ConditionalAttribute("TRACE")]
internal static void PrintInfo(TraceSource traceSource, string msg);
    [ConditionalAttribute("TRACE")]
internal static void PrintWarning(TraceSource traceSource, object obj, string method, string msg);
    [ConditionalAttribute("TRACE")]
internal static void PrintWarning(TraceSource traceSource, string msg);
    [ConditionalAttribute("TRACE")]
internal static void PrintError(TraceSource traceSource, string msg);
}
public class System.Net.Mail.AlternateView : AttachmentBase {
    private Uri baseUri;
    private LinkedResourceCollection linkedResources;
    public Uri BaseUri { get; public set; }
    public LinkedResourceCollection LinkedResources { get; }
    public AlternateView(string fileName);
    public AlternateView(string fileName, ContentType contentType);
    public AlternateView(string fileName, string mediaType);
    public AlternateView(Stream contentStream);
    public AlternateView(Stream contentStream, string mediaType);
    public AlternateView(Stream contentStream, ContentType contentType);
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public LinkedResourceCollection get_LinkedResources();
    public static AlternateView CreateAlternateViewFromString(string content);
    public static AlternateView CreateAlternateViewFromString(string content, ContentType contentType);
    public static AlternateView CreateAlternateViewFromString(string content, Encoding contentEncoding, string mediaType);
    protected virtual void Dispose(bool disposing);
}
public class System.Net.Mail.AlternateViewCollection : Collection`1<AlternateView> {
    public sealed virtual void Dispose();
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, AlternateView item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, AlternateView item);
}
public class System.Net.Mail.Attachment : AttachmentBase {
    private ContentDisposition contentDisposition;
    private Encoding nameEncoding;
    public ContentDisposition ContentDisposition { get; }
    public string Name { get; public set; }
    public Encoding NameEncoding { get; public set; }
    public Attachment(string fileName);
    public Attachment(string fileName, string mediaType);
    public Attachment(string fileName, ContentType contentType);
    public Attachment(Stream contentStream, ContentType contentType);
    public Attachment(Stream contentStream, string name);
    public Attachment(Stream contentStream, string name, string mediaType);
    public ContentDisposition get_ContentDisposition();
    public string get_Name();
    public void set_Name(string value);
    public Encoding get_NameEncoding();
    public void set_NameEncoding(Encoding value);
    public static Attachment CreateAttachmentFromString(string content, ContentType contentType);
    public static Attachment CreateAttachmentFromString(string content, string name);
    public static Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType);
    private void InitName(string fileName);
}
public abstract class System.Net.Mail.AttachmentBase : object {
    private string id;
    private ContentType contentType;
    private Stream contentStream;
    private TransferEncoding transferEncoding;
    public string ContentId { get; public set; }
    public Stream ContentStream { get; }
    public ContentType ContentType { get; public set; }
    public TransferEncoding TransferEncoding { get; public set; }
    protected AttachmentBase(Stream contentStream);
    protected AttachmentBase(Stream contentStream, ContentType contentType);
    protected AttachmentBase(Stream contentStream, string mediaType);
    protected AttachmentBase(string fileName);
    protected AttachmentBase(string fileName, ContentType contentType);
    protected AttachmentBase(string fileName, string mediaType);
    public string get_ContentId();
    public void set_ContentId(string value);
    public Stream get_ContentStream();
    public ContentType get_ContentType();
    public void set_ContentType(ContentType value);
    public TransferEncoding get_TransferEncoding();
    public void set_TransferEncoding(TransferEncoding value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Net.Mail.AttachmentCollection : Collection`1<Attachment> {
    public sealed virtual void Dispose();
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, Attachment item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, Attachment item);
}
internal class System.Net.Mail.BufferBuilder : object {
    private Byte[] _buffer;
    private int _offset;
    internal int Length { get; }
    internal BufferBuilder(int initialSize);
    private void EnsureBuffer(int count);
    internal void Append(byte value);
    internal void Append(Byte[] value);
    internal void Append(Byte[] value, int offset, int count);
    internal void Append(string value);
    internal void Append(string value, bool allowUnicode);
    internal void Append(string value, int offset, int count, bool allowUnicode);
    internal void Append(string value, int offset, int count);
    internal int get_Length();
    internal Byte[] GetBuffer();
    internal void Reset();
}
internal class System.Net.Mail.CCredentialsByHost : object {
    private string userName;
    private string password;
    public CCredentialsByHost(string userName, string password);
    public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
}
[FlagsAttribute]
public enum System.Net.Mail.DeliveryNotificationOptions : Enum {
    public int value__;
    public static DeliveryNotificationOptions None;
    public static DeliveryNotificationOptions OnSuccess;
    public static DeliveryNotificationOptions OnFailure;
    public static DeliveryNotificationOptions Delay;
    public static DeliveryNotificationOptions Never;
}
internal static class System.Net.Mail.DomainLiteralReader : object {
    internal static int ReadReverse(string data, int index);
}
internal static class System.Net.Mail.DotAtomReader : object {
    internal static int ReadReverse(string data, int index);
}
public class System.Net.Mail.LinkedResource : AttachmentBase {
    private Uri contentLink;
    public Uri ContentLink { get; public set; }
    public LinkedResource(string fileName);
    public LinkedResource(string fileName, ContentType contentType);
    public LinkedResource(string fileName, string mediaType);
    public LinkedResource(Stream contentStream);
    public LinkedResource(Stream contentStream, ContentType contentType);
    public LinkedResource(Stream contentStream, string mediaType);
    public Uri get_ContentLink();
    public void set_ContentLink(Uri value);
    public static LinkedResource CreateLinkedResourceFromString(string content);
    public static LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType);
    public static LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType);
}
public class System.Net.Mail.LinkedResourceCollection : Collection`1<LinkedResource> {
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, LinkedResource item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, LinkedResource item);
}
public class System.Net.Mail.MailAddress : object {
    private Encoding _displayNameEncoding;
    private string _displayName;
    private string _userName;
    private string _host;
    private static EncodedStreamFactory s_encoderFactory;
    public string DisplayName { get; }
    public string User { get; }
    public string Host { get; }
    public string Address { get; }
    private string SmtpAddress { get; }
    internal MailAddress(string displayName, string userName, string domain);
    public MailAddress(string address);
    public MailAddress(string address, string displayName);
    public MailAddress(string address, string displayName, Encoding displayNameEncoding);
    private static MailAddress();
    public string get_DisplayName();
    public string get_User();
    private string GetUser(bool allowUnicode);
    public string get_Host();
    private string GetHost(bool allowUnicode);
    public string get_Address();
    private string GetAddress(bool allowUnicode);
    private string get_SmtpAddress();
    internal string GetSmtpAddress(bool allowUnicode);
    public virtual string ToString();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal string Encode(int charsConsumed, bool allowUnicode);
}
public class System.Net.Mail.MailAddressCollection : Collection`1<MailAddress> {
    public void Add(string addresses);
    protected virtual void SetItem(int index, MailAddress item);
    protected virtual void InsertItem(int index, MailAddress item);
    internal void ParseValue(string addresses);
    public virtual string ToString();
    internal string Encode(int charsConsumed, bool allowUnicode);
}
internal static class System.Net.Mail.MailAddressParser : object {
    internal static MailAddress ParseAddress(string data);
    internal static List`1<MailAddress> ParseMultipleAddresses(string data);
    private static MailAddress ParseAddress(string data, bool expectMultipleAddresses, Int32& index);
    private static int ReadCfwsAndThrowIfIncomplete(string data, int index);
    private static string ParseDomain(string data, Int32& index);
    private static string ParseLocalPart(string data, Int32& index, bool expectAngleBracket, bool expectMultipleAddresses);
    private static string ParseDisplayName(string data, Int32& index, bool expectMultipleAddresses);
    internal static string NormalizeOrThrow(string input);
}
internal enum System.Net.Mail.MailHeaderID : Enum {
    public int value__;
    public static MailHeaderID Bcc;
    public static MailHeaderID Cc;
    public static MailHeaderID Comments;
    public static MailHeaderID ContentDescription;
    public static MailHeaderID ContentDisposition;
    public static MailHeaderID ContentID;
    public static MailHeaderID ContentLocation;
    public static MailHeaderID ContentTransferEncoding;
    public static MailHeaderID ContentType;
    public static MailHeaderID Date;
    public static MailHeaderID From;
    public static MailHeaderID Importance;
    public static MailHeaderID InReplyTo;
    public static MailHeaderID Keywords;
    public static MailHeaderID Max;
    public static MailHeaderID MessageID;
    public static MailHeaderID MimeVersion;
    public static MailHeaderID Priority;
    public static MailHeaderID References;
    public static MailHeaderID ReplyTo;
    public static MailHeaderID ResentBcc;
    public static MailHeaderID ResentCc;
    public static MailHeaderID ResentDate;
    public static MailHeaderID ResentFrom;
    public static MailHeaderID ResentMessageID;
    public static MailHeaderID ResentSender;
    public static MailHeaderID ResentTo;
    public static MailHeaderID Sender;
    public static MailHeaderID Subject;
    public static MailHeaderID To;
    public static MailHeaderID XPriority;
    public static MailHeaderID XReceiver;
    public static MailHeaderID XSender;
    public static MailHeaderID ZMaxEnumValue;
    public static MailHeaderID Unknown;
}
internal static class System.Net.Mail.MailHeaderInfo : object {
    private static HeaderInfo[] s_headerInfo;
    private static Dictionary`2<string, int> s_headerDictionary;
    private static MailHeaderInfo();
    internal static string GetString(MailHeaderID id);
    internal static MailHeaderID GetID(string name);
    internal static bool IsUserSettable(string name);
    internal static bool IsSingleton(string name);
    internal static string NormalizeCase(string name);
    internal static bool AllowsUnicode(string name);
}
public class System.Net.Mail.MailMessage : object {
    private AlternateViewCollection alternateViews;
    private AttachmentCollection attachments;
    private MailAddressCollection bcc;
    private MailAddressCollection replyTo;
    private string body;
    private MailPriority priority;
    private MailAddress sender;
    private DeliveryNotificationOptions deliveryNotificationOptions;
    private MailAddressCollection cc;
    private MailAddress from;
    private NameValueCollection headers;
    private MailAddressCollection to;
    private string subject;
    private Encoding subjectEncoding;
    private Encoding bodyEncoding;
    private Encoding headersEncoding;
    private bool isHtml;
    private static Char[] hex;
    private static Encoding utf8unmarked;
    public AlternateViewCollection AlternateViews { get; }
    public AttachmentCollection Attachments { get; }
    public MailAddressCollection Bcc { get; }
    public string Body { get; public set; }
    internal ContentType BodyContentType { get; }
    internal TransferEncoding ContentTransferEncoding { get; }
    public Encoding BodyEncoding { get; public set; }
    public TransferEncoding BodyTransferEncoding { get; public set; }
    public MailAddressCollection CC { get; }
    public DeliveryNotificationOptions DeliveryNotificationOptions { get; public set; }
    public MailAddress From { get; public set; }
    public NameValueCollection Headers { get; }
    public bool IsBodyHtml { get; public set; }
    public MailPriority Priority { get; public set; }
    public Encoding HeadersEncoding { get; public set; }
    public MailAddressCollection ReplyToList { get; }
    [ObsoleteAttribute("Use ReplyToList instead")]
public MailAddress ReplyTo { get; public set; }
    public MailAddress Sender { get; public set; }
    public string Subject { get; public set; }
    public Encoding SubjectEncoding { get; public set; }
    public MailAddressCollection To { get; }
    private static Encoding UTF8Unmarked { get; }
    public MailMessage(MailAddress from, MailAddress to);
    public MailMessage(string from, string to);
    public MailMessage(string from, string to, string subject, string body);
    private static MailMessage();
    public AlternateViewCollection get_AlternateViews();
    public AttachmentCollection get_Attachments();
    public MailAddressCollection get_Bcc();
    public string get_Body();
    public void set_Body(string value);
    internal ContentType get_BodyContentType();
    internal TransferEncoding get_ContentTransferEncoding();
    public Encoding get_BodyEncoding();
    public void set_BodyEncoding(Encoding value);
    public TransferEncoding get_BodyTransferEncoding();
    public void set_BodyTransferEncoding(TransferEncoding value);
    public MailAddressCollection get_CC();
    public DeliveryNotificationOptions get_DeliveryNotificationOptions();
    public void set_DeliveryNotificationOptions(DeliveryNotificationOptions value);
    public MailAddress get_From();
    public void set_From(MailAddress value);
    public NameValueCollection get_Headers();
    public bool get_IsBodyHtml();
    public void set_IsBodyHtml(bool value);
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    public Encoding get_HeadersEncoding();
    public void set_HeadersEncoding(Encoding value);
    public MailAddressCollection get_ReplyToList();
    public MailAddress get_ReplyTo();
    public void set_ReplyTo(MailAddress value);
    public MailAddress get_Sender();
    public void set_Sender(MailAddress value);
    public string get_Subject();
    public void set_Subject(string value);
    public Encoding get_SubjectEncoding();
    public void set_SubjectEncoding(Encoding value);
    public MailAddressCollection get_To();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private Encoding GuessEncoding(string s);
    internal static TransferEncoding GuessTransferEncoding(Encoding enc);
    internal static string To2047(Byte[] bytes);
    internal static string EncodeSubjectRFC2047(string s, Encoding enc);
    private static Encoding get_UTF8Unmarked();
}
public enum System.Net.Mail.MailPriority : Enum {
    public int value__;
    public static MailPriority Normal;
    public static MailPriority Low;
    public static MailPriority High;
}
internal static class System.Net.Mail.QuotedPairReader : object {
    internal static int CountQuotedChars(string data, int index, bool permitUnicodeEscaping);
    private static int CountBackslashes(string data, int index);
}
internal static class System.Net.Mail.QuotedStringFormatReader : object {
    internal static int ReadReverseQuoted(string data, int index, bool permitUnicode);
    internal static int ReadReverseUnQuoted(string data, int index, bool permitUnicode, bool expectCommaDelimiter);
    private static bool IsValidQtext(bool allowUnicode, char ch);
}
public class System.Net.Mail.SendCompletedEventHandler : MulticastDelegate {
    public SendCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Net.Mail.SmtpAccess : Enum {
    public int value__;
    public static SmtpAccess None;
    public static SmtpAccess Connect;
    public static SmtpAccess ConnectToUnrestrictedPort;
}
[ObsoleteAttribute("SmtpClient and its network of types are poorly designed, we strongly recommend you use https://github.com/jstedfast/MailKit and https://github.com/jstedfast/MimeKit instead")]
public class System.Net.Mail.SmtpClient : object {
    private string host;
    private int port;
    private int timeout;
    private ICredentialsByHost credentials;
    private string pickupDirectoryLocation;
    private SmtpDeliveryMethod deliveryMethod;
    private SmtpDeliveryFormat deliveryFormat;
    private bool enableSsl;
    private X509CertificateCollection clientCertificates;
    private TcpClient client;
    private Stream stream;
    private StreamWriter writer;
    private StreamReader reader;
    private int boundaryIndex;
    private MailAddress defaultFrom;
    private MailMessage messageInProcess;
    private BackgroundWorker worker;
    private object user_async_state;
    private AuthMechs authMechs;
    private Mutex mutex;
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private SendCompletedEventHandler SendCompleted;
    [MonoTODOAttribute("Client certificates not used")]
public X509CertificateCollection ClientCertificates { get; }
    public string TargetName { get; public set; }
    public ICredentialsByHost Credentials { get; public set; }
    public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    public bool EnableSsl { get; public set; }
    public string Host { get; public set; }
    public string PickupDirectoryLocation { get; public set; }
    public int Port { get; public set; }
    public SmtpDeliveryFormat DeliveryFormat { get; public set; }
    [MonoTODOAttribute]
public ServicePoint ServicePoint { get; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public SmtpClient(string host);
    public SmtpClient(string host, int port);
    public X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public void set_TargetName(string value);
    public ICredentialsByHost get_Credentials();
    public void set_Credentials(ICredentialsByHost value);
    public SmtpDeliveryMethod get_DeliveryMethod();
    public void set_DeliveryMethod(SmtpDeliveryMethod value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public string get_Host();
    public void set_Host(string value);
    public string get_PickupDirectoryLocation();
    public void set_PickupDirectoryLocation(string value);
    public int get_Port();
    public void set_Port(int value);
    public SmtpDeliveryFormat get_DeliveryFormat();
    public void set_DeliveryFormat(SmtpDeliveryFormat value);
    public ServicePoint get_ServicePoint();
    public int get_Timeout();
    public void set_Timeout(int value);
    public bool get_UseDefaultCredentials();
    [MonoNotSupportedAttribute("no DefaultCredential support in Mono")]
public void set_UseDefaultCredentials(bool value);
    [CompilerGeneratedAttribute]
public void add_SendCompleted(SendCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SendCompleted(SendCompletedEventHandler value);
    public sealed virtual void Dispose();
    [MonoTODOAttribute("Does nothing at the moment.")]
protected virtual void Dispose(bool disposing);
    private void CheckState();
    private static string EncodeAddress(MailAddress address);
    private static string EncodeAddresses(MailAddressCollection addresses);
    private string EncodeSubjectRFC2047(MailMessage message);
    private string EncodeBody(MailMessage message);
    private string EncodeBody(AlternateView av);
    private void EndSection(string section);
    private string GenerateBoundary();
    private static string GenerateBoundary(int index);
    private bool IsError(SmtpResponse status);
    protected void OnSendCompleted(AsyncCompletedEventArgs e);
    private void CheckCancellation();
    private SmtpResponse Read();
    private void ResetExtensions();
    private void ParseExtensions(string extens);
    public void Send(MailMessage message);
    private void SendInternal(MailMessage message);
    private void SendToFile(MailMessage message);
    private void SendCore(MailMessage message);
    public void Send(string from, string recipients, string subject, string body);
    public Task SendMailAsync(MailMessage message);
    public Task SendMailAsync(string from, string recipients, string subject, string body);
    private static void SendMailAsyncCompletedHandler(TaskCompletionSource`1<object> source, AsyncCompletedEventArgs e, SendCompletedEventHandler handler, SmtpClient client);
    private void SendDot();
    private void SendData(string data);
    public void SendAsync(MailMessage message, object userToken);
    public void SendAsync(string from, string recipients, string subject, string body, object userToken);
    public void SendAsyncCancel();
    private void AddPriorityHeader(MailMessage message);
    private void SendSimpleBody(MailMessage message);
    private void SendBodylessSingleAlternate(AlternateView av);
    private void SendWithoutAttachments(MailMessage message, string boundary, bool attachmentExists);
    private void SendWithAttachments(MailMessage message);
    private void SendBodyWithAlternateViews(MailMessage message, string boundary, bool attachmentExists);
    private void SendLinkedResources(MailMessage message, LinkedResourceCollection resources, string boundary);
    private void SendAttachments(MailMessage message, Attachment body, string boundary);
    private SmtpResponse SendCommand(string command);
    private void SendHeader(string name, string value);
    private void StartSection(string section, ContentType sectionContentType);
    private void StartSection(string section, ContentType sectionContentType, AttachmentBase att);
    private void StartSection(string section, ContentType sectionContentType, Attachment att, bool sendDisposition);
    private string ToQuotedPrintable(string input, Encoding enc);
    private string ToQuotedPrintable(Byte[] bytes);
    private static string GetTransferEncodingName(TransferEncoding encoding);
    private void InitiateSecureConnection();
    private void Authenticate();
    private void CheckStatus(SmtpResponse status, int i);
    private void ThrowIfError(SmtpResponse status);
    private void Authenticate(string user, string password);
}
public enum System.Net.Mail.SmtpDeliveryFormat : Enum {
    public int value__;
    public static SmtpDeliveryFormat SevenBit;
    public static SmtpDeliveryFormat International;
}
public enum System.Net.Mail.SmtpDeliveryMethod : Enum {
    public int value__;
    public static SmtpDeliveryMethod Network;
    public static SmtpDeliveryMethod SpecifiedPickupDirectory;
    public static SmtpDeliveryMethod PickupDirectoryFromIis;
}
public class System.Net.Mail.SmtpException : Exception {
    private SmtpStatusCode statusCode;
    public SmtpStatusCode StatusCode { get; public set; }
    public SmtpException(SmtpStatusCode statusCode);
    public SmtpException(string message);
    protected SmtpException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public SmtpException(SmtpStatusCode statusCode, string message);
    public SmtpException(string message, Exception innerException);
    public SmtpStatusCode get_StatusCode();
    public void set_StatusCode(SmtpStatusCode value);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Net.Mail.SmtpFailedRecipientException : SmtpException {
    private string failedRecipient;
    public string FailedRecipient { get; }
    public SmtpFailedRecipientException(string message);
    protected SmtpFailedRecipientException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient);
    public SmtpFailedRecipientException(string message, Exception innerException);
    public SmtpFailedRecipientException(string message, string failedRecipient, Exception innerException);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient, string serverResponse);
    public string get_FailedRecipient();
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Net.Mail.SmtpFailedRecipientsException : SmtpFailedRecipientException {
    private SmtpFailedRecipientException[] innerExceptions;
    public SmtpFailedRecipientException[] InnerExceptions { get; }
    public SmtpFailedRecipientsException(string message);
    public SmtpFailedRecipientsException(string message, Exception innerException);
    public SmtpFailedRecipientsException(string message, SmtpFailedRecipientException[] innerExceptions);
    protected SmtpFailedRecipientsException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientException[] get_InnerExceptions();
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Net.Mail.SmtpPermission : CodeAccessPermission {
    private static int version;
    private bool unrestricted;
    private SmtpAccess access;
    public SmtpAccess Access { get; }
    public SmtpPermission(bool unrestricted);
    public SmtpPermission(PermissionState state);
    public SmtpPermission(SmtpAccess access);
    public SmtpAccess get_Access();
    public void AddPermission(SmtpAccess access);
    public virtual IPermission Copy();
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Union(IPermission target);
    private bool IsEmpty();
    private SmtpPermission Cast(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Net.Mail.SmtpPermissionAttribute : CodeAccessSecurityAttribute {
    private string access;
    public string Access { get; public set; }
    public SmtpPermissionAttribute(SecurityAction action);
    public string get_Access();
    public void set_Access(string value);
    private SmtpAccess GetSmtpAccess();
    public virtual IPermission CreatePermission();
}
public enum System.Net.Mail.SmtpStatusCode : Enum {
    public int value__;
    public static SmtpStatusCode BadCommandSequence;
    public static SmtpStatusCode CannotVerifyUserWillAttemptDelivery;
    public static SmtpStatusCode ClientNotPermitted;
    public static SmtpStatusCode CommandNotImplemented;
    public static SmtpStatusCode CommandParameterNotImplemented;
    public static SmtpStatusCode CommandUnrecognized;
    public static SmtpStatusCode ExceededStorageAllocation;
    public static SmtpStatusCode GeneralFailure;
    public static SmtpStatusCode HelpMessage;
    public static SmtpStatusCode InsufficientStorage;
    public static SmtpStatusCode LocalErrorInProcessing;
    public static SmtpStatusCode MailboxBusy;
    public static SmtpStatusCode MailboxNameNotAllowed;
    public static SmtpStatusCode MailboxUnavailable;
    public static SmtpStatusCode Ok;
    public static SmtpStatusCode ServiceClosingTransmissionChannel;
    public static SmtpStatusCode ServiceNotAvailable;
    public static SmtpStatusCode ServiceReady;
    public static SmtpStatusCode StartMailInput;
    public static SmtpStatusCode SyntaxError;
    public static SmtpStatusCode SystemStatus;
    public static SmtpStatusCode TransactionFailed;
    public static SmtpStatusCode UserNotLocalTryAlternatePath;
    public static SmtpStatusCode UserNotLocalWillForward;
    public static SmtpStatusCode MustIssueStartTlsFirst;
}
internal static class System.Net.Mail.WhitespaceReader : object {
    internal static int ReadFwsReverse(string data, int index);
    internal static int ReadCfwsReverse(string data, int index);
}
internal class System.Net.Mime.Base64WriteStateInfo : WriteStateInfoBase {
    [CompilerGeneratedAttribute]
private int <Padding>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <LastBits>k__BackingField;
    internal int Padding { get; internal set; }
    internal byte LastBits { get; internal set; }
    internal Base64WriteStateInfo(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    [CompilerGeneratedAttribute]
internal int get_Padding();
    [CompilerGeneratedAttribute]
internal void set_Padding(int value);
    [CompilerGeneratedAttribute]
internal byte get_LastBits();
    [CompilerGeneratedAttribute]
internal void set_LastBits(byte value);
}
internal abstract class System.Net.Mime.BaseWriter : object {
    private static int DefaultLineLength;
    private static AsyncCallback s_onWrite;
    protected static Byte[] s_crlf;
    protected BufferBuilder _bufferBuilder;
    protected Stream _stream;
    private EventHandler _onCloseHandler;
    private bool _shouldEncodeLeadingDots;
    private int _lineLength;
    protected Stream _contentStream;
    protected bool _isInContent;
    protected BaseWriter(Stream stream, bool shouldEncodeLeadingDots);
    private static BaseWriter();
    internal abstract virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal void WriteHeader(string name, string value, bool allowUnicode);
    private void WriteAndFold(string value, int charsAlreadyOnLine, bool allowUnicode);
    internal Stream GetContentStream();
    private Stream GetContentStream(MultiAsyncResult multiResult);
    internal IAsyncResult BeginGetContentStream(AsyncCallback callback, object state);
    internal Stream EndGetContentStream(IAsyncResult result);
    protected void Flush(MultiAsyncResult multiResult);
    protected static void OnWrite(IAsyncResult result);
    internal abstract virtual void Close();
    protected abstract virtual void OnClose(object sender, EventArgs args);
    protected virtual void CheckBoundary();
}
public class System.Net.Mime.ContentDisposition : object {
    private static string CreationDateKey;
    private static string ModificationDateKey;
    private static string ReadDateKey;
    private static string FileNameKey;
    private static string SizeKey;
    private TrackingValidationObjectDictionary _parameters;
    private string _disposition;
    private string _dispositionType;
    private bool _isChanged;
    private bool _isPersisted;
    private static ValidateAndParseValue s_dateParser;
    private static ValidateAndParseValue s_longParser;
    private static Dictionary`2<string, ValidateAndParseValue> s_validators;
    public string DispositionType { get; public set; }
    public StringDictionary Parameters { get; }
    public string FileName { get; public set; }
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    public bool Inline { get; public set; }
    public DateTime ReadDate { get; public set; }
    public long Size { get; public set; }
    internal bool IsChanged { get; }
    public ContentDisposition(string disposition);
    private static ContentDisposition();
    internal DateTime GetDateParameter(string parameterName);
    public string get_DispositionType();
    public void set_DispositionType(string value);
    public StringDictionary get_Parameters();
    public string get_FileName();
    public void set_FileName(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    public bool get_Inline();
    public void set_Inline(bool value);
    public DateTime get_ReadDate();
    public void set_ReadDate(DateTime value);
    public long get_Size();
    public void set_Size(long value);
    internal void Set(string contentDisposition, HeaderCollection headers);
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    private static void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    private void ParseValue();
}
public class System.Net.Mime.ContentType : object {
    private TrackingStringDictionary _parameters;
    private string _mediaType;
    private string _subType;
    private bool _isChanged;
    private string _type;
    private bool _isPersisted;
    internal static string Default;
    public string Boundary { get; public set; }
    public string CharSet { get; public set; }
    public string MediaType { get; public set; }
    public string Name { get; public set; }
    public StringDictionary Parameters { get; }
    internal bool IsChanged { get; }
    public ContentType(string contentType);
    public string get_Boundary();
    public void set_Boundary(string value);
    public string get_CharSet();
    public void set_CharSet(string value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public string get_Name();
    public void set_Name(string value);
    public StringDictionary get_Parameters();
    internal void Set(string contentType, HeaderCollection headers);
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    private static void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    private void ParseValue();
}
public static class System.Net.Mime.DispositionTypeNames : object {
    public static string Inline;
    public static string Attachment;
}
internal class System.Net.Mime.EightBitStream : DelegatedStream {
    private WriteStateInfoBase _writeState;
    private bool _shouldEncodeLeadingDots;
    private WriteStateInfoBase WriteState { get; }
    internal EightBitStream(Stream stream);
    internal EightBitStream(Stream stream, bool shouldEncodeLeadingDots);
    private WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void EncodeLines(Byte[] buffer, int offset, int count);
    public sealed virtual Stream GetStream();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual string GetEncodedString();
}
internal class System.Net.Mime.EncodedStreamFactory : object {
    internal static int DefaultMaxLineLength;
    private static int InitialBufferSize;
    internal IEncodableStream GetEncoder(TransferEncoding encoding, Stream stream);
    internal IEncodableStream GetEncoderForHeader(Encoding encoding, bool useBase64Encoding, int headerTextLength);
    protected Byte[] CreateHeader(Encoding encoding, bool useBase64Encoding);
    protected Byte[] CreateFooter();
}
internal class System.Net.Mime.HeaderCollection : NameValueCollection {
    private MimeBasePart _part;
    public virtual void Remove(string name);
    public virtual string Get(string name);
    public virtual String[] GetValues(string name);
    internal void InternalRemove(string name);
    internal void InternalSet(string name, string value);
    internal void InternalAdd(string name, string value);
    public virtual void Set(string name, string value);
    public virtual void Add(string name, string value);
}
internal interface System.Net.Mime.IEncodableStream {
    public abstract virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual string GetEncodedString();
    public abstract virtual Stream GetStream();
}
internal static class System.Net.Mime.MailBnfHelper : object {
    internal static Boolean[] Atext;
    internal static Boolean[] Qtext;
    internal static Boolean[] Dtext;
    internal static Boolean[] Ftext;
    internal static Boolean[] Ttext;
    internal static Boolean[] Ctext;
    internal static int Ascii7bitMaxValue;
    internal static char Quote;
    internal static char Space;
    internal static char Tab;
    internal static char CR;
    internal static char LF;
    internal static char StartComment;
    internal static char EndComment;
    internal static char Backslash;
    internal static char At;
    internal static char EndAngleBracket;
    internal static char StartAngleBracket;
    internal static char StartSquareBracket;
    internal static char EndSquareBracket;
    internal static char Comma;
    internal static char Dot;
    private static Char[] s_colonSeparator;
    private static String[] s_months;
    private static MailBnfHelper();
    private static Boolean[] CreateCharactersAllowedInAtoms();
    private static Boolean[] CreateCharactersAllowedInQuotedStrings();
    private static Boolean[] CreateCharactersAllowedInDomainLiterals();
    private static Boolean[] CreateCharactersAllowedInHeaderNames();
    private static Boolean[] CreateCharactersAllowedInTokens();
    private static Boolean[] CreateCharactersAllowedInComments();
    internal static bool SkipCFWS(string data, Int32& offset);
    internal static void ValidateHeaderName(string data);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder, bool doesntRequireQuotes, bool permitUnicodeInDisplayName);
    internal static string ReadParameterAttribute(string data, Int32& offset, StringBuilder builder);
    internal static string ReadToken(string data, Int32& offset, StringBuilder builder);
    internal static string GetDateTimeString(DateTime value, StringBuilder builder);
    internal static void GetTokenOrQuotedString(string data, StringBuilder builder, bool allowUnicode);
    private static bool CheckForUnicode(char ch, bool allowUnicode);
    internal static bool IsAllowedWhiteSpace(char c);
    internal static bool HasCROrLF(string data);
    internal static bool IsFWSAt(string data, int index);
}
public static class System.Net.Mime.MediaTypeNames : object {
}
internal class System.Net.Mime.MimeBasePart : object {
    internal static string DefaultCharSet;
    private static Char[] s_decodeEncodingSplitChars;
    protected ContentType _contentType;
    protected ContentDisposition _contentDisposition;
    private HeaderCollection _headers;
    private static Char[] s_headerValueSplitChars;
    private static Char[] s_questionMarkSplitChars;
    internal string ContentID { get; internal set; }
    internal string ContentLocation { get; internal set; }
    internal NameValueCollection Headers { get; }
    internal ContentType ContentType { get; internal set; }
    private static MimeBasePart();
    internal static bool ShouldUseBase64Encoding(Encoding encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding, int headerLength);
    internal static string DecodeHeaderValue(string value);
    internal static Encoding DecodeEncoding(string value);
    internal static bool IsAscii(string value, bool permitCROrLF);
    internal string get_ContentID();
    internal void set_ContentID(string value);
    internal string get_ContentLocation();
    internal void set_ContentLocation(string value);
    internal NameValueCollection get_Headers();
    internal ContentType get_ContentType();
    internal void set_ContentType(ContentType value);
    internal void PrepareHeaders(bool allowUnicode);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal void EndSend(IAsyncResult asyncResult);
}
internal class System.Net.Mime.MimeMultiPart : MimeBasePart {
    private Collection`1<MimeBasePart> _parts;
    private static int s_boundary;
    private AsyncCallback _mimePartSentCallback;
    private bool _allowUnicode;
    unknown MimeMultiPartType MimeMultiPartType {internal set; }
    internal Collection`1<MimeBasePart> Parts { get; }
    internal MimeMultiPart(MimeMultiPartType type);
    internal void set_MimeMultiPartType(MimeMultiPartType value);
    private void SetType(MimeMultiPartType type);
    internal Collection`1<MimeBasePart> get_Parts();
    internal void Complete(IAsyncResult result, Exception e);
    internal void MimeWriterCloseCallback(IAsyncResult result);
    private void MimeWriterCloseCallbackHandler(IAsyncResult result);
    internal void MimePartSentCallback(IAsyncResult result);
    private void MimePartSentCallbackHandler(IAsyncResult result);
    internal void ContentStreamCallback(IAsyncResult result);
    private void ContentStreamCallbackHandler(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal string GetNextBoundary();
}
internal enum System.Net.Mime.MimeMultiPartType : Enum {
    public int value__;
    public static MimeMultiPartType Mixed;
    public static MimeMultiPartType Alternative;
    public static MimeMultiPartType Parallel;
    public static MimeMultiPartType Related;
    public static MimeMultiPartType Unknown;
}
internal class System.Net.Mime.MimePart : MimeBasePart {
    private Stream _stream;
    private bool _streamSet;
    private bool _streamUsedOnce;
    private AsyncCallback _readCallback;
    private AsyncCallback _writeCallback;
    private static int maxBufferSize;
    internal Stream Stream { get; }
    internal ContentDisposition ContentDisposition { get; internal set; }
    internal TransferEncoding TransferEncoding { get; internal set; }
    public sealed virtual void Dispose();
    internal Stream get_Stream();
    internal ContentDisposition get_ContentDisposition();
    internal void set_ContentDisposition(ContentDisposition value);
    internal TransferEncoding get_TransferEncoding();
    internal void set_TransferEncoding(TransferEncoding value);
    internal void SetContent(Stream stream);
    internal void SetContent(Stream stream, string name, string mimeType);
    internal void SetContent(Stream stream, ContentType contentType);
    internal void Complete(IAsyncResult result, Exception e);
    internal void ReadCallback(IAsyncResult result);
    internal void ReadCallbackHandler(IAsyncResult result);
    internal void WriteCallback(IAsyncResult result);
    internal void WriteCallbackHandler(IAsyncResult result);
    internal Stream GetEncodedStream(Stream stream);
    internal void ContentStreamCallbackHandler(IAsyncResult result);
    internal void ContentStreamCallback(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal void ResetStream();
}
internal class System.Net.Mime.MimeWriter : BaseWriter {
    private static Byte[] s_DASHDASH;
    private Byte[] _boundaryBytes;
    private bool _writeBoundary;
    internal MimeWriter(Stream stream, string boundary);
    private static MimeWriter();
    internal virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal IAsyncResult BeginClose(AsyncCallback callback, object state);
    internal void EndClose(IAsyncResult result);
    internal virtual void Close();
    private void Close(MultiAsyncResult multiResult);
    protected virtual void OnClose(object sender, EventArgs args);
    protected virtual void CheckBoundary();
}
internal class System.Net.Mime.MultiAsyncResult : LazyAsyncResult {
    private object _context;
    private int _outstanding;
    internal object Context { get; }
    internal MultiAsyncResult(object context, AsyncCallback callback, object state);
    internal object get_Context();
    internal void Enter();
    internal void Leave();
    internal void Leave(object result);
    private void Decrement();
    private void Increment();
    internal void CompleteSequence();
    internal static object End(IAsyncResult result);
}
internal class System.Net.Mime.QEncodedStream : DelegatedStream {
    private static int SizeOfFoldingCRLF;
    private static Byte[] s_hexDecodeMap;
    private static Byte[] s_hexEncodeMap;
    private ReadStateInfo _readState;
    private WriteStateInfoBase _writeState;
    private ReadStateInfo ReadState { get; }
    internal WriteStateInfoBase WriteState { get; }
    internal QEncodedStream(WriteStateInfoBase wsi);
    private static QEncodedStream();
    private ReadStateInfo get_ReadState();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    private static bool IsAsciiLetterOrDigit(char character);
    private static bool IsAsciiLetter(char character);
    public sealed virtual Stream GetStream();
    public sealed virtual string GetEncodedString();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    private void FlushInternal();
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Net.Mime.QuotedPrintableStream : DelegatedStream {
    private bool _encodeCRLF;
    private static int SizeOfSoftCRLF;
    private static int SizeOfEncodedChar;
    private static int SizeOfEncodedCRLF;
    private static int SizeOfNonEncodedCRLF;
    private static Byte[] s_hexDecodeMap;
    private static Byte[] s_hexEncodeMap;
    private int _lineLength;
    private ReadStateInfo _readState;
    private WriteStateInfoBase _writeState;
    private ReadStateInfo ReadState { get; }
    internal WriteStateInfoBase WriteState { get; }
    internal QuotedPrintableStream(Stream stream, int lineLength);
    internal QuotedPrintableStream(Stream stream, bool encodeCRLF);
    private static QuotedPrintableStream();
    private ReadStateInfo get_ReadState();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual Stream GetStream();
    public sealed virtual string GetEncodedString();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    private void FlushInternal();
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Net.Mime.SmtpDateTime : object {
    internal static string UnknownTimeZoneDefaultOffset;
    internal static string UtcDefaultTimeZoneOffset;
    internal static int OffsetLength;
    internal static int MaxMinuteValue;
    internal static string DateFormatWithDayOfWeek;
    internal static string DateFormatWithoutDayOfWeek;
    internal static string DateFormatWithDayOfWeekAndNoSeconds;
    internal static string DateFormatWithoutDayOfWeekAndNoSeconds;
    internal static String[] s_validDateTimeFormats;
    internal static Char[] s_allowedWhiteSpaceChars;
    internal static Dictionary`2<string, TimeSpan> s_timeZoneOffsetLookup;
    internal static long TimeSpanMaxTicks;
    internal static int OffsetMaxValue;
    private DateTime _date;
    private TimeSpan _timeZone;
    private bool _unknownTimeZone;
    internal DateTime Date { get; }
    internal SmtpDateTime(DateTime value);
    internal SmtpDateTime(string value);
    private static SmtpDateTime();
    internal static Dictionary`2<string, TimeSpan> InitializeShortHandLookups();
    internal DateTime get_Date();
    public virtual string ToString();
    internal void ValidateAndGetTimeZoneOffsetValues(string offset, Boolean& positive, Int32& hours, Int32& minutes);
    internal void ValidateTimeZoneShortHandValue(string value);
    internal string FormatDate(DateTime value);
    internal DateTime ParseValue(string data, String& timeZone);
    internal bool TryParseTimeZoneString(string timeZoneString, TimeSpan& timeZone);
    internal TimeSpan ValidateAndGetSanitizedTimeSpan(TimeSpan span);
    internal string TimeSpanToOffset(TimeSpan span);
}
public enum System.Net.Mime.TransferEncoding : Enum {
    public int value__;
    public static TransferEncoding Unknown;
    public static TransferEncoding QuotedPrintable;
    public static TransferEncoding Base64;
    public static TransferEncoding SevenBit;
    public static TransferEncoding EightBit;
}
internal class System.Net.Mime.WriteStateInfoBase : object {
    protected Byte[] _header;
    protected Byte[] _footer;
    protected int _maxLineLength;
    protected Byte[] _buffer;
    protected int _currentLineLength;
    protected int _currentBufferUsed;
    protected static int DefaultBufferSize;
    internal int FooterLength { get; }
    internal Byte[] Footer { get; }
    internal Byte[] Header { get; }
    internal Byte[] Buffer { get; }
    internal int Length { get; }
    internal int CurrentLineLength { get; }
    internal int MaxLineLength { get; }
    internal WriteStateInfoBase(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength);
    internal WriteStateInfoBase(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    internal int get_FooterLength();
    internal Byte[] get_Footer();
    internal Byte[] get_Header();
    internal Byte[] get_Buffer();
    internal int get_Length();
    internal int get_CurrentLineLength();
    private void EnsureSpaceInBuffer(int moreBytes);
    internal void Append(byte aByte);
    internal void Append(Byte[] bytes);
    internal void AppendCRLF(bool includeSpace);
    internal void AppendHeader();
    internal void AppendFooter();
    internal int get_MaxLineLength();
    internal void Reset();
    internal void BufferFlushed();
}
internal class System.Net.MonoChunkParser : object {
    private WebHeaderCollection headers;
    private int chunkSize;
    private int chunkRead;
    private int totalWritten;
    private State state;
    private StringBuilder saved;
    private bool sawCR;
    private bool gotit;
    private int trailerState;
    private ArrayList chunks;
    public bool WantMore { get; }
    public bool DataAvailable { get; }
    public int TotalDataSize { get; }
    public int ChunkLeft { get; }
    public MonoChunkParser(WebHeaderCollection headers);
    public void WriteAndReadBack(Byte[] buffer, int offset, int size, Int32& read);
    public int Read(Byte[] buffer, int offset, int size);
    private int ReadFromChunks(Byte[] buffer, int offset, int size);
    public void Write(Byte[] buffer, int offset, int size);
    private void InternalWrite(Byte[] buffer, Int32& offset, int size);
    public bool get_WantMore();
    public bool get_DataAvailable();
    public int get_TotalDataSize();
    public int get_ChunkLeft();
    private State ReadBody(Byte[] buffer, Int32& offset, int size);
    private State GetChunkSize(Byte[] buffer, Int32& offset, int size);
    private static string RemoveChunkExtension(string input);
    private State ReadCRLF(Byte[] buffer, Int32& offset, int size);
    private State ReadTrailer(Byte[] buffer, Int32& offset, int size);
    private static void ThrowProtocolViolation(string message);
}
internal class System.Net.MonoChunkStream : WebReadStream {
    [CompilerGeneratedAttribute]
private WebHeaderCollection <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private MonoChunkParser <Decoder>k__BackingField;
    protected WebHeaderCollection Headers { get; }
    protected MonoChunkParser Decoder { get; }
    public MonoChunkStream(WebOperation operation, Stream innerStream, WebHeaderCollection headers);
    [CompilerGeneratedAttribute]
protected WebHeaderCollection get_Headers();
    [CompilerGeneratedAttribute]
protected MonoChunkParser get_Decoder();
    [AsyncStateMachineAttribute("System.Net.MonoChunkStream/<ProcessReadAsync>d__7")]
protected virtual Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.MonoChunkStream/<FinishReading>d__8")]
internal virtual Task FinishReading(CancellationToken cancellationToken);
    private static void ThrowExpectingChunkTrailer();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
}
internal class System.Net.MonoHttpDate : object {
    private static string rfc1123_date;
    private static string rfc850_date;
    private static string asctime_date;
    private static String[] formats;
    private static MonoHttpDate();
    internal static DateTime Parse(string dateStr);
}
internal static class System.Net.NclConstants : object {
    internal static object Sentinel;
    internal static Object[] EmptyObjectArray;
    internal static Uri[] EmptyUriArray;
    internal static Byte[] CRLF;
    internal static Byte[] ChunkTerminator;
    private static NclConstants();
}
internal static class System.Net.NclUtilities : object {
    private static ContextCallback modreq(System.Runtime.CompilerServices.IsVolatile) s_ContextRelativeDemandCallback;
    private static IPAddress[] modreq(System.Runtime.CompilerServices.IsVolatile) _LocalAddresses;
    private static object _LocalAddressesLock;
    private static int HostNameBufferLength;
    internal static string _LocalDomainName;
    internal static bool HasShutdownStarted { get; }
    internal static ContextCallback ContextRelativeDemandCallback { get; }
    internal static IPAddress[] LocalAddresses { get; }
    private static object LocalAddressesLock { get; }
    internal static bool IsThreadPoolLow();
    internal static bool get_HasShutdownStarted();
    internal static bool IsCredentialFailure(SecurityStatus error);
    internal static bool IsClientFault(SecurityStatus error);
    internal static ContextCallback get_ContextRelativeDemandCallback();
    private static void DemandCallback(object state);
    internal static bool GuessWhetherHostIsLoopback(string host);
    internal static bool IsFatal(Exception exception);
    internal static bool IsAddressLocal(IPAddress ipAddress);
    private static IPHostEntry GetLocalHost();
    internal static IPAddress[] get_LocalAddresses();
    private static object get_LocalAddressesLock();
}
internal class System.Net.NegotiationInfoClass : object {
    internal string AuthenticationPackage;
    internal static string NTLM;
    internal static string Kerberos;
    internal static string Negotiate;
    internal static string Basic;
    internal NegotiationInfoClass(SafeHandle safeHandle, int negotiationState);
}
internal class System.Net.NetConfig : object {
    internal bool ipv6Enabled;
    internal int MaxResponseHeadersLength;
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static string MissingMember;
    private static string NullInstance;
    private static string StaticMethodObject;
    private static string NoParameters;
    private static int MaxDumpSize;
    private static int EnterEventId;
    private static int ExitEventId;
    private static int AssociateEventId;
    private static int InfoEventId;
    private static int ErrorEventId;
    private static int CriticalFailureEventId;
    private static int DumpArrayEventId;
    private static int EnumerateSecurityPackagesId;
    private static int SspiPackageNotFoundId;
    private static int AcquireDefaultCredentialId;
    private static int AcquireCredentialsHandleId;
    private static int InitializeSecurityContextId;
    private static int SecurityContextInputBufferId;
    private static int SecurityContextInputBuffersId;
    private static int AcceptSecuritContextId;
    private static int OperationReturnedSomethingId;
    private static int NextAvailableEventId;
    public static bool IsEnabled { get; }
    private static NetEventSource();
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName);
    [EventAttribute("1")]
private void Enter(string thisOrContextObject, string memberName, string parameters);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, object arg1, string memberName);
    [EventAttribute("2")]
private void Exit(string thisOrContextObject, string memberName, string result);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("4")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("5")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, object message, string memberName);
    [EventAttribute("6")]
private void CriticalFailure(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, IntPtr bufferPtr, int count, string memberName);
    [EventAttribute("7")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(object arg);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(FormattableString arg);
    public static bool get_IsEnabled();
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static object Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, string arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4);
    [EventAttribute("10")]
public void AcquireDefaultCredential(string packageName, CredentialUse intent);
    [NonEventAttribute]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, object authdata);
    [EventAttribute("11")]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, string authdata);
    [NonEventAttribute]
public void InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, string targetName, ContextFlags inFlags);
    [EventAttribute("12")]
private void InitializeSecurityContext(string credential, string context, string targetName, ContextFlags inFlags);
    [NonEventAttribute]
public void AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, ContextFlags inFlags);
    [EventAttribute("15")]
private void AcceptSecurityContext(string credential, string context, ContextFlags inFlags);
    [EventAttribute("16")]
public void OperationReturnedSomething(string operation, SECURITY_STATUS errorCode);
    [EventAttribute("13")]
public void SecurityContextInputBuffer(string context, int inputBufferSize, int outputBufferSize, SECURITY_STATUS errorCode);
    [EventAttribute("14")]
public void SecurityContextInputBuffers(string context, int inputBuffersSize, int outputBufferSize, SECURITY_STATUS errorCode);
    [EventAttribute("8")]
public void EnumerateSecurityPackages(string securityPackage);
    [EventAttribute("9")]
public void SspiPackageNotFound(string packageName);
}
internal class System.Net.NetRes : object {
    public static string GetWebStatusString(string Res, WebExceptionStatus Status);
    public static string GetWebStatusString(WebExceptionStatus Status);
    public static string GetWebStatusCodeString(HttpStatusCode statusCode, string statusDescription);
    public static string GetWebStatusCodeString(FtpStatusCode statusCode, string statusDescription);
}
[FlagsAttribute]
public enum System.Net.NetworkAccess : Enum {
    public int value__;
    public static NetworkAccess Accept;
    public static NetworkAccess Connect;
}
public class System.Net.NetworkCredential : object {
    private string m_domain;
    private string m_userName;
    private SecureString m_password;
    public string UserName { get; public set; }
    public string Password { get; public set; }
    public SecureString SecurePassword { get; public set; }
    public string Domain { get; public set; }
    public NetworkCredential(string userName, string password);
    public NetworkCredential(string userName, SecureString password);
    public NetworkCredential(string userName, string password, string domain);
    public NetworkCredential(string userName, SecureString password, string domain);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    public SecureString get_SecurePassword();
    public void set_SecurePassword(SecureString value);
    public string get_Domain();
    public void set_Domain(string value);
    internal string InternalGetUserName();
    internal string InternalGetPassword();
    internal SecureString InternalGetSecurePassword();
    internal string InternalGetDomain();
    internal string InternalGetDomainUserName();
    public sealed virtual NetworkCredential GetCredential(Uri uri, string authType);
    public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
}
internal class System.Net.NetworkInformation.AlignmentUnion : ValueType {
    public ulong Alignment;
    public int Length;
    public int IfIndex;
}
public enum System.Net.NetworkInformation.DuplicateAddressDetectionState : Enum {
    public int value__;
    public static DuplicateAddressDetectionState Invalid;
    public static DuplicateAddressDetectionState Tentative;
    public static DuplicateAddressDetectionState Duplicate;
    public static DuplicateAddressDetectionState Deprecated;
    public static DuplicateAddressDetectionState Preferred;
}
public abstract class System.Net.NetworkInformation.GatewayIPAddressInformation : object {
    public IPAddress Address { get; }
    public abstract virtual IPAddress get_Address();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.GatewayIPAddressInformationCollection : object {
    private Collection`1<GatewayIPAddressInformation> addresses;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public GatewayIPAddressInformation Item { get; }
    public virtual void CopyTo(GatewayIPAddressInformation[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual GatewayIPAddressInformation get_Item(int index);
    public virtual void Add(GatewayIPAddressInformation address);
    internal void InternalAdd(GatewayIPAddressInformation address);
    public virtual bool Contains(GatewayIPAddressInformation address);
    public virtual IEnumerator`1<GatewayIPAddressInformation> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Remove(GatewayIPAddressInformation address);
    public virtual void Clear();
}
internal enum System.Net.NetworkInformation.IcmpV4Code : Enum {
    public int value__;
    public static IcmpV4Code ICMP4_UNREACH_NET;
    public static IcmpV4Code ICMP4_UNREACH_HOST;
    public static IcmpV4Code ICMP4_UNREACH_PROTOCOL;
    public static IcmpV4Code ICMP4_UNREACH_PORT;
    public static IcmpV4Code ICMP4_UNREACH_FRAG_NEEDED;
    public static IcmpV4Code ICMP4_UNREACH_SOURCEROUTE_FAILED;
    public static IcmpV4Code ICMP4_UNREACH_NET_UNKNOWN;
    public static IcmpV4Code ICMP4_UNREACH_HOST_UNKNOWN;
    public static IcmpV4Code ICMP4_UNREACH_ISOLATED;
    public static IcmpV4Code ICMP4_UNREACH_NET_ADMIN;
    public static IcmpV4Code ICMP4_UNREACH_HOST_ADMIN;
    public static IcmpV4Code ICMP4_UNREACH_NET_TOS;
    public static IcmpV4Code ICMP4_UNREACH_HOST_TOS;
    public static IcmpV4Code ICMP4_UNREACH_ADMIN;
}
public abstract class System.Net.NetworkInformation.IcmpV4Statistics : object {
    public long AddressMaskRepliesReceived { get; }
    public long AddressMaskRepliesSent { get; }
    public long AddressMaskRequestsReceived { get; }
    public long AddressMaskRequestsSent { get; }
    public long DestinationUnreachableMessagesReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long EchoRepliesReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRequestsSent { get; }
    public long ErrorsReceived { get; }
    public long ErrorsSent { get; }
    public long MessagesReceived { get; }
    public long MessagesSent { get; }
    public long ParameterProblemsReceived { get; }
    public long ParameterProblemsSent { get; }
    public long RedirectsReceived { get; }
    public long RedirectsSent { get; }
    public long SourceQuenchesReceived { get; }
    public long SourceQuenchesSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public long TimestampRepliesReceived { get; }
    public long TimestampRepliesSent { get; }
    public long TimestampRequestsReceived { get; }
    public long TimestampRequestsSent { get; }
    public abstract virtual long get_AddressMaskRepliesReceived();
    public abstract virtual long get_AddressMaskRepliesSent();
    public abstract virtual long get_AddressMaskRequestsReceived();
    public abstract virtual long get_AddressMaskRequestsSent();
    public abstract virtual long get_DestinationUnreachableMessagesReceived();
    public abstract virtual long get_DestinationUnreachableMessagesSent();
    public abstract virtual long get_EchoRepliesReceived();
    public abstract virtual long get_EchoRepliesSent();
    public abstract virtual long get_EchoRequestsReceived();
    public abstract virtual long get_EchoRequestsSent();
    public abstract virtual long get_ErrorsReceived();
    public abstract virtual long get_ErrorsSent();
    public abstract virtual long get_MessagesReceived();
    public abstract virtual long get_MessagesSent();
    public abstract virtual long get_ParameterProblemsReceived();
    public abstract virtual long get_ParameterProblemsSent();
    public abstract virtual long get_RedirectsReceived();
    public abstract virtual long get_RedirectsSent();
    public abstract virtual long get_SourceQuenchesReceived();
    public abstract virtual long get_SourceQuenchesSent();
    public abstract virtual long get_TimeExceededMessagesReceived();
    public abstract virtual long get_TimeExceededMessagesSent();
    public abstract virtual long get_TimestampRepliesReceived();
    public abstract virtual long get_TimestampRepliesSent();
    public abstract virtual long get_TimestampRequestsReceived();
    public abstract virtual long get_TimestampRequestsSent();
}
internal enum System.Net.NetworkInformation.IcmpV4Type : Enum {
    public int value__;
    public static IcmpV4Type ICMP4_ECHO_REPLY;
    public static IcmpV4Type ICMP4_DST_UNREACH;
    public static IcmpV4Type ICMP4_SOURCE_QUENCH;
    public static IcmpV4Type ICMP4_TIME_EXCEEDED;
    public static IcmpV4Type ICMP4_PARAM_PROB;
    public static IcmpV4Type ICMP4_REDIRECT;
    public static IcmpV4Type ICMP4_ECHO_REQUEST;
    public static IcmpV4Type ICMP4_ROUTER_ADVERT;
    public static IcmpV4Type ICMP4_ROUTER_SOLICIT;
    public static IcmpV4Type ICMP4_TIMESTAMP_REQUEST;
    public static IcmpV4Type ICMP4_TIMESTAMP_REPLY;
    public static IcmpV4Type ICMP4_MASK_REQUEST;
    public static IcmpV4Type ICMP4_MASK_REPLY;
}
internal class System.Net.NetworkInformation.IcmpV6MessageTypes : object {
    public static int DestinationUnreachable;
    public static int PacketTooBig;
    public static int TimeExceeded;
    public static int ParameterProblem;
    public static int EchoRequest;
    public static int EchoReply;
    public static int GroupMembershipQuery;
    public static int GroupMembershipReport;
    public static int GroupMembershipReduction;
    public static int RouterSolicitation;
    public static int RouterAdvertisement;
    public static int NeighborSolicitation;
    public static int NeighborAdvertisement;
    public static int Redirect;
    public static int RouterRenumbering;
}
public abstract class System.Net.NetworkInformation.IcmpV6Statistics : object {
    public long DestinationUnreachableMessagesReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long EchoRepliesReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRequestsSent { get; }
    public long ErrorsReceived { get; }
    public long ErrorsSent { get; }
    public long MembershipQueriesReceived { get; }
    public long MembershipQueriesSent { get; }
    public long MembershipReductionsReceived { get; }
    public long MembershipReductionsSent { get; }
    public long MembershipReportsReceived { get; }
    public long MembershipReportsSent { get; }
    public long MessagesReceived { get; }
    public long MessagesSent { get; }
    public long NeighborAdvertisementsReceived { get; }
    public long NeighborAdvertisementsSent { get; }
    public long NeighborSolicitsReceived { get; }
    public long NeighborSolicitsSent { get; }
    public long PacketTooBigMessagesReceived { get; }
    public long PacketTooBigMessagesSent { get; }
    public long ParameterProblemsReceived { get; }
    public long ParameterProblemsSent { get; }
    public long RedirectsReceived { get; }
    public long RedirectsSent { get; }
    public long RouterAdvertisementsReceived { get; }
    public long RouterAdvertisementsSent { get; }
    public long RouterSolicitsReceived { get; }
    public long RouterSolicitsSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public abstract virtual long get_DestinationUnreachableMessagesReceived();
    public abstract virtual long get_DestinationUnreachableMessagesSent();
    public abstract virtual long get_EchoRepliesReceived();
    public abstract virtual long get_EchoRepliesSent();
    public abstract virtual long get_EchoRequestsReceived();
    public abstract virtual long get_EchoRequestsSent();
    public abstract virtual long get_ErrorsReceived();
    public abstract virtual long get_ErrorsSent();
    public abstract virtual long get_MembershipQueriesReceived();
    public abstract virtual long get_MembershipQueriesSent();
    public abstract virtual long get_MembershipReductionsReceived();
    public abstract virtual long get_MembershipReductionsSent();
    public abstract virtual long get_MembershipReportsReceived();
    public abstract virtual long get_MembershipReportsSent();
    public abstract virtual long get_MessagesReceived();
    public abstract virtual long get_MessagesSent();
    public abstract virtual long get_NeighborAdvertisementsReceived();
    public abstract virtual long get_NeighborAdvertisementsSent();
    public abstract virtual long get_NeighborSolicitsReceived();
    public abstract virtual long get_NeighborSolicitsSent();
    public abstract virtual long get_PacketTooBigMessagesReceived();
    public abstract virtual long get_PacketTooBigMessagesSent();
    public abstract virtual long get_ParameterProblemsReceived();
    public abstract virtual long get_ParameterProblemsSent();
    public abstract virtual long get_RedirectsReceived();
    public abstract virtual long get_RedirectsSent();
    public abstract virtual long get_RouterAdvertisementsReceived();
    public abstract virtual long get_RouterAdvertisementsSent();
    public abstract virtual long get_RouterSolicitsReceived();
    public abstract virtual long get_RouterSolicitsSent();
    public abstract virtual long get_TimeExceededMessagesReceived();
    public abstract virtual long get_TimeExceededMessagesSent();
}
internal interface System.Net.NetworkInformation.INetworkChange {
    public bool HasRegisteredEvents { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    public abstract virtual bool get_HasRegisteredEvents();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.IPAddressCollection : object {
    private Collection`1<IPAddress> addresses;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IPAddress Item { get; }
    public virtual void CopyTo(IPAddress[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Add(IPAddress address);
    internal void InternalAdd(IPAddress address);
    public virtual bool Contains(IPAddress address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<IPAddress> GetEnumerator();
    public virtual IPAddress get_Item(int index);
    public virtual bool Remove(IPAddress address);
    public virtual void Clear();
}
public abstract class System.Net.NetworkInformation.IPAddressInformation : object {
    public IPAddress Address { get; }
    public bool IsDnsEligible { get; }
    public bool IsTransient { get; }
    public abstract virtual IPAddress get_Address();
    public abstract virtual bool get_IsDnsEligible();
    public abstract virtual bool get_IsTransient();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.IPAddressInformationCollection : object {
    private Collection`1<IPAddressInformation> addresses;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IPAddressInformation Item { get; }
    public virtual void CopyTo(IPAddressInformation[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Add(IPAddressInformation address);
    internal void InternalAdd(IPAddressInformation address);
    public virtual bool Contains(IPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<IPAddressInformation> GetEnumerator();
    public virtual IPAddressInformation get_Item(int index);
    public virtual bool Remove(IPAddressInformation address);
    public virtual void Clear();
}
public abstract class System.Net.NetworkInformation.IPGlobalProperties : object {
    public string DhcpScopeName { get; }
    public string DomainName { get; }
    public string HostName { get; }
    public bool IsWinsProxy { get; }
    public NetBiosNodeType NodeType { get; }
    public static IPGlobalProperties GetIPGlobalProperties();
    internal static IPGlobalProperties InternalGetIPGlobalProperties();
    public abstract virtual IPEndPoint[] GetActiveUdpListeners();
    public abstract virtual IPEndPoint[] GetActiveTcpListeners();
    public abstract virtual TcpConnectionInformation[] GetActiveTcpConnections();
    public abstract virtual string get_DhcpScopeName();
    public abstract virtual string get_DomainName();
    public abstract virtual string get_HostName();
    public abstract virtual bool get_IsWinsProxy();
    public abstract virtual NetBiosNodeType get_NodeType();
    public abstract virtual TcpStatistics GetTcpIPv4Statistics();
    public abstract virtual TcpStatistics GetTcpIPv6Statistics();
    public abstract virtual UdpStatistics GetUdpIPv4Statistics();
    public abstract virtual UdpStatistics GetUdpIPv6Statistics();
    public abstract virtual IcmpV4Statistics GetIcmpV4Statistics();
    public abstract virtual IcmpV6Statistics GetIcmpV6Statistics();
    public abstract virtual IPGlobalStatistics GetIPv4GlobalStatistics();
    public abstract virtual IPGlobalStatistics GetIPv6GlobalStatistics();
    public virtual UnicastIPAddressInformationCollection GetUnicastAddresses();
    public virtual IAsyncResult BeginGetUnicastAddresses(AsyncCallback callback, object state);
    public virtual UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult);
    public virtual Task`1<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync();
}
internal static class System.Net.NetworkInformation.IPGlobalPropertiesFactoryPal : object {
    public static IPGlobalProperties Create();
}
public abstract class System.Net.NetworkInformation.IPGlobalStatistics : object {
    public int DefaultTtl { get; }
    public bool ForwardingEnabled { get; }
    public int NumberOfInterfaces { get; }
    public int NumberOfIPAddresses { get; }
    public long OutputPacketRequests { get; }
    public long OutputPacketRoutingDiscards { get; }
    public long OutputPacketsDiscarded { get; }
    public long OutputPacketsWithNoRoute { get; }
    public long PacketFragmentFailures { get; }
    public long PacketReassembliesRequired { get; }
    public long PacketReassemblyFailures { get; }
    public long PacketReassemblyTimeout { get; }
    public long PacketsFragmented { get; }
    public long PacketsReassembled { get; }
    public long ReceivedPackets { get; }
    public long ReceivedPacketsDelivered { get; }
    public long ReceivedPacketsDiscarded { get; }
    public long ReceivedPacketsForwarded { get; }
    public long ReceivedPacketsWithAddressErrors { get; }
    public long ReceivedPacketsWithHeadersErrors { get; }
    public long ReceivedPacketsWithUnknownProtocol { get; }
    public int NumberOfRoutes { get; }
    public abstract virtual int get_DefaultTtl();
    public abstract virtual bool get_ForwardingEnabled();
    public abstract virtual int get_NumberOfInterfaces();
    public abstract virtual int get_NumberOfIPAddresses();
    public abstract virtual long get_OutputPacketRequests();
    public abstract virtual long get_OutputPacketRoutingDiscards();
    public abstract virtual long get_OutputPacketsDiscarded();
    public abstract virtual long get_OutputPacketsWithNoRoute();
    public abstract virtual long get_PacketFragmentFailures();
    public abstract virtual long get_PacketReassembliesRequired();
    public abstract virtual long get_PacketReassemblyFailures();
    public abstract virtual long get_PacketReassemblyTimeout();
    public abstract virtual long get_PacketsFragmented();
    public abstract virtual long get_PacketsReassembled();
    public abstract virtual long get_ReceivedPackets();
    public abstract virtual long get_ReceivedPacketsDelivered();
    public abstract virtual long get_ReceivedPacketsDiscarded();
    public abstract virtual long get_ReceivedPacketsForwarded();
    public abstract virtual long get_ReceivedPacketsWithAddressErrors();
    public abstract virtual long get_ReceivedPacketsWithHeadersErrors();
    public abstract virtual long get_ReceivedPacketsWithUnknownProtocol();
    public abstract virtual int get_NumberOfRoutes();
}
public abstract class System.Net.NetworkInformation.IPInterfaceProperties : object {
    public bool IsDnsEnabled { get; }
    public string DnsSuffix { get; }
    public bool IsDynamicDnsEnabled { get; }
    public UnicastIPAddressInformationCollection UnicastAddresses { get; }
    public MulticastIPAddressInformationCollection MulticastAddresses { get; }
    public IPAddressInformationCollection AnycastAddresses { get; }
    public IPAddressCollection DnsAddresses { get; }
    public GatewayIPAddressInformationCollection GatewayAddresses { get; }
    public IPAddressCollection DhcpServerAddresses { get; }
    public IPAddressCollection WinsServersAddresses { get; }
    public abstract virtual bool get_IsDnsEnabled();
    public abstract virtual string get_DnsSuffix();
    public abstract virtual bool get_IsDynamicDnsEnabled();
    public abstract virtual UnicastIPAddressInformationCollection get_UnicastAddresses();
    public abstract virtual MulticastIPAddressInformationCollection get_MulticastAddresses();
    public abstract virtual IPAddressInformationCollection get_AnycastAddresses();
    public abstract virtual IPAddressCollection get_DnsAddresses();
    public abstract virtual GatewayIPAddressInformationCollection get_GatewayAddresses();
    public abstract virtual IPAddressCollection get_DhcpServerAddresses();
    public abstract virtual IPAddressCollection get_WinsServersAddresses();
    public abstract virtual IPv4InterfaceProperties GetIPv4Properties();
    public abstract virtual IPv6InterfaceProperties GetIPv6Properties();
}
public abstract class System.Net.NetworkInformation.IPInterfaceStatistics : object {
    public long BytesReceived { get; }
    public long BytesSent { get; }
    public long IncomingPacketsDiscarded { get; }
    public long IncomingPacketsWithErrors { get; }
    public long IncomingUnknownProtocolPackets { get; }
    public long NonUnicastPacketsReceived { get; }
    public long NonUnicastPacketsSent { get; }
    public long OutgoingPacketsDiscarded { get; }
    public long OutgoingPacketsWithErrors { get; }
    public long OutputQueueLength { get; }
    public long UnicastPacketsReceived { get; }
    public long UnicastPacketsSent { get; }
    public abstract virtual long get_BytesReceived();
    public abstract virtual long get_BytesSent();
    public abstract virtual long get_IncomingPacketsDiscarded();
    public abstract virtual long get_IncomingPacketsWithErrors();
    public abstract virtual long get_IncomingUnknownProtocolPackets();
    public abstract virtual long get_NonUnicastPacketsReceived();
    public abstract virtual long get_NonUnicastPacketsSent();
    public abstract virtual long get_OutgoingPacketsDiscarded();
    public abstract virtual long get_OutgoingPacketsWithErrors();
    public abstract virtual long get_OutputQueueLength();
    public abstract virtual long get_UnicastPacketsReceived();
    public abstract virtual long get_UnicastPacketsSent();
}
public enum System.Net.NetworkInformation.IPStatus : Enum {
    public int value__;
    public static IPStatus Success;
    public static IPStatus DestinationNetworkUnreachable;
    public static IPStatus DestinationHostUnreachable;
    public static IPStatus DestinationProtocolUnreachable;
    public static IPStatus DestinationPortUnreachable;
    public static IPStatus DestinationProhibited;
    public static IPStatus NoResources;
    public static IPStatus BadOption;
    public static IPStatus HardwareError;
    public static IPStatus PacketTooBig;
    public static IPStatus TimedOut;
    public static IPStatus BadRoute;
    public static IPStatus TtlExpired;
    public static IPStatus TtlReassemblyTimeExceeded;
    public static IPStatus ParameterProblem;
    public static IPStatus SourceQuench;
    public static IPStatus BadDestination;
    public static IPStatus DestinationUnreachable;
    public static IPStatus TimeExceeded;
    public static IPStatus BadHeader;
    public static IPStatus UnrecognizedNextHeader;
    public static IPStatus IcmpError;
    public static IPStatus DestinationScopeMismatch;
    public static IPStatus Unknown;
}
public abstract class System.Net.NetworkInformation.IPv4InterfaceProperties : object {
    public bool UsesWins { get; }
    public bool IsDhcpEnabled { get; }
    public bool IsAutomaticPrivateAddressingActive { get; }
    public bool IsAutomaticPrivateAddressingEnabled { get; }
    public int Index { get; }
    public bool IsForwardingEnabled { get; }
    public int Mtu { get; }
    public abstract virtual bool get_UsesWins();
    public abstract virtual bool get_IsDhcpEnabled();
    public abstract virtual bool get_IsAutomaticPrivateAddressingActive();
    public abstract virtual bool get_IsAutomaticPrivateAddressingEnabled();
    public abstract virtual int get_Index();
    public abstract virtual bool get_IsForwardingEnabled();
    public abstract virtual int get_Mtu();
}
public abstract class System.Net.NetworkInformation.IPv4InterfaceStatistics : object {
    public long BytesReceived { get; }
    public long BytesSent { get; }
    public long IncomingPacketsDiscarded { get; }
    public long IncomingPacketsWithErrors { get; }
    public long IncomingUnknownProtocolPackets { get; }
    public long NonUnicastPacketsReceived { get; }
    public long NonUnicastPacketsSent { get; }
    public long OutgoingPacketsDiscarded { get; }
    public long OutgoingPacketsWithErrors { get; }
    public long OutputQueueLength { get; }
    public long UnicastPacketsReceived { get; }
    public long UnicastPacketsSent { get; }
    public abstract virtual long get_BytesReceived();
    public abstract virtual long get_BytesSent();
    public abstract virtual long get_IncomingPacketsDiscarded();
    public abstract virtual long get_IncomingPacketsWithErrors();
    public abstract virtual long get_IncomingUnknownProtocolPackets();
    public abstract virtual long get_NonUnicastPacketsReceived();
    public abstract virtual long get_NonUnicastPacketsSent();
    public abstract virtual long get_OutgoingPacketsDiscarded();
    public abstract virtual long get_OutgoingPacketsWithErrors();
    public abstract virtual long get_OutputQueueLength();
    public abstract virtual long get_UnicastPacketsReceived();
    public abstract virtual long get_UnicastPacketsSent();
}
public abstract class System.Net.NetworkInformation.IPv6InterfaceProperties : object {
    public int Index { get; }
    public int Mtu { get; }
    public abstract virtual int get_Index();
    public abstract virtual int get_Mtu();
    public virtual long GetScopeId(ScopeLevel scopeLevel);
}
internal class System.Net.NetworkInformation.LinuxNetworkChange : object {
    private object _lock;
    private Socket nl_sock;
    private SocketAsyncEventArgs nl_args;
    private EventType pending_events;
    private Timer timer;
    private NetworkAddressChangedEventHandler AddressChanged;
    private NetworkAvailabilityChangedEventHandler AvailabilityChanged;
    public bool HasRegisteredEvents { get; }
    public sealed virtual void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    public sealed virtual void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    public sealed virtual void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    public sealed virtual void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    public sealed virtual bool get_HasRegisteredEvents();
    public sealed virtual void Dispose();
    private bool EnsureSocket();
    private void MaybeCloseSocket();
    private bool GetAvailability();
    private void OnAvailabilityChanged(object unused);
    private void OnAddressChanged(object unused);
    private void OnEventDue(object unused);
    private void QueueEvent(EventType type);
    private void OnDataAvailable(object sender, SocketAsyncEventArgs args);
    private void Register(NetworkAddressChangedEventHandler d);
    private void Register(NetworkAvailabilityChangedEventHandler d);
    private void Unregister(NetworkAddressChangedEventHandler d);
    private void Unregister(NetworkAvailabilityChangedEventHandler d);
    private static IntPtr CreateNLSocket();
    private static EventType ReadEvents(IntPtr sock, IntPtr buffer, int count, int size);
    private static IntPtr CloseNLSocket(IntPtr sock);
}
internal class System.Net.NetworkInformation.MacNetworkChange : object {
    private static string DL_LIB;
    private static string CORE_SERVICES_LIB;
    private static string CORE_FOUNDATION_LIB;
    private IntPtr handle;
    private IntPtr runLoopMode;
    private SCNetworkReachabilityCallback callback;
    private bool scheduledWithRunLoop;
    private NetworkReachabilityFlags flags;
    [CompilerGeneratedAttribute]
private NetworkAddressChangedEventHandler networkAddressChanged;
    [CompilerGeneratedAttribute]
private NetworkAvailabilityChangedEventHandler networkAvailabilityChanged;
    private bool IsAvailable { get; }
    public bool HasRegisteredEvents { get; }
    private static IntPtr dlopen(string path, int mode);
    private static IntPtr dlsym(IntPtr handle, string symbol);
    private static int dlclose(IntPtr handle);
    private static void CFRelease(IntPtr handle);
    private static IntPtr CFRunLoopGetMain();
    private static IntPtr SCNetworkReachabilityCreateWithAddress(IntPtr allocator, sockaddr_in& sockaddr);
    private static bool SCNetworkReachabilityGetFlags(IntPtr reachability, NetworkReachabilityFlags& flags);
    private static bool SCNetworkReachabilitySetCallback(IntPtr reachability, SCNetworkReachabilityCallback callback, SCNetworkReachabilityContext& context);
    private static bool SCNetworkReachabilityScheduleWithRunLoop(IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode);
    private static bool SCNetworkReachabilityUnscheduleFromRunLoop(IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode);
    [CompilerGeneratedAttribute]
private void add_networkAddressChanged(NetworkAddressChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_networkAddressChanged(NetworkAddressChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void add_networkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_networkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    public sealed virtual void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    public sealed virtual void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    public sealed virtual void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    public sealed virtual void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    private bool get_IsAvailable();
    public sealed virtual bool get_HasRegisteredEvents();
    private bool LoadRunLoopMode();
    public sealed virtual void Dispose();
    [MonoPInvokeCallbackAttribute("System.Net.NetworkInformation.MacNetworkChange/SCNetworkReachabilityCallback")]
private static void HandleCallback(IntPtr reachability, NetworkReachabilityFlags flags, IntPtr info);
}
public abstract class System.Net.NetworkInformation.MulticastIPAddressInformation : IPAddressInformation {
    public long AddressPreferredLifetime { get; }
    public long AddressValidLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public abstract virtual long get_AddressPreferredLifetime();
    public abstract virtual long get_AddressValidLifetime();
    public abstract virtual long get_DhcpLeaseLifetime();
    public abstract virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public abstract virtual PrefixOrigin get_PrefixOrigin();
    public abstract virtual SuffixOrigin get_SuffixOrigin();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.MulticastIPAddressInformationCollection : object {
    private Collection`1<MulticastIPAddressInformation> addresses;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public MulticastIPAddressInformation Item { get; }
    public virtual void CopyTo(MulticastIPAddressInformation[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Add(MulticastIPAddressInformation address);
    internal void InternalAdd(MulticastIPAddressInformation address);
    public virtual bool Contains(MulticastIPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<MulticastIPAddressInformation> GetEnumerator();
    public virtual MulticastIPAddressInformation get_Item(int index);
    public virtual bool Remove(MulticastIPAddressInformation address);
    public virtual void Clear();
}
public enum System.Net.NetworkInformation.NetBiosNodeType : Enum {
    public int value__;
    public static NetBiosNodeType Unknown;
    public static NetBiosNodeType Broadcast;
    public static NetBiosNodeType Peer2Peer;
    public static NetBiosNodeType Mixed;
    public static NetBiosNodeType Hybrid;
}
public class System.Net.NetworkInformation.NetworkAddressChangedEventHandler : MulticastDelegate {
    public NetworkAddressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.NetworkInformation.NetworkAvailabilityChangedEventHandler : MulticastDelegate {
    public NetworkAvailabilityChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NetworkAvailabilityEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NetworkAvailabilityEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.NetworkInformation.NetworkAvailabilityEventArgs : EventArgs {
    private bool isAvailable;
    public bool IsAvailable { get; }
    internal NetworkAvailabilityEventArgs(bool isAvailable);
    public bool get_IsAvailable();
}
public class System.Net.NetworkInformation.NetworkChange : object {
    private static INetworkChange networkChange;
    private static bool IsWindows { get; }
    public static void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    public static void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    public static void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    public static void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    private static void MaybeCreate();
    private static bool get_IsWindows();
    private static void MaybeDispose();
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public static void RegisterNetworkChange(NetworkChange nc);
}
[FlagsAttribute]
public enum System.Net.NetworkInformation.NetworkInformationAccess : Enum {
    public int value__;
    public static NetworkInformationAccess None;
    public static NetworkInformationAccess Read;
    public static NetworkInformationAccess Ping;
}
public class System.Net.NetworkInformation.NetworkInformationException : Win32Exception {
    public int ErrorCode { get; }
    public NetworkInformationException(int errorCode);
    internal NetworkInformationException(SocketError socketError);
    protected NetworkInformationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
public class System.Net.NetworkInformation.NetworkInformationPermission : CodeAccessPermission {
    private NetworkInformationAccess access;
    private bool unrestricted;
    public NetworkInformationAccess Access { get; }
    public NetworkInformationPermission(PermissionState state);
    internal NetworkInformationPermission(bool unrestricted);
    public NetworkInformationPermission(NetworkInformationAccess access);
    public NetworkInformationAccess get_Access();
    public void AddPermission(NetworkInformationAccess access);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public class System.Net.NetworkInformation.NetworkInformationPermissionAttribute : CodeAccessSecurityAttribute {
    private static string strAccess;
    private string access;
    public string Access { get; public set; }
    public NetworkInformationPermissionAttribute(SecurityAction action);
    public string get_Access();
    public void set_Access(string value);
    public virtual IPermission CreatePermission();
}
public abstract class System.Net.NetworkInformation.NetworkInterface : object {
    public static int LoopbackInterfaceIndex { get; }
    public static int IPv6LoopbackInterfaceIndex { get; }
    public string Id { get; }
    public string Name { get; }
    public string Description { get; }
    public OperationalStatus OperationalStatus { get; }
    public long Speed { get; }
    public bool IsReceiveOnly { get; }
    public bool SupportsMulticast { get; }
    public NetworkInterfaceType NetworkInterfaceType { get; }
    public static NetworkInterface[] GetAllNetworkInterfaces();
    public static bool GetIsNetworkAvailable();
    public static int get_LoopbackInterfaceIndex();
    public static int get_IPv6LoopbackInterfaceIndex();
    public virtual string get_Id();
    public virtual string get_Name();
    public virtual string get_Description();
    public virtual IPInterfaceProperties GetIPProperties();
    public virtual IPv4InterfaceStatistics GetIPv4Statistics();
    public virtual IPInterfaceStatistics GetIPStatistics();
    public virtual OperationalStatus get_OperationalStatus();
    public virtual long get_Speed();
    public virtual bool get_IsReceiveOnly();
    public virtual bool get_SupportsMulticast();
    public virtual PhysicalAddress GetPhysicalAddress();
    public virtual NetworkInterfaceType get_NetworkInterfaceType();
    public virtual bool Supports(NetworkInterfaceComponent networkInterfaceComponent);
}
public enum System.Net.NetworkInformation.NetworkInterfaceComponent : Enum {
    public int value__;
    public static NetworkInterfaceComponent IPv4;
    public static NetworkInterfaceComponent IPv6;
}
internal abstract class System.Net.NetworkInformation.NetworkInterfaceFactory : object {
    public abstract virtual NetworkInterface[] GetAllNetworkInterfaces();
    public abstract virtual int GetLoopbackInterfaceIndex();
    public abstract virtual IPAddress GetNetMask(IPAddress address);
    public static NetworkInterfaceFactory Create();
}
internal static class System.Net.NetworkInformation.NetworkInterfaceFactoryPal : object {
    public static NetworkInterfaceFactory Create();
}
public enum System.Net.NetworkInformation.NetworkInterfaceType : Enum {
    public int value__;
    public static NetworkInterfaceType Unknown;
    public static NetworkInterfaceType Ethernet;
    public static NetworkInterfaceType TokenRing;
    public static NetworkInterfaceType Fddi;
    public static NetworkInterfaceType BasicIsdn;
    public static NetworkInterfaceType PrimaryIsdn;
    public static NetworkInterfaceType Ppp;
    public static NetworkInterfaceType Loopback;
    public static NetworkInterfaceType Ethernet3Megabit;
    public static NetworkInterfaceType Slip;
    public static NetworkInterfaceType Atm;
    public static NetworkInterfaceType GenericModem;
    public static NetworkInterfaceType FastEthernetT;
    public static NetworkInterfaceType Isdn;
    public static NetworkInterfaceType FastEthernetFx;
    public static NetworkInterfaceType Wireless80211;
    public static NetworkInterfaceType AsymmetricDsl;
    public static NetworkInterfaceType RateAdaptDsl;
    public static NetworkInterfaceType SymmetricDsl;
    public static NetworkInterfaceType VeryHighSpeedDsl;
    public static NetworkInterfaceType IPOverAtm;
    public static NetworkInterfaceType GigabitEthernet;
    public static NetworkInterfaceType Tunnel;
    public static NetworkInterfaceType MultiRateSymmetricDsl;
    public static NetworkInterfaceType HighPerformanceSerialBus;
    public static NetworkInterfaceType Wman;
    public static NetworkInterfaceType Wwanpp;
    public static NetworkInterfaceType Wwanpp2;
}
public enum System.Net.NetworkInformation.OperationalStatus : Enum {
    public int value__;
    public static OperationalStatus Up;
    public static OperationalStatus Down;
    public static OperationalStatus Testing;
    public static OperationalStatus Unknown;
    public static OperationalStatus Dormant;
    public static OperationalStatus NotPresent;
    public static OperationalStatus LowerLayerDown;
}
public class System.Net.NetworkInformation.PhysicalAddress : object {
    private Byte[] address;
    private bool changed;
    private int hash;
    public static PhysicalAddress None;
    public PhysicalAddress(Byte[] address);
    private static PhysicalAddress();
    public virtual int GetHashCode();
    public virtual bool Equals(object comparand);
    public virtual string ToString();
    public Byte[] GetAddressBytes();
    public static PhysicalAddress Parse(string address);
}
[MonoTODOAttribute("IPv6 support is missing")]
public class System.Net.NetworkInformation.Ping : Component {
    private static int DefaultCount;
    private static String[] PingBinPaths;
    private static string PingBinPath;
    private static bool canSendPrivileged;
    private static int default_timeout;
    private ushort identifier;
    private static UInt32 _LINUX_CAPABILITY_VERSION_1;
    private static Byte[] default_buffer;
    private BackgroundWorker worker;
    private object user_async_state;
    private CancellationTokenSource cts;
    [CompilerGeneratedAttribute]
private PingCompletedEventHandler PingCompleted;
    private static Ping();
    [CompilerGeneratedAttribute]
public void add_PingCompleted(PingCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PingCompleted(PingCompletedEventHandler value);
    private static int capget(cap_user_header_t& header, cap_user_data_t& data);
    private static void CheckLinuxCapabilities();
    private sealed virtual override void System.IDisposable.Dispose();
    protected void OnPingCompleted(PingCompletedEventArgs e);
    public PingReply Send(IPAddress address);
    public PingReply Send(IPAddress address, int timeout);
    public PingReply Send(IPAddress address, int timeout, Byte[] buffer);
    public PingReply Send(string hostNameOrAddress);
    public PingReply Send(string hostNameOrAddress, int timeout);
    public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer);
    public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options);
    public PingReply Send(IPAddress address, int timeout, Byte[] buffer, PingOptions options);
    private PingReply SendPrivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options);
    private PingReply SendUnprivileged(IPAddress address, int timeout, Byte[] buffer, PingOptions options);
    public void SendAsync(IPAddress address, int timeout, Byte[] buffer, object userToken);
    public void SendAsync(IPAddress address, int timeout, object userToken);
    public void SendAsync(IPAddress address, object userToken);
    public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, object userToken);
    public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options, object userToken);
    public void SendAsync(string hostNameOrAddress, int timeout, object userToken);
    public void SendAsync(string hostNameOrAddress, object userToken);
    public void SendAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options, object userToken);
    public void SendAsyncCancel();
    private string BuildPingArgs(IPAddress address, int timeout, PingOptions options);
    public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer);
    public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout);
    public Task`1<PingReply> SendPingAsync(IPAddress address);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress);
    public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options);
}
public class System.Net.NetworkInformation.PingCompletedEventArgs : AsyncCompletedEventArgs {
    private PingReply reply;
    public PingReply Reply { get; }
    internal PingCompletedEventArgs(Exception ex, bool cancelled, object userState, PingReply reply);
    public PingReply get_Reply();
}
public class System.Net.NetworkInformation.PingCompletedEventHandler : MulticastDelegate {
    public PingCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PingCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PingCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.NetworkInformation.PingException : InvalidOperationException {
    protected PingException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public PingException(string message);
    public PingException(string message, Exception innerException);
}
public class System.Net.NetworkInformation.PingOptions : object {
    private static int DontFragmentFlag;
    private int ttl;
    private bool dontFragment;
    public int Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    public PingOptions(int ttl, bool dontFragment);
    public int get_Ttl();
    public void set_Ttl(int value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
}
public class System.Net.NetworkInformation.PingReply : object {
    private IPAddress address;
    private PingOptions options;
    private IPStatus ipStatus;
    private long rtt;
    private Byte[] buffer;
    public IPStatus Status { get; }
    public IPAddress Address { get; }
    public long RoundtripTime { get; }
    public PingOptions Options { get; }
    public Byte[] Buffer { get; }
    internal PingReply(IPStatus ipStatus);
    internal PingReply(Byte[] data, int dataLength, IPAddress address, int time);
    internal PingReply(IPAddress address, Byte[] buffer, PingOptions options, long roundtripTime, IPStatus status);
    private IPStatus GetIPStatus(IcmpV4Type type, IcmpV4Code code);
    public IPStatus get_Status();
    public IPAddress get_Address();
    public long get_RoundtripTime();
    public PingOptions get_Options();
    public Byte[] get_Buffer();
}
public enum System.Net.NetworkInformation.PrefixOrigin : Enum {
    public int value__;
    public static PrefixOrigin Other;
    public static PrefixOrigin Manual;
    public static PrefixOrigin WellKnown;
    public static PrefixOrigin Dhcp;
    public static PrefixOrigin RouterAdvertisement;
}
public enum System.Net.NetworkInformation.ScopeLevel : Enum {
    public int value__;
    public static ScopeLevel None;
    public static ScopeLevel Interface;
    public static ScopeLevel Link;
    public static ScopeLevel Subnet;
    public static ScopeLevel Admin;
    public static ScopeLevel Site;
    public static ScopeLevel Organization;
    public static ScopeLevel Global;
}
[FlagsAttribute]
internal enum System.Net.NetworkInformation.StartIPOptions : Enum {
    public int value__;
    public static StartIPOptions Both;
    public static StartIPOptions None;
    public static StartIPOptions StartIPv4;
    public static StartIPOptions StartIPv6;
}
public enum System.Net.NetworkInformation.SuffixOrigin : Enum {
    public int value__;
    public static SuffixOrigin Other;
    public static SuffixOrigin Manual;
    public static SuffixOrigin WellKnown;
    public static SuffixOrigin OriginDhcp;
    public static SuffixOrigin LinkLayerAddress;
    public static SuffixOrigin Random;
}
internal class System.Net.NetworkInformation.SystemGatewayIPAddressInformation : GatewayIPAddressInformation {
    private IPAddress address;
    public IPAddress Address { get; }
    internal SystemGatewayIPAddressInformation(IPAddress address);
    public virtual IPAddress get_Address();
    internal static GatewayIPAddressInformationCollection ToGatewayIpAddressInformationCollection(IPAddressCollection addresses);
}
internal class System.Net.NetworkInformation.SystemIPAddressInformation : IPAddressInformation {
    private IPAddress address;
    internal bool transient;
    internal bool dnsEligible;
    public IPAddress Address { get; }
    public bool IsTransient { get; }
    public bool IsDnsEligible { get; }
    public SystemIPAddressInformation(IPAddress address, bool isDnsEligible, bool isTransient);
    public virtual IPAddress get_Address();
    public virtual bool get_IsTransient();
    public virtual bool get_IsDnsEligible();
}
internal class System.Net.NetworkInformation.SystemMulticastIPAddressInformation : MulticastIPAddressInformation {
    private SystemIPAddressInformation innerInfo;
    public IPAddress Address { get; }
    public bool IsTransient { get; }
    public bool IsDnsEligible { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public long AddressValidLifetime { get; }
    public long AddressPreferredLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    public SystemMulticastIPAddressInformation(SystemIPAddressInformation addressInfo);
    public virtual IPAddress get_Address();
    public virtual bool get_IsTransient();
    public virtual bool get_IsDnsEligible();
    public virtual PrefixOrigin get_PrefixOrigin();
    public virtual SuffixOrigin get_SuffixOrigin();
    public virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public virtual long get_AddressValidLifetime();
    public virtual long get_AddressPreferredLifetime();
    public virtual long get_DhcpLeaseLifetime();
    internal static MulticastIPAddressInformationCollection ToMulticastIpAddressInformationCollection(IPAddressInformationCollection addresses);
}
internal static class System.Net.NetworkInformation.SystemNetworkInterface : object {
    private static NetworkInterfaceFactory nif;
    public static int InternalLoopbackInterfaceIndex { get; }
    public static int InternalIPv6LoopbackInterfaceIndex { get; }
    private static SystemNetworkInterface();
    public static NetworkInterface[] GetNetworkInterfaces();
    public static bool InternalGetIsNetworkAvailable();
    public static int get_InternalLoopbackInterfaceIndex();
    public static int get_InternalIPv6LoopbackInterfaceIndex();
    public static IPAddress GetNetMask(IPAddress address);
}
internal class System.Net.NetworkInformation.SystemTcpConnectionInformation : TcpConnectionInformation {
    private IPEndPoint localEndPoint;
    private IPEndPoint remoteEndPoint;
    private TcpState state;
    public TcpState State { get; }
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public SystemTcpConnectionInformation(IPEndPoint local, IPEndPoint remote, TcpState state);
    public virtual TcpState get_State();
    public virtual IPEndPoint get_LocalEndPoint();
    public virtual IPEndPoint get_RemoteEndPoint();
}
public abstract class System.Net.NetworkInformation.TcpConnectionInformation : object {
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public TcpState State { get; }
    public abstract virtual IPEndPoint get_LocalEndPoint();
    public abstract virtual IPEndPoint get_RemoteEndPoint();
    public abstract virtual TcpState get_State();
}
public enum System.Net.NetworkInformation.TcpState : Enum {
    public int value__;
    public static TcpState Unknown;
    public static TcpState Closed;
    public static TcpState Listen;
    public static TcpState SynSent;
    public static TcpState SynReceived;
    public static TcpState Established;
    public static TcpState FinWait1;
    public static TcpState FinWait2;
    public static TcpState CloseWait;
    public static TcpState Closing;
    public static TcpState LastAck;
    public static TcpState TimeWait;
    public static TcpState DeleteTcb;
}
public abstract class System.Net.NetworkInformation.TcpStatistics : object {
    public long ConnectionsAccepted { get; }
    public long ConnectionsInitiated { get; }
    public long CumulativeConnections { get; }
    public long CurrentConnections { get; }
    public long ErrorsReceived { get; }
    public long FailedConnectionAttempts { get; }
    public long MaximumConnections { get; }
    public long MaximumTransmissionTimeout { get; }
    public long MinimumTransmissionTimeout { get; }
    public long ResetConnections { get; }
    public long SegmentsReceived { get; }
    public long SegmentsResent { get; }
    public long SegmentsSent { get; }
    public long ResetsSent { get; }
    public abstract virtual long get_ConnectionsAccepted();
    public abstract virtual long get_ConnectionsInitiated();
    public abstract virtual long get_CumulativeConnections();
    public abstract virtual long get_CurrentConnections();
    public abstract virtual long get_ErrorsReceived();
    public abstract virtual long get_FailedConnectionAttempts();
    public abstract virtual long get_MaximumConnections();
    public abstract virtual long get_MaximumTransmissionTimeout();
    public abstract virtual long get_MinimumTransmissionTimeout();
    public abstract virtual long get_ResetConnections();
    public abstract virtual long get_SegmentsReceived();
    public abstract virtual long get_SegmentsResent();
    public abstract virtual long get_SegmentsSent();
    public abstract virtual long get_ResetsSent();
}
public abstract class System.Net.NetworkInformation.UdpStatistics : object {
    public long DatagramsReceived { get; }
    public long DatagramsSent { get; }
    public long IncomingDatagramsDiscarded { get; }
    public long IncomingDatagramsWithErrors { get; }
    public int UdpListeners { get; }
    public abstract virtual long get_DatagramsReceived();
    public abstract virtual long get_DatagramsSent();
    public abstract virtual long get_IncomingDatagramsDiscarded();
    public abstract virtual long get_IncomingDatagramsWithErrors();
    public abstract virtual int get_UdpListeners();
}
public abstract class System.Net.NetworkInformation.UnicastIPAddressInformation : IPAddressInformation {
    public long AddressPreferredLifetime { get; }
    public long AddressValidLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public IPAddress IPv4Mask { get; }
    public int PrefixLength { get; }
    public abstract virtual long get_AddressPreferredLifetime();
    public abstract virtual long get_AddressValidLifetime();
    public abstract virtual long get_DhcpLeaseLifetime();
    public abstract virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public abstract virtual PrefixOrigin get_PrefixOrigin();
    public abstract virtual SuffixOrigin get_SuffixOrigin();
    public abstract virtual IPAddress get_IPv4Mask();
    public virtual int get_PrefixLength();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.UnicastIPAddressInformationCollection : object {
    private Collection`1<UnicastIPAddressInformation> addresses;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public UnicastIPAddressInformation Item { get; }
    public virtual void CopyTo(UnicastIPAddressInformation[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Add(UnicastIPAddressInformation address);
    internal void InternalAdd(UnicastIPAddressInformation address);
    public virtual bool Contains(UnicastIPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<UnicastIPAddressInformation> GetEnumerator();
    public virtual UnicastIPAddressInformation get_Item(int index);
    public virtual bool Remove(UnicastIPAddressInformation address);
    public virtual void Clear();
}
internal static class System.Net.NetworkInformation.UnixIPGlobalPropertiesFactoryPal : object {
    public static IPGlobalProperties Create();
}
internal static class System.Net.NetworkInformation.UnixNetworkInterfaceFactoryPal : object {
    public static NetworkInterfaceFactory Create();
}
internal class System.Net.NetworkInformation.Win32_FIXED_INFO : ValueType {
    public string HostName;
    public string DomainName;
    public IntPtr CurrentDnsServer;
    public Win32_IP_ADDR_STRING DnsServerList;
    public NetBiosNodeType NodeType;
    public string ScopeId;
    public UInt32 EnableRouting;
    public UInt32 EnableProxy;
    public UInt32 EnableDns;
}
internal class System.Net.NetworkInformation.Win32_FIXED_INFO_Marshal : ValueType {
    private static int MAX_HOSTNAME_LEN;
    private static int MAX_DOMAIN_NAME_LEN;
    private static int MAX_SCOPE_ID_LEN;
    [FixedBufferAttribute("System.Byte", "132")]
public <HostName>e__FixedBuffer HostName;
    [FixedBufferAttribute("System.Byte", "132")]
public <DomainName>e__FixedBuffer DomainName;
    public IntPtr CurrentDnsServer;
    public Win32_IP_ADDR_STRING DnsServerList;
    public NetBiosNodeType NodeType;
    [FixedBufferAttribute("System.Byte", "260")]
public <ScopeId>e__FixedBuffer ScopeId;
    public UInt32 EnableRouting;
    public UInt32 EnableProxy;
    public UInt32 EnableDns;
}
internal class System.Net.NetworkInformation.Win32_IP_ADAPTER_ADDRESSES : ValueType {
    public AlignmentUnion Alignment;
    public IntPtr Next;
    public string AdapterName;
    public IntPtr FirstUnicastAddress;
    public IntPtr FirstAnycastAddress;
    public IntPtr FirstMulticastAddress;
    public IntPtr FirstDnsServerAddress;
    public string DnsSuffix;
    public string Description;
    public string FriendlyName;
    public Byte[] PhysicalAddress;
    public UInt32 PhysicalAddressLength;
    public UInt32 Flags;
    public UInt32 Mtu;
    public NetworkInterfaceType IfType;
    public OperationalStatus OperStatus;
    public int Ipv6IfIndex;
    public UInt32[] ZoneIndices;
    public IntPtr FirstPrefix;
    public ulong TransmitLinkSpeed;
    public ulong ReceiveLinkSpeed;
    public IntPtr FirstWinsServerAddress;
    public IntPtr FirstGatewayAddress;
    public UInt32 Ipv4Metric;
    public UInt32 Ipv6Metric;
    public ulong Luid;
    public Win32_SOCKET_ADDRESS Dhcpv4Server;
    public UInt32 CompartmentId;
    public ulong NetworkGuid;
    public int ConnectionType;
    public int TunnelType;
    public Win32_SOCKET_ADDRESS Dhcpv6Server;
    public Byte[] Dhcpv6ClientDuid;
    public ulong Dhcpv6ClientDuidLength;
    public ulong Dhcpv6Iaid;
    public IntPtr FirstDnsSuffix;
    public static int GAA_FLAG_INCLUDE_WINS_INFO;
    public static int GAA_FLAG_INCLUDE_GATEWAYS;
    private static int MAX_ADAPTER_ADDRESS_LENGTH;
    private static int MAX_DHCPV6_DUID_LENGTH;
    private static int IP_ADAPTER_DDNS_ENABLED;
    private static int IP_ADAPTER_DHCP_ENABLED;
    private static int IP_ADAPTER_RECEIVE_ONLY;
    private static int IP_ADAPTER_NO_MULTICAST;
    public bool DdnsEnabled { get; }
    public bool DhcpEnabled { get; }
    public bool IsReceiveOnly { get; }
    public bool NoMulticast { get; }
    public bool get_DdnsEnabled();
    public bool get_DhcpEnabled();
    public bool get_IsReceiveOnly();
    public bool get_NoMulticast();
}
internal class System.Net.NetworkInformation.Win32_IP_ADAPTER_ANYCAST_ADDRESS : ValueType {
    public Win32LengthFlagsUnion LengthFlags;
    public IntPtr Next;
    public Win32_SOCKET_ADDRESS Address;
}
internal class System.Net.NetworkInformation.Win32_IP_ADAPTER_DNS_SERVER_ADDRESS : ValueType {
    public Win32LengthFlagsUnion LengthFlags;
    public IntPtr Next;
    public Win32_SOCKET_ADDRESS Address;
}
internal class System.Net.NetworkInformation.Win32_IP_ADAPTER_GATEWAY_ADDRESS : ValueType {
    public Win32LengthFlagsUnion LengthFlags;
    public IntPtr Next;
    public Win32_SOCKET_ADDRESS Address;
}
internal class System.Net.NetworkInformation.Win32_IP_ADAPTER_INFO : ValueType {
    private static int MAX_ADAPTER_NAME_LENGTH;
    private static int MAX_ADAPTER_DESCRIPTION_LENGTH;
    private static int MAX_ADAPTER_ADDRESS_LENGTH;
    public IntPtr Next;
    public int ComboIndex;
    public string AdapterName;
    public string Description;
    public UInt32 AddressLength;
    public Byte[] Address;
    public UInt32 Index;
    public UInt32 Type;
    public UInt32 DhcpEnabled;
    public IntPtr CurrentIpAddress;
    public Win32_IP_ADDR_STRING IpAddressList;
    public Win32_IP_ADDR_STRING GatewayList;
    public Win32_IP_ADDR_STRING DhcpServer;
    public bool HaveWins;
    public Win32_IP_ADDR_STRING PrimaryWinsServer;
    public Win32_IP_ADDR_STRING SecondaryWinsServer;
    public long LeaseObtained;
    public long LeaseExpires;
}
internal class System.Net.NetworkInformation.Win32_IP_ADAPTER_MULTICAST_ADDRESS : ValueType {
    public Win32LengthFlagsUnion LengthFlags;
    public IntPtr Next;
    public Win32_SOCKET_ADDRESS Address;
}
internal class System.Net.NetworkInformation.Win32_IP_ADAPTER_UNICAST_ADDRESS : ValueType {
    public Win32LengthFlagsUnion LengthFlags;
    public IntPtr Next;
    public Win32_SOCKET_ADDRESS Address;
    public PrefixOrigin PrefixOrigin;
    public SuffixOrigin SuffixOrigin;
    public DuplicateAddressDetectionState DadState;
    public UInt32 ValidLifetime;
    public UInt32 PreferredLifetime;
    public UInt32 LeaseLifetime;
    public byte OnLinkPrefixLength;
}
internal class System.Net.NetworkInformation.Win32_IP_ADAPTER_WINS_SERVER_ADDRESS : ValueType {
    public Win32LengthFlagsUnion LengthFlags;
    public IntPtr Next;
    public Win32_SOCKET_ADDRESS Address;
}
internal class System.Net.NetworkInformation.Win32_IP_ADDR_STRING : ValueType {
    public IntPtr Next;
    public string IpAddress;
    public string IpMask;
    public UInt32 Context;
}
internal class System.Net.NetworkInformation.Win32_IP_PER_ADAPTER_INFO : object {
    public UInt32 AutoconfigEnabled;
    public UInt32 AutoconfigActive;
    public IntPtr CurrentDnsServer;
    public Win32_IP_ADDR_STRING DnsServerList;
}
internal class System.Net.NetworkInformation.Win32_MIB_ICMP_EX : ValueType {
    public Win32_MIBICMPSTATS_EX InStats;
    public Win32_MIBICMPSTATS_EX OutStats;
}
internal class System.Net.NetworkInformation.Win32_MIB_IFROW : ValueType {
    private static int MAX_INTERFACE_NAME_LEN;
    private static int MAXLEN_PHYSADDR;
    private static int MAXLEN_IFDESCR;
    public Char[] Name;
    public int Index;
    public NetworkInterfaceType Type;
    public int Mtu;
    public UInt32 Speed;
    public int PhysAddrLen;
    public Byte[] PhysAddr;
    public UInt32 AdminStatus;
    public UInt32 OperStatus;
    public UInt32 LastChange;
    public int InOctets;
    public int InUcastPkts;
    public int InNUcastPkts;
    public int InDiscards;
    public int InErrors;
    public int InUnknownProtos;
    public int OutOctets;
    public int OutUcastPkts;
    public int OutNUcastPkts;
    public int OutDiscards;
    public int OutErrors;
    public int OutQLen;
    public int DescrLen;
    public Byte[] Descr;
}
internal class System.Net.NetworkInformation.Win32_MIB_IPSTATS : ValueType {
    public int Forwarding;
    public int DefaultTTL;
    public UInt32 InReceives;
    public UInt32 InHdrErrors;
    public UInt32 InAddrErrors;
    public UInt32 ForwDatagrams;
    public UInt32 InUnknownProtos;
    public UInt32 InDiscards;
    public UInt32 InDelivers;
    public UInt32 OutRequests;
    public UInt32 RoutingDiscards;
    public UInt32 OutDiscards;
    public UInt32 OutNoRoutes;
    public UInt32 ReasmTimeout;
    public UInt32 ReasmReqds;
    public UInt32 ReasmOks;
    public UInt32 ReasmFails;
    public UInt32 FragOks;
    public UInt32 FragFails;
    public UInt32 FragCreates;
    public int NumIf;
    public int NumAddr;
    public int NumRoutes;
}
internal class System.Net.NetworkInformation.Win32_MIB_TCPSTATS : ValueType {
    public UInt32 RtoAlgorithm;
    public UInt32 RtoMin;
    public UInt32 RtoMax;
    public UInt32 MaxConn;
    public UInt32 ActiveOpens;
    public UInt32 PassiveOpens;
    public UInt32 AttemptFails;
    public UInt32 EstabResets;
    public UInt32 CurrEstab;
    public UInt32 InSegs;
    public UInt32 OutSegs;
    public UInt32 RetransSegs;
    public UInt32 InErrs;
    public UInt32 OutRsts;
    public UInt32 NumConns;
}
internal class System.Net.NetworkInformation.Win32_MIB_UDPSTATS : ValueType {
    public UInt32 InDatagrams;
    public UInt32 NoPorts;
    public UInt32 InErrors;
    public UInt32 OutDatagrams;
    public int NumAddrs;
}
internal class System.Net.NetworkInformation.Win32_MIBICMPINFO : ValueType {
    public Win32_MIBICMPSTATS InStats;
    public Win32_MIBICMPSTATS OutStats;
}
internal class System.Net.NetworkInformation.Win32_MIBICMPSTATS : ValueType {
    public UInt32 Msgs;
    public UInt32 Errors;
    public UInt32 DestUnreachs;
    public UInt32 TimeExcds;
    public UInt32 ParmProbs;
    public UInt32 SrcQuenchs;
    public UInt32 Redirects;
    public UInt32 Echos;
    public UInt32 EchoReps;
    public UInt32 Timestamps;
    public UInt32 TimestampReps;
    public UInt32 AddrMasks;
    public UInt32 AddrMaskReps;
}
internal class System.Net.NetworkInformation.Win32_MIBICMPSTATS_EX : ValueType {
    public UInt32 Msgs;
    public UInt32 Errors;
    public UInt32[] Counts;
}
internal class System.Net.NetworkInformation.Win32_SOCKADDR : ValueType {
    public ushort AddressFamily;
    public Byte[] AddressData;
}
internal class System.Net.NetworkInformation.Win32_SOCKET_ADDRESS : ValueType {
    public IntPtr Sockaddr;
    public int SockaddrLength;
    private static int AF_INET6;
    public IPAddress GetIPAddress();
}
internal class System.Net.NetworkInformation.Win32IcmpV4Statistics : IcmpV4Statistics {
    private Win32_MIBICMPSTATS iin;
    private Win32_MIBICMPSTATS iout;
    public long AddressMaskRepliesReceived { get; }
    public long AddressMaskRepliesSent { get; }
    public long AddressMaskRequestsReceived { get; }
    public long AddressMaskRequestsSent { get; }
    public long DestinationUnreachableMessagesReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long EchoRepliesReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRequestsSent { get; }
    public long ErrorsReceived { get; }
    public long ErrorsSent { get; }
    public long MessagesReceived { get; }
    public long MessagesSent { get; }
    public long ParameterProblemsReceived { get; }
    public long ParameterProblemsSent { get; }
    public long RedirectsReceived { get; }
    public long RedirectsSent { get; }
    public long SourceQuenchesReceived { get; }
    public long SourceQuenchesSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public long TimestampRepliesReceived { get; }
    public long TimestampRepliesSent { get; }
    public long TimestampRequestsReceived { get; }
    public long TimestampRequestsSent { get; }
    public Win32IcmpV4Statistics(Win32_MIBICMPINFO info);
    public virtual long get_AddressMaskRepliesReceived();
    public virtual long get_AddressMaskRepliesSent();
    public virtual long get_AddressMaskRequestsReceived();
    public virtual long get_AddressMaskRequestsSent();
    public virtual long get_DestinationUnreachableMessagesReceived();
    public virtual long get_DestinationUnreachableMessagesSent();
    public virtual long get_EchoRepliesReceived();
    public virtual long get_EchoRepliesSent();
    public virtual long get_EchoRequestsReceived();
    public virtual long get_EchoRequestsSent();
    public virtual long get_ErrorsReceived();
    public virtual long get_ErrorsSent();
    public virtual long get_MessagesReceived();
    public virtual long get_MessagesSent();
    public virtual long get_ParameterProblemsReceived();
    public virtual long get_ParameterProblemsSent();
    public virtual long get_RedirectsReceived();
    public virtual long get_RedirectsSent();
    public virtual long get_SourceQuenchesReceived();
    public virtual long get_SourceQuenchesSent();
    public virtual long get_TimeExceededMessagesReceived();
    public virtual long get_TimeExceededMessagesSent();
    public virtual long get_TimestampRepliesReceived();
    public virtual long get_TimestampRepliesSent();
    public virtual long get_TimestampRequestsReceived();
    public virtual long get_TimestampRequestsSent();
}
internal class System.Net.NetworkInformation.Win32IcmpV6Statistics : IcmpV6Statistics {
    private Win32_MIBICMPSTATS_EX iin;
    private Win32_MIBICMPSTATS_EX iout;
    public long DestinationUnreachableMessagesReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long EchoRepliesReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRequestsSent { get; }
    public long ErrorsReceived { get; }
    public long ErrorsSent { get; }
    public long MembershipQueriesReceived { get; }
    public long MembershipQueriesSent { get; }
    public long MembershipReductionsReceived { get; }
    public long MembershipReductionsSent { get; }
    public long MembershipReportsReceived { get; }
    public long MembershipReportsSent { get; }
    public long MessagesReceived { get; }
    public long MessagesSent { get; }
    public long NeighborAdvertisementsReceived { get; }
    public long NeighborAdvertisementsSent { get; }
    public long NeighborSolicitsReceived { get; }
    public long NeighborSolicitsSent { get; }
    public long PacketTooBigMessagesReceived { get; }
    public long PacketTooBigMessagesSent { get; }
    public long ParameterProblemsReceived { get; }
    public long ParameterProblemsSent { get; }
    public long RedirectsReceived { get; }
    public long RedirectsSent { get; }
    public long RouterAdvertisementsReceived { get; }
    public long RouterAdvertisementsSent { get; }
    public long RouterSolicitsReceived { get; }
    public long RouterSolicitsSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public Win32IcmpV6Statistics(Win32_MIB_ICMP_EX info);
    public virtual long get_DestinationUnreachableMessagesReceived();
    public virtual long get_DestinationUnreachableMessagesSent();
    public virtual long get_EchoRepliesReceived();
    public virtual long get_EchoRepliesSent();
    public virtual long get_EchoRequestsReceived();
    public virtual long get_EchoRequestsSent();
    public virtual long get_ErrorsReceived();
    public virtual long get_ErrorsSent();
    public virtual long get_MembershipQueriesReceived();
    public virtual long get_MembershipQueriesSent();
    public virtual long get_MembershipReductionsReceived();
    public virtual long get_MembershipReductionsSent();
    public virtual long get_MembershipReportsReceived();
    public virtual long get_MembershipReportsSent();
    public virtual long get_MessagesReceived();
    public virtual long get_MessagesSent();
    public virtual long get_NeighborAdvertisementsReceived();
    public virtual long get_NeighborAdvertisementsSent();
    public virtual long get_NeighborSolicitsReceived();
    public virtual long get_NeighborSolicitsSent();
    public virtual long get_PacketTooBigMessagesReceived();
    public virtual long get_PacketTooBigMessagesSent();
    public virtual long get_ParameterProblemsReceived();
    public virtual long get_ParameterProblemsSent();
    public virtual long get_RedirectsReceived();
    public virtual long get_RedirectsSent();
    public virtual long get_RouterAdvertisementsReceived();
    public virtual long get_RouterAdvertisementsSent();
    public virtual long get_RouterSolicitsReceived();
    public virtual long get_RouterSolicitsSent();
    public virtual long get_TimeExceededMessagesReceived();
    public virtual long get_TimeExceededMessagesSent();
}
internal class System.Net.NetworkInformation.Win32IPAddressCollection : IPAddressCollection {
    public static Win32IPAddressCollection Empty;
    public Win32IPAddressCollection(IntPtr[] heads);
    public Win32IPAddressCollection(Win32_IP_ADDR_STRING[] al);
    private static Win32IPAddressCollection();
    public static Win32IPAddressCollection FromAnycast(IntPtr ptr);
    public static Win32IPAddressCollection FromDnsServer(IntPtr ptr);
    public static Win32IPAddressCollection FromSocketAddress(Win32_SOCKET_ADDRESS addr);
    public static Win32IPAddressCollection FromWinsServer(IntPtr ptr);
    private void AddSubsequentlyString(IntPtr head);
}
internal class System.Net.NetworkInformation.Win32IPGlobalProperties : IPGlobalProperties {
    public static int AF_INET;
    public static int AF_INET6;
    public string DhcpScopeName { get; }
    public string DomainName { get; }
    public string HostName { get; }
    public bool IsWinsProxy { get; }
    public NetBiosNodeType NodeType { get; }
    private void FillTcpTable(List`1& tab4, List`1& tab6);
    private bool IsListenerState(TcpState state);
    public virtual TcpConnectionInformation[] GetActiveTcpConnections();
    public virtual IPEndPoint[] GetActiveTcpListeners();
    public virtual IPEndPoint[] GetActiveUdpListeners();
    public virtual IcmpV4Statistics GetIcmpV4Statistics();
    public virtual IcmpV6Statistics GetIcmpV6Statistics();
    public virtual IPGlobalStatistics GetIPv4GlobalStatistics();
    public virtual IPGlobalStatistics GetIPv6GlobalStatistics();
    public virtual TcpStatistics GetTcpIPv4Statistics();
    public virtual TcpStatistics GetTcpIPv6Statistics();
    public virtual UdpStatistics GetUdpIPv4Statistics();
    public virtual UdpStatistics GetUdpIPv6Statistics();
    public virtual string get_DhcpScopeName();
    public virtual string get_DomainName();
    public virtual string get_HostName();
    public virtual bool get_IsWinsProxy();
    public virtual NetBiosNodeType get_NodeType();
    private static int GetTcpTable(Byte[] pTcpTable, Int32& pdwSize, bool bOrder);
    private static int GetTcp6Table(Byte[] TcpTable, Int32& SizePointer, bool Order);
    private static int GetUdpTable(Byte[] pUdpTable, Int32& pdwSize, bool bOrder);
    private static int GetUdp6Table(Byte[] Udp6Table, Int32& SizePointer, bool Order);
    private static int GetTcpStatisticsEx(Win32_MIB_TCPSTATS& pStats, int dwFamily);
    private static int GetUdpStatisticsEx(Win32_MIB_UDPSTATS& pStats, int dwFamily);
    private static int GetIcmpStatistics(Win32_MIBICMPINFO& pStats, int dwFamily);
    private static int GetIcmpStatisticsEx(Win32_MIB_ICMP_EX& pStats, int dwFamily);
    private static int GetIpStatisticsEx(Win32_MIB_IPSTATS& pStats, int dwFamily);
    private static ushort ntohs(ushort netshort);
}
internal static class System.Net.NetworkInformation.Win32IPGlobalPropertiesFactoryPal : object {
    public static IPGlobalProperties Create();
}
internal class System.Net.NetworkInformation.Win32IPGlobalStatistics : IPGlobalStatistics {
    private Win32_MIB_IPSTATS info;
    public int DefaultTtl { get; }
    public bool ForwardingEnabled { get; }
    public int NumberOfInterfaces { get; }
    public int NumberOfIPAddresses { get; }
    public int NumberOfRoutes { get; }
    public long OutputPacketRequests { get; }
    public long OutputPacketRoutingDiscards { get; }
    public long OutputPacketsDiscarded { get; }
    public long OutputPacketsWithNoRoute { get; }
    public long PacketFragmentFailures { get; }
    public long PacketReassembliesRequired { get; }
    public long PacketReassemblyFailures { get; }
    public long PacketReassemblyTimeout { get; }
    public long PacketsFragmented { get; }
    public long PacketsReassembled { get; }
    public long ReceivedPackets { get; }
    public long ReceivedPacketsDelivered { get; }
    public long ReceivedPacketsDiscarded { get; }
    public long ReceivedPacketsForwarded { get; }
    public long ReceivedPacketsWithAddressErrors { get; }
    public long ReceivedPacketsWithHeadersErrors { get; }
    public long ReceivedPacketsWithUnknownProtocol { get; }
    public Win32IPGlobalStatistics(Win32_MIB_IPSTATS info);
    public virtual int get_DefaultTtl();
    public virtual bool get_ForwardingEnabled();
    public virtual int get_NumberOfInterfaces();
    public virtual int get_NumberOfIPAddresses();
    public virtual int get_NumberOfRoutes();
    public virtual long get_OutputPacketRequests();
    public virtual long get_OutputPacketRoutingDiscards();
    public virtual long get_OutputPacketsDiscarded();
    public virtual long get_OutputPacketsWithNoRoute();
    public virtual long get_PacketFragmentFailures();
    public virtual long get_PacketReassembliesRequired();
    public virtual long get_PacketReassemblyFailures();
    public virtual long get_PacketReassemblyTimeout();
    public virtual long get_PacketsFragmented();
    public virtual long get_PacketsReassembled();
    public virtual long get_ReceivedPackets();
    public virtual long get_ReceivedPacketsDelivered();
    public virtual long get_ReceivedPacketsDiscarded();
    public virtual long get_ReceivedPacketsForwarded();
    public virtual long get_ReceivedPacketsWithAddressErrors();
    public virtual long get_ReceivedPacketsWithHeadersErrors();
    public virtual long get_ReceivedPacketsWithUnknownProtocol();
}
internal class System.Net.NetworkInformation.Win32IPInterfaceProperties2 : IPInterfaceProperties {
    private Win32_IP_ADAPTER_ADDRESSES addr;
    private Win32_MIB_IFROW mib4;
    private Win32_MIB_IFROW mib6;
    public IPAddressInformationCollection AnycastAddresses { get; }
    public IPAddressCollection DhcpServerAddresses { get; }
    public IPAddressCollection DnsAddresses { get; }
    public string DnsSuffix { get; }
    public GatewayIPAddressInformationCollection GatewayAddresses { get; }
    public bool IsDnsEnabled { get; }
    public bool IsDynamicDnsEnabled { get; }
    public MulticastIPAddressInformationCollection MulticastAddresses { get; }
    public UnicastIPAddressInformationCollection UnicastAddresses { get; }
    public IPAddressCollection WinsServersAddresses { get; }
    public Win32IPInterfaceProperties2(Win32_IP_ADAPTER_ADDRESSES addr, Win32_MIB_IFROW mib4, Win32_MIB_IFROW mib6);
    public virtual IPv4InterfaceProperties GetIPv4Properties();
    public virtual IPv6InterfaceProperties GetIPv6Properties();
    public virtual IPAddressInformationCollection get_AnycastAddresses();
    private static IPAddressInformationCollection Win32FromAnycast(IntPtr ptr);
    public virtual IPAddressCollection get_DhcpServerAddresses();
    public virtual IPAddressCollection get_DnsAddresses();
    public virtual string get_DnsSuffix();
    public virtual GatewayIPAddressInformationCollection get_GatewayAddresses();
    public virtual bool get_IsDnsEnabled();
    public virtual bool get_IsDynamicDnsEnabled();
    public virtual MulticastIPAddressInformationCollection get_MulticastAddresses();
    private static MulticastIPAddressInformationCollection Win32FromMulticast(IntPtr ptr);
    public virtual UnicastIPAddressInformationCollection get_UnicastAddresses();
    private static UnicastIPAddressInformationCollection Win32FromUnicast(IntPtr ptr);
    public virtual IPAddressCollection get_WinsServersAddresses();
}
internal class System.Net.NetworkInformation.Win32IPv4InterfaceProperties : IPv4InterfaceProperties {
    private Win32_IP_ADAPTER_ADDRESSES addr;
    private Win32_IP_PER_ADAPTER_INFO painfo;
    private Win32_MIB_IFROW mib;
    public int Index { get; }
    public bool IsAutomaticPrivateAddressingActive { get; }
    public bool IsAutomaticPrivateAddressingEnabled { get; }
    public bool IsDhcpEnabled { get; }
    public bool IsForwardingEnabled { get; }
    public int Mtu { get; }
    public bool UsesWins { get; }
    public Win32IPv4InterfaceProperties(Win32_IP_ADAPTER_ADDRESSES addr, Win32_MIB_IFROW mib);
    private static int GetPerAdapterInfo(int IfIndex, Win32_IP_PER_ADAPTER_INFO pPerAdapterInfo, Int32& pOutBufLen);
    public virtual int get_Index();
    public virtual bool get_IsAutomaticPrivateAddressingActive();
    public virtual bool get_IsAutomaticPrivateAddressingEnabled();
    public virtual bool get_IsDhcpEnabled();
    public virtual bool get_IsForwardingEnabled();
    public virtual int get_Mtu();
    public virtual bool get_UsesWins();
}
internal class System.Net.NetworkInformation.Win32IPv4InterfaceStatistics : IPv4InterfaceStatistics {
    private Win32_MIB_IFROW info;
    public long BytesReceived { get; }
    public long BytesSent { get; }
    public long IncomingPacketsDiscarded { get; }
    public long IncomingPacketsWithErrors { get; }
    public long IncomingUnknownProtocolPackets { get; }
    public long NonUnicastPacketsReceived { get; }
    public long NonUnicastPacketsSent { get; }
    public long OutgoingPacketsDiscarded { get; }
    public long OutgoingPacketsWithErrors { get; }
    public long OutputQueueLength { get; }
    public long UnicastPacketsReceived { get; }
    public long UnicastPacketsSent { get; }
    public Win32IPv4InterfaceStatistics(Win32_MIB_IFROW info);
    public virtual long get_BytesReceived();
    public virtual long get_BytesSent();
    public virtual long get_IncomingPacketsDiscarded();
    public virtual long get_IncomingPacketsWithErrors();
    public virtual long get_IncomingUnknownProtocolPackets();
    public virtual long get_NonUnicastPacketsReceived();
    public virtual long get_NonUnicastPacketsSent();
    public virtual long get_OutgoingPacketsDiscarded();
    public virtual long get_OutgoingPacketsWithErrors();
    public virtual long get_OutputQueueLength();
    public virtual long get_UnicastPacketsReceived();
    public virtual long get_UnicastPacketsSent();
}
internal class System.Net.NetworkInformation.Win32IPv6InterfaceProperties : IPv6InterfaceProperties {
    private Win32_MIB_IFROW mib;
    public int Index { get; }
    public int Mtu { get; }
    public Win32IPv6InterfaceProperties(Win32_MIB_IFROW mib);
    public virtual int get_Index();
    public virtual int get_Mtu();
}
internal class System.Net.NetworkInformation.Win32LengthFlagsUnion : ValueType {
    private static int IP_ADAPTER_ADDRESS_DNS_ELIGIBLE;
    private static int IP_ADAPTER_ADDRESS_TRANSIENT;
    public UInt32 Length;
    public UInt32 Flags;
    public bool IsDnsEligible { get; }
    public bool IsTransient { get; }
    public bool get_IsDnsEligible();
    public bool get_IsTransient();
}
internal class System.Net.NetworkInformation.Win32NetworkInterface : object {
    private static Win32_FIXED_INFO fixedInfo;
    private static bool initialized;
    public static Win32_FIXED_INFO FixedInfo { get; }
    private static int GetNetworkParams(IntPtr ptr, Int32& size);
    private static int MultiByteToWideChar(UInt32 CodePage, UInt32 dwFlags, Byte* lpMultiByteStr, int cbMultiByte, Char* lpWideCharStr, int cchWideChar);
    public static Win32_FIXED_INFO get_FixedInfo();
    [CompilerGeneratedAttribute]
internal static string <get_FixedInfo>g__GetStringFromMultiByte|5_0(Byte* bytes);
}
internal class System.Net.NetworkInformation.Win32NetworkInterface2 : NetworkInterface {
    private Win32_IP_ADAPTER_ADDRESSES addr;
    private Win32_MIB_IFROW mib4;
    private Win32_MIB_IFROW mib6;
    private Win32IPv4InterfaceStatistics ip4stats;
    private IPInterfaceProperties ip_if_props;
    public string Description { get; }
    public string Id { get; }
    public bool IsReceiveOnly { get; }
    public string Name { get; }
    public NetworkInterfaceType NetworkInterfaceType { get; }
    public OperationalStatus OperationalStatus { get; }
    public long Speed { get; }
    public bool SupportsMulticast { get; }
    internal Win32NetworkInterface2(Win32_IP_ADAPTER_ADDRESSES addr);
    private static int GetAdaptersInfo(IntPtr info, Int32& size);
    private static int GetIfEntry(Win32_MIB_IFROW& row);
    private static Win32_IP_ADAPTER_INFO[] GetAdaptersInfo();
    public virtual IPInterfaceProperties GetIPProperties();
    public virtual IPv4InterfaceStatistics GetIPv4Statistics();
    public virtual PhysicalAddress GetPhysicalAddress();
    public virtual bool Supports(NetworkInterfaceComponent networkInterfaceComponent);
    public virtual string get_Description();
    public virtual string get_Id();
    public virtual bool get_IsReceiveOnly();
    public virtual string get_Name();
    public virtual NetworkInterfaceType get_NetworkInterfaceType();
    public virtual OperationalStatus get_OperationalStatus();
    public virtual long get_Speed();
    public virtual bool get_SupportsMulticast();
}
internal class System.Net.NetworkInformation.Win32NetworkInterfaceAPI : NetworkInterfaceFactory {
    private static string IPHLPAPI;
    private static int GetAdaptersAddresses(UInt32 family, UInt32 flags, IntPtr reserved, IntPtr info, Int32& size);
    private static UInt32 GetBestInterfaceEx(Byte[] ipAddress, Int32& index);
    private static Win32_IP_ADAPTER_ADDRESSES[] GetAdaptersAddresses();
    public virtual NetworkInterface[] GetAllNetworkInterfaces();
    private static int GetBestInterfaceForAddress(IPAddress addr);
    public virtual int GetLoopbackInterfaceIndex();
    public virtual IPAddress GetNetMask(IPAddress address);
}
internal static class System.Net.NetworkInformation.Win32NetworkInterfaceFactoryPal : object {
    public static NetworkInterfaceFactory Create();
}
internal class System.Net.NetworkInformation.Win32TcpStatistics : TcpStatistics {
    private Win32_MIB_TCPSTATS info;
    public long ConnectionsAccepted { get; }
    public long ConnectionsInitiated { get; }
    public long CumulativeConnections { get; }
    public long CurrentConnections { get; }
    public long ErrorsReceived { get; }
    public long FailedConnectionAttempts { get; }
    public long MaximumConnections { get; }
    public long MaximumTransmissionTimeout { get; }
    public long MinimumTransmissionTimeout { get; }
    public long ResetConnections { get; }
    public long ResetsSent { get; }
    public long SegmentsReceived { get; }
    public long SegmentsResent { get; }
    public long SegmentsSent { get; }
    public Win32TcpStatistics(Win32_MIB_TCPSTATS info);
    public virtual long get_ConnectionsAccepted();
    public virtual long get_ConnectionsInitiated();
    public virtual long get_CumulativeConnections();
    public virtual long get_CurrentConnections();
    public virtual long get_ErrorsReceived();
    public virtual long get_FailedConnectionAttempts();
    public virtual long get_MaximumConnections();
    public virtual long get_MaximumTransmissionTimeout();
    public virtual long get_MinimumTransmissionTimeout();
    public virtual long get_ResetConnections();
    public virtual long get_ResetsSent();
    public virtual long get_SegmentsReceived();
    public virtual long get_SegmentsResent();
    public virtual long get_SegmentsSent();
}
internal class System.Net.NetworkInformation.Win32UdpStatistics : UdpStatistics {
    private Win32_MIB_UDPSTATS info;
    public long DatagramsReceived { get; }
    public long DatagramsSent { get; }
    public long IncomingDatagramsDiscarded { get; }
    public long IncomingDatagramsWithErrors { get; }
    public int UdpListeners { get; }
    public Win32UdpStatistics(Win32_MIB_UDPSTATS info);
    public virtual long get_DatagramsReceived();
    public virtual long get_DatagramsSent();
    public virtual long get_IncomingDatagramsDiscarded();
    public virtual long get_IncomingDatagramsWithErrors();
    public virtual int get_UdpListeners();
}
internal class System.Net.NetworkInformation.Win32UnicastIPAddressInformation : UnicastIPAddressInformation {
    private Win32_IP_ADAPTER_UNICAST_ADDRESS info;
    private IPAddress ipv4Mask;
    public IPAddress Address { get; }
    public bool IsDnsEligible { get; }
    public bool IsTransient { get; }
    public long AddressPreferredLifetime { get; }
    public long AddressValidLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public IPAddress IPv4Mask { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public Win32UnicastIPAddressInformation(Win32_IP_ADAPTER_UNICAST_ADDRESS info);
    public virtual IPAddress get_Address();
    public virtual bool get_IsDnsEligible();
    public virtual bool get_IsTransient();
    public virtual long get_AddressPreferredLifetime();
    public virtual long get_AddressValidLifetime();
    public virtual long get_DhcpLeaseLifetime();
    public virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public virtual IPAddress get_IPv4Mask();
    public virtual PrefixOrigin get_PrefixOrigin();
    public virtual SuffixOrigin get_SuffixOrigin();
    private static IPAddress PrefixLengthToSubnetMask(byte prefixLength, AddressFamily family);
}
internal class System.Net.NetworkStreamWrapper : Stream {
    private TcpClient _client;
    private NetworkStream _networkStream;
    protected bool UsingSecureStream { get; }
    internal IPAddress ServerAddress { get; }
    internal Socket Socket { get; }
    internal NetworkStream NetworkStream { get; internal set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal NetworkStreamWrapper(TcpClient client);
    protected bool get_UsingSecureStream();
    internal IPAddress get_ServerAddress();
    internal Socket get_Socket();
    internal NetworkStream get_NetworkStream();
    internal void set_NetworkStream(NetworkStream value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    protected virtual void Dispose(bool disposing);
    internal void CloseSocket();
    public void Close(int timeout);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    internal void SetSocketTimeoutOption(int timeout);
}
internal class System.Net.NTAuthentication : object {
    private bool _isServer;
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteContext _securityContext;
    private string _spn;
    private int _tokenSize;
    private ContextFlagsPal _requestedContextFlags;
    private ContextFlagsPal _contextFlags;
    private bool _isCompleted;
    private string _package;
    private string _lastProtocolName;
    private string _protocolName;
    private string _clientSpecifiedSpn;
    private ChannelBinding _channelBinding;
    internal bool IsCompleted { get; }
    internal bool IsValidContext { get; }
    internal string Package { get; }
    internal bool IsServer { get; }
    internal string ClientSpecifiedSpn { get; }
    internal string ProtocolName { get; }
    internal bool IsKerberos { get; }
    internal NTAuthentication(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    internal bool get_IsCompleted();
    internal bool get_IsValidContext();
    internal string get_Package();
    internal bool get_IsServer();
    internal string get_ClientSpecifiedSpn();
    internal string get_ProtocolName();
    internal bool get_IsKerberos();
    private void Initialize(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    internal SafeDeleteContext GetContext(SecurityStatusPal& status);
    internal void CloseContext();
    internal int VerifySignature(Byte[] buffer, int offset, int count);
    internal int MakeSignature(Byte[] buffer, int offset, int count, Byte[]& output);
    internal string GetOutgoingBlob(string incomingBlob);
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool thrownOnError);
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool throwOnError, SecurityStatusPal& statusCode);
    private string GetClientSpecifiedSpn();
}
internal class System.Net.NtlmClient : object {
    private IAuthenticationModule authObject;
    public string AuthenticationType { get; }
    public bool CanPreAuthenticate { get; }
    public sealed virtual Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
    public sealed virtual Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool get_CanPreAuthenticate();
}
public class System.Net.OpenReadCompletedEventArgs : AsyncCompletedEventArgs {
    private Stream _result;
    public Stream Result { get; }
    internal OpenReadCompletedEventArgs(Stream result, Exception exception, bool cancelled, object userToken);
    public Stream get_Result();
}
public class System.Net.OpenReadCompletedEventHandler : MulticastDelegate {
    public OpenReadCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OpenReadCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OpenReadCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.OpenWriteCompletedEventArgs : AsyncCompletedEventArgs {
    private Stream _result;
    public Stream Result { get; }
    internal OpenWriteCompletedEventArgs(Stream result, Exception exception, bool cancelled, object userToken);
    public Stream get_Result();
}
public class System.Net.OpenWriteCompletedEventHandler : MulticastDelegate {
    public OpenWriteCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OpenWriteCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OpenWriteCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.PathList : object {
    private SortedList m_list;
    public int Count { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public object SyncRoot { get; }
    public int get_Count();
    public int GetCookiesCount();
    public ICollection get_Values();
    public object get_Item(string s);
    public void set_Item(string s, object value);
    public IEnumerator GetEnumerator();
    public object get_SyncRoot();
}
public class System.Net.ProtocolViolationException : InvalidOperationException {
    public ProtocolViolationException(string message);
    protected ProtocolViolationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal abstract class System.Net.ProxyChain : object {
    private List`1<Uri> m_Cache;
    private bool m_CacheComplete;
    private ProxyEnumerator m_MainEnumerator;
    private Uri m_Destination;
    private HttpAbortDelegate m_HttpAbortDelegate;
    internal IEnumerator`1<Uri> Enumerator { get; }
    internal Uri Destination { get; }
    internal HttpAbortDelegate HttpAbortDelegate { get; }
    protected ProxyChain(Uri destination);
    public sealed virtual IEnumerator`1<Uri> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void Dispose();
    internal IEnumerator`1<Uri> get_Enumerator();
    internal Uri get_Destination();
    internal virtual void Abort();
    internal bool HttpAbort(HttpWebRequest request, WebException webException);
    internal HttpAbortDelegate get_HttpAbortDelegate();
    protected abstract virtual bool GetNextProxy(Uri& proxy);
}
internal class System.Net.ProxyScriptChain : ProxyChain {
    private WebProxy m_Proxy;
    private Uri[] m_ScriptProxies;
    private int m_CurrentIndex;
    private int m_SyncStatus;
    internal ProxyScriptChain(WebProxy proxy, Uri destination);
    protected virtual bool GetNextProxy(Uri& proxy);
    internal virtual void Abort();
}
internal static class System.Net.RangeValidationHelpers : object {
    public static bool ValidateRange(int actual, int fromAllowed, int toAllowed);
    public static void ValidateSegment(ArraySegment`1<byte> segment);
}
internal enum System.Net.ReadState : Enum {
    public int value__;
    public static ReadState None;
    public static ReadState Status;
    public static ReadState Headers;
    public static ReadState Content;
    public static ReadState Aborted;
}
internal class System.Net.ReceiveState : object {
    private static int bufferSize;
    internal ResponseDescription Resp;
    internal int ValidThrough;
    internal Byte[] Buffer;
    internal CommandStream Connection;
    internal ReceiveState(CommandStream connection);
}
internal class System.Net.RequestStream : Stream {
    private Byte[] buffer;
    private int offset;
    private int length;
    private long remaining_body;
    private bool disposed;
    private Stream stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal RequestStream(Stream stream, Byte[] buffer, int offset, int length);
    internal RequestStream(Stream stream, Byte[] buffer, int offset, int length, long contentlength);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    private int FillFromBuffer(Byte[] buffer, int off, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state);
    public virtual int EndRead(IAsyncResult ares);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state);
    public virtual void EndWrite(IAsyncResult async_result);
}
internal class System.Net.ResponseDescription : object {
    internal static int NoStatus;
    internal bool Multiline;
    internal int Status;
    internal string StatusDescription;
    internal StringBuilder StatusBuffer;
    internal string StatusCodeString;
    internal bool PositiveIntermediate { get; }
    internal bool PositiveCompletion { get; }
    internal bool TransientFailure { get; }
    internal bool PermanentFailure { get; }
    internal bool InvalidStatusCode { get; }
    internal bool get_PositiveIntermediate();
    internal bool get_PositiveCompletion();
    internal bool get_TransientFailure();
    internal bool get_PermanentFailure();
    internal bool get_InvalidStatusCode();
}
internal class System.Net.ResponseStream : Stream {
    private HttpListenerResponse response;
    private bool ignore_errors;
    private bool disposed;
    private bool trailer_sent;
    private Stream stream;
    private static Byte[] crlf;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ResponseStream(Stream stream, HttpListenerResponse response, bool ignore_errors);
    private static ResponseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    private MemoryStream GetHeaders(bool closing);
    public virtual void Flush();
    private static Byte[] GetChunkSizeBytes(int size, bool final);
    internal void InternalWrite(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cback, object state);
    public virtual void EndWrite(IAsyncResult ares);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cback, object state);
    public virtual int EndRead(IAsyncResult ares);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class System.Net.ScatterGatherBuffers : object {
    private MemoryChunk headChunk;
    private MemoryChunk currentChunk;
    private int nextChunkLength;
    private int totalLength;
    private int chunkCount;
    private bool Empty { get; }
    internal int Length { get; }
    internal ScatterGatherBuffers(long totalSize);
    internal BufferOffsetSize[] GetBuffers();
    private bool get_Empty();
    internal int get_Length();
    internal void Write(Byte[] buffer, int offset, int count);
    private MemoryChunk AllocateMemoryChunk(int newSize);
}
internal class System.Net.SecChannelBindings : object {
    internal int dwInitiatorAddrType;
    internal int cbInitiatorLength;
    internal int dwInitiatorOffset;
    internal int dwAcceptorAddrType;
    internal int cbAcceptorLength;
    internal int dwAcceptorOffset;
    internal int cbApplicationDataLength;
    internal int dwApplicationDataOffset;
}
internal class System.Net.SecPkgContext_Bindings : ValueType {
    internal int BindingsLength;
    internal IntPtr Bindings;
}
internal class System.Net.SecPkgContext_ConnectionInfo : object {
    public int Protocol;
    public int DataCipherAlg;
    public int DataKeySize;
    public int DataHashAlg;
    public int DataHashKeySize;
    public int KeyExchangeAlg;
    public int KeyExchKeySize;
    internal SecPkgContext_ConnectionInfo(Byte[] nativeBuffer);
}
internal class System.Net.SecPkgContext_NegotiationInfoW : ValueType {
    internal IntPtr PackageInfo;
    internal UInt32 NegotiationState;
}
internal class System.Net.SecPkgContext_Sizes : object {
    public int cbMaxToken;
    public int cbMaxSignature;
    public int cbBlockSize;
    public int cbSecurityTrailer;
    public static int SizeOf;
    internal SecPkgContext_Sizes(Byte[] memory);
    private static SecPkgContext_Sizes();
}
internal class System.Net.SecPkgContext_StreamSizes : object {
    public int cbHeader;
    public int cbTrailer;
    public int cbMaximumMessage;
    public int cBuffers;
    public int cbBlockSize;
    public static int SizeOf;
    internal SecPkgContext_StreamSizes(Byte[] memory);
    private static SecPkgContext_StreamSizes();
}
public abstract class System.Net.Security.AuthenticatedStream : Stream {
    private Stream _InnerStream;
    private bool _LeaveStreamOpen;
    public bool LeaveInnerStreamOpen { get; }
    protected Stream InnerStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    protected AuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen);
    public bool get_LeaveInnerStreamOpen();
    protected Stream get_InnerStream();
    protected virtual void Dispose(bool disposing);
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsMutuallyAuthenticated();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsSigned();
    public abstract virtual bool get_IsServer();
}
public enum System.Net.Security.AuthenticationLevel : Enum {
    public int value__;
    public static AuthenticationLevel None;
    public static AuthenticationLevel MutualAuthRequested;
    public static AuthenticationLevel MutualAuthRequired;
}
internal static class System.Net.Security.CertificateHelper : object {
    private static string ClientAuthenticationOID;
    internal static X509Certificate2 GetEligibleClientCertificate(X509CertificateCollection candidateCerts);
    internal static X509Certificate2 GetEligibleClientCertificate(X509Certificate2Collection candidateCerts);
    private static bool IsValidClientCertificate(X509Certificate2 cert);
    private static bool IsValidForClientAuthenticationEKU(X509EnhancedKeyUsageExtension eku);
    private static bool IsValidForDigitalSignatureUsage(X509KeyUsageExtension ku);
    internal static X509Certificate2 GetEligibleClientCertificate();
}
public enum System.Net.Security.EncryptionPolicy : Enum {
    public int value__;
    public static EncryptionPolicy RequireEncryption;
    public static EncryptionPolicy AllowNoEncryption;
    public static EncryptionPolicy NoEncryption;
}
public class System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
    public LocalCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.LocalCertSelectionCallback : MulticastDelegate {
    public LocalCertSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
public class System.Net.Security.NegotiateStream : AuthenticatedStream {
    private int readTimeout;
    private int writeTimeout;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    [MonoTODOAttribute]
public bool CanTimeout { get; }
    public bool CanWrite { get; }
    [MonoTODOAttribute]
public TokenImpersonationLevel ImpersonationLevel { get; }
    [MonoTODOAttribute]
public bool IsAuthenticated { get; }
    [MonoTODOAttribute]
public bool IsEncrypted { get; }
    [MonoTODOAttribute]
public bool IsMutuallyAuthenticated { get; }
    [MonoTODOAttribute]
public bool IsServer { get; }
    [MonoTODOAttribute]
public bool IsSigned { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    [MonoTODOAttribute]
public IIdentity RemoteIdentity { get; }
    public int WriteTimeout { get; public set; }
    [MonoTODOAttribute]
public NegotiateStream(Stream innerStream);
    [MonoTODOAttribute]
public NegotiateStream(Stream innerStream, bool leaveInnerStreamOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual TokenImpersonationLevel get_ImpersonationLevel();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsServer();
    public virtual bool get_IsSigned();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual IIdentity get_RemoteIdentity();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginAuthenticateAsServer(AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginAuthenticateAsServer(ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    [MonoTODOAttribute]
public virtual void AuthenticateAsClient();
    [MonoTODOAttribute]
public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName);
    [MonoTODOAttribute]
public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName);
    [MonoTODOAttribute]
public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    [MonoTODOAttribute]
public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    [MonoTODOAttribute]
public virtual void AuthenticateAsServer();
    [MonoTODOAttribute]
public virtual void AuthenticateAsServer(ExtendedProtectionPolicy policy);
    [MonoTODOAttribute]
public virtual void AuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    [MonoTODOAttribute]
public virtual void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    [MonoTODOAttribute]
protected virtual void Dispose(bool disposing);
    [MonoTODOAttribute]
public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    [MonoTODOAttribute]
public virtual int EndRead(IAsyncResult asyncResult);
    [MonoTODOAttribute]
public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    [MonoTODOAttribute]
public virtual void EndWrite(IAsyncResult asyncResult);
    [MonoTODOAttribute]
public virtual void Flush();
    [MonoTODOAttribute]
public virtual int Read(Byte[] buffer, int offset, int count);
    [MonoTODOAttribute]
public virtual long Seek(long offset, SeekOrigin origin);
    [MonoTODOAttribute]
public virtual void SetLength(long value);
    [MonoTODOAttribute]
public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task AuthenticateAsClientAsync();
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync();
    public virtual Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
}
internal static class System.Net.Security.NegotiateStreamPal : object {
    internal static int QueryMaxTokenSize(string package);
    internal static SafeFreeCredentials AcquireDefaultCredential(string package, bool isServer);
    internal static SafeFreeCredentials AcquireCredentialsHandle(string package, bool isServer, NetworkCredential credential);
    internal static string QueryContextClientSpecifiedSpn(SafeDeleteContext securityContext);
    internal static string QueryContextAuthenticationPackage(SafeDeleteContext securityContext);
    internal static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, string spn, ContextFlagsPal requestedContextFlags, SecurityBuffer[] inSecurityBufferArray, SecurityBuffer outSecurityBuffer, ContextFlagsPal& contextFlags);
    internal static SecurityStatusPal CompleteAuthToken(SafeDeleteContext& securityContext, SecurityBuffer[] inSecurityBufferArray);
    internal static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, ContextFlagsPal requestedContextFlags, SecurityBuffer[] inSecurityBufferArray, SecurityBuffer outSecurityBuffer, ContextFlagsPal& contextFlags);
    internal static Win32Exception CreateExceptionFromError(SecurityStatusPal statusCode);
    internal static int VerifySignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count);
    internal static int MakeSignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, Byte[]& output);
}
public enum System.Net.Security.ProtectionLevel : Enum {
    public int value__;
    public static ProtectionLevel None;
    public static ProtectionLevel Sign;
    public static ProtectionLevel EncryptAndSign;
}
public class System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
    public RemoteCertificateValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.RemoteCertValidationCallback : MulticastDelegate {
    public RemoteCertValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(string host, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(string host, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.SafeCredentialReference : CriticalHandleMinusOneIsInvalid {
    internal SafeFreeCredentials Target;
    private SafeCredentialReference(SafeFreeCredentials target);
    internal static SafeCredentialReference CreateReference(SafeFreeCredentials target);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeDeleteContext : SafeHandle {
    internal CredHandle _handle;
    private static string dummyStr;
    private static Byte[] s_dummyBytes;
    private static IdnMapping s_idnMapping;
    protected SafeFreeCredentials _EffectiveCredential;
    public bool IsInvalid { get; }
    private static SafeDeleteContext();
    public virtual bool get_IsInvalid();
    public virtual string ToString();
    internal static int InitializeSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inSecBuffer, SecurityBuffer[] inSecBuffers, SecurityBuffer outSecBuffer, ContextFlags& outFlags);
    private static int MustRunInitializeSecurityContext(SafeFreeCredentials& inCredentials, Void* inContextPtr, Byte* targetName, ContextFlags inFlags, Endianness endianness, SecBufferDesc* inputBuffer, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& attributes, SafeFreeContextBuffer handleTemplate);
    internal static int AcceptSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, ContextFlags inFlags, Endianness endianness, SecurityBuffer inSecBuffer, SecurityBuffer[] inSecBuffers, SecurityBuffer outSecBuffer, ContextFlags& outFlags);
    private static int MustRunAcceptSecurityContext_SECURITY(SafeFreeCredentials& inCredentials, Void* inContextPtr, SecBufferDesc* inputBuffer, ContextFlags inFlags, Endianness endianness, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& outFlags, SafeFreeContextBuffer handleTemplate);
    internal static int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inSecBuffers);
    internal static int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inSecBuffers);
}
internal class System.Net.Security.SafeDeleteContext_SECURITY : SafeDeleteContext {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCertContext : SafeHandleZeroOrMinusOneIsInvalid {
    private static UInt32 CRYPT_ACQUIRE_SILENT_FLAG;
    internal void Set(IntPtr value);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeContextBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    internal void Set(IntPtr value);
    internal static int EnumeratePackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    internal static SafeFreeContextBuffer CreateEmptyHandle();
    public static int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte* buffer, SafeHandle refHandle);
    public static int SetContextAttributes(SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte[] buffer);
}
internal class System.Net.Security.SafeFreeContextBuffer_SECURITY : SafeFreeContextBuffer {
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeContextBufferChannelBinding : ChannelBinding {
    private int _size;
    public int Size { get; }
    public bool IsInvalid { get; }
    public virtual int get_Size();
    public virtual bool get_IsInvalid();
    internal void Set(IntPtr value);
    internal static SafeFreeContextBufferChannelBinding CreateEmptyHandle();
    public static int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute contextAttribute, SecPkgContext_Bindings* buffer, SafeFreeContextBufferChannelBinding refHandle);
    public virtual string ToString();
}
internal class System.Net.Security.SafeFreeContextBufferChannelBinding_SECURITY : SafeFreeContextBufferChannelBinding {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCredential_SECURITY : SafeFreeCredentials {
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeCredentials : SafeHandle {
    internal CredHandle _handle;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SEC_WINNT_AUTH_IDENTITY_W& authdata, SafeFreeCredentials& outCredential);
    public static int AcquireDefaultCredential(string package, CredentialUse intent, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential);
}
internal class System.Net.Security.SafeSspiAuthDataHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SecurityBuffer : object {
    public int size;
    public SecurityBufferType type;
    public Byte[] token;
    public SafeHandle unmanagedToken;
    public int offset;
    public SecurityBuffer(Byte[] data, int offset, int size, SecurityBufferType tokentype);
    public SecurityBuffer(Byte[] data, SecurityBufferType tokentype);
    public SecurityBuffer(int size, SecurityBufferType tokentype);
    public SecurityBuffer(ChannelBinding binding);
}
internal enum System.Net.Security.SecurityBufferType : Enum {
    public int value__;
    public static SecurityBufferType SECBUFFER_EMPTY;
    public static SecurityBufferType SECBUFFER_DATA;
    public static SecurityBufferType SECBUFFER_TOKEN;
    public static SecurityBufferType SECBUFFER_PKG_PARAMS;
    public static SecurityBufferType SECBUFFER_MISSING;
    public static SecurityBufferType SECBUFFER_EXTRA;
    public static SecurityBufferType SECBUFFER_STREAM_TRAILER;
    public static SecurityBufferType SECBUFFER_STREAM_HEADER;
    public static SecurityBufferType SECBUFFER_PADDING;
    public static SecurityBufferType SECBUFFER_STREAM;
    public static SecurityBufferType SECBUFFER_CHANNEL_BINDINGS;
    public static SecurityBufferType SECBUFFER_TARGET_HOST;
    public static SecurityBufferType SECBUFFER_ALERT;
    public static SecurityBufferType SECBUFFER_APPLICATION_PROTOCOLS;
    public static SecurityBufferType SECBUFFER_READONLY;
    public static SecurityBufferType SECBUFFER_READONLY_WITH_CHECKSUM;
}
internal class System.Net.Security.SecurityContextTokenHandle : CriticalHandleZeroOrMinusOneIsInvalid {
    private int _disposed;
    internal IntPtr DangerousGetHandle();
    protected virtual bool ReleaseHandle();
}
public class System.Net.Security.ServerCertificateSelectionCallback : MulticastDelegate {
    public ServerCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string hostName);
    public virtual IAsyncResult BeginInvoke(object sender, string hostName, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.ServerCertSelectionCallback : MulticastDelegate {
    public ServerCertSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(string hostName);
    public virtual IAsyncResult BeginInvoke(string hostName, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class System.Net.Security.SslApplicationProtocol : ValueType {
    private ReadOnlyMemory`1<byte> _readOnlyProtocol;
    private static Encoding s_utf8;
    public static SslApplicationProtocol Http2;
    public static SslApplicationProtocol Http11;
    public ReadOnlyMemory`1<byte> Protocol { get; }
    internal SslApplicationProtocol(Byte[] protocol, bool copy);
    public SslApplicationProtocol(Byte[] protocol);
    public SslApplicationProtocol(string protocol);
    private static SslApplicationProtocol();
    public ReadOnlyMemory`1<byte> get_Protocol();
    public sealed virtual bool Equals(SslApplicationProtocol other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static char GetHexValue(int i);
    public static bool op_Equality(SslApplicationProtocol left, SslApplicationProtocol right);
    public static bool op_Inequality(SslApplicationProtocol left, SslApplicationProtocol right);
}
internal class System.Net.Security.SslAuthenticationOptions : object {
    [CompilerGeneratedAttribute]
private bool <AllowRenegotiation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServer>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback <LocalCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <ServerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <EnabledSslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private X509RevocationMode <CertificateRevocationCheckMode>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionPolicy <EncryptionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoteCertRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertName>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertValidationCallback <CertValidationDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalCertSelectionCallback <CertSelectionDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCertSelectionCallback <ServerCertSelectionDelegate>k__BackingField;
    internal bool AllowRenegotiation { get; internal set; }
    internal string TargetHost { get; internal set; }
    internal X509CertificateCollection ClientCertificates { get; internal set; }
    internal List`1<SslApplicationProtocol> ApplicationProtocols { get; }
    internal bool IsServer { get; internal set; }
    internal RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; internal set; }
    internal LocalCertificateSelectionCallback LocalCertificateSelectionCallback { get; internal set; }
    internal X509Certificate ServerCertificate { get; internal set; }
    internal SslProtocols EnabledSslProtocols { get; internal set; }
    internal X509RevocationMode CertificateRevocationCheckMode { get; internal set; }
    internal EncryptionPolicy EncryptionPolicy { get; internal set; }
    internal bool RemoteCertRequired { get; internal set; }
    internal bool CheckCertName { get; internal set; }
    internal RemoteCertValidationCallback CertValidationDelegate { get; internal set; }
    internal LocalCertSelectionCallback CertSelectionDelegate { get; internal set; }
    internal ServerCertSelectionCallback ServerCertSelectionDelegate { get; internal set; }
    internal SslAuthenticationOptions(SslClientAuthenticationOptions sslClientAuthenticationOptions, RemoteCertValidationCallback remoteCallback, LocalCertSelectionCallback localCallback);
    internal SslAuthenticationOptions(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    [CompilerGeneratedAttribute]
internal bool get_AllowRenegotiation();
    [CompilerGeneratedAttribute]
internal void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
internal string get_TargetHost();
    [CompilerGeneratedAttribute]
internal void set_TargetHost(string value);
    [CompilerGeneratedAttribute]
internal X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
internal void set_ClientCertificates(X509CertificateCollection value);
    [CompilerGeneratedAttribute]
internal List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
internal bool get_IsServer();
    [CompilerGeneratedAttribute]
internal void set_IsServer(bool value);
    [CompilerGeneratedAttribute]
internal RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
internal void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
internal LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
internal void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
internal X509Certificate get_ServerCertificate();
    [CompilerGeneratedAttribute]
internal void set_ServerCertificate(X509Certificate value);
    [CompilerGeneratedAttribute]
internal SslProtocols get_EnabledSslProtocols();
    [CompilerGeneratedAttribute]
internal void set_EnabledSslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
internal X509RevocationMode get_CertificateRevocationCheckMode();
    [CompilerGeneratedAttribute]
internal void set_CertificateRevocationCheckMode(X509RevocationMode value);
    [CompilerGeneratedAttribute]
internal EncryptionPolicy get_EncryptionPolicy();
    [CompilerGeneratedAttribute]
internal void set_EncryptionPolicy(EncryptionPolicy value);
    [CompilerGeneratedAttribute]
internal bool get_RemoteCertRequired();
    [CompilerGeneratedAttribute]
internal void set_RemoteCertRequired(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CheckCertName();
    [CompilerGeneratedAttribute]
internal void set_CheckCertName(bool value);
    [CompilerGeneratedAttribute]
internal RemoteCertValidationCallback get_CertValidationDelegate();
    [CompilerGeneratedAttribute]
internal void set_CertValidationDelegate(RemoteCertValidationCallback value);
    [CompilerGeneratedAttribute]
internal LocalCertSelectionCallback get_CertSelectionDelegate();
    [CompilerGeneratedAttribute]
internal void set_CertSelectionDelegate(LocalCertSelectionCallback value);
    [CompilerGeneratedAttribute]
internal ServerCertSelectionCallback get_ServerCertSelectionDelegate();
    [CompilerGeneratedAttribute]
internal void set_ServerCertSelectionDelegate(ServerCertSelectionCallback value);
}
public class System.Net.Security.SslClientAuthenticationOptions : object {
    private EncryptionPolicy _encryptionPolicy;
    private X509RevocationMode _checkCertificateRevocation;
    private SslProtocols _enabledSslProtocols;
    private bool _allowRenegotiation;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback <LocalCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    public bool AllowRenegotiation { get; public set; }
    public LocalCertificateSelectionCallback LocalCertificateSelectionCallback { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public string TargetHost { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
public LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
public string get_TargetHost();
    [CompilerGeneratedAttribute]
public void set_TargetHost(string value);
    [CompilerGeneratedAttribute]
public X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
public void set_ClientCertificates(X509CertificateCollection value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
}
[ExtensionAttribute]
internal static class System.Net.Security.SslClientAuthenticationOptionsExtensions : object {
    [ExtensionAttribute]
public static SslClientAuthenticationOptions ShallowClone(SslClientAuthenticationOptions options);
}
[FlagsAttribute]
public enum System.Net.Security.SslPolicyErrors : Enum {
    public int value__;
    public static SslPolicyErrors None;
    public static SslPolicyErrors RemoteCertificateNotAvailable;
    public static SslPolicyErrors RemoteCertificateNameMismatch;
    public static SslPolicyErrors RemoteCertificateChainErrors;
}
public class System.Net.Security.SslServerAuthenticationOptions : object {
    private X509RevocationMode _checkCertificateRevocation;
    private SslProtocols _enabledSslProtocols;
    private EncryptionPolicy _encryptionPolicy;
    private bool _allowRenegotiation;
    [CompilerGeneratedAttribute]
private bool <ClientCertificateRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCertificateSelectionCallback <ServerCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <ServerCertificate>k__BackingField;
    public bool AllowRenegotiation { get; public set; }
    public bool ClientCertificateRequired { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public ServerCertificateSelectionCallback ServerCertificateSelectionCallback { get; public set; }
    public X509Certificate ServerCertificate { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
public bool get_ClientCertificateRequired();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateRequired(bool value);
    [CompilerGeneratedAttribute]
public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public ServerCertificateSelectionCallback get_ServerCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateSelectionCallback(ServerCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public X509Certificate get_ServerCertificate();
    [CompilerGeneratedAttribute]
public void set_ServerCertificate(X509Certificate value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
}
public class System.Net.Security.SslStream : AuthenticatedStream {
    private MobileTlsProvider provider;
    private MonoTlsSettings settings;
    private RemoteCertificateValidationCallback validationCallback;
    private LocalCertificateSelectionCallback selectionCallback;
    private MobileAuthenticatedStream impl;
    private bool explicitSettings;
    internal MobileAuthenticatedStream Impl { get; }
    internal MonoTlsProvider Provider { get; }
    internal string InternalTargetHost { get; }
    public TransportContext TransportContext { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public SslProtocols SslProtocol { get; }
    public bool CheckCertRevocationStatus { get; }
    public X509Certificate LocalCertificate { get; }
    public X509Certificate RemoteCertificate { get; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public int CipherStrength { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public int HashStrength { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int KeyExchangeStrength { get; }
    public SslApplicationProtocol NegotiatedApplicationProtocol { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public SslStream(Stream innerStream);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback);
    [MonoLimitationAttribute("encryptionPolicy is ignored")]
public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy);
    internal SslStream(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsProvider provider, MonoTlsSettings settings);
    internal MobileAuthenticatedStream get_Impl();
    internal MonoTlsProvider get_Provider();
    internal string get_InternalTargetHost();
    private static MobileTlsProvider GetProvider();
    internal static IMonoSslStream CreateMonoSslStream(Stream innerStream, bool leaveInnerStreamOpen, MobileTlsProvider provider, MonoTlsSettings settings);
    private void SetAndVerifyValidationCallback(RemoteCertificateValidationCallback callback);
    private void SetAndVerifySelectionCallback(LocalCertificateSelectionCallback callback);
    private MonoSslServerAuthenticationOptions CreateAuthenticationOptions(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    public virtual void AuthenticateAsClient(string targetHost);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public TransportContext get_TransportContext();
    public virtual Task AuthenticateAsClientAsync(string targetHost);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsClientAsync(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsServerAsync(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken);
    public virtual Task ShutdownAsync();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual SslProtocols get_SslProtocol();
    public virtual bool get_CheckCertRevocationStatus();
    public virtual X509Certificate get_LocalCertificate();
    public virtual X509Certificate get_RemoteCertificate();
    public virtual CipherAlgorithmType get_CipherAlgorithm();
    public virtual int get_CipherStrength();
    public virtual HashAlgorithmType get_HashAlgorithm();
    public virtual int get_HashStrength();
    public virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public virtual int get_KeyExchangeStrength();
    public SslApplicationProtocol get_NegotiatedApplicationProtocol();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Flush();
    private void CheckDisposed();
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
}
internal static class System.Net.Security.SSPIHandleCache : object {
    private static int c_MaxCacheSize;
    private static SafeCredentialReference[] s_cacheSlots;
    private static int s_current;
    private static SSPIHandleCache();
    internal static void CacheCredential(SafeFreeCredentials newHandle);
}
internal class System.Net.SecurityPackageInfo : ValueType {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal IntPtr Name;
    internal IntPtr Comment;
}
internal class System.Net.SecurityPackageInfoClass : object {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal string Name;
    internal string Comment;
    internal SecurityPackageInfoClass(SafeHandle safeHandle, int index);
    public virtual string ToString();
}
internal static class System.Net.SecurityProtocol : object {
    public static SslProtocols DefaultSecurityProtocols;
    public static SslProtocols SystemDefaultSecurityProtocols;
}
[FlagsAttribute]
public enum System.Net.SecurityProtocolType : Enum {
    public int value__;
    public static SecurityProtocolType SystemDefault;
    public static SecurityProtocolType Ssl3;
    public static SecurityProtocolType Tls;
    public static SecurityProtocolType Tls11;
    public static SecurityProtocolType Tls12;
    public static SecurityProtocolType Tls13;
}
internal enum System.Net.SecurityStatus : Enum {
    public int value__;
    public static SecurityStatus OK;
    public static SecurityStatus ContinueNeeded;
    public static SecurityStatus CompleteNeeded;
    public static SecurityStatus CompAndContinue;
    public static SecurityStatus ContextExpired;
    public static SecurityStatus CredentialsNeeded;
    public static SecurityStatus Renegotiate;
    public static SecurityStatus OutOfMemory;
    public static SecurityStatus InvalidHandle;
    public static SecurityStatus Unsupported;
    public static SecurityStatus TargetUnknown;
    public static SecurityStatus InternalError;
    public static SecurityStatus PackageNotFound;
    public static SecurityStatus NotOwner;
    public static SecurityStatus CannotInstall;
    public static SecurityStatus InvalidToken;
    public static SecurityStatus CannotPack;
    public static SecurityStatus QopNotSupported;
    public static SecurityStatus NoImpersonation;
    public static SecurityStatus LogonDenied;
    public static SecurityStatus UnknownCredentials;
    public static SecurityStatus NoCredentials;
    public static SecurityStatus MessageAltered;
    public static SecurityStatus OutOfSequence;
    public static SecurityStatus NoAuthenticatingAuthority;
    public static SecurityStatus IncompleteMessage;
    public static SecurityStatus IncompleteCredentials;
    public static SecurityStatus BufferNotEnough;
    public static SecurityStatus WrongPrincipal;
    public static SecurityStatus TimeSkew;
    public static SecurityStatus UntrustedRoot;
    public static SecurityStatus IllegalMessage;
    public static SecurityStatus CertUnknown;
    public static SecurityStatus CertExpired;
    public static SecurityStatus AlgorithmMismatch;
    public static SecurityStatus SecurityQosFailed;
    public static SecurityStatus SmartcardLogonRequired;
    public static SecurityStatus UnsupportedPreauth;
    public static SecurityStatus BadBinding;
}
internal static class System.Net.SecurityStatusAdapterPal : object {
    private static int StatusDictionarySize;
    private static BidirectionalDictionary`2<SECURITY_STATUS, SecurityStatusPalErrorCode> s_statusDictionary;
    private static SecurityStatusAdapterPal();
    internal static SecurityStatusPal GetSecurityStatusPalFromNativeInt(int win32SecurityStatus);
    internal static SecurityStatusPal GetSecurityStatusPalFromInterop(SECURITY_STATUS win32SecurityStatus, bool attachException);
    internal static SECURITY_STATUS GetInteropFromSecurityStatusPal(SecurityStatusPal status);
}
[IsReadOnlyAttribute]
internal class System.Net.SecurityStatusPal : ValueType {
    public SecurityStatusPalErrorCode ErrorCode;
    public Exception Exception;
    public SecurityStatusPal(SecurityStatusPalErrorCode errorCode, Exception exception);
    public virtual string ToString();
}
internal enum System.Net.SecurityStatusPalErrorCode : Enum {
    public int value__;
    public static SecurityStatusPalErrorCode NotSet;
    public static SecurityStatusPalErrorCode OK;
    public static SecurityStatusPalErrorCode ContinueNeeded;
    public static SecurityStatusPalErrorCode CompleteNeeded;
    public static SecurityStatusPalErrorCode CompAndContinue;
    public static SecurityStatusPalErrorCode ContextExpired;
    public static SecurityStatusPalErrorCode CredentialsNeeded;
    public static SecurityStatusPalErrorCode Renegotiate;
    public static SecurityStatusPalErrorCode OutOfMemory;
    public static SecurityStatusPalErrorCode InvalidHandle;
    public static SecurityStatusPalErrorCode Unsupported;
    public static SecurityStatusPalErrorCode TargetUnknown;
    public static SecurityStatusPalErrorCode InternalError;
    public static SecurityStatusPalErrorCode PackageNotFound;
    public static SecurityStatusPalErrorCode NotOwner;
    public static SecurityStatusPalErrorCode CannotInstall;
    public static SecurityStatusPalErrorCode InvalidToken;
    public static SecurityStatusPalErrorCode CannotPack;
    public static SecurityStatusPalErrorCode QopNotSupported;
    public static SecurityStatusPalErrorCode NoImpersonation;
    public static SecurityStatusPalErrorCode LogonDenied;
    public static SecurityStatusPalErrorCode UnknownCredentials;
    public static SecurityStatusPalErrorCode NoCredentials;
    public static SecurityStatusPalErrorCode MessageAltered;
    public static SecurityStatusPalErrorCode OutOfSequence;
    public static SecurityStatusPalErrorCode NoAuthenticatingAuthority;
    public static SecurityStatusPalErrorCode IncompleteMessage;
    public static SecurityStatusPalErrorCode IncompleteCredentials;
    public static SecurityStatusPalErrorCode BufferNotEnough;
    public static SecurityStatusPalErrorCode WrongPrincipal;
    public static SecurityStatusPalErrorCode TimeSkew;
    public static SecurityStatusPalErrorCode UntrustedRoot;
    public static SecurityStatusPalErrorCode IllegalMessage;
    public static SecurityStatusPalErrorCode CertUnknown;
    public static SecurityStatusPalErrorCode CertExpired;
    public static SecurityStatusPalErrorCode AlgorithmMismatch;
    public static SecurityStatusPalErrorCode SecurityQosFailed;
    public static SecurityStatusPalErrorCode SmartcardLogonRequired;
    public static SecurityStatusPalErrorCode UnsupportedPreauth;
    public static SecurityStatusPalErrorCode BadBinding;
    public static SecurityStatusPalErrorCode DowngradeDetected;
    public static SecurityStatusPalErrorCode ApplicationProtocolMismatch;
}
internal class System.Net.Semaphore : WaitHandle {
    internal Semaphore(int initialCount, int maxCount);
    internal bool ReleaseSemaphore();
}
internal class System.Net.ServerCertValidationCallback : object {
    private RemoteCertificateValidationCallback m_ValidationCallback;
    private ExecutionContext m_Context;
    internal RemoteCertificateValidationCallback ValidationCallback { get; }
    internal ServerCertValidationCallback(RemoteCertificateValidationCallback validationCallback);
    internal RemoteCertificateValidationCallback get_ValidationCallback();
    internal void Callback(object state);
    internal bool Invoke(object request, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
}
internal class System.Net.ServiceNameStore : object {
    private List`1<string> serviceNames;
    private ServiceNameCollection serviceNameCollection;
    public ServiceNameCollection ServiceNames { get; }
    public ServiceNameCollection get_ServiceNames();
    private bool AddSingleServiceName(string spn);
    public bool Add(string uriPrefix);
    public bool Remove(string uriPrefix);
    private bool Contains(string newServiceName);
    public void Clear();
    private string ExtractHostname(string uriPrefix, bool allowInvalidUriStrings);
    public string BuildSimpleServiceName(string uriPrefix);
    public String[] BuildServiceNames(string uriPrefix);
}
public class System.Net.ServicePoint : object {
    private Uri uri;
    private DateTime lastDnsResolve;
    private Version protocolVersion;
    private IPHostEntry host;
    private bool usesProxy;
    private bool sendContinue;
    private bool useConnect;
    private object hostE;
    private bool useNagle;
    private BindIPEndPoint endPointCallback;
    private bool tcp_keepalive;
    private int tcp_keepalive_time;
    private int tcp_keepalive_interval;
    private bool disposed;
    private int connectionLeaseTimeout;
    private int receiveBufferSize;
    [CompilerGeneratedAttribute]
private SPKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private ServicePointScheduler <Scheduler>k__BackingField;
    private int connectionLimit;
    private int maxIdleTime;
    private object m_ServerCertificateOrBytes;
    private object m_ClientCertificateOrBytes;
    internal SPKey Key { get; }
    private ServicePointScheduler Scheduler { get; private set; }
    public Uri Address { get; }
    public BindIPEndPoint BindIPEndPointDelegate { get; public set; }
    public int ConnectionLeaseTimeout { get; public set; }
    public int ConnectionLimit { get; public set; }
    public string ConnectionName { get; }
    public int CurrentConnections { get; }
    public DateTime IdleSince { get; }
    public int MaxIdleTime { get; public set; }
    public Version ProtocolVersion { get; }
    public int ReceiveBufferSize { get; public set; }
    public bool SupportsPipelining { get; }
    public bool Expect100Continue { get; public set; }
    public bool UseNagleAlgorithm { get; public set; }
    internal bool SendContinue { get; internal set; }
    internal bool UsesProxy { get; internal set; }
    internal bool UseConnect { get; internal set; }
    private bool HasTimedOut { get; }
    internal IPHostEntry HostEntry { get; }
    public X509Certificate Certificate { get; }
    public X509Certificate ClientCertificate { get; }
    internal ServicePoint(SPKey key, Uri uri, int connectionLimit, int maxIdleTime);
    [CompilerGeneratedAttribute]
internal SPKey get_Key();
    [CompilerGeneratedAttribute]
private ServicePointScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
private void set_Scheduler(ServicePointScheduler value);
    public Uri get_Address();
    public BindIPEndPoint get_BindIPEndPointDelegate();
    public void set_BindIPEndPointDelegate(BindIPEndPoint value);
    public int get_ConnectionLeaseTimeout();
    public void set_ConnectionLeaseTimeout(int value);
    public int get_ConnectionLimit();
    public void set_ConnectionLimit(int value);
    public string get_ConnectionName();
    public int get_CurrentConnections();
    public DateTime get_IdleSince();
    public int get_MaxIdleTime();
    public void set_MaxIdleTime(int value);
    public virtual Version get_ProtocolVersion();
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public bool get_SupportsPipelining();
    public bool get_Expect100Continue();
    public void set_Expect100Continue(bool value);
    public bool get_UseNagleAlgorithm();
    public void set_UseNagleAlgorithm(bool value);
    internal bool get_SendContinue();
    internal void set_SendContinue(bool value);
    public void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);
    internal void KeepAliveSetup(Socket socket);
    private static void PutBytes(Byte[] bytes, UInt32 v, int offset);
    internal bool get_UsesProxy();
    internal void set_UsesProxy(bool value);
    internal bool get_UseConnect();
    internal void set_UseConnect(bool value);
    private bool get_HasTimedOut();
    internal IPHostEntry get_HostEntry();
    internal void SetVersion(Version version);
    internal void SendRequest(WebOperation operation, string groupName);
    public bool CloseConnectionGroup(string connectionGroupName);
    internal void FreeServicePoint();
    public X509Certificate get_Certificate();
    internal void UpdateServerCertificate(X509Certificate certificate);
    public X509Certificate get_ClientCertificate();
    internal void UpdateClientCertificate(X509Certificate certificate);
    internal bool CallEndPointDelegate(Socket sock, IPEndPoint remote);
}
public class System.Net.ServicePointManager : object {
    private static ConcurrentDictionary`2<SPKey, ServicePoint> servicePoints;
    private static ICertificatePolicy policy;
    private static int defaultConnectionLimit;
    private static int maxServicePointIdleTime;
    private static int maxServicePoints;
    private static int dnsRefreshTimeout;
    private static bool _checkCRL;
    private static SecurityProtocolType _securityProtocol;
    private static bool expectContinue;
    private static bool useNagle;
    private static ServerCertValidationCallback server_cert_cb;
    private static bool tcp_keepalive;
    private static int tcp_keepalive_time;
    private static int tcp_keepalive_interval;
    public static int DefaultNonPersistentConnectionLimit;
    public static int DefaultPersistentConnectionLimit;
    private static string configKey;
    private static ConnectionManagementData manager;
    [ObsoleteAttribute("Use ServerCertificateValidationCallback instead", "False")]
public static ICertificatePolicy CertificatePolicy { get; public set; }
    [MonoTODOAttribute("CRL checks not implemented")]
public static bool CheckCertificateRevocationList { get; public set; }
    public static int DefaultConnectionLimit { get; public set; }
    public static int DnsRefreshTimeout { get; public set; }
    [MonoTODOAttribute]
public static bool EnableDnsRoundRobin { get; public set; }
    public static int MaxServicePointIdleTime { get; public set; }
    public static int MaxServicePoints { get; public set; }
    [MonoTODOAttribute]
public static bool ReusePort { get; public set; }
    public static SecurityProtocolType SecurityProtocol { get; public set; }
    internal static ServerCertValidationCallback ServerCertValidationCallback { get; }
    public static RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    [MonoTODOAttribute("Always returns EncryptionPolicy.RequireEncryption.")]
public static EncryptionPolicy EncryptionPolicy { get; }
    public static bool Expect100Continue { get; public set; }
    public static bool UseNagleAlgorithm { get; public set; }
    internal static bool DisableStrongCrypto { get; }
    internal static bool DisableSendAuxRecord { get; }
    private static ServicePointManager();
    public static ICertificatePolicy get_CertificatePolicy();
    public static void set_CertificatePolicy(ICertificatePolicy value);
    internal static ICertificatePolicy GetLegacyCertificatePolicy();
    public static bool get_CheckCertificateRevocationList();
    public static void set_CheckCertificateRevocationList(bool value);
    public static int get_DefaultConnectionLimit();
    public static void set_DefaultConnectionLimit(int value);
    private static Exception GetMustImplement();
    public static int get_DnsRefreshTimeout();
    public static void set_DnsRefreshTimeout(int value);
    public static bool get_EnableDnsRoundRobin();
    public static void set_EnableDnsRoundRobin(bool value);
    public static int get_MaxServicePointIdleTime();
    public static void set_MaxServicePointIdleTime(int value);
    public static int get_MaxServicePoints();
    public static void set_MaxServicePoints(int value);
    public static bool get_ReusePort();
    public static void set_ReusePort(bool value);
    public static SecurityProtocolType get_SecurityProtocol();
    public static void set_SecurityProtocol(SecurityProtocolType value);
    internal static ServerCertValidationCallback get_ServerCertValidationCallback();
    public static RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    public static void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public static EncryptionPolicy get_EncryptionPolicy();
    public static bool get_Expect100Continue();
    public static void set_Expect100Continue(bool value);
    public static bool get_UseNagleAlgorithm();
    public static void set_UseNagleAlgorithm(bool value);
    internal static bool get_DisableStrongCrypto();
    internal static bool get_DisableSendAuxRecord();
    public static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);
    public static ServicePoint FindServicePoint(Uri address);
    public static ServicePoint FindServicePoint(string uriString, IWebProxy proxy);
    public static ServicePoint FindServicePoint(Uri address, IWebProxy proxy);
    internal static void CloseConnectionGroup(string connectionGroupName);
    internal static void RemoveServicePoint(ServicePoint sp);
}
internal class System.Net.ServicePointScheduler : object {
    [CompilerGeneratedAttribute]
private ServicePoint <ServicePoint>k__BackingField;
    private int running;
    private int maxIdleTime;
    private AsyncManualResetEvent schedulerEvent;
    private ConnectionGroup defaultGroup;
    private Dictionary`2<string, ConnectionGroup> groups;
    private LinkedList`1<ValueTuple`2<ConnectionGroup, WebOperation>> operations;
    private LinkedList`1<ValueTuple`3<ConnectionGroup, WebConnection, Task>> idleConnections;
    private int currentConnections;
    private int connectionLimit;
    private DateTime idleSince;
    private static int nextId;
    public int ID;
    [CompilerGeneratedAttribute]
private string <ME>k__BackingField;
    private ServicePoint ServicePoint { get; private set; }
    public int MaxIdleTime { get; public set; }
    public int ConnectionLimit { get; public set; }
    public int CurrentConnections { get; }
    public DateTime IdleSince { get; }
    internal string ME { get; }
    public ServicePointScheduler(ServicePoint servicePoint, int connectionLimit, int maxIdleTime);
    [CompilerGeneratedAttribute]
private ServicePoint get_ServicePoint();
    [CompilerGeneratedAttribute]
private void set_ServicePoint(ServicePoint value);
    public int get_MaxIdleTime();
    public void set_MaxIdleTime(int value);
    public int get_ConnectionLimit();
    public void set_ConnectionLimit(int value);
    [ConditionalAttribute("MONO_WEB_DEBUG")]
private void Debug(string message);
    public int get_CurrentConnections();
    public DateTime get_IdleSince();
    [CompilerGeneratedAttribute]
internal string get_ME();
    public void Run();
    [AsyncStateMachineAttribute("System.Net.ServicePointScheduler/<RunScheduler>d__32")]
private Task RunScheduler();
    private void Cleanup();
    private void RunSchedulerIteration();
    private bool OperationCompleted(ConnectionGroup group, WebOperation operation);
    private void CloseIdleConnection(ConnectionGroup group, WebConnection connection);
    private bool SchedulerIteration(ConnectionGroup group);
    private void RemoveOperation(WebOperation operation);
    private void RemoveIdleConnection(WebConnection connection);
    private void FinalCleanup();
    public void SendRequest(WebOperation operation, string groupName);
    public bool CloseConnectionGroup(string groupName);
    private ConnectionGroup GetConnectionGroup(string name);
    private void OnConnectionCreated(WebConnection connection);
    private void OnConnectionClosed(WebConnection connection);
    [AsyncStateMachineAttribute("System.Net.ServicePointScheduler/<WaitAsync>d__46")]
public static Task`1<bool> WaitAsync(Task workerTask, int millisecondTimeout);
    [CompilerGeneratedAttribute]
private Task <Run>b__31_0();
}
[DefaultMemberAttribute("Item")]
public class System.Net.SocketAddress : object {
    internal static int IPv6AddressSize;
    internal static int IPv4AddressSize;
    internal int m_Size;
    internal Byte[] m_Buffer;
    private static int WriteableOffset;
    private static int MaxSize;
    private bool m_changed;
    private int m_hash;
    public AddressFamily Family { get; }
    public int Size { get; }
    public byte Item { get; public set; }
    public SocketAddress(AddressFamily family);
    public SocketAddress(AddressFamily family, int size);
    internal SocketAddress(IPAddress ipAddress);
    internal SocketAddress(IPAddress ipaddress, int port);
    public AddressFamily get_Family();
    public int get_Size();
    public byte get_Item(int offset);
    public void set_Item(int offset, byte value);
    internal IPAddress GetIPAddress();
    internal IPEndPoint GetIPEndPoint();
    internal void CopyAddressSizeIntoBuffer();
    internal int GetAddressSizeOffset();
    internal void SetSize(IntPtr ptr);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Net.SocketPermission : CodeAccessPermission {
    private ArrayList m_acceptList;
    private ArrayList m_connectList;
    private bool m_noRestriction;
    public static int AllPorts;
    public IEnumerator AcceptList { get; }
    public IEnumerator ConnectList { get; }
    public SocketPermission(PermissionState state);
    public SocketPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber);
    public IEnumerator get_AcceptList();
    public IEnumerator get_ConnectList();
    public void AddPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber);
    public virtual IPermission Copy();
    public virtual IPermission Intersect(IPermission target);
    private bool IntersectEmpty(SocketPermission permission);
    private void Intersect(ArrayList list1, ArrayList list2, ArrayList result);
    public virtual bool IsSubsetOf(IPermission target);
    private bool IsSubsetOf(ArrayList list1, ArrayList list2);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    private void ToXml(SecurityElement root, string childName, IEnumerator enumerator);
    public virtual void FromXml(SecurityElement securityElement);
    private void FromXml(ArrayList endpoints, NetworkAccess access);
    public virtual IPermission Union(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Net.SocketPermissionAttribute : CodeAccessSecurityAttribute {
    private string m_access;
    private string m_host;
    private string m_port;
    private string m_transport;
    public string Access { get; public set; }
    public string Host { get; public set; }
    public string Port { get; public set; }
    public string Transport { get; public set; }
    public SocketPermissionAttribute(SecurityAction action);
    public string get_Access();
    public void set_Access(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Port();
    public void set_Port(string value);
    public string get_Transport();
    public void set_Transport(string value);
    public virtual IPermission CreatePermission();
    internal void AlreadySet(string property);
}
public enum System.Net.Sockets.AddressFamily : Enum {
    public int value__;
    public static AddressFamily Unknown;
    public static AddressFamily Unspecified;
    public static AddressFamily Unix;
    public static AddressFamily InterNetwork;
    public static AddressFamily ImpLink;
    public static AddressFamily Pup;
    public static AddressFamily Chaos;
    public static AddressFamily NS;
    public static AddressFamily Ipx;
    public static AddressFamily Iso;
    public static AddressFamily Osi;
    public static AddressFamily Ecma;
    public static AddressFamily DataKit;
    public static AddressFamily Ccitt;
    public static AddressFamily Sna;
    public static AddressFamily DecNet;
    public static AddressFamily DataLink;
    public static AddressFamily Lat;
    public static AddressFamily HyperChannel;
    public static AddressFamily AppleTalk;
    public static AddressFamily NetBios;
    public static AddressFamily VoiceView;
    public static AddressFamily FireFox;
    public static AddressFamily Banyan;
    public static AddressFamily Atm;
    public static AddressFamily InterNetworkV6;
    public static AddressFamily Cluster;
    public static AddressFamily Ieee12844;
    public static AddressFamily Irda;
    public static AddressFamily NetworkDesigners;
    public static AddressFamily Max;
}
internal class System.Net.Sockets.DualSocketMultipleConnectAsync : MultipleConnectAsync {
    private Socket _socket4;
    private Socket _socket6;
    public DualSocketMultipleConnectAsync(SocketType socketType, ProtocolType protocolType);
    protected virtual IPAddress GetNextAddress(Socket& attemptSocket);
    protected virtual void OnSucceed();
    protected virtual void OnFail(bool abortive);
}
public enum System.Net.Sockets.IOControlCode : Enum {
    public long value__;
    public static IOControlCode AsyncIO;
    public static IOControlCode NonBlockingIO;
    public static IOControlCode DataToRead;
    public static IOControlCode OobDataRead;
    public static IOControlCode AssociateHandle;
    public static IOControlCode EnableCircularQueuing;
    public static IOControlCode Flush;
    public static IOControlCode GetBroadcastAddress;
    public static IOControlCode GetExtensionFunctionPointer;
    public static IOControlCode GetQos;
    public static IOControlCode GetGroupQos;
    public static IOControlCode MultipointLoopback;
    public static IOControlCode MulticastScope;
    public static IOControlCode SetQos;
    public static IOControlCode SetGroupQos;
    public static IOControlCode TranslateHandle;
    public static IOControlCode RoutingInterfaceQuery;
    public static IOControlCode RoutingInterfaceChange;
    public static IOControlCode AddressListQuery;
    public static IOControlCode AddressListChange;
    public static IOControlCode QueryTargetPnpHandle;
    public static IOControlCode NamespaceChange;
    public static IOControlCode AddressListSort;
    public static IOControlCode ReceiveAll;
    public static IOControlCode ReceiveAllMulticast;
    public static IOControlCode ReceiveAllIgmpMulticast;
    public static IOControlCode KeepAliveValues;
    public static IOControlCode AbsorbRouterAlert;
    public static IOControlCode UnicastInterface;
    public static IOControlCode LimitBroadcasts;
    public static IOControlCode BindToInterface;
    public static IOControlCode MulticastInterface;
    public static IOControlCode AddMulticastGroupOnInterface;
    public static IOControlCode DeleteMulticastGroupFromInterface;
}
public class System.Net.Sockets.IPPacketInformation : ValueType {
    private IPAddress address;
    private int networkInterface;
    public IPAddress Address { get; }
    public int Interface { get; }
    internal IPPacketInformation(IPAddress address, int networkInterface);
    public IPAddress get_Address();
    public int get_Interface();
    public static bool op_Equality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
    public static bool op_Inequality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
}
public enum System.Net.Sockets.IPProtectionLevel : Enum {
    public int value__;
    public static IPProtectionLevel Unspecified;
    public static IPProtectionLevel Unrestricted;
    public static IPProtectionLevel EdgeRestricted;
    public static IPProtectionLevel Restricted;
}
public class System.Net.Sockets.IPv6MulticastOption : object {
    private IPAddress m_Group;
    private long m_Interface;
    public IPAddress Group { get; public set; }
    public long InterfaceIndex { get; public set; }
    public IPv6MulticastOption(IPAddress group, long ifindex);
    public IPv6MulticastOption(IPAddress group);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    public long get_InterfaceIndex();
    public void set_InterfaceIndex(long value);
}
public class System.Net.Sockets.LingerOption : object {
    private bool enabled;
    private int lingerTime;
    public bool Enabled { get; public set; }
    public int LingerTime { get; public set; }
    public LingerOption(bool enable, int seconds);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public int get_LingerTime();
    public void set_LingerTime(int value);
}
public class System.Net.Sockets.MulticastOption : object {
    private IPAddress group;
    private IPAddress localAddress;
    private int ifIndex;
    public IPAddress Group { get; public set; }
    public IPAddress LocalAddress { get; public set; }
    public int InterfaceIndex { get; public set; }
    public MulticastOption(IPAddress group, IPAddress mcint);
    public MulticastOption(IPAddress group, int interfaceIndex);
    public MulticastOption(IPAddress group);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    public IPAddress get_LocalAddress();
    public void set_LocalAddress(IPAddress value);
    public int get_InterfaceIndex();
    public void set_InterfaceIndex(int value);
}
internal abstract class System.Net.Sockets.MultipleConnectAsync : object {
    protected SocketAsyncEventArgs _userArgs;
    protected SocketAsyncEventArgs _internalArgs;
    protected DnsEndPoint _endPoint;
    protected IPAddress[] _addressList;
    protected int _nextAddress;
    private State _state;
    private object _lockObject;
    public bool StartConnectAsync(SocketAsyncEventArgs args, DnsEndPoint endPoint);
    private void DnsCallback(IAsyncResult result);
    private bool DoDnsCallback(IAsyncResult result, bool sync);
    private void InternalConnectCallback(object sender, SocketAsyncEventArgs args);
    private Exception AttemptConnection();
    private Exception AttemptConnection(Socket attemptSocket, SocketAsyncEventArgs args);
    protected abstract virtual void OnSucceed();
    private void Succeed();
    protected abstract virtual void OnFail(bool abortive);
    private bool Fail(bool sync, Exception e);
    private void SyncFail(Exception e);
    private void AsyncFail(Exception e);
    public void Cancel();
    private void CallAsyncFail(object ignored);
    protected abstract virtual IPAddress GetNextAddress(Socket& attemptSocket);
    [CompilerGeneratedAttribute]
private void <Cancel>b__20_0(object s);
}
public class System.Net.Sockets.NetworkStream : Stream {
    private Socket _streamSocket;
    private bool _ownsSocket;
    private bool _readable;
    private bool _writeable;
    private int _closeTimeout;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cleanedUp;
    private int _currentReadTimeout;
    private int _currentWriteTimeout;
    protected Socket Socket { get; }
    protected bool Readable { get; protected set; }
    protected bool Writeable { get; protected set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool DataAvailable { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal Socket InternalSocket { get; }
    public NetworkStream(Socket socket);
    public NetworkStream(Socket socket, bool ownsSocket);
    public NetworkStream(Socket socket, FileAccess access);
    public NetworkStream(Socket socket, FileAccess access, bool ownsSocket);
    protected Socket get_Socket();
    protected bool get_Readable();
    protected void set_Readable(bool value);
    protected bool get_Writeable();
    protected void set_Writeable(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual bool get_DataAvailable();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual int Read(Span`1<byte> destination);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual void Write(ReadOnlySpan`1<byte> source);
    public virtual void WriteByte(byte value);
    public void Close(int timeout);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    internal void SetSocketTimeoutOption(SocketShutdown mode, int timeout, bool silent);
    internal Socket get_InternalSocket();
}
public enum System.Net.Sockets.ProtocolFamily : Enum {
    public int value__;
    public static ProtocolFamily Unknown;
    public static ProtocolFamily Unspecified;
    public static ProtocolFamily Unix;
    public static ProtocolFamily InterNetwork;
    public static ProtocolFamily ImpLink;
    public static ProtocolFamily Pup;
    public static ProtocolFamily Chaos;
    public static ProtocolFamily NS;
    public static ProtocolFamily Ipx;
    public static ProtocolFamily Iso;
    public static ProtocolFamily Osi;
    public static ProtocolFamily Ecma;
    public static ProtocolFamily DataKit;
    public static ProtocolFamily Ccitt;
    public static ProtocolFamily Sna;
    public static ProtocolFamily DecNet;
    public static ProtocolFamily DataLink;
    public static ProtocolFamily Lat;
    public static ProtocolFamily HyperChannel;
    public static ProtocolFamily AppleTalk;
    public static ProtocolFamily NetBios;
    public static ProtocolFamily VoiceView;
    public static ProtocolFamily FireFox;
    public static ProtocolFamily Banyan;
    public static ProtocolFamily Atm;
    public static ProtocolFamily InterNetworkV6;
    public static ProtocolFamily Cluster;
    public static ProtocolFamily Ieee12844;
    public static ProtocolFamily Irda;
    public static ProtocolFamily NetworkDesigners;
    public static ProtocolFamily Max;
}
public enum System.Net.Sockets.ProtocolType : Enum {
    public int value__;
    public static ProtocolType IP;
    public static ProtocolType IPv6HopByHopOptions;
    public static ProtocolType Icmp;
    public static ProtocolType Igmp;
    public static ProtocolType Ggp;
    public static ProtocolType IPv4;
    public static ProtocolType Tcp;
    public static ProtocolType Pup;
    public static ProtocolType Udp;
    public static ProtocolType Idp;
    public static ProtocolType IPv6;
    public static ProtocolType IPv6RoutingHeader;
    public static ProtocolType IPv6FragmentHeader;
    public static ProtocolType IPSecEncapsulatingSecurityPayload;
    public static ProtocolType IPSecAuthenticationHeader;
    public static ProtocolType IcmpV6;
    public static ProtocolType IPv6NoNextHeader;
    public static ProtocolType IPv6DestinationOptions;
    public static ProtocolType ND;
    public static ProtocolType Raw;
    public static ProtocolType Unspecified;
    public static ProtocolType Ipx;
    public static ProtocolType Spx;
    public static ProtocolType SpxII;
    public static ProtocolType Unknown;
}
internal class System.Net.Sockets.SafeSocketHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private List`1<Thread> blocking_threads;
    private Dictionary`2<Thread, StackTrace> threads_stacktraces;
    private bool in_cleanup;
    private static int SOCKET_CLOSED;
    private static int ABORT_RETRIES;
    private static bool THROW_ON_ABORT_RETRIES;
    public SafeSocketHandle(IntPtr preexistingHandle, bool ownsHandle);
    private static SafeSocketHandle();
    protected virtual bool ReleaseHandle();
    public void RegisterForBlockingSyscall();
    public void UnRegisterForBlockingSyscall();
}
public enum System.Net.Sockets.SelectMode : Enum {
    public int value__;
    public static SelectMode SelectRead;
    public static SelectMode SelectWrite;
    public static SelectMode SelectError;
}
public class System.Net.Sockets.SendPacketsElement : object {
    internal string m_FilePath;
    internal Byte[] m_Buffer;
    internal int m_Offset;
    internal int m_Count;
    private bool m_endOfPacket;
    public string FilePath { get; }
    public Byte[] Buffer { get; }
    public int Count { get; }
    public int Offset { get; }
    public bool EndOfPacket { get; }
    public SendPacketsElement(string filepath);
    public SendPacketsElement(string filepath, int offset, int count);
    public SendPacketsElement(string filepath, int offset, int count, bool endOfPacket);
    public SendPacketsElement(Byte[] buffer);
    public SendPacketsElement(Byte[] buffer, int offset, int count);
    public SendPacketsElement(Byte[] buffer, int offset, int count, bool endOfPacket);
    private void Initialize(string filePath, Byte[] buffer, int offset, int count, bool endOfPacket);
    public string get_FilePath();
    public Byte[] get_Buffer();
    public int get_Count();
    public int get_Offset();
    public bool get_EndOfPacket();
}
internal class System.Net.Sockets.SingleSocketMultipleConnectAsync : MultipleConnectAsync {
    private Socket _socket;
    private bool _userSocket;
    public SingleSocketMultipleConnectAsync(Socket socket, bool userSocket);
    protected virtual IPAddress GetNextAddress(Socket& attemptSocket);
    protected virtual void OnFail(bool abortive);
    protected virtual void OnSucceed();
}
public class System.Net.Sockets.Socket : object {
    private static EventHandler`1<SocketAsyncEventArgs> AcceptCompletedHandler;
    private static EventHandler`1<SocketAsyncEventArgs> ReceiveCompletedHandler;
    private static EventHandler`1<SocketAsyncEventArgs> SendCompletedHandler;
    private static TaskSocketAsyncEventArgs`1<Socket> s_rentedSocketSentinel;
    private static Int32TaskSocketAsyncEventArgs s_rentedInt32Sentinel;
    private static Task`1<int> s_zeroTask;
    private CachedEventArgs _cachedTaskEventArgs;
    private static object s_InternalSyncObject;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_SupportsIPv4;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_SupportsIPv6;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_OSSupportsIPv6;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_Initialized;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_LoggingEnabled;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_PerfCountersEnabled;
    internal static int DefaultCloseTimeout;
    private static int SOCKET_CLOSED_CODE;
    private static string TIMEOUT_EXCEPTION_MSG;
    private bool is_closed;
    private bool is_listening;
    private bool useOverlappedIO;
    private int linger_timeout;
    private AddressFamily addressFamily;
    private SocketType socketType;
    private ProtocolType protocolType;
    internal SafeSocketHandle m_Handle;
    internal EndPoint seed_endpoint;
    internal SemaphoreSlim ReadSem;
    internal SemaphoreSlim WriteSem;
    internal bool is_blocking;
    internal bool is_bound;
    internal bool is_connected;
    private int m_IntCleanedUp;
    internal bool connect_in_progress;
    internal int ID;
    private static AsyncCallback AcceptAsyncCallback;
    private static IOAsyncCallback BeginAcceptCallback;
    private static IOAsyncCallback BeginAcceptReceiveCallback;
    private static AsyncCallback ConnectAsyncCallback;
    private static IOAsyncCallback BeginConnectCallback;
    private static AsyncCallback DisconnectAsyncCallback;
    private static IOAsyncCallback BeginDisconnectCallback;
    private static AsyncCallback ReceiveAsyncCallback;
    private static IOAsyncCallback BeginReceiveCallback;
    private static IOAsyncCallback BeginReceiveGenericCallback;
    private static AsyncCallback ReceiveFromAsyncCallback;
    private static IOAsyncCallback BeginReceiveFromCallback;
    private static AsyncCallback SendAsyncCallback;
    private static IOAsyncCallback BeginSendGenericCallback;
    private static AsyncCallback SendToAsyncCallback;
    [ObsoleteAttribute("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static bool SupportsIPv4 { get; }
    public static bool OSSupportsIPv4 { get; }
    [ObsoleteAttribute("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static bool SupportsIPv6 { get; }
    internal static bool LegacySupportsIPv6 { get; }
    public static bool OSSupportsIPv6 { get; }
    public IntPtr Handle { get; }
    public bool UseOnlyOverlappedIO { get; public set; }
    public AddressFamily AddressFamily { get; }
    public SocketType SocketType { get; }
    public ProtocolType ProtocolType { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendTimeout { get; public set; }
    public LingerOption LingerState { get; public set; }
    public short Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    public bool DualMode { get; public set; }
    private bool IsDualMode { get; }
    private static object InternalSyncObject { get; }
    internal bool CleanedUp { get; }
    public int Available { get; }
    public bool EnableBroadcast { get; public set; }
    public bool IsBound { get; }
    public bool MulticastLoopback { get; public set; }
    public EndPoint LocalEndPoint { get; }
    public bool Blocking { get; public set; }
    public bool Connected { get; internal set; }
    public bool NoDelay { get; public set; }
    public EndPoint RemoteEndPoint { get; }
    internal SafeHandle SafeHandle { get; }
    internal static int FamilyHint { get; }
    public Socket(SocketType socketType, ProtocolType protocolType);
    public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    public Socket(SocketInformation socketInformation);
    internal Socket(AddressFamily family, SocketType type, ProtocolType proto, SafeSocketHandle safe_handle);
    private static Socket();
    internal Task`1<Socket> AcceptAsync(Socket acceptSocket);
    private Task`1<Socket> AcceptAsyncApm(Socket acceptSocket);
    internal Task ConnectAsync(EndPoint remoteEP);
    internal Task ConnectAsync(IPAddress address, int port);
    internal Task ConnectAsync(IPAddress[] addresses, int port);
    internal Task ConnectAsync(string host, int port);
    internal Task`1<int> ReceiveAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, bool fromNetworkStream);
    internal ValueTask`1<int> ReceiveAsync(Memory`1<byte> buffer, SocketFlags socketFlags, bool fromNetworkStream, CancellationToken cancellationToken);
    private Task`1<int> ReceiveAsyncApm(Memory`1<byte> buffer, SocketFlags socketFlags);
    internal Task`1<int> ReceiveAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    private Task`1<int> ReceiveAsyncApm(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    internal Task`1<SocketReceiveFromResult> ReceiveFromAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    internal Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    internal Task`1<int> SendAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    internal ValueTask`1<int> SendAsync(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    internal ValueTask SendAsyncForNetworkStream(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    private Task`1<int> SendAsyncApm(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags);
    internal Task`1<int> SendAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    private Task`1<int> SendAsyncApm(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    internal Task`1<int> SendToAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP);
    private static void ValidateBuffer(ArraySegment`1<byte> buffer);
    private static void ValidateBuffersList(IList`1<ArraySegment`1<byte>> buffers);
    private static void ConfigureBufferList(Int32TaskSocketAsyncEventArgs saea, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    private Task`1<int> GetTaskForSendReceive(bool pending, Int32TaskSocketAsyncEventArgs saea, bool fromNetworkStream, bool isReceive);
    private static void CompleteAccept(Socket s, TaskSocketAsyncEventArgs`1<Socket> saea);
    private static void CompleteSendReceive(Socket s, Int32TaskSocketAsyncEventArgs saea, bool isReceive);
    private static Exception GetException(SocketError error, bool wrapExceptionsInIOExceptions);
    private Int32TaskSocketAsyncEventArgs RentSocketAsyncEventArgs(bool isReceive);
    private void ReturnSocketAsyncEventArgs(Int32TaskSocketAsyncEventArgs saea, bool isReceive);
    private void ReturnSocketAsyncEventArgs(TaskSocketAsyncEventArgs`1<Socket> saea);
    private void DisposeCachedTaskSocketAsyncEventArgs();
    public static bool get_SupportsIPv4();
    public static bool get_OSSupportsIPv4();
    public static bool get_SupportsIPv6();
    internal static bool get_LegacySupportsIPv6();
    public static bool get_OSSupportsIPv6();
    public IntPtr get_Handle();
    public bool get_UseOnlyOverlappedIO();
    public void set_UseOnlyOverlappedIO(bool value);
    public AddressFamily get_AddressFamily();
    public SocketType get_SocketType();
    public ProtocolType get_ProtocolType();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public short get_Ttl();
    public void set_Ttl(short value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_DualMode();
    public void set_DualMode(bool value);
    private bool get_IsDualMode();
    internal bool CanTryAddressFamily(AddressFamily family);
    public void Connect(IPAddress[] addresses, int port);
    public int Send(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Send(Byte[] buffer, SocketFlags socketFlags);
    public int Send(Byte[] buffer);
    public int Send(IList`1<ArraySegment`1<byte>> buffers);
    public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public void SendFile(string fileName);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int SendTo(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, EndPoint remoteEP);
    public int Receive(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Receive(Byte[] buffer, SocketFlags socketFlags);
    public int Receive(Byte[] buffer);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public int ReceiveFrom(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, EndPoint& remoteEP);
    public int IOControl(IOControlCode ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    public void SetIPProtectionLevel(IPProtectionLevel level);
    public IAsyncResult BeginSendFile(string fileName, AsyncCallback callback, object state);
    public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    public int EndSend(IAsyncResult asyncResult);
    public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    public int EndReceive(IAsyncResult asyncResult);
    public IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, object state);
    public Socket EndAccept(Byte[]& buffer, IAsyncResult asyncResult);
    private static object get_InternalSyncObject();
    internal bool get_CleanedUp();
    internal static void InitializeSockets();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e);
    internal void InternalShutdown(SocketShutdown how);
    internal IAsyncResult UnsafeBeginConnect(EndPoint remoteEP, AsyncCallback callback, object state);
    internal IAsyncResult UnsafeBeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal IAsyncResult UnsafeBeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal IAsyncResult BeginMultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal IAsyncResult UnsafeBeginMultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal int EndMultipleSend(IAsyncResult asyncResult);
    internal void MultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags);
    internal void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue, bool silent);
    private void SocketDefaults();
    private static IntPtr Socket_icall(AddressFamily family, SocketType type, ProtocolType proto, Int32& error);
    public int get_Available();
    private static int Available_internal(SafeSocketHandle safeHandle, Int32& error);
    private static int Available_icall(IntPtr socket, Int32& error);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_IsBound();
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public EndPoint get_LocalEndPoint();
    private static SocketAddress LocalEndPoint_internal(SafeSocketHandle safeHandle, int family, Int32& error);
    private static SocketAddress LocalEndPoint_icall(IntPtr socket, int family, Int32& error);
    public bool get_Blocking();
    public void set_Blocking(bool value);
    private static void Blocking_internal(SafeSocketHandle safeHandle, bool block, Int32& error);
    internal static void Blocking_icall(IntPtr socket, bool block, Int32& error);
    public bool get_Connected();
    internal void set_Connected(bool value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    public EndPoint get_RemoteEndPoint();
    private static SocketAddress RemoteEndPoint_internal(SafeSocketHandle safeHandle, int family, Int32& error);
    private static SocketAddress RemoteEndPoint_icall(IntPtr socket, int family, Int32& error);
    internal SafeHandle get_SafeHandle();
    public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds);
    private static void AddSockets(List`1<Socket> sockets, IList list, string name);
    private static void Select_icall(Socket[]& sockets, int microSeconds, Int32& error);
    public bool Poll(int microSeconds, SelectMode mode);
    private static bool Poll_internal(SafeSocketHandle safeHandle, SelectMode mode, int timeout, Int32& error);
    private static bool Poll_icall(IntPtr socket, SelectMode mode, int timeout, Int32& error);
    public Socket Accept();
    internal void Accept(Socket acceptSocket);
    public bool AcceptAsync(SocketAsyncEventArgs e);
    public IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);
    public Socket EndAccept(IAsyncResult asyncResult);
    public Socket EndAccept(Byte[]& buffer, Int32& bytesTransferred, IAsyncResult asyncResult);
    private static SafeSocketHandle Accept_internal(SafeSocketHandle safeHandle, Int32& error, bool blocking);
    private static IntPtr Accept_icall(IntPtr sock, Int32& error, bool blocking);
    public void Bind(EndPoint localEP);
    private static void Bind_internal(SafeSocketHandle safeHandle, SocketAddress sa, Int32& error);
    private static void Bind_icall(IntPtr sock, SocketAddress sa, Int32& error);
    public void Listen(int backlog);
    private static void Listen_internal(SafeSocketHandle safeHandle, int backlog, Int32& error);
    private static void Listen_icall(IntPtr sock, int backlog, Int32& error);
    public void Connect(IPAddress address, int port);
    public void Connect(string host, int port);
    public void Connect(EndPoint remoteEP);
    public bool ConnectAsync(SocketAsyncEventArgs e);
    public static void CancelConnectAsync(SocketAsyncEventArgs e);
    public IAsyncResult BeginConnect(string host, int port, AsyncCallback callback, object state);
    public IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback callback, object state);
    public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    private static bool BeginMConnect(SocketAsyncResult sockares);
    private static bool BeginSConnect(SocketAsyncResult sockares);
    public void EndConnect(IAsyncResult asyncResult);
    private static void Connect_internal(SafeSocketHandle safeHandle, SocketAddress sa, Int32& error, bool blocking);
    private static void Connect_icall(IntPtr sock, SocketAddress sa, Int32& error, bool blocking);
    private bool GetCheckedIPs(SocketAsyncEventArgs e, IPAddress[]& addresses);
    public void Disconnect(bool reuseSocket);
    public bool DisconnectAsync(SocketAsyncEventArgs e);
    public IAsyncResult BeginDisconnect(bool reuseSocket, AsyncCallback callback, object state);
    public void EndDisconnect(IAsyncResult asyncResult);
    private static void Disconnect_internal(SafeSocketHandle safeHandle, bool reuse, Int32& error);
    private static void Disconnect_icall(IntPtr sock, bool reuse, Int32& error);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    private int Receive(Memory`1<byte> buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    [CLSCompliantAttribute("False")]
public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public int Receive(Span`1<byte> buffer, SocketFlags socketFlags, SocketError& errorCode);
    public int Send(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags, SocketError& errorCode);
    public int Receive(Span`1<byte> buffer, SocketFlags socketFlags);
    public int Receive(Span`1<byte> buffer);
    public bool ReceiveAsync(SocketAsyncEventArgs e);
    public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    [CLSCompliantAttribute("False")]
public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public int EndReceive(IAsyncResult asyncResult, SocketError& errorCode);
    private static int Receive_internal(SafeSocketHandle safeHandle, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking);
    private static int Receive_array_icall(IntPtr sock, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking);
    private static int Receive_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking);
    private static int Receive_icall(IntPtr sock, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking);
    public int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    internal int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, SocketError& errorCode);
    private int ReceiveFrom(Memory`1<byte> buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, SocketError& errorCode);
    public bool ReceiveFromAsync(SocketAsyncEventArgs e);
    public IAsyncResult BeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    public int EndReceiveFrom(IAsyncResult asyncResult, EndPoint& endPoint);
    private int EndReceiveFrom_internal(SocketAsyncResult sockares, SocketAsyncEventArgs ares);
    private static int ReceiveFrom_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, SocketAddress& sockaddr, Int32& error, bool blocking);
    private static int ReceiveFrom_icall(IntPtr sock, Byte* buffer, int count, SocketFlags flags, SocketAddress& sockaddr, Int32& error, bool blocking);
    [MonoTODOAttribute("Not implemented")]
public int ReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags& socketFlags, EndPoint& remoteEP, IPPacketInformation& ipPacketInformation);
    [MonoTODOAttribute("Not implemented")]
public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e);
    [MonoTODOAttribute]
public IAsyncResult BeginReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    [MonoTODOAttribute]
public int EndReceiveMessageFrom(IAsyncResult asyncResult, SocketFlags& socketFlags, EndPoint& endPoint, IPPacketInformation& ipPacketInformation);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    [CLSCompliantAttribute("False")]
public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public int Send(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags);
    public int Send(ReadOnlySpan`1<byte> buffer);
    public bool SendAsync(SocketAsyncEventArgs e);
    public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    private static void BeginSendCallback(SocketAsyncResult sockares, int sent_so_far);
    [CLSCompliantAttribute("False")]
public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public int EndSend(IAsyncResult asyncResult, SocketError& errorCode);
    private static int Send_internal(SafeSocketHandle safeHandle, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking);
    private static int Send_array_icall(IntPtr sock, WSABUF* bufarray, int count, SocketFlags flags, Int32& error, bool blocking);
    private static int Send_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking);
    private static int Send_icall(IntPtr sock, Byte* buffer, int count, SocketFlags flags, Int32& error, bool blocking);
    public int SendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP);
    private int SendTo(Memory`1<byte> buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public bool SendToAsync(SocketAsyncEventArgs e);
    public IAsyncResult BeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP, AsyncCallback callback, object state);
    private static void BeginSendToCallback(SocketAsyncResult sockares, int sent_so_far);
    public int EndSendTo(IAsyncResult asyncResult);
    private static int SendTo_internal(SafeSocketHandle safeHandle, Byte* buffer, int count, SocketFlags flags, SocketAddress sa, Int32& error, bool blocking);
    private static int SendTo_icall(IntPtr sock, Byte* buffer, int count, SocketFlags flags, SocketAddress sa, Int32& error, bool blocking);
    public void SendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags);
    public IAsyncResult BeginSendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags, AsyncCallback callback, object state);
    public void EndSendFile(IAsyncResult asyncResult);
    private static bool SendFile_internal(SafeSocketHandle safeHandle, string filename, Byte[] pre_buffer, Byte[] post_buffer, TransmitFileOptions flags, Int32& error, bool blocking);
    private static bool SendFile_icall(IntPtr sock, string filename, Byte[] pre_buffer, Byte[] post_buffer, TransmitFileOptions flags, Int32& error, bool blocking);
    [MonoTODOAttribute("Not implemented")]
public bool SendPacketsAsync(SocketAsyncEventArgs e);
    private static bool Duplicate_icall(IntPtr handle, int targetProcessId, IntPtr& duplicateHandle, MonoIOError& error);
    [MonoLimitationAttribute("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")]
public SocketInformation DuplicateAndClose(int targetProcessId);
    public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public Byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength);
    public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName);
    private static void GetSocketOption_arr_internal(SafeSocketHandle safeHandle, SocketOptionLevel level, SocketOptionName name, Byte[]& byte_val, Int32& error);
    private static void GetSocketOption_arr_icall(IntPtr socket, SocketOptionLevel level, SocketOptionName name, Byte[]& byte_val, Int32& error);
    private static void GetSocketOption_obj_internal(SafeSocketHandle safeHandle, SocketOptionLevel level, SocketOptionName name, Object& obj_val, Int32& error);
    private static void GetSocketOption_obj_icall(IntPtr socket, SocketOptionLevel level, SocketOptionName name, Object& obj_val, Int32& error);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue);
    private static void SetSocketOption_internal(SafeSocketHandle safeHandle, SocketOptionLevel level, SocketOptionName name, object obj_val, Byte[] byte_val, int int_val, Int32& error);
    private static void SetSocketOption_icall(IntPtr socket, SocketOptionLevel level, SocketOptionName name, object obj_val, Byte[] byte_val, int int_val, Int32& error);
    public int IOControl(int ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    private static int IOControl_internal(SafeSocketHandle safeHandle, int ioctl_code, Byte[] input, Byte[] output, Int32& error);
    private static int IOControl_icall(IntPtr sock, int ioctl_code, Byte[] input, Byte[] output, Int32& error);
    public void Close();
    public void Close(int timeout);
    internal static void Close_icall(IntPtr socket, Int32& error);
    public void Shutdown(SocketShutdown how);
    private static void Shutdown_internal(SafeSocketHandle safeHandle, SocketShutdown how, Int32& error);
    internal static void Shutdown_icall(IntPtr socket, SocketShutdown how, Int32& error);
    protected virtual void Dispose(bool disposing);
    private void Linger(IntPtr handle);
    private void ThrowIfDisposedAndClosed(Socket socket);
    private void ThrowIfDisposedAndClosed();
    private void ThrowIfBufferNull(Byte[] buffer);
    private void ThrowIfBufferOutOfRange(Byte[] buffer, int offset, int size);
    private void ThrowIfUdp();
    private SocketAsyncResult ValidateEndIAsyncResult(IAsyncResult ares, string methodName, string argName);
    private void QueueIOSelectorJob(SemaphoreSlim sem, IntPtr handle, IOSelectorJob job);
    private void InitSocketAsyncEventArgs(SocketAsyncEventArgs e, AsyncCallback callback, object state, SocketOperation operation);
    private SocketAsyncOperation SocketOperationToSocketAsyncOperation(SocketOperation op);
    private IPEndPoint RemapIPEndPoint(IPEndPoint input);
    internal static void cancel_blocking_socket_operation(Thread thread);
    internal static bool SupportsPortReuse(ProtocolType proto);
    internal static int get_FamilyHint();
    private static bool IsProtocolSupported_internal(NetworkInterfaceComponent networkInterface);
    private static bool IsProtocolSupported(NetworkInterfaceComponent networkInterface);
    internal void ReplaceHandleIfNecessaryAfterFailedConnect();
}
public class System.Net.Sockets.SocketAsyncEventArgs : EventArgs {
    private bool disposed;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) in_progress;
    private EndPoint remote_ep;
    private Socket current_socket;
    internal SocketAsyncResult socket_async_result;
    [CompilerGeneratedAttribute]
private Exception <ConnectByNameError>k__BackingField;
    [CompilerGeneratedAttribute]
private Socket <AcceptSocket>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BytesTransferred>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisconnectReuseSocket>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketAsyncOperation <LastOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private IPPacketInformation <ReceiveMessageFromPacketInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private SendPacketsElement[] <SendPacketsElements>k__BackingField;
    [CompilerGeneratedAttribute]
private TransmitFileOptions <SendPacketsFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendPacketsSendSize>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketError <SocketError>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketFlags <SocketFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private object <UserToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<SocketAsyncEventArgs> Completed;
    private Memory`1<byte> _buffer;
    private int _offset;
    private int _count;
    private bool _bufferIsExplicitArray;
    private IList`1<ArraySegment`1<byte>> _bufferList;
    private List`1<ArraySegment`1<byte>> _bufferListInternal;
    public Exception ConnectByNameError { get; private set; }
    public Socket AcceptSocket { get; public set; }
    public int BytesTransferred { get; private set; }
    public bool DisconnectReuseSocket { get; public set; }
    public SocketAsyncOperation LastOperation { get; private set; }
    public EndPoint RemoteEndPoint { get; public set; }
    public IPPacketInformation ReceiveMessageFromPacketInfo { get; private set; }
    public SendPacketsElement[] SendPacketsElements { get; public set; }
    public TransmitFileOptions SendPacketsFlags { get; public set; }
    [MonoTODOAttribute("unused property")]
public int SendPacketsSendSize { get; public set; }
    public SocketError SocketError { get; public set; }
    public SocketFlags SocketFlags { get; public set; }
    public object UserToken { get; public set; }
    public Socket ConnectSocket { get; }
    internal Socket CurrentSocket { get; }
    public Byte[] Buffer { get; }
    public Memory`1<byte> MemoryBuffer { get; }
    public int Offset { get; }
    public int Count { get; }
    public IList`1<ArraySegment`1<byte>> BufferList { get; public set; }
    internal bool HasMultipleBuffers { get; }
    public SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol { get; public set; }
    internal SocketAsyncEventArgs(bool flowExecutionContext);
    [CompilerGeneratedAttribute]
public Exception get_ConnectByNameError();
    [CompilerGeneratedAttribute]
private void set_ConnectByNameError(Exception value);
    [CompilerGeneratedAttribute]
public Socket get_AcceptSocket();
    [CompilerGeneratedAttribute]
public void set_AcceptSocket(Socket value);
    [CompilerGeneratedAttribute]
public int get_BytesTransferred();
    [CompilerGeneratedAttribute]
private void set_BytesTransferred(int value);
    [CompilerGeneratedAttribute]
public bool get_DisconnectReuseSocket();
    [CompilerGeneratedAttribute]
public void set_DisconnectReuseSocket(bool value);
    [CompilerGeneratedAttribute]
public SocketAsyncOperation get_LastOperation();
    [CompilerGeneratedAttribute]
private void set_LastOperation(SocketAsyncOperation value);
    public EndPoint get_RemoteEndPoint();
    public void set_RemoteEndPoint(EndPoint value);
    [CompilerGeneratedAttribute]
public IPPacketInformation get_ReceiveMessageFromPacketInfo();
    [CompilerGeneratedAttribute]
private void set_ReceiveMessageFromPacketInfo(IPPacketInformation value);
    [CompilerGeneratedAttribute]
public SendPacketsElement[] get_SendPacketsElements();
    [CompilerGeneratedAttribute]
public void set_SendPacketsElements(SendPacketsElement[] value);
    [CompilerGeneratedAttribute]
public TransmitFileOptions get_SendPacketsFlags();
    [CompilerGeneratedAttribute]
public void set_SendPacketsFlags(TransmitFileOptions value);
    [CompilerGeneratedAttribute]
public int get_SendPacketsSendSize();
    [CompilerGeneratedAttribute]
public void set_SendPacketsSendSize(int value);
    [CompilerGeneratedAttribute]
public SocketError get_SocketError();
    [CompilerGeneratedAttribute]
public void set_SocketError(SocketError value);
    [CompilerGeneratedAttribute]
public SocketFlags get_SocketFlags();
    [CompilerGeneratedAttribute]
public void set_SocketFlags(SocketFlags value);
    [CompilerGeneratedAttribute]
public object get_UserToken();
    [CompilerGeneratedAttribute]
public void set_UserToken(object value);
    public Socket get_ConnectSocket();
    [CompilerGeneratedAttribute]
public void add_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    protected virtual override void Finalize();
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    internal void SetConnectByNameError(Exception error);
    internal void SetBytesTransferred(int value);
    internal Socket get_CurrentSocket();
    internal void SetCurrentSocket(Socket socket);
    internal void SetLastOperation(SocketAsyncOperation op);
    internal void Complete_internal();
    protected virtual void OnCompleted(SocketAsyncEventArgs e);
    internal void StartOperationCommon(Socket socket);
    internal void StartOperationWrapperConnect(MultipleConnectAsync args);
    internal void FinishConnectByNameSyncFailure(Exception exception, int bytesTransferred, SocketFlags flags);
    internal void FinishOperationAsyncFailure(Exception exception, int bytesTransferred, SocketFlags flags);
    internal void FinishWrapperConnectSuccess(Socket connectSocket, int bytesTransferred, SocketFlags flags);
    internal void SetResults(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal void SetResults(Exception exception, int bytesTransferred, SocketFlags flags);
    public Byte[] get_Buffer();
    public Memory`1<byte> get_MemoryBuffer();
    public int get_Offset();
    public int get_Count();
    public IList`1<ArraySegment`1<byte>> get_BufferList();
    public void set_BufferList(IList`1<ArraySegment`1<byte>> value);
    public void SetBuffer(int offset, int count);
    internal void CopyBufferFrom(SocketAsyncEventArgs source);
    public void SetBuffer(Byte[] buffer, int offset, int count);
    public void SetBuffer(Memory`1<byte> buffer);
    internal bool get_HasMultipleBuffers();
    [CompilerGeneratedAttribute]
public SocketClientAccessPolicyProtocol get_SocketClientAccessPolicyProtocol();
    [CompilerGeneratedAttribute]
public void set_SocketClientAccessPolicyProtocol(SocketClientAccessPolicyProtocol value);
}
public enum System.Net.Sockets.SocketAsyncOperation : Enum {
    public int value__;
    public static SocketAsyncOperation None;
    public static SocketAsyncOperation Accept;
    public static SocketAsyncOperation Connect;
    public static SocketAsyncOperation Disconnect;
    public static SocketAsyncOperation Receive;
    public static SocketAsyncOperation ReceiveFrom;
    public static SocketAsyncOperation ReceiveMessageFrom;
    public static SocketAsyncOperation Send;
    public static SocketAsyncOperation SendPackets;
    public static SocketAsyncOperation SendTo;
}
internal class System.Net.Sockets.SocketAsyncResult : IOAsyncResult {
    public Socket socket;
    public SocketOperation operation;
    private Exception DelayedException;
    public EndPoint EndPoint;
    public Memory`1<byte> Buffer;
    public int Offset;
    public int Size;
    public SocketFlags SockFlags;
    public Socket AcceptSocket;
    public IPAddress[] Addresses;
    public int Port;
    public IList`1<ArraySegment`1<byte>> Buffers;
    public bool ReuseSocket;
    public int CurrentAddress;
    public Socket AcceptedSocket;
    public int Total;
    internal int error;
    public int EndCalled;
    public IntPtr Handle { get; }
    public SocketError ErrorCode { get; }
    public SocketAsyncResult(Socket socket, AsyncCallback callback, object state, SocketOperation operation);
    public IntPtr get_Handle();
    public void Init(Socket socket, AsyncCallback callback, object state, SocketOperation operation);
    public SocketError get_ErrorCode();
    public void CheckIfThrowDelayedException();
    internal virtual void CompleteDisposed();
    public void Complete();
    public void Complete(bool synch);
    public void Complete(int total);
    public void Complete(Exception e, bool synch);
    public void Complete(Exception e);
    public void Complete(Socket s);
    public void Complete(Socket s, int total);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public enum System.Net.Sockets.SocketClientAccessPolicyProtocol : Enum {
    public int value__;
    public static SocketClientAccessPolicyProtocol Tcp;
    public static SocketClientAccessPolicyProtocol Http;
}
public enum System.Net.Sockets.SocketError : Enum {
    public int value__;
    public static SocketError Success;
    public static SocketError SocketError;
    public static SocketError Interrupted;
    public static SocketError AccessDenied;
    public static SocketError Fault;
    public static SocketError InvalidArgument;
    public static SocketError TooManyOpenSockets;
    public static SocketError WouldBlock;
    public static SocketError InProgress;
    public static SocketError AlreadyInProgress;
    public static SocketError NotSocket;
    public static SocketError DestinationAddressRequired;
    public static SocketError MessageSize;
    public static SocketError ProtocolType;
    public static SocketError ProtocolOption;
    public static SocketError ProtocolNotSupported;
    public static SocketError SocketNotSupported;
    public static SocketError OperationNotSupported;
    public static SocketError ProtocolFamilyNotSupported;
    public static SocketError AddressFamilyNotSupported;
    public static SocketError AddressAlreadyInUse;
    public static SocketError AddressNotAvailable;
    public static SocketError NetworkDown;
    public static SocketError NetworkUnreachable;
    public static SocketError NetworkReset;
    public static SocketError ConnectionAborted;
    public static SocketError ConnectionReset;
    public static SocketError NoBufferSpaceAvailable;
    public static SocketError IsConnected;
    public static SocketError NotConnected;
    public static SocketError Shutdown;
    public static SocketError TimedOut;
    public static SocketError ConnectionRefused;
    public static SocketError HostDown;
    public static SocketError HostUnreachable;
    public static SocketError ProcessLimit;
    public static SocketError SystemNotReady;
    public static SocketError VersionNotSupported;
    public static SocketError NotInitialized;
    public static SocketError Disconnecting;
    public static SocketError TypeNotFound;
    public static SocketError HostNotFound;
    public static SocketError TryAgain;
    public static SocketError NoRecovery;
    public static SocketError NoData;
    public static SocketError IOPending;
    public static SocketError OperationAborted;
}
public class System.Net.Sockets.SocketException : Win32Exception {
    private EndPoint m_EndPoint;
    public int ErrorCode { get; }
    public string Message { get; }
    public SocketError SocketErrorCode { get; }
    internal SocketException(int error, string message);
    internal SocketException(EndPoint endPoint);
    public SocketException(int errorCode);
    internal SocketException(int errorCode, EndPoint endPoint);
    internal SocketException(SocketError socketError);
    protected SocketException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static int WSAGetLastError_icall();
    public virtual int get_ErrorCode();
    public virtual string get_Message();
    public SocketError get_SocketErrorCode();
}
[FlagsAttribute]
public enum System.Net.Sockets.SocketFlags : Enum {
    public int value__;
    public static SocketFlags None;
    public static SocketFlags OutOfBand;
    public static SocketFlags Peek;
    public static SocketFlags DontRoute;
    public static SocketFlags MaxIOVectorLength;
    public static SocketFlags Truncated;
    public static SocketFlags ControlDataTruncated;
    public static SocketFlags Broadcast;
    public static SocketFlags Multicast;
    public static SocketFlags Partial;
}
public class System.Net.Sockets.SocketInformation : ValueType {
    private Byte[] protocolInformation;
    private SocketInformationOptions options;
    [OptionalFieldAttribute]
private EndPoint remoteEndPoint;
    public Byte[] ProtocolInformation { get; public set; }
    public SocketInformationOptions Options { get; public set; }
    internal bool IsNonBlocking { get; internal set; }
    internal bool IsConnected { get; internal set; }
    internal bool IsListening { get; internal set; }
    internal bool UseOnlyOverlappedIO { get; internal set; }
    internal EndPoint RemoteEndPoint { get; internal set; }
    public Byte[] get_ProtocolInformation();
    public void set_ProtocolInformation(Byte[] value);
    public SocketInformationOptions get_Options();
    public void set_Options(SocketInformationOptions value);
    internal bool get_IsNonBlocking();
    internal void set_IsNonBlocking(bool value);
    internal bool get_IsConnected();
    internal void set_IsConnected(bool value);
    internal bool get_IsListening();
    internal void set_IsListening(bool value);
    internal bool get_UseOnlyOverlappedIO();
    internal void set_UseOnlyOverlappedIO(bool value);
    internal EndPoint get_RemoteEndPoint();
    internal void set_RemoteEndPoint(EndPoint value);
}
[FlagsAttribute]
public enum System.Net.Sockets.SocketInformationOptions : Enum {
    public int value__;
    public static SocketInformationOptions NonBlocking;
    public static SocketInformationOptions Connected;
    public static SocketInformationOptions Listening;
    public static SocketInformationOptions UseOnlyOverlappedIO;
}
internal enum System.Net.Sockets.SocketOperation : Enum {
    public int value__;
    public static SocketOperation Accept;
    public static SocketOperation Connect;
    public static SocketOperation Receive;
    public static SocketOperation ReceiveFrom;
    public static SocketOperation Send;
    public static SocketOperation SendTo;
    public static SocketOperation RecvJustCallback;
    public static SocketOperation SendJustCallback;
    public static SocketOperation Disconnect;
    public static SocketOperation AcceptReceive;
    public static SocketOperation ReceiveGeneric;
    public static SocketOperation SendGeneric;
}
public enum System.Net.Sockets.SocketOptionLevel : Enum {
    public int value__;
    public static SocketOptionLevel Socket;
    public static SocketOptionLevel IP;
    public static SocketOptionLevel IPv6;
    public static SocketOptionLevel Tcp;
    public static SocketOptionLevel Udp;
}
public enum System.Net.Sockets.SocketOptionName : Enum {
    public int value__;
    public static SocketOptionName Debug;
    public static SocketOptionName AcceptConnection;
    public static SocketOptionName ReuseAddress;
    public static SocketOptionName KeepAlive;
    public static SocketOptionName DontRoute;
    public static SocketOptionName Broadcast;
    public static SocketOptionName UseLoopback;
    public static SocketOptionName Linger;
    public static SocketOptionName OutOfBandInline;
    public static SocketOptionName DontLinger;
    public static SocketOptionName ExclusiveAddressUse;
    public static SocketOptionName SendBuffer;
    public static SocketOptionName ReceiveBuffer;
    public static SocketOptionName SendLowWater;
    public static SocketOptionName ReceiveLowWater;
    public static SocketOptionName SendTimeout;
    public static SocketOptionName ReceiveTimeout;
    public static SocketOptionName Error;
    public static SocketOptionName Type;
    public static SocketOptionName ReuseUnicastPort;
    public static SocketOptionName MaxConnections;
    public static SocketOptionName IPOptions;
    public static SocketOptionName HeaderIncluded;
    public static SocketOptionName TypeOfService;
    public static SocketOptionName IpTimeToLive;
    public static SocketOptionName MulticastInterface;
    public static SocketOptionName MulticastTimeToLive;
    public static SocketOptionName MulticastLoopback;
    public static SocketOptionName AddMembership;
    public static SocketOptionName DropMembership;
    public static SocketOptionName DontFragment;
    public static SocketOptionName AddSourceMembership;
    public static SocketOptionName DropSourceMembership;
    public static SocketOptionName BlockSource;
    public static SocketOptionName UnblockSource;
    public static SocketOptionName PacketInformation;
    public static SocketOptionName HopLimit;
    public static SocketOptionName IPProtectionLevel;
    public static SocketOptionName IPv6Only;
    public static SocketOptionName NoDelay;
    public static SocketOptionName BsdUrgent;
    public static SocketOptionName Expedited;
    public static SocketOptionName NoChecksum;
    public static SocketOptionName ChecksumCoverage;
    public static SocketOptionName UpdateAcceptContext;
    public static SocketOptionName UpdateConnectContext;
}
public class System.Net.Sockets.SocketReceiveFromResult : ValueType {
    public int ReceivedBytes;
    public EndPoint RemoteEndPoint;
}
public class System.Net.Sockets.SocketReceiveMessageFromResult : ValueType {
    public int ReceivedBytes;
    public SocketFlags SocketFlags;
    public EndPoint RemoteEndPoint;
    public IPPacketInformation PacketInformation;
}
public enum System.Net.Sockets.SocketShutdown : Enum {
    public int value__;
    public static SocketShutdown Receive;
    public static SocketShutdown Send;
    public static SocketShutdown Both;
}
[ExtensionAttribute]
public static class System.Net.Sockets.SocketTaskExtensions : object {
    [ExtensionAttribute]
public static Task`1<Socket> AcceptAsync(Socket socket);
    [ExtensionAttribute]
public static Task`1<Socket> AcceptAsync(Socket socket, Socket acceptSocket);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, EndPoint remoteEP);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, IPAddress address, int port);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, IPAddress[] addresses, int port);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, string host, int port);
    [ExtensionAttribute]
public static Task`1<int> ReceiveAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> ReceiveAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<SocketReceiveFromResult> ReceiveFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
public static Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
public static Task`1<int> SendAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> SendAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> SendToAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP);
    [ExtensionAttribute]
public static ValueTask`1<int> SendAsync(Socket socket, ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<int> ReceiveAsync(Socket socket, Memory`1<byte> memory, SocketFlags socketFlags, CancellationToken cancellationToken);
}
public enum System.Net.Sockets.SocketType : Enum {
    public int value__;
    public static SocketType Stream;
    public static SocketType Dgram;
    public static SocketType Raw;
    public static SocketType Rdm;
    public static SocketType Seqpacket;
    public static SocketType Unknown;
}
public class System.Net.Sockets.TcpClient : object {
    private Socket m_ClientSocket;
    private bool m_Active;
    private NetworkStream m_DataStream;
    private AddressFamily m_Family;
    private bool m_CleanedUp;
    public Socket Client { get; public set; }
    protected bool Active { get; protected set; }
    public int Available { get; }
    public bool Connected { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendTimeout { get; public set; }
    public LingerOption LingerState { get; public set; }
    public bool NoDelay { get; public set; }
    public TcpClient(IPEndPoint localEP);
    public TcpClient(AddressFamily family);
    public TcpClient(string hostname, int port);
    internal TcpClient(Socket acceptedSocket);
    public Socket get_Client();
    public void set_Client(Socket value);
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public bool get_Connected();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public void Connect(string hostname, int port);
    public void Connect(IPAddress address, int port);
    public void Connect(IPEndPoint remoteEP);
    public void Connect(IPAddress[] ipAddresses, int port);
    public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    public void EndConnect(IAsyncResult asyncResult);
    public Task ConnectAsync(IPAddress address, int port);
    public Task ConnectAsync(string host, int port);
    public Task ConnectAsync(IPAddress[] addresses, int port);
    public NetworkStream GetStream();
    public void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    private void initialize();
    private int numericOption(SocketOptionLevel optionLevel, SocketOptionName optionName);
}
public class System.Net.Sockets.TcpListener : object {
    private IPEndPoint m_ServerSocketEP;
    private Socket m_ServerSocket;
    private bool m_Active;
    private bool m_ExclusiveAddressUse;
    public Socket Server { get; }
    protected bool Active { get; }
    public EndPoint LocalEndpoint { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public TcpListener(IPEndPoint localEP);
    public TcpListener(IPAddress localaddr, int port);
    [ObsoleteAttribute("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public TcpListener(int port);
    public static TcpListener Create(int port);
    public Socket get_Server();
    protected bool get_Active();
    public EndPoint get_LocalEndpoint();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public void AllowNatTraversal(bool allowed);
    public void Start();
    public void Start(int backlog);
    public void Stop();
    public bool Pending();
    public Socket AcceptSocket();
    public TcpClient AcceptTcpClient();
    public IAsyncResult BeginAcceptSocket(AsyncCallback callback, object state);
    public Socket EndAcceptSocket(IAsyncResult asyncResult);
    public IAsyncResult BeginAcceptTcpClient(AsyncCallback callback, object state);
    public TcpClient EndAcceptTcpClient(IAsyncResult asyncResult);
    public Task`1<Socket> AcceptSocketAsync();
    public Task`1<TcpClient> AcceptTcpClientAsync();
}
[FlagsAttribute]
public enum System.Net.Sockets.TransmitFileOptions : Enum {
    public int value__;
    public static TransmitFileOptions UseDefaultWorkerThread;
    public static TransmitFileOptions Disconnect;
    public static TransmitFileOptions ReuseSocket;
    public static TransmitFileOptions WriteBehind;
    public static TransmitFileOptions UseSystemThread;
    public static TransmitFileOptions UseKernelApc;
}
public class System.Net.Sockets.UdpClient : object {
    private static int MaxUDPSize;
    private Socket m_ClientSocket;
    private bool m_Active;
    private Byte[] m_Buffer;
    private AddressFamily m_Family;
    private bool m_CleanedUp;
    private bool m_IsBroadcast;
    public Socket Client { get; public set; }
    protected bool Active { get; protected set; }
    public int Available { get; }
    public short Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    public bool MulticastLoopback { get; public set; }
    public bool EnableBroadcast { get; public set; }
    public bool ExclusiveAddressUse { get; public set; }
    public UdpClient(AddressFamily family);
    public UdpClient(int port);
    public UdpClient(int port, AddressFamily family);
    public UdpClient(IPEndPoint localEP);
    public UdpClient(string hostname, int port);
    public Socket get_Client();
    public void set_Client(Socket value);
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public short get_Ttl();
    public void set_Ttl(short value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public void AllowNatTraversal(bool allowed);
    public void Close();
    private void FreeResources();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Connect(string hostname, int port);
    public void Connect(IPAddress addr, int port);
    public void Connect(IPEndPoint endPoint);
    private void CheckForBroadcast(IPAddress ipAddress);
    private static bool IsBroadcast(IPAddress address);
    public int Send(Byte[] dgram, int bytes, IPEndPoint endPoint);
    public int Send(Byte[] dgram, int bytes, string hostname, int port);
    public int Send(Byte[] dgram, int bytes);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, AsyncCallback requestCallback, object state);
    public int EndSend(IAsyncResult asyncResult);
    public Byte[] Receive(IPEndPoint& remoteEP);
    public IAsyncResult BeginReceive(AsyncCallback requestCallback, object state);
    public Byte[] EndReceive(IAsyncResult asyncResult, IPEndPoint& remoteEP);
    public void JoinMulticastGroup(IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress);
    public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive);
    public void DropMulticastGroup(IPAddress multicastAddr);
    public void DropMulticastGroup(IPAddress multicastAddr, int ifindex);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, IPEndPoint endPoint);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, string hostname, int port);
    public Task`1<UdpReceiveResult> ReceiveAsync();
    private void createClientSocket();
    [CompilerGeneratedAttribute]
private IAsyncResult <ReceiveAsync>b__65_0(AsyncCallback callback, object state);
    [CompilerGeneratedAttribute]
private UdpReceiveResult <ReceiveAsync>b__65_1(IAsyncResult ar);
}
public class System.Net.Sockets.UdpReceiveResult : ValueType {
    private Byte[] m_buffer;
    private IPEndPoint m_remoteEndPoint;
    public Byte[] Buffer { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public UdpReceiveResult(Byte[] buffer, IPEndPoint remoteEndPoint);
    public Byte[] get_Buffer();
    public IPEndPoint get_RemoteEndPoint();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UdpReceiveResult other);
    public static bool op_Equality(UdpReceiveResult left, UdpReceiveResult right);
    public static bool op_Inequality(UdpReceiveResult left, UdpReceiveResult right);
}
internal class System.Net.SplitWritesState : object {
    private static int c_SplitEncryptedBuffersSize;
    private BufferOffsetSize[] _UserBuffers;
    private int _Index;
    private int _LastBufferConsumed;
    private BufferOffsetSize[] _RealBuffers;
    internal bool IsDone { get; }
    internal SplitWritesState(BufferOffsetSize[] buffers);
    internal bool get_IsDone();
    internal BufferOffsetSize[] GetNextBuffers();
}
internal class System.Net.SSPIAuthType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SEC_WINNT_AUTH_IDENTITY_W& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int QueryContextChannelBinding(SafeDeleteContext context, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& binding);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Byte[] buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int SetContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Byte[] buffer);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public sealed virtual int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
    private static int GetSecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& safeHandle);
    public sealed virtual int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
}
internal interface System.Net.SSPIInterface {
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public abstract virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public abstract virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public abstract virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SEC_WINNT_AUTH_IDENTITY_W& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public abstract virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public abstract virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public abstract virtual int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public abstract virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle);
    public abstract virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer, Type handleType, SafeHandle& refHandle);
    public abstract virtual int SetContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer);
    public abstract virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public abstract virtual int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
    public abstract virtual int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
}
internal class System.Net.SSPISecureChannelType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SEC_WINNT_AUTH_IDENTITY_W& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int SetContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public sealed virtual int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
    public sealed virtual int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
}
internal static class System.Net.SSPIWrapper : object {
    internal static SecurityPackageInfoClass[] EnumerateSecurityPackages(SSPIInterface secModule);
    internal static SecurityPackageInfoClass GetVerifyPackageInfo(SSPIInterface secModule, string packageName);
    internal static SecurityPackageInfoClass GetVerifyPackageInfo(SSPIInterface secModule, string packageName, bool throwIfMissing);
    public static SafeFreeCredentials AcquireDefaultCredential(SSPIInterface secModule, string package, CredentialUse intent);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SEC_WINNT_AUTH_IDENTITY_W& authdata);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SCHANNEL_CRED scc);
    internal static int InitializeSecurityContext(SSPIInterface secModule, SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness datarep, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    internal static int InitializeSecurityContext(SSPIInterface secModule, SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness datarep, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    internal static int AcceptSecurityContext(SSPIInterface secModule, SafeFreeCredentials& credential, SafeDeleteContext& context, ContextFlags inFlags, Endianness datarep, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    internal static int AcceptSecurityContext(SSPIInterface secModule, SafeFreeCredentials credential, SafeDeleteContext& context, ContextFlags inFlags, Endianness datarep, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    internal static int CompleteAuthToken(SSPIInterface secModule, SafeDeleteContext& context, SecurityBuffer[] inputBuffers);
    internal static int ApplyControlToken(SSPIInterface secModule, SafeDeleteContext& context, SecurityBuffer[] inputBuffers);
    public static int QuerySecurityContextToken(SSPIInterface secModule, SafeDeleteContext context, SecurityContextTokenHandle& token);
    public static int EncryptMessage(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    public static int DecryptMessage(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    internal static int MakeSignature(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    public static int VerifySignature(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    private static int EncryptDecryptHelper(OP op, SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    public static SafeFreeContextBufferChannelBinding QueryContextChannelBinding(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    public static object QueryContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    public static object QueryContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, Int32& errorCode);
    public static string ErrorDescription(int errorCode);
}
internal class System.Net.StaticProxy : ProxyChain {
    private Uri m_Proxy;
    internal StaticProxy(Uri destination, Uri proxy);
    protected virtual bool GetNextProxy(Uri& proxy);
}
internal class System.Net.SystemNetworkCredential : NetworkCredential {
    internal static SystemNetworkCredential defaultCredential;
    private static SystemNetworkCredential();
}
internal static class System.Net.TcpValidationHelpers : object {
    public static bool ValidatePortNumber(int port);
}
[FlagsAttribute]
internal enum System.Net.ThreadKinds : Enum {
    public int value__;
    public static ThreadKinds Unknown;
    public static ThreadKinds User;
    public static ThreadKinds System;
    public static ThreadKinds Sync;
    public static ThreadKinds Async;
    public static ThreadKinds Timer;
    public static ThreadKinds CompletionPort;
    public static ThreadKinds Worker;
    public static ThreadKinds Finalization;
    public static ThreadKinds Other;
    public static ThreadKinds OwnerMask;
    public static ThreadKinds SyncMask;
    public static ThreadKinds SourceMask;
    public static ThreadKinds SafeSources;
    public static ThreadKinds ThreadPool;
}
internal static class System.Net.TimerThread : object {
    private static int c_ThreadIdleTimeoutMilliseconds;
    private static int c_CacheScanPerIterations;
    private static int c_TickCountResolution;
    private static LinkedList`1<WeakReference> s_Queues;
    private static LinkedList`1<WeakReference> s_NewQueues;
    private static int s_ThreadState;
    private static AutoResetEvent s_ThreadReadyEvent;
    private static ManualResetEvent s_ThreadShutdownEvent;
    private static WaitHandle[] s_ThreadEvents;
    private static int s_CacheScanIteration;
    private static Hashtable s_QueuesCache;
    private static TimerThread();
    internal static Queue CreateQueue(int durationMilliseconds);
    internal static Queue GetOrCreateQueue(int durationMilliseconds);
    private static void Prod();
    private static void ThreadProc();
    private static void StopTimerThread();
    private static bool IsTickBetween(int start, int end, int comparand);
    private static void OnDomainUnload(object sender, EventArgs e);
}
internal class System.Net.TlsStream : NetworkStream {
    private SslStream _sslStream;
    private string _host;
    private X509CertificateCollection _clientCertificates;
    public TlsStream(NetworkStream stream, Socket socket, string host, X509CertificateCollection clientCertificates);
    public void AuthenticateAsClient();
    public IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object state);
    public void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult result);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Close();
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingStringDictionary : StringDictionary {
    private bool _isReadOnly;
    private bool _isChanged;
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingStringDictionary(bool isReadOnly);
    internal bool get_IsChanged();
    internal void set_IsChanged(bool value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingValidationObjectDictionary : StringDictionary {
    private Dictionary`2<string, ValidateAndParseValue> _validators;
    private Dictionary`2<string, object> _internalObjects;
    [CompilerGeneratedAttribute]
private bool <IsChanged>k__BackingField;
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingValidationObjectDictionary(Dictionary`2<string, ValidateAndParseValue> validators);
    private void PersistValue(string key, string value, bool addValue);
    [CompilerGeneratedAttribute]
internal bool get_IsChanged();
    [CompilerGeneratedAttribute]
internal void set_IsChanged(bool value);
    internal object InternalGet(string key);
    internal void InternalSet(string key, object value);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
}
public abstract class System.Net.TransportContext : object {
    public abstract virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    public virtual IEnumerable`1<TokenBinding> GetTlsTokenBindings();
}
public enum System.Net.TransportType : Enum {
    public int value__;
    public static TransportType Udp;
    public static TransportType Connectionless;
    public static TransportType Tcp;
    public static TransportType ConnectionOriented;
    public static TransportType All;
}
internal enum System.Net.TriState : Enum {
    public int value__;
    public static TriState Unspecified;
    public static TriState False;
    public static TriState True;
}
internal class System.Net.UnlockConnectionDelegate : MulticastDelegate {
    public UnlockConnectionDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Net.UnsafeNclNativeMethods : object {
}
public class System.Net.UploadDataCompletedEventArgs : AsyncCompletedEventArgs {
    private Byte[] _result;
    public Byte[] Result { get; }
    internal UploadDataCompletedEventArgs(Byte[] result, Exception exception, bool cancelled, object userToken);
    public Byte[] get_Result();
}
public class System.Net.UploadDataCompletedEventHandler : MulticastDelegate {
    public UploadDataCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadDataCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadDataCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadFileCompletedEventArgs : AsyncCompletedEventArgs {
    private Byte[] _result;
    public Byte[] Result { get; }
    internal UploadFileCompletedEventArgs(Byte[] result, Exception exception, bool cancelled, object userToken);
    public Byte[] get_Result();
}
public class System.Net.UploadFileCompletedEventHandler : MulticastDelegate {
    public UploadFileCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadFileCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadFileCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadProgressChangedEventArgs : ProgressChangedEventArgs {
    [CompilerGeneratedAttribute]
private long <BytesReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalBytesToReceive>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesSent>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalBytesToSend>k__BackingField;
    public long BytesReceived { get; }
    public long TotalBytesToReceive { get; }
    public long BytesSent { get; }
    public long TotalBytesToSend { get; }
    internal UploadProgressChangedEventArgs(int progressPercentage, object userToken, long bytesSent, long totalBytesToSend, long bytesReceived, long totalBytesToReceive);
    [CompilerGeneratedAttribute]
public long get_BytesReceived();
    [CompilerGeneratedAttribute]
public long get_TotalBytesToReceive();
    [CompilerGeneratedAttribute]
public long get_BytesSent();
    [CompilerGeneratedAttribute]
public long get_TotalBytesToSend();
}
public class System.Net.UploadProgressChangedEventHandler : MulticastDelegate {
    public UploadProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadStringCompletedEventArgs : AsyncCompletedEventArgs {
    private string _result;
    public string Result { get; }
    internal UploadStringCompletedEventArgs(string result, Exception exception, bool cancelled, object userToken);
    public string get_Result();
}
public class System.Net.UploadStringCompletedEventHandler : MulticastDelegate {
    public UploadStringCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadStringCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadStringCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadValuesCompletedEventArgs : AsyncCompletedEventArgs {
    private Byte[] _result;
    public Byte[] Result { get; }
    internal UploadValuesCompletedEventArgs(Byte[] result, Exception exception, bool cancelled, object userToken);
    public Byte[] get_Result();
}
public class System.Net.UploadValuesCompletedEventHandler : MulticastDelegate {
    public UploadValuesCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadValuesCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadValuesCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Net.UriScheme : object {
    public static string File;
    public static string Ftp;
    public static string Gopher;
    public static string Http;
    public static string Https;
    public static string News;
    public static string NetPipe;
    public static string NetTcp;
    public static string Nntp;
    public static string Mailto;
    public static string Ws;
    public static string Wss;
    public static string SchemeDelimiter;
}
internal static class System.Net.ValidationHelper : object {
    public static String[] EmptyArray;
    internal static Char[] InvalidMethodChars;
    internal static Char[] InvalidParamChars;
    private static ValidationHelper();
    public static String[] MakeEmptyArrayNull(String[] stringArray);
    public static string MakeStringNull(string stringValue);
    public static string ExceptionMessage(Exception exception);
    public static string ToString(object objectValue);
    public static string HashString(object objectValue);
    public static bool IsInvalidHttpString(string stringValue);
    public static bool IsBlankString(string stringValue);
    public static bool ValidateTcpPort(int port);
    public static bool ValidateRange(int actual, int fromAllowed, int toAllowed);
    internal static void ValidateSegment(ArraySegment`1<byte> segment);
}
public class System.Net.WebClient : Component {
    private static int DefaultCopyBufferLength;
    private static int DefaultDownloadBufferLength;
    private static string DefaultUploadFileContentType;
    private static string UploadFileContentType;
    private static string UploadValuesContentType;
    private Uri _baseAddress;
    private ICredentials _credentials;
    private WebHeaderCollection _headers;
    private NameValueCollection _requestParameters;
    private WebResponse _webResponse;
    private WebRequest _webRequest;
    private Encoding _encoding;
    private string _method;
    private long _contentLength;
    private bool _initWebClientAsync;
    private bool _canceled;
    private ProgressData _progress;
    private IWebProxy _proxy;
    private bool _proxySet;
    private int _callNesting;
    private AsyncOperation _asyncOp;
    private SendOrPostCallback _downloadDataOperationCompleted;
    private SendOrPostCallback _openReadOperationCompleted;
    private SendOrPostCallback _openWriteOperationCompleted;
    private SendOrPostCallback _downloadStringOperationCompleted;
    private SendOrPostCallback _downloadFileOperationCompleted;
    private SendOrPostCallback _uploadStringOperationCompleted;
    private SendOrPostCallback _uploadDataOperationCompleted;
    private SendOrPostCallback _uploadFileOperationCompleted;
    private SendOrPostCallback _uploadValuesOperationCompleted;
    private SendOrPostCallback _reportDownloadProgressChanged;
    private SendOrPostCallback _reportUploadProgressChanged;
    [CompilerGeneratedAttribute]
private DownloadStringCompletedEventHandler DownloadStringCompleted;
    [CompilerGeneratedAttribute]
private DownloadDataCompletedEventHandler DownloadDataCompleted;
    [CompilerGeneratedAttribute]
private AsyncCompletedEventHandler DownloadFileCompleted;
    [CompilerGeneratedAttribute]
private UploadStringCompletedEventHandler UploadStringCompleted;
    [CompilerGeneratedAttribute]
private UploadDataCompletedEventHandler UploadDataCompleted;
    [CompilerGeneratedAttribute]
private UploadFileCompletedEventHandler UploadFileCompleted;
    [CompilerGeneratedAttribute]
private UploadValuesCompletedEventHandler UploadValuesCompleted;
    [CompilerGeneratedAttribute]
private OpenReadCompletedEventHandler OpenReadCompleted;
    [CompilerGeneratedAttribute]
private OpenWriteCompletedEventHandler OpenWriteCompleted;
    [CompilerGeneratedAttribute]
private DownloadProgressChangedEventHandler DownloadProgressChanged;
    [CompilerGeneratedAttribute]
private UploadProgressChangedEventHandler UploadProgressChanged;
    [CompilerGeneratedAttribute]
private RequestCachePolicy <CachePolicy>k__BackingField;
    private static Char[] s_parseContentTypeSeparators;
    private static Encoding[] s_knownEncodings;
    [CompilerGeneratedAttribute]
private bool <AllowReadStreamBuffering>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowWriteStreamBuffering>k__BackingField;
    public Encoding Encoding { get; public set; }
    public string BaseAddress { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public NameValueCollection QueryString { get; public set; }
    public WebHeaderCollection ResponseHeaders { get; }
    public IWebProxy Proxy { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public bool IsBusy { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public bool AllowReadStreamBuffering { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public bool AllowWriteStreamBuffering { get; public set; }
    private static WebClient();
    [CompilerGeneratedAttribute]
public void add_DownloadStringCompleted(DownloadStringCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DownloadStringCompleted(DownloadStringCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DownloadDataCompleted(DownloadDataCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DownloadDataCompleted(DownloadDataCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DownloadFileCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DownloadFileCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UploadStringCompleted(UploadStringCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadStringCompleted(UploadStringCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UploadDataCompleted(UploadDataCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadDataCompleted(UploadDataCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UploadFileCompleted(UploadFileCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadFileCompleted(UploadFileCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UploadValuesCompleted(UploadValuesCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadValuesCompleted(UploadValuesCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_OpenReadCompleted(OpenReadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OpenReadCompleted(OpenReadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_OpenWriteCompleted(OpenWriteCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OpenWriteCompleted(OpenWriteCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DownloadProgressChanged(DownloadProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DownloadProgressChanged(DownloadProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UploadProgressChanged(UploadProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadProgressChanged(UploadProgressChangedEventHandler value);
    protected virtual void OnDownloadStringCompleted(DownloadStringCompletedEventArgs e);
    protected virtual void OnDownloadDataCompleted(DownloadDataCompletedEventArgs e);
    protected virtual void OnDownloadFileCompleted(AsyncCompletedEventArgs e);
    protected virtual void OnDownloadProgressChanged(DownloadProgressChangedEventArgs e);
    protected virtual void OnUploadStringCompleted(UploadStringCompletedEventArgs e);
    protected virtual void OnUploadDataCompleted(UploadDataCompletedEventArgs e);
    protected virtual void OnUploadFileCompleted(UploadFileCompletedEventArgs e);
    protected virtual void OnUploadValuesCompleted(UploadValuesCompletedEventArgs e);
    protected virtual void OnUploadProgressChanged(UploadProgressChangedEventArgs e);
    protected virtual void OnOpenReadCompleted(OpenReadCompletedEventArgs e);
    protected virtual void OnOpenWriteCompleted(OpenWriteCompletedEventArgs e);
    private void StartOperation();
    private AsyncOperation StartAsyncOperation(object userToken);
    private void EndOperation();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string get_BaseAddress();
    public void set_BaseAddress(string value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    public NameValueCollection get_QueryString();
    public void set_QueryString(NameValueCollection value);
    public WebHeaderCollection get_ResponseHeaders();
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public RequestCachePolicy get_CachePolicy();
    [CompilerGeneratedAttribute]
public void set_CachePolicy(RequestCachePolicy value);
    public bool get_IsBusy();
    protected virtual WebRequest GetWebRequest(Uri address);
    protected virtual WebResponse GetWebResponse(WebRequest request);
    protected virtual WebResponse GetWebResponse(WebRequest request, IAsyncResult result);
    [AsyncStateMachineAttribute("System.Net.WebClient/<GetWebResponseTaskAsync>d__112")]
private Task`1<WebResponse> GetWebResponseTaskAsync(WebRequest request);
    public Byte[] DownloadData(string address);
    public Byte[] DownloadData(Uri address);
    private Byte[] DownloadDataInternal(Uri address, WebRequest& request);
    public void DownloadFile(string address, string fileName);
    public void DownloadFile(Uri address, string fileName);
    public Stream OpenRead(string address);
    public Stream OpenRead(Uri address);
    public Stream OpenWrite(string address);
    public Stream OpenWrite(Uri address);
    public Stream OpenWrite(string address, string method);
    public Stream OpenWrite(Uri address, string method);
    public Byte[] UploadData(string address, Byte[] data);
    public Byte[] UploadData(Uri address, Byte[] data);
    public Byte[] UploadData(string address, string method, Byte[] data);
    public Byte[] UploadData(Uri address, string method, Byte[] data);
    private Byte[] UploadDataInternal(Uri address, string method, Byte[] data, WebRequest& request);
    private void OpenFileInternal(bool needsHeaderAndBoundary, string fileName, FileStream& fs, Byte[]& buffer, Byte[]& formHeaderBytes, Byte[]& boundaryBytes);
    public Byte[] UploadFile(string address, string fileName);
    public Byte[] UploadFile(Uri address, string fileName);
    public Byte[] UploadFile(string address, string method, string fileName);
    public Byte[] UploadFile(Uri address, string method, string fileName);
    private Byte[] GetValuesToUpload(NameValueCollection data);
    public Byte[] UploadValues(string address, NameValueCollection data);
    public Byte[] UploadValues(Uri address, NameValueCollection data);
    public Byte[] UploadValues(string address, string method, NameValueCollection data);
    public Byte[] UploadValues(Uri address, string method, NameValueCollection data);
    public string UploadString(string address, string data);
    public string UploadString(Uri address, string data);
    public string UploadString(string address, string method, string data);
    public string UploadString(Uri address, string method, string data);
    public string DownloadString(string address);
    public string DownloadString(Uri address);
    private static void AbortRequest(WebRequest request);
    private void CopyHeadersTo(WebRequest request);
    private Uri GetUri(string address);
    private Uri GetUri(Uri address);
    private Byte[] DownloadBits(WebRequest request, Stream writeStream);
    [AsyncStateMachineAttribute("System.Net.WebClient/<DownloadBitsAsync>d__150")]
private void DownloadBitsAsync(WebRequest request, Stream writeStream, AsyncOperation asyncOp, Action`3<Byte[], Exception, AsyncOperation> completionDelegate);
    private Byte[] UploadBits(WebRequest request, Stream readStream, Byte[] buffer, int chunkSize, Byte[] header, Byte[] footer);
    [AsyncStateMachineAttribute("System.Net.WebClient/<UploadBitsAsync>d__152")]
private void UploadBitsAsync(WebRequest request, Stream readStream, Byte[] buffer, int chunkSize, Byte[] header, Byte[] footer, AsyncOperation asyncOp, Action`3<Byte[], Exception, AsyncOperation> completionDelegate);
    private static bool ByteArrayHasPrefix(Byte[] prefix, Byte[] byteArray);
    private string GetStringUsingEncoding(WebRequest request, Byte[] data);
    private string MapToDefaultMethod(Uri address);
    private static string UrlEncode(string str);
    private static Byte[] UrlEncodeBytesToBytesInternal(Byte[] bytes, int offset, int count, bool alwaysCreateReturnValue);
    private static char IntToHex(int n);
    private static bool IsSafe(char ch);
    private void InvokeOperationCompleted(AsyncOperation asyncOp, SendOrPostCallback callback, AsyncCompletedEventArgs eventArgs);
    public void OpenReadAsync(Uri address);
    public void OpenReadAsync(Uri address, object userToken);
    public void OpenWriteAsync(Uri address);
    public void OpenWriteAsync(Uri address, string method);
    public void OpenWriteAsync(Uri address, string method, object userToken);
    private void DownloadStringAsyncCallback(Byte[] returnBytes, Exception exception, object state);
    public void DownloadStringAsync(Uri address);
    public void DownloadStringAsync(Uri address, object userToken);
    private void DownloadDataAsyncCallback(Byte[] returnBytes, Exception exception, object state);
    public void DownloadDataAsync(Uri address);
    public void DownloadDataAsync(Uri address, object userToken);
    private void DownloadFileAsyncCallback(Byte[] returnBytes, Exception exception, object state);
    public void DownloadFileAsync(Uri address, string fileName);
    public void DownloadFileAsync(Uri address, string fileName, object userToken);
    public void UploadStringAsync(Uri address, string data);
    public void UploadStringAsync(Uri address, string method, string data);
    public void UploadStringAsync(Uri address, string method, string data, object userToken);
    public void UploadDataAsync(Uri address, Byte[] data);
    public void UploadDataAsync(Uri address, string method, Byte[] data);
    public void UploadDataAsync(Uri address, string method, Byte[] data, object userToken);
    public void UploadFileAsync(Uri address, string fileName);
    public void UploadFileAsync(Uri address, string method, string fileName);
    public void UploadFileAsync(Uri address, string method, string fileName, object userToken);
    public void UploadValuesAsync(Uri address, NameValueCollection data);
    public void UploadValuesAsync(Uri address, string method, NameValueCollection data);
    public void UploadValuesAsync(Uri address, string method, NameValueCollection data, object userToken);
    private static Exception GetExceptionToPropagate(Exception e);
    public void CancelAsync();
    public Task`1<string> DownloadStringTaskAsync(string address);
    public Task`1<string> DownloadStringTaskAsync(Uri address);
    public Task`1<Stream> OpenReadTaskAsync(string address);
    public Task`1<Stream> OpenReadTaskAsync(Uri address);
    public Task`1<Stream> OpenWriteTaskAsync(string address);
    public Task`1<Stream> OpenWriteTaskAsync(Uri address);
    public Task`1<Stream> OpenWriteTaskAsync(string address, string method);
    public Task`1<Stream> OpenWriteTaskAsync(Uri address, string method);
    public Task`1<string> UploadStringTaskAsync(string address, string data);
    public Task`1<string> UploadStringTaskAsync(Uri address, string data);
    public Task`1<string> UploadStringTaskAsync(string address, string method, string data);
    public Task`1<string> UploadStringTaskAsync(Uri address, string method, string data);
    public Task`1<Byte[]> DownloadDataTaskAsync(string address);
    public Task`1<Byte[]> DownloadDataTaskAsync(Uri address);
    public Task DownloadFileTaskAsync(string address, string fileName);
    public Task DownloadFileTaskAsync(Uri address, string fileName);
    public Task`1<Byte[]> UploadDataTaskAsync(string address, Byte[] data);
    public Task`1<Byte[]> UploadDataTaskAsync(Uri address, Byte[] data);
    public Task`1<Byte[]> UploadDataTaskAsync(string address, string method, Byte[] data);
    public Task`1<Byte[]> UploadDataTaskAsync(Uri address, string method, Byte[] data);
    public Task`1<Byte[]> UploadFileTaskAsync(string address, string fileName);
    public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string fileName);
    public Task`1<Byte[]> UploadFileTaskAsync(string address, string method, string fileName);
    public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string method, string fileName);
    public Task`1<Byte[]> UploadValuesTaskAsync(string address, NameValueCollection data);
    public Task`1<Byte[]> UploadValuesTaskAsync(string address, string method, NameValueCollection data);
    public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, NameValueCollection data);
    public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, string method, NameValueCollection data);
    private void HandleCompletion(TaskCompletionSource`1<T> tcs, TAsyncCompletedEventArgs e, Func`2<TAsyncCompletedEventArgs, T> getResult, TCompletionDelegate handler, Action`2<WebClient, TCompletionDelegate> unregisterHandler);
    private void PostProgressChanged(AsyncOperation asyncOp, ProgressData progress);
    private static void ThrowIfNull(object argument, string parameterName);
    [CompilerGeneratedAttribute]
public bool get_AllowReadStreamBuffering();
    [CompilerGeneratedAttribute]
public void set_AllowReadStreamBuffering(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowWriteStreamBuffering();
    [CompilerGeneratedAttribute]
public void set_AllowWriteStreamBuffering(bool value);
    public void add_WriteStreamClosed(WriteStreamClosedEventHandler value);
    public void remove_WriteStreamClosed(WriteStreamClosedEventHandler value);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
protected virtual void OnWriteStreamClosed(WriteStreamClosedEventArgs e);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_0(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_1(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_2(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_3(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_4(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_5(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_6(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_7(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_8(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_9(object arg);
    [CompilerGeneratedAttribute]
private void <StartAsyncOperation>b__78_10(object arg);
    [CompilerGeneratedAttribute]
private void <UploadStringAsync>b__179_0(Byte[] bytesResult, Exception error, AsyncOperation uploadAsyncOp);
}
internal class System.Net.WebCompletionSource : WebCompletionSource`1<object> {
}
internal class System.Net.WebCompletionSource`1 : object {
    private TaskCompletionSource`1<Result<T>> completion;
    private Result<T> currentResult;
    internal Result<T> CurrentResult { get; }
    internal Status<T> CurrentStatus { get; }
    internal Task Task { get; }
    public WebCompletionSource`1(bool runAsync);
    internal Result<T> get_CurrentResult();
    internal Status<T> get_CurrentStatus();
    internal Task get_Task();
    public bool TrySetCompleted(T argument);
    public bool TrySetCompleted();
    public bool TrySetCanceled();
    public bool TrySetCanceled(OperationCanceledException error);
    public bool TrySetException(Exception error);
    public void ThrowOnError();
    [AsyncStateMachineAttribute("System.Net.WebCompletionSource`1/<WaitForCompletion>d__15")]
public Task`1<T> WaitForCompletion();
}
internal class System.Net.WebConnection : object {
    private NetworkCredential ntlm_credentials;
    private bool ntlm_authenticated;
    private bool unsafe_sharing;
    private Stream networkStream;
    private Socket socket;
    private MonoTlsStream monoTlsStream;
    private WebConnectionTunnel tunnel;
    private int disposed;
    [CompilerGeneratedAttribute]
private ServicePoint <ServicePoint>k__BackingField;
    internal int ID;
    private DateTime idleSince;
    private WebOperation currentOperation;
    public ServicePoint ServicePoint { get; }
    public bool Closed { get; }
    public bool Busy { get; }
    public DateTime IdleSince { get; }
    internal bool NtlmAuthenticated { get; internal set; }
    internal NetworkCredential NtlmCredential { get; internal set; }
    internal bool UnsafeAuthenticatedConnectionSharing { get; internal set; }
    public WebConnection(ServicePoint sPoint);
    [CompilerGeneratedAttribute]
public ServicePoint get_ServicePoint();
    [ConditionalAttribute("MONO_WEB_DEBUG")]
internal static void Debug(string message, Object[] args);
    [ConditionalAttribute("MONO_WEB_DEBUG")]
internal static void Debug(string message);
    private bool CanReuse();
    private bool CheckReusable();
    [AsyncStateMachineAttribute("System.Net.WebConnection/<Connect>d__16")]
private Task Connect(WebOperation operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebConnection/<CreateStream>d__18")]
private Task`1<bool> CreateStream(WebOperation operation, bool reused, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebConnection/<InitConnection>d__19")]
internal Task`1<WebRequestStream> InitConnection(WebOperation operation, CancellationToken cancellationToken);
    internal static WebException GetException(WebExceptionStatus status, Exception error);
    internal static bool ReadLine(Byte[] buffer, Int32& start, int max, String& output);
    internal bool CanReuseConnection(WebOperation operation);
    private bool PrepareSharingNtlm(WebOperation operation);
    private void Reset();
    private void Close(bool reset);
    private void CloseSocket();
    public bool get_Closed();
    public bool get_Busy();
    public DateTime get_IdleSince();
    public bool StartOperation(WebOperation operation, bool reused);
    public bool Continue(WebOperation next);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private void ResetNtlm();
    internal bool get_NtlmAuthenticated();
    internal void set_NtlmAuthenticated(bool value);
    internal NetworkCredential get_NtlmCredential();
    internal void set_NtlmCredential(NetworkCredential value);
    internal bool get_UnsafeAuthenticatedConnectionSharing();
    internal void set_UnsafeAuthenticatedConnectionSharing(bool value);
}
internal abstract class System.Net.WebConnectionStream : Stream {
    protected bool closed;
    private bool disposed;
    private object locker;
    private int read_timeout;
    private int write_timeout;
    internal bool IgnoreIOErrors;
    [CompilerGeneratedAttribute]
private HttpWebRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private WebConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private WebOperation <Operation>k__BackingField;
    internal HttpWebRequest Request { get; }
    internal WebConnection Connection { get; }
    internal WebOperation Operation { get; }
    internal ServicePoint ServicePoint { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected WebConnectionStream(WebConnection cnc, WebOperation operation);
    [CompilerGeneratedAttribute]
internal HttpWebRequest get_Request();
    [CompilerGeneratedAttribute]
internal WebConnection get_Connection();
    [CompilerGeneratedAttribute]
internal WebOperation get_Operation();
    internal ServicePoint get_ServicePoint();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected Exception GetException(Exception e);
    protected abstract virtual bool TryReadFromBufferedContent(Byte[] buffer, int offset, int count, Int32& result);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback cb, object state);
    public virtual int EndRead(IAsyncResult r);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback cb, object state);
    public virtual void EndWrite(IAsyncResult r);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    internal void InternalClose();
    protected abstract virtual void Close_internal(Boolean& disposed);
    public virtual void Close();
    public virtual long Seek(long a, SeekOrigin b);
    public virtual void SetLength(long a);
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class System.Net.WebConnectionTunnel : object {
    [CompilerGeneratedAttribute]
private HttpWebRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ConnectUri>k__BackingField;
    private HttpWebRequest connectRequest;
    private NtlmAuthState ntlmAuthState;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CloseConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Challenge>k__BackingField;
    [CompilerGeneratedAttribute]
private WebHeaderCollection <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ProxyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public HttpWebRequest Request { get; }
    public Uri ConnectUri { get; }
    public bool Success { get; private set; }
    public bool CloseConnection { get; private set; }
    public int StatusCode { get; private set; }
    public string StatusDescription { get; private set; }
    public String[] Challenge { get; private set; }
    public WebHeaderCollection Headers { get; private set; }
    public Version ProxyVersion { get; private set; }
    public Byte[] Data { get; private set; }
    public WebConnectionTunnel(HttpWebRequest request, Uri connectUri);
    [CompilerGeneratedAttribute]
public HttpWebRequest get_Request();
    [CompilerGeneratedAttribute]
public Uri get_ConnectUri();
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
private void set_Success(bool value);
    [CompilerGeneratedAttribute]
public bool get_CloseConnection();
    [CompilerGeneratedAttribute]
private void set_CloseConnection(bool value);
    [CompilerGeneratedAttribute]
public int get_StatusCode();
    [CompilerGeneratedAttribute]
private void set_StatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_StatusDescription();
    [CompilerGeneratedAttribute]
private void set_StatusDescription(string value);
    [CompilerGeneratedAttribute]
public String[] get_Challenge();
    [CompilerGeneratedAttribute]
private void set_Challenge(String[] value);
    [CompilerGeneratedAttribute]
public WebHeaderCollection get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(WebHeaderCollection value);
    [CompilerGeneratedAttribute]
public Version get_ProxyVersion();
    [CompilerGeneratedAttribute]
private void set_ProxyVersion(Version value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
    [AsyncStateMachineAttribute("System.Net.WebConnectionTunnel/<Initialize>d__42")]
internal Task Initialize(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebConnectionTunnel/<ReadHeaders>d__43")]
private Task`1<ValueTuple`3<WebHeaderCollection, Byte[], int>> ReadHeaders(Stream stream, CancellationToken cancellationToken);
    private void FlushContents(Stream stream, int contentLength);
}
public class System.Net.WebException : InvalidOperationException {
    private WebExceptionStatus m_Status;
    private WebResponse m_Response;
    private WebExceptionInternalStatus m_InternalStatus;
    public WebExceptionStatus Status { get; }
    public WebResponse Response { get; }
    internal WebExceptionInternalStatus InternalStatus { get; }
    public WebException(string message);
    public WebException(string message, Exception innerException);
    public WebException(string message, WebExceptionStatus status);
    internal WebException(string message, WebExceptionStatus status, WebExceptionInternalStatus internalStatus, Exception innerException);
    public WebException(string message, Exception innerException, WebExceptionStatus status, WebResponse response);
    internal WebException(string message, string data, Exception innerException, WebExceptionStatus status, WebResponse response);
    internal WebException(string message, Exception innerException, WebExceptionStatus status, WebResponse response, WebExceptionInternalStatus internalStatus);
    internal WebException(string message, string data, Exception innerException, WebExceptionStatus status, WebResponse response, WebExceptionInternalStatus internalStatus);
    protected WebException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public WebExceptionStatus get_Status();
    public WebResponse get_Response();
    internal WebExceptionInternalStatus get_InternalStatus();
}
internal enum System.Net.WebExceptionInternalStatus : Enum {
    public int value__;
    public static WebExceptionInternalStatus RequestFatal;
    public static WebExceptionInternalStatus ServicePointFatal;
    public static WebExceptionInternalStatus Recoverable;
    public static WebExceptionInternalStatus Isolated;
}
internal static class System.Net.WebExceptionMapping : object {
    private static String[] s_Mapping;
    private static WebExceptionMapping();
    internal static string GetWebStatusString(WebExceptionStatus status);
}
public enum System.Net.WebExceptionStatus : Enum {
    public int value__;
    public static WebExceptionStatus Success;
    public static WebExceptionStatus NameResolutionFailure;
    public static WebExceptionStatus ConnectFailure;
    public static WebExceptionStatus ReceiveFailure;
    public static WebExceptionStatus SendFailure;
    public static WebExceptionStatus PipelineFailure;
    public static WebExceptionStatus RequestCanceled;
    public static WebExceptionStatus ProtocolError;
    public static WebExceptionStatus ConnectionClosed;
    public static WebExceptionStatus TrustFailure;
    public static WebExceptionStatus SecureChannelFailure;
    public static WebExceptionStatus ServerProtocolViolation;
    public static WebExceptionStatus KeepAliveFailure;
    public static WebExceptionStatus Pending;
    public static WebExceptionStatus Timeout;
    public static WebExceptionStatus ProxyNameResolutionFailure;
    public static WebExceptionStatus UnknownError;
    public static WebExceptionStatus MessageLengthLimitExceeded;
    public static WebExceptionStatus CacheEntryNotFound;
    public static WebExceptionStatus RequestProhibitedByCachePolicy;
    public static WebExceptionStatus RequestProhibitedByProxy;
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.Net.WebHeaderCollection : NameValueCollection {
    private static int ApproxAveHeaderLineSize;
    private static int ApproxHighAvgNumHeaders;
    private static HeaderInfoTable HInfo;
    private String[] m_CommonHeaders;
    private int m_NumCommonHeaders;
    private static String[] s_CommonHeaderNames;
    private static SByte[] s_CommonHeaderHints;
    private static int c_AcceptRanges;
    private static int c_ContentLength;
    private static int c_CacheControl;
    private static int c_ContentType;
    private static int c_Date;
    private static int c_Expires;
    private static int c_ETag;
    private static int c_LastModified;
    private static int c_Location;
    private static int c_ProxyAuthenticate;
    private static int c_P3P;
    private static int c_SetCookie2;
    private static int c_SetCookie;
    private static int c_Server;
    private static int c_Via;
    private static int c_WwwAuthenticate;
    private static int c_XAspNetVersion;
    private static int c_XPoweredBy;
    private NameValueCollection m_InnerCollection;
    private WebHeaderCollectionType m_Type;
    private static Char[] HttpTrimCharacters;
    private static RfcChar[] RfcCharMap;
    internal string ContentLength { get; }
    internal string CacheControl { get; }
    internal string ContentType { get; }
    internal string Date { get; }
    internal string Expires { get; }
    internal string ETag { get; }
    internal string LastModified { get; }
    internal string Location { get; }
    internal string ProxyAuthenticate { get; }
    internal string SetCookie2 { get; }
    internal string SetCookie { get; }
    internal string Server { get; }
    internal string Via { get; }
    private NameValueCollection InnerCollection { get; }
    private bool AllowHttpRequestHeader { get; }
    internal bool AllowHttpResponseHeader { get; }
    public string Item { get; public set; }
    public string Item { get; public set; }
    public int Count { get; }
    public KeysCollection Keys { get; }
    public String[] AllKeys { get; }
    internal WebHeaderCollection(WebHeaderCollectionType type);
    internal WebHeaderCollection(NameValueCollection cc);
    protected WebHeaderCollection(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static WebHeaderCollection();
    internal string get_ContentLength();
    internal string get_CacheControl();
    internal string get_ContentType();
    internal string get_Date();
    internal string get_Expires();
    internal string get_ETag();
    internal string get_LastModified();
    internal string get_Location();
    internal string get_ProxyAuthenticate();
    internal string get_SetCookie2();
    internal string get_SetCookie();
    internal string get_Server();
    internal string get_Via();
    private void NormalizeCommonHeaders();
    private NameValueCollection get_InnerCollection();
    internal static bool AllowMultiValues(string name);
    private bool get_AllowHttpRequestHeader();
    internal bool get_AllowHttpResponseHeader();
    public string get_Item(HttpRequestHeader header);
    public void set_Item(HttpRequestHeader header, string value);
    public string get_Item(HttpResponseHeader header);
    public void set_Item(HttpResponseHeader header, string value);
    public void Add(HttpRequestHeader header, string value);
    public void Add(HttpResponseHeader header, string value);
    public void Set(HttpRequestHeader header, string value);
    public void Set(HttpResponseHeader header, string value);
    internal void SetInternal(HttpResponseHeader header, string value);
    public void Remove(HttpRequestHeader header);
    public void Remove(HttpResponseHeader header);
    protected void AddWithoutValidate(string headerName, string headerValue);
    internal void SetAddVerified(string name, string value);
    internal void AddInternal(string name, string value);
    internal void ChangeInternal(string name, string value);
    internal void RemoveInternal(string name);
    internal void CheckUpdate(string name, string value);
    private void AddInternalNotCommon(string name, string value);
    internal static string CheckBadChars(string name, bool isHeaderValue);
    internal static bool IsValidToken(string token);
    internal static bool ContainsNonAsciiChars(string token);
    internal void ThrowOnRestrictedHeader(string headerName);
    public virtual void Add(string name, string value);
    public void Add(string header);
    public virtual void Set(string name, string value);
    internal void SetInternal(string name, string value);
    public virtual void Remove(string name);
    public virtual String[] GetValues(string header);
    public virtual string ToString();
    internal string ToString(bool forTrace);
    internal static string GetAsString(NameValueCollection cc, bool winInetCompat, bool forTrace);
    public Byte[] ToByteArray();
    public static bool IsRestricted(string headerName);
    public static bool IsRestricted(string headerName, bool response);
    public virtual void OnDeserialization(object sender);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal DataParseStatus ParseHeaders(Byte[] buffer, int size, Int32& unparsed, Int32& totalResponseHeadersLength, int maximumResponseHeadersLength, WebParseError& parseError);
    internal DataParseStatus ParseHeadersStrict(Byte[] buffer, int size, Int32& unparsed, Int32& totalResponseHeadersLength, int maximumResponseHeadersLength, WebParseError& parseError);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual string Get(string name);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    public virtual KeysCollection get_Keys();
    internal virtual bool InternalHasKeys();
    public virtual string Get(int index);
    public virtual String[] GetValues(int index);
    public virtual string GetKey(int index);
    public virtual String[] get_AllKeys();
    public virtual void Clear();
}
internal enum System.Net.WebHeaderCollectionType : Enum {
    public ushort value__;
    public static WebHeaderCollectionType Unknown;
    public static WebHeaderCollectionType WebRequest;
    public static WebHeaderCollectionType WebResponse;
    public static WebHeaderCollectionType HttpWebRequest;
    public static WebHeaderCollectionType HttpWebResponse;
    public static WebHeaderCollectionType HttpListenerRequest;
    public static WebHeaderCollectionType HttpListenerResponse;
    public static WebHeaderCollectionType FtpWebRequest;
    public static WebHeaderCollectionType FtpWebResponse;
    public static WebHeaderCollectionType FileWebRequest;
    public static WebHeaderCollectionType FileWebResponse;
}
internal class System.Net.WebOperation : object {
    [CompilerGeneratedAttribute]
private HttpWebRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private WebConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private ServicePoint <ServicePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private BufferOffsetSize <WriteBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNtlmChallenge>k__BackingField;
    internal int ID;
    private CancellationTokenSource cts;
    private WebCompletionSource`1<WebRequestStream> requestTask;
    private WebCompletionSource`1<WebRequestStream> requestWrittenTask;
    private WebCompletionSource`1<WebResponseStream> responseTask;
    private WebCompletionSource`1<ValueTuple`2<bool, WebOperation>> finishedTask;
    private WebRequestStream writeStream;
    private WebResponseStream responseStream;
    private ExceptionDispatchInfo disposedInfo;
    private ExceptionDispatchInfo closedInfo;
    private WebOperation priorityRequest;
    private int requestSent;
    private int finished;
    public HttpWebRequest Request { get; }
    public WebConnection Connection { get; private set; }
    public ServicePoint ServicePoint { get; private set; }
    public BufferOffsetSize WriteBuffer { get; }
    public bool IsNtlmChallenge { get; }
    internal string ME { get; }
    public bool Aborted { get; }
    public bool Closed { get; }
    public WebRequestStream WriteStream { get; }
    internal WebCompletionSource`1<ValueTuple`2<bool, WebOperation>> Finished { get; }
    public WebOperation(HttpWebRequest request, BufferOffsetSize writeBuffer, bool isNtlmChallenge, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public HttpWebRequest get_Request();
    [CompilerGeneratedAttribute]
public WebConnection get_Connection();
    [CompilerGeneratedAttribute]
private void set_Connection(WebConnection value);
    [CompilerGeneratedAttribute]
public ServicePoint get_ServicePoint();
    [CompilerGeneratedAttribute]
private void set_ServicePoint(ServicePoint value);
    [CompilerGeneratedAttribute]
public BufferOffsetSize get_WriteBuffer();
    [CompilerGeneratedAttribute]
public bool get_IsNtlmChallenge();
    internal string get_ME();
    public bool get_Aborted();
    public bool get_Closed();
    public void Abort();
    public void Close();
    private void SetCanceled();
    private void SetError(Exception error);
    private ValueTuple`2<ExceptionDispatchInfo, bool> SetDisposed(ExceptionDispatchInfo& field);
    internal ExceptionDispatchInfo CheckDisposed(CancellationToken cancellationToken);
    internal void ThrowIfDisposed();
    internal void ThrowIfDisposed(CancellationToken cancellationToken);
    internal void ThrowIfClosedOrDisposed();
    internal void ThrowIfClosedOrDisposed(CancellationToken cancellationToken);
    private ExceptionDispatchInfo CheckThrowDisposed(bool throwIt, ExceptionDispatchInfo& field);
    internal void RegisterRequest(ServicePoint servicePoint, WebConnection connection);
    public void SetPriorityRequest(WebOperation operation);
    [AsyncStateMachineAttribute("System.Net.WebOperation/<GetRequestStream>d__50")]
public Task`1<Stream> GetRequestStream();
    internal Task`1<WebRequestStream> GetRequestStreamInternal();
    public Task WaitUntilRequestWritten();
    public WebRequestStream get_WriteStream();
    public Task`1<WebResponseStream> GetResponseStream();
    internal WebCompletionSource`1<ValueTuple`2<bool, WebOperation>> get_Finished();
    [AsyncStateMachineAttribute("System.Net.WebOperation/<Run>d__58")]
internal void Run();
    internal void CompleteRequestWritten(WebRequestStream stream, Exception error);
    internal void Finish(bool ok, Exception error);
    [CompilerGeneratedAttribute]
private void <RegisterRequest>b__48_0();
}
internal class System.Net.WebParseError : ValueType {
    public WebParseErrorSection Section;
    public WebParseErrorCode Code;
}
internal enum System.Net.WebParseErrorCode : Enum {
    public int value__;
    public static WebParseErrorCode Generic;
    public static WebParseErrorCode InvalidHeaderName;
    public static WebParseErrorCode InvalidContentLength;
    public static WebParseErrorCode IncompleteHeaderLine;
    public static WebParseErrorCode CrLfError;
    public static WebParseErrorCode InvalidChunkFormat;
    public static WebParseErrorCode UnexpectedServerResponse;
}
internal enum System.Net.WebParseErrorSection : Enum {
    public int value__;
    public static WebParseErrorSection Generic;
    public static WebParseErrorSection ResponseHeader;
    public static WebParseErrorSection ResponseStatusLine;
    public static WebParseErrorSection ResponseBody;
}
public class System.Net.WebPermission : CodeAccessPermission {
    private bool m_noRestriction;
    [OptionalFieldAttribute]
private bool m_UnrestrictedConnect;
    [OptionalFieldAttribute]
private bool m_UnrestrictedAccept;
    private ArrayList m_connectList;
    private ArrayList m_acceptList;
    internal static string MatchAll;
    private static Regex modreq(System.Runtime.CompilerServices.IsVolatile) s_MatchAllRegex;
    internal static Regex MatchAllRegex { get; }
    public IEnumerator ConnectList { get; }
    public IEnumerator AcceptList { get; }
    public WebPermission(PermissionState state);
    internal WebPermission(bool unrestricted);
    internal WebPermission(NetworkAccess access);
    public WebPermission(NetworkAccess access, Regex uriRegex);
    public WebPermission(NetworkAccess access, string uriString);
    internal WebPermission(NetworkAccess access, Uri uri);
    internal static Regex get_MatchAllRegex();
    public IEnumerator get_ConnectList();
    public IEnumerator get_AcceptList();
    public void AddPermission(NetworkAccess access, string uriString);
    internal void AddPermission(NetworkAccess access, Uri uri);
    public void AddPermission(NetworkAccess access, Regex uriRegex);
    internal void AddAsPattern(NetworkAccess access, DelayedRegex uriRegexPattern);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    private static bool isSpecialSubsetCase(string regexToCheck, ArrayList permList);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
    private static bool isMatchedURI(object uriToCheck, ArrayList uriPatternList);
    private static void intersectList(ArrayList A, ArrayList B, ArrayList result);
    private static object intersectPair(object L, object R, Boolean& isUri);
}
[AttributeUsageAttribute("109")]
public class System.Net.WebPermissionAttribute : CodeAccessSecurityAttribute {
    private object m_accept;
    private object m_connect;
    public string Connect { get; public set; }
    public string Accept { get; public set; }
    public string ConnectPattern { get; public set; }
    public string AcceptPattern { get; public set; }
    public WebPermissionAttribute(SecurityAction action);
    public string get_Connect();
    public void set_Connect(string value);
    public string get_Accept();
    public void set_Accept(string value);
    public string get_ConnectPattern();
    public void set_ConnectPattern(string value);
    public string get_AcceptPattern();
    public void set_AcceptPattern(string value);
    public virtual IPermission CreatePermission();
}
public class System.Net.WebProxy : object {
    private bool _UseRegistry;
    private bool _BypassOnLocal;
    private bool m_EnableAutoproxy;
    private Uri _ProxyAddress;
    private ArrayList _BypassList;
    private ICredentials _Credentials;
    private Regex[] _RegExBypassList;
    private Hashtable _ProxyHostAddresses;
    private AutoWebProxyScriptEngine m_ScriptEngine;
    public Uri Address { get; public set; }
    unknown bool AutoDetect {internal set; }
    unknown Uri ScriptLocation {internal set; }
    public bool BypassProxyOnLocal { get; public set; }
    public String[] BypassList { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public ArrayList BypassArrayList { get; }
    internal AutoWebProxyScriptEngine ScriptEngine { get; internal set; }
    public WebProxy(Uri Address);
    public WebProxy(Uri Address, bool BypassOnLocal);
    public WebProxy(Uri Address, bool BypassOnLocal, String[] BypassList);
    public WebProxy(Uri Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials);
    public WebProxy(string Host, int Port);
    public WebProxy(string Address);
    public WebProxy(string Address, bool BypassOnLocal);
    public WebProxy(string Address, bool BypassOnLocal, String[] BypassList);
    public WebProxy(string Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials);
    protected WebProxy(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal WebProxy(bool enableAutoproxy);
    public Uri get_Address();
    public void set_Address(Uri value);
    internal void set_AutoDetect(bool value);
    internal void set_ScriptLocation(Uri value);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public String[] get_BypassList();
    public void set_BypassList(String[] value);
    public sealed virtual ICredentials get_Credentials();
    public sealed virtual void set_Credentials(ICredentials value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ArrayList get_BypassArrayList();
    internal void CheckForChanges();
    public sealed virtual Uri GetProxy(Uri destination);
    private static Uri CreateProxyUri(string address);
    private void UpdateRegExList(bool canThrow);
    private bool IsMatchInBypassList(Uri input);
    private bool IsLocal(Uri host);
    private bool IsLocalInProxyHash(Uri host);
    public sealed virtual bool IsBypassed(Uri host);
    private bool IsBypassedManual(Uri host);
    [ObsoleteAttribute("This method has been deprecated. Please use the proxy selected for you by default. http://go.microsoft.com/fwlink/?linkid=14202")]
public static WebProxy GetDefaultProxy();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal AutoWebProxyScriptEngine get_ScriptEngine();
    internal void set_ScriptEngine(AutoWebProxyScriptEngine value);
    public static IWebProxy CreateDefaultProxy();
    internal void DeleteScriptEngine();
    internal void UnsafeUpdateFromRegistry();
    internal void Update(WebProxyData webProxyData);
    private sealed virtual override ProxyChain System.Net.IAutoWebProxy.GetProxies(Uri destination);
    private bool GetProxyAuto(Uri destination, Uri& proxyUri);
    private bool IsBypassedAuto(Uri destination, Boolean& isBypassed);
    internal Uri[] GetProxiesAuto(Uri destination, Int32& syncStatus);
    internal void AbortGetProxiesAuto(Int32& syncStatus);
    internal Uri GetProxyAutoFailover(Uri destination);
    private static bool AreAllBypassed(IEnumerable`1<string> proxies, bool checkFirstOnly);
    private static Uri ProxyUri(string proxyName);
}
internal class System.Net.WebProxyData : object {
    internal bool bypassOnLocal;
    internal bool automaticallyDetectSettings;
    internal Uri proxyAddress;
    internal Hashtable proxyHostAddresses;
    internal Uri scriptLocation;
    internal ArrayList bypassList;
}
internal abstract class System.Net.WebProxyDataBuilder : object {
    private static char addressListDelimiter;
    private static char addressListSchemeValueDelimiter;
    private static char bypassListDelimiter;
    private WebProxyData m_Result;
    private static string regexReserved;
    public WebProxyData Build();
    protected abstract virtual void BuildInternal();
    protected void SetProxyAndBypassList(string addressString, string bypassListString);
    protected void SetAutoProxyUrl(string autoConfigUrl);
    protected void SetAutoDetectSettings(bool value);
    private static Uri ParseProxyUri(string proxyString);
    private static Hashtable ParseProtocolProxies(string proxyListString);
    private static FormatException CreateInvalidProxyStringException(string originalProxyString);
    private static string BypassStringEscape(string rawString);
    private static string ConvertRegexReservedChars(string rawString);
    private static ArrayList ParseBypassList(string bypassListString, Boolean& bypassOnLocal);
}
internal abstract class System.Net.WebReadStream : Stream {
    [CompilerGeneratedAttribute]
private WebOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <InnerStream>k__BackingField;
    private bool disposed;
    public WebOperation Operation { get; }
    protected Stream InnerStream { get; }
    internal string ME { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public WebReadStream(WebOperation operation, Stream innerStream);
    [CompilerGeneratedAttribute]
public WebOperation get_Operation();
    [CompilerGeneratedAttribute]
protected Stream get_InnerStream();
    internal string get_ME();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected Exception GetException(Exception e);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback cb, object state);
    public virtual int EndRead(IAsyncResult r);
    [AsyncStateMachineAttribute("System.Net.WebReadStream/<ReadAsync>d__28")]
public sealed virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    protected abstract virtual Task`1<int> ProcessReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    internal virtual Task FinishReading(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
public abstract class System.Net.WebRequest : MarshalByRefObject {
    internal static int DefaultTimeout;
    private static ArrayList modreq(System.Runtime.CompilerServices.IsVolatile) s_PrefixList;
    private static object s_InternalSyncObject;
    private static Queue s_DefaultTimerQueue;
    private AuthenticationLevel m_AuthenticationLevel;
    private TokenImpersonationLevel m_ImpersonationLevel;
    private RequestCachePolicy m_CachePolicy;
    private RequestCacheProtocol m_CacheProtocol;
    private RequestCacheBinding m_CacheBinding;
    private static DesignerWebRequestCreate webRequestCreate;
    private static IWebProxy modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultWebProxy;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultWebProxyInitialized;
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public IWebRequestCreate CreatorInstance { get; }
    private static object InternalSyncObject { get; }
    internal static Queue DefaultTimerQueue { get; }
    internal static ArrayList PrefixList { get; internal set; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public string Method { get; public set; }
    public Uri RequestUri { get; }
    public string ConnectionGroupName { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public int Timeout { get; public set; }
    internal RequestCacheProtocol CacheProtocol { get; internal set; }
    public AuthenticationLevel AuthenticationLevel { get; public set; }
    public TokenImpersonationLevel ImpersonationLevel { get; public set; }
    internal static IWebProxy InternalDefaultWebProxy { get; internal set; }
    public static IWebProxy DefaultWebProxy { get; public set; }
    protected WebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static WebRequest();
    public virtual IWebRequestCreate get_CreatorInstance();
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public static void RegisterPortableWebRequestCreator(IWebRequestCreate creator);
    private static object get_InternalSyncObject();
    internal static Queue get_DefaultTimerQueue();
    private static WebRequest Create(Uri requestUri, bool useUriBase);
    public static WebRequest Create(string requestUriString);
    public static WebRequest Create(Uri requestUri);
    public static WebRequest CreateDefault(Uri requestUri);
    public static HttpWebRequest CreateHttp(string requestUriString);
    public static HttpWebRequest CreateHttp(Uri requestUri);
    public static bool RegisterPrefix(string prefix, IWebRequestCreate creator);
    internal static ArrayList get_PrefixList();
    internal static void set_PrefixList(ArrayList value);
    private static ArrayList PopulatePrefixList();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    private void InternalSetCachePolicy(RequestCachePolicy policy);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual Uri get_RequestUri();
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual Task`1<Stream> GetRequestStreamAsync();
    public virtual Task`1<WebResponse> GetResponseAsync();
    [SecuritySafeCriticalAttribute]
private WindowsIdentity SafeCaptureIdenity();
    public virtual void Abort();
    internal RequestCacheProtocol get_CacheProtocol();
    internal void set_CacheProtocol(RequestCacheProtocol value);
    public AuthenticationLevel get_AuthenticationLevel();
    public void set_AuthenticationLevel(AuthenticationLevel value);
    public TokenImpersonationLevel get_ImpersonationLevel();
    public void set_ImpersonationLevel(TokenImpersonationLevel value);
    internal static IWebProxy get_InternalDefaultWebProxy();
    internal static void set_InternalDefaultWebProxy(IWebProxy value);
    public static IWebProxy get_DefaultWebProxy();
    public static void set_DefaultWebProxy(IWebProxy value);
    public static IWebProxy GetSystemWebProxy();
    internal static IWebProxy InternalGetSystemWebProxy();
    internal void SetupCacheProtocol(Uri uri);
    [CompilerGeneratedAttribute]
private Task`1<Stream> <GetRequestStreamAsync>b__78_0();
    [CompilerGeneratedAttribute]
private Task`1<WebResponse> <GetResponseAsync>b__79_0();
}
public static class System.Net.WebRequestMethods : object {
}
internal class System.Net.WebRequestPrefixElement : object {
    public string Prefix;
    internal IWebRequestCreate creator;
    internal Type creatorType;
    public IWebRequestCreate Creator { get; public set; }
    public WebRequestPrefixElement(string P, Type creatorType);
    public WebRequestPrefixElement(string P, IWebRequestCreate C);
    public IWebRequestCreate get_Creator();
    public void set_Creator(IWebRequestCreate value);
}
internal class System.Net.WebRequestStream : WebConnectionStream {
    private static Byte[] crlf;
    private MemoryStream writeBuffer;
    private bool requestWritten;
    private bool allowBuffering;
    private bool sendChunked;
    private WebCompletionSource pendingWrite;
    private long totalWritten;
    private Byte[] headers;
    private bool headersSent;
    private int completeRequestWritten;
    private int chunkTrailerWritten;
    internal string ME;
    [CompilerGeneratedAttribute]
private Stream <InnerStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepAlive>k__BackingField;
    internal Stream InnerStream { get; }
    public bool KeepAlive { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    internal bool SendChunked { get; internal set; }
    internal bool HasWriteBuffer { get; }
    internal int WriteBufferLength { get; }
    public WebRequestStream(WebConnection connection, WebOperation operation, Stream stream, WebConnectionTunnel tunnel);
    private static WebRequestStream();
    [CompilerGeneratedAttribute]
internal Stream get_InnerStream();
    [CompilerGeneratedAttribute]
public bool get_KeepAlive();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    internal bool get_SendChunked();
    internal void set_SendChunked(bool value);
    internal bool get_HasWriteBuffer();
    internal int get_WriteBufferLength();
    internal BufferOffsetSize GetWriteBuffer();
    [AsyncStateMachineAttribute("System.Net.WebRequestStream/<FinishWriting>d__31")]
private Task FinishWriting(CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebRequestStream/<WriteAsyncInner>d__33")]
private Task WriteAsyncInner(Byte[] buffer, int offset, int size, WebCompletionSource completion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebRequestStream/<ProcessWrite>d__34")]
private Task ProcessWrite(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    private void CheckWriteOverflow(long contentLength, long totalWritten, long size);
    [AsyncStateMachineAttribute("System.Net.WebRequestStream/<Initialize>d__36")]
internal Task Initialize(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebRequestStream/<SetHeadersAsync>d__37")]
private Task SetHeadersAsync(bool setInternalLength, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebRequestStream/<WriteRequestAsync>d__38")]
internal Task WriteRequestAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebRequestStream/<WriteChunkTrailer_inner>d__39")]
private Task WriteChunkTrailer_inner(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebRequestStream/<WriteChunkTrailer>d__40")]
private Task WriteChunkTrailer();
    internal void KillBuffer();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    protected virtual bool TryReadFromBufferedContent(Byte[] buffer, int offset, int count, Int32& result);
    protected virtual void Close_internal(Boolean& disposed);
}
public abstract class System.Net.WebResponse : MarshalByRefObject {
    private bool m_IsCacheFresh;
    private bool m_IsFromCache;
    public bool IsFromCache { get; }
    unknown bool InternalSetFromCache {internal set; }
    internal bool IsCacheFresh { get; }
    unknown bool InternalSetIsCacheFresh {internal set; }
    public bool IsMutuallyAuthenticated { get; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public Uri ResponseUri { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    protected WebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_IsFromCache();
    internal void set_InternalSetFromCache(bool value);
    internal virtual bool get_IsCacheFresh();
    internal void set_InternalSetIsCacheFresh(bool value);
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual Stream GetResponseStream();
    public virtual Uri get_ResponseUri();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
}
internal class System.Net.WebResponseStream : WebConnectionStream {
    private WebReadStream innerStream;
    private bool nextReadCalled;
    private bool bufferedEntireContent;
    private WebCompletionSource pendingRead;
    private object locker;
    private int nestedRead;
    private bool read_eof;
    [CompilerGeneratedAttribute]
private WebRequestStream <RequestStream>k__BackingField;
    [CompilerGeneratedAttribute]
private WebHeaderCollection <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StatusDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepAlive>k__BackingField;
    internal string ME;
    [CompilerGeneratedAttribute]
private bool <ChunkedRead>k__BackingField;
    public WebRequestStream RequestStream { get; }
    public WebHeaderCollection Headers { get; private set; }
    public HttpStatusCode StatusCode { get; private set; }
    public string StatusDescription { get; private set; }
    public Version Version { get; private set; }
    public bool KeepAlive { get; private set; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    private bool ChunkedRead { get; private set; }
    private bool ExpectContent { get; }
    public WebResponseStream(WebRequestStream request);
    [CompilerGeneratedAttribute]
public WebRequestStream get_RequestStream();
    [CompilerGeneratedAttribute]
public WebHeaderCollection get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(WebHeaderCollection value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
private void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public string get_StatusDescription();
    [CompilerGeneratedAttribute]
private void set_StatusDescription(string value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    [CompilerGeneratedAttribute]
public bool get_KeepAlive();
    [CompilerGeneratedAttribute]
private void set_KeepAlive(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
private bool get_ChunkedRead();
    [CompilerGeneratedAttribute]
private void set_ChunkedRead(bool value);
    [AsyncStateMachineAttribute("System.Net.WebResponseStream/<ReadAsync>d__40")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private Task`1<int> ProcessRead(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    protected virtual bool TryReadFromBufferedContent(Byte[] buffer, int offset, int count, Int32& result);
    private bool CheckAuthHeader(string headerName);
    private bool get_ExpectContent();
    private void Initialize(BufferOffsetSize buffer);
    [AsyncStateMachineAttribute("System.Net.WebResponseStream/<ReadAllAsyncInner>d__47")]
private Task`1<Byte[]> ReadAllAsyncInner(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebResponseStream/<ReadAllAsync>d__48")]
internal Task ReadAllAsync(bool resending, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Close_internal(Boolean& disposed);
    private WebException GetReadException(WebExceptionStatus status, Exception error, string where);
    [AsyncStateMachineAttribute("System.Net.WebResponseStream/<InitReadAsync>d__52")]
internal Task InitReadAsync(CancellationToken cancellationToken);
    private bool GetResponse(BufferOffsetSize buffer, Int32& pos, ReadState& state);
}
public class System.Net.WebSockets.ClientWebSocket : WebSocket {
    private ClientWebSocketOptions _options;
    private WebSocketHandle _innerWebSocket;
    private int _state;
    public ClientWebSocketOptions Options { get; }
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public string SubProtocol { get; }
    public WebSocketState State { get; }
    public ClientWebSocketOptions get_Options();
    public virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public virtual string get_CloseStatusDescription();
    public virtual string get_SubProtocol();
    public virtual WebSocketState get_State();
    public Task ConnectAsync(Uri uri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ClientWebSocket/<ConnectAsyncCore>d__16")]
private Task ConnectAsyncCore(Uri uri, CancellationToken cancellationToken);
    public virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public virtual ValueTask SendAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public virtual ValueTask`1<ValueWebSocketReceiveResult> ReceiveAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual void Abort();
    public virtual void Dispose();
    private void ThrowIfNotConnected();
}
public class System.Net.WebSockets.ClientWebSocketOptions : object {
    private bool _isReadOnly;
    private List`1<string> _requestedSubProtocols;
    private WebHeaderCollection _requestHeaders;
    private TimeSpan _keepAliveInterval;
    private bool _useDefaultCredentials;
    private ICredentials _credentials;
    private IWebProxy _proxy;
    private X509CertificateCollection _clientCertificates;
    private CookieContainer _cookies;
    private int _receiveBufferSize;
    private int _sendBufferSize;
    private Nullable`1<ArraySegment`1<byte>> _buffer;
    private RemoteCertificateValidationCallback _remoteCertificateValidationCallback;
    internal WebHeaderCollection RequestHeaders { get; }
    internal List`1<string> RequestedSubProtocols { get; }
    public bool UseDefaultCredentials { get; public set; }
    public ICredentials Credentials { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public CookieContainer Cookies { get; public set; }
    public TimeSpan KeepAliveInterval { get; public set; }
    internal int ReceiveBufferSize { get; }
    internal int SendBufferSize { get; }
    internal Nullable`1<ArraySegment`1<byte>> Buffer { get; }
    public void SetRequestHeader(string headerName, string headerValue);
    internal WebHeaderCollection get_RequestHeaders();
    internal List`1<string> get_RequestedSubProtocols();
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public CookieContainer get_Cookies();
    public void set_Cookies(CookieContainer value);
    public void AddSubProtocol(string subProtocol);
    public TimeSpan get_KeepAliveInterval();
    public void set_KeepAliveInterval(TimeSpan value);
    internal int get_ReceiveBufferSize();
    internal int get_SendBufferSize();
    internal Nullable`1<ArraySegment`1<byte>> get_Buffer();
    public void SetBuffer(int receiveBufferSize, int sendBufferSize);
    public void SetBuffer(int receiveBufferSize, int sendBufferSize, ArraySegment`1<byte> buffer);
    internal void SetToReadOnly();
    private void ThrowIfReadOnly();
}
public class System.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
    private Uri _requestUri;
    private NameValueCollection _headers;
    private CookieCollection _cookieCollection;
    private IPrincipal _user;
    private bool _isAuthenticated;
    private bool _isLocal;
    private bool _isSecureConnection;
    private string _origin;
    private IEnumerable`1<string> _secWebSocketProtocols;
    private string _secWebSocketVersion;
    private string _secWebSocketKey;
    private WebSocket _webSocket;
    public Uri RequestUri { get; }
    public NameValueCollection Headers { get; }
    public string Origin { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public string SecWebSocketKey { get; }
    public CookieCollection CookieCollection { get; }
    public IPrincipal User { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public WebSocket WebSocket { get; }
    internal HttpListenerWebSocketContext(Uri requestUri, NameValueCollection headers, CookieCollection cookieCollection, IPrincipal user, bool isAuthenticated, bool isLocal, bool isSecureConnection, string origin, IEnumerable`1<string> secWebSocketProtocols, string secWebSocketVersion, string secWebSocketKey, WebSocket webSocket);
    public virtual Uri get_RequestUri();
    public virtual NameValueCollection get_Headers();
    public virtual string get_Origin();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual string get_SecWebSocketKey();
    public virtual CookieCollection get_CookieCollection();
    public virtual IPrincipal get_User();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual WebSocket get_WebSocket();
    private static IPrincipal CopyPrincipal(IPrincipal user);
}
internal class System.Net.WebSockets.ManagedWebSocket : WebSocket {
    private static RandomNumberGenerator s_random;
    private static UTF8Encoding s_textEncoding;
    private static WebSocketState[] s_validSendStates;
    private static WebSocketState[] s_validReceiveStates;
    private static WebSocketState[] s_validCloseOutputStates;
    private static WebSocketState[] s_validCloseStates;
    private static Task`1<WebSocketReceiveResult> s_cachedCloseTask;
    internal static int MaxMessageHeaderLength;
    private static int MaxControlPayloadLength;
    private static int MaskLength;
    private Stream _stream;
    private bool _isServer;
    private string _subprotocol;
    private Timer _keepAliveTimer;
    private CancellationTokenSource _abortSource;
    private Memory`1<byte> _receiveBuffer;
    private Utf8MessageState _utf8TextState;
    private SemaphoreSlim _sendFrameAsyncLock;
    private WebSocketState _state;
    private bool _disposed;
    private bool _sentCloseFrame;
    private bool _receivedCloseFrame;
    private Nullable`1<WebSocketCloseStatus> _closeStatus;
    private string _closeStatusDescription;
    private MessageHeader _lastReceiveHeader;
    private int _receiveBufferOffset;
    private int _receiveBufferCount;
    private int _receivedMaskOffsetOffset;
    private Byte[] _sendBuffer;
    private bool _lastSendWasFragment;
    private Task _lastReceiveAsync;
    private object StateUpdateLock { get; }
    private object ReceiveAsyncLock { get; }
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public WebSocketState State { get; }
    public string SubProtocol { get; }
    private ManagedWebSocket(Stream stream, bool isServer, string subprotocol, TimeSpan keepAliveInterval);
    private static ManagedWebSocket();
    public static ManagedWebSocket CreateFromConnectedStream(Stream stream, bool isServer, string subprotocol, TimeSpan keepAliveInterval);
    private object get_StateUpdateLock();
    private object get_ReceiveAsyncLock();
    public virtual void Dispose();
    private void DisposeCore();
    public virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public virtual string get_CloseStatusDescription();
    public virtual WebSocketState get_State();
    public virtual string get_SubProtocol();
    public virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    private ValueTask SendPrivateAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual void Abort();
    private ValueTask SendFrameAsync(MessageOpcode opcode, bool endOfMessage, ReadOnlyMemory`1<byte> payloadBuffer, CancellationToken cancellationToken);
    private ValueTask SendFrameLockAcquiredNonCancelableAsync(MessageOpcode opcode, bool endOfMessage, ReadOnlyMemory`1<byte> payloadBuffer);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<WaitForWriteTaskAsync>d__55")]
private Task WaitForWriteTaskAsync(ValueTask writeTask);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<SendFrameFallbackAsync>d__56")]
private Task SendFrameFallbackAsync(MessageOpcode opcode, bool endOfMessage, ReadOnlyMemory`1<byte> payloadBuffer, CancellationToken cancellationToken);
    private int WriteFrameToSendBuffer(MessageOpcode opcode, bool endOfMessage, ReadOnlySpan`1<byte> payloadBuffer);
    private void SendKeepAliveFrameAsync();
    private static int WriteHeader(MessageOpcode opcode, Byte[] sendBuffer, ReadOnlySpan`1<byte> payload, bool endOfMessage, bool useMask);
    private static void WriteRandomMask(Byte[] buffer, int offset);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<ReceiveAsyncPrivate>d__61`2")]
private ValueTask`1<TWebSocketReceiveResult> ReceiveAsyncPrivate(Memory`1<byte> payloadBuffer, CancellationToken cancellationToken, TWebSocketReceiveResultGetter resultGetter);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<HandleReceivedCloseAsync>d__62")]
private Task HandleReceivedCloseAsync(MessageHeader header, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<WaitForServerToCloseConnectionAsync>d__63")]
private Task WaitForServerToCloseConnectionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<HandleReceivedPingPongAsync>d__64")]
private Task HandleReceivedPingPongAsync(MessageHeader header, CancellationToken cancellationToken);
    private static bool IsValidCloseStatus(WebSocketCloseStatus closeStatus);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<CloseWithReceiveErrorAndThrowAsync>d__66")]
private Task CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus closeStatus, WebSocketError error, Exception innerException);
    private bool TryParseMessageHeaderFromReceiveBuffer(MessageHeader& resultHeader);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<CloseAsyncPrivate>d__68")]
private Task CloseAsyncPrivate(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<SendCloseFrameAsync>d__69")]
private Task SendCloseFrameAsync(WebSocketCloseStatus closeStatus, string closeStatusDescription, CancellationToken cancellationToken);
    private void ConsumeFromBuffer(int count);
    [AsyncStateMachineAttribute("System.Net.WebSockets.ManagedWebSocket/<EnsureBufferContainsAsync>d__71")]
private Task EnsureBufferContainsAsync(int minimumRequiredBytes, CancellationToken cancellationToken, bool throwOnPrematureClosure);
    private void ThrowIfEOFUnexpected(bool throwOnPrematureClosure);
    private void AllocateSendBuffer(int minLength);
    private void ReleaseSendBuffer();
    private static int CombineMaskBytes(Span`1<byte> buffer, int maskOffset);
    private static int ApplyMask(Span`1<byte> toMask, Byte[] mask, int maskOffset, int maskOffsetIndex);
    private static int ApplyMask(Span`1<byte> toMask, int mask, int maskIndex);
    private void ThrowIfOperationInProgress(bool operationCompleted, string methodName);
    private void ThrowOperationInProgress(string methodName);
    private static Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken);
    private static bool TryValidateUtf8(Span`1<byte> span, bool endOfMessage, Utf8MessageState state);
    private Task ValidateAndReceiveAsync(Task receiveTask, Byte[] buffer, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
public class System.Net.WebSockets.ValueWebSocketReceiveResult : ValueType {
    private UInt32 _countAndEndOfMessage;
    private WebSocketMessageType _messageType;
    public int Count { get; }
    public bool EndOfMessage { get; }
    public WebSocketMessageType MessageType { get; }
    public ValueWebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage);
    public int get_Count();
    public bool get_EndOfMessage();
    public WebSocketMessageType get_MessageType();
    private static void ThrowCountOutOfRange();
    private static void ThrowMessageTypeOutOfRange();
}
public abstract class System.Net.WebSockets.WebSocket : object {
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public string SubProtocol { get; }
    public WebSocketState State { get; }
    public static TimeSpan DefaultKeepAliveInterval { get; }
    public abstract virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public abstract virtual string get_CloseStatusDescription();
    public abstract virtual string get_SubProtocol();
    public abstract virtual WebSocketState get_State();
    public abstract virtual void Abort();
    public abstract virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public abstract virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public abstract virtual void Dispose();
    public abstract virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public abstract virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocket/<ReceiveAsync>d__14")]
public virtual ValueTask`1<ValueWebSocketReceiveResult> ReceiveAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual ValueTask SendAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocket/<SendWithArrayPoolAsync>d__16")]
private Task SendWithArrayPoolAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public static TimeSpan get_DefaultKeepAliveInterval();
    protected static void ThrowOnInvalidState(WebSocketState state, WebSocketState[] validStates);
    protected static bool IsStateTerminal(WebSocketState state);
    public static ArraySegment`1<byte> CreateClientBuffer(int receiveBufferSize, int sendBufferSize);
    public static ArraySegment`1<byte> CreateServerBuffer(int receiveBufferSize);
    public static WebSocket CreateFromStream(Stream stream, bool isServer, string subProtocol, TimeSpan keepAliveInterval);
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.")]
[EditorBrowsableAttribute("1")]
public static bool IsApplicationTargeting45();
    [EditorBrowsableAttribute("1")]
public static void RegisterPrefixes();
    [EditorBrowsableAttribute("1")]
public static WebSocket CreateClientWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval, bool useZeroMaskingKey, ArraySegment`1<byte> internalBuffer);
}
public enum System.Net.WebSockets.WebSocketCloseStatus : Enum {
    public int value__;
    public static WebSocketCloseStatus NormalClosure;
    public static WebSocketCloseStatus EndpointUnavailable;
    public static WebSocketCloseStatus ProtocolError;
    public static WebSocketCloseStatus InvalidMessageType;
    public static WebSocketCloseStatus Empty;
    public static WebSocketCloseStatus InvalidPayloadData;
    public static WebSocketCloseStatus PolicyViolation;
    public static WebSocketCloseStatus MessageTooBig;
    public static WebSocketCloseStatus MandatoryExtension;
    public static WebSocketCloseStatus InternalServerError;
}
public abstract class System.Net.WebSockets.WebSocketContext : object {
    public Uri RequestUri { get; }
    public NameValueCollection Headers { get; }
    public string Origin { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public string SecWebSocketKey { get; }
    public CookieCollection CookieCollection { get; }
    public IPrincipal User { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public WebSocket WebSocket { get; }
    public abstract virtual Uri get_RequestUri();
    public abstract virtual NameValueCollection get_Headers();
    public abstract virtual string get_Origin();
    public abstract virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public abstract virtual string get_SecWebSocketVersion();
    public abstract virtual string get_SecWebSocketKey();
    public abstract virtual CookieCollection get_CookieCollection();
    public abstract virtual IPrincipal get_User();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsLocal();
    public abstract virtual bool get_IsSecureConnection();
    public abstract virtual WebSocket get_WebSocket();
}
public enum System.Net.WebSockets.WebSocketError : Enum {
    public int value__;
    public static WebSocketError Success;
    public static WebSocketError InvalidMessageType;
    public static WebSocketError Faulted;
    public static WebSocketError NativeError;
    public static WebSocketError NotAWebSocket;
    public static WebSocketError UnsupportedVersion;
    public static WebSocketError UnsupportedProtocol;
    public static WebSocketError HeaderError;
    public static WebSocketError ConnectionClosedPrematurely;
    public static WebSocketError InvalidState;
}
public class System.Net.WebSockets.WebSocketException : Win32Exception {
    private WebSocketError _webSocketErrorCode;
    public int ErrorCode { get; }
    public WebSocketError WebSocketErrorCode { get; }
    public WebSocketException(WebSocketError error);
    public WebSocketException(WebSocketError error, string message);
    public WebSocketException(WebSocketError error, Exception innerException);
    public WebSocketException(WebSocketError error, string message, Exception innerException);
    public WebSocketException(int nativeError);
    public WebSocketException(int nativeError, string message);
    public WebSocketException(int nativeError, Exception innerException);
    public WebSocketException(WebSocketError error, int nativeError);
    public WebSocketException(WebSocketError error, int nativeError, string message);
    public WebSocketException(WebSocketError error, int nativeError, Exception innerException);
    public WebSocketException(WebSocketError error, int nativeError, string message, Exception innerException);
    public WebSocketException(string message);
    public WebSocketException(string message, Exception innerException);
    private WebSocketException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
    public WebSocketError get_WebSocketErrorCode();
    private static string GetErrorMessage(WebSocketError error);
    private void SetErrorCodeOnError(int nativeError);
    private static bool Succeeded(int hr);
}
internal class System.Net.WebSockets.WebSocketHandle : object {
    [ThreadStaticAttribute]
private static StringBuilder t_cachedStringBuilder;
    private static Encoding s_defaultHttpEncoding;
    private static int DefaultReceiveBufferSize;
    private static string WSServerGuid;
    private CancellationTokenSource _abortSource;
    private WebSocketState _state;
    private WebSocket _webSocket;
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public WebSocketState State { get; }
    public string SubProtocol { get; }
    private static WebSocketHandle();
    public static WebSocketHandle Create();
    public static bool IsValid(WebSocketHandle handle);
    public Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public string get_CloseStatusDescription();
    public WebSocketState get_State();
    public string get_SubProtocol();
    public static void CheckPlatformSupport();
    public void Dispose();
    public void Abort();
    public Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public ValueTask SendAsync(ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public ValueTask`1<ValueWebSocketReceiveResult> ReceiveAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHandle/<ConnectAsyncCore>d__26")]
public Task ConnectAsyncCore(Uri uri, CancellationToken cancellationToken, ClientWebSocketOptions options);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHandle/<ConnectSocketAsync>d__27")]
private Task`1<Socket> ConnectSocketAsync(string host, int port, CancellationToken cancellationToken);
    private static Byte[] BuildRequestHeader(Uri uri, ClientWebSocketOptions options, string secKey);
    private static KeyValuePair`2<string, string> CreateSecKeyAndSecWebSocketAccept();
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHandle/<ParseAndValidateConnectResponseAsync>d__30")]
private Task`1<string> ParseAndValidateConnectResponseAsync(Stream stream, ClientWebSocketOptions options, string expectedSecWebSocketAccept, CancellationToken cancellationToken);
    private static void ValidateAndTrackHeader(string targetHeaderName, string targetHeaderValue, string foundHeaderName, string foundHeaderValue, Boolean& foundHeader);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHandle/<ReadResponseHeaderLineAsync>d__32")]
private static Task`1<string> ReadResponseHeaderLineAsync(Stream stream, CancellationToken cancellationToken);
}
public enum System.Net.WebSockets.WebSocketMessageType : Enum {
    public int value__;
    public static WebSocketMessageType Text;
    public static WebSocketMessageType Binary;
    public static WebSocketMessageType Close;
}
public class System.Net.WebSockets.WebSocketReceiveResult : object {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EndOfMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private WebSocketMessageType <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<WebSocketCloseStatus> <CloseStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloseStatusDescription>k__BackingField;
    public int Count { get; }
    public bool EndOfMessage { get; }
    public WebSocketMessageType MessageType { get; }
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public WebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage);
    public WebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage, Nullable`1<WebSocketCloseStatus> closeStatus, string closeStatusDescription);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public bool get_EndOfMessage();
    [CompilerGeneratedAttribute]
public WebSocketMessageType get_MessageType();
    [CompilerGeneratedAttribute]
public Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    [CompilerGeneratedAttribute]
public string get_CloseStatusDescription();
}
public enum System.Net.WebSockets.WebSocketState : Enum {
    public int value__;
    public static WebSocketState None;
    public static WebSocketState Connecting;
    public static WebSocketState Open;
    public static WebSocketState CloseSent;
    public static WebSocketState CloseReceived;
    public static WebSocketState Closed;
    public static WebSocketState Aborted;
}
internal static class System.Net.WebSockets.WebSocketValidate : object {
    internal static int MaxControlFramePayloadLength;
    private static int CloseStatusCodeAbort;
    private static int CloseStatusCodeFailedTLSHandshake;
    private static int InvalidCloseStatusCodesFrom;
    private static int InvalidCloseStatusCodesTo;
    private static string Separators;
    internal static void ThrowIfInvalidState(WebSocketState currentState, bool isDisposed, WebSocketState[] validStates);
    internal static void ValidateSubprotocol(string subProtocol);
    internal static void ValidateCloseStatus(WebSocketCloseStatus closeStatus, string statusDescription);
    internal static void ThrowPlatformNotSupportedException();
    internal static void ValidateArraySegment(ArraySegment`1<byte> arraySegment, string parameterName);
    internal static void ValidateBuffer(Byte[] buffer, int offset, int count);
}
public static class System.Net.WebUtility : object {
    private static char HIGH_SURROGATE_START;
    private static char LOW_SURROGATE_START;
    private static char LOW_SURROGATE_END;
    private static int UNICODE_PLANE00_END;
    private static int UNICODE_PLANE01_START;
    private static int UNICODE_PLANE16_END;
    private static int UnicodeReplacementChar;
    private static Char[] _htmlEntityEndingChars;
    private static UnicodeDecodingConformance modreq(System.Runtime.CompilerServices.IsVolatile) _htmlDecodeConformance;
    private static UnicodeEncodingConformance modreq(System.Runtime.CompilerServices.IsVolatile) _htmlEncodeConformance;
    private static UnicodeDecodingConformance HtmlDecodeConformance { get; }
    private static UnicodeEncodingConformance HtmlEncodeConformance { get; }
    private static WebUtility();
    public static string HtmlEncode(string value);
    public static void HtmlEncode(string value, TextWriter output);
    public static string HtmlDecode(string value);
    public static void HtmlDecode(string value, TextWriter output);
    private static int IndexOfHtmlEncodingChars(string s, int startPos);
    private static UnicodeDecodingConformance get_HtmlDecodeConformance();
    private static UnicodeEncodingConformance get_HtmlEncodeConformance();
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue);
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    public static string UrlEncode(string value);
    public static Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count);
    private static string UrlDecodeInternal(string value, Encoding encoding);
    private static Byte[] UrlDecodeInternal(Byte[] bytes, int offset, int count);
    public static string UrlDecode(string encodedValue);
    public static Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count);
    private static void ConvertSmpToUtf16(UInt32 smpChar, Char& leadingSurrogate, Char& trailingSurrogate);
    private static int GetNextUnicodeScalarValueFromUtf16Surrogate(Char*& pch, Int32& charsRemaining);
    private static int HexToInt(char h);
    private static char IntToHex(int n);
    private static bool IsUrlSafeChar(char ch);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
    private static bool StringRequiresHtmlDecoding(string s);
}
internal enum System.Net.WindowsInstallationType : Enum {
    public int value__;
    public static WindowsInstallationType Unknown;
    public static WindowsInstallationType Client;
    public static WindowsInstallationType Server;
    public static WindowsInstallationType ServerCore;
    public static WindowsInstallationType Embedded;
}
internal enum System.Net.WriteBufferState : Enum {
    public int value__;
    public static WriteBufferState Disabled;
    public static WriteBufferState Headers;
    public static WriteBufferState Buffer;
    public static WriteBufferState Playback;
}
[EditorBrowsableAttribute("1")]
public class System.Net.WriteStreamClosedEventArgs : EventArgs {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
public Exception Error { get; }
    public Exception get_Error();
}
[EditorBrowsableAttribute("1")]
public class System.Net.WriteStreamClosedEventHandler : MulticastDelegate {
    public WriteStreamClosedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WriteStreamClosedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WriteStreamClosedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.NetPipeStyleUriParser : UriParser {
}
public class System.NetTcpStyleUriParser : UriParser {
}
public class System.NewsStyleUriParser : UriParser {
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
internal enum System.ParsingError : Enum {
    public int value__;
    public static ParsingError None;
    public static ParsingError BadFormat;
    public static ParsingError BadScheme;
    public static ParsingError BadAuthority;
    public static ParsingError EmptyUriString;
    public static ParsingError LastRelativeUriOkErrIndex;
    public static ParsingError SchemeLimit;
    public static ParsingError SizeLimit;
    public static ParsingError MustRootedPath;
    public static ParsingError BadHostName;
    public static ParsingError NonEmptyHost;
    public static ParsingError BadPort;
    public static ParsingError BadAuthorityTerminator;
    public static ParsingError CannotCreateRelative;
}
internal static class System.PasteArguments : object {
    private static char Quote;
    private static char Backslash;
    internal static void AppendArgument(StringBuilder stringBuilder, string argument);
    private static bool ContainsNoWhitespaceOrQuotes(string s);
}
internal static class System.Platform : object {
    private static bool checkedOS;
    private static bool isMacOS;
    private static bool isAix;
    private static bool isIBMi;
    private static bool isFreeBSD;
    private static bool isOpenBSD;
    public static bool IsMacOS { get; }
    public static bool IsFreeBSD { get; }
    public static bool IsOpenBSD { get; }
    public static bool IsIBMi { get; }
    public static bool IsAix { get; }
    private static int uname(IntPtr buf);
    private static void CheckOS();
    public static bool get_IsMacOS();
    public static bool get_IsFreeBSD();
    public static bool get_IsOpenBSD();
    public static bool get_IsIBMi();
    public static bool get_IsAix();
}
public interface System.Reflection.ICustomTypeProvider {
    public abstract virtual Type GetCustomType();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.ADVF : Enum {
    public int value__;
    public static ADVF ADVF_NODATA;
    public static ADVF ADVF_PRIMEFIRST;
    public static ADVF ADVF_ONLYONCE;
    public static ADVF ADVFCACHE_NOHANDLER;
    public static ADVF ADVFCACHE_FORCEBUILTIN;
    public static ADVF ADVFCACHE_ONSAVE;
    public static ADVF ADVF_DATAONSTOP;
}
public enum System.Runtime.InteropServices.ComTypes.DATADIR : Enum {
    public int value__;
    public static DATADIR DATADIR_GET;
    public static DATADIR DATADIR_SET;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.DVASPECT : Enum {
    public int value__;
    public static DVASPECT DVASPECT_CONTENT;
    public static DVASPECT DVASPECT_THUMBNAIL;
    public static DVASPECT DVASPECT_ICON;
    public static DVASPECT DVASPECT_DOCPRINT;
}
public class System.Runtime.InteropServices.ComTypes.FORMATETC : ValueType {
    public short cfFormat;
    public DVASPECT dwAspect;
    public int lindex;
    public IntPtr ptd;
    public TYMED tymed;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000010F-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IAdviseSink {
    public abstract virtual void OnClose();
    public abstract virtual void OnDataChange(FORMATETC& format, STGMEDIUM& stgmedium);
    public abstract virtual void OnRename(IMoniker moniker);
    public abstract virtual void OnSave();
    public abstract virtual void OnViewChange(int aspect, int index);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000010e-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IDataObject {
    public abstract virtual int DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink adviseSink, Int32& connection);
    public abstract virtual void DUnadvise(int connection);
    public abstract virtual int EnumDAdvise(IEnumSTATDATA& enumAdvise);
    public abstract virtual IEnumFORMATETC EnumFormatEtc(DATADIR direction);
    public abstract virtual int GetCanonicalFormatEtc(FORMATETC& formatIn, FORMATETC& formatOut);
    public abstract virtual void GetData(FORMATETC& format, STGMEDIUM& medium);
    public abstract virtual void GetDataHere(FORMATETC& format, STGMEDIUM& medium);
    public abstract virtual int QueryGetData(FORMATETC& format);
    public abstract virtual void SetData(FORMATETC& formatIn, STGMEDIUM& medium, bool release);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000103-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IEnumFORMATETC {
    public abstract virtual void Clone(IEnumFORMATETC& newEnum);
    public abstract virtual int Next(int celt, FORMATETC[] rgelt, Int32[] pceltFetched);
    public abstract virtual int Reset();
    public abstract virtual int Skip(int celt);
}
[GuidAttribute("00000103-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumSTATDATA {
    public abstract virtual void Clone(IEnumSTATDATA& newEnum);
    public abstract virtual int Next(int celt, STATDATA[] rgelt, Int32[] pceltFetched);
    public abstract virtual int Reset();
    public abstract virtual int Skip(int celt);
}
public class System.Runtime.InteropServices.ComTypes.STATDATA : ValueType {
    public ADVF advf;
    public IAdviseSink advSink;
    public int connection;
    public FORMATETC formatetc;
}
public class System.Runtime.InteropServices.ComTypes.STGMEDIUM : ValueType {
    public object pUnkForRelease;
    public TYMED tymed;
    public IntPtr unionmember;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYMED : Enum {
    public int value__;
    public static TYMED TYMED_HGLOBAL;
    public static TYMED TYMED_FILE;
    public static TYMED TYMED_ISTREAM;
    public static TYMED TYMED_ISTORAGE;
    public static TYMED TYMED_GDI;
    public static TYMED TYMED_MFPICT;
    public static TYMED TYMED_ENHMF;
    public static TYMED TYMED_NULL;
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.DefaultParameterValueAttribute : Attribute {
    private object value;
    public object Value { get; }
    public DefaultParameterValueAttribute(object value);
    public object get_Value();
}
public class System.Runtime.InteropServices.HandleCollector : object {
    private static int deltaPercent;
    private string name;
    private int initialThreshold;
    private int maximumThreshold;
    private int threshold;
    private int handleCount;
    private Int32[] gc_counts;
    private int gc_gen;
    public int Count { get; }
    public int InitialThreshold { get; }
    public int MaximumThreshold { get; }
    public string Name { get; }
    public HandleCollector(string name, int initialThreshold);
    public HandleCollector(string name, int initialThreshold, int maximumThreshold);
    public int get_Count();
    public int get_InitialThreshold();
    public int get_MaximumThreshold();
    public string get_Name();
    public void Add();
    public void Remove();
}
[MonoLimitationAttribute("The runtime does nothing special apart from what it already does with marshal-by-ref objects")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.StandardOleMarshalObject : MarshalByRefObject {
}
internal static class System.Runtime.Versioning.BinaryCompatibility : object {
    public static bool TargetsAtLeast_Desktop_V4_5;
}
public class System.Runtime.Versioning.FrameworkName : object {
    private string m_identifier;
    private Version m_version;
    private string m_profile;
    private string m_fullName;
    private static char c_componentSeparator;
    private static char c_keyValueSeparator;
    private static char c_versionValuePrefix;
    private static string c_versionKey;
    private static string c_profileKey;
    public string Identifier { get; }
    public Version Version { get; }
    public string Profile { get; }
    public string FullName { get; }
    public FrameworkName(string identifier, Version version);
    public FrameworkName(string identifier, Version version, string profile);
    public FrameworkName(string frameworkName);
    public string get_Identifier();
    public Version get_Version();
    public string get_Profile();
    public string get_FullName();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FrameworkName other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(FrameworkName left, FrameworkName right);
    public static bool op_Inequality(FrameworkName left, FrameworkName right);
}
[ComVisibleAttribute("False")]
public class System.Security.AccessControl.SemaphoreAccessRule : AccessRule {
    public SemaphoreRights SemaphoreRights { get; }
    public SemaphoreAccessRule(IdentityReference identity, SemaphoreRights eventRights, AccessControlType type);
    public SemaphoreAccessRule(string identity, SemaphoreRights eventRights, AccessControlType type);
    public SemaphoreRights get_SemaphoreRights();
}
[ComVisibleAttribute("False")]
public class System.Security.AccessControl.SemaphoreAuditRule : AuditRule {
    public SemaphoreRights SemaphoreRights { get; }
    public SemaphoreAuditRule(IdentityReference identity, SemaphoreRights eventRights, AuditFlags flags);
    public SemaphoreRights get_SemaphoreRights();
}
[FlagsAttribute]
[ComVisibleAttribute("False")]
public enum System.Security.AccessControl.SemaphoreRights : Enum {
    public int value__;
    public static SemaphoreRights Modify;
    public static SemaphoreRights Delete;
    public static SemaphoreRights ReadPermissions;
    public static SemaphoreRights ChangePermissions;
    public static SemaphoreRights TakeOwnership;
    public static SemaphoreRights Synchronize;
    public static SemaphoreRights FullControl;
}
[ComVisibleAttribute("False")]
public class System.Security.AccessControl.SemaphoreSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    public SemaphoreSecurity(string name, AccessControlSections includeSections);
    internal SemaphoreSecurity(SafeHandle handle, AccessControlSections includeSections);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public void AddAccessRule(SemaphoreAccessRule rule);
    public bool RemoveAccessRule(SemaphoreAccessRule rule);
    public void RemoveAccessRuleAll(SemaphoreAccessRule rule);
    public void RemoveAccessRuleSpecific(SemaphoreAccessRule rule);
    public void ResetAccessRule(SemaphoreAccessRule rule);
    public void SetAccessRule(SemaphoreAccessRule rule);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public void AddAuditRule(SemaphoreAuditRule rule);
    public bool RemoveAuditRule(SemaphoreAuditRule rule);
    public void RemoveAuditRuleAll(SemaphoreAuditRule rule);
    public void RemoveAuditRuleSpecific(SemaphoreAuditRule rule);
    public void SetAuditRule(SemaphoreAuditRule rule);
    internal void Persist(SafeHandle handle);
}
public class System.Security.Authentication.AuthenticationException : SystemException {
    public AuthenticationException(string message);
    public AuthenticationException(string message, Exception innerException);
    protected AuthenticationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.Security.Authentication.CipherAlgorithmType : Enum {
    public int value__;
    public static CipherAlgorithmType None;
    public static CipherAlgorithmType Null;
    public static CipherAlgorithmType Aes;
    public static CipherAlgorithmType Aes128;
    public static CipherAlgorithmType Aes192;
    public static CipherAlgorithmType Aes256;
    public static CipherAlgorithmType Des;
    public static CipherAlgorithmType Rc2;
    public static CipherAlgorithmType Rc4;
    public static CipherAlgorithmType TripleDes;
}
public enum System.Security.Authentication.ExchangeAlgorithmType : Enum {
    public int value__;
    public static ExchangeAlgorithmType None;
    public static ExchangeAlgorithmType DiffieHellman;
    public static ExchangeAlgorithmType RsaKeyX;
    public static ExchangeAlgorithmType RsaSign;
}
public abstract class System.Security.Authentication.ExtendedProtection.ChannelBinding : SafeHandleZeroOrMinusOneIsInvalid {
    public int Size { get; }
    protected ChannelBinding(bool ownsHandle);
    public abstract virtual int get_Size();
}
public enum System.Security.Authentication.ExtendedProtection.ChannelBindingKind : Enum {
    public int value__;
    public static ChannelBindingKind Unknown;
    public static ChannelBindingKind Unique;
    public static ChannelBindingKind Endpoint;
}
internal static class System.Security.Authentication.ExtendedProtection.Configuration.ConfigUtil : object {
    internal static T GetCustomAttribute(MemberInfo m, bool inherit);
    internal static ConfigurationProperty BuildProperty(Type t, string name);
}
[MonoTODOAttribute]
public class System.Security.Authentication.ExtendedProtection.Configuration.ExtendedProtectionPolicyElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty custom_service_names;
    private static ConfigurationProperty policy_enforcement;
    private static ConfigurationProperty protection_scenario;
    [ConfigurationPropertyAttribute("customServiceNames")]
public ServiceNameElementCollection CustomServiceNames { get; }
    [ConfigurationPropertyAttribute("policyEnforcement")]
public PolicyEnforcement PolicyEnforcement { get; public set; }
    [ConfigurationPropertyAttribute("protectionScenario")]
public ProtectionScenario ProtectionScenario { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static ExtendedProtectionPolicyElement();
    public ServiceNameElementCollection get_CustomServiceNames();
    public PolicyEnforcement get_PolicyEnforcement();
    public void set_PolicyEnforcement(PolicyEnforcement value);
    public ProtectionScenario get_ProtectionScenario();
    public void set_ProtectionScenario(ProtectionScenario value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public ExtendedProtectionPolicy BuildPolicy();
}
public class System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElement : ConfigurationElement {
    private static ConfigurationPropertyCollection properties;
    private static ConfigurationProperty name;
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static ServiceNameElement();
    public string get_Name();
    public void set_Name(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElement")]
public class System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElementCollection : ConfigurationElementCollection {
    public ServiceNameElement Item { get; }
    public ServiceNameElement Item { get; }
    unknown string Item {public set; }
    public ServiceNameElement get_Item(int index);
    public ServiceNameElement get_Item(string name);
    public void Add(ServiceNameElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(ServiceNameElement element);
    public void Remove(string name);
    public void Remove(ServiceNameElement element);
    public void RemoveAt(int index);
    public void set_Item(int index, ServiceNameElement value);
    public void set_Item(string name, ServiceNameElement value);
}
[MonoTODOAttribute]
[TypeConverterAttribute("System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicyTypeConverter")]
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy : object {
    public ChannelBinding CustomChannelBinding { get; }
    public ServiceNameCollection CustomServiceNames { get; }
    public static bool OSSupportsExtendedProtection { get; }
    public PolicyEnforcement PolicyEnforcement { get; }
    public ProtectionScenario ProtectionScenario { get; }
    [MonoTODOAttribute("Not implemented.")]
public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames);
    protected ExtendedProtectionPolicy(SerializationInfo info, StreamingContext context);
    public ChannelBinding get_CustomChannelBinding();
    public ServiceNameCollection get_CustomServiceNames();
    public static bool get_OSSupportsExtendedProtection();
    public PolicyEnforcement get_PolicyEnforcement();
    public ProtectionScenario get_ProtectionScenario();
    [MonoTODOAttribute]
public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[MonoTODOAttribute]
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicyTypeConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Security.Authentication.ExtendedProtection.PolicyEnforcement : Enum {
    public int value__;
    public static PolicyEnforcement Never;
    public static PolicyEnforcement WhenSupported;
    public static PolicyEnforcement Always;
}
public enum System.Security.Authentication.ExtendedProtection.ProtectionScenario : Enum {
    public int value__;
    public static ProtectionScenario TransportSelected;
    public static ProtectionScenario TrustedProxy;
}
public class System.Security.Authentication.ExtendedProtection.ServiceNameCollection : ReadOnlyCollectionBase {
    public ServiceNameCollection(ICollection items);
    public ServiceNameCollection Merge(string serviceName);
    public ServiceNameCollection Merge(IEnumerable serviceNames);
    private static void AddIfNew(ArrayList newServiceNames, string serviceName);
    internal static bool Contains(string searchServiceName, ICollection serviceNames);
    public bool Contains(string searchServiceName);
    internal static string NormalizeServiceName(string inputServiceName);
    internal static bool Match(string serviceName1, string serviceName2);
}
public class System.Security.Authentication.ExtendedProtection.TokenBinding : object {
    private Byte[] _rawTokenBindingId;
    [CompilerGeneratedAttribute]
private TokenBindingType <BindingType>k__BackingField;
    public TokenBindingType BindingType { get; private set; }
    internal TokenBinding(TokenBindingType bindingType, Byte[] rawData);
    public Byte[] GetRawTokenBindingId();
    [CompilerGeneratedAttribute]
public TokenBindingType get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(TokenBindingType value);
}
public enum System.Security.Authentication.ExtendedProtection.TokenBindingType : Enum {
    public int value__;
    public static TokenBindingType Provided;
    public static TokenBindingType Referred;
}
public enum System.Security.Authentication.HashAlgorithmType : Enum {
    public int value__;
    public static HashAlgorithmType None;
    public static HashAlgorithmType Md5;
    public static HashAlgorithmType Sha1;
    public static HashAlgorithmType Sha256;
    public static HashAlgorithmType Sha384;
    public static HashAlgorithmType Sha512;
}
public class System.Security.Authentication.InvalidCredentialException : AuthenticationException {
    public InvalidCredentialException(string message);
    public InvalidCredentialException(string message, Exception innerException);
    protected InvalidCredentialException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
[FlagsAttribute]
public enum System.Security.Authentication.SslProtocols : Enum {
    public int value__;
    public static SslProtocols None;
    public static SslProtocols Ssl2;
    public static SslProtocols Ssl3;
    public static SslProtocols Tls;
    [MonoTODOAttribute("unsupported")]
public static SslProtocols Tls11;
    [MonoTODOAttribute("unsupported")]
public static SslProtocols Tls12;
    public static SslProtocols Tls13;
    public static SslProtocols Default;
}
public static class System.Security.Claims.DynamicRoleClaimProvider : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ClaimsAuthenticationManager to add claims to a ClaimsIdentity", "True")]
public static void AddDynamicRoleClaims(ClaimsIdentity claimsIdentity, IEnumerable`1<Claim> claims);
}
internal enum System.Security.Cryptography.AsnDecodeStatus : Enum {
    public int value__;
    public static AsnDecodeStatus NotDecoded;
    public static AsnDecodeStatus Ok;
    public static AsnDecodeStatus BadAsn;
    public static AsnDecodeStatus BadTag;
    public static AsnDecodeStatus BadLength;
    public static AsnDecodeStatus InformationNotAvailable;
}
public class System.Security.Cryptography.AsnEncodedData : object {
    internal Oid _oid;
    internal Byte[] _raw;
    public Oid Oid { get; public set; }
    public Byte[] RawData { get; public set; }
    public AsnEncodedData(string oid, Byte[] rawData);
    public AsnEncodedData(Oid oid, Byte[] rawData);
    public AsnEncodedData(AsnEncodedData asnEncodedData);
    public AsnEncodedData(Byte[] rawData);
    public Oid get_Oid();
    public void set_Oid(Oid value);
    public Byte[] get_RawData();
    public void set_RawData(Byte[] value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public virtual string Format(bool multiLine);
    internal virtual string ToString(bool multiLine);
    internal string Default(bool multiLine);
    internal string BasicConstraintsExtension(bool multiLine);
    internal string EnhancedKeyUsageExtension(bool multiLine);
    internal string KeyUsageExtension(bool multiLine);
    internal string SubjectKeyIdentifierExtension(bool multiLine);
    internal string SubjectAltName(bool multiLine);
    internal string NetscapeCertType(bool multiLine);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.AsnEncodedDataCollection : object {
    private List`1<AsnEncodedData> _list;
    public AsnEncodedData Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public AsnEncodedDataCollection(AsnEncodedData asnEncodedData);
    public int Add(AsnEncodedData asnEncodedData);
    public void Remove(AsnEncodedData asnEncodedData);
    public AsnEncodedData get_Item(int index);
    public sealed virtual int get_Count();
    public AsnEncodedDataEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(AsnEncodedData[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.AsnEncodedDataEnumerator : object {
    private AsnEncodedDataCollection _asnEncodedDatas;
    private int _current;
    public AsnEncodedData Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal AsnEncodedDataEnumerator(AsnEncodedDataCollection asnEncodedDatas);
    public AsnEncodedData get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal static class System.Security.Cryptography.DerEncoder : object {
    private static byte ConstructedFlag;
    private static byte ConstructedSequenceTag;
    private static byte ConstructedSetTag;
    private static Byte[][] s_nullTlv;
    private static DerEncoder();
    private static Byte[] EncodeLength(int length);
    internal static Byte[][] SegmentedEncodeBoolean(bool value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(UInt32 value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(ReadOnlySpan`1<byte> bigEndianBytes);
    internal static Byte[][] SegmentedEncodeBitString(Byte[][][] childSegments);
    internal static Byte[][] SegmentedEncodeBitString(Byte[] data);
    internal static Byte[][] SegmentedEncodeBitString(int unusedBits, Byte[] data);
    internal static Byte[][] SegmentedEncodeNamedBitList(Byte[] bigEndianBytes, int namedBitsCount);
    internal static Byte[][] SegmentedEncodeOctetString(Byte[] data);
    internal static Byte[][] SegmentedEncodeNull();
    internal static Byte[] EncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeOid(Oid oid);
    internal static Byte[][] SegmentedEncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars, int offset, int count);
    internal static Byte[][] ConstructSegmentedSequence(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSequence(IEnumerable`1<Byte[][]> items);
    internal static Byte[][] ConstructSegmentedContextSpecificValue(int contextId, Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSet(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedPresortedSet(Byte[][][] items);
    internal static bool IsValidPrintableString(Char[] chars);
    internal static bool IsValidPrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeUtcTime(DateTime utcTime);
    internal static Byte[][] SegmentedEncodeGeneralizedTime(DateTime utcTime);
    internal static Byte[] ConstructSequence(Byte[][][] items);
    internal static Byte[] ConstructSequence(IEnumerable`1<Byte[][]> items);
    private static BigInteger ParseOidRid(string oidValue, Int32& startIndex);
    private static int AtoI(char c);
    private static void EncodeRid(List`1<byte> encodedData, BigInteger& rid);
    private static bool IsPrintableStringCharacter(char c);
    private static Byte[] ConcatenateArrays(Byte[][][] segments);
    private static Byte[] ConcatenateArrays(IEnumerable`1<Byte[][]> segments);
}
internal class System.Security.Cryptography.DerSequenceReader : object {
    internal static byte ContextSpecificTagFlag;
    internal static byte ConstructedFlag;
    internal static byte ContextSpecificConstructedTag0;
    internal static byte ContextSpecificConstructedTag1;
    internal static byte ContextSpecificConstructedTag2;
    internal static byte ContextSpecificConstructedTag3;
    internal static byte ConstructedSequence;
    internal static byte TagClassMask;
    internal static byte TagNumberMask;
    internal static DateTimeFormatInfo s_validityDateTimeFormatInfo;
    private static Encoding s_utf8EncodingWithExceptionFallback;
    private static Encoding s_latin1Encoding;
    private Byte[] _data;
    private int _end;
    private int _position;
    [CompilerGeneratedAttribute]
private int <ContentLength>k__BackingField;
    internal int ContentLength { get; private set; }
    internal bool HasData { get; }
    private DerSequenceReader(bool startAtPayload, Byte[] data, int offset, int length);
    internal DerSequenceReader(Byte[] data);
    internal DerSequenceReader(Byte[] data, int offset, int length);
    private DerSequenceReader(DerTag tagToEat, Byte[] data, int offset, int length);
    [CompilerGeneratedAttribute]
internal int get_ContentLength();
    [CompilerGeneratedAttribute]
private void set_ContentLength(int value);
    internal static DerSequenceReader CreateForPayload(Byte[] payload);
    internal bool get_HasData();
    internal byte PeekTag();
    internal bool HasTag(DerTag expectedTag);
    internal bool HasTag(byte expectedTag);
    internal void SkipValue();
    internal void ValidateAndSkipDerValue();
    internal Byte[] ReadNextEncodedValue();
    internal bool ReadBoolean();
    internal int ReadInteger();
    internal Byte[] ReadIntegerBytes();
    internal Byte[] ReadBitString();
    internal Byte[] ReadOctetString();
    internal string ReadOidAsString();
    internal Oid ReadOid();
    internal string ReadUtf8String();
    private DerSequenceReader ReadCollectionWithTag(DerTag expected);
    internal DerSequenceReader ReadSequence();
    internal DerSequenceReader ReadSet();
    internal string ReadPrintableString();
    internal string ReadIA5String();
    internal string ReadT61String();
    internal DateTime ReadX509Date();
    internal DateTime ReadUtcTime();
    internal DateTime ReadGeneralizedTime();
    internal string ReadBMPString();
    private static string TrimTrailingNulls(string value);
    private DateTime ReadTime(DerTag timeTag, string formatString);
    private Byte[] ReadContentAsBytes();
    private void EatTag(DerTag expected);
    private static void CheckTag(DerTag expected, Byte[] data, int position);
    private int EatLength();
    private static int ScanContentLength(Byte[] data, int offset, int end, Int32& bytesConsumed);
}
public class System.Security.Cryptography.Oid : object {
    private string _value;
    private string _friendlyName;
    private OidGroup _group;
    public string Value { get; public set; }
    public string FriendlyName { get; public set; }
    public Oid(string oid);
    public Oid(string value, string friendlyName);
    public Oid(Oid oid);
    private Oid(string value, string friendlyName, OidGroup group);
    public static Oid FromFriendlyName(string friendlyName, OidGroup group);
    public static Oid FromOidValue(string oidValue, OidGroup group);
    public string get_Value();
    public void set_Value(string value);
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.OidCollection : object {
    private List`1<Oid> _list;
    public Oid Item { get; }
    public Oid Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Add(Oid oid);
    public Oid get_Item(int index);
    public Oid get_Item(string oid);
    public sealed virtual int get_Count();
    public OidEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Oid[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.OidEnumerator : object {
    private OidCollection _oids;
    private int _current;
    public Oid Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal OidEnumerator(OidCollection oids);
    public Oid get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.OidGroup : Enum {
    public int value__;
    public static OidGroup All;
    public static OidGroup HashAlgorithm;
    public static OidGroup EncryptionAlgorithm;
    public static OidGroup PublicKeyAlgorithm;
    public static OidGroup SignatureAlgorithm;
    public static OidGroup Attribute;
    public static OidGroup ExtensionOrAttribute;
    public static OidGroup EnhancedKeyUsage;
    public static OidGroup Policy;
    public static OidGroup Template;
    public static OidGroup KeyDerivationFunction;
}
public class System.Security.Cryptography.X509Certificates.CertificateRequest : object {
    public Collection`1<X509Extension> CertificateExtensions { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public PublicKey PublicKey { get; }
    public X500DistinguishedName SubjectName { get; }
    public CertificateRequest(X500DistinguishedName subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(string subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(string subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Collection`1<X509Extension> get_CertificateExtensions();
    public HashAlgorithmName get_HashAlgorithm();
    public PublicKey get_PublicKey();
    public X500DistinguishedName get_SubjectName();
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 CreateSelfSigned(DateTimeOffset notBefore, DateTimeOffset notAfter);
    public Byte[] CreateSigningRequest();
    public Byte[] CreateSigningRequest(X509SignatureGenerator signatureGenerator);
}
internal class System.Security.Cryptography.X509Certificates.GeneralNameEncoder : object {
    private static IdnMapping s_idnMapping;
    private static GeneralNameEncoder();
    internal Byte[][] EncodeEmailAddress(string emailAddress);
    internal Byte[][] EncodeDnsName(string dnsName);
    internal Byte[][] EncodeUri(Uri uri);
    internal Byte[][] EncodeIpAddress(IPAddress address);
    internal Byte[][] EncodeUserPrincipalName(string upn);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags IncludeArchived;
}
internal static class System.Security.Cryptography.X509Certificates.OSX509Certificates : object {
    public static string SecurityLibrary;
    public static string CoreFoundationLibrary;
    private static IntPtr SecCertificateCreateWithData(IntPtr allocator, IntPtr nsdataRef);
    private static int SecTrustCreateWithCertificates(IntPtr certOrCertArray, IntPtr policies, IntPtr& sectrustref);
    private static int SecTrustSetAnchorCertificates(IntPtr trust, IntPtr anchorCertificates);
    private static IntPtr SecPolicyCreateSSL(bool server, IntPtr cfStringHostname);
    private static int SecTrustEvaluate(IntPtr secTrustRef, SecTrustResult& secTrustResultTime);
    private static IntPtr CFStringCreateWithCharacters(IntPtr allocator, string str, IntPtr count);
    private static IntPtr CFDataCreate(IntPtr allocator, Byte* bytes, IntPtr length);
    private static void CFRetain(IntPtr handle);
    private static void CFRelease(IntPtr handle);
    private static IntPtr CFArrayCreate(IntPtr allocator, IntPtr values, IntPtr numValues, IntPtr callbacks);
    private static IntPtr MakeCFData(Byte[] data);
    private static IntPtr FromIntPtrs(IntPtr[] values);
    private static IntPtr GetCertificate(X509Certificate certificate);
    public static SecTrustResult TrustEvaluateSsl(X509CertificateCollection certificates, X509CertificateCollection anchors, string host);
    private static SecTrustResult _TrustEvaluateSsl(X509CertificateCollection certificates, X509CertificateCollection anchors, string hostName);
}
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    private static string rsaOid;
    private static string dsaOid;
    private AsymmetricAlgorithm _key;
    private AsnEncodedData _keyValue;
    private AsnEncodedData _params;
    private Oid _oid;
    private static Byte[] Empty;
    public AsnEncodedData EncodedKeyValue { get; }
    public AsnEncodedData EncodedParameters { get; }
    public AsymmetricAlgorithm Key { get; }
    public Oid Oid { get; }
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    internal PublicKey(X509Certificate certificate);
    private static PublicKey();
    public AsnEncodedData get_EncodedKeyValue();
    public AsnEncodedData get_EncodedParameters();
    public AsymmetricAlgorithm get_Key();
    public Oid get_Oid();
    private static Byte[] GetUnsignedBigInteger(Byte[] integer);
    internal static DSA DecodeDSA(Byte[] rawPublicKey, Byte[] rawParameters);
    internal static RSA DecodeRSA(Byte[] rawPublicKey);
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
public class System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder : object {
    private List`1<Byte[][]> _encodedTlvs;
    private GeneralNameEncoder _generalNameEncoder;
    public void AddEmailAddress(string emailAddress);
    public void AddDnsName(string dnsName);
    public void AddUri(Uri uri);
    public void AddIpAddress(IPAddress ipAddress);
    public void AddUserPrincipalName(string upn);
    public X509Extension Build(bool critical);
}
[MonoTODOAttribute("Some X500DistinguishedNameFlags options aren't supported, like DoNotUsePlusSign, DoNotUseQuotes and ForceUTF8Encoding")]
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    private static X500DistinguishedNameFlags AllFlags;
    private string name;
    private Byte[] canonEncoding;
    internal Byte[] CanonicalEncoding { get; }
    public string Name { get; }
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    internal X500DistinguishedName(Byte[] encoded, Byte[] canonEncoding, string name);
    internal Byte[] get_CanonicalEncoding();
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public virtual string Format(bool multiLine);
    private static string GetSeparator(X500DistinguishedNameFlags flag);
    private void DecodeRawData();
    private static string Canonize(string s);
    internal static bool AreEqual(X500DistinguishedName name1, X500DistinguishedName name2);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
}
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    internal static string oid;
    internal static string friendlyName;
    private bool _certificateAuthority;
    private bool _hasPathLengthConstraint;
    private int _pathLengthConstraint;
    private AsnDecodeStatus _status;
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    internal AsnDecodeStatus Decode(Byte[] extension);
    internal Byte[] Encode();
    internal virtual string ToString(bool multiLine);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) lazyRawData;
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) lazySignatureAlgorithm;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) lazyVersion;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) lazySubjectName;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) lazyIssuerName;
    private PublicKey modreq(System.Runtime.CompilerServices.IsVolatile) lazyPublicKey;
    private AsymmetricAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) lazyPrivateKey;
    private X509ExtensionCollection modreq(System.Runtime.CompilerServices.IsVolatile) lazyExtensions;
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public bool HasPrivateKey { get; }
    public AsymmetricAlgorithm PrivateKey { get; public set; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    public string SerialNumber { get; }
    public Oid SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    internal X509Certificate2Impl Impl { get; }
    public X509Certificate2(Byte[] rawData);
    public X509Certificate2(Byte[] rawData, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password);
    public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(IntPtr handle);
    internal X509Certificate2(X509Certificate2Impl impl);
    public X509Certificate2(string fileName);
    public X509Certificate2(string fileName, string password);
    public X509Certificate2(string fileName, SecureString password);
    public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(X509Certificate certificate);
    protected X509Certificate2(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    public bool get_Archived();
    public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public bool get_HasPrivateKey();
    public AsymmetricAlgorithm get_PrivateKey();
    public void set_PrivateKey(AsymmetricAlgorithm value);
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    public string get_SerialNumber();
    public Oid get_SignatureAlgorithm();
    public X500DistinguishedName get_SubjectName();
    public string get_Thumbprint();
    public int get_Version();
    public static X509ContentType GetCertContentType(Byte[] rawData);
    public static X509ContentType GetCertContentType(string fileName);
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    public virtual void Import(Byte[] rawData);
    public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName);
    public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public bool Verify();
    private static X509Extension CreateCustomExtensionIfAny(Oid oid);
    internal X509Certificate2Impl get_Impl();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    private static String[] newline_split;
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    private static X509Certificate2Collection();
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    [MonoTODOAttribute("Method isn't transactional (like documented)")]
public void AddRange(X509Certificate2[] certificates);
    [MonoTODOAttribute("Method isn't transactional (like documented)")]
public void AddRange(X509Certificate2Collection certificates);
    public bool Contains(X509Certificate2 certificate);
    [MonoTODOAttribute("only support X509ContentType.Cert")]
public Byte[] Export(X509ContentType contentType);
    [MonoTODOAttribute("only support X509ContentType.Cert")]
public Byte[] Export(X509ContentType contentType, string password);
    private string GetKeyIdentifier(X509Certificate2 x);
    [MonoTODOAttribute("Does not support X509FindType.FindByTemplateName, FindByApplicationPolicy and FindByCertificatePolicy")]
public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public X509Certificate2Enumerator GetEnumerator();
    [MonoTODOAttribute("same limitations as X509Certificate2.Import")]
public void Import(Byte[] rawData);
    [MonoTODOAttribute("same limitations as X509Certificate2.Import")]
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [MonoTODOAttribute("same limitations as X509Certificate2.Import")]
public void Import(string fileName);
    [MonoTODOAttribute("same limitations as X509Certificate2.Import")]
public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public void Insert(int index, X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    [MonoTODOAttribute("Method isn't transactional (like documented)")]
public void RemoveRange(X509Certificate2[] certificates);
    [MonoTODOAttribute("Method isn't transactional (like documented)")]
public void RemoveRange(X509Certificate2Collection certificates);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    private IEnumerator enumerator;
    public X509Certificate2 Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509Certificate2Enumerator(X509Certificate2Collection collection);
    public X509Certificate2 get_Current();
    public bool MoveNext();
    public void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal abstract class System.Security.Cryptography.X509Certificates.X509Certificate2Impl : X509CertificateImpl {
    public bool Archived { get; public set; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName IssuerName { get; }
    public AsymmetricAlgorithm PrivateKey { get; public set; }
    public PublicKey PublicKey { get; }
    public string SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public int Version { get; }
    internal X509CertificateImplCollection IntermediateCertificates { get; }
    internal X509Certificate2Impl FallbackImpl { get; }
    public abstract virtual bool get_Archived();
    public abstract virtual void set_Archived(bool value);
    public abstract virtual IEnumerable`1<X509Extension> get_Extensions();
    public abstract virtual string get_FriendlyName();
    public abstract virtual void set_FriendlyName(string value);
    public abstract virtual X500DistinguishedName get_IssuerName();
    public abstract virtual AsymmetricAlgorithm get_PrivateKey();
    public abstract virtual void set_PrivateKey(AsymmetricAlgorithm value);
    public abstract virtual PublicKey get_PublicKey();
    public abstract virtual string get_SignatureAlgorithm();
    public abstract virtual X500DistinguishedName get_SubjectName();
    public abstract virtual int get_Version();
    internal abstract virtual X509CertificateImplCollection get_IntermediateCertificates();
    internal abstract virtual X509Certificate2Impl get_FallbackImpl();
    public abstract virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public abstract virtual bool Verify(X509Certificate2 thisCertificate);
    public abstract virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public sealed virtual X509CertificateImpl CopyWithPrivateKey(RSA privateKey);
    public sealed virtual X509Certificate CreateCertificate();
    public abstract virtual void Reset();
}
internal class System.Security.Cryptography.X509Certificates.X509Certificate2ImplMono : X509Certificate2ImplUnix {
    private PublicKey _publicKey;
    private X509CertificateImplCollection intermediateCerts;
    private X509Certificate _cert;
    private static string empty_error;
    private static Byte[] signedData;
    public bool IsValid { get; }
    public IntPtr Handle { get; }
    private X509Certificate Cert { get; }
    public bool HasPrivateKey { get; }
    public AsymmetricAlgorithm PrivateKey { get; public set; }
    public PublicKey PublicKey { get; }
    internal X509CertificateImplCollection IntermediateCertificates { get; }
    internal X509Certificate MonoCertificate { get; }
    internal X509Certificate2Impl FallbackImpl { get; }
    public X509Certificate2ImplMono(X509Certificate cert);
    private X509Certificate2ImplMono(X509Certificate2ImplMono other);
    public X509Certificate2ImplMono(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    private static X509Certificate2ImplMono();
    public virtual bool get_IsValid();
    public virtual IntPtr get_Handle();
    public virtual IntPtr GetNativeAppleCertificate();
    public virtual X509CertificateImpl Clone();
    private X509Certificate get_Cert();
    protected virtual Byte[] GetRawCertData();
    public virtual bool Equals(X509CertificateImpl other, Boolean& result);
    public virtual bool get_HasPrivateKey();
    public virtual AsymmetricAlgorithm get_PrivateKey();
    public virtual void set_PrivateKey(AsymmetricAlgorithm value);
    public virtual RSA GetRSAPrivateKey();
    public virtual DSA GetDSAPrivateKey();
    public virtual PublicKey get_PublicKey();
    private X509Certificate ImportPkcs12(Byte[] rawData, SafePasswordHandle password);
    private X509Certificate ImportPkcs12(Byte[] rawData, string password);
    public virtual void Reset();
    [MonoTODOAttribute("by default this depends on the incomplete X509Chain")]
public virtual bool Verify(X509Certificate2 thisCertificate);
    [MonoTODOAttribute("Detection limited to Cert, Pfx, Pkcs12, Pkcs7 and Unknown")]
public static X509ContentType GetCertContentType(Byte[] rawData);
    [MonoTODOAttribute("Detection limited to Cert, Pfx, Pkcs12 and Unknown")]
public static X509ContentType GetCertContentType(string fileName);
    internal virtual X509CertificateImplCollection get_IntermediateCertificates();
    internal X509Certificate get_MonoCertificate();
    internal virtual X509Certificate2Impl get_FallbackImpl();
}
internal abstract class System.Security.Cryptography.X509Certificates.X509Certificate2ImplUnix : X509Certificate2Impl {
    private bool readCertData;
    private CertificateData certData;
    public bool Archived { get; public set; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public string FriendlyName { get; public set; }
    public int Version { get; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public string Subject { get; }
    public string Issuer { get; }
    public string LegacySubject { get; }
    public string LegacyIssuer { get; }
    public Byte[] RawData { get; }
    public Byte[] Thumbprint { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    private void EnsureCertData();
    protected abstract virtual Byte[] GetRawCertData();
    public sealed virtual bool get_Archived();
    public sealed virtual void set_Archived(bool value);
    public sealed virtual string get_KeyAlgorithm();
    public sealed virtual Byte[] get_KeyAlgorithmParameters();
    public sealed virtual Byte[] get_PublicKeyValue();
    public sealed virtual Byte[] get_SerialNumber();
    public sealed virtual string get_SignatureAlgorithm();
    public sealed virtual string get_FriendlyName();
    public sealed virtual void set_FriendlyName(string value);
    public sealed virtual int get_Version();
    public sealed virtual X500DistinguishedName get_SubjectName();
    public sealed virtual X500DistinguishedName get_IssuerName();
    public sealed virtual string get_Subject();
    public sealed virtual string get_Issuer();
    public sealed virtual string get_LegacySubject();
    public sealed virtual string get_LegacyIssuer();
    public sealed virtual Byte[] get_RawData();
    public sealed virtual Byte[] get_Thumbprint();
    public sealed virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public sealed virtual IEnumerable`1<X509Extension> get_Extensions();
    public sealed virtual DateTime get_NotAfter();
    public sealed virtual DateTime get_NotBefore();
    public sealed virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public virtual void Reset();
    public sealed virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
    private Byte[] ExportPkcs12(SafePasswordHandle password);
    private Byte[] ExportPkcs12(string password);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
    public X509Certificate Item { get; public set; }
    public X509CertificateCollection(X509Certificate[] value);
    public X509CertificateCollection(X509CertificateCollection value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509Certificate[] value);
    public void AddRange(X509CertificateCollection value);
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    public void Remove(X509Certificate value);
    private bool Compare(Byte[] array1, Byte[] array2);
}
[DefaultMemberAttribute("Item")]
internal class System.Security.Cryptography.X509Certificates.X509CertificateImplCollection : object {
    private List`1<X509CertificateImpl> list;
    public int Count { get; }
    public X509CertificateImpl Item { get; }
    private X509CertificateImplCollection(X509CertificateImplCollection other);
    public int get_Count();
    public X509CertificateImpl get_Item(int index);
    public void Add(X509CertificateImpl impl, bool takeOwnership);
    public X509CertificateImplCollection Clone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    private X509ChainImpl impl;
    internal X509ChainImpl Impl { get; }
    internal bool IsValid { get; }
    [MonoTODOAttribute("Mono's X509Chain is fully managed. Always returns IntPtr.Zero.")]
public IntPtr ChainContext { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public X509Chain(bool useMachineContext);
    internal X509Chain(X509ChainImpl impl);
    [MonoTODOAttribute("Mono's X509Chain is fully managed. All handles are invalid.")]
public X509Chain(IntPtr chainContext);
    internal X509ChainImpl get_Impl();
    internal bool get_IsValid();
    internal void ThrowIfContextInvalid();
    public IntPtr get_ChainContext();
    public X509ChainElementCollection get_ChainElements();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    public SafeX509ChainHandle get_SafeHandle();
    [MonoTODOAttribute("Not totally RFC3280 compliant, but neither is MS implementation...")]
public bool Build(X509Certificate2 certificate);
    public void Reset();
    public static X509Chain Create();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    private X509Certificate2 certificate;
    private X509ChainStatus[] status;
    private string info;
    private X509ChainStatusFlags compressed_status_flags;
    public X509Certificate2 Certificate { get; }
    public X509ChainStatus[] ChainElementStatus { get; }
    public string Information { get; }
    internal X509ChainStatusFlags StatusFlags { get; internal set; }
    internal X509ChainElement(X509Certificate2 certificate);
    public X509Certificate2 get_Certificate();
    public X509ChainStatus[] get_ChainElementStatus();
    public string get_Information();
    internal X509ChainStatusFlags get_StatusFlags();
    internal void set_StatusFlags(X509ChainStatusFlags value);
    private int Count(X509ChainStatusFlags flags);
    private void Set(X509ChainStatus[] status, Int32& position, X509ChainStatusFlags flags, X509ChainStatusFlags mask);
    internal void UncompressFlags();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    private ArrayList _list;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public X509ChainElement Item { get; }
    public object SyncRoot { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public X509ChainElement get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public void CopyTo(X509ChainElement[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Add(X509Certificate2 certificate);
    internal void Clear();
    internal bool Contains(X509Certificate2 certificate);
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    private IEnumerator enumerator;
    public X509ChainElement Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ChainElementEnumerator(IEnumerable enumerable);
    public X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal abstract class System.Security.Cryptography.X509Certificates.X509ChainImpl : object {
    public bool IsValid { get; }
    public IntPtr Handle { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public abstract virtual bool get_IsValid();
    public abstract virtual IntPtr get_Handle();
    protected void ThrowIfContextInvalid();
    public abstract virtual X509ChainElementCollection get_ChainElements();
    public abstract virtual X509ChainPolicy get_ChainPolicy();
    public abstract virtual void set_ChainPolicy(X509ChainPolicy value);
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual bool Build(X509Certificate2 certificate);
    public abstract virtual void AddStatus(X509ChainStatusFlags errorCode);
    public abstract virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
internal class System.Security.Cryptography.X509Certificates.X509ChainImplMono : X509ChainImpl {
    private StoreLocation location;
    private X509ChainElementCollection elements;
    private X509ChainPolicy policy;
    private X509ChainStatus[] status;
    private static X509ChainStatus[] Empty;
    private int max_path_length;
    private X500DistinguishedName working_issuer_name;
    private AsymmetricAlgorithm working_public_key;
    private X509ChainElement bce_restriction;
    private X509Certificate2Collection roots;
    private X509Certificate2Collection cas;
    private X509Store root_store;
    private X509Store ca_store;
    private X509Store user_root_store;
    private X509Store user_ca_store;
    private X509Certificate2Collection collection;
    public bool IsValid { get; }
    public IntPtr Handle { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    private X509Certificate2Collection Roots { get; }
    private X509Certificate2Collection CertificateAuthorities { get; }
    private X509Store LMRootStore { get; }
    private X509Store UserRootStore { get; }
    private X509Store LMCAStore { get; }
    private X509Store UserCAStore { get; }
    private X509Certificate2Collection CertificateCollection { get; }
    public X509ChainImplMono(bool useMachineContext);
    [MonoTODOAttribute("Mono's X509Chain is fully managed. All handles are invalid.")]
public X509ChainImplMono(IntPtr chainContext);
    private static X509ChainImplMono();
    public virtual bool get_IsValid();
    public virtual IntPtr get_Handle();
    public virtual X509ChainElementCollection get_ChainElements();
    public virtual X509ChainPolicy get_ChainPolicy();
    public virtual void set_ChainPolicy(X509ChainPolicy value);
    public virtual X509ChainStatus[] get_ChainStatus();
    public virtual void AddStatus(X509ChainStatusFlags error);
    [MonoTODOAttribute("Not totally RFC3280 compliant, but neither is MS implementation...")]
public virtual bool Build(X509Certificate2 certificate);
    public virtual void Reset();
    private X509Certificate2Collection get_Roots();
    private X509Certificate2Collection get_CertificateAuthorities();
    private X509Store get_LMRootStore();
    private X509Store get_UserRootStore();
    private X509Store get_LMCAStore();
    private X509Store get_UserCAStore();
    private X509Certificate2Collection get_CertificateCollection();
    private X509ChainStatusFlags BuildChainFrom(X509Certificate2 certificate);
    private X509Certificate2 SelectBestFromCollection(X509Certificate2 child, X509Certificate2Collection c);
    private X509Certificate2 FindParent(X509Certificate2 certificate);
    private bool IsChainComplete(X509Certificate2 certificate);
    private bool IsSelfIssued(X509Certificate2 certificate);
    private void ValidateChain(X509ChainStatusFlags flag);
    private void Process(int n);
    private void PrepareForNextCertificate(int n);
    private void WrapUp();
    private void ProcessCertificateExtensions(X509ChainElement element);
    private bool IsSignedWith(X509Certificate2 signed, AsymmetricAlgorithm pubkey);
    private string GetSubjectKeyIdentifier(X509Certificate2 certificate);
    private static string GetAuthorityKeyIdentifier(X509Certificate2 certificate);
    private static string GetAuthorityKeyIdentifier(X509Crl crl);
    private static string GetAuthorityKeyIdentifier(X509Extension ext);
    private void CheckRevocationOnChain(X509ChainStatusFlags flag);
    private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, int ca, bool online);
    private X509ChainStatusFlags CheckRevocation(X509Certificate2 certificate, X509Certificate2 ca_cert, bool online);
    private static X509Crl CheckCrls(string subject, string ski, X509Store store);
    private X509Crl FindCrl(X509Certificate2 caCertificate);
    private bool ProcessCrlExtensions(X509Crl crl);
    private bool ProcessCrlEntryExtensions(X509CrlEntry entry);
}
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    private OidCollection apps;
    private OidCollection cert;
    private X509CertificateCollection store;
    private X509Certificate2Collection store2;
    private X509RevocationFlag rflag;
    private X509RevocationMode mode;
    private TimeSpan timeout;
    private X509VerificationFlags vflags;
    private DateTime vtime;
    public OidCollection ApplicationPolicy { get; }
    public OidCollection CertificatePolicy { get; }
    public X509Certificate2Collection ExtraStore { get; internal set; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public DateTime VerificationTime { get; public set; }
    internal X509ChainPolicy(X509CertificateCollection store);
    public OidCollection get_ApplicationPolicy();
    public OidCollection get_CertificatePolicy();
    public X509Certificate2Collection get_ExtraStore();
    internal void set_ExtraStore(X509Certificate2Collection value);
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public TimeSpan get_UrlRetrievalTimeout();
    public void set_UrlRetrievalTimeout(TimeSpan value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    public DateTime get_VerificationTime();
    public void set_VerificationTime(DateTime value);
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    private X509ChainStatusFlags status;
    private string info;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    internal X509ChainStatus(X509ChainStatusFlags flag);
    public X509ChainStatusFlags get_Status();
    public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
    internal static string GetInformation(X509ChainStatusFlags flags);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags UntrustedRoot;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
    public static X509ChainStatusFlags HasWeakSignature;
}
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    internal static string oid;
    internal static string friendlyName;
    private OidCollection _enhKeyUsage;
    private AsnDecodeStatus _status;
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    internal AsnDecodeStatus Decode(Byte[] extension);
    internal Byte[] Encode();
    internal virtual string ToString(bool multiLine);
}
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    private bool _critical;
    public bool Critical { get; public set; }
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    public bool get_Critical();
    public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    internal string FormatUnkownData(Byte[] data);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    private static Byte[] Empty;
    private ArrayList _list;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public X509Extension Item { get; }
    public X509Extension Item { get; }
    internal X509ExtensionCollection(X509Certificate cert);
    private static X509ExtensionCollection();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public int Add(X509Extension extension);
    public void CopyTo(X509Extension[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    private IEnumerator enumerator;
    public X509Extension Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ExtensionEnumerator(ArrayList list);
    public X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindByTimeValid;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySubjectKeyIdentifier;
}
internal static class System.Security.Cryptography.X509Certificates.X509Helper2 : object {
    [MonoTODOAttribute("Investigate replacement; see comments in source.")]
internal static X509Certificate GetMonoCertificate(X509Certificate2 certificate);
    internal static X509ChainImpl CreateChainImpl(bool useMachineContext);
    public static bool IsValid(X509ChainImpl impl);
    internal static void ThrowIfContextInvalid(X509ChainImpl impl);
    internal static Exception GetInvalidChainContextException();
    [ObsoleteAttribute("This is only used by Mono.Security's X509Store and will be replaced shortly.")]
internal static long GetSubjectNameHash(X509Certificate certificate);
    [ObsoleteAttribute("This is only used by Mono.Security's X509Store and will be replaced shortly.")]
internal static void ExportAsPEM(X509Certificate certificate, Stream stream, bool includeHumanReadableForm);
    private static MonoBtlsX509 GetNativeInstance(X509CertificateImpl impl);
}
public enum System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
    public int value__;
    public static X509IncludeOption None;
    public static X509IncludeOption ExcludeRoot;
    public static X509IncludeOption EndCertOnly;
    public static X509IncludeOption WholeChain;
}
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    internal static string oid;
    internal static string friendlyName;
    internal static X509KeyUsageFlags all;
    private X509KeyUsageFlags _keyUsages;
    private AsnDecodeStatus _status;
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    internal X509KeyUsageFlags GetValidFlags(X509KeyUsageFlags flags);
    internal AsnDecodeStatus Decode(Byte[] extension);
    internal Byte[] Encode();
    internal virtual string ToString(bool multiLine);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType SimpleName;
    public static X509NameType EmailName;
    public static X509NameType UpnName;
    public static X509NameType DnsName;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType UrlName;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Online;
    public static X509RevocationMode Offline;
}
public abstract class System.Security.Cryptography.X509Certificates.X509SignatureGenerator : object {
    public PublicKey PublicKey { get; }
    public PublicKey get_PublicKey();
    protected abstract virtual PublicKey BuildPublicKey();
    public static X509SignatureGenerator CreateForECDsa(ECDsa key);
    public static X509SignatureGenerator CreateForRSA(RSA key, RSASignaturePadding signaturePadding);
    public abstract virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
}
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    private string _name;
    private StoreLocation _location;
    private X509Certificate2Collection list;
    private OpenFlags _flags;
    private X509Store store;
    public X509Certificate2Collection Certificates { get; }
    public StoreLocation Location { get; }
    public string Name { get; }
    private X509Stores Factory { get; }
    public bool IsOpen { get; }
    private bool IsReadOnly { get; }
    internal X509Store Store { get; }
    [MonoTODOAttribute("Mono's stores are fully managed. Always returns IntPtr.Zero.")]
public IntPtr StoreHandle { get; }
    public X509Store(string storeName);
    public X509Store(StoreName storeName);
    public X509Store(StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation, OpenFlags openFlags);
    public X509Store(string storeName, StoreLocation storeLocation, OpenFlags openFlags);
    [MonoTODOAttribute("Mono's stores are fully managed. All handles are invalid.")]
public X509Store(IntPtr storeHandle);
    public X509Store(string storeName, StoreLocation storeLocation);
    public X509Certificate2Collection get_Certificates();
    public StoreLocation get_Location();
    public string get_Name();
    private X509Stores get_Factory();
    public bool get_IsOpen();
    private bool get_IsReadOnly();
    internal X509Store get_Store();
    public IntPtr get_StoreHandle();
    public void Add(X509Certificate2 certificate);
    [MonoTODOAttribute("Method isn't transactional (like documented)")]
public void AddRange(X509Certificate2Collection certificates);
    public void Close();
    public sealed virtual void Dispose();
    public void Open(OpenFlags flags);
    public void Remove(X509Certificate2 certificate);
    [MonoTODOAttribute("Method isn't transactional (like documented)")]
public void RemoveRange(X509Certificate2Collection certificates);
    private bool Exists(X509Certificate2 certificate);
}
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    internal static string oid;
    internal static string friendlyName;
    private Byte[] _subjectKeyIdentifier;
    private string _ski;
    private AsnDecodeStatus _status;
    public string SubjectKeyIdentifier { get; }
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public string get_SubjectKeyIdentifier();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    internal static byte FromHexChar(char c);
    internal static byte FromHexChars(char c1, char c2);
    internal static Byte[] FromHex(string hex);
    internal AsnDecodeStatus Decode(Byte[] extension);
    internal Byte[] Encode();
    internal virtual string ToString(bool multiLine);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags NoFlag;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags AllFlags;
}
internal class System.Security.Permissions.PermissionHelper : object {
    internal static SecurityElement Element(Type type, int version);
    internal static PermissionState CheckPermissionState(PermissionState state, bool allowUnrestricted);
    internal static int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion);
    internal static bool IsUnrestricted(SecurityElement se);
    internal static void ThrowInvalidPermission(IPermission target, Type expected);
}
public abstract class System.Security.Permissions.ResourcePermissionBase : CodeAccessPermission {
    private static int version;
    private ArrayList _list;
    private bool _unrestricted;
    private Type _type;
    private String[] _tags;
    public static string Any;
    public static string Local;
    private static Char[] invalidChars;
    protected Type PermissionAccessType { get; protected set; }
    protected String[] TagNames { get; protected set; }
    protected ResourcePermissionBase(PermissionState state);
    private static ResourcePermissionBase();
    protected Type get_PermissionAccessType();
    protected void set_PermissionAccessType(Type value);
    protected String[] get_TagNames();
    protected void set_TagNames(String[] value);
    protected void AddPermissionAccess(ResourcePermissionBaseEntry entry);
    protected void Clear();
    public virtual IPermission Copy();
    [MonoTODOAttribute("incomplete - need more test")]
public virtual void FromXml(SecurityElement securityElement);
    protected ResourcePermissionBaseEntry[] GetPermissionEntries();
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    protected void RemovePermissionAccess(ResourcePermissionBaseEntry entry);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
    private bool IsEmpty();
    private ResourcePermissionBase Cast(IPermission target);
    internal void CheckEntry(ResourcePermissionBaseEntry entry);
    internal bool Equals(ResourcePermissionBaseEntry entry1, ResourcePermissionBaseEntry entry2);
    internal bool Exists(ResourcePermissionBaseEntry entry);
    internal static void ValidateMachineName(string name);
    internal static ResourcePermissionBase CreateFromType(Type type, bool unrestricted);
}
public class System.Security.Permissions.ResourcePermissionBaseEntry : object {
    private int permissionAccess;
    private String[] permissionAccessPath;
    public int PermissionAccess { get; }
    public String[] PermissionAccessPath { get; }
    public ResourcePermissionBaseEntry(int permissionAccess, String[] permissionAccessPath);
    public int get_PermissionAccess();
    public String[] get_PermissionAccessPath();
}
public class System.Security.Permissions.StorePermission : CodeAccessPermission {
    private static int version;
    private StorePermissionFlags _flags;
    public StorePermissionFlags Flags { get; public set; }
    public StorePermission(PermissionState state);
    public StorePermission(StorePermissionFlags flag);
    public StorePermissionFlags get_Flags();
    public void set_Flags(StorePermissionFlags value);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
    private StorePermission Cast(IPermission target);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.StorePermissionAttribute : CodeAccessSecurityAttribute {
    private StorePermissionFlags _flags;
    public StorePermissionFlags Flags { get; public set; }
    public bool AddToStore { get; public set; }
    public bool CreateStore { get; public set; }
    public bool DeleteStore { get; public set; }
    public bool EnumerateCertificates { get; public set; }
    public bool EnumerateStores { get; public set; }
    public bool OpenStore { get; public set; }
    public bool RemoveFromStore { get; public set; }
    public StorePermissionAttribute(SecurityAction action);
    public StorePermissionFlags get_Flags();
    public void set_Flags(StorePermissionFlags value);
    public bool get_AddToStore();
    public void set_AddToStore(bool value);
    public bool get_CreateStore();
    public void set_CreateStore(bool value);
    public bool get_DeleteStore();
    public void set_DeleteStore(bool value);
    public bool get_EnumerateCertificates();
    public void set_EnumerateCertificates(bool value);
    public bool get_EnumerateStores();
    public void set_EnumerateStores(bool value);
    public bool get_OpenStore();
    public void set_OpenStore(bool value);
    public bool get_RemoveFromStore();
    public void set_RemoveFromStore(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.StorePermissionFlags : Enum {
    public int value__;
    public static StorePermissionFlags NoFlags;
    public static StorePermissionFlags CreateStore;
    public static StorePermissionFlags DeleteStore;
    public static StorePermissionFlags EnumerateStores;
    public static StorePermissionFlags OpenStore;
    public static StorePermissionFlags AddToStore;
    public static StorePermissionFlags RemoveFromStore;
    public static StorePermissionFlags EnumerateCertificates;
    public static StorePermissionFlags AllFlags;
}
public class System.Security.Permissions.TypeDescriptorPermission : CodeAccessPermission {
    private TypeDescriptorPermissionFlags m_flags;
    public TypeDescriptorPermissionFlags Flags { get; public set; }
    public TypeDescriptorPermission(PermissionState state);
    public TypeDescriptorPermission(TypeDescriptorPermissionFlags flag);
    private void SetUnrestricted(bool unrestricted);
    private void Reset();
    public void set_Flags(TypeDescriptorPermissionFlags value);
    public TypeDescriptorPermissionFlags get_Flags();
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Union(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Copy();
    private void VerifyAccess(TypeDescriptorPermissionFlags type);
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    internal static void VerifyFlags(TypeDescriptorPermissionFlags flags);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.TypeDescriptorPermissionAttribute : CodeAccessSecurityAttribute {
    public TypeDescriptorPermissionFlags Flags { get; public set; }
    public bool RestrictedRegistrationAccess { get; public set; }
    public TypeDescriptorPermissionAttribute(SecurityAction action);
    public TypeDescriptorPermissionFlags get_Flags();
    public void set_Flags(TypeDescriptorPermissionFlags value);
    public bool get_RestrictedRegistrationAccess();
    public void set_RestrictedRegistrationAccess(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.TypeDescriptorPermissionFlags : Enum {
    public int value__;
    public static TypeDescriptorPermissionFlags NoFlags;
    public static TypeDescriptorPermissionFlags RestrictedRegistrationAccess;
}
public static class System.Security.SecureStringMarshal : object {
    public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
}
internal static class System.SecurityUtils : object {
    private static ReflectionPermission modreq(System.Runtime.CompilerServices.IsVolatile) memberAccessPermission;
    private static ReflectionPermission modreq(System.Runtime.CompilerServices.IsVolatile) restrictedMemberAccessPermission;
    private static ReflectionPermission MemberAccessPermission { get; }
    private static ReflectionPermission RestrictedMemberAccessPermission { get; }
    private static ReflectionPermission get_MemberAccessPermission();
    private static ReflectionPermission get_RestrictedMemberAccessPermission();
    private static void DemandReflectionAccess(Type type);
    [SecuritySafeCriticalAttribute]
private static void DemandGrantSet(Assembly assembly);
    private static bool HasReflectionPermission(Type type);
    internal static object SecureCreateInstance(Type type);
    internal static object SecureCreateInstance(Type type, Object[] args, bool allowNonPublic);
    internal static object SecureCreateInstance(Type type, Object[] args);
    internal static object SecureConstructorInvoke(Type type, Type[] argTypes, Object[] args, bool allowNonPublic);
    internal static object SecureConstructorInvoke(Type type, Type[] argTypes, Object[] args, bool allowNonPublic, BindingFlags extraFlags);
    private static bool GenericArgumentsAreVisible(MethodInfo method);
    internal static object FieldInfoGetValue(FieldInfo field, object target);
    internal static object MethodInfoInvoke(MethodInfo method, object target, Object[] args);
    internal static object ConstructorInfoInvoke(ConstructorInfo ctor, Object[] args);
    internal static object ArrayCreateInstance(Type type, int length);
}
[AttributeUsageAttribute("32767")]
internal class System.SRDescriptionAttribute : DescriptionAttribute {
    private bool isReplaced;
    public string Description { get; }
    public SRDescriptionAttribute(string description);
    public virtual string get_Description();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex);
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex, int length);
}
[ExtensionAttribute]
public static class System.StringNormalizationExtensions : object {
    [ExtensionAttribute]
public static bool IsNormalized(string strInput);
    [ExtensionAttribute]
public static bool IsNormalized(string strInput, NormalizationForm normalizationForm);
    [ExtensionAttribute]
public static string Normalize(string strInput);
    [ExtensionAttribute]
public static string Normalize(string strInput, NormalizationForm normalizationForm);
}
public class System.Text.RegularExpressions.Capture : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public int Index { get; private protected set; }
    public int Length { get; private protected set; }
    internal string Text { get; private protected set; }
    public string Value { get; }
    internal Capture(string text, int index, int length);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private protected void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private protected void set_Length(int value);
    [CompilerGeneratedAttribute]
internal string get_Text();
    [CompilerGeneratedAttribute]
private protected void set_Text(string value);
    public string get_Value();
    public virtual string ToString();
    internal ReadOnlySpan`1<char> GetLeftSubstring();
    internal ReadOnlySpan`1<char> GetRightSubstring();
}
[DebuggerTypeProxyAttribute("System.Text.RegularExpressions.CollectionDebuggerProxy`1<System.Text.RegularExpressions.Capture>")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Text.RegularExpressions.CaptureCollection : object {
    private Group _group;
    private int _capcount;
    private Capture[] _captures;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Capture Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal CaptureCollection(Group group);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual Capture get_Item(int i);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Capture> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Capture>.GetEnumerator();
    private Capture GetCapture(int i);
    internal void ForceInitialized();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Capture[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.IndexOf(Capture item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Insert(int index, Capture item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.RemoveAt(int index);
    private sealed virtual override Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.set_Item(int index, Capture value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Add(Capture item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Contains(Capture item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Remove(Capture item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
internal class System.Text.RegularExpressions.CollectionDebuggerProxy`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public CollectionDebuggerProxy`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Text.RegularExpressions.CompiledRegexRunner : RegexRunner {
    private Action`1<RegexRunner> _goMethod;
    private Func`2<RegexRunner, bool> _findFirstCharMethod;
    private Action`1<RegexRunner> _initTrackCountMethod;
    public void SetDelegates(Action`1<RegexRunner> go, Func`2<RegexRunner, bool> firstChar, Action`1<RegexRunner> trackCount);
    protected virtual void Go();
    protected virtual bool FindFirstChar();
    protected virtual void InitTrackCount();
}
internal class System.Text.RegularExpressions.CompiledRegexRunnerFactory : RegexRunnerFactory {
    private DynamicMethod _goMethod;
    private DynamicMethod _findFirstCharMethod;
    private DynamicMethod _initTrackCountMethod;
    public CompiledRegexRunnerFactory(DynamicMethod go, DynamicMethod firstChar, DynamicMethod trackCount);
    protected internal virtual RegexRunner CreateInstance();
}
internal class System.Text.RegularExpressions.ExclusiveReference : object {
    private RegexRunner _ref;
    private RegexRunner _obj;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _locked;
    public RegexRunner Get();
    public void Release(RegexRunner obj);
}
public class System.Text.RegularExpressions.Group : Capture {
    internal static Group s_emptyGroup;
    internal Int32[] _caps;
    internal int _capcount;
    internal CaptureCollection _capcoll;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool Success { get; }
    public string Name { get; }
    public CaptureCollection Captures { get; }
    internal Group(string text, Int32[] caps, int capcount, string name);
    private static Group();
    public bool get_Success();
    [CompilerGeneratedAttribute]
public string get_Name();
    public CaptureCollection get_Captures();
    public static Group Synchronized(Group inner);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Text.RegularExpressions.CollectionDebuggerProxy`1<System.Text.RegularExpressions.Group>")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Text.RegularExpressions.GroupCollection : object {
    private Match _match;
    private Hashtable _captureMap;
    private Group[] _groups;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Group Item { get; }
    public Group Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal GroupCollection(Match match, Hashtable caps);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual Group get_Item(int groupnum);
    public Group get_Item(string groupname);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Group> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Group>.GetEnumerator();
    private Group GetGroup(int groupnum);
    private Group GetGroupImpl(int groupnum);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Group[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.IndexOf(Group item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Insert(int index, Group item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.RemoveAt(int index);
    private sealed virtual override Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.set_Item(int index, Group value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Add(Group item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Contains(Group item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Remove(Group item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
public class System.Text.RegularExpressions.Match : Group {
    internal GroupCollection _groupcoll;
    internal Regex _regex;
    internal int _textbeg;
    internal int _textpos;
    internal int _textend;
    internal int _textstart;
    internal Int32[][] _matches;
    internal Int32[] _matchcount;
    internal bool _balancing;
    [CompilerGeneratedAttribute]
private static Match <Empty>k__BackingField;
    public static Match Empty { get; }
    public GroupCollection Groups { get; }
    internal Match(Regex regex, int capcount, string text, int begpos, int len, int startpos);
    private static Match();
    [CompilerGeneratedAttribute]
public static Match get_Empty();
    internal virtual void Reset(Regex regex, string text, int textbeg, int textend, int textstart);
    public virtual GroupCollection get_Groups();
    public Match NextMatch();
    public virtual string Result(string replacement);
    internal virtual ReadOnlySpan`1<char> GroupToStringImpl(int groupnum);
    internal ReadOnlySpan`1<char> LastGroupToStringImpl();
    public static Match Synchronized(Match inner);
    internal virtual void AddMatch(int cap, int start, int len);
    internal virtual void BalanceMatch(int cap);
    internal virtual void RemoveMatch(int cap);
    internal virtual bool IsMatched(int cap);
    internal virtual int MatchIndex(int cap);
    internal virtual int MatchLength(int cap);
    internal virtual void Tidy(int textpos);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Text.RegularExpressions.CollectionDebuggerProxy`1<System.Text.RegularExpressions.Match>")]
public class System.Text.RegularExpressions.MatchCollection : object {
    private Regex _regex;
    private List`1<Match> _matches;
    private bool _done;
    private string _input;
    private int _beginning;
    private int _length;
    private int _startat;
    private int _prevlen;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Match Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal MatchCollection(Regex regex, string input, int beginning, int length, int startat);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public virtual Match get_Item(int i);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Match> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Match>.GetEnumerator();
    private Match GetMatch(int i);
    private void EnsureInitialized();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Match[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.IndexOf(Match item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Insert(int index, Match item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.RemoveAt(int index);
    private sealed virtual override Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.set_Item(int index, Match value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Add(Match item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Contains(Match item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Remove(Match item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
public class System.Text.RegularExpressions.MatchEvaluator : MulticastDelegate {
    public MatchEvaluator(object object, IntPtr method);
    public virtual string Invoke(Match match);
    public virtual IAsyncResult BeginInvoke(Match match, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class System.Text.RegularExpressions.MatchSparse : Match {
    internal Hashtable _caps;
    public GroupCollection Groups { get; }
    internal MatchSparse(Regex regex, Hashtable caps, int capcount, string text, int begpos, int len, int startpos);
    public virtual GroupCollection get_Groups();
}
public class System.Text.RegularExpressions.Regex : object {
    private static int CacheDictionarySwitchLimit;
    private static int s_cacheSize;
    private static Dictionary`2<CachedCodeEntryKey, CachedCodeEntry> s_cache;
    private static int s_cacheCount;
    private static CachedCodeEntry s_cacheFirst;
    private static CachedCodeEntry s_cacheLast;
    private static TimeSpan s_maximumMatchTimeout;
    private static string DefaultMatchTimeout_ConfigKeyName;
    internal static TimeSpan s_defaultMatchTimeout;
    public static TimeSpan InfiniteMatchTimeout;
    protected internal TimeSpan internalMatchTimeout;
    internal static int MaxOptionShift;
    protected internal string pattern;
    protected internal RegexOptions roptions;
    protected internal RegexRunnerFactory factory;
    protected internal Hashtable caps;
    protected internal Hashtable capnames;
    protected internal String[] capslist;
    protected internal int capsize;
    internal ExclusiveReference _runnerref;
    internal WeakReference`1<RegexReplacement> _replref;
    internal RegexCode _code;
    internal bool _refsInitialized;
    public static int CacheSize { get; public set; }
    public TimeSpan MatchTimeout { get; }
    [CLSCompliantAttribute("False")]
protected IDictionary Caps { get; protected set; }
    [CLSCompliantAttribute("False")]
protected IDictionary CapNames { get; protected set; }
    public RegexOptions Options { get; }
    public bool RightToLeft { get; }
    private static Regex();
    public Regex(string pattern);
    public Regex(string pattern, RegexOptions options);
    public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout);
    protected Regex(SerializationInfo info, StreamingContext context);
    private Regex(string pattern, RegexOptions options, TimeSpan matchTimeout, bool addToCache);
    public static int get_CacheSize();
    public static void set_CacheSize(int value);
    private CachedCodeEntry GetCachedCode(CachedCodeEntryKey key, bool isToAdd);
    private CachedCodeEntry GetCachedCodeEntryInternal(CachedCodeEntryKey key, bool isToAdd);
    private void FillCacheDictionary();
    private static bool TryGetCacheValue(CachedCodeEntryKey key, CachedCodeEntry& entry);
    private static bool TryGetCacheValueSmall(CachedCodeEntryKey key, CachedCodeEntry& entry);
    private static CachedCodeEntry LookupCachedAndPromote(CachedCodeEntryKey key);
    public static bool IsMatch(string input, string pattern);
    public static bool IsMatch(string input, string pattern, RegexOptions options);
    public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public bool IsMatch(string input);
    public bool IsMatch(string input, int startat);
    public static Match Match(string input, string pattern);
    public static Match Match(string input, string pattern, RegexOptions options);
    public static Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public Match Match(string input);
    public Match Match(string input, int startat);
    public Match Match(string input, int beginning, int length);
    public static MatchCollection Matches(string input, string pattern);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public MatchCollection Matches(string input);
    public MatchCollection Matches(string input, int startat);
    public static string Replace(string input, string pattern, string replacement);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, string replacement);
    public string Replace(string input, string replacement, int count);
    public string Replace(string input, string replacement, int count, int startat);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, MatchEvaluator evaluator);
    public string Replace(string input, MatchEvaluator evaluator, int count);
    public string Replace(string input, MatchEvaluator evaluator, int count, int startat);
    private static string Replace(MatchEvaluator evaluator, Regex regex, string input, int count, int startat);
    public static String[] Split(string input, string pattern);
    public static String[] Split(string input, string pattern, RegexOptions options);
    public static String[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public String[] Split(string input);
    public String[] Split(string input, int count);
    public String[] Split(string input, int count, int startat);
    private static String[] Split(Regex regex, string input, int count, int startat);
    public TimeSpan get_MatchTimeout();
    protected internal static void ValidateMatchTimeout(TimeSpan matchTimeout);
    private static TimeSpan InitDefaultMatchTimeout();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    protected IDictionary get_Caps();
    protected void set_Caps(IDictionary value);
    protected IDictionary get_CapNames();
    protected void set_CapNames(IDictionary value);
    private RegexRunnerFactory Compile(RegexCode code, RegexOptions roptions);
    public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname);
    public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes);
    public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile);
    public static string Escape(string str);
    public static string Unescape(string str);
    public RegexOptions get_Options();
    public bool get_RightToLeft();
    public virtual string ToString();
    public String[] GetGroupNames();
    public Int32[] GetGroupNumbers();
    public string GroupNameFromNumber(int i);
    public int GroupNumberFromName(string name);
    protected void InitializeReferences();
    internal Match Run(bool quick, int prevlen, string input, int beginning, int length, int startat);
    protected bool UseOptionC();
    protected internal bool UseOptionR();
    internal bool UseOptionInvariant();
}
internal class System.Text.RegularExpressions.RegexBoyerMoore : object {
    public Int32[] Positive;
    public Int32[] NegativeASCII;
    public Int32[][] NegativeUnicode;
    public string Pattern;
    public int LowASCII;
    public int HighASCII;
    public bool RightToLeft;
    public bool CaseInsensitive;
    private CultureInfo _culture;
    public RegexBoyerMoore(string pattern, bool caseInsensitive, bool rightToLeft, CultureInfo culture);
    private bool MatchPattern(string text, int index);
    public bool IsMatch(string text, int index, int beglimit, int endlimit);
    public int Scan(string text, int index, int beglimit, int endlimit);
}
internal class System.Text.RegularExpressions.RegexCharClass : object {
    private static int FLAGS;
    private static int SETLENGTH;
    private static int CATEGORYLENGTH;
    private static int SETSTART;
    private static string NullCharString;
    private static char NullChar;
    private static char LastChar;
    private static char GroupChar;
    private static short SpaceConst;
    private static short NotSpaceConst;
    private static char ZeroWidthJoiner;
    private static char ZeroWidthNonJoiner;
    private static string s_internalRegexIgnoreCase;
    private static string s_space;
    private static string s_notSpace;
    private static string s_word;
    private static string s_notWord;
    public static string SpaceClass;
    public static string NotSpaceClass;
    public static string WordClass;
    public static string NotWordClass;
    public static string DigitClass;
    public static string NotDigitClass;
    private static string ECMASpaceSet;
    private static string NotECMASpaceSet;
    private static string ECMAWordSet;
    private static string NotECMAWordSet;
    private static string ECMADigitSet;
    private static string NotECMADigitSet;
    public static string ECMASpaceClass;
    public static string NotECMASpaceClass;
    public static string ECMAWordClass;
    public static string NotECMAWordClass;
    public static string ECMADigitClass;
    public static string NotECMADigitClass;
    public static string AnyClass;
    public static string EmptyClass;
    private static int DefinedCategoriesCapacity;
    private static Dictionary`2<string, string> s_definedCategories;
    private static String[][] s_propTable;
    private static int LowercaseSet;
    private static int LowercaseAdd;
    private static int LowercaseBor;
    private static int LowercaseBad;
    private static LowerCaseMapping[] s_lcTable;
    private List`1<SingleRange> _rangelist;
    private StringBuilder _categories;
    private bool _canonical;
    private bool _negate;
    private RegexCharClass _subtractor;
    public bool CanMerge { get; }
    unknown bool Negate {public set; }
    private RegexCharClass(bool negate, List`1<SingleRange> ranges, StringBuilder categories, RegexCharClass subtraction);
    private static RegexCharClass();
    public bool get_CanMerge();
    public void set_Negate(bool value);
    public void AddChar(char c);
    public void AddCharClass(RegexCharClass cc);
    private void AddSet(string set);
    public void AddSubtraction(RegexCharClass sub);
    public void AddRange(char first, char last);
    public void AddCategoryFromName(string categoryName, bool invert, bool caseInsensitive, string pattern);
    private void AddCategory(string category);
    public void AddLowercase(CultureInfo culture);
    private void AddLowercaseRange(char chMin, char chMax, CultureInfo culture);
    public void AddWord(bool ecma, bool negate);
    public void AddSpace(bool ecma, bool negate);
    public void AddDigit(bool ecma, bool negate, string pattern);
    public static string ConvertOldStringsToClass(string set, string category);
    public static char SingletonChar(string set);
    public static bool IsMergeable(string charClass);
    public static bool IsEmpty(string charClass);
    public static bool IsSingleton(string set);
    public static bool IsSingletonInverse(string set);
    private static bool IsSubtraction(string charClass);
    private static bool IsNegated(string set);
    public static bool IsECMAWordChar(char ch);
    public static bool IsWordChar(char ch);
    public static bool CharInClass(char ch, string set);
    private static bool CharInClassRecursive(char ch, string set, int start);
    private static bool CharInClassInternal(char ch, string set, int start, int mySetLength, int myCategoryLength);
    private static bool CharInCategory(char ch, string set, int start, int mySetLength, int myCategoryLength);
    private static bool CharInCategoryGroup(char ch, UnicodeCategory chcategory, string category, Int32& i);
    private static string NegateCategory(string category);
    public static RegexCharClass Parse(string charClass);
    private static RegexCharClass ParseRecursive(string charClass, int start);
    private int RangeCount();
    public string ToStringClass();
    private SingleRange GetRangeAt(int i);
    private void Canonicalize();
    private static string SetFromProperty(string capname, bool invert, string pattern);
}
internal class System.Text.RegularExpressions.RegexCode : object {
    public static int Onerep;
    public static int Notonerep;
    public static int Setrep;
    public static int Oneloop;
    public static int Notoneloop;
    public static int Setloop;
    public static int Onelazy;
    public static int Notonelazy;
    public static int Setlazy;
    public static int One;
    public static int Notone;
    public static int Set;
    public static int Multi;
    public static int Ref;
    public static int Bol;
    public static int Eol;
    public static int Boundary;
    public static int Nonboundary;
    public static int Beginning;
    public static int Start;
    public static int EndZ;
    public static int End;
    public static int Nothing;
    public static int Lazybranch;
    public static int Branchmark;
    public static int Lazybranchmark;
    public static int Nullcount;
    public static int Setcount;
    public static int Branchcount;
    public static int Lazybranchcount;
    public static int Nullmark;
    public static int Setmark;
    public static int Capturemark;
    public static int Getmark;
    public static int Setjump;
    public static int Backjump;
    public static int Forejump;
    public static int Testref;
    public static int Goto;
    public static int Prune;
    public static int Stop;
    public static int ECMABoundary;
    public static int NonECMABoundary;
    public static int Mask;
    public static int Rtl;
    public static int Back;
    public static int Back2;
    public static int Ci;
    public Int32[] Codes;
    public String[] Strings;
    public int TrackCount;
    public Hashtable Caps;
    public int CapSize;
    public Nullable`1<RegexPrefix> FCPrefix;
    public RegexBoyerMoore BMPrefix;
    public int Anchors;
    public bool RightToLeft;
    public RegexCode(Int32[] codes, List`1<string> stringlist, int trackcount, Hashtable caps, int capsize, RegexBoyerMoore bmPrefix, Nullable`1<RegexPrefix> fcPrefix, int anchors, bool rightToLeft);
    public static bool OpcodeBacktracks(int Op);
    public static int OpcodeSize(int opcode);
}
public class System.Text.RegularExpressions.RegexCompilationInfo : object {
    private string _pattern;
    private string _name;
    private string _nspace;
    private TimeSpan _matchTimeout;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexOptions <Options>k__BackingField;
    public bool IsPublic { get; public set; }
    public TimeSpan MatchTimeout { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public RegexOptions Options { get; public set; }
    public string Pattern { get; public set; }
    public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic);
    public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic, TimeSpan matchTimeout);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public void set_IsPublic(bool value);
    public TimeSpan get_MatchTimeout();
    public void set_MatchTimeout(TimeSpan value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public RegexOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(RegexOptions value);
    public string get_Pattern();
    public void set_Pattern(string value);
}
internal abstract class System.Text.RegularExpressions.RegexCompiler : object {
    private static FieldInfo s_textbegF;
    private static FieldInfo s_textendF;
    private static FieldInfo s_textstartF;
    private static FieldInfo s_textposF;
    private static FieldInfo s_textF;
    private static FieldInfo s_trackposF;
    private static FieldInfo s_trackF;
    private static FieldInfo s_stackposF;
    private static FieldInfo s_stackF;
    private static FieldInfo s_trackcountF;
    private static MethodInfo s_ensurestorageM;
    private static MethodInfo s_captureM;
    private static MethodInfo s_transferM;
    private static MethodInfo s_uncaptureM;
    private static MethodInfo s_ismatchedM;
    private static MethodInfo s_matchlengthM;
    private static MethodInfo s_matchindexM;
    private static MethodInfo s_isboundaryM;
    private static MethodInfo s_isECMABoundaryM;
    private static MethodInfo s_chartolowerM;
    private static MethodInfo s_getcharM;
    private static MethodInfo s_crawlposM;
    private static MethodInfo s_charInSetM;
    private static MethodInfo s_getCurrentCulture;
    private static MethodInfo s_getInvariantCulture;
    private static MethodInfo s_checkTimeoutM;
    protected ILGenerator _ilg;
    private LocalBuilder _textstartV;
    private LocalBuilder _textbegV;
    private LocalBuilder _textendV;
    private LocalBuilder _textposV;
    private LocalBuilder _textV;
    private LocalBuilder _trackposV;
    private LocalBuilder _trackV;
    private LocalBuilder _stackposV;
    private LocalBuilder _stackV;
    private LocalBuilder _tempV;
    private LocalBuilder _temp2V;
    private LocalBuilder _temp3V;
    protected RegexCode _code;
    protected Int32[] _codes;
    protected String[] _strings;
    protected Nullable`1<RegexPrefix> _fcPrefix;
    protected RegexBoyerMoore _bmPrefix;
    protected int _anchors;
    private Label[] _labels;
    private BacktrackNote[] _notes;
    private int _notecount;
    protected int _trackcount;
    private Label _backtrack;
    private int _regexopcode;
    private int _codepos;
    private int _backpos;
    protected RegexOptions _options;
    private Int32[] _uniquenote;
    private Int32[] _goto;
    private static int Stackpop;
    private static int Stackpop2;
    private static int Stackpop3;
    private static int Capback;
    private static int Capback2;
    private static int Branchmarkback2;
    private static int Lazybranchmarkback2;
    private static int Branchcountback2;
    private static int Lazybranchcountback2;
    private static int Forejumpback;
    private static int Uniquecount;
    private static RegexCompiler();
    private static FieldInfo RegexRunnerField(string fieldname);
    private static MethodInfo RegexRunnerMethod(string methname);
    internal static RegexRunnerFactory Compile(RegexCode code, RegexOptions options);
    private int AddBacktrackNote(int flags, Label l, int codepos);
    private int AddTrack();
    private int AddTrack(int flags);
    private int AddGoto(int destpos);
    private int AddUniqueTrack(int i);
    private int AddUniqueTrack(int i, int flags);
    private Label DefineLabel();
    private void MarkLabel(Label l);
    private int Operand(int i);
    private bool IsRtl();
    private bool IsCi();
    private int Code();
    private void Ldstr(string str);
    private void Ldc(int i);
    private void LdcI8(long i);
    private void Dup();
    private void Ret();
    private void Pop();
    private void Add();
    private void Add(bool negate);
    private void Sub();
    private void Sub(bool negate);
    private void Ldloc(LocalBuilder lt);
    private void Stloc(LocalBuilder lt);
    private void Ldthis();
    private void Ldthisfld(FieldInfo ft);
    private void Mvfldloc(FieldInfo ft, LocalBuilder lt);
    private void Mvlocfld(LocalBuilder lt, FieldInfo ft);
    private void Stfld(FieldInfo ft);
    private void Callvirt(MethodInfo mt);
    private void Call(MethodInfo mt);
    private void Newobj(ConstructorInfo ct);
    private void BrfalseFar(Label l);
    private void BrtrueFar(Label l);
    private void BrFar(Label l);
    private void BleFar(Label l);
    private void BltFar(Label l);
    private void BgeFar(Label l);
    private void BgtFar(Label l);
    private void BneFar(Label l);
    private void BeqFar(Label l);
    private void Brfalse(Label l);
    private void Br(Label l);
    private void Ble(Label l);
    private void Blt(Label l);
    private void Bge(Label l);
    private void Bgt(Label l);
    private void Bgtun(Label l);
    private void Bne(Label l);
    private void Beq(Label l);
    private void Ldlen();
    private void Rightchar();
    private void Rightcharnext();
    private void Leftchar();
    private void Leftcharnext();
    private void Track();
    private void Trackagain();
    private void PushTrack(LocalBuilder lt);
    private void TrackUnique(int i);
    private void TrackUnique2(int i);
    private void ReadyPushTrack();
    private void PopTrack();
    private void TopTrack();
    private void PushStack(LocalBuilder lt);
    internal void ReadyReplaceStack(int i);
    private void ReadyPushStack();
    private void TopStack();
    private void PopStack();
    private void PopDiscardStack();
    private void PopDiscardStack(int i);
    private void DoReplace();
    private void DoPush();
    private void Back();
    private void Goto(int i);
    private int NextCodepos();
    private Label AdvanceLabel();
    private void Advance();
    private void CallToLower();
    private void GenerateForwardSection();
    private void GenerateMiddleSection();
    private void GenerateBacktrackSection();
    protected void GenerateFindFirstChar();
    protected void GenerateInitTrackCount();
    private LocalBuilder DeclareInt();
    private LocalBuilder DeclareIntArray();
    private LocalBuilder DeclareString();
    protected void GenerateGo();
    private void GenerateOneCode();
}
internal class System.Text.RegularExpressions.RegexFC : object {
    private RegexCharClass _cc;
    public bool _nullable;
    [CompilerGeneratedAttribute]
private bool <CaseInsensitive>k__BackingField;
    public bool CaseInsensitive { get; private set; }
    public RegexFC(bool nullable);
    public RegexFC(char ch, bool not, bool nullable, bool caseInsensitive);
    public RegexFC(string charClass, bool nullable, bool caseInsensitive);
    public bool AddFC(RegexFC fc, bool concatenate);
    [CompilerGeneratedAttribute]
public bool get_CaseInsensitive();
    [CompilerGeneratedAttribute]
private void set_CaseInsensitive(bool value);
    public string GetFirstChars(CultureInfo culture);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Text.RegularExpressions.RegexFCD : ValueType {
    private static int StackBufferSize;
    private static int BeforeChild;
    private static int AfterChild;
    public static int Beginning;
    public static int Bol;
    public static int Start;
    public static int Eol;
    public static int EndZ;
    public static int End;
    public static int Boundary;
    public static int ECMABoundary;
    private List`1<RegexFC> _fcStack;
    private ValueListBuilder`1<int> _intStack;
    private bool _skipAllChildren;
    private bool _skipchild;
    private bool _failed;
    private RegexFCD(Span`1<int> intStack);
    public static Nullable`1<RegexPrefix> FirstChars(RegexTree t);
    public static RegexPrefix Prefix(RegexTree tree);
    public static int Anchors(RegexTree tree);
    private static int AnchorFromType(int type);
    private void PushInt(int i);
    private bool IntIsEmpty();
    private int PopInt();
    private void PushFC(RegexFC fc);
    private bool FCIsEmpty();
    private RegexFC PopFC();
    private RegexFC TopFC();
    public void Dispose();
    private RegexFC RegexFCFromRegexTree(RegexTree tree);
    private void SkipChild();
    private void CalculateFC(int NodeType, RegexNode node, int CurIndex);
}
internal class System.Text.RegularExpressions.RegexInterpreter : RegexRunner {
    private RegexCode _code;
    private CultureInfo _culture;
    private int _operator;
    private int _codepos;
    private bool _rightToLeft;
    private bool _caseInsensitive;
    public RegexInterpreter(RegexCode code, CultureInfo culture);
    protected virtual void InitTrackCount();
    private void Advance(int i);
    private void Goto(int newpos);
    private void Textto(int newpos);
    private void Trackto(int newpos);
    private int Textstart();
    private int Textpos();
    private int Trackpos();
    private void TrackPush();
    private void TrackPush(int I1);
    private void TrackPush(int I1, int I2);
    private void TrackPush(int I1, int I2, int I3);
    private void TrackPush2(int I1);
    private void TrackPush2(int I1, int I2);
    private void Backtrack();
    private void SetOperator(int op);
    private void TrackPop();
    private void TrackPop(int framesize);
    private int TrackPeek();
    private int TrackPeek(int i);
    private void StackPush(int I1);
    private void StackPush(int I1, int I2);
    private void StackPop();
    private void StackPop(int framesize);
    private int StackPeek();
    private int StackPeek(int i);
    private int Operator();
    private int Operand(int i);
    private int Leftchars();
    private int Rightchars();
    private int Bump();
    private int Forwardchars();
    private char Forwardcharnext();
    private bool Stringmatch(string str);
    private bool Refmatch(int index, int len);
    private void Backwardnext();
    private char CharAt(int j);
    protected virtual bool FindFirstChar();
    protected virtual void Go();
}
internal class System.Text.RegularExpressions.RegexLWCGCompiler : RegexCompiler {
    private static int s_regexCount;
    private static Type[] s_paramTypes;
    private static RegexLWCGCompiler();
    public RegexRunnerFactory FactoryInstanceFromCode(RegexCode code, RegexOptions options);
    public DynamicMethod DefineDynamicMethod(string methname, Type returntype, Type hostType);
}
public class System.Text.RegularExpressions.RegexMatchTimeoutException : TimeoutException {
    [CompilerGeneratedAttribute]
private string <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MatchTimeout>k__BackingField;
    public string Input { get; }
    public string Pattern { get; }
    public TimeSpan MatchTimeout { get; }
    public RegexMatchTimeoutException(string regexInput, string regexPattern, TimeSpan matchTimeout);
    public RegexMatchTimeoutException(string message);
    public RegexMatchTimeoutException(string message, Exception inner);
    protected RegexMatchTimeoutException(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Input();
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public TimeSpan get_MatchTimeout();
}
internal class System.Text.RegularExpressions.RegexNode : object {
    public static int Oneloop;
    public static int Notoneloop;
    public static int Setloop;
    public static int Onelazy;
    public static int Notonelazy;
    public static int Setlazy;
    public static int One;
    public static int Notone;
    public static int Set;
    public static int Multi;
    public static int Ref;
    public static int Bol;
    public static int Eol;
    public static int Boundary;
    public static int Nonboundary;
    public static int ECMABoundary;
    public static int NonECMABoundary;
    public static int Beginning;
    public static int Start;
    public static int EndZ;
    public static int End;
    public static int Nothing;
    public static int Empty;
    public static int Alternate;
    public static int Concatenate;
    public static int Loop;
    public static int Lazyloop;
    public static int Capture;
    public static int Group;
    public static int Require;
    public static int Prevent;
    public static int Greedy;
    public static int Testref;
    public static int Testgroup;
    public int NType;
    public List`1<RegexNode> Children;
    public string Str;
    public char Ch;
    public int M;
    public int N;
    public RegexOptions Options;
    public RegexNode Next;
    public RegexNode(int type, RegexOptions options);
    public RegexNode(int type, RegexOptions options, char ch);
    public RegexNode(int type, RegexOptions options, string str);
    public RegexNode(int type, RegexOptions options, int m);
    public RegexNode(int type, RegexOptions options, int m, int n);
    public bool UseOptionR();
    public RegexNode ReverseLeft();
    private void MakeRep(int type, int min, int max);
    private RegexNode Reduce();
    private RegexNode StripEnation(int emptyType);
    private RegexNode ReduceGroup();
    private RegexNode ReduceRep();
    private RegexNode ReduceSet();
    private RegexNode ReduceAlternation();
    private RegexNode ReduceConcatenation();
    public RegexNode MakeQuantifier(bool lazy, int min, int max);
    public void AddChild(RegexNode newChild);
    public RegexNode Child(int i);
    public int ChildCount();
    public int Type();
}
[FlagsAttribute]
public enum System.Text.RegularExpressions.RegexOptions : Enum {
    public int value__;
    public static RegexOptions None;
    public static RegexOptions IgnoreCase;
    public static RegexOptions Multiline;
    public static RegexOptions ExplicitCapture;
    public static RegexOptions Compiled;
    public static RegexOptions Singleline;
    public static RegexOptions IgnorePatternWhitespace;
    public static RegexOptions RightToLeft;
    public static RegexOptions ECMAScript;
    public static RegexOptions CultureInvariant;
}
internal class System.Text.RegularExpressions.RegexParser : object {
    private static int MaxValueDiv10;
    private static int MaxValueMod10;
    private RegexNode _stack;
    private RegexNode _group;
    private RegexNode _alternation;
    private RegexNode _concatenation;
    private RegexNode _unit;
    private string _pattern;
    private int _currentPos;
    private CultureInfo _culture;
    private int _autocap;
    private int _capcount;
    private int _captop;
    private int _capsize;
    private Hashtable _caps;
    private Hashtable _capnames;
    private Int32[] _capnumlist;
    private List`1<string> _capnamelist;
    private RegexOptions _options;
    private List`1<RegexOptions> _optionsStack;
    private bool _ignoreNextParen;
    private static byte Q;
    private static byte S;
    private static byte Z;
    private static byte X;
    private static byte E;
    private static Byte[] s_category;
    private RegexParser(CultureInfo culture);
    private static RegexParser();
    public static RegexTree Parse(string re, RegexOptions op);
    public static RegexReplacement ParseReplacement(string rep, Hashtable caps, int capsize, Hashtable capnames, RegexOptions op);
    public static string Escape(string input);
    public static string Unescape(string input);
    private void SetPattern(string Re);
    private void Reset(RegexOptions topopts);
    private RegexNode ScanRegex();
    private RegexNode ScanReplacement();
    private RegexCharClass ScanCharClass(bool caseInsensitive, bool scanOnly);
    private RegexNode ScanGroupOpen();
    private void ScanBlank();
    private RegexNode ScanBackslash(bool scanOnly);
    private RegexNode ScanBasicBackslash(bool scanOnly);
    private RegexNode ScanDollar();
    private string ScanCapname();
    private char ScanOctal();
    private int ScanDecimal();
    private char ScanHex(int c);
    private static int HexDigit(char ch);
    private char ScanControl();
    private bool IsOnlyTopOption(RegexOptions option);
    private void ScanOptions();
    private char ScanCharEscape();
    private string ParseProperty();
    private int TypeFromCode(char ch);
    private static RegexOptions OptionFromCode(char ch);
    private void CountCaptures();
    private void NoteCaptureSlot(int i, int pos);
    private void NoteCaptureName(string name, int pos);
    private void NoteCaptures(Hashtable caps, int capsize, Hashtable capnames);
    private void AssignNameSlots();
    private int CaptureSlotFromName(string capname);
    private bool IsCaptureSlot(int i);
    private bool IsCaptureName(string capname);
    private bool UseOptionN();
    private bool UseOptionI();
    private bool UseOptionM();
    private bool UseOptionS();
    private bool UseOptionX();
    private bool UseOptionE();
    private static bool IsSpecial(char ch);
    private static bool IsStopperX(char ch);
    private static bool IsQuantifier(char ch);
    private bool IsTrueQuantifier();
    private static bool IsSpace(char ch);
    private static bool IsMetachar(char ch);
    private void AddConcatenate(int pos, int cch, bool isReplacement);
    private void PushGroup();
    private void PopGroup();
    private bool EmptyStack();
    private void StartGroup(RegexNode openGroup);
    private void AddAlternate();
    private void AddConcatenate();
    private void AddConcatenate(bool lazy, int min, int max);
    private RegexNode Unit();
    private void AddUnitOne(char ch);
    private void AddUnitNotone(char ch);
    private void AddUnitSet(string cc);
    private void AddUnitNode(RegexNode node);
    private void AddUnitType(int type);
    private void AddGroup();
    private void PushOptions();
    private void PopOptions();
    private bool EmptyOptionsStack();
    private void PopKeepOptions();
    private ArgumentException MakeException(string message);
    private int Textpos();
    private void Textto(int pos);
    private char RightCharMoveRight();
    private void MoveRight();
    private void MoveRight(int i);
    private void MoveLeft();
    private char CharAt(int i);
    internal char RightChar();
    private char RightChar(int i);
    private int CharsRight();
}
[IsReadOnlyAttribute]
internal class System.Text.RegularExpressions.RegexPrefix : ValueType {
    [CompilerGeneratedAttribute]
private bool <CaseInsensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private static RegexPrefix <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    internal bool CaseInsensitive { get; }
    internal static RegexPrefix Empty { get; }
    internal string Prefix { get; }
    internal RegexPrefix(string prefix, bool ci);
    private static RegexPrefix();
    [CompilerGeneratedAttribute]
internal bool get_CaseInsensitive();
    [CompilerGeneratedAttribute]
internal static RegexPrefix get_Empty();
    [CompilerGeneratedAttribute]
internal string get_Prefix();
}
internal class System.Text.RegularExpressions.RegexReplacement : object {
    private static int Specials;
    public static int LeftPortion;
    public static int RightPortion;
    public static int LastGroup;
    public static int WholeString;
    private List`1<string> _strings;
    private List`1<int> _rules;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public string Pattern { get; }
    public RegexReplacement(string rep, RegexNode concat, Hashtable _caps);
    public static RegexReplacement GetOrCreate(WeakReference`1<RegexReplacement> replRef, string replacement, Hashtable caps, int capsize, Hashtable capnames, RegexOptions roptions);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    private void ReplacementImpl(StringBuilder sb, Match match);
    private void ReplacementImplRTL(List`1<string> al, Match match);
    public string Replacement(Match match);
    public string Replace(Regex regex, string input, int count, int startat);
}
public abstract class System.Text.RegularExpressions.RegexRunner : object {
    protected internal int runtextbeg;
    protected internal int runtextend;
    protected internal int runtextstart;
    protected internal string runtext;
    protected internal int runtextpos;
    protected internal Int32[] runtrack;
    protected internal int runtrackpos;
    protected internal Int32[] runstack;
    protected internal int runstackpos;
    protected internal Int32[] runcrawl;
    protected internal int runcrawlpos;
    protected internal int runtrackcount;
    protected internal Match runmatch;
    protected internal Regex runregex;
    private int _timeout;
    private bool _ignoreTimeout;
    private int _timeoutOccursAt;
    private static int TimeoutCheckFrequency;
    private int _timeoutChecksToSkip;
    protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick);
    protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, TimeSpan timeout);
    private void StartTimeoutWatch();
    protected void CheckTimeout();
    private void DoCheckTimeout();
    protected abstract virtual void Go();
    protected abstract virtual bool FindFirstChar();
    protected abstract virtual void InitTrackCount();
    private void InitMatch();
    private Match TidyMatch(bool quick);
    protected void EnsureStorage();
    protected bool IsBoundary(int index, int startpos, int endpos);
    protected bool IsECMABoundary(int index, int startpos, int endpos);
    protected static bool CharInSet(char ch, string set, string category);
    protected static bool CharInClass(char ch, string charClass);
    protected void DoubleTrack();
    protected void DoubleStack();
    protected void DoubleCrawl();
    protected void Crawl(int i);
    protected int Popcrawl();
    protected int Crawlpos();
    protected void Capture(int capnum, int start, int end);
    protected void TransferCapture(int capnum, int uncapnum, int start, int end);
    protected void Uncapture();
    protected bool IsMatched(int cap);
    protected int MatchIndex(int cap);
    protected int MatchLength(int cap);
}
public abstract class System.Text.RegularExpressions.RegexRunnerFactory : object {
    protected internal abstract virtual RegexRunner CreateInstance();
}
internal class System.Text.RegularExpressions.RegexTree : object {
    public RegexNode Root;
    public Hashtable Caps;
    public Int32[] CapNumList;
    public int CapTop;
    public Hashtable CapNames;
    public String[] CapsList;
    public RegexOptions Options;
    internal RegexTree(RegexNode root, Hashtable caps, Int32[] capNumList, int capTop, Hashtable capNames, String[] capsList, RegexOptions options);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Text.RegularExpressions.RegexWriter : ValueType {
    private static int BeforeChild;
    private static int AfterChild;
    private static int EmittedSize;
    private static int IntStackSize;
    private ValueListBuilder`1<int> _emitted;
    private ValueListBuilder`1<int> _intStack;
    private Dictionary`2<string, int> _stringHash;
    private List`1<string> _stringTable;
    private Hashtable _caps;
    private int _trackCount;
    private RegexWriter(Span`1<int> emittedSpan, Span`1<int> intStackSpan);
    public static RegexCode Write(RegexTree tree);
    public void Dispose();
    public RegexCode RegexCodeFromRegexTree(RegexTree tree);
    private void PatchJump(int offset, int jumpDest);
    private void Emit(int op);
    private void Emit(int op, int opd1);
    private void Emit(int op, int opd1, int opd2);
    private int StringCode(string str);
    private int MapCapnum(int capnum);
    private void EmitFragment(int nodetype, RegexNode node, int curIndex);
}
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Participant Count={ParticipantCount},Participants Remaining={ParticipantsRemaining}")]
public class System.Threading.Barrier : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentTotalCount;
    private static int CURRENT_MASK;
    private static int TOTAL_MASK;
    private static int SENSE_MASK;
    private static int MAX_PARTICIPANTS;
    private long m_currentPhase;
    private bool m_disposed;
    private ManualResetEventSlim m_oddEvent;
    private ManualResetEventSlim m_evenEvent;
    private ExecutionContext m_ownerThreadContext;
    [SecurityCriticalAttribute]
private static ContextCallback s_invokePostPhaseAction;
    private Action`1<Barrier> m_postPhaseAction;
    private Exception m_exception;
    private int m_actionCallerID;
    public int ParticipantsRemaining { get; }
    public int ParticipantCount { get; }
    public long CurrentPhaseNumber { get; internal set; }
    public Barrier(int participantCount);
    public Barrier(int participantCount, Action`1<Barrier> postPhaseAction);
    public int get_ParticipantsRemaining();
    public int get_ParticipantCount();
    public long get_CurrentPhaseNumber();
    internal void set_CurrentPhaseNumber(long value);
    private void GetCurrentTotal(int currentTotal, Int32& current, Int32& total, Boolean& sense);
    private bool SetCurrentTotal(int currentTotal, int current, int total, bool sense);
    public long AddParticipant();
    public long AddParticipants(int participantCount);
    public void RemoveParticipant();
    public void RemoveParticipants(int participantCount);
    public void SignalAndWait();
    public void SignalAndWait(CancellationToken cancellationToken);
    public bool SignalAndWait(TimeSpan timeout);
    public bool SignalAndWait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool SignalAndWait(int millisecondsTimeout);
    public bool SignalAndWait(int millisecondsTimeout, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
private void FinishPhase(bool observedSense);
    [SecurityCriticalAttribute]
private static void InvokePostPhaseAction(object obj);
    private void SetResetEvents(bool observedSense);
    private void WaitCurrentPhase(ManualResetEventSlim currentPhaseEvent, long observedPhase);
    private bool DiscontinuousWait(ManualResetEventSlim currentPhaseEvent, int totalTimeout, CancellationToken token, long observedPhase);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
}
public class System.Threading.BarrierPostPhaseException : Exception {
    public BarrierPostPhaseException(Exception innerException);
    public BarrierPostPhaseException(string message);
    public BarrierPostPhaseException(string message, Exception innerException);
    [SecurityCriticalAttribute]
protected BarrierPostPhaseException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("False")]
public class System.Threading.Semaphore : WaitHandle {
    private static int MAX_PATH;
    [SecuritySafeCriticalAttribute]
public Semaphore(int initialCount, int maximumCount);
    public Semaphore(int initialCount, int maximumCount, string name);
    public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew, SemaphoreSecurity semaphoreSecurity);
    private Semaphore(SafeWaitHandle handle);
    public static Semaphore OpenExisting(string name);
    public static Semaphore OpenExisting(string name, SemaphoreRights rights);
    public static bool TryOpenExisting(string name, Semaphore& result);
    public static bool TryOpenExisting(string name, SemaphoreRights rights, Semaphore& result);
    private static OpenExistingResult OpenExistingWorker(string name, SemaphoreRights rights, Semaphore& result);
    [ReliabilityContractAttribute("3", "2")]
[PrePrepareMethodAttribute]
public int Release();
    [ReliabilityContractAttribute("3", "2")]
public int Release(int releaseCount);
    public SemaphoreSecurity GetAccessControl();
    public void SetAccessControl(SemaphoreSecurity semaphoreSecurity);
    internal static IntPtr CreateSemaphore_internal(int initialCount, int maximumCount, string name, Int32& errorCode);
    private static IntPtr OpenSemaphore_internal(string name, SemaphoreRights rights, Int32& errorCode);
    private static IntPtr CreateSemaphore_icall(int initialCount, int maximumCount, Char* name, int name_length, Int32& errorCode);
    private static IntPtr OpenSemaphore_icall(Char* name, int name_length, SemaphoreRights rights, Int32& errorCode);
    internal static bool ReleaseSemaphore_internal(IntPtr handle, int releaseCount, Int32& previousCount);
}
public class System.Threading.ThreadExceptionEventArgs : EventArgs {
    private Exception exception;
    public Exception Exception { get; }
    public ThreadExceptionEventArgs(Exception t);
    public Exception get_Exception();
}
public class System.Threading.ThreadExceptionEventHandler : MulticastDelegate {
    public ThreadExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ThreadExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ThreadExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Timers.ElapsedEventArgs : EventArgs {
    private DateTime time;
    public DateTime SignalTime { get; }
    internal ElapsedEventArgs(DateTime time);
    public DateTime get_SignalTime();
}
public class System.Timers.ElapsedEventHandler : MulticastDelegate {
    public ElapsedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ElapsedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ElapsedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultPropertyAttribute("Interval")]
[DefaultEventAttribute("Elapsed")]
public class System.Timers.Timer : Component {
    private double interval;
    private bool enabled;
    private bool initializing;
    private bool delayedEnable;
    private ElapsedEventHandler onIntervalElapsed;
    private bool autoReset;
    private ISynchronizeInvoke synchronizingObject;
    private bool disposed;
    private Timer timer;
    private TimerCallback callback;
    private object cookie;
    [TimersDescriptionAttribute("Indicates whether the timer will be restarted when it is enabled.")]
[CategoryAttribute("Behavior")]
[DefaultValueAttribute("True")]
public bool AutoReset { get; public set; }
    [DefaultValueAttribute("False")]
[CategoryAttribute("Behavior")]
[TimersDescriptionAttribute("Indicates whether the timer is enabled to fire events at a defined interval.")]
public bool Enabled { get; public set; }
    [CategoryAttribute("Behavior")]
[TimersDescriptionAttribute("The number of milliseconds between timer events.")]
[DefaultValueAttribute("100")]
[SettingsBindableAttribute("True")]
public double Interval { get; public set; }
    public ISite Site { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[TimersDescriptionAttribute("The object used to marshal the event handler calls issued when an interval has elapsed.")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public Timer(double interval);
    public bool get_AutoReset();
    public void set_AutoReset(bool value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    private static int CalculateRoundedInterval(double interval, bool argumentCheck);
    private void UpdateTimer();
    public double get_Interval();
    public void set_Interval(double value);
    public void add_Elapsed(ElapsedEventHandler value);
    public void remove_Elapsed(ElapsedEventHandler value);
    public virtual void set_Site(ISite value);
    public virtual ISite get_Site();
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public sealed virtual void BeginInit();
    public void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    public void Start();
    public void Stop();
    private void MyTimerCallback(object state);
}
[AttributeUsageAttribute("32767")]
public class System.Timers.TimersDescriptionAttribute : DescriptionAttribute {
    private bool replaced;
    public string Description { get; }
    public TimersDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal class System.UncNameHelper : object {
    internal static int MaximumInternetNameLength;
    internal static string ParseCanonicalName(string str, int start, int end, Boolean& loopback);
    internal static bool IsValid(Char* name, ushort start, Int32& returnedEnd, bool notImplicitFile);
}
[FlagsAttribute]
internal enum System.UnescapeMode : Enum {
    public int value__;
    public static UnescapeMode CopyOnly;
    public static UnescapeMode Escape;
    public static UnescapeMode Unescape;
    public static UnescapeMode EscapeUnescape;
    public static UnescapeMode V1ToStringFlag;
    public static UnescapeMode UnescapeAll;
    public static UnescapeMode UnescapeAllOrThrow;
}
[TypeConverterAttribute("System.UriTypeConverter")]
public class System.Uri : object {
    public static string UriSchemeFile;
    public static string UriSchemeFtp;
    public static string UriSchemeGopher;
    public static string UriSchemeHttp;
    public static string UriSchemeHttps;
    internal static string UriSchemeWs;
    internal static string UriSchemeWss;
    public static string UriSchemeMailto;
    public static string UriSchemeNews;
    public static string UriSchemeNntp;
    public static string UriSchemeNetTcp;
    public static string UriSchemeNetPipe;
    public static string SchemeDelimiter;
    private static int c_Max16BitUtf8SequenceLength;
    internal static int c_MaxUriBufferSize;
    private static int c_MaxUriSchemeName;
    private string m_String;
    private string m_originalUnicodeString;
    private UriParser m_Syntax;
    private string m_DnsSafeHost;
    private Flags m_Flags;
    private UriInfo m_Info;
    private bool m_iriParsing;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_ConfigInitialized;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_ConfigInitializing;
    private static UriIdnScope modreq(System.Runtime.CompilerServices.IsVolatile) s_IdnScope;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_IriParsing;
    private static bool useDotNetRelativeOrAbsolute;
    private static UriKind DotNetRelativeOrAbsolute;
    internal static bool IsWindowsFileSystem;
    private static object s_initLock;
    private static UriFormat V1ToStringUnescape;
    internal static char c_DummyChar;
    internal static char c_EOL;
    internal static Char[] HexLowerChars;
    private static Char[] _WSchars;
    private bool IsImplicitFile { get; }
    private bool IsUncOrDosPath { get; }
    private bool IsDosPath { get; }
    private bool IsUncPath { get; }
    private Flags HostType { get; }
    private UriParser Syntax { get; }
    private bool IsNotAbsoluteUri { get; }
    private bool AllowIdn { get; }
    internal bool UserDrivenParsing { get; }
    private ushort SecuredPathIndex { get; }
    public string AbsolutePath { get; }
    private string PrivateAbsolutePath { get; }
    public string AbsoluteUri { get; }
    public string LocalPath { get; }
    public string Authority { get; }
    public UriHostNameType HostNameType { get; }
    public bool IsDefaultPort { get; }
    public bool IsFile { get; }
    public bool IsLoopback { get; }
    public string PathAndQuery { get; }
    public String[] Segments { get; }
    public bool IsUnc { get; }
    public string Host { get; }
    private static object InitializeLock { get; }
    public int Port { get; }
    public string Query { get; }
    public string Fragment { get; }
    public string Scheme { get; }
    private bool OriginalStringSwitched { get; }
    public string OriginalString { get; }
    public string DnsSafeHost { get; }
    public string IdnHost { get; }
    public bool IsAbsoluteUri { get; }
    public bool UserEscaped { get; }
    public string UserInfo { get; }
    internal bool HasAuthority { get; }
    public Uri(string uriString);
    [ObsoleteAttribute("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")]
public Uri(string uriString, bool dontEscape);
    [ObsoleteAttribute("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")]
public Uri(Uri baseUri, string relativeUri, bool dontEscape);
    public Uri(string uriString, UriKind uriKind);
    public Uri(Uri baseUri, string relativeUri);
    public Uri(Uri baseUri, Uri relativeUri);
    protected Uri(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private Uri(Flags flags, UriParser uriParser, string uri);
    private static Uri();
    private bool get_IsImplicitFile();
    private bool get_IsUncOrDosPath();
    private bool get_IsDosPath();
    private bool get_IsUncPath();
    private Flags get_HostType();
    private UriParser get_Syntax();
    private bool get_IsNotAbsoluteUri();
    internal static bool IriParsingStatic(UriParser syntax);
    private bool get_AllowIdn();
    private bool AllowIdnStatic(UriParser syntax, Flags flags);
    private bool IsIntranet(string schemeHost);
    internal bool get_UserDrivenParsing();
    private void SetUserDrivenParsing();
    private ushort get_SecuredPathIndex();
    private bool NotAny(Flags flags);
    private bool InFact(Flags flags);
    private static bool StaticNotAny(Flags allFlags, Flags checkFlags);
    private static bool StaticInFact(Flags allFlags, Flags checkFlags);
    private UriInfo EnsureUriInfo();
    private void EnsureParseRemaining();
    private void EnsureHostString(bool allowDnsOptimization);
    private void CreateUri(Uri baseUri, string relativeUri, bool dontEscape);
    private static ParsingError GetCombinedString(Uri baseUri, string relativeStr, bool dontEscape, String& result);
    private static UriFormatException GetException(ParsingError err);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public string get_AbsolutePath();
    private string get_PrivateAbsolutePath();
    public string get_AbsoluteUri();
    public string get_LocalPath();
    public string get_Authority();
    public UriHostNameType get_HostNameType();
    public bool get_IsDefaultPort();
    public bool get_IsFile();
    public bool get_IsLoopback();
    public string get_PathAndQuery();
    public String[] get_Segments();
    public bool get_IsUnc();
    public string get_Host();
    private static bool StaticIsFile(UriParser syntax);
    private static object get_InitializeLock();
    private static void InitializeUriConfig();
    private string GetLocalPath();
    public int get_Port();
    public string get_Query();
    public string get_Fragment();
    public string get_Scheme();
    private bool get_OriginalStringSwitched();
    public string get_OriginalString();
    public string get_DnsSafeHost();
    public string get_IdnHost();
    public bool get_IsAbsoluteUri();
    public bool get_UserEscaped();
    public string get_UserInfo();
    public static UriHostNameType CheckHostName(string name);
    public string GetLeftPart(UriPartial part);
    public static string HexEscape(char character);
    public static char HexUnescape(string pattern, Int32& index);
    public static bool IsHexEncoding(string pattern, int index);
    internal static bool IsGenDelim(char ch);
    public static bool CheckSchemeName(string schemeName);
    public static bool IsHexDigit(char character);
    public static int FromHex(char digit);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Uri uri1, Uri uri2);
    public static bool op_Inequality(Uri uri1, Uri uri2);
    public virtual bool Equals(object comparand);
    public Uri MakeRelativeUri(Uri uri);
    private static bool CheckForColonInFirstPathSegment(string uriString);
    internal static string InternalEscapeString(string rawString);
    private static ParsingError ParseScheme(string uriString, Flags& flags, UriParser& syntax);
    internal UriFormatException ParseMinimal();
    private ParsingError PrivateParseMinimal();
    private void PrivateParseMinimalIri(string newHost, ushort idx);
    private void CreateUriInfo(Flags cF);
    private void CreateHostString();
    private static string CreateHostStringHelper(string str, ushort idx, ushort end, Flags& flags, String& scopeId);
    private void GetHostViaCustomSyntax();
    internal string GetParts(UriComponents uriParts, UriFormat formatAs);
    private string GetEscapedParts(UriComponents uriParts);
    private string GetUnescapedParts(UriComponents uriParts, UriFormat formatAs);
    private string ReCreateParts(UriComponents parts, ushort nonCanonical, UriFormat formatAs);
    private string GetUriPartsFromUserString(UriComponents uriParts);
    private void ParseRemaining();
    private static ushort ParseSchemeCheckImplicitFile(Char* uriString, ushort length, ParsingError& err, Flags& flags, UriParser& syntax);
    private static bool CheckKnownSchemes(Int64* lptr, ushort nChars, UriParser& syntax);
    private static ParsingError CheckSchemeSyntax(Char* ptr, ushort length, UriParser& syntax);
    private ushort CheckAuthorityHelper(Char* pString, ushort idx, ushort length, ParsingError& err, Flags& flags, UriParser syntax, String& newHost);
    private void CheckAuthorityHelperHandleDnsIri(Char* pString, ushort start, int end, int startInput, bool iriParsing, bool hasUnicode, UriParser syntax, string userInfoString, Flags& flags, Boolean& justNormalized, String& newHost, ParsingError& err);
    private void CheckAuthorityHelperHandleAnyHostIri(Char* pString, int startInput, int end, bool iriParsing, bool hasUnicode, UriParser syntax, Flags& flags, String& newHost, ParsingError& err);
    private void FindEndOfComponent(string input, UInt16& idx, ushort end, char delim);
    private void FindEndOfComponent(Char* str, UInt16& idx, ushort end, char delim);
    private Check CheckCanonical(Char* str, UInt16& idx, ushort end, char delim);
    private Char[] GetCanonicalPath(Char[] dest, Int32& pos, UriFormat formatAs);
    private static void UnescapeOnly(Char* pch, int start, Int32& end, char ch1, char ch2, char ch3);
    private static Char[] Compress(Char[] dest, ushort start, Int32& destLength, UriParser syntax);
    internal static int CalculateCaseInsensitiveHashCode(string text);
    private static string CombineUri(Uri basePart, string relativePart, UriFormat uriFormat);
    private static string PathDifference(string path1, string path2, bool compareCase);
    internal bool get_HasAuthority();
    private static bool IsLWS(char ch);
    private static bool IsAsciiLetter(char character);
    internal static bool IsAsciiLetterOrDigit(char character);
    internal static bool IsBidiControlCharacter(char ch);
    internal static string StripBidiControlCharacter(Char* strToClean, int start, int length);
    [ObsoleteAttribute("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")]
public string MakeRelative(Uri toUri);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Parse();
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Canonicalize();
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Escape();
    [ObsoleteAttribute("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual string Unescape(string path);
    [ObsoleteAttribute("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")]
protected static string EscapeString(string str);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void CheckSecurity();
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual bool IsReservedCharacter(char character);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected static bool IsExcludedCharacter(char character);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual bool IsBadFileSystemCharacter(char character);
    private void CreateThis(string uri, bool dontEscape, UriKind uriKind);
    private void InitializeUri(ParsingError err, UriKind uriKind, UriFormatException& e);
    private bool CheckForConfigLoad(string data);
    private bool CheckForUnicode(string data);
    private bool CheckForEscapedUnreserved(string data);
    public static bool TryCreate(string uriString, UriKind uriKind, Uri& result);
    public static bool TryCreate(Uri baseUri, string relativeUri, Uri& result);
    public static bool TryCreate(Uri baseUri, Uri relativeUri, Uri& result);
    public string GetComponents(UriComponents components, UriFormat format);
    public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);
    public bool IsWellFormedOriginalString();
    public static bool IsWellFormedUriString(string uriString, UriKind uriKind);
    internal bool InternalIsWellFormedOriginalString();
    public static string UnescapeDataString(string stringToUnescape);
    public static string EscapeUriString(string stringToEscape);
    public static string EscapeDataString(string stringToEscape);
    internal string EscapeUnescapeIri(string input, int start, int end, UriComponents component);
    internal static Uri CreateHelper(string uriString, bool dontEscape, UriKind uriKind, UriFormatException& e);
    internal static Uri ResolveHelper(Uri baseUri, Uri relativeUri, String& newUriString, Boolean& userEscaped, UriFormatException& e);
    private string GetRelativeSerializationString(UriFormat format);
    internal string GetComponentsHelper(UriComponents uriComponents, UriFormat uriFormat);
    public bool IsBaseOf(Uri uri);
    internal bool IsBaseOfHelper(Uri uriLink);
    private void CreateThisFromUri(Uri otherUri);
}
public class System.UriBuilder : object {
    private bool _changed;
    private string _fragment;
    private string _host;
    private string _password;
    private string _path;
    private int _port;
    private string _query;
    private string _scheme;
    private string _schemeDelimiter;
    private Uri _uri;
    private string _username;
    unknown string Extra {private set; }
    public string Fragment { get; public set; }
    public string Host { get; public set; }
    public string Password { get; public set; }
    public string Path { get; public set; }
    public int Port { get; public set; }
    public string Query { get; public set; }
    public string Scheme { get; public set; }
    public Uri Uri { get; }
    public string UserName { get; public set; }
    public UriBuilder(string uri);
    public UriBuilder(Uri uri);
    public UriBuilder(string schemeName, string hostName);
    public UriBuilder(string scheme, string host, int portNumber);
    public UriBuilder(string scheme, string host, int port, string pathValue);
    public UriBuilder(string scheme, string host, int port, string path, string extraValue);
    private void Init(Uri uri);
    private void set_Extra(string value);
    public string get_Fragment();
    public void set_Fragment(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Password();
    public void set_Password(string value);
    public string get_Path();
    public void set_Path(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_Query();
    public void set_Query(string value);
    public string get_Scheme();
    public void set_Scheme(string value);
    public Uri get_Uri();
    public string get_UserName();
    public void set_UserName(string value);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    private void SetFieldsFromUri(Uri uri);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.UriComponents : Enum {
    public int value__;
    public static UriComponents Scheme;
    public static UriComponents UserInfo;
    public static UriComponents Host;
    public static UriComponents Port;
    public static UriComponents Path;
    public static UriComponents Query;
    public static UriComponents Fragment;
    public static UriComponents StrongPort;
    public static UriComponents NormalizedHost;
    public static UriComponents KeepDelimiter;
    public static UriComponents SerializationInfoString;
    public static UriComponents AbsoluteUri;
    public static UriComponents HostAndPort;
    public static UriComponents StrongAuthority;
    public static UriComponents SchemeAndServer;
    public static UriComponents HttpRequestUrl;
    public static UriComponents PathAndQuery;
}
public enum System.UriFormat : Enum {
    public int value__;
    public static UriFormat UriEscaped;
    public static UriFormat Unescaped;
    public static UriFormat SafeUnescaped;
}
public class System.UriFormatException : FormatException {
    public UriFormatException(string textString);
    public UriFormatException(string textString, Exception e);
    protected UriFormatException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal static class System.UriHelper : object {
    private static Char[] HexUpperChars;
    private static short c_MaxAsciiCharsReallocate;
    private static short c_MaxUnicodeCharsReallocate;
    private static short c_MaxUTF_8BytesPerUnicodeChar;
    private static short c_EncodedCharsPerByte;
    private static string RFC2396ReservedMarks;
    private static string RFC3986ReservedMarks;
    private static string RFC2396UnreservedMarks;
    private static string RFC3986UnreservedMarks;
    private static UriHelper();
    internal static bool TestForSubPath(Char* pMe, ushort meLength, Char* pShe, ushort sheLength, bool ignoreCase);
    internal static Char[] EscapeString(string input, int start, int end, Char[] dest, Int32& destPos, bool isUriString, char force1, char force2, char rsvd);
    private static Char[] EnsureDestinationSize(Char* pStr, Char[] dest, int currentInputPos, short charsToAdd, short minReallocateChars, Int32& destPos, int prevInputPos);
    internal static Char[] UnescapeString(string input, int start, int end, Char[] dest, Int32& destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery);
    internal static Char[] UnescapeString(Char* pStr, int start, int end, Char[] dest, Int32& destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery);
    internal static void MatchUTF8Sequence(Char* pDest, Char[] dest, Int32& destOffset, Char[] unescapedChars, int charCount, Byte[] bytes, int byteCount, bool isQuery, bool iriParsing);
    internal static void EscapeAsciiChar(char ch, Char[] to, Int32& pos);
    internal static char EscapedAscii(char digit, char next);
    internal static bool IsNotSafeForUnescape(char ch);
    private static bool IsReservedUnreservedOrHash(char c);
    internal static bool IsUnreserved(char c);
    internal static bool Is3986Unreserved(char c);
}
public enum System.UriHostNameType : Enum {
    public int value__;
    public static UriHostNameType Unknown;
    public static UriHostNameType Basic;
    public static UriHostNameType Dns;
    public static UriHostNameType IPv4;
    public static UriHostNameType IPv6;
}
public enum System.UriIdnScope : Enum {
    public int value__;
    public static UriIdnScope None;
    public static UriIdnScope AllExceptIntranet;
    public static UriIdnScope All;
}
public enum System.UriKind : Enum {
    public int value__;
    public static UriKind RelativeOrAbsolute;
    public static UriKind Absolute;
    public static UriKind Relative;
}
public abstract class System.UriParser : object {
    private static UriSyntaxFlags SchemeOnlyFlags;
    private static Dictionary`2<string, UriParser> m_Table;
    private static Dictionary`2<string, UriParser> m_TempTable;
    private UriSyntaxFlags m_Flags;
    private UriSyntaxFlags modreq(System.Runtime.CompilerServices.IsVolatile) m_UpdatableFlags;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_UpdatableFlagsUsed;
    private static UriSyntaxFlags c_UpdatableFlags;
    private int m_Port;
    private string m_Scheme;
    internal static int NoDefaultPort;
    private static int c_InitialTableSize;
    internal static UriParser HttpUri;
    internal static UriParser HttpsUri;
    internal static UriParser WsUri;
    internal static UriParser WssUri;
    internal static UriParser FtpUri;
    internal static UriParser FileUri;
    internal static UriParser GopherUri;
    internal static UriParser NntpUri;
    internal static UriParser NewsUri;
    internal static UriParser MailToUri;
    internal static UriParser UuidUri;
    internal static UriParser TelnetUri;
    internal static UriParser LdapUri;
    internal static UriParser NetTcpUri;
    internal static UriParser NetPipeUri;
    internal static UriParser VsMacrosUri;
    private static UriQuirksVersion s_QuirksVersion;
    private static int c_MaxCapacity;
    private static UriSyntaxFlags UnknownV1SyntaxFlags;
    private static UriSyntaxFlags HttpSyntaxFlags;
    private static UriSyntaxFlags FtpSyntaxFlags;
    private static UriSyntaxFlags FileSyntaxFlags;
    private static UriSyntaxFlags VsmacrosSyntaxFlags;
    private static UriSyntaxFlags GopherSyntaxFlags;
    private static UriSyntaxFlags NewsSyntaxFlags;
    private static UriSyntaxFlags NntpSyntaxFlags;
    private static UriSyntaxFlags TelnetSyntaxFlags;
    private static UriSyntaxFlags LdapSyntaxFlags;
    private static UriSyntaxFlags MailtoSyntaxFlags;
    private static UriSyntaxFlags NetPipeSyntaxFlags;
    private static UriSyntaxFlags NetTcpSyntaxFlags;
    internal string SchemeName { get; }
    internal int DefaultPort { get; }
    internal static bool ShouldUseLegacyV2Quirks { get; }
    internal UriSyntaxFlags Flags { get; }
    internal bool IsSimple { get; }
    private static UriParser();
    internal UriParser(UriSyntaxFlags flags);
    internal string get_SchemeName();
    internal int get_DefaultPort();
    protected virtual UriParser OnNewUri();
    protected virtual void OnRegister(string schemeName, int defaultPort);
    protected virtual void InitializeAndValidate(Uri uri, UriFormatException& parsingError);
    protected virtual string Resolve(Uri baseUri, Uri relativeUri, UriFormatException& parsingError);
    protected virtual bool IsBaseOf(Uri baseUri, Uri relativeUri);
    protected virtual string GetComponents(Uri uri, UriComponents components, UriFormat format);
    protected virtual bool IsWellFormedOriginalString(Uri uri);
    public static void Register(UriParser uriParser, string schemeName, int defaultPort);
    public static bool IsKnownScheme(string schemeName);
    internal static bool get_ShouldUseLegacyV2Quirks();
    internal UriSyntaxFlags get_Flags();
    internal bool NotAny(UriSyntaxFlags flags);
    internal bool InFact(UriSyntaxFlags flags);
    internal bool IsAllSet(UriSyntaxFlags flags);
    private bool IsFullMatch(UriSyntaxFlags flags, UriSyntaxFlags expected);
    private static void FetchSyntax(UriParser syntax, string lwrCaseSchemeName, int defaultPort);
    internal static UriParser FindOrFetchAsUnknownV1Syntax(string lwrCaseScheme);
    internal static UriParser GetSyntax(string lwrCaseScheme);
    internal bool get_IsSimple();
    internal void CheckSetIsSimpleFlag();
    internal void SetUpdatableFlags(UriSyntaxFlags flags);
    internal UriParser InternalOnNewUri();
    internal void InternalValidate(Uri thisUri, UriFormatException& parsingError);
    internal string InternalResolve(Uri thisBaseUri, Uri uriLink, UriFormatException& parsingError);
    internal bool InternalIsBaseOf(Uri thisBaseUri, Uri uriLink);
    internal string InternalGetComponents(Uri thisUri, UriComponents uriComponents, UriFormat uriFormat);
    internal bool InternalIsWellFormedOriginalString(Uri thisUri);
}
public enum System.UriPartial : Enum {
    public int value__;
    public static UriPartial Scheme;
    public static UriPartial Authority;
    public static UriPartial Path;
    public static UriPartial Query;
}
[FlagsAttribute]
internal enum System.UriSyntaxFlags : Enum {
    public int value__;
    public static UriSyntaxFlags None;
    public static UriSyntaxFlags MustHaveAuthority;
    public static UriSyntaxFlags OptionalAuthority;
    public static UriSyntaxFlags MayHaveUserInfo;
    public static UriSyntaxFlags MayHavePort;
    public static UriSyntaxFlags MayHavePath;
    public static UriSyntaxFlags MayHaveQuery;
    public static UriSyntaxFlags MayHaveFragment;
    public static UriSyntaxFlags AllowEmptyHost;
    public static UriSyntaxFlags AllowUncHost;
    public static UriSyntaxFlags AllowDnsHost;
    public static UriSyntaxFlags AllowIPv4Host;
    public static UriSyntaxFlags AllowIPv6Host;
    public static UriSyntaxFlags AllowAnInternetHost;
    public static UriSyntaxFlags AllowAnyOtherHost;
    public static UriSyntaxFlags FileLikeUri;
    public static UriSyntaxFlags MailToLikeUri;
    public static UriSyntaxFlags V1_UnknownUri;
    public static UriSyntaxFlags SimpleUserSyntax;
    public static UriSyntaxFlags BuiltInSyntax;
    public static UriSyntaxFlags ParserSchemeOnly;
    public static UriSyntaxFlags AllowDOSPath;
    public static UriSyntaxFlags PathIsRooted;
    public static UriSyntaxFlags ConvertPathSlashes;
    public static UriSyntaxFlags CompressPath;
    public static UriSyntaxFlags CanonicalizeAsFilePath;
    public static UriSyntaxFlags UnEscapeDotsAndSlashes;
    public static UriSyntaxFlags AllowIdn;
    public static UriSyntaxFlags AllowIriParsing;
}
public class System.UriTypeConverter : TypeConverter {
    private bool CanConvert(Type type);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
public class System.Web.AspNetHostingPermission : CodeAccessPermission {
    private static int version;
    private AspNetHostingPermissionLevel _level;
    public AspNetHostingPermissionLevel Level { get; public set; }
    public AspNetHostingPermission(AspNetHostingPermissionLevel level);
    public AspNetHostingPermission(PermissionState state);
    public AspNetHostingPermissionLevel get_Level();
    public void set_Level(AspNetHostingPermissionLevel value);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Union(IPermission target);
    private bool IsEmpty();
    private AspNetHostingPermission Cast(IPermission target);
}
[AttributeUsageAttribute("32767")]
public class System.Web.AspNetHostingPermissionAttribute : CodeAccessSecurityAttribute {
    private AspNetHostingPermissionLevel _level;
    public AspNetHostingPermissionLevel Level { get; public set; }
    public AspNetHostingPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
    public AspNetHostingPermissionLevel get_Level();
    public void set_Level(AspNetHostingPermissionLevel value);
}
public enum System.Web.AspNetHostingPermissionLevel : Enum {
    public int value__;
    public static AspNetHostingPermissionLevel None;
    public static AspNetHostingPermissionLevel Minimal;
    public static AspNetHostingPermissionLevel Low;
    public static AspNetHostingPermissionLevel Medium;
    public static AspNetHostingPermissionLevel High;
    public static AspNetHostingPermissionLevel Unrestricted;
}
public class System.Web.HttpUtility : object {
    public static void HtmlAttributeEncode(string s, TextWriter output);
    public static string HtmlAttributeEncode(string s);
    public static string UrlDecode(string str);
    private static Char[] GetChars(MemoryStream b, Encoding e);
    private static void WriteCharBytes(IList buf, char ch, Encoding e);
    public static string UrlDecode(string str, Encoding e);
    public static string UrlDecode(Byte[] bytes, Encoding e);
    private static int GetInt(byte b);
    private static int GetChar(Byte[] bytes, int offset, int length);
    private static int GetChar(string str, int offset, int length);
    public static string UrlDecode(Byte[] bytes, int offset, int count, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes);
    public static Byte[] UrlDecodeToBytes(string str);
    public static Byte[] UrlDecodeToBytes(string str, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncode(string str);
    public static string UrlEncode(string str, Encoding e);
    public static string UrlEncode(Byte[] bytes);
    public static string UrlEncode(Byte[] bytes, int offset, int count);
    public static Byte[] UrlEncodeToBytes(string str);
    public static Byte[] UrlEncodeToBytes(string str, Encoding e);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncodeUnicode(string str);
    public static Byte[] UrlEncodeUnicodeToBytes(string str);
    public static string HtmlDecode(string s);
    public static void HtmlDecode(string s, TextWriter output);
    public static string HtmlEncode(string s);
    public static void HtmlEncode(string s, TextWriter output);
    public static string HtmlEncode(object value);
    public static string JavaScriptStringEncode(string value);
    public static string JavaScriptStringEncode(string value, bool addDoubleQuotes);
    public static string UrlPathEncode(string str);
    public static NameValueCollection ParseQueryString(string query);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding);
    internal static void ParseQueryString(string query, Encoding encoding, NameValueCollection result);
}
internal class System.Web.Util.Helpers : object {
    public static CultureInfo InvariantCulture;
    private static Helpers();
}
public class System.Web.Util.HttpEncoder : object {
    private static Char[] hexChars;
    private static object entitiesLock;
    private static SortedDictionary`2<string, char> entities;
    private static Lazy`1<HttpEncoder> defaultEncoder;
    private static Lazy`1<HttpEncoder> currentEncoderLazy;
    private static HttpEncoder currentEncoder;
    private static IDictionary`2<string, char> Entities { get; }
    public static HttpEncoder Current { get; public set; }
    public static HttpEncoder Default { get; }
    private static HttpEncoder();
    private static IDictionary`2<string, char> get_Entities();
    public static HttpEncoder get_Current();
    public static void set_Current(HttpEncoder value);
    public static HttpEncoder get_Default();
    protected internal virtual void HeaderNameValueEncode(string headerName, string headerValue, String& encodedHeaderName, String& encodedHeaderValue);
    private static void StringBuilderAppend(string s, StringBuilder& sb);
    private static string EncodeHeaderString(string input);
    protected internal virtual void HtmlAttributeEncode(string value, TextWriter output);
    protected internal virtual void HtmlDecode(string value, TextWriter output);
    protected internal virtual void HtmlEncode(string value, TextWriter output);
    protected internal virtual Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    private static HttpEncoder GetCustomEncoderFromConfig();
    protected internal virtual string UrlPathEncode(string value);
    internal static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    internal static string HtmlEncode(string s);
    internal static string HtmlAttributeEncode(string s);
    internal static string HtmlDecode(string s);
    internal static bool NotEncoded(char c);
    internal static void UrlEncodeChar(char c, Stream result, bool isUnicode);
    internal static void UrlPathEncodeChar(char c, Stream result);
    private static void InitEntities();
    protected internal virtual string JavaScriptStringEncode(string value);
}
[TypeForwardedFromAttribute("PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Windows.Input.ICommand {
    public abstract virtual bool CanExecute(object parameter);
    public abstract virtual void Execute(object parameter);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CanExecuteChanged(EventHandler value);
}
[AttributeUsageAttribute("1244")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.ValueSerializerAttribute : Attribute {
    private Type _valueSerializerType;
    private string _valueSerializerTypeName;
    public Type ValueSerializerType { get; }
    public string ValueSerializerTypeName { get; }
    public ValueSerializerAttribute(Type valueSerializerType);
    public ValueSerializerAttribute(string valueSerializerTypeName);
    public Type get_ValueSerializerType();
    public string get_ValueSerializerTypeName();
}
internal class Unity.ThrowStub : ObjectDisposedException {
    public static void ThrowNotSupportedException();
}
