[NativeHeaderAttribute("Modules/Physics/ArticulationBody.h")]
[NativeClassAttribute("Unity::ArticulationBody")]
public class UnityEngine.ArticulationBody : Behaviour {
    
public ArticulationJointType jointType { get; public set; }
    
public Vector3 anchorPosition { get; public set; }
    
public Vector3 parentAnchorPosition { get; public set; }
    
public Quaternion anchorRotation { get; public set; }
    
public Quaternion parentAnchorRotation { get; public set; }
    
public bool isRoot { get; }
    
public bool matchAnchors { get; public set; }
    
public ArticulationDofLock linearLockX { get; public set; }
    
public ArticulationDofLock linearLockY { get; public set; }
    
public ArticulationDofLock linearLockZ { get; public set; }
    
public ArticulationDofLock swingYLock { get; public set; }
    
public ArticulationDofLock swingZLock { get; public set; }
    
public ArticulationDofLock twistLock { get; public set; }
    
public ArticulationDrive xDrive { get; public set; }
    
public ArticulationDrive yDrive { get; public set; }
    
public ArticulationDrive zDrive { get; public set; }
    
public bool immovable { get; public set; }
    
public bool useGravity { get; public set; }
    
public float linearDamping { get; public set; }
    
public float angularDamping { get; public set; }
    
public float jointFriction { get; public set; }
    
public LayerMask excludeLayers { get; public set; }
    
public LayerMask includeLayers { get; public set; }
    
public Vector3 velocity { get; public set; }
    
public Vector3 angularVelocity { get; public set; }
    
public float mass { get; public set; }
    
public bool automaticCenterOfMass { get; public set; }
    
public Vector3 centerOfMass { get; public set; }
    
public Vector3 worldCenterOfMass { get; }
    
public bool automaticInertiaTensor { get; public set; }
    
public Vector3 inertiaTensor { get; public set; }
    
public Quaternion inertiaTensorRotation { get; public set; }
    
public float sleepThreshold { get; public set; }
    
public int solverIterations { get; public set; }
    
public int solverVelocityIterations { get; public set; }
    
public float maxAngularVelocity { get; public set; }
    
public float maxLinearVelocity { get; public set; }
    
public float maxJointVelocity { get; public set; }
    
public float maxDepenetrationVelocity { get; public set; }
    
public ArticulationReducedSpace jointPosition { get; public set; }
    
public ArticulationReducedSpace jointVelocity { get; public set; }
    
public ArticulationReducedSpace jointAcceleration { get; public set; }
    
public ArticulationReducedSpace jointForce { get; public set; }
    
public ArticulationReducedSpace driveForce { get; }
    
public int dofCount { get; }
    
public int index { get; }
    
public CollisionDetectionMode collisionDetectionMode { get; public set; }
    [ObsoleteAttribute("computeParentAnchor has been renamed to matchAnchors (UnityUpgradable) -> matchAnchors")]

public bool computeParentAnchor { get; public set; }
    public ArticulationJointType get_jointType();
    public void set_jointType(ArticulationJointType value);
    public Vector3 get_anchorPosition();
    public void set_anchorPosition(Vector3 value);
    public Vector3 get_parentAnchorPosition();
    public void set_parentAnchorPosition(Vector3 value);
    public Quaternion get_anchorRotation();
    public void set_anchorRotation(Quaternion value);
    public Quaternion get_parentAnchorRotation();
    public void set_parentAnchorRotation(Quaternion value);
    public bool get_isRoot();
    public bool get_matchAnchors();
    public void set_matchAnchors(bool value);
    public ArticulationDofLock get_linearLockX();
    public void set_linearLockX(ArticulationDofLock value);
    public ArticulationDofLock get_linearLockY();
    public void set_linearLockY(ArticulationDofLock value);
    public ArticulationDofLock get_linearLockZ();
    public void set_linearLockZ(ArticulationDofLock value);
    public ArticulationDofLock get_swingYLock();
    public void set_swingYLock(ArticulationDofLock value);
    public ArticulationDofLock get_swingZLock();
    public void set_swingZLock(ArticulationDofLock value);
    public ArticulationDofLock get_twistLock();
    public void set_twistLock(ArticulationDofLock value);
    public ArticulationDrive get_xDrive();
    public void set_xDrive(ArticulationDrive value);
    public ArticulationDrive get_yDrive();
    public void set_yDrive(ArticulationDrive value);
    public ArticulationDrive get_zDrive();
    public void set_zDrive(ArticulationDrive value);
    public bool get_immovable();
    public void set_immovable(bool value);
    public bool get_useGravity();
    public void set_useGravity(bool value);
    public float get_linearDamping();
    public void set_linearDamping(float value);
    public float get_angularDamping();
    public void set_angularDamping(float value);
    public float get_jointFriction();
    public void set_jointFriction(float value);
    public LayerMask get_excludeLayers();
    public void set_excludeLayers(LayerMask value);
    public LayerMask get_includeLayers();
    public void set_includeLayers(LayerMask value);
    public Vector3 GetAccumulatedForce(float step);
    [ExcludeFromDocsAttribute]
public Vector3 GetAccumulatedForce();
    public Vector3 GetAccumulatedTorque(float step);
    [ExcludeFromDocsAttribute]
public Vector3 GetAccumulatedTorque();
    public void AddForce(Vector3 force, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddForce(Vector3 force);
    public void AddRelativeForce(Vector3 force, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddRelativeForce(Vector3 force);
    public void AddTorque(Vector3 torque, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddTorque(Vector3 torque);
    public void AddRelativeTorque(Vector3 torque, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddRelativeTorque(Vector3 torque);
    public void AddForceAtPosition(Vector3 force, Vector3 position, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddForceAtPosition(Vector3 force, Vector3 position);
    public Vector3 get_velocity();
    public void set_velocity(Vector3 value);
    public Vector3 get_angularVelocity();
    public void set_angularVelocity(Vector3 value);
    public float get_mass();
    public void set_mass(float value);
    public bool get_automaticCenterOfMass();
    public void set_automaticCenterOfMass(bool value);
    public Vector3 get_centerOfMass();
    public void set_centerOfMass(Vector3 value);
    public Vector3 get_worldCenterOfMass();
    public bool get_automaticInertiaTensor();
    public void set_automaticInertiaTensor(bool value);
    public Vector3 get_inertiaTensor();
    public void set_inertiaTensor(Vector3 value);
    public Quaternion get_inertiaTensorRotation();
    public void set_inertiaTensorRotation(Quaternion value);
    public void ResetCenterOfMass();
    public void ResetInertiaTensor();
    public void Sleep();
    public bool IsSleeping();
    public void WakeUp();
    public float get_sleepThreshold();
    public void set_sleepThreshold(float value);
    public int get_solverIterations();
    public void set_solverIterations(int value);
    public int get_solverVelocityIterations();
    public void set_solverVelocityIterations(int value);
    public float get_maxAngularVelocity();
    public void set_maxAngularVelocity(float value);
    public float get_maxLinearVelocity();
    public void set_maxLinearVelocity(float value);
    public float get_maxJointVelocity();
    public void set_maxJointVelocity(float value);
    public float get_maxDepenetrationVelocity();
    public void set_maxDepenetrationVelocity(float value);
    public ArticulationReducedSpace get_jointPosition();
    public void set_jointPosition(ArticulationReducedSpace value);
    public ArticulationReducedSpace get_jointVelocity();
    public void set_jointVelocity(ArticulationReducedSpace value);
    public ArticulationReducedSpace get_jointAcceleration();
    [ObsoleteAttribute("Setting joint accelerations is not supported in forward kinematics. To have inverse dynamics take acceleration into account, use GetJointForcesForAcceleration instead", "True")]
public void set_jointAcceleration(ArticulationReducedSpace value);
    public ArticulationReducedSpace get_jointForce();
    public void set_jointForce(ArticulationReducedSpace value);
    public ArticulationReducedSpace get_driveForce();
    public int get_dofCount();
    [NativeMethodAttribute("GetBodyIndex")]
public int get_index();
    public void TeleportRoot(Vector3 position, Quaternion rotation);
    public Vector3 GetClosestPoint(Vector3 point);
    public Vector3 GetRelativePointVelocity(Vector3 relativePoint);
    public Vector3 GetPointVelocity(Vector3 worldPoint);
    [NativeMethodAttribute("GetDenseJacobian")]
private int GetDenseJacobian_Internal(ArticulationJacobian& jacobian);
    public int GetDenseJacobian(ArticulationJacobian& jacobian);
    public int GetJointPositions(List`1<float> positions);
    public void SetJointPositions(List`1<float> positions);
    public int GetJointVelocities(List`1<float> velocities);
    public void SetJointVelocities(List`1<float> velocities);
    public int GetJointAccelerations(List`1<float> accelerations);
    public int GetJointForces(List`1<float> forces);
    public void SetJointForces(List`1<float> forces);
    public ArticulationReducedSpace GetJointForcesForAcceleration(ArticulationReducedSpace acceleration);
    public int GetDriveForces(List`1<float> forces);
    public int GetJointGravityForces(List`1<float> forces);
    public int GetJointCoriolisCentrifugalForces(List`1<float> forces);
    public int GetJointExternalForces(List`1<float> forces, float step);
    public int GetDriveTargets(List`1<float> targets);
    public void SetDriveTargets(List`1<float> targets);
    public int GetDriveTargetVelocities(List`1<float> targetVelocities);
    public void SetDriveTargetVelocities(List`1<float> targetVelocities);
    public int GetDofStartIndices(List`1<int> dofStartIndices);
    public void SetDriveTarget(ArticulationDriveAxis axis, float value);
    public void SetDriveTargetVelocity(ArticulationDriveAxis axis, float value);
    public void SetDriveLimits(ArticulationDriveAxis axis, float lower, float upper);
    public void SetDriveStiffness(ArticulationDriveAxis axis, float value);
    public void SetDriveDamping(ArticulationDriveAxis axis, float value);
    public void SetDriveForceLimit(ArticulationDriveAxis axis, float value);
    public CollisionDetectionMode get_collisionDetectionMode();
    public void set_collisionDetectionMode(CollisionDetectionMode value);
    public void SnapAnchorToClosestContact();
    public bool get_computeParentAnchor();
    public void set_computeParentAnchor(bool value);
    [ObsoleteAttribute("Setting joint accelerations is not supported in forward kinematics. To have inverse dynamics take acceleration into account, use GetJointForcesForAcceleration instead", "True")]
public void SetJointAccelerations(List`1<float> accelerations);
    private void get_anchorPosition_Injected(Vector3& ret);
    private void set_anchorPosition_Injected(Vector3& value);
    private void get_parentAnchorPosition_Injected(Vector3& ret);
    private void set_parentAnchorPosition_Injected(Vector3& value);
    private void get_anchorRotation_Injected(Quaternion& ret);
    private void set_anchorRotation_Injected(Quaternion& value);
    private void get_parentAnchorRotation_Injected(Quaternion& ret);
    private void set_parentAnchorRotation_Injected(Quaternion& value);
    private void get_xDrive_Injected(ArticulationDrive& ret);
    private void set_xDrive_Injected(ArticulationDrive& value);
    private void get_yDrive_Injected(ArticulationDrive& ret);
    private void set_yDrive_Injected(ArticulationDrive& value);
    private void get_zDrive_Injected(ArticulationDrive& ret);
    private void set_zDrive_Injected(ArticulationDrive& value);
    private void get_excludeLayers_Injected(LayerMask& ret);
    private void set_excludeLayers_Injected(LayerMask& value);
    private void get_includeLayers_Injected(LayerMask& ret);
    private void set_includeLayers_Injected(LayerMask& value);
    private void GetAccumulatedForce_Injected(float step, Vector3& ret);
    private void GetAccumulatedTorque_Injected(float step, Vector3& ret);
    private void AddForce_Injected(Vector3& force, ForceMode mode);
    private void AddRelativeForce_Injected(Vector3& force, ForceMode mode);
    private void AddTorque_Injected(Vector3& torque, ForceMode mode);
    private void AddRelativeTorque_Injected(Vector3& torque, ForceMode mode);
    private void AddForceAtPosition_Injected(Vector3& force, Vector3& position, ForceMode mode);
    private void get_velocity_Injected(Vector3& ret);
    private void set_velocity_Injected(Vector3& value);
    private void get_angularVelocity_Injected(Vector3& ret);
    private void set_angularVelocity_Injected(Vector3& value);
    private void get_centerOfMass_Injected(Vector3& ret);
    private void set_centerOfMass_Injected(Vector3& value);
    private void get_worldCenterOfMass_Injected(Vector3& ret);
    private void get_inertiaTensor_Injected(Vector3& ret);
    private void set_inertiaTensor_Injected(Vector3& value);
    private void get_inertiaTensorRotation_Injected(Quaternion& ret);
    private void set_inertiaTensorRotation_Injected(Quaternion& value);
    private void get_jointPosition_Injected(ArticulationReducedSpace& ret);
    private void set_jointPosition_Injected(ArticulationReducedSpace& value);
    private void get_jointVelocity_Injected(ArticulationReducedSpace& ret);
    private void set_jointVelocity_Injected(ArticulationReducedSpace& value);
    private void get_jointAcceleration_Injected(ArticulationReducedSpace& ret);
    private void set_jointAcceleration_Injected(ArticulationReducedSpace& value);
    private void get_jointForce_Injected(ArticulationReducedSpace& ret);
    private void set_jointForce_Injected(ArticulationReducedSpace& value);
    private void get_driveForce_Injected(ArticulationReducedSpace& ret);
    private void TeleportRoot_Injected(Vector3& position, Quaternion& rotation);
    private void GetClosestPoint_Injected(Vector3& point, Vector3& ret);
    private void GetRelativePointVelocity_Injected(Vector3& relativePoint, Vector3& ret);
    private void GetPointVelocity_Injected(Vector3& worldPoint, Vector3& ret);
    private void GetJointForcesForAcceleration_Injected(ArticulationReducedSpace& acceleration, ArticulationReducedSpace& ret);
}
public enum UnityEngine.ArticulationDofLock : Enum {
    
public int value__;
    
public static ArticulationDofLock LockedMotion;
    
public static ArticulationDofLock LimitedMotion;
    
public static ArticulationDofLock FreeMotion;
}
[NativeHeaderAttribute("Modules/Physics/ArticulationBody.h")]
public class UnityEngine.ArticulationDrive : ValueType {
    
public float lowerLimit;
    
public float upperLimit;
    
public float stiffness;
    
public float damping;
    
public float forceLimit;
    
public float target;
    
public float targetVelocity;
    
public ArticulationDriveType driveType;
}
public enum UnityEngine.ArticulationDriveAxis : Enum {
    
public int value__;
    
public static ArticulationDriveAxis X;
    
public static ArticulationDriveAxis Y;
    
public static ArticulationDriveAxis Z;
}
public enum UnityEngine.ArticulationDriveType : Enum {
    
public int value__;
    
public static ArticulationDriveType Force;
    
public static ArticulationDriveType Acceleration;
    
public static ArticulationDriveType Target;
    
public static ArticulationDriveType Velocity;
}
[DefaultMemberAttribute("Item")]
[NativeHeaderAttribute("Modules/Physics/ArticulationBody.h")]
public class UnityEngine.ArticulationJacobian : ValueType {
    
private int rowsCount;
    
private int colsCount;
    
private List`1<float> matrixData;
    
public float Item { get; public set; }
    
public int rows { get; public set; }
    
public int columns { get; public set; }
    
public List`1<float> elements { get; public set; }
    public ArticulationJacobian(int rows, int cols);
    public float get_Item(int row, int col);
    public void set_Item(int row, int col, float value);
    public int get_rows();
    public void set_rows(int value);
    public int get_columns();
    public void set_columns(int value);
    public List`1<float> get_elements();
    public void set_elements(List`1<float> value);
}
public enum UnityEngine.ArticulationJointType : Enum {
    
public int value__;
    
public static ArticulationJointType FixedJoint;
    
public static ArticulationJointType PrismaticJoint;
    
public static ArticulationJointType RevoluteJoint;
    
public static ArticulationJointType SphericalJoint;
}
[DefaultMemberAttribute("Item")]
[NativeHeaderAttribute("Modules/Physics/ArticulationBody.h")]
public class UnityEngine.ArticulationReducedSpace : ValueType {
    [FixedBufferAttribute("System.Single", "3")]

private <x>e__FixedBuffer x;
    
public int dofCount;
    
public float Item { get; public set; }
    public ArticulationReducedSpace(float a);
    public ArticulationReducedSpace(float a, float b);
    public ArticulationReducedSpace(float a, float b, float c);
    public float get_Item(int i);
    public void set_Item(int i, float value);
}
[NativeHeaderAttribute("Runtime/Jobs/ScriptBindings/JobsBindingsTypes.h")]
[NativeHeaderAttribute("Modules/Physics/BatchCommands/BoxcastCommand.h")]
public class UnityEngine.BoxcastCommand : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <center>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Vector3 <halfExtents>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Quaternion <orientation>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <direction>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private float <distance>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private PhysicsScene <physicsScene>k__BackingField;
    
public QueryParameters queryParameters;
    
public Vector3 center { get; public set; }
    
public Vector3 halfExtents { get; public set; }
    
public Quaternion orientation { get; public set; }
    
public Vector3 direction { get; public set; }
    
public float distance { get; public set; }
    
public PhysicsScene physicsScene { get; public set; }
    [ObsoleteAttribute("Layer Mask is now a part of QueryParameters struct", "False")]

public int layerMask { get; public set; }
    public BoxcastCommand(Vector3 center, Vector3 halfExtents, Quaternion orientation, Vector3 direction, QueryParameters queryParameters, float distance);
    public BoxcastCommand(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Quaternion orientation, Vector3 direction, QueryParameters queryParameters, float distance);
    [ObsoleteAttribute("This struct signature is no longer supported. Use struct with a QueryParameters instead", "False")]
public BoxcastCommand(Vector3 center, Vector3 halfExtents, Quaternion orientation, Vector3 direction, float distance, int layerMask);
    [ObsoleteAttribute("This struct signature is no longer supported. Use struct with a QueryParameters instead", "False")]
public BoxcastCommand(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Quaternion orientation, Vector3 direction, float distance, int layerMask);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector3 get_center();
    [CompilerGeneratedAttribute]
public void set_center(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector3 get_halfExtents();
    [CompilerGeneratedAttribute]
public void set_halfExtents(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Quaternion get_orientation();
    [CompilerGeneratedAttribute]
public void set_orientation(Quaternion value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_direction();
    [CompilerGeneratedAttribute]
public void set_direction(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_distance();
    [CompilerGeneratedAttribute]
public void set_distance(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PhysicsScene get_physicsScene();
    [CompilerGeneratedAttribute]
public void set_physicsScene(PhysicsScene value);
    public static JobHandle ScheduleBatch(NativeArray`1<BoxcastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, int maxHits, JobHandle dependsOn);
    public static JobHandle ScheduleBatch(NativeArray`1<BoxcastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn);
    [FreeFunctionAttribute("ScheduleBoxcastCommandBatch")]
private static JobHandle ScheduleBoxcastBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits);
    public int get_layerMask();
    public void set_layerMask(int value);
    private static void ScheduleBoxcastBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits, JobHandle& ret);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/Physics/BoxCollider.h")]
public class UnityEngine.BoxCollider : Collider {
    
public Vector3 center { get; public set; }
    
public Vector3 size { get; public set; }
    [ObsoleteAttribute("Use BoxCollider.size instead. (UnityUpgradable) -> size")]

public Vector3 extents { get; public set; }
    public Vector3 get_center();
    public void set_center(Vector3 value);
    public Vector3 get_size();
    public void set_size(Vector3 value);
    public Vector3 get_extents();
    public void set_extents(Vector3 value);
    private void get_center_Injected(Vector3& ret);
    private void set_center_Injected(Vector3& value);
    private void get_size_Injected(Vector3& ret);
    private void set_size_Injected(Vector3& value);
}
[NativeHeaderAttribute("Modules/Physics/BatchCommands/CapsulecastCommand.h")]
[NativeHeaderAttribute("Runtime/Jobs/ScriptBindings/JobsBindingsTypes.h")]
public class UnityEngine.CapsulecastCommand : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Vector3 <point1>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <point2>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private float <radius>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <direction>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private float <distance>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private PhysicsScene <physicsScene>k__BackingField;
    
public QueryParameters queryParameters;
    
public Vector3 point1 { get; public set; }
    
public Vector3 point2 { get; public set; }
    
public float radius { get; public set; }
    
public Vector3 direction { get; public set; }
    
public float distance { get; public set; }
    
public PhysicsScene physicsScene { get; public set; }
    [ObsoleteAttribute("Layer Mask is now a part of QueryParameters struct", "False")]

public int layerMask { get; public set; }
    public CapsulecastCommand(Vector3 p1, Vector3 p2, float radius, Vector3 direction, QueryParameters queryParameters, float distance);
    public CapsulecastCommand(PhysicsScene physicsScene, Vector3 p1, Vector3 p2, float radius, Vector3 direction, QueryParameters queryParameters, float distance);
    [ObsoleteAttribute("This struct signature is no longer supported. Use struct with a QueryParameters instead", "False")]
public CapsulecastCommand(Vector3 p1, Vector3 p2, float radius, Vector3 direction, float distance, int layerMask);
    [ObsoleteAttribute("This struct signature is no longer supported. Use struct with a QueryParameters instead", "False")]
public CapsulecastCommand(PhysicsScene physicsScene, Vector3 p1, Vector3 p2, float radius, Vector3 direction, float distance, int layerMask);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector3 get_point1();
    [CompilerGeneratedAttribute]
public void set_point1(Vector3 value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_point2();
    [CompilerGeneratedAttribute]
public void set_point2(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_radius();
    [CompilerGeneratedAttribute]
public void set_radius(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector3 get_direction();
    [CompilerGeneratedAttribute]
public void set_direction(Vector3 value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public float get_distance();
    [CompilerGeneratedAttribute]
public void set_distance(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PhysicsScene get_physicsScene();
    [CompilerGeneratedAttribute]
public void set_physicsScene(PhysicsScene value);
    public static JobHandle ScheduleBatch(NativeArray`1<CapsulecastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, int maxHits, JobHandle dependsOn);
    public static JobHandle ScheduleBatch(NativeArray`1<CapsulecastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn);
    [FreeFunctionAttribute("ScheduleCapsulecastCommandBatch")]
private static JobHandle ScheduleCapsulecastBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits);
    public int get_layerMask();
    public void set_layerMask(int value);
    private static void ScheduleCapsulecastBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits, JobHandle& ret);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/Physics/CapsuleCollider.h")]
public class UnityEngine.CapsuleCollider : Collider {
    
public Vector3 center { get; public set; }
    
public float radius { get; public set; }
    
public float height { get; public set; }
    
public int direction { get; public set; }
    public Vector3 get_center();
    public void set_center(Vector3 value);
    public float get_radius();
    public void set_radius(float value);
    public float get_height();
    public void set_height(float value);
    public int get_direction();
    public void set_direction(int value);
    internal Vector2 GetGlobalExtents();
    internal Matrix4x4 CalculateTransform();
    private void get_center_Injected(Vector3& ret);
    private void set_center_Injected(Vector3& value);
    private void GetGlobalExtents_Injected(Vector2& ret);
    private void CalculateTransform_Injected(Matrix4x4& ret);
}
[NativeHeaderAttribute("Modules/Physics/CharacterController.h")]
public class UnityEngine.CharacterController : Collider {
    
public Vector3 velocity { get; }
    
public bool isGrounded { get; }
    
public CollisionFlags collisionFlags { get; }
    
public float radius { get; public set; }
    
public float height { get; public set; }
    
public Vector3 center { get; public set; }
    
public float slopeLimit { get; public set; }
    
public float stepOffset { get; public set; }
    
public float skinWidth { get; public set; }
    
public float minMoveDistance { get; public set; }
    
public bool detectCollisions { get; public set; }
    
public bool enableOverlapRecovery { get; public set; }
    public bool SimpleMove(Vector3 speed);
    public CollisionFlags Move(Vector3 motion);
    public Vector3 get_velocity();
    [NativeNameAttribute("IsGrounded")]
public bool get_isGrounded();
    public CollisionFlags get_collisionFlags();
    public float get_radius();
    public void set_radius(float value);
    public float get_height();
    public void set_height(float value);
    public Vector3 get_center();
    public void set_center(Vector3 value);
    public float get_slopeLimit();
    public void set_slopeLimit(float value);
    public float get_stepOffset();
    public void set_stepOffset(float value);
    public float get_skinWidth();
    public void set_skinWidth(float value);
    public float get_minMoveDistance();
    public void set_minMoveDistance(float value);
    public bool get_detectCollisions();
    public void set_detectCollisions(bool value);
    public bool get_enableOverlapRecovery();
    public void set_enableOverlapRecovery(bool value);
    private bool SimpleMove_Injected(Vector3& speed);
    private CollisionFlags Move_Injected(Vector3& motion);
    private void get_velocity_Injected(Vector3& ret);
    private void get_center_Injected(Vector3& ret);
    private void set_center_Injected(Vector3& value);
}
[NativeClassAttribute("Unity::CharacterJoint")]
[NativeHeaderAttribute("Modules/Physics/CharacterJoint.h")]
public class UnityEngine.CharacterJoint : Joint {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("TargetRotation not in use for Unity 5 and assumed disabled.", "True")]

public Quaternion targetRotation;
    [ObsoleteAttribute("TargetAngularVelocity not in use for Unity 5 and assumed disabled.", "True")]
[EditorBrowsableAttribute("1")]

public Vector3 targetAngularVelocity;
    [ObsoleteAttribute("RotationDrive not in use for Unity 5 and assumed disabled.", "True")]
[EditorBrowsableAttribute("1")]

public JointDrive rotationDrive;
    
public Vector3 swingAxis { get; public set; }
    
public SoftJointLimitSpring twistLimitSpring { get; public set; }
    
public SoftJointLimitSpring swingLimitSpring { get; public set; }
    
public SoftJointLimit lowTwistLimit { get; public set; }
    
public SoftJointLimit highTwistLimit { get; public set; }
    
public SoftJointLimit swing1Limit { get; public set; }
    
public SoftJointLimit swing2Limit { get; public set; }
    
public bool enableProjection { get; public set; }
    
public float projectionDistance { get; public set; }
    
public float projectionAngle { get; public set; }
    public Vector3 get_swingAxis();
    public void set_swingAxis(Vector3 value);
    public SoftJointLimitSpring get_twistLimitSpring();
    public void set_twistLimitSpring(SoftJointLimitSpring value);
    public SoftJointLimitSpring get_swingLimitSpring();
    public void set_swingLimitSpring(SoftJointLimitSpring value);
    public SoftJointLimit get_lowTwistLimit();
    public void set_lowTwistLimit(SoftJointLimit value);
    public SoftJointLimit get_highTwistLimit();
    public void set_highTwistLimit(SoftJointLimit value);
    public SoftJointLimit get_swing1Limit();
    public void set_swing1Limit(SoftJointLimit value);
    public SoftJointLimit get_swing2Limit();
    public void set_swing2Limit(SoftJointLimit value);
    public bool get_enableProjection();
    public void set_enableProjection(bool value);
    public float get_projectionDistance();
    public void set_projectionDistance(float value);
    public float get_projectionAngle();
    public void set_projectionAngle(float value);
    private void get_swingAxis_Injected(Vector3& ret);
    private void set_swingAxis_Injected(Vector3& value);
    private void get_twistLimitSpring_Injected(SoftJointLimitSpring& ret);
    private void set_twistLimitSpring_Injected(SoftJointLimitSpring& value);
    private void get_swingLimitSpring_Injected(SoftJointLimitSpring& ret);
    private void set_swingLimitSpring_Injected(SoftJointLimitSpring& value);
    private void get_lowTwistLimit_Injected(SoftJointLimit& ret);
    private void set_lowTwistLimit_Injected(SoftJointLimit& value);
    private void get_highTwistLimit_Injected(SoftJointLimit& ret);
    private void set_highTwistLimit_Injected(SoftJointLimit& value);
    private void get_swing1Limit_Injected(SoftJointLimit& ret);
    private void set_swing1Limit_Injected(SoftJointLimit& value);
    private void get_swing2Limit_Injected(SoftJointLimit& ret);
    private void set_swing2Limit_Injected(SoftJointLimit& value);
}
[NativeHeaderAttribute("Runtime/Jobs/ScriptBindings/JobsBindingsTypes.h")]
[NativeHeaderAttribute("Modules/Physics/BatchCommands/ClosestPointCommand.h")]
public class UnityEngine.ClosestPointCommand : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <point>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private int <colliderInstanceID>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <position>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Quaternion <rotation>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <scale>k__BackingField;
    
public Vector3 point { get; public set; }
    
public int colliderInstanceID { get; public set; }
    
public Vector3 position { get; public set; }
    
public Quaternion rotation { get; public set; }
    
public Vector3 scale { get; public set; }
    public ClosestPointCommand(Vector3 point, int colliderInstanceID, Vector3 position, Quaternion rotation, Vector3 scale);
    public ClosestPointCommand(Vector3 point, Collider collider, Vector3 position, Quaternion rotation, Vector3 scale);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_point();
    [CompilerGeneratedAttribute]
public void set_point(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_colliderInstanceID();
    [CompilerGeneratedAttribute]
public void set_colliderInstanceID(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_position();
    [CompilerGeneratedAttribute]
public void set_position(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Quaternion get_rotation();
    [CompilerGeneratedAttribute]
public void set_rotation(Quaternion value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector3 get_scale();
    [CompilerGeneratedAttribute]
public void set_scale(Vector3 value);
    public static JobHandle ScheduleBatch(NativeArray`1<ClosestPointCommand> commands, NativeArray`1<Vector3> results, int minCommandsPerJob, JobHandle dependsOn);
    [FreeFunctionAttribute("ScheduleClosestPointCommandBatch")]
private static JobHandle ScheduleClosestPointCommandBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob);
    private static void ScheduleClosestPointCommandBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, JobHandle& ret);
}
[NativeHeaderAttribute("Modules/Physics/Collider.h")]
[RequireComponent("UnityEngine.Transform")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.Collider : Component {
    
public bool enabled { get; public set; }
    
public Rigidbody attachedRigidbody { get; }
    
public ArticulationBody attachedArticulationBody { get; }
    
public bool isTrigger { get; public set; }
    
public float contactOffset { get; public set; }
    
public Bounds bounds { get; }
    
public bool hasModifiableContacts { get; public set; }
    
public bool providesContacts { get; public set; }
    
public int layerOverridePriority { get; public set; }
    
public LayerMask excludeLayers { get; public set; }
    
public LayerMask includeLayers { get; public set; }
    [NativeMethodAttribute("Material")]

public PhysicMaterial sharedMaterial { get; public set; }
    
public PhysicMaterial material { get; public set; }
    public bool get_enabled();
    public void set_enabled(bool value);
    [NativeMethodAttribute("GetRigidbody")]
public Rigidbody get_attachedRigidbody();
    [NativeMethodAttribute("GetArticulationBody")]
public ArticulationBody get_attachedArticulationBody();
    public bool get_isTrigger();
    public void set_isTrigger(bool value);
    public float get_contactOffset();
    public void set_contactOffset(float value);
    public Vector3 ClosestPoint(Vector3 position);
    public Bounds get_bounds();
    public bool get_hasModifiableContacts();
    public void set_hasModifiableContacts(bool value);
    public bool get_providesContacts();
    public void set_providesContacts(bool value);
    public int get_layerOverridePriority();
    public void set_layerOverridePriority(int value);
    public LayerMask get_excludeLayers();
    public void set_excludeLayers(LayerMask value);
    public LayerMask get_includeLayers();
    public void set_includeLayers(LayerMask value);
    public PhysicMaterial get_sharedMaterial();
    public void set_sharedMaterial(PhysicMaterial value);
    [NativeMethodAttribute("GetClonedMaterial")]
public PhysicMaterial get_material();
    [NativeMethodAttribute("SetMaterial")]
public void set_material(PhysicMaterial value);
    private RaycastHit Raycast(Ray ray, float maxDistance, Boolean& hasHit);
    public bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance);
    [NativeNameAttribute("ClosestPointOnBounds")]
private void Internal_ClosestPointOnBounds(Vector3 point, Vector3& outPos, Single& distance);
    public Vector3 ClosestPointOnBounds(Vector3 position);
    private void ClosestPoint_Injected(Vector3& position, Vector3& ret);
    private void get_bounds_Injected(Bounds& ret);
    private void get_excludeLayers_Injected(LayerMask& ret);
    private void set_excludeLayers_Injected(LayerMask& value);
    private void get_includeLayers_Injected(LayerMask& ret);
    private void set_includeLayers_Injected(LayerMask& value);
    private void Raycast_Injected(Ray& ray, float maxDistance, Boolean& hasHit, RaycastHit& ret);
    private void Internal_ClosestPointOnBounds_Injected(Vector3& point, Vector3& outPos, Single& distance);
}
public class UnityEngine.ColliderHit : ValueType {
    
private int m_ColliderInstanceID;
    
public int instanceID { get; }
    
public Collider collider { get; }
    public int get_instanceID();
    public Collider get_collider();
}
public class UnityEngine.Collision : object {
    
private ContactPairHeader m_Header;
    
private ContactPair m_Pair;
    
private bool m_Flipped;
    
private ContactPoint[] m_LegacyContacts;
    
public Vector3 impulse { get; }
    
public Vector3 relativeVelocity { get; }
    
public Rigidbody rigidbody { get; }
    
public ArticulationBody articulationBody { get; }
    
public Component body { get; }
    
public Collider collider { get; }
    
public Transform transform { get; }
    
public GameObject gameObject { get; }
    
internal bool Flipped { get; internal set; }
    
public int contactCount { get; }
    
public ContactPoint[] contacts { get; }
    [ObsoleteAttribute("Use Collision.relativeVelocity instead. (UnityUpgradable) -> relativeVelocity", "False")]
[EditorBrowsableAttribute("1")]

public Vector3 impactForceSum { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Will always return zero.", "True")]

public Vector3 frictionForceSum { get; }
    [ObsoleteAttribute("Please use Collision.rigidbody, Collision.transform or Collision.collider instead", "False")]
[EditorBrowsableAttribute("1")]

public Component other { get; }
    internal Collision(ContactPairHeader& header, ContactPair& pair, bool flipped);
    public Vector3 get_impulse();
    public Vector3 get_relativeVelocity();
    public Rigidbody get_rigidbody();
    public ArticulationBody get_articulationBody();
    public Component get_body();
    public Collider get_collider();
    public Transform get_transform();
    public GameObject get_gameObject();
    internal bool get_Flipped();
    internal void set_Flipped(bool value);
    public int get_contactCount();
    public ContactPoint[] get_contacts();
    internal void Reuse(ContactPairHeader& header, ContactPair& pair);
    public ContactPoint GetContact(int index);
    public int GetContacts(ContactPoint[] contacts);
    public int GetContacts(List`1<ContactPoint> contacts);
    [ObsoleteAttribute("Do not use Collision.GetEnumerator(), enumerate using non-allocating array returned by Collision.GetContacts() or enumerate using Collision.GetContact(index) instead.", "False")]
[EditorBrowsableAttribute("1")]
public virtual IEnumerator GetEnumerator();
    public Vector3 get_impactForceSum();
    public Vector3 get_frictionForceSum();
    public Component get_other();
}
public enum UnityEngine.CollisionDetectionMode : Enum {
    
public int value__;
    
public static CollisionDetectionMode Discrete;
    
public static CollisionDetectionMode Continuous;
    
public static CollisionDetectionMode ContinuousDynamic;
    
public static CollisionDetectionMode ContinuousSpeculative;
}
public enum UnityEngine.CollisionFlags : Enum {
    
public int value__;
    
public static CollisionFlags None;
    
public static CollisionFlags Sides;
    
public static CollisionFlags Above;
    
public static CollisionFlags Below;
    
public static CollisionFlags CollidedSides;
    
public static CollisionFlags CollidedAbove;
    
public static CollisionFlags CollidedBelow;
}
internal enum UnityEngine.CollisionPairEventFlags : Enum {
    
public ushort value__;
    
public static CollisionPairEventFlags SolveContacts;
    
public static CollisionPairEventFlags ModifyContacts;
    
public static CollisionPairEventFlags NotifyTouchFound;
    
public static CollisionPairEventFlags NotifyTouchPersists;
    
public static CollisionPairEventFlags NotifyTouchLost;
    
public static CollisionPairEventFlags NotifyTouchCCD;
    
public static CollisionPairEventFlags NotifyThresholdForceFound;
    
public static CollisionPairEventFlags NotifyThresholdForcePersists;
    
public static CollisionPairEventFlags NotifyThresholdForceLost;
    
public static CollisionPairEventFlags NotifyContactPoint;
    
public static CollisionPairEventFlags DetectDiscreteContact;
    
public static CollisionPairEventFlags DetectCCDContact;
    
public static CollisionPairEventFlags PreSolverVelocity;
    
public static CollisionPairEventFlags PostSolverVelocity;
    
public static CollisionPairEventFlags ContactEventPose;
    
public static CollisionPairEventFlags NextFree;
    
public static CollisionPairEventFlags ContactDefault;
    
public static CollisionPairEventFlags TriggerDefault;
}
internal enum UnityEngine.CollisionPairFlags : Enum {
    
public ushort value__;
    
public static CollisionPairFlags RemovedShape;
    
public static CollisionPairFlags RemovedOtherShape;
    
public static CollisionPairFlags ActorPairHasFirstTouch;
    
public static CollisionPairFlags ActorPairLostTouch;
    
public static CollisionPairFlags InternalHasImpulses;
    
public static CollisionPairFlags InternalContactsAreFlipped;
}
internal enum UnityEngine.CollisionPairHeaderFlags : Enum {
    
public ushort value__;
    
public static CollisionPairHeaderFlags RemovedActor;
    
public static CollisionPairHeaderFlags RemovedOtherActor;
}
[NativeClassAttribute("Unity::ConfigurableJoint")]
[NativeHeaderAttribute("Modules/Physics/ConfigurableJoint.h")]
public class UnityEngine.ConfigurableJoint : Joint {
    
public Vector3 secondaryAxis { get; public set; }
    
public ConfigurableJointMotion xMotion { get; public set; }
    
public ConfigurableJointMotion yMotion { get; public set; }
    
public ConfigurableJointMotion zMotion { get; public set; }
    
public ConfigurableJointMotion angularXMotion { get; public set; }
    
public ConfigurableJointMotion angularYMotion { get; public set; }
    
public ConfigurableJointMotion angularZMotion { get; public set; }
    
public SoftJointLimitSpring linearLimitSpring { get; public set; }
    
public SoftJointLimitSpring angularXLimitSpring { get; public set; }
    
public SoftJointLimitSpring angularYZLimitSpring { get; public set; }
    
public SoftJointLimit linearLimit { get; public set; }
    
public SoftJointLimit lowAngularXLimit { get; public set; }
    
public SoftJointLimit highAngularXLimit { get; public set; }
    
public SoftJointLimit angularYLimit { get; public set; }
    
public SoftJointLimit angularZLimit { get; public set; }
    
public Vector3 targetPosition { get; public set; }
    
public Vector3 targetVelocity { get; public set; }
    
public JointDrive xDrive { get; public set; }
    
public JointDrive yDrive { get; public set; }
    
public JointDrive zDrive { get; public set; }
    
public Quaternion targetRotation { get; public set; }
    
public Vector3 targetAngularVelocity { get; public set; }
    
public RotationDriveMode rotationDriveMode { get; public set; }
    
public JointDrive angularXDrive { get; public set; }
    
public JointDrive angularYZDrive { get; public set; }
    
public JointDrive slerpDrive { get; public set; }
    
public JointProjectionMode projectionMode { get; public set; }
    
public float projectionDistance { get; public set; }
    
public float projectionAngle { get; public set; }
    
public bool configuredInWorldSpace { get; public set; }
    
public bool swapBodies { get; public set; }
    public Vector3 get_secondaryAxis();
    public void set_secondaryAxis(Vector3 value);
    public ConfigurableJointMotion get_xMotion();
    public void set_xMotion(ConfigurableJointMotion value);
    public ConfigurableJointMotion get_yMotion();
    public void set_yMotion(ConfigurableJointMotion value);
    public ConfigurableJointMotion get_zMotion();
    public void set_zMotion(ConfigurableJointMotion value);
    public ConfigurableJointMotion get_angularXMotion();
    public void set_angularXMotion(ConfigurableJointMotion value);
    public ConfigurableJointMotion get_angularYMotion();
    public void set_angularYMotion(ConfigurableJointMotion value);
    public ConfigurableJointMotion get_angularZMotion();
    public void set_angularZMotion(ConfigurableJointMotion value);
    public SoftJointLimitSpring get_linearLimitSpring();
    public void set_linearLimitSpring(SoftJointLimitSpring value);
    public SoftJointLimitSpring get_angularXLimitSpring();
    public void set_angularXLimitSpring(SoftJointLimitSpring value);
    public SoftJointLimitSpring get_angularYZLimitSpring();
    public void set_angularYZLimitSpring(SoftJointLimitSpring value);
    public SoftJointLimit get_linearLimit();
    public void set_linearLimit(SoftJointLimit value);
    public SoftJointLimit get_lowAngularXLimit();
    public void set_lowAngularXLimit(SoftJointLimit value);
    public SoftJointLimit get_highAngularXLimit();
    public void set_highAngularXLimit(SoftJointLimit value);
    public SoftJointLimit get_angularYLimit();
    public void set_angularYLimit(SoftJointLimit value);
    public SoftJointLimit get_angularZLimit();
    public void set_angularZLimit(SoftJointLimit value);
    public Vector3 get_targetPosition();
    public void set_targetPosition(Vector3 value);
    public Vector3 get_targetVelocity();
    public void set_targetVelocity(Vector3 value);
    public JointDrive get_xDrive();
    public void set_xDrive(JointDrive value);
    public JointDrive get_yDrive();
    public void set_yDrive(JointDrive value);
    public JointDrive get_zDrive();
    public void set_zDrive(JointDrive value);
    public Quaternion get_targetRotation();
    public void set_targetRotation(Quaternion value);
    public Vector3 get_targetAngularVelocity();
    public void set_targetAngularVelocity(Vector3 value);
    public RotationDriveMode get_rotationDriveMode();
    public void set_rotationDriveMode(RotationDriveMode value);
    public JointDrive get_angularXDrive();
    public void set_angularXDrive(JointDrive value);
    public JointDrive get_angularYZDrive();
    public void set_angularYZDrive(JointDrive value);
    public JointDrive get_slerpDrive();
    public void set_slerpDrive(JointDrive value);
    public JointProjectionMode get_projectionMode();
    public void set_projectionMode(JointProjectionMode value);
    public float get_projectionDistance();
    public void set_projectionDistance(float value);
    public float get_projectionAngle();
    public void set_projectionAngle(float value);
    public bool get_configuredInWorldSpace();
    public void set_configuredInWorldSpace(bool value);
    public bool get_swapBodies();
    public void set_swapBodies(bool value);
    private void get_secondaryAxis_Injected(Vector3& ret);
    private void set_secondaryAxis_Injected(Vector3& value);
    private void get_linearLimitSpring_Injected(SoftJointLimitSpring& ret);
    private void set_linearLimitSpring_Injected(SoftJointLimitSpring& value);
    private void get_angularXLimitSpring_Injected(SoftJointLimitSpring& ret);
    private void set_angularXLimitSpring_Injected(SoftJointLimitSpring& value);
    private void get_angularYZLimitSpring_Injected(SoftJointLimitSpring& ret);
    private void set_angularYZLimitSpring_Injected(SoftJointLimitSpring& value);
    private void get_linearLimit_Injected(SoftJointLimit& ret);
    private void set_linearLimit_Injected(SoftJointLimit& value);
    private void get_lowAngularXLimit_Injected(SoftJointLimit& ret);
    private void set_lowAngularXLimit_Injected(SoftJointLimit& value);
    private void get_highAngularXLimit_Injected(SoftJointLimit& ret);
    private void set_highAngularXLimit_Injected(SoftJointLimit& value);
    private void get_angularYLimit_Injected(SoftJointLimit& ret);
    private void set_angularYLimit_Injected(SoftJointLimit& value);
    private void get_angularZLimit_Injected(SoftJointLimit& ret);
    private void set_angularZLimit_Injected(SoftJointLimit& value);
    private void get_targetPosition_Injected(Vector3& ret);
    private void set_targetPosition_Injected(Vector3& value);
    private void get_targetVelocity_Injected(Vector3& ret);
    private void set_targetVelocity_Injected(Vector3& value);
    private void get_xDrive_Injected(JointDrive& ret);
    private void set_xDrive_Injected(JointDrive& value);
    private void get_yDrive_Injected(JointDrive& ret);
    private void set_yDrive_Injected(JointDrive& value);
    private void get_zDrive_Injected(JointDrive& ret);
    private void set_zDrive_Injected(JointDrive& value);
    private void get_targetRotation_Injected(Quaternion& ret);
    private void set_targetRotation_Injected(Quaternion& value);
    private void get_targetAngularVelocity_Injected(Vector3& ret);
    private void set_targetAngularVelocity_Injected(Vector3& value);
    private void get_angularXDrive_Injected(JointDrive& ret);
    private void set_angularXDrive_Injected(JointDrive& value);
    private void get_angularYZDrive_Injected(JointDrive& ret);
    private void set_angularYZDrive_Injected(JointDrive& value);
    private void get_slerpDrive_Injected(JointDrive& ret);
    private void set_slerpDrive_Injected(JointDrive& value);
}
public enum UnityEngine.ConfigurableJointMotion : Enum {
    
public int value__;
    
public static ConfigurableJointMotion Locked;
    
public static ConfigurableJointMotion Limited;
    
public static ConfigurableJointMotion Free;
}
[RequireComponent("UnityEngine.Rigidbody")]
[NativeHeaderAttribute("Modules/Physics/ConstantForce.h")]
public class UnityEngine.ConstantForce : Behaviour {
    
public Vector3 force { get; public set; }
    
public Vector3 relativeForce { get; public set; }
    
public Vector3 torque { get; public set; }
    
public Vector3 relativeTorque { get; public set; }
    public Vector3 get_force();
    public void set_force(Vector3 value);
    public Vector3 get_relativeForce();
    public void set_relativeForce(Vector3 value);
    public Vector3 get_torque();
    public void set_torque(Vector3 value);
    public Vector3 get_relativeTorque();
    public void set_relativeTorque(Vector3 value);
    private void get_force_Injected(Vector3& ret);
    private void set_force_Injected(Vector3& value);
    private void get_relativeForce_Injected(Vector3& ret);
    private void set_relativeForce_Injected(Vector3& value);
    private void get_torque_Injected(Vector3& ret);
    private void set_torque_Injected(Vector3& value);
    private void get_relativeTorque_Injected(Vector3& ret);
    private void set_relativeTorque_Injected(Vector3& value);
}
[IsReadOnlyAttribute]
[UsedByNativeCodeAttribute]
public class UnityEngine.ContactPair : ValueType {
    
private static UInt32 c_InvalidFaceIndex;
    
internal int m_ColliderID;
    
internal int m_OtherColliderID;
    
internal IntPtr m_StartPtr;
    
internal UInt32 m_NbPoints;
    
internal CollisionPairFlags m_Flags;
    
internal CollisionPairEventFlags m_Events;
    
internal Vector3 m_ImpulseSum;
    
public int ColliderInstanceID { get; }
    
public int OtherColliderInstanceID { get; }
    
public Collider Collider { get; }
    
public Collider OtherCollider { get; }
    
public int ContactCount { get; }
    
public Vector3 ImpulseSum { get; }
    
public bool IsCollisionEnter { get; }
    
public bool IsCollisionExit { get; }
    
public bool IsCollisionStay { get; }
    
internal bool HasRemovedCollider { get; }
    public int get_ColliderInstanceID();
    public int get_OtherColliderInstanceID();
    public Collider get_Collider();
    public Collider get_OtherCollider();
    public int get_ContactCount();
    public Vector3 get_ImpulseSum();
    public bool get_IsCollisionEnter();
    public bool get_IsCollisionExit();
    public bool get_IsCollisionStay();
    internal bool get_HasRemovedCollider();
    internal int ExtractContacts(List`1<ContactPoint> managedContainer, bool flipped);
    internal int ExtractContactsArray(ContactPoint[] managedContainer, bool flipped);
    public void CopyToNativeArray(NativeArray`1<ContactPairPoint> buffer);
    public ContactPairPoint& modreq(System.Runtime.InteropServices.InAttribute) GetContactPoint(int index);
    public UInt32 GetContactPointFaceIndex(int contactIndex);
    internal ContactPairPoint* GetContactPoint_Internal(int index);
    private static int ExtractContacts_Injected(ContactPair& _unity_self, List`1<ContactPoint> managedContainer, bool flipped);
    private static int ExtractContactsArray_Injected(ContactPair& _unity_self, ContactPoint[] managedContainer, bool flipped);
}
[IsReadOnlyAttribute]
public class UnityEngine.ContactPairHeader : ValueType {
    
internal int m_BodyID;
    
internal int m_OtherBodyID;
    
internal IntPtr m_StartPtr;
    
internal UInt32 m_NbPairs;
    
internal CollisionPairHeaderFlags m_Flags;
    
internal Vector3 m_RelativeVelocity;
    
public int BodyInstanceID { get; }
    
public int OtherBodyInstanceID { get; }
    
public Component Body { get; }
    
public Component OtherBody { get; }
    
public int PairCount { get; }
    
internal bool HasRemovedBody { get; }
    public int get_BodyInstanceID();
    public int get_OtherBodyInstanceID();
    public Component get_Body();
    public Component get_OtherBody();
    public int get_PairCount();
    internal bool get_HasRemovedBody();
    public ContactPair& modreq(System.Runtime.InteropServices.InAttribute) GetContactPair(int index);
    internal ContactPair* GetContactPair_Internal(int index);
}
[IsReadOnlyAttribute]
public class UnityEngine.ContactPairPoint : ValueType {
    
internal Vector3 m_Position;
    
internal float m_Separation;
    
internal Vector3 m_Normal;
    
internal UInt32 m_InternalFaceIndex0;
    
internal Vector3 m_Impulse;
    
internal UInt32 m_InternalFaceIndex1;
    
public Vector3 Position { get; }
    
public float Separation { get; }
    
public Vector3 Normal { get; }
    
public Vector3 Impulse { get; }
    public Vector3 get_Position();
    public float get_Separation();
    public Vector3 get_Normal();
    public Vector3 get_Impulse();
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/Physics/MessageParameters.h")]
public class UnityEngine.ContactPoint : ValueType {
    
internal Vector3 m_Point;
    
internal Vector3 m_Normal;
    
internal Vector3 m_Impulse;
    
internal int m_ThisColliderInstanceID;
    
internal int m_OtherColliderInstanceID;
    
internal float m_Separation;
    
public Vector3 point { get; }
    
public Vector3 normal { get; }
    
public Vector3 impulse { get; }
    
public Collider thisCollider { get; }
    
public Collider otherCollider { get; }
    
public float separation { get; }
    internal ContactPoint(Vector3 point, Vector3 normal, Vector3 impulse, float separation, int thisInstanceID, int otherInstenceID);
    public Vector3 get_point();
    public Vector3 get_normal();
    public Vector3 get_impulse();
    public Collider get_thisCollider();
    public Collider get_otherCollider();
    public float get_separation();
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.ControllerColliderHit : object {
    
internal CharacterController m_Controller;
    
internal Collider m_Collider;
    
internal Vector3 m_Point;
    
internal Vector3 m_Normal;
    
internal Vector3 m_MoveDirection;
    
internal float m_MoveLength;
    
internal int m_Push;
    
public CharacterController controller { get; }
    
public Collider collider { get; }
    
public Rigidbody rigidbody { get; }
    
public GameObject gameObject { get; }
    
public Transform transform { get; }
    
public Vector3 point { get; }
    
public Vector3 normal { get; }
    
public Vector3 moveDirection { get; }
    
public float moveLength { get; }
    
private bool push { get; private set; }
    public CharacterController get_controller();
    public Collider get_collider();
    public Rigidbody get_rigidbody();
    public GameObject get_gameObject();
    public Transform get_transform();
    public Vector3 get_point();
    public Vector3 get_normal();
    public Vector3 get_moveDirection();
    public float get_moveLength();
    private bool get_push();
    private void set_push(bool value);
}
[NativeHeaderAttribute("Modules/Physics/FixedJoint.h")]
[NativeClassAttribute("Unity::FixedJoint")]
public class UnityEngine.FixedJoint : Joint {
}
public enum UnityEngine.ForceMode : Enum {
    
public int value__;
    
public static ForceMode Force;
    
public static ForceMode Acceleration;
    
public static ForceMode Impulse;
    
public static ForceMode VelocityChange;
}
[NativeClassAttribute("Unity::HingeJoint")]
[NativeHeaderAttribute("Modules/Physics/HingeJoint.h")]
public class UnityEngine.HingeJoint : Joint {
    
public JointMotor motor { get; public set; }
    
public JointLimits limits { get; public set; }
    
public JointSpring spring { get; public set; }
    
public bool useMotor { get; public set; }
    
public bool useLimits { get; public set; }
    
public bool extendedLimits { get; public set; }
    
public bool useSpring { get; public set; }
    
public float velocity { get; }
    
public float angle { get; }
    
public bool useAcceleration { get; public set; }
    public JointMotor get_motor();
    public void set_motor(JointMotor value);
    public JointLimits get_limits();
    public void set_limits(JointLimits value);
    public JointSpring get_spring();
    public void set_spring(JointSpring value);
    public bool get_useMotor();
    public void set_useMotor(bool value);
    public bool get_useLimits();
    public void set_useLimits(bool value);
    public bool get_extendedLimits();
    public void set_extendedLimits(bool value);
    public bool get_useSpring();
    public void set_useSpring(bool value);
    public float get_velocity();
    public float get_angle();
    public bool get_useAcceleration();
    public void set_useAcceleration(bool value);
    private void get_motor_Injected(JointMotor& ret);
    private void set_motor_Injected(JointMotor& value);
    private void get_limits_Injected(JointLimits& ret);
    private void set_limits_Injected(JointLimits& value);
    private void get_spring_Injected(JointSpring& ret);
    private void set_spring_Injected(JointSpring& value);
}
[RequireComponent("UnityEngine.Rigidbody")]
[NativeHeaderAttribute("Modules/Physics/Joint.h")]
[NativeClassAttribute("Unity::Joint")]
public class UnityEngine.Joint : Component {
    
public Rigidbody connectedBody { get; public set; }
    
public ArticulationBody connectedArticulationBody { get; public set; }
    
public Vector3 axis { get; public set; }
    
public Vector3 anchor { get; public set; }
    
public Vector3 connectedAnchor { get; public set; }
    
public bool autoConfigureConnectedAnchor { get; public set; }
    
public float breakForce { get; public set; }
    
public float breakTorque { get; public set; }
    
public bool enableCollision { get; public set; }
    
public bool enablePreprocessing { get; public set; }
    
public float massScale { get; public set; }
    
public float connectedMassScale { get; public set; }
    
public Vector3 currentForce { get; }
    
public Vector3 currentTorque { get; }
    public Rigidbody get_connectedBody();
    public void set_connectedBody(Rigidbody value);
    public ArticulationBody get_connectedArticulationBody();
    public void set_connectedArticulationBody(ArticulationBody value);
    public Vector3 get_axis();
    public void set_axis(Vector3 value);
    public Vector3 get_anchor();
    public void set_anchor(Vector3 value);
    public Vector3 get_connectedAnchor();
    public void set_connectedAnchor(Vector3 value);
    public bool get_autoConfigureConnectedAnchor();
    public void set_autoConfigureConnectedAnchor(bool value);
    public float get_breakForce();
    public void set_breakForce(float value);
    public float get_breakTorque();
    public void set_breakTorque(float value);
    public bool get_enableCollision();
    public void set_enableCollision(bool value);
    public bool get_enablePreprocessing();
    public void set_enablePreprocessing(bool value);
    public float get_massScale();
    public void set_massScale(float value);
    public float get_connectedMassScale();
    public void set_connectedMassScale(float value);
    private void GetCurrentForces(Vector3& linearForce, Vector3& angularForce);
    public Vector3 get_currentForce();
    public Vector3 get_currentTorque();
    private void get_axis_Injected(Vector3& ret);
    private void set_axis_Injected(Vector3& value);
    private void get_anchor_Injected(Vector3& ret);
    private void set_anchor_Injected(Vector3& value);
    private void get_connectedAnchor_Injected(Vector3& ret);
    private void set_connectedAnchor_Injected(Vector3& value);
}
public class UnityEngine.JointDrive : ValueType {
    
private float m_PositionSpring;
    
private float m_PositionDamper;
    
private float m_MaximumForce;
    
private int m_UseAcceleration;
    
public float positionSpring { get; public set; }
    
public float positionDamper { get; public set; }
    
public float maximumForce { get; public set; }
    
public bool useAcceleration { get; public set; }
    [ObsoleteAttribute("JointDriveMode is obsolete")]

public JointDriveMode mode { get; public set; }
    public float get_positionSpring();
    public void set_positionSpring(float value);
    public float get_positionDamper();
    public void set_positionDamper(float value);
    public float get_maximumForce();
    public void set_maximumForce(float value);
    public bool get_useAcceleration();
    public void set_useAcceleration(bool value);
    public JointDriveMode get_mode();
    public void set_mode(JointDriveMode value);
}
[FlagsAttribute]
[ObsoleteAttribute("JointDriveMode is no longer supported")]
public enum UnityEngine.JointDriveMode : Enum {
    
public int value__;
    [ObsoleteAttribute("JointDriveMode.None is no longer supported")]

public static JointDriveMode None;
    [ObsoleteAttribute("JointDriveMode.Position is no longer supported")]

public static JointDriveMode Position;
    [ObsoleteAttribute("JointDriveMode.Velocity is no longer supported")]

public static JointDriveMode Velocity;
    [ObsoleteAttribute("JointDriveMode.PositionAndvelocity is no longer supported")]

public static JointDriveMode PositionAndVelocity;
}
public class UnityEngine.JointLimits : ValueType {
    
private float m_Min;
    
private float m_Max;
    
private float m_Bounciness;
    
private float m_BounceMinVelocity;
    
private float m_ContactDistance;
    [ObsoleteAttribute("minBounce and maxBounce are replaced by a single JointLimits.bounciness for both limit ends.", "True")]
[EditorBrowsableAttribute("1")]

public float minBounce;
    [ObsoleteAttribute("minBounce and maxBounce are replaced by a single JointLimits.bounciness for both limit ends.", "True")]
[EditorBrowsableAttribute("1")]

public float maxBounce;
    
public float min { get; public set; }
    
public float max { get; public set; }
    
public float bounciness { get; public set; }
    
public float bounceMinVelocity { get; public set; }
    
public float contactDistance { get; public set; }
    public float get_min();
    public void set_min(float value);
    public float get_max();
    public void set_max(float value);
    public float get_bounciness();
    public void set_bounciness(float value);
    public float get_bounceMinVelocity();
    public void set_bounceMinVelocity(float value);
    public float get_contactDistance();
    public void set_contactDistance(float value);
}
public class UnityEngine.JointMotor : ValueType {
    
private float m_TargetVelocity;
    
private float m_Force;
    
private int m_FreeSpin;
    
public float targetVelocity { get; public set; }
    
public float force { get; public set; }
    
public bool freeSpin { get; public set; }
    public float get_targetVelocity();
    public void set_targetVelocity(float value);
    public float get_force();
    public void set_force(float value);
    public bool get_freeSpin();
    public void set_freeSpin(bool value);
}
public enum UnityEngine.JointProjectionMode : Enum {
    
public int value__;
    
public static JointProjectionMode None;
    
public static JointProjectionMode PositionAndRotation;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("JointProjectionMode.PositionOnly is no longer supported", "True")]

public static JointProjectionMode PositionOnly;
}
public class UnityEngine.JointSpring : ValueType {
    
public float spring;
    
public float damper;
    
public float targetPosition;
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/Physics/MeshCollider.h")]
[NativeHeaderAttribute("Runtime/Graphics/Mesh/Mesh.h")]
public class UnityEngine.MeshCollider : Collider {
    
public Mesh sharedMesh { get; public set; }
    
public bool convex { get; public set; }
    
public MeshColliderCookingOptions cookingOptions { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Configuring smooth sphere collisions is no longer needed.", "True")]

public bool smoothSphereCollisions { get; public set; }
    [ObsoleteAttribute("MeshCollider.skinWidth is no longer used.")]

public float skinWidth { get; public set; }
    [ObsoleteAttribute("MeshCollider.inflateMesh is no longer supported. The new cooking algorithm doesn't need inflation to be used.")]

public bool inflateMesh { get; public set; }
    public Mesh get_sharedMesh();
    public void set_sharedMesh(Mesh value);
    public bool get_convex();
    public void set_convex(bool value);
    public MeshColliderCookingOptions get_cookingOptions();
    public void set_cookingOptions(MeshColliderCookingOptions value);
    public bool get_smoothSphereCollisions();
    public void set_smoothSphereCollisions(bool value);
    public float get_skinWidth();
    public void set_skinWidth(float value);
    public bool get_inflateMesh();
    public void set_inflateMesh(bool value);
}
[FlagsAttribute]
public enum UnityEngine.MeshColliderCookingOptions : Enum {
    
public int value__;
    
public static MeshColliderCookingOptions None;
    [ObsoleteAttribute("No longer used because the problem this was trying to solve is gone since Unity 2018.3", "True")]

public static MeshColliderCookingOptions InflateConvexMesh;
    
public static MeshColliderCookingOptions CookForFasterSimulation;
    
public static MeshColliderCookingOptions EnableMeshCleaning;
    
public static MeshColliderCookingOptions WeldColocatedVertices;
    
public static MeshColliderCookingOptions UseFastMidphase;
}
internal class UnityEngine.ModifiableContact : ValueType {
    
public Vector3 contact;
    
public float separation;
    
public Vector3 targetVelocity;
    
public float maxImpulse;
    
public Vector3 normal;
    
public float restitution;
    
public UInt32 materialFlags;
    
public ushort materialIndex;
    
public ushort otherMaterialIndex;
    
public float staticFriction;
    
public float dynamicFriction;
}
public class UnityEngine.ModifiableContactPair : ValueType {
    
private IntPtr actor;
    
private IntPtr otherActor;
    
private IntPtr shape;
    
private IntPtr otherShape;
    
public Quaternion rotation;
    
public Vector3 position;
    
public Quaternion otherRotation;
    
public Vector3 otherPosition;
    
private int numContacts;
    
private IntPtr contacts;
    
public int colliderInstanceID { get; }
    
public int otherColliderInstanceID { get; }
    
public int bodyInstanceID { get; }
    
public int otherBodyInstanceID { get; }
    
public Vector3 bodyVelocity { get; }
    
public Vector3 bodyAngularVelocity { get; }
    
public Vector3 otherBodyVelocity { get; }
    
public Vector3 otherBodyAngularVelocity { get; }
    
public int contactCount { get; }
    
public ModifiableMassProperties massProperties { get; public set; }
    public int get_colliderInstanceID();
    public int get_otherColliderInstanceID();
    public int get_bodyInstanceID();
    public int get_otherBodyInstanceID();
    public Vector3 get_bodyVelocity();
    public Vector3 get_bodyAngularVelocity();
    public Vector3 get_otherBodyVelocity();
    public Vector3 get_otherBodyAngularVelocity();
    public int get_contactCount();
    public ModifiableMassProperties get_massProperties();
    public void set_massProperties(ModifiableMassProperties value);
    public Vector3 GetPoint(int i);
    public void SetPoint(int i, Vector3 v);
    public Vector3 GetNormal(int i);
    public void SetNormal(int i, Vector3 normal);
    public float GetSeparation(int i);
    public void SetSeparation(int i, float separation);
    public Vector3 GetTargetVelocity(int i);
    public void SetTargetVelocity(int i, Vector3 velocity);
    public float GetBounciness(int i);
    public void SetBounciness(int i, float bounciness);
    public float GetStaticFriction(int i);
    public void SetStaticFriction(int i, float staticFriction);
    public float GetDynamicFriction(int i);
    public void SetDynamicFriction(int i, float dynamicFriction);
    public float GetMaxImpulse(int i);
    public void SetMaxImpulse(int i, float value);
    public void IgnoreContact(int i);
    public UInt32 GetFaceIndex(int i);
    private ModifiableContact* GetContact(int index);
    private ModifiableContactPatch* GetContactPatch();
}
internal class UnityEngine.ModifiableContactPatch : ValueType {
    
public ModifiableMassProperties massProperties;
    
public Vector3 normal;
    
public float restitution;
    
public float dynamicFriction;
    
public float staticFriction;
    
public byte startContactIndex;
    
public byte contactCount;
    
public byte materialFlags;
    
public byte internalFlags;
    
public ushort materialIndex;
    
public ushort otherMaterialIndex;
}
public class UnityEngine.ModifiableMassProperties : ValueType {
    
public float inverseMassScale;
    
public float inverseInertiaScale;
    
public float otherInverseMassScale;
    
public float otherInverseInertiaScale;
}
[NativeHeaderAttribute("Modules/Physics/BatchCommands/OverlapBoxCommand.h")]
public class UnityEngine.OverlapBoxCommand : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <center>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Vector3 <halfExtents>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Quaternion <orientation>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private PhysicsScene <physicsScene>k__BackingField;
    
public QueryParameters queryParameters;
    
public Vector3 center { get; public set; }
    
public Vector3 halfExtents { get; public set; }
    
public Quaternion orientation { get; public set; }
    
public PhysicsScene physicsScene { get; public set; }
    public OverlapBoxCommand(Vector3 center, Vector3 halfExtents, Quaternion orientation, QueryParameters queryParameters);
    public OverlapBoxCommand(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Quaternion orientation, QueryParameters queryParameters);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_center();
    [CompilerGeneratedAttribute]
public void set_center(Vector3 value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_halfExtents();
    [CompilerGeneratedAttribute]
public void set_halfExtents(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Quaternion get_orientation();
    [CompilerGeneratedAttribute]
public void set_orientation(Quaternion value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PhysicsScene get_physicsScene();
    [CompilerGeneratedAttribute]
public void set_physicsScene(PhysicsScene value);
    public static JobHandle ScheduleBatch(NativeArray`1<OverlapBoxCommand> commands, NativeArray`1<ColliderHit> results, int minCommandsPerJob, int maxHits, JobHandle dependsOn);
    [FreeFunctionAttribute("ScheduleOverlapBoxCommandBatch")]
private static JobHandle ScheduleOverlapBoxBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits);
    private static void ScheduleOverlapBoxBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits, JobHandle& ret);
}
[NativeHeaderAttribute("Modules/Physics/BatchCommands/OverlapCapsuleCommand.h")]
public class UnityEngine.OverlapCapsuleCommand : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <point0>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Vector3 <point1>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private float <radius>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private PhysicsScene <physicsScene>k__BackingField;
    
public QueryParameters queryParameters;
    
public Vector3 point0 { get; public set; }
    
public Vector3 point1 { get; public set; }
    
public float radius { get; public set; }
    
public PhysicsScene physicsScene { get; public set; }
    public OverlapCapsuleCommand(Vector3 point0, Vector3 point1, float radius, QueryParameters queryParameters);
    public OverlapCapsuleCommand(PhysicsScene physicsScene, Vector3 point0, Vector3 point1, float radius, QueryParameters queryParameters);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector3 get_point0();
    [CompilerGeneratedAttribute]
public void set_point0(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector3 get_point1();
    [CompilerGeneratedAttribute]
public void set_point1(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_radius();
    [CompilerGeneratedAttribute]
public void set_radius(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PhysicsScene get_physicsScene();
    [CompilerGeneratedAttribute]
public void set_physicsScene(PhysicsScene value);
    public static JobHandle ScheduleBatch(NativeArray`1<OverlapCapsuleCommand> commands, NativeArray`1<ColliderHit> results, int minCommandsPerJob, int maxHits, JobHandle dependsOn);
    [FreeFunctionAttribute("ScheduleOverlapCapsuleCommandBatch")]
private static JobHandle ScheduleOverlapCapsuleBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits);
    private static void ScheduleOverlapCapsuleBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits, JobHandle& ret);
}
[NativeHeaderAttribute("Modules/Physics/BatchCommands/OverlapSphereCommand.h")]
public class UnityEngine.OverlapSphereCommand : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Vector3 <point>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private float <radius>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private PhysicsScene <physicsScene>k__BackingField;
    
public QueryParameters queryParameters;
    
public Vector3 point { get; public set; }
    
public float radius { get; public set; }
    
public PhysicsScene physicsScene { get; public set; }
    public OverlapSphereCommand(Vector3 point, float radius, QueryParameters queryParameters);
    public OverlapSphereCommand(PhysicsScene physicsScene, Vector3 point, float radius, QueryParameters queryParameters);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector3 get_point();
    [CompilerGeneratedAttribute]
public void set_point(Vector3 value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public float get_radius();
    [CompilerGeneratedAttribute]
public void set_radius(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PhysicsScene get_physicsScene();
    [CompilerGeneratedAttribute]
public void set_physicsScene(PhysicsScene value);
    public static JobHandle ScheduleBatch(NativeArray`1<OverlapSphereCommand> commands, NativeArray`1<ColliderHit> results, int minCommandsPerJob, int maxHits, JobHandle dependsOn);
    [FreeFunctionAttribute("ScheduleOverlapSphereCommandBatch")]
private static JobHandle ScheduleOverlapSphereBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits);
    private static void ScheduleOverlapSphereBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits, JobHandle& ret);
}
[NativeHeaderAttribute("Modules/Physics/PhysicMaterial.h")]
public class UnityEngine.PhysicMaterial : Object {
    
public float bounciness { get; public set; }
    
public float dynamicFriction { get; public set; }
    
public float staticFriction { get; public set; }
    
public PhysicMaterialCombine frictionCombine { get; public set; }
    
public PhysicMaterialCombine bounceCombine { get; public set; }
    [ObsoleteAttribute("Use PhysicMaterial.bounciness instead (UnityUpgradable) -> bounciness")]

public float bouncyness { get; public set; }
    [ObsoleteAttribute("Anisotropic friction is no longer supported since Unity 5.0.", "True")]
[EditorBrowsableAttribute("1")]

public Vector3 frictionDirection2 { get; public set; }
    [ObsoleteAttribute("Anisotropic friction is no longer supported since Unity 5.0.", "True")]
[EditorBrowsableAttribute("1")]

public float dynamicFriction2 { get; public set; }
    [ObsoleteAttribute("Anisotropic friction is no longer supported since Unity 5.0.", "True")]
[EditorBrowsableAttribute("1")]

public float staticFriction2 { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Anisotropic friction is no longer supported since Unity 5.0.", "True")]

public Vector3 frictionDirection { get; public set; }
    public PhysicMaterial(string name);
    private static void Internal_CreateDynamicsMaterial(PhysicMaterial mat, string name);
    public float get_bounciness();
    public void set_bounciness(float value);
    public float get_dynamicFriction();
    public void set_dynamicFriction(float value);
    public float get_staticFriction();
    public void set_staticFriction(float value);
    public PhysicMaterialCombine get_frictionCombine();
    public void set_frictionCombine(PhysicMaterialCombine value);
    public PhysicMaterialCombine get_bounceCombine();
    public void set_bounceCombine(PhysicMaterialCombine value);
    public float get_bouncyness();
    public void set_bouncyness(float value);
    public Vector3 get_frictionDirection2();
    public void set_frictionDirection2(Vector3 value);
    public float get_dynamicFriction2();
    public void set_dynamicFriction2(float value);
    public float get_staticFriction2();
    public void set_staticFriction2(float value);
    public Vector3 get_frictionDirection();
    public void set_frictionDirection(Vector3 value);
}
public enum UnityEngine.PhysicMaterialCombine : Enum {
    
public int value__;
    
public static PhysicMaterialCombine Average;
    
public static PhysicMaterialCombine Minimum;
    
public static PhysicMaterialCombine Multiply;
    
public static PhysicMaterialCombine Maximum;
}
[NativeHeaderAttribute("Modules/Physics/PhysicsManager.h")]
[StaticAccessorAttribute("GetPhysicsManager()", "0")]
public class UnityEngine.Physics : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private static Action`2<PhysicsScene, NativeArray`1<ModifiableContactPair>> ContactModifyEvent;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private static Action`2<PhysicsScene, NativeArray`1<ModifiableContactPair>> ContactModifyEventCCD;
    
internal static float k_MaxFloatMinusEpsilon;
    
public static int IgnoreRaycastLayer;
    
public static int DefaultRaycastLayers;
    
public static int AllLayers;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use Physics.IgnoreRaycastLayer instead. (UnityUpgradable) -> IgnoreRaycastLayer", "True")]

public static int kIgnoreRaycastLayer;
    [ObsoleteAttribute("Please use Physics.DefaultRaycastLayers instead. (UnityUpgradable) -> DefaultRaycastLayers", "True")]
[EditorBrowsableAttribute("1")]

public static int kDefaultRaycastLayers;
    [ObsoleteAttribute("Please use Physics.AllLayers instead. (UnityUpgradable) -> AllLayers", "True")]
[EditorBrowsableAttribute("1")]

public static int kAllLayers;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private static ContactEventDelegate ContactEvent;
    
private static Collision s_ReusableCollision;
    
public static Vector3 gravity { get; public set; }
    
public static float defaultContactOffset { get; public set; }
    
public static float sleepThreshold { get; public set; }
    
public static bool queriesHitTriggers { get; public set; }
    
public static bool queriesHitBackfaces { get; public set; }
    
public static float bounceThreshold { get; public set; }
    
public static float defaultMaxDepenetrationVelocity { get; public set; }
    
public static int defaultSolverIterations { get; public set; }
    
public static int defaultSolverVelocityIterations { get; public set; }
    
public static SimulationMode simulationMode { get; public set; }
    
public static float defaultMaxAngularSpeed { get; public set; }
    
public static bool improvedPatchFriction { get; public set; }
    
public static bool invokeCollisionCallbacks { get; public set; }
    [NativePropertyAttribute("DefaultPhysicsSceneHandle", "True", "0", "True")]

public static PhysicsScene defaultPhysicsScene { get; }
    
public static bool autoSyncTransforms { get; public set; }
    
public static bool reuseCollisionCallbacks { get; public set; }
    [StaticAccessorAttribute("GetPhysicsManager()")]

public static float interCollisionDistance { get; public set; }
    [StaticAccessorAttribute("GetPhysicsManager()")]

public static float interCollisionStiffness { get; public set; }
    [StaticAccessorAttribute("GetPhysicsManager()")]

public static bool interCollisionSettingsToggle { get; public set; }
    
public static Vector3 clothGravity { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Physics.defaultContactOffset or Collider.contactOffset instead.", "True")]

public static float minPenetrationForPenalty { get; public set; }
    [ObsoleteAttribute("Please use bounceThreshold instead. (UnityUpgradable) -> bounceThreshold")]

public static float bounceTreshold { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The sleepVelocity is no longer supported. Use sleepThreshold. Note that sleepThreshold is energy but not velocity.", "True")]

public static float sleepVelocity { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The sleepAngularVelocity is no longer supported. Use sleepThreshold. Note that sleepThreshold is energy but not velocity.", "True")]

public static float sleepAngularVelocity { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Rigidbody.maxAngularVelocity instead.", "True")]

public static float maxAngularVelocity { get; public set; }
    [ObsoleteAttribute("Please use Physics.defaultSolverIterations instead. (UnityUpgradable) -> defaultSolverIterations")]

public static int solverIterationCount { get; public set; }
    [ObsoleteAttribute("Please use Physics.defaultSolverVelocityIterations instead. (UnityUpgradable) -> defaultSolverVelocityIterations")]

public static int solverVelocityIterationCount { get; public set; }
    [ObsoleteAttribute("penetrationPenaltyForce has no effect.", "True")]
[EditorBrowsableAttribute("1")]

public static float penetrationPenaltyForce { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Physics.autoSimulation has been replaced by Physics.simulationMode", "False")]

public static bool autoSimulation { get; public set; }
    private static Physics();
    [CompilerGeneratedAttribute]
public static void add_ContactModifyEvent(Action`2<PhysicsScene, NativeArray`1<ModifiableContactPair>> value);
    [CompilerGeneratedAttribute]
public static void remove_ContactModifyEvent(Action`2<PhysicsScene, NativeArray`1<ModifiableContactPair>> value);
    [CompilerGeneratedAttribute]
public static void add_ContactModifyEventCCD(Action`2<PhysicsScene, NativeArray`1<ModifiableContactPair>> value);
    [CompilerGeneratedAttribute]
public static void remove_ContactModifyEventCCD(Action`2<PhysicsScene, NativeArray`1<ModifiableContactPair>> value);
    [RequiredByNativeCodeAttribute]
private static void OnSceneContactModify(PhysicsScene scene, IntPtr buffer, int count, bool isCCD);
    [ThreadSafeAttribute]
public static Vector3 get_gravity();
    public static void set_gravity(Vector3 value);
    public static float get_defaultContactOffset();
    public static void set_defaultContactOffset(float value);
    public static float get_sleepThreshold();
    public static void set_sleepThreshold(float value);
    public static bool get_queriesHitTriggers();
    public static void set_queriesHitTriggers(bool value);
    public static bool get_queriesHitBackfaces();
    public static void set_queriesHitBackfaces(bool value);
    public static float get_bounceThreshold();
    public static void set_bounceThreshold(float value);
    public static float get_defaultMaxDepenetrationVelocity();
    public static void set_defaultMaxDepenetrationVelocity(float value);
    public static int get_defaultSolverIterations();
    public static void set_defaultSolverIterations(int value);
    public static int get_defaultSolverVelocityIterations();
    public static void set_defaultSolverVelocityIterations(int value);
    public static SimulationMode get_simulationMode();
    public static void set_simulationMode(SimulationMode value);
    public static float get_defaultMaxAngularSpeed();
    public static void set_defaultMaxAngularSpeed(float value);
    public static bool get_improvedPatchFriction();
    public static void set_improvedPatchFriction(bool value);
    public static bool get_invokeCollisionCallbacks();
    public static void set_invokeCollisionCallbacks(bool value);
    public static PhysicsScene get_defaultPhysicsScene();
    public static void IgnoreCollision(Collider collider1, Collider collider2, bool ignore);
    [ExcludeFromDocsAttribute]
public static void IgnoreCollision(Collider collider1, Collider collider2);
    [NativeNameAttribute("IgnoreCollision")]
public static void IgnoreLayerCollision(int layer1, int layer2, bool ignore);
    [ExcludeFromDocsAttribute]
public static void IgnoreLayerCollision(int layer1, int layer2);
    public static bool GetIgnoreLayerCollision(int layer1, int layer2);
    public static bool GetIgnoreCollision(Collider collider1, Collider collider2);
    public static bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Vector3 origin, Vector3 direction, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Vector3 origin, Vector3 direction);
    public static bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [RequiredByNativeCodeAttribute]
[ExcludeFromDocsAttribute]
public static bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo);
    public static bool Raycast(Ray ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Ray ray, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Ray ray, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Ray ray);
    public static bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool Raycast(Ray ray, RaycastHit& hitInfo);
    public static bool Linecast(Vector3 start, Vector3 end, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool Linecast(Vector3 start, Vector3 end, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool Linecast(Vector3 start, Vector3 end);
    public static bool Linecast(Vector3 start, Vector3 end, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool Linecast(Vector3 start, Vector3 end, RaycastHit& hitInfo, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool Linecast(Vector3 start, Vector3 end, RaycastHit& hitInfo);
    public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction);
    public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo);
    public static bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo);
    public static bool SphereCast(Ray ray, float radius, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool SphereCast(Ray ray, float radius, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool SphereCast(Ray ray, float radius, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool SphereCast(Ray ray, float radius);
    public static bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo);
    public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation);
    [ExcludeFromDocsAttribute]
public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction);
    public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance);
    [ExcludeFromDocsAttribute]
public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation);
    [ExcludeFromDocsAttribute]
public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
[NativeNameAttribute("RaycastAll")]
private static RaycastHit[] Internal_RaycastAll(PhysicsScene physicsScene, Ray ray, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    public static RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction);
    public static RaycastHit[] RaycastAll(Ray ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
[RequiredByNativeCodeAttribute]
public static RaycastHit[] RaycastAll(Ray ray, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] RaycastAll(Ray ray, float maxDistance);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] RaycastAll(Ray ray);
    public static int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [RequiredByNativeCodeAttribute]
[ExcludeFromDocsAttribute]
public static int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance);
    [ExcludeFromDocsAttribute]
public static int RaycastNonAlloc(Ray ray, RaycastHit[] results);
    public static int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance);
    [ExcludeFromDocsAttribute]
public static int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results);
    [NativeNameAttribute("CapsuleCastAll")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
private static RaycastHit[] Query_CapsuleCastAll(PhysicsScene physicsScene, Vector3 p0, Vector3 p1, float radius, Vector3 direction, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    public static RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
[NativeNameAttribute("SphereCastAll")]
private static RaycastHit[] Query_SphereCastAll(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    public static RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction);
    public static RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] SphereCastAll(Ray ray, float radius);
    [NativeNameAttribute("OverlapCapsule")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
private static Collider[] OverlapCapsule_Internal(PhysicsScene physicsScene, Vector3 point0, Vector3 point1, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public static Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, int layerMask);
    [ExcludeFromDocsAttribute]
public static Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
[NativeNameAttribute("OverlapSphere")]
private static Collider[] OverlapSphere_Internal(PhysicsScene physicsScene, Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask);
    [ExcludeFromDocsAttribute]
public static Collider[] OverlapSphere(Vector3 position, float radius);
    [NativeNameAttribute("Simulate")]
internal static void Simulate_Internal(PhysicsScene physicsScene, float step);
    public static void Simulate(float step);
    [NativeNameAttribute("InterpolateBodies")]
internal static void InterpolateBodies_Internal(PhysicsScene physicsScene);
    [NativeNameAttribute("ResetInterpolatedTransformPosition")]
internal static void ResetInterpolationPoses_Internal(PhysicsScene physicsScene);
    public static void SyncTransforms();
    public static bool get_autoSyncTransforms();
    public static void set_autoSyncTransforms(bool value);
    public static bool get_reuseCollisionCallbacks();
    public static void set_reuseCollisionCallbacks(bool value);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
[NativeNameAttribute("ComputePenetration")]
private static bool Query_ComputePenetration(Collider colliderA, Vector3 positionA, Quaternion rotationA, Collider colliderB, Vector3 positionB, Quaternion rotationB, Vector3& direction, Single& distance);
    public static bool ComputePenetration(Collider colliderA, Vector3 positionA, Quaternion rotationA, Collider colliderB, Vector3 positionB, Quaternion rotationB, Vector3& direction, Single& distance);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
[NativeNameAttribute("ClosestPoint")]
private static Vector3 Query_ClosestPoint(Collider collider, Vector3 position, Quaternion rotation, Vector3 point);
    public static Vector3 ClosestPoint(Vector3 point, Collider collider, Vector3 position, Quaternion rotation);
    [NativeNameAttribute("GetClothInterCollisionDistance")]
public static float get_interCollisionDistance();
    [NativeNameAttribute("SetClothInterCollisionDistance")]
public static void set_interCollisionDistance(float value);
    [NativeNameAttribute("GetClothInterCollisionStiffness")]
public static float get_interCollisionStiffness();
    [NativeNameAttribute("SetClothInterCollisionStiffness")]
public static void set_interCollisionStiffness(float value);
    [NativeNameAttribute("GetClothInterCollisionSettingsToggle")]
public static bool get_interCollisionSettingsToggle();
    [NativeNameAttribute("SetClothInterCollisionSettingsToggle")]
public static void set_interCollisionSettingsToggle(bool value);
    [ThreadSafeAttribute]
public static Vector3 get_clothGravity();
    public static void set_clothGravity(Vector3 value);
    public static int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results, int layerMask);
    [ExcludeFromDocsAttribute]
public static int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results);
    [NativeNameAttribute("SphereTest")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
private static bool CheckSphere_Internal(PhysicsScene physicsScene, Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public static bool CheckSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool CheckSphere(Vector3 position, float radius, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool CheckSphere(Vector3 position, float radius);
    public static int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance);
    [ExcludeFromDocsAttribute]
public static int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results);
    public static int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance);
    [ExcludeFromDocsAttribute]
public static int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results);
    public static int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance);
    [ExcludeFromDocsAttribute]
public static int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results);
    [NativeNameAttribute("CapsuleTest")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
private static bool CheckCapsule_Internal(PhysicsScene physicsScene, Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool CheckCapsule(Vector3 start, Vector3 end, float radius);
    [NativeNameAttribute("BoxTest")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
private static bool CheckBox_Internal(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Quaternion orientation, int layermask, QueryTriggerInteraction queryTriggerInteraction);
    public static bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layermask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask);
    [ExcludeFromDocsAttribute]
public static bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation);
    [ExcludeFromDocsAttribute]
public static bool CheckBox(Vector3 center, Vector3 halfExtents);
    [NativeNameAttribute("OverlapBox")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
private static Collider[] OverlapBox_Internal(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public static Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask);
    [ExcludeFromDocsAttribute]
public static Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation);
    [ExcludeFromDocsAttribute]
public static Collider[] OverlapBox(Vector3 center, Vector3 halfExtents);
    public static int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int mask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int mask);
    [ExcludeFromDocsAttribute]
public static int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation);
    [ExcludeFromDocsAttribute]
public static int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results);
    public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation);
    [ExcludeFromDocsAttribute]
public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance);
    [ExcludeFromDocsAttribute]
public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results);
    [NativeNameAttribute("BoxCastAll")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
private static RaycastHit[] Internal_BoxCastAll(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation);
    [ExcludeFromDocsAttribute]
public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction);
    public static int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public static int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask);
    [ExcludeFromDocsAttribute]
public static int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results);
    [NativeNameAttribute("RebuildBroadphaseRegions")]
[StaticAccessorAttribute("GetPhysicsManager()")]
private static void Internal_RebuildBroadphaseRegions(Bounds bounds, int subdivisions);
    public static void RebuildBroadphaseRegions(Bounds worldBounds, int subdivisions);
    [StaticAccessorAttribute("GetPhysicsManager()")]
[ThreadSafeAttribute]
public static void BakeMesh(int meshID, bool convex, MeshColliderCookingOptions cookingOptions);
    public static void BakeMesh(int meshID, bool convex);
    [StaticAccessorAttribute("PhysicsManager", "2")]
internal static Collider ResolveShapeToCollider(IntPtr shapePtr);
    [StaticAccessorAttribute("PhysicsManager", "2")]
internal static Component ResolveActorToComponent(IntPtr actorPtr);
    [StaticAccessorAttribute("PhysicsManager", "2")]
[ThreadSafeAttribute]
internal static int ResolveShapeToInstanceID(IntPtr shapePtr);
    [StaticAccessorAttribute("PhysicsManager", "2")]
[ThreadSafeAttribute]
internal static int ResolveActorToInstanceID(IntPtr actorPtr);
    [StaticAccessorAttribute("PhysicsManager", "2")]
internal static Collider GetColliderByInstanceID(int instanceID);
    [StaticAccessorAttribute("PhysicsManager", "2")]
internal static Component GetBodyByInstanceID(int instanceID);
    [StaticAccessorAttribute("PhysicsManager", "2")]
[ThreadSafeAttribute]
internal static UInt32 TranslateTriangleIndex(IntPtr shapePtr, UInt32 rawIndex);
    [ThreadSafeAttribute]
[StaticAccessorAttribute("PhysicsManager", "2")]
internal static UInt32 TranslateTriangleIndexFromID(int instanceID, UInt32 faceIndex);
    [StaticAccessorAttribute("PhysicsManager", "2")]
[ThreadSafeAttribute]
internal static bool IsShapeTrigger(IntPtr shapePtr);
    [StaticAccessorAttribute("PhysicsManager", "2")]
private static void SendOnCollisionEnter(Component component, Collision collision);
    [StaticAccessorAttribute("PhysicsManager", "2")]
private static void SendOnCollisionStay(Component component, Collision collision);
    [StaticAccessorAttribute("PhysicsManager", "2")]
private static void SendOnCollisionExit(Component component, Collision collision);
    [StaticAccessorAttribute("PhysicsManager", "2")]
[ThreadSafeAttribute]
internal static Vector3 GetActorLinearVelocity(IntPtr actorPtr);
    [StaticAccessorAttribute("PhysicsManager", "2")]
[ThreadSafeAttribute]
internal static Vector3 GetActorAngularVelocity(IntPtr actorPtr);
    public static float get_minPenetrationForPenalty();
    public static void set_minPenetrationForPenalty(float value);
    public static float get_bounceTreshold();
    public static void set_bounceTreshold(float value);
    public static float get_sleepVelocity();
    public static void set_sleepVelocity(float value);
    public static float get_sleepAngularVelocity();
    public static void set_sleepAngularVelocity(float value);
    public static float get_maxAngularVelocity();
    public static void set_maxAngularVelocity(float value);
    public static int get_solverIterationCount();
    public static void set_solverIterationCount(int value);
    public static int get_solverVelocityIterationCount();
    public static void set_solverVelocityIterationCount(int value);
    public static float get_penetrationPenaltyForce();
    public static void set_penetrationPenaltyForce(float value);
    public static bool get_autoSimulation();
    public static void set_autoSimulation(bool value);
    [CompilerGeneratedAttribute]
public static void add_ContactEvent(ContactEventDelegate value);
    [CompilerGeneratedAttribute]
public static void remove_ContactEvent(ContactEventDelegate value);
    [RequiredByNativeCodeAttribute]
private static void OnSceneContact(PhysicsScene scene, IntPtr buffer, int count);
    private static void ReportContacts(ReadOnly<ContactPairHeader> array);
    private static Collision GetCollisionToReport(ContactPairHeader& header, ContactPair& pair, bool flipped);
    private static void get_gravity_Injected(Vector3& ret);
    private static void set_gravity_Injected(Vector3& value);
    private static void get_defaultPhysicsScene_Injected(PhysicsScene& ret);
    private static RaycastHit[] Internal_RaycastAll_Injected(PhysicsScene& physicsScene, Ray& ray, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    private static RaycastHit[] Query_CapsuleCastAll_Injected(PhysicsScene& physicsScene, Vector3& p0, Vector3& p1, float radius, Vector3& direction, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    private static RaycastHit[] Query_SphereCastAll_Injected(PhysicsScene& physicsScene, Vector3& origin, float radius, Vector3& direction, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    private static Collider[] OverlapCapsule_Internal_Injected(PhysicsScene& physicsScene, Vector3& point0, Vector3& point1, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static Collider[] OverlapSphere_Internal_Injected(PhysicsScene& physicsScene, Vector3& position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static void Simulate_Internal_Injected(PhysicsScene& physicsScene, float step);
    private static void InterpolateBodies_Internal_Injected(PhysicsScene& physicsScene);
    private static void ResetInterpolationPoses_Internal_Injected(PhysicsScene& physicsScene);
    private static bool Query_ComputePenetration_Injected(Collider colliderA, Vector3& positionA, Quaternion& rotationA, Collider colliderB, Vector3& positionB, Quaternion& rotationB, Vector3& direction, Single& distance);
    private static void Query_ClosestPoint_Injected(Collider collider, Vector3& position, Quaternion& rotation, Vector3& point, Vector3& ret);
    private static void get_clothGravity_Injected(Vector3& ret);
    private static void set_clothGravity_Injected(Vector3& value);
    private static bool CheckSphere_Internal_Injected(PhysicsScene& physicsScene, Vector3& position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static bool CheckCapsule_Internal_Injected(PhysicsScene& physicsScene, Vector3& start, Vector3& end, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static bool CheckBox_Internal_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Quaternion& orientation, int layermask, QueryTriggerInteraction queryTriggerInteraction);
    private static Collider[] OverlapBox_Internal_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Quaternion& orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static RaycastHit[] Internal_BoxCastAll_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Vector3& direction, Quaternion& orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static void Internal_RebuildBroadphaseRegions_Injected(Bounds& bounds, int subdivisions);
    private static void GetActorLinearVelocity_Injected(IntPtr actorPtr, Vector3& ret);
    private static void GetActorAngularVelocity_Injected(IntPtr actorPtr, Vector3& ret);
}
[NativeHeaderAttribute("Modules/Physics/Public/PhysicsSceneHandle.h")]
public class UnityEngine.PhysicsScene : ValueType {
    
private int m_Handle;
    public virtual string ToString();
    public static bool op_Equality(PhysicsScene lhs, PhysicsScene rhs);
    public static bool op_Inequality(PhysicsScene lhs, PhysicsScene rhs);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(PhysicsScene other);
    public bool IsValid();
    [NativeMethodAttribute("IsPhysicsSceneValid")]
[StaticAccessorAttribute("GetPhysicsManager()", "0")]
private static bool IsValid_Internal(PhysicsScene physicsScene);
    public bool IsEmpty();
    [NativeMethodAttribute("IsPhysicsWorldEmpty")]
[StaticAccessorAttribute("GetPhysicsManager()", "0")]
private static bool IsEmpty_Internal(PhysicsScene physicsScene);
    public void Simulate(float step);
    public void InterpolateBodies();
    public void ResetInterpolationPoses();
    public bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [NativeNameAttribute("RaycastTest")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
private static bool Internal_RaycastTest(PhysicsScene physicsScene, Ray ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
[NativeNameAttribute("Raycast")]
private static bool Internal_Raycast(PhysicsScene physicsScene, Ray ray, float maxDistance, RaycastHit& hit, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public int Raycast(Vector3 origin, Vector3 direction, RaycastHit[] raycastHits, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
[NativeNameAttribute("RaycastNonAlloc")]
private static int Internal_RaycastNonAlloc(PhysicsScene physicsScene, Ray ray, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
[NativeNameAttribute("CapsuleCast")]
private static bool Query_CapsuleCast(PhysicsScene physicsScene, Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static bool Internal_CapsuleCast(PhysicsScene physicsScene, Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
[NativeNameAttribute("CapsuleCastNonAlloc")]
private static int Internal_CapsuleCastNonAlloc(PhysicsScene physicsScene, Vector3 p0, Vector3 p1, float radius, Vector3 direction, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    public int CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
[NativeNameAttribute("OverlapCapsuleNonAlloc")]
private static int OverlapCapsuleNonAlloc_Internal(PhysicsScene physicsScene, Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public int OverlapCapsule(Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
[NativeNameAttribute("SphereCast")]
private static bool Query_SphereCast(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, float maxDistance, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static bool Internal_SphereCast(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
[NativeNameAttribute("SphereCastNonAlloc")]
private static int Internal_SphereCastNonAlloc(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    public int SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [NativeNameAttribute("OverlapSphereNonAlloc")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
private static int OverlapSphereNonAlloc_Internal(PhysicsScene physicsScene, Vector3 position, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public int OverlapSphere(Vector3 position, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()", "0")]
[NativeNameAttribute("BoxCast")]
private static bool Query_BoxCast(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, RaycastHit& outHit, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static bool Internal_BoxCast(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Quaternion orientation, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo);
    [NativeNameAttribute("OverlapBoxNonAlloc")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
private static int OverlapBoxNonAlloc_Internal(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int mask, QueryTriggerInteraction queryTriggerInteraction);
    public int OverlapBox(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public int OverlapBox(Vector3 center, Vector3 halfExtents, Collider[] results);
    [NativeNameAttribute("BoxCastNonAlloc")]
[StaticAccessorAttribute("GetPhysicsManager().GetPhysicsQuery()")]
private static int Internal_BoxCastNonAlloc(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] raycastHits, Quaternion orientation, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    public int BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public int BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results);
    private static bool IsValid_Internal_Injected(PhysicsScene& physicsScene);
    private static bool IsEmpty_Internal_Injected(PhysicsScene& physicsScene);
    private static bool Internal_RaycastTest_Injected(PhysicsScene& physicsScene, Ray& ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static bool Internal_Raycast_Injected(PhysicsScene& physicsScene, Ray& ray, float maxDistance, RaycastHit& hit, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static int Internal_RaycastNonAlloc_Injected(PhysicsScene& physicsScene, Ray& ray, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    private static bool Query_CapsuleCast_Injected(PhysicsScene& physicsScene, Vector3& point1, Vector3& point2, float radius, Vector3& direction, float maxDistance, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static int Internal_CapsuleCastNonAlloc_Injected(PhysicsScene& physicsScene, Vector3& p0, Vector3& p1, float radius, Vector3& direction, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    private static int OverlapCapsuleNonAlloc_Internal_Injected(PhysicsScene& physicsScene, Vector3& point0, Vector3& point1, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static bool Query_SphereCast_Injected(PhysicsScene& physicsScene, Vector3& origin, float radius, Vector3& direction, float maxDistance, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static int Internal_SphereCastNonAlloc_Injected(PhysicsScene& physicsScene, Vector3& origin, float radius, Vector3& direction, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
    private static int OverlapSphereNonAlloc_Internal_Injected(PhysicsScene& physicsScene, Vector3& position, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static bool Query_BoxCast_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Vector3& direction, Quaternion& orientation, float maxDistance, RaycastHit& outHit, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
    private static int OverlapBoxNonAlloc_Internal_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Collider[] results, Quaternion& orientation, int mask, QueryTriggerInteraction queryTriggerInteraction);
    private static int Internal_BoxCastNonAlloc_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Vector3& direction, RaycastHit[] raycastHits, Quaternion& orientation, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction);
}
[ExtensionAttribute]
public static class UnityEngine.PhysicsSceneExtensions : object {
    [ExtensionAttribute]
public static PhysicsScene GetPhysicsScene(Scene scene);
    [NativeMethodAttribute("GetPhysicsSceneFromUnityScene")]
[StaticAccessorAttribute("GetPhysicsManager()", "0")]
private static PhysicsScene GetPhysicsScene_Internal(Scene scene);
    private static void GetPhysicsScene_Internal_Injected(Scene& scene, PhysicsScene& ret);
}
public class UnityEngine.QueryParameters : ValueType {
    
public int layerMask;
    
public bool hitMultipleFaces;
    
public QueryTriggerInteraction hitTriggers;
    
public bool hitBackfaces;
    
public static QueryParameters Default { get; }
    public QueryParameters(int layerMask, bool hitMultipleFaces, QueryTriggerInteraction hitTriggers, bool hitBackfaces);
    public static QueryParameters get_Default();
}
public enum UnityEngine.QueryTriggerInteraction : Enum {
    
public int value__;
    
public static QueryTriggerInteraction UseGlobal;
    
public static QueryTriggerInteraction Ignore;
    
public static QueryTriggerInteraction Collide;
}
[NativeHeaderAttribute("Modules/Physics/BatchCommands/RaycastCommand.h")]
[NativeHeaderAttribute("Runtime/Jobs/ScriptBindings/JobsBindingsTypes.h")]
public class UnityEngine.RaycastCommand : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Vector3 <from>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Vector3 <direction>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private PhysicsScene <physicsScene>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private float <distance>k__BackingField;
    
public QueryParameters queryParameters;
    
public Vector3 from { get; public set; }
    
public Vector3 direction { get; public set; }
    
public PhysicsScene physicsScene { get; public set; }
    
public float distance { get; public set; }
    [ObsoleteAttribute("maxHits property was moved to be a part of RaycastCommand.ScheduleBatch.", "False")]

public int maxHits { get; public set; }
    [ObsoleteAttribute("Layer Mask is now a part of QueryParameters struct", "False")]

public int layerMask { get; public set; }
    public RaycastCommand(Vector3 from, Vector3 direction, QueryParameters queryParameters, float distance);
    public RaycastCommand(PhysicsScene physicsScene, Vector3 from, Vector3 direction, QueryParameters queryParameters, float distance);
    [ObsoleteAttribute("This struct signature is no longer supported. Use struct with a QueryParameters instead", "False")]
public RaycastCommand(Vector3 from, Vector3 direction, float distance, int layerMask, int maxHits);
    [ObsoleteAttribute("This struct signature is no longer supported. Use struct with a QueryParameters instead", "False")]
public RaycastCommand(PhysicsScene physicsScene, Vector3 from, Vector3 direction, float distance, int layerMask, int maxHits);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_from();
    [CompilerGeneratedAttribute]
public void set_from(Vector3 value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_direction();
    [CompilerGeneratedAttribute]
public void set_direction(Vector3 value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public PhysicsScene get_physicsScene();
    [CompilerGeneratedAttribute]
public void set_physicsScene(PhysicsScene value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_distance();
    [CompilerGeneratedAttribute]
public void set_distance(float value);
    public static JobHandle ScheduleBatch(NativeArray`1<RaycastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, int maxHits, JobHandle dependsOn);
    public static JobHandle ScheduleBatch(NativeArray`1<RaycastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn);
    [FreeFunctionAttribute("ScheduleRaycastCommandBatch")]
private static JobHandle ScheduleRaycastBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits);
    public int get_maxHits();
    public void set_maxHits(int value);
    public int get_layerMask();
    public void set_layerMask(int value);
    private static void ScheduleRaycastBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits, JobHandle& ret);
}
[NativeHeaderAttribute("PhysicsScriptingClasses.h")]
[NativeHeaderAttribute("Modules/Physics/RaycastHit.h")]
[NativeHeaderAttribute("Runtime/Interfaces/IRaycast.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.RaycastHit : ValueType {
    [NativeNameAttribute("point")]

internal Vector3 m_Point;
    [NativeNameAttribute("normal")]

internal Vector3 m_Normal;
    [NativeNameAttribute("faceID")]

internal UInt32 m_FaceID;
    [NativeNameAttribute("distance")]

internal float m_Distance;
    [NativeNameAttribute("uv")]

internal Vector2 m_UV;
    [NativeNameAttribute("collider")]

internal int m_Collider;
    
public Collider collider { get; }
    
public int colliderInstanceID { get; }
    
public Vector3 point { get; public set; }
    
public Vector3 normal { get; public set; }
    
public Vector3 barycentricCoordinate { get; public set; }
    
public float distance { get; public set; }
    
public int triangleIndex { get; }
    
public Vector2 textureCoord { get; }
    
public Vector2 textureCoord2 { get; }
    
public Transform transform { get; }
    
public Rigidbody rigidbody { get; }
    
public ArticulationBody articulationBody { get; }
    
public Vector2 lightmapCoord { get; }
    [ObsoleteAttribute("Use textureCoord2 instead. (UnityUpgradable) -> textureCoord2")]
[EditorBrowsableAttribute("1")]

public Vector2 textureCoord1 { get; }
    public Collider get_collider();
    public int get_colliderInstanceID();
    public Vector3 get_point();
    public void set_point(Vector3 value);
    public Vector3 get_normal();
    public void set_normal(Vector3 value);
    public Vector3 get_barycentricCoordinate();
    public void set_barycentricCoordinate(Vector3 value);
    public float get_distance();
    public void set_distance(float value);
    public int get_triangleIndex();
    [NativeMethodAttribute("CalculateRaycastTexCoord", "True", "True")]
private static Vector2 CalculateRaycastTexCoord(int colliderInstanceID, Vector2 uv, Vector3 pos, UInt32 face, int textcoord);
    public Vector2 get_textureCoord();
    public Vector2 get_textureCoord2();
    public Transform get_transform();
    public Rigidbody get_rigidbody();
    public ArticulationBody get_articulationBody();
    public Vector2 get_lightmapCoord();
    public Vector2 get_textureCoord1();
    private static void CalculateRaycastTexCoord_Injected(int colliderInstanceID, Vector2& uv, Vector3& pos, UInt32 face, int textcoord, Vector2& ret);
}
[NativeHeaderAttribute("Modules/Physics/Rigidbody.h")]
[RequireComponent("UnityEngine.Transform")]
public class UnityEngine.Rigidbody : Component {
    
public Vector3 velocity { get; public set; }
    
public Vector3 angularVelocity { get; public set; }
    
public float drag { get; public set; }
    
public float angularDrag { get; public set; }
    
public float mass { get; public set; }
    
public bool useGravity { get; public set; }
    
public float maxDepenetrationVelocity { get; public set; }
    
public bool isKinematic { get; public set; }
    
public bool freezeRotation { get; public set; }
    
public RigidbodyConstraints constraints { get; public set; }
    
public CollisionDetectionMode collisionDetectionMode { get; public set; }
    
public bool automaticCenterOfMass { get; public set; }
    
public Vector3 centerOfMass { get; public set; }
    
public Vector3 worldCenterOfMass { get; }
    
public bool automaticInertiaTensor { get; public set; }
    
public Quaternion inertiaTensorRotation { get; public set; }
    
public Vector3 inertiaTensor { get; public set; }
    
public bool detectCollisions { get; public set; }
    
public Vector3 position { get; public set; }
    
public Quaternion rotation { get; public set; }
    
public RigidbodyInterpolation interpolation { get; public set; }
    
public int solverIterations { get; public set; }
    
public float sleepThreshold { get; public set; }
    
public float maxAngularVelocity { get; public set; }
    
public float maxLinearVelocity { get; public set; }
    
public int solverVelocityIterations { get; public set; }
    
public LayerMask excludeLayers { get; public set; }
    
public LayerMask includeLayers { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The sleepVelocity is no longer supported. Use sleepThreshold. Note that sleepThreshold is energy but not velocity.", "True")]

public float sleepVelocity { get; public set; }
    [ObsoleteAttribute("The sleepAngularVelocity is no longer supported. Use sleepThreshold to specify energy.", "True")]
[EditorBrowsableAttribute("1")]

public float sleepAngularVelocity { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Cone friction is no longer supported.", "True")]

public bool useConeFriction { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use Rigidbody.solverIterations instead. (UnityUpgradable) -> solverIterations")]

public int solverIterationCount { get; public set; }
    [ObsoleteAttribute("Please use Rigidbody.solverVelocityIterations instead. (UnityUpgradable) -> solverVelocityIterations")]
[EditorBrowsableAttribute("1")]

public int solverVelocityIterationCount { get; public set; }
    public Vector3 get_velocity();
    public void set_velocity(Vector3 value);
    public Vector3 get_angularVelocity();
    public void set_angularVelocity(Vector3 value);
    public float get_drag();
    public void set_drag(float value);
    public float get_angularDrag();
    public void set_angularDrag(float value);
    public float get_mass();
    public void set_mass(float value);
    public void SetDensity(float density);
    public bool get_useGravity();
    public void set_useGravity(bool value);
    public float get_maxDepenetrationVelocity();
    public void set_maxDepenetrationVelocity(float value);
    public bool get_isKinematic();
    public void set_isKinematic(bool value);
    public bool get_freezeRotation();
    public void set_freezeRotation(bool value);
    public RigidbodyConstraints get_constraints();
    public void set_constraints(RigidbodyConstraints value);
    public CollisionDetectionMode get_collisionDetectionMode();
    public void set_collisionDetectionMode(CollisionDetectionMode value);
    public bool get_automaticCenterOfMass();
    public void set_automaticCenterOfMass(bool value);
    public Vector3 get_centerOfMass();
    public void set_centerOfMass(Vector3 value);
    public Vector3 get_worldCenterOfMass();
    public bool get_automaticInertiaTensor();
    public void set_automaticInertiaTensor(bool value);
    public Quaternion get_inertiaTensorRotation();
    public void set_inertiaTensorRotation(Quaternion value);
    public Vector3 get_inertiaTensor();
    public void set_inertiaTensor(Vector3 value);
    public bool get_detectCollisions();
    public void set_detectCollisions(bool value);
    public Vector3 get_position();
    public void set_position(Vector3 value);
    public Quaternion get_rotation();
    public void set_rotation(Quaternion value);
    public RigidbodyInterpolation get_interpolation();
    public void set_interpolation(RigidbodyInterpolation value);
    public int get_solverIterations();
    public void set_solverIterations(int value);
    public float get_sleepThreshold();
    public void set_sleepThreshold(float value);
    public float get_maxAngularVelocity();
    public void set_maxAngularVelocity(float value);
    public float get_maxLinearVelocity();
    public void set_maxLinearVelocity(float value);
    public void MovePosition(Vector3 position);
    public void MoveRotation(Quaternion rot);
    public void Move(Vector3 position, Quaternion rotation);
    public void Sleep();
    public bool IsSleeping();
    public void WakeUp();
    public void ResetCenterOfMass();
    public void ResetInertiaTensor();
    public Vector3 GetRelativePointVelocity(Vector3 relativePoint);
    public Vector3 GetPointVelocity(Vector3 worldPoint);
    public int get_solverVelocityIterations();
    public void set_solverVelocityIterations(int value);
    public LayerMask get_excludeLayers();
    public void set_excludeLayers(LayerMask value);
    public LayerMask get_includeLayers();
    public void set_includeLayers(LayerMask value);
    public Vector3 GetAccumulatedForce(float step);
    [ExcludeFromDocsAttribute]
public Vector3 GetAccumulatedForce();
    public Vector3 GetAccumulatedTorque(float step);
    [ExcludeFromDocsAttribute]
public Vector3 GetAccumulatedTorque();
    public void AddForce(Vector3 force, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddForce(Vector3 force);
    public void AddForce(float x, float y, float z, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddForce(float x, float y, float z);
    public void AddRelativeForce(Vector3 force, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddRelativeForce(Vector3 force);
    public void AddRelativeForce(float x, float y, float z, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddRelativeForce(float x, float y, float z);
    public void AddTorque(Vector3 torque, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddTorque(Vector3 torque);
    public void AddTorque(float x, float y, float z, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddTorque(float x, float y, float z);
    public void AddRelativeTorque(Vector3 torque, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddRelativeTorque(Vector3 torque);
    public void AddRelativeTorque(float x, float y, float z, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddRelativeTorque(float x, float y, float z);
    public void AddForceAtPosition(Vector3 force, Vector3 position, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddForceAtPosition(Vector3 force, Vector3 position);
    public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier, ForceMode mode);
    [ExcludeFromDocsAttribute]
public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier);
    [ExcludeFromDocsAttribute]
public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius);
    [NativeNameAttribute("ClosestPointOnBounds")]
private void Internal_ClosestPointOnBounds(Vector3 point, Vector3& outPos, Single& distance);
    public Vector3 ClosestPointOnBounds(Vector3 position);
    private RaycastHit SweepTest(Vector3 direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction, Boolean& hasHit);
    public bool SweepTest(Vector3 direction, RaycastHit& hitInfo, float maxDistance, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public bool SweepTest(Vector3 direction, RaycastHit& hitInfo, float maxDistance);
    [ExcludeFromDocsAttribute]
public bool SweepTest(Vector3 direction, RaycastHit& hitInfo);
    [NativeNameAttribute("SweepTestAll")]
private RaycastHit[] Internal_SweepTestAll(Vector3 direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction);
    public RaycastHit[] SweepTestAll(Vector3 direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction);
    [ExcludeFromDocsAttribute]
public RaycastHit[] SweepTestAll(Vector3 direction, float maxDistance);
    [ExcludeFromDocsAttribute]
public RaycastHit[] SweepTestAll(Vector3 direction);
    public float get_sleepVelocity();
    public void set_sleepVelocity(float value);
    public float get_sleepAngularVelocity();
    public void set_sleepAngularVelocity(float value);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Rigidbody.maxAngularVelocity instead.")]
public void SetMaxAngularVelocity(float a);
    public bool get_useConeFriction();
    public void set_useConeFriction(bool value);
    public int get_solverIterationCount();
    public void set_solverIterationCount(int value);
    public int get_solverVelocityIterationCount();
    public void set_solverVelocityIterationCount(int value);
    private void get_velocity_Injected(Vector3& ret);
    private void set_velocity_Injected(Vector3& value);
    private void get_angularVelocity_Injected(Vector3& ret);
    private void set_angularVelocity_Injected(Vector3& value);
    private void get_centerOfMass_Injected(Vector3& ret);
    private void set_centerOfMass_Injected(Vector3& value);
    private void get_worldCenterOfMass_Injected(Vector3& ret);
    private void get_inertiaTensorRotation_Injected(Quaternion& ret);
    private void set_inertiaTensorRotation_Injected(Quaternion& value);
    private void get_inertiaTensor_Injected(Vector3& ret);
    private void set_inertiaTensor_Injected(Vector3& value);
    private void get_position_Injected(Vector3& ret);
    private void set_position_Injected(Vector3& value);
    private void get_rotation_Injected(Quaternion& ret);
    private void set_rotation_Injected(Quaternion& value);
    private void MovePosition_Injected(Vector3& position);
    private void MoveRotation_Injected(Quaternion& rot);
    private void Move_Injected(Vector3& position, Quaternion& rotation);
    private void GetRelativePointVelocity_Injected(Vector3& relativePoint, Vector3& ret);
    private void GetPointVelocity_Injected(Vector3& worldPoint, Vector3& ret);
    private void get_excludeLayers_Injected(LayerMask& ret);
    private void set_excludeLayers_Injected(LayerMask& value);
    private void get_includeLayers_Injected(LayerMask& ret);
    private void set_includeLayers_Injected(LayerMask& value);
    private void GetAccumulatedForce_Injected(float step, Vector3& ret);
    private void GetAccumulatedTorque_Injected(float step, Vector3& ret);
    private void AddForce_Injected(Vector3& force, ForceMode mode);
    private void AddRelativeForce_Injected(Vector3& force, ForceMode mode);
    private void AddTorque_Injected(Vector3& torque, ForceMode mode);
    private void AddRelativeTorque_Injected(Vector3& torque, ForceMode mode);
    private void AddForceAtPosition_Injected(Vector3& force, Vector3& position, ForceMode mode);
    private void AddExplosionForce_Injected(float explosionForce, Vector3& explosionPosition, float explosionRadius, float upwardsModifier, ForceMode mode);
    private void Internal_ClosestPointOnBounds_Injected(Vector3& point, Vector3& outPos, Single& distance);
    private void SweepTest_Injected(Vector3& direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction, Boolean& hasHit, RaycastHit& ret);
    private RaycastHit[] Internal_SweepTestAll_Injected(Vector3& direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction);
}
public enum UnityEngine.RigidbodyConstraints : Enum {
    
public int value__;
    
public static RigidbodyConstraints None;
    
public static RigidbodyConstraints FreezePositionX;
    
public static RigidbodyConstraints FreezePositionY;
    
public static RigidbodyConstraints FreezePositionZ;
    
public static RigidbodyConstraints FreezeRotationX;
    
public static RigidbodyConstraints FreezeRotationY;
    
public static RigidbodyConstraints FreezeRotationZ;
    
public static RigidbodyConstraints FreezePosition;
    
public static RigidbodyConstraints FreezeRotation;
    
public static RigidbodyConstraints FreezeAll;
}
public enum UnityEngine.RigidbodyInterpolation : Enum {
    
public int value__;
    
public static RigidbodyInterpolation None;
    
public static RigidbodyInterpolation Interpolate;
    
public static RigidbodyInterpolation Extrapolate;
}
public enum UnityEngine.RotationDriveMode : Enum {
    
public int value__;
    
public static RotationDriveMode XYAndZ;
    
public static RotationDriveMode Slerp;
}
public enum UnityEngine.SimulationMode : Enum {
    
public int value__;
    
public static SimulationMode FixedUpdate;
    
public static SimulationMode Update;
    
public static SimulationMode Script;
}
public class UnityEngine.SoftJointLimit : ValueType {
    
private float m_Limit;
    
private float m_Bounciness;
    
private float m_ContactDistance;
    
public float limit { get; public set; }
    
public float bounciness { get; public set; }
    
public float contactDistance { get; public set; }
    [ObsoleteAttribute("Spring has been moved to SoftJointLimitSpring class in Unity 5", "True")]
[EditorBrowsableAttribute("1")]

public float spring { get; public set; }
    [ObsoleteAttribute("Damper has been moved to SoftJointLimitSpring class in Unity 5", "True")]
[EditorBrowsableAttribute("1")]

public float damper { get; public set; }
    [ObsoleteAttribute("Use SoftJointLimit.bounciness instead", "True")]
[EditorBrowsableAttribute("1")]

public float bouncyness { get; public set; }
    public float get_limit();
    public void set_limit(float value);
    public float get_bounciness();
    public void set_bounciness(float value);
    public float get_contactDistance();
    public void set_contactDistance(float value);
    public float get_spring();
    public void set_spring(float value);
    public float get_damper();
    public void set_damper(float value);
    public float get_bouncyness();
    public void set_bouncyness(float value);
}
public class UnityEngine.SoftJointLimitSpring : ValueType {
    
private float m_Spring;
    
private float m_Damper;
    
public float spring { get; public set; }
    
public float damper { get; public set; }
    public float get_spring();
    public void set_spring(float value);
    public float get_damper();
    public void set_damper(float value);
}
[NativeHeaderAttribute("Runtime/Jobs/ScriptBindings/JobsBindingsTypes.h")]
[NativeHeaderAttribute("Modules/Physics/BatchCommands/SpherecastCommand.h")]
public class UnityEngine.SpherecastCommand : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector3 <origin>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private float <radius>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Vector3 <direction>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private float <distance>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private PhysicsScene <physicsScene>k__BackingField;
    
public QueryParameters queryParameters;
    
public Vector3 origin { get; public set; }
    
public float radius { get; public set; }
    
public Vector3 direction { get; public set; }
    
public float distance { get; public set; }
    
public PhysicsScene physicsScene { get; public set; }
    [ObsoleteAttribute("Layer Mask is now a part of QueryParameters struct", "False")]

public int layerMask { get; public set; }
    public SpherecastCommand(Vector3 origin, float radius, Vector3 direction, QueryParameters queryParameters, float distance);
    public SpherecastCommand(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, QueryParameters queryParameters, float distance);
    [ObsoleteAttribute("This struct signature is no longer supported. Use struct with a QueryParameters instead", "False")]
public SpherecastCommand(Vector3 origin, float radius, Vector3 direction, float distance, int layerMask);
    [ObsoleteAttribute("This struct signature is no longer supported. Use struct with a QueryParameters instead", "False")]
public SpherecastCommand(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, float distance, int layerMask);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_origin();
    [CompilerGeneratedAttribute]
public void set_origin(Vector3 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_radius();
    [CompilerGeneratedAttribute]
public void set_radius(float value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_direction();
    [CompilerGeneratedAttribute]
public void set_direction(Vector3 value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public float get_distance();
    [CompilerGeneratedAttribute]
public void set_distance(float value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public PhysicsScene get_physicsScene();
    [CompilerGeneratedAttribute]
public void set_physicsScene(PhysicsScene value);
    public static JobHandle ScheduleBatch(NativeArray`1<SpherecastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, int maxHits, JobHandle dependsOn);
    public static JobHandle ScheduleBatch(NativeArray`1<SpherecastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn);
    [FreeFunctionAttribute("ScheduleSpherecastCommandBatch")]
private static JobHandle ScheduleSpherecastBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits);
    public int get_layerMask();
    public void set_layerMask(int value);
    private static void ScheduleSpherecastBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, int maxHits, JobHandle& ret);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/Physics/SphereCollider.h")]
public class UnityEngine.SphereCollider : Collider {
    
public Vector3 center { get; public set; }
    
public float radius { get; public set; }
    public Vector3 get_center();
    public void set_center(Vector3 value);
    public float get_radius();
    public void set_radius(float value);
    private void get_center_Injected(Vector3& ret);
    private void set_center_Injected(Vector3& value);
}
[NativeHeaderAttribute("Modules/Physics/SpringJoint.h")]
[NativeClassAttribute("Unity::SpringJoint")]
public class UnityEngine.SpringJoint : Joint {
    
public float spring { get; public set; }
    
public float damper { get; public set; }
    
public float minDistance { get; public set; }
    
public float maxDistance { get; public set; }
    
public float tolerance { get; public set; }
    public float get_spring();
    public void set_spring(float value);
    public float get_damper();
    public void set_damper(float value);
    public float get_minDistance();
    public void set_minDistance(float value);
    public float get_maxDistance();
    public void set_maxDistance(float value);
    public float get_tolerance();
    public void set_tolerance(float value);
}
public class UnityEngine.WheelFrictionCurve : ValueType {
    
private float m_ExtremumSlip;
    
private float m_ExtremumValue;
    
private float m_AsymptoteSlip;
    
private float m_AsymptoteValue;
    
private float m_Stiffness;
    
public float extremumSlip { get; public set; }
    
public float extremumValue { get; public set; }
    
public float asymptoteSlip { get; public set; }
    
public float asymptoteValue { get; public set; }
    
public float stiffness { get; public set; }
    public float get_extremumSlip();
    public void set_extremumSlip(float value);
    public float get_extremumValue();
    public void set_extremumValue(float value);
    public float get_asymptoteSlip();
    public void set_asymptoteSlip(float value);
    public float get_asymptoteValue();
    public void set_asymptoteValue(float value);
    public float get_stiffness();
    public void set_stiffness(float value);
}
