public UnityEngine.BoxCollider : Collider {
public Vector3 center
public Vector3 size
public Vector3 extents
public Vector3 get_center()
public void set_center(Vector3 value)
private void INTERNAL_get_center(Vector3& value)
private void INTERNAL_set_center(Vector3& value)
public Vector3 get_size()
public void set_size(Vector3 value)
private void INTERNAL_get_size(Vector3& value)
private void INTERNAL_set_size(Vector3& value)
public Vector3 get_extents()
public void set_extents(Vector3 value)
}
public UnityEngine.CapsuleCollider : Collider {
public Vector3 center
public float radius
public float height
public int direction
public Vector3 get_center()
public void set_center(Vector3 value)
private void INTERNAL_get_center(Vector3& value)
private void INTERNAL_set_center(Vector3& value)
public float get_radius()
public void set_radius(float value)
public float get_height()
public void set_height(float value)
public int get_direction()
public void set_direction(int value)
}
public UnityEngine.CharacterController : Collider {
public bool isGrounded
public Vector3 velocity
public CollisionFlags collisionFlags
public float radius
public float height
public Vector3 center
public float slopeLimit
public float stepOffset
public float skinWidth
public float minMoveDistance
public bool detectCollisions
public bool enableOverlapRecovery
public bool SimpleMove(Vector3 speed)
private bool INTERNAL_CALL_SimpleMove(CharacterController self, Vector3& speed)
public CollisionFlags Move(Vector3 motion)
private CollisionFlags INTERNAL_CALL_Move(CharacterController self, Vector3& motion)
public bool get_isGrounded()
public Vector3 get_velocity()
private void INTERNAL_get_velocity(Vector3& value)
public CollisionFlags get_collisionFlags()
public float get_radius()
public void set_radius(float value)
public float get_height()
public void set_height(float value)
public Vector3 get_center()
public void set_center(Vector3 value)
private void INTERNAL_get_center(Vector3& value)
private void INTERNAL_set_center(Vector3& value)
public float get_slopeLimit()
public void set_slopeLimit(float value)
public float get_stepOffset()
public void set_stepOffset(float value)
public float get_skinWidth()
public void set_skinWidth(float value)
public float get_minMoveDistance()
public void set_minMoveDistance(float value)
public bool get_detectCollisions()
public void set_detectCollisions(bool value)
public bool get_enableOverlapRecovery()
public void set_enableOverlapRecovery(bool value)
}
public UnityEngine.CharacterJoint : Joint {
public Quaternion targetRotation
public Vector3 targetAngularVelocity
public JointDrive rotationDrive
public Vector3 swingAxis
public SoftJointLimitSpring twistLimitSpring
public SoftJointLimitSpring swingLimitSpring
public SoftJointLimit lowTwistLimit
public SoftJointLimit highTwistLimit
public SoftJointLimit swing1Limit
public SoftJointLimit swing2Limit
public bool enableProjection
public float projectionDistance
public float projectionAngle
public Vector3 get_swingAxis()
public void set_swingAxis(Vector3 value)
private void INTERNAL_get_swingAxis(Vector3& value)
private void INTERNAL_set_swingAxis(Vector3& value)
public SoftJointLimitSpring get_twistLimitSpring()
public void set_twistLimitSpring(SoftJointLimitSpring value)
private void INTERNAL_get_twistLimitSpring(SoftJointLimitSpring& value)
private void INTERNAL_set_twistLimitSpring(SoftJointLimitSpring& value)
public SoftJointLimitSpring get_swingLimitSpring()
public void set_swingLimitSpring(SoftJointLimitSpring value)
private void INTERNAL_get_swingLimitSpring(SoftJointLimitSpring& value)
private void INTERNAL_set_swingLimitSpring(SoftJointLimitSpring& value)
public SoftJointLimit get_lowTwistLimit()
public void set_lowTwistLimit(SoftJointLimit value)
private void INTERNAL_get_lowTwistLimit(SoftJointLimit& value)
private void INTERNAL_set_lowTwistLimit(SoftJointLimit& value)
public SoftJointLimit get_highTwistLimit()
public void set_highTwistLimit(SoftJointLimit value)
private void INTERNAL_get_highTwistLimit(SoftJointLimit& value)
private void INTERNAL_set_highTwistLimit(SoftJointLimit& value)
public SoftJointLimit get_swing1Limit()
public void set_swing1Limit(SoftJointLimit value)
private void INTERNAL_get_swing1Limit(SoftJointLimit& value)
private void INTERNAL_set_swing1Limit(SoftJointLimit& value)
public SoftJointLimit get_swing2Limit()
public void set_swing2Limit(SoftJointLimit value)
private void INTERNAL_get_swing2Limit(SoftJointLimit& value)
private void INTERNAL_set_swing2Limit(SoftJointLimit& value)
public bool get_enableProjection()
public void set_enableProjection(bool value)
public float get_projectionDistance()
public void set_projectionDistance(float value)
public float get_projectionAngle()
public void set_projectionAngle(float value)
}
public UnityEngine.Collider : Component {
public bool enabled
public Rigidbody attachedRigidbody
public bool isTrigger
public float contactOffset
public PhysicMaterial material
public PhysicMaterial sharedMaterial
public Bounds bounds
public bool get_enabled()
public void set_enabled(bool value)
public Rigidbody get_attachedRigidbody()
public bool get_isTrigger()
public void set_isTrigger(bool value)
public float get_contactOffset()
public void set_contactOffset(float value)
public PhysicMaterial get_material()
public void set_material(PhysicMaterial value)
public Vector3 ClosestPointOnBounds(Vector3 position)
private void INTERNAL_CALL_ClosestPointOnBounds(Collider self, Vector3& position, Vector3& value)
public Vector3 ClosestPoint(Vector3 position)
private void INTERNAL_CALL_ClosestPoint(Collider self, Vector3& position, Vector3& value)
public PhysicMaterial get_sharedMaterial()
public void set_sharedMaterial(PhysicMaterial value)
public Bounds get_bounds()
private void INTERNAL_get_bounds(Bounds& value)
private bool Internal_Raycast(Collider col, Ray ray, RaycastHit& hitInfo, float maxDistance)
private bool INTERNAL_CALL_Internal_Raycast(Collider col, Ray& ray, RaycastHit& hitInfo, float maxDistance)
public bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance)
}
public UnityEngine.Collision : object {
internal Vector3 m_Impulse
internal Vector3 m_RelativeVelocity
internal Rigidbody m_Rigidbody
internal Collider m_Collider
internal ContactPoint[] m_Contacts
public Vector3 relativeVelocity
public Rigidbody rigidbody
public Collider collider
public Transform transform
public GameObject gameObject
public ContactPoint[] contacts
public Vector3 impulse
public Vector3 impactForceSum
public Vector3 frictionForceSum
public Component other
public Vector3 get_relativeVelocity()
public Rigidbody get_rigidbody()
public Collider get_collider()
public Transform get_transform()
public GameObject get_gameObject()
public ContactPoint[] get_contacts()
public IEnumerator GetEnumerator()
public Vector3 get_impulse()
public Vector3 get_impactForceSum()
public Vector3 get_frictionForceSum()
public Component get_other()
}
public UnityEngine.CollisionDetectionMode : Enum {
public int value__
public CollisionDetectionMode Discrete
public CollisionDetectionMode Continuous
public CollisionDetectionMode ContinuousDynamic
}
public UnityEngine.CollisionFlags : Enum {
public int value__
public CollisionFlags None
public CollisionFlags Sides
public CollisionFlags Above
public CollisionFlags Below
public CollisionFlags CollidedSides
public CollisionFlags CollidedAbove
public CollisionFlags CollidedBelow
}
public UnityEngine.ConfigurableJoint : Joint {
public Vector3 secondaryAxis
public ConfigurableJointMotion xMotion
public ConfigurableJointMotion yMotion
public ConfigurableJointMotion zMotion
public ConfigurableJointMotion angularXMotion
public ConfigurableJointMotion angularYMotion
public ConfigurableJointMotion angularZMotion
public SoftJointLimitSpring linearLimitSpring
public SoftJointLimitSpring angularXLimitSpring
public SoftJointLimitSpring angularYZLimitSpring
public SoftJointLimit linearLimit
public SoftJointLimit lowAngularXLimit
public SoftJointLimit highAngularXLimit
public SoftJointLimit angularYLimit
public SoftJointLimit angularZLimit
public Vector3 targetPosition
public Vector3 targetVelocity
public JointDrive xDrive
public JointDrive yDrive
public JointDrive zDrive
public Quaternion targetRotation
public Vector3 targetAngularVelocity
public RotationDriveMode rotationDriveMode
public JointDrive angularXDrive
public JointDrive angularYZDrive
public JointDrive slerpDrive
public JointProjectionMode projectionMode
public float projectionDistance
public float projectionAngle
public bool configuredInWorldSpace
public bool swapBodies
public Vector3 get_secondaryAxis()
public void set_secondaryAxis(Vector3 value)
private void INTERNAL_get_secondaryAxis(Vector3& value)
private void INTERNAL_set_secondaryAxis(Vector3& value)
public ConfigurableJointMotion get_xMotion()
public void set_xMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_yMotion()
public void set_yMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_zMotion()
public void set_zMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_angularXMotion()
public void set_angularXMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_angularYMotion()
public void set_angularYMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_angularZMotion()
public void set_angularZMotion(ConfigurableJointMotion value)
public SoftJointLimitSpring get_linearLimitSpring()
public void set_linearLimitSpring(SoftJointLimitSpring value)
private void INTERNAL_get_linearLimitSpring(SoftJointLimitSpring& value)
private void INTERNAL_set_linearLimitSpring(SoftJointLimitSpring& value)
public SoftJointLimitSpring get_angularXLimitSpring()
public void set_angularXLimitSpring(SoftJointLimitSpring value)
private void INTERNAL_get_angularXLimitSpring(SoftJointLimitSpring& value)
private void INTERNAL_set_angularXLimitSpring(SoftJointLimitSpring& value)
public SoftJointLimitSpring get_angularYZLimitSpring()
public void set_angularYZLimitSpring(SoftJointLimitSpring value)
private void INTERNAL_get_angularYZLimitSpring(SoftJointLimitSpring& value)
private void INTERNAL_set_angularYZLimitSpring(SoftJointLimitSpring& value)
public SoftJointLimit get_linearLimit()
public void set_linearLimit(SoftJointLimit value)
private void INTERNAL_get_linearLimit(SoftJointLimit& value)
private void INTERNAL_set_linearLimit(SoftJointLimit& value)
public SoftJointLimit get_lowAngularXLimit()
public void set_lowAngularXLimit(SoftJointLimit value)
private void INTERNAL_get_lowAngularXLimit(SoftJointLimit& value)
private void INTERNAL_set_lowAngularXLimit(SoftJointLimit& value)
public SoftJointLimit get_highAngularXLimit()
public void set_highAngularXLimit(SoftJointLimit value)
private void INTERNAL_get_highAngularXLimit(SoftJointLimit& value)
private void INTERNAL_set_highAngularXLimit(SoftJointLimit& value)
public SoftJointLimit get_angularYLimit()
public void set_angularYLimit(SoftJointLimit value)
private void INTERNAL_get_angularYLimit(SoftJointLimit& value)
private void INTERNAL_set_angularYLimit(SoftJointLimit& value)
public SoftJointLimit get_angularZLimit()
public void set_angularZLimit(SoftJointLimit value)
private void INTERNAL_get_angularZLimit(SoftJointLimit& value)
private void INTERNAL_set_angularZLimit(SoftJointLimit& value)
public Vector3 get_targetPosition()
public void set_targetPosition(Vector3 value)
private void INTERNAL_get_targetPosition(Vector3& value)
private void INTERNAL_set_targetPosition(Vector3& value)
public Vector3 get_targetVelocity()
public void set_targetVelocity(Vector3 value)
private void INTERNAL_get_targetVelocity(Vector3& value)
private void INTERNAL_set_targetVelocity(Vector3& value)
public JointDrive get_xDrive()
public void set_xDrive(JointDrive value)
private void INTERNAL_get_xDrive(JointDrive& value)
private void INTERNAL_set_xDrive(JointDrive& value)
public JointDrive get_yDrive()
public void set_yDrive(JointDrive value)
private void INTERNAL_get_yDrive(JointDrive& value)
private void INTERNAL_set_yDrive(JointDrive& value)
public JointDrive get_zDrive()
public void set_zDrive(JointDrive value)
private void INTERNAL_get_zDrive(JointDrive& value)
private void INTERNAL_set_zDrive(JointDrive& value)
public Quaternion get_targetRotation()
public void set_targetRotation(Quaternion value)
private void INTERNAL_get_targetRotation(Quaternion& value)
private void INTERNAL_set_targetRotation(Quaternion& value)
public Vector3 get_targetAngularVelocity()
public void set_targetAngularVelocity(Vector3 value)
private void INTERNAL_get_targetAngularVelocity(Vector3& value)
private void INTERNAL_set_targetAngularVelocity(Vector3& value)
public RotationDriveMode get_rotationDriveMode()
public void set_rotationDriveMode(RotationDriveMode value)
public JointDrive get_angularXDrive()
public void set_angularXDrive(JointDrive value)
private void INTERNAL_get_angularXDrive(JointDrive& value)
private void INTERNAL_set_angularXDrive(JointDrive& value)
public JointDrive get_angularYZDrive()
public void set_angularYZDrive(JointDrive value)
private void INTERNAL_get_angularYZDrive(JointDrive& value)
private void INTERNAL_set_angularYZDrive(JointDrive& value)
public JointDrive get_slerpDrive()
public void set_slerpDrive(JointDrive value)
private void INTERNAL_get_slerpDrive(JointDrive& value)
private void INTERNAL_set_slerpDrive(JointDrive& value)
public JointProjectionMode get_projectionMode()
public void set_projectionMode(JointProjectionMode value)
public float get_projectionDistance()
public void set_projectionDistance(float value)
public float get_projectionAngle()
public void set_projectionAngle(float value)
public bool get_configuredInWorldSpace()
public void set_configuredInWorldSpace(bool value)
public bool get_swapBodies()
public void set_swapBodies(bool value)
}
public UnityEngine.ConfigurableJointMotion : Enum {
public int value__
public ConfigurableJointMotion Locked
public ConfigurableJointMotion Limited
public ConfigurableJointMotion Free
}
public UnityEngine.ConstantForce : Behaviour {
public Vector3 force
public Vector3 relativeForce
public Vector3 torque
public Vector3 relativeTorque
public Vector3 get_force()
public void set_force(Vector3 value)
private void INTERNAL_get_force(Vector3& value)
private void INTERNAL_set_force(Vector3& value)
public Vector3 get_relativeForce()
public void set_relativeForce(Vector3 value)
private void INTERNAL_get_relativeForce(Vector3& value)
private void INTERNAL_set_relativeForce(Vector3& value)
public Vector3 get_torque()
public void set_torque(Vector3 value)
private void INTERNAL_get_torque(Vector3& value)
private void INTERNAL_set_torque(Vector3& value)
public Vector3 get_relativeTorque()
public void set_relativeTorque(Vector3 value)
private void INTERNAL_get_relativeTorque(Vector3& value)
private void INTERNAL_set_relativeTorque(Vector3& value)
}
public UnityEngine.ContactPoint : ValueType {
internal Vector3 m_Point
internal Vector3 m_Normal
internal int m_ThisColliderInstanceID
internal int m_OtherColliderInstanceID
internal float m_Separation
public Vector3 point
public Vector3 normal
public Collider thisCollider
public Collider otherCollider
public float separation
public Vector3 get_point()
public Vector3 get_normal()
public Collider get_thisCollider()
public Collider get_otherCollider()
public float get_separation()
}
public UnityEngine.ControllerColliderHit : object {
internal CharacterController m_Controller
internal Collider m_Collider
internal Vector3 m_Point
internal Vector3 m_Normal
internal Vector3 m_MoveDirection
internal float m_MoveLength
internal int m_Push
public CharacterController controller
public Collider collider
public Rigidbody rigidbody
public GameObject gameObject
public Transform transform
public Vector3 point
public Vector3 normal
public Vector3 moveDirection
public float moveLength
private bool push
public CharacterController get_controller()
public Collider get_collider()
public Rigidbody get_rigidbody()
public GameObject get_gameObject()
public Transform get_transform()
public Vector3 get_point()
public Vector3 get_normal()
public Vector3 get_moveDirection()
public float get_moveLength()
private bool get_push()
private void set_push(bool value)
}
public UnityEngine.ForceMode : Enum {
public int value__
public ForceMode Force
public ForceMode Acceleration
public ForceMode Impulse
public ForceMode VelocityChange
}
public UnityEngine.HingeJoint : Joint {
public JointMotor motor
public JointLimits limits
public JointSpring spring
public bool useMotor
public bool useLimits
public bool useSpring
public float velocity
public float angle
public JointMotor get_motor()
public void set_motor(JointMotor value)
private void INTERNAL_get_motor(JointMotor& value)
private void INTERNAL_set_motor(JointMotor& value)
public JointLimits get_limits()
public void set_limits(JointLimits value)
private void INTERNAL_get_limits(JointLimits& value)
private void INTERNAL_set_limits(JointLimits& value)
public JointSpring get_spring()
public void set_spring(JointSpring value)
private void INTERNAL_get_spring(JointSpring& value)
private void INTERNAL_set_spring(JointSpring& value)
public bool get_useMotor()
public void set_useMotor(bool value)
public bool get_useLimits()
public void set_useLimits(bool value)
public bool get_useSpring()
public void set_useSpring(bool value)
public float get_velocity()
public float get_angle()
}
public UnityEngine.Joint : Component {
public Rigidbody connectedBody
public Vector3 axis
public Vector3 anchor
public Vector3 connectedAnchor
public bool autoConfigureConnectedAnchor
public float breakForce
public float breakTorque
public bool enableCollision
public bool enablePreprocessing
public Vector3 currentForce
public Vector3 currentTorque
public float massScale
public float connectedMassScale
public Rigidbody get_connectedBody()
public void set_connectedBody(Rigidbody value)
public Vector3 get_axis()
public void set_axis(Vector3 value)
private void INTERNAL_get_axis(Vector3& value)
private void INTERNAL_set_axis(Vector3& value)
public Vector3 get_anchor()
public void set_anchor(Vector3 value)
private void INTERNAL_get_anchor(Vector3& value)
private void INTERNAL_set_anchor(Vector3& value)
public Vector3 get_connectedAnchor()
public void set_connectedAnchor(Vector3 value)
private void INTERNAL_get_connectedAnchor(Vector3& value)
private void INTERNAL_set_connectedAnchor(Vector3& value)
public bool get_autoConfigureConnectedAnchor()
public void set_autoConfigureConnectedAnchor(bool value)
public float get_breakForce()
public void set_breakForce(float value)
public float get_breakTorque()
public void set_breakTorque(float value)
public bool get_enableCollision()
public void set_enableCollision(bool value)
public bool get_enablePreprocessing()
public void set_enablePreprocessing(bool value)
public Vector3 get_currentForce()
private void INTERNAL_get_currentForce(Vector3& value)
public Vector3 get_currentTorque()
private void INTERNAL_get_currentTorque(Vector3& value)
public float get_massScale()
public void set_massScale(float value)
public float get_connectedMassScale()
public void set_connectedMassScale(float value)
}
public UnityEngine.JointDrive : ValueType {
private float m_PositionSpring
private float m_PositionDamper
private float m_MaximumForce
public JointDriveMode mode
public float positionSpring
public float positionDamper
public float maximumForce
public JointDriveMode get_mode()
public void set_mode(JointDriveMode value)
public float get_positionSpring()
public void set_positionSpring(float value)
public float get_positionDamper()
public void set_positionDamper(float value)
public float get_maximumForce()
public void set_maximumForce(float value)
}
public UnityEngine.JointDriveMode : Enum {
public int value__
public JointDriveMode None
public JointDriveMode Position
public JointDriveMode Velocity
public JointDriveMode PositionAndVelocity
}
public UnityEngine.JointLimits : ValueType {
private float m_Min
private float m_Max
private float m_Bounciness
private float m_BounceMinVelocity
private float m_ContactDistance
public float minBounce
public float maxBounce
public float min
public float max
public float bounciness
public float bounceMinVelocity
public float contactDistance
public float get_min()
public void set_min(float value)
public float get_max()
public void set_max(float value)
public float get_bounciness()
public void set_bounciness(float value)
public float get_bounceMinVelocity()
public void set_bounceMinVelocity(float value)
public float get_contactDistance()
public void set_contactDistance(float value)
}
public UnityEngine.JointMotor : ValueType {
private float m_TargetVelocity
private float m_Force
private int m_FreeSpin
public float targetVelocity
public float force
public bool freeSpin
public float get_targetVelocity()
public void set_targetVelocity(float value)
public float get_force()
public void set_force(float value)
public bool get_freeSpin()
public void set_freeSpin(bool value)
}
public UnityEngine.JointProjectionMode : Enum {
public int value__
public JointProjectionMode None
public JointProjectionMode PositionAndRotation
public JointProjectionMode PositionOnly
}
public UnityEngine.JointSpring : ValueType {
public float spring
public float damper
public float targetPosition
}
public UnityEngine.MeshCollider : Collider {
public Mesh sharedMesh
public bool convex
public MeshColliderCookingOptions cookingOptions
public bool inflateMesh
public float skinWidth
public bool smoothSphereCollisions
public Mesh get_sharedMesh()
public void set_sharedMesh(Mesh value)
public bool get_convex()
public void set_convex(bool value)
public MeshColliderCookingOptions get_cookingOptions()
public void set_cookingOptions(MeshColliderCookingOptions value)
public bool get_inflateMesh()
public void set_inflateMesh(bool value)
public float get_skinWidth()
public void set_skinWidth(float value)
public bool get_smoothSphereCollisions()
public void set_smoothSphereCollisions(bool value)
}
public UnityEngine.MeshColliderCookingOptions : Enum {
public int value__
public MeshColliderCookingOptions None
public MeshColliderCookingOptions InflateConvexMesh
public MeshColliderCookingOptions CookForFasterSimulation
public MeshColliderCookingOptions EnableMeshCleaning
public MeshColliderCookingOptions WeldColocatedVertices
}
public UnityEngine.PhysicMaterial : Object {
public float dynamicFriction
public float staticFriction
public float bounciness
public float bouncyness
public Vector3 frictionDirection2
public float dynamicFriction2
public float staticFriction2
public PhysicMaterialCombine frictionCombine
public PhysicMaterialCombine bounceCombine
public Vector3 frictionDirection
public void .ctor(string name)
private void Internal_CreateDynamicsMaterial(PhysicMaterial mat, string name)
public float get_dynamicFriction()
public void set_dynamicFriction(float value)
public float get_staticFriction()
public void set_staticFriction(float value)
public float get_bounciness()
public void set_bounciness(float value)
public float get_bouncyness()
public void set_bouncyness(float value)
public Vector3 get_frictionDirection2()
public void set_frictionDirection2(Vector3 value)
public float get_dynamicFriction2()
public void set_dynamicFriction2(float value)
public float get_staticFriction2()
public void set_staticFriction2(float value)
public PhysicMaterialCombine get_frictionCombine()
public void set_frictionCombine(PhysicMaterialCombine value)
public PhysicMaterialCombine get_bounceCombine()
public void set_bounceCombine(PhysicMaterialCombine value)
public Vector3 get_frictionDirection()
public void set_frictionDirection(Vector3 value)
}
public UnityEngine.PhysicMaterialCombine : Enum {
public int value__
public PhysicMaterialCombine Average
public PhysicMaterialCombine Minimum
public PhysicMaterialCombine Multiply
public PhysicMaterialCombine Maximum
}
public UnityEngine.Physics : object {
internal float k_MaxFloatMinusEpsilon
public int IgnoreRaycastLayer
public int kIgnoreRaycastLayer
public int DefaultRaycastLayers
public int kDefaultRaycastLayers
public int AllLayers
public int kAllLayers
public Vector3 gravity
public float minPenetrationForPenalty
public float defaultContactOffset
public float bounceThreshold
public float bounceTreshold
public float sleepVelocity
public float sleepAngularVelocity
public float maxAngularVelocity
public int defaultSolverIterations
public int solverIterationCount
public int defaultSolverVelocityIterations
public int solverVelocityIterationCount
public float sleepThreshold
public bool queriesHitTriggers
public bool queriesHitBackfaces
public float interCollisionDistance
public float interCollisionStiffness
public bool interCollisionSettingsToggle
public float penetrationPenaltyForce
public bool autoSimulation
public bool autoSyncTransforms
public Vector3 get_gravity()
public void set_gravity(Vector3 value)
private void INTERNAL_get_gravity(Vector3& value)
private void INTERNAL_set_gravity(Vector3& value)
public float get_minPenetrationForPenalty()
public void set_minPenetrationForPenalty(float value)
public float get_defaultContactOffset()
public void set_defaultContactOffset(float value)
public float get_bounceThreshold()
public void set_bounceThreshold(float value)
public float get_bounceTreshold()
public void set_bounceTreshold(float value)
public float get_sleepVelocity()
public void set_sleepVelocity(float value)
public float get_sleepAngularVelocity()
public void set_sleepAngularVelocity(float value)
public float get_maxAngularVelocity()
public void set_maxAngularVelocity(float value)
public int get_defaultSolverIterations()
public void set_defaultSolverIterations(int value)
public int get_solverIterationCount()
public void set_solverIterationCount(int value)
public int get_defaultSolverVelocityIterations()
public void set_defaultSolverVelocityIterations(int value)
public int get_solverVelocityIterationCount()
public void set_solverVelocityIterationCount(int value)
public float get_sleepThreshold()
public void set_sleepThreshold(float value)
public bool get_queriesHitTriggers()
public void set_queriesHitTriggers(bool value)
public bool get_queriesHitBackfaces()
public void set_queriesHitBackfaces(bool value)
public float get_interCollisionDistance()
public void set_interCollisionDistance(float value)
public float get_interCollisionStiffness()
public void set_interCollisionStiffness(float value)
public bool get_interCollisionSettingsToggle()
public void set_interCollisionSettingsToggle(bool value)
public bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, int layerMask)
public bool Raycast(Vector3 origin, Vector3 direction, float maxDistance)
public bool Raycast(Vector3 origin, Vector3 direction)
public bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance)
public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo)
public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Raycast(Ray ray, float maxDistance, int layerMask)
public bool Raycast(Ray ray, float maxDistance)
public bool Raycast(Ray ray)
public bool Raycast(Ray ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance)
public bool Raycast(Ray ray, RaycastHit& hitInfo)
public bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] RaycastAll(Ray ray, float maxDistance, int layerMask)
public RaycastHit[] RaycastAll(Ray ray, float maxDistance)
public RaycastHit[] RaycastAll(Ray ray)
public RaycastHit[] RaycastAll(Ray ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance, int layermask)
public RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance)
public RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction)
private RaycastHit[] INTERNAL_CALL_RaycastAll(Vector3& origin, Vector3& direction, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance, int layerMask)
public int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance)
public int RaycastNonAlloc(Ray ray, RaycastHit[] results)
public int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance, int layermask)
public int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance)
public int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results)
private int INTERNAL_CALL_RaycastNonAlloc(Vector3& origin, Vector3& direction, RaycastHit[] results, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public bool Linecast(Vector3 start, Vector3 end, int layerMask)
public bool Linecast(Vector3 start, Vector3 end)
public bool Linecast(Vector3 start, Vector3 end, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Linecast(Vector3 start, Vector3 end, RaycastHit& hitInfo, int layerMask)
public bool Linecast(Vector3 start, Vector3 end, RaycastHit& hitInfo)
public bool Linecast(Vector3 start, Vector3 end, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapSphere(Vector3 position, float radius, int layerMask)
public Collider[] OverlapSphere(Vector3 position, float radius)
private Collider[] INTERNAL_CALL_OverlapSphere(Vector3& position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results, int layerMask)
public int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results)
private int INTERNAL_CALL_OverlapSphereNonAlloc(Vector3& position, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, int layerMask)
public Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius)
private Collider[] INTERNAL_CALL_OverlapCapsule(Vector3& point0, Vector3& point1, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask)
public int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results)
private int INTERNAL_CALL_OverlapCapsuleNonAlloc(Vector3& point0, Vector3& point1, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance)
public bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo)
public bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool SphereCast(Ray ray, float radius, float maxDistance, int layerMask)
public bool SphereCast(Ray ray, float radius, float maxDistance)
public bool SphereCast(Ray ray, float radius)
public bool SphereCast(Ray ray, float radius, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance)
public bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo)
public bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layermask)
public RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance)
public RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction)
private RaycastHit[] INTERNAL_CALL_CapsuleCastAll(Vector3& point1, Vector3& point2, float radius, Vector3& direction, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layermask)
public int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance)
public int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results)
private int INTERNAL_CALL_CapsuleCastNonAlloc(Vector3& point1, Vector3& point2, float radius, Vector3& direction, RaycastHit[] results, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance, int layerMask)
public RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance)
public RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction)
public RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance, int layerMask)
public RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance)
public RaycastHit[] SphereCastAll(Ray ray, float radius)
public RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask)
public int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance)
public int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results)
public int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance, int layerMask)
public int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance)
public int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results)
public int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckSphere(Vector3 position, float radius, int layerMask)
public bool CheckSphere(Vector3 position, float radius)
private bool INTERNAL_CALL_CheckSphere(Vector3& position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layermask)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius)
private bool INTERNAL_CALL_CheckCapsule(Vector3& start, Vector3& end, float radius, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layermask)
public bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation)
public bool CheckBox(Vector3 center, Vector3 halfExtents)
private bool INTERNAL_CALL_CheckBox(Vector3& center, Vector3& halfExtents, Quaternion& orientation, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask)
public Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation)
public Collider[] OverlapBox(Vector3 center, Vector3 halfExtents)
private Collider[] INTERNAL_CALL_OverlapBox(Vector3& center, Vector3& halfExtents, Quaternion& orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int layerMask)
public int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation)
public int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results)
private int INTERNAL_CALL_OverlapBoxNonAlloc(Vector3& center, Vector3& halfExtents, Collider[] results, Quaternion& orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layermask)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction)
private RaycastHit[] INTERNAL_CALL_BoxCastAll(Vector3& center, Vector3& halfExtents, Vector3& direction, Quaternion& orientation, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance, int layermask)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results)
private int INTERNAL_CALL_BoxCastNonAlloc(Vector3& center, Vector3& halfExtents, Vector3& direction, RaycastHit[] results, Quaternion& orientation, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
private bool Internal_BoxCast(Vector3 center, Vector3 halfExtents, Quaternion orientation, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
private bool INTERNAL_CALL_Internal_BoxCast(Vector3& center, Vector3& halfExtents, Quaternion& orientation, Vector3& direction, RaycastHit& hitInfo, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance, int layerMask)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public float get_penetrationPenaltyForce()
public void set_penetrationPenaltyForce(float value)
public void IgnoreCollision(Collider collider1, Collider collider2, bool ignore)
public void IgnoreCollision(Collider collider1, Collider collider2)
public void IgnoreLayerCollision(int layer1, int layer2, bool ignore)
public void IgnoreLayerCollision(int layer1, int layer2)
public bool GetIgnoreLayerCollision(int layer1, int layer2)
private bool Internal_Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
private bool INTERNAL_CALL_Internal_Raycast(Vector3& origin, Vector3& direction, RaycastHit& hitInfo, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
private bool Internal_CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
private bool INTERNAL_CALL_Internal_CapsuleCast(Vector3& point1, Vector3& point2, float radius, Vector3& direction, RaycastHit& hitInfo, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
private bool Internal_RaycastTest(Vector3 origin, Vector3 direction, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
private bool INTERNAL_CALL_Internal_RaycastTest(Vector3& origin, Vector3& direction, float maxDistance, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public bool ComputePenetration(Collider colliderA, Vector3 positionA, Quaternion rotationA, Collider colliderB, Vector3 positionB, Quaternion rotationB, Vector3& direction, Single& distance)
private bool INTERNAL_CALL_ComputePenetration(Collider colliderA, Vector3& positionA, Quaternion& rotationA, Collider colliderB, Vector3& positionB, Quaternion& rotationB, Vector3& direction, Single& distance)
public Vector3 ClosestPoint(Vector3 point, Collider collider, Vector3 position, Quaternion rotation)
private void INTERNAL_CALL_ClosestPoint(Vector3& point, Collider collider, Vector3& position, Quaternion& rotation, Vector3& value)
public void Simulate(float step)
public bool get_autoSimulation()
public void set_autoSimulation(bool value)
public void SyncTransforms()
public bool get_autoSyncTransforms()
public void set_autoSyncTransforms(bool value)
public void RebuildBroadphaseRegions(Bounds worldBounds, int subdivisions)
private void INTERNAL_CALL_RebuildBroadphaseRegions(Bounds& worldBounds, int subdivisions)
}
public UnityEngine.QueryTriggerInteraction : Enum {
public int value__
public QueryTriggerInteraction UseGlobal
public QueryTriggerInteraction Ignore
public QueryTriggerInteraction Collide
}
public UnityEngine.RaycastCommand : ValueType {
public Vector3 from
public Vector3 direction
private float <distance>k__BackingField
private int <layerMask>k__BackingField
private int <maxHits>k__BackingField
public float distance
public int layerMask
public int maxHits
public void .ctor(Vector3 from, Vector3 direction, float distance, int layerMask, int maxHits)
public float get_distance()
public void set_distance(float value)
public int get_layerMask()
public void set_layerMask(int value)
public int get_maxHits()
public void set_maxHits(int value)
public JobHandle ScheduleBatch(NativeArray`1<RaycastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn)
private JobHandle ScheduleRaycastBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob)
private void ScheduleRaycastBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, JobHandle& ret)
}
public UnityEngine.RaycastHit : ValueType {
private Vector3 m_Point
private Vector3 m_Normal
private int m_FaceID
private float m_Distance
private Vector2 m_UV
private int m_Collider
public Vector3 point
public Vector3 normal
public Vector3 barycentricCoordinate
public float distance
public int triangleIndex
public Vector2 textureCoord
public Vector2 textureCoord2
public Vector2 textureCoord1
public Vector2 lightmapCoord
public Collider collider
public Rigidbody rigidbody
public Transform transform
private void CalculateRaycastTexCoord(Vector2& output, Collider col, Vector2 uv, Vector3 point, int face, int index)
private void INTERNAL_CALL_CalculateRaycastTexCoord(Vector2& output, Collider col, Vector2& uv, Vector3& point, int face, int index)
public Vector3 get_point()
public void set_point(Vector3 value)
public Vector3 get_normal()
public void set_normal(Vector3 value)
public Vector3 get_barycentricCoordinate()
public void set_barycentricCoordinate(Vector3 value)
public float get_distance()
public void set_distance(float value)
public int get_triangleIndex()
public Vector2 get_textureCoord()
public Vector2 get_textureCoord2()
public Vector2 get_textureCoord1()
public Vector2 get_lightmapCoord()
public Collider get_collider()
public Rigidbody get_rigidbody()
public Transform get_transform()
}
public UnityEngine.Rigidbody : Component {
public Vector3 velocity
public Vector3 angularVelocity
public float drag
public float angularDrag
public float mass
public bool useGravity
public float maxDepenetrationVelocity
public bool isKinematic
public bool freezeRotation
public RigidbodyConstraints constraints
public CollisionDetectionMode collisionDetectionMode
public Vector3 centerOfMass
public Vector3 worldCenterOfMass
public Quaternion inertiaTensorRotation
public Vector3 inertiaTensor
public bool detectCollisions
public bool useConeFriction
public Vector3 position
public Quaternion rotation
public RigidbodyInterpolation interpolation
public int solverIterations
public int solverIterationCount
public int solverVelocityIterations
public int solverVelocityIterationCount
public float sleepVelocity
public float sleepAngularVelocity
public float sleepThreshold
public float maxAngularVelocity
public Vector3 get_velocity()
public void set_velocity(Vector3 value)
private void INTERNAL_get_velocity(Vector3& value)
private void INTERNAL_set_velocity(Vector3& value)
public Vector3 get_angularVelocity()
public void set_angularVelocity(Vector3 value)
private void INTERNAL_get_angularVelocity(Vector3& value)
private void INTERNAL_set_angularVelocity(Vector3& value)
public float get_drag()
public void set_drag(float value)
public float get_angularDrag()
public void set_angularDrag(float value)
public float get_mass()
public void set_mass(float value)
public void SetDensity(float density)
private void INTERNAL_CALL_SetDensity(Rigidbody self, float density)
public bool get_useGravity()
public void set_useGravity(bool value)
public float get_maxDepenetrationVelocity()
public void set_maxDepenetrationVelocity(float value)
public bool get_isKinematic()
public void set_isKinematic(bool value)
public bool get_freezeRotation()
public void set_freezeRotation(bool value)
public RigidbodyConstraints get_constraints()
public void set_constraints(RigidbodyConstraints value)
public CollisionDetectionMode get_collisionDetectionMode()
public void set_collisionDetectionMode(CollisionDetectionMode value)
public void AddForce(Vector3 force, ForceMode mode)
public void AddForce(Vector3 force)
private void INTERNAL_CALL_AddForce(Rigidbody self, Vector3& force, ForceMode mode)
public void AddForce(float x, float y, float z)
public void AddForce(float x, float y, float z, ForceMode mode)
public void AddRelativeForce(Vector3 force, ForceMode mode)
public void AddRelativeForce(Vector3 force)
private void INTERNAL_CALL_AddRelativeForce(Rigidbody self, Vector3& force, ForceMode mode)
public void AddRelativeForce(float x, float y, float z)
public void AddRelativeForce(float x, float y, float z, ForceMode mode)
public void AddTorque(Vector3 torque, ForceMode mode)
public void AddTorque(Vector3 torque)
private void INTERNAL_CALL_AddTorque(Rigidbody self, Vector3& torque, ForceMode mode)
public void AddTorque(float x, float y, float z)
public void AddTorque(float x, float y, float z, ForceMode mode)
public void AddRelativeTorque(Vector3 torque, ForceMode mode)
public void AddRelativeTorque(Vector3 torque)
private void INTERNAL_CALL_AddRelativeTorque(Rigidbody self, Vector3& torque, ForceMode mode)
public void AddRelativeTorque(float x, float y, float z)
public void AddRelativeTorque(float x, float y, float z, ForceMode mode)
public void AddForceAtPosition(Vector3 force, Vector3 position, ForceMode mode)
public void AddForceAtPosition(Vector3 force, Vector3 position)
private void INTERNAL_CALL_AddForceAtPosition(Rigidbody self, Vector3& force, Vector3& position, ForceMode mode)
public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier, ForceMode mode)
public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier)
public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius)
private void INTERNAL_CALL_AddExplosionForce(Rigidbody self, float explosionForce, Vector3& explosionPosition, float explosionRadius, float upwardsModifier, ForceMode mode)
public Vector3 ClosestPointOnBounds(Vector3 position)
private void INTERNAL_CALL_ClosestPointOnBounds(Rigidbody self, Vector3& position, Vector3& value)
public Vector3 GetRelativePointVelocity(Vector3 relativePoint)
private void INTERNAL_CALL_GetRelativePointVelocity(Rigidbody self, Vector3& relativePoint, Vector3& value)
public Vector3 GetPointVelocity(Vector3 worldPoint)
private void INTERNAL_CALL_GetPointVelocity(Rigidbody self, Vector3& worldPoint, Vector3& value)
public Vector3 get_centerOfMass()
public void set_centerOfMass(Vector3 value)
private void INTERNAL_get_centerOfMass(Vector3& value)
private void INTERNAL_set_centerOfMass(Vector3& value)
public Vector3 get_worldCenterOfMass()
private void INTERNAL_get_worldCenterOfMass(Vector3& value)
public Quaternion get_inertiaTensorRotation()
public void set_inertiaTensorRotation(Quaternion value)
private void INTERNAL_get_inertiaTensorRotation(Quaternion& value)
private void INTERNAL_set_inertiaTensorRotation(Quaternion& value)
public Vector3 get_inertiaTensor()
public void set_inertiaTensor(Vector3 value)
private void INTERNAL_get_inertiaTensor(Vector3& value)
private void INTERNAL_set_inertiaTensor(Vector3& value)
public bool get_detectCollisions()
public void set_detectCollisions(bool value)
public bool get_useConeFriction()
public void set_useConeFriction(bool value)
public Vector3 get_position()
public void set_position(Vector3 value)
private void INTERNAL_get_position(Vector3& value)
private void INTERNAL_set_position(Vector3& value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
private void INTERNAL_get_rotation(Quaternion& value)
private void INTERNAL_set_rotation(Quaternion& value)
public void MovePosition(Vector3 position)
private void INTERNAL_CALL_MovePosition(Rigidbody self, Vector3& position)
public void MoveRotation(Quaternion rot)
private void INTERNAL_CALL_MoveRotation(Rigidbody self, Quaternion& rot)
public RigidbodyInterpolation get_interpolation()
public void set_interpolation(RigidbodyInterpolation value)
public void Sleep()
private void INTERNAL_CALL_Sleep(Rigidbody self)
public bool IsSleeping()
private bool INTERNAL_CALL_IsSleeping(Rigidbody self)
public void WakeUp()
private void INTERNAL_CALL_WakeUp(Rigidbody self)
public void ResetCenterOfMass()
private void INTERNAL_CALL_ResetCenterOfMass(Rigidbody self)
public void ResetInertiaTensor()
private void INTERNAL_CALL_ResetInertiaTensor(Rigidbody self)
public int get_solverIterations()
public void set_solverIterations(int value)
public int get_solverIterationCount()
public void set_solverIterationCount(int value)
public int get_solverVelocityIterations()
public void set_solverVelocityIterations(int value)
public int get_solverVelocityIterationCount()
public void set_solverVelocityIterationCount(int value)
public float get_sleepVelocity()
public void set_sleepVelocity(float value)
public float get_sleepAngularVelocity()
public void set_sleepAngularVelocity(float value)
public float get_sleepThreshold()
public void set_sleepThreshold(float value)
public float get_maxAngularVelocity()
public void set_maxAngularVelocity(float value)
public bool SweepTest(Vector3 direction, RaycastHit& hitInfo, float maxDistance, QueryTriggerInteraction queryTriggerInteraction)
public bool SweepTest(Vector3 direction, RaycastHit& hitInfo, float maxDistance)
public bool SweepTest(Vector3 direction, RaycastHit& hitInfo)
private bool INTERNAL_CALL_SweepTest(Rigidbody self, Vector3& direction, RaycastHit& hitInfo, float maxDistance, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] SweepTestAll(Vector3 direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] SweepTestAll(Vector3 direction, float maxDistance)
public RaycastHit[] SweepTestAll(Vector3 direction)
private RaycastHit[] INTERNAL_CALL_SweepTestAll(Rigidbody self, Vector3& direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction)
public void SetMaxAngularVelocity(float a)
}
public UnityEngine.RigidbodyConstraints : Enum {
public int value__
public RigidbodyConstraints None
public RigidbodyConstraints FreezePositionX
public RigidbodyConstraints FreezePositionY
public RigidbodyConstraints FreezePositionZ
public RigidbodyConstraints FreezeRotationX
public RigidbodyConstraints FreezeRotationY
public RigidbodyConstraints FreezeRotationZ
public RigidbodyConstraints FreezePosition
public RigidbodyConstraints FreezeRotation
public RigidbodyConstraints FreezeAll
}
public UnityEngine.RigidbodyInterpolation : Enum {
public int value__
public RigidbodyInterpolation None
public RigidbodyInterpolation Interpolate
public RigidbodyInterpolation Extrapolate
}
public UnityEngine.RotationDriveMode : Enum {
public int value__
public RotationDriveMode XYAndZ
public RotationDriveMode Slerp
}
public UnityEngine.SoftJointLimit : ValueType {
private float m_Limit
private float m_Bounciness
private float m_ContactDistance
public float limit
public float spring
public float damper
public float bounciness
public float contactDistance
public float bouncyness
public float get_limit()
public void set_limit(float value)
public float get_spring()
public void set_spring(float value)
public float get_damper()
public void set_damper(float value)
public float get_bounciness()
public void set_bounciness(float value)
public float get_contactDistance()
public void set_contactDistance(float value)
public float get_bouncyness()
public void set_bouncyness(float value)
}
public UnityEngine.SoftJointLimitSpring : ValueType {
private float m_Spring
private float m_Damper
public float spring
public float damper
public float get_spring()
public void set_spring(float value)
public float get_damper()
public void set_damper(float value)
}
public UnityEngine.SphereCollider : Collider {
public Vector3 center
public float radius
public Vector3 get_center()
public void set_center(Vector3 value)
private void INTERNAL_get_center(Vector3& value)
private void INTERNAL_set_center(Vector3& value)
public float get_radius()
public void set_radius(float value)
}
public UnityEngine.SpringJoint : Joint {
public float spring
public float damper
public float minDistance
public float maxDistance
public float tolerance
public float get_spring()
public void set_spring(float value)
public float get_damper()
public void set_damper(float value)
public float get_minDistance()
public void set_minDistance(float value)
public float get_maxDistance()
public void set_maxDistance(float value)
public float get_tolerance()
public void set_tolerance(float value)
}
public UnityEngine.WheelFrictionCurve : ValueType {
private float m_ExtremumSlip
private float m_ExtremumValue
private float m_AsymptoteSlip
private float m_AsymptoteValue
private float m_Stiffness
public float extremumSlip
public float extremumValue
public float asymptoteSlip
public float asymptoteValue
public float stiffness
public float get_extremumSlip()
public void set_extremumSlip(float value)
public float get_extremumValue()
public void set_extremumValue(float value)
public float get_asymptoteSlip()
public void set_asymptoteSlip(float value)
public float get_asymptoteValue()
public void set_asymptoteValue(float value)
public float get_stiffness()
public void set_stiffness(float value)
}
