public UnityEngine.BoxcastCommand : ValueType {
private Vector3 <center>k__BackingField
private Vector3 <halfExtents>k__BackingField
private Quaternion <orientation>k__BackingField
private Vector3 <direction>k__BackingField
private float <distance>k__BackingField
private int <layerMask>k__BackingField
private int <maxHits>k__BackingField
public Vector3 center
public Vector3 halfExtents
public Quaternion orientation
public Vector3 direction
public float distance
public int layerMask
internal int maxHits
public void .ctor(Vector3 center, Vector3 halfExtents, Quaternion orientation, Vector3 direction, float distance, int layerMask)
public Vector3 get_center()
public void set_center(Vector3 value)
public Vector3 get_halfExtents()
public void set_halfExtents(Vector3 value)
public Quaternion get_orientation()
public void set_orientation(Quaternion value)
public Vector3 get_direction()
public void set_direction(Vector3 value)
public float get_distance()
public void set_distance(float value)
public int get_layerMask()
public void set_layerMask(int value)
internal int get_maxHits()
internal void set_maxHits(int value)
public JobHandle ScheduleBatch(NativeArray`1<BoxcastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn)
private JobHandle ScheduleBoxcastBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob)
private void ScheduleBoxcastBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, JobHandle& ret)
}
public UnityEngine.BoxCollider : Collider {
public Vector3 center
public Vector3 size
public Vector3 extents
public Vector3 get_center()
public void set_center(Vector3 value)
public Vector3 get_size()
public void set_size(Vector3 value)
public Vector3 get_extents()
public void set_extents(Vector3 value)
private void get_center_Injected(Vector3& ret)
private void set_center_Injected(Vector3& value)
private void get_size_Injected(Vector3& ret)
private void set_size_Injected(Vector3& value)
}
public UnityEngine.CapsulecastCommand : ValueType {
private Vector3 <point1>k__BackingField
private Vector3 <point2>k__BackingField
private float <radius>k__BackingField
private Vector3 <direction>k__BackingField
private float <distance>k__BackingField
private int <layerMask>k__BackingField
private int <maxHits>k__BackingField
public Vector3 point1
public Vector3 point2
public float radius
public Vector3 direction
public float distance
public int layerMask
internal int maxHits
public void .ctor(Vector3 p1, Vector3 p2, float radius, Vector3 direction, float distance, int layerMask)
public Vector3 get_point1()
public void set_point1(Vector3 value)
public Vector3 get_point2()
public void set_point2(Vector3 value)
public float get_radius()
public void set_radius(float value)
public Vector3 get_direction()
public void set_direction(Vector3 value)
public float get_distance()
public void set_distance(float value)
public int get_layerMask()
public void set_layerMask(int value)
internal int get_maxHits()
internal void set_maxHits(int value)
public JobHandle ScheduleBatch(NativeArray`1<CapsulecastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn)
private JobHandle ScheduleCapsulecastBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob)
private void ScheduleCapsulecastBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, JobHandle& ret)
}
public UnityEngine.CapsuleCollider : Collider {
public Vector3 center
public float radius
public float height
public int direction
public Vector3 get_center()
public void set_center(Vector3 value)
public float get_radius()
public void set_radius(float value)
public float get_height()
public void set_height(float value)
public int get_direction()
public void set_direction(int value)
internal Vector2 GetGlobalExtents()
internal Matrix4x4 CalculateTransform()
private void get_center_Injected(Vector3& ret)
private void set_center_Injected(Vector3& value)
private void GetGlobalExtents_Injected(Vector2& ret)
private void CalculateTransform_Injected(Matrix4x4& ret)
}
public UnityEngine.CharacterController : Collider {
public Vector3 velocity
public bool isGrounded
public CollisionFlags collisionFlags
public float radius
public float height
public Vector3 center
public float slopeLimit
public float stepOffset
public float skinWidth
public float minMoveDistance
public bool detectCollisions
public bool enableOverlapRecovery
public bool SimpleMove(Vector3 speed)
public CollisionFlags Move(Vector3 motion)
public Vector3 get_velocity()
public bool get_isGrounded()
public CollisionFlags get_collisionFlags()
public float get_radius()
public void set_radius(float value)
public float get_height()
public void set_height(float value)
public Vector3 get_center()
public void set_center(Vector3 value)
public float get_slopeLimit()
public void set_slopeLimit(float value)
public float get_stepOffset()
public void set_stepOffset(float value)
public float get_skinWidth()
public void set_skinWidth(float value)
public float get_minMoveDistance()
public void set_minMoveDistance(float value)
public bool get_detectCollisions()
public void set_detectCollisions(bool value)
public bool get_enableOverlapRecovery()
public void set_enableOverlapRecovery(bool value)
private bool SimpleMove_Injected(Vector3& speed)
private CollisionFlags Move_Injected(Vector3& motion)
private void get_velocity_Injected(Vector3& ret)
private void get_center_Injected(Vector3& ret)
private void set_center_Injected(Vector3& value)
}
public UnityEngine.CharacterJoint : Joint {
public Quaternion targetRotation
public Vector3 targetAngularVelocity
public JointDrive rotationDrive
public Vector3 swingAxis
public SoftJointLimitSpring twistLimitSpring
public SoftJointLimitSpring swingLimitSpring
public SoftJointLimit lowTwistLimit
public SoftJointLimit highTwistLimit
public SoftJointLimit swing1Limit
public SoftJointLimit swing2Limit
public bool enableProjection
public float projectionDistance
public float projectionAngle
public Vector3 get_swingAxis()
public void set_swingAxis(Vector3 value)
public SoftJointLimitSpring get_twistLimitSpring()
public void set_twistLimitSpring(SoftJointLimitSpring value)
public SoftJointLimitSpring get_swingLimitSpring()
public void set_swingLimitSpring(SoftJointLimitSpring value)
public SoftJointLimit get_lowTwistLimit()
public void set_lowTwistLimit(SoftJointLimit value)
public SoftJointLimit get_highTwistLimit()
public void set_highTwistLimit(SoftJointLimit value)
public SoftJointLimit get_swing1Limit()
public void set_swing1Limit(SoftJointLimit value)
public SoftJointLimit get_swing2Limit()
public void set_swing2Limit(SoftJointLimit value)
public bool get_enableProjection()
public void set_enableProjection(bool value)
public float get_projectionDistance()
public void set_projectionDistance(float value)
public float get_projectionAngle()
public void set_projectionAngle(float value)
private void get_swingAxis_Injected(Vector3& ret)
private void set_swingAxis_Injected(Vector3& value)
private void get_twistLimitSpring_Injected(SoftJointLimitSpring& ret)
private void set_twistLimitSpring_Injected(SoftJointLimitSpring& value)
private void get_swingLimitSpring_Injected(SoftJointLimitSpring& ret)
private void set_swingLimitSpring_Injected(SoftJointLimitSpring& value)
private void get_lowTwistLimit_Injected(SoftJointLimit& ret)
private void set_lowTwistLimit_Injected(SoftJointLimit& value)
private void get_highTwistLimit_Injected(SoftJointLimit& ret)
private void set_highTwistLimit_Injected(SoftJointLimit& value)
private void get_swing1Limit_Injected(SoftJointLimit& ret)
private void set_swing1Limit_Injected(SoftJointLimit& value)
private void get_swing2Limit_Injected(SoftJointLimit& ret)
private void set_swing2Limit_Injected(SoftJointLimit& value)
}
public UnityEngine.Collider : Component {
public bool enabled
public Rigidbody attachedRigidbody
public bool isTrigger
public float contactOffset
public Bounds bounds
public PhysicMaterial sharedMaterial
public PhysicMaterial material
public bool get_enabled()
public void set_enabled(bool value)
public Rigidbody get_attachedRigidbody()
public bool get_isTrigger()
public void set_isTrigger(bool value)
public float get_contactOffset()
public void set_contactOffset(float value)
public Vector3 ClosestPoint(Vector3 position)
public Bounds get_bounds()
public PhysicMaterial get_sharedMaterial()
public void set_sharedMaterial(PhysicMaterial value)
public PhysicMaterial get_material()
public void set_material(PhysicMaterial value)
private RaycastHit Raycast(Ray ray, float maxDistance, Boolean& hasHit)
public bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance)
private void Internal_ClosestPointOnBounds(Vector3 point, Vector3& outPos, Single& distance)
public Vector3 ClosestPointOnBounds(Vector3 position)
private void ClosestPoint_Injected(Vector3& position, Vector3& ret)
private void get_bounds_Injected(Bounds& ret)
private void Raycast_Injected(Ray& ray, float maxDistance, Boolean& hasHit, RaycastHit& ret)
private void Internal_ClosestPointOnBounds_Injected(Vector3& point, Vector3& outPos, Single& distance)
}
public UnityEngine.Collision : object {
internal Vector3 m_Impulse
internal Vector3 m_RelativeVelocity
internal Rigidbody m_Rigidbody
internal Collider m_Collider
internal int m_ContactCount
internal ContactPoint[] m_RecycledContacts
internal ContactPoint[] m_LegacyContacts
public Vector3 relativeVelocity
public Rigidbody rigidbody
public Collider collider
public Transform transform
public GameObject gameObject
public int contactCount
public ContactPoint[] contacts
public Vector3 impulse
public Vector3 impactForceSum
public Vector3 frictionForceSum
public Component other
private ContactPoint[] GetContacts_Internal()
public Vector3 get_relativeVelocity()
public Rigidbody get_rigidbody()
public Collider get_collider()
public Transform get_transform()
public GameObject get_gameObject()
public int get_contactCount()
public ContactPoint[] get_contacts()
public ContactPoint GetContact(int index)
public int GetContacts(ContactPoint[] contacts)
public IEnumerator GetEnumerator()
public Vector3 get_impulse()
public Vector3 get_impactForceSum()
public Vector3 get_frictionForceSum()
public Component get_other()
}
public UnityEngine.CollisionDetectionMode : Enum {
public int value__
public CollisionDetectionMode Discrete
public CollisionDetectionMode Continuous
public CollisionDetectionMode ContinuousDynamic
public CollisionDetectionMode ContinuousSpeculative
}
public UnityEngine.CollisionFlags : Enum {
public int value__
public CollisionFlags None
public CollisionFlags Sides
public CollisionFlags Above
public CollisionFlags Below
public CollisionFlags CollidedSides
public CollisionFlags CollidedAbove
public CollisionFlags CollidedBelow
}
public UnityEngine.ConfigurableJoint : Joint {
public Vector3 secondaryAxis
public ConfigurableJointMotion xMotion
public ConfigurableJointMotion yMotion
public ConfigurableJointMotion zMotion
public ConfigurableJointMotion angularXMotion
public ConfigurableJointMotion angularYMotion
public ConfigurableJointMotion angularZMotion
public SoftJointLimitSpring linearLimitSpring
public SoftJointLimitSpring angularXLimitSpring
public SoftJointLimitSpring angularYZLimitSpring
public SoftJointLimit linearLimit
public SoftJointLimit lowAngularXLimit
public SoftJointLimit highAngularXLimit
public SoftJointLimit angularYLimit
public SoftJointLimit angularZLimit
public Vector3 targetPosition
public Vector3 targetVelocity
public JointDrive xDrive
public JointDrive yDrive
public JointDrive zDrive
public Quaternion targetRotation
public Vector3 targetAngularVelocity
public RotationDriveMode rotationDriveMode
public JointDrive angularXDrive
public JointDrive angularYZDrive
public JointDrive slerpDrive
public JointProjectionMode projectionMode
public float projectionDistance
public float projectionAngle
public bool configuredInWorldSpace
public bool swapBodies
public Vector3 get_secondaryAxis()
public void set_secondaryAxis(Vector3 value)
public ConfigurableJointMotion get_xMotion()
public void set_xMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_yMotion()
public void set_yMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_zMotion()
public void set_zMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_angularXMotion()
public void set_angularXMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_angularYMotion()
public void set_angularYMotion(ConfigurableJointMotion value)
public ConfigurableJointMotion get_angularZMotion()
public void set_angularZMotion(ConfigurableJointMotion value)
public SoftJointLimitSpring get_linearLimitSpring()
public void set_linearLimitSpring(SoftJointLimitSpring value)
public SoftJointLimitSpring get_angularXLimitSpring()
public void set_angularXLimitSpring(SoftJointLimitSpring value)
public SoftJointLimitSpring get_angularYZLimitSpring()
public void set_angularYZLimitSpring(SoftJointLimitSpring value)
public SoftJointLimit get_linearLimit()
public void set_linearLimit(SoftJointLimit value)
public SoftJointLimit get_lowAngularXLimit()
public void set_lowAngularXLimit(SoftJointLimit value)
public SoftJointLimit get_highAngularXLimit()
public void set_highAngularXLimit(SoftJointLimit value)
public SoftJointLimit get_angularYLimit()
public void set_angularYLimit(SoftJointLimit value)
public SoftJointLimit get_angularZLimit()
public void set_angularZLimit(SoftJointLimit value)
public Vector3 get_targetPosition()
public void set_targetPosition(Vector3 value)
public Vector3 get_targetVelocity()
public void set_targetVelocity(Vector3 value)
public JointDrive get_xDrive()
public void set_xDrive(JointDrive value)
public JointDrive get_yDrive()
public void set_yDrive(JointDrive value)
public JointDrive get_zDrive()
public void set_zDrive(JointDrive value)
public Quaternion get_targetRotation()
public void set_targetRotation(Quaternion value)
public Vector3 get_targetAngularVelocity()
public void set_targetAngularVelocity(Vector3 value)
public RotationDriveMode get_rotationDriveMode()
public void set_rotationDriveMode(RotationDriveMode value)
public JointDrive get_angularXDrive()
public void set_angularXDrive(JointDrive value)
public JointDrive get_angularYZDrive()
public void set_angularYZDrive(JointDrive value)
public JointDrive get_slerpDrive()
public void set_slerpDrive(JointDrive value)
public JointProjectionMode get_projectionMode()
public void set_projectionMode(JointProjectionMode value)
public float get_projectionDistance()
public void set_projectionDistance(float value)
public float get_projectionAngle()
public void set_projectionAngle(float value)
public bool get_configuredInWorldSpace()
public void set_configuredInWorldSpace(bool value)
public bool get_swapBodies()
public void set_swapBodies(bool value)
private void get_secondaryAxis_Injected(Vector3& ret)
private void set_secondaryAxis_Injected(Vector3& value)
private void get_linearLimitSpring_Injected(SoftJointLimitSpring& ret)
private void set_linearLimitSpring_Injected(SoftJointLimitSpring& value)
private void get_angularXLimitSpring_Injected(SoftJointLimitSpring& ret)
private void set_angularXLimitSpring_Injected(SoftJointLimitSpring& value)
private void get_angularYZLimitSpring_Injected(SoftJointLimitSpring& ret)
private void set_angularYZLimitSpring_Injected(SoftJointLimitSpring& value)
private void get_linearLimit_Injected(SoftJointLimit& ret)
private void set_linearLimit_Injected(SoftJointLimit& value)
private void get_lowAngularXLimit_Injected(SoftJointLimit& ret)
private void set_lowAngularXLimit_Injected(SoftJointLimit& value)
private void get_highAngularXLimit_Injected(SoftJointLimit& ret)
private void set_highAngularXLimit_Injected(SoftJointLimit& value)
private void get_angularYLimit_Injected(SoftJointLimit& ret)
private void set_angularYLimit_Injected(SoftJointLimit& value)
private void get_angularZLimit_Injected(SoftJointLimit& ret)
private void set_angularZLimit_Injected(SoftJointLimit& value)
private void get_targetPosition_Injected(Vector3& ret)
private void set_targetPosition_Injected(Vector3& value)
private void get_targetVelocity_Injected(Vector3& ret)
private void set_targetVelocity_Injected(Vector3& value)
private void get_xDrive_Injected(JointDrive& ret)
private void set_xDrive_Injected(JointDrive& value)
private void get_yDrive_Injected(JointDrive& ret)
private void set_yDrive_Injected(JointDrive& value)
private void get_zDrive_Injected(JointDrive& ret)
private void set_zDrive_Injected(JointDrive& value)
private void get_targetRotation_Injected(Quaternion& ret)
private void set_targetRotation_Injected(Quaternion& value)
private void get_targetAngularVelocity_Injected(Vector3& ret)
private void set_targetAngularVelocity_Injected(Vector3& value)
private void get_angularXDrive_Injected(JointDrive& ret)
private void set_angularXDrive_Injected(JointDrive& value)
private void get_angularYZDrive_Injected(JointDrive& ret)
private void set_angularYZDrive_Injected(JointDrive& value)
private void get_slerpDrive_Injected(JointDrive& ret)
private void set_slerpDrive_Injected(JointDrive& value)
}
public UnityEngine.ConfigurableJointMotion : Enum {
public int value__
public ConfigurableJointMotion Locked
public ConfigurableJointMotion Limited
public ConfigurableJointMotion Free
}
public UnityEngine.ConstantForce : Behaviour {
public Vector3 force
public Vector3 relativeForce
public Vector3 torque
public Vector3 relativeTorque
public Vector3 get_force()
public void set_force(Vector3 value)
public Vector3 get_relativeForce()
public void set_relativeForce(Vector3 value)
public Vector3 get_torque()
public void set_torque(Vector3 value)
public Vector3 get_relativeTorque()
public void set_relativeTorque(Vector3 value)
private void get_force_Injected(Vector3& ret)
private void set_force_Injected(Vector3& value)
private void get_relativeForce_Injected(Vector3& ret)
private void set_relativeForce_Injected(Vector3& value)
private void get_torque_Injected(Vector3& ret)
private void set_torque_Injected(Vector3& value)
private void get_relativeTorque_Injected(Vector3& ret)
private void set_relativeTorque_Injected(Vector3& value)
}
public UnityEngine.ContactPoint : ValueType {
internal Vector3 m_Point
internal Vector3 m_Normal
internal int m_ThisColliderInstanceID
internal int m_OtherColliderInstanceID
internal float m_Separation
public Vector3 point
public Vector3 normal
public Collider thisCollider
public Collider otherCollider
public float separation
public Vector3 get_point()
public Vector3 get_normal()
public Collider get_thisCollider()
public Collider get_otherCollider()
public float get_separation()
private Collider GetColliderByInstanceID(int instanceID)
}
public UnityEngine.ControllerColliderHit : object {
internal CharacterController m_Controller
internal Collider m_Collider
internal Vector3 m_Point
internal Vector3 m_Normal
internal Vector3 m_MoveDirection
internal float m_MoveLength
internal int m_Push
public CharacterController controller
public Collider collider
public Rigidbody rigidbody
public GameObject gameObject
public Transform transform
public Vector3 point
public Vector3 normal
public Vector3 moveDirection
public float moveLength
private bool push
public CharacterController get_controller()
public Collider get_collider()
public Rigidbody get_rigidbody()
public GameObject get_gameObject()
public Transform get_transform()
public Vector3 get_point()
public Vector3 get_normal()
public Vector3 get_moveDirection()
public float get_moveLength()
private bool get_push()
private void set_push(bool value)
}
public UnityEngine.ForceMode : Enum {
public int value__
public ForceMode Force
public ForceMode Acceleration
public ForceMode Impulse
public ForceMode VelocityChange
}
public UnityEngine.HingeJoint : Joint {
public JointMotor motor
public JointLimits limits
public JointSpring spring
public bool useMotor
public bool useLimits
public bool useSpring
public float velocity
public float angle
public JointMotor get_motor()
public void set_motor(JointMotor value)
public JointLimits get_limits()
public void set_limits(JointLimits value)
public JointSpring get_spring()
public void set_spring(JointSpring value)
public bool get_useMotor()
public void set_useMotor(bool value)
public bool get_useLimits()
public void set_useLimits(bool value)
public bool get_useSpring()
public void set_useSpring(bool value)
public float get_velocity()
public float get_angle()
private void get_motor_Injected(JointMotor& ret)
private void set_motor_Injected(JointMotor& value)
private void get_limits_Injected(JointLimits& ret)
private void set_limits_Injected(JointLimits& value)
private void get_spring_Injected(JointSpring& ret)
private void set_spring_Injected(JointSpring& value)
}
public UnityEngine.Joint : Component {
public Rigidbody connectedBody
public Vector3 axis
public Vector3 anchor
public Vector3 connectedAnchor
public bool autoConfigureConnectedAnchor
public float breakForce
public float breakTorque
public bool enableCollision
public bool enablePreprocessing
public float massScale
public float connectedMassScale
public Vector3 currentForce
public Vector3 currentTorque
public Rigidbody get_connectedBody()
public void set_connectedBody(Rigidbody value)
public Vector3 get_axis()
public void set_axis(Vector3 value)
public Vector3 get_anchor()
public void set_anchor(Vector3 value)
public Vector3 get_connectedAnchor()
public void set_connectedAnchor(Vector3 value)
public bool get_autoConfigureConnectedAnchor()
public void set_autoConfigureConnectedAnchor(bool value)
public float get_breakForce()
public void set_breakForce(float value)
public float get_breakTorque()
public void set_breakTorque(float value)
public bool get_enableCollision()
public void set_enableCollision(bool value)
public bool get_enablePreprocessing()
public void set_enablePreprocessing(bool value)
public float get_massScale()
public void set_massScale(float value)
public float get_connectedMassScale()
public void set_connectedMassScale(float value)
private void GetCurrentForces(Vector3& linearForce, Vector3& angularForce)
public Vector3 get_currentForce()
public Vector3 get_currentTorque()
private void get_axis_Injected(Vector3& ret)
private void set_axis_Injected(Vector3& value)
private void get_anchor_Injected(Vector3& ret)
private void set_anchor_Injected(Vector3& value)
private void get_connectedAnchor_Injected(Vector3& ret)
private void set_connectedAnchor_Injected(Vector3& value)
}
public UnityEngine.JointDrive : ValueType {
private float m_PositionSpring
private float m_PositionDamper
private float m_MaximumForce
public JointDriveMode mode
public float positionSpring
public float positionDamper
public float maximumForce
public JointDriveMode get_mode()
public void set_mode(JointDriveMode value)
public float get_positionSpring()
public void set_positionSpring(float value)
public float get_positionDamper()
public void set_positionDamper(float value)
public float get_maximumForce()
public void set_maximumForce(float value)
}
public UnityEngine.JointDriveMode : Enum {
public int value__
public JointDriveMode None
public JointDriveMode Position
public JointDriveMode Velocity
public JointDriveMode PositionAndVelocity
}
public UnityEngine.JointLimits : ValueType {
private float m_Min
private float m_Max
private float m_Bounciness
private float m_BounceMinVelocity
private float m_ContactDistance
public float minBounce
public float maxBounce
public float min
public float max
public float bounciness
public float bounceMinVelocity
public float contactDistance
public float get_min()
public void set_min(float value)
public float get_max()
public void set_max(float value)
public float get_bounciness()
public void set_bounciness(float value)
public float get_bounceMinVelocity()
public void set_bounceMinVelocity(float value)
public float get_contactDistance()
public void set_contactDistance(float value)
}
public UnityEngine.JointMotor : ValueType {
private float m_TargetVelocity
private float m_Force
private int m_FreeSpin
public float targetVelocity
public float force
public bool freeSpin
public float get_targetVelocity()
public void set_targetVelocity(float value)
public float get_force()
public void set_force(float value)
public bool get_freeSpin()
public void set_freeSpin(bool value)
}
public UnityEngine.JointProjectionMode : Enum {
public int value__
public JointProjectionMode None
public JointProjectionMode PositionAndRotation
public JointProjectionMode PositionOnly
}
public UnityEngine.JointSpring : ValueType {
public float spring
public float damper
public float targetPosition
}
public UnityEngine.MeshCollider : Collider {
public Mesh sharedMesh
public bool convex
public bool inflateMesh
public MeshColliderCookingOptions cookingOptions
public float skinWidth
public bool smoothSphereCollisions
public Mesh get_sharedMesh()
public void set_sharedMesh(Mesh value)
public bool get_convex()
public void set_convex(bool value)
public bool get_inflateMesh()
public void set_inflateMesh(bool value)
public MeshColliderCookingOptions get_cookingOptions()
public void set_cookingOptions(MeshColliderCookingOptions value)
public float get_skinWidth()
public void set_skinWidth(float value)
public bool get_smoothSphereCollisions()
public void set_smoothSphereCollisions(bool value)
}
public UnityEngine.MeshColliderCookingOptions : Enum {
public int value__
public MeshColliderCookingOptions None
public MeshColliderCookingOptions InflateConvexMesh
public MeshColliderCookingOptions CookForFasterSimulation
public MeshColliderCookingOptions EnableMeshCleaning
public MeshColliderCookingOptions WeldColocatedVertices
}
public UnityEngine.PhysicMaterial : Object {
public float bounciness
public float dynamicFriction
public float staticFriction
public PhysicMaterialCombine frictionCombine
public PhysicMaterialCombine bounceCombine
public float bouncyness
public Vector3 frictionDirection2
public float dynamicFriction2
public float staticFriction2
public Vector3 frictionDirection
public void .ctor(string name)
private void Internal_CreateDynamicsMaterial(PhysicMaterial mat, string name)
public float get_bounciness()
public void set_bounciness(float value)
public float get_dynamicFriction()
public void set_dynamicFriction(float value)
public float get_staticFriction()
public void set_staticFriction(float value)
public PhysicMaterialCombine get_frictionCombine()
public void set_frictionCombine(PhysicMaterialCombine value)
public PhysicMaterialCombine get_bounceCombine()
public void set_bounceCombine(PhysicMaterialCombine value)
public float get_bouncyness()
public void set_bouncyness(float value)
public Vector3 get_frictionDirection2()
public void set_frictionDirection2(Vector3 value)
public float get_dynamicFriction2()
public void set_dynamicFriction2(float value)
public float get_staticFriction2()
public void set_staticFriction2(float value)
public Vector3 get_frictionDirection()
public void set_frictionDirection(Vector3 value)
}
public UnityEngine.PhysicMaterialCombine : Enum {
public int value__
public PhysicMaterialCombine Average
public PhysicMaterialCombine Minimum
public PhysicMaterialCombine Multiply
public PhysicMaterialCombine Maximum
}
public UnityEngine.Physics : object {
internal float k_MaxFloatMinusEpsilon
public int IgnoreRaycastLayer
public int DefaultRaycastLayers
public int AllLayers
public int kIgnoreRaycastLayer
public int kDefaultRaycastLayers
public int kAllLayers
public float minPenetrationForPenalty
public Vector3 gravity
public float defaultContactOffset
public float sleepThreshold
public bool queriesHitTriggers
public bool queriesHitBackfaces
public float bounceThreshold
public int defaultSolverIterations
public int defaultSolverVelocityIterations
public float bounceTreshold
public float sleepVelocity
public float sleepAngularVelocity
public float maxAngularVelocity
public int solverIterationCount
public int solverVelocityIterationCount
public float penetrationPenaltyForce
public PhysicsScene defaultPhysicsScene
public bool autoSimulation
public bool autoSyncTransforms
public bool reuseCollisionCallbacks
public float interCollisionDistance
public float interCollisionStiffness
public bool interCollisionSettingsToggle
public float get_minPenetrationForPenalty()
public void set_minPenetrationForPenalty(float value)
public Vector3 get_gravity()
public void set_gravity(Vector3 value)
public float get_defaultContactOffset()
public void set_defaultContactOffset(float value)
public float get_sleepThreshold()
public void set_sleepThreshold(float value)
public bool get_queriesHitTriggers()
public void set_queriesHitTriggers(bool value)
public bool get_queriesHitBackfaces()
public void set_queriesHitBackfaces(bool value)
public float get_bounceThreshold()
public void set_bounceThreshold(float value)
public int get_defaultSolverIterations()
public void set_defaultSolverIterations(int value)
public int get_defaultSolverVelocityIterations()
public void set_defaultSolverVelocityIterations(int value)
public float get_bounceTreshold()
public void set_bounceTreshold(float value)
public float get_sleepVelocity()
public void set_sleepVelocity(float value)
public float get_sleepAngularVelocity()
public void set_sleepAngularVelocity(float value)
public float get_maxAngularVelocity()
public void set_maxAngularVelocity(float value)
public int get_solverIterationCount()
public void set_solverIterationCount(int value)
public int get_solverVelocityIterationCount()
public void set_solverVelocityIterationCount(int value)
public float get_penetrationPenaltyForce()
public void set_penetrationPenaltyForce(float value)
public PhysicsScene get_defaultPhysicsScene()
public void IgnoreCollision(Collider collider1, Collider collider2, bool ignore)
public void IgnoreCollision(Collider collider1, Collider collider2)
public void IgnoreLayerCollision(int layer1, int layer2, bool ignore)
public void IgnoreLayerCollision(int layer1, int layer2)
public bool GetIgnoreLayerCollision(int layer1, int layer2)
public bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, int layerMask)
public bool Raycast(Vector3 origin, Vector3 direction, float maxDistance)
public bool Raycast(Vector3 origin, Vector3 direction)
public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance)
public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo)
public bool Raycast(Ray ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Raycast(Ray ray, float maxDistance, int layerMask)
public bool Raycast(Ray ray, float maxDistance)
public bool Raycast(Ray ray)
public bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool Raycast(Ray ray, RaycastHit& hitInfo, float maxDistance)
public bool Raycast(Ray ray, RaycastHit& hitInfo)
public bool Linecast(Vector3 start, Vector3 end, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Linecast(Vector3 start, Vector3 end, int layerMask)
public bool Linecast(Vector3 start, Vector3 end)
public bool Linecast(Vector3 start, Vector3 end, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Linecast(Vector3 start, Vector3 end, RaycastHit& hitInfo, int layerMask)
public bool Linecast(Vector3 start, Vector3 end, RaycastHit& hitInfo)
private bool Query_CapsuleCast(PhysicsScene physicsScene, Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool Internal_CapsuleCast(PhysicsScene physicsScene, Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance)
public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit& hitInfo)
private bool Query_SphereCast(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, float maxDistance, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool Internal_SphereCast(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo, float maxDistance)
public bool SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit& hitInfo)
public bool SphereCast(Ray ray, float radius, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool SphereCast(Ray ray, float radius, float maxDistance, int layerMask)
public bool SphereCast(Ray ray, float radius, float maxDistance)
public bool SphereCast(Ray ray, float radius)
public bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask)
public bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance)
public bool SphereCast(Ray ray, float radius, RaycastHit& hitInfo)
private bool Query_BoxCast(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, RaycastHit& outHit, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool Internal_BoxCast(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Quaternion orientation, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance, int layerMask)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation, float maxDistance)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo, Quaternion orientation)
public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit& hitInfo)
private RaycastHit[] Internal_RaycastAll(PhysicsScene physicsScene, Ray ray, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance, int layerMask)
public RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance)
public RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction)
public RaycastHit[] RaycastAll(Ray ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] RaycastAll(Ray ray, float maxDistance, int layerMask)
public RaycastHit[] RaycastAll(Ray ray, float maxDistance)
public RaycastHit[] RaycastAll(Ray ray)
public int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance, int layerMask)
public int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance)
public int RaycastNonAlloc(Ray ray, RaycastHit[] results)
public int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask)
public int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance)
public int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results)
private RaycastHit[] Query_CapsuleCastAll(PhysicsScene physicsScene, Vector3 p0, Vector3 p1, float radius, Vector3 direction, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask)
public RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance)
public RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction)
private RaycastHit[] Query_SphereCastAll(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance, int layerMask)
public RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance)
public RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction)
public RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance, int layerMask)
public RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance)
public RaycastHit[] SphereCastAll(Ray ray, float radius)
private Collider[] OverlapCapsule_Internal(PhysicsScene physicsScene, Vector3 point0, Vector3 point1, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, int layerMask)
public Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius)
private Collider[] OverlapSphere_Internal(PhysicsScene physicsScene, Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapSphere(Vector3 position, float radius, int layerMask)
public Collider[] OverlapSphere(Vector3 position, float radius)
internal void Simulate_Internal(PhysicsScene physicsScene, float step)
public void Simulate(float step)
public bool get_autoSimulation()
public void set_autoSimulation(bool value)
public void SyncTransforms()
public bool get_autoSyncTransforms()
public void set_autoSyncTransforms(bool value)
public bool get_reuseCollisionCallbacks()
public void set_reuseCollisionCallbacks(bool value)
private bool Query_ComputePenetration(Collider colliderA, Vector3 positionA, Quaternion rotationA, Collider colliderB, Vector3 positionB, Quaternion rotationB, Vector3& direction, Single& distance)
public bool ComputePenetration(Collider colliderA, Vector3 positionA, Quaternion rotationA, Collider colliderB, Vector3 positionB, Quaternion rotationB, Vector3& direction, Single& distance)
private Vector3 Query_ClosestPoint(Collider collider, Vector3 position, Quaternion rotation, Vector3 point)
public Vector3 ClosestPoint(Vector3 point, Collider collider, Vector3 position, Quaternion rotation)
public float get_interCollisionDistance()
public void set_interCollisionDistance(float value)
public float get_interCollisionStiffness()
public void set_interCollisionStiffness(float value)
public bool get_interCollisionSettingsToggle()
public void set_interCollisionSettingsToggle(bool value)
private int OverlapSphereNonAlloc_Internal(PhysicsScene physicsScene, Vector3 position, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results, int layerMask)
public int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results)
private bool CheckSphere_Internal(PhysicsScene physicsScene, Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckSphere(Vector3 position, float radius, int layerMask)
public bool CheckSphere(Vector3 position, float radius)
private int Internal_CapsuleCastNonAlloc(PhysicsScene physicsScene, Vector3 p0, Vector3 p1, float radius, Vector3 direction, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
public int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask)
public int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance)
public int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results)
private int Internal_SphereCastNonAlloc(PhysicsScene physicsScene, Vector3 origin, float radius, Vector3 direction, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
public int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask)
public int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance)
public int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results)
public int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance, int layerMask)
public int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance)
public int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results)
private bool CheckCapsule_Internal(PhysicsScene physicsScene, Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius)
private bool CheckBox_Internal(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Quaternion orientation, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layermask, QueryTriggerInteraction queryTriggerInteraction)
public bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask)
public bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation)
public bool CheckBox(Vector3 center, Vector3 halfExtents)
private Collider[] OverlapBox_Internal(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask)
public Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation)
public Collider[] OverlapBox(Vector3 center, Vector3 halfExtents)
private int OverlapBoxNonAlloc_Internal(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int mask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int mask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int mask)
public int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation)
public int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results)
private int Internal_BoxCastNonAlloc(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] raycastHits, Quaternion orientation, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance, int layerMask)
public int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results)
private RaycastHit[] Internal_BoxCastAll(PhysicsScene physicsScene, Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation)
public RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction)
private int OverlapCapsuleNonAlloc_Internal(PhysicsScene physicsScene, Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask)
public int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results)
private void Internal_RebuildBroadphaseRegions(Bounds bounds, int subdivisions)
public void RebuildBroadphaseRegions(Bounds worldBounds, int subdivisions)
private void get_gravity_Injected(Vector3& ret)
private void set_gravity_Injected(Vector3& value)
private void get_defaultPhysicsScene_Injected(PhysicsScene& ret)
private bool Query_CapsuleCast_Injected(PhysicsScene& physicsScene, Vector3& point1, Vector3& point2, float radius, Vector3& direction, float maxDistance, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool Query_SphereCast_Injected(PhysicsScene& physicsScene, Vector3& origin, float radius, Vector3& direction, float maxDistance, RaycastHit& hitInfo, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool Query_BoxCast_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Vector3& direction, Quaternion& orientation, float maxDistance, RaycastHit& outHit, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private RaycastHit[] Internal_RaycastAll_Injected(PhysicsScene& physicsScene, Ray& ray, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
private RaycastHit[] Query_CapsuleCastAll_Injected(PhysicsScene& physicsScene, Vector3& p0, Vector3& p1, float radius, Vector3& direction, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
private RaycastHit[] Query_SphereCastAll_Injected(PhysicsScene& physicsScene, Vector3& origin, float radius, Vector3& direction, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
private Collider[] OverlapCapsule_Internal_Injected(PhysicsScene& physicsScene, Vector3& point0, Vector3& point1, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private Collider[] OverlapSphere_Internal_Injected(PhysicsScene& physicsScene, Vector3& position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private void Simulate_Internal_Injected(PhysicsScene& physicsScene, float step)
private bool Query_ComputePenetration_Injected(Collider colliderA, Vector3& positionA, Quaternion& rotationA, Collider colliderB, Vector3& positionB, Quaternion& rotationB, Vector3& direction, Single& distance)
private void Query_ClosestPoint_Injected(Collider collider, Vector3& position, Quaternion& rotation, Vector3& point, Vector3& ret)
private int OverlapSphereNonAlloc_Internal_Injected(PhysicsScene& physicsScene, Vector3& position, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool CheckSphere_Internal_Injected(PhysicsScene& physicsScene, Vector3& position, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private int Internal_CapsuleCastNonAlloc_Injected(PhysicsScene& physicsScene, Vector3& p0, Vector3& p1, float radius, Vector3& direction, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
private int Internal_SphereCastNonAlloc_Injected(PhysicsScene& physicsScene, Vector3& origin, float radius, Vector3& direction, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
private bool CheckCapsule_Internal_Injected(PhysicsScene& physicsScene, Vector3& start, Vector3& end, float radius, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool CheckBox_Internal_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Quaternion& orientation, int layermask, QueryTriggerInteraction queryTriggerInteraction)
private Collider[] OverlapBox_Internal_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Quaternion& orientation, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private int OverlapBoxNonAlloc_Internal_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Collider[] results, Quaternion& orientation, int mask, QueryTriggerInteraction queryTriggerInteraction)
private int Internal_BoxCastNonAlloc_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Vector3& direction, RaycastHit[] raycastHits, Quaternion& orientation, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
private RaycastHit[] Internal_BoxCastAll_Injected(PhysicsScene& physicsScene, Vector3& center, Vector3& halfExtents, Vector3& direction, Quaternion& orientation, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private int OverlapCapsuleNonAlloc_Internal_Injected(PhysicsScene& physicsScene, Vector3& point0, Vector3& point1, float radius, Collider[] results, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private void Internal_RebuildBroadphaseRegions_Injected(Bounds& bounds, int subdivisions)
}
public UnityEngine.PhysicsScene : ValueType {
private int m_Handle
public string ToString()
public bool op_Equality(PhysicsScene lhs, PhysicsScene rhs)
public bool op_Inequality(PhysicsScene lhs, PhysicsScene rhs)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(PhysicsScene other)
public bool IsValid()
private bool IsValid_Internal(PhysicsScene physicsScene)
public bool IsEmpty()
private bool IsEmpty_Internal(PhysicsScene physicsScene)
public void Simulate(float step)
public bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool Internal_RaycastTest(PhysicsScene physicsScene, Ray ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public bool Raycast(Vector3 origin, Vector3 direction, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool Internal_Raycast(PhysicsScene physicsScene, Ray ray, float maxDistance, RaycastHit& hit, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
public int Raycast(Vector3 origin, Vector3 direction, RaycastHit[] raycastHits, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private int Internal_RaycastNonAlloc(PhysicsScene physicsScene, Ray ray, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
private bool IsValid_Internal_Injected(PhysicsScene& physicsScene)
private bool IsEmpty_Internal_Injected(PhysicsScene& physicsScene)
private bool Internal_RaycastTest_Injected(PhysicsScene& physicsScene, Ray& ray, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private bool Internal_Raycast_Injected(PhysicsScene& physicsScene, Ray& ray, float maxDistance, RaycastHit& hit, int layerMask, QueryTriggerInteraction queryTriggerInteraction)
private int Internal_RaycastNonAlloc_Injected(PhysicsScene& physicsScene, Ray& ray, RaycastHit[] raycastHits, float maxDistance, int mask, QueryTriggerInteraction queryTriggerInteraction)
}
public UnityEngine.PhysicsSceneExtensions : object {
public PhysicsScene GetPhysicsScene(Scene scene)
private PhysicsScene GetPhysicsScene_Internal(Scene scene)
private void GetPhysicsScene_Internal_Injected(Scene& scene, PhysicsScene& ret)
}
public UnityEngine.QueryTriggerInteraction : Enum {
public int value__
public QueryTriggerInteraction UseGlobal
public QueryTriggerInteraction Ignore
public QueryTriggerInteraction Collide
}
public UnityEngine.RaycastCommand : ValueType {
private Vector3 <from>k__BackingField
private Vector3 <direction>k__BackingField
private float <distance>k__BackingField
private int <layerMask>k__BackingField
private int <maxHits>k__BackingField
public Vector3 from
public Vector3 direction
public float distance
public int layerMask
public int maxHits
public void .ctor(Vector3 from, Vector3 direction, float distance, int layerMask, int maxHits)
public Vector3 get_from()
public void set_from(Vector3 value)
public Vector3 get_direction()
public void set_direction(Vector3 value)
public float get_distance()
public void set_distance(float value)
public int get_layerMask()
public void set_layerMask(int value)
public int get_maxHits()
public void set_maxHits(int value)
public JobHandle ScheduleBatch(NativeArray`1<RaycastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn)
private JobHandle ScheduleRaycastBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob)
private void ScheduleRaycastBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, JobHandle& ret)
}
public UnityEngine.RaycastHit : ValueType {
internal Vector3 m_Point
internal Vector3 m_Normal
internal UInt32 m_FaceID
internal float m_Distance
internal Vector2 m_UV
internal int m_Collider
public Collider collider
public Vector3 point
public Vector3 normal
public Vector3 barycentricCoordinate
public float distance
public int triangleIndex
public Vector2 textureCoord
public Vector2 textureCoord2
public Vector2 textureCoord1
public Transform transform
public Rigidbody rigidbody
public Vector2 lightmapCoord
public Collider get_collider()
public Vector3 get_point()
public void set_point(Vector3 value)
public Vector3 get_normal()
public void set_normal(Vector3 value)
public Vector3 get_barycentricCoordinate()
public void set_barycentricCoordinate(Vector3 value)
public float get_distance()
public void set_distance(float value)
public int get_triangleIndex()
private Vector2 CalculateRaycastTexCoord(Collider collider, Vector2 uv, Vector3 pos, UInt32 face, int textcoord)
public Vector2 get_textureCoord()
public Vector2 get_textureCoord2()
public Vector2 get_textureCoord1()
public Transform get_transform()
public Rigidbody get_rigidbody()
public Vector2 get_lightmapCoord()
private void CalculateRaycastTexCoord_Injected(Collider collider, Vector2& uv, Vector3& pos, UInt32 face, int textcoord, Vector2& ret)
}
public UnityEngine.Rigidbody : Component {
public Vector3 velocity
public Vector3 angularVelocity
public float drag
public float angularDrag
public float mass
public bool useGravity
public float maxDepenetrationVelocity
public bool isKinematic
public bool freezeRotation
public RigidbodyConstraints constraints
public CollisionDetectionMode collisionDetectionMode
public Vector3 centerOfMass
public Vector3 worldCenterOfMass
public Quaternion inertiaTensorRotation
public Vector3 inertiaTensor
public bool detectCollisions
public Vector3 position
public Quaternion rotation
public RigidbodyInterpolation interpolation
public int solverIterations
public float sleepThreshold
public float maxAngularVelocity
public int solverVelocityIterations
public float sleepVelocity
public float sleepAngularVelocity
public bool useConeFriction
public int solverIterationCount
public int solverVelocityIterationCount
public Vector3 get_velocity()
public void set_velocity(Vector3 value)
public Vector3 get_angularVelocity()
public void set_angularVelocity(Vector3 value)
public float get_drag()
public void set_drag(float value)
public float get_angularDrag()
public void set_angularDrag(float value)
public float get_mass()
public void set_mass(float value)
public void SetDensity(float density)
public bool get_useGravity()
public void set_useGravity(bool value)
public float get_maxDepenetrationVelocity()
public void set_maxDepenetrationVelocity(float value)
public bool get_isKinematic()
public void set_isKinematic(bool value)
public bool get_freezeRotation()
public void set_freezeRotation(bool value)
public RigidbodyConstraints get_constraints()
public void set_constraints(RigidbodyConstraints value)
public CollisionDetectionMode get_collisionDetectionMode()
public void set_collisionDetectionMode(CollisionDetectionMode value)
public Vector3 get_centerOfMass()
public void set_centerOfMass(Vector3 value)
public Vector3 get_worldCenterOfMass()
public Quaternion get_inertiaTensorRotation()
public void set_inertiaTensorRotation(Quaternion value)
public Vector3 get_inertiaTensor()
public void set_inertiaTensor(Vector3 value)
public bool get_detectCollisions()
public void set_detectCollisions(bool value)
public Vector3 get_position()
public void set_position(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public RigidbodyInterpolation get_interpolation()
public void set_interpolation(RigidbodyInterpolation value)
public int get_solverIterations()
public void set_solverIterations(int value)
public float get_sleepThreshold()
public void set_sleepThreshold(float value)
public float get_maxAngularVelocity()
public void set_maxAngularVelocity(float value)
public void MovePosition(Vector3 position)
public void MoveRotation(Quaternion rot)
public void Sleep()
public bool IsSleeping()
public void WakeUp()
public void ResetCenterOfMass()
public void ResetInertiaTensor()
public Vector3 GetRelativePointVelocity(Vector3 relativePoint)
public Vector3 GetPointVelocity(Vector3 worldPoint)
public int get_solverVelocityIterations()
public void set_solverVelocityIterations(int value)
public float get_sleepVelocity()
public void set_sleepVelocity(float value)
public float get_sleepAngularVelocity()
public void set_sleepAngularVelocity(float value)
public void SetMaxAngularVelocity(float a)
public bool get_useConeFriction()
public void set_useConeFriction(bool value)
public int get_solverIterationCount()
public void set_solverIterationCount(int value)
public int get_solverVelocityIterationCount()
public void set_solverVelocityIterationCount(int value)
public void AddForce(Vector3 force, ForceMode mode)
public void AddForce(Vector3 force)
public void AddForce(float x, float y, float z, ForceMode mode)
public void AddForce(float x, float y, float z)
public void AddRelativeForce(Vector3 force, ForceMode mode)
public void AddRelativeForce(Vector3 force)
public void AddRelativeForce(float x, float y, float z, ForceMode mode)
public void AddRelativeForce(float x, float y, float z)
public void AddTorque(Vector3 torque, ForceMode mode)
public void AddTorque(Vector3 torque)
public void AddTorque(float x, float y, float z, ForceMode mode)
public void AddTorque(float x, float y, float z)
public void AddRelativeTorque(Vector3 torque, ForceMode mode)
public void AddRelativeTorque(Vector3 torque)
public void AddRelativeTorque(float x, float y, float z, ForceMode mode)
public void AddRelativeTorque(float x, float y, float z)
public void AddForceAtPosition(Vector3 force, Vector3 position, ForceMode mode)
public void AddForceAtPosition(Vector3 force, Vector3 position)
public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier, ForceMode mode)
public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier)
public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius)
private void Internal_ClosestPointOnBounds(Vector3 point, Vector3& outPos, Single& distance)
public Vector3 ClosestPointOnBounds(Vector3 position)
private RaycastHit SweepTest(Vector3 direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction, Boolean& hasHit)
public bool SweepTest(Vector3 direction, RaycastHit& hitInfo, float maxDistance, QueryTriggerInteraction queryTriggerInteraction)
public bool SweepTest(Vector3 direction, RaycastHit& hitInfo, float maxDistance)
public bool SweepTest(Vector3 direction, RaycastHit& hitInfo)
private RaycastHit[] Internal_SweepTestAll(Vector3 direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] SweepTestAll(Vector3 direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction)
public RaycastHit[] SweepTestAll(Vector3 direction, float maxDistance)
public RaycastHit[] SweepTestAll(Vector3 direction)
private void get_velocity_Injected(Vector3& ret)
private void set_velocity_Injected(Vector3& value)
private void get_angularVelocity_Injected(Vector3& ret)
private void set_angularVelocity_Injected(Vector3& value)
private void get_centerOfMass_Injected(Vector3& ret)
private void set_centerOfMass_Injected(Vector3& value)
private void get_worldCenterOfMass_Injected(Vector3& ret)
private void get_inertiaTensorRotation_Injected(Quaternion& ret)
private void set_inertiaTensorRotation_Injected(Quaternion& value)
private void get_inertiaTensor_Injected(Vector3& ret)
private void set_inertiaTensor_Injected(Vector3& value)
private void get_position_Injected(Vector3& ret)
private void set_position_Injected(Vector3& value)
private void get_rotation_Injected(Quaternion& ret)
private void set_rotation_Injected(Quaternion& value)
private void MovePosition_Injected(Vector3& position)
private void MoveRotation_Injected(Quaternion& rot)
private void GetRelativePointVelocity_Injected(Vector3& relativePoint, Vector3& ret)
private void GetPointVelocity_Injected(Vector3& worldPoint, Vector3& ret)
private void AddForce_Injected(Vector3& force, ForceMode mode)
private void AddRelativeForce_Injected(Vector3& force, ForceMode mode)
private void AddTorque_Injected(Vector3& torque, ForceMode mode)
private void AddRelativeTorque_Injected(Vector3& torque, ForceMode mode)
private void AddForceAtPosition_Injected(Vector3& force, Vector3& position, ForceMode mode)
private void AddExplosionForce_Injected(float explosionForce, Vector3& explosionPosition, float explosionRadius, float upwardsModifier, ForceMode mode)
private void Internal_ClosestPointOnBounds_Injected(Vector3& point, Vector3& outPos, Single& distance)
private void SweepTest_Injected(Vector3& direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction, Boolean& hasHit, RaycastHit& ret)
private RaycastHit[] Internal_SweepTestAll_Injected(Vector3& direction, float maxDistance, QueryTriggerInteraction queryTriggerInteraction)
}
public UnityEngine.RigidbodyConstraints : Enum {
public int value__
public RigidbodyConstraints None
public RigidbodyConstraints FreezePositionX
public RigidbodyConstraints FreezePositionY
public RigidbodyConstraints FreezePositionZ
public RigidbodyConstraints FreezeRotationX
public RigidbodyConstraints FreezeRotationY
public RigidbodyConstraints FreezeRotationZ
public RigidbodyConstraints FreezePosition
public RigidbodyConstraints FreezeRotation
public RigidbodyConstraints FreezeAll
}
public UnityEngine.RigidbodyInterpolation : Enum {
public int value__
public RigidbodyInterpolation None
public RigidbodyInterpolation Interpolate
public RigidbodyInterpolation Extrapolate
}
public UnityEngine.RotationDriveMode : Enum {
public int value__
public RotationDriveMode XYAndZ
public RotationDriveMode Slerp
}
public UnityEngine.SoftJointLimit : ValueType {
private float m_Limit
private float m_Bounciness
private float m_ContactDistance
public float limit
public float spring
public float damper
public float bounciness
public float contactDistance
public float bouncyness
public float get_limit()
public void set_limit(float value)
public float get_spring()
public void set_spring(float value)
public float get_damper()
public void set_damper(float value)
public float get_bounciness()
public void set_bounciness(float value)
public float get_contactDistance()
public void set_contactDistance(float value)
public float get_bouncyness()
public void set_bouncyness(float value)
}
public UnityEngine.SoftJointLimitSpring : ValueType {
private float m_Spring
private float m_Damper
public float spring
public float damper
public float get_spring()
public void set_spring(float value)
public float get_damper()
public void set_damper(float value)
}
public UnityEngine.SpherecastCommand : ValueType {
private Vector3 <origin>k__BackingField
private float <radius>k__BackingField
private Vector3 <direction>k__BackingField
private float <distance>k__BackingField
private int <layerMask>k__BackingField
private int <maxHits>k__BackingField
public Vector3 origin
public float radius
public Vector3 direction
public float distance
public int layerMask
internal int maxHits
public void .ctor(Vector3 origin, float radius, Vector3 direction, float distance, int layerMask)
public Vector3 get_origin()
public void set_origin(Vector3 value)
public float get_radius()
public void set_radius(float value)
public Vector3 get_direction()
public void set_direction(Vector3 value)
public float get_distance()
public void set_distance(float value)
public int get_layerMask()
public void set_layerMask(int value)
internal int get_maxHits()
internal void set_maxHits(int value)
public JobHandle ScheduleBatch(NativeArray`1<SpherecastCommand> commands, NativeArray`1<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn)
private JobHandle ScheduleSpherecastBatch(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob)
private void ScheduleSpherecastBatch_Injected(JobScheduleParameters& parameters, Void* commands, int commandLen, Void* result, int resultLen, int minCommandsPerJob, JobHandle& ret)
}
public UnityEngine.SphereCollider : Collider {
public Vector3 center
public float radius
public Vector3 get_center()
public void set_center(Vector3 value)
public float get_radius()
public void set_radius(float value)
private void get_center_Injected(Vector3& ret)
private void set_center_Injected(Vector3& value)
}
public UnityEngine.SpringJoint : Joint {
public float spring
public float damper
public float minDistance
public float maxDistance
public float tolerance
public float get_spring()
public void set_spring(float value)
public float get_damper()
public void set_damper(float value)
public float get_minDistance()
public void set_minDistance(float value)
public float get_maxDistance()
public void set_maxDistance(float value)
public float get_tolerance()
public void set_tolerance(float value)
}
public UnityEngine.WheelFrictionCurve : ValueType {
private float m_ExtremumSlip
private float m_ExtremumValue
private float m_AsymptoteSlip
private float m_AsymptoteValue
private float m_Stiffness
public float extremumSlip
public float extremumValue
public float asymptoteSlip
public float asymptoteValue
public float stiffness
public float get_extremumSlip()
public void set_extremumSlip(float value)
public float get_extremumValue()
public void set_extremumValue(float value)
public float get_asymptoteSlip()
public void set_asymptoteSlip(float value)
public float get_asymptoteValue()
public void set_asymptoteValue(float value)
public float get_stiffness()
public void set_stiffness(float value)
}
