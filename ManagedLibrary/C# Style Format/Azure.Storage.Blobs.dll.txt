internal Autorest.CSharp.Core.GeneratorPageableHelpers : object {
private Byte[] DefaultItemPropertyName
private Byte[] DefaultNextLinkPropertyName
public AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext)
public AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext)
public Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize)
public AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize)
}
internal Azure.Core.AppContextSwitchHelper : object {
public bool GetConfigValue(string appContexSwitchName, string environmentVariableName)
}
internal Azure.Core.Argument : object {
public void AssertNotNull(T value, string name)
public void AssertNotNull(Nullable`1<T> value, string name)
public void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name)
public void AssertNotNullOrEmpty(string value, string name)
public void AssertNotNullOrWhiteSpace(string value, string name)
public void AssertNotDefault(T& value, string name)
public void AssertInRange(T value, T minimum, T maximum, string name)
public void AssertEnumDefined(Type enumType, object value, string name)
public T CheckNotNull(T value, string name)
public string CheckNotNullOrEmpty(string value, string name)
public void AssertNull(T value, string name, string message)
}
internal Azure.Core.ArrayBufferWriter`1 : object {
private T[] _buffer
private int DefaultInitialBufferSize
private int <WrittenCount>k__BackingField
public ReadOnlyMemory`1<T> WrittenMemory
public ReadOnlySpan`1<T> WrittenSpan
public int WrittenCount
public int Capacity
public int FreeCapacity
public void .ctor(int initialCapacity)
public ReadOnlyMemory`1<T> get_WrittenMemory()
public ReadOnlySpan`1<T> get_WrittenSpan()
public int get_WrittenCount()
private void set_WrittenCount(int value)
public int get_Capacity()
public int get_FreeCapacity()
public void Clear()
public void Advance(int count)
public Memory`1<T> GetMemory(int sizeHint)
public Span`1<T> GetSpan(int sizeHint)
private void CheckAndResizeBuffer(int sizeHint)
private void ThrowInvalidOperationException_AdvancedTooFar(int capacity)
}
internal Azure.Core.AsyncLockWithValue`1 : object {
private object _syncObj
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters
private bool _isLocked
private bool _hasValue
private long _index
private T _value
public bool HasValue
public bool get_HasValue()
public void .ctor(T value)
public bool TryGetValue(T& value)
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken)
private void SetValue(T value, Int64& lockIndex)
private void Reset(Int64& lockIndex)
private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter)
}
internal Azure.Core.AuthorizationChallengeParser : object {
public string GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter)
internal bool TryGetNextChallenge(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& challengeKey)
internal bool TryGetNextParameter(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& paramKey, ReadOnlySpan`1& paramValue, char separator)
}
internal Azure.Core.AzureResourceProviderNamespaceAttribute : Attribute {
private string <ResourceProviderNamespace>k__BackingField
public string ResourceProviderNamespace
public string get_ResourceProviderNamespace()
public void .ctor(string resourceProviderNamespace)
}
internal Azure.Core.AzureSasCredentialSynchronousPolicy : HttpPipelineSynchronousPolicy {
private AzureSasCredential _credential
public void .ctor(AzureSasCredential credential)
public void OnSendingRequest(HttpMessage message)
}
internal Azure.Core.CallerShouldAuditAttribute : Attribute {
private string <Reason>k__BackingField
public string Reason
public string get_Reason()
public void set_Reason(string value)
}
internal Azure.Core.CancellationHelper : object {
private string s_cancellationMessage
internal bool ShouldWrapInOperationCanceledException(Exception exception, CancellationToken cancellationToken)
internal Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken, string message)
private void ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken)
internal void ThrowIfCancellationRequested(CancellationToken cancellationToken)
}
internal Azure.Core.ChangeTrackingDictionary`2 : object {
private IDictionary`2<TKey, TValue> _innerDictionary
public bool IsUndefined
public int Count
public bool IsReadOnly
public TValue Item
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public void .ctor(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optionalDictionary)
public void .ctor(Optional`1<IDictionary`2<TKey, TValue>> optionalDictionary)
private void .ctor(IDictionary`2<TKey, TValue> dictionary)
private void .ctor(IReadOnlyDictionary`2<TKey, TValue> dictionary)
public bool get_IsUndefined()
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(KeyValuePair`2<TKey, TValue> item)
public void Clear()
public bool Contains(KeyValuePair`2<TKey, TValue> item)
public void CopyTo(KeyValuePair`2[] array, int arrayIndex)
public bool Remove(KeyValuePair`2<TKey, TValue> item)
public int get_Count()
public bool get_IsReadOnly()
public void Add(TKey key, TValue value)
public bool ContainsKey(TKey key)
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys()
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values()
public ICollection`1<TKey> get_Keys()
public ICollection`1<TValue> get_Values()
private IDictionary`2<TKey, TValue> EnsureDictionary()
internal IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__GetEmptyEnumerator|8_0()
}
internal Azure.Core.ChangeTrackingList`1 : object {
private IList`1<T> _innerList
public bool IsUndefined
public int Count
public bool IsReadOnly
public T Item
public void .ctor(Optional`1<IList`1<T>> optionalList)
public void .ctor(Optional`1<IReadOnlyList`1<T>> optionalList)
private void .ctor(IEnumerable`1<T> innerList)
private void .ctor(IList`1<T> innerList)
public bool get_IsUndefined()
public void Reset()
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
public bool Remove(T item)
public int get_Count()
public bool get_IsReadOnly()
public int IndexOf(T item)
public void Insert(int index, T item)
public void RemoveAt(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
private IList`1<T> EnsureList()
internal IEnumerator`1<T> <GetEnumerator>g__EnumerateEmpty|9_0()
}
internal Azure.Core.CodeGenClientAttribute : CodeGenTypeAttribute {
private Type <ParentClient>k__BackingField
public Type ParentClient
public Type get_ParentClient()
public void set_ParentClient(Type value)
public void .ctor(string originalName)
}
internal Azure.Core.CodeGenMemberAttribute : CodeGenTypeAttribute {
public void .ctor(string originalName)
}
internal Azure.Core.CodeGenMemberSerializationAttribute : Attribute {
private String[] <SerializationPath>k__BackingField
public String[] SerializationPath
public String[] get_SerializationPath()
public void .ctor(String[] serializationPath)
}
internal Azure.Core.CodeGenMemberSerializationHooksAttribute : Attribute {
private string <SerializationValueHook>k__BackingField
private string <DeserializationValueHook>k__BackingField
public string SerializationValueHook
public string DeserializationValueHook
public string get_SerializationValueHook()
public void set_SerializationValueHook(string value)
public string get_DeserializationValueHook()
public void set_DeserializationValueHook(string value)
}
internal Azure.Core.CodeGenModelAttribute : CodeGenTypeAttribute {
private String[] <Usage>k__BackingField
private String[] <Formats>k__BackingField
public String[] Usage
public String[] Formats
public String[] get_Usage()
public void set_Usage(String[] value)
public String[] get_Formats()
public void set_Formats(String[] value)
public void .ctor(string originalName)
}
internal Azure.Core.CodeGenOverrideServiceVersionsAttribute : Attribute {
private String[] <Versions>k__BackingField
public String[] Versions
public String[] get_Versions()
public void .ctor(String[] versions)
}
internal Azure.Core.CodeGenSuppressAttribute : Attribute {
private string <Member>k__BackingField
private Type[] <Parameters>k__BackingField
public string Member
public Type[] Parameters
public string get_Member()
public Type[] get_Parameters()
public void .ctor(string member, Type[] parameters)
}
internal Azure.Core.CodeGenSuppressTypeAttribute : Attribute {
private string <Typename>k__BackingField
public string Typename
public string get_Typename()
public void .ctor(string typename)
}
internal Azure.Core.CodeGenTypeAttribute : Attribute {
private string <OriginalName>k__BackingField
public string OriginalName
public string get_OriginalName()
public void .ctor(string originalName)
}
internal Azure.Core.FixedDelayWithNoJitterStrategy : DelayStrategy {
private TimeSpan DefaultDelay
private TimeSpan _delay
public void .ctor(Nullable`1<TimeSpan> suggestedDelay)
protected TimeSpan GetNextDelayCore(Response response, int retryNumber)
}
internal Azure.Core.FormUrlEncodedContent : RequestContent {
private List`1<KeyValuePair`2<string, string>> _values
private Encoding Latin1
private Byte[] _bytes
public void Add(string parameter, string value)
private void BuildIfNeeded()
public Task WriteToAsync(Stream stream, CancellationToken cancellation)
public void WriteTo(Stream stream, CancellationToken cancellation)
public bool TryComputeLength(Int64& length)
public void Dispose()
private Byte[] GetContentByteArray(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection)
private string Encode(string data)
}
internal Azure.Core.ForwardsClientCallsAttribute : Attribute {
private bool <SkipChecks>k__BackingField
public bool SkipChecks
public void .ctor(bool skipChecks)
public bool get_SkipChecks()
}
internal Azure.Core.HashCodeBuilder : ValueType {
private UInt32 s_seed
private UInt32 Prime1
private UInt32 Prime2
private UInt32 Prime3
private UInt32 Prime4
private UInt32 Prime5
private UInt32 _v1
private UInt32 _v2
private UInt32 _v3
private UInt32 _v4
private UInt32 _queue1
private UInt32 _queue2
private UInt32 _queue3
private UInt32 _length
private UInt32 GenerateGlobalSeed()
public int Combine(T1 value1)
public int Combine(T1 value1, T2 value2)
public int Combine(T1 value1, T2 value2, T3 value3)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7)
public int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8)
private void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4)
private UInt32 Round(UInt32 hash, UInt32 input)
private UInt32 QueueRound(UInt32 hash, UInt32 queuedValue)
private UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4)
public UInt32 RotateLeft(UInt32 value, int offset)
private UInt32 MixEmptyState()
private UInt32 MixFinal(UInt32 hash)
public void Add(T value)
public void Add(T value, IEqualityComparer`1<T> comparer)
private void Add(int value)
public int ToHashCode()
public int GetHashCode()
public bool Equals(object obj)
}
internal Azure.Core.HttpMessageSanitizer : object {
private string LogAllValue
private bool _logAllHeaders
private bool _logFullQueries
private String[] _allowedQueryParameters
private string _redactedPlaceholder
private HashSet`1<string> _allowedHeaders
internal HttpMessageSanitizer Default
public void .ctor(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder)
public string SanitizeHeader(string name, string value)
public string SanitizeUrl(string url)
}
internal Azure.Core.HttpPipelineExtensions : object {
public ValueTask`1<Response> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken)
public Response ProcessMessage(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken)
public ValueTask`1<Response`1<bool>> ProcessHeadAsBoolMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext)
public Response`1<bool> ProcessHeadAsBoolMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext)
private ValueTuple`2<CancellationToken, ErrorOptions> ApplyRequestContext(RequestContext requestContext)
}
internal Azure.Core.IOperation {
public ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.IOperation`1 {
public ValueTask`1<OperationState`1<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.IOperationSource`1 {
public T CreateResult(Response response, CancellationToken cancellationToken)
public ValueTask`1<T> CreateResultAsync(Response response, CancellationToken cancellationToken)
}
internal Azure.Core.IUtf8JsonSerializable {
public void Write(Utf8JsonWriter writer)
}
internal Azure.Core.IXmlSerializable {
public void Write(XmlWriter writer, string nameHint)
}
internal Azure.Core.JsonElementExtensions : object {
public object GetObject(JsonElement& element)
public Byte[] GetBytesFromBase64(JsonElement& element, string format)
public DateTimeOffset GetDateTimeOffset(JsonElement& element, string format)
public TimeSpan GetTimeSpan(JsonElement& element, string format)
public char GetChar(JsonElement& element)
public void ThrowNonNullablePropertyIsNull(JsonProperty property)
public string GetRequiredString(JsonElement& element)
}
internal Azure.Core.NextLinkOperationImplementation : object {
private string ApiVersionParam
private String[] FailureStates
private String[] SuccessStates
private HeaderSource _headerSource
private bool _originalResponseHasLocation
private Uri _startRequestUri
private OperationFinalStateVia _finalStateVia
private RequestMethod _requestMethod
private HttpPipeline _pipeline
private string _apiVersion
private string _lastKnownLocation
private string _nextRequestUri
public IOperation Create(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue)
public IOperation`1<T> Create(IOperationSource`1<T> operationSource, HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue)
private void .ctor(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, HeaderSource headerSource, bool originalResponseHasLocation, string lastKnownLocation, OperationFinalStateVia finalStateVia, string apiVersion)
public ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken)
private OperationState GetOperationStateFromFinalResponse(RequestMethod requestMethod, Response response)
private void UpdateNextRequestUri(ResponseHeaders headers)
internal string AppendOrReplaceApiVersion(string uri, string apiVersion)
internal bool TryGetApiVersion(Uri startRequestUri, ReadOnlySpan`1& apiVersion)
private string GetFinalUri(string resourceLocation)
private ValueTask`1<Response> GetResponseAsync(bool async, string uri, CancellationToken cancellationToken)
private HttpMessage CreateRequest(string uri)
private bool IsFinalState(Response response, HeaderSource headerSource, Nullable`1& failureState, String& resourceLocation)
private bool ShouldIgnoreHeader(RequestMethod method, Response response)
private HeaderSource GetHeaderSource(RequestMethod requestMethod, Uri requestUri, Response response, string apiVersion, String& nextRequestUri)
}
internal Azure.Core.OperationFinalStateVia : Enum {
public int value__
public OperationFinalStateVia AzureAsyncOperation
public OperationFinalStateVia Location
public OperationFinalStateVia OriginalUri
public OperationFinalStateVia OperationLocation
public OperationFinalStateVia LocationOverride
}
internal Azure.Core.OperationHelpers : object {
public T GetValue(T& value)
public T GetValue(Nullable`1& value)
public ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, CancellationToken cancellationToken)
public ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, CancellationToken cancellationToken)
public Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
public ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, CancellationToken cancellationToken)
public ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response DefaultWaitForCompletionResponse(Operation operation, CancellationToken cancellationToken)
public Response DefaultWaitForCompletionResponse(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
}
internal Azure.Core.OperationInternal : OperationInternalBase {
private OperationInternal`1<VoidValue> _internalOperation
public Response RawResponse
public bool HasCompleted
public OperationInternal Succeeded(Response rawResponse)
public OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException)
public void .ctor(IOperation operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy)
private void .ctor(OperationState finalState)
public Response get_RawResponse()
public bool get_HasCompleted()
protected ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.OperationInternal`1 : OperationInternalBase {
private IOperation`1<T> _operation
private AsyncLockWithValue`1<OperationState`1<T>> _stateLock
private Response _rawResponse
public Response RawResponse
public bool HasCompleted
public bool HasValue
public T Value
public OperationInternal`1<T> Succeeded(Response rawResponse, T value)
public OperationInternal`1<T> Failed(Response rawResponse, RequestFailedException operationFailedException)
public void .ctor(IOperation`1<T> operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy)
private void .ctor(OperationState`1<T> finalState)
public Response get_RawResponse()
public bool get_HasCompleted()
public bool get_HasValue()
public T get_Value()
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken)
private ValueTask`1<Response`1<T>> WaitForCompletionAsync(bool async, Nullable`1<TimeSpan> pollingInterval, CancellationToken cancellationToken)
protected ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
private Response GetResponseFromState(OperationState`1<T> state)
}
internal Azure.Core.OperationInternalBase : object {
private ClientDiagnostics _diagnostics
private IReadOnlyDictionary`2<string, string> _scopeAttributes
private DelayStrategy _fallbackStrategy
private AsyncLockWithValue`1<Response> _responseLock
private string _waitForCompletionResponseScopeName
protected string _updateStatusScopeName
protected string _waitForCompletionScopeName
public Response RawResponse
public bool HasCompleted
protected void .ctor(Response rawResponse)
protected void .ctor(ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy)
public Response get_RawResponse()
public bool get_HasCompleted()
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken)
public Response UpdateStatus(CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(CancellationToken cancellationToken)
public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken)
protected ValueTask`1<Response> WaitForCompletionResponseAsync(bool async, Nullable`1<TimeSpan> pollingInterval, string scopeName, CancellationToken cancellationToken)
protected ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
protected DiagnosticScope CreateScope(string scopeName)
}
internal Azure.Core.OperationPoller : object {
private DelayStrategy _delayStrategy
public void .ctor(DelayStrategy strategy)
public ValueTask`1<Response> WaitForCompletionResponseAsync(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public ValueTask`1<Response> WaitForCompletionResponseAsync(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response WaitForCompletionResponse(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
public Response`1<T> WaitForCompletion(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
private ValueTask`1<Response> WaitForCompletionAsync(bool async, Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
private ValueTask`1<Response> WaitForCompletionAsync(bool async, OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken)
private ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken)
}
internal Azure.Core.OperationState : ValueType {
private Response <RawResponse>k__BackingField
private bool <HasCompleted>k__BackingField
private bool <HasSucceeded>k__BackingField
private RequestFailedException <OperationFailedException>k__BackingField
public Response RawResponse
public bool HasCompleted
public bool HasSucceeded
public RequestFailedException OperationFailedException
private void .ctor(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException operationFailedException)
public Response get_RawResponse()
public bool get_HasCompleted()
public bool get_HasSucceeded()
public RequestFailedException get_OperationFailedException()
public OperationState Success(Response rawResponse)
public OperationState Failure(Response rawResponse, RequestFailedException operationFailedException)
public OperationState Pending(Response rawResponse)
}
internal Azure.Core.OperationState`1 : ValueType {
private Response <RawResponse>k__BackingField
private bool <HasCompleted>k__BackingField
private bool <HasSucceeded>k__BackingField
private T <Value>k__BackingField
private RequestFailedException <OperationFailedException>k__BackingField
public Response RawResponse
public bool HasCompleted
public bool HasSucceeded
public T Value
public RequestFailedException OperationFailedException
private void .ctor(Response rawResponse, bool hasCompleted, bool hasSucceeded, T value, RequestFailedException operationFailedException)
public Response get_RawResponse()
public bool get_HasCompleted()
public bool get_HasSucceeded()
public T get_Value()
public RequestFailedException get_OperationFailedException()
public OperationState`1<T> Success(Response rawResponse, T value)
public OperationState`1<T> Failure(Response rawResponse, RequestFailedException operationFailedException)
public OperationState`1<T> Pending(Response rawResponse)
}
internal Azure.Core.Optional : object {
public bool IsCollectionDefined(IEnumerable`1<T> collection)
public bool IsCollectionDefined(IReadOnlyDictionary`2<TKey, TValue> collection)
public bool IsCollectionDefined(IDictionary`2<TKey, TValue> collection)
public bool IsDefined(Nullable`1<T> value)
public bool IsDefined(object value)
public bool IsDefined(string value)
public bool IsDefined(JsonElement value)
public IReadOnlyDictionary`2<TKey, TValue> ToDictionary(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optional)
public IDictionary`2<TKey, TValue> ToDictionary(Optional`1<IDictionary`2<TKey, TValue>> optional)
public IReadOnlyList`1<T> ToList(Optional`1<IReadOnlyList`1<T>> optional)
public IList`1<T> ToList(Optional`1<IList`1<T>> optional)
public Nullable`1<T> ToNullable(Optional`1<T> optional)
public Nullable`1<T> ToNullable(Optional`1<Nullable`1<T>> optional)
}
internal Azure.Core.Optional`1 : ValueType {
private T <Value>k__BackingField
private bool <HasValue>k__BackingField
public T Value
public bool HasValue
public void .ctor(T value)
public T get_Value()
public bool get_HasValue()
public Optional`1<T> op_Implicit(T value)
public T op_Implicit(Optional`1<T> optional)
}
internal Azure.Core.Page : object {
public Page`1<T> FromValues(IEnumerable`1<T> values, string continuationToken, Response response)
}
internal Azure.Core.PageableHelpers : object {
private Byte[] DefaultItemPropertyName
private Byte[] DefaultNextLinkPropertyName
public AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext)
public AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext)
public Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken)
public ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext)
public Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize)
public AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize)
private ValueTuple`2<List`1<T>, string> ParseResponseForBinaryData(Response response, Byte[] itemPropertyName, Byte[] nextLinkPropertyName)
internal object <ParseResponseForBinaryData>g__ReadBinaryData|19_0(Utf8JsonReader& r, ReadOnlyMemory`1& content)
}
internal Azure.Core.Pipeline.ActivityExtensions : object {
private bool <SupportsActivitySource>k__BackingField
public bool SupportsActivitySource
public bool get_SupportsActivitySource()
private void set_SupportsActivitySource(bool value)
public void ResetFeatureSwitch()
}
internal Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
public void .ctor(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities)
public void .ctor(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities)
internal HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics)
internal string GetResourceProviderNamespace(Assembly assembly)
}
internal Azure.Core.Pipeline.DiagnosticScope : ValueType {
private string AzureSdkScopeLabel
internal string OpenTelemetrySchemaAttribute
internal string OpenTelemetrySchemaVersion
private object AzureSdkScopeValue
private ActivityAdapter _activityAdapter
private bool _suppressNestedClientActivities
private bool <IsEnabled>k__BackingField
public bool IsEnabled
internal void .ctor(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities)
public bool get_IsEnabled()
public void AddAttribute(string name, string value)
public void AddIntegerAttribute(string name, int value)
public void AddAttribute(string name, T value, Func`2<T, string> format)
public void AddLink(string traceparent, string tracestate, IDictionary`2<string, string> attributes)
public void Start()
public void SetDisplayName(string displayName)
public void SetStartTime(DateTime dateTime)
public void SetTraceContext(string traceparent, string tracestate)
public void Dispose()
public void Failed(Exception exception)
public void Failed(string errorCode)
}
internal Azure.Core.Pipeline.DiagnosticScopeFactory : object {
private Dictionary`2<string, DiagnosticListener> _listeners
private string _resourceProviderNamespace
private DiagnosticListener _source
private bool _suppressNestedClientActivities
private bool _isStable
private ConcurrentDictionary`2<string, ActivitySource> ActivitySources
private bool <IsActivityEnabled>k__BackingField
public bool IsActivityEnabled
public void .ctor(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable)
public bool get_IsActivityEnabled()
public DiagnosticScope CreateScope(string name, ActivityKind kind)
private ActivitySource GetActivitySource(string ns, string name)
}
internal Azure.Core.Pipeline.RetriableStream : object {
public Stream Create(Func`2<long, Stream> responseFactory, Func`2<long, ValueTask`1<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries)
public Task`1<Stream> CreateAsync(Func`2<long, Stream> responseFactory, Func`2<long, ValueTask`1<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries)
public Stream Create(Stream initialResponse, Func`2<long, Stream> streamFactory, Func`2<long, ValueTask`1<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries)
}
internal Azure.Core.Pipeline.StorageRequestFailedDetailsParser : RequestFailedDetailsParser {
public bool TryParse(Response response, ResponseError& error, IDictionary`2& data)
}
internal Azure.Core.Pipeline.TaskExtensions : object {
public WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken)
public WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken)
public WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken)
public T EnsureCompleted(Task`1<T> task)
public void EnsureCompleted(Task task)
public T EnsureCompleted(ValueTask`1<T> task)
public void EnsureCompleted(ValueTask task)
public Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable)
public ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async)
public ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async)
private void VerifyTaskCompleted(bool isCompleted)
}
internal Azure.Core.ProtocolOperation`1 : Operation`1<T> {
private Func`2<Response, T> _resultSelector
private OperationInternal`1<T> _operation
private IOperation _nextLinkOperation
public string Id
public T Value
public bool HasCompleted
public bool HasValue
internal void .ctor(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, string scopeName, Func`2<Response, T> resultSelector)
public string get_Id()
public T get_Value()
public bool get_HasCompleted()
public bool get_HasValue()
public Response GetRawResponse()
public Response UpdateStatus(CancellationToken cancellationToken)
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken)
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
private ValueTask`1<OperationState`1<T>> Azure.Core.IOperation<T>.UpdateStateAsync(bool async, CancellationToken cancellationToken)
}
internal Azure.Core.ProtocolOperationHelpers : object {
public Operation`1<TTo> Convert(Operation`1<TFrom> operation, Func`2<Response, TTo> convertFunc, ClientDiagnostics diagnostics, string scopeName)
public ValueTask`1<Operation`1<VoidValue>> ProcessMessageWithoutResponseValueAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil)
public Operation`1<VoidValue> ProcessMessageWithoutResponseValue(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil)
public ValueTask`1<Operation`1<BinaryData>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil)
public Operation`1<BinaryData> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil)
public ValueTask`1<Operation`1<T>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector)
public Operation`1<T> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector)
}
internal Azure.Core.RawRequestUriBuilder : RequestUriBuilder {
private string SchemeSeparator
private char HostSeparator
private char PortSeparator
private Char[] HostOrPort
private char QueryBeginSeparator
private char QueryContinueSeparator
private char QueryValueSeparator
private Nullable`1<RawWritingPosition> _position
private void GetQueryParts(ReadOnlySpan`1<char> queryUnparsed, ReadOnlySpan`1& name, ReadOnlySpan`1& value)
public void AppendRaw(string value, bool escape)
private void AppendRaw(ReadOnlySpan`1<char> value, bool escape)
public void AppendRawNextLink(string nextLink, bool escape)
}
internal Azure.Core.RequestContentHelper : object {
public RequestContent FromEnumerable(IEnumerable`1<T> enumerable)
public RequestContent FromEnumerable(IEnumerable`1<BinaryData> enumerable)
public RequestContent FromDictionary(IDictionary`2<string, T> dictionary)
public RequestContent FromDictionary(IDictionary`2<string, BinaryData> dictionary)
public RequestContent FromObject(object value)
public RequestContent FromObject(BinaryData value)
}
internal Azure.Core.RequestHeaderExtensions : object {
public void Add(RequestHeaders headers, string name, bool value)
public void Add(RequestHeaders headers, string name, float value)
public void Add(RequestHeaders headers, string name, double value)
public void Add(RequestHeaders headers, string name, int value)
public void Add(RequestHeaders headers, string name, long value)
public void Add(RequestHeaders headers, string name, DateTimeOffset value, string format)
public void Add(RequestHeaders headers, string name, TimeSpan value, string format)
public void Add(RequestHeaders headers, string name, Guid value)
public void Add(RequestHeaders headers, string name, Byte[] value, string format)
public void Add(RequestHeaders headers, string name, BinaryData value, string format)
public void Add(RequestHeaders headers, string prefix, IDictionary`2<string, string> headersToAdd)
public void Add(RequestHeaders headers, string name, ETag value)
public void Add(RequestHeaders headers, MatchConditions conditions)
public void Add(RequestHeaders headers, RequestConditions conditions, string format)
public void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter)
public void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter, string format)
}
internal Azure.Core.RequestUriBuilderExtensions : object {
public void AppendPath(RequestUriBuilder builder, bool value, bool escape)
public void AppendPath(RequestUriBuilder builder, float value, bool escape)
public void AppendPath(RequestUriBuilder builder, double value, bool escape)
public void AppendPath(RequestUriBuilder builder, int value, bool escape)
public void AppendPath(RequestUriBuilder builder, Byte[] value, string format, bool escape)
public void AppendPath(RequestUriBuilder builder, IEnumerable`1<string> value, bool escape)
public void AppendPath(RequestUriBuilder builder, DateTimeOffset value, string format, bool escape)
public void AppendPath(RequestUriBuilder builder, TimeSpan value, string format, bool escape)
public void AppendPath(RequestUriBuilder builder, Guid value, bool escape)
public void AppendPath(RequestUriBuilder builder, long value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, bool value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, float value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, DateTimeOffset value, string format, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, string format, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, double value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, decimal value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, int value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, long value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, Byte[] value, string format, bool escape)
public void AppendQuery(RequestUriBuilder builder, string name, Guid value, bool escape)
public void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, bool escape)
public void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, string format, bool escape)
}
internal Azure.Core.ResponseHeadersExtensions : object {
private String[] KnownFormats
public bool TryGetValue(ResponseHeaders headers, string name, Byte[]& value)
public bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value)
public bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value)
public bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value)
public bool TryGetValue(ResponseHeaders headers, string name, T& value)
public bool TryGetValue(ResponseHeaders headers, string prefix, IDictionary`2& value)
}
internal Azure.Core.ResponseWithHeaders : object {
public ResponseWithHeaders`2<T, THeaders> FromValue(T value, THeaders headers, Response rawResponse)
public ResponseWithHeaders`1<THeaders> FromValue(THeaders headers, Response rawResponse)
}
internal Azure.Core.ResponseWithHeaders`1 : object {
private Response _rawResponse
private THeaders <Headers>k__BackingField
public THeaders Headers
public void .ctor(THeaders headers, Response rawResponse)
public Response GetRawResponse()
public THeaders get_Headers()
public Response op_Implicit(ResponseWithHeaders`1<THeaders> self)
}
internal Azure.Core.ResponseWithHeaders`2 : Response`1<T> {
private Response _rawResponse
private T <Value>k__BackingField
private THeaders <Headers>k__BackingField
public T Value
public THeaders Headers
public void .ctor(T value, THeaders headers, Response rawResponse)
public Response GetRawResponse()
public T get_Value()
public THeaders get_Headers()
public Response op_Implicit(ResponseWithHeaders`2<T, THeaders> self)
}
internal Azure.Core.SequentialDelayStrategy : DelayStrategy {
private TimeSpan[] _pollingSequence
private TimeSpan _maxDelay
protected TimeSpan GetNextDelayCore(Response response, int retryNumber)
}
internal Azure.Core.StringRequestContent : RequestContent {
private Byte[] _bytes
public void .ctor(string value)
public Task WriteToAsync(Stream stream, CancellationToken cancellation)
public void WriteTo(Stream stream, CancellationToken cancellation)
public bool TryComputeLength(Int64& length)
public void Dispose()
}
internal Azure.Core.TypeFormatters : object {
private string RoundtripZFormat
private string <DefaultNumberFormat>k__BackingField
public string DefaultNumberFormat
public string get_DefaultNumberFormat()
public string ToString(bool value)
public string ToString(DateTime value, string format)
public string ToString(DateTimeOffset value, string format)
public string ToString(TimeSpan value, string format)
public string ToString(Byte[] value, string format)
public string ToBase64UrlString(Byte[] value)
public Byte[] FromBase64UrlString(string value)
private int GetNumBase64PaddingCharsToAddForDecode(int inputLength)
public DateTimeOffset ParseDateTimeOffset(string value, string format)
public TimeSpan ParseTimeSpan(string value, string format)
public string ConvertToString(object value, string format)
}
internal Azure.Core.Utf8JsonRequestContent : RequestContent {
private MemoryStream _stream
private RequestContent _content
private Utf8JsonWriter <JsonWriter>k__BackingField
public Utf8JsonWriter JsonWriter
public Utf8JsonWriter get_JsonWriter()
public Task WriteToAsync(Stream stream, CancellationToken cancellation)
public void WriteTo(Stream stream, CancellationToken cancellation)
public bool TryComputeLength(Int64& length)
public void Dispose()
}
internal Azure.Core.Utf8JsonWriterExtensions : object {
public void WriteStringValue(Utf8JsonWriter writer, DateTimeOffset value, string format)
public void WriteStringValue(Utf8JsonWriter writer, DateTime value, string format)
public void WriteStringValue(Utf8JsonWriter writer, TimeSpan value, string format)
public void WriteStringValue(Utf8JsonWriter writer, char value)
public void WriteNonEmptyArray(Utf8JsonWriter writer, string name, IReadOnlyList`1<string> values)
public void WriteBase64StringValue(Utf8JsonWriter writer, Byte[] value, string format)
public void WriteNumberValue(Utf8JsonWriter writer, DateTimeOffset value, string format)
public void WriteObjectValue(Utf8JsonWriter writer, object value)
}
internal Azure.Core.XElementExtensions : object {
public Byte[] GetBytesFromBase64Value(XElement element, string format)
public DateTimeOffset GetDateTimeOffsetValue(XElement element, string format)
public TimeSpan GetTimeSpanValue(XElement element, string format)
public object GetObjectValue(XElement element, string format)
}
internal Azure.Core.XmlWriterContent : RequestContent {
private MemoryStream _stream
private RequestContent _content
private XmlWriter <XmlWriter>k__BackingField
public XmlWriter XmlWriter
public XmlWriter get_XmlWriter()
public Task WriteToAsync(Stream stream, CancellationToken cancellation)
public void WriteTo(Stream stream, CancellationToken cancellation)
public bool TryComputeLength(Int64& length)
public void Dispose()
}
internal Azure.Core.XmlWriterExtensions : object {
public void WriteObjectValue(XmlWriter writer, object value, string nameHint)
public void WriteValue(XmlWriter writer, DateTimeOffset value, string format)
public void WriteValue(XmlWriter writer, TimeSpan value, string format)
public void WriteValue(XmlWriter writer, Byte[] value, string format)
}
internal Azure.NoBodyResponse`1 : Response`1<T> {
private Response _response
public bool HasValue
public T Value
public void .ctor(Response response)
public bool get_HasValue()
public T get_Value()
public Response GetRawResponse()
public string ToString()
}
internal Azure.Storage.AggregatingProgressIncrementer : object {
private long _currentValue
private IProgress`1<long> _innerHandler
private AggregatingProgressIncrementer <None>k__BackingField
public AggregatingProgressIncrementer None
public long Current
public Stream CreateProgressIncrementingStream(Stream stream)
public void .ctor(IProgress`1<long> innerHandler)
public void Report(long bytes)
public void Reset()
public AggregatingProgressIncrementer get_None()
public long get_Current()
}
internal Azure.Storage.Blobs.AppendBlobAppendBlockFromUrlHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public Byte[] XMsContentCrc64
public string Version
public string BlobAppendOffset
public Nullable`1<int> BlobCommittedBlockCount
public string EncryptionKeySha256
public string EncryptionScope
public Nullable`1<bool> IsServerEncrypted
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public Byte[] get_XMsContentCrc64()
public string get_Version()
public string get_BlobAppendOffset()
public Nullable`1<int> get_BlobCommittedBlockCount()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
public Nullable`1<bool> get_IsServerEncrypted()
}
internal Azure.Storage.Blobs.AppendBlobAppendBlockHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public Byte[] XMsContentCrc64
public string Version
public string BlobAppendOffset
public Nullable`1<int> BlobCommittedBlockCount
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public Byte[] get_XMsContentCrc64()
public string get_Version()
public string get_BlobAppendOffset()
public Nullable`1<int> get_BlobCommittedBlockCount()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.AppendBlobCreateHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public string Version
public string VersionId
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public string get_Version()
public string get_VersionId()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.AppendBlobRestClient : object {
private HttpPipeline _pipeline
private string _url
private string _version
private ClientDiagnostics <ClientDiagnostics>k__BackingField
internal ClientDiagnostics ClientDiagnostics
internal ClientDiagnostics get_ClientDiagnostics()
public void .ctor(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
internal HttpMessage CreateCreateRequest(long contentLength, Nullable`1<int> timeout, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold)
public Task`1<ResponseWithHeaders`1<AppendBlobCreateHeaders>> CreateAsync(long contentLength, Nullable`1<int> timeout, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken)
public ResponseWithHeaders`1<AppendBlobCreateHeaders> Create(long contentLength, Nullable`1<int> timeout, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken)
internal HttpMessage CreateAppendBlockRequest(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<AppendBlobAppendBlockHeaders>> AppendBlockAsync(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<AppendBlobAppendBlockHeaders> AppendBlock(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateAppendBlockFromUrlRequest(string sourceUrl, long contentLength, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization)
public Task`1<ResponseWithHeaders`1<AppendBlobAppendBlockFromUrlHeaders>> AppendBlockFromUrlAsync(string sourceUrl, long contentLength, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken)
public ResponseWithHeaders`1<AppendBlobAppendBlockFromUrlHeaders> AppendBlockFromUrl(string sourceUrl, long contentLength, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> maxSize, Nullable`1<long> appendPosition, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken)
internal HttpMessage CreateSealRequest(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, Nullable`1<long> appendPosition)
public Task`1<ResponseWithHeaders`1<AppendBlobSealHeaders>> SealAsync(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, Nullable`1<long> appendPosition, CancellationToken cancellationToken)
public ResponseWithHeaders`1<AppendBlobSealHeaders> Seal(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, Nullable`1<long> appendPosition, CancellationToken cancellationToken)
}
internal Azure.Storage.Blobs.AppendBlobSealHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public Nullable`1<bool> IsSealed
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
public Nullable`1<bool> get_IsSealed()
}
internal Azure.Storage.Blobs.AppendBlobWriteStream : StorageWriteStream {
private AppendBlobClient _appendBlobClient
private AppendBlobRequestConditions _conditions
public void .ctor(AppendBlobClient appendBlobClient, long bufferSize, long position, AppendBlobRequestConditions conditions, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidation)
protected Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
protected void ValidateBufferSize(long bufferSize)
}
internal Azure.Storage.Blobs.BlobAbortCopyFromURLHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.BlobAcquireLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string LeaseId
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_LeaseId()
public string get_Version()
}
internal Azure.Storage.Blobs.BlobBreakLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<int> LeaseTime
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<int> get_LeaseTime()
public string get_Version()
}
internal Azure.Storage.Blobs.BlobChangeLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string LeaseId
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_LeaseId()
public string get_Version()
}
public Azure.Storage.Blobs.BlobClient : BlobBaseClient {
private BlockBlobClient _blockBlobClient
private BlockBlobClient BlockBlobClient
public void .ctor(string connectionString, string blobContainerName, string blobName)
public void .ctor(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
public void .ctor(Uri blobUri, BlobClientOptions options)
public void .ctor(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, AzureSasCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, TokenCredential credential, BlobClientOptions options)
internal void .ctor(Uri blobUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption)
public BlobClient WithSnapshot(string snapshot)
public BlobClient WithVersion(string versionId)
public BlobClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey)
public BlobClient WithEncryptionScope(string encryptionScope)
protected internal BlobClient WithClientSideEncryptionOptionsCore(ClientSideEncryptionOptions clientSideEncryptionOptions)
public Response`1<BlobContentInfo> Upload(Stream content)
public Response`1<BlobContentInfo> Upload(BinaryData content)
public Response`1<BlobContentInfo> Upload(string path)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(BinaryData content)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(string path)
public Response`1<BlobContentInfo> Upload(Stream content, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(BinaryData content, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(string path, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(BinaryData content, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(string path, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(Stream content, bool overwrite, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(BinaryData content, bool overwrite, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(string path, bool overwrite, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, bool overwrite, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(BinaryData content, bool overwrite, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(string path, bool overwrite, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(Stream content, BlobUploadOptions options, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(BinaryData content, BlobUploadOptions options, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(Stream content, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, IProgress`1<long> progressHandler, Nullable`1<AccessTier> accessTier, StorageTransferOptions transferOptions, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(string path, BlobUploadOptions options, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(string path, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, IProgress`1<long> progressHandler, Nullable`1<AccessTier> accessTier, StorageTransferOptions transferOptions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, BlobUploadOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(BinaryData content, BlobUploadOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, IProgress`1<long> progressHandler, Nullable`1<AccessTier> accessTier, StorageTransferOptions transferOptions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(string path, BlobUploadOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(string path, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, IProgress`1<long> progressHandler, Nullable`1<AccessTier> accessTier, StorageTransferOptions transferOptions, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContentInfo>> StagedUploadInternal(Stream content, BlobUploadOptions options, bool async, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContentInfo>> StagedUploadInternal(string path, BlobUploadOptions options, bool async, CancellationToken cancellationToken)
public Stream OpenWrite(bool overwrite, BlobOpenWriteOptions options, CancellationToken cancellationToken)
public Task`1<Stream> OpenWriteAsync(bool overwrite, BlobOpenWriteOptions options, CancellationToken cancellationToken)
internal Task`1<Stream> OpenWriteInternal(bool overwrite, BlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
private BlockBlobClient get_BlockBlobClient()
internal PartitionedUploader`2<BlobUploadOptions, BlobContentInfo> GetPartitionedUploader(StorageTransferOptions transferOptions, UploadTransferValidationOptions validationOptions, ArrayPool`1<byte> arrayPool, string operationName)
}
internal Azure.Storage.Blobs.BlobClientConfiguration : StorageClientConfiguration {
private ServiceVersion <Version>k__BackingField
private Nullable`1<CustomerProvidedKey> <CustomerProvidedKey>k__BackingField
private TransferValidationOptions <TransferValidation>k__BackingField
private string <EncryptionScope>k__BackingField
private bool <TrimBlobNameSlashes>k__BackingField
public ServiceVersion Version
public Nullable`1<CustomerProvidedKey> CustomerProvidedKey
public TransferValidationOptions TransferValidation
public string EncryptionScope
public bool TrimBlobNameSlashes
public ServiceVersion get_Version()
internal void set_Version(ServiceVersion value)
public Nullable`1<CustomerProvidedKey> get_CustomerProvidedKey()
internal void set_CustomerProvidedKey(Nullable`1<CustomerProvidedKey> value)
public TransferValidationOptions get_TransferValidation()
internal void set_TransferValidation(TransferValidationOptions value)
public string get_EncryptionScope()
internal void set_EncryptionScope(string value)
public bool get_TrimBlobNameSlashes()
internal void set_TrimBlobNameSlashes(bool value)
public void .ctor(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
public void .ctor(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
public void .ctor(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
public void .ctor(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
internal void .ctor(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, TokenCredential tokenCredential, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics, ServiceVersion version, Nullable`1<CustomerProvidedKey> customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
internal BlobClientConfiguration DeepCopy(BlobClientConfiguration originalClientConfiguration)
}
public Azure.Storage.Blobs.BlobClientOptions : ClientOptions {
internal ServiceVersion LatestVersion
private ServiceVersion <Version>k__BackingField
private Nullable`1<CustomerProvidedKey> <CustomerProvidedKey>k__BackingField
private string <EncryptionScope>k__BackingField
private Uri <GeoRedundantSecondaryUri>k__BackingField
private TransferValidationOptions <TransferValidation>k__BackingField
private bool <TrimBlobNameSlashes>k__BackingField
internal ClientSideEncryptionOptions _clientSideEncryptionOptions
private bool <EnableTenantDiscovery>k__BackingField
private Nullable`1<BlobAudience> <Audience>k__BackingField
public ServiceVersion Version
public Nullable`1<CustomerProvidedKey> CustomerProvidedKey
public string EncryptionScope
public Uri GeoRedundantSecondaryUri
public TransferValidationOptions TransferValidation
public bool TrimBlobNameSlashes
public bool EnableTenantDiscovery
public Nullable`1<BlobAudience> Audience
public ServiceVersion get_Version()
public Nullable`1<CustomerProvidedKey> get_CustomerProvidedKey()
public void set_CustomerProvidedKey(Nullable`1<CustomerProvidedKey> value)
public string get_EncryptionScope()
public void set_EncryptionScope(string value)
public Uri get_GeoRedundantSecondaryUri()
public void set_GeoRedundantSecondaryUri(Uri value)
public TransferValidationOptions get_TransferValidation()
public bool get_TrimBlobNameSlashes()
public void set_TrimBlobNameSlashes(bool value)
public void .ctor(ServiceVersion version)
private void AddHeadersAndQueryParameters()
internal HttpPipeline Build(HttpPipelinePolicy authentication)
internal HttpPipeline Build(object credentials)
public bool get_EnableTenantDiscovery()
public void set_EnableTenantDiscovery(bool value)
public Nullable`1<BlobAudience> get_Audience()
public void set_Audience(Nullable`1<BlobAudience> value)
}
internal Azure.Storage.Blobs.BlobClientSideDecryptor : object {
private ClientSideDecryptor _decryptor
public void .ctor(ClientSideDecryptor decryptor)
public Task`1<Stream> DecryptInternal(Stream content, IDictionary`2<string, string> metadata, HttpRange originalRange, string receivedContentRange, bool async, CancellationToken cancellationToken)
public Task`1<Stream> DecryptWholeBlobWriteInternal(Stream plaintextDestination, IDictionary`2<string, string> metadata, bool async, CancellationToken cancellationToken)
private Task`1<Stream> TrimStreamInternal(Stream stream, HttpRange originalRange, Nullable`1<ContentRange> receivedRange, int alreadyTrimmedOffsetAmount, bool async, CancellationToken cancellationToken)
internal EncryptionData GetAndValidateEncryptionDataOrDefault(IDictionary`2<string, string> metadata)
private bool CanIgnorePadding(Nullable`1<ContentRange> contentRange)
internal HttpRange GetEncryptedBlobRange(HttpRange originalRange, string rawEncryptionData)
internal HttpRange GetEncryptedBlobRange(HttpRange originalRange, EncryptionData encryptionData)
private HttpRange GetEncryptedBlobRangeV2_0(HttpRange originalRange, EncryptionData encryptionData)
private HttpRange GetEncryptedBlobRangeV1_0(HttpRange originalRange)
}
internal Azure.Storage.Blobs.BlobClientSideEncryptor : object {
private IClientSideEncryptor _encryptor
public void .ctor(IClientSideEncryptor encryptor)
public Task`1<ValueTuple`2<Stream, IDictionary`2<string, string>>> ClientSideEncryptInternal(Stream content, IDictionary`2<string, string> metadata, bool async, CancellationToken cancellationToken)
public Task`1<Stream> ClientSideEncryptionOpenWriteInternal(BlockBlobClient blobClient, bool overwrite, BlockBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
private IDictionary`2<string, string> TransformMetadata(IDictionary`2<string, string> metadata, EncryptionData encryptionData)
}
public Azure.Storage.Blobs.BlobContainerClient : object {
public string RootBlobContainerName
public string LogsBlobContainerName
public string WebBlobContainerName
private Uri _uri
private BlobClientConfiguration _clientConfiguration
private HttpPipelinePolicy _authenticationPolicy
private ClientSideEncryptionOptions _clientSideEncryption
private string _accountName
private string _name
private ContainerRestClient _containerRestClient
private BlobServiceClient _parentBlobServiceClient
public Uri Uri
internal BlobClientConfiguration ClientConfiguration
internal HttpPipelinePolicy AuthenticationPolicy
internal ClientSideEncryptionOptions ClientSideEncryption
public string AccountName
public string Name
public bool CanGenerateSasUri
internal ContainerRestClient ContainerRestClient
public Uri get_Uri()
internal BlobClientConfiguration get_ClientConfiguration()
internal HttpPipelinePolicy get_AuthenticationPolicy()
internal ClientSideEncryptionOptions get_ClientSideEncryption()
public string get_AccountName()
public string get_Name()
public bool get_CanGenerateSasUri()
internal ContainerRestClient get_ContainerRestClient()
public void .ctor(string connectionString, string blobContainerName)
public void .ctor(string connectionString, string blobContainerName, BlobClientOptions options)
public void .ctor(Uri blobContainerUri, BlobClientOptions options)
public void .ctor(Uri blobContainerUri, StorageSharedKeyCredential credential, BlobClientOptions options)
public void .ctor(Uri blobContainerUri, AzureSasCredential credential, BlobClientOptions options)
public void .ctor(Uri blobContainerUri, TokenCredential credential, BlobClientOptions options)
internal void .ctor(Uri containerUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption)
protected BlobContainerClient CreateClient(Uri containerUri, BlobClientOptions options, HttpPipeline pipeline)
private ContainerRestClient BuildContainerRestClient(Uri containerUri)
protected internal BlobBaseClient GetBlobBaseClientCore(string blobName)
public BlobClient GetBlobClient(string blobName)
protected internal BlockBlobClient GetBlockBlobClientCore(string blobName)
protected internal AppendBlobClient GetAppendBlobClientCore(string blobName)
protected internal PageBlobClient GetPageBlobClientCore(string blobName)
protected internal BlobLeaseClient GetBlobLeaseClientCore(string leaseId)
private void SetNameFieldsIfNull()
public Response`1<BlobContainerInfo> Create(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, CancellationToken cancellationToken)
public Response`1<BlobContainerInfo> Create(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerInfo>> CreateAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerInfo>> CreateAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
public Response`1<BlobContainerInfo> CreateIfNotExists(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, CancellationToken cancellationToken)
public Response`1<BlobContainerInfo> CreateIfNotExists(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerInfo>> CreateIfNotExistsAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerInfo>> CreateIfNotExistsAsync(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContainerInfo>> CreateIfNotExistsInternal(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, bool async, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContainerInfo>> CreateInternal(PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, bool async, CancellationToken cancellationToken, string operationName)
public Response Delete(BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response> DeleteAsync(BlobRequestConditions conditions, CancellationToken cancellationToken)
public Response`1<bool> DeleteIfExists(BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<bool>> DeleteIfExistsAsync(BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<bool>> DeleteIfExistsInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
private Task`1<Response> DeleteInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName)
public Response`1<bool> Exists(CancellationToken cancellationToken)
public Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken)
private Task`1<Response`1<bool>> ExistsInternal(bool async, CancellationToken cancellationToken)
public Response`1<BlobContainerProperties> GetProperties(BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerProperties>> GetPropertiesAsync(BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContainerProperties>> GetPropertiesInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobContainerInfo> SetMetadata(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContainerInfo>> SetMetadataInternal(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobContainerAccessPolicy> GetAccessPolicy(BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerAccessPolicy>> GetAccessPolicyAsync(BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContainerAccessPolicy>> GetAccessPolicyInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobContainerInfo> SetAccessPolicy(PublicAccessType accessType, IEnumerable`1<BlobSignedIdentifier> permissions, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerInfo>> SetAccessPolicyAsync(PublicAccessType accessType, IEnumerable`1<BlobSignedIdentifier> permissions, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContainerInfo>> SetAccessPolicyInternal(PublicAccessType accessType, IEnumerable`1<BlobSignedIdentifier> permissions, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Pageable`1<BlobItem> GetBlobs(BlobTraits traits, BlobStates states, string prefix, CancellationToken cancellationToken)
public AsyncPageable`1<BlobItem> GetBlobsAsync(BlobTraits traits, BlobStates states, string prefix, CancellationToken cancellationToken)
internal Task`1<Response`1<ListBlobsFlatSegmentResponse>> GetBlobsInternal(string marker, BlobTraits traits, BlobStates states, string prefix, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
public Pageable`1<BlobHierarchyItem> GetBlobsByHierarchy(BlobTraits traits, BlobStates states, string delimiter, string prefix, CancellationToken cancellationToken)
public AsyncPageable`1<BlobHierarchyItem> GetBlobsByHierarchyAsync(BlobTraits traits, BlobStates states, string delimiter, string prefix, CancellationToken cancellationToken)
internal Task`1<Response`1<ListBlobsHierarchySegmentResponse>> GetBlobsByHierarchyInternal(string marker, string delimiter, BlobTraits traits, BlobStates states, string prefix, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> UploadBlob(string blobName, Stream content, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadBlobAsync(string blobName, Stream content, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> UploadBlob(string blobName, BinaryData content, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadBlobAsync(string blobName, BinaryData content, CancellationToken cancellationToken)
public Response DeleteBlob(string blobName, DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response> DeleteBlobAsync(string blobName, DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Response`1<bool> DeleteBlobIfExists(string blobName, DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<bool>> DeleteBlobIfExistsAsync(string blobName, DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken)
internal Response`1<BlobContainerClient> Rename(string destinationContainerName, BlobRequestConditions sourceConditions, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContainerClient>> RenameAsync(string destinationContainerName, BlobRequestConditions sourceConditions, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContainerClient>> RenameInternal(string destinationContainerName, BlobRequestConditions sourceConditions, bool async, CancellationToken cancellationToken)
public Pageable`1<TaggedBlobItem> FindBlobsByTags(string tagFilterSqlExpression, CancellationToken cancellationToken)
public AsyncPageable`1<TaggedBlobItem> FindBlobsByTagsAsync(string tagFilterSqlExpression, CancellationToken cancellationToken)
internal Task`1<Response`1<FilterBlobSegment>> FindBlobsByTagsInternal(string marker, string expression, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
public Uri GenerateSasUri(BlobContainerSasPermissions permissions, DateTimeOffset expiresOn)
public Uri GenerateSasUri(BlobSasBuilder builder)
protected internal BlobServiceClient GetParentBlobServiceClientCore()
}
internal Azure.Storage.Blobs.BlobCopyFromURLHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public string VersionId
public string CopyId
public string CopyStatus
public Byte[] ContentMD5
public Byte[] XMsContentCrc64
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
public string get_VersionId()
public string get_CopyId()
public string get_CopyStatus()
public Byte[] get_ContentMD5()
public Byte[] get_XMsContentCrc64()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.BlobCreateSnapshotHeaders : object {
private Response _response
public string Snapshot
public Nullable`1<DateTimeOffset> LastModified
public string Version
public string VersionId
public Nullable`1<bool> IsServerEncrypted
public void .ctor(Response response)
public string get_Snapshot()
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
public string get_VersionId()
public Nullable`1<bool> get_IsServerEncrypted()
}
internal Azure.Storage.Blobs.BlobDeleteHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.BlobDeleteImmutabilityPolicyHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.BlobDownloadHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<DateTimeOffset> CreationTime
public IDictionary`2<string, string> Metadata
public string ObjectReplicationPolicyId
public IDictionary`2<string, string> ObjectReplicationRules
public Nullable`1<long> ContentLength
public string ContentType
public string ContentRange
public Byte[] ContentMD5
public string ContentEncoding
public string CacheControl
public string ContentDisposition
public string ContentLanguage
public Nullable`1<long> BlobSequenceNumber
public Nullable`1<BlobType> BlobType
public Nullable`1<DateTimeOffset> CopyCompletionTime
public string CopyStatusDescription
public string CopyId
public string CopyProgress
public string CopySource
public Nullable`1<CopyStatus> CopyStatus
public Nullable`1<LeaseDurationType> LeaseDuration
public Nullable`1<LeaseState> LeaseState
public Nullable`1<LeaseStatus> LeaseStatus
public string Version
public string VersionId
public Nullable`1<bool> IsCurrentVersion
public string AcceptRanges
public Nullable`1<int> BlobCommittedBlockCount
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public Byte[] BlobContentMD5
public Nullable`1<long> TagCount
public Nullable`1<bool> IsSealed
public Nullable`1<DateTimeOffset> LastAccessed
public Nullable`1<DateTimeOffset> ImmutabilityPolicyExpiresOn
public Nullable`1<BlobImmutabilityPolicyMode> ImmutabilityPolicyMode
public Nullable`1<bool> LegalHold
public Byte[] ContentCrc64
public string ErrorCode
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<DateTimeOffset> get_CreationTime()
public IDictionary`2<string, string> get_Metadata()
public string get_ObjectReplicationPolicyId()
public IDictionary`2<string, string> get_ObjectReplicationRules()
public Nullable`1<long> get_ContentLength()
public string get_ContentType()
public string get_ContentRange()
public Byte[] get_ContentMD5()
public string get_ContentEncoding()
public string get_CacheControl()
public string get_ContentDisposition()
public string get_ContentLanguage()
public Nullable`1<long> get_BlobSequenceNumber()
public Nullable`1<BlobType> get_BlobType()
public Nullable`1<DateTimeOffset> get_CopyCompletionTime()
public string get_CopyStatusDescription()
public string get_CopyId()
public string get_CopyProgress()
public string get_CopySource()
public Nullable`1<CopyStatus> get_CopyStatus()
public Nullable`1<LeaseDurationType> get_LeaseDuration()
public Nullable`1<LeaseState> get_LeaseState()
public Nullable`1<LeaseStatus> get_LeaseStatus()
public string get_Version()
public string get_VersionId()
public Nullable`1<bool> get_IsCurrentVersion()
public string get_AcceptRanges()
public Nullable`1<int> get_BlobCommittedBlockCount()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
public Byte[] get_BlobContentMD5()
public Nullable`1<long> get_TagCount()
public Nullable`1<bool> get_IsSealed()
public Nullable`1<DateTimeOffset> get_LastAccessed()
public Nullable`1<DateTimeOffset> get_ImmutabilityPolicyExpiresOn()
public Nullable`1<BlobImmutabilityPolicyMode> get_ImmutabilityPolicyMode()
public Nullable`1<bool> get_LegalHold()
public Byte[] get_ContentCrc64()
public string get_ErrorCode()
}
internal Azure.Storage.Blobs.BlobErrors : Errors {
public ArgumentOutOfRangeException BlobConditionsMustBeDefault(String[] conditions)
public InvalidOperationException BlobOrContainerMissing(string leaseClient, string blobBaseClient, string blobContainerClient)
public ArgumentException InvalidDateTimeUtc(string dateTime)
internal void VerifyHttpsCustomerProvidedKey(Uri uri, Nullable`1<CustomerProvidedKey> customerProvidedKey)
internal void VerifyCpkAndEncryptionScopeNotBothSet(Nullable`1<CustomerProvidedKey> customerProvidedKey, string encryptionScope)
public ArgumentException ParsingFullHttpRangeFailed(string range)
}
internal Azure.Storage.Blobs.BlobExtensions : object {
internal IDictionary`2<string, string> ToTagDictionary(BlobTags blobTags)
internal BlobTags ToBlobTags(IDictionary`2<string, string> tags)
internal string ToTagsString(IDictionary`2<string, string> tags)
internal TaggedBlobItem ToBlobTagItem(FilterBlobItem filterBlobItem)
internal List`1<TaggedBlobItem> ToBlobTagItems(IEnumerable`1<FilterBlobItem> filterBlobItems)
internal IList`1<ObjectReplicationPolicy> ParseObjectReplicationIds(IDictionary`2<string, string> OrIds)
internal IList`1<ObjectReplicationPolicy> ParseObjectReplicationMetadata(IReadOnlyDictionary`2<string, string> OrMetadata)
internal Nullable`1<RehydratePriority> ToRehydratePriority(string rehydratePriority)
internal AccountInfo ToAccountInfo(ResponseWithHeaders`1<ServiceGetAccountInfoHeaders> response)
internal BlobContainerInfo ToBlobContainerInfo(ResponseWithHeaders`1<ContainerCreateHeaders> response)
internal BlobContainerAccessPolicy ToBlobContainerAccessPolicy(ResponseWithHeaders`2<IReadOnlyList`1<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders> response)
internal BlobContainerInfo ToBlobContainerInfo(ResponseWithHeaders`1<ContainerSetAccessPolicyHeaders> response)
internal BlobContainerInfo ToBlobContainerInfo(ResponseWithHeaders`1<ContainerSetMetadataHeaders> response)
internal BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<AppendBlobCreateHeaders> response)
internal BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<PageBlobCreateHeaders> response)
internal BlobAppendInfo ToBlobAppendInfo(ResponseWithHeaders`1<AppendBlobAppendBlockHeaders> response)
internal BlobAppendInfo ToBlobAppendInfo(ResponseWithHeaders`1<AppendBlobAppendBlockFromUrlHeaders> response)
internal BlobInfo ToBlobInfo(ResponseWithHeaders`1<AppendBlobSealHeaders> response)
internal PageInfo ToPageInfo(ResponseWithHeaders`1<PageBlobUploadPagesHeaders> response)
internal PageInfo ToPageInfo(ResponseWithHeaders`1<PageBlobClearPagesHeaders> response)
internal PageInfo ToPageInfo(ResponseWithHeaders`1<PageBlobUploadPagesFromURLHeaders> response)
internal PageRangesInfo ToPageRangesInfo(ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders> response)
internal PageRangesInfo ToPageRangesInfo(ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders> response)
internal HttpRange ToHttpRange(PageRange pageRange)
internal HttpRange ToHttpRange(ClearRange clearRange)
internal PageBlobInfo ToPageBlobInfo(ResponseWithHeaders`1<PageBlobResizeHeaders> response)
internal PageBlobInfo ToPageBlobInfo(ResponseWithHeaders`1<PageBlobUpdateSequenceNumberHeaders> response)
internal BlockInfo ToBlockInfo(ResponseWithHeaders`1<BlockBlobStageBlockHeaders> response)
internal BlockInfo ToBlockInfo(ResponseWithHeaders`1<BlockBlobStageBlockFromURLHeaders> response)
internal BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<BlockBlobCommitBlockListHeaders> response)
internal BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<BlockBlobPutBlobFromUrlHeaders> response)
internal BlobContentInfo ToBlobContentInfo(ResponseWithHeaders`1<BlockBlobUploadHeaders> response)
internal BlockList ToBlockList(ResponseWithHeaders`2<BlockList, BlockBlobGetBlockListHeaders> response)
internal BlobSnapshotInfo ToBlobSnapshotInfo(ResponseWithHeaders`1<BlobCreateSnapshotHeaders> response)
internal BlobInfo ToBlobInfo(ResponseWithHeaders`1<BlobSetMetadataHeaders> response)
internal BlobInfo ToBlobInfo(ResponseWithHeaders`1<BlobSetHttpHeadersHeaders> response)
internal BlobProperties ToBlobProperties(ResponseWithHeaders`1<BlobGetPropertiesHeaders> response)
internal BlobCopyInfo ToBlobCopyInfo(ResponseWithHeaders`1<BlobCopyFromURLHeaders> response)
internal BlobCopyInfo ToBlobCopyInfo(ResponseWithHeaders`1<BlobStartCopyFromURLHeaders> response)
internal BlobCopyInfo ToBlobCopyInfo(ResponseWithHeaders`1<PageBlobCopyIncrementalHeaders> response)
internal BlobDownloadStreamingResult ToBlobDownloadStreamingResult(ResponseWithHeaders`2<Stream, BlobDownloadHeaders> response)
internal BlobDownloadInfo ToBlobDownloadInfo(ResponseWithHeaders`2<Stream, BlobQueryHeaders> response, Stream stream)
private void ExtractMultiHeaderDownloadProperties(ResponseHeaders headers, IDictionary`2& metadata, IDictionary`2& objectReplicationRules)
internal BlobLease ToBlobLease(ResponseWithHeaders`1<BlobAcquireLeaseHeaders> response)
internal BlobLease ToBlobLease(ResponseWithHeaders`1<ContainerAcquireLeaseHeaders> response)
internal BlobLease ToBlobLease(ResponseWithHeaders`1<BlobRenewLeaseHeaders> response)
internal BlobLease ToBlobLease(ResponseWithHeaders`1<ContainerRenewLeaseHeaders> response)
internal BlobLease ToBlobLease(ResponseWithHeaders`1<BlobChangeLeaseHeaders> response)
internal BlobLease ToBlobLease(ResponseWithHeaders`1<ContainerChangeLeaseHeaders> response)
internal BlobLease ToBlobLease(ResponseWithHeaders`1<BlobBreakLeaseHeaders> response)
internal BlobLease ToBlobLease(ResponseWithHeaders`1<ContainerBreakLeaseHeaders> response)
internal Nullable`1<int> ExtractLeaseTime(ResponseHeaders responseHeaders)
internal ReleasedObjectInfo ToReleasedObjectInfo(ResponseWithHeaders`1<BlobReleaseLeaseHeaders> response)
internal ReleasedObjectInfo ToReleasedObjectInfo(ResponseWithHeaders`1<ContainerReleaseLeaseHeaders> response)
internal BlobItem[] ToBlobItems(IReadOnlyList`1<BlobItemInternal> blobItemInternals)
internal BlobItem ToBlobItem(BlobItemInternal blobItemInternal)
internal string ToBlobNameString(BlobName blobName)
internal BlobItemProperties ToBlobItemProperties(BlobPropertiesInternal blobPropertiesInternal)
internal BlobContainerItem[] ToBlobContainerItems(IReadOnlyList`1<ContainerItemInternal> containerItemInternals)
internal BlobContainerItem ToBlobContainerItem(ContainerItemInternal containerItemInternal)
internal BlobContainerProperties ToBlobContainerProperties(ContainerPropertiesInternal containerPropertiesInternal, IReadOnlyDictionary`2<string, string> metadata)
internal BlobContainerProperties ToBlobContainerProperties(ResponseWithHeaders`1<ContainerGetPropertiesHeaders> response)
internal IDictionary`2<string, string> ToMetadata(IDictionary`2<string, string> originalMetadata)
internal IDictionary`2<string, string> ToMetadata(IReadOnlyDictionary`2<string, string> originalMetadata)
internal BlobImmutabilityPolicy ToBlobImmutabilityPolicy(ResponseWithHeaders`1<BlobSetImmutabilityPolicyHeaders> response)
internal BlobLegalHoldResult ToBlobLegalHoldInfo(ResponseWithHeaders`1<BlobSetLegalHoldHeaders> response)
internal string ToEncryptionAlgorithmString(EncryptionAlgorithmType type)
internal PageRangeItem[] ToPageBlobRanges(ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders> response)
internal PageRangeItem[] ToPageBlobRanges(ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders> response)
internal PageRangeItem[] ToPageBlobRanges(IReadOnlyList`1<PageRange> pageRanges, IReadOnlyList`1<ClearRange> clearRanges)
internal void ValidateConditionsNotPresent(RequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
internal void ValidateConditionsNotPresent(BlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
internal void ValidateConditionsNotPresent(BlobLeaseRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
internal void ValidateConditionsNotPresent(AppendBlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
internal void ValidateConditionsNotPresent(PageBlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
internal void ValidateConditionsNotPresent(RequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, List`1& invalidList)
internal void ValidateConditionsNotPresent(BlobLeaseRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, List`1& invalidList)
internal void ValidateConditionsNotPresent(BlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, List`1& invalidList)
internal BlockListType ToBlockListType(BlockListTypes options)
internal IEnumerable`1<ListContainersIncludeType> AsIncludeItems(BlobContainerTraits traits, BlobContainerStates states)
internal IEnumerable`1<ListBlobsIncludeItem> AsIncludeItems(BlobTraits traits, BlobStates states)
internal string ToPermissionsString(BlobAccountSasPermissions permissions)
internal string ToPermissionsString(BlobContainerSasPermissions permissions)
internal string ToPermissionsString(BlobSasPermissions permissions)
internal string ToPermissionsString(BlobVersionSasPermissions permissions)
internal string ToPermissionsString(SnapshotSasPermissions permissions)
}
internal Azure.Storage.Blobs.BlobGetPropertiesHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<DateTimeOffset> CreationTime
public IDictionary`2<string, string> Metadata
public string ObjectReplicationPolicyId
public IDictionary`2<string, string> ObjectReplicationRules
public Nullable`1<BlobType> BlobType
public Nullable`1<DateTimeOffset> CopyCompletionTime
public string CopyStatusDescription
public string CopyId
public string CopyProgress
public string CopySource
public Nullable`1<CopyStatus> CopyStatus
public Nullable`1<bool> IsIncrementalCopy
public string DestinationSnapshot
public Nullable`1<LeaseDurationType> LeaseDuration
public Nullable`1<LeaseState> LeaseState
public Nullable`1<LeaseStatus> LeaseStatus
public Nullable`1<long> ContentLength
public string ContentType
public Byte[] ContentMD5
public string ContentEncoding
public string ContentDisposition
public string ContentLanguage
public string CacheControl
public Nullable`1<long> BlobSequenceNumber
public string Version
public string AcceptRanges
public Nullable`1<int> BlobCommittedBlockCount
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public string AccessTier
public Nullable`1<bool> AccessTierInferred
public string ArchiveStatus
public Nullable`1<DateTimeOffset> AccessTierChangeTime
public string VersionId
public Nullable`1<bool> IsCurrentVersion
public Nullable`1<long> TagCount
public Nullable`1<DateTimeOffset> ExpiresOn
public Nullable`1<bool> IsSealed
public string RehydratePriority
public Nullable`1<DateTimeOffset> LastAccessed
public Nullable`1<DateTimeOffset> ImmutabilityPolicyExpiresOn
public Nullable`1<BlobImmutabilityPolicyMode> ImmutabilityPolicyMode
public Nullable`1<bool> LegalHold
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<DateTimeOffset> get_CreationTime()
public IDictionary`2<string, string> get_Metadata()
public string get_ObjectReplicationPolicyId()
public IDictionary`2<string, string> get_ObjectReplicationRules()
public Nullable`1<BlobType> get_BlobType()
public Nullable`1<DateTimeOffset> get_CopyCompletionTime()
public string get_CopyStatusDescription()
public string get_CopyId()
public string get_CopyProgress()
public string get_CopySource()
public Nullable`1<CopyStatus> get_CopyStatus()
public Nullable`1<bool> get_IsIncrementalCopy()
public string get_DestinationSnapshot()
public Nullable`1<LeaseDurationType> get_LeaseDuration()
public Nullable`1<LeaseState> get_LeaseState()
public Nullable`1<LeaseStatus> get_LeaseStatus()
public Nullable`1<long> get_ContentLength()
public string get_ContentType()
public Byte[] get_ContentMD5()
public string get_ContentEncoding()
public string get_ContentDisposition()
public string get_ContentLanguage()
public string get_CacheControl()
public Nullable`1<long> get_BlobSequenceNumber()
public string get_Version()
public string get_AcceptRanges()
public Nullable`1<int> get_BlobCommittedBlockCount()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
public string get_AccessTier()
public Nullable`1<bool> get_AccessTierInferred()
public string get_ArchiveStatus()
public Nullable`1<DateTimeOffset> get_AccessTierChangeTime()
public string get_VersionId()
public Nullable`1<bool> get_IsCurrentVersion()
public Nullable`1<long> get_TagCount()
public Nullable`1<DateTimeOffset> get_ExpiresOn()
public Nullable`1<bool> get_IsSealed()
public string get_RehydratePriority()
public Nullable`1<DateTimeOffset> get_LastAccessed()
public Nullable`1<DateTimeOffset> get_ImmutabilityPolicyExpiresOn()
public Nullable`1<BlobImmutabilityPolicyMode> get_ImmutabilityPolicyMode()
public Nullable`1<bool> get_LegalHold()
}
internal Azure.Storage.Blobs.BlobGetTagsHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.BlobQueryHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public IDictionary`2<string, string> Metadata
public Nullable`1<long> ContentLength
public string ContentType
public string ContentRange
public Byte[] ContentMD5
public string ContentEncoding
public string CacheControl
public string ContentDisposition
public string ContentLanguage
public Nullable`1<long> BlobSequenceNumber
public Nullable`1<BlobType> BlobType
public Nullable`1<DateTimeOffset> CopyCompletionTime
public string CopyStatusDescription
public string CopyId
public string CopyProgress
public string CopySource
public Nullable`1<CopyStatus> CopyStatus
public Nullable`1<LeaseDurationType> LeaseDuration
public Nullable`1<LeaseState> LeaseState
public Nullable`1<LeaseStatus> LeaseStatus
public string Version
public string AcceptRanges
public Nullable`1<int> BlobCommittedBlockCount
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public Byte[] BlobContentMD5
public Byte[] ContentCrc64
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public IDictionary`2<string, string> get_Metadata()
public Nullable`1<long> get_ContentLength()
public string get_ContentType()
public string get_ContentRange()
public Byte[] get_ContentMD5()
public string get_ContentEncoding()
public string get_CacheControl()
public string get_ContentDisposition()
public string get_ContentLanguage()
public Nullable`1<long> get_BlobSequenceNumber()
public Nullable`1<BlobType> get_BlobType()
public Nullable`1<DateTimeOffset> get_CopyCompletionTime()
public string get_CopyStatusDescription()
public string get_CopyId()
public string get_CopyProgress()
public string get_CopySource()
public Nullable`1<CopyStatus> get_CopyStatus()
public Nullable`1<LeaseDurationType> get_LeaseDuration()
public Nullable`1<LeaseState> get_LeaseState()
public Nullable`1<LeaseStatus> get_LeaseStatus()
public string get_Version()
public string get_AcceptRanges()
public Nullable`1<int> get_BlobCommittedBlockCount()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
public Byte[] get_BlobContentMD5()
public Byte[] get_ContentCrc64()
}
internal Azure.Storage.Blobs.BlobQuickQueryStream : Stream {
internal Stream _avroStream
internal AvroReader _avroReader
internal Byte[] _buffer
internal int _bufferOffset
internal int _bufferLength
internal IProgress`1<long> _progressHandler
internal Action`1<BlobQueryError> _errorHandler
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(Stream avroStream, IProgress`1<long> progressHandler, Action`1<BlobQueryError> errorHandler)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count)
private Task`1<int> ReadInternal(bool async, Byte[] buffer, int offset, int count)
internal void ValidateReadParameters(Byte[] buffer, int offset, int count)
internal void ProcessErrorRecord(Dictionary`2<string, object> record)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
protected void Dispose(bool disposing)
}
internal Azure.Storage.Blobs.BlobReleaseLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
}
internal Azure.Storage.Blobs.BlobRenewLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string LeaseId
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_LeaseId()
public string get_Version()
}
internal Azure.Storage.Blobs.BlobRestClient : object {
private HttpPipeline _pipeline
private string _url
private string _version
private ClientDiagnostics <ClientDiagnostics>k__BackingField
private ResponseClassifier _responseClassifier200
private ResponseClassifier _responseClassifier201
internal ClientDiagnostics ClientDiagnostics
private ResponseClassifier ResponseClassifier200
private ResponseClassifier ResponseClassifier201
internal ClientDiagnostics get_ClientDiagnostics()
public void .ctor(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
internal HttpMessage CreateDownloadRequest(string snapshot, string versionId, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<bool> rangeGetContentMD5, Nullable`1<bool> rangeGetContentCRC64, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`2<Stream, BlobDownloadHeaders>> DownloadAsync(string snapshot, string versionId, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<bool> rangeGetContentMD5, Nullable`1<bool> rangeGetContentCRC64, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`2<Stream, BlobDownloadHeaders> Download(string snapshot, string versionId, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<bool> rangeGetContentMD5, Nullable`1<bool> rangeGetContentCRC64, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateGetPropertiesRequest(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<BlobGetPropertiesHeaders>> GetPropertiesAsync(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobGetPropertiesHeaders> GetProperties(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateGetPropertiesRequest(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, string encryptionAlgorithm, string ifTags, RequestConditions requestConditions, RequestContext context)
public Task`1<Response> GetPropertiesAsync(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, string encryptionAlgorithm, string ifTags, RequestConditions requestConditions, RequestContext context)
public Response GetProperties(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, string encryptionAlgorithm, string ifTags, RequestConditions requestConditions, RequestContext context)
internal HttpMessage CreateDeleteRequest(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, Nullable`1<DeleteSnapshotsOption> deleteSnapshots, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<BlobDeleteType> blobDeleteType)
public Task`1<ResponseWithHeaders`1<BlobDeleteHeaders>> DeleteAsync(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, Nullable`1<DeleteSnapshotsOption> deleteSnapshots, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<BlobDeleteType> blobDeleteType, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobDeleteHeaders> Delete(string snapshot, string versionId, Nullable`1<int> timeout, string leaseId, Nullable`1<DeleteSnapshotsOption> deleteSnapshots, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<BlobDeleteType> blobDeleteType, CancellationToken cancellationToken)
internal HttpMessage CreateUndeleteRequest(Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`1<BlobUndeleteHeaders>> UndeleteAsync(Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobUndeleteHeaders> Undelete(Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateSetExpiryRequest(BlobExpiryOptions expiryOptions, Nullable`1<int> timeout, string expiresOn)
public Task`1<ResponseWithHeaders`1<BlobSetExpiryHeaders>> SetExpiryAsync(BlobExpiryOptions expiryOptions, Nullable`1<int> timeout, string expiresOn, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobSetExpiryHeaders> SetExpiry(BlobExpiryOptions expiryOptions, Nullable`1<int> timeout, string expiresOn, CancellationToken cancellationToken)
internal HttpMessage CreateSetHttpHeadersRequest(Nullable`1<int> timeout, string blobCacheControl, string blobContentType, Byte[] blobContentMD5, string blobContentEncoding, string blobContentLanguage, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobContentDisposition)
public Task`1<ResponseWithHeaders`1<BlobSetHttpHeadersHeaders>> SetHttpHeadersAsync(Nullable`1<int> timeout, string blobCacheControl, string blobContentType, Byte[] blobContentMD5, string blobContentEncoding, string blobContentLanguage, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobContentDisposition, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobSetHttpHeadersHeaders> SetHttpHeaders(Nullable`1<int> timeout, string blobCacheControl, string blobContentType, Byte[] blobContentMD5, string blobContentEncoding, string blobContentLanguage, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobContentDisposition, CancellationToken cancellationToken)
internal HttpMessage CreateSetImmutabilityPolicyRequest(Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifUnmodifiedSince, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode)
public Task`1<ResponseWithHeaders`1<BlobSetImmutabilityPolicyHeaders>> SetImmutabilityPolicyAsync(Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifUnmodifiedSince, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobSetImmutabilityPolicyHeaders> SetImmutabilityPolicy(Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifUnmodifiedSince, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, CancellationToken cancellationToken)
internal HttpMessage CreateDeleteImmutabilityPolicyRequest(Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`1<BlobDeleteImmutabilityPolicyHeaders>> DeleteImmutabilityPolicyAsync(Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobDeleteImmutabilityPolicyHeaders> DeleteImmutabilityPolicy(Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateSetLegalHoldRequest(bool legalHold, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`1<BlobSetLegalHoldHeaders>> SetLegalHoldAsync(bool legalHold, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobSetLegalHoldHeaders> SetLegalHold(bool legalHold, Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateSetMetadataRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<BlobSetMetadataHeaders>> SetMetadataAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobSetMetadataHeaders> SetMetadata(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<BlobAcquireLeaseHeaders>> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobAcquireLeaseHeaders> AcquireLease(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, string ifTags, RequestConditions requestConditions, RequestContext context)
public Task`1<Response> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, string ifTags, RequestConditions requestConditions, RequestContext context)
public Response AcquireLease(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, string ifTags, RequestConditions requestConditions, RequestContext context)
internal HttpMessage CreateReleaseLeaseRequest(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<BlobReleaseLeaseHeaders>> ReleaseLeaseAsync(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobReleaseLeaseHeaders> ReleaseLease(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateRenewLeaseRequest(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<BlobRenewLeaseHeaders>> RenewLeaseAsync(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobRenewLeaseHeaders> RenewLease(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateChangeLeaseRequest(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<BlobChangeLeaseHeaders>> ChangeLeaseAsync(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobChangeLeaseHeaders> ChangeLease(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateBreakLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<BlobBreakLeaseHeaders>> BreakLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobBreakLeaseHeaders> BreakLease(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateCreateSnapshotRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId)
public Task`1<ResponseWithHeaders`1<BlobCreateSnapshotHeaders>> CreateSnapshotAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobCreateSnapshotHeaders> CreateSnapshot(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, CancellationToken cancellationToken)
internal HttpMessage CreateStartCopyFromURLRequest(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, string blobTagsString, Nullable`1<bool> sealBlob, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold)
public Task`1<ResponseWithHeaders`1<BlobStartCopyFromURLHeaders>> StartCopyFromURLAsync(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, string blobTagsString, Nullable`1<bool> sealBlob, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobStartCopyFromURLHeaders> StartCopyFromURL(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, string blobTagsString, Nullable`1<bool> sealBlob, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken)
internal HttpMessage CreateCopyFromURLRequest(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, string copySourceAuthorization, string encryptionScope, Nullable`1<BlobCopySourceTagsMode> copySourceTags)
public Task`1<ResponseWithHeaders`1<BlobCopyFromURLHeaders>> CopyFromURLAsync(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, string copySourceAuthorization, string encryptionScope, Nullable`1<BlobCopySourceTagsMode> copySourceTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobCopyFromURLHeaders> CopyFromURL(string copySource, Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, string copySourceAuthorization, string encryptionScope, Nullable`1<BlobCopySourceTagsMode> copySourceTags, CancellationToken cancellationToken)
internal HttpMessage CreateAbortCopyFromURLRequest(string copyId, Nullable`1<int> timeout, string leaseId)
public Task`1<ResponseWithHeaders`1<BlobAbortCopyFromURLHeaders>> AbortCopyFromURLAsync(string copyId, Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobAbortCopyFromURLHeaders> AbortCopyFromURL(string copyId, Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken)
internal HttpMessage CreateSetTierRequest(AccessTier tier, string snapshot, string versionId, Nullable`1<int> timeout, Nullable`1<RehydratePriority> rehydratePriority, string leaseId, string ifTags)
public Task`1<ResponseWithHeaders`1<BlobSetTierHeaders>> SetTierAsync(AccessTier tier, string snapshot, string versionId, Nullable`1<int> timeout, Nullable`1<RehydratePriority> rehydratePriority, string leaseId, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobSetTierHeaders> SetTier(AccessTier tier, string snapshot, string versionId, Nullable`1<int> timeout, Nullable`1<RehydratePriority> rehydratePriority, string leaseId, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateQueryRequest(string snapshot, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, QueryRequest queryRequest)
public Task`1<ResponseWithHeaders`2<Stream, BlobQueryHeaders>> QueryAsync(string snapshot, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, QueryRequest queryRequest, CancellationToken cancellationToken)
public ResponseWithHeaders`2<Stream, BlobQueryHeaders> Query(string snapshot, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, QueryRequest queryRequest, CancellationToken cancellationToken)
internal HttpMessage CreateGetTagsRequest(Nullable`1<int> timeout, string snapshot, string versionId, string ifTags, string leaseId)
public Task`1<ResponseWithHeaders`2<BlobTags, BlobGetTagsHeaders>> GetTagsAsync(Nullable`1<int> timeout, string snapshot, string versionId, string ifTags, string leaseId, CancellationToken cancellationToken)
public ResponseWithHeaders`2<BlobTags, BlobGetTagsHeaders> GetTags(Nullable`1<int> timeout, string snapshot, string versionId, string ifTags, string leaseId, CancellationToken cancellationToken)
internal HttpMessage CreateSetTagsRequest(Nullable`1<int> timeout, string versionId, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string ifTags, string leaseId, BlobTags tags)
public Task`1<ResponseWithHeaders`1<BlobSetTagsHeaders>> SetTagsAsync(Nullable`1<int> timeout, string versionId, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string ifTags, string leaseId, BlobTags tags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlobSetTagsHeaders> SetTags(Nullable`1<int> timeout, string versionId, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, string ifTags, string leaseId, BlobTags tags, CancellationToken cancellationToken)
private ResponseClassifier get_ResponseClassifier200()
private ResponseClassifier get_ResponseClassifier201()
}
public Azure.Storage.Blobs.BlobServiceClient : object {
private Uri _uri
private BlobClientConfiguration _clientConfiguration
private HttpPipelinePolicy _authenticationPolicy
private ClientSideEncryptionOptions _clientSideEncryption
private string _accountName
private ServiceRestClient _serviceRestClient
public Uri Uri
internal BlobClientConfiguration ClientConfiguration
internal HttpPipelinePolicy AuthenticationPolicy
internal ClientSideEncryptionOptions ClientSideEncryption
public string AccountName
public bool CanGenerateAccountSasUri
internal ServiceRestClient ServiceRestClient
public Uri get_Uri()
internal BlobClientConfiguration get_ClientConfiguration()
internal HttpPipelinePolicy get_AuthenticationPolicy()
internal ClientSideEncryptionOptions get_ClientSideEncryption()
public string get_AccountName()
public bool get_CanGenerateAccountSasUri()
internal ServiceRestClient get_ServiceRestClient()
public void .ctor(string connectionString)
public void .ctor(string connectionString, BlobClientOptions options)
public void .ctor(Uri serviceUri, BlobClientOptions options)
public void .ctor(Uri serviceUri, StorageSharedKeyCredential credential, BlobClientOptions options)
public void .ctor(Uri serviceUri, AzureSasCredential credential, BlobClientOptions options)
public void .ctor(Uri serviceUri, TokenCredential credential, BlobClientOptions options)
internal void .ctor(Uri serviceUri, HttpPipelinePolicy authentication, BlobClientOptions options)
internal void .ctor(Uri serviceUri, HttpPipelinePolicy authentication, StorageSharedKeyCredential storageSharedKeyCredential, BlobClientOptions options)
internal void .ctor(Uri serviceUri, HttpPipelinePolicy authentication, TokenCredential tokenCredential, BlobClientOptions options)
internal void .ctor(Uri serviceUri, HttpPipelinePolicy authentication, AzureSasCredential sasCredential, BlobClientOptions options)
internal void .ctor(Uri serviceUri, BlobClientConfiguration clientConfiguration, HttpPipelinePolicy authentication, ClientSideEncryptionOptions clientSideEncryption)
protected BlobServiceClient CreateClient(Uri serviceUri, BlobClientOptions options, HttpPipelinePolicy authentication, HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential)
protected BlobServiceClient CreateClient(Uri serviceUri, BlobClientOptions options, HttpPipelinePolicy authentication, HttpPipeline pipeline)
private ServiceRestClient BuildServiceRestClient(Uri uri)
public BlobContainerClient GetBlobContainerClient(string blobContainerName)
protected HttpPipeline GetHttpPipeline(BlobServiceClient client)
protected HttpPipelinePolicy GetAuthenticationPolicy(BlobServiceClient client)
protected BlobClientOptions GetClientOptions(BlobServiceClient client)
public Pageable`1<BlobContainerItem> GetBlobContainers(BlobContainerTraits traits, BlobContainerStates states, string prefix, CancellationToken cancellationToken)
public Pageable`1<BlobContainerItem> GetBlobContainers(BlobContainerTraits traits, string prefix, CancellationToken cancellationToken)
public AsyncPageable`1<BlobContainerItem> GetBlobContainersAsync(BlobContainerTraits traits, BlobContainerStates states, string prefix, CancellationToken cancellationToken)
public AsyncPageable`1<BlobContainerItem> GetBlobContainersAsync(BlobContainerTraits traits, string prefix, CancellationToken cancellationToken)
internal Task`1<Response`1<ListContainersSegmentResponse>> GetBlobContainersInternal(string continuationToken, BlobContainerTraits traits, BlobContainerStates states, string prefix, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
public Response`1<AccountInfo> GetAccountInfo(CancellationToken cancellationToken)
public Task`1<Response`1<AccountInfo>> GetAccountInfoAsync(CancellationToken cancellationToken)
private Task`1<Response`1<AccountInfo>> GetAccountInfoInternal(bool async, CancellationToken cancellationToken)
public Response`1<BlobServiceProperties> GetProperties(CancellationToken cancellationToken)
public Task`1<Response`1<BlobServiceProperties>> GetPropertiesAsync(CancellationToken cancellationToken)
private Task`1<Response`1<BlobServiceProperties>> GetPropertiesInternal(bool async, CancellationToken cancellationToken)
public Response SetProperties(BlobServiceProperties properties, CancellationToken cancellationToken)
public Task`1<Response> SetPropertiesAsync(BlobServiceProperties properties, CancellationToken cancellationToken)
private Task`1<Response> SetPropertiesInternal(BlobServiceProperties properties, bool async, CancellationToken cancellationToken)
public Response`1<BlobServiceStatistics> GetStatistics(CancellationToken cancellationToken)
public Task`1<Response`1<BlobServiceStatistics>> GetStatisticsAsync(CancellationToken cancellationToken)
private Task`1<Response`1<BlobServiceStatistics>> GetStatisticsInternal(bool async, CancellationToken cancellationToken)
public Response`1<UserDelegationKey> GetUserDelegationKey(Nullable`1<DateTimeOffset> startsOn, DateTimeOffset expiresOn, CancellationToken cancellationToken)
public Task`1<Response`1<UserDelegationKey>> GetUserDelegationKeyAsync(Nullable`1<DateTimeOffset> startsOn, DateTimeOffset expiresOn, CancellationToken cancellationToken)
private Task`1<Response`1<UserDelegationKey>> GetUserDelegationKeyInternal(Nullable`1<DateTimeOffset> startsOn, DateTimeOffset expiresOn, bool async, CancellationToken cancellationToken)
public Response`1<BlobContainerClient> CreateBlobContainer(string blobContainerName, PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerClient>> CreateBlobContainerAsync(string blobContainerName, PublicAccessType publicAccessType, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
public Response DeleteBlobContainer(string blobContainerName, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response> DeleteBlobContainerAsync(string blobContainerName, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Response`1<BlobContainerClient> UndeleteBlobContainer(string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerClient>> UndeleteBlobContainerAsync(string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken)
public Response`1<BlobContainerClient> UndeleteBlobContainer(string deletedContainerName, string deletedContainerVersion, string destinationContainerName, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContainerClient>> UndeleteBlobContainerAsync(string deletedContainerName, string deletedContainerVersion, string destinationContainerName, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContainerClient>> UndeleteBlobContainerInternal(string deletedContainerName, string deletedContainerVersion, string destinationContainerName, bool async, CancellationToken cancellationToken)
internal Response`1<BlobContainerClient> RenameBlobContainer(string sourceContainerName, string destinationContainerName, BlobRequestConditions sourceConditions, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContainerClient>> RenameBlobContainerAsync(string sourceContainerName, string destinationContainerName, BlobRequestConditions sourceConditions, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContainerClient>> RenameBlobContainerInternal(string sourceContainerName, string destinationContainerName, BlobRequestConditions sourceConditions, bool async, CancellationToken cancellationToken)
public Pageable`1<TaggedBlobItem> FindBlobsByTags(string tagFilterSqlExpression, CancellationToken cancellationToken)
public AsyncPageable`1<TaggedBlobItem> FindBlobsByTagsAsync(string tagFilterSqlExpression, CancellationToken cancellationToken)
internal Task`1<Response`1<FilterBlobSegment>> FindBlobsByTagsInternal(string marker, string expression, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
public Uri GenerateAccountSasUri(AccountSasPermissions permissions, DateTimeOffset expiresOn, AccountSasResourceTypes resourceTypes)
public Uri GenerateAccountSasUri(AccountSasBuilder builder)
}
internal Azure.Storage.Blobs.BlobSetExpiryHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
}
internal Azure.Storage.Blobs.BlobSetHttpHeadersHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<long> BlobSequenceNumber
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<long> get_BlobSequenceNumber()
public string get_Version()
}
internal Azure.Storage.Blobs.BlobSetImmutabilityPolicyHeaders : object {
private Response _response
public string Version
public Nullable`1<DateTimeOffset> ImmutabilityPolicyExpiry
public Nullable`1<BlobImmutabilityPolicyMode> ImmutabilityPolicyMode
public void .ctor(Response response)
public string get_Version()
public Nullable`1<DateTimeOffset> get_ImmutabilityPolicyExpiry()
public Nullable`1<BlobImmutabilityPolicyMode> get_ImmutabilityPolicyMode()
}
internal Azure.Storage.Blobs.BlobSetLegalHoldHeaders : object {
private Response _response
public string Version
public Nullable`1<bool> LegalHold
public void .ctor(Response response)
public string get_Version()
public Nullable`1<bool> get_LegalHold()
}
internal Azure.Storage.Blobs.BlobSetMetadataHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public string VersionId
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
public string get_VersionId()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.BlobSetTagsHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.BlobSetTierHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.BlobStartCopyFromURLHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public string VersionId
public string CopyId
public Nullable`1<CopyStatus> CopyStatus
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
public string get_VersionId()
public string get_CopyId()
public Nullable`1<CopyStatus> get_CopyStatus()
}
internal Azure.Storage.Blobs.BlobUndeleteHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
public Azure.Storage.Blobs.BlobUriBuilder : object {
private Uri _uri
private bool _isPathStyleUri
private bool <TrimBlobNameSlashes>k__BackingField
private string _scheme
private string _host
private int _port
private string _accountName
private string _containerName
private string _blobName
private string _snapshot
private string _versionId
private BlobSasQueryParameters _sas
private string _query
public bool TrimBlobNameSlashes
public string Scheme
public string Host
public int Port
public string AccountName
public string BlobContainerName
public string BlobName
public string Snapshot
public string VersionId
public BlobSasQueryParameters Sas
public string Query
public bool get_TrimBlobNameSlashes()
public string get_Scheme()
public void set_Scheme(string value)
public string get_Host()
public void set_Host(string value)
public int get_Port()
public void set_Port(int value)
public string get_AccountName()
public void set_AccountName(string value)
public string get_BlobContainerName()
public void set_BlobContainerName(string value)
public string get_BlobName()
public void set_BlobName(string value)
public string get_Snapshot()
public void set_Snapshot(string value)
public string get_VersionId()
public void set_VersionId(string value)
public BlobSasQueryParameters get_Sas()
public void set_Sas(BlobSasQueryParameters value)
public string get_Query()
public void set_Query(string value)
public void .ctor(Uri uri)
public void .ctor(Uri uri, bool trimBlobNameSlashes)
public Uri ToUri()
public string ToString()
private void ResetUri()
private RequestUriBuilder BuildUri()
}
internal Azure.Storage.Blobs.BlockBlobCommitBlockListHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public Byte[] XMsContentCrc64
public string Version
public string VersionId
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public Byte[] get_XMsContentCrc64()
public string get_Version()
public string get_VersionId()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.BlockBlobGetBlockListHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string ContentType
public Nullable`1<long> BlobContentLength
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_ContentType()
public Nullable`1<long> get_BlobContentLength()
public string get_Version()
}
internal Azure.Storage.Blobs.BlockBlobPutBlobFromUrlHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public string Version
public string VersionId
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public string get_Version()
public string get_VersionId()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.BlockBlobRestClient : object {
private HttpPipeline _pipeline
private string _url
private string _version
private ClientDiagnostics <ClientDiagnostics>k__BackingField
internal ClientDiagnostics ClientDiagnostics
internal ClientDiagnostics get_ClientDiagnostics()
public void .ctor(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
internal HttpMessage CreateUploadRequest(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, Byte[] transactionalContentCrc64)
public Task`1<ResponseWithHeaders`1<BlockBlobUploadHeaders>> UploadAsync(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, Byte[] transactionalContentCrc64, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlockBlobUploadHeaders> Upload(long contentLength, Stream body, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, Byte[] transactionalContentCrc64, CancellationToken cancellationToken)
internal HttpMessage CreatePutBlobFromUrlRequest(long contentLength, string copySource, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<bool> copySourceBlobProperties, string copySourceAuthorization, Nullable`1<BlobCopySourceTagsMode> copySourceTags)
public Task`1<ResponseWithHeaders`1<BlockBlobPutBlobFromUrlHeaders>> PutBlobFromUrlAsync(long contentLength, string copySource, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<bool> copySourceBlobProperties, string copySourceAuthorization, Nullable`1<BlobCopySourceTagsMode> copySourceTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlockBlobPutBlobFromUrlHeaders> PutBlobFromUrl(long contentLength, string copySource, Nullable`1<int> timeout, Byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, Byte[] sourceContentMD5, string blobTagsString, Nullable`1<bool> copySourceBlobProperties, string copySourceAuthorization, Nullable`1<BlobCopySourceTagsMode> copySourceTags, CancellationToken cancellationToken)
internal HttpMessage CreateStageBlockRequest(string blockId, long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope)
public Task`1<ResponseWithHeaders`1<BlockBlobStageBlockHeaders>> StageBlockAsync(string blockId, long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlockBlobStageBlockHeaders> StageBlock(string blockId, long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, CancellationToken cancellationToken)
internal HttpMessage CreateStageBlockFromURLRequest(string blockId, long contentLength, string sourceUrl, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization)
public Task`1<ResponseWithHeaders`1<BlockBlobStageBlockFromURLHeaders>> StageBlockFromURLAsync(string blockId, long contentLength, string sourceUrl, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlockBlobStageBlockFromURLHeaders> StageBlockFromURL(string blockId, long contentLength, string sourceUrl, string sourceRange, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken)
internal HttpMessage CreateCommitBlockListRequest(BlockLookupList blocks, Nullable`1<int> timeout, string blobCacheControl, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold)
public Task`1<ResponseWithHeaders`1<BlockBlobCommitBlockListHeaders>> CommitBlockListAsync(BlockLookupList blocks, Nullable`1<int> timeout, string blobCacheControl, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken)
public ResponseWithHeaders`1<BlockBlobCommitBlockListHeaders> CommitBlockList(BlockLookupList blocks, Nullable`1<int> timeout, string blobCacheControl, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<AccessTier> tier, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken)
internal HttpMessage CreateGetBlockListRequest(BlockListType listType, string snapshot, Nullable`1<int> timeout, string leaseId, string ifTags)
public Task`1<ResponseWithHeaders`2<BlockList, BlockBlobGetBlockListHeaders>> GetBlockListAsync(BlockListType listType, string snapshot, Nullable`1<int> timeout, string leaseId, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`2<BlockList, BlockBlobGetBlockListHeaders> GetBlockList(BlockListType listType, string snapshot, Nullable`1<int> timeout, string leaseId, string ifTags, CancellationToken cancellationToken)
}
internal Azure.Storage.Blobs.BlockBlobStageBlockFromURLHeaders : object {
private Response _response
public Byte[] ContentMD5
public Byte[] XMsContentCrc64
public string Version
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Byte[] get_ContentMD5()
public Byte[] get_XMsContentCrc64()
public string get_Version()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.BlockBlobStageBlockHeaders : object {
private Response _response
public Byte[] ContentMD5
public string Version
public Byte[] XMsContentCrc64
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Byte[] get_ContentMD5()
public string get_Version()
public Byte[] get_XMsContentCrc64()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.BlockBlobUploadHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public string Version
public string VersionId
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public string get_Version()
public string get_VersionId()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.BlockBlobWriteStream : StorageWriteStream {
private BlockBlobClient _blockBlobClient
private BlobRequestConditions _conditions
private List`1<string> _blockIds
private BlobHttpHeaders _blobHttpHeaders
private IDictionary`2<string, string> _metadata
private IDictionary`2<string, string> _tags
public void .ctor(BlockBlobClient blockBlobClient, long bufferSize, long position, BlobRequestConditions conditions, IProgress`1<long> progressHandler, BlobHttpHeaders blobHttpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, UploadTransferValidationOptions transferValidation)
protected Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
protected Task CommitInternal(bool async, CancellationToken cancellationToken)
protected void ValidateBufferSize(long bufferSize)
}
internal Azure.Storage.Blobs.ContainerAcquireLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string LeaseId
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_LeaseId()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerBreakLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<int> LeaseTime
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<int> get_LeaseTime()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerChangeLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string LeaseId
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_LeaseId()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerCreateHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerDeleteHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerFilterBlobsHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerGetAccessPolicyHeaders : object {
private Response _response
public Nullable`1<PublicAccessType> BlobPublicAccess
public Nullable`1<DateTimeOffset> LastModified
public string Version
public void .ctor(Response response)
public Nullable`1<PublicAccessType> get_BlobPublicAccess()
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerGetPropertiesHeaders : object {
private Response _response
public IDictionary`2<string, string> Metadata
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<LeaseDurationType> LeaseDuration
public Nullable`1<LeaseState> LeaseState
public Nullable`1<LeaseStatus> LeaseStatus
public string Version
public Nullable`1<PublicAccessType> BlobPublicAccess
public Nullable`1<bool> HasImmutabilityPolicy
public Nullable`1<bool> HasLegalHold
public string DefaultEncryptionScope
public Nullable`1<bool> DenyEncryptionScopeOverride
public Nullable`1<bool> IsImmutableStorageWithVersioningEnabled
public void .ctor(Response response)
public IDictionary`2<string, string> get_Metadata()
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<LeaseDurationType> get_LeaseDuration()
public Nullable`1<LeaseState> get_LeaseState()
public Nullable`1<LeaseStatus> get_LeaseStatus()
public string get_Version()
public Nullable`1<PublicAccessType> get_BlobPublicAccess()
public Nullable`1<bool> get_HasImmutabilityPolicy()
public Nullable`1<bool> get_HasLegalHold()
public string get_DefaultEncryptionScope()
public Nullable`1<bool> get_DenyEncryptionScopeOverride()
public Nullable`1<bool> get_IsImmutableStorageWithVersioningEnabled()
}
internal Azure.Storage.Blobs.ContainerListBlobFlatSegmentHeaders : object {
private Response _response
public string ContentType
public string Version
public void .ctor(Response response)
public string get_ContentType()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerListBlobHierarchySegmentHeaders : object {
private Response _response
public string ContentType
public string Version
public void .ctor(Response response)
public string get_ContentType()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerReleaseLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerRenameHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerRenewLeaseHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string LeaseId
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_LeaseId()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerRestClient : object {
private HttpPipeline _pipeline
private string _url
private string _version
private ClientDiagnostics <ClientDiagnostics>k__BackingField
private ResponseClassifier _responseClassifier201
internal ClientDiagnostics ClientDiagnostics
private ResponseClassifier ResponseClassifier201
internal ClientDiagnostics get_ClientDiagnostics()
public void .ctor(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
internal HttpMessage CreateCreateRequest(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<PublicAccessType> access, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride)
public Task`1<ResponseWithHeaders`1<ContainerCreateHeaders>> CreateAsync(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<PublicAccessType> access, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerCreateHeaders> Create(Nullable`1<int> timeout, IDictionary`2<string, string> metadata, Nullable`1<PublicAccessType> access, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, CancellationToken cancellationToken)
internal HttpMessage CreateGetPropertiesRequest(Nullable`1<int> timeout, string leaseId)
public Task`1<ResponseWithHeaders`1<ContainerGetPropertiesHeaders>> GetPropertiesAsync(Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerGetPropertiesHeaders> GetProperties(Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken)
internal HttpMessage CreateDeleteRequest(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince)
public Task`1<ResponseWithHeaders`1<ContainerDeleteHeaders>> DeleteAsync(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerDeleteHeaders> Delete(Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
internal HttpMessage CreateSetMetadataRequest(Nullable`1<int> timeout, string leaseId, IDictionary`2<string, string> metadata, Nullable`1<DateTimeOffset> ifModifiedSince)
public Task`1<ResponseWithHeaders`1<ContainerSetMetadataHeaders>> SetMetadataAsync(Nullable`1<int> timeout, string leaseId, IDictionary`2<string, string> metadata, Nullable`1<DateTimeOffset> ifModifiedSince, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerSetMetadataHeaders> SetMetadata(Nullable`1<int> timeout, string leaseId, IDictionary`2<string, string> metadata, Nullable`1<DateTimeOffset> ifModifiedSince, CancellationToken cancellationToken)
internal HttpMessage CreateGetAccessPolicyRequest(Nullable`1<int> timeout, string leaseId)
public Task`1<ResponseWithHeaders`2<IReadOnlyList`1<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders>> GetAccessPolicyAsync(Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken)
public ResponseWithHeaders`2<IReadOnlyList`1<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders> GetAccessPolicy(Nullable`1<int> timeout, string leaseId, CancellationToken cancellationToken)
internal HttpMessage CreateSetAccessPolicyRequest(Nullable`1<int> timeout, string leaseId, Nullable`1<PublicAccessType> access, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, IEnumerable`1<BlobSignedIdentifier> containerAcl)
public Task`1<ResponseWithHeaders`1<ContainerSetAccessPolicyHeaders>> SetAccessPolicyAsync(Nullable`1<int> timeout, string leaseId, Nullable`1<PublicAccessType> access, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, IEnumerable`1<BlobSignedIdentifier> containerAcl, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerSetAccessPolicyHeaders> SetAccessPolicy(Nullable`1<int> timeout, string leaseId, Nullable`1<PublicAccessType> access, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, IEnumerable`1<BlobSignedIdentifier> containerAcl, CancellationToken cancellationToken)
internal HttpMessage CreateRestoreRequest(Nullable`1<int> timeout, string deletedContainerName, string deletedContainerVersion)
public Task`1<ResponseWithHeaders`1<ContainerRestoreHeaders>> RestoreAsync(Nullable`1<int> timeout, string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerRestoreHeaders> Restore(Nullable`1<int> timeout, string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken)
internal HttpMessage CreateRenameRequest(string sourceContainerName, Nullable`1<int> timeout, string sourceLeaseId)
public Task`1<ResponseWithHeaders`1<ContainerRenameHeaders>> RenameAsync(string sourceContainerName, Nullable`1<int> timeout, string sourceLeaseId, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerRenameHeaders> Rename(string sourceContainerName, Nullable`1<int> timeout, string sourceLeaseId, CancellationToken cancellationToken)
internal HttpMessage CreateSubmitBatchRequest(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<Stream, ContainerSubmitBatchHeaders>> SubmitBatchAsync(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<Stream, ContainerSubmitBatchHeaders> SubmitBatch(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateFilterBlobsRequest(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include)
public Task`1<ResponseWithHeaders`2<FilterBlobSegment, ContainerFilterBlobsHeaders>> FilterBlobsAsync(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include, CancellationToken cancellationToken)
public ResponseWithHeaders`2<FilterBlobSegment, ContainerFilterBlobsHeaders> FilterBlobs(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include, CancellationToken cancellationToken)
internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince)
public Task`1<ResponseWithHeaders`1<ContainerAcquireLeaseHeaders>> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerAcquireLeaseHeaders> AcquireLease(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
internal HttpMessage CreateAcquireLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, RequestConditions requestConditions, RequestContext context)
public Task`1<Response> AcquireLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, RequestConditions requestConditions, RequestContext context)
public Response AcquireLease(Nullable`1<int> timeout, Nullable`1<long> duration, string proposedLeaseId, RequestConditions requestConditions, RequestContext context)
internal HttpMessage CreateReleaseLeaseRequest(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince)
public Task`1<ResponseWithHeaders`1<ContainerReleaseLeaseHeaders>> ReleaseLeaseAsync(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerReleaseLeaseHeaders> ReleaseLease(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
internal HttpMessage CreateRenewLeaseRequest(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince)
public Task`1<ResponseWithHeaders`1<ContainerRenewLeaseHeaders>> RenewLeaseAsync(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerRenewLeaseHeaders> RenewLease(string leaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
internal HttpMessage CreateBreakLeaseRequest(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince)
public Task`1<ResponseWithHeaders`1<ContainerBreakLeaseHeaders>> BreakLeaseAsync(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerBreakLeaseHeaders> BreakLease(Nullable`1<int> timeout, Nullable`1<long> breakPeriod, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
internal HttpMessage CreateChangeLeaseRequest(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince)
public Task`1<ResponseWithHeaders`1<ContainerChangeLeaseHeaders>> ChangeLeaseAsync(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ContainerChangeLeaseHeaders> ChangeLease(string leaseId, string proposedLeaseId, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, CancellationToken cancellationToken)
internal HttpMessage CreateListBlobFlatSegmentRequest(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders>> ListBlobFlatSegmentAsync(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders> ListBlobFlatSegment(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateListBlobHierarchySegmentRequest(string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders>> ListBlobHierarchySegmentAsync(string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders> ListBlobHierarchySegment(string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateListBlobFlatSegmentNextPageRequest(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders>> ListBlobFlatSegmentNextPageAsync(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders> ListBlobFlatSegmentNextPage(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateListBlobHierarchySegmentNextPageRequest(string nextLink, string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders>> ListBlobHierarchySegmentNextPageAsync(string nextLink, string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders> ListBlobHierarchySegmentNextPage(string nextLink, string prefix, string delimiter, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListBlobsIncludeItem> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
private ResponseClassifier get_ResponseClassifier201()
}
internal Azure.Storage.Blobs.ContainerRestoreHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerSetAccessPolicyHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerSetMetadataHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
}
internal Azure.Storage.Blobs.ContainerSubmitBatchHeaders : object {
private Response _response
public string ContentType
public string Version
public void .ctor(Response response)
public string get_ContentType()
public string get_Version()
}
internal Azure.Storage.Blobs.EncryptionRangeExtensions : object {
public int GetTotalRegionLength(EncryptedRegionInfo info)
}
public Azure.Storage.Blobs.Models.AccessTier : ValueType {
private string _value
private string P4Value
private string P6Value
private string P10Value
private string P15Value
private string P20Value
private string P30Value
private string P40Value
private string P50Value
private string P60Value
private string P70Value
private string P80Value
private string HotValue
private string CoolValue
private string ArchiveValue
private string PremiumValue
private string ColdValue
private AccessTier <P4>k__BackingField
private AccessTier <P6>k__BackingField
private AccessTier <P10>k__BackingField
private AccessTier <P15>k__BackingField
private AccessTier <P20>k__BackingField
private AccessTier <P30>k__BackingField
private AccessTier <P40>k__BackingField
private AccessTier <P50>k__BackingField
private AccessTier <P60>k__BackingField
private AccessTier <P70>k__BackingField
private AccessTier <P80>k__BackingField
private AccessTier <Hot>k__BackingField
private AccessTier <Cool>k__BackingField
private AccessTier <Archive>k__BackingField
private AccessTier <Premium>k__BackingField
private AccessTier <Cold>k__BackingField
public AccessTier P4
public AccessTier P6
public AccessTier P10
public AccessTier P15
public AccessTier P20
public AccessTier P30
public AccessTier P40
public AccessTier P50
public AccessTier P60
public AccessTier P70
public AccessTier P80
public AccessTier Hot
public AccessTier Cool
public AccessTier Archive
public AccessTier Premium
public AccessTier Cold
public void .ctor(string value)
public AccessTier get_P4()
public AccessTier get_P6()
public AccessTier get_P10()
public AccessTier get_P15()
public AccessTier get_P20()
public AccessTier get_P30()
public AccessTier get_P40()
public AccessTier get_P50()
public AccessTier get_P60()
public AccessTier get_P70()
public AccessTier get_P80()
public AccessTier get_Hot()
public AccessTier get_Cool()
public AccessTier get_Archive()
public AccessTier get_Premium()
public AccessTier get_Cold()
public bool op_Equality(AccessTier left, AccessTier right)
public bool op_Inequality(AccessTier left, AccessTier right)
public AccessTier op_Implicit(string value)
public bool Equals(object obj)
public bool Equals(AccessTier other)
public int GetHashCode()
public string ToString()
}
public Azure.Storage.Blobs.Models.AccountInfo : object {
private SkuName <SkuName>k__BackingField
private AccountKind <AccountKind>k__BackingField
private bool <IsHierarchicalNamespaceEnabled>k__BackingField
public SkuName SkuName
public AccountKind AccountKind
public bool IsHierarchicalNamespaceEnabled
public SkuName get_SkuName()
internal void set_SkuName(SkuName value)
public AccountKind get_AccountKind()
internal void set_AccountKind(AccountKind value)
public bool get_IsHierarchicalNamespaceEnabled()
internal void set_IsHierarchicalNamespaceEnabled(bool value)
}
public Azure.Storage.Blobs.Models.AccountKind : Enum {
public int value__
public AccountKind Storage
public AccountKind BlobStorage
public AccountKind StorageV2
public AccountKind FileStorage
public AccountKind BlockBlobStorage
}
internal Azure.Storage.Blobs.Models.AccountKindExtensions : object {
public string ToSerialString(AccountKind value)
public AccountKind ToAccountKind(string value)
}
public Azure.Storage.Blobs.Models.AppendBlobAppendBlockFromUriOptions : object {
private HttpRange <SourceRange>k__BackingField
private Byte[] <SourceContentHash>k__BackingField
private AppendBlobRequestConditions <DestinationConditions>k__BackingField
private AppendBlobRequestConditions <SourceConditions>k__BackingField
private HttpAuthorization <SourceAuthentication>k__BackingField
public HttpRange SourceRange
public Byte[] SourceContentHash
public AppendBlobRequestConditions DestinationConditions
public AppendBlobRequestConditions SourceConditions
public HttpAuthorization SourceAuthentication
public HttpRange get_SourceRange()
public void set_SourceRange(HttpRange value)
public Byte[] get_SourceContentHash()
public void set_SourceContentHash(Byte[] value)
public AppendBlobRequestConditions get_DestinationConditions()
public void set_DestinationConditions(AppendBlobRequestConditions value)
public AppendBlobRequestConditions get_SourceConditions()
public void set_SourceConditions(AppendBlobRequestConditions value)
public HttpAuthorization get_SourceAuthentication()
public void set_SourceAuthentication(HttpAuthorization value)
}
public Azure.Storage.Blobs.Models.AppendBlobAppendBlockOptions : object {
private AppendBlobRequestConditions <Conditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private UploadTransferValidationOptions <TransferValidation>k__BackingField
public AppendBlobRequestConditions Conditions
public IProgress`1<long> ProgressHandler
public UploadTransferValidationOptions TransferValidation
public AppendBlobRequestConditions get_Conditions()
public void set_Conditions(AppendBlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public UploadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(UploadTransferValidationOptions value)
}
public Azure.Storage.Blobs.Models.AppendBlobCreateOptions : object {
private BlobHttpHeaders <HttpHeaders>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField
private Nullable`1<bool> <HasLegalHold>k__BackingField
private AppendBlobRequestConditions <Conditions>k__BackingField
public BlobHttpHeaders HttpHeaders
public IDictionary`2<string, string> Metadata
public IDictionary`2<string, string> Tags
public BlobImmutabilityPolicy ImmutabilityPolicy
public Nullable`1<bool> HasLegalHold
public AppendBlobRequestConditions Conditions
public BlobHttpHeaders get_HttpHeaders()
public void set_HttpHeaders(BlobHttpHeaders value)
public IDictionary`2<string, string> get_Metadata()
public void set_Metadata(IDictionary`2<string, string> value)
public IDictionary`2<string, string> get_Tags()
public void set_Tags(IDictionary`2<string, string> value)
public BlobImmutabilityPolicy get_ImmutabilityPolicy()
public void set_ImmutabilityPolicy(BlobImmutabilityPolicy value)
public Nullable`1<bool> get_HasLegalHold()
public void set_HasLegalHold(Nullable`1<bool> value)
public AppendBlobRequestConditions get_Conditions()
public void set_Conditions(AppendBlobRequestConditions value)
}
public Azure.Storage.Blobs.Models.AppendBlobOpenWriteOptions : object {
private Nullable`1<long> <BufferSize>k__BackingField
private AppendBlobRequestConditions <OpenConditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private UploadTransferValidationOptions <TransferValidation>k__BackingField
public Nullable`1<long> BufferSize
public AppendBlobRequestConditions OpenConditions
public IProgress`1<long> ProgressHandler
public UploadTransferValidationOptions TransferValidation
public Nullable`1<long> get_BufferSize()
public void set_BufferSize(Nullable`1<long> value)
public AppendBlobRequestConditions get_OpenConditions()
public void set_OpenConditions(AppendBlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public UploadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(UploadTransferValidationOptions value)
}
public Azure.Storage.Blobs.Models.AppendBlobRequestConditions : BlobRequestConditions {
private Nullable`1<long> <IfAppendPositionEqual>k__BackingField
private Nullable`1<long> <IfMaxSizeLessThanOrEqual>k__BackingField
public Nullable`1<long> IfAppendPositionEqual
public Nullable`1<long> IfMaxSizeLessThanOrEqual
public Nullable`1<long> get_IfAppendPositionEqual()
public void set_IfAppendPositionEqual(Nullable`1<long> value)
public Nullable`1<long> get_IfMaxSizeLessThanOrEqual()
public void set_IfMaxSizeLessThanOrEqual(Nullable`1<long> value)
internal void AddConditions(StringBuilder conditions)
}
public Azure.Storage.Blobs.Models.ArchiveStatus : Enum {
public int value__
public ArchiveStatus RehydratePendingToHot
public ArchiveStatus RehydratePendingToCool
public ArchiveStatus RehydratePendingToCold
}
internal Azure.Storage.Blobs.Models.ArchiveStatusExtensions : object {
public string ToSerialString(ArchiveStatus value)
public ArchiveStatus ToArchiveStatus(string value)
}
internal Azure.Storage.Blobs.Models.ArrowFieldInternal : object {
private string <Type>k__BackingField
private string <Name>k__BackingField
private Nullable`1<int> <Precision>k__BackingField
private Nullable`1<int> <Scale>k__BackingField
public string Type
public string Name
public Nullable`1<int> Precision
public Nullable`1<int> Scale
public void .ctor(string type)
public string get_Type()
public string get_Name()
public void set_Name(string value)
public Nullable`1<int> get_Precision()
public void set_Precision(Nullable`1<int> value)
public Nullable`1<int> get_Scale()
public void set_Scale(Nullable`1<int> value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
}
internal Azure.Storage.Blobs.Models.ArrowTextConfigurationInternal : object {
private IList`1<ArrowFieldInternal> <Schema>k__BackingField
public IList`1<ArrowFieldInternal> Schema
public void .ctor(IEnumerable`1<ArrowFieldInternal> schema)
public IList`1<ArrowFieldInternal> get_Schema()
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
}
public Azure.Storage.Blobs.Models.BlobAccessPolicy : object {
private Nullable`1<DateTimeOffset> <PolicyStartsOn>k__BackingField
private Nullable`1<DateTimeOffset> <PolicyExpiresOn>k__BackingField
private string <Permissions>k__BackingField
public Nullable`1<DateTimeOffset> PolicyStartsOn
public Nullable`1<DateTimeOffset> PolicyExpiresOn
public string Permissions
public DateTimeOffset StartsOn
public DateTimeOffset ExpiresOn
internal void .ctor(Nullable`1<DateTimeOffset> policyStartsOn, Nullable`1<DateTimeOffset> policyExpiresOn, string permissions)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobAccessPolicy DeserializeBlobAccessPolicy(XElement element)
public Nullable`1<DateTimeOffset> get_PolicyStartsOn()
public void set_PolicyStartsOn(Nullable`1<DateTimeOffset> value)
public Nullable`1<DateTimeOffset> get_PolicyExpiresOn()
public void set_PolicyExpiresOn(Nullable`1<DateTimeOffset> value)
public string get_Permissions()
public void set_Permissions(string value)
public DateTimeOffset get_StartsOn()
public void set_StartsOn(DateTimeOffset value)
public DateTimeOffset get_ExpiresOn()
public void set_ExpiresOn(DateTimeOffset value)
}
public Azure.Storage.Blobs.Models.BlobAnalyticsLogging : object {
private string <Version>k__BackingField
private bool <Delete>k__BackingField
private bool <Read>k__BackingField
private bool <Write>k__BackingField
private BlobRetentionPolicy <RetentionPolicy>k__BackingField
public string Version
public bool Delete
public bool Read
public bool Write
public BlobRetentionPolicy RetentionPolicy
public string get_Version()
public void set_Version(string value)
public bool get_Delete()
public void set_Delete(bool value)
public bool get_Read()
public void set_Read(bool value)
public bool get_Write()
public void set_Write(bool value)
public BlobRetentionPolicy get_RetentionPolicy()
public void set_RetentionPolicy(BlobRetentionPolicy value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobAnalyticsLogging DeserializeBlobAnalyticsLogging(XElement element)
internal void .ctor(string version, bool delete, bool read, bool write, BlobRetentionPolicy retentionPolicy)
internal void .ctor(bool skipInitialization)
}
public Azure.Storage.Blobs.Models.BlobAppendInfo : object {
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private Byte[] <ContentHash>k__BackingField
private Byte[] <ContentCrc64>k__BackingField
private string <BlobAppendOffset>k__BackingField
private int <BlobCommittedBlockCount>k__BackingField
private bool <IsServerEncrypted>k__BackingField
private string <EncryptionKeySha256>k__BackingField
private string <EncryptionScope>k__BackingField
public ETag ETag
public DateTimeOffset LastModified
public Byte[] ContentHash
public Byte[] ContentCrc64
public string BlobAppendOffset
public int BlobCommittedBlockCount
public bool IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public Byte[] get_ContentHash()
internal void set_ContentHash(Byte[] value)
public Byte[] get_ContentCrc64()
internal void set_ContentCrc64(Byte[] value)
public string get_BlobAppendOffset()
internal void set_BlobAppendOffset(string value)
public int get_BlobCommittedBlockCount()
internal void set_BlobCommittedBlockCount(int value)
public bool get_IsServerEncrypted()
internal void set_IsServerEncrypted(bool value)
public string get_EncryptionKeySha256()
internal void set_EncryptionKeySha256(string value)
public string get_EncryptionScope()
internal void set_EncryptionScope(string value)
}
public Azure.Storage.Blobs.Models.BlobAudience : ValueType {
private string _value
private string _defaultAudience
private BlobAudience <DefaultAudience>k__BackingField
public BlobAudience DefaultAudience
public void .ctor(string value)
public BlobAudience get_DefaultAudience()
public BlobAudience CreateBlobServiceAccountAudience(string storageAccountName)
public bool op_Equality(BlobAudience left, BlobAudience right)
public bool op_Inequality(BlobAudience left, BlobAudience right)
public BlobAudience op_Implicit(string value)
public bool Equals(object obj)
public bool Equals(BlobAudience other)
public int GetHashCode()
public string ToString()
internal string CreateDefaultScope()
}
internal Azure.Storage.Blobs.Models.BlobBaseClientExistsClassifier : ResponseClassificationHandler {
public bool IsResourceNotFoundResponse(Response response)
public bool IsUsesCustomerSpecifiedEncryptionResponse(Response response)
public bool TryClassify(HttpMessage message, Boolean& isError)
}
public Azure.Storage.Blobs.Models.BlobBlock : ValueType {
private long <SizeLong>k__BackingField
private string <Name>k__BackingField
public long SizeLong
public int Size
public string Name
internal void .ctor(string name, long sizeLong)
internal BlobBlock DeserializeBlobBlock(XElement element)
public long get_SizeLong()
public int get_Size()
public string get_Name()
public bool Equals(BlobBlock other)
public bool Equals(object obj)
public int GetHashCode()
}
public Azure.Storage.Blobs.Models.BlobContainerAccessPolicy : object {
private PublicAccessType <BlobPublicAccess>k__BackingField
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private IEnumerable`1<BlobSignedIdentifier> <SignedIdentifiers>k__BackingField
public PublicAccessType BlobPublicAccess
public ETag ETag
public DateTimeOffset LastModified
public IEnumerable`1<BlobSignedIdentifier> SignedIdentifiers
public PublicAccessType get_BlobPublicAccess()
internal void set_BlobPublicAccess(PublicAccessType value)
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public IEnumerable`1<BlobSignedIdentifier> get_SignedIdentifiers()
internal void set_SignedIdentifiers(IEnumerable`1<BlobSignedIdentifier> value)
}
public Azure.Storage.Blobs.Models.BlobContainerEncryptionScopeOptions : object {
private string <DefaultEncryptionScope>k__BackingField
private bool <PreventEncryptionScopeOverride>k__BackingField
public string DefaultEncryptionScope
public bool PreventEncryptionScopeOverride
public string get_DefaultEncryptionScope()
public void set_DefaultEncryptionScope(string value)
public bool get_PreventEncryptionScopeOverride()
public void set_PreventEncryptionScopeOverride(bool value)
}
public Azure.Storage.Blobs.Models.BlobContainerInfo : object {
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
public ETag ETag
public DateTimeOffset LastModified
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
}
public Azure.Storage.Blobs.Models.BlobContainerItem : object {
private string <Name>k__BackingField
private Nullable`1<bool> <IsDeleted>k__BackingField
private string <VersionId>k__BackingField
private BlobContainerProperties <Properties>k__BackingField
public string Name
public Nullable`1<bool> IsDeleted
public string VersionId
public BlobContainerProperties Properties
public string get_Name()
internal void set_Name(string value)
public Nullable`1<bool> get_IsDeleted()
internal void set_IsDeleted(Nullable`1<bool> value)
public string get_VersionId()
internal void set_VersionId(string value)
public BlobContainerProperties get_Properties()
internal void set_Properties(BlobContainerProperties value)
}
public Azure.Storage.Blobs.Models.BlobContainerProperties : object {
private DateTimeOffset <LastModified>k__BackingField
private Nullable`1<LeaseStatus> <LeaseStatus>k__BackingField
private Nullable`1<LeaseState> <LeaseState>k__BackingField
private Nullable`1<LeaseDurationType> <LeaseDuration>k__BackingField
private Nullable`1<PublicAccessType> <PublicAccess>k__BackingField
private Nullable`1<bool> <HasImmutabilityPolicy>k__BackingField
private Nullable`1<bool> <HasLegalHold>k__BackingField
private string <DefaultEncryptionScope>k__BackingField
private Nullable`1<bool> <PreventEncryptionScopeOverride>k__BackingField
private Nullable`1<DateTimeOffset> <DeletedOn>k__BackingField
private Nullable`1<int> <RemainingRetentionDays>k__BackingField
private ETag <ETag>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private bool <HasImmutableStorageWithVersioning>k__BackingField
public DateTimeOffset LastModified
public Nullable`1<LeaseStatus> LeaseStatus
public Nullable`1<LeaseState> LeaseState
public Nullable`1<LeaseDurationType> LeaseDuration
public Nullable`1<PublicAccessType> PublicAccess
public Nullable`1<bool> HasImmutabilityPolicy
public Nullable`1<bool> HasLegalHold
public string DefaultEncryptionScope
public Nullable`1<bool> PreventEncryptionScopeOverride
public Nullable`1<DateTimeOffset> DeletedOn
public Nullable`1<int> RemainingRetentionDays
public ETag ETag
public IDictionary`2<string, string> Metadata
public bool HasImmutableStorageWithVersioning
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public Nullable`1<LeaseStatus> get_LeaseStatus()
internal void set_LeaseStatus(Nullable`1<LeaseStatus> value)
public Nullable`1<LeaseState> get_LeaseState()
internal void set_LeaseState(Nullable`1<LeaseState> value)
public Nullable`1<LeaseDurationType> get_LeaseDuration()
internal void set_LeaseDuration(Nullable`1<LeaseDurationType> value)
public Nullable`1<PublicAccessType> get_PublicAccess()
internal void set_PublicAccess(Nullable`1<PublicAccessType> value)
public Nullable`1<bool> get_HasImmutabilityPolicy()
internal void set_HasImmutabilityPolicy(Nullable`1<bool> value)
public Nullable`1<bool> get_HasLegalHold()
internal void set_HasLegalHold(Nullable`1<bool> value)
public string get_DefaultEncryptionScope()
internal void set_DefaultEncryptionScope(string value)
public Nullable`1<bool> get_PreventEncryptionScopeOverride()
internal void set_PreventEncryptionScopeOverride(Nullable`1<bool> value)
public Nullable`1<DateTimeOffset> get_DeletedOn()
internal void set_DeletedOn(Nullable`1<DateTimeOffset> value)
public Nullable`1<int> get_RemainingRetentionDays()
internal void set_RemainingRetentionDays(Nullable`1<int> value)
public ETag get_ETag()
internal void set_ETag(ETag value)
public IDictionary`2<string, string> get_Metadata()
internal void set_Metadata(IDictionary`2<string, string> value)
public bool get_HasImmutableStorageWithVersioning()
internal void set_HasImmutableStorageWithVersioning(bool value)
internal void .ctor(bool skipInitialization)
}
public Azure.Storage.Blobs.Models.BlobContainerStates : Enum {
public int value__
public BlobContainerStates None
public BlobContainerStates Deleted
public BlobContainerStates System
}
public Azure.Storage.Blobs.Models.BlobContainerTraits : Enum {
public int value__
public BlobContainerTraits None
public BlobContainerTraits Metadata
}
public Azure.Storage.Blobs.Models.BlobContentInfo : object {
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private Byte[] <ContentHash>k__BackingField
private string <VersionId>k__BackingField
private string <EncryptionKeySha256>k__BackingField
private string <EncryptionScope>k__BackingField
private long <BlobSequenceNumber>k__BackingField
public ETag ETag
public DateTimeOffset LastModified
public Byte[] ContentHash
public string VersionId
public string EncryptionKeySha256
public string EncryptionScope
public long BlobSequenceNumber
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public Byte[] get_ContentHash()
internal void set_ContentHash(Byte[] value)
public string get_VersionId()
internal void set_VersionId(string value)
public string get_EncryptionKeySha256()
internal void set_EncryptionKeySha256(string value)
public string get_EncryptionScope()
internal void set_EncryptionScope(string value)
public long get_BlobSequenceNumber()
internal void set_BlobSequenceNumber(long value)
}
public Azure.Storage.Blobs.Models.BlobCopyFromUriOptions : object {
private IDictionary`2<string, string> <Metadata>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
private Nullable`1<AccessTier> <AccessTier>k__BackingField
private BlobRequestConditions <SourceConditions>k__BackingField
private BlobRequestConditions <DestinationConditions>k__BackingField
private Nullable`1<RehydratePriority> <RehydratePriority>k__BackingField
private Nullable`1<bool> <ShouldSealDestination>k__BackingField
private BlobImmutabilityPolicy <DestinationImmutabilityPolicy>k__BackingField
private Nullable`1<bool> <LegalHold>k__BackingField
private HttpAuthorization <SourceAuthentication>k__BackingField
private Nullable`1<BlobCopySourceTagsMode> <CopySourceTagsMode>k__BackingField
public IDictionary`2<string, string> Metadata
public IDictionary`2<string, string> Tags
public Nullable`1<AccessTier> AccessTier
public BlobRequestConditions SourceConditions
public BlobRequestConditions DestinationConditions
public Nullable`1<RehydratePriority> RehydratePriority
public Nullable`1<bool> ShouldSealDestination
public BlobImmutabilityPolicy DestinationImmutabilityPolicy
public Nullable`1<bool> LegalHold
public HttpAuthorization SourceAuthentication
public Nullable`1<BlobCopySourceTagsMode> CopySourceTagsMode
public IDictionary`2<string, string> get_Metadata()
public void set_Metadata(IDictionary`2<string, string> value)
public IDictionary`2<string, string> get_Tags()
public void set_Tags(IDictionary`2<string, string> value)
public Nullable`1<AccessTier> get_AccessTier()
public void set_AccessTier(Nullable`1<AccessTier> value)
public BlobRequestConditions get_SourceConditions()
public void set_SourceConditions(BlobRequestConditions value)
public BlobRequestConditions get_DestinationConditions()
public void set_DestinationConditions(BlobRequestConditions value)
public Nullable`1<RehydratePriority> get_RehydratePriority()
public void set_RehydratePriority(Nullable`1<RehydratePriority> value)
public Nullable`1<bool> get_ShouldSealDestination()
public void set_ShouldSealDestination(Nullable`1<bool> value)
public BlobImmutabilityPolicy get_DestinationImmutabilityPolicy()
public void set_DestinationImmutabilityPolicy(BlobImmutabilityPolicy value)
public Nullable`1<bool> get_LegalHold()
public void set_LegalHold(Nullable`1<bool> value)
public HttpAuthorization get_SourceAuthentication()
public void set_SourceAuthentication(HttpAuthorization value)
public Nullable`1<BlobCopySourceTagsMode> get_CopySourceTagsMode()
public void set_CopySourceTagsMode(Nullable`1<BlobCopySourceTagsMode> value)
}
public Azure.Storage.Blobs.Models.BlobCopyInfo : object {
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private string <VersionId>k__BackingField
private string <CopyId>k__BackingField
private CopyStatus <CopyStatus>k__BackingField
private string <EncryptionScope>k__BackingField
public ETag ETag
public DateTimeOffset LastModified
public string VersionId
public string CopyId
public CopyStatus CopyStatus
public string EncryptionScope
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public string get_VersionId()
internal void set_VersionId(string value)
public string get_CopyId()
internal void set_CopyId(string value)
public CopyStatus get_CopyStatus()
internal void set_CopyStatus(CopyStatus value)
public string get_EncryptionScope()
internal void set_EncryptionScope(string value)
}
public Azure.Storage.Blobs.Models.BlobCopySourceTagsMode : Enum {
public int value__
public BlobCopySourceTagsMode Replace
public BlobCopySourceTagsMode Copy
}
internal Azure.Storage.Blobs.Models.BlobCopySourceTagsModeExtensions : object {
public string ToSerialString(BlobCopySourceTagsMode value)
public BlobCopySourceTagsMode ToBlobCopySourceTagsMode(string value)
}
public Azure.Storage.Blobs.Models.BlobCorsRule : object {
private string <AllowedOrigins>k__BackingField
private string <AllowedMethods>k__BackingField
private string <AllowedHeaders>k__BackingField
private string <ExposedHeaders>k__BackingField
private int <MaxAgeInSeconds>k__BackingField
public string AllowedOrigins
public string AllowedMethods
public string AllowedHeaders
public string ExposedHeaders
public int MaxAgeInSeconds
public string get_AllowedOrigins()
public void set_AllowedOrigins(string value)
public string get_AllowedMethods()
public void set_AllowedMethods(string value)
public string get_AllowedHeaders()
public void set_AllowedHeaders(string value)
public string get_ExposedHeaders()
public void set_ExposedHeaders(string value)
public int get_MaxAgeInSeconds()
public void set_MaxAgeInSeconds(int value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobCorsRule DeserializeBlobCorsRule(XElement element)
internal void .ctor(string allowedOrigins, string allowedMethods, string allowedHeaders, string exposedHeaders, int maxAgeInSeconds)
}
internal Azure.Storage.Blobs.Models.BlobDeleteType : Enum {
public int value__
public BlobDeleteType None
public BlobDeleteType Permanent
}
internal Azure.Storage.Blobs.Models.BlobDeleteTypeExtensions : object {
public string ToSerialString(BlobDeleteType value)
public BlobDeleteType ToBlobDeleteType(string value)
}
public Azure.Storage.Blobs.Models.BlobDownloadDetails : object {
private BlobType <BlobType>k__BackingField
private long <ContentLength>k__BackingField
private string <ContentType>k__BackingField
private Byte[] <ContentHash>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private string <ContentRange>k__BackingField
private ETag <ETag>k__BackingField
private string <ContentEncoding>k__BackingField
private string <CacheControl>k__BackingField
private string <ContentDisposition>k__BackingField
private string <ContentLanguage>k__BackingField
private long <BlobSequenceNumber>k__BackingField
private DateTimeOffset <CopyCompletedOn>k__BackingField
private string <CopyStatusDescription>k__BackingField
private string <CopyId>k__BackingField
private string <CopyProgress>k__BackingField
private Uri <CopySource>k__BackingField
private CopyStatus <CopyStatus>k__BackingField
private LeaseDurationType <LeaseDuration>k__BackingField
private LeaseState <LeaseState>k__BackingField
private LeaseStatus <LeaseStatus>k__BackingField
private string <AcceptRanges>k__BackingField
private int <BlobCommittedBlockCount>k__BackingField
private bool <IsServerEncrypted>k__BackingField
private string <EncryptionKeySha256>k__BackingField
private string <EncryptionScope>k__BackingField
private Byte[] <BlobContentHash>k__BackingField
private long <TagCount>k__BackingField
private string <VersionId>k__BackingField
private bool <IsSealed>k__BackingField
private IList`1<ObjectReplicationPolicy> <ObjectReplicationSourceProperties>k__BackingField
private string <ObjectReplicationDestinationPolicyId>k__BackingField
private DateTimeOffset <LastAccessed>k__BackingField
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField
private bool <HasLegalHold>k__BackingField
private DateTimeOffset <CreatedOn>k__BackingField
public BlobType BlobType
public long ContentLength
public string ContentType
public Byte[] ContentHash
public DateTimeOffset LastModified
public IDictionary`2<string, string> Metadata
public string ContentRange
public ETag ETag
public string ContentEncoding
public string CacheControl
public string ContentDisposition
public string ContentLanguage
public long BlobSequenceNumber
public DateTimeOffset CopyCompletedOn
public string CopyStatusDescription
public string CopyId
public string CopyProgress
public Uri CopySource
public CopyStatus CopyStatus
public LeaseDurationType LeaseDuration
public LeaseState LeaseState
public LeaseStatus LeaseStatus
public string AcceptRanges
public int BlobCommittedBlockCount
public bool IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public Byte[] BlobContentHash
public long TagCount
public string VersionId
public bool IsSealed
public IList`1<ObjectReplicationPolicy> ObjectReplicationSourceProperties
public string ObjectReplicationDestinationPolicyId
public DateTimeOffset LastAccessed
public BlobImmutabilityPolicy ImmutabilityPolicy
public bool HasLegalHold
public DateTimeOffset CreatedOn
public BlobType get_BlobType()
internal void set_BlobType(BlobType value)
public long get_ContentLength()
internal void set_ContentLength(long value)
public string get_ContentType()
internal void set_ContentType(string value)
public Byte[] get_ContentHash()
internal void set_ContentHash(Byte[] value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public IDictionary`2<string, string> get_Metadata()
internal void set_Metadata(IDictionary`2<string, string> value)
public string get_ContentRange()
internal void set_ContentRange(string value)
public ETag get_ETag()
internal void set_ETag(ETag value)
public string get_ContentEncoding()
internal void set_ContentEncoding(string value)
public string get_CacheControl()
internal void set_CacheControl(string value)
public string get_ContentDisposition()
internal void set_ContentDisposition(string value)
public string get_ContentLanguage()
internal void set_ContentLanguage(string value)
public long get_BlobSequenceNumber()
internal void set_BlobSequenceNumber(long value)
public DateTimeOffset get_CopyCompletedOn()
internal void set_CopyCompletedOn(DateTimeOffset value)
public string get_CopyStatusDescription()
internal void set_CopyStatusDescription(string value)
public string get_CopyId()
internal void set_CopyId(string value)
public string get_CopyProgress()
internal void set_CopyProgress(string value)
public Uri get_CopySource()
internal void set_CopySource(Uri value)
public CopyStatus get_CopyStatus()
internal void set_CopyStatus(CopyStatus value)
public LeaseDurationType get_LeaseDuration()
internal void set_LeaseDuration(LeaseDurationType value)
public LeaseState get_LeaseState()
internal void set_LeaseState(LeaseState value)
public LeaseStatus get_LeaseStatus()
internal void set_LeaseStatus(LeaseStatus value)
public string get_AcceptRanges()
internal void set_AcceptRanges(string value)
public int get_BlobCommittedBlockCount()
internal void set_BlobCommittedBlockCount(int value)
public bool get_IsServerEncrypted()
internal void set_IsServerEncrypted(bool value)
public string get_EncryptionKeySha256()
internal void set_EncryptionKeySha256(string value)
public string get_EncryptionScope()
internal void set_EncryptionScope(string value)
public Byte[] get_BlobContentHash()
internal void set_BlobContentHash(Byte[] value)
public long get_TagCount()
internal void set_TagCount(long value)
public string get_VersionId()
internal void set_VersionId(string value)
public bool get_IsSealed()
internal void set_IsSealed(bool value)
public IList`1<ObjectReplicationPolicy> get_ObjectReplicationSourceProperties()
internal void set_ObjectReplicationSourceProperties(IList`1<ObjectReplicationPolicy> value)
public string get_ObjectReplicationDestinationPolicyId()
internal void set_ObjectReplicationDestinationPolicyId(string value)
public DateTimeOffset get_LastAccessed()
internal void set_LastAccessed(DateTimeOffset value)
public BlobImmutabilityPolicy get_ImmutabilityPolicy()
internal void set_ImmutabilityPolicy(BlobImmutabilityPolicy value)
public bool get_HasLegalHold()
internal void set_HasLegalHold(bool value)
public DateTimeOffset get_CreatedOn()
internal void set_CreatedOn(DateTimeOffset value)
}
public Azure.Storage.Blobs.Models.BlobDownloadInfo : object {
private BlobType <BlobType>k__BackingField
private long <ContentLength>k__BackingField
private Stream <Content>k__BackingField
private string <ContentType>k__BackingField
private Byte[] <ContentHash>k__BackingField
private BlobDownloadDetails <Details>k__BackingField
public BlobType BlobType
public long ContentLength
public Stream Content
public string ContentType
public Byte[] ContentHash
public BlobDownloadDetails Details
public BlobType get_BlobType()
internal void set_BlobType(BlobType value)
public long get_ContentLength()
internal void set_ContentLength(long value)
public Stream get_Content()
internal void set_Content(Stream value)
public string get_ContentType()
internal void set_ContentType(string value)
public Byte[] get_ContentHash()
internal void set_ContentHash(Byte[] value)
public BlobDownloadDetails get_Details()
internal void set_Details(BlobDownloadDetails value)
public void Dispose()
}
public Azure.Storage.Blobs.Models.BlobDownloadOptions : object {
private HttpRange <Range>k__BackingField
private BlobRequestConditions <Conditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private DownloadTransferValidationOptions <TransferValidation>k__BackingField
public HttpRange Range
public BlobRequestConditions Conditions
public IProgress`1<long> ProgressHandler
public DownloadTransferValidationOptions TransferValidation
public HttpRange get_Range()
public void set_Range(HttpRange value)
public BlobRequestConditions get_Conditions()
public void set_Conditions(BlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public DownloadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(DownloadTransferValidationOptions value)
}
public Azure.Storage.Blobs.Models.BlobDownloadResult : object {
private BlobDownloadDetails <Details>k__BackingField
private BinaryData <Content>k__BackingField
public BlobDownloadDetails Details
public BinaryData Content
public BlobDownloadDetails get_Details()
internal void set_Details(BlobDownloadDetails value)
public BinaryData get_Content()
internal void set_Content(BinaryData value)
}
public Azure.Storage.Blobs.Models.BlobDownloadStreamingResult : object {
private BlobDownloadDetails <Details>k__BackingField
private Stream <Content>k__BackingField
public BlobDownloadDetails Details
public Stream Content
public BlobDownloadDetails get_Details()
internal void set_Details(BlobDownloadDetails value)
public Stream get_Content()
internal void set_Content(Stream value)
public void Dispose()
}
public Azure.Storage.Blobs.Models.BlobDownloadToOptions : object {
private BlobRequestConditions <Conditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private StorageTransferOptions <TransferOptions>k__BackingField
private DownloadTransferValidationOptions <TransferValidation>k__BackingField
public BlobRequestConditions Conditions
public IProgress`1<long> ProgressHandler
public StorageTransferOptions TransferOptions
public DownloadTransferValidationOptions TransferValidation
public BlobRequestConditions get_Conditions()
public void set_Conditions(BlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public StorageTransferOptions get_TransferOptions()
public void set_TransferOptions(StorageTransferOptions value)
public DownloadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(DownloadTransferValidationOptions value)
}
public Azure.Storage.Blobs.Models.BlobErrorCode : ValueType {
private string _value
private string AccountAlreadyExistsValue
private string AccountBeingCreatedValue
private string AccountIsDisabledValue
private string AuthenticationFailedValue
private string AuthorizationFailureValue
private string ConditionHeadersNotSupportedValue
private string ConditionNotMetValue
private string EmptyMetadataKeyValue
private string InsufficientAccountPermissionsValue
private string InternalErrorValue
private string InvalidAuthenticationInfoValue
private string InvalidHeaderValueValue
private string InvalidHttpVerbValue
private string InvalidInputValue
private string InvalidMd5Value
private string InvalidMetadataValue
private string InvalidQueryParameterValueValue
private string InvalidRangeValue
private string InvalidResourceNameValue
private string InvalidUriValue
private string InvalidXmlDocumentValue
private string InvalidXmlNodeValueValue
private string Md5MismatchValue
private string MetadataTooLargeValue
private string MissingContentLengthHeaderValue
private string MissingRequiredQueryParameterValue
private string MissingRequiredHeaderValue
private string MissingRequiredXmlNodeValue
private string MultipleConditionHeadersNotSupportedValue
private string OperationTimedOutValue
private string OutOfRangeInputValue
private string OutOfRangeQueryParameterValueValue
private string RequestBodyTooLargeValue
private string ResourceTypeMismatchValue
private string RequestUrlFailedToParseValue
private string ResourceAlreadyExistsValue
private string ResourceNotFoundValue
private string ServerBusyValue
private string UnsupportedHeaderValue
private string UnsupportedXmlNodeValue
private string UnsupportedQueryParameterValue
private string UnsupportedHttpVerbValue
private string AppendPositionConditionNotMetValue
private string BlobAlreadyExistsValue
private string BlobImmutableDueToPolicyValue
private string BlobNotFoundValue
private string BlobOverwrittenValue
private string BlobTierInadequateForContentLengthValue
private string BlobUsesCustomerSpecifiedEncryptionValue
private string BlockCountExceedsLimitValue
private string BlockListTooLongValue
private string CannotChangeToLowerTierValue
private string CannotVerifyCopySourceValue
private string ContainerAlreadyExistsValue
private string ContainerBeingDeletedValue
private string ContainerDisabledValue
private string ContainerNotFoundValue
private string ContentLengthLargerThanTierLimitValue
private string CopyAcrossAccountsNotSupportedValue
private string CopyIdMismatchValue
private string FeatureVersionMismatchValue
private string IncrementalCopyBlobMismatchValue
private string IncrementalCopyOfEarlierVersionSnapshotNotAllowedValue
private string IncrementalCopySourceMustBeSnapshotValue
private string InfiniteLeaseDurationRequiredValue
private string InvalidBlobOrBlockValue
private string InvalidBlobTierValue
private string InvalidBlobTypeValue
private string InvalidBlockIdValue
private string InvalidBlockListValue
private string InvalidOperationValue
private string InvalidPageRangeValue
private string InvalidSourceBlobTypeValue
private string InvalidSourceBlobUrlValue
private string InvalidVersionForPageBlobOperationValue
private string LeaseAlreadyPresentValue
private string LeaseAlreadyBrokenValue
private string LeaseIdMismatchWithBlobOperationValue
private string LeaseIdMismatchWithContainerOperationValue
private string LeaseIdMismatchWithLeaseOperationValue
private string LeaseIdMissingValue
private string LeaseIsBreakingAndCannotBeAcquiredValue
private string LeaseIsBreakingAndCannotBeChangedValue
private string LeaseIsBrokenAndCannotBeRenewedValue
private string LeaseLostValue
private string LeaseNotPresentWithBlobOperationValue
private string LeaseNotPresentWithContainerOperationValue
private string LeaseNotPresentWithLeaseOperationValue
private string MaxBlobSizeConditionNotMetValue
private string NoAuthenticationInformationValue
private string NoPendingCopyOperationValue
private string OperationNotAllowedOnIncrementalCopyBlobValue
private string PendingCopyOperationValue
private string PreviousSnapshotCannotBeNewerValue
private string PreviousSnapshotNotFoundValue
private string PreviousSnapshotOperationNotSupportedValue
private string SequenceNumberConditionNotMetValue
private string SequenceNumberIncrementTooLargeValue
private string SnapshotCountExceededValue
private string SnapshotOperationRateExceededValue
private string SnapshotsPresentValue
private string SourceConditionNotMetValue
private string SystemInUseValue
private string TargetConditionNotMetValue
private string UnauthorizedBlobOverwriteValue
private string BlobBeingRehydratedValue
private string BlobArchivedValue
private string BlobNotArchivedValue
private string AuthorizationSourceIPMismatchValue
private string AuthorizationProtocolMismatchValue
private string AuthorizationPermissionMismatchValue
private string AuthorizationServiceMismatchValue
private string AuthorizationResourceTypeMismatchValue
private BlobErrorCode <AccountAlreadyExists>k__BackingField
private BlobErrorCode <AccountBeingCreated>k__BackingField
private BlobErrorCode <AccountIsDisabled>k__BackingField
private BlobErrorCode <AuthenticationFailed>k__BackingField
private BlobErrorCode <AuthorizationFailure>k__BackingField
private BlobErrorCode <ConditionHeadersNotSupported>k__BackingField
private BlobErrorCode <ConditionNotMet>k__BackingField
private BlobErrorCode <EmptyMetadataKey>k__BackingField
private BlobErrorCode <InsufficientAccountPermissions>k__BackingField
private BlobErrorCode <InternalError>k__BackingField
private BlobErrorCode <InvalidAuthenticationInfo>k__BackingField
private BlobErrorCode <InvalidHeaderValue>k__BackingField
private BlobErrorCode <InvalidHttpVerb>k__BackingField
private BlobErrorCode <InvalidInput>k__BackingField
private BlobErrorCode <InvalidMd5>k__BackingField
private BlobErrorCode <InvalidMetadata>k__BackingField
private BlobErrorCode <InvalidQueryParameterValue>k__BackingField
private BlobErrorCode <InvalidRange>k__BackingField
private BlobErrorCode <InvalidResourceName>k__BackingField
private BlobErrorCode <InvalidUri>k__BackingField
private BlobErrorCode <InvalidXmlDocument>k__BackingField
private BlobErrorCode <InvalidXmlNodeValue>k__BackingField
private BlobErrorCode <Md5Mismatch>k__BackingField
private BlobErrorCode <MetadataTooLarge>k__BackingField
private BlobErrorCode <MissingContentLengthHeader>k__BackingField
private BlobErrorCode <MissingRequiredQueryParameter>k__BackingField
private BlobErrorCode <MissingRequiredHeader>k__BackingField
private BlobErrorCode <MissingRequiredXmlNode>k__BackingField
private BlobErrorCode <MultipleConditionHeadersNotSupported>k__BackingField
private BlobErrorCode <OperationTimedOut>k__BackingField
private BlobErrorCode <OutOfRangeInput>k__BackingField
private BlobErrorCode <OutOfRangeQueryParameterValue>k__BackingField
private BlobErrorCode <RequestBodyTooLarge>k__BackingField
private BlobErrorCode <ResourceTypeMismatch>k__BackingField
private BlobErrorCode <RequestUrlFailedToParse>k__BackingField
private BlobErrorCode <ResourceAlreadyExists>k__BackingField
private BlobErrorCode <ResourceNotFound>k__BackingField
private BlobErrorCode <ServerBusy>k__BackingField
private BlobErrorCode <UnsupportedHeader>k__BackingField
private BlobErrorCode <UnsupportedXmlNode>k__BackingField
private BlobErrorCode <UnsupportedQueryParameter>k__BackingField
private BlobErrorCode <UnsupportedHttpVerb>k__BackingField
private BlobErrorCode <AppendPositionConditionNotMet>k__BackingField
private BlobErrorCode <BlobAlreadyExists>k__BackingField
private BlobErrorCode <BlobImmutableDueToPolicy>k__BackingField
private BlobErrorCode <BlobNotFound>k__BackingField
private BlobErrorCode <BlobOverwritten>k__BackingField
private BlobErrorCode <BlobTierInadequateForContentLength>k__BackingField
private BlobErrorCode <BlobUsesCustomerSpecifiedEncryption>k__BackingField
private BlobErrorCode <BlockCountExceedsLimit>k__BackingField
private BlobErrorCode <BlockListTooLong>k__BackingField
private BlobErrorCode <CannotChangeToLowerTier>k__BackingField
private BlobErrorCode <CannotVerifyCopySource>k__BackingField
private BlobErrorCode <ContainerAlreadyExists>k__BackingField
private BlobErrorCode <ContainerBeingDeleted>k__BackingField
private BlobErrorCode <ContainerDisabled>k__BackingField
private BlobErrorCode <ContainerNotFound>k__BackingField
private BlobErrorCode <ContentLengthLargerThanTierLimit>k__BackingField
private BlobErrorCode <CopyAcrossAccountsNotSupported>k__BackingField
private BlobErrorCode <CopyIdMismatch>k__BackingField
private BlobErrorCode <FeatureVersionMismatch>k__BackingField
private BlobErrorCode <IncrementalCopyBlobMismatch>k__BackingField
private BlobErrorCode <IncrementalCopyOfEarlierVersionSnapshotNotAllowed>k__BackingField
private BlobErrorCode <IncrementalCopySourceMustBeSnapshot>k__BackingField
private BlobErrorCode <InfiniteLeaseDurationRequired>k__BackingField
private BlobErrorCode <InvalidBlobOrBlock>k__BackingField
private BlobErrorCode <InvalidBlobTier>k__BackingField
private BlobErrorCode <InvalidBlobType>k__BackingField
private BlobErrorCode <InvalidBlockId>k__BackingField
private BlobErrorCode <InvalidBlockList>k__BackingField
private BlobErrorCode <InvalidOperation>k__BackingField
private BlobErrorCode <InvalidPageRange>k__BackingField
private BlobErrorCode <InvalidSourceBlobType>k__BackingField
private BlobErrorCode <InvalidSourceBlobUrl>k__BackingField
private BlobErrorCode <InvalidVersionForPageBlobOperation>k__BackingField
private BlobErrorCode <LeaseAlreadyPresent>k__BackingField
private BlobErrorCode <LeaseAlreadyBroken>k__BackingField
private BlobErrorCode <LeaseIdMismatchWithBlobOperation>k__BackingField
private BlobErrorCode <LeaseIdMismatchWithContainerOperation>k__BackingField
private BlobErrorCode <LeaseIdMismatchWithLeaseOperation>k__BackingField
private BlobErrorCode <LeaseIdMissing>k__BackingField
private BlobErrorCode <LeaseIsBreakingAndCannotBeAcquired>k__BackingField
private BlobErrorCode <LeaseIsBreakingAndCannotBeChanged>k__BackingField
private BlobErrorCode <LeaseIsBrokenAndCannotBeRenewed>k__BackingField
private BlobErrorCode <LeaseLost>k__BackingField
private BlobErrorCode <LeaseNotPresentWithBlobOperation>k__BackingField
private BlobErrorCode <LeaseNotPresentWithContainerOperation>k__BackingField
private BlobErrorCode <LeaseNotPresentWithLeaseOperation>k__BackingField
private BlobErrorCode <MaxBlobSizeConditionNotMet>k__BackingField
private BlobErrorCode <NoAuthenticationInformation>k__BackingField
private BlobErrorCode <NoPendingCopyOperation>k__BackingField
private BlobErrorCode <OperationNotAllowedOnIncrementalCopyBlob>k__BackingField
private BlobErrorCode <PendingCopyOperation>k__BackingField
private BlobErrorCode <PreviousSnapshotCannotBeNewer>k__BackingField
private BlobErrorCode <PreviousSnapshotNotFound>k__BackingField
private BlobErrorCode <PreviousSnapshotOperationNotSupported>k__BackingField
private BlobErrorCode <SequenceNumberConditionNotMet>k__BackingField
private BlobErrorCode <SequenceNumberIncrementTooLarge>k__BackingField
private BlobErrorCode <SnapshotCountExceeded>k__BackingField
private BlobErrorCode <SnapshotOperationRateExceeded>k__BackingField
private BlobErrorCode <SnapshotsPresent>k__BackingField
private BlobErrorCode <SourceConditionNotMet>k__BackingField
private BlobErrorCode <SystemInUse>k__BackingField
private BlobErrorCode <TargetConditionNotMet>k__BackingField
private BlobErrorCode <UnauthorizedBlobOverwrite>k__BackingField
private BlobErrorCode <BlobBeingRehydrated>k__BackingField
private BlobErrorCode <BlobArchived>k__BackingField
private BlobErrorCode <BlobNotArchived>k__BackingField
private BlobErrorCode <AuthorizationSourceIPMismatch>k__BackingField
private BlobErrorCode <AuthorizationProtocolMismatch>k__BackingField
private BlobErrorCode <AuthorizationPermissionMismatch>k__BackingField
private BlobErrorCode <AuthorizationServiceMismatch>k__BackingField
private BlobErrorCode <AuthorizationResourceTypeMismatch>k__BackingField
private string SnaphotOperationRateExceededValue
private string IncrementalCopyOfEralierVersionSnapshotNotAllowedValue
private BlobErrorCode <SnaphotOperationRateExceeded>k__BackingField
private BlobErrorCode <IncrementalCopyOfEralierVersionSnapshotNotAllowed>k__BackingField
public BlobErrorCode AccountAlreadyExists
public BlobErrorCode AccountBeingCreated
public BlobErrorCode AccountIsDisabled
public BlobErrorCode AuthenticationFailed
public BlobErrorCode AuthorizationFailure
public BlobErrorCode ConditionHeadersNotSupported
public BlobErrorCode ConditionNotMet
public BlobErrorCode EmptyMetadataKey
public BlobErrorCode InsufficientAccountPermissions
public BlobErrorCode InternalError
public BlobErrorCode InvalidAuthenticationInfo
public BlobErrorCode InvalidHeaderValue
public BlobErrorCode InvalidHttpVerb
public BlobErrorCode InvalidInput
public BlobErrorCode InvalidMd5
public BlobErrorCode InvalidMetadata
public BlobErrorCode InvalidQueryParameterValue
public BlobErrorCode InvalidRange
public BlobErrorCode InvalidResourceName
public BlobErrorCode InvalidUri
public BlobErrorCode InvalidXmlDocument
public BlobErrorCode InvalidXmlNodeValue
public BlobErrorCode Md5Mismatch
public BlobErrorCode MetadataTooLarge
public BlobErrorCode MissingContentLengthHeader
public BlobErrorCode MissingRequiredQueryParameter
public BlobErrorCode MissingRequiredHeader
public BlobErrorCode MissingRequiredXmlNode
public BlobErrorCode MultipleConditionHeadersNotSupported
public BlobErrorCode OperationTimedOut
public BlobErrorCode OutOfRangeInput
public BlobErrorCode OutOfRangeQueryParameterValue
public BlobErrorCode RequestBodyTooLarge
public BlobErrorCode ResourceTypeMismatch
public BlobErrorCode RequestUrlFailedToParse
public BlobErrorCode ResourceAlreadyExists
public BlobErrorCode ResourceNotFound
public BlobErrorCode ServerBusy
public BlobErrorCode UnsupportedHeader
public BlobErrorCode UnsupportedXmlNode
public BlobErrorCode UnsupportedQueryParameter
public BlobErrorCode UnsupportedHttpVerb
public BlobErrorCode AppendPositionConditionNotMet
public BlobErrorCode BlobAlreadyExists
public BlobErrorCode BlobImmutableDueToPolicy
public BlobErrorCode BlobNotFound
public BlobErrorCode BlobOverwritten
public BlobErrorCode BlobTierInadequateForContentLength
public BlobErrorCode BlobUsesCustomerSpecifiedEncryption
public BlobErrorCode BlockCountExceedsLimit
public BlobErrorCode BlockListTooLong
public BlobErrorCode CannotChangeToLowerTier
public BlobErrorCode CannotVerifyCopySource
public BlobErrorCode ContainerAlreadyExists
public BlobErrorCode ContainerBeingDeleted
public BlobErrorCode ContainerDisabled
public BlobErrorCode ContainerNotFound
public BlobErrorCode ContentLengthLargerThanTierLimit
public BlobErrorCode CopyAcrossAccountsNotSupported
public BlobErrorCode CopyIdMismatch
public BlobErrorCode FeatureVersionMismatch
public BlobErrorCode IncrementalCopyBlobMismatch
public BlobErrorCode IncrementalCopyOfEarlierVersionSnapshotNotAllowed
public BlobErrorCode IncrementalCopySourceMustBeSnapshot
public BlobErrorCode InfiniteLeaseDurationRequired
public BlobErrorCode InvalidBlobOrBlock
public BlobErrorCode InvalidBlobTier
public BlobErrorCode InvalidBlobType
public BlobErrorCode InvalidBlockId
public BlobErrorCode InvalidBlockList
public BlobErrorCode InvalidOperation
public BlobErrorCode InvalidPageRange
public BlobErrorCode InvalidSourceBlobType
public BlobErrorCode InvalidSourceBlobUrl
public BlobErrorCode InvalidVersionForPageBlobOperation
public BlobErrorCode LeaseAlreadyPresent
public BlobErrorCode LeaseAlreadyBroken
public BlobErrorCode LeaseIdMismatchWithBlobOperation
public BlobErrorCode LeaseIdMismatchWithContainerOperation
public BlobErrorCode LeaseIdMismatchWithLeaseOperation
public BlobErrorCode LeaseIdMissing
public BlobErrorCode LeaseIsBreakingAndCannotBeAcquired
public BlobErrorCode LeaseIsBreakingAndCannotBeChanged
public BlobErrorCode LeaseIsBrokenAndCannotBeRenewed
public BlobErrorCode LeaseLost
public BlobErrorCode LeaseNotPresentWithBlobOperation
public BlobErrorCode LeaseNotPresentWithContainerOperation
public BlobErrorCode LeaseNotPresentWithLeaseOperation
public BlobErrorCode MaxBlobSizeConditionNotMet
public BlobErrorCode NoAuthenticationInformation
public BlobErrorCode NoPendingCopyOperation
public BlobErrorCode OperationNotAllowedOnIncrementalCopyBlob
public BlobErrorCode PendingCopyOperation
public BlobErrorCode PreviousSnapshotCannotBeNewer
public BlobErrorCode PreviousSnapshotNotFound
public BlobErrorCode PreviousSnapshotOperationNotSupported
public BlobErrorCode SequenceNumberConditionNotMet
public BlobErrorCode SequenceNumberIncrementTooLarge
public BlobErrorCode SnapshotCountExceeded
public BlobErrorCode SnapshotOperationRateExceeded
public BlobErrorCode SnapshotsPresent
public BlobErrorCode SourceConditionNotMet
public BlobErrorCode SystemInUse
public BlobErrorCode TargetConditionNotMet
public BlobErrorCode UnauthorizedBlobOverwrite
public BlobErrorCode BlobBeingRehydrated
public BlobErrorCode BlobArchived
public BlobErrorCode BlobNotArchived
public BlobErrorCode AuthorizationSourceIPMismatch
public BlobErrorCode AuthorizationProtocolMismatch
public BlobErrorCode AuthorizationPermissionMismatch
public BlobErrorCode AuthorizationServiceMismatch
public BlobErrorCode AuthorizationResourceTypeMismatch
public BlobErrorCode SnaphotOperationRateExceeded
public BlobErrorCode IncrementalCopyOfEralierVersionSnapshotNotAllowed
public void .ctor(string value)
public BlobErrorCode get_AccountAlreadyExists()
public BlobErrorCode get_AccountBeingCreated()
public BlobErrorCode get_AccountIsDisabled()
public BlobErrorCode get_AuthenticationFailed()
public BlobErrorCode get_AuthorizationFailure()
public BlobErrorCode get_ConditionHeadersNotSupported()
public BlobErrorCode get_ConditionNotMet()
public BlobErrorCode get_EmptyMetadataKey()
public BlobErrorCode get_InsufficientAccountPermissions()
public BlobErrorCode get_InternalError()
public BlobErrorCode get_InvalidAuthenticationInfo()
public BlobErrorCode get_InvalidHeaderValue()
public BlobErrorCode get_InvalidHttpVerb()
public BlobErrorCode get_InvalidInput()
public BlobErrorCode get_InvalidMd5()
public BlobErrorCode get_InvalidMetadata()
public BlobErrorCode get_InvalidQueryParameterValue()
public BlobErrorCode get_InvalidRange()
public BlobErrorCode get_InvalidResourceName()
public BlobErrorCode get_InvalidUri()
public BlobErrorCode get_InvalidXmlDocument()
public BlobErrorCode get_InvalidXmlNodeValue()
public BlobErrorCode get_Md5Mismatch()
public BlobErrorCode get_MetadataTooLarge()
public BlobErrorCode get_MissingContentLengthHeader()
public BlobErrorCode get_MissingRequiredQueryParameter()
public BlobErrorCode get_MissingRequiredHeader()
public BlobErrorCode get_MissingRequiredXmlNode()
public BlobErrorCode get_MultipleConditionHeadersNotSupported()
public BlobErrorCode get_OperationTimedOut()
public BlobErrorCode get_OutOfRangeInput()
public BlobErrorCode get_OutOfRangeQueryParameterValue()
public BlobErrorCode get_RequestBodyTooLarge()
public BlobErrorCode get_ResourceTypeMismatch()
public BlobErrorCode get_RequestUrlFailedToParse()
public BlobErrorCode get_ResourceAlreadyExists()
public BlobErrorCode get_ResourceNotFound()
public BlobErrorCode get_ServerBusy()
public BlobErrorCode get_UnsupportedHeader()
public BlobErrorCode get_UnsupportedXmlNode()
public BlobErrorCode get_UnsupportedQueryParameter()
public BlobErrorCode get_UnsupportedHttpVerb()
public BlobErrorCode get_AppendPositionConditionNotMet()
public BlobErrorCode get_BlobAlreadyExists()
public BlobErrorCode get_BlobImmutableDueToPolicy()
public BlobErrorCode get_BlobNotFound()
public BlobErrorCode get_BlobOverwritten()
public BlobErrorCode get_BlobTierInadequateForContentLength()
public BlobErrorCode get_BlobUsesCustomerSpecifiedEncryption()
public BlobErrorCode get_BlockCountExceedsLimit()
public BlobErrorCode get_BlockListTooLong()
public BlobErrorCode get_CannotChangeToLowerTier()
public BlobErrorCode get_CannotVerifyCopySource()
public BlobErrorCode get_ContainerAlreadyExists()
public BlobErrorCode get_ContainerBeingDeleted()
public BlobErrorCode get_ContainerDisabled()
public BlobErrorCode get_ContainerNotFound()
public BlobErrorCode get_ContentLengthLargerThanTierLimit()
public BlobErrorCode get_CopyAcrossAccountsNotSupported()
public BlobErrorCode get_CopyIdMismatch()
public BlobErrorCode get_FeatureVersionMismatch()
public BlobErrorCode get_IncrementalCopyBlobMismatch()
public BlobErrorCode get_IncrementalCopyOfEarlierVersionSnapshotNotAllowed()
public BlobErrorCode get_IncrementalCopySourceMustBeSnapshot()
public BlobErrorCode get_InfiniteLeaseDurationRequired()
public BlobErrorCode get_InvalidBlobOrBlock()
public BlobErrorCode get_InvalidBlobTier()
public BlobErrorCode get_InvalidBlobType()
public BlobErrorCode get_InvalidBlockId()
public BlobErrorCode get_InvalidBlockList()
public BlobErrorCode get_InvalidOperation()
public BlobErrorCode get_InvalidPageRange()
public BlobErrorCode get_InvalidSourceBlobType()
public BlobErrorCode get_InvalidSourceBlobUrl()
public BlobErrorCode get_InvalidVersionForPageBlobOperation()
public BlobErrorCode get_LeaseAlreadyPresent()
public BlobErrorCode get_LeaseAlreadyBroken()
public BlobErrorCode get_LeaseIdMismatchWithBlobOperation()
public BlobErrorCode get_LeaseIdMismatchWithContainerOperation()
public BlobErrorCode get_LeaseIdMismatchWithLeaseOperation()
public BlobErrorCode get_LeaseIdMissing()
public BlobErrorCode get_LeaseIsBreakingAndCannotBeAcquired()
public BlobErrorCode get_LeaseIsBreakingAndCannotBeChanged()
public BlobErrorCode get_LeaseIsBrokenAndCannotBeRenewed()
public BlobErrorCode get_LeaseLost()
public BlobErrorCode get_LeaseNotPresentWithBlobOperation()
public BlobErrorCode get_LeaseNotPresentWithContainerOperation()
public BlobErrorCode get_LeaseNotPresentWithLeaseOperation()
public BlobErrorCode get_MaxBlobSizeConditionNotMet()
public BlobErrorCode get_NoAuthenticationInformation()
public BlobErrorCode get_NoPendingCopyOperation()
public BlobErrorCode get_OperationNotAllowedOnIncrementalCopyBlob()
public BlobErrorCode get_PendingCopyOperation()
public BlobErrorCode get_PreviousSnapshotCannotBeNewer()
public BlobErrorCode get_PreviousSnapshotNotFound()
public BlobErrorCode get_PreviousSnapshotOperationNotSupported()
public BlobErrorCode get_SequenceNumberConditionNotMet()
public BlobErrorCode get_SequenceNumberIncrementTooLarge()
public BlobErrorCode get_SnapshotCountExceeded()
public BlobErrorCode get_SnapshotOperationRateExceeded()
public BlobErrorCode get_SnapshotsPresent()
public BlobErrorCode get_SourceConditionNotMet()
public BlobErrorCode get_SystemInUse()
public BlobErrorCode get_TargetConditionNotMet()
public BlobErrorCode get_UnauthorizedBlobOverwrite()
public BlobErrorCode get_BlobBeingRehydrated()
public BlobErrorCode get_BlobArchived()
public BlobErrorCode get_BlobNotArchived()
public BlobErrorCode get_AuthorizationSourceIPMismatch()
public BlobErrorCode get_AuthorizationProtocolMismatch()
public BlobErrorCode get_AuthorizationPermissionMismatch()
public BlobErrorCode get_AuthorizationServiceMismatch()
public BlobErrorCode get_AuthorizationResourceTypeMismatch()
public bool op_Equality(BlobErrorCode left, BlobErrorCode right)
public bool op_Inequality(BlobErrorCode left, BlobErrorCode right)
public BlobErrorCode op_Implicit(string value)
public bool Equals(object obj)
public bool Equals(BlobErrorCode other)
public int GetHashCode()
public string ToString()
public BlobErrorCode get_SnaphotOperationRateExceeded()
public BlobErrorCode get_IncrementalCopyOfEralierVersionSnapshotNotAllowed()
}
internal Azure.Storage.Blobs.Models.BlobExpiryOptions : ValueType {
private string _value
private string NeverExpireValue
private string RelativeToCreationValue
private string RelativeToNowValue
private string AbsoluteValue
private BlobExpiryOptions <NeverExpire>k__BackingField
private BlobExpiryOptions <RelativeToCreation>k__BackingField
private BlobExpiryOptions <RelativeToNow>k__BackingField
private BlobExpiryOptions <Absolute>k__BackingField
public BlobExpiryOptions NeverExpire
public BlobExpiryOptions RelativeToCreation
public BlobExpiryOptions RelativeToNow
public BlobExpiryOptions Absolute
public void .ctor(string value)
public BlobExpiryOptions get_NeverExpire()
public BlobExpiryOptions get_RelativeToCreation()
public BlobExpiryOptions get_RelativeToNow()
public BlobExpiryOptions get_Absolute()
public bool op_Equality(BlobExpiryOptions left, BlobExpiryOptions right)
public bool op_Inequality(BlobExpiryOptions left, BlobExpiryOptions right)
public BlobExpiryOptions op_Implicit(string value)
public bool Equals(object obj)
public bool Equals(BlobExpiryOptions other)
public int GetHashCode()
public string ToString()
}
internal Azure.Storage.Blobs.Models.BlobFlatListSegment : object {
private IReadOnlyList`1<BlobItemInternal> <BlobItems>k__BackingField
public IReadOnlyList`1<BlobItemInternal> BlobItems
internal void .ctor(IEnumerable`1<BlobItemInternal> blobItems)
internal void .ctor(IReadOnlyList`1<BlobItemInternal> blobItems)
public IReadOnlyList`1<BlobItemInternal> get_BlobItems()
internal BlobFlatListSegment DeserializeBlobFlatListSegment(XElement element)
}
public Azure.Storage.Blobs.Models.BlobGeoReplication : object {
private BlobGeoReplicationStatus <Status>k__BackingField
private Nullable`1<DateTimeOffset> <LastSyncedOn>k__BackingField
public BlobGeoReplicationStatus Status
public Nullable`1<DateTimeOffset> LastSyncedOn
internal void .ctor(BlobGeoReplicationStatus status, Nullable`1<DateTimeOffset> lastSyncedOn)
public BlobGeoReplicationStatus get_Status()
internal BlobGeoReplication DeserializeBlobGeoReplication(XElement element)
public Nullable`1<DateTimeOffset> get_LastSyncedOn()
internal void set_LastSyncedOn(Nullable`1<DateTimeOffset> value)
}
public Azure.Storage.Blobs.Models.BlobGeoReplicationStatus : Enum {
public int value__
public BlobGeoReplicationStatus Live
public BlobGeoReplicationStatus Bootstrap
public BlobGeoReplicationStatus Unavailable
}
internal Azure.Storage.Blobs.Models.BlobGeoReplicationStatusExtensions : object {
public string ToSerialString(BlobGeoReplicationStatus value)
public BlobGeoReplicationStatus ToBlobGeoReplicationStatus(string value)
}
public Azure.Storage.Blobs.Models.BlobHierarchyItem : object {
private string <Prefix>k__BackingField
private BlobItem <Blob>k__BackingField
public string Prefix
public BlobItem Blob
public bool IsPrefix
public bool IsBlob
public string get_Prefix()
internal void set_Prefix(string value)
public BlobItem get_Blob()
internal void set_Blob(BlobItem value)
public bool get_IsPrefix()
public bool get_IsBlob()
internal void .ctor(string prefix, BlobItem blob)
}
internal Azure.Storage.Blobs.Models.BlobHierarchyListSegment : object {
private IReadOnlyList`1<BlobPrefix> <BlobPrefixes>k__BackingField
private IReadOnlyList`1<BlobItemInternal> <BlobItems>k__BackingField
public IReadOnlyList`1<BlobPrefix> BlobPrefixes
public IReadOnlyList`1<BlobItemInternal> BlobItems
internal void .ctor(IEnumerable`1<BlobItemInternal> blobItems)
internal void .ctor(IReadOnlyList`1<BlobPrefix> blobPrefixes, IReadOnlyList`1<BlobItemInternal> blobItems)
public IReadOnlyList`1<BlobPrefix> get_BlobPrefixes()
public IReadOnlyList`1<BlobItemInternal> get_BlobItems()
internal BlobHierarchyListSegment DeserializeBlobHierarchyListSegment(XElement element)
}
public Azure.Storage.Blobs.Models.BlobHttpHeaders : object {
private string <ContentType>k__BackingField
private Byte[] <ContentHash>k__BackingField
private string <ContentEncoding>k__BackingField
private string <ContentLanguage>k__BackingField
private string <ContentDisposition>k__BackingField
private string <CacheControl>k__BackingField
public string ContentType
public Byte[] ContentHash
public string ContentEncoding
public string ContentLanguage
public string ContentDisposition
public string CacheControl
public string get_ContentType()
public void set_ContentType(string value)
public Byte[] get_ContentHash()
public void set_ContentHash(Byte[] value)
public string get_ContentEncoding()
public void set_ContentEncoding(string value)
public string get_ContentLanguage()
public void set_ContentLanguage(string value)
public string get_ContentDisposition()
public void set_ContentDisposition(string value)
public string get_CacheControl()
public void set_CacheControl(string value)
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
public Azure.Storage.Blobs.Models.BlobImmutabilityPolicy : object {
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField
private Nullable`1<BlobImmutabilityPolicyMode> <PolicyMode>k__BackingField
public Nullable`1<DateTimeOffset> ExpiresOn
public Nullable`1<BlobImmutabilityPolicyMode> PolicyMode
public Nullable`1<DateTimeOffset> get_ExpiresOn()
public void set_ExpiresOn(Nullable`1<DateTimeOffset> value)
public Nullable`1<BlobImmutabilityPolicyMode> get_PolicyMode()
public void set_PolicyMode(Nullable`1<BlobImmutabilityPolicyMode> value)
}
public Azure.Storage.Blobs.Models.BlobImmutabilityPolicyMode : Enum {
public int value__
public BlobImmutabilityPolicyMode Mutable
public BlobImmutabilityPolicyMode Unlocked
public BlobImmutabilityPolicyMode Locked
}
internal Azure.Storage.Blobs.Models.BlobImmutabilityPolicyModeExtensions : object {
public string ToSerialString(BlobImmutabilityPolicyMode value)
public BlobImmutabilityPolicyMode ToBlobImmutabilityPolicyMode(string value)
}
public Azure.Storage.Blobs.Models.BlobInfo : object {
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private long <BlobSequenceNumber>k__BackingField
private string <VersionId>k__BackingField
public ETag ETag
public DateTimeOffset LastModified
public long BlobSequenceNumber
public string VersionId
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public long get_BlobSequenceNumber()
internal void set_BlobSequenceNumber(long value)
public string get_VersionId()
internal void set_VersionId(string value)
}
public Azure.Storage.Blobs.Models.BlobItem : object {
private string <Name>k__BackingField
private bool <Deleted>k__BackingField
private string <Snapshot>k__BackingField
private string <VersionId>k__BackingField
private Nullable`1<bool> <IsLatestVersion>k__BackingField
private BlobItemProperties <Properties>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
private IList`1<ObjectReplicationPolicy> <ObjectReplicationSourceProperties>k__BackingField
private Nullable`1<bool> <HasVersionsOnly>k__BackingField
public string Name
public bool Deleted
public string Snapshot
public string VersionId
public Nullable`1<bool> IsLatestVersion
public BlobItemProperties Properties
public IDictionary`2<string, string> Metadata
public IDictionary`2<string, string> Tags
public IList`1<ObjectReplicationPolicy> ObjectReplicationSourceProperties
public Nullable`1<bool> HasVersionsOnly
public string get_Name()
internal void set_Name(string value)
public bool get_Deleted()
internal void set_Deleted(bool value)
public string get_Snapshot()
internal void set_Snapshot(string value)
public string get_VersionId()
internal void set_VersionId(string value)
public Nullable`1<bool> get_IsLatestVersion()
internal void set_IsLatestVersion(Nullable`1<bool> value)
public BlobItemProperties get_Properties()
internal void set_Properties(BlobItemProperties value)
public IDictionary`2<string, string> get_Metadata()
internal void set_Metadata(IDictionary`2<string, string> value)
public IDictionary`2<string, string> get_Tags()
internal void set_Tags(IDictionary`2<string, string> value)
public IList`1<ObjectReplicationPolicy> get_ObjectReplicationSourceProperties()
internal void set_ObjectReplicationSourceProperties(IList`1<ObjectReplicationPolicy> value)
public Nullable`1<bool> get_HasVersionsOnly()
internal void set_HasVersionsOnly(Nullable`1<bool> value)
}
internal Azure.Storage.Blobs.Models.BlobItemInternal : object {
private BlobName <Name>k__BackingField
private bool <Deleted>k__BackingField
private string <Snapshot>k__BackingField
private string <VersionId>k__BackingField
private Nullable`1<bool> <IsCurrentVersion>k__BackingField
private BlobPropertiesInternal <Properties>k__BackingField
private IReadOnlyDictionary`2<string, string> <Metadata>k__BackingField
private BlobTags <BlobTags>k__BackingField
private Nullable`1<bool> <HasVersionsOnly>k__BackingField
private IReadOnlyDictionary`2<string, string> <OrMetadata>k__BackingField
public BlobName Name
public bool Deleted
public string Snapshot
public string VersionId
public Nullable`1<bool> IsCurrentVersion
public BlobPropertiesInternal Properties
public IReadOnlyDictionary`2<string, string> Metadata
public BlobTags BlobTags
public Nullable`1<bool> HasVersionsOnly
public IReadOnlyDictionary`2<string, string> OrMetadata
internal void .ctor(BlobName name, bool deleted, string snapshot, BlobPropertiesInternal properties)
internal void .ctor(BlobName name, bool deleted, string snapshot, string versionId, Nullable`1<bool> isCurrentVersion, BlobPropertiesInternal properties, IReadOnlyDictionary`2<string, string> metadata, BlobTags blobTags, Nullable`1<bool> hasVersionsOnly, IReadOnlyDictionary`2<string, string> orMetadata)
public BlobName get_Name()
public bool get_Deleted()
public string get_Snapshot()
public string get_VersionId()
public Nullable`1<bool> get_IsCurrentVersion()
public BlobPropertiesInternal get_Properties()
public IReadOnlyDictionary`2<string, string> get_Metadata()
public BlobTags get_BlobTags()
public Nullable`1<bool> get_HasVersionsOnly()
public IReadOnlyDictionary`2<string, string> get_OrMetadata()
internal BlobItemInternal DeserializeBlobItemInternal(XElement element)
}
public Azure.Storage.Blobs.Models.BlobItemProperties : object {
private Nullable`1<DateTimeOffset> <LastModified>k__BackingField
private Nullable`1<long> <ContentLength>k__BackingField
private string <ContentType>k__BackingField
private string <ContentEncoding>k__BackingField
private string <ContentLanguage>k__BackingField
private Byte[] <ContentHash>k__BackingField
private string <ContentDisposition>k__BackingField
private string <CacheControl>k__BackingField
private Nullable`1<long> <BlobSequenceNumber>k__BackingField
private Nullable`1<BlobType> <BlobType>k__BackingField
private Nullable`1<LeaseStatus> <LeaseStatus>k__BackingField
private Nullable`1<LeaseState> <LeaseState>k__BackingField
private Nullable`1<LeaseDurationType> <LeaseDuration>k__BackingField
private string <CopyId>k__BackingField
private Nullable`1<CopyStatus> <CopyStatus>k__BackingField
private Uri <CopySource>k__BackingField
private string <CopyProgress>k__BackingField
private string <CopyStatusDescription>k__BackingField
private Nullable`1<bool> <ServerEncrypted>k__BackingField
private Nullable`1<bool> <IncrementalCopy>k__BackingField
private string <DestinationSnapshot>k__BackingField
private Nullable`1<int> <RemainingRetentionDays>k__BackingField
private Nullable`1<AccessTier> <AccessTier>k__BackingField
private bool <AccessTierInferred>k__BackingField
private Nullable`1<ArchiveStatus> <ArchiveStatus>k__BackingField
private string <CustomerProvidedKeySha256>k__BackingField
private string <EncryptionScope>k__BackingField
private Nullable`1<long> <TagCount>k__BackingField
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField
private Nullable`1<bool> <IsSealed>k__BackingField
private Nullable`1<RehydratePriority> <RehydratePriority>k__BackingField
private Nullable`1<DateTimeOffset> <LastAccessedOn>k__BackingField
private Nullable`1<ETag> <ETag>k__BackingField
private Nullable`1<DateTimeOffset> <CreatedOn>k__BackingField
private Nullable`1<DateTimeOffset> <CopyCompletedOn>k__BackingField
private Nullable`1<DateTimeOffset> <DeletedOn>k__BackingField
private Nullable`1<DateTimeOffset> <AccessTierChangedOn>k__BackingField
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField
private bool <HasLegalHold>k__BackingField
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<long> ContentLength
public string ContentType
public string ContentEncoding
public string ContentLanguage
public Byte[] ContentHash
public string ContentDisposition
public string CacheControl
public Nullable`1<long> BlobSequenceNumber
public Nullable`1<BlobType> BlobType
public Nullable`1<LeaseStatus> LeaseStatus
public Nullable`1<LeaseState> LeaseState
public Nullable`1<LeaseDurationType> LeaseDuration
public string CopyId
public Nullable`1<CopyStatus> CopyStatus
public Uri CopySource
public string CopyProgress
public string CopyStatusDescription
public Nullable`1<bool> ServerEncrypted
public Nullable`1<bool> IncrementalCopy
public string DestinationSnapshot
public Nullable`1<int> RemainingRetentionDays
public Nullable`1<AccessTier> AccessTier
public bool AccessTierInferred
public Nullable`1<ArchiveStatus> ArchiveStatus
public string CustomerProvidedKeySha256
public string EncryptionScope
public Nullable`1<long> TagCount
public Nullable`1<DateTimeOffset> ExpiresOn
public Nullable`1<bool> IsSealed
public Nullable`1<RehydratePriority> RehydratePriority
public Nullable`1<DateTimeOffset> LastAccessedOn
public Nullable`1<ETag> ETag
public Nullable`1<DateTimeOffset> CreatedOn
public Nullable`1<DateTimeOffset> CopyCompletedOn
public Nullable`1<DateTimeOffset> DeletedOn
public Nullable`1<DateTimeOffset> AccessTierChangedOn
public BlobImmutabilityPolicy ImmutabilityPolicy
public bool HasLegalHold
public Nullable`1<DateTimeOffset> get_LastModified()
internal void set_LastModified(Nullable`1<DateTimeOffset> value)
public Nullable`1<long> get_ContentLength()
internal void set_ContentLength(Nullable`1<long> value)
public string get_ContentType()
internal void set_ContentType(string value)
public string get_ContentEncoding()
internal void set_ContentEncoding(string value)
public string get_ContentLanguage()
internal void set_ContentLanguage(string value)
public Byte[] get_ContentHash()
internal void set_ContentHash(Byte[] value)
public string get_ContentDisposition()
internal void set_ContentDisposition(string value)
public string get_CacheControl()
internal void set_CacheControl(string value)
public Nullable`1<long> get_BlobSequenceNumber()
internal void set_BlobSequenceNumber(Nullable`1<long> value)
public Nullable`1<BlobType> get_BlobType()
internal void set_BlobType(Nullable`1<BlobType> value)
public Nullable`1<LeaseStatus> get_LeaseStatus()
internal void set_LeaseStatus(Nullable`1<LeaseStatus> value)
public Nullable`1<LeaseState> get_LeaseState()
internal void set_LeaseState(Nullable`1<LeaseState> value)
public Nullable`1<LeaseDurationType> get_LeaseDuration()
internal void set_LeaseDuration(Nullable`1<LeaseDurationType> value)
public string get_CopyId()
internal void set_CopyId(string value)
public Nullable`1<CopyStatus> get_CopyStatus()
internal void set_CopyStatus(Nullable`1<CopyStatus> value)
public Uri get_CopySource()
internal void set_CopySource(Uri value)
public string get_CopyProgress()
internal void set_CopyProgress(string value)
public string get_CopyStatusDescription()
internal void set_CopyStatusDescription(string value)
public Nullable`1<bool> get_ServerEncrypted()
internal void set_ServerEncrypted(Nullable`1<bool> value)
public Nullable`1<bool> get_IncrementalCopy()
internal void set_IncrementalCopy(Nullable`1<bool> value)
public string get_DestinationSnapshot()
internal void set_DestinationSnapshot(string value)
public Nullable`1<int> get_RemainingRetentionDays()
internal void set_RemainingRetentionDays(Nullable`1<int> value)
public Nullable`1<AccessTier> get_AccessTier()
internal void set_AccessTier(Nullable`1<AccessTier> value)
public bool get_AccessTierInferred()
internal void set_AccessTierInferred(bool value)
public Nullable`1<ArchiveStatus> get_ArchiveStatus()
internal void set_ArchiveStatus(Nullable`1<ArchiveStatus> value)
public string get_CustomerProvidedKeySha256()
internal void set_CustomerProvidedKeySha256(string value)
public string get_EncryptionScope()
internal void set_EncryptionScope(string value)
public Nullable`1<long> get_TagCount()
internal void set_TagCount(Nullable`1<long> value)
public Nullable`1<DateTimeOffset> get_ExpiresOn()
internal void set_ExpiresOn(Nullable`1<DateTimeOffset> value)
public Nullable`1<bool> get_IsSealed()
internal void set_IsSealed(Nullable`1<bool> value)
public Nullable`1<RehydratePriority> get_RehydratePriority()
internal void set_RehydratePriority(Nullable`1<RehydratePriority> value)
public Nullable`1<DateTimeOffset> get_LastAccessedOn()
internal void set_LastAccessedOn(Nullable`1<DateTimeOffset> value)
public Nullable`1<ETag> get_ETag()
internal void set_ETag(Nullable`1<ETag> value)
public Nullable`1<DateTimeOffset> get_CreatedOn()
internal void set_CreatedOn(Nullable`1<DateTimeOffset> value)
public Nullable`1<DateTimeOffset> get_CopyCompletedOn()
internal void set_CopyCompletedOn(Nullable`1<DateTimeOffset> value)
public Nullable`1<DateTimeOffset> get_DeletedOn()
internal void set_DeletedOn(Nullable`1<DateTimeOffset> value)
public Nullable`1<DateTimeOffset> get_AccessTierChangedOn()
internal void set_AccessTierChangedOn(Nullable`1<DateTimeOffset> value)
public BlobImmutabilityPolicy get_ImmutabilityPolicy()
internal void set_ImmutabilityPolicy(BlobImmutabilityPolicy value)
public bool get_HasLegalHold()
internal void set_HasLegalHold(bool value)
}
public Azure.Storage.Blobs.Models.BlobLease : object {
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private string <LeaseId>k__BackingField
private Nullable`1<int> <LeaseTime>k__BackingField
public ETag ETag
public DateTimeOffset LastModified
public string LeaseId
public Nullable`1<int> LeaseTime
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public string get_LeaseId()
internal void set_LeaseId(string value)
public Nullable`1<int> get_LeaseTime()
internal void set_LeaseTime(Nullable`1<int> value)
}
public Azure.Storage.Blobs.Models.BlobLeaseRequestConditions : RequestConditions {
private string <TagConditions>k__BackingField
public string TagConditions
public string get_TagConditions()
public void set_TagConditions(string value)
internal void .ctor(BlobLeaseRequestConditions deepCopySource)
internal BlobLeaseRequestConditions CloneOrDefault(BlobLeaseRequestConditions deepCopySource)
}
public Azure.Storage.Blobs.Models.BlobLegalHoldResult : object {
private bool <HasLegalHold>k__BackingField
public bool HasLegalHold
public bool get_HasLegalHold()
internal void set_HasLegalHold(bool value)
}
public Azure.Storage.Blobs.Models.BlobMetrics : object {
private string <Version>k__BackingField
private bool <Enabled>k__BackingField
private BlobRetentionPolicy <RetentionPolicy>k__BackingField
private Nullable`1<bool> <IncludeApis>k__BackingField
public string Version
public bool Enabled
public BlobRetentionPolicy RetentionPolicy
public Nullable`1<bool> IncludeApis
internal void .ctor(string version, bool enabled, Nullable`1<bool> includeApis, BlobRetentionPolicy retentionPolicy)
public string get_Version()
public void set_Version(string value)
public bool get_Enabled()
public void set_Enabled(bool value)
public BlobRetentionPolicy get_RetentionPolicy()
public void set_RetentionPolicy(BlobRetentionPolicy value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobMetrics DeserializeBlobMetrics(XElement element)
public Nullable`1<bool> get_IncludeApis()
public void set_IncludeApis(Nullable`1<bool> value)
internal void .ctor(bool skipInitialization)
}
internal Azure.Storage.Blobs.Models.BlobName : object {
private Nullable`1<bool> <Encoded>k__BackingField
private string <Content>k__BackingField
public Nullable`1<bool> Encoded
public string Content
internal void .ctor(Nullable`1<bool> encoded, string content)
public Nullable`1<bool> get_Encoded()
public string get_Content()
internal BlobName DeserializeBlobName(XElement element)
}
public Azure.Storage.Blobs.Models.BlobOpenReadOptions : object {
private long <Position>k__BackingField
private Nullable`1<int> <BufferSize>k__BackingField
private BlobRequestConditions <Conditions>k__BackingField
private DownloadTransferValidationOptions <TransferValidation>k__BackingField
private bool <AllowModifications>k__BackingField
public long Position
public Nullable`1<int> BufferSize
public BlobRequestConditions Conditions
public DownloadTransferValidationOptions TransferValidation
internal bool AllowModifications
public long get_Position()
public void set_Position(long value)
public Nullable`1<int> get_BufferSize()
public void set_BufferSize(Nullable`1<int> value)
public BlobRequestConditions get_Conditions()
public void set_Conditions(BlobRequestConditions value)
public DownloadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(DownloadTransferValidationOptions value)
internal bool get_AllowModifications()
public void .ctor(bool allowModifications)
}
public Azure.Storage.Blobs.Models.BlobOpenWriteOptions : object {
private Nullable`1<long> <BufferSize>k__BackingField
private BlobRequestConditions <OpenConditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private BlobHttpHeaders <HttpHeaders>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
private UploadTransferValidationOptions <TransferValidation>k__BackingField
public Nullable`1<long> BufferSize
public BlobRequestConditions OpenConditions
public IProgress`1<long> ProgressHandler
public BlobHttpHeaders HttpHeaders
public IDictionary`2<string, string> Metadata
public IDictionary`2<string, string> Tags
public UploadTransferValidationOptions TransferValidation
public Nullable`1<long> get_BufferSize()
public void set_BufferSize(Nullable`1<long> value)
public BlobRequestConditions get_OpenConditions()
public void set_OpenConditions(BlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public BlobHttpHeaders get_HttpHeaders()
public void set_HttpHeaders(BlobHttpHeaders value)
public IDictionary`2<string, string> get_Metadata()
public void set_Metadata(IDictionary`2<string, string> value)
public IDictionary`2<string, string> get_Tags()
public void set_Tags(IDictionary`2<string, string> value)
public UploadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(UploadTransferValidationOptions value)
}
internal Azure.Storage.Blobs.Models.BlobOpenWriteOptionsExtensions : object {
public BlockBlobOpenWriteOptions ToBlockBlobOpenWriteOptions(BlobOpenWriteOptions options)
}
internal Azure.Storage.Blobs.Models.BlobPrefix : object {
private BlobName <Name>k__BackingField
public BlobName Name
internal void .ctor(BlobName name)
public BlobName get_Name()
internal BlobPrefix DeserializeBlobPrefix(XElement element)
}
public Azure.Storage.Blobs.Models.BlobProperties : object {
private DateTimeOffset <LastModified>k__BackingField
private DateTimeOffset <CreatedOn>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private string <ObjectReplicationDestinationPolicyId>k__BackingField
private IList`1<ObjectReplicationPolicy> <ObjectReplicationSourceProperties>k__BackingField
private BlobType <BlobType>k__BackingField
private DateTimeOffset <CopyCompletedOn>k__BackingField
private string <CopyStatusDescription>k__BackingField
private string <CopyId>k__BackingField
private string <CopyProgress>k__BackingField
private Uri <CopySource>k__BackingField
private Nullable`1<CopyStatus> <BlobCopyStatus>k__BackingField
private bool <IsIncrementalCopy>k__BackingField
private string <DestinationSnapshot>k__BackingField
private LeaseDurationType <LeaseDuration>k__BackingField
private LeaseState <LeaseState>k__BackingField
private LeaseStatus <LeaseStatus>k__BackingField
private long <ContentLength>k__BackingField
private string <ContentType>k__BackingField
private ETag <ETag>k__BackingField
private Byte[] <ContentHash>k__BackingField
private string <ContentEncoding>k__BackingField
private string <ContentDisposition>k__BackingField
private string <ContentLanguage>k__BackingField
private string <CacheControl>k__BackingField
private long <BlobSequenceNumber>k__BackingField
private string <AcceptRanges>k__BackingField
private int <BlobCommittedBlockCount>k__BackingField
private bool <IsServerEncrypted>k__BackingField
private string <EncryptionKeySha256>k__BackingField
private string <EncryptionScope>k__BackingField
private string <AccessTier>k__BackingField
private bool <AccessTierInferred>k__BackingField
private string <ArchiveStatus>k__BackingField
private DateTimeOffset <AccessTierChangedOn>k__BackingField
private string <VersionId>k__BackingField
private bool <IsLatestVersion>k__BackingField
private long <TagCount>k__BackingField
private DateTimeOffset <ExpiresOn>k__BackingField
private bool <IsSealed>k__BackingField
private string <RehydratePriority>k__BackingField
private DateTimeOffset <LastAccessed>k__BackingField
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField
private bool <HasLegalHold>k__BackingField
public DateTimeOffset LastModified
public DateTimeOffset CreatedOn
public IDictionary`2<string, string> Metadata
public string ObjectReplicationDestinationPolicyId
public IList`1<ObjectReplicationPolicy> ObjectReplicationSourceProperties
public BlobType BlobType
public DateTimeOffset CopyCompletedOn
public string CopyStatusDescription
public string CopyId
public string CopyProgress
public Uri CopySource
public CopyStatus CopyStatus
public Nullable`1<CopyStatus> BlobCopyStatus
public bool IsIncrementalCopy
public string DestinationSnapshot
public LeaseDurationType LeaseDuration
public LeaseState LeaseState
public LeaseStatus LeaseStatus
public long ContentLength
public string ContentType
public ETag ETag
public Byte[] ContentHash
public string ContentEncoding
public string ContentDisposition
public string ContentLanguage
public string CacheControl
public long BlobSequenceNumber
public string AcceptRanges
public int BlobCommittedBlockCount
public bool IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public string AccessTier
public bool AccessTierInferred
public string ArchiveStatus
public DateTimeOffset AccessTierChangedOn
public string VersionId
public bool IsLatestVersion
public long TagCount
public DateTimeOffset ExpiresOn
public bool IsSealed
public string RehydratePriority
public DateTimeOffset LastAccessed
public BlobImmutabilityPolicy ImmutabilityPolicy
public bool HasLegalHold
public DateTimeOffset get_LastModified()
public DateTimeOffset get_CreatedOn()
public IDictionary`2<string, string> get_Metadata()
public string get_ObjectReplicationDestinationPolicyId()
public IList`1<ObjectReplicationPolicy> get_ObjectReplicationSourceProperties()
public BlobType get_BlobType()
public DateTimeOffset get_CopyCompletedOn()
public string get_CopyStatusDescription()
public string get_CopyId()
public string get_CopyProgress()
public Uri get_CopySource()
public CopyStatus get_CopyStatus()
public Nullable`1<CopyStatus> get_BlobCopyStatus()
public bool get_IsIncrementalCopy()
public string get_DestinationSnapshot()
public LeaseDurationType get_LeaseDuration()
public LeaseState get_LeaseState()
public LeaseStatus get_LeaseStatus()
public long get_ContentLength()
public string get_ContentType()
public ETag get_ETag()
public Byte[] get_ContentHash()
public string get_ContentEncoding()
public string get_ContentDisposition()
public string get_ContentLanguage()
public string get_CacheControl()
public long get_BlobSequenceNumber()
public string get_AcceptRanges()
public int get_BlobCommittedBlockCount()
public bool get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
public string get_AccessTier()
public bool get_AccessTierInferred()
public string get_ArchiveStatus()
public DateTimeOffset get_AccessTierChangedOn()
public string get_VersionId()
public bool get_IsLatestVersion()
public long get_TagCount()
public DateTimeOffset get_ExpiresOn()
public bool get_IsSealed()
public string get_RehydratePriority()
public DateTimeOffset get_LastAccessed()
public BlobImmutabilityPolicy get_ImmutabilityPolicy()
internal void set_ImmutabilityPolicy(BlobImmutabilityPolicy value)
public bool get_HasLegalHold()
internal void set_HasLegalHold(bool value)
internal void .ctor(DateTimeOffset lastModified, DateTimeOffset createdOn, IDictionary`2<string, string> metadata, string objectReplicationDestinationPolicyId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, BlobType blobType, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, Nullable`1<CopyStatus> blobCopyStatus, bool isIncrementalCopy, string destinationSnapshot, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, string accessTier, bool accessTierInferred, string archiveStatus, DateTimeOffset accessTierChangedOn, string versionId, bool isLatestVersion, long tagCount, DateTimeOffset expiresOn, bool isSealed, string rehydratePriority, DateTimeOffset lastAccessed, BlobImmutabilityPolicy immutabilityPolicy, bool hasLegalHold)
}
internal Azure.Storage.Blobs.Models.BlobPropertiesInternal : object {
private Nullable`1<DateTimeOffset> <CreationTime>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private string <Etag>k__BackingField
private Nullable`1<long> <ContentLength>k__BackingField
private string <ContentType>k__BackingField
private string <ContentEncoding>k__BackingField
private string <ContentLanguage>k__BackingField
private Byte[] <ContentMD5>k__BackingField
private string <ContentDisposition>k__BackingField
private string <CacheControl>k__BackingField
private Nullable`1<long> <BlobSequenceNumber>k__BackingField
private Nullable`1<BlobType> <BlobType>k__BackingField
private Nullable`1<LeaseStatus> <LeaseStatus>k__BackingField
private Nullable`1<LeaseState> <LeaseState>k__BackingField
private Nullable`1<LeaseDurationType> <LeaseDuration>k__BackingField
private string <CopyId>k__BackingField
private Nullable`1<CopyStatus> <CopyStatus>k__BackingField
private string <CopySource>k__BackingField
private string <CopyProgress>k__BackingField
private Nullable`1<DateTimeOffset> <CopyCompletionTime>k__BackingField
private string <CopyStatusDescription>k__BackingField
private Nullable`1<bool> <ServerEncrypted>k__BackingField
private Nullable`1<bool> <IncrementalCopy>k__BackingField
private string <DestinationSnapshot>k__BackingField
private Nullable`1<DateTimeOffset> <DeletedTime>k__BackingField
private Nullable`1<int> <RemainingRetentionDays>k__BackingField
private Nullable`1<AccessTier> <AccessTier>k__BackingField
private Nullable`1<bool> <AccessTierInferred>k__BackingField
private Nullable`1<ArchiveStatus> <ArchiveStatus>k__BackingField
private string <CustomerProvidedKeySha256>k__BackingField
private string <EncryptionScope>k__BackingField
private Nullable`1<DateTimeOffset> <AccessTierChangeTime>k__BackingField
private Nullable`1<int> <TagCount>k__BackingField
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField
private Nullable`1<bool> <IsSealed>k__BackingField
private Nullable`1<RehydratePriority> <RehydratePriority>k__BackingField
private Nullable`1<DateTimeOffset> <LastAccessedOn>k__BackingField
private Nullable`1<DateTimeOffset> <ImmutabilityPolicyExpiresOn>k__BackingField
private Nullable`1<BlobImmutabilityPolicyMode> <ImmutabilityPolicyMode>k__BackingField
private Nullable`1<bool> <LegalHold>k__BackingField
public Nullable`1<DateTimeOffset> CreationTime
public DateTimeOffset LastModified
public string Etag
public Nullable`1<long> ContentLength
public string ContentType
public string ContentEncoding
public string ContentLanguage
public Byte[] ContentMD5
public string ContentDisposition
public string CacheControl
public Nullable`1<long> BlobSequenceNumber
public Nullable`1<BlobType> BlobType
public Nullable`1<LeaseStatus> LeaseStatus
public Nullable`1<LeaseState> LeaseState
public Nullable`1<LeaseDurationType> LeaseDuration
public string CopyId
public Nullable`1<CopyStatus> CopyStatus
public string CopySource
public string CopyProgress
public Nullable`1<DateTimeOffset> CopyCompletionTime
public string CopyStatusDescription
public Nullable`1<bool> ServerEncrypted
public Nullable`1<bool> IncrementalCopy
public string DestinationSnapshot
public Nullable`1<DateTimeOffset> DeletedTime
public Nullable`1<int> RemainingRetentionDays
public Nullable`1<AccessTier> AccessTier
public Nullable`1<bool> AccessTierInferred
public Nullable`1<ArchiveStatus> ArchiveStatus
public string CustomerProvidedKeySha256
public string EncryptionScope
public Nullable`1<DateTimeOffset> AccessTierChangeTime
public Nullable`1<int> TagCount
public Nullable`1<DateTimeOffset> ExpiresOn
public Nullable`1<bool> IsSealed
public Nullable`1<RehydratePriority> RehydratePriority
public Nullable`1<DateTimeOffset> LastAccessedOn
public Nullable`1<DateTimeOffset> ImmutabilityPolicyExpiresOn
public Nullable`1<BlobImmutabilityPolicyMode> ImmutabilityPolicyMode
public Nullable`1<bool> LegalHold
internal void .ctor(DateTimeOffset lastModified, string etag)
internal void .ctor(Nullable`1<DateTimeOffset> creationTime, DateTimeOffset lastModified, string etag, Nullable`1<long> contentLength, string contentType, string contentEncoding, string contentLanguage, Byte[] contentMD5, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, string copySource, string copyProgress, Nullable`1<DateTimeOffset> copyCompletionTime, string copyStatusDescription, Nullable`1<bool> serverEncrypted, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<DateTimeOffset> deletedTime, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<bool> accessTierInferred, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, string encryptionScope, Nullable`1<DateTimeOffset> accessTierChangeTime, Nullable`1<int> tagCount, Nullable`1<DateTimeOffset> expiresOn, Nullable`1<bool> isSealed, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> lastAccessedOn, Nullable`1<DateTimeOffset> immutabilityPolicyExpiresOn, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold)
public Nullable`1<DateTimeOffset> get_CreationTime()
public DateTimeOffset get_LastModified()
public string get_Etag()
public Nullable`1<long> get_ContentLength()
public string get_ContentType()
public string get_ContentEncoding()
public string get_ContentLanguage()
public Byte[] get_ContentMD5()
public string get_ContentDisposition()
public string get_CacheControl()
public Nullable`1<long> get_BlobSequenceNumber()
public Nullable`1<BlobType> get_BlobType()
public Nullable`1<LeaseStatus> get_LeaseStatus()
public Nullable`1<LeaseState> get_LeaseState()
public Nullable`1<LeaseDurationType> get_LeaseDuration()
public string get_CopyId()
public Nullable`1<CopyStatus> get_CopyStatus()
public string get_CopySource()
public string get_CopyProgress()
public Nullable`1<DateTimeOffset> get_CopyCompletionTime()
public string get_CopyStatusDescription()
public Nullable`1<bool> get_ServerEncrypted()
public Nullable`1<bool> get_IncrementalCopy()
public string get_DestinationSnapshot()
public Nullable`1<DateTimeOffset> get_DeletedTime()
public Nullable`1<int> get_RemainingRetentionDays()
public Nullable`1<AccessTier> get_AccessTier()
public Nullable`1<bool> get_AccessTierInferred()
public Nullable`1<ArchiveStatus> get_ArchiveStatus()
public string get_CustomerProvidedKeySha256()
public string get_EncryptionScope()
public Nullable`1<DateTimeOffset> get_AccessTierChangeTime()
public Nullable`1<int> get_TagCount()
public Nullable`1<DateTimeOffset> get_ExpiresOn()
public Nullable`1<bool> get_IsSealed()
public Nullable`1<RehydratePriority> get_RehydratePriority()
public Nullable`1<DateTimeOffset> get_LastAccessedOn()
public Nullable`1<DateTimeOffset> get_ImmutabilityPolicyExpiresOn()
public Nullable`1<BlobImmutabilityPolicyMode> get_ImmutabilityPolicyMode()
public Nullable`1<bool> get_LegalHold()
internal BlobPropertiesInternal DeserializeBlobPropertiesInternal(XElement element)
}
public Azure.Storage.Blobs.Models.BlobQueryArrowField : object {
private BlobQueryArrowFieldType <Type>k__BackingField
private string <Name>k__BackingField
private int <Precision>k__BackingField
private int <Scale>k__BackingField
public BlobQueryArrowFieldType Type
public string Name
public int Precision
public int Scale
public BlobQueryArrowFieldType get_Type()
public void set_Type(BlobQueryArrowFieldType value)
public string get_Name()
public void set_Name(string value)
public int get_Precision()
public void set_Precision(int value)
public int get_Scale()
public void set_Scale(int value)
}
public Azure.Storage.Blobs.Models.BlobQueryArrowFieldType : Enum {
public int value__
public BlobQueryArrowFieldType Int64
public BlobQueryArrowFieldType Bool
public BlobQueryArrowFieldType Timestamp
public BlobQueryArrowFieldType String
public BlobQueryArrowFieldType Double
public BlobQueryArrowFieldType Decimal
}
public Azure.Storage.Blobs.Models.BlobQueryArrowOptions : BlobQueryTextOptions {
private IList`1<BlobQueryArrowField> <Schema>k__BackingField
public IList`1<BlobQueryArrowField> Schema
public IList`1<BlobQueryArrowField> get_Schema()
public void set_Schema(IList`1<BlobQueryArrowField> value)
}
public Azure.Storage.Blobs.Models.BlobQueryCsvTextOptions : BlobQueryTextOptions {
private string <RecordSeparator>k__BackingField
private string <ColumnSeparator>k__BackingField
private Nullable`1<char> <QuotationCharacter>k__BackingField
private Nullable`1<char> <EscapeCharacter>k__BackingField
private bool <HasHeaders>k__BackingField
public string RecordSeparator
public string ColumnSeparator
public Nullable`1<char> QuotationCharacter
public Nullable`1<char> EscapeCharacter
public bool HasHeaders
public string get_RecordSeparator()
public void set_RecordSeparator(string value)
public string get_ColumnSeparator()
public void set_ColumnSeparator(string value)
public Nullable`1<char> get_QuotationCharacter()
public void set_QuotationCharacter(Nullable`1<char> value)
public Nullable`1<char> get_EscapeCharacter()
public void set_EscapeCharacter(Nullable`1<char> value)
public bool get_HasHeaders()
public void set_HasHeaders(bool value)
}
public Azure.Storage.Blobs.Models.BlobQueryError : object {
private string <Name>k__BackingField
private string <Description>k__BackingField
private bool <IsFatal>k__BackingField
private long <Position>k__BackingField
public string Name
public string Description
public bool IsFatal
public long Position
public string get_Name()
internal void set_Name(string value)
public string get_Description()
internal void set_Description(string value)
public bool get_IsFatal()
internal void set_IsFatal(bool value)
public long get_Position()
internal void set_Position(long value)
}
public Azure.Storage.Blobs.Models.BlobQueryJsonTextOptions : BlobQueryTextOptions {
private string <RecordSeparator>k__BackingField
public string RecordSeparator
public string get_RecordSeparator()
public void set_RecordSeparator(string value)
}
public Azure.Storage.Blobs.Models.BlobQueryOptions : object {
private BlobQueryTextOptions <InputTextConfiguration>k__BackingField
private BlobQueryTextOptions <OutputTextConfiguration>k__BackingField
private object _objectLock
internal Action`1<BlobQueryError> _errorHandler
private BlobRequestConditions <Conditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
public BlobQueryTextOptions InputTextConfiguration
public BlobQueryTextOptions OutputTextConfiguration
public BlobRequestConditions Conditions
public IProgress`1<long> ProgressHandler
public BlobQueryTextOptions get_InputTextConfiguration()
public void set_InputTextConfiguration(BlobQueryTextOptions value)
public BlobQueryTextOptions get_OutputTextConfiguration()
public void set_OutputTextConfiguration(BlobQueryTextOptions value)
public void add_ErrorHandler(Action`1<BlobQueryError> value)
public void remove_ErrorHandler(Action`1<BlobQueryError> value)
public BlobRequestConditions get_Conditions()
public void set_Conditions(BlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
}
internal Azure.Storage.Blobs.Models.BlobRequestConditionProperty : Enum {
public int value__
public BlobRequestConditionProperty None
public BlobRequestConditionProperty LeaseId
public BlobRequestConditionProperty TagConditions
public BlobRequestConditionProperty IfModifiedSince
public BlobRequestConditionProperty IfUnmodifiedSince
public BlobRequestConditionProperty IfMatch
public BlobRequestConditionProperty IfNoneMatch
public BlobRequestConditionProperty IfAppendPositionEqual
public BlobRequestConditionProperty IfMaxSizeLessThanOrEqual
public BlobRequestConditionProperty IfSequenceNumberLessThan
public BlobRequestConditionProperty IfSequenceNumberLessThanOrEqual
public BlobRequestConditionProperty IfSequenceNumberEqual
}
public Azure.Storage.Blobs.Models.BlobRequestConditions : BlobLeaseRequestConditions {
private string <LeaseId>k__BackingField
public string LeaseId
public string get_LeaseId()
public void set_LeaseId(string value)
private void .ctor(BlobRequestConditions deepCopySource)
internal BlobRequestConditions CloneOrDefault(BlobRequestConditions deepCopySource)
public string ToString()
internal BlobRequestConditions WithIfMatch(ETag etag)
internal void AddConditions(StringBuilder conditions)
}
public Azure.Storage.Blobs.Models.BlobRetentionPolicy : object {
private bool <Enabled>k__BackingField
private Nullable`1<int> <Days>k__BackingField
private Nullable`1<bool> <AllowPermanentDelete>k__BackingField
public bool Enabled
public Nullable`1<int> Days
internal Nullable`1<bool> AllowPermanentDelete
internal void .ctor(bool enabled, Nullable`1<int> days, Nullable`1<bool> allowPermanentDelete)
public bool get_Enabled()
public void set_Enabled(bool value)
public Nullable`1<int> get_Days()
public void set_Days(Nullable`1<int> value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobRetentionPolicy DeserializeBlobRetentionPolicy(XElement element)
internal void .ctor(bool enabled)
internal Nullable`1<bool> get_AllowPermanentDelete()
internal void set_AllowPermanentDelete(Nullable`1<bool> value)
}
public Azure.Storage.Blobs.Models.BlobServiceProperties : object {
private BlobAnalyticsLogging <Logging>k__BackingField
private BlobMetrics <HourMetrics>k__BackingField
private BlobMetrics <MinuteMetrics>k__BackingField
private string <DefaultServiceVersion>k__BackingField
private BlobRetentionPolicy <DeleteRetentionPolicy>k__BackingField
private BlobStaticWebsite <StaticWebsite>k__BackingField
private IList`1<BlobCorsRule> <Cors>k__BackingField
public BlobAnalyticsLogging Logging
public BlobMetrics HourMetrics
public BlobMetrics MinuteMetrics
public string DefaultServiceVersion
public BlobRetentionPolicy DeleteRetentionPolicy
public BlobStaticWebsite StaticWebsite
public IList`1<BlobCorsRule> Cors
internal void .ctor(BlobAnalyticsLogging logging, BlobMetrics hourMetrics, BlobMetrics minuteMetrics, IList`1<BlobCorsRule> cors, string defaultServiceVersion, BlobRetentionPolicy deleteRetentionPolicy, BlobStaticWebsite staticWebsite)
public BlobAnalyticsLogging get_Logging()
public void set_Logging(BlobAnalyticsLogging value)
public BlobMetrics get_HourMetrics()
public void set_HourMetrics(BlobMetrics value)
public BlobMetrics get_MinuteMetrics()
public void set_MinuteMetrics(BlobMetrics value)
public string get_DefaultServiceVersion()
public void set_DefaultServiceVersion(string value)
public BlobRetentionPolicy get_DeleteRetentionPolicy()
public void set_DeleteRetentionPolicy(BlobRetentionPolicy value)
public BlobStaticWebsite get_StaticWebsite()
public void set_StaticWebsite(BlobStaticWebsite value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobServiceProperties DeserializeBlobServiceProperties(XElement element)
public IList`1<BlobCorsRule> get_Cors()
public void set_Cors(IList`1<BlobCorsRule> value)
internal void .ctor(bool skipInitialization)
}
public Azure.Storage.Blobs.Models.BlobServiceStatistics : object {
private BlobGeoReplication <GeoReplication>k__BackingField
public BlobGeoReplication GeoReplication
internal void .ctor(BlobGeoReplication geoReplication)
public BlobGeoReplication get_GeoReplication()
internal BlobServiceStatistics DeserializeBlobServiceStatistics(XElement element)
}
public Azure.Storage.Blobs.Models.BlobSignedIdentifier : object {
private string <Id>k__BackingField
private BlobAccessPolicy <AccessPolicy>k__BackingField
public string Id
public BlobAccessPolicy AccessPolicy
public string get_Id()
public void set_Id(string value)
public BlobAccessPolicy get_AccessPolicy()
public void set_AccessPolicy(BlobAccessPolicy value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobSignedIdentifier DeserializeBlobSignedIdentifier(XElement element)
internal void .ctor(string id, BlobAccessPolicy accessPolicy)
internal void .ctor(bool skipInitialization)
}
public Azure.Storage.Blobs.Models.BlobsModelFactory : object {
public UserDelegationKey UserDelegationKey(string signedObjectId, string signedTenantId, DateTimeOffset signedStartsOn, DateTimeOffset signedExpiresOn, string signedService, string signedVersion, string value)
public BlobContentInfo BlobContentInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, string versionId, string encryptionKeySha256, string encryptionScope, long blobSequenceNumber)
public BlobContentInfo BlobContentInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, string encryptionKeySha256, string encryptionScope, long blobSequenceNumber)
public BlobContentInfo BlobContentInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, string encryptionKeySha256, long blobSequenceNumber)
public BlobAppendInfo BlobAppendInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, Byte[] contentCrc64, string blobAppendOffset, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope)
public BlobAppendInfo BlobAppendInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, Byte[] contentCrc64, string blobAppendOffset, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256)
public BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, Nullable`1<CopyStatus> blobCopyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary`2<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, Byte[] contentHash, DateTimeOffset lastAccessed, BlobImmutabilityPolicy immutabilityPolicy, bool hasLegalHold)
public BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, CopyStatus copyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary`2<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, Byte[] contentHash, DateTimeOffset lastAccessed, BlobImmutabilityPolicy immutabilityPolicy, bool hasLegalHold)
public BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, CopyStatus copyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary`2<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, Byte[] contentHash, DateTimeOffset lastAccessed)
public BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, CopyStatus copyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary`2<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, Byte[] contentHash)
public BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseState leaseState, LeaseStatus leaseStatus, long contentLength, LeaseDurationType leaseDuration, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string destinationSnapshot, string cacheControl, bool isIncrementalCopy, long blobSequenceNumber, CopyStatus copyStatus, string acceptRanges, Uri copySource, int blobCommittedBlockCount, string copyProgress, bool isServerEncrypted, string copyId, string encryptionKeySha256, string copyStatusDescription, string encryptionScope, DateTimeOffset copyCompletedOn, string accessTier, BlobType blobType, bool accessTierInferred, IDictionary`2<string, string> metadata, string archiveStatus, DateTimeOffset createdOn, DateTimeOffset accessTierChangedOn, string contentType)
public BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, long contentLength, string destinationSnapshot, ETag eTag, Byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, bool isIncrementalCopy, string cacheControl, CopyStatus copyStatus, long blobSequenceNumber, Uri copySource, string acceptRanges, string copyProgress, int blobCommittedBlockCount, string copyId, bool isServerEncrypted, string copyStatusDescription, string encryptionKeySha256, DateTimeOffset copyCompletedOn, string accessTier, BlobType blobType, bool accessTierInferred, IDictionary`2<string, string> metadata, string archiveStatus, DateTimeOffset createdOn, DateTimeOffset accessTierChangedOn, string contentType)
public BlobItemProperties BlobItemProperties(bool accessTierInferred, Nullable`1<bool> serverEncrypted, string contentType, string contentEncoding, string contentLanguage, Byte[] contentHash, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, Uri copySource, string copyProgress, string copyStatusDescription, Nullable`1<long> contentLength, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, string encryptionScope, Nullable`1<long> tagCount, Nullable`1<DateTimeOffset> expiresOn, Nullable`1<bool> isSealed, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<DateTimeOffset> lastAccessedOn, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> copyCompletedOn, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> accessTierChangedOn)
public BlobItemProperties BlobItemProperties(bool accessTierInferred, Nullable`1<bool> serverEncrypted, string contentType, string contentEncoding, string contentLanguage, Byte[] contentHash, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, Uri copySource, string copyProgress, string copyStatusDescription, Nullable`1<long> contentLength, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, string encryptionScope, Nullable`1<long> tagCount, Nullable`1<DateTimeOffset> expiresOn, Nullable`1<bool> isSealed, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> copyCompletedOn, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> accessTierChangedOn)
public BlobItemProperties BlobItemProperties(bool accessTierInferred, string copyProgress, string contentType, string contentEncoding, string contentLanguage, Byte[] contentHash, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, Uri copySource, Nullable`1<long> contentLength, string copyStatusDescription, Nullable`1<bool> serverEncrypted, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, string encryptionScope, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> copyCompletedOn, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> accessTierChangedOn)
public BlobItemProperties BlobItemProperties(bool accessTierInferred, Uri copySource, string contentType, string contentEncoding, string contentLanguage, Byte[] contentHash, string contentDisposition, string cacheControl, Nullable`1<long> blobSequenceNumber, Nullable`1<BlobType> blobType, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, string copyId, Nullable`1<CopyStatus> copyStatus, Nullable`1<long> contentLength, string copyProgress, string copyStatusDescription, Nullable`1<bool> serverEncrypted, Nullable`1<bool> incrementalCopy, string destinationSnapshot, Nullable`1<int> remainingRetentionDays, Nullable`1<AccessTier> accessTier, Nullable`1<DateTimeOffset> lastModified, Nullable`1<ArchiveStatus> archiveStatus, string customerProvidedKeySha256, Nullable`1<ETag> eTag, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> copyCompletedOn, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> accessTierChangedOn)
public BlockInfo BlockInfo(Byte[] contentHash, Byte[] contentCrc64, string encryptionKeySha256, string encryptionScope)
public BlockInfo BlockInfo(Byte[] contentHash, Byte[] contentCrc64, string encryptionKeySha256)
public PageInfo PageInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, Byte[] contentCrc64, long blobSequenceNumber, string encryptionKeySha256, string encryptionScope)
public PageInfo PageInfo(ETag eTag, DateTimeOffset lastModified, Byte[] contentHash, Byte[] contentCrc64, long blobSequenceNumber, string encryptionKeySha256)
public BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<LeaseStatus> leaseStatus, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<int> remainingRetentionDays, IDictionary`2<string, string> metadata, Nullable`1<bool> hasLegalHold)
public BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<bool> hasLegalHold, IDictionary`2<string, string> metadata)
public BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<LeaseStatus> leaseStatus, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, IDictionary`2<string, string> metadata, Nullable`1<bool> hasLegalHold)
public BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<bool> hasLegalHold, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, IDictionary`2<string, string> metadata, Nullable`1<bool> hasImmutabilityPolicy)
public BlobCopyInfo BlobCopyInfo(ETag eTag, DateTimeOffset lastModified, string versionId, string copyId, CopyStatus copyStatus)
public BlobCopyInfo BlobCopyInfo(ETag eTag, DateTimeOffset lastModified, string copyId, CopyStatus copyStatus)
public BlobItem BlobItem(string name, bool deleted, BlobItemProperties properties, string snapshot, string versionId, Nullable`1<bool> isLatestVersion, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, List`1<ObjectReplicationPolicy> objectReplicationSourcePolicies, Nullable`1<bool> hasVersionsOnly)
public BlobItem BlobItem(string name, bool deleted, BlobItemProperties properties, string snapshot, string versionId, Nullable`1<bool> isLatestVersion, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, List`1<ObjectReplicationPolicy> objectReplicationSourcePolicies)
public BlobItem BlobItem(string name, bool deleted, BlobItemProperties properties, string snapshot, IDictionary`2<string, string> metadata)
public BlobSnapshotInfo BlobSnapshotInfo(string snapshot, ETag eTag, DateTimeOffset lastModified, string versionId, bool isServerEncrypted)
public BlobSnapshotInfo BlobSnapshotInfo(string snapshot, ETag eTag, DateTimeOffset lastModified, bool isServerEncrypted)
public BlobInfo blobInfo(ETag eTag, DateTimeOffset lastModifed, long blobSequenceNumber, string versionId)
public BlobContainerItem BlobContainerItem(string name, BlobContainerProperties properties, Nullable`1<bool> isDeleted, string versionId)
public BlobContainerInfo BlobContainerInfo(ETag eTag, DateTimeOffset lastModified)
public BlobContainerItem BlobContainerItem(string name, BlobContainerProperties properties)
public BlobQueryError BlobQueryError(string name, string description, bool isFatal, long position)
public GetBlobTagResult GetBlobTagResult(IDictionary`2<string, string> tags)
public TaggedBlobItem TaggedBlobItem(string blobName, string blobContainerName, IDictionary`2<string, string> tags)
public TaggedBlobItem TaggedBlobItem(string blobName, string blobContainerName)
public ObjectReplicationPolicy ObjectReplicationPolicy(string policyId, IList`1<ObjectReplicationRule> rules)
public ObjectReplicationRule ObjectReplicationRule(string ruleId, ObjectReplicationStatus replicationStatus)
public BlobDownloadDetails BlobDownloadDetails(BlobType blobType, long contentLength, string contentType, Byte[] contentHash, DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, long blobSequenceNumber, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, Byte[] blobContentHash, long tagCount, string versionId, bool isSealed, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, string objectReplicationDestinationPolicy, bool hasLegalHold, DateTimeOffset createdOn)
public BlobDownloadDetails BlobDownloadDetails(DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, long blobSequenceNumber, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, Byte[] blobContentHash, long tagCount, string versionId, bool isSealed, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, string objectReplicationDestinationPolicy)
public BlobDownloadDetails BlobDownloadDetails(BlobType blobType, long contentLength, string contentType, Byte[] contentHash, DateTimeOffset lastModified, IDictionary`2<string, string> metadata, string contentRange, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, long blobSequenceNumber, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, Byte[] blobContentHash, long tagCount, string versionId, bool isSealed, IList`1<ObjectReplicationPolicy> objectReplicationSourceProperties, string objectReplicationDestinationPolicy)
public AccountInfo AccountInfo(SkuName skuName, AccountKind accountKind, bool isHierarchicalNamespaceEnabled)
public AccountInfo AccountInfo(SkuName skuName, AccountKind accountKind)
public BlobContainerAccessPolicy BlobContainerAccessPolicy(PublicAccessType blobPublicAccess, ETag eTag, DateTimeOffset lastModified, IEnumerable`1<BlobSignedIdentifier> signedIdentifiers)
public PageBlobInfo PageBlobInfo(ETag eTag, DateTimeOffset lastModified, long blobSequenceNumber)
public BlobBlock BlobBlock(string name, int size)
public BlobBlock BlobBlock(string name, long size)
public BlobGeoReplication BlobGeoReplication(BlobGeoReplicationStatus status, Nullable`1<DateTimeOffset> lastSyncedOn)
public BlobInfo BlobInfo(ETag eTag, DateTimeOffset lastModified)
public BlobLease BlobLease(ETag eTag, DateTimeOffset lastModified, string leaseId)
public BlobServiceStatistics BlobServiceStatistics(BlobGeoReplication geoReplication)
public BlockList BlockList(IEnumerable`1<BlobBlock> committedBlocks, IEnumerable`1<BlobBlock> uncommittedBlocks)
public UserDelegationKey UserDelegationKey(string signedObjectId, string signedTenantId, string signedService, string signedVersion, string value, DateTimeOffset signedExpiresOn, DateTimeOffset signedStartsOn)
public BlobHierarchyItem BlobHierarchyItem(string prefix, BlobItem blob)
public BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, Byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, Byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, string encryptionScope, long contentLength, Byte[] blobContentHash, string versionId, IDictionary`2<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime, long tagCount, DateTimeOffset lastAccessed)
public BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, Byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, Byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, string encryptionScope, long contentLength, Byte[] blobContentHash, string versionId, IDictionary`2<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime, long tagCount)
public BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, Byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, Byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, string encryptionScope, long contentLength, Byte[] blobContentHash, IDictionary`2<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime)
public BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, Byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, Byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, long contentLength, Byte[] blobContentHash, IDictionary`2<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime)
public BlobDownloadResult BlobDownloadResult(BinaryData content, BlobDownloadDetails details)
public BlobDownloadStreamingResult BlobDownloadStreamingResult(Stream content, BlobDownloadDetails details)
public PageRangesInfo PageRangesInfo(DateTimeOffset lastModified, ETag eTag, long blobContentLength, IEnumerable`1<HttpRange> pageRanges, IEnumerable`1<HttpRange> clearRanges)
}
public Azure.Storage.Blobs.Models.BlobSnapshotInfo : object {
private string <Snapshot>k__BackingField
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private string <VersionId>k__BackingField
private bool <IsServerEncrypted>k__BackingField
public string Snapshot
public ETag ETag
public DateTimeOffset LastModified
public string VersionId
public bool IsServerEncrypted
public string get_Snapshot()
internal void set_Snapshot(string value)
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public string get_VersionId()
internal void set_VersionId(string value)
public bool get_IsServerEncrypted()
internal void set_IsServerEncrypted(bool value)
}
public Azure.Storage.Blobs.Models.BlobStates : Enum {
public int value__
public BlobStates None
public BlobStates Snapshots
public BlobStates Uncommitted
public BlobStates Deleted
public BlobStates Version
public BlobStates DeletedWithVersions
public BlobStates All
}
public Azure.Storage.Blobs.Models.BlobStaticWebsite : object {
private bool <Enabled>k__BackingField
private string <IndexDocument>k__BackingField
private string <ErrorDocument404Path>k__BackingField
private string <DefaultIndexDocumentPath>k__BackingField
public bool Enabled
public string IndexDocument
public string ErrorDocument404Path
public string DefaultIndexDocumentPath
internal void .ctor(bool enabled, string indexDocument, string errorDocument404Path, string defaultIndexDocumentPath)
public bool get_Enabled()
public void set_Enabled(bool value)
public string get_IndexDocument()
public void set_IndexDocument(string value)
public string get_ErrorDocument404Path()
public void set_ErrorDocument404Path(string value)
public string get_DefaultIndexDocumentPath()
public void set_DefaultIndexDocumentPath(string value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobStaticWebsite DeserializeBlobStaticWebsite(XElement element)
internal void .ctor(bool enabled)
}
public Azure.Storage.Blobs.Models.BlobSyncUploadFromUriOptions : object {
private Nullable`1<bool> <CopySourceBlobProperties>k__BackingField
private BlobHttpHeaders <HttpHeaders>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
private BlobRequestConditions <DestinationConditions>k__BackingField
private BlobRequestConditions <SourceConditions>k__BackingField
private Nullable`1<AccessTier> <AccessTier>k__BackingField
private Byte[] <ContentHash>k__BackingField
private HttpAuthorization <SourceAuthentication>k__BackingField
private Nullable`1<BlobCopySourceTagsMode> <CopySourceTagsMode>k__BackingField
public Nullable`1<bool> CopySourceBlobProperties
public BlobHttpHeaders HttpHeaders
public IDictionary`2<string, string> Metadata
public IDictionary`2<string, string> Tags
public BlobRequestConditions DestinationConditions
public BlobRequestConditions SourceConditions
public Nullable`1<AccessTier> AccessTier
public Byte[] ContentHash
public HttpAuthorization SourceAuthentication
public Nullable`1<BlobCopySourceTagsMode> CopySourceTagsMode
public Nullable`1<bool> get_CopySourceBlobProperties()
public void set_CopySourceBlobProperties(Nullable`1<bool> value)
public BlobHttpHeaders get_HttpHeaders()
public void set_HttpHeaders(BlobHttpHeaders value)
public IDictionary`2<string, string> get_Metadata()
public void set_Metadata(IDictionary`2<string, string> value)
public IDictionary`2<string, string> get_Tags()
public void set_Tags(IDictionary`2<string, string> value)
public BlobRequestConditions get_DestinationConditions()
public void set_DestinationConditions(BlobRequestConditions value)
public BlobRequestConditions get_SourceConditions()
public void set_SourceConditions(BlobRequestConditions value)
public Nullable`1<AccessTier> get_AccessTier()
public void set_AccessTier(Nullable`1<AccessTier> value)
public Byte[] get_ContentHash()
public void set_ContentHash(Byte[] value)
public HttpAuthorization get_SourceAuthentication()
public void set_SourceAuthentication(HttpAuthorization value)
public Nullable`1<BlobCopySourceTagsMode> get_CopySourceTagsMode()
public void set_CopySourceTagsMode(Nullable`1<BlobCopySourceTagsMode> value)
}
internal Azure.Storage.Blobs.Models.BlobTag : object {
private string <Key>k__BackingField
private string <Value>k__BackingField
public string Key
public string Value
public void .ctor(string key, string value)
public string get_Key()
public void set_Key(string value)
public string get_Value()
public void set_Value(string value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobTag DeserializeBlobTag(XElement element)
}
internal Azure.Storage.Blobs.Models.BlobTags : object {
private IList`1<BlobTag> <BlobTagSet>k__BackingField
public IList`1<BlobTag> BlobTagSet
public void .ctor(IEnumerable`1<BlobTag> blobTagSet)
internal void .ctor(IList`1<BlobTag> blobTagSet)
public IList`1<BlobTag> get_BlobTagSet()
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
internal BlobTags DeserializeBlobTags(XElement element)
}
public Azure.Storage.Blobs.Models.BlobTraits : Enum {
public int value__
public BlobTraits None
public BlobTraits CopyStatus
public BlobTraits Metadata
public BlobTraits Tags
public BlobTraits ImmutabilityPolicy
public BlobTraits LegalHold
public BlobTraits All
}
public Azure.Storage.Blobs.Models.BlobType : Enum {
public int value__
public BlobType Block
public BlobType Page
public BlobType Append
}
internal Azure.Storage.Blobs.Models.BlobTypeExtensions : object {
public string ToSerialString(BlobType value)
public BlobType ToBlobType(string value)
}
public Azure.Storage.Blobs.Models.BlobUploadOptions : object {
private BlobHttpHeaders <HttpHeaders>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
private BlobRequestConditions <Conditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private Nullable`1<AccessTier> <AccessTier>k__BackingField
private StorageTransferOptions <TransferOptions>k__BackingField
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField
private Nullable`1<bool> <LegalHold>k__BackingField
private UploadTransferValidationOptions <TransferValidation>k__BackingField
public BlobHttpHeaders HttpHeaders
public IDictionary`2<string, string> Metadata
public IDictionary`2<string, string> Tags
public BlobRequestConditions Conditions
public IProgress`1<long> ProgressHandler
public Nullable`1<AccessTier> AccessTier
public StorageTransferOptions TransferOptions
public BlobImmutabilityPolicy ImmutabilityPolicy
public Nullable`1<bool> LegalHold
public UploadTransferValidationOptions TransferValidation
public BlobHttpHeaders get_HttpHeaders()
public void set_HttpHeaders(BlobHttpHeaders value)
public IDictionary`2<string, string> get_Metadata()
public void set_Metadata(IDictionary`2<string, string> value)
public IDictionary`2<string, string> get_Tags()
public void set_Tags(IDictionary`2<string, string> value)
public BlobRequestConditions get_Conditions()
public void set_Conditions(BlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public Nullable`1<AccessTier> get_AccessTier()
public void set_AccessTier(Nullable`1<AccessTier> value)
public StorageTransferOptions get_TransferOptions()
public void set_TransferOptions(StorageTransferOptions value)
public BlobImmutabilityPolicy get_ImmutabilityPolicy()
public void set_ImmutabilityPolicy(BlobImmutabilityPolicy value)
public Nullable`1<bool> get_LegalHold()
public void set_LegalHold(Nullable`1<bool> value)
public UploadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(UploadTransferValidationOptions value)
}
public Azure.Storage.Blobs.Models.BlockBlobOpenWriteOptions : object {
private Nullable`1<long> <BufferSize>k__BackingField
private BlobRequestConditions <OpenConditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private BlobHttpHeaders <HttpHeaders>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
private UploadTransferValidationOptions <TransferValidation>k__BackingField
private string <OperationName>k__BackingField
public Nullable`1<long> BufferSize
public BlobRequestConditions OpenConditions
public IProgress`1<long> ProgressHandler
public BlobHttpHeaders HttpHeaders
public IDictionary`2<string, string> Metadata
public IDictionary`2<string, string> Tags
public UploadTransferValidationOptions TransferValidation
internal string OperationName
public Nullable`1<long> get_BufferSize()
public void set_BufferSize(Nullable`1<long> value)
public BlobRequestConditions get_OpenConditions()
public void set_OpenConditions(BlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public BlobHttpHeaders get_HttpHeaders()
public void set_HttpHeaders(BlobHttpHeaders value)
public IDictionary`2<string, string> get_Metadata()
public void set_Metadata(IDictionary`2<string, string> value)
public IDictionary`2<string, string> get_Tags()
public void set_Tags(IDictionary`2<string, string> value)
public UploadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(UploadTransferValidationOptions value)
internal string get_OperationName()
internal void set_OperationName(string value)
}
public Azure.Storage.Blobs.Models.BlockBlobStageBlockOptions : object {
private BlobRequestConditions <Conditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private UploadTransferValidationOptions <TransferValidation>k__BackingField
public BlobRequestConditions Conditions
public IProgress`1<long> ProgressHandler
public UploadTransferValidationOptions TransferValidation
public BlobRequestConditions get_Conditions()
public void set_Conditions(BlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public UploadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(UploadTransferValidationOptions value)
}
public Azure.Storage.Blobs.Models.BlockInfo : object {
private Byte[] <ContentHash>k__BackingField
private Byte[] <ContentCrc64>k__BackingField
private string <EncryptionKeySha256>k__BackingField
private string <EncryptionScope>k__BackingField
public Byte[] ContentHash
public Byte[] ContentCrc64
public string EncryptionKeySha256
public string EncryptionScope
public Byte[] get_ContentHash()
internal void set_ContentHash(Byte[] value)
public Byte[] get_ContentCrc64()
internal void set_ContentCrc64(Byte[] value)
public string get_EncryptionKeySha256()
internal void set_EncryptionKeySha256(string value)
public string get_EncryptionScope()
internal void set_EncryptionScope(string value)
}
public Azure.Storage.Blobs.Models.BlockList : object {
private DateTimeOffset <LastModified>k__BackingField
private ETag <ETag>k__BackingField
private string <ContentType>k__BackingField
private long <BlobContentLength>k__BackingField
private IEnumerable`1<BlobBlock> <CommittedBlocks>k__BackingField
private IEnumerable`1<BlobBlock> <UncommittedBlocks>k__BackingField
public DateTimeOffset LastModified
public ETag ETag
public string ContentType
public long BlobContentLength
public IEnumerable`1<BlobBlock> CommittedBlocks
public IEnumerable`1<BlobBlock> UncommittedBlocks
internal void .ctor(IEnumerable`1<BlobBlock> committedBlocks, IEnumerable`1<BlobBlock> uncommittedBlocks)
internal BlockList DeserializeBlockList(XElement element)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public ETag get_ETag()
internal void set_ETag(ETag value)
public string get_ContentType()
internal void set_ContentType(string value)
public long get_BlobContentLength()
internal void set_BlobContentLength(long value)
public IEnumerable`1<BlobBlock> get_CommittedBlocks()
internal void set_CommittedBlocks(IEnumerable`1<BlobBlock> value)
public IEnumerable`1<BlobBlock> get_UncommittedBlocks()
internal void set_UncommittedBlocks(IEnumerable`1<BlobBlock> value)
}
internal Azure.Storage.Blobs.Models.BlockListType : Enum {
public int value__
public BlockListType Committed
public BlockListType Uncommitted
public BlockListType All
}
internal Azure.Storage.Blobs.Models.BlockListTypeExtensions : object {
public string ToSerialString(BlockListType value)
public BlockListType ToBlockListType(string value)
}
public Azure.Storage.Blobs.Models.BlockListTypes : Enum {
public int value__
public BlockListTypes All
public BlockListTypes Committed
public BlockListTypes Uncommitted
}
internal Azure.Storage.Blobs.Models.BlockLookupList : object {
private IList`1<string> <Committed>k__BackingField
private IList`1<string> <Uncommitted>k__BackingField
private IList`1<string> <Latest>k__BackingField
public IList`1<string> Committed
public IList`1<string> Uncommitted
public IList`1<string> Latest
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
public IList`1<string> get_Committed()
public void set_Committed(IList`1<string> value)
public IList`1<string> get_Uncommitted()
public void set_Uncommitted(IList`1<string> value)
public IList`1<string> get_Latest()
public void set_Latest(IList`1<string> value)
}
internal Azure.Storage.Blobs.Models.ClearRange : object {
private long <Start>k__BackingField
private long <End>k__BackingField
public long Start
public long End
internal void .ctor(long start, long end)
public long get_Start()
public long get_End()
internal ClearRange DeserializeClearRange(XElement element)
}
public Azure.Storage.Blobs.Models.CommitBlockListOptions : object {
private BlobHttpHeaders <HttpHeaders>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
private BlobRequestConditions <Conditions>k__BackingField
private Nullable`1<AccessTier> <AccessTier>k__BackingField
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField
private Nullable`1<bool> <LegalHold>k__BackingField
public BlobHttpHeaders HttpHeaders
public IDictionary`2<string, string> Metadata
public IDictionary`2<string, string> Tags
public BlobRequestConditions Conditions
public Nullable`1<AccessTier> AccessTier
public BlobImmutabilityPolicy ImmutabilityPolicy
public Nullable`1<bool> LegalHold
public BlobHttpHeaders get_HttpHeaders()
public void set_HttpHeaders(BlobHttpHeaders value)
public IDictionary`2<string, string> get_Metadata()
public void set_Metadata(IDictionary`2<string, string> value)
public IDictionary`2<string, string> get_Tags()
public void set_Tags(IDictionary`2<string, string> value)
public BlobRequestConditions get_Conditions()
public void set_Conditions(BlobRequestConditions value)
public Nullable`1<AccessTier> get_AccessTier()
public void set_AccessTier(Nullable`1<AccessTier> value)
public BlobImmutabilityPolicy get_ImmutabilityPolicy()
public void set_ImmutabilityPolicy(BlobImmutabilityPolicy value)
public Nullable`1<bool> get_LegalHold()
public void set_LegalHold(Nullable`1<bool> value)
}
internal Azure.Storage.Blobs.Models.ContainerItemInternal : object {
private string <Name>k__BackingField
private Nullable`1<bool> <Deleted>k__BackingField
private string <Version>k__BackingField
private ContainerPropertiesInternal <Properties>k__BackingField
private IReadOnlyDictionary`2<string, string> <Metadata>k__BackingField
public string Name
public Nullable`1<bool> Deleted
public string Version
public ContainerPropertiesInternal Properties
public IReadOnlyDictionary`2<string, string> Metadata
internal void .ctor(string name, ContainerPropertiesInternal properties)
internal void .ctor(string name, Nullable`1<bool> deleted, string version, ContainerPropertiesInternal properties, IReadOnlyDictionary`2<string, string> metadata)
public string get_Name()
public Nullable`1<bool> get_Deleted()
public string get_Version()
public ContainerPropertiesInternal get_Properties()
public IReadOnlyDictionary`2<string, string> get_Metadata()
internal ContainerItemInternal DeserializeContainerItemInternal(XElement element)
}
internal Azure.Storage.Blobs.Models.ContainerPropertiesInternal : object {
private DateTimeOffset <LastModified>k__BackingField
private string <Etag>k__BackingField
private Nullable`1<LeaseStatus> <LeaseStatus>k__BackingField
private Nullable`1<LeaseState> <LeaseState>k__BackingField
private Nullable`1<LeaseDurationType> <LeaseDuration>k__BackingField
private Nullable`1<PublicAccessType> <PublicAccess>k__BackingField
private Nullable`1<bool> <HasImmutabilityPolicy>k__BackingField
private Nullable`1<bool> <HasLegalHold>k__BackingField
private string <DefaultEncryptionScope>k__BackingField
private Nullable`1<bool> <PreventEncryptionScopeOverride>k__BackingField
private Nullable`1<DateTimeOffset> <DeletedTime>k__BackingField
private Nullable`1<int> <RemainingRetentionDays>k__BackingField
private Nullable`1<bool> <IsImmutableStorageWithVersioningEnabled>k__BackingField
public DateTimeOffset LastModified
public string Etag
public Nullable`1<LeaseStatus> LeaseStatus
public Nullable`1<LeaseState> LeaseState
public Nullable`1<LeaseDurationType> LeaseDuration
public Nullable`1<PublicAccessType> PublicAccess
public Nullable`1<bool> HasImmutabilityPolicy
public Nullable`1<bool> HasLegalHold
public string DefaultEncryptionScope
public Nullable`1<bool> PreventEncryptionScopeOverride
public Nullable`1<DateTimeOffset> DeletedTime
public Nullable`1<int> RemainingRetentionDays
public Nullable`1<bool> IsImmutableStorageWithVersioningEnabled
internal void .ctor(DateTimeOffset lastModified, string etag)
internal void .ctor(DateTimeOffset lastModified, string etag, Nullable`1<LeaseStatus> leaseStatus, Nullable`1<LeaseState> leaseState, Nullable`1<LeaseDurationType> leaseDuration, Nullable`1<PublicAccessType> publicAccess, Nullable`1<bool> hasImmutabilityPolicy, Nullable`1<bool> hasLegalHold, string defaultEncryptionScope, Nullable`1<bool> preventEncryptionScopeOverride, Nullable`1<DateTimeOffset> deletedTime, Nullable`1<int> remainingRetentionDays, Nullable`1<bool> isImmutableStorageWithVersioningEnabled)
public DateTimeOffset get_LastModified()
public string get_Etag()
public Nullable`1<LeaseStatus> get_LeaseStatus()
public Nullable`1<LeaseState> get_LeaseState()
public Nullable`1<LeaseDurationType> get_LeaseDuration()
public Nullable`1<PublicAccessType> get_PublicAccess()
public Nullable`1<bool> get_HasImmutabilityPolicy()
public Nullable`1<bool> get_HasLegalHold()
public string get_DefaultEncryptionScope()
public Nullable`1<bool> get_PreventEncryptionScopeOverride()
public Nullable`1<DateTimeOffset> get_DeletedTime()
public Nullable`1<int> get_RemainingRetentionDays()
public Nullable`1<bool> get_IsImmutableStorageWithVersioningEnabled()
internal ContainerPropertiesInternal DeserializeContainerPropertiesInternal(XElement element)
}
internal Azure.Storage.Blobs.Models.ContentRange : ValueType {
private string WildcardMarker
private Nullable`1<long> <Start>k__BackingField
private Nullable`1<long> <End>k__BackingField
private Nullable`1<long> <Size>k__BackingField
private RangeUnit <Unit>k__BackingField
public Nullable`1<long> Start
public Nullable`1<long> End
public Nullable`1<long> Size
public RangeUnit Unit
public Nullable`1<long> get_Start()
public Nullable`1<long> get_End()
public Nullable`1<long> get_Size()
public RangeUnit get_Unit()
public void .ctor(RangeUnit unit, Nullable`1<long> start, Nullable`1<long> end, Nullable`1<long> size)
public ContentRange Parse(string headerValue)
}
public Azure.Storage.Blobs.Models.CopyFromUriOperation : Operation`1<long> {
private BlobBaseClient _client
private CancellationToken _cancellationToken
private bool _hasCompleted
private Nullable`1<long> _value
private Response _rawResponse
private string <Id>k__BackingField
public bool HasCompleted
public bool HasValue
public string Id
public long Value
public bool get_HasCompleted()
public bool get_HasValue()
public string get_Id()
public long get_Value()
public Response GetRawResponse()
public ValueTask`1<Response`1<long>> WaitForCompletionAsync(CancellationToken cancellationToken)
public ValueTask`1<Response`1<long>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
public void .ctor(string id, BlobBaseClient client)
internal void .ctor(BlobBaseClient client, string copyId, Response initialResponse, CancellationToken cancellationToken)
public Response UpdateStatus(CancellationToken cancellationToken)
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken)
private Task`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
}
public Azure.Storage.Blobs.Models.CopyStatus : Enum {
public int value__
public CopyStatus Pending
public CopyStatus Success
public CopyStatus Aborted
public CopyStatus Failed
}
internal Azure.Storage.Blobs.Models.CopyStatusExtensions : object {
public string ToSerialString(CopyStatus value)
public CopyStatus ToCopyStatus(string value)
}
public Azure.Storage.Blobs.Models.CustomerProvidedKey : ValueType {
private string <EncryptionKey>k__BackingField
private string <EncryptionKeyHash>k__BackingField
private EncryptionAlgorithmType <EncryptionAlgorithm>k__BackingField
public string EncryptionKey
public string EncryptionKeyHash
public EncryptionAlgorithmType EncryptionAlgorithm
public string get_EncryptionKey()
public string get_EncryptionKeyHash()
public EncryptionAlgorithmType get_EncryptionAlgorithm()
public void .ctor(string key)
public void .ctor(Byte[] key)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CustomerProvidedKey left, CustomerProvidedKey right)
public bool op_Inequality(CustomerProvidedKey left, CustomerProvidedKey right)
public bool Equals(CustomerProvidedKey other)
public string ToString()
}
public Azure.Storage.Blobs.Models.DeleteSnapshotsOption : Enum {
public int value__
public DeleteSnapshotsOption None
public DeleteSnapshotsOption IncludeSnapshots
public DeleteSnapshotsOption OnlySnapshots
}
internal Azure.Storage.Blobs.Models.DeleteSnapshotsOptionExtensions : object {
public string ToSerialString(DeleteSnapshotsOption value)
public DeleteSnapshotsOption ToDeleteSnapshotsOption(string value)
}
internal Azure.Storage.Blobs.Models.DelimitedTextConfigurationInternal : object {
private string <ColumnSeparator>k__BackingField
private string <FieldQuote>k__BackingField
private string <RecordSeparator>k__BackingField
private string <EscapeChar>k__BackingField
private Nullable`1<bool> <HeadersPresent>k__BackingField
public string ColumnSeparator
public string FieldQuote
public string RecordSeparator
public string EscapeChar
public Nullable`1<bool> HeadersPresent
public string get_ColumnSeparator()
public void set_ColumnSeparator(string value)
public string get_FieldQuote()
public void set_FieldQuote(string value)
public string get_RecordSeparator()
public void set_RecordSeparator(string value)
public string get_EscapeChar()
public void set_EscapeChar(string value)
public Nullable`1<bool> get_HeadersPresent()
public void set_HeadersPresent(Nullable`1<bool> value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
}
public Azure.Storage.Blobs.Models.EncryptionAlgorithmType : Enum {
public int value__
public EncryptionAlgorithmType Aes256
}
internal Azure.Storage.Blobs.Models.EncryptionAlgorithmTypeInternal : Enum {
public int value__
public EncryptionAlgorithmTypeInternal None
public EncryptionAlgorithmTypeInternal AES256
}
internal Azure.Storage.Blobs.Models.EncryptionAlgorithmTypeInternalExtensions : object {
public string ToSerialString(EncryptionAlgorithmTypeInternal value)
public EncryptionAlgorithmTypeInternal ToEncryptionAlgorithmTypeInternal(string value)
}
internal Azure.Storage.Blobs.Models.FilterBlobItem : object {
private string <Name>k__BackingField
private string <ContainerName>k__BackingField
private BlobTags <Tags>k__BackingField
private string <VersionId>k__BackingField
private Nullable`1<bool> <IsCurrentVersion>k__BackingField
public string Name
public string ContainerName
public BlobTags Tags
public string VersionId
public Nullable`1<bool> IsCurrentVersion
internal void .ctor(string name, string containerName)
internal void .ctor(string name, string containerName, BlobTags tags, string versionId, Nullable`1<bool> isCurrentVersion)
public string get_Name()
public string get_ContainerName()
public BlobTags get_Tags()
public string get_VersionId()
public Nullable`1<bool> get_IsCurrentVersion()
internal FilterBlobItem DeserializeFilterBlobItem(XElement element)
}
internal Azure.Storage.Blobs.Models.FilterBlobsAsyncCollection : StorageCollectionEnumerator`1<TaggedBlobItem> {
private BlobServiceClient _serviceClient
private BlobContainerClient _containerClient
private string _expression
public void .ctor(BlobServiceClient serviceClient, string expression)
public void .ctor(BlobContainerClient containerClient, string expression)
public ValueTask`1<Page`1<TaggedBlobItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.Blobs.Models.FilterBlobSegment : object {
private string <ServiceEndpoint>k__BackingField
private string <Where>k__BackingField
private IReadOnlyList`1<FilterBlobItem> <Blobs>k__BackingField
private string <NextMarker>k__BackingField
public string ServiceEndpoint
public string Where
public IReadOnlyList`1<FilterBlobItem> Blobs
public string NextMarker
internal void .ctor(string serviceEndpoint, string where, IEnumerable`1<FilterBlobItem> blobs)
internal void .ctor(string serviceEndpoint, string where, IReadOnlyList`1<FilterBlobItem> blobs, string nextMarker)
public string get_ServiceEndpoint()
public string get_Where()
public IReadOnlyList`1<FilterBlobItem> get_Blobs()
public string get_NextMarker()
internal FilterBlobSegment DeserializeFilterBlobSegment(XElement element)
}
internal Azure.Storage.Blobs.Models.FilterBlobsIncludeItem : Enum {
public int value__
public FilterBlobsIncludeItem None
public FilterBlobsIncludeItem Versions
}
internal Azure.Storage.Blobs.Models.FilterBlobsIncludeItemExtensions : object {
public string ToSerialString(FilterBlobsIncludeItem value)
public FilterBlobsIncludeItem ToFilterBlobsIncludeItem(string value)
}
internal Azure.Storage.Blobs.Models.GetBlobContainersAsyncCollection : StorageCollectionEnumerator`1<BlobContainerItem> {
private BlobServiceClient _client
private BlobContainerTraits _traits
private BlobContainerStates _states
private string _prefix
public void .ctor(BlobServiceClient client, BlobContainerTraits traits, BlobContainerStates states, string prefix)
public ValueTask`1<Page`1<BlobContainerItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.Blobs.Models.GetBlobsAsyncCollection : StorageCollectionEnumerator`1<BlobItem> {
private BlobContainerClient _client
private BlobTraits _traits
private BlobStates _states
private string _prefix
public void .ctor(BlobContainerClient client, BlobTraits traits, BlobStates states, string prefix)
public ValueTask`1<Page`1<BlobItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.Blobs.Models.GetBlobsByHierarchyAsyncCollection : StorageCollectionEnumerator`1<BlobHierarchyItem> {
private BlobContainerClient _client
private BlobTraits _traits
private BlobStates _states
private string _delimiter
private string _prefix
public void .ctor(BlobContainerClient client, string delimiter, BlobTraits traits, BlobStates states, string prefix)
public ValueTask`1<Page`1<BlobHierarchyItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
}
public Azure.Storage.Blobs.Models.GetBlobTagResult : object {
private IDictionary`2<string, string> <Tags>k__BackingField
public IDictionary`2<string, string> Tags
public IDictionary`2<string, string> get_Tags()
internal void set_Tags(IDictionary`2<string, string> value)
}
internal Azure.Storage.Blobs.Models.GetPageRangesAsyncCollection : StorageCollectionEnumerator`1<PageRangeItem> {
private bool _diff
private PageBlobClient _client
private Nullable`1<HttpRange> _range
private string _snapshot
private string _previousSnapshot
private Uri _previousSnapshotUri
private PageBlobRequestConditions _requestConditions
private string _operationName
public void .ctor(bool diff, PageBlobClient client, Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, Uri previousSnapshotUri, PageBlobRequestConditions requestConditions, string operationName)
public ValueTask`1<Page`1<PageRangeItem>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
}
public Azure.Storage.Blobs.Models.GetPageRangesDiffOptions : object {
private Nullable`1<HttpRange> <Range>k__BackingField
private string <Snapshot>k__BackingField
private string <PreviousSnapshot>k__BackingField
private PageBlobRequestConditions <Conditions>k__BackingField
public Nullable`1<HttpRange> Range
public string Snapshot
public string PreviousSnapshot
public PageBlobRequestConditions Conditions
public Nullable`1<HttpRange> get_Range()
public void set_Range(Nullable`1<HttpRange> value)
public string get_Snapshot()
public void set_Snapshot(string value)
public string get_PreviousSnapshot()
public void set_PreviousSnapshot(string value)
public PageBlobRequestConditions get_Conditions()
public void set_Conditions(PageBlobRequestConditions value)
}
public Azure.Storage.Blobs.Models.GetPageRangesOptions : object {
private Nullable`1<HttpRange> <Range>k__BackingField
private string <Snapshot>k__BackingField
private PageBlobRequestConditions <Conditions>k__BackingField
public Nullable`1<HttpRange> Range
public string Snapshot
public PageBlobRequestConditions Conditions
public Nullable`1<HttpRange> get_Range()
public void set_Range(Nullable`1<HttpRange> value)
public string get_Snapshot()
public void set_Snapshot(string value)
public PageBlobRequestConditions get_Conditions()
public void set_Conditions(PageBlobRequestConditions value)
}
internal Azure.Storage.Blobs.Models.JsonTextConfigurationInternal : object {
private string <RecordSeparator>k__BackingField
public string RecordSeparator
public string get_RecordSeparator()
public void set_RecordSeparator(string value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
}
internal Azure.Storage.Blobs.Models.KeyInfo : object {
private string <Start>k__BackingField
private string <Expiry>k__BackingField
public string Start
public string Expiry
public void .ctor(string expiry)
public string get_Start()
public void set_Start(string value)
public string get_Expiry()
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
}
public Azure.Storage.Blobs.Models.LeaseDurationType : Enum {
public int value__
public LeaseDurationType Infinite
public LeaseDurationType Fixed
}
internal Azure.Storage.Blobs.Models.LeaseDurationTypeExtensions : object {
public string ToSerialString(LeaseDurationType value)
public LeaseDurationType ToLeaseDurationType(string value)
}
public Azure.Storage.Blobs.Models.LeaseState : Enum {
public int value__
public LeaseState Available
public LeaseState Leased
public LeaseState Expired
public LeaseState Breaking
public LeaseState Broken
}
internal Azure.Storage.Blobs.Models.LeaseStateExtensions : object {
public string ToSerialString(LeaseState value)
public LeaseState ToLeaseState(string value)
}
public Azure.Storage.Blobs.Models.LeaseStatus : Enum {
public int value__
public LeaseStatus Locked
public LeaseStatus Unlocked
}
internal Azure.Storage.Blobs.Models.LeaseStatusExtensions : object {
public string ToSerialString(LeaseStatus value)
public LeaseStatus ToLeaseStatus(string value)
}
internal Azure.Storage.Blobs.Models.ListBlobsFlatSegmentResponse : object {
private string <ServiceEndpoint>k__BackingField
private string <ContainerName>k__BackingField
private string <Prefix>k__BackingField
private string <Marker>k__BackingField
private Nullable`1<int> <MaxResults>k__BackingField
private BlobFlatListSegment <Segment>k__BackingField
private string <NextMarker>k__BackingField
public string ServiceEndpoint
public string ContainerName
public string Prefix
public string Marker
public Nullable`1<int> MaxResults
public BlobFlatListSegment Segment
public string NextMarker
internal void .ctor(string serviceEndpoint, string containerName, BlobFlatListSegment segment)
internal void .ctor(string serviceEndpoint, string containerName, string prefix, string marker, Nullable`1<int> maxResults, BlobFlatListSegment segment, string nextMarker)
public string get_ServiceEndpoint()
public string get_ContainerName()
public string get_Prefix()
public string get_Marker()
public Nullable`1<int> get_MaxResults()
public BlobFlatListSegment get_Segment()
public string get_NextMarker()
internal ListBlobsFlatSegmentResponse DeserializeListBlobsFlatSegmentResponse(XElement element)
}
internal Azure.Storage.Blobs.Models.ListBlobsHierarchySegmentResponse : object {
private string <ServiceEndpoint>k__BackingField
private string <ContainerName>k__BackingField
private string <Prefix>k__BackingField
private string <Marker>k__BackingField
private Nullable`1<int> <MaxResults>k__BackingField
private string <Delimiter>k__BackingField
private BlobHierarchyListSegment <Segment>k__BackingField
private string <NextMarker>k__BackingField
public string ServiceEndpoint
public string ContainerName
public string Prefix
public string Marker
public Nullable`1<int> MaxResults
public string Delimiter
public BlobHierarchyListSegment Segment
public string NextMarker
internal void .ctor(string serviceEndpoint, string containerName, BlobHierarchyListSegment segment)
internal void .ctor(string serviceEndpoint, string containerName, string prefix, string marker, Nullable`1<int> maxResults, string delimiter, BlobHierarchyListSegment segment, string nextMarker)
public string get_ServiceEndpoint()
public string get_ContainerName()
public string get_Prefix()
public string get_Marker()
public Nullable`1<int> get_MaxResults()
public string get_Delimiter()
public BlobHierarchyListSegment get_Segment()
public string get_NextMarker()
internal ListBlobsHierarchySegmentResponse DeserializeListBlobsHierarchySegmentResponse(XElement element)
}
internal Azure.Storage.Blobs.Models.ListBlobsIncludeItem : Enum {
public int value__
public ListBlobsIncludeItem Copy
public ListBlobsIncludeItem Deleted
public ListBlobsIncludeItem Metadata
public ListBlobsIncludeItem Snapshots
public ListBlobsIncludeItem Uncommittedblobs
public ListBlobsIncludeItem Versions
public ListBlobsIncludeItem Tags
public ListBlobsIncludeItem Immutabilitypolicy
public ListBlobsIncludeItem Legalhold
public ListBlobsIncludeItem DeletedWithVersions
}
internal Azure.Storage.Blobs.Models.ListBlobsIncludeItemExtensions : object {
public string ToSerialString(ListBlobsIncludeItem value)
public ListBlobsIncludeItem ToListBlobsIncludeItem(string value)
}
internal Azure.Storage.Blobs.Models.ListContainersIncludeType : Enum {
public int value__
public ListContainersIncludeType Metadata
public ListContainersIncludeType Deleted
public ListContainersIncludeType System
}
internal Azure.Storage.Blobs.Models.ListContainersIncludeTypeExtensions : object {
public string ToSerialString(ListContainersIncludeType value)
public ListContainersIncludeType ToListContainersIncludeType(string value)
}
internal Azure.Storage.Blobs.Models.ListContainersSegmentResponse : object {
private string <ServiceEndpoint>k__BackingField
private string <Prefix>k__BackingField
private string <Marker>k__BackingField
private Nullable`1<int> <MaxResults>k__BackingField
private IReadOnlyList`1<ContainerItemInternal> <ContainerItems>k__BackingField
private string <NextMarker>k__BackingField
public string ServiceEndpoint
public string Prefix
public string Marker
public Nullable`1<int> MaxResults
public IReadOnlyList`1<ContainerItemInternal> ContainerItems
public string NextMarker
internal void .ctor(string serviceEndpoint, IEnumerable`1<ContainerItemInternal> containerItems)
internal void .ctor(string serviceEndpoint, string prefix, string marker, Nullable`1<int> maxResults, IReadOnlyList`1<ContainerItemInternal> containerItems, string nextMarker)
public string get_ServiceEndpoint()
public string get_Prefix()
public string get_Marker()
public Nullable`1<int> get_MaxResults()
public IReadOnlyList`1<ContainerItemInternal> get_ContainerItems()
public string get_NextMarker()
internal ListContainersSegmentResponse DeserializeListContainersSegmentResponse(XElement element)
}
public Azure.Storage.Blobs.Models.ObjectReplicationPolicy : object {
private string <PolicyId>k__BackingField
private IList`1<ObjectReplicationRule> <Rules>k__BackingField
public string PolicyId
public IList`1<ObjectReplicationRule> Rules
public string get_PolicyId()
internal void set_PolicyId(string value)
public IList`1<ObjectReplicationRule> get_Rules()
internal void set_Rules(IList`1<ObjectReplicationRule> value)
}
public Azure.Storage.Blobs.Models.ObjectReplicationRule : object {
private string <RuleId>k__BackingField
private ObjectReplicationStatus <ReplicationStatus>k__BackingField
public string RuleId
public ObjectReplicationStatus ReplicationStatus
public string get_RuleId()
internal void set_RuleId(string value)
public ObjectReplicationStatus get_ReplicationStatus()
internal void set_ReplicationStatus(ObjectReplicationStatus value)
}
public Azure.Storage.Blobs.Models.ObjectReplicationStatus : Enum {
public int value__
public ObjectReplicationStatus Complete
public ObjectReplicationStatus Failed
}
public Azure.Storage.Blobs.Models.PageBlobCreateOptions : object {
private Nullable`1<long> <SequenceNumber>k__BackingField
private BlobHttpHeaders <HttpHeaders>k__BackingField
private PageBlobRequestConditions <Conditions>k__BackingField
private IDictionary`2<string, string> <Metadata>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
private BlobImmutabilityPolicy <ImmutabilityPolicy>k__BackingField
private Nullable`1<bool> <LegalHold>k__BackingField
public Nullable`1<long> SequenceNumber
public BlobHttpHeaders HttpHeaders
public PageBlobRequestConditions Conditions
public IDictionary`2<string, string> Metadata
public IDictionary`2<string, string> Tags
public BlobImmutabilityPolicy ImmutabilityPolicy
public Nullable`1<bool> LegalHold
public Nullable`1<long> get_SequenceNumber()
public void set_SequenceNumber(Nullable`1<long> value)
public BlobHttpHeaders get_HttpHeaders()
public void set_HttpHeaders(BlobHttpHeaders value)
public PageBlobRequestConditions get_Conditions()
public void set_Conditions(PageBlobRequestConditions value)
public IDictionary`2<string, string> get_Metadata()
public void set_Metadata(IDictionary`2<string, string> value)
public IDictionary`2<string, string> get_Tags()
public void set_Tags(IDictionary`2<string, string> value)
public BlobImmutabilityPolicy get_ImmutabilityPolicy()
public void set_ImmutabilityPolicy(BlobImmutabilityPolicy value)
public Nullable`1<bool> get_LegalHold()
public void set_LegalHold(Nullable`1<bool> value)
}
public Azure.Storage.Blobs.Models.PageBlobInfo : object {
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private long <BlobSequenceNumber>k__BackingField
public ETag ETag
public DateTimeOffset LastModified
public long BlobSequenceNumber
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public long get_BlobSequenceNumber()
internal void set_BlobSequenceNumber(long value)
}
public Azure.Storage.Blobs.Models.PageBlobOpenWriteOptions : object {
private Nullable`1<long> <BufferSize>k__BackingField
private PageBlobRequestConditions <OpenConditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private Nullable`1<long> <Size>k__BackingField
private UploadTransferValidationOptions <TransferValidation>k__BackingField
public Nullable`1<long> BufferSize
public PageBlobRequestConditions OpenConditions
public IProgress`1<long> ProgressHandler
public Nullable`1<long> Size
public UploadTransferValidationOptions TransferValidation
public Nullable`1<long> get_BufferSize()
public void set_BufferSize(Nullable`1<long> value)
public PageBlobRequestConditions get_OpenConditions()
public void set_OpenConditions(PageBlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public Nullable`1<long> get_Size()
public void set_Size(Nullable`1<long> value)
public UploadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(UploadTransferValidationOptions value)
}
public Azure.Storage.Blobs.Models.PageBlobRequestConditions : BlobRequestConditions {
private Nullable`1<long> <IfSequenceNumberLessThan>k__BackingField
private Nullable`1<long> <IfSequenceNumberLessThanOrEqual>k__BackingField
private Nullable`1<long> <IfSequenceNumberEqual>k__BackingField
public Nullable`1<long> IfSequenceNumberLessThan
public Nullable`1<long> IfSequenceNumberLessThanOrEqual
public Nullable`1<long> IfSequenceNumberEqual
public Nullable`1<long> get_IfSequenceNumberLessThan()
public void set_IfSequenceNumberLessThan(Nullable`1<long> value)
public Nullable`1<long> get_IfSequenceNumberLessThanOrEqual()
public void set_IfSequenceNumberLessThanOrEqual(Nullable`1<long> value)
public Nullable`1<long> get_IfSequenceNumberEqual()
public void set_IfSequenceNumberEqual(Nullable`1<long> value)
internal void AddConditions(StringBuilder conditions)
}
public Azure.Storage.Blobs.Models.PageBlobUploadPagesFromUriOptions : object {
private Byte[] <SourceContentHash>k__BackingField
private PageBlobRequestConditions <DestinationConditions>k__BackingField
private PageBlobRequestConditions <SourceConditions>k__BackingField
private HttpAuthorization <SourceAuthentication>k__BackingField
public Byte[] SourceContentHash
public PageBlobRequestConditions DestinationConditions
public PageBlobRequestConditions SourceConditions
public HttpAuthorization SourceAuthentication
public Byte[] get_SourceContentHash()
public void set_SourceContentHash(Byte[] value)
public PageBlobRequestConditions get_DestinationConditions()
public void set_DestinationConditions(PageBlobRequestConditions value)
public PageBlobRequestConditions get_SourceConditions()
public void set_SourceConditions(PageBlobRequestConditions value)
public HttpAuthorization get_SourceAuthentication()
public void set_SourceAuthentication(HttpAuthorization value)
}
public Azure.Storage.Blobs.Models.PageBlobUploadPagesOptions : object {
private PageBlobRequestConditions <Conditions>k__BackingField
private IProgress`1<long> <ProgressHandler>k__BackingField
private UploadTransferValidationOptions <TransferValidation>k__BackingField
public PageBlobRequestConditions Conditions
public IProgress`1<long> ProgressHandler
public UploadTransferValidationOptions TransferValidation
public PageBlobRequestConditions get_Conditions()
public void set_Conditions(PageBlobRequestConditions value)
public IProgress`1<long> get_ProgressHandler()
public void set_ProgressHandler(IProgress`1<long> value)
public UploadTransferValidationOptions get_TransferValidation()
public void set_TransferValidation(UploadTransferValidationOptions value)
}
public Azure.Storage.Blobs.Models.PageInfo : object {
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
private Byte[] <ContentHash>k__BackingField
private Byte[] <ContentCrc64>k__BackingField
private long <BlobSequenceNumber>k__BackingField
private string <EncryptionKeySha256>k__BackingField
private string <EncryptionScope>k__BackingField
public ETag ETag
public DateTimeOffset LastModified
public Byte[] ContentHash
public Byte[] ContentCrc64
public long BlobSequenceNumber
public string EncryptionKeySha256
public string EncryptionScope
public ETag get_ETag()
internal void set_ETag(ETag value)
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public Byte[] get_ContentHash()
internal void set_ContentHash(Byte[] value)
public Byte[] get_ContentCrc64()
internal void set_ContentCrc64(Byte[] value)
public long get_BlobSequenceNumber()
internal void set_BlobSequenceNumber(long value)
public string get_EncryptionKeySha256()
internal void set_EncryptionKeySha256(string value)
public string get_EncryptionScope()
internal void set_EncryptionScope(string value)
}
internal Azure.Storage.Blobs.Models.PageList : object {
private IReadOnlyList`1<PageRange> <PageRange>k__BackingField
private IReadOnlyList`1<ClearRange> <ClearRange>k__BackingField
private string <NextMarker>k__BackingField
public IReadOnlyList`1<PageRange> PageRange
public IReadOnlyList`1<ClearRange> ClearRange
public string NextMarker
internal void .ctor(IReadOnlyList`1<PageRange> pageRange, IReadOnlyList`1<ClearRange> clearRange, string nextMarker)
public IReadOnlyList`1<PageRange> get_PageRange()
public IReadOnlyList`1<ClearRange> get_ClearRange()
public string get_NextMarker()
internal PageList DeserializePageList(XElement element)
}
internal Azure.Storage.Blobs.Models.PageRange : ValueType {
private long <Start>k__BackingField
private long <End>k__BackingField
public long Start
public long End
public long get_Start()
public long get_End()
internal PageRange DeserializePageRange(XElement element)
internal void .ctor(long start, long end)
public bool Equals(PageRange other)
public bool Equals(object obj)
public int GetHashCode()
}
public Azure.Storage.Blobs.Models.PageRangeItem : object {
private HttpRange <Range>k__BackingField
private bool <IsClear>k__BackingField
public HttpRange Range
public bool IsClear
public HttpRange get_Range()
internal void set_Range(HttpRange value)
public bool get_IsClear()
internal void set_IsClear(bool value)
}
public Azure.Storage.Blobs.Models.PageRangesInfo : object {
private DateTimeOffset <LastModified>k__BackingField
private ETag <ETag>k__BackingField
private long <BlobContentLength>k__BackingField
private IEnumerable`1<HttpRange> <PageRanges>k__BackingField
private IEnumerable`1<HttpRange> <ClearRanges>k__BackingField
public DateTimeOffset LastModified
public ETag ETag
public long BlobContentLength
public IEnumerable`1<HttpRange> PageRanges
public IEnumerable`1<HttpRange> ClearRanges
public DateTimeOffset get_LastModified()
internal void set_LastModified(DateTimeOffset value)
public ETag get_ETag()
internal void set_ETag(ETag value)
public long get_BlobContentLength()
internal void set_BlobContentLength(long value)
public IEnumerable`1<HttpRange> get_PageRanges()
internal void set_PageRanges(IEnumerable`1<HttpRange> value)
public IEnumerable`1<HttpRange> get_ClearRanges()
internal void set_ClearRanges(IEnumerable`1<HttpRange> value)
}
public Azure.Storage.Blobs.Models.PathRenameMode : Enum {
public int value__
public PathRenameMode Legacy
public PathRenameMode Posix
}
internal Azure.Storage.Blobs.Models.PremiumPageBlobAccessTier : ValueType {
private string _value
private string P4Value
private string P6Value
private string P10Value
private string P15Value
private string P20Value
private string P30Value
private string P40Value
private string P50Value
private string P60Value
private string P70Value
private string P80Value
private PremiumPageBlobAccessTier <P4>k__BackingField
private PremiumPageBlobAccessTier <P6>k__BackingField
private PremiumPageBlobAccessTier <P10>k__BackingField
private PremiumPageBlobAccessTier <P15>k__BackingField
private PremiumPageBlobAccessTier <P20>k__BackingField
private PremiumPageBlobAccessTier <P30>k__BackingField
private PremiumPageBlobAccessTier <P40>k__BackingField
private PremiumPageBlobAccessTier <P50>k__BackingField
private PremiumPageBlobAccessTier <P60>k__BackingField
private PremiumPageBlobAccessTier <P70>k__BackingField
private PremiumPageBlobAccessTier <P80>k__BackingField
public PremiumPageBlobAccessTier P4
public PremiumPageBlobAccessTier P6
public PremiumPageBlobAccessTier P10
public PremiumPageBlobAccessTier P15
public PremiumPageBlobAccessTier P20
public PremiumPageBlobAccessTier P30
public PremiumPageBlobAccessTier P40
public PremiumPageBlobAccessTier P50
public PremiumPageBlobAccessTier P60
public PremiumPageBlobAccessTier P70
public PremiumPageBlobAccessTier P80
public void .ctor(string value)
public PremiumPageBlobAccessTier get_P4()
public PremiumPageBlobAccessTier get_P6()
public PremiumPageBlobAccessTier get_P10()
public PremiumPageBlobAccessTier get_P15()
public PremiumPageBlobAccessTier get_P20()
public PremiumPageBlobAccessTier get_P30()
public PremiumPageBlobAccessTier get_P40()
public PremiumPageBlobAccessTier get_P50()
public PremiumPageBlobAccessTier get_P60()
public PremiumPageBlobAccessTier get_P70()
public PremiumPageBlobAccessTier get_P80()
public bool op_Equality(PremiumPageBlobAccessTier left, PremiumPageBlobAccessTier right)
public bool op_Inequality(PremiumPageBlobAccessTier left, PremiumPageBlobAccessTier right)
public PremiumPageBlobAccessTier op_Implicit(string value)
public bool Equals(object obj)
public bool Equals(PremiumPageBlobAccessTier other)
public int GetHashCode()
public string ToString()
}
public Azure.Storage.Blobs.Models.PublicAccessType : Enum {
public int value__
public PublicAccessType None
public PublicAccessType BlobContainer
public PublicAccessType Blob
}
internal Azure.Storage.Blobs.Models.PublicAccessTypeExtensions : object {
public string ToSerialString(PublicAccessType value)
public PublicAccessType ToPublicAccessType(string value)
}
internal Azure.Storage.Blobs.Models.QueryFormat : object {
private QueryFormatType <Type>k__BackingField
private DelimitedTextConfigurationInternal <DelimitedTextConfiguration>k__BackingField
private JsonTextConfigurationInternal <JsonTextConfiguration>k__BackingField
private ArrowTextConfigurationInternal <ArrowConfiguration>k__BackingField
private object <ParquetTextConfiguration>k__BackingField
public QueryFormatType Type
public DelimitedTextConfigurationInternal DelimitedTextConfiguration
public JsonTextConfigurationInternal JsonTextConfiguration
public ArrowTextConfigurationInternal ArrowConfiguration
public object ParquetTextConfiguration
public void .ctor(QueryFormatType type)
public QueryFormatType get_Type()
public DelimitedTextConfigurationInternal get_DelimitedTextConfiguration()
public void set_DelimitedTextConfiguration(DelimitedTextConfigurationInternal value)
public JsonTextConfigurationInternal get_JsonTextConfiguration()
public void set_JsonTextConfiguration(JsonTextConfigurationInternal value)
public ArrowTextConfigurationInternal get_ArrowConfiguration()
public void set_ArrowConfiguration(ArrowTextConfigurationInternal value)
public object get_ParquetTextConfiguration()
public void set_ParquetTextConfiguration(object value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
}
internal Azure.Storage.Blobs.Models.QueryFormatType : Enum {
public int value__
public QueryFormatType Delimited
public QueryFormatType Json
public QueryFormatType Arrow
public QueryFormatType Parquet
}
internal Azure.Storage.Blobs.Models.QueryFormatTypeExtensions : object {
public string ToSerialString(QueryFormatType value)
public QueryFormatType ToQueryFormatType(string value)
}
internal Azure.Storage.Blobs.Models.QueryRequest : object {
private QuerySerialization <InputSerialization>k__BackingField
private QuerySerialization <OutputSerialization>k__BackingField
private string <QueryType>k__BackingField
private string <Expression>k__BackingField
public QuerySerialization InputSerialization
public QuerySerialization OutputSerialization
public string QueryType
public string Expression
public void .ctor(string expression)
public QuerySerialization get_InputSerialization()
public void set_InputSerialization(QuerySerialization value)
public QuerySerialization get_OutputSerialization()
public void set_OutputSerialization(QuerySerialization value)
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
public string get_QueryType()
public void set_QueryType(string value)
public string get_Expression()
public void set_Expression(string value)
}
internal Azure.Storage.Blobs.Models.QuerySerialization : object {
private QueryFormat <Format>k__BackingField
public QueryFormat Format
public void .ctor(QueryFormat format)
public QueryFormat get_Format()
private void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
}
public Azure.Storage.Blobs.Models.RehydratePriority : Enum {
public int value__
public RehydratePriority High
public RehydratePriority Standard
}
internal Azure.Storage.Blobs.Models.RehydratePriorityExtensions : object {
public string ToSerialString(RehydratePriority value)
public RehydratePriority ToRehydratePriority(string value)
}
public Azure.Storage.Blobs.Models.ReleasedObjectInfo : object {
private ETag <ETag>k__BackingField
private DateTimeOffset <LastModified>k__BackingField
public ETag ETag
public DateTimeOffset LastModified
public ETag get_ETag()
public DateTimeOffset get_LastModified()
public void .ctor(ETag eTag, DateTimeOffset lastModified)
internal void .ctor(BlobInfo info)
internal void .ctor(BlobContainerInfo info)
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
public Azure.Storage.Blobs.Models.SequenceNumberAction : Enum {
public int value__
public SequenceNumberAction Max
public SequenceNumberAction Update
public SequenceNumberAction Increment
}
internal Azure.Storage.Blobs.Models.SequenceNumberActionExtensions : object {
public string ToSerialString(SequenceNumberAction value)
public SequenceNumberAction ToSequenceNumberAction(string value)
}
public Azure.Storage.Blobs.Models.SkuName : Enum {
public int value__
public SkuName StandardLrs
public SkuName StandardGrs
public SkuName StandardRagrs
public SkuName StandardZrs
public SkuName PremiumLrs
}
internal Azure.Storage.Blobs.Models.SkuNameExtensions : object {
public string ToSerialString(SkuName value)
public SkuName ToSkuName(string value)
}
public Azure.Storage.Blobs.Models.StageBlockFromUriOptions : object {
private HttpRange <SourceRange>k__BackingField
private Byte[] <SourceContentHash>k__BackingField
private RequestConditions <SourceConditions>k__BackingField
private BlobRequestConditions <DestinationConditions>k__BackingField
private HttpAuthorization <SourceAuthentication>k__BackingField
public HttpRange SourceRange
public Byte[] SourceContentHash
public RequestConditions SourceConditions
public BlobRequestConditions DestinationConditions
public HttpAuthorization SourceAuthentication
public HttpRange get_SourceRange()
public void set_SourceRange(HttpRange value)
public Byte[] get_SourceContentHash()
public void set_SourceContentHash(Byte[] value)
public RequestConditions get_SourceConditions()
public void set_SourceConditions(RequestConditions value)
public BlobRequestConditions get_DestinationConditions()
public void set_DestinationConditions(BlobRequestConditions value)
public HttpAuthorization get_SourceAuthentication()
public void set_SourceAuthentication(HttpAuthorization value)
}
internal Azure.Storage.Blobs.Models.StorageError : object {
private string <Message>k__BackingField
public string Message
internal void .ctor(string message)
public string get_Message()
internal StorageError DeserializeStorageError(XElement element)
}
public Azure.Storage.Blobs.Models.TaggedBlobItem : object {
private string <BlobName>k__BackingField
private string <BlobContainerName>k__BackingField
private IDictionary`2<string, string> <Tags>k__BackingField
public string BlobName
public string BlobContainerName
public IDictionary`2<string, string> Tags
public string get_BlobName()
internal void set_BlobName(string value)
public string get_BlobContainerName()
internal void set_BlobContainerName(string value)
public IDictionary`2<string, string> get_Tags()
internal void set_Tags(IDictionary`2<string, string> value)
}
public Azure.Storage.Blobs.Models.UserDelegationKey : object {
private string <SignedObjectId>k__BackingField
private string <SignedTenantId>k__BackingField
private DateTimeOffset <SignedExpiresOn>k__BackingField
private DateTimeOffset <SignedStartsOn>k__BackingField
private string <SignedService>k__BackingField
private string <SignedVersion>k__BackingField
private string <Value>k__BackingField
public string SignedObjectId
public string SignedTenantId
public DateTimeOffset SignedExpiresOn
public DateTimeOffset SignedStartsOn
public string SignedService
public string SignedVersion
public string Value
internal void .ctor(string signedObjectId, string signedTenantId, DateTimeOffset signedStartsOn, DateTimeOffset signedExpiresOn, string signedService, string signedVersion, string value)
internal UserDelegationKey DeserializeUserDelegationKey(XElement element)
public string get_SignedObjectId()
internal void set_SignedObjectId(string value)
public string get_SignedTenantId()
internal void set_SignedTenantId(string value)
public DateTimeOffset get_SignedExpiresOn()
internal void set_SignedExpiresOn(DateTimeOffset value)
public DateTimeOffset get_SignedStartsOn()
internal void set_SignedStartsOn(DateTimeOffset value)
public string get_SignedService()
internal void set_SignedService(string value)
public string get_SignedVersion()
internal void set_SignedVersion(string value)
public string get_Value()
internal void set_Value(string value)
}
internal Azure.Storage.Blobs.PageBlobClearPagesHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public Byte[] XMsContentCrc64
public Nullable`1<long> BlobSequenceNumber
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public Byte[] get_XMsContentCrc64()
public Nullable`1<long> get_BlobSequenceNumber()
public string get_Version()
}
internal Azure.Storage.Blobs.PageBlobCopyIncrementalHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public string Version
public string CopyId
public Nullable`1<CopyStatus> CopyStatus
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public string get_Version()
public string get_CopyId()
public Nullable`1<CopyStatus> get_CopyStatus()
}
internal Azure.Storage.Blobs.PageBlobCreateHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public string Version
public string VersionId
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public string get_Version()
public string get_VersionId()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.PageBlobGetPageRangesDiffHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<long> BlobContentLength
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<long> get_BlobContentLength()
public string get_Version()
}
internal Azure.Storage.Blobs.PageBlobGetPageRangesHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<long> BlobContentLength
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<long> get_BlobContentLength()
public string get_Version()
}
internal Azure.Storage.Blobs.PageBlobResizeHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<long> BlobSequenceNumber
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<long> get_BlobSequenceNumber()
public string get_Version()
}
internal Azure.Storage.Blobs.PageBlobRestClient : object {
private HttpPipeline _pipeline
private string _url
private string _version
private ClientDiagnostics <ClientDiagnostics>k__BackingField
internal ClientDiagnostics ClientDiagnostics
internal ClientDiagnostics get_ClientDiagnostics()
public void .ctor(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
internal HttpMessage CreateCreateRequest(long contentLength, long blobContentLength, Nullable`1<int> timeout, Nullable`1<PremiumPageBlobAccessTier> tier, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold)
public Task`1<ResponseWithHeaders`1<PageBlobCreateHeaders>> CreateAsync(long contentLength, long blobContentLength, Nullable`1<int> timeout, Nullable`1<PremiumPageBlobAccessTier> tier, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken)
public ResponseWithHeaders`1<PageBlobCreateHeaders> Create(long contentLength, long blobContentLength, Nullable`1<int> timeout, Nullable`1<PremiumPageBlobAccessTier> tier, string blobContentType, string blobContentEncoding, string blobContentLanguage, Byte[] blobContentMD5, string blobCacheControl, IDictionary`2<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, string blobTagsString, Nullable`1<DateTimeOffset> immutabilityPolicyExpiry, Nullable`1<BlobImmutabilityPolicyMode> immutabilityPolicyMode, Nullable`1<bool> legalHold, CancellationToken cancellationToken)
internal HttpMessage CreateUploadPagesRequest(long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<PageBlobUploadPagesHeaders>> UploadPagesAsync(long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<PageBlobUploadPagesHeaders> UploadPages(long contentLength, Stream body, Byte[] transactionalContentMD5, Byte[] transactionalContentCrc64, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateClearPagesRequest(long contentLength, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<PageBlobClearPagesHeaders>> ClearPagesAsync(long contentLength, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<PageBlobClearPagesHeaders> ClearPages(long contentLength, Nullable`1<int> timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateUploadPagesFromURLRequest(string sourceUrl, string sourceRange, long contentLength, string range, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization)
public Task`1<ResponseWithHeaders`1<PageBlobUploadPagesFromURLHeaders>> UploadPagesFromURLAsync(string sourceUrl, string sourceRange, long contentLength, string range, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken)
public ResponseWithHeaders`1<PageBlobUploadPagesFromURLHeaders> UploadPagesFromURL(string sourceUrl, string sourceRange, long contentLength, string range, Byte[] sourceContentMD5, Byte[] sourceContentcrc64, Nullable`1<int> timeout, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, string leaseId, Nullable`1<long> ifSequenceNumberLessThanOrEqualTo, Nullable`1<long> ifSequenceNumberLessThan, Nullable`1<long> ifSequenceNumberEqualTo, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<DateTimeOffset> sourceIfModifiedSince, Nullable`1<DateTimeOffset> sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization, CancellationToken cancellationToken)
internal HttpMessage CreateGetPageRangesRequest(string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults)
public Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders>> GetPageRangesAsync(string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken)
public ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders> GetPageRanges(string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken)
internal HttpMessage CreateGetPageRangesDiffRequest(string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults)
public Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders>> GetPageRangesDiffAsync(string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken)
public ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders> GetPageRangesDiff(string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken)
internal HttpMessage CreateResizeRequest(long blobContentLength, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<PageBlobResizeHeaders>> ResizeAsync(long blobContentLength, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<PageBlobResizeHeaders> Resize(long blobContentLength, Nullable`1<int> timeout, string leaseId, string encryptionKey, string encryptionKeySha256, Nullable`1<EncryptionAlgorithmTypeInternal> encryptionAlgorithm, string encryptionScope, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateUpdateSequenceNumberRequest(SequenceNumberAction sequenceNumberAction, Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber)
public Task`1<ResponseWithHeaders`1<PageBlobUpdateSequenceNumberHeaders>> UpdateSequenceNumberAsync(SequenceNumberAction sequenceNumberAction, Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, CancellationToken cancellationToken)
public ResponseWithHeaders`1<PageBlobUpdateSequenceNumberHeaders> UpdateSequenceNumber(SequenceNumberAction sequenceNumberAction, Nullable`1<int> timeout, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, Nullable`1<long> blobSequenceNumber, CancellationToken cancellationToken)
internal HttpMessage CreateCopyIncrementalRequest(string copySource, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
public Task`1<ResponseWithHeaders`1<PageBlobCopyIncrementalHeaders>> CopyIncrementalAsync(string copySource, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
public ResponseWithHeaders`1<PageBlobCopyIncrementalHeaders> CopyIncremental(string copySource, Nullable`1<int> timeout, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, CancellationToken cancellationToken)
internal HttpMessage CreateGetPageRangesNextPageRequest(string nextLink, string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults)
public Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders>> GetPageRangesNextPageAsync(string nextLink, string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken)
public ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders> GetPageRangesNextPage(string nextLink, string snapshot, Nullable`1<int> timeout, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken)
internal HttpMessage CreateGetPageRangesDiffNextPageRequest(string nextLink, string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults)
public Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders>> GetPageRangesDiffNextPageAsync(string nextLink, string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken)
public ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders> GetPageRangesDiffNextPage(string nextLink, string snapshot, Nullable`1<int> timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, Nullable`1<DateTimeOffset> ifModifiedSince, Nullable`1<DateTimeOffset> ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, Nullable`1<int> maxresults, CancellationToken cancellationToken)
}
internal Azure.Storage.Blobs.PageBlobUpdateSequenceNumberHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Nullable`1<long> BlobSequenceNumber
public string Version
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Nullable`1<long> get_BlobSequenceNumber()
public string get_Version()
}
internal Azure.Storage.Blobs.PageBlobUploadPagesFromURLHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public Byte[] XMsContentCrc64
public Nullable`1<long> BlobSequenceNumber
public string Version
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public Byte[] get_XMsContentCrc64()
public Nullable`1<long> get_BlobSequenceNumber()
public string get_Version()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.PageBlobUploadPagesHeaders : object {
private Response _response
public Nullable`1<DateTimeOffset> LastModified
public Byte[] ContentMD5
public Byte[] XMsContentCrc64
public Nullable`1<long> BlobSequenceNumber
public string Version
public Nullable`1<bool> IsServerEncrypted
public string EncryptionKeySha256
public string EncryptionScope
public void .ctor(Response response)
public Nullable`1<DateTimeOffset> get_LastModified()
public Byte[] get_ContentMD5()
public Byte[] get_XMsContentCrc64()
public Nullable`1<long> get_BlobSequenceNumber()
public string get_Version()
public Nullable`1<bool> get_IsServerEncrypted()
public string get_EncryptionKeySha256()
public string get_EncryptionScope()
}
internal Azure.Storage.Blobs.PageBlobWriteStream : StorageWriteStream {
private PageBlobClient _pageBlobClient
private PageBlobRequestConditions _conditions
private long _writeIndex
public void .ctor(PageBlobClient pageBlobClient, long bufferSize, long position, PageBlobRequestConditions conditions, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidation)
protected Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
protected void ValidateBufferSize(long bufferSize)
private void ValidatePosition(long position)
}
internal Azure.Storage.Blobs.PartitionedDownloader : object {
private string _operationName
private string _innerOperationName
private BlobBaseClient _client
private int _maxWorkerCount
private long _initialRangeSize
private long _rangeSize
private StorageChecksumAlgorithm _validationAlgorithm
private int _checksumSize
private StorageCrc64HashAlgorithm _masterCrcCalculator
private IProgress`1<long> _progress
private ArrayPool`1<byte> _arrayPool
private bool UseMasterCrc
private DownloadTransferValidationOptions ValidationOptions
private bool get_UseMasterCrc()
private DownloadTransferValidationOptions get_ValidationOptions()
public void .ctor(BlobBaseClient client, StorageTransferOptions transferOptions, DownloadTransferValidationOptions transferValidation, IProgress`1<long> progress, ArrayPool`1<byte> arrayPool)
public Task`1<Response> DownloadToInternal(Stream destination, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
private Task HandleOneShotDownload(Response`1<BlobDownloadStreamingResult> response, Stream destination, bool async, CancellationToken cancellationToken)
private Task FinalizeDownloadInternal(Stream destination, Memory`1<byte> composedCrc, bool async, CancellationToken cancellationToken)
private long ParseRangeTotalLength(string range)
private Task CopyToInternal(Response`1<BlobDownloadStreamingResult> response, Stream destination, Memory`1<byte> checksumBuffer, bool async, CancellationToken cancellationToken)
private IEnumerable`1<HttpRange> GetRanges(long initialLength, long totalLength)
private Task FlushFinalIfNecessaryInternal(Stream destination, bool async, CancellationToken cancellationToken)
private void ValidateFinalCrc(ReadOnlySpan`1<byte> composedCrc)
}
internal Azure.Storage.Blobs.QuickQueryExtensions : object {
internal QuerySerialization ToQuickQuerySerialization(BlobQueryTextOptions textConfiguration, bool isInput)
internal ArrowFieldInternal ToArrowFieldInternal(BlobQueryArrowField blobQueryArrowField)
internal string ToArrowFiledInternalType(BlobQueryArrowFieldType blobQueryArrowFieldType)
}
internal Azure.Storage.Blobs.ServiceFilterBlobsHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ServiceGetAccountInfoHeaders : object {
private Response _response
public string Version
public Nullable`1<SkuName> SkuName
public Nullable`1<AccountKind> AccountKind
public Nullable`1<bool> IsHierarchicalNamespaceEnabled
public void .ctor(Response response)
public string get_Version()
public Nullable`1<SkuName> get_SkuName()
public Nullable`1<AccountKind> get_AccountKind()
public Nullable`1<bool> get_IsHierarchicalNamespaceEnabled()
}
internal Azure.Storage.Blobs.ServiceGetPropertiesHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ServiceGetStatisticsHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ServiceGetUserDelegationKeyHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ServiceListContainersSegmentHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ServiceRestClient : object {
private HttpPipeline _pipeline
private string _url
private string _version
private ClientDiagnostics <ClientDiagnostics>k__BackingField
internal ClientDiagnostics ClientDiagnostics
internal ClientDiagnostics get_ClientDiagnostics()
public void .ctor(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
internal HttpMessage CreateSetPropertiesRequest(BlobServiceProperties storageServiceProperties, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`1<ServiceSetPropertiesHeaders>> SetPropertiesAsync(BlobServiceProperties storageServiceProperties, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`1<ServiceSetPropertiesHeaders> SetProperties(BlobServiceProperties storageServiceProperties, Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateGetPropertiesRequest(Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<BlobServiceProperties, ServiceGetPropertiesHeaders>> GetPropertiesAsync(Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<BlobServiceProperties, ServiceGetPropertiesHeaders> GetProperties(Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateGetStatisticsRequest(Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<BlobServiceStatistics, ServiceGetStatisticsHeaders>> GetStatisticsAsync(Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<BlobServiceStatistics, ServiceGetStatisticsHeaders> GetStatistics(Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateListContainersSegmentRequest(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders>> ListContainersSegmentAsync(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders> ListContainersSegment(string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateGetUserDelegationKeyRequest(KeyInfo keyInfo, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<UserDelegationKey, ServiceGetUserDelegationKeyHeaders>> GetUserDelegationKeyAsync(KeyInfo keyInfo, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<UserDelegationKey, ServiceGetUserDelegationKeyHeaders> GetUserDelegationKey(KeyInfo keyInfo, Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateGetAccountInfoRequest()
public Task`1<ResponseWithHeaders`1<ServiceGetAccountInfoHeaders>> GetAccountInfoAsync(CancellationToken cancellationToken)
public ResponseWithHeaders`1<ServiceGetAccountInfoHeaders> GetAccountInfo(CancellationToken cancellationToken)
internal HttpMessage CreateSubmitBatchRequest(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<Stream, ServiceSubmitBatchHeaders>> SubmitBatchAsync(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<Stream, ServiceSubmitBatchHeaders> SubmitBatch(long contentLength, string multipartContentType, Stream body, Nullable`1<int> timeout, CancellationToken cancellationToken)
internal HttpMessage CreateFilterBlobsRequest(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include)
public Task`1<ResponseWithHeaders`2<FilterBlobSegment, ServiceFilterBlobsHeaders>> FilterBlobsAsync(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include, CancellationToken cancellationToken)
public ResponseWithHeaders`2<FilterBlobSegment, ServiceFilterBlobsHeaders> FilterBlobs(Nullable`1<int> timeout, string where, string marker, Nullable`1<int> maxresults, IEnumerable`1<FilterBlobsIncludeItem> include, CancellationToken cancellationToken)
internal HttpMessage CreateListContainersSegmentNextPageRequest(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout)
public Task`1<ResponseWithHeaders`2<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders>> ListContainersSegmentNextPageAsync(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
public ResponseWithHeaders`2<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders> ListContainersSegmentNextPage(string nextLink, string prefix, string marker, Nullable`1<int> maxresults, IEnumerable`1<ListContainersIncludeType> include, Nullable`1<int> timeout, CancellationToken cancellationToken)
}
internal Azure.Storage.Blobs.ServiceSetPropertiesHeaders : object {
private Response _response
public string Version
public void .ctor(Response response)
public string get_Version()
}
internal Azure.Storage.Blobs.ServiceSubmitBatchHeaders : object {
private Response _response
public string ContentType
public string Version
public void .ctor(Response response)
public string get_ContentType()
public string get_Version()
}
public Azure.Storage.Blobs.Specialized.AppendBlobClient : BlobBaseClient {
private AppendBlobRestClient _appendBlobRestClient
public int AppendBlobMaxAppendBlockBytes
public int AppendBlobMaxBlocks
internal AppendBlobRestClient AppendBlobRestClient
public int get_AppendBlobMaxAppendBlockBytes()
public int get_AppendBlobMaxBlocks()
internal AppendBlobRestClient get_AppendBlobRestClient()
public void .ctor(string connectionString, string blobContainerName, string blobName)
public void .ctor(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
public void .ctor(Uri blobUri, BlobClientOptions options)
public void .ctor(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, AzureSasCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, TokenCredential credential, BlobClientOptions options)
internal void .ctor(Uri blobUri, BlobClientConfiguration clientConfiguration)
private void AssertNoClientSideEncryption(BlobClientOptions options)
private AppendBlobRestClient BuildAppendBlobRestClient(Uri blobUri)
public AppendBlobClient WithSnapshot(string snapshot)
public AppendBlobClient WithVersion(string versionId)
public AppendBlobClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey)
public AppendBlobClient WithEncryptionScope(string encryptionScope)
public Response`1<BlobContentInfo> Create(AppendBlobCreateOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CreateAsync(AppendBlobCreateOptions options, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Create(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, AppendBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CreateAsync(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, AppendBlobRequestConditions conditions, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> CreateIfNotExists(AppendBlobCreateOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsAsync(AppendBlobCreateOptions options, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> CreateIfNotExists(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsAsync(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsInternal(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContentInfo>> CreateInternal(BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, AppendBlobRequestConditions conditions, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken, string operationName)
public Response`1<BlobAppendInfo> AppendBlock(Stream content, Byte[] transactionalContentHash, AppendBlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
public Task`1<Response`1<BlobAppendInfo>> AppendBlockAsync(Stream content, Byte[] transactionalContentHash, AppendBlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
public Response`1<BlobAppendInfo> AppendBlock(Stream content, AppendBlobAppendBlockOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobAppendInfo>> AppendBlockAsync(Stream content, AppendBlobAppendBlockOptions options, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobAppendInfo>> AppendBlockInternal(Stream content, UploadTransferValidationOptions transferValidationOverride, AppendBlobRequestConditions conditions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken)
public Response`1<BlobAppendInfo> AppendBlockFromUri(Uri sourceUri, AppendBlobAppendBlockFromUriOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobAppendInfo>> AppendBlockFromUriAsync(Uri sourceUri, AppendBlobAppendBlockFromUriOptions options, CancellationToken cancellationToken)
public Response`1<BlobAppendInfo> AppendBlockFromUri(Uri sourceUri, HttpRange sourceRange, Byte[] sourceContentHash, AppendBlobRequestConditions conditions, AppendBlobRequestConditions sourceConditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobAppendInfo>> AppendBlockFromUriAsync(Uri sourceUri, HttpRange sourceRange, Byte[] sourceContentHash, AppendBlobRequestConditions conditions, AppendBlobRequestConditions sourceConditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobAppendInfo>> AppendBlockFromUriInternal(Uri sourceUri, HttpRange sourceRange, Byte[] sourceContentHash, AppendBlobRequestConditions conditions, AppendBlobRequestConditions sourceConditions, HttpAuthorization sourceAuthentication, bool async, CancellationToken cancellationToken)
public Response`1<BlobInfo> Seal(AppendBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobInfo>> SealAsync(AppendBlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobInfo>> SealInternal(AppendBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Stream OpenWrite(bool overwrite, AppendBlobOpenWriteOptions options, CancellationToken cancellationToken)
public Task`1<Stream> OpenWriteAsync(bool overwrite, AppendBlobOpenWriteOptions options, CancellationToken cancellationToken)
private Task`1<Stream> OpenWriteInternal(bool overwrite, AppendBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
}
public Azure.Storage.Blobs.Specialized.BlobBaseClient : object {
private protected Uri _uri
internal BlobClientConfiguration _clientConfiguration
private ClientSideEncryptionOptions _clientSideEncryption
private string _snapshot
private string _blobVersionId
private string _accountName
private string _containerName
private string _name
private BlobRestClient _blobRestClient
private BlobContainerClient _parentBlobContainerClient
public Uri Uri
internal BlobClientConfiguration ClientConfiguration
internal ClientSideEncryptionOptions ClientSideEncryption
internal bool UsingClientSideEncryption
public string AccountName
public string BlobContainerName
public string Name
public bool CanGenerateSasUri
internal BlobRestClient BlobRestClient
public Uri get_Uri()
internal BlobClientConfiguration get_ClientConfiguration()
internal ClientSideEncryptionOptions get_ClientSideEncryption()
internal bool get_UsingClientSideEncryption()
public string get_AccountName()
public string get_BlobContainerName()
public string get_Name()
public bool get_CanGenerateSasUri()
internal BlobRestClient get_BlobRestClient()
public void .ctor(string connectionString, string blobContainerName, string blobName)
public void .ctor(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
public void .ctor(Uri blobUri, BlobClientOptions options)
public void .ctor(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, AzureSasCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, TokenCredential credential, BlobClientOptions options)
internal void .ctor(Uri blobUri, HttpPipelinePolicy authentication, BlobClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential)
internal void .ctor(Uri blobUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption)
private BlobRestClient BuildBlobRestClient(Uri blobUri)
public BlobBaseClient WithSnapshot(string snapshot)
protected BlobBaseClient WithSnapshotCore(string snapshot)
public BlobBaseClient WithVersion(string versionId)
private protected BlobBaseClient WithVersionCore(string versionId)
public BlobBaseClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey)
private protected BlobBaseClient WithCustomerProvidedKeyCore(Nullable`1<CustomerProvidedKey> customerProvidedKey)
public BlobBaseClient WithEncryptionScope(string encryptionScope)
private protected BlobBaseClient WithEncryptionScopeCore(string encryptionScope)
protected internal BlobLeaseClient GetBlobLeaseClientCore(string leaseId)
private void SetNameFieldsIfNull()
protected Task`1<HttpAuthorization> GetCopyAuthorizationHeaderAsync(BlobBaseClient client, CancellationToken cancellationToken)
public Response`1<BlobDownloadInfo> Download()
public Task`1<Response`1<BlobDownloadInfo>> DownloadAsync()
public Response`1<BlobDownloadInfo> Download(CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadInfo>> DownloadAsync(CancellationToken cancellationToken)
public Response`1<BlobDownloadInfo> Download(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadInfo>> DownloadAsync(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken)
private Task`1<Response`1<BlobDownloadInfo>> DownloadInternal(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, bool async, CancellationToken cancellationToken)
public Response`1<BlobDownloadStreamingResult> DownloadStreaming(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingAsync(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken)
public Response`1<BlobDownloadStreamingResult> DownloadStreaming(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingAsync(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
public Response`1<BlobDownloadStreamingResult> DownloadStreaming(BlobDownloadOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingAsync(BlobDownloadOptions options, CancellationToken cancellationToken)
private ValueTask`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingDirect(HttpRange range, BlobRequestConditions conditions, DownloadTransferValidationOptions transferValidationOverride, IProgress`1<long> progressHandler, string operationName, bool async, CancellationToken cancellationToken)
internal ValueTask`1<Response`1<BlobDownloadStreamingResult>> DownloadStreamingInternal(HttpRange range, BlobRequestConditions conditions, DownloadTransferValidationOptions transferValidationOverride, IProgress`1<long> progressHandler, string operationName, bool async, CancellationToken cancellationToken)
private ValueTask`1<Response`1<BlobDownloadStreamingResult>> StartDownloadAsync(HttpRange range, BlobRequestConditions conditions, DownloadTransferValidationOptions validationOptions, long startOffset, bool async, CancellationToken cancellationToken)
public Response`1<BlobDownloadResult> DownloadContent()
public Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync()
public Response`1<BlobDownloadResult> DownloadContent(CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync(CancellationToken cancellationToken)
public Response`1<BlobDownloadResult> DownloadContent(BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync(BlobRequestConditions conditions, CancellationToken cancellationToken)
public Response`1<BlobDownloadResult> DownloadContent(BlobRequestConditions conditions, IProgress`1<long> progressHandler, HttpRange range, CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync(BlobRequestConditions conditions, IProgress`1<long> progressHandler, HttpRange range, CancellationToken cancellationToken)
public Response`1<BlobDownloadResult> DownloadContent(BlobDownloadOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadResult>> DownloadContentAsync(BlobDownloadOptions options, CancellationToken cancellationToken)
private Task`1<Response`1<BlobDownloadResult>> DownloadContentInternal(BlobRequestConditions conditions, IProgress`1<long> progressHandler, HttpRange range, DownloadTransferValidationOptions transferValidationOverride, bool async, CancellationToken cancellationToken)
public Response DownloadTo(Stream destination)
public Response DownloadTo(string path)
public Task`1<Response> DownloadToAsync(Stream destination)
public Task`1<Response> DownloadToAsync(string path)
public Response DownloadTo(Stream destination, CancellationToken cancellationToken)
public Response DownloadTo(string path, CancellationToken cancellationToken)
public Task`1<Response> DownloadToAsync(Stream destination, CancellationToken cancellationToken)
public Task`1<Response> DownloadToAsync(string path, CancellationToken cancellationToken)
public Response DownloadTo(Stream destination, BlobDownloadToOptions options, CancellationToken cancellationToken)
public Response DownloadTo(string path, BlobDownloadToOptions options, CancellationToken cancellationToken)
public Task`1<Response> DownloadToAsync(Stream destination, BlobDownloadToOptions options, CancellationToken cancellationToken)
public Task`1<Response> DownloadToAsync(string path, BlobDownloadToOptions options, CancellationToken cancellationToken)
public Response DownloadTo(Stream destination, BlobRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken)
public Response DownloadTo(string path, BlobRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken)
public Task`1<Response> DownloadToAsync(Stream destination, BlobRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken)
public Task`1<Response> DownloadToAsync(string path, BlobRequestConditions conditions, StorageTransferOptions transferOptions, CancellationToken cancellationToken)
internal Task`1<Response> StagedDownloadAsync(Stream destination, BlobRequestConditions conditions, IProgress`1<long> progressHandler, StorageTransferOptions transferOptions, DownloadTransferValidationOptions transferValidationOverride, bool async, CancellationToken cancellationToken)
public Stream OpenRead(BlobOpenReadOptions options, CancellationToken cancellationToken)
public Task`1<Stream> OpenReadAsync(BlobOpenReadOptions options, CancellationToken cancellationToken)
public Stream OpenRead(long position, Nullable`1<int> bufferSize, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Stream OpenRead(bool allowBlobModifications, long position, Nullable`1<int> bufferSize, CancellationToken cancellationToken)
public Task`1<Stream> OpenReadAsync(long position, Nullable`1<int> bufferSize, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Stream> OpenReadAsync(bool allowBlobModifications, long position, Nullable`1<int> bufferSize, CancellationToken cancellationToken)
internal Task`1<Stream> OpenReadInternal(long position, Nullable`1<int> bufferSize, BlobRequestConditions conditions, bool allowModifications, DownloadTransferValidationOptions transferValidationOverride, bool async, CancellationToken cancellationToken)
public CopyFromUriOperation StartCopyFromUri(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken)
public CopyFromUriOperation StartCopyFromUri(Uri source, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, Nullable`1<RehydratePriority> rehydratePriority, CancellationToken cancellationToken)
public Task`1<CopyFromUriOperation> StartCopyFromUriAsync(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken)
public Task`1<CopyFromUriOperation> StartCopyFromUriAsync(Uri source, IDictionary`2<string, string> metadata, Nullable`1<AccessTier> accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, Nullable`1<RehydratePriority> rehydratePriority, CancellationToken cancellationToken)
private Task`1<Response`1<BlobCopyInfo>> StartCopyFromUriInternal(Uri source, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, Nullable`1<AccessTier> accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, Nullable`1<RehydratePriority> rehydratePriority, Nullable`1<bool> sealBlob, BlobImmutabilityPolicy destinationImmutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken)
public Response AbortCopyFromUri(string copyId, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response> AbortCopyFromUriAsync(string copyId, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response> AbortCopyFromUriInternal(string copyId, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobCopyInfo> SyncCopyFromUri(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobCopyInfo>> SyncCopyFromUriAsync(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken)
private Task`1<Response`1<BlobCopyInfo>> SyncCopyFromUriInternal(Uri source, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, Nullable`1<AccessTier> accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, BlobImmutabilityPolicy destinationImmutabilityPolicy, Nullable`1<bool> legalHold, HttpAuthorization sourceAuthentication, Nullable`1<BlobCopySourceTagsMode> copySourceTags, bool async, CancellationToken cancellationToken)
public Response Delete(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response> DeleteAsync(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Response`1<bool> DeleteIfExists(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<bool>> DeleteIfExistsAsync(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, CancellationToken cancellationToken)
internal Task`1<Response`1<bool>> DeleteIfExistsInternal(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
private Task`1<Response> DeleteInternal(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName)
public Response`1<bool> Exists(CancellationToken cancellationToken)
public Task`1<Response`1<bool>> ExistsAsync(CancellationToken cancellationToken)
private Task`1<Response`1<bool>> ExistsInternal(bool async, CancellationToken cancellationToken)
public Response Undelete(CancellationToken cancellationToken)
public Task`1<Response> UndeleteAsync(CancellationToken cancellationToken)
private Task`1<Response> UndeleteInternal(bool async, CancellationToken cancellationToken)
public Response`1<BlobProperties> GetProperties(BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobProperties>> GetPropertiesAsync(BlobRequestConditions conditions, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobProperties>> GetPropertiesInternal(BlobRequestConditions conditions, bool async, RequestContext context, string operationName)
public Response`1<BlobInfo> SetHttpHeaders(BlobHttpHeaders httpHeaders, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobInfo>> SetHttpHeadersAsync(BlobHttpHeaders httpHeaders, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobInfo>> SetHttpHeadersInternal(BlobHttpHeaders httpHeaders, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobInfo> SetMetadata(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobInfo>> SetMetadataAsync(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobInfo>> SetMetadataInternal(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobSnapshotInfo> CreateSnapshot(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobSnapshotInfo>> CreateSnapshotAsync(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobSnapshotInfo>> CreateSnapshotInternal(IDictionary`2<string, string> metadata, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response SetAccessTier(AccessTier accessTier, BlobRequestConditions conditions, Nullable`1<RehydratePriority> rehydratePriority, CancellationToken cancellationToken)
public Task`1<Response> SetAccessTierAsync(AccessTier accessTier, BlobRequestConditions conditions, Nullable`1<RehydratePriority> rehydratePriority, CancellationToken cancellationToken)
private Task`1<Response> SetAccessTierInternal(AccessTier accessTier, BlobRequestConditions conditions, Nullable`1<RehydratePriority> rehydratePriority, bool async, CancellationToken cancellationToken)
public Response`1<GetBlobTagResult> GetTags(BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<GetBlobTagResult>> GetTagsAsync(BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<GetBlobTagResult>> GetTagsInternal(bool async, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Response SetTags(IDictionary`2<string, string> tags, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response> SetTagsAsync(IDictionary`2<string, string> tags, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response> SetTagsInternal(IDictionary`2<string, string> tags, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobImmutabilityPolicy> SetImmutabilityPolicy(BlobImmutabilityPolicy immutabilityPolicy, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobImmutabilityPolicy>> SetImmutabilityPolicyAsync(BlobImmutabilityPolicy immutabilityPolicy, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobImmutabilityPolicy>> SetImmutabilityPolicyInternal(BlobImmutabilityPolicy immutabilityPolicy, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response DeleteImmutabilityPolicy(CancellationToken cancellationToken)
public Task`1<Response> DeleteImmutabilityPolicyAsync(CancellationToken cancellationToken)
private Task`1<Response> DeleteImmutabilityPolicyInternal(bool async, CancellationToken cancellationToken)
public Response`1<BlobLegalHoldResult> SetLegalHold(bool hasLegalHold, CancellationToken cancellationToken)
public Task`1<Response`1<BlobLegalHoldResult>> SetLegalHoldAsync(bool hasLegalHold, CancellationToken cancellationToken)
private Task`1<Response`1<BlobLegalHoldResult>> SetLegalHoldInternal(bool hasLegalHold, bool async, CancellationToken cancellationToken)
public Uri GenerateSasUri(BlobSasPermissions permissions, DateTimeOffset expiresOn)
public Uri GenerateSasUri(BlobSasBuilder builder)
protected internal BlobContainerClient GetParentBlobContainerClientCore()
private Task`1<Response`1<BlobProperties>> <OpenReadInternal>b__98_2(bool async, CancellationToken cancellationToken)
}
public Azure.Storage.Blobs.Specialized.BlobLeaseClient : object {
private BlobBaseClient _blob
private BlobContainerClient _container
private string _leaseId
public TimeSpan InfiniteLeaseDuration
protected BlobBaseClient BlobClient
protected BlobContainerClient BlobContainerClient
public Uri Uri
public string LeaseId
private HttpPipeline Pipeline
internal ServiceVersion Version
internal ClientDiagnostics ClientDiagnostics
protected BlobBaseClient get_BlobClient()
protected BlobContainerClient get_BlobContainerClient()
public Uri get_Uri()
public string get_LeaseId()
private void set_LeaseId(string value)
private HttpPipeline get_Pipeline()
internal ServiceVersion get_Version()
internal ClientDiagnostics get_ClientDiagnostics()
public void .ctor(BlobBaseClient client, string leaseId)
public void .ctor(BlobContainerClient client, string leaseId)
private string CreateUniqueLeaseId()
private void EnsureClient()
public Response`1<BlobLease> Acquire(TimeSpan duration, RequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobLease>> AcquireAsync(TimeSpan duration, RequestConditions conditions, CancellationToken cancellationToken)
private Response`1<BlobLease> ParseAcquireResponse(Response response)
public Response Acquire(TimeSpan duration, RequestConditions conditions, RequestContext context)
public Task`1<Response> AcquireAsync(TimeSpan duration, RequestConditions conditions, RequestContext context)
private Task`1<Response> AcquireInternal(TimeSpan duration, RequestConditions conditions, bool async, RequestContext context)
public Response`1<BlobLease> Renew(RequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobLease>> RenewAsync(RequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobLease>> RenewInternal(RequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<ReleasedObjectInfo> Release(RequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<ReleasedObjectInfo>> ReleaseAsync(RequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<ReleasedObjectInfo>> ReleaseInternal(RequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobLease> Change(string proposedId, RequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobLease>> ChangeAsync(string proposedId, RequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobLease>> ChangeInternal(string proposedId, RequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobLease> Break(Nullable`1<TimeSpan> breakPeriod, RequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobLease>> BreakAsync(Nullable`1<TimeSpan> breakPeriod, RequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobLease>> BreakInternal(Nullable`1<TimeSpan> breakPeriod, RequestConditions conditions, bool async, CancellationToken cancellationToken)
}
public Azure.Storage.Blobs.Specialized.BlockBlobClient : BlobBaseClient {
private BlockBlobRestClient _blockBlobRestClient
public int BlockBlobMaxUploadBlobBytes
public long BlockBlobMaxUploadBlobLongBytes
public int BlockBlobMaxStageBlockBytes
public long BlockBlobMaxStageBlockLongBytes
public int BlockBlobMaxBlocks
internal BlockBlobRestClient BlockBlobRestClient
public int get_BlockBlobMaxUploadBlobBytes()
public long get_BlockBlobMaxUploadBlobLongBytes()
public int get_BlockBlobMaxStageBlockBytes()
public long get_BlockBlobMaxStageBlockLongBytes()
public int get_BlockBlobMaxBlocks()
internal BlockBlobRestClient get_BlockBlobRestClient()
public void .ctor(string connectionString, string containerName, string blobName)
public void .ctor(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
public void .ctor(Uri blobUri, BlobClientOptions options)
public void .ctor(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, AzureSasCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, TokenCredential credential, BlobClientOptions options)
internal void .ctor(Uri blobUri, BlobClientConfiguration clientConfiguration)
internal void .ctor(Uri blobUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption)
protected BlockBlobClient CreateClient(Uri blobUri, BlobClientOptions options, HttpPipeline pipeline)
private void AssertNoClientSideEncryption(BlobClientOptions options)
private BlockBlobRestClient BuildBlockBlobRestClient(Uri blobUri)
public BlockBlobClient WithSnapshot(string snapshot)
public BlockBlobClient WithVersion(string versionId)
protected BlobBaseClient WithSnapshotCore(string snapshot)
public BlockBlobClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey)
public BlockBlobClient WithEncryptionScope(string encryptionScope)
public Response`1<BlobContentInfo> Upload(Stream content, BlobUploadOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, BlobUploadOptions options, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Upload(Stream content, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> UploadAsync(Stream content, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContentInfo>> UploadInternal(Stream content, BlobHttpHeaders blobHttpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidationOverride, string operationName, bool async, CancellationToken cancellationToken)
public Response`1<BlockInfo> StageBlock(string base64BlockId, Stream content, Byte[] transactionalContentHash, BlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
public Task`1<Response`1<BlockInfo>> StageBlockAsync(string base64BlockId, Stream content, Byte[] transactionalContentHash, BlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
public Response`1<BlockInfo> StageBlock(string base64BlockId, Stream content, BlockBlobStageBlockOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlockInfo>> StageBlockAsync(string base64BlockId, Stream content, BlockBlobStageBlockOptions options, CancellationToken cancellationToken)
internal Task`1<Response`1<BlockInfo>> StageBlockInternal(string base64BlockId, Stream content, UploadTransferValidationOptions transferValidationOverride, BlobRequestConditions conditions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken)
public Response`1<BlockInfo> StageBlockFromUri(Uri sourceUri, string base64BlockId, StageBlockFromUriOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlockInfo>> StageBlockFromUriAsync(Uri sourceUri, string base64BlockId, StageBlockFromUriOptions options, CancellationToken cancellationToken)
public Response`1<BlockInfo> StageBlockFromUri(Uri sourceUri, string base64BlockId, HttpRange sourceRange, Byte[] sourceContentHash, RequestConditions sourceConditions, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlockInfo>> StageBlockFromUriAsync(Uri sourceUri, string base64BlockId, HttpRange sourceRange, Byte[] sourceContentHash, RequestConditions sourceConditions, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlockInfo>> StageBlockFromUriInternal(Uri sourceUri, string base64BlockId, HttpRange sourceRange, Byte[] sourceContentHash, RequestConditions sourceConditions, BlobRequestConditions conditions, HttpAuthorization sourceAuthentication, bool async, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> CommitBlockList(IEnumerable`1<string> base64BlockIds, CommitBlockListOptions options, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> CommitBlockList(IEnumerable`1<string> base64BlockIds, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CommitBlockListAsync(IEnumerable`1<string> base64BlockIds, CommitBlockListOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CommitBlockListAsync(IEnumerable`1<string> base64BlockIds, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContentInfo>> CommitBlockListInternal(IEnumerable`1<string> base64BlockIds, BlobHttpHeaders blobHttpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, BlobRequestConditions conditions, Nullable`1<AccessTier> accessTier, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken)
public Response`1<BlockList> GetBlockList(BlockListTypes blockListTypes, string snapshot, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlockList>> GetBlockListAsync(BlockListTypes blockListTypes, string snapshot, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlockList>> GetBlockListInternal(BlockListTypes blockListTypes, string snapshot, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<BlobDownloadInfo> Query(string querySqlExpression, BlobQueryOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobDownloadInfo>> QueryAsync(string querySqlExpression, BlobQueryOptions options, CancellationToken cancellationToken)
private Task`1<Response`1<BlobDownloadInfo>> QueryInternal(string querySqlExpression, BlobQueryOptions options, bool async, CancellationToken cancellationToken)
public Stream OpenWrite(bool overwrite, BlockBlobOpenWriteOptions options, CancellationToken cancellationToken)
public Task`1<Stream> OpenWriteAsync(bool overwrite, BlockBlobOpenWriteOptions options, CancellationToken cancellationToken)
internal Task`1<Stream> OpenWriteInternal(bool overwrite, BlockBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> SyncUploadFromUri(Uri copySource, bool overwrite, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> SyncUploadFromUriAsync(Uri copySource, bool overwrite, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> SyncUploadFromUri(Uri copySource, BlobSyncUploadFromUriOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> SyncUploadFromUriAsync(Uri copySource, BlobSyncUploadFromUriOptions options, CancellationToken cancellationToken)
internal Task`1<Response`1<BlobContentInfo>> SyncUploadFromUriInternal(Uri copySource, BlobSyncUploadFromUriOptions options, bool async, CancellationToken cancellationToken)
internal PartitionedUploader`2<BlobUploadOptions, BlobContentInfo> GetPartitionedUploader(StorageTransferOptions transferOptions, UploadTransferValidationOptions validationOptions, ArrayPool`1<byte> arrayPool, string operationName)
internal Behaviors<BlobUploadOptions, BlobContentInfo> GetPartitionedUploaderBehaviors(BlockBlobClient client)
}
public Azure.Storage.Blobs.Specialized.PageBlobClient : BlobBaseClient {
private PageBlobRestClient _pageBlobRestClient
public int PageBlobPageBytes
public int PageBlobMaxUploadPagesBytes
internal PageBlobRestClient PageBlobRestClient
public int get_PageBlobPageBytes()
public int get_PageBlobMaxUploadPagesBytes()
internal PageBlobRestClient get_PageBlobRestClient()
public void .ctor(string connectionString, string blobContainerName, string blobName)
public void .ctor(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
public void .ctor(Uri blobUri, BlobClientOptions options)
public void .ctor(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, AzureSasCredential credential, BlobClientOptions options)
public void .ctor(Uri blobUri, TokenCredential credential, BlobClientOptions options)
internal void .ctor(Uri blobUri, BlobClientConfiguration clientConfiguration)
private void AssertNoClientSideEncryption(BlobClientOptions options)
private PageBlobRestClient BuildPageBlobRestClient(Uri blobUri)
public PageBlobClient WithSnapshot(string snapshot)
protected BlobBaseClient WithSnapshotCore(string snapshot)
public PageBlobClient WithVersion(string versionId)
public PageBlobClient WithCustomerProvidedKey(Nullable`1<CustomerProvidedKey> customerProvidedKey)
public PageBlobClient WithEncryptionScope(string encryptionScope)
public Response`1<BlobContentInfo> Create(long size, PageBlobCreateOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CreateAsync(long size, PageBlobCreateOptions options, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> Create(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CreateAsync(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> CreateIfNotExists(long size, PageBlobCreateOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsAsync(long size, PageBlobCreateOptions options, CancellationToken cancellationToken)
public Response`1<BlobContentInfo> CreateIfNotExists(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
public Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsAsync(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContentInfo>> CreateIfNotExistsInternal(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken)
private Task`1<Response`1<BlobContentInfo>> CreateInternal(long size, Nullable`1<long> sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary`2<string, string> metadata, IDictionary`2<string, string> tags, PageBlobRequestConditions conditions, BlobImmutabilityPolicy immutabilityPolicy, Nullable`1<bool> legalHold, bool async, CancellationToken cancellationToken, string operationName)
public Response`1<PageInfo> UploadPages(Stream content, long offset, Byte[] transactionalContentHash, PageBlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
public Task`1<Response`1<PageInfo>> UploadPagesAsync(Stream content, long offset, Byte[] transactionalContentHash, PageBlobRequestConditions conditions, IProgress`1<long> progressHandler, CancellationToken cancellationToken)
public Response`1<PageInfo> UploadPages(Stream content, long offset, PageBlobUploadPagesOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<PageInfo>> UploadPagesAsync(Stream content, long offset, PageBlobUploadPagesOptions options, CancellationToken cancellationToken)
internal Task`1<Response`1<PageInfo>> UploadPagesInternal(Stream content, long offset, UploadTransferValidationOptions transferValidationOverride, PageBlobRequestConditions conditions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken)
public Response`1<PageInfo> ClearPages(HttpRange range, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<PageInfo>> ClearPagesAsync(HttpRange range, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<PageInfo>> ClearPagesInternal(HttpRange range, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Pageable`1<PageRangeItem> GetAllPageRanges(GetPageRangesOptions options, CancellationToken cancellationToken)
public AsyncPageable`1<PageRangeItem> GetAllPageRangesAsync(GetPageRangesOptions options, CancellationToken cancellationToken)
internal Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesHeaders>> GetAllPageRangesInteral(string marker, Nullable`1<int> pageSizeHint, Nullable`1<HttpRange> range, string snapshot, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<PageRangesInfo> GetPageRanges(Nullable`1<HttpRange> range, string snapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<PageRangesInfo>> GetPageRangesAsync(Nullable`1<HttpRange> range, string snapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<PageRangesInfo>> GetPageRangesInternal(Nullable`1<HttpRange> range, string snapshot, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Pageable`1<PageRangeItem> GetAllPageRangesDiff(GetPageRangesDiffOptions options, CancellationToken cancellationToken)
public AsyncPageable`1<PageRangeItem> GetAllPageRangesDiffAsync(GetPageRangesDiffOptions options, CancellationToken cancellationToken)
internal Task`1<ResponseWithHeaders`2<PageList, PageBlobGetPageRangesDiffHeaders>> GetAllPageRangesDiffInternal(string marker, Nullable`1<int> pageSizeHint, Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, bool async, string operationName, CancellationToken cancellationToken)
public Response`1<PageRangesInfo> GetPageRangesDiff(Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<PageRangesInfo>> GetPageRangesDiffAsync(Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<PageRangesInfo>> GetPageRangesDiffInternal(Nullable`1<HttpRange> range, string snapshot, string previousSnapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, bool async, string operationName, CancellationToken cancellationToken)
public Response`1<PageRangesInfo> GetManagedDiskPageRangesDiff(Nullable`1<HttpRange> range, string snapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<PageRangesInfo>> GetManagedDiskPageRangesDiffAsync(Nullable`1<HttpRange> range, string snapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Response`1<PageBlobInfo> Resize(long size, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<PageBlobInfo>> ResizeAsync(long size, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<PageBlobInfo>> ResizeInternal(long size, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<PageBlobInfo> UpdateSequenceNumber(SequenceNumberAction action, Nullable`1<long> sequenceNumber, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<Response`1<PageBlobInfo>> UpdateSequenceNumberAsync(SequenceNumberAction action, Nullable`1<long> sequenceNumber, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<PageBlobInfo>> UpdateSequenceNumberInternal(SequenceNumberAction action, Nullable`1<long> sequenceNumber, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public CopyFromUriOperation StartCopyIncremental(Uri sourceUri, string snapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
public Task`1<CopyFromUriOperation> StartCopyIncrementalAsync(Uri sourceUri, string snapshot, PageBlobRequestConditions conditions, CancellationToken cancellationToken)
private Task`1<Response`1<BlobCopyInfo>> StartCopyIncrementalInternal(Uri sourceUri, string snapshot, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
public Response`1<PageInfo> UploadPagesFromUri(Uri sourceUri, HttpRange sourceRange, HttpRange range, PageBlobUploadPagesFromUriOptions options, CancellationToken cancellationToken)
public Task`1<Response`1<PageInfo>> UploadPagesFromUriAsync(Uri sourceUri, HttpRange sourceRange, HttpRange range, PageBlobUploadPagesFromUriOptions options, CancellationToken cancellationToken)
public Response`1<PageInfo> UploadPagesFromUri(Uri sourceUri, HttpRange sourceRange, HttpRange range, Byte[] sourceContentHash, PageBlobRequestConditions conditions, PageBlobRequestConditions sourceConditions, CancellationToken cancellationToken)
public Task`1<Response`1<PageInfo>> UploadPagesFromUriAsync(Uri sourceUri, HttpRange sourceRange, HttpRange range, Byte[] sourceContentHash, PageBlobRequestConditions conditions, PageBlobRequestConditions sourceConditions, CancellationToken cancellationToken)
private Task`1<Response`1<PageInfo>> UploadPagesFromUriInternal(Uri sourceUri, HttpRange sourceRange, HttpRange range, Byte[] sourceContentHash, PageBlobRequestConditions conditions, PageBlobRequestConditions sourceConditions, HttpAuthorization sourceAuthentication, bool async, CancellationToken cancellationToken)
public Stream OpenWrite(bool overwrite, long position, PageBlobOpenWriteOptions options, CancellationToken cancellationToken)
public Task`1<Stream> OpenWriteAsync(bool overwrite, long position, PageBlobOpenWriteOptions options, CancellationToken cancellationToken)
private Task`1<Stream> OpenWriteInternal(bool overwrite, long position, PageBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
}
public Azure.Storage.Blobs.Specialized.SpecializedBlobClientOptions : BlobClientOptions {
public ClientSideEncryptionOptions ClientSideEncryption
public void .ctor(ServiceVersion version)
public ClientSideEncryptionOptions get_ClientSideEncryption()
public void set_ClientSideEncryption(ClientSideEncryptionOptions value)
}
public Azure.Storage.Blobs.Specialized.SpecializedBlobExtensions : object {
public AppendBlobClient GetAppendBlobClient(BlobContainerClient client, string blobName)
public BlobContainerClient GetParentBlobContainerClient(BlobBaseClient client)
public BlobBaseClient GetBlobBaseClient(BlobContainerClient client, string blobName)
public BlobClient WithClientSideEncryptionOptions(BlobClient client, ClientSideEncryptionOptions clientSideEncryptionOptions)
public BlobServiceClient GetParentBlobServiceClient(BlobContainerClient client)
public BlobLeaseClient GetBlobLeaseClient(BlobBaseClient client, string leaseId)
public BlobLeaseClient GetBlobLeaseClient(BlobContainerClient client, string leaseId)
public BlockBlobClient GetBlockBlobClient(BlobContainerClient client, string blobName)
public PageBlobClient GetPageBlobClient(BlobContainerClient client, string blobName)
public void UpdateClientSideKeyEncryptionKey(BlobClient client, ClientSideEncryptionOptions encryptionOptionsOverride, BlobRequestConditions conditions, CancellationToken cancellationToken)
public Task UpdateClientSideKeyEncryptionKeyAsync(BlobClient client, ClientSideEncryptionOptions encryptionOptionsOverride, BlobRequestConditions conditions, CancellationToken cancellationToken)
private Task UpdateClientsideKeyEncryptionKeyInternal(BlobClient client, ClientSideEncryptionOptions encryptionOptionsOverride, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
private Task`1<Byte[]> UnwrapKeyInternal(EncryptionData encryptionData, IKeyEncryptionKeyResolver keyResolver, bool async, CancellationToken cancellationToken)
private Task`1<Byte[]> WrapKeyInternal(ReadOnlyMemory`1<byte> contentEncryptionKey, string keyWrapAlgorithm, IKeyEncryptionKey key, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.BufferExtensions : object {
public IDisposable RentDisposable(ArrayPool`1<T> pool, int minimumLength, T[]& array)
public IDisposable RentAsMemoryDisposable(ArrayPool`1<T> pool, int minimumLength, Memory`1& memory)
public IDisposable RentAsSpanDisposable(ArrayPool`1<T> pool, int minimumLength, Span`1& span)
public T[] Clear(T[] array)
}
internal Azure.Storage.ChecksumCalculatingStream : Stream {
private Stream _stream
private AppendChecksumCalculation _appendChecksumCalculation
private long _initialPosition
private long _nextToBeChecksummedPosition
private bool <CanRead>k__BackingField
private bool <CanWrite>k__BackingField
public bool CanRead
public bool CanWrite
public bool CanSeek
public long Length
public long Position
public bool CanTimeout
public int ReadTimeout
public int WriteTimeout
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public bool get_CanTimeout()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public Stream GetReadStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation)
public Stream GetWriteStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation)
private void .ctor(Stream stream, AppendChecksumCalculation appendChecksumCalculation, bool isReadMode)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> ReadSeekableInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
private Task`1<int> ReadUnseekableInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
public long Seek(long offset, SeekOrigin origin)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public void Close()
public void SetLength(long value)
private void AssertCanRead()
private void AssertCanWrite()
}
internal Azure.Storage.CompatSwitches : object {
private Nullable`1<bool> _disableRequestConditionsValidation
public bool DisableRequestConditionsValidation
public bool get_DisableRequestConditionsValidation()
}
internal Azure.Storage.Constants : object {
public int KB
public int MB
public int GB
public long TB
public int Base16
public int MaxReliabilityRetries
public int MaxIdleTimeMs
public string DefaultSasVersion
public int MaxHashRequestDownloadRange
public int DefaultBufferSize
public int LargeBufferSize
public int LargeUploadThreshold
public int DefaultStreamingDownloadSize
public int DefaultStreamCopyBufferSize
public int DefaultDownloadCopyBufferSize
public int StorageCrc64SizeInBytes
public int MD5SizeInBytes
public bool DefaultTrimBlobNameSlashes
public string CloseAllHandles
public string Wildcard
public string BlockNameFormat
public string SasTimeFormatSeconds
public string SasTimeFormatSubSeconds
public string SasTimeFormatMinutes
public string SasTimeFormatDays
public string SnapshotParameterName
public string VersionIdParameterName
public string ShareSnapshotParameterName
public string Https
public string Http
public string PercentSign
public string EncodedPercentSign
public string QueryDelimiter
public string PathBackSlashDelimiter
public string FalseName
public string TrueName
public string ErrorCode
public string ErrorMessage
public string CommaString
public char CommaChar
public string ContentTypeApplicationXml
public string ContentTypeApplicationJson
public string ErrorPropertyKey
public string DetailPropertyKey
public string MessagePropertyKey
public string CodePropertyKey
public string Iso8601Format
public string DisableRequestConditionsValidationSwitchName
public string DisableRequestConditionsValidationEnvVar
public string DefaultScope
}
internal Azure.Storage.ContentHasher : object {
internal int GetHashSizeInBytes(StorageChecksumAlgorithm algorithm)
internal UploadTransferValidationOptions ToUploadTransferValidationOptions(GetHashResult hashResult)
public Task AssertResponseHashMatchInternal(Stream content, StorageChecksumAlgorithm algorithm, Response response, bool async, CancellationToken cancellationToken)
public void AssertResponseHashMatch(Byte[] content, int offset, int count, StorageChecksumAlgorithm algorithm, Response response)
private void AssertResponseHashMatch(GetHashResult computedHash, StorageChecksumAlgorithm algorithm, Response response)
public Task`1<GetHashResult> GetHashOrDefaultInternal(Stream content, UploadTransferValidationOptions options, bool async, CancellationToken cancellationToken)
public GetHashResult GetHashOrDefault(BinaryData content, UploadTransferValidationOptions options)
private bool GetHashOrDefaultTryFromOptions(UploadTransferValidationOptions options, GetHashResult& result)
public Task`1<GetHashResult> GetHashInternal(Stream content, StorageChecksumAlgorithm algorithmIdentifier, bool async, CancellationToken cancellationToken)
public GetHashResult GetHash(BinaryData content, StorageChecksumAlgorithm algorithmIdentifier)
public ValueTuple`4<Stream, GetFinalStreamHash, int, IDisposable> SetupChecksumCalculatingReadStream(Stream stream, StorageChecksumAlgorithm algorithmIdentifier)
private IHasher GetHasher(StorageChecksumAlgorithm algorithmIdentifier)
private Task`1<Byte[]> ComputeHashInternal(Stream content, IHasher hasher, bool async, CancellationToken cancellationToken)
public IHasher GetHasherFromAlgorithmId(StorageChecksumAlgorithm algorithm)
public ValueTuple`2<ReadOnlyMemory`1<byte>, StorageChecksumAlgorithm> GetResponseChecksumOrDefault(Response response)
internal Byte[] <GetHash>g__computeCrc|10_0(StorageCrc64HashAlgorithm nonCryptographicHashAlgorithm, <>c__DisplayClass10_0& )
}
internal Azure.Storage.Cryptography.AuthenticatedRegionCryptoStream : Stream {
private Stream _innerStream
private CryptoStreamMode _mode
private IAuthenticatedCryptographicTransform _transform
private bool _flushedFinal
private Byte[] _buffer
private int _bufferPos
private int _bufferPopulatedLength
private int _bufferLength
private int _tempRefillBufferSize
public bool CanRead
public bool CanWrite
public bool CanSeek
public long Length
public long Position
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void .ctor(Stream innerStream, IAuthenticatedCryptographicTransform transform, int regionDataSize, CryptoStreamMode streamMode)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
private Task FlushIfReadyInternal(bool async, CancellationToken cancellationToken)
public Task FlushFinalInternal(bool async, CancellationToken cancellationToken)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
protected void Dispose(bool disposing)
}
internal Azure.Storage.Cryptography.ClientSideDecryptor : object {
private AsyncLocal`1<ContentEncryptionKeyCache> s_contentEncryptionKeyCache
private IKeyEncryptionKey _potentialCachedIKeyEncryptionKey
private IKeyEncryptionKeyResolver _keyResolver
public void .ctor(ClientSideEncryptionOptions options)
public Task`1<Stream> DecryptReadInternal(Stream ciphertext, EncryptionData encryptionData, bool ivInStream, bool noPadding, bool async, CancellationToken cancellationToken)
public Task`1<Stream> DecryptWholeContentWriteInternal(Stream plaintextDestination, EncryptionData encryptionData, bool async, CancellationToken cancellationToken)
private Task`1<Stream> DecryptInternalV2_0(Stream ciphertext, EncryptionData encryptionData, CryptoStreamMode mode, bool async, CancellationToken cancellationToken)
private Stream WrapStreamV2_0(Stream contentStream, CryptoStreamMode mode, Byte[] contentEncryptionKey, int authRegionPlaintextSize)
private Task`1<Stream> DecryptReadInternalV1_0(Stream ciphertext, EncryptionData encryptionData, bool ivInStream, bool noPadding, bool async, CancellationToken cancellationToken)
private Task`1<Stream> DecryptWholeContentWriteInternalV1_0(Stream plaintextDestination, EncryptionData encryptionData, bool async, CancellationToken cancellationToken)
private Stream WrapStreamV1_0(Stream contentStream, Byte[] contentEncryptionKey, EncryptionData encryptionData, Byte[] iv, bool noPadding, CryptoStreamMode mode)
internal Task`1<Memory`1<byte>> GetContentEncryptionKeyAsync(EncryptionData encryptionData, bool async, CancellationToken cancellationToken)
internal void BeginContentEncryptionKeyCaching(ContentEncryptionKeyCache cache)
}
internal Azure.Storage.Cryptography.ClientSideEncryptionOptionsExtensions : object {
public ClientSideEncryptionOptions Clone(ClientSideEncryptionOptions options)
internal void CopyOptions(ClientSideEncryptionOptions source, ClientSideEncryptionOptions destination)
public IClientSideEncryptor GetClientSideEncryptor(ClientSideEncryptionOptions options)
}
internal Azure.Storage.Cryptography.ClientSideEncryptorV1_0 : object {
private IKeyEncryptionKey _keyEncryptionKey
private string _keyWrapAlgorithm
public void .ctor(ClientSideEncryptionOptions options)
private void ValidateMembers()
public long ExpectedOutputContentLength(long plaintextLength)
public long CalculateExpectedOutputContentLength(long plaintextLength)
public Task`1<ValueTuple`2<Stream, EncryptionData>> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
public Task`1<ValueTuple`2<Byte[], EncryptionData>> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
public Task`1<Stream> EncryptedOpenWriteInternal(Func`4<EncryptionData, bool, CancellationToken, Task`1<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken)
private Task`1<EncryptionData> CreateEncryptionDataInternal(Aes aes, bool async, CancellationToken cancellationToken)
private Byte[] CreateKey(int numBits)
}
internal Azure.Storage.Cryptography.ClientSideEncryptorV2_0 : object {
private IKeyEncryptionKey _keyEncryptionKey
private string _keyWrapAlgorithm
public void .ctor(ClientSideEncryptionOptions options)
public long ExpectedOutputContentLength(long plaintextLength)
public long CalculateExpectedOutputContentLength(long plaintextLength)
public Task`1<ValueTuple`2<Stream, EncryptionData>> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
public Task`1<ValueTuple`2<Byte[], EncryptionData>> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
public Task`1<Stream> EncryptedOpenWriteInternal(Func`4<EncryptionData, bool, CancellationToken, Task`1<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken)
private Task`1<EncryptionData> CreateEncryptionDataInternal(Byte[] key, bool async, CancellationToken cancellationToken)
private Byte[] CreateKey(int numBits)
}
internal Azure.Storage.Cryptography.GcmAuthenticatedCryptographicTransform : object {
private AesGcmWindows _gcm
private long _nonceCounter
private TransformMode <TransformMode>k__BackingField
public TransformMode TransformMode
public int NonceLength
public int TagLength
public TransformMode get_TransformMode()
public int get_NonceLength()
public int get_TagLength()
public void .ctor(Byte[] key, TransformMode mode)
public int TransformAuthenticationBlock(ReadOnlySpan`1<byte> input, Span`1<byte> output)
public void Dispose()
private ReadOnlySpan`1<byte> GetNewNonce()
}
internal Azure.Storage.Cryptography.IAuthenticatedCryptographicTransform {
public TransformMode TransformMode
public int NonceLength
public int TagLength
public TransformMode get_TransformMode()
public int get_NonceLength()
public int get_TagLength()
public int TransformAuthenticationBlock(ReadOnlySpan`1<byte> input, Span`1<byte> output)
}
internal Azure.Storage.Cryptography.IClientSideEncryptor {
public long ExpectedOutputContentLength(long plaintextLength)
public Task`1<ValueTuple`2<Stream, EncryptionData>> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
public Task`1<ValueTuple`2<Byte[], EncryptionData>> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
public Task`1<Stream> EncryptedOpenWriteInternal(Func`4<EncryptionData, bool, CancellationToken, Task`1<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.Cryptography.Models.ClientSideEncryptionAlgorithm : ValueType {
internal string AesCbc256Value
internal string AesGcm256Value
private string _value
private ClientSideEncryptionAlgorithm <AesCbc256>k__BackingField
private ClientSideEncryptionAlgorithm <AesGcm256>k__BackingField
public ClientSideEncryptionAlgorithm AesCbc256
public ClientSideEncryptionAlgorithm AesGcm256
public void .ctor(string value)
public ClientSideEncryptionAlgorithm get_AesCbc256()
public ClientSideEncryptionAlgorithm get_AesGcm256()
public bool op_Equality(ClientSideEncryptionAlgorithm left, ClientSideEncryptionAlgorithm right)
public bool op_Inequality(ClientSideEncryptionAlgorithm left, ClientSideEncryptionAlgorithm right)
public ClientSideEncryptionAlgorithm op_Implicit(string value)
public bool Equals(object obj)
public bool Equals(ClientSideEncryptionAlgorithm other)
public int GetHashCode()
public string ToString()
}
internal Azure.Storage.Cryptography.Models.ClientSideEncryptionVersionExtensions : object {
public string Serialize(ClientSideEncryptionVersion version)
public ClientSideEncryptionVersion ToClientSideEncryptionVersion(string versionString)
}
internal Azure.Storage.Cryptography.Models.EncryptedRegionInfo : object {
private int <DataLength>k__BackingField
private int <NonceLength>k__BackingField
public int DataLength
public int NonceLength
public int get_DataLength()
public void set_DataLength(int value)
public int get_NonceLength()
public void set_NonceLength(int value)
}
internal Azure.Storage.Cryptography.Models.EncryptionAgent : object {
private ClientSideEncryptionVersion <EncryptionVersion>k__BackingField
private ClientSideEncryptionAlgorithm <EncryptionAlgorithm>k__BackingField
public ClientSideEncryptionVersion EncryptionVersion
public ClientSideEncryptionAlgorithm EncryptionAlgorithm
public ClientSideEncryptionVersion get_EncryptionVersion()
public void set_EncryptionVersion(ClientSideEncryptionVersion value)
public ClientSideEncryptionAlgorithm get_EncryptionAlgorithm()
public void set_EncryptionAlgorithm(ClientSideEncryptionAlgorithm value)
}
internal Azure.Storage.Cryptography.Models.EncryptionData : object {
private string <EncryptionMode>k__BackingField
private KeyEnvelope <WrappedContentKey>k__BackingField
private EncryptionAgent <EncryptionAgent>k__BackingField
private Byte[] <ContentEncryptionIV>k__BackingField
private EncryptedRegionInfo <EncryptedRegionInfo>k__BackingField
private IDictionary`2<string, string> <KeyWrappingMetadata>k__BackingField
private string <AgentString>k__BackingField
public string EncryptionMode
public KeyEnvelope WrappedContentKey
public EncryptionAgent EncryptionAgent
public Byte[] ContentEncryptionIV
public EncryptedRegionInfo EncryptedRegionInfo
public IDictionary`2<string, string> KeyWrappingMetadata
private string AgentString
public string get_EncryptionMode()
public void set_EncryptionMode(string value)
public KeyEnvelope get_WrappedContentKey()
public void set_WrappedContentKey(KeyEnvelope value)
public EncryptionAgent get_EncryptionAgent()
public void set_EncryptionAgent(EncryptionAgent value)
public Byte[] get_ContentEncryptionIV()
public void set_ContentEncryptionIV(Byte[] value)
public EncryptedRegionInfo get_EncryptedRegionInfo()
public void set_EncryptedRegionInfo(EncryptedRegionInfo value)
public IDictionary`2<string, string> get_KeyWrappingMetadata()
public void set_KeyWrappingMetadata(IDictionary`2<string, string> value)
internal ValueTask`1<EncryptionData> CreateInternalV1_0(Byte[] contentEncryptionIv, string keyWrapAlgorithm, Byte[] contentEncryptionKey, IKeyEncryptionKey keyEncryptionKey, bool async, CancellationToken cancellationToken)
internal Task`1<EncryptionData> CreateInternalV2_0(string keyWrapAlgorithm, Byte[] contentEncryptionKey, IKeyEncryptionKey keyEncryptionKey, bool async, CancellationToken cancellationToken)
private string get_AgentString()
private string GenerateAgentString()
}
internal Azure.Storage.Cryptography.Models.EncryptionDataSerializer : object {
private string EncryptionAgent_EncryptionVersionName
public string Serialize(EncryptionData data)
private ReadOnlyMemory`1<byte> SerializeEncryptionData(EncryptionData data)
public void WriteEncryptionData(Utf8JsonWriter json, EncryptionData data)
private void WriteEncryptedRegionInfo(Utf8JsonWriter json, EncryptedRegionInfo encryptedRegionInfo)
private void WriteWrappedKey(Utf8JsonWriter json, KeyEnvelope key)
private void WriteEncryptionAgent(Utf8JsonWriter json, EncryptionAgent encryptionAgent)
private void WriteDictionary(Utf8JsonWriter json, IDictionary`2<string, string> dictionary)
public EncryptionData Deserialize(string serializedData)
public EncryptionData DeserializeEncryptionData(Utf8JsonReader& reader)
public EncryptionData ReadEncryptionData(JsonElement root)
private void ReadPropertyValue(EncryptionData data, JsonProperty property)
private void ReadPropertyValue(KeyEnvelope key, JsonProperty property)
private void ReadPropertyValue(EncryptionAgent agent, JsonProperty property)
private void ReadPropertyValue(EncryptedRegionInfo info, JsonProperty property)
}
internal Azure.Storage.Cryptography.Models.KeyEnvelope : object {
private string <KeyId>k__BackingField
private Byte[] <EncryptedKey>k__BackingField
private string <Algorithm>k__BackingField
public string KeyId
public Byte[] EncryptedKey
public string Algorithm
public string get_KeyId()
public void set_KeyId(string value)
public Byte[] get_EncryptedKey()
public void set_EncryptedKey(Byte[] value)
public string get_Algorithm()
public void set_Algorithm(string value)
}
internal Azure.Storage.Cryptography.Models.TransformMode : Enum {
public int value__
public TransformMode Encrypt
public TransformMode Decrypt
}
internal Azure.Storage.DisposableBucket : object {
private List`1<IDisposable> <Disposables>k__BackingField
private List`1<IDisposable> Disposables
private List`1<IDisposable> get_Disposables()
public void Add(IDisposable disposable)
public void Dispose()
}
internal Azure.Storage.Errors : object {
public ArgumentException AccountMismatch(string accountNameCredential, string accountNameValue)
public InvalidOperationException AccountSasMissingData()
public ArgumentNullException ArgumentNull(string paramName)
public ArgumentException InvalidArgument(string paramName)
public ArgumentException InvalidResourceType(char s)
public InvalidOperationException TaskIncomplete()
public FormatException InvalidFormat(string err)
public ArgumentException ParsingConnectionStringFailed()
public ArgumentOutOfRangeException InvalidSasProtocol(string protocol, string sasProtocol)
public ArgumentException InvalidService(char s)
public ArgumentException InsufficientStorageTransferOptions(long streamLength, long statedMaxBlockSize, long necessaryMinBlockSize)
public InvalidDataException HashMismatch(string hashHeaderName)
public InvalidDataException ChecksumMismatch(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right)
public InvalidDataException HashMismatchOnStreamedDownload(string mismatchedRange)
public ArgumentException PrecalculatedHashNotSupportedOnSplit()
public ArgumentException CannotDeferTransactionalHashVerification()
public ArgumentException CannotInitializeWriteStreamWithData()
internal void VerifyStreamPosition(Stream stream, string streamName)
public void ThrowIfParamNull(object obj, string paramName)
internal void CheckCryptKeySize(int keySizeInBytes)
public CryptographicException CryptographyAuthTagMismatch()
public ArgumentException CryptographyPlaintextCiphertextLengthMismatch()
public ArgumentException CryptographyInvalidNonceLength()
public ArgumentException CryptographyInvalidTagLength()
public ArgumentException CannotBothBeNotNull(string param0, string param1)
public ArgumentOutOfRangeException MustBeGreaterThanOrEqualTo(string paramName, long value)
public ArgumentOutOfRangeException MustBeLessThanOrEqualTo(string paramName, long value)
public ArgumentOutOfRangeException MustBeBetweenInclusive(string paramName, long lower, long upper, long actual)
public ArgumentOutOfRangeException MustBeGreaterThanValueOrEqualToOtherValue(string paramName, long value0, long value1)
public ArgumentException StreamMustBeReadable(string paramName)
public InvalidOperationException StreamMustBeAtPosition0()
public InvalidOperationException TokenCredentialsRequireHttps()
public ArgumentException SasCredentialRequiresUriWithoutSas(Uri uri)
public InvalidOperationException SasMissingData(string paramName)
public InvalidOperationException SasDataNotAllowed(string paramName, string paramNameNotAllowed)
public InvalidOperationException SasDataInConjunction(string paramName, string paramName2)
public InvalidOperationException SasNamesNotMatching(string builderParam, string builderName, string clientParam)
public InvalidOperationException SasNamesNotMatching(string builderParam, string builderName)
public InvalidOperationException SasServiceNotMatching(string builderParam, string builderName, string expectedService)
public InvalidOperationException SasClientMissingData(string paramName)
public InvalidOperationException SasBuilderEmptyParam(string builderName, string paramName, string sasType)
public InvalidOperationException SasIncorrectResourceType(string builderName, string builderParam, string value, string clientName)
public ArgumentException InvalidPermission(char s)
public ArgumentException ParsingHttpRangeFailed()
public AccessViolationException UnableAccessArray()
public NotImplementedException NotImplemented()
public AuthenticationException InvalidCredentials(string fullName)
public ArgumentException SeekOutsideBufferRange(long index, long inclusiveRangeStart, long exclusiveRangeEnd)
public ArgumentException VersionNotSupported(string paramName)
public RequestFailedException ClientRequestIdMismatch(Response response, string echo, string original)
public ArgumentException TransactionalHashingNotSupportedWithClientSideEncryption()
public void VerifyHttpsTokenAuth(Uri uri)
}
internal Azure.Storage.GeoRedundantReadPolicy : HttpPipelineSynchronousPolicy {
private string _secondaryStorageHost
public void .ctor(Uri secondaryStorageUri)
public void OnSendingRequest(HttpMessage message)
}
internal Azure.Storage.HashAlgorithmHasher : object {
private HashAlgorithm _hashAlgorithm
public int HashSizeInBytes
public int get_HashSizeInBytes()
public void .ctor(HashAlgorithm hashAlgorithm)
public Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken)
public void AppendHash(ReadOnlySpan`1<byte> content)
public int GetFinalHash(Span`1<byte> hashDestination)
public void Dispose()
private int BitsToBytes(int bits)
}
internal Azure.Storage.IHasher {
public int HashSizeInBytes
public int get_HashSizeInBytes()
public Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken)
public void AppendHash(ReadOnlySpan`1<byte> content)
public int GetFinalHash(Span`1<byte> hashDestination)
}
internal Azure.Storage.IHasherExtensions : object {
public Memory`1<byte> GetFinalHash(IHasher hasher)
}
internal Azure.Storage.Internal.Avro.AvroConstants : object {
public int SyncMarkerSize
public Byte[] InitBytes
public string CodecKey
public string SchemaKey
public string Null
public string Boolean
public string Int
public string Long
public string Float
public string Double
public string Bytes
public string String
public string Record
public string Enum
public string Map
public string Array
public string Union
public string Fixed
public string Aliases
public string Name
public string Fields
public string Type
public string Symbols
public string Values
}
internal Azure.Storage.Internal.Avro.AvroEnumType : AvroType {
private IReadOnlyList`1<string> <Symbols>k__BackingField
public IReadOnlyList`1<string> Symbols
public IReadOnlyList`1<string> get_Symbols()
public void set_Symbols(IReadOnlyList`1<string> value)
public Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.Internal.Avro.AvroMapType : AvroType {
private AvroType <ItemType>k__BackingField
public AvroType ItemType
public AvroType get_ItemType()
public void set_ItemType(AvroType value)
public Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
private Task`1<object> <ReadAsync>b__4_0(Stream s, bool a, CancellationToken c)
}
internal Azure.Storage.Internal.Avro.AvroParser : object {
public Task`1<Byte[]> ReadFixedBytesAsync(Stream stream, int length, bool async, CancellationToken cancellationToken)
private Task`1<byte> ReadByteAsync(Stream stream, bool async, CancellationToken cancellationToken)
private Task`1<long> ReadZigZagLongAsync(Stream stream, bool async, CancellationToken cancellationToken)
public Task`1<object> ReadNullAsync()
public Task`1<bool> ReadBoolAsync(Stream stream, bool async, CancellationToken cancellationToken)
public Task`1<long> ReadLongAsync(Stream stream, bool async, CancellationToken cancellationToken)
public Task`1<int> ReadIntAsync(Stream stream, bool async, CancellationToken cancellationToken)
public Task`1<float> ReadFloatAsync(Stream stream, bool async, CancellationToken cancellationToken)
public Task`1<double> ReadDoubleAsync(Stream stream, bool async, CancellationToken cancellationToken)
public Task`1<Byte[]> ReadBytesAsync(Stream stream, bool async, CancellationToken cancellationToken)
public Task`1<string> ReadStringAsync(Stream stream, bool async, CancellationToken cancellationToken)
private Task`1<KeyValuePair`2<string, T>> ReadMapPairAsync(Stream stream, Func`4<Stream, bool, CancellationToken, Task`1<T>> parseItemAsync, bool async, CancellationToken cancellationToken)
public Task`1<Dictionary`2<string, T>> ReadMapAsync(Stream stream, Func`4<Stream, bool, CancellationToken, Task`1<T>> parseItemAsync, bool async, CancellationToken cancellationToken)
private Task`1<IEnumerable`1<T>> ReadArrayAsync(Stream stream, Func`4<Stream, bool, CancellationToken, Task`1<T>> parseItemAsync, bool async, CancellationToken cancellationToken)
internal List`1<T> Map(JsonElement array, Func`2<JsonElement, T> selector)
internal Dictionary`2<string, T> ToDictionary(IEnumerable`1<KeyValuePair`2<string, T>> values)
}
internal Azure.Storage.Internal.Avro.AvroPrimitive : Enum {
public int value__
public AvroPrimitive Null
public AvroPrimitive Boolean
public AvroPrimitive Int
public AvroPrimitive Long
public AvroPrimitive Float
public AvroPrimitive Double
public AvroPrimitive Bytes
public AvroPrimitive String
}
internal Azure.Storage.Internal.Avro.AvroPrimitiveType : AvroType {
private AvroPrimitive <Primitive>k__BackingField
public AvroPrimitive Primitive
public AvroPrimitive get_Primitive()
public void set_Primitive(AvroPrimitive value)
public Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.Internal.Avro.AvroReader : object {
private Stream _dataStream
private Stream _headerStream
private Byte[] _syncMarker
private Dictionary`2<string, string> _metadata
private AvroType _itemType
private long _itemsRemainingInBlock
private long <BlockOffset>k__BackingField
private long <ObjectIndex>k__BackingField
private bool _initalized
private bool _disposed
private long _initialBlockOffset
public long BlockOffset
public long ObjectIndex
public long get_BlockOffset()
private void set_BlockOffset(long value)
public long get_ObjectIndex()
private void set_ObjectIndex(long value)
public void .ctor(Stream dataStream)
public void .ctor(Stream dataStream, Stream headerStream, long currentBlockOffset, long indexWithinCurrentBlock)
public Task Initalize(bool async, CancellationToken cancellationToken)
public bool HasNext()
public Task`1<object> Next(bool async, CancellationToken cancellationToken)
public void Dispose()
protected void Dispose(bool disposing)
}
internal Azure.Storage.Internal.Avro.AvroRecordType : AvroType {
private string <Schema>k__BackingField
private IReadOnlyDictionary`2<string, AvroType> <Fields>k__BackingField
public string Schema
public IReadOnlyDictionary`2<string, AvroType> Fields
public string get_Schema()
public void set_Schema(string value)
public IReadOnlyDictionary`2<string, AvroType> get_Fields()
public void set_Fields(IReadOnlyDictionary`2<string, AvroType> value)
public Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.Internal.Avro.AvroType : object {
public Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
public AvroType FromSchema(JsonElement schema)
private AvroType FromStringSchema(JsonElement schema)
private AvroType FromArraySchema(JsonElement schema)
private AvroType FromObjectSchema(JsonElement schema)
}
internal Azure.Storage.Internal.Avro.AvroUnionType : AvroType {
private IReadOnlyList`1<AvroType> <Types>k__BackingField
public IReadOnlyList`1<AvroType> Types
public IReadOnlyList`1<AvroType> get_Types()
public void set_Types(IReadOnlyList`1<AvroType> value)
public Task`1<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.Internal.Avro.StreamWithPosition : Stream {
private Stream _stream
private long _position
private bool _disposed
public long Position
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public void .ctor(Stream stream, long position)
public long get_Position()
public void set_Position(long value)
public int ReadByte()
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void Flush()
protected void Dispose(bool disposing)
}
internal Azure.Storage.LazyLoadingReadOnlyStream`1 : Stream {
private long _position
private long _length
private int _bufferSize
private Byte[] _buffer
private int _bufferPosition
private int _bufferLength
private bool _allowBlobModifications
private bool _bufferInvalidated
private DownloadInternalAsync<TProperties> _downloadInternalFunc
private GetPropertiesAsync<TProperties> _getPropertiesInternalFunc
private DownloadTransferValidationOptions _validationOptions
private PredictEncryptedRangeAdjustment<TProperties> _predictEncryptedRangeAdjustment
public PredictEncryptedRangeAdjustment<TProperties> NoRangeAdjustment
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public PredictEncryptedRangeAdjustment<TProperties> get_NoRangeAdjustment()
public void .ctor(DownloadInternalAsync<TProperties> downloadInternalFunc, GetPropertiesAsync<TProperties> getPropertiesFunc, DownloadTransferValidationOptions transferValidation, bool allowModifications, long initialLenght, long position, Nullable`1<int> bufferSize, PredictEncryptedRangeAdjustment<TProperties> rangePredictionFunc)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
private Task`1<int> DownloadInternal(bool async, CancellationToken cancellationToken)
private void ValidateReadParameters(Byte[] buffer, int offset, int count)
protected void Dispose(bool disposing)
private Task`1<long> GetBlobLengthInternal(bool async, CancellationToken cancellationToken)
private long GetBlobLengthFromResponse(Response response)
private HttpRange GetResponseRange(Response response)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public long Seek(long offset, SeekOrigin origin)
internal long CalculateNewPosition(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
}
internal Azure.Storage.LoggingExtensions : object {
public IDisposable BeginLoggingScope(HttpPipeline pipeline, string className, string member)
public void LogMethodEnter(HttpPipeline pipeline, string className, string member, string message)
public void LogMethodExit(HttpPipeline pipeline, string className, string member, string message)
public void LogException(HttpPipeline pipeline, Exception ex, string message)
public void LogTrace(HttpPipeline pipeline, string message)
}
internal Azure.Storage.NonCryptographicHashAlgorithmHasher : object {
private int _streamBufferSize
private NonCryptographicHashAlgorithm _nonCryptographicHashAlgorithm
public int HashSizeInBytes
public int get_HashSizeInBytes()
public void .ctor(NonCryptographicHashAlgorithm nonCryptographicHashAlgorithm)
public Task`1<Byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken)
public void AppendHash(ReadOnlySpan`1<byte> content)
public int GetFinalHash(Span`1<byte> hashDestination)
public void Dispose()
}
internal Azure.Storage.NonDisposingStream : Stream {
private Stream _innerStream
public bool CanRead
public bool CanSeek
public bool CanWrite
public bool CanTimeout
public long Length
public long Position
public int ReadTimeout
public int WriteTimeout
public void .ctor(Stream innerStream)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public bool get_CanTimeout()
public Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public int ReadByte()
public void WriteByte(byte value)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public void EndWrite(IAsyncResult asyncResult)
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
}
internal Azure.Storage.PartitionedUploader`2 : object {
public InitializeDestinationInternal<TServiceSpecificData, TCompleteUploadReturn> InitializeNoOp
private InitializeDestinationInternal<TServiceSpecificData, TCompleteUploadReturn> _initializeDestinationInternal
private SingleUploadStreamingInternal<TServiceSpecificData, TCompleteUploadReturn> _singleUploadStreamingInternal
private SingleUploadBinaryDataInternal<TServiceSpecificData, TCompleteUploadReturn> _singleUploadBinaryDataInternal
private UploadPartitionStreamingInternal<TServiceSpecificData, TCompleteUploadReturn> _uploadPartitionStreamingInternal
private UploadPartitionBinaryDataInternal<TServiceSpecificData, TCompleteUploadReturn> _uploadPartitionBinaryDataInternal
private CommitPartitionedUploadInternal<TServiceSpecificData, TCompleteUploadReturn> _commitPartitionedUploadInternal
private CreateScope<TServiceSpecificData, TCompleteUploadReturn> _createScope
private int _maxWorkerCount
private ArrayPool`1<byte> _arrayPool
private long _singleUploadThreshold
private Nullable`1<long> _blockSize
private StorageChecksumAlgorithm _validationAlgorithm
private Func`1<Memory`1<byte>> _masterCrcSupplier
private string _operationName
private bool UseMasterCrc
private UploadTransferValidationOptions ValidationOptions
private bool get_UseMasterCrc()
private UploadTransferValidationOptions get_ValidationOptions()
public void .ctor(Behaviors<TServiceSpecificData, TCompleteUploadReturn> behaviors, StorageTransferOptions transferOptions, UploadTransferValidationOptions transferValidation, ArrayPool`1<byte> arrayPool, string operationName)
public Task`1<Response`1<TCompleteUploadReturn>> UploadInternal(BinaryData content, TServiceSpecificData args, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken)
public Task`1<Response`1<TCompleteUploadReturn>> UploadInternal(Stream content, Nullable`1<long> expectedContentLength, TServiceSpecificData args, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken)
private Task`1<ValueTuple`2<Stream, UploadTransferValidationOptions>> BufferAndOptionalChecksumStreamInternal(Stream source, long minCount, long maxCount, UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
private Task`1<Response`1<TCompleteUploadReturn>> UploadInSequenceInternal(TContent content, Nullable`1<long> contentLength, long partitionSize, TServiceSpecificData args, IProgress`1<long> progressHandler, GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> partitionContentAsync, StageContentPartitionAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> stageContentAsync, bool async, CancellationToken cancellationToken)
private Task`1<Response`1<TCompleteUploadReturn>> UploadInParallelAsync(TContent content, Nullable`1<long> contentLength, long blockSize, TServiceSpecificData args, IProgress`1<long> progressHandler, GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> partitionContentAsync, StageContentPartitionAsync`1<TServiceSpecificData, TCompleteUploadReturn, TContent> stageContentAsync, CancellationToken cancellationToken)
private Task StageStreamPartitionInternal(Stream partition, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken)
private Task StageBinaryDataPartitionInternal(BinaryData content, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress`1<long> progressHandler, bool async, CancellationToken cancellationToken)
private IAsyncEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, BinaryData>> GetContentPartitionsBinaryDataInternal(BinaryData content, Nullable`1<long> contentLength, long blockSize, bool async, CancellationToken cancellationToken)
private IEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, BinaryData>> GetBinaryDataPartitions(BinaryData content, int blockSize)
private GetContentPartitionsAsync`1<TServiceSpecificData, TCompleteUploadReturn, Stream> GetStreamPartitioner(GetNextStreamPartition<TServiceSpecificData, TCompleteUploadReturn> partitionCreator)
private IAsyncEnumerable`1<ContentPartition`1<TServiceSpecificData, TCompleteUploadReturn, Stream>> GetStreamPartitionsAsync(Stream stream, Nullable`1<long> streamLength, long blockSize, GetNextStreamPartition<TServiceSpecificData, TCompleteUploadReturn> getNextPartition, bool async, CancellationToken cancellationToken)
private Task`1<ValueTuple`2<Stream, ReadOnlyMemory`1<byte>>> GetBufferedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken)
private Task`1<ValueTuple`2<Stream, ReadOnlyMemory`1<byte>>> GetStreamedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.ProgressIncrementingStream : Stream {
private Stream _innerStream
private AggregatingProgressIncrementer _incrementer
public bool CanRead
public bool CanSeek
public bool CanTimeout
public bool CanWrite
public long Length
public long Position
public int ReadTimeout
public int WriteTimeout
public void .ctor(Stream stream, AggregatingProgressIncrementer incrementer)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanTimeout()
public bool get_CanWrite()
protected void Dispose(bool disposing)
public Task FlushAsync(CancellationToken cancellationToken)
public void Flush()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public int ReadByte()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
public void WriteByte(byte value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
}
public Azure.Storage.Sas.BlobAccountSasPermissions : Enum {
public int value__
public BlobAccountSasPermissions Read
public BlobAccountSasPermissions Add
public BlobAccountSasPermissions Create
public BlobAccountSasPermissions Write
public BlobAccountSasPermissions Delete
public BlobAccountSasPermissions List
public BlobAccountSasPermissions All
}
public Azure.Storage.Sas.BlobContainerSasPermissions : Enum {
public int value__
public BlobContainerSasPermissions Read
public BlobContainerSasPermissions Add
public BlobContainerSasPermissions Create
public BlobContainerSasPermissions Write
public BlobContainerSasPermissions Delete
public BlobContainerSasPermissions List
public BlobContainerSasPermissions Tag
public BlobContainerSasPermissions DeleteBlobVersion
public BlobContainerSasPermissions Move
public BlobContainerSasPermissions Execute
public BlobContainerSasPermissions SetImmutabilityPolicy
public BlobContainerSasPermissions Filter
public BlobContainerSasPermissions All
}
public Azure.Storage.Sas.BlobSasBuilder : object {
private string <Version>k__BackingField
private SasProtocol <Protocol>k__BackingField
private DateTimeOffset <StartsOn>k__BackingField
private DateTimeOffset <ExpiresOn>k__BackingField
private string <Permissions>k__BackingField
private SasIPRange <IPRange>k__BackingField
private string <Identifier>k__BackingField
private string <BlobContainerName>k__BackingField
private string <BlobName>k__BackingField
private string <Snapshot>k__BackingField
private string <BlobVersionId>k__BackingField
private string <Resource>k__BackingField
private string <CacheControl>k__BackingField
private string <ContentDisposition>k__BackingField
private string <ContentEncoding>k__BackingField
private string <ContentLanguage>k__BackingField
private string <ContentType>k__BackingField
private string <PreauthorizedAgentObjectId>k__BackingField
private string <CorrelationId>k__BackingField
private string <EncryptionScope>k__BackingField
public string Version
public SasProtocol Protocol
public DateTimeOffset StartsOn
public DateTimeOffset ExpiresOn
public string Permissions
public SasIPRange IPRange
public string Identifier
public string BlobContainerName
public string BlobName
public string Snapshot
public string BlobVersionId
public string Resource
public string CacheControl
public string ContentDisposition
public string ContentEncoding
public string ContentLanguage
public string ContentType
public string PreauthorizedAgentObjectId
public string CorrelationId
public string EncryptionScope
public string get_Version()
public void set_Version(string value)
public SasProtocol get_Protocol()
public void set_Protocol(SasProtocol value)
public DateTimeOffset get_StartsOn()
public void set_StartsOn(DateTimeOffset value)
public DateTimeOffset get_ExpiresOn()
public void set_ExpiresOn(DateTimeOffset value)
public string get_Permissions()
private void set_Permissions(string value)
public SasIPRange get_IPRange()
public void set_IPRange(SasIPRange value)
public string get_Identifier()
public void set_Identifier(string value)
public string get_BlobContainerName()
public void set_BlobContainerName(string value)
public string get_BlobName()
public void set_BlobName(string value)
public string get_Snapshot()
public void set_Snapshot(string value)
public string get_BlobVersionId()
public void set_BlobVersionId(string value)
public string get_Resource()
public void set_Resource(string value)
public string get_CacheControl()
public void set_CacheControl(string value)
public string get_ContentDisposition()
public void set_ContentDisposition(string value)
public string get_ContentEncoding()
public void set_ContentEncoding(string value)
public string get_ContentLanguage()
public void set_ContentLanguage(string value)
public string get_ContentType()
public void set_ContentType(string value)
public string get_PreauthorizedAgentObjectId()
public void set_PreauthorizedAgentObjectId(string value)
public string get_CorrelationId()
public void set_CorrelationId(string value)
public string get_EncryptionScope()
public void set_EncryptionScope(string value)
public void .ctor(BlobSasPermissions permissions, DateTimeOffset expiresOn)
public void .ctor(BlobContainerSasPermissions permissions, DateTimeOffset expiresOn)
public void SetPermissions(BlobSasPermissions permissions)
public void SetPermissions(BlobAccountSasPermissions permissions)
public void SetPermissions(BlobContainerSasPermissions permissions)
public void SetPermissions(SnapshotSasPermissions permissions)
public void SetPermissions(BlobVersionSasPermissions permissions)
public void SetPermissions(string rawPermissions, bool normalize)
public void SetPermissions(string rawPermissions)
public BlobSasQueryParameters ToSasQueryParameters(StorageSharedKeyCredential sharedKeyCredential)
public BlobSasQueryParameters ToSasQueryParameters(UserDelegationKey userDelegationKey, string accountName)
private string GetCanonicalName(string account, string containerName, string blobName)
private string ComputeHMACSHA256(string userDelegationKeyValue, string message)
private void EnsureState()
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
internal BlobSasBuilder DeepCopy(BlobSasBuilder originalBlobSasBuilder)
}
public Azure.Storage.Sas.BlobSasPermissions : Enum {
public int value__
public BlobSasPermissions Read
public BlobSasPermissions Add
public BlobSasPermissions Create
public BlobSasPermissions Write
public BlobSasPermissions Delete
public BlobSasPermissions Tag
public BlobSasPermissions DeleteBlobVersion
public BlobSasPermissions List
public BlobSasPermissions Move
public BlobSasPermissions Execute
public BlobSasPermissions SetImmutabilityPolicy
public BlobSasPermissions PermanentDelete
public BlobSasPermissions All
}
public Azure.Storage.Sas.BlobSasQueryParameters : SasQueryParameters {
private UserDelegationKeyProperties <KeyProperties>k__BackingField
internal UserDelegationKeyProperties KeyProperties
public string KeyObjectId
public string KeyTenantId
public DateTimeOffset KeyStartsOn
public DateTimeOffset KeyExpiresOn
public string KeyService
public string KeyVersion
public BlobSasQueryParameters Empty
internal UserDelegationKeyProperties get_KeyProperties()
internal void set_KeyProperties(UserDelegationKeyProperties value)
public string get_KeyObjectId()
public string get_KeyTenantId()
public DateTimeOffset get_KeyStartsOn()
public DateTimeOffset get_KeyExpiresOn()
public string get_KeyService()
public string get_KeyVersion()
public BlobSasQueryParameters get_Empty()
internal void .ctor(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string keyOid, string keyTid, DateTimeOffset keyStart, DateTimeOffset keyExpiry, string keyService, string keyVersion, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, string encryptionScope)
internal void .ctor(IDictionary`2<string, string> values)
public string ToString()
}
public Azure.Storage.Sas.BlobVersionSasPermissions : Enum {
public int value__
public BlobVersionSasPermissions Delete
public BlobVersionSasPermissions SetImmutabilityPolicy
public BlobVersionSasPermissions PermanentDelete
public BlobVersionSasPermissions All
}
internal Azure.Storage.Sas.SasExtensions : object {
private string NoneName
private string HttpsName
private string HttpsAndHttpName
internal string ToPermissionsString(AccountSasResourceTypes resourceTypes)
internal AccountSasResourceTypes ParseResourceTypes(string s)
internal string ToProtocolString(SasProtocol protocol)
public SasProtocol ParseProtocol(string s)
internal string ToPermissionsString(AccountSasServices services)
internal AccountSasServices ParseAccountServices(string s)
internal string FormatTimesForSasSigning(DateTimeOffset time)
internal void AddToBuilder(StringBuilder sb, string key, string value)
internal string ValidateAndSanitizeRawPermissions(string permissions, List`1<char> validPermissionsInOrder)
}
internal Azure.Storage.Sas.SasQueryParametersExtensions : object {
internal void ParseKeyProperties(BlobSasQueryParameters parameters, IDictionary`2<string, string> values)
}
internal Azure.Storage.Sas.SasQueryParametersInternals : SasQueryParameters {
private string <DefaultSasVersionInternal>k__BackingField
internal string DefaultSasVersionInternal
internal string get_DefaultSasVersionInternal()
internal void set_DefaultSasVersionInternal(string value)
internal SasQueryParameters Create(IDictionary`2<string, string> values)
internal SasQueryParameters Create(string version, Nullable`1<AccountSasServices> services, Nullable`1<AccountSasResourceTypes> resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl, string contentDisposition, string contentEncoding, string contentLanguage, string contentType, string authorizedAadObjectId, string unauthorizedAadObjectId, string correlationId, Nullable`1<int> directoryDepth, string encryptionScope)
}
public Azure.Storage.Sas.SnapshotSasPermissions : Enum {
public int value__
public SnapshotSasPermissions Read
public SnapshotSasPermissions Write
public SnapshotSasPermissions Delete
public SnapshotSasPermissions SetImmutabilityPolicy
public SnapshotSasPermissions PermanentDelete
public SnapshotSasPermissions All
}
internal Azure.Storage.Sas.UserDelegationKeyProperties : object {
private string <ObjectId>k__BackingField
private string <TenantId>k__BackingField
private DateTimeOffset <StartsOn>k__BackingField
private DateTimeOffset <ExpiresOn>k__BackingField
private string <Service>k__BackingField
private string <Version>k__BackingField
internal string ObjectId
internal string TenantId
internal DateTimeOffset StartsOn
internal DateTimeOffset ExpiresOn
internal string Service
internal string Version
internal string get_ObjectId()
internal void set_ObjectId(string value)
internal string get_TenantId()
internal void set_TenantId(string value)
internal DateTimeOffset get_StartsOn()
internal void set_StartsOn(DateTimeOffset value)
internal DateTimeOffset get_ExpiresOn()
internal void set_ExpiresOn(DateTimeOffset value)
internal string get_Service()
internal void set_Service(string value)
internal string get_Version()
internal void set_Version(string value)
public void AppendProperties(StringBuilder stringBuilder)
}
internal Azure.Storage.Shared.AesGcm.AeadCommon : object {
internal void Encrypt(SafeKeyHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag)
internal void Decrypt(SafeKeyHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, bool clearPlaintextOnFailure)
private Byte& modreq(System.Runtime.InteropServices.InAttribute) GetNonNullPinnableReference(ReadOnlySpan`1<byte> buffer)
private Byte& GetNonNullPinnableReference(Span`1<byte> buffer)
}
internal Azure.Storage.Shared.AesGcm.AesGcmWindows : object {
private int NonceSize
private KeySizes <NonceByteSizes>k__BackingField
private KeySizes <TagByteSizes>k__BackingField
private SafeKeyHandle _keyHandle
internal KeySizes NonceByteSizes
internal KeySizes TagByteSizes
internal bool IsSupported
internal KeySizes get_NonceByteSizes()
internal KeySizes get_TagByteSizes()
internal void .ctor(ReadOnlySpan`1<byte> key)
internal void .ctor(Byte[] key)
internal void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData)
internal void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData)
internal void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData)
internal void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData)
private void CheckParameters(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> tag)
private void ThrowIfNotSupported()
internal bool get_IsSupported()
private void ImportKey(ReadOnlySpan`1<byte> key)
private void EncryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData)
private void DecryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData)
public void Dispose()
}
internal Azure.Storage.Shared.AesGcm.KeySizeHelpers : object {
internal KeySizes[] CloneKeySizesArray(KeySizes[] src)
internal bool IsLegalSize(int size, KeySizes legalSizes)
internal bool IsLegalSize(int size, KeySizes[] legalSizes)
internal bool IsLegalSize(int size, KeySizes legalSizes, Boolean& validatedByZeroSkipSizeKeySizes)
internal bool IsLegalSize(int size, KeySizes[] legalSizes, Boolean& validatedByZeroSkipSizeKeySizes)
}
internal Azure.Storage.Shared.AesGcm.SafeBCryptHandle : SafeHandle {
public bool IsInvalid
public bool get_IsInvalid()
protected bool ReleaseHandle()
}
internal Azure.Storage.Shared.IDownloadedContent {
public Stream Content
public Stream get_Content()
}
internal Azure.Storage.Shared.ISupportsTenantIdChallenges {
public bool EnableTenantDiscovery
public bool get_EnableTenantDiscovery()
}
internal Azure.Storage.Shared.PooledMemoryStream : Stream {
private int DefaultMaxArrayPoolRentalSize
private int <MaxArraySize>k__BackingField
private ArrayPool`1<byte> <ArrayPool>k__BackingField
private List`1<BufferPartition> <BufferSet>k__BackingField
private long <Position>k__BackingField
public int MaxArraySize
public ArrayPool`1<byte> ArrayPool
private List`1<BufferPartition> BufferSet
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public int get_MaxArraySize()
public ArrayPool`1<byte> get_ArrayPool()
private List`1<BufferPartition> get_BufferSet()
public void .ctor(ArrayPool`1<byte> arrayPool, int maxArraySize)
internal Task`1<PooledMemoryStream> BufferStreamPartitionInternal(Stream stream, long minCount, long maxCount, ArrayPool`1<byte> arrayPool, Nullable`1<int> maxArrayPoolRentalSize, bool async, CancellationToken cancellationToken)
private Task`1<int> ReadLoopInternal(Stream stream, Byte[] buffer, int offset, int minCount, int maxCount, bool async, CancellationToken cancellationToken)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
private ValueTuple`3<Byte[], int, long> GetBufferFromPosition()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
protected void Dispose(bool disposing)
public void Clear()
private void AssertPositionInBounds()
private BufferPartition GetLatestBufferWithAvailableSpaceOrDefault()
private long Min(long val1, long val2, long val3)
}
internal Azure.Storage.Shared.StorageClientConfiguration : object {
private HttpPipeline <Pipeline>k__BackingField
private StorageSharedKeyCredential <SharedKeyCredential>k__BackingField
private TokenCredential <TokenCredential>k__BackingField
private AzureSasCredential <SasCredential>k__BackingField
private ClientDiagnostics <ClientDiagnostics>k__BackingField
public HttpPipeline Pipeline
public StorageSharedKeyCredential SharedKeyCredential
public TokenCredential TokenCredential
public AzureSasCredential SasCredential
public ClientDiagnostics ClientDiagnostics
public HttpPipeline get_Pipeline()
private void set_Pipeline(HttpPipeline value)
public StorageSharedKeyCredential get_SharedKeyCredential()
private void set_SharedKeyCredential(StorageSharedKeyCredential value)
public TokenCredential get_TokenCredential()
private void set_TokenCredential(TokenCredential value)
public AzureSasCredential get_SasCredential()
private void set_SasCredential(AzureSasCredential value)
public ClientDiagnostics get_ClientDiagnostics()
private void set_ClientDiagnostics(ClientDiagnostics value)
public void .ctor(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, ClientDiagnostics clientDiagnostics)
public void .ctor(HttpPipeline pipeline, AzureSasCredential sasCredential, ClientDiagnostics clientDiagnostics)
public void .ctor(HttpPipeline pipeline, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics)
internal void .ctor(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential, ClientDiagnostics clientDiagnostics)
internal void .ctor(HttpPipeline pipeline, ClientDiagnostics clientDiagnostics)
}
internal Azure.Storage.Shared.StorageExtensions : object {
public string EscapePath(string path, bool trimOuterSlashes)
public string UnescapePath(string path, bool trimOuterSlashes)
public string GenerateBlockId(long offset)
public Task`1<HttpAuthorization> GetCopyAuthorizationHeaderAsync(TokenCredential tokenCredential, CancellationToken cancellationToken)
public IDisposable CreateClientSideEncryptionScope(ClientSideEncryptionVersion version)
}
internal Azure.Storage.Shared.StorageWriteStream : Stream {
protected long _position
protected long _bufferSize
protected IProgress`1<long> _progressHandler
protected PooledMemoryStream _buffer
private ArrayPool`1<byte> _bufferPool
private StorageChecksumAlgorithm _checksumAlgorithm
private StorageCrc64HashAlgorithm _masterCrcChecksummer
private Memory`1<byte> _composedCrc
private Memory`1<byte> _userProvidedChecksum
private IHasher _bufferChecksumer
private bool _disposed
private DisposableBucket _accumulatedDisposables
private bool UseMasterCrc
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
private bool get_UseMasterCrc()
protected void .ctor(long position, long bufferSize, IProgress`1<long> progressHandler, UploadTransferValidationOptions transferValidation, PooledMemoryStream buffer, ArrayPool`1<byte> bufferPool)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public int Read(Byte[] buffer, int offset, int count)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task WriteInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
public void Flush()
public Task FlushAsync(CancellationToken cancellationToken)
private Task FlushInternal(bool async, CancellationToken cancellationToken)
protected Task CommitInternal(bool async, CancellationToken cancellationToken)
private Task AppendAndClearBufferInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
protected Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
protected void ValidateBufferSize(long bufferSize)
protected Task WriteToBufferInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
protected void ValidateWriteParameters(Byte[] buffer, int offset, int count)
protected void Dispose(bool disposing)
private void ValidateCallerCrcIfAny()
protected IDisposable FinalizeAndReplaceBufferChecksum(UploadTransferValidationOptions& validationOptions)
}
internal Azure.Storage.Shared.StreamExtensions : object {
public Nullable`1<long> GetPositionOrDefault(Stream content)
}
internal Azure.Storage.Shared.WindowStream : Stream {
private Stream <InnerStream>k__BackingField
private Stream InnerStream
public bool CanRead
public bool CanWrite
private Stream get_InnerStream()
public bool get_CanRead()
public bool get_CanWrite()
private void .ctor(Stream stream)
public Stream GetWindow(Stream stream, long maxWindowLength)
public void Flush()
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
public int ReadByte()
public int Read(Byte[] buffer, int offset, int count)
public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken)
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
protected int AdjustCount(int count)
protected void ReportInnerStreamRead(int resultRead)
}
internal Azure.Storage.SharedAccessSignatureCredentials : object {
private string <SasToken>k__BackingField
public string SasToken
public string get_SasToken()
public void .ctor(string sasToken)
}
internal Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy : BearerTokenAuthenticationPolicy {
private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _scopes
private String modreq(System.Runtime.CompilerServices.IsVolatile) tenantId
private bool _enableTenantDiscovery
public void .ctor(TokenCredential credential, string scope, bool enableTenantDiscovery)
public void .ctor(TokenCredential credential, IEnumerable`1<string> scopes, bool enableTenantDiscovery)
protected void AuthorizeRequest(HttpMessage message)
protected ValueTask AuthorizeRequestAsync(HttpMessage message)
private ValueTask AuthorizeRequestInternal(HttpMessage message, bool async)
protected bool AuthorizeRequestOnChallenge(HttpMessage message)
protected ValueTask`1<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message)
private ValueTask`1<bool> AuthorizeRequestOnChallengeInternalAsync(HttpMessage message, bool async)
}
internal Azure.Storage.StorageClientOptions : object {
private string StorageScope
public void Initialize(ClientOptions options)
public HttpPipelinePolicy AsPolicy(StorageSharedKeyCredential credential)
public HttpPipelinePolicy AsPolicy(AzureSasCredential credential, Uri resourceUri)
public HttpPipelinePolicy AsPolicy(TokenCredential credential, string scope, ClientOptions options)
public HttpPipelinePolicy GetAuthenticationPolicy(object credentials, string scope, ClientOptions options)
public HttpPipeline Build(ClientOptions options, HttpPipelinePolicy authentication, Uri geoRedundantSecondaryStorageUri)
public HttpPipeline Build(ClientOptions options, object credentials, Uri geoRedundantSecondaryStorageUri)
}
internal Azure.Storage.StorageCollectionEnumerator`1 : object {
public ValueTask`1<Page`1<T>> GetNextPageAsync(string continuationToken, Nullable`1<int> pageSizeHint, bool async, CancellationToken cancellationToken)
public Pageable`1<T> ToSyncCollection(CancellationToken cancellationToken)
public AsyncPageable`1<T> ToAsyncCollection(CancellationToken cancellationToken)
}
internal Azure.Storage.StorageConnectionString : object {
private KeyValuePair`2<string, Func`2<string, bool>> s_useDevelopmentStorageSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_developmentStorageProxyUriSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_defaultEndpointsProtocolSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_accountNameSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_accountKeyNameSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_accountKeySetting
private KeyValuePair`2<string, Func`2<string, bool>> s_blobEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_queueEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_fileEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_tableEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_blobSecondaryEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_queueSecondaryEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_fileSecondaryEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_tableSecondaryEndpointSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_endpointSuffixSetting
private KeyValuePair`2<string, Func`2<string, bool>> s_sharedAccessSignatureSetting
private StorageConnectionString s_devStoreAccount
private bool <IsDevStoreAccount>k__BackingField
private string <EndpointSuffix>k__BackingField
private IDictionary`2<string, string> <Settings>k__BackingField
private bool <DefaultEndpoints>k__BackingField
private ValueTuple`2<Uri, Uri> <BlobStorageUri>k__BackingField
private ValueTuple`2<Uri, Uri> <QueueStorageUri>k__BackingField
private ValueTuple`2<Uri, Uri> <TableStorageUri>k__BackingField
private ValueTuple`2<Uri, Uri> <FileStorageUri>k__BackingField
private object <Credentials>k__BackingField
internal string _accountName
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> s_validCredentials
internal bool UseV1MD5
public StorageConnectionString DevelopmentStorageAccount
internal bool IsDevStoreAccount
internal string EndpointSuffix
internal IDictionary`2<string, string> Settings
internal bool DefaultEndpoints
public Uri BlobEndpoint
public Uri QueueEndpoint
public Uri TableEndpoint
public Uri FileEndpoint
public ValueTuple`2<Uri, Uri> BlobStorageUri
public ValueTuple`2<Uri, Uri> QueueStorageUri
public ValueTuple`2<Uri, Uri> TableStorageUri
public ValueTuple`2<Uri, Uri> FileStorageUri
public object Credentials
internal bool get_UseV1MD5()
public void .ctor(object storageCredentials, ValueTuple`2<Uri, Uri> blobStorageUri, ValueTuple`2<Uri, Uri> queueStorageUri, ValueTuple`2<Uri, Uri> tableStorageUri, ValueTuple`2<Uri, Uri> fileStorageUri)
public StorageConnectionString get_DevelopmentStorageAccount()
internal bool get_IsDevStoreAccount()
internal void set_IsDevStoreAccount(bool value)
internal string get_EndpointSuffix()
internal void set_EndpointSuffix(string value)
internal IDictionary`2<string, string> get_Settings()
internal void set_Settings(IDictionary`2<string, string> value)
internal bool get_DefaultEndpoints()
internal void set_DefaultEndpoints(bool value)
public Uri get_BlobEndpoint()
public Uri get_QueueEndpoint()
public Uri get_TableEndpoint()
public Uri get_FileEndpoint()
public ValueTuple`2<Uri, Uri> get_BlobStorageUri()
public void set_BlobStorageUri(ValueTuple`2<Uri, Uri> value)
public ValueTuple`2<Uri, Uri> get_QueueStorageUri()
public void set_QueueStorageUri(ValueTuple`2<Uri, Uri> value)
public ValueTuple`2<Uri, Uri> get_TableStorageUri()
public void set_TableStorageUri(ValueTuple`2<Uri, Uri> value)
public ValueTuple`2<Uri, Uri> get_FileStorageUri()
public void set_FileStorageUri(ValueTuple`2<Uri, Uri> value)
public object get_Credentials()
public void set_Credentials(object value)
public StorageConnectionString Parse(string connectionString)
public bool TryParse(string connectionString, StorageConnectionString& account)
private StorageConnectionString GetDevelopmentStorageAccount(Uri proxyUri)
internal bool ParseCore(string connectionString, StorageConnectionString& accountInformation, Action`1<string> error)
private IDictionary`2<string, string> ParseStringIntoSettings(string connectionString, Action`1<string> error)
private KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, String[] validValues)
private KeyValuePair`2<string, Func`2<string, bool>> Setting(string name, Func`2<string, bool> isValid)
private bool IsValidBase64String(string settingValue)
private bool IsValidUri(string settingValue)
private bool IsValidDomain(string settingValue)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AllRequired(KeyValuePair`2[] requiredSettings)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> Optional(KeyValuePair`2[] optionalSettings)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> AtLeastOne(KeyValuePair`2[] atLeastOneSettings)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> None(KeyValuePair`2[] atLeastOneSettings)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesAll(Func`2[] filters)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesOne(Func`2[] filters)
private Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> MatchesExactly(Func`2<IDictionary`2<string, string>, IDictionary`2<string, string>> filter)
private bool MatchesSpecification(IDictionary`2<string, string> settings, Func`2[] constraints)
private object GetCredentials(IDictionary`2<string, string> settings)
private ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(IDictionary`2<string, string> settings)
internal ValueTuple`2<Uri, Uri> ConstructBlobEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
private ValueTuple`2<Uri, Uri> ConstructFileEndpoint(IDictionary`2<string, string> settings)
internal ValueTuple`2<Uri, Uri> ConstructFileEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
private ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(IDictionary`2<string, string> settings)
internal ValueTuple`2<Uri, Uri> ConstructQueueEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
private ValueTuple`2<Uri, Uri> ConstructTableEndpoint(IDictionary`2<string, string> settings)
internal ValueTuple`2<Uri, Uri> ConstructTableEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
private ValueTuple`2<Uri, Uri> ConstructUris(string scheme, string accountName, string hostNamePrefix, string endpointSuffix, string sasToken)
internal string <ParseCore>g__settingOrDefault|70_0(string key, <>c__DisplayClass70_0& )
internal bool <ParseCore>g__s_isValidEndpointPair|70_1(string primary, string secondary)
internal ValueTuple`2<Uri, Uri> <ParseCore>g__createStorageUri|70_2(string primary, string secondary, string sasToken, Func`2<IDictionary`2<string, string>, ValueTuple`2<Uri, Uri>> factory, <>c__DisplayClass70_0& )
internal Uri <ParseCore>g__CreateUri|70_3(string endpoint, string sasToken)
}
internal Azure.Storage.StorageCrc64Calculator : object {
private ulong poly
private UInt64[] m_u1
private UInt64[] m_u32
private UInt64[] m_uX2N
private ulong m_uComplement
private int m_uBitWidth
public ulong ComputeSlicedSafe(ReadOnlySpan`1<byte> src, ulong uCrc)
internal ulong Concatenate(ulong uInitialCrcAB, ulong uInitialCrcA, ulong uFinalCrcA, ulong uSizeA, ulong uInitialCrcB, ulong uFinalCrcB, ulong uSizeB)
private ulong MulX_N(ulong a, ulong uSize)
private ulong MulPoly(ulong a, ulong b)
private ulong MulPolyUnrolled(ulong a, ulong b)
}
internal Azure.Storage.StorageCrc64Composer : object {
public Memory`1<byte> Compose(ValueTuple`2[] partitions)
public Memory`1<byte> Compose(IEnumerable`1<ValueTuple`2<Byte[], long>> partitions)
public ulong Compose(IEnumerable`1<ValueTuple`2<ulong, long>> partitions)
}
internal Azure.Storage.StorageExceptionExtensions : object {
public string GetErrorCode(Response response, string errorCode)
public bool IsUnavailable(Response`1<T> response)
public Response`1<T> AsNoBodyResponse(Response rawResponse)
}
internal Azure.Storage.StorageProgressExtensions : object {
public Stream WithProgress(Stream stream, IProgress`1<long> progressHandler)
}
internal Azure.Storage.StorageRequestValidationPipelinePolicy : HttpPipelineSynchronousPolicy {
public void OnReceivedResponse(HttpMessage message)
}
internal Azure.Storage.StorageResponseClassifier : ResponseClassifier {
private Uri <SecondaryStorageUri>k__BackingField
public Uri SecondaryStorageUri
public Uri get_SecondaryStorageUri()
public void set_SecondaryStorageUri(Uri value)
public bool IsRetriableResponse(HttpMessage message)
public bool IsErrorResponse(HttpMessage message)
}
internal Azure.Storage.StorageServerTimeoutPolicy : HttpPipelineSynchronousPolicy {
private string QueryParameterKeyWithEqualSign
private StorageServerTimeoutPolicy <Shared>k__BackingField
public StorageServerTimeoutPolicy Shared
public StorageServerTimeoutPolicy get_Shared()
public void OnSendingRequest(HttpMessage message)
}
internal Azure.Storage.StorageSharedKeyCredentialInternals : StorageSharedKeyCredential {
private void .ctor(string accountName, string accountKey)
internal string ComputeSasSignature(StorageSharedKeyCredential credential, string message)
}
internal Azure.Storage.StorageSharedKeyPipelinePolicy : HttpPipelineSynchronousPolicy {
private bool IncludeXMsDate
private StorageSharedKeyCredential _credentials
public void .ctor(StorageSharedKeyCredential credentials)
public void OnSendingRequest(HttpMessage message)
private string BuildStringToSign(HttpMessage message)
private void BuildCanonicalizedHeaders(StringBuilder stringBuilder, HttpMessage message)
private void BuildCanonicalizedResource(StringBuilder stringBuilder, Uri resource)
}
internal Azure.Storage.StorageTelemetryPolicy : HttpPipelineSynchronousPolicy {
private string CseIdentifierV2
private string CseIdentifierV1
private StorageTelemetryPolicy <Shared>k__BackingField
public StorageTelemetryPolicy Shared
public StorageTelemetryPolicy get_Shared()
public void OnSendingRequest(HttpMessage message)
private void ApplyAzFeatures(HttpMessage message, AzFeatures azFeatures)
private string Serialize(AzFeatures azFeatures)
private string TransformUserAgent(string userAgent, string injection)
}
internal Azure.Storage.StorageVersionExtensions : object {
public ServiceVersion LatestVersion
internal ServiceVersion MaxVersion
public string ToVersionString(ServiceVersion version)
}
internal Azure.Storage.StreamExtensions : object {
public Stream WithNoDispose(Stream stream)
public Nullable`1<long> GetLengthOrDefault(Stream content)
public Task`1<int> ReadInternal(Stream stream, Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
public Task WriteInternal(Stream stream, Byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
public Task CopyToInternal(Stream src, Stream dest, bool async, CancellationToken cancellationToken)
public Task CopyToInternal(Stream src, Stream dest, int bufferSize, bool async, CancellationToken cancellationToken)
}
internal Azure.Storage.TransferValidationOptionsExtensions : object {
public StorageChecksumAlgorithm ResolveAuto(StorageChecksumAlgorithm checksumAlgorithm)
public UploadTransferValidationOptions ToValidationOptions(Byte[] md5)
public DownloadTransferValidationOptions ToValidationOptions(bool requestTransactionalMD5)
public void CopyTo(TransferValidationOptions source, TransferValidationOptions dest)
public void CopyTo(UploadTransferValidationOptions source, UploadTransferValidationOptions dest)
public void CopyTo(DownloadTransferValidationOptions source, DownloadTransferValidationOptions dest)
}
internal Azure.Storage.UriExtensions : object {
public Uri AppendToPath(Uri uri, string segment)
public IDictionary`2<string, string> GetQueryParameters(Uri uri)
public string GetAccountNameFromDomain(Uri uri, string serviceSubDomain)
public string GetAccountNameFromDomain(string host, string serviceSubDomain)
public string GetPath(Uri uri)
public bool IsHostIPEndPointStyle(Uri uri)
internal void AppendQueryParameter(StringBuilder sb, string key, string value)
}
internal Azure.Storage.UriQueryParamsCollection : Dictionary`2<string, string> {
public void .ctor(string encodedQueryParamString)
public string ToString()
}
public Microsoft.Extensions.Azure.BlobClientBuilderExtensions : object {
public IAzureClientBuilder`2<BlobServiceClient, BlobClientOptions> AddBlobServiceClient(TBuilder builder, string connectionString)
public IAzureClientBuilder`2<BlobServiceClient, BlobClientOptions> AddBlobServiceClient(TBuilder builder, Uri serviceUri)
public IAzureClientBuilder`2<BlobServiceClient, BlobClientOptions> AddBlobServiceClient(TBuilder builder, Uri serviceUri, StorageSharedKeyCredential sharedKeyCredential)
public IAzureClientBuilder`2<BlobServiceClient, BlobClientOptions> AddBlobServiceClient(TBuilder builder, TConfiguration configuration)
}
internal System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
public DynamicallyAccessedMemberTypes MemberTypes
public void .ctor(DynamicallyAccessedMemberTypes memberTypes)
public DynamicallyAccessedMemberTypes get_MemberTypes()
}
internal System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
public int value__
public DynamicallyAccessedMemberTypes None
public DynamicallyAccessedMemberTypes PublicParameterlessConstructor
public DynamicallyAccessedMemberTypes PublicConstructors
public DynamicallyAccessedMemberTypes NonPublicConstructors
public DynamicallyAccessedMemberTypes PublicMethods
public DynamicallyAccessedMemberTypes NonPublicMethods
public DynamicallyAccessedMemberTypes PublicFields
public DynamicallyAccessedMemberTypes NonPublicFields
public DynamicallyAccessedMemberTypes PublicNestedTypes
public DynamicallyAccessedMemberTypes NonPublicNestedTypes
public DynamicallyAccessedMemberTypes PublicProperties
public DynamicallyAccessedMemberTypes NonPublicProperties
public DynamicallyAccessedMemberTypes PublicEvents
public DynamicallyAccessedMemberTypes NonPublicEvents
public DynamicallyAccessedMemberTypes Interfaces
public DynamicallyAccessedMemberTypes All
}
internal System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
private string <MemberSignature>k__BackingField
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
private Type <Type>k__BackingField
private string <TypeName>k__BackingField
private string <AssemblyName>k__BackingField
private string <Condition>k__BackingField
public string MemberSignature
public DynamicallyAccessedMemberTypes MemberTypes
public Type Type
public string TypeName
public string AssemblyName
public string Condition
public void .ctor(string memberSignature)
public void .ctor(string memberSignature, Type type)
public void .ctor(string memberSignature, string typeName, string assemblyName)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, Type type)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName)
public string get_MemberSignature()
public DynamicallyAccessedMemberTypes get_MemberTypes()
public Type get_Type()
public string get_TypeName()
public string get_AssemblyName()
public string get_Condition()
public void set_Condition(string value)
}
internal System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
internal System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
internal System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
private string <Category>k__BackingField
private string <CheckId>k__BackingField
private string <Scope>k__BackingField
private string <Target>k__BackingField
private string <MessageId>k__BackingField
private string <Justification>k__BackingField
public string Category
public string CheckId
public string Scope
public string Target
public string MessageId
public string Justification
public void .ctor(string category, string checkId)
public string get_Category()
public string get_CheckId()
public string get_Scope()
public void set_Scope(string value)
public string get_Target()
public void set_Target(string value)
public string get_MessageId()
public void set_MessageId(string value)
public string get_Justification()
public void set_Justification(string value)
}
internal System.Runtime.CompilerServices.NullableAttribute : Attribute {
public Byte[] NullableFlags
public void .ctor(byte )
public void .ctor(Byte[] )
}
internal System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
public byte Flag
public void .ctor(byte )
}
internal System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
public int Version
public void .ctor(int )
}
