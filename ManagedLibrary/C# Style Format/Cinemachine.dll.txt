public class Cinemachine.AxisBase : ValueType {
    [NoSaveDuringPlayAttribute]
[TooltipAttribute("The current value of the axis.")]

public float m_Value;
    [TooltipAttribute("The minimum value for the axis")]

public float m_MinValue;
    [TooltipAttribute("The maximum value for the axis")]

public float m_MaxValue;
    [TooltipAttribute("If checked, then the axis will wrap around at the min/max values, forming a loop")]

public bool m_Wrap;
    public void Validate();
}
[DocumentationSortingAttribute("2")]
public class Cinemachine.AxisState : ValueType {
    [NoSaveDuringPlayAttribute]
[TooltipAttribute("The current value of the axis.")]

public float Value;
    [TooltipAttribute("How to interpret the Max Speed setting: in units/second, or as a direct input value multiplier")]

public SpeedMode m_SpeedMode;
    [TooltipAttribute("The maximum speed of this axis in units/second, or the input value multiplier, depending on the Speed Mode")]

public float m_MaxSpeed;
    [TooltipAttribute("The amount of time in seconds it takes to accelerate to MaxSpeed with the supplied Axis at its maximum value")]

public float m_AccelTime;
    [TooltipAttribute("The amount of time in seconds it takes to decelerate the axis to zero if the supplied axis is in a neutral position")]

public float m_DecelTime;
    [FormerlySerializedAsAttribute("m_AxisName")]
[TooltipAttribute("The name of this axis as specified in Unity Input manager. Setting to an empty string will disable the automatic updating of this axis")]

public string m_InputAxisName;
    [NoSaveDuringPlayAttribute]
[TooltipAttribute("The value of the input axis.  A value of 0 means no input.  You can drive this directly from a custom input system, or you can set the Axis Name and have the value driven by the internal Input Manager")]

public float m_InputAxisValue;
    [FormerlySerializedAsAttribute("m_InvertAxis")]
[TooltipAttribute("If checked, then the raw value of the input axis will be inverted before it is used")]

public bool m_InvertInput;
    [TooltipAttribute("The minimum value for the axis")]

public float m_MinValue;
    [TooltipAttribute("The maximum value for the axis")]

public float m_MaxValue;
    [TooltipAttribute("If checked, then the axis will wrap around at the min/max values, forming a loop")]

public bool m_Wrap;
    [TooltipAttribute("Automatic recentering to at-rest position")]

public Recentering m_Recentering;
    
private float m_CurrentSpeed;
    
private float m_LastUpdateTime;
    
private int m_LastUpdateFrame;
    
private static float Epsilon;
    
private IInputAxisProvider m_InputAxisProvider;
    
private int m_InputAxisIndex;
    [CompilerGeneratedAttribute]

private bool <ValueRangeLocked>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <HasRecentering>k__BackingField;
    
public bool HasInputProvider { get; }
    
public bool ValueRangeLocked { get; public set; }
    
public bool HasRecentering { get; public set; }
    public AxisState(float minValue, float maxValue, bool wrap, bool rangeLocked, float maxSpeed, float accelTime, float decelTime, string name, bool invert);
    public void Validate();
    public void Reset();
    public void SetInputAxisProvider(int axis, IInputAxisProvider provider);
    public bool get_HasInputProvider();
    public bool Update(float deltaTime);
    private float ClampValue(float v);
    private bool MaxSpeedUpdate(float input, float deltaTime);
    private float GetMaxSpeed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ValueRangeLocked();
    [CompilerGeneratedAttribute]
public void set_ValueRangeLocked(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasRecentering();
    [CompilerGeneratedAttribute]
public void set_HasRecentering(bool value);
}
public class Cinemachine.AxisStatePropertyAttribute : PropertyAttribute {
}
internal class Cinemachine.BlendSourceVirtualCamera : object {
    [CompilerGeneratedAttribute]

private CinemachineBlend <Blend>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]

private Transform <LookAt>k__BackingField;
    [CompilerGeneratedAttribute]

private Transform <Follow>k__BackingField;
    [CompilerGeneratedAttribute]

private CameraState <State>k__BackingField;
    
public CinemachineBlend Blend { get; public set; }
    
public string Name { get; }
    
public string Description { get; }
    
public int Priority { get; public set; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    
public CameraState State { get; private set; }
    
public GameObject VirtualCameraGameObject { get; }
    
public bool IsValid { get; }
    
public ICinemachineCamera ParentCamera { get; }
    public BlendSourceVirtualCamera(CinemachineBlend blend);
    [CompilerGeneratedAttribute]
public CinemachineBlend get_Blend();
    [CompilerGeneratedAttribute]
public void set_Blend(CinemachineBlend value);
    public sealed virtual string get_Name();
    public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Transform get_LookAt();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LookAt(Transform value);
    [CompilerGeneratedAttribute]
public sealed virtual Transform get_Follow();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Follow(Transform value);
    [CompilerGeneratedAttribute]
public sealed virtual CameraState get_State();
    [CompilerGeneratedAttribute]
private void set_State(CameraState value);
    public sealed virtual GameObject get_VirtualCameraGameObject();
    public sealed virtual bool get_IsValid();
    public sealed virtual ICinemachineCamera get_ParentCamera();
    public sealed virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly);
    public CameraState CalculateNewState(float deltaTime);
    public sealed virtual void UpdateCameraState(Vector3 worldUp, float deltaTime);
    public sealed virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
    public sealed virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    public sealed virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
}
public class Cinemachine.CameraState : ValueType {
    
public LensSettings Lens;
    
public Vector3 ReferenceUp;
    
public Vector3 ReferenceLookAt;
    
public static Vector3 kNoPoint;
    
public Vector3 RawPosition;
    
public Quaternion RawOrientation;
    
public Vector3 PositionDampingBypass;
    
public float ShotQuality;
    
public Vector3 PositionCorrection;
    
public Quaternion OrientationCorrection;
    
public BlendHintValue BlendHint;
    
private CustomBlendable mCustom0;
    
private CustomBlendable mCustom1;
    
private CustomBlendable mCustom2;
    
private CustomBlendable mCustom3;
    
private List`1<CustomBlendable> m_CustomOverflow;
    [CompilerGeneratedAttribute]

private int <NumCustomBlendables>k__BackingField;
    
public bool HasLookAt { get; }
    
public Vector3 CorrectedPosition { get; }
    
public Quaternion CorrectedOrientation { get; }
    
public Vector3 FinalPosition { get; }
    
public Quaternion FinalOrientation { get; }
    
public static CameraState Default { get; }
    
public int NumCustomBlendables { get; private set; }
    private static CameraState();
    public bool get_HasLookAt();
    public Vector3 get_CorrectedPosition();
    public Quaternion get_CorrectedOrientation();
    public Vector3 get_FinalPosition();
    public Quaternion get_FinalOrientation();
    public static CameraState get_Default();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumCustomBlendables();
    [CompilerGeneratedAttribute]
private void set_NumCustomBlendables(int value);
    public CustomBlendable GetCustomBlendable(int index);
    private int FindCustomBlendable(Object custom);
    public void AddCustomBlendable(CustomBlendable b);
    public static CameraState Lerp(CameraState stateA, CameraState stateB, float t);
    private static float InterpolateFOV(float fovA, float fovB, float dA, float dB, float t);
    private static Vector3 ApplyPosBlendHint(Vector3 posA, BlendHintValue hintA, Vector3 posB, BlendHintValue hintB, Vector3 original, Vector3 blended);
    private static Quaternion ApplyRotBlendHint(Quaternion rotA, BlendHintValue hintA, Quaternion rotB, BlendHintValue hintB, Quaternion original, Quaternion blended);
    private Vector3 InterpolatePosition(Vector3 posA, Vector3 pivotA, Vector3 posB, Vector3 pivotB, float t);
}
[AddComponentMenu("")]
[ExecuteAlways]
[SaveDuringPlayAttribute]
[DisallowMultipleComponent]
public class Cinemachine.Cinemachine3rdPersonAim : CinemachineExtension {
    [HeaderAttribute("Aim Target Detection")]
[TooltipAttribute("Objects on these layers will be detected")]

public LayerMask AimCollisionFilter;
    [TagFieldAttribute]
[TooltipAttribute("Objects with this tag will be ignored.  It is a good idea to set this field to the target's tag")]

public string IgnoreTag;
    [TooltipAttribute("How far to project the object detection ray")]

public float AimDistance;
    [TooltipAttribute("This 2D object will be positioned in the game view over the raycast hit point, if any, or will remain in the center of the screen if no hit point is detected.  May be null, in which case no on-screen indicator will appear")]

public RectTransform AimTargetReticle;
    [CompilerGeneratedAttribute]

private Vector3 <AimTarget>k__BackingField;
    
public Vector3 AimTarget { get; private set; }
    [CompilerGeneratedAttribute]
public Vector3 get_AimTarget();
    [CompilerGeneratedAttribute]
private void set_AimTarget(Vector3 value);
    private void OnValidate();
    private void Reset();
    public virtual bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    private void DrawReticle(CinemachineBrain brain);
    private Vector3 ComputeLookAtPoint(Vector3 camPos, Transform player);
    private Vector3 ComputeAimTarget(Vector3 cameraLookAt, Transform player);
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
}
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.Cinemachine3rdPersonFollow : CinemachineComponentBase {
    [TooltipAttribute("How responsively the camera tracks the target.  Each axis (camera-local) can have its own setting.  Value is the approximate time it takes the camera to catch up to the target's new position.  Smaller values give a more rigid effect, larger values give a squishier one")]

public Vector3 Damping;
    [HeaderAttribute("Rig")]
[TooltipAttribute("Position of the shoulder pivot relative to the Follow target origin.  This offset is in target-local space")]

public Vector3 ShoulderOffset;
    [TooltipAttribute("Vertical offset of the hand in relation to the shoulder.  Arm length will affect the follow target's screen position when the camera rotates vertically")]

public float VerticalArmLength;
    [TooltipAttribute("Specifies which shoulder (left, right, or in-between) the camera is on")]
[RangeAttribute("0", "1")]

public float CameraSide;
    [TooltipAttribute("How far behind the hand the camera will be placed")]

public float CameraDistance;
    [HeaderAttribute("Obstacles")]
[TooltipAttribute("Camera will avoid obstacles on these layers")]

public LayerMask CameraCollisionFilter;
    [TagFieldAttribute]
[TooltipAttribute("Obstacles with this tag will be ignored.  It is a good idea to set this field to the target's tag")]

public string IgnoreTag;
    [TooltipAttribute("Specifies how close the camera can get to obstacles")]
[RangeAttribute("0", "1")]

public float CameraRadius;
    [RangeAttribute("0", "10")]
[TooltipAttribute("How gradually the camera moves to correct for occlusions.  Higher numbers will move the camera more gradually.")]

public float DampingIntoCollision;
    [RangeAttribute("0", "10")]
[TooltipAttribute("How gradually the camera returns to its normal position after having been corrected by the built-in collision resolution system.  Higher numbers will move the camera more gradually back to normal.")]

public float DampingFromCollision;
    
private Vector3 m_PreviousFollowTargetPosition;
    
private Vector3 m_DampingCorrection;
    
private float m_CamPosCollisionCorrection;
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    private void OnValidate();
    private void Reset();
    private void OnDestroy();
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    public virtual float GetMaxDampTime();
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    private void PositionCamera(CameraState& curState, float deltaTime);
    public void GetRigPositions(Vector3& root, Vector3& shoulder, Vector3& hand);
    internal static Quaternion GetHeading(Quaternion targetRot, Vector3 up);
    private void GetRawRigPositions(Vector3 root, Quaternion targetRot, Quaternion heading, Vector3& shoulder, Vector3& hand);
    private Vector3 ResolveCollisions(Vector3 root, Vector3 tip, float deltaTime, float cameraRadius, Single& collisionCorrection);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineBasicMultiChannelPerlin : CinemachineComponentBase {
    [TooltipAttribute("The asset containing the Noise Profile.  Define the frequencies and amplitudes there to make a characteristic noise profile.  Make your own or just use one of the many presets.")]
[FormerlySerializedAsAttribute("m_Definition")]
[NoiseSettingsPropertyAttribute]

public NoiseSettings m_NoiseProfile;
    [TooltipAttribute("When rotating the camera, offset the camera's pivot position by this much (camera space)")]

public Vector3 m_PivotOffset;
    [TooltipAttribute("Gain to apply to the amplitudes defined in the NoiseSettings asset.  1 is normal.  Setting this to 0 completely mutes the noise.")]

public float m_AmplitudeGain;
    [TooltipAttribute("Scale factor to apply to the frequencies defined in the NoiseSettings asset.  1 is normal.  Larger magnitudes will make the noise shake more rapidly.")]

public float m_FrequencyGain;
    
private bool mInitialized;
    
private float mNoiseTime;
    [SerializeField]
[HideInInspector]

private Vector3 mNoiseOffsets;
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
    public void ReSeed();
    private void Initialize();
}
public class Cinemachine.CinemachineBlend : object {
    
public ICinemachineCamera CamA;
    
public ICinemachineCamera CamB;
    
public AnimationCurve BlendCurve;
    
public float TimeInBlend;
    
public float Duration;
    
public float BlendWeight { get; }
    
public bool IsValid { get; }
    
public bool IsComplete { get; }
    
public string Description { get; }
    
public CameraState State { get; }
    public CinemachineBlend(ICinemachineCamera a, ICinemachineCamera b, AnimationCurve curve, float duration, float t);
    public float get_BlendWeight();
    public bool get_IsValid();
    public bool get_IsComplete();
    public string get_Description();
    public bool Uses(ICinemachineCamera cam);
    public void UpdateCameraState(Vector3 worldUp, float deltaTime);
    public CameraState get_State();
}
[DocumentationSortingAttribute("2")]
public class Cinemachine.CinemachineBlendDefinition : ValueType {
    [TooltipAttribute("Shape of the blend curve")]

public Style m_Style;
    [TooltipAttribute("Duration of the blend, in seconds")]

public float m_Time;
    
public AnimationCurve m_CustomCurve;
    
private static AnimationCurve[] sStandardCurves;
    
public float BlendTime { get; }
    
public AnimationCurve BlendCurve { get; }
    public CinemachineBlendDefinition(Style style, float time);
    public float get_BlendTime();
    private void CreateStandardCurves();
    public AnimationCurve get_BlendCurve();
}
public class Cinemachine.CinemachineBlendDefinitionPropertyAttribute : PropertyAttribute {
}
[DocumentationSortingAttribute("2")]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineBlending.html")]
public class Cinemachine.CinemachineBlenderSettings : ScriptableObject {
    [TooltipAttribute("The array containing explicitly defined blends between two Virtual Cameras")]

public CustomBlend[] m_CustomBlends;
    
public static string kBlendFromAnyCameraLabel;
    public CinemachineBlendDefinition GetBlendForVirtualCameras(string fromCameraName, string toCameraName, CinemachineBlendDefinition defaultBlend);
}
[DocumentationSortingAttribute("2")]
[DisallowMultipleComponent]
[ExecuteAlways]
[ExcludeFromPresetAttribute]
[AddComponentMenu("Cinemachine/CinemachineBlendListCamera")]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineBlendListCamera.html")]
public class Cinemachine.CinemachineBlendListCamera : CinemachineVirtualCameraBase {
    [TooltipAttribute("Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty if all of the children define targets of their own.")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_LookAt;
    [TooltipAttribute("Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty if all of the children define targets of their own.")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_Follow;
    [TooltipAttribute("When enabled, the current child camera and blend will be indicated in the game window, for debugging")]

public bool m_ShowDebugText;
    [TooltipAttribute("When enabled, the child vcams will cycle indefinitely instead of just stopping at the last one")]

public bool m_Loop;
    [SerializeField]
[HideInInspector]
[NoSaveDuringPlayAttribute]

internal CinemachineVirtualCameraBase[] m_ChildCameras;
    [TooltipAttribute("The set of instructions for enabling child cameras.")]

public Instruction[] m_Instructions;
    [CompilerGeneratedAttribute]

private ICinemachineCamera <LiveChild>k__BackingField;
    
private ICinemachineCamera m_TransitioningFrom;
    
private CameraState m_State;
    
private float mActivationTime;
    
private int mCurrentInstruction;
    
private CinemachineBlend mActiveBlend;
    
public string Description { get; }
    
public ICinemachineCamera LiveChild { get; public set; }
    
public CameraState State { get; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    
public CinemachineVirtualCameraBase[] ChildCameras { get; }
    
public bool IsBlending { get; }
    public virtual string get_Description();
    private void Reset();
    [CompilerGeneratedAttribute]
public ICinemachineCamera get_LiveChild();
    [CompilerGeneratedAttribute]
public void set_LiveChild(ICinemachineCamera value);
    public virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly);
    public virtual CameraState get_State();
    public virtual Transform get_LookAt();
    public virtual void set_LookAt(Transform value);
    public virtual Transform get_Follow();
    public virtual void set_Follow(Transform value);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    public virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
    protected virtual void OnEnable();
    protected virtual void OnDisable();
    private void OnTransformChildrenChanged();
    private void OnGuiHandler();
    public CinemachineVirtualCameraBase[] get_ChildCameras();
    public bool get_IsBlending();
    private void InvalidateListOfChildren();
    private void UpdateListOfChildren();
    internal void ValidateInstructions();
    private void AdvanceCurrentInstruction(float deltaTime);
}
[DocumentationSortingAttribute("2")]
[DisallowMultipleComponent]
[ExecuteAlways]
[AddComponentMenu("Cinemachine/CinemachineBrain")]
[SaveDuringPlayAttribute]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineBrainProperties.html")]
public class Cinemachine.CinemachineBrain : MonoBehaviour {
    [TooltipAttribute("When enabled, the current camera and blend will be indicated in the game window, for debugging")]

public bool m_ShowDebugText;
    [TooltipAttribute("When enabled, the camera's frustum will be shown at all times in the scene view")]

public bool m_ShowCameraFrustum;
    [TooltipAttribute("When enabled, the cameras will always respond in real-time to user input and damping, even if the game is running in slow motion")]

public bool m_IgnoreTimeScale;
    [TooltipAttribute("If set, this object's Y axis will define the worldspace Up vector for all the virtual cameras.  This is useful for instance in top-down game environments.  If not set, Up is worldspace Y.  Setting this appropriately is important, because Virtual Cameras don't like looking straight up or straight down.")]

public Transform m_WorldUpOverride;
    [TooltipAttribute("The update time for the vcams.  Use FixedUpdate if all your targets are animated during FixedUpdate (e.g. RigidBodies), LateUpdate if all your targets are animated during the normal Update loop, and SmartUpdate if you want Cinemachine to do the appropriate thing on a per-target basis.  SmartUpdate is the recommended setting")]

public UpdateMethod m_UpdateMethod;
    [TooltipAttribute("The update time for the Brain, i.e. when the blends are evaluated and the brain's transform is updated")]

public BrainUpdateMethod m_BlendUpdateMethod;
    [CinemachineBlendDefinitionPropertyAttribute]
[TooltipAttribute("The blend that is used in cases where you haven't explicitly defined a blend between two Virtual Cameras")]

public CinemachineBlendDefinition m_DefaultBlend;
    [TooltipAttribute("This is the asset that contains custom settings for blends between specific virtual cameras in your scene")]

public CinemachineBlenderSettings m_CustomBlends;
    
private Camera m_OutputCamera;
    
private GameObject m_TargetOverride;
    [TooltipAttribute("This event will fire whenever a virtual camera goes live and there is no blend")]

public BrainEvent m_CameraCutEvent;
    [TooltipAttribute("This event will fire whenever a virtual camera goes live.  If a blend is involved, then the event will fire on the first frame of the blend.")]

public VcamActivatedEvent m_CameraActivatedEvent;
    
private static ICinemachineCamera mSoloCamera;
    
private Coroutine mPhysicsCoroutine;
    
private int m_LastFrameUpdated;
    
private WaitForFixedUpdate mWaitForFixedUpdate;
    
private List`1<BrainFrame> mFrameStack;
    
private int mNextFrameId;
    
private CinemachineBlend mCurrentLiveCameras;
    
private static AnimationCurve mDefaultLinearAnimationCurve;
    
private ICinemachineCamera mActiveCameraPreviousFrame;
    
private GameObject mActiveCameraPreviousFrameGameObject;
    [CompilerGeneratedAttribute]

private CameraState <CurrentCameraState>k__BackingField;
    
public Camera OutputCamera { get; }
    
public GameObject ControlledObject { get; public set; }
    
public static ICinemachineCamera SoloCamera { get; public set; }
    
public Vector3 DefaultWorldUp { get; }
    
public ICinemachineCamera ActiveVirtualCamera { get; }
    
public bool IsBlending { get; }
    
public CinemachineBlend ActiveBlend { get; public set; }
    
public CameraState CurrentCameraState { get; private set; }
    private static CinemachineBrain();
    public Camera get_OutputCamera();
    public GameObject get_ControlledObject();
    public void set_ControlledObject(GameObject value);
    public static ICinemachineCamera get_SoloCamera();
    public static void set_SoloCamera(ICinemachineCamera value);
    public static Color GetSoloGUIColor();
    public sealed virtual Vector3 get_DefaultWorldUp();
    private void OnEnable();
    private void OnDisable();
    private void OnSceneLoaded(Scene scene, LoadSceneMode mode);
    private void OnSceneUnloaded(Scene scene);
    private void Awake();
    private void Start();
    private void OnGuiHandler();
    [IteratorStateMachineAttribute("Cinemachine.CinemachineBrain/<AfterPhysics>d__38")]
private IEnumerator AfterPhysics();
    private void LateUpdate();
    public void ManualUpdate();
    private float GetEffectiveDeltaTime(bool fixedDelta);
    private void UpdateVirtualCameras(UpdateFilter updateFilter, float deltaTime);
    public ICinemachineCamera get_ActiveVirtualCamera();
    private static ICinemachineCamera DeepCamBFromBlend(CinemachineBlend blend);
    public bool IsLiveInBlend(ICinemachineCamera vcam);
    public bool get_IsBlending();
    public CinemachineBlend get_ActiveBlend();
    public void set_ActiveBlend(CinemachineBlend value);
    private int GetBrainFrame(int withId);
    public sealed virtual int SetCameraOverride(int overrideId, ICinemachineCamera camA, ICinemachineCamera camB, float weightB, float deltaTime);
    public sealed virtual void ReleaseCameraOverride(int overrideId);
    private void ProcessActiveCamera(float deltaTime);
    private void UpdateFrame0(float deltaTime);
    public void ComputeCurrentBlend(CinemachineBlend& outputBlend, int numTopLayersToExclude);
    public bool IsLive(ICinemachineCamera vcam, bool dominantChildOnly);
    [CompilerGeneratedAttribute]
public CameraState get_CurrentCameraState();
    [CompilerGeneratedAttribute]
private void set_CurrentCameraState(CameraState value);
    protected virtual ICinemachineCamera TopCameraFromPriorityQueue();
    private CinemachineBlendDefinition LookupBlend(ICinemachineCamera fromKey, ICinemachineCamera toKey);
    private void PushStateToUnityCamera(CameraState& state);
}
[DocumentationSortingAttribute("2")]
[DisallowMultipleComponent]
[ExecuteAlways]
[ExcludeFromPresetAttribute]
[AddComponentMenu("Cinemachine/CinemachineClearShot")]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineClearShot.html")]
public class Cinemachine.CinemachineClearShot : CinemachineVirtualCameraBase {
    [TooltipAttribute("Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty if all children specify targets of their own.")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_LookAt;
    [TooltipAttribute("Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty if all children specify targets of their own.")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_Follow;
    [TooltipAttribute("When enabled, the current child camera and blend will be indicated in the game window, for debugging")]
[NoSaveDuringPlayAttribute]

public bool m_ShowDebugText;
    [SerializeField]
[HideInInspector]
[NoSaveDuringPlayAttribute]

internal CinemachineVirtualCameraBase[] m_ChildCameras;
    [TooltipAttribute("Wait this many seconds before activating a new child camera")]

public float m_ActivateAfter;
    [TooltipAttribute("An active camera must be active for at least this many seconds")]

public float m_MinDuration;
    [TooltipAttribute("If checked, camera choice will be randomized if multiple cameras are equally desirable.  Otherwise, child list order and child camera priority will be used.")]

public bool m_RandomizeChoice;
    [CinemachineBlendDefinitionPropertyAttribute]
[TooltipAttribute("The blend which is used if you don't explicitly define a blend between two Virtual Cameras")]

public CinemachineBlendDefinition m_DefaultBlend;
    [HideInInspector]

public CinemachineBlenderSettings m_CustomBlends;
    [CompilerGeneratedAttribute]

private ICinemachineCamera <LiveChild>k__BackingField;
    
private CameraState m_State;
    
private float mActivationTime;
    
private float mPendingActivationTime;
    
private ICinemachineCamera mPendingCamera;
    
private CinemachineBlend mActiveBlend;
    
private bool mRandomizeNow;
    
private CinemachineVirtualCameraBase[] m_RandomizedChilden;
    
private ICinemachineCamera m_TransitioningFrom;
    
public string Description { get; }
    
public ICinemachineCamera LiveChild { get; public set; }
    
public CameraState State { get; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    
public bool IsBlending { get; }
    
public CinemachineBlend ActiveBlend { get; }
    
public CinemachineVirtualCameraBase[] ChildCameras { get; }
    public virtual string get_Description();
    [CompilerGeneratedAttribute]
public ICinemachineCamera get_LiveChild();
    [CompilerGeneratedAttribute]
public void set_LiveChild(ICinemachineCamera value);
    public virtual CameraState get_State();
    public virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly);
    public virtual Transform get_LookAt();
    public virtual void set_LookAt(Transform value);
    public virtual Transform get_Follow();
    public virtual void set_Follow(Transform value);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
    protected virtual void OnEnable();
    protected virtual void OnDisable();
    public void OnTransformChildrenChanged();
    private void OnGuiHandler();
    public bool get_IsBlending();
    public CinemachineBlend get_ActiveBlend();
    public CinemachineVirtualCameraBase[] get_ChildCameras();
    private void InvalidateListOfChildren();
    public void ResetRandomization();
    private void UpdateListOfChildren();
    private ICinemachineCamera ChooseCurrentCamera(Vector3 worldUp);
    private CinemachineVirtualCameraBase[] Randomize(CinemachineVirtualCameraBase[] src);
    private CinemachineBlendDefinition LookupBlend(ICinemachineCamera fromKey, ICinemachineCamera toKey);
    public virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
[ExecuteAlways]
[DisallowMultipleComponent]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineCollider.html")]
public class Cinemachine.CinemachineCollider : CinemachineExtension {
    [HeaderAttribute("Obstacle Detection")]
[TooltipAttribute("Objects on these layers will be detected")]

public LayerMask m_CollideAgainst;
    [TagFieldAttribute]
[TooltipAttribute("Obstacles with this tag will be ignored.  It is a good idea to set this field to the target's tag")]

public string m_IgnoreTag;
    [TooltipAttribute("Objects on these layers will never obstruct view of the target")]

public LayerMask m_TransparentLayers;
    [TooltipAttribute("Obstacles closer to the target than this will be ignored")]

public float m_MinimumDistanceFromTarget;
    [SpaceAttribute]
[TooltipAttribute("When enabled, will attempt to resolve situations where the line of sight to the target is blocked by an obstacle")]
[FormerlySerializedAsAttribute("m_PreserveLineOfSight")]

public bool m_AvoidObstacles;
    [TooltipAttribute("The maximum raycast distance when checking if the line of sight to this camera's target is clear.  If the setting is 0 or less, the current actual distance to target will be used.")]
[FormerlySerializedAsAttribute("m_LineOfSightFeelerDistance")]

public float m_DistanceLimit;
    [TooltipAttribute("Don't take action unless occlusion has lasted at least this long.")]

public float m_MinimumOcclusionTime;
    [TooltipAttribute("Camera will try to maintain this distance from any obstacle.  Try to keep this value small.  Increase it if you are seeing inside obstacles due to a large FOV on the camera.")]

public float m_CameraRadius;
    [TooltipAttribute("The way in which the Collider will attempt to preserve sight of the target.")]

public ResolutionStrategy m_Strategy;
    [RangeAttribute("1", "10")]
[TooltipAttribute("Upper limit on how many obstacle hits to process.  Higher numbers may impact performance.  In most environments, 4 is enough.")]

public int m_MaximumEffort;
    [RangeAttribute("0", "2")]
[TooltipAttribute("Smoothing to apply to obstruction resolution.  Nearest camera point is held for at least this long")]

public float m_SmoothingTime;
    [RangeAttribute("0", "10")]
[TooltipAttribute("How gradually the camera returns to its normal position after having been corrected.  Higher numbers will move the camera more gradually back to normal.")]
[FormerlySerializedAsAttribute("m_Smoothing")]

public float m_Damping;
    [RangeAttribute("0", "10")]
[TooltipAttribute("How gradually the camera moves to resolve an occlusion.  Higher numbers will move the camera more gradually.")]

public float m_DampingWhenOccluded;
    [HeaderAttribute("Shot Evaluation")]
[TooltipAttribute("If greater than zero, a higher score will be given to shots when the target is closer to this distance.  Set this to zero to disable this feature.")]

public float m_OptimalTargetDistance;
    
private static float k_PrecisionSlush;
    
private RaycastHit[] m_CornerBuffer;
    
private static float k_AngleThreshold;
    
private static Collider[] s_ColliderBuffer;
    
public List`1<List`1<Vector3>> DebugPaths { get; }
    private static CinemachineCollider();
    public bool IsTargetObscured(ICinemachineCamera vcam);
    public bool CameraWasDisplaced(ICinemachineCamera vcam);
    public float GetCameraDisplacementDistance(ICinemachineCamera vcam);
    private void OnValidate();
    protected virtual void OnDestroy();
    public List`1<List`1<Vector3>> get_DebugPaths();
    public virtual float GetMaxDampTime();
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
    private Vector3 PreserveLineOfSight(CameraState& state, VcamExtraState& extra);
    private Vector3 PullCameraInFrontOfNearestObstacle(Vector3 cameraPos, Vector3 lookAtPos, int layerMask, RaycastHit& hitInfo);
    private Vector3 PushCameraBack(Vector3 currentPos, Vector3 pushDir, RaycastHit obstacle, Vector3 lookAtPos, Plane startPlane, float targetDistance, int iterations, VcamExtraState& extra);
    private bool GetWalkingDirection(Vector3 pos, Vector3 pushDir, RaycastHit obstacle, Vector3& outDir);
    private float GetPushBackDistance(Ray ray, Plane startPlane, float targetDistance, Vector3 lookAtPos);
    private static float ClampRayToBounds(Ray ray, float distance, Bounds bounds);
    private Vector3 RespectCameraRadius(Vector3 cameraPos, Vector3 lookAtPos);
    private bool CheckForTargetObstructions(CameraState state);
    private static bool IsTargetOffscreen(CameraState state);
}
[DocumentationSortingAttribute("2")]
[SaveDuringPlayAttribute]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineCollisionImpulseSource.html")]
public class Cinemachine.CinemachineCollisionImpulseSource : CinemachineImpulseSource {
    [HeaderAttribute("Trigger Object Filter")]
[TooltipAttribute("Only collisions with objects on these layers will generate Impulse events")]

public LayerMask m_LayerMask;
    [TagFieldAttribute]
[TooltipAttribute("No Impulse evemts will be generated for collisions with objects having these tags")]

public string m_IgnoreTag;
    [HeaderAttribute("How To Generate The Impulse")]
[TooltipAttribute("If checked, signal direction will be affected by the direction of impact")]

public bool m_UseImpactDirection;
    [TooltipAttribute("If checked, signal amplitude will be multiplied by the mass of the impacting object")]

public bool m_ScaleImpactWithMass;
    [TooltipAttribute("If checked, signal amplitude will be multiplied by the speed of the impacting object")]

public bool m_ScaleImpactWithSpeed;
    
private Rigidbody mRigidBody;
    
private Rigidbody2D mRigidBody2D;
    private void Start();
    private void OnEnable();
    private void OnCollisionEnter(Collision c);
    private void OnTriggerEnter(Collider c);
    private float GetMassAndVelocity(Collider other, Vector3& vel);
    private void GenerateImpactEvent(Collider other, Vector3 vel);
    private void OnCollisionEnter2D(Collision2D c);
    private void OnTriggerEnter2D(Collider2D c);
    private float GetMassAndVelocity2D(Collider2D other2d, Vector3& vel);
    private void GenerateImpactEvent2D(Collider2D other2d, Vector3 vel);
}
[DocumentationSortingAttribute("1")]
public abstract class Cinemachine.CinemachineComponentBase : MonoBehaviour {
    
protected static float Epsilon;
    
private CinemachineVirtualCameraBase m_vcamOwner;
    
public CinemachineVirtualCameraBase VirtualCamera { get; }
    
public Transform FollowTarget { get; }
    
public Transform LookAtTarget { get; }
    
public ICinemachineTargetGroup AbstractFollowTargetGroup { get; }
    
public CinemachineTargetGroup FollowTargetGroup { get; }
    
public Vector3 FollowTargetPosition { get; }
    
public Quaternion FollowTargetRotation { get; }
    
public ICinemachineTargetGroup AbstractLookAtTargetGroup { get; }
    
public CinemachineTargetGroup LookAtTargetGroup { get; }
    
public Vector3 LookAtTargetPosition { get; }
    
public Quaternion LookAtTargetRotation { get; }
    
public CameraState VcamState { get; }
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    
public bool BodyAppliesAfterAim { get; }
    
public bool RequiresUserInput { get; }
    public CinemachineVirtualCameraBase get_VirtualCamera();
    public Transform get_FollowTarget();
    public Transform get_LookAtTarget();
    public ICinemachineTargetGroup get_AbstractFollowTargetGroup();
    public CinemachineTargetGroup get_FollowTargetGroup();
    public Vector3 get_FollowTargetPosition();
    public Quaternion get_FollowTargetRotation();
    public ICinemachineTargetGroup get_AbstractLookAtTargetGroup();
    public CinemachineTargetGroup get_LookAtTargetGroup();
    public Vector3 get_LookAtTargetPosition();
    public Quaternion get_LookAtTargetRotation();
    public CameraState get_VcamState();
    public abstract virtual bool get_IsValid();
    public virtual void PrePipelineMutateCameraState(CameraState& curState, float deltaTime);
    public abstract virtual Stage get_Stage();
    public virtual bool get_BodyAppliesAfterAim();
    public abstract virtual void MutateCameraState(CameraState& curState, float deltaTime);
    public virtual bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, TransitionParams& transitionParams);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual float GetMaxDampTime();
    public virtual bool get_RequiresUserInput();
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineComposer : CinemachineComponentBase {
    [TooltipAttribute("Target offset from the target object's center in target-local space. Use this to fine-tune the tracking target position when the desired area is not the tracked object's center.")]

public Vector3 m_TrackedObjectOffset;
    [SpaceAttribute]
[TooltipAttribute("This setting will instruct the composer to adjust its target offset based on the motion of the target.  The composer will look at a point where it estimates the target will be this many seconds into the future.  Note that this setting is sensitive to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.  If the camera jitters unacceptably when the target is in motion, turn down this setting, or animate the target more smoothly.")]
[RangeAttribute("0", "1")]

public float m_LookaheadTime;
    [TooltipAttribute("Controls the smoothness of the lookahead algorithm.  Larger values smooth out jittery predictions and also increase prediction lag")]
[RangeAttribute("0", "30")]

public float m_LookaheadSmoothing;
    [TooltipAttribute("If checked, movement along the Y axis will be ignored for lookahead calculations")]

public bool m_LookaheadIgnoreY;
    [SpaceAttribute]
[RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to follow the target in the screen-horizontal direction. Small numbers are more responsive, rapidly orienting the camera to keep the target in the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical and horizontal settings can yield a wide range of camera behaviors.")]

public float m_HorizontalDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to follow the target in the screen-vertical direction. Small numbers are more responsive, rapidly orienting the camera to keep the target in the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical and horizontal settings can yield a wide range of camera behaviors.")]

public float m_VerticalDamping;
    [SpaceAttribute]
[RangeAttribute("-0,5", "1,5")]
[TooltipAttribute("Horizontal screen position for target. The camera will rotate to position the tracked object here.")]

public float m_ScreenX;
    [RangeAttribute("-0,5", "1,5")]
[TooltipAttribute("Vertical screen position for target, The camera will rotate to position the tracked object here.")]

public float m_ScreenY;
    [RangeAttribute("0", "2")]
[TooltipAttribute("Camera will not rotate horizontally if the target is within this range of the position.")]

public float m_DeadZoneWidth;
    [RangeAttribute("0", "2")]
[TooltipAttribute("Camera will not rotate vertically if the target is within this range of the position.")]

public float m_DeadZoneHeight;
    [RangeAttribute("0", "2")]
[TooltipAttribute("When target is within this region, camera will gradually rotate horizontally to re-align towards the desired position, depending on the damping speed.")]

public float m_SoftZoneWidth;
    [RangeAttribute("0", "2")]
[TooltipAttribute("When target is within this region, camera will gradually rotate vertically to re-align towards the desired position, depending on the damping speed.")]

public float m_SoftZoneHeight;
    [RangeAttribute("-0,5", "0,5")]
[TooltipAttribute("A non-zero bias will move the target position horizontally away from the center of the soft zone.")]

public float m_BiasX;
    [RangeAttribute("-0,5", "0,5")]
[TooltipAttribute("A non-zero bias will move the target position vertically away from the center of the soft zone.")]

public float m_BiasY;
    [TooltipAttribute("Force target to center of screen when this camera activates.  If false, will clamp target to the edges of the dead zone")]

public bool m_CenterOnActivate;
    [CompilerGeneratedAttribute]

private Vector3 <TrackedPoint>k__BackingField;
    
private Vector3 m_CameraPosPrevFrame;
    
private Vector3 m_LookAtPrevFrame;
    
private Vector2 m_ScreenOffsetPrevFrame;
    
private Quaternion m_CameraOrientationPrevFrame;
    
internal PositionPredictor m_Predictor;
    
private FovCache mCache;
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    
public Vector3 TrackedPoint { get; private set; }
    
internal Rect SoftGuideRect { get; internal set; }
    
internal Rect HardGuideRect { get; internal set; }
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    [CompilerGeneratedAttribute]
public Vector3 get_TrackedPoint();
    [CompilerGeneratedAttribute]
private void set_TrackedPoint(Vector3 value);
    protected virtual Vector3 GetLookAtPointAndSetTrackedPoint(Vector3 lookAt, Vector3 up, float deltaTime);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual float GetMaxDampTime();
    public virtual void PrePipelineMutateCameraState(CameraState& curState, float deltaTime);
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
    internal Rect get_SoftGuideRect();
    internal void set_SoftGuideRect(Rect value);
    internal Rect get_HardGuideRect();
    internal void set_HardGuideRect(Rect value);
    private void RotateToScreenBounds(CameraState& state, Rect screenRect, Vector3 trackedPoint, Quaternion& rigOrientation, float fov, float fovH, float deltaTime);
    private bool ClampVerticalBounds(Rect& r, Vector3 dir, Vector3 up, float fov);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
[ExecuteAlways]
[DisallowMultipleComponent]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineConfiner.html")]
public class Cinemachine.CinemachineConfiner : CinemachineExtension {
    [TooltipAttribute("The confiner can operate using a 2D bounding shape or a 3D bounding volume")]

public Mode m_ConfineMode;
    [TooltipAttribute("The volume within which the camera is to be contained")]

public Collider m_BoundingVolume;
    [TooltipAttribute("The 2D shape within which the camera is to be contained")]

public Collider2D m_BoundingShape2D;
    
private Collider2D m_BoundingShape2DCache;
    [TooltipAttribute("If camera is orthographic, screen edges will be confined to the volume.  If not checked, then only the camera center will be confined")]

public bool m_ConfineScreenEdges;
    [TooltipAttribute("How gradually to return the camera to the bounding volume if it goes beyond the borders.  Higher numbers are more gradual.")]
[RangeAttribute("0", "10")]

public float m_Damping;
    
private List`1<List`1<Vector2>> m_pathCache;
    
private int m_pathTotalPointCount;
    
public bool IsValid { get; }
    public bool CameraWasDisplaced(CinemachineVirtualCameraBase vcam);
    public float GetCameraDisplacementDistance(CinemachineVirtualCameraBase vcam);
    private void OnValidate();
    protected virtual void ConnectToVcam(bool connect);
    public bool get_IsValid();
    public virtual float GetMaxDampTime();
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
    public void InvalidatePathCache();
    private bool ValidatePathCache();
    private Vector3 ConfinePoint(Vector3 camPos);
    private Vector3 ConfineScreenEdges(CameraState& state);
}
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
[ExecuteAlways]
[DisallowMultipleComponent]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineConfiner2D.html")]
public class Cinemachine.CinemachineConfiner2D : CinemachineExtension {
    [TooltipAttribute("The 2D shape within which the camera is to be contained.  Can be a 2D polygon or 2D composite collider.")]

public Collider2D m_BoundingShape2D;
    [TooltipAttribute("Damping applied around corners to avoid jumps.  Higher numbers are more gradual.")]
[RangeAttribute("0", "5")]

public float m_Damping;
    [TooltipAttribute("To optimize computation and memory costs, set this to the largest view size that the camera is expected to have.  The confiner will not compute a polygon cache for frustum sizes larger than this.  This refers to the size in world units of the frustum at the confiner plane (for orthographic cameras, this is just the orthographic size).  If set to 0, then this parameter is ignored and a polygon cache will be calculated for all potential window sizes.")]

public float m_MaxWindowSize;
    
private float m_MaxComputationTimePerFrameInSeconds;
    
private static float k_cornerAngleTreshold;
    
private ShapeCache m_shapeCache;
    public void InvalidateCache();
    public bool ValidateCache(float cameraAspectRatio);
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
    private float CalculateHalfFrustumHeight(CameraState& state, Single& cameraPosLocalZ);
    private void OnValidate();
    private void Reset();
}
public class Cinemachine.CinemachineCore : object {
    
public static int kStreamingVersion;
    
private static CinemachineCore sInstance;
    
public static bool sShowHiddenObjects;
    
public static AxisInputDelegate GetInputAxis;
    
public static float UniformDeltaTimeOverride;
    
public static float CurrentTimeOverride;
    
public static GetBlendOverrideDelegate GetBlendOverride;
    
public static BrainEvent CameraUpdatedEvent;
    
public static BrainEvent CameraCutEvent;
    
private List`1<CinemachineBrain> mActiveBrains;
    
internal static bool FrameDeltaCompensationEnabled;
    
private List`1<CinemachineVirtualCameraBase> mActiveCameras;
    
private bool m_ActiveCamerasAreSorted;
    
private int m_ActivationSequence;
    
private List`1<List`1<CinemachineVirtualCameraBase>> mAllCameras;
    
private CinemachineVirtualCameraBase mRoundRobinVcamLastFrame;
    
private static float s_LastUpdateTime;
    
private static int s_FixedFrameCount;
    
private Dictionary`2<CinemachineVirtualCameraBase, UpdateStatus> mUpdateStatus;
    
internal UpdateFilter m_CurrentUpdateFilter;
    
public static CinemachineCore Instance { get; }
    
public static float DeltaTime { get; }
    
public static float CurrentTime { get; }
    
public int BrainCount { get; }
    
public int VirtualCameraCount { get; }
    private static CinemachineCore();
    public static CinemachineCore get_Instance();
    public static float get_DeltaTime();
    public static float get_CurrentTime();
    public int get_BrainCount();
    public CinemachineBrain GetActiveBrain(int index);
    internal void AddActiveBrain(CinemachineBrain brain);
    internal void RemoveActiveBrain(CinemachineBrain brain);
    public int get_VirtualCameraCount();
    public CinemachineVirtualCameraBase GetVirtualCamera(int index);
    internal void AddActiveCamera(CinemachineVirtualCameraBase vcam);
    internal void RemoveActiveCamera(CinemachineVirtualCameraBase vcam);
    internal void CameraDestroyed(CinemachineVirtualCameraBase vcam);
    internal void CameraEnabled(CinemachineVirtualCameraBase vcam);
    internal void CameraDisabled(CinemachineVirtualCameraBase vcam);
    internal void UpdateAllActiveVirtualCameras(int layerMask, Vector3 worldUp, float deltaTime);
    internal void UpdateVirtualCamera(CinemachineVirtualCameraBase vcam, Vector3 worldUp, float deltaTime);
    [RuntimeInitializeOnLoadMethodAttribute]
private static void InitializeModule();
    private static Transform GetUpdateTarget(CinemachineVirtualCameraBase vcam);
    internal UpdateClock GetVcamUpdateStatus(CinemachineVirtualCameraBase vcam);
    public bool IsLive(ICinemachineCamera vcam);
    public bool IsLiveInBlend(ICinemachineCamera vcam);
    public void GenerateCameraActivationEvent(ICinemachineCamera vcam, ICinemachineCamera vcamFrom);
    public void GenerateCameraCutEvent(ICinemachineCamera vcam);
    public CinemachineBrain FindPotentialTargetBrain(CinemachineVirtualCameraBase vcam);
    public void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
}
[DocumentationSortingAttribute("2")]
[ExecuteAlways]
[DisallowMultipleComponent]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineDollyCart.html")]
public class Cinemachine.CinemachineDollyCart : MonoBehaviour {
    [TooltipAttribute("The path to follow")]

public CinemachinePathBase m_Path;
    [TooltipAttribute("When to move the cart, if Velocity is non-zero")]

public UpdateMethod m_UpdateMethod;
    [TooltipAttribute("How to interpret the Path Position.  If set to Path Units, values are as follows: 0 represents the first waypoint on the path, 1 is the second, and so on.  Values in-between are points on the path in between the waypoints.  If set to Distance, then Path Position represents distance along the path.")]

public PositionUnits m_PositionUnits;
    [TooltipAttribute("Move the cart with this speed along the path.  The value is interpreted according to the Position Units setting.")]
[FormerlySerializedAsAttribute("m_Velocity")]

public float m_Speed;
    [TooltipAttribute("The position along the path at which the cart will be placed.  This can be animated directly or, if the velocity is non-zero, will be updated automatically.  The value is interpreted according to the Position Units setting.")]
[FormerlySerializedAsAttribute("m_CurrentDistance")]

public float m_Position;
    private void FixedUpdate();
    private void Update();
    private void LateUpdate();
    private void SetCartPosition(float distanceAlongPath);
}
public class Cinemachine.CinemachineEmbeddedAssetPropertyAttribute : PropertyAttribute {
    
public bool WarnIfNull;
    public CinemachineEmbeddedAssetPropertyAttribute(bool warnIfNull);
}
[DocumentationSortingAttribute("1")]
public abstract class Cinemachine.CinemachineExtension : MonoBehaviour {
    
protected static float Epsilon;
    
private CinemachineVirtualCameraBase m_vcamOwner;
    
private Dictionary`2<ICinemachineCamera, object> mExtraState;
    
public CinemachineVirtualCameraBase VirtualCamera { get; }
    
public bool RequiresUserInput { get; }
    public CinemachineVirtualCameraBase get_VirtualCamera();
    protected virtual void Awake();
    protected virtual void OnEnable();
    protected virtual void OnDestroy();
    internal void EnsureStarted();
    protected virtual void ConnectToVcam(bool connect);
    public virtual void PrePipelineMutateCameraStateCallback(CinemachineVirtualCameraBase vcam, CameraState& curState, float deltaTime);
    public void InvokePostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
    protected abstract virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    public virtual float GetMaxDampTime();
    public virtual bool get_RequiresUserInput();
    protected T GetExtraState(ICinemachineCamera vcam);
    protected List`1<T> GetAllExtraStates();
}
[DocumentationSortingAttribute("2")]
[RequireComponent("UnityEngine.Camera")]
[DisallowMultipleComponent]
[AddComponentMenu("Cinemachine/CinemachineExternalCamera")]
[ExecuteAlways]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineExternalCamera.html")]
public class Cinemachine.CinemachineExternalCamera : CinemachineVirtualCameraBase {
    [TooltipAttribute("The object that the camera is looking at.  Setting this will improve the quality of the blends to and from this camera")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_LookAt;
    
private Camera m_Camera;
    
private CameraState m_State;
    [CompilerGeneratedAttribute]

private Transform <Follow>k__BackingField;
    [TooltipAttribute("Hint for blending positions to and from this virtual camera")]
[FormerlySerializedAsAttribute("m_PositionBlending")]

public BlendHint m_BlendHint;
    
public CameraState State { get; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    public virtual CameraState get_State();
    public virtual Transform get_LookAt();
    public virtual void set_LookAt(Transform value);
    [CompilerGeneratedAttribute]
public virtual Transform get_Follow();
    [CompilerGeneratedAttribute]
public virtual void set_Follow(Transform value);
    public virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
}
[DocumentationSortingAttribute("2")]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineImpulseFixedSignals.html")]
public class Cinemachine.CinemachineFixedSignal : SignalSourceAsset {
    [TooltipAttribute("The raw signal shape along the X axis")]

public AnimationCurve m_XCurve;
    [TooltipAttribute("The raw signal shape along the Y axis")]

public AnimationCurve m_YCurve;
    [TooltipAttribute("The raw signal shape along the Z axis")]

public AnimationCurve m_ZCurve;
    
public float SignalDuration { get; }
    public virtual float get_SignalDuration();
    private float AxisDuration(AnimationCurve axis);
    public virtual void GetSignal(float timeSinceSignalStart, Vector3& pos, Quaternion& rot);
    private float AxisValue(AnimationCurve axis, float time);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
[ExecuteAlways]
[DisallowMultipleComponent]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineFollowZoom.html")]
public class Cinemachine.CinemachineFollowZoom : CinemachineExtension {
    [TooltipAttribute("The shot width to maintain, in world units, at target distance.")]

public float m_Width;
    [RangeAttribute("0", "20")]
[TooltipAttribute("Increase this value to soften the aggressiveness of the follow-zoom.  Small numbers are more responsive, larger numbers give a more heavy slowly responding camera.")]

public float m_Damping;
    [RangeAttribute("1", "179")]
[TooltipAttribute("Lower limit for the FOV that this behaviour will generate.")]

public float m_MinFOV;
    [RangeAttribute("1", "179")]
[TooltipAttribute("Upper limit for the FOV that this behaviour will generate.")]

public float m_MaxFOV;
    private void OnValidate();
    public virtual float GetMaxDampTime();
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineFramingTransposer : CinemachineComponentBase {
    [TooltipAttribute("Offset from the Follow Target object (in target-local co-ordinates).  The camera will attempt to frame the point which is the target's position plus this offset.  Use it to correct for cases when the target's origin is not the point of interest for the camera.")]

public Vector3 m_TrackedObjectOffset;
    [TooltipAttribute("This setting will instruct the composer to adjust its target offset based on the motion of the target.  The composer will look at a point where it estimates the target will be this many seconds into the future.  Note that this setting is sensitive to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.  If the camera jitters unacceptably when the target is in motion, turn down this setting, or animate the target more smoothly.")]
[RangeAttribute("0", "1")]
[SpaceAttribute]

public float m_LookaheadTime;
    [TooltipAttribute("Controls the smoothness of the lookahead algorithm.  Larger values smooth out jittery predictions and also increase prediction lag")]
[RangeAttribute("0", "30")]

public float m_LookaheadSmoothing;
    [TooltipAttribute("If checked, movement along the Y axis will be ignored for lookahead calculations")]

public bool m_LookaheadIgnoreY;
    [SpaceAttribute]
[RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to maintain the offset in the X-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's x-axis offset.  Larger numbers give a more heavy slowly responding camera.  Using different settings per axis can yield a wide range of camera behaviors.")]

public float m_XDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to maintain the offset in the Y-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's y-axis offset.  Larger numbers give a more heavy slowly responding camera.  Using different settings per axis can yield a wide range of camera behaviors.")]

public float m_YDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to maintain the offset in the Z-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.  Using different settings per axis can yield a wide range of camera behaviors.")]

public float m_ZDamping;
    [TooltipAttribute("If set, damping will apply  only to target motion, but not to camera rotation changes.  Turn this on to get an instant response when the rotation changes.  ")]

public bool m_TargetMovementOnly;
    [SpaceAttribute]
[RangeAttribute("-0,5", "1,5")]
[TooltipAttribute("Horizontal screen position for target. The camera will move to position the tracked object here.")]

public float m_ScreenX;
    [RangeAttribute("-0,5", "1,5")]
[TooltipAttribute("Vertical screen position for target, The camera will move to position the tracked object here.")]

public float m_ScreenY;
    [TooltipAttribute("The distance along the camera axis that will be maintained from the Follow target")]

public float m_CameraDistance;
    [SpaceAttribute]
[RangeAttribute("0", "2")]
[TooltipAttribute("Camera will not move horizontally if the target is within this range of the position.")]

public float m_DeadZoneWidth;
    [RangeAttribute("0", "2")]
[TooltipAttribute("Camera will not move vertically if the target is within this range of the position.")]

public float m_DeadZoneHeight;
    [TooltipAttribute("The camera will not move along its z-axis if the Follow target is within this distance of the specified camera distance")]
[FormerlySerializedAsAttribute("m_DistanceDeadZoneSize")]

public float m_DeadZoneDepth;
    [SpaceAttribute]
[TooltipAttribute("If checked, then then soft zone will be unlimited in size.")]

public bool m_UnlimitedSoftZone;
    [RangeAttribute("0", "2")]
[TooltipAttribute("When target is within this region, camera will gradually move horizontally to re-align towards the desired position, depending on the damping speed.")]

public float m_SoftZoneWidth;
    [RangeAttribute("0", "2")]
[TooltipAttribute("When target is within this region, camera will gradually move vertically to re-align towards the desired position, depending on the damping speed.")]

public float m_SoftZoneHeight;
    [RangeAttribute("-0,5", "0,5")]
[TooltipAttribute("A non-zero bias will move the target position horizontally away from the center of the soft zone.")]

public float m_BiasX;
    [RangeAttribute("-0,5", "0,5")]
[TooltipAttribute("A non-zero bias will move the target position vertically away from the center of the soft zone.")]

public float m_BiasY;
    [TooltipAttribute("Force target to center of screen when this camera activates.  If false, will clamp target to the edges of the dead zone")]

public bool m_CenterOnActivate;
    [SpaceAttribute]
[TooltipAttribute("What screen dimensions to consider when framing.  Can be Horizontal, Vertical, or both")]
[FormerlySerializedAsAttribute("m_FramingMode")]

public FramingMode m_GroupFramingMode;
    [TooltipAttribute("How to adjust the camera to get the desired framing.  You can zoom, dolly in/out, or do both.")]

public AdjustmentMode m_AdjustmentMode;
    [TooltipAttribute("The bounding box of the targets should occupy this amount of the screen space.  1 means fill the whole screen.  0.5 means fill half the screen, etc.")]

public float m_GroupFramingSize;
    [TooltipAttribute("The maximum distance toward the target that this behaviour is allowed to move the camera.")]

public float m_MaxDollyIn;
    [TooltipAttribute("The maximum distance away the target that this behaviour is allowed to move the camera.")]

public float m_MaxDollyOut;
    [TooltipAttribute("Set this to limit how close to the target the camera can get.")]

public float m_MinimumDistance;
    [TooltipAttribute("Set this to limit how far from the target the camera can get.")]

public float m_MaximumDistance;
    [RangeAttribute("1", "179")]
[TooltipAttribute("If adjusting FOV, will not set the FOV lower than this.")]

public float m_MinimumFOV;
    [RangeAttribute("1", "179")]
[TooltipAttribute("If adjusting FOV, will not set the FOV higher than this.")]

public float m_MaximumFOV;
    [TooltipAttribute("If adjusting Orthographic Size, will not set it lower than this.")]

public float m_MinimumOrthoSize;
    [TooltipAttribute("If adjusting Orthographic Size, will not set it higher than this.")]

public float m_MaximumOrthoSize;
    
private static float kMinimumCameraDistance;
    
private static float kMinimumGroupSize;
    
private Vector3 m_PreviousCameraPosition;
    
internal PositionPredictor m_Predictor;
    [CompilerGeneratedAttribute]

private Vector3 <TrackedPoint>k__BackingField;
    
private bool m_InheritingPosition;
    
private float m_prevFOV;
    
private Quaternion m_prevRotation;
    [CompilerGeneratedAttribute]

private Bounds <LastBounds>k__BackingField;
    [CompilerGeneratedAttribute]

private Matrix4x4 <LastBoundsMatrix>k__BackingField;
    
internal Rect SoftGuideRect { get; internal set; }
    
internal Rect HardGuideRect { get; internal set; }
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    
public bool BodyAppliesAfterAim { get; }
    
public Vector3 TrackedPoint { get; private set; }
    
public Bounds LastBounds { get; private set; }
    
public Matrix4x4 LastBoundsMatrix { get; private set; }
    internal Rect get_SoftGuideRect();
    internal void set_SoftGuideRect(Rect value);
    internal Rect get_HardGuideRect();
    internal void set_HardGuideRect(Rect value);
    private void OnValidate();
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    public virtual bool get_BodyAppliesAfterAim();
    [CompilerGeneratedAttribute]
public Vector3 get_TrackedPoint();
    [CompilerGeneratedAttribute]
private void set_TrackedPoint(Vector3 value);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual float GetMaxDampTime();
    public virtual bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, TransitionParams& transitionParams);
    private Rect ScreenToOrtho(Rect rScreen, float orthoSize, float aspect);
    private Vector3 OrthoOffsetToScreenBounds(Vector3 targetPos2D, Rect screenRect);
    [CompilerGeneratedAttribute]
public Bounds get_LastBounds();
    [CompilerGeneratedAttribute]
private void set_LastBounds(Bounds value);
    [CompilerGeneratedAttribute]
public Matrix4x4 get_LastBoundsMatrix();
    [CompilerGeneratedAttribute]
private void set_LastBoundsMatrix(Matrix4x4 value);
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
    private float GetTargetHeight(Vector2 boundsSize);
    private Vector3 ComputeGroupBounds(ICinemachineTargetGroup group, CameraState& curState);
    private static Bounds GetScreenSpaceGroupBoundingBox(ICinemachineTargetGroup group, Vector3& pos, Quaternion orientation);
}
[DocumentationSortingAttribute("2")]
[DisallowMultipleComponent]
[ExecuteAlways]
[ExcludeFromPresetAttribute]
[AddComponentMenu("Cinemachine/CinemachineFreeLook")]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineFreeLook.html")]
public class Cinemachine.CinemachineFreeLook : CinemachineVirtualCameraBase {
    [TooltipAttribute("Object for the camera children to look at (the aim target).")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_LookAt;
    [TooltipAttribute("Object for the camera children wants to move with (the body target).")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_Follow;
    [TooltipAttribute("If enabled, this lens setting will apply to all three child rigs, otherwise the child rig lens settings will be used")]
[FormerlySerializedAsAttribute("m_UseCommonLensSetting")]

public bool m_CommonLens;
    [FormerlySerializedAsAttribute("m_LensAttributes")]
[TooltipAttribute("Specifies the lens properties of this Virtual Camera.  This generally mirrors the Unity Camera's lens settings, and will be used to drive the Unity camera when the vcam is active")]

public LensSettings m_Lens;
    
public TransitionParams m_Transitions;
    [SerializeField]
[HideInInspector]
[FormerlySerializedAsAttribute("m_BlendHint")]
[FormerlySerializedAsAttribute("m_PositionBlending")]

private BlendHint m_LegacyBlendHint;
    [HeaderAttribute("Axis Control")]
[TooltipAttribute("The Vertical axis.  Value is 0..1.  Chooses how to blend the child rigs")]
[AxisStatePropertyAttribute]

public AxisState m_YAxis;
    [TooltipAttribute("Controls how automatic recentering of the Y axis is accomplished")]

public Recentering m_YAxisRecentering;
    [TooltipAttribute("The Horizontal axis.  Value is -180...180.  This is passed on to the rigs' OrbitalTransposer component")]
[AxisStatePropertyAttribute]

public AxisState m_XAxis;
    [OrbitalTransposerHeadingPropertyAttribute]
[TooltipAttribute("The definition of Forward.  Camera will follow behind.")]

public Heading m_Heading;
    [TooltipAttribute("Controls how automatic recentering of the X axis is accomplished")]

public Recentering m_RecenterToTargetHeading;
    [HeaderAttribute("Orbits")]
[TooltipAttribute("The coordinate space to use when interpreting the offset from the target.  This is also used to set the camera's Up vector, which will be maintained when aiming the camera.")]

public BindingMode m_BindingMode;
    [TooltipAttribute("Controls how taut is the line that connects the rigs' orbits, which determines final placement on the Y axis")]
[RangeAttribute("0", "1")]
[FormerlySerializedAsAttribute("m_SplineTension")]

public float m_SplineCurvature;
    [TooltipAttribute("The radius and height of the three orbiting rigs.")]

public Orbit[] m_Orbits;
    [SerializeField]
[HideInInspector]
[FormerlySerializedAsAttribute("m_HeadingBias")]

private float m_LegacyHeadingBias;
    
private bool mUseLegacyRigDefinitions;
    
private bool mIsDestroyed;
    
private CameraState m_State;
    [SerializeField]
[HideInInspector]
[NoSaveDuringPlayAttribute]

private CinemachineVirtualCamera[] m_Rigs;
    
private CinemachineOrbitalTransposer[] mOrbitals;
    
private CinemachineBlend mBlendA;
    
private CinemachineBlend mBlendB;
    
public static CreateRigDelegate CreateRigOverride;
    
public static DestroyRigDelegate DestroyRigOverride;
    
private float m_CachedXAxisHeading;
    
private float m_LastHeadingUpdateFrame;
    
private Orbit[] m_CachedOrbits;
    
private float m_CachedTension;
    
private Vector4[] m_CachedKnots;
    
private Vector4[] m_CachedCtrl1;
    
private Vector4[] m_CachedCtrl2;
    
internal bool RigsAreCreated { get; }
    
public static String[] RigNames { get; }
    
public bool PreviousStateIsValid { get; public set; }
    
public CameraState State { get; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    protected virtual void OnValidate();
    public CinemachineVirtualCamera GetRig(int i);
    internal bool get_RigsAreCreated();
    public static String[] get_RigNames();
    protected virtual void OnEnable();
    public void UpdateInputAxisProvider();
    protected virtual void OnDestroy();
    private void OnTransformChildrenChanged();
    private void Reset();
    public virtual bool get_PreviousStateIsValid();
    public virtual void set_PreviousStateIsValid(bool value);
    public virtual CameraState get_State();
    public virtual Transform get_LookAt();
    public virtual void set_LookAt(Transform value);
    public virtual Transform get_Follow();
    public virtual void set_Follow(Transform value);
    public virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
    public virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    internal virtual bool RequiresUserInput();
    private float GetYAxisClosestValue(Vector3 cameraPos, Vector3 up);
    private float SteepestDescent(Vector3 cameraOffset);
    private void InvalidateRigCache();
    private void DestroyRigs();
    private CinemachineVirtualCamera[] CreateRigs(CinemachineVirtualCamera[] copyFrom);
    private bool UpdateRigCache();
    private List`1<CinemachineVirtualCamera> LocateExistingRigs(bool forceOrbital);
    private float UpdateXAxisHeading(CinemachineOrbitalTransposer orbital, float deltaTime, Vector3 up);
    private void PushSettingsToRigs();
    private float GetYAxisValue();
    private CameraState CalculateNewState(Vector3 worldUp, float deltaTime);
    public Vector3 GetLocalPositionForCameraFromInput(float t);
    private void UpdateCachedSpline();
    internal virtual void OnBeforeSerialize();
    [CompilerGeneratedAttribute]
private float <SteepestDescent>g__AngleFunction|47_0(float input, <>c__DisplayClass47_0& );
    [CompilerGeneratedAttribute]
private float <SteepestDescent>g__SlopeOfAngleFunction|47_1(float input, <>c__DisplayClass47_0& );
    [CompilerGeneratedAttribute]
private float <SteepestDescent>g__InitialGuess|47_2(<>c__DisplayClass47_0& );
    [CompilerGeneratedAttribute]
private void <SteepestDescent>g__ChooseBestAngle|47_3(float referenceAngle, <>c__DisplayClass47_0& , <>c__DisplayClass47_1& );
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineGroupComposer : CinemachineComposer {
    [SpaceAttribute]
[TooltipAttribute("The bounding box of the targets should occupy this amount of the screen space.  1 means fill the whole screen.  0.5 means fill half the screen, etc.")]

public float m_GroupFramingSize;
    [TooltipAttribute("What screen dimensions to consider when framing.  Can be Horizontal, Vertical, or both")]

public FramingMode m_FramingMode;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to frame the group. Small numbers are more responsive, rapidly adjusting the camera to keep the group in the frame.  Larger numbers give a more heavy slowly responding camera.")]

public float m_FrameDamping;
    [TooltipAttribute("How to adjust the camera to get the desired framing.  You can zoom, dolly in/out, or do both.")]

public AdjustmentMode m_AdjustmentMode;
    [TooltipAttribute("The maximum distance toward the target that this behaviour is allowed to move the camera.")]

public float m_MaxDollyIn;
    [TooltipAttribute("The maximum distance away the target that this behaviour is allowed to move the camera.")]

public float m_MaxDollyOut;
    [TooltipAttribute("Set this to limit how close to the target the camera can get.")]

public float m_MinimumDistance;
    [TooltipAttribute("Set this to limit how far from the target the camera can get.")]

public float m_MaximumDistance;
    [RangeAttribute("1", "179")]
[TooltipAttribute("If adjusting FOV, will not set the FOV lower than this.")]

public float m_MinimumFOV;
    [RangeAttribute("1", "179")]
[TooltipAttribute("If adjusting FOV, will not set the FOV higher than this.")]

public float m_MaximumFOV;
    [TooltipAttribute("If adjusting Orthographic Size, will not set it lower than this.")]

public float m_MinimumOrthoSize;
    [TooltipAttribute("If adjusting Orthographic Size, will not set it higher than this.")]

public float m_MaximumOrthoSize;
    
private float m_prevFramingDistance;
    
private float m_prevFOV;
    [CompilerGeneratedAttribute]

private Bounds <LastBounds>k__BackingField;
    [CompilerGeneratedAttribute]

private Matrix4x4 <LastBoundsMatrix>k__BackingField;
    
public Bounds LastBounds { get; private set; }
    
public Matrix4x4 LastBoundsMatrix { get; private set; }
    private void OnValidate();
    [CompilerGeneratedAttribute]
public Bounds get_LastBounds();
    [CompilerGeneratedAttribute]
private void set_LastBounds(Bounds value);
    [CompilerGeneratedAttribute]
public Matrix4x4 get_LastBoundsMatrix();
    [CompilerGeneratedAttribute]
private void set_LastBoundsMatrix(Matrix4x4 value);
    public virtual float GetMaxDampTime();
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
    private float GetTargetHeight(Vector2 boundsSize);
    private static Bounds GetScreenSpaceGroupBoundingBox(ICinemachineTargetGroup group, Matrix4x4 observer, Vector3& newFwd);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineHardLockToTarget : CinemachineComponentBase {
    [TooltipAttribute("How much time it takes for the position to catch up to the target's position")]

public float m_Damping;
    
private Vector3 m_PreviousTargetPosition;
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    public virtual float GetMaxDampTime();
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineHardLookAt : CinemachineComponentBase {
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
}
public class Cinemachine.CinemachineImpulseChannelPropertyAttribute : PropertyAttribute {
}
[DocumentationSortingAttribute("1")]
public class Cinemachine.CinemachineImpulseDefinition : object {
    [CinemachineImpulseChannelPropertyAttribute]
[TooltipAttribute("Impulse events generated here will appear on the channels included in the mask.")]

public int m_ImpulseChannel;
    [TooltipAttribute("Shape of the impact signal")]

public ImpulseShapes m_ImpulseShape;
    [TooltipAttribute("Defines the custom shape of the impact signal that will be generated.")]

public AnimationCurve m_CustomImpulseShape;
    [TooltipAttribute("The time during which the impact signal will occur.  The signal shape will be stretched to fill that time.")]

public float m_ImpulseDuration;
    [TooltipAttribute("How the impulse travels through space and time.")]

public ImpulseTypes m_ImpulseType;
    [TooltipAttribute("This defines how the widely signal will spread within the effect radius before dissipating with distance from the impact point")]
[RangeAttribute("0", "1")]

public float m_DissipationRate;
    [HeaderAttribute("Signal Shape")]
[TooltipAttribute("Legacy mode only: Defines the signal that will be generated.")]
[CinemachineEmbeddedAssetPropertyAttribute("True")]

public SignalSourceAsset m_RawSignal;
    [TooltipAttribute("Legacy mode only: Gain to apply to the amplitudes defined in the signal source.  1 is normal.  Setting this to 0 completely mutes the signal.")]

public float m_AmplitudeGain;
    [TooltipAttribute("Legacy mode only: Scale factor to apply to the time axis.  1 is normal.  Larger magnitudes will make the signal progress more rapidly.")]

public float m_FrequencyGain;
    [TooltipAttribute("Legacy mode only: How to fit the signal into the envelope time")]

public RepeatMode m_RepeatMode;
    [TooltipAttribute("Legacy mode only: Randomize the signal start time")]

public bool m_Randomize;
    [TooltipAttribute("Legacy mode only: This defines the time-envelope of the signal.  The raw signal will be time-scaled to fit in the envelope.")]

public EnvelopeDefinition m_TimeEnvelope;
    [HeaderAttribute("Spatial Range")]
[TooltipAttribute("Legacy mode only: The signal will have full amplitude in this radius surrounding the impact point.  Beyond that it will dissipate with distance.")]

public float m_ImpactRadius;
    [TooltipAttribute("Legacy mode only: How the signal direction behaves as the listener moves away from the origin.")]

public DirectionMode m_DirectionMode;
    [TooltipAttribute("Legacy mode only: This defines how the signal will dissipate with distance beyond the impact radius.")]

public DissipationMode m_DissipationMode;
    [TooltipAttribute("The signal will have no effect outside this radius surrounding the impact point.")]

public float m_DissipationDistance;
    [TooltipAttribute("The speed (m/s) at which the impulse propagates through space.  High speeds allow listeners to react instantaneously, while slower speeds allow listeners in the scene to react as if to a wave spreading from the source.")]

public float m_PropagationSpeed;
    
private static AnimationCurve[] sStandardShapes;
    
internal AnimationCurve ImpulseCurve { get; }
    public void OnValidate();
    private static void CreateStandardShapes();
    internal static AnimationCurve GetStandardCurve(ImpulseShapes shape);
    internal AnimationCurve get_ImpulseCurve();
    public void CreateEvent(Vector3 position, Vector3 velocity);
    public ImpulseEvent CreateAndReturnEvent(Vector3 position, Vector3 velocity);
    private ImpulseEvent LegacyCreateAndReturnEvent(Vector3 position, Vector3 velocity);
}
public class Cinemachine.CinemachineImpulseDefinitionPropertyAttribute : PropertyAttribute {
}
public class Cinemachine.CinemachineImpulseEnvelopePropertyAttribute : PropertyAttribute {
}
[SaveDuringPlayAttribute]
[AddComponentMenu("")]
[DocumentationSortingAttribute("2")]
[ExecuteAlways]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineImpulseListener.html")]
public class Cinemachine.CinemachineImpulseListener : CinemachineExtension {
    [TooltipAttribute("When to apply the impulse reaction.  Default is after the Noise stage.  Modify this if necessary to influence the ordering of extension effects")]

public Stage m_ApplyAfter;
    [TooltipAttribute("Impulse events on channels not included in the mask will be ignored.")]
[CinemachineImpulseChannelPropertyAttribute]

public int m_ChannelMask;
    [TooltipAttribute("Gain to apply to the Impulse signal.  1 is normal strength.  Setting this to 0 completely mutes the signal.")]

public float m_Gain;
    [TooltipAttribute("Enable this to perform distance calculation in 2D (ignore Z)")]

public bool m_Use2DDistance;
    [TooltipAttribute("Enable this to process all impulse signals in camera space")]

public bool m_UseCameraSpace;
    [TooltipAttribute("This controls the secondary reaction of the listener to the incoming impulse.  The impulse might be for example a sharp shock, and the secondary reaction could be a vibration whose amplitude and duration is controlled by the size of the original impulse.  This allows different listeners to respond in different ways to the same impulse signal.")]

public ImpulseReaction m_ReactionSettings;
    private void Reset();
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
}
[DocumentationSortingAttribute("1")]
public class Cinemachine.CinemachineImpulseManager : object {
    
private static CinemachineImpulseManager sInstance;
    
private static float Epsilon;
    
private List`1<ImpulseEvent> m_ExpiredEvents;
    
private List`1<ImpulseEvent> m_ActiveEvents;
    
public bool IgnoreTimeScale;
    
public static CinemachineImpulseManager Instance { get; }
    
public float CurrentTime { get; }
    public static CinemachineImpulseManager get_Instance();
    [RuntimeInitializeOnLoadMethodAttribute]
private static void InitializeModule();
    internal static float EvaluateDissipationScale(float spread, float normalizedDistance);
    public bool GetImpulseAt(Vector3 listenerLocation, bool distance2D, int channelMask, Vector3& pos, Quaternion& rot);
    public float get_CurrentTime();
    public ImpulseEvent NewImpulseEvent();
    public void AddImpulseEvent(ImpulseEvent e);
    public void Clear();
}
[DocumentationSortingAttribute("2")]
[SaveDuringPlayAttribute]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineImpulseSourceOverview.html")]
public class Cinemachine.CinemachineImpulseSource : MonoBehaviour {
    
public CinemachineImpulseDefinition m_ImpulseDefinition;
    [HeaderAttribute("Default Invocation")]
[TooltipAttribute("The default direction and force of the Impulse Signal in the absense of any specified overrides.  Overrides can be specified by calling the appropriate GenerateImpulse method in the API.")]

public Vector3 m_DefaultVelocity;
    private void OnValidate();
    private void Reset();
    public void GenerateImpulseAtPositionWithVelocity(Vector3 position, Vector3 velocity);
    public void GenerateImpulseWithVelocity(Vector3 velocity);
    public void GenerateImpulseWithForce(float force);
    public void GenerateImpulse();
    public void GenerateImpulseAt(Vector3 position, Vector3 velocity);
    public void GenerateImpulse(Vector3 velocity);
    public void GenerateImpulse(float force);
}
[SaveDuringPlayAttribute]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/api/Cinemachine.CinemachineIndependentImpulseListener.html")]
public class Cinemachine.CinemachineIndependentImpulseListener : MonoBehaviour {
    
private Vector3 impulsePosLastFrame;
    
private Quaternion impulseRotLastFrame;
    [TooltipAttribute("Impulse events on channels not included in the mask will be ignored.")]
[CinemachineImpulseChannelPropertyAttribute]

public int m_ChannelMask;
    [TooltipAttribute("Gain to apply to the Impulse signal.  1 is normal strength.  Setting this to 0 completely mutes the signal.")]

public float m_Gain;
    [TooltipAttribute("Enable this to perform distance calculation in 2D (ignore Z)")]

public bool m_Use2DDistance;
    [TooltipAttribute("Enable this to process all impulse signals in camera space")]

public bool m_UseLocalSpace;
    [TooltipAttribute("This controls the secondary reaction of the listener to the incoming impulse.  The impulse might be for example a sharp shock, and the secondary reaction could be a vibration whose amplitude and duration is controlled by the size of the original impulse.  This allows different listeners to respond in different ways to the same impulse signal.")]

public ImpulseReaction m_ReactionSettings;
    private void Reset();
    private void OnEnable();
    private void Update();
    private void LateUpdate();
}
public class Cinemachine.CinemachineInputAxisDriver : ValueType {
    [TooltipAttribute("Multiply the input by this amount prior to processing.  Controls the input power.")]

public float multiplier;
    [TooltipAttribute("The amount of time in seconds it takes to accelerate to a higher speed")]

public float accelTime;
    [TooltipAttribute("The amount of time in seconds it takes to decelerate to a lower speed")]

public float decelTime;
    [TooltipAttribute("The name of this axis as specified in Unity Input manager. Setting to an empty string will disable the automatic updating of this axis")]

public string name;
    [NoSaveDuringPlayAttribute]
[TooltipAttribute("The value of the input axis.  A value of 0 means no input.  You can drive this directly from a custom input system, or you can set the Axis Name and have the value driven by the internal Input Manager")]

public float inputValue;
    
private float mCurrentSpeed;
    
private static float Epsilon;
    public void Validate();
    public bool Update(float deltaTime, AxisBase& axis);
    public bool Update(float deltaTime, AxisState& axis);
    private float ClampValue(AxisBase& axis, float v);
}
[AddComponentMenu("")]
public class Cinemachine.CinemachineInputProvider : MonoBehaviour {
}
[DocumentationSortingAttribute("2")]
[DisallowMultipleComponent]
[ExecuteAlways]
[ExcludeFromPresetAttribute]
[AddComponentMenu("Cinemachine/CinemachineMixingCamera")]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineMixingCamera.html")]
public class Cinemachine.CinemachineMixingCamera : CinemachineVirtualCameraBase {
    
public static int MaxCameras;
    [TooltipAttribute("The weight of the first tracked camera")]

public float m_Weight0;
    [TooltipAttribute("The weight of the second tracked camera")]

public float m_Weight1;
    [TooltipAttribute("The weight of the third tracked camera")]

public float m_Weight2;
    [TooltipAttribute("The weight of the fourth tracked camera")]

public float m_Weight3;
    [TooltipAttribute("The weight of the fifth tracked camera")]

public float m_Weight4;
    [TooltipAttribute("The weight of the sixth tracked camera")]

public float m_Weight5;
    [TooltipAttribute("The weight of the seventh tracked camera")]

public float m_Weight6;
    [TooltipAttribute("The weight of the eighth tracked camera")]

public float m_Weight7;
    
private CameraState m_State;
    [CompilerGeneratedAttribute]

private ICinemachineCamera <LiveChild>k__BackingField;
    [CompilerGeneratedAttribute]

private Transform <LookAt>k__BackingField;
    [CompilerGeneratedAttribute]

private Transform <Follow>k__BackingField;
    
private CinemachineVirtualCameraBase[] m_ChildCameras;
    
private Dictionary`2<CinemachineVirtualCameraBase, int> m_indexMap;
    
private ICinemachineCamera LiveChild { get; private set; }
    
public CameraState State { get; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    
public CinemachineVirtualCameraBase[] ChildCameras { get; }
    public float GetWeight(int index);
    public void SetWeight(int index, float w);
    public float GetWeight(CinemachineVirtualCameraBase vcam);
    public void SetWeight(CinemachineVirtualCameraBase vcam, float w);
    [CompilerGeneratedAttribute]
private ICinemachineCamera get_LiveChild();
    [CompilerGeneratedAttribute]
private void set_LiveChild(ICinemachineCamera value);
    public virtual CameraState get_State();
    [CompilerGeneratedAttribute]
public virtual Transform get_LookAt();
    [CompilerGeneratedAttribute]
public virtual void set_LookAt(Transform value);
    [CompilerGeneratedAttribute]
public virtual Transform get_Follow();
    [CompilerGeneratedAttribute]
public virtual void set_Follow(Transform value);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    protected virtual void OnEnable();
    public void OnTransformChildrenChanged();
    protected virtual void OnValidate();
    public virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly);
    public CinemachineVirtualCameraBase[] get_ChildCameras();
    protected void InvalidateListOfChildren();
    protected void ValidateListOfChildren();
    public virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    public virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineOrbitalTransposer : CinemachineTransposer {
    [SpaceAttribute]
[OrbitalTransposerHeadingPropertyAttribute]
[TooltipAttribute("The definition of Forward.  Camera will follow behind.")]

public Heading m_Heading;
    [TooltipAttribute("Automatic heading recentering.  The settings here defines how the camera will reposition itself in the absence of player input.")]

public Recentering m_RecenterToTargetHeading;
    [TooltipAttribute("Heading Control.  The settings here control the behaviour of the camera in response to the player's input.")]
[AxisStatePropertyAttribute]

public AxisState m_XAxis;
    [SerializeField]
[HideInInspector]
[FormerlySerializedAsAttribute("m_Radius")]

private float m_LegacyRadius;
    [SerializeField]
[HideInInspector]
[FormerlySerializedAsAttribute("m_HeightOffset")]

private float m_LegacyHeightOffset;
    [SerializeField]
[HideInInspector]
[FormerlySerializedAsAttribute("m_HeadingBias")]

private float m_LegacyHeadingBias;
    [HideInInspector]
[NoSaveDuringPlayAttribute]

public bool m_HeadingIsSlave;
    
internal UpdateHeadingDelegate HeadingUpdater;
    
private Vector3 m_LastTargetPosition;
    
private HeadingTracker mHeadingTracker;
    
private Rigidbody m_TargetRigidBody;
    
private Transform m_PreviousTarget;
    
private Vector3 m_LastCameraPosition;
    
private float m_LastHeading;
    
public bool RequiresUserInput { get; }
    protected virtual void OnValidate();
    public float UpdateHeading(float deltaTime, Vector3 up, AxisState& axis);
    public float UpdateHeading(float deltaTime, Vector3 up, AxisState& axis, Recentering& recentering, bool isLive);
    private void OnEnable();
    public void UpdateInputAxisProvider();
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, TransitionParams& transitionParams);
    public float GetAxisClosestValue(Vector3 cameraPos, Vector3 up);
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
    public virtual Vector3 GetTargetCameraPosition(Vector3 worldUp);
    public virtual bool get_RequiresUserInput();
    private float GetTargetHeading(float currentHeading, Quaternion targetOrientation);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("Cinemachine/CinemachinePath")]
[SaveDuringPlayAttribute]
[DisallowMultipleComponent]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachinePath.html")]
public class Cinemachine.CinemachinePath : CinemachinePathBase {
    [TooltipAttribute("If checked, then the path ends are joined to form a continuous loop.")]

public bool m_Looped;
    [TooltipAttribute("The waypoints that define the path.  They will be interpolated using a bezier curve.")]

public Waypoint[] m_Waypoints;
    
public float MinPos { get; }
    
public float MaxPos { get; }
    
public bool Looped { get; }
    
public int DistanceCacheSampleStepsPerSegment { get; }
    public virtual float get_MinPos();
    public virtual float get_MaxPos();
    public virtual bool get_Looped();
    private void Reset();
    private void OnValidate();
    public virtual int get_DistanceCacheSampleStepsPerSegment();
    private float GetBoundingIndices(float pos, Int32& indexA, Int32& indexB);
    public virtual Vector3 EvaluateLocalPosition(float pos);
    public virtual Vector3 EvaluateLocalTangent(float pos);
    public virtual Quaternion EvaluateLocalOrientation(float pos);
    internal float GetRoll(int indexA, int indexB, float standardizedPos);
    private static Quaternion RollAroundForward(float angle);
}
public abstract class Cinemachine.CinemachinePathBase : MonoBehaviour {
    [TooltipAttribute("Path samples per waypoint.  This is used for calculating path distances.")]
[RangeAttribute("1", "100")]

public int m_Resolution;
    [TooltipAttribute("The settings that control how the path will appear in the editor scene view.")]

public Appearance m_Appearance;
    
private Single[] m_DistanceToPos;
    
private Single[] m_PosToDistance;
    
private int m_CachedSampleSteps;
    
private float m_PathLength;
    
private float m_cachedPosStepSize;
    
private float m_cachedDistanceStepSize;
    
public float MinPos { get; }
    
public float MaxPos { get; }
    
public bool Looped { get; }
    
public int DistanceCacheSampleStepsPerSegment { get; }
    
public float PathLength { get; }
    public abstract virtual float get_MinPos();
    public abstract virtual float get_MaxPos();
    public abstract virtual bool get_Looped();
    public virtual float StandardizePos(float pos);
    public virtual Vector3 EvaluatePosition(float pos);
    public virtual Vector3 EvaluateTangent(float pos);
    public virtual Quaternion EvaluateOrientation(float pos);
    public abstract virtual Vector3 EvaluateLocalPosition(float pos);
    public abstract virtual Vector3 EvaluateLocalTangent(float pos);
    public abstract virtual Quaternion EvaluateLocalOrientation(float pos);
    public virtual float FindClosestPoint(Vector3 p, int startSegment, int searchRadius, int stepsPerSegment);
    public float MinUnit(PositionUnits units);
    public float MaxUnit(PositionUnits units);
    public virtual float StandardizeUnit(float pos, PositionUnits units);
    public Vector3 EvaluatePositionAtUnit(float pos, PositionUnits units);
    public Vector3 EvaluateTangentAtUnit(float pos, PositionUnits units);
    public Quaternion EvaluateOrientationAtUnit(float pos, PositionUnits units);
    public abstract virtual int get_DistanceCacheSampleStepsPerSegment();
    public virtual void InvalidateDistanceCache();
    public bool DistanceCacheIsValid();
    public float get_PathLength();
    public float StandardizePathDistance(float distance);
    public float ToNativePathUnits(float pos, PositionUnits units);
    public float FromPathNativeUnits(float pos, PositionUnits units);
    private void ResamplePath(int stepsPerSegment);
}
[AddComponentMenu("")]
public class Cinemachine.CinemachinePipeline : MonoBehaviour {
}
[AddComponentMenu("")]
[DisallowMultipleComponent]
public class Cinemachine.CinemachinePixelPerfect : MonoBehaviour {
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachinePOV : CinemachineComponentBase {
    
public RecenterTargetMode m_RecenterTarget;
    [TooltipAttribute("The Vertical axis.  Value is -90..90. Controls the vertical orientation")]
[AxisStatePropertyAttribute]

public AxisState m_VerticalAxis;
    [TooltipAttribute("Controls how automatic recentering of the Vertical axis is accomplished")]

public Recentering m_VerticalRecentering;
    [TooltipAttribute("The Horizontal axis.  Value is -180..180.  Controls the horizontal orientation")]
[AxisStatePropertyAttribute]

public AxisState m_HorizontalAxis;
    [TooltipAttribute("Controls how automatic recentering of the Horizontal axis is accomplished")]

public Recentering m_HorizontalRecentering;
    [HideInInspector]
[TooltipAttribute("Obsolete - no longer used")]

public bool m_ApplyBeforeBody;
    
private Quaternion m_PreviousCameraRotation;
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    
public bool RequiresUserInput { get; }
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    private void OnValidate();
    private void OnEnable();
    public void UpdateInputAxisProvider();
    public virtual void PrePipelineMutateCameraState(CameraState& state, float deltaTime);
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
    public Vector2 GetRecenterTarget();
    private static float NormalizeAngle(float angle);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, TransitionParams& transitionParams);
    public virtual bool get_RequiresUserInput();
    private void SetAxesForRotation(Quaternion targetRot);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineSameAsFollowTarget : CinemachineComponentBase {
    [TooltipAttribute("How much time it takes for the aim to catch up to the target's rotation")]
[FormerlySerializedAsAttribute("m_AngularDamping")]

public float m_Damping;
    
private Quaternion m_PreviousReferenceOrientation;
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    public virtual float GetMaxDampTime();
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("Cinemachine/CinemachineSmoothPath")]
[SaveDuringPlayAttribute]
[DisallowMultipleComponent]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineSmoothPath.html")]
public class Cinemachine.CinemachineSmoothPath : CinemachinePathBase {
    [TooltipAttribute("If checked, then the path ends are joined to form a continuous loop.")]

public bool m_Looped;
    [TooltipAttribute("The waypoints that define the path.  They will be interpolated using a bezier curve.")]

public Waypoint[] m_Waypoints;
    
internal Waypoint[] m_ControlPoints1;
    
internal Waypoint[] m_ControlPoints2;
    
private bool m_IsLoopedCache;
    
public float MinPos { get; }
    
public float MaxPos { get; }
    
public bool Looped { get; }
    
public int DistanceCacheSampleStepsPerSegment { get; }
    public virtual float get_MinPos();
    public virtual float get_MaxPos();
    public virtual bool get_Looped();
    public virtual int get_DistanceCacheSampleStepsPerSegment();
    private void OnValidate();
    private void Reset();
    public virtual void InvalidateDistanceCache();
    internal void UpdateControlPoints();
    private float GetBoundingIndices(float pos, Int32& indexA, Int32& indexB);
    public virtual Vector3 EvaluateLocalPosition(float pos);
    public virtual Vector3 EvaluateLocalTangent(float pos);
    public virtual Quaternion EvaluateLocalOrientation(float pos);
    private static Quaternion RollAroundForward(float angle);
}
[DocumentationSortingAttribute("2")]
[DisallowMultipleComponent]
[ExecuteAlways]
[ExcludeFromPresetAttribute]
[AddComponentMenu("Cinemachine/CinemachineStateDrivenCamera")]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineStateDrivenCamera.html")]
public class Cinemachine.CinemachineStateDrivenCamera : CinemachineVirtualCameraBase {
    [TooltipAttribute("Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty if all of the children define targets of their own.")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_LookAt;
    [TooltipAttribute("Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty if all of the children define targets of their own.")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_Follow;
    [SpaceAttribute]
[TooltipAttribute("The state machine whose state changes will drive this camera's choice of active child")]
[NoSaveDuringPlayAttribute]

public Animator m_AnimatedTarget;
    [TooltipAttribute("Which layer in the target state machine to observe")]
[NoSaveDuringPlayAttribute]

public int m_LayerIndex;
    [TooltipAttribute("When enabled, the current child camera and blend will be indicated in the game window, for debugging")]

public bool m_ShowDebugText;
    [SerializeField]
[HideInInspector]
[NoSaveDuringPlayAttribute]

internal CinemachineVirtualCameraBase[] m_ChildCameras;
    [TooltipAttribute("The set of instructions associating virtual cameras with states.  These instructions are used to choose the live child at any given moment")]

public Instruction[] m_Instructions;
    [CinemachineBlendDefinitionPropertyAttribute]
[TooltipAttribute("The blend which is used if you don't explicitly define a blend between two Virtual Camera children")]

public CinemachineBlendDefinition m_DefaultBlend;
    [TooltipAttribute("This is the asset which contains custom settings for specific child blends")]

public CinemachineBlenderSettings m_CustomBlends;
    [HideInInspector]
[SerializeField]

internal ParentHash[] m_ParentHash;
    [CompilerGeneratedAttribute]

private ICinemachineCamera <LiveChild>k__BackingField;
    
private ICinemachineCamera m_TransitioningFrom;
    
private CameraState m_State;
    
private Dictionary`2<AnimationClip, List`1<HashPair>> mHashCache;
    
private float mActivationTime;
    
private Instruction mActiveInstruction;
    
private float mPendingActivationTime;
    
private Instruction mPendingInstruction;
    
private CinemachineBlend mActiveBlend;
    
private Dictionary`2<int, int> mInstructionDictionary;
    
private Dictionary`2<int, int> mStateParentLookup;
    
private List`1<AnimatorClipInfo> m_clipInfoList;
    
public string Description { get; }
    
public ICinemachineCamera LiveChild { get; public set; }
    
public CameraState State { get; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    
public CinemachineVirtualCameraBase[] ChildCameras { get; }
    
public bool IsBlending { get; }
    
public CinemachineBlend ActiveBlend { get; }
    public virtual string get_Description();
    [CompilerGeneratedAttribute]
public ICinemachineCamera get_LiveChild();
    [CompilerGeneratedAttribute]
public void set_LiveChild(ICinemachineCamera value);
    public virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly);
    public virtual CameraState get_State();
    public virtual Transform get_LookAt();
    public virtual void set_LookAt(Transform value);
    public virtual Transform get_Follow();
    public virtual void set_Follow(Transform value);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    public virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    public virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
    protected virtual void OnEnable();
    protected virtual void OnDisable();
    public void OnTransformChildrenChanged();
    private void OnGuiHandler();
    public CinemachineVirtualCameraBase[] get_ChildCameras();
    public bool get_IsBlending();
    public CinemachineBlend get_ActiveBlend();
    public static int CreateFakeHash(int parentHash, AnimationClip clip);
    private int LookupFakeHash(int parentHash, AnimationClip clip);
    private void InvalidateListOfChildren();
    private void UpdateListOfChildren();
    internal void ValidateInstructions();
    private CinemachineVirtualCameraBase ChooseCurrentCamera();
    private int GetClipHash(int hash, List`1<AnimatorClipInfo> clips);
    private CinemachineBlendDefinition LookupBlend(ICinemachineCamera fromKey, ICinemachineCamera toKey);
}
[SaveDuringPlayAttribute]
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[ExecuteAlways]
[DisallowMultipleComponent]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineStoryboard.html")]
public class Cinemachine.CinemachineStoryboard : CinemachineExtension {
    [TooltipAttribute("If checked, all storyboards are globally muted")]

public static bool s_StoryboardGlobalMute;
    [TooltipAttribute("If checked, the specified image will be displayed as an overlay over the virtual camera's output")]

public bool m_ShowImage;
    [TooltipAttribute("The image to display")]

public Texture m_Image;
    [TooltipAttribute("How to handle differences between image aspect and screen aspect")]

public FillStrategy m_Aspect;
    [TooltipAttribute("The opacity of the image.  0 is transparent, 1 is opaque")]
[RangeAttribute("0", "1")]

public float m_Alpha;
    [TooltipAttribute("The screen-space position at which to display the image.  Zero is center")]

public Vector2 m_Center;
    [TooltipAttribute("The screen-space rotation to apply to the image")]

public Vector3 m_Rotation;
    [TooltipAttribute("The screen-space scaling to apply to the image")]

public Vector2 m_Scale;
    [TooltipAttribute("If checked, X and Y scale are synchronized")]

public bool m_SyncScale;
    [TooltipAttribute("If checked, Camera transform will not be controlled by this virtual camera")]

public bool m_MuteCamera;
    [RangeAttribute("-1", "1")]
[TooltipAttribute("Wipe the image on and off horizontally")]

public float m_SplitView;
    [TooltipAttribute("The render mode of the canvas on which the storyboard is drawn.")]

public StoryboardRenderMode m_RenderMode;
    [TooltipAttribute("Allows ordering canvases to render on top or below other canvases.")]

public int m_SortingOrder;
    [TooltipAttribute("How far away from the camera is the Canvas generated.")]

public float m_PlaneDistance;
    
private List`1<CanvasInfo> mCanvasInfo;
    
private string CanvasName { get; }
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
    private void UpdateRenderCanvas();
    protected virtual void ConnectToVcam(bool connect);
    private string get_CanvasName();
    private void CameraUpdatedCallback(CinemachineBrain brain);
    private CanvasInfo LocateMyCanvas(CinemachineBrain parent, bool createIfNotFound);
    private void CreateCanvas(CanvasInfo ci);
    private void DestroyCanvas();
    private void PlaceImage(CanvasInfo ci, float alpha);
    private static void StaticBlendingHandler(CinemachineBrain brain);
    [RuntimeInitializeOnLoadMethodAttribute]
private static void InitializeModule();
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("Cinemachine/CinemachineTargetGroup")]
[SaveDuringPlayAttribute]
[ExecuteAlways]
[DisallowMultipleComponent]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineTargetGroup.html")]
public class Cinemachine.CinemachineTargetGroup : MonoBehaviour {
    [TooltipAttribute("How the group's position is calculated.  Select GroupCenter for the center of the bounding box, and GroupAverage for a weighted average of the positions of the members.")]

public PositionMode m_PositionMode;
    [TooltipAttribute("How the group's rotation is calculated.  Select Manual to use the value in the group's transform, and GroupAverage for a weighted average of the orientations of the members.")]

public RotationMode m_RotationMode;
    [TooltipAttribute("When to update the group's transform based on the position of the group members")]

public UpdateMethod m_UpdateMethod;
    [NoSaveDuringPlayAttribute]
[TooltipAttribute("The target objects, together with their weights and radii, that will contribute to the group's average position, orientation, and size.")]

public Target[] m_Targets;
    
private float m_MaxWeight;
    
private float m_WeightSum;
    
private Vector3 m_AveragePos;
    
private Bounds m_BoundingBox;
    
private BoundingSphere m_BoundingSphere;
    
private int m_LastUpdateFrame;
    
private List`1<int> m_ValidMembers;
    
private List`1<bool> m_MemberValidity;
    
public Transform Transform { get; }
    
public Bounds BoundingBox { get; private set; }
    
public BoundingSphere Sphere { get; private set; }
    
public bool IsEmpty { get; }
    
private bool CachedCountIsValid { get; }
    private void OnValidate();
    private void Reset();
    public sealed virtual Transform get_Transform();
    public sealed virtual Bounds get_BoundingBox();
    private void set_BoundingBox(Bounds value);
    public sealed virtual BoundingSphere get_Sphere();
    private void set_Sphere(BoundingSphere value);
    public sealed virtual bool get_IsEmpty();
    public void AddMember(Transform t, float weight, float radius);
    public void RemoveMember(Transform t);
    public int FindMember(Transform t);
    public BoundingSphere GetWeightedBoundsForMember(int index);
    public sealed virtual Bounds GetViewSpaceBoundingBox(Matrix4x4 observer);
    private bool get_CachedCountIsValid();
    private bool IndexIsValid(int index);
    private static BoundingSphere WeightedMemberBoundsForValidMember(Target& t, Vector3 avgPos, float maxWeight);
    public void DoUpdate();
    private void UpdateMemberValidity();
    private Vector3 CalculateAveragePosition();
    private Bounds CalculateBoundingBox();
    private BoundingSphere CalculateBoundingSphere();
    private Quaternion CalculateAverageOrientation();
    private void FixedUpdate();
    private void Update();
    private void LateUpdate();
    public sealed virtual void GetViewSpaceAngularBounds(Matrix4x4 observer, Vector2& minAngles, Vector2& maxAngles, Vector2& zRange);
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineTrackedDolly : CinemachineComponentBase {
    [TooltipAttribute("The path to which the camera will be constrained.  This must be non-null.")]

public CinemachinePathBase m_Path;
    [TooltipAttribute("The position along the path at which the camera will be placed.  This can be animated directly, or set automatically by the Auto-Dolly feature to get as close as possible to the Follow target.  The value is interpreted according to the Position Units setting.")]

public float m_PathPosition;
    [TooltipAttribute("How to interpret Path Position.  If set to Path Units, values are as follows: 0 represents the first waypoint on the path, 1 is the second, and so on.  Values in-between are points on the path in between the waypoints.  If set to Distance, then Path Position represents distance along the path.")]

public PositionUnits m_PositionUnits;
    [TooltipAttribute("Where to put the camera relative to the path position.  X is perpendicular to the path, Y is up, and Z is parallel to the path.  This allows the camera to be offset from the path itself (as if on a tripod, for example).")]

public Vector3 m_PathOffset;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to maintain its position in a direction perpendicular to the path.  Small numbers are more responsive, rapidly translating the camera to keep the target's x-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]

public float m_XDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to maintain its position in the path-local up direction.  Small numbers are more responsive, rapidly translating the camera to keep the target's y-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]

public float m_YDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to maintain its position in a direction parallel to the path.  Small numbers are more responsive, rapidly translating the camera to keep the target's z-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]

public float m_ZDamping;
    [TooltipAttribute("How to set the virtual camera's Up vector.  This will affect the screen composition, because the camera Aim behaviours will always try to respect the Up direction.")]

public CameraUpMode m_CameraUp;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to track the target rotation's X angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]

public float m_PitchDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to track the target rotation's Y angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]

public float m_YawDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to track the target rotation's Z angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]

public float m_RollDamping;
    [TooltipAttribute("Controls how automatic dollying occurs.  A Follow target is necessary to use this feature.")]

public AutoDolly m_AutoDolly;
    
private float m_PreviousPathPosition;
    
private Quaternion m_PreviousOrientation;
    
private Vector3 m_PreviousCameraPosition;
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    
private Vector3 AngularDamping { get; }
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    public virtual float GetMaxDampTime();
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
    private Quaternion GetCameraOrientationAtPathPoint(Quaternion pathOrientation, Vector3 up);
    private Vector3 get_AngularDamping();
}
[DocumentationSortingAttribute("2")]
[AddComponentMenu("")]
[SaveDuringPlayAttribute]
public class Cinemachine.CinemachineTransposer : CinemachineComponentBase {
    [TooltipAttribute("The coordinate space to use when interpreting the offset from the target.  This is also used to set the camera's Up vector, which will be maintained when aiming the camera.")]

public BindingMode m_BindingMode;
    [TooltipAttribute("The distance vector that the transposer will attempt to maintain from the Follow target")]

public Vector3 m_FollowOffset;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to maintain the offset in the X-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's x-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]

public float m_XDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to maintain the offset in the Y-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's y-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]

public float m_YDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to maintain the offset in the Z-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's z-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]

public float m_ZDamping;
    
public AngularDampingMode m_AngularDampingMode;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to track the target rotation's X angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]

public float m_PitchDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to track the target rotation's Y angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]

public float m_YawDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to track the target rotation's Z angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]

public float m_RollDamping;
    [RangeAttribute("0", "20")]
[TooltipAttribute("How aggressively the camera tries to track the target's orientation.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]

public float m_AngularDamping;
    [CompilerGeneratedAttribute]

private bool <HideOffsetInInspector>k__BackingField;
    
private Vector3 m_PreviousTargetPosition;
    
private Quaternion m_PreviousReferenceOrientation;
    
private Quaternion m_targetOrientationOnAssign;
    
private Vector3 m_PreviousOffset;
    
private Transform m_previousTarget;
    
public bool HideOffsetInInspector { get; public set; }
    
public Vector3 EffectiveOffset { get; }
    
public bool IsValid { get; }
    
public Stage Stage { get; }
    
protected Vector3 Damping { get; }
    
protected Vector3 AngularDamping { get; }
    protected virtual void OnValidate();
    [CompilerGeneratedAttribute]
public bool get_HideOffsetInInspector();
    [CompilerGeneratedAttribute]
public void set_HideOffsetInInspector(bool value);
    public Vector3 get_EffectiveOffset();
    public virtual bool get_IsValid();
    public virtual Stage get_Stage();
    public virtual float GetMaxDampTime();
    public virtual void MutateCameraState(CameraState& curState, float deltaTime);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    protected void InitPrevFrameStateInfo(CameraState& curState, float deltaTime);
    protected void TrackTarget(float deltaTime, Vector3 up, Vector3 desiredCameraOffset, Vector3& outTargetPosition, Quaternion& outTargetOrient);
    protected Vector3 GetOffsetForMinimumTargetDistance(Vector3 dampedTargetPos, Vector3 cameraOffset, Vector3 cameraFwd, Vector3 up, Vector3 actualTargetPos);
    protected Vector3 get_Damping();
    protected Vector3 get_AngularDamping();
    public virtual Vector3 GetTargetCameraPosition(Vector3 worldUp);
    public Quaternion GetReferenceOrientation(Vector3 worldUp);
}
[DocumentationSortingAttribute("2")]
[SaveDuringPlayAttribute]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/api/Cinemachine.CinemachineTriggerAction.html")]
public class Cinemachine.CinemachineTriggerAction : MonoBehaviour {
    [HeaderAttribute("Trigger Object Filter")]
[TooltipAttribute("Only triggers generated by objects on these layers will be considered")]

public LayerMask m_LayerMask;
    [TagFieldAttribute]
[TooltipAttribute("If set, only triggers generated by objects with this tag will be considered")]

public string m_WithTag;
    [TagFieldAttribute]
[TooltipAttribute("Triggers generated by objects with this tag will be ignored")]

public string m_WithoutTag;
    [NoSaveDuringPlayAttribute]
[TooltipAttribute("Skip this many trigger entries before taking action")]

public int m_SkipFirst;
    [TooltipAttribute("Repeat the action for all subsequent trigger entries")]

public bool m_Repeating;
    
public ActionSettings m_OnObjectEnter;
    
public ActionSettings m_OnObjectExit;
    
private HashSet`1<GameObject> m_ActiveTriggerObjects;
    private bool Filter(GameObject other);
    private void InternalDoTriggerEnter(GameObject other);
    private void InternalDoTriggerExit(GameObject other);
    private void OnTriggerEnter(Collider other);
    private void OnTriggerExit(Collider other);
    private void OnCollisionEnter(Collision other);
    private void OnCollisionExit(Collision other);
    private void OnTriggerEnter2D(Collider2D other);
    private void OnTriggerExit2D(Collider2D other);
    private void OnCollisionEnter2D(Collision2D other);
    private void OnCollisionExit2D(Collision2D other);
    private void OnEnable();
}
[DocumentationSortingAttribute("2")]
[DisallowMultipleComponent]
[ExecuteAlways]
[ExcludeFromPresetAttribute]
[AddComponentMenu("Cinemachine/CinemachineVirtualCamera")]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineVirtualCamera.html")]
public class Cinemachine.CinemachineVirtualCamera : CinemachineVirtualCameraBase {
    [TooltipAttribute("The object that the camera wants to look at (the Aim target).  If this is null, then the vcam's Transform orientation will define the camera's orientation.")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_LookAt;
    [TooltipAttribute("The object that the camera wants to move with (the Body target).  If this is null, then the vcam's Transform position will define the camera's position.")]
[NoSaveDuringPlayAttribute]
[VcamTargetPropertyAttribute]

public Transform m_Follow;
    [FormerlySerializedAsAttribute("m_LensAttributes")]
[TooltipAttribute("Specifies the lens properties of this Virtual Camera.  This generally mirrors the Unity Camera's lens settings, and will be used to drive the Unity camera when the vcam is active.")]

public LensSettings m_Lens;
    
public TransitionParams m_Transitions;
    [SerializeField]
[HideInInspector]
[FormerlySerializedAsAttribute("m_BlendHint")]
[FormerlySerializedAsAttribute("m_PositionBlending")]

private BlendHint m_LegacyBlendHint;
    
public static string PipelineName;
    
public static CreatePipelineDelegate CreatePipelineOverride;
    
public static DestroyPipelineDelegate DestroyPipelineOverride;
    
private CameraState m_State;
    
private CinemachineComponentBase[] m_ComponentPipeline;
    [SerializeField]
[HideInInspector]

private Transform m_ComponentOwner;
    
private Transform mCachedLookAtTarget;
    
private CinemachineVirtualCameraBase mCachedLookAtTargetVcam;
    
public CameraState State { get; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    public virtual CameraState get_State();
    public virtual Transform get_LookAt();
    public virtual void set_LookAt(Transform value);
    public virtual Transform get_Follow();
    public virtual void set_Follow(Transform value);
    public virtual float GetMaxDampTime();
    public virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
    protected virtual void OnEnable();
    protected virtual void OnDestroy();
    protected virtual void OnValidate();
    private void OnTransformChildrenChanged();
    private void Reset();
    internal void DestroyPipeline();
    internal Transform CreatePipeline(CinemachineVirtualCamera copyFrom);
    public void InvalidateComponentPipeline();
    public Transform GetComponentOwner();
    public CinemachineComponentBase[] GetComponentPipeline();
    public CinemachineComponentBase GetCinemachineComponent(Stage stage);
    public T GetCinemachineComponent();
    public T AddCinemachineComponent();
    public void DestroyCinemachineComponent();
    private void UpdateComponentPipeline();
    internal static void SetFlagsForHiddenChild(GameObject child);
    private CameraState CalculateNewState(Vector3 worldUp, float deltaTime);
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    internal void SetStateRawPosition(Vector3 pos);
    public virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    internal virtual bool RequiresUserInput();
    internal virtual void OnBeforeSerialize();
}
[SaveDuringPlayAttribute]
public abstract class Cinemachine.CinemachineVirtualCameraBase : MonoBehaviour {
    [HideInInspector]
[SerializeField]
[NoSaveDuringPlayAttribute]

public String[] m_ExcludedPropertiesInInspector;
    [HideInInspector]
[SerializeField]
[NoSaveDuringPlayAttribute]

public Stage[] m_LockStageInInspector;
    
private int m_ValidatingStreamVersion;
    
private bool m_OnValidateCalled;
    [HideInInspector]
[SerializeField]
[NoSaveDuringPlayAttribute]

private int m_StreamingVersion;
    [NoSaveDuringPlayAttribute]
[TooltipAttribute("The priority will determine which camera becomes active based on the state of other cameras and this camera.  Higher numbers have greater priority.")]

public int m_Priority;
    
internal int m_ActivationId;
    
public float FollowTargetAttachment;
    
public float LookAtTargetAttachment;
    [TooltipAttribute("When the virtual camera is not live, this is how often the virtual camera will be updated.  Set this to tune for performance. Most of the time Never is fine, unless the virtual camera is doing shot evaluation.")]

public StandbyUpdateMode m_StandbyUpdate;
    [CompilerGeneratedAttribute]

private List`1<CinemachineExtension> <mExtensions>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <PreviousStateIsValid>k__BackingField;
    
private bool m_WasStarted;
    
private bool mSlaveStatusUpdated;
    
private CinemachineVirtualCameraBase m_parentVcam;
    
private int m_QueuePriority;
    
private float m_blendStartPosition;
    
private Transform m_CachedFollowTarget;
    
private CinemachineVirtualCameraBase m_CachedFollowTargetVcam;
    
private ICinemachineTargetGroup m_CachedFollowTargetGroup;
    
private Transform m_CachedLookAtTarget;
    
private CinemachineVirtualCameraBase m_CachedLookAtTargetVcam;
    
private ICinemachineTargetGroup m_CachedLookAtTargetGroup;
    [CompilerGeneratedAttribute]

private bool <FollowTargetChanged>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <LookAtTargetChanged>k__BackingField;
    
public int ValidatingStreamVersion { get; private set; }
    
internal List`1<CinemachineExtension> mExtensions { get; private set; }
    
public string Name { get; }
    
public string Description { get; }
    
public int Priority { get; public set; }
    
public GameObject VirtualCameraGameObject { get; }
    
public bool IsValid { get; }
    
public CameraState State { get; }
    
public ICinemachineCamera ParentCamera { get; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    
public bool PreviousStateIsValid { get; public set; }
    
public bool FollowTargetChanged { get; private set; }
    
public bool LookAtTargetChanged { get; private set; }
    
public ICinemachineTargetGroup AbstractFollowTargetGroup { get; }
    
public CinemachineVirtualCameraBase FollowTargetAsVcam { get; }
    
public ICinemachineTargetGroup AbstractLookAtTargetGroup { get; }
    
public CinemachineVirtualCameraBase LookAtTargetAsVcam { get; }
    public int get_ValidatingStreamVersion();
    private void set_ValidatingStreamVersion(int value);
    public virtual float GetMaxDampTime();
    public float DetachedFollowTargetDamp(float initial, float dampTime, float deltaTime);
    public Vector3 DetachedFollowTargetDamp(Vector3 initial, Vector3 dampTime, float deltaTime);
    public Vector3 DetachedFollowTargetDamp(Vector3 initial, float dampTime, float deltaTime);
    public float DetachedLookAtTargetDamp(float initial, float dampTime, float deltaTime);
    public Vector3 DetachedLookAtTargetDamp(Vector3 initial, Vector3 dampTime, float deltaTime);
    public Vector3 DetachedLookAtTargetDamp(Vector3 initial, float dampTime, float deltaTime);
    public virtual void AddExtension(CinemachineExtension extension);
    public virtual void RemoveExtension(CinemachineExtension extension);
    [CompilerGeneratedAttribute]
internal List`1<CinemachineExtension> get_mExtensions();
    [CompilerGeneratedAttribute]
private void set_mExtensions(List`1<CinemachineExtension> value);
    protected void InvokePostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& newState, float deltaTime);
    protected void InvokePrePipelineMutateCameraStateCallback(CinemachineVirtualCameraBase vcam, CameraState& newState, float deltaTime);
    protected bool InvokeOnTransitionInExtensions(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    public sealed virtual string get_Name();
    public virtual string get_Description();
    public sealed virtual int get_Priority();
    public sealed virtual void set_Priority(int value);
    protected void ApplyPositionBlendMethod(CameraState& state, BlendHint hint);
    public sealed virtual GameObject get_VirtualCameraGameObject();
    public sealed virtual bool get_IsValid();
    public abstract virtual CameraState get_State();
    public sealed virtual ICinemachineCamera get_ParentCamera();
    public virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly);
    public abstract virtual Transform get_LookAt();
    public abstract virtual void set_LookAt(Transform value);
    public abstract virtual Transform get_Follow();
    public abstract virtual void set_Follow(Transform value);
    [CompilerGeneratedAttribute]
public virtual bool get_PreviousStateIsValid();
    [CompilerGeneratedAttribute]
public virtual void set_PreviousStateIsValid(bool value);
    public sealed virtual void UpdateCameraState(Vector3 worldUp, float deltaTime);
    public abstract virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
    public virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    protected virtual void OnDestroy();
    protected virtual void OnTransformParentChanged();
    protected virtual void Start();
    internal virtual bool RequiresUserInput();
    internal void EnsureStarted();
    public IInputAxisProvider GetInputAxisProvider();
    protected virtual void OnValidate();
    protected virtual void OnEnable();
    protected virtual void OnDisable();
    protected virtual void Update();
    private void UpdateSlaveStatus();
    public Transform ResolveLookAt(Transform localLookAt);
    public Transform ResolveFollow(Transform localFollow);
    private void UpdateVcamPoolStatus();
    public void MoveToTopOfPrioritySubqueue();
    public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
    public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot);
    private bool GetInheritPosition(ICinemachineCamera cam);
    protected CinemachineBlend CreateBlend(ICinemachineCamera camA, ICinemachineCamera camB, CinemachineBlendDefinition blendDef, CinemachineBlend activeBlend);
    protected CameraState PullStateFromVirtualCamera(Vector3 worldUp, LensSettings& lens);
    private void InvalidateCachedTargets();
    [CompilerGeneratedAttribute]
public bool get_FollowTargetChanged();
    [CompilerGeneratedAttribute]
private void set_FollowTargetChanged(bool value);
    [CompilerGeneratedAttribute]
public bool get_LookAtTargetChanged();
    [CompilerGeneratedAttribute]
private void set_LookAtTargetChanged(bool value);
    protected void UpdateTargetCache();
    public ICinemachineTargetGroup get_AbstractFollowTargetGroup();
    public CinemachineVirtualCameraBase get_FollowTargetAsVcam();
    public ICinemachineTargetGroup get_AbstractLookAtTargetGroup();
    public CinemachineVirtualCameraBase get_LookAtTargetAsVcam();
    private sealed virtual override void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize();
    private sealed virtual override void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize();
    protected internal virtual void LegacyUpgrade(int streamedVersion);
    internal virtual void OnBeforeSerialize();
    public void CancelDamping(bool updateNow);
}
internal static class Cinemachine.ClipperLib : object {
}
internal class Cinemachine.ConfinerOven : object {
    
private float m_MinFrustumHeightWithBones;
    
private List`1<List`1<IntPoint>> m_OriginalPolygon;
    
private IntPoint m_MidPoint;
    
private List`1<List`1<IntPoint>> m_Skeleton;
    
private static long k_FloatToIntScaler;
    
private static float k_IntToFloatScaler;
    
private static float k_MinStepSize;
    
private Rect m_PolygonRect;
    
private AspectStretcher m_AspectStretcher;
    
private float m_MaxComputationTimeForFullSkeletonBakeInSeconds;
    [CompilerGeneratedAttribute]

private BakingState <State>k__BackingField;
    
public float bakeProgress;
    
private BakingStateCache m_Cache;
    
public BakingState State { get; private set; }
    public ConfinerOven(List`1& inputPath, Single& aspectRatio, float maxFrustumHeight);
    public BakedSolution GetBakedSolution(float frustumHeight);
    [CompilerGeneratedAttribute]
public BakingState get_State();
    [CompilerGeneratedAttribute]
private void set_State(BakingState value);
    private void Initialize(List`1& inputPath, Single& aspectRatio, float maxFrustumHeight);
    public void BakeConfiner(float maxComputationTimePerFrameInSeconds);
    [CompilerGeneratedAttribute]
internal static Rect <Initialize>g__GetPolygonBoundingBox|23_0(List`1& polygons);
    [CompilerGeneratedAttribute]
internal static IntPoint <Initialize>g__MidPointOfIntRect|23_1(IntRect bounds);
    [CompilerGeneratedAttribute]
private void <BakeConfiner>g__ComputeSkeleton|24_0(List`1& solutions);
}
internal static class Cinemachine.Documentation : object {
    
public static string BaseURL;
}
[DocumentationSortingAttribute("0")]
public class Cinemachine.DocumentationSortingAttribute : Attribute {
    [CompilerGeneratedAttribute]

private Level <Category>k__BackingField;
    
public Level Category { get; private set; }
    public DocumentationSortingAttribute(Level category);
    [CompilerGeneratedAttribute]
public Level get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(Level value);
}
[RequireComponent("Cinemachine.CinemachineTargetGroup")]
[ExecuteAlways]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/api/Cinemachine.GroupWeightManipulator.html")]
public class Cinemachine.GroupWeightManipulator : MonoBehaviour {
    [TooltipAttribute("The weight of the group member at index 0")]

public float m_Weight0;
    [TooltipAttribute("The weight of the group member at index 1")]

public float m_Weight1;
    [TooltipAttribute("The weight of the group member at index 2")]

public float m_Weight2;
    [TooltipAttribute("The weight of the group member at index 3")]

public float m_Weight3;
    [TooltipAttribute("The weight of the group member at index 4")]

public float m_Weight4;
    [TooltipAttribute("The weight of the group member at index 5")]

public float m_Weight5;
    [TooltipAttribute("The weight of the group member at index 6")]

public float m_Weight6;
    [TooltipAttribute("The weight of the group member at index 7")]

public float m_Weight7;
    
private CinemachineTargetGroup m_group;
    private void Start();
    private void OnValidate();
    private void Update();
    private void UpdateWeights();
}
public interface Cinemachine.ICameraOverrideStack {
    
public Vector3 DefaultWorldUp { get; }
    public abstract virtual int SetCameraOverride(int overrideId, ICinemachineCamera camA, ICinemachineCamera camB, float weightB, float deltaTime);
    public abstract virtual void ReleaseCameraOverride(int overrideId);
    public abstract virtual Vector3 get_DefaultWorldUp();
}
public interface Cinemachine.ICinemachineCamera {
    
public string Name { get; }
    
public string Description { get; }
    
public int Priority { get; public set; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    
public CameraState State { get; }
    
public GameObject VirtualCameraGameObject { get; }
    
public bool IsValid { get; }
    
public ICinemachineCamera ParentCamera { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Description();
    public abstract virtual int get_Priority();
    public abstract virtual void set_Priority(int value);
    public abstract virtual Transform get_LookAt();
    public abstract virtual void set_LookAt(Transform value);
    public abstract virtual Transform get_Follow();
    public abstract virtual void set_Follow(Transform value);
    public abstract virtual CameraState get_State();
    public abstract virtual GameObject get_VirtualCameraGameObject();
    public abstract virtual bool get_IsValid();
    public abstract virtual ICinemachineCamera get_ParentCamera();
    public abstract virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly);
    public abstract virtual void UpdateCameraState(Vector3 worldUp, float deltaTime);
    public abstract virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
    public abstract virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    public abstract virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
}
public interface Cinemachine.ICinemachineTargetGroup {
    
public Transform Transform { get; }
    
public Bounds BoundingBox { get; }
    
public BoundingSphere Sphere { get; }
    
public bool IsEmpty { get; }
    public abstract virtual Transform get_Transform();
    public abstract virtual Bounds get_BoundingBox();
    public abstract virtual BoundingSphere get_Sphere();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual Bounds GetViewSpaceBoundingBox(Matrix4x4 observer);
    public abstract virtual void GetViewSpaceAngularBounds(Matrix4x4 observer, Vector2& minAngles, Vector2& maxAngles, Vector2& zRange);
}
public interface Cinemachine.ISignalSource6D {
    
public float SignalDuration { get; }
    public abstract virtual float get_SignalDuration();
    public abstract virtual void GetSignal(float timeSinceSignalStart, Vector3& pos, Quaternion& rot);
}
[DocumentationSortingAttribute("2")]
public class Cinemachine.LensSettings : ValueType {
    
public static LensSettings Default;
    [RangeAttribute("1", "179")]
[TooltipAttribute("This is the camera view in degrees. Display will be in vertical degress, unless the associated camera has its FOV axis setting set to Horizontal, in which case display will be in horizontal degress.  Internally, it is always vertical degrees.  For cinematic people, a 50mm lens on a super-35mm sensor would equal a 19.6 degree FOV")]

public float FieldOfView;
    [TooltipAttribute("When using an orthographic camera, this defines the half-height, in world coordinates, of the camera view.")]

public float OrthographicSize;
    [TooltipAttribute("This defines the near region in the renderable range of the camera frustum. Raising this value will stop the game from drawing things near the camera, which can sometimes come in handy.  Larger values will also increase your shadow resolution.")]

public float NearClipPlane;
    [TooltipAttribute("This defines the far region of the renderable range of the camera frustum. Typically you want to set this value as low as possible without cutting off desired distant objects")]

public float FarClipPlane;
    [RangeAttribute("-180", "180")]
[TooltipAttribute("Camera Z roll, or tilt, in degrees.")]

public float Dutch;
    [TooltipAttribute("Allows you to select a different camera mode to apply to the Camera component when Cinemachine activates this Virtual Camera.  The changes applied to the Camera component through this setting will remain after the Virtual Camera deactivation.")]

public OverrideModes ModeOverride;
    
public Vector2 LensShift;
    
public GateFitMode GateFit;
    
public float FocusDistance;
    [SerializeField]

private Vector2 m_SensorSize;
    
private bool m_OrthoFromCamera;
    
private bool m_PhysicalFromCamera;
    
public bool Orthographic { get; public set; }
    
public Vector2 SensorSize { get; public set; }
    
public float Aspect { get; }
    
public bool IsPhysicalCamera { get; public set; }
    public LensSettings(float verticalFOV, float orthographicSize, float nearClip, float farClip, float dutch);
    private static LensSettings();
    public bool get_Orthographic();
    public void set_Orthographic(bool value);
    public Vector2 get_SensorSize();
    public void set_SensorSize(Vector2 value);
    public float get_Aspect();
    public bool get_IsPhysicalCamera();
    public void set_IsPhysicalCamera(bool value);
    public static LensSettings FromCamera(Camera fromCamera);
    public void SnapshotCameraReadOnlyProperties(Camera camera);
    public void SnapshotCameraReadOnlyProperties(LensSettings& lens);
    public static LensSettings Lerp(LensSettings lensA, LensSettings lensB, float t);
    public void Validate();
}
public class Cinemachine.LensSettingsPropertyAttribute : PropertyAttribute {
}
[DocumentationSortingAttribute("2")]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineNoiseProfiles.html")]
public class Cinemachine.NoiseSettings : SignalSourceAsset {
    [TooltipAttribute("These are the noise channels for the virtual camera's position. Convincing noise setups typically mix low, medium and high frequencies together, so start with a size of 3")]
[FormerlySerializedAsAttribute("m_Position")]

public TransformNoiseParams[] PositionNoise;
    [TooltipAttribute("These are the noise channels for the virtual camera's orientation. Convincing noise setups typically mix low, medium and high frequencies together, so start with a size of 3")]
[FormerlySerializedAsAttribute("m_Orientation")]

public TransformNoiseParams[] OrientationNoise;
    
public float SignalDuration { get; }
    public static Vector3 GetCombinedFilterResults(TransformNoiseParams[] noiseParams, float time, Vector3 timeOffsets);
    public virtual float get_SignalDuration();
    public virtual void GetSignal(float timeSinceSignalStart, Vector3& pos, Quaternion& rot);
}
public class Cinemachine.NoiseSettingsPropertyAttribute : PropertyAttribute {
}
public class Cinemachine.NoSaveDuringPlayAttribute : PropertyAttribute {
}
public class Cinemachine.OrbitalTransposerHeadingPropertyAttribute : PropertyAttribute {
}
[SaveDuringPlayAttribute]
[AddComponentMenu("")]
public class Cinemachine.PostFX.CinemachinePostProcessing : CinemachineExtension {
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
}
[AddComponentMenu("")]
public class Cinemachine.PostFX.CinemachineVolumeSettings : MonoBehaviour {
}
[DocumentationSortingAttribute("0")]
public static class Cinemachine.RuntimeUtility : object {
    
private static RaycastHit[] s_HitBuffer;
    
private static Int32[] s_PenetrationIndexBuffer;
    
private static SphereCollider s_ScratchCollider;
    
private static GameObject s_ScratchColliderGameObject;
    private static RuntimeUtility();
    public static void DestroyObject(Object obj);
    public static bool IsPrefab(GameObject gameObject);
    public static bool RaycastIgnoreTag(Ray ray, RaycastHit& hitInfo, float rayLength, int layerMask, String& ignoreTag);
    public static bool SphereCastIgnoreTag(Vector3 rayStart, float radius, Vector3 dir, RaycastHit& hitInfo, float rayLength, int layerMask, String& ignoreTag);
    internal static SphereCollider GetScratchCollider();
    internal static void DestroyScratchCollider();
    public static AnimationCurve NormalizeCurve(AnimationCurve curve, bool normalizeX, bool normalizeY);
}
public class Cinemachine.SaveDuringPlayAttribute : Attribute {
}
[DocumentationSortingAttribute("1")]
public abstract class Cinemachine.SignalSourceAsset : ScriptableObject {
    
public float SignalDuration { get; }
    public abstract virtual float get_SignalDuration();
    public abstract virtual void GetSignal(float timeSinceSignalStart, Vector3& pos, Quaternion& rot);
}
internal class Cinemachine.StaticPointVirtualCamera : object {
    [CompilerGeneratedAttribute]

private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]

private Transform <LookAt>k__BackingField;
    [CompilerGeneratedAttribute]

private Transform <Follow>k__BackingField;
    [CompilerGeneratedAttribute]

private CameraState <State>k__BackingField;
    
public string Name { get; private set; }
    
public string Description { get; }
    
public int Priority { get; public set; }
    
public Transform LookAt { get; public set; }
    
public Transform Follow { get; public set; }
    
public CameraState State { get; private set; }
    
public GameObject VirtualCameraGameObject { get; }
    
public bool IsValid { get; }
    
public ICinemachineCamera ParentCamera { get; }
    public StaticPointVirtualCamera(CameraState state, string name);
    public void SetState(CameraState state);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Transform get_LookAt();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LookAt(Transform value);
    [CompilerGeneratedAttribute]
public sealed virtual Transform get_Follow();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Follow(Transform value);
    [CompilerGeneratedAttribute]
public sealed virtual CameraState get_State();
    [CompilerGeneratedAttribute]
private void set_State(CameraState value);
    public sealed virtual GameObject get_VirtualCameraGameObject();
    public sealed virtual bool get_IsValid();
    public sealed virtual ICinemachineCamera get_ParentCamera();
    public sealed virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly);
    public sealed virtual void UpdateCameraState(Vector3 worldUp, float deltaTime);
    public sealed virtual void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);
    public sealed virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);
    public sealed virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
}
public class Cinemachine.TagFieldAttribute : PropertyAttribute {
}
internal class Cinemachine.TargetPositionCache : object {
    
public static bool UseCache;
    
public static float CacheStepSize;
    
private static Mode m_CacheMode;
    
public static float CurrentTime;
    
public static int CurrentFrame;
    
public static bool IsCameraCut;
    
private static Dictionary`2<Transform, CacheEntry> m_Cache;
    
private static TimeRange m_CacheTimeRange;
    
private static float kWraparoundSlush;
    
public static Mode CacheMode { get; public set; }
    
public static bool IsRecording { get; }
    
public static bool CurrentPlaybackTimeValid { get; }
    
public static bool IsEmpty { get; }
    
public static TimeRange CacheTimeRange { get; }
    
public static bool HasCurrentTime { get; }
    public static Mode get_CacheMode();
    public static void set_CacheMode(Mode value);
    public static bool get_IsRecording();
    public static bool get_CurrentPlaybackTimeValid();
    public static bool get_IsEmpty();
    public static TimeRange get_CacheTimeRange();
    public static bool get_HasCurrentTime();
    public static void ClearCache();
    private static void CreatePlaybackCurves();
    public static Vector3 GetTargetPosition(Transform target);
    public static Quaternion GetTargetRotation(Transform target);
}
[DocumentationSortingAttribute("0")]
internal class Cinemachine.UpdateTracker : object {
    
private static Dictionary`2<Transform, UpdateStatus> mUpdateStatus;
    
private static List`1<Transform> sToDelete;
    
private static float mLastUpdateTime;
    private static UpdateTracker();
    [RuntimeInitializeOnLoadMethodAttribute]
private static void InitializeModule();
    private static void UpdateTargets(UpdateClock currentClock);
    public static UpdateClock GetPreferredUpdate(Transform target);
    public static void OnUpdate(UpdateClock currentClock);
}
public class Cinemachine.Utility.CinemachineDebug : object {
    
private static HashSet`1<Object> mClients;
    
public static OnGUIDelegate OnGUIHandlers;
    
private static List`1<StringBuilder> mAvailableStringBuilders;
    public static void ReleaseScreenPos(Object client);
    public static Rect GetScreenPos(Object client, string text, GUIStyle style);
    public static StringBuilder SBFromPool();
    public static void ReturnToPool(StringBuilder sb);
}
public static class Cinemachine.Utility.Damper : object {
    
private static float Epsilon;
    
public static float kNegligibleResidual;
    
private static float kLogNegligibleResidual;
    private static float DecayConstant(float time, float residual);
    private static float DecayedRemainder(float initial, float decayConstant, float deltaTime);
    public static float Damp(float initial, float dampTime, float deltaTime);
    public static Vector3 Damp(Vector3 initial, Vector3 dampTime, float deltaTime);
    public static Vector3 Damp(Vector3 initial, float dampTime, float deltaTime);
}
internal class Cinemachine.Utility.GaussianWindow1D_CameraRotation : GaussianWindow1d`1<Vector2> {
    public GaussianWindow1D_CameraRotation(float sigma, int maxKernelRadius);
    protected virtual Vector2 Compute(int windowPos);
}
internal class Cinemachine.Utility.GaussianWindow1D_Quaternion : GaussianWindow1d`1<Quaternion> {
    public GaussianWindow1D_Quaternion(float sigma, int maxKernelRadius);
    protected virtual Quaternion Compute(int windowPos);
}
internal class Cinemachine.Utility.GaussianWindow1D_Vector3 : GaussianWindow1d`1<Vector3> {
    public GaussianWindow1D_Vector3(float sigma, int maxKernelRadius);
    protected virtual Vector3 Compute(int windowPos);
}
internal abstract class Cinemachine.Utility.GaussianWindow1d`1 : object {
    
protected T[] mData;
    
protected Single[] mKernel;
    
protected int mCurrentPos;
    [CompilerGeneratedAttribute]

private float <Sigma>k__BackingField;
    
public float Sigma { get; private set; }
    
public int KernelSize { get; }
    
public int BufferLength { get; }
    public GaussianWindow1d`1(float sigma, int maxKernelRadius);
    [CompilerGeneratedAttribute]
public float get_Sigma();
    [CompilerGeneratedAttribute]
private void set_Sigma(float value);
    public int get_KernelSize();
    private void GenerateKernel(float sigma, int maxKernelRadius);
    protected abstract virtual T Compute(int windowPos);
    public void Reset();
    public bool IsEmpty();
    public void AddValue(T v);
    public T Filter(T v);
    public T Value();
    public int get_BufferLength();
    public void SetBufferValue(int index, T value);
    public T GetBufferValue(int index);
}
public class Cinemachine.Utility.HeadingTracker : object {
    
private Item[] mHistory;
    
private int mTop;
    
private int mBottom;
    
private int mCount;
    
private Vector3 mHeadingSum;
    
private float mWeightSum;
    
private float mWeightTime;
    
private Vector3 mLastGoodHeading;
    
private static float mDecayExponent;
    
public int FilterSize { get; }
    public HeadingTracker(int filterSize);
    public int get_FilterSize();
    private void ClearHistory();
    private static float Decay(float time);
    public void Add(Vector3 velocity);
    private void PopBottom();
    public void DecayHistory();
    public Vector3 GetReliableHeading();
}
public class Cinemachine.Utility.PositionPredictor : object {
    
private Vector3 m_Velocity;
    
private Vector3 m_SmoothDampVelocity;
    
private Vector3 m_Pos;
    
private bool m_HavePos;
    
public float Smoothing;
    public bool IsEmpty();
    public void ApplyTransformDelta(Vector3 positionDelta);
    public void Reset();
    public void AddPosition(Vector3 pos, float deltaTime, float lookaheadTime);
    public Vector3 PredictPositionDelta(float lookaheadTime);
    public Vector3 PredictPosition(float lookaheadTime);
}
public static class Cinemachine.Utility.SplineHelpers : object {
    public static Vector3 Bezier3(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3);
    public static Vector3 BezierTangent3(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3);
    public static void BezierTangentWeights3(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, Vector3& w0, Vector3& w1, Vector3& w2);
    public static float Bezier1(float t, float p0, float p1, float p2, float p3);
    public static float BezierTangent1(float t, float p0, float p1, float p2, float p3);
    public static void ComputeSmoothControlPoints(Vector4[]& knot, Vector4[]& ctrl1, Vector4[]& ctrl2);
    public static void ComputeSmoothControlPointsLooped(Vector4[]& knot, Vector4[]& ctrl1, Vector4[]& ctrl2);
}
[ExtensionAttribute]
public static class Cinemachine.Utility.UnityQuaternionExtensions : object {
    public static Quaternion SlerpWithReferenceUp(Quaternion qA, Quaternion qB, float t, Vector3 up);
    [ExtensionAttribute]
public static Quaternion Normalized(Quaternion q);
    [ExtensionAttribute]
public static Vector2 GetCameraRotationToTarget(Quaternion orient, Vector3 lookAtDir, Vector3 worldUp);
    [ExtensionAttribute]
public static Quaternion ApplyCameraRotation(Quaternion orient, Vector2 rot, Vector3 worldUp);
}
[ExtensionAttribute]
public static class Cinemachine.Utility.UnityRectExtensions : object {
    [ExtensionAttribute]
public static Rect Inflated(Rect r, Vector2 delta);
}
[ExtensionAttribute]
public static class Cinemachine.Utility.UnityVectorExtensions : object {
    
public static float Epsilon;
    [ExtensionAttribute]
public static bool IsNaN(Vector2 v);
    [ExtensionAttribute]
public static bool IsNaN(Vector3 v);
    [ExtensionAttribute]
public static float ClosestPointOnSegment(Vector3 p, Vector3 s0, Vector3 s1);
    [ExtensionAttribute]
public static float ClosestPointOnSegment(Vector2 p, Vector2 s0, Vector2 s1);
    [ExtensionAttribute]
public static Vector3 ProjectOntoPlane(Vector3 vector, Vector3 planeNormal);
    [ExtensionAttribute]
public static Vector2 SquareNormalize(Vector2 v);
    public static int FindIntersection(Vector2& p1, Vector2& p2, Vector2& q1, Vector2& q2, Vector2& intersection);
    [ExtensionAttribute]
private static float Cross(Vector2 v1, Vector2 v2);
    [ExtensionAttribute]
public static Vector2 Abs(Vector2 v);
    [ExtensionAttribute]
public static Vector3 Abs(Vector3 v);
    [ExtensionAttribute]
public static bool IsUniform(Vector2 v);
    [ExtensionAttribute]
public static bool IsUniform(Vector3 v);
    [ExtensionAttribute]
public static bool AlmostZero(Vector3 v);
    [ExtensionAttribute]
internal static void ConservativeSetPositionAndRotation(Transform t, Vector3 pos, Quaternion rot);
    public static float Angle(Vector3 v1, Vector3 v2);
    public static float SignedAngle(Vector3 v1, Vector3 v2, Vector3 up);
    public static Quaternion SafeFromToRotation(Vector3 v1, Vector3 v2, Vector3 up);
    public static Vector3 SlerpWithReferenceUp(Vector3 vA, Vector3 vB, float t, Vector3 up);
}
public class Cinemachine.VcamTargetPropertyAttribute : PropertyAttribute {
}
[AddComponentMenu("")]
[ExecuteAlways]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/api/Cinemachine.CinemachineCameraOffset.html")]
[SaveDuringPlayAttribute]
public class CinemachineCameraOffset : CinemachineExtension {
    [TooltipAttribute("Offset the camera's position by this much (camera space)")]

public Vector3 m_Offset;
    [TooltipAttribute("When to apply the offset")]

public Stage m_ApplyAfter;
    [TooltipAttribute("If applying offset after aim, re-adjust the aim to preserve the screen position of the LookAt target as much as possible")]

public bool m_PreserveComposition;
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
}
internal class CinemachineMixer : PlayableBehaviour {
    
public static MasterDirectorDelegate GetMasterPlayableDirector;
    
private ICameraOverrideStack m_BrainOverrideStack;
    
private int m_BrainOverrideId;
    
private bool m_PreviewPlay;
    public virtual void OnPlayableDestroy(Playable playable);
    public virtual void PrepareFrame(Playable playable, FrameData info);
    public virtual void ProcessFrame(Playable playable, FrameData info, object playerData);
    private float GetDeltaTime(float deltaTime);
}
[AddComponentMenu("")]
[ExecuteAlways]
[SaveDuringPlayAttribute]
[HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineRecomposer.html")]
public class CinemachineRecomposer : CinemachineExtension {
    [TooltipAttribute("When to apply the adjustment")]

public Stage m_ApplyAfter;
    [TooltipAttribute("Tilt the camera by this much")]

public float m_Tilt;
    [TooltipAttribute("Pan the camera by this much")]

public float m_Pan;
    [TooltipAttribute("Roll the camera by this much")]

public float m_Dutch;
    [TooltipAttribute("Scale the zoom by this amount (normal = 1)")]

public float m_ZoomScale;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Lowering this value relaxes the camera's attention to the Follow target (normal = 1)")]

public float m_FollowAttachment;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Lowering this value relaxes the camera's attention to the LookAt target (normal = 1)")]

public float m_LookAtAttachment;
    private void Reset();
    private void OnValidate();
    public virtual void PrePipelineMutateCameraStateCallback(CinemachineVirtualCameraBase vcam, CameraState& curState, float deltaTime);
    protected virtual void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime);
}
public class CinemachineShot : PlayableAsset {
    
public string DisplayName;
    
public ExposedReference`1<CinemachineVirtualCameraBase> VirtualCamera;
    public virtual Playable CreatePlayable(PlayableGraph graph, GameObject owner);
    public sealed virtual void GatherProperties(PlayableDirector director, IPropertyCollector driver);
}
internal class CinemachineShotPlayable : PlayableBehaviour {
    
public CinemachineVirtualCameraBase VirtualCamera;
    
public bool IsValid { get; }
    public bool get_IsValid();
}
public class CinemachineTouchInputMapper : MonoBehaviour {
    [TooltipAttribute("Sensitivity multiplier for x-axis")]

public float TouchSensitivityX;
    [TooltipAttribute("Sensitivity multiplier for y-axis")]

public float TouchSensitivityY;
    [TooltipAttribute("Input channel to spoof for X axis")]

public string TouchXInputMapTo;
    [TooltipAttribute("Input channel to spoof for Y axis")]

public string TouchYInputMapTo;
    private void Start();
    private float GetInputAxis(string axisName);
}
[TrackClipTypeAttribute("CinemachineShot")]
[TrackBindingTypeAttribute("Cinemachine.CinemachineBrain", "0")]
[TrackColorAttribute("0,53", "0", "0,08")]
public class CinemachineTrack : TrackAsset {
    public virtual Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount);
}
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
[GeneratedCodeAttribute("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", "")]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1 : object {
    private static MonoScriptData Get();
}
