public Cinemachine.AxisBase : ValueType {
public float m_Value
public float m_MinValue
public float m_MaxValue
public bool m_Wrap
public void Validate()
}
public Cinemachine.AxisState : ValueType {
public float Value
public SpeedMode m_SpeedMode
public float m_MaxSpeed
public float m_AccelTime
public float m_DecelTime
public string m_InputAxisName
public float m_InputAxisValue
public bool m_InvertInput
public float m_MinValue
public float m_MaxValue
public bool m_Wrap
public Recentering m_Recentering
private float m_CurrentSpeed
private float m_LastUpdateTime
private int m_LastUpdateFrame
private float Epsilon
private IInputAxisProvider m_InputAxisProvider
private int m_InputAxisIndex
private bool <ValueRangeLocked>k__BackingField
private bool <HasRecentering>k__BackingField
public bool HasInputProvider
public bool ValueRangeLocked
public bool HasRecentering
public void .ctor(float minValue, float maxValue, bool wrap, bool rangeLocked, float maxSpeed, float accelTime, float decelTime, string name, bool invert)
public void Validate()
public void Reset()
public void SetInputAxisProvider(int axis, IInputAxisProvider provider)
public bool get_HasInputProvider()
public bool Update(float deltaTime)
private float ClampValue(float v)
private bool MaxSpeedUpdate(float input, float deltaTime)
private float GetMaxSpeed()
public bool get_ValueRangeLocked()
public void set_ValueRangeLocked(bool value)
public bool get_HasRecentering()
public void set_HasRecentering(bool value)
}
internal Cinemachine.BlendSourceVirtualCamera : object {
private CinemachineBlend <Blend>k__BackingField
private int <Priority>k__BackingField
private Transform <LookAt>k__BackingField
private Transform <Follow>k__BackingField
private CameraState <State>k__BackingField
public CinemachineBlend Blend
public string Name
public string Description
public int Priority
public Transform LookAt
public Transform Follow
public CameraState State
public GameObject VirtualCameraGameObject
public bool IsValid
public ICinemachineCamera ParentCamera
public void .ctor(CinemachineBlend blend)
public CinemachineBlend get_Blend()
public void set_Blend(CinemachineBlend value)
public string get_Name()
public string get_Description()
public int get_Priority()
public void set_Priority(int value)
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public CameraState get_State()
private void set_State(CameraState value)
public GameObject get_VirtualCameraGameObject()
public bool get_IsValid()
public ICinemachineCamera get_ParentCamera()
public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly)
public CameraState CalculateNewState(float deltaTime)
public void UpdateCameraState(Vector3 worldUp, float deltaTime)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
}
public Cinemachine.CameraState : ValueType {
public LensSettings Lens
public Vector3 ReferenceUp
public Vector3 ReferenceLookAt
public Vector3 kNoPoint
public Vector3 RawPosition
public Quaternion RawOrientation
public Vector3 PositionDampingBypass
public float ShotQuality
public Vector3 PositionCorrection
public Quaternion OrientationCorrection
public BlendHintValue BlendHint
private CustomBlendable mCustom0
private CustomBlendable mCustom1
private CustomBlendable mCustom2
private CustomBlendable mCustom3
private List`1<CustomBlendable> m_CustomOverflow
private int <NumCustomBlendables>k__BackingField
public bool HasLookAt
public Vector3 CorrectedPosition
public Quaternion CorrectedOrientation
public Vector3 FinalPosition
public Quaternion FinalOrientation
public CameraState Default
public int NumCustomBlendables
public bool get_HasLookAt()
public Vector3 get_CorrectedPosition()
public Quaternion get_CorrectedOrientation()
public Vector3 get_FinalPosition()
public Quaternion get_FinalOrientation()
public CameraState get_Default()
public int get_NumCustomBlendables()
private void set_NumCustomBlendables(int value)
public CustomBlendable GetCustomBlendable(int index)
private int FindCustomBlendable(Object custom)
public void AddCustomBlendable(CustomBlendable b)
public CameraState Lerp(CameraState stateA, CameraState stateB, float t)
private float InterpolateFOV(float fovA, float fovB, float dA, float dB, float t)
private Vector3 ApplyPosBlendHint(Vector3 posA, BlendHintValue hintA, Vector3 posB, BlendHintValue hintB, Vector3 original, Vector3 blended)
private Quaternion ApplyRotBlendHint(Quaternion rotA, BlendHintValue hintA, Quaternion rotB, BlendHintValue hintB, Quaternion original, Quaternion blended)
private Vector3 InterpolatePosition(Vector3 posA, Vector3 pivotA, Vector3 posB, Vector3 pivotB, float t)
}
public Cinemachine.Cinemachine3rdPersonAim : CinemachineExtension {
public LayerMask AimCollisionFilter
public string IgnoreTag
public float AimDistance
public RectTransform AimTargetReticle
private Vector3 <AimTarget>k__BackingField
public Vector3 AimTarget
public Vector3 get_AimTarget()
private void set_AimTarget(Vector3 value)
private void OnValidate()
private void Reset()
public bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
private void DrawReticle(CinemachineBrain brain)
private Vector3 ComputeLookAtPoint(Vector3 camPos, Transform player)
private Vector3 ComputeAimTarget(Vector3 cameraLookAt, Transform player)
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
}
public Cinemachine.Cinemachine3rdPersonFollow : CinemachineComponentBase {
public Vector3 Damping
public Vector3 ShoulderOffset
public float VerticalArmLength
public float CameraSide
public float CameraDistance
public LayerMask CameraCollisionFilter
public string IgnoreTag
public float CameraRadius
public float DampingIntoCollision
public float DampingFromCollision
private Vector3 m_PreviousFollowTargetPosition
private Vector3 m_DampingCorrection
private float m_CamPosCollisionCorrection
public bool IsValid
public Stage Stage
private void OnValidate()
private void Reset()
private void OnDestroy()
public bool get_IsValid()
public Stage get_Stage()
public float GetMaxDampTime()
public void MutateCameraState(CameraState& curState, float deltaTime)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
private void PositionCamera(CameraState& curState, float deltaTime)
public void GetRigPositions(Vector3& root, Vector3& shoulder, Vector3& hand)
internal Quaternion GetHeading(Quaternion targetRot, Vector3 up)
private void GetRawRigPositions(Vector3 root, Quaternion targetRot, Quaternion heading, Vector3& shoulder, Vector3& hand)
private Vector3 ResolveCollisions(Vector3 root, Vector3 tip, float deltaTime, float cameraRadius, Single& collisionCorrection)
}
public Cinemachine.CinemachineBasicMultiChannelPerlin : CinemachineComponentBase {
public NoiseSettings m_NoiseProfile
public Vector3 m_PivotOffset
public float m_AmplitudeGain
public float m_FrequencyGain
private bool mInitialized
private float mNoiseTime
private Vector3 mNoiseOffsets
public bool IsValid
public Stage Stage
public bool get_IsValid()
public Stage get_Stage()
public void MutateCameraState(CameraState& curState, float deltaTime)
public void ReSeed()
private void Initialize()
}
public Cinemachine.CinemachineBlend : object {
public ICinemachineCamera CamA
public ICinemachineCamera CamB
public AnimationCurve BlendCurve
public float TimeInBlend
public float Duration
public float BlendWeight
public bool IsValid
public bool IsComplete
public string Description
public CameraState State
public float get_BlendWeight()
public bool get_IsValid()
public bool get_IsComplete()
public string get_Description()
public bool Uses(ICinemachineCamera cam)
public void .ctor(ICinemachineCamera a, ICinemachineCamera b, AnimationCurve curve, float duration, float t)
public void UpdateCameraState(Vector3 worldUp, float deltaTime)
public CameraState get_State()
}
public Cinemachine.CinemachineBlendDefinition : ValueType {
public Style m_Style
public float m_Time
public AnimationCurve m_CustomCurve
private AnimationCurve[] sStandardCurves
public float BlendTime
public AnimationCurve BlendCurve
public float get_BlendTime()
public void .ctor(Style style, float time)
private void CreateStandardCurves()
public AnimationCurve get_BlendCurve()
}
public Cinemachine.CinemachineBlenderSettings : ScriptableObject {
public CustomBlend[] m_CustomBlends
public string kBlendFromAnyCameraLabel
public CinemachineBlendDefinition GetBlendForVirtualCameras(string fromCameraName, string toCameraName, CinemachineBlendDefinition defaultBlend)
}
public Cinemachine.CinemachineBlendListCamera : CinemachineVirtualCameraBase {
public Transform m_LookAt
public Transform m_Follow
public bool m_ShowDebugText
public bool m_Loop
internal CinemachineVirtualCameraBase[] m_ChildCameras
public Instruction[] m_Instructions
private ICinemachineCamera <LiveChild>k__BackingField
private ICinemachineCamera m_TransitioningFrom
private CameraState m_State
private float mActivationTime
private int mCurrentInstruction
private CinemachineBlend mActiveBlend
public string Description
public ICinemachineCamera LiveChild
public CameraState State
public Transform LookAt
public Transform Follow
public CinemachineVirtualCameraBase[] ChildCameras
public bool IsBlending
public string get_Description()
private void Reset()
public ICinemachineCamera get_LiveChild()
public void set_LiveChild(ICinemachineCamera value)
public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly)
public CameraState get_State()
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
protected void OnEnable()
protected void OnDisable()
private void OnTransformChildrenChanged()
private void OnGuiHandler()
public CinemachineVirtualCameraBase[] get_ChildCameras()
public bool get_IsBlending()
private void InvalidateListOfChildren()
private void UpdateListOfChildren()
internal void ValidateInstructions()
private void AdvanceCurrentInstruction(float deltaTime)
}
public Cinemachine.CinemachineBrain : MonoBehaviour {
public bool m_ShowDebugText
public bool m_ShowCameraFrustum
public bool m_IgnoreTimeScale
public Transform m_WorldUpOverride
public UpdateMethod m_UpdateMethod
public BrainUpdateMethod m_BlendUpdateMethod
public CinemachineBlendDefinition m_DefaultBlend
public CinemachineBlenderSettings m_CustomBlends
private Camera m_OutputCamera
private GameObject m_TargetOverride
public BrainEvent m_CameraCutEvent
public VcamActivatedEvent m_CameraActivatedEvent
private ICinemachineCamera mSoloCamera
private Coroutine mPhysicsCoroutine
private int m_LastFrameUpdated
private WaitForFixedUpdate mWaitForFixedUpdate
private List`1<BrainFrame> mFrameStack
private int mNextFrameId
private CinemachineBlend mCurrentLiveCameras
private AnimationCurve mDefaultLinearAnimationCurve
private ICinemachineCamera mActiveCameraPreviousFrame
private GameObject mActiveCameraPreviousFrameGameObject
private CameraState <CurrentCameraState>k__BackingField
public Camera OutputCamera
public GameObject ControlledObject
public ICinemachineCamera SoloCamera
public Vector3 DefaultWorldUp
public ICinemachineCamera ActiveVirtualCamera
public bool IsBlending
public CinemachineBlend ActiveBlend
public CameraState CurrentCameraState
public Camera get_OutputCamera()
public GameObject get_ControlledObject()
public void set_ControlledObject(GameObject value)
public ICinemachineCamera get_SoloCamera()
public void set_SoloCamera(ICinemachineCamera value)
public Color GetSoloGUIColor()
public Vector3 get_DefaultWorldUp()
private void OnEnable()
private void OnDisable()
private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
private void OnSceneUnloaded(Scene scene)
private void Awake()
private void Start()
private void OnGuiHandler()
private IEnumerator AfterPhysics()
private void LateUpdate()
public void ManualUpdate()
private float GetEffectiveDeltaTime(bool fixedDelta)
private void UpdateVirtualCameras(UpdateFilter updateFilter, float deltaTime)
public ICinemachineCamera get_ActiveVirtualCamera()
private ICinemachineCamera DeepCamBFromBlend(CinemachineBlend blend)
public bool IsLiveInBlend(ICinemachineCamera vcam)
public bool get_IsBlending()
public CinemachineBlend get_ActiveBlend()
public void set_ActiveBlend(CinemachineBlend value)
private int GetBrainFrame(int withId)
public int SetCameraOverride(int overrideId, ICinemachineCamera camA, ICinemachineCamera camB, float weightB, float deltaTime)
public void ReleaseCameraOverride(int overrideId)
private void ProcessActiveCamera(float deltaTime)
private void UpdateFrame0(float deltaTime)
public void ComputeCurrentBlend(CinemachineBlend& outputBlend, int numTopLayersToExclude)
public bool IsLive(ICinemachineCamera vcam, bool dominantChildOnly)
public CameraState get_CurrentCameraState()
private void set_CurrentCameraState(CameraState value)
protected ICinemachineCamera TopCameraFromPriorityQueue()
private CinemachineBlendDefinition LookupBlend(ICinemachineCamera fromKey, ICinemachineCamera toKey)
private void PushStateToUnityCamera(CameraState& state)
}
public Cinemachine.CinemachineClearShot : CinemachineVirtualCameraBase {
public Transform m_LookAt
public Transform m_Follow
public bool m_ShowDebugText
internal CinemachineVirtualCameraBase[] m_ChildCameras
public float m_ActivateAfter
public float m_MinDuration
public bool m_RandomizeChoice
public CinemachineBlendDefinition m_DefaultBlend
public CinemachineBlenderSettings m_CustomBlends
private ICinemachineCamera <LiveChild>k__BackingField
private CameraState m_State
private float mActivationTime
private float mPendingActivationTime
private ICinemachineCamera mPendingCamera
private CinemachineBlend mActiveBlend
private bool mRandomizeNow
private CinemachineVirtualCameraBase[] m_RandomizedChilden
private ICinemachineCamera m_TransitioningFrom
public string Description
public ICinemachineCamera LiveChild
public CameraState State
public Transform LookAt
public Transform Follow
public bool IsBlending
public CinemachineBlend ActiveBlend
public CinemachineVirtualCameraBase[] ChildCameras
public string get_Description()
public ICinemachineCamera get_LiveChild()
public void set_LiveChild(ICinemachineCamera value)
public CameraState get_State()
public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly)
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
protected void OnEnable()
protected void OnDisable()
public void OnTransformChildrenChanged()
private void OnGuiHandler()
public bool get_IsBlending()
public CinemachineBlend get_ActiveBlend()
public CinemachineVirtualCameraBase[] get_ChildCameras()
private void InvalidateListOfChildren()
public void ResetRandomization()
private void UpdateListOfChildren()
private ICinemachineCamera ChooseCurrentCamera(Vector3 worldUp)
private CinemachineVirtualCameraBase[] Randomize(CinemachineVirtualCameraBase[] src)
private CinemachineBlendDefinition LookupBlend(ICinemachineCamera fromKey, ICinemachineCamera toKey)
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
}
public Cinemachine.CinemachineCollider : CinemachineExtension {
public LayerMask m_CollideAgainst
public string m_IgnoreTag
public LayerMask m_TransparentLayers
public float m_MinimumDistanceFromTarget
public bool m_AvoidObstacles
public float m_DistanceLimit
public float m_MinimumOcclusionTime
public float m_CameraRadius
public ResolutionStrategy m_Strategy
public int m_MaximumEffort
public float m_SmoothingTime
public float m_Damping
public float m_DampingWhenOccluded
public float m_OptimalTargetDistance
private float k_PrecisionSlush
private RaycastHit[] m_CornerBuffer
private float k_AngleThreshold
private Collider[] s_ColliderBuffer
public List`1<List`1<Vector3>> DebugPaths
public bool IsTargetObscured(ICinemachineCamera vcam)
public bool CameraWasDisplaced(ICinemachineCamera vcam)
public float GetCameraDisplacementDistance(ICinemachineCamera vcam)
private void OnValidate()
protected void OnDestroy()
public List`1<List`1<Vector3>> get_DebugPaths()
public float GetMaxDampTime()
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
private Vector3 PreserveLineOfSight(CameraState& state, VcamExtraState& extra)
private Vector3 PullCameraInFrontOfNearestObstacle(Vector3 cameraPos, Vector3 lookAtPos, int layerMask, RaycastHit& hitInfo)
private Vector3 PushCameraBack(Vector3 currentPos, Vector3 pushDir, RaycastHit obstacle, Vector3 lookAtPos, Plane startPlane, float targetDistance, int iterations, VcamExtraState& extra)
private bool GetWalkingDirection(Vector3 pos, Vector3 pushDir, RaycastHit obstacle, Vector3& outDir)
private float GetPushBackDistance(Ray ray, Plane startPlane, float targetDistance, Vector3 lookAtPos)
private float ClampRayToBounds(Ray ray, float distance, Bounds bounds)
private Vector3 RespectCameraRadius(Vector3 cameraPos, Vector3 lookAtPos)
private bool CheckForTargetObstructions(CameraState state)
private bool IsTargetOffscreen(CameraState state)
}
public Cinemachine.CinemachineCollisionImpulseSource : CinemachineImpulseSource {
public LayerMask m_LayerMask
public string m_IgnoreTag
public bool m_UseImpactDirection
public bool m_ScaleImpactWithMass
public bool m_ScaleImpactWithSpeed
private Rigidbody mRigidBody
private Rigidbody2D mRigidBody2D
private void Start()
private void OnEnable()
private void OnCollisionEnter(Collision c)
private void OnTriggerEnter(Collider c)
private float GetMassAndVelocity(Collider other, Vector3& vel)
private void GenerateImpactEvent(Collider other, Vector3 vel)
private void OnCollisionEnter2D(Collision2D c)
private void OnTriggerEnter2D(Collider2D c)
private float GetMassAndVelocity2D(Collider2D other2d, Vector3& vel)
private void GenerateImpactEvent2D(Collider2D other2d, Vector3 vel)
}
public Cinemachine.CinemachineComponentBase : MonoBehaviour {
protected float Epsilon
private CinemachineVirtualCameraBase m_vcamOwner
public CinemachineVirtualCameraBase VirtualCamera
public Transform FollowTarget
public Transform LookAtTarget
public ICinemachineTargetGroup AbstractFollowTargetGroup
public CinemachineTargetGroup FollowTargetGroup
public Vector3 FollowTargetPosition
public Quaternion FollowTargetRotation
public ICinemachineTargetGroup AbstractLookAtTargetGroup
public CinemachineTargetGroup LookAtTargetGroup
public Vector3 LookAtTargetPosition
public Quaternion LookAtTargetRotation
public CameraState VcamState
public bool IsValid
public Stage Stage
public bool BodyAppliesAfterAim
public bool RequiresUserInput
public CinemachineVirtualCameraBase get_VirtualCamera()
public Transform get_FollowTarget()
public Transform get_LookAtTarget()
public ICinemachineTargetGroup get_AbstractFollowTargetGroup()
public CinemachineTargetGroup get_FollowTargetGroup()
public Vector3 get_FollowTargetPosition()
public Quaternion get_FollowTargetRotation()
public ICinemachineTargetGroup get_AbstractLookAtTargetGroup()
public CinemachineTargetGroup get_LookAtTargetGroup()
public Vector3 get_LookAtTargetPosition()
public Quaternion get_LookAtTargetRotation()
public CameraState get_VcamState()
public bool get_IsValid()
public void PrePipelineMutateCameraState(CameraState& curState, float deltaTime)
public Stage get_Stage()
public bool get_BodyAppliesAfterAim()
public void MutateCameraState(CameraState& curState, float deltaTime)
public bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, TransitionParams& transitionParams)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public float GetMaxDampTime()
public bool get_RequiresUserInput()
}
public Cinemachine.CinemachineComposer : CinemachineComponentBase {
public Vector3 m_TrackedObjectOffset
public float m_LookaheadTime
public float m_LookaheadSmoothing
public bool m_LookaheadIgnoreY
public float m_HorizontalDamping
public float m_VerticalDamping
public float m_ScreenX
public float m_ScreenY
public float m_DeadZoneWidth
public float m_DeadZoneHeight
public float m_SoftZoneWidth
public float m_SoftZoneHeight
public float m_BiasX
public float m_BiasY
public bool m_CenterOnActivate
private Vector3 <TrackedPoint>k__BackingField
private Vector3 m_CameraPosPrevFrame
private Vector3 m_LookAtPrevFrame
private Vector2 m_ScreenOffsetPrevFrame
private Quaternion m_CameraOrientationPrevFrame
internal PositionPredictor m_Predictor
private FovCache mCache
public bool IsValid
public Stage Stage
public Vector3 TrackedPoint
internal Rect SoftGuideRect
internal Rect HardGuideRect
public bool get_IsValid()
public Stage get_Stage()
public Vector3 get_TrackedPoint()
private void set_TrackedPoint(Vector3 value)
protected Vector3 GetLookAtPointAndSetTrackedPoint(Vector3 lookAt, Vector3 up, float deltaTime)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public float GetMaxDampTime()
public void PrePipelineMutateCameraState(CameraState& curState, float deltaTime)
public void MutateCameraState(CameraState& curState, float deltaTime)
internal Rect get_SoftGuideRect()
internal void set_SoftGuideRect(Rect value)
internal Rect get_HardGuideRect()
internal void set_HardGuideRect(Rect value)
private void RotateToScreenBounds(CameraState& state, Rect screenRect, Vector3 trackedPoint, Quaternion& rigOrientation, float fov, float fovH, float deltaTime)
private bool ClampVerticalBounds(Rect& r, Vector3 dir, Vector3 up, float fov)
}
public Cinemachine.CinemachineConfiner : CinemachineExtension {
public Mode m_ConfineMode
public Collider m_BoundingVolume
public Collider2D m_BoundingShape2D
private Collider2D m_BoundingShape2DCache
public bool m_ConfineScreenEdges
public float m_Damping
private List`1<List`1<Vector2>> m_pathCache
private int m_pathTotalPointCount
public bool IsValid
public bool CameraWasDisplaced(CinemachineVirtualCameraBase vcam)
public float GetCameraDisplacementDistance(CinemachineVirtualCameraBase vcam)
private void OnValidate()
protected void ConnectToVcam(bool connect)
public bool get_IsValid()
public float GetMaxDampTime()
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
public void InvalidatePathCache()
private bool ValidatePathCache()
private Vector3 ConfinePoint(Vector3 camPos)
private Vector3 ConfineScreenEdges(CameraState& state)
}
public Cinemachine.CinemachineConfiner2D : CinemachineExtension {
public Collider2D m_BoundingShape2D
public float m_Damping
public float m_MaxWindowSize
private float m_MaxComputationTimePerFrameInSeconds
private float k_cornerAngleTreshold
private ShapeCache m_shapeCache
public void InvalidateCache()
public bool ValidateCache(float cameraAspectRatio)
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
private float CalculateHalfFrustumHeight(CameraState& state, Single& cameraPosLocalZ)
private void OnValidate()
private void Reset()
}
public Cinemachine.CinemachineCore : object {
public int kStreamingVersion
private CinemachineCore sInstance
public bool sShowHiddenObjects
public AxisInputDelegate GetInputAxis
public float UniformDeltaTimeOverride
public float CurrentTimeOverride
public GetBlendOverrideDelegate GetBlendOverride
public BrainEvent CameraUpdatedEvent
public BrainEvent CameraCutEvent
private List`1<CinemachineBrain> mActiveBrains
internal bool FrameDeltaCompensationEnabled
private List`1<CinemachineVirtualCameraBase> mActiveCameras
private bool m_ActiveCamerasAreSorted
private int m_ActivationSequence
private List`1<List`1<CinemachineVirtualCameraBase>> mAllCameras
private CinemachineVirtualCameraBase mRoundRobinVcamLastFrame
private float s_LastUpdateTime
private int s_FixedFrameCount
private Dictionary`2<CinemachineVirtualCameraBase, UpdateStatus> mUpdateStatus
internal UpdateFilter m_CurrentUpdateFilter
public CinemachineCore Instance
public float DeltaTime
public float CurrentTime
public int BrainCount
public int VirtualCameraCount
public CinemachineCore get_Instance()
public float get_DeltaTime()
public float get_CurrentTime()
public int get_BrainCount()
public CinemachineBrain GetActiveBrain(int index)
internal void AddActiveBrain(CinemachineBrain brain)
internal void RemoveActiveBrain(CinemachineBrain brain)
public int get_VirtualCameraCount()
public CinemachineVirtualCameraBase GetVirtualCamera(int index)
internal void AddActiveCamera(CinemachineVirtualCameraBase vcam)
internal void RemoveActiveCamera(CinemachineVirtualCameraBase vcam)
internal void CameraDestroyed(CinemachineVirtualCameraBase vcam)
internal void CameraEnabled(CinemachineVirtualCameraBase vcam)
internal void CameraDisabled(CinemachineVirtualCameraBase vcam)
internal void UpdateAllActiveVirtualCameras(int layerMask, Vector3 worldUp, float deltaTime)
internal void UpdateVirtualCamera(CinemachineVirtualCameraBase vcam, Vector3 worldUp, float deltaTime)
private void InitializeModule()
private Transform GetUpdateTarget(CinemachineVirtualCameraBase vcam)
internal UpdateClock GetVcamUpdateStatus(CinemachineVirtualCameraBase vcam)
public bool IsLive(ICinemachineCamera vcam)
public bool IsLiveInBlend(ICinemachineCamera vcam)
public void GenerateCameraActivationEvent(ICinemachineCamera vcam, ICinemachineCamera vcamFrom)
public void GenerateCameraCutEvent(ICinemachineCamera vcam)
public CinemachineBrain FindPotentialTargetBrain(CinemachineVirtualCameraBase vcam)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
}
public Cinemachine.CinemachineDollyCart : MonoBehaviour {
public CinemachinePathBase m_Path
public UpdateMethod m_UpdateMethod
public PositionUnits m_PositionUnits
public float m_Speed
public float m_Position
private void FixedUpdate()
private void Update()
private void LateUpdate()
private void SetCartPosition(float distanceAlongPath)
}
public Cinemachine.CinemachineEmbeddedAssetPropertyAttribute : PropertyAttribute {
public bool WarnIfNull
public void .ctor(bool warnIfNull)
}
public Cinemachine.CinemachineExtension : MonoBehaviour {
protected float Epsilon
private CinemachineVirtualCameraBase m_vcamOwner
private Dictionary`2<ICinemachineCamera, object> mExtraState
public CinemachineVirtualCameraBase VirtualCamera
public bool RequiresUserInput
public CinemachineVirtualCameraBase get_VirtualCamera()
protected void Awake()
protected void OnEnable()
protected void OnDestroy()
internal void EnsureStarted()
protected void ConnectToVcam(bool connect)
public void PrePipelineMutateCameraStateCallback(CinemachineVirtualCameraBase vcam, CameraState& curState, float deltaTime)
public void InvokePostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
public float GetMaxDampTime()
public bool get_RequiresUserInput()
protected T GetExtraState(ICinemachineCamera vcam)
protected List`1<T> GetAllExtraStates()
}
public Cinemachine.CinemachineExternalCamera : CinemachineVirtualCameraBase {
public Transform m_LookAt
private Camera m_Camera
private CameraState m_State
private Transform <Follow>k__BackingField
public BlendHint m_BlendHint
public CameraState State
public Transform LookAt
public Transform Follow
public CameraState get_State()
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
}
public Cinemachine.CinemachineFixedSignal : SignalSourceAsset {
public AnimationCurve m_XCurve
public AnimationCurve m_YCurve
public AnimationCurve m_ZCurve
public float SignalDuration
public float get_SignalDuration()
private float AxisDuration(AnimationCurve axis)
public void GetSignal(float timeSinceSignalStart, Vector3& pos, Quaternion& rot)
private float AxisValue(AnimationCurve axis, float time)
}
public Cinemachine.CinemachineFollowZoom : CinemachineExtension {
public float m_Width
public float m_Damping
public float m_MinFOV
public float m_MaxFOV
private void OnValidate()
public float GetMaxDampTime()
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
}
public Cinemachine.CinemachineFramingTransposer : CinemachineComponentBase {
public Vector3 m_TrackedObjectOffset
public float m_LookaheadTime
public float m_LookaheadSmoothing
public bool m_LookaheadIgnoreY
public float m_XDamping
public float m_YDamping
public float m_ZDamping
public bool m_TargetMovementOnly
public float m_ScreenX
public float m_ScreenY
public float m_CameraDistance
public float m_DeadZoneWidth
public float m_DeadZoneHeight
public float m_DeadZoneDepth
public bool m_UnlimitedSoftZone
public float m_SoftZoneWidth
public float m_SoftZoneHeight
public float m_BiasX
public float m_BiasY
public bool m_CenterOnActivate
public FramingMode m_GroupFramingMode
public AdjustmentMode m_AdjustmentMode
public float m_GroupFramingSize
public float m_MaxDollyIn
public float m_MaxDollyOut
public float m_MinimumDistance
public float m_MaximumDistance
public float m_MinimumFOV
public float m_MaximumFOV
public float m_MinimumOrthoSize
public float m_MaximumOrthoSize
private float kMinimumCameraDistance
private float kMinimumGroupSize
private Vector3 m_PreviousCameraPosition
internal PositionPredictor m_Predictor
private Vector3 <TrackedPoint>k__BackingField
private bool m_InheritingPosition
private float m_prevFOV
private Quaternion m_prevRotation
private Bounds <LastBounds>k__BackingField
private Matrix4x4 <LastBoundsMatrix>k__BackingField
internal Rect SoftGuideRect
internal Rect HardGuideRect
public bool IsValid
public Stage Stage
public bool BodyAppliesAfterAim
public Vector3 TrackedPoint
public Bounds LastBounds
public Matrix4x4 LastBoundsMatrix
internal Rect get_SoftGuideRect()
internal void set_SoftGuideRect(Rect value)
internal Rect get_HardGuideRect()
internal void set_HardGuideRect(Rect value)
private void OnValidate()
public bool get_IsValid()
public Stage get_Stage()
public bool get_BodyAppliesAfterAim()
public Vector3 get_TrackedPoint()
private void set_TrackedPoint(Vector3 value)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public float GetMaxDampTime()
public bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, TransitionParams& transitionParams)
private Rect ScreenToOrtho(Rect rScreen, float orthoSize, float aspect)
private Vector3 OrthoOffsetToScreenBounds(Vector3 targetPos2D, Rect screenRect)
public Bounds get_LastBounds()
private void set_LastBounds(Bounds value)
public Matrix4x4 get_LastBoundsMatrix()
private void set_LastBoundsMatrix(Matrix4x4 value)
public void MutateCameraState(CameraState& curState, float deltaTime)
private float GetTargetHeight(Vector2 boundsSize)
private Vector3 ComputeGroupBounds(ICinemachineTargetGroup group, CameraState& curState)
private Bounds GetScreenSpaceGroupBoundingBox(ICinemachineTargetGroup group, Vector3& pos, Quaternion orientation)
}
public Cinemachine.CinemachineFreeLook : CinemachineVirtualCameraBase {
public Transform m_LookAt
public Transform m_Follow
public bool m_CommonLens
public LensSettings m_Lens
public TransitionParams m_Transitions
private BlendHint m_LegacyBlendHint
public AxisState m_YAxis
public Recentering m_YAxisRecentering
public AxisState m_XAxis
public Heading m_Heading
public Recentering m_RecenterToTargetHeading
public BindingMode m_BindingMode
public float m_SplineCurvature
public Orbit[] m_Orbits
private float m_LegacyHeadingBias
private bool mUseLegacyRigDefinitions
private bool mIsDestroyed
private CameraState m_State
private CinemachineVirtualCamera[] m_Rigs
private CinemachineOrbitalTransposer[] mOrbitals
private CinemachineBlend mBlendA
private CinemachineBlend mBlendB
public CreateRigDelegate CreateRigOverride
public DestroyRigDelegate DestroyRigOverride
private float m_CachedXAxisHeading
private float m_LastHeadingUpdateFrame
private Orbit[] m_CachedOrbits
private float m_CachedTension
private Vector4[] m_CachedKnots
private Vector4[] m_CachedCtrl1
private Vector4[] m_CachedCtrl2
internal bool RigsAreCreated
public String[] RigNames
public bool PreviousStateIsValid
public CameraState State
public Transform LookAt
public Transform Follow
protected void OnValidate()
public CinemachineVirtualCamera GetRig(int i)
internal bool get_RigsAreCreated()
public String[] get_RigNames()
protected void OnEnable()
public void UpdateInputAxisProvider()
protected void OnDestroy()
private void OnTransformChildrenChanged()
private void Reset()
public bool get_PreviousStateIsValid()
public void set_PreviousStateIsValid(bool value)
public CameraState get_State()
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
internal bool RequiresUserInput()
private float GetYAxisClosestValue(Vector3 cameraPos, Vector3 up)
private float SteepestDescent(Vector3 cameraOffset)
private void InvalidateRigCache()
private void DestroyRigs()
private CinemachineVirtualCamera[] CreateRigs(CinemachineVirtualCamera[] copyFrom)
private bool UpdateRigCache()
private List`1<CinemachineVirtualCamera> LocateExistingRigs(bool forceOrbital)
private float UpdateXAxisHeading(CinemachineOrbitalTransposer orbital, float deltaTime, Vector3 up)
private void PushSettingsToRigs()
private float GetYAxisValue()
private CameraState CalculateNewState(Vector3 worldUp, float deltaTime)
public Vector3 GetLocalPositionForCameraFromInput(float t)
private void UpdateCachedSpline()
internal void OnBeforeSerialize()
private float <SteepestDescent>g__AngleFunction|47_0(float input, <>c__DisplayClass47_0& )
private float <SteepestDescent>g__SlopeOfAngleFunction|47_1(float input, <>c__DisplayClass47_0& )
private float <SteepestDescent>g__InitialGuess|47_2(<>c__DisplayClass47_0& )
private void <SteepestDescent>g__ChooseBestAngle|47_3(float referenceAngle, <>c__DisplayClass47_0& , <>c__DisplayClass47_1& )
}
public Cinemachine.CinemachineGroupComposer : CinemachineComposer {
public float m_GroupFramingSize
public FramingMode m_FramingMode
public float m_FrameDamping
public AdjustmentMode m_AdjustmentMode
public float m_MaxDollyIn
public float m_MaxDollyOut
public float m_MinimumDistance
public float m_MaximumDistance
public float m_MinimumFOV
public float m_MaximumFOV
public float m_MinimumOrthoSize
public float m_MaximumOrthoSize
private float m_prevFramingDistance
private float m_prevFOV
private Bounds <LastBounds>k__BackingField
private Matrix4x4 <LastBoundsMatrix>k__BackingField
public Bounds LastBounds
public Matrix4x4 LastBoundsMatrix
private void OnValidate()
public Bounds get_LastBounds()
private void set_LastBounds(Bounds value)
public Matrix4x4 get_LastBoundsMatrix()
private void set_LastBoundsMatrix(Matrix4x4 value)
public float GetMaxDampTime()
public void MutateCameraState(CameraState& curState, float deltaTime)
private float GetTargetHeight(Vector2 boundsSize)
private Bounds GetScreenSpaceGroupBoundingBox(ICinemachineTargetGroup group, Matrix4x4 observer, Vector3& newFwd)
}
public Cinemachine.CinemachineHardLockToTarget : CinemachineComponentBase {
public float m_Damping
private Vector3 m_PreviousTargetPosition
public bool IsValid
public Stage Stage
public bool get_IsValid()
public Stage get_Stage()
public float GetMaxDampTime()
public void MutateCameraState(CameraState& curState, float deltaTime)
}
public Cinemachine.CinemachineHardLookAt : CinemachineComponentBase {
public bool IsValid
public Stage Stage
public bool get_IsValid()
public Stage get_Stage()
public void MutateCameraState(CameraState& curState, float deltaTime)
}
public Cinemachine.CinemachineImpulseDefinition : object {
public int m_ImpulseChannel
public ImpulseShapes m_ImpulseShape
public AnimationCurve m_CustomImpulseShape
public float m_ImpulseDuration
public ImpulseTypes m_ImpulseType
public float m_DissipationRate
public SignalSourceAsset m_RawSignal
public float m_AmplitudeGain
public float m_FrequencyGain
public RepeatMode m_RepeatMode
public bool m_Randomize
public EnvelopeDefinition m_TimeEnvelope
public float m_ImpactRadius
public DirectionMode m_DirectionMode
public DissipationMode m_DissipationMode
public float m_DissipationDistance
public float m_PropagationSpeed
private AnimationCurve[] sStandardShapes
internal AnimationCurve ImpulseCurve
public void OnValidate()
private void CreateStandardShapes()
internal AnimationCurve GetStandardCurve(ImpulseShapes shape)
internal AnimationCurve get_ImpulseCurve()
public void CreateEvent(Vector3 position, Vector3 velocity)
public ImpulseEvent CreateAndReturnEvent(Vector3 position, Vector3 velocity)
private ImpulseEvent LegacyCreateAndReturnEvent(Vector3 position, Vector3 velocity)
}
public Cinemachine.CinemachineImpulseListener : CinemachineExtension {
public Stage m_ApplyAfter
public int m_ChannelMask
public float m_Gain
public bool m_Use2DDistance
public bool m_UseCameraSpace
public ImpulseReaction m_ReactionSettings
private void Reset()
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
}
public Cinemachine.CinemachineImpulseManager : object {
private CinemachineImpulseManager sInstance
private float Epsilon
private List`1<ImpulseEvent> m_ExpiredEvents
private List`1<ImpulseEvent> m_ActiveEvents
public bool IgnoreTimeScale
public CinemachineImpulseManager Instance
public float CurrentTime
public CinemachineImpulseManager get_Instance()
private void InitializeModule()
internal float EvaluateDissipationScale(float spread, float normalizedDistance)
public bool GetImpulseAt(Vector3 listenerLocation, bool distance2D, int channelMask, Vector3& pos, Quaternion& rot)
public float get_CurrentTime()
public ImpulseEvent NewImpulseEvent()
public void AddImpulseEvent(ImpulseEvent e)
public void Clear()
}
public Cinemachine.CinemachineImpulseSource : MonoBehaviour {
public CinemachineImpulseDefinition m_ImpulseDefinition
public Vector3 m_DefaultVelocity
private void OnValidate()
private void Reset()
public void GenerateImpulseAtPositionWithVelocity(Vector3 position, Vector3 velocity)
public void GenerateImpulseWithVelocity(Vector3 velocity)
public void GenerateImpulseWithForce(float force)
public void GenerateImpulse()
public void GenerateImpulseAt(Vector3 position, Vector3 velocity)
public void GenerateImpulse(Vector3 velocity)
public void GenerateImpulse(float force)
}
public Cinemachine.CinemachineIndependentImpulseListener : MonoBehaviour {
private Vector3 impulsePosLastFrame
private Quaternion impulseRotLastFrame
public int m_ChannelMask
public float m_Gain
public bool m_Use2DDistance
public bool m_UseLocalSpace
public ImpulseReaction m_ReactionSettings
private void Reset()
private void OnEnable()
private void Update()
private void LateUpdate()
}
public Cinemachine.CinemachineInputAxisDriver : ValueType {
public float multiplier
public float accelTime
public float decelTime
public string name
public float inputValue
private float mCurrentSpeed
private float Epsilon
public void Validate()
public bool Update(float deltaTime, AxisBase& axis)
public bool Update(float deltaTime, AxisState& axis)
private float ClampValue(AxisBase& axis, float v)
}
public Cinemachine.CinemachineMixingCamera : CinemachineVirtualCameraBase {
public int MaxCameras
public float m_Weight0
public float m_Weight1
public float m_Weight2
public float m_Weight3
public float m_Weight4
public float m_Weight5
public float m_Weight6
public float m_Weight7
private CameraState m_State
private ICinemachineCamera <LiveChild>k__BackingField
private Transform <LookAt>k__BackingField
private Transform <Follow>k__BackingField
private CinemachineVirtualCameraBase[] m_ChildCameras
private Dictionary`2<CinemachineVirtualCameraBase, int> m_indexMap
private ICinemachineCamera LiveChild
public CameraState State
public Transform LookAt
public Transform Follow
public CinemachineVirtualCameraBase[] ChildCameras
public float GetWeight(int index)
public void SetWeight(int index, float w)
public float GetWeight(CinemachineVirtualCameraBase vcam)
public void SetWeight(CinemachineVirtualCameraBase vcam, float w)
private ICinemachineCamera get_LiveChild()
private void set_LiveChild(ICinemachineCamera value)
public CameraState get_State()
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
protected void OnEnable()
public void OnTransformChildrenChanged()
protected void OnValidate()
public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly)
public CinemachineVirtualCameraBase[] get_ChildCameras()
protected void InvalidateListOfChildren()
protected void ValidateListOfChildren()
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
}
public Cinemachine.CinemachineOrbitalTransposer : CinemachineTransposer {
public Heading m_Heading
public Recentering m_RecenterToTargetHeading
public AxisState m_XAxis
private float m_LegacyRadius
private float m_LegacyHeightOffset
private float m_LegacyHeadingBias
public bool m_HeadingIsSlave
internal UpdateHeadingDelegate HeadingUpdater
private Vector3 m_LastTargetPosition
private HeadingTracker mHeadingTracker
private Rigidbody m_TargetRigidBody
private Transform m_PreviousTarget
private Vector3 m_LastCameraPosition
private float m_LastHeading
public bool RequiresUserInput
protected void OnValidate()
public float UpdateHeading(float deltaTime, Vector3 up, AxisState& axis)
public float UpdateHeading(float deltaTime, Vector3 up, AxisState& axis, Recentering& recentering, bool isLive)
private void OnEnable()
public void UpdateInputAxisProvider()
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, TransitionParams& transitionParams)
public float GetAxisClosestValue(Vector3 cameraPos, Vector3 up)
public void MutateCameraState(CameraState& curState, float deltaTime)
public Vector3 GetTargetCameraPosition(Vector3 worldUp)
public bool get_RequiresUserInput()
private float GetTargetHeading(float currentHeading, Quaternion targetOrientation)
}
public Cinemachine.CinemachinePath : CinemachinePathBase {
public bool m_Looped
public Waypoint[] m_Waypoints
public float MinPos
public float MaxPos
public bool Looped
public int DistanceCacheSampleStepsPerSegment
public float get_MinPos()
public float get_MaxPos()
public bool get_Looped()
private void Reset()
private void OnValidate()
public int get_DistanceCacheSampleStepsPerSegment()
private float GetBoundingIndices(float pos, Int32& indexA, Int32& indexB)
public Vector3 EvaluateLocalPosition(float pos)
public Vector3 EvaluateLocalTangent(float pos)
public Quaternion EvaluateLocalOrientation(float pos)
internal float GetRoll(int indexA, int indexB, float standardizedPos)
private Quaternion RollAroundForward(float angle)
}
public Cinemachine.CinemachinePathBase : MonoBehaviour {
public int m_Resolution
public Appearance m_Appearance
private Single[] m_DistanceToPos
private Single[] m_PosToDistance
private int m_CachedSampleSteps
private float m_PathLength
private float m_cachedPosStepSize
private float m_cachedDistanceStepSize
public float MinPos
public float MaxPos
public bool Looped
public int DistanceCacheSampleStepsPerSegment
public float PathLength
public float get_MinPos()
public float get_MaxPos()
public bool get_Looped()
public float StandardizePos(float pos)
public Vector3 EvaluatePosition(float pos)
public Vector3 EvaluateTangent(float pos)
public Quaternion EvaluateOrientation(float pos)
public Vector3 EvaluateLocalPosition(float pos)
public Vector3 EvaluateLocalTangent(float pos)
public Quaternion EvaluateLocalOrientation(float pos)
public float FindClosestPoint(Vector3 p, int startSegment, int searchRadius, int stepsPerSegment)
public float MinUnit(PositionUnits units)
public float MaxUnit(PositionUnits units)
public float StandardizeUnit(float pos, PositionUnits units)
public Vector3 EvaluatePositionAtUnit(float pos, PositionUnits units)
public Vector3 EvaluateTangentAtUnit(float pos, PositionUnits units)
public Quaternion EvaluateOrientationAtUnit(float pos, PositionUnits units)
public int get_DistanceCacheSampleStepsPerSegment()
public void InvalidateDistanceCache()
public bool DistanceCacheIsValid()
public float get_PathLength()
public float StandardizePathDistance(float distance)
public float ToNativePathUnits(float pos, PositionUnits units)
public float FromPathNativeUnits(float pos, PositionUnits units)
private void ResamplePath(int stepsPerSegment)
}
public Cinemachine.CinemachinePOV : CinemachineComponentBase {
public RecenterTargetMode m_RecenterTarget
public AxisState m_VerticalAxis
public Recentering m_VerticalRecentering
public AxisState m_HorizontalAxis
public Recentering m_HorizontalRecentering
public bool m_ApplyBeforeBody
private Quaternion m_PreviousCameraRotation
public bool IsValid
public Stage Stage
public bool RequiresUserInput
public bool get_IsValid()
public Stage get_Stage()
private void OnValidate()
private void OnEnable()
public void UpdateInputAxisProvider()
public void PrePipelineMutateCameraState(CameraState& state, float deltaTime)
public void MutateCameraState(CameraState& curState, float deltaTime)
public Vector2 GetRecenterTarget()
private float NormalizeAngle(float angle)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, TransitionParams& transitionParams)
public bool get_RequiresUserInput()
private void SetAxesForRotation(Quaternion targetRot)
}
public Cinemachine.CinemachineSameAsFollowTarget : CinemachineComponentBase {
public float m_Damping
private Quaternion m_PreviousReferenceOrientation
public bool IsValid
public Stage Stage
public bool get_IsValid()
public Stage get_Stage()
public float GetMaxDampTime()
public void MutateCameraState(CameraState& curState, float deltaTime)
}
public Cinemachine.CinemachineSmoothPath : CinemachinePathBase {
public bool m_Looped
public Waypoint[] m_Waypoints
internal Waypoint[] m_ControlPoints1
internal Waypoint[] m_ControlPoints2
private bool m_IsLoopedCache
public float MinPos
public float MaxPos
public bool Looped
public int DistanceCacheSampleStepsPerSegment
public float get_MinPos()
public float get_MaxPos()
public bool get_Looped()
public int get_DistanceCacheSampleStepsPerSegment()
private void OnValidate()
private void Reset()
public void InvalidateDistanceCache()
internal void UpdateControlPoints()
private float GetBoundingIndices(float pos, Int32& indexA, Int32& indexB)
public Vector3 EvaluateLocalPosition(float pos)
public Vector3 EvaluateLocalTangent(float pos)
public Quaternion EvaluateLocalOrientation(float pos)
private Quaternion RollAroundForward(float angle)
}
public Cinemachine.CinemachineStateDrivenCamera : CinemachineVirtualCameraBase {
public Transform m_LookAt
public Transform m_Follow
public Animator m_AnimatedTarget
public int m_LayerIndex
public bool m_ShowDebugText
internal CinemachineVirtualCameraBase[] m_ChildCameras
public Instruction[] m_Instructions
public CinemachineBlendDefinition m_DefaultBlend
public CinemachineBlenderSettings m_CustomBlends
internal ParentHash[] m_ParentHash
private ICinemachineCamera <LiveChild>k__BackingField
private ICinemachineCamera m_TransitioningFrom
private CameraState m_State
private Dictionary`2<AnimationClip, List`1<HashPair>> mHashCache
private float mActivationTime
private Instruction mActiveInstruction
private float mPendingActivationTime
private Instruction mPendingInstruction
private CinemachineBlend mActiveBlend
private Dictionary`2<int, int> mInstructionDictionary
private Dictionary`2<int, int> mStateParentLookup
private List`1<AnimatorClipInfo> m_clipInfoList
public string Description
public ICinemachineCamera LiveChild
public CameraState State
public Transform LookAt
public Transform Follow
public CinemachineVirtualCameraBase[] ChildCameras
public bool IsBlending
public CinemachineBlend ActiveBlend
public string get_Description()
public ICinemachineCamera get_LiveChild()
public void set_LiveChild(ICinemachineCamera value)
public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly)
public CameraState get_State()
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
protected void OnEnable()
protected void OnDisable()
public void OnTransformChildrenChanged()
private void OnGuiHandler()
public CinemachineVirtualCameraBase[] get_ChildCameras()
public bool get_IsBlending()
public CinemachineBlend get_ActiveBlend()
public int CreateFakeHash(int parentHash, AnimationClip clip)
private int LookupFakeHash(int parentHash, AnimationClip clip)
private void InvalidateListOfChildren()
private void UpdateListOfChildren()
internal void ValidateInstructions()
private CinemachineVirtualCameraBase ChooseCurrentCamera()
private int GetClipHash(int hash, List`1<AnimatorClipInfo> clips)
private CinemachineBlendDefinition LookupBlend(ICinemachineCamera fromKey, ICinemachineCamera toKey)
}
public Cinemachine.CinemachineStoryboard : CinemachineExtension {
public bool s_StoryboardGlobalMute
public bool m_ShowImage
public Texture m_Image
public FillStrategy m_Aspect
public float m_Alpha
public Vector2 m_Center
public Vector3 m_Rotation
public Vector2 m_Scale
public bool m_SyncScale
public bool m_MuteCamera
public float m_SplitView
public StoryboardRenderMode m_RenderMode
public int m_SortingOrder
public float m_PlaneDistance
private List`1<CanvasInfo> mCanvasInfo
private string CanvasName
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
private void UpdateRenderCanvas()
protected void ConnectToVcam(bool connect)
private string get_CanvasName()
private void CameraUpdatedCallback(CinemachineBrain brain)
private CanvasInfo LocateMyCanvas(CinemachineBrain parent, bool createIfNotFound)
private void CreateCanvas(CanvasInfo ci)
private void DestroyCanvas()
private void PlaceImage(CanvasInfo ci, float alpha)
private void StaticBlendingHandler(CinemachineBrain brain)
private void InitializeModule()
}
public Cinemachine.CinemachineTargetGroup : MonoBehaviour {
public PositionMode m_PositionMode
public RotationMode m_RotationMode
public UpdateMethod m_UpdateMethod
public Target[] m_Targets
private float m_MaxWeight
private Vector3 m_AveragePos
private Bounds m_BoundingBox
private BoundingSphere m_BoundingSphere
private int m_LastUpdateFrame
private List`1<int> m_ValidMembers
private List`1<bool> m_MemberValidity
public Transform Transform
public Bounds BoundingBox
public BoundingSphere Sphere
public bool IsEmpty
private bool CachedCountIsValid
private void OnValidate()
private void Reset()
public Transform get_Transform()
public Bounds get_BoundingBox()
private void set_BoundingBox(Bounds value)
public BoundingSphere get_Sphere()
private void set_Sphere(BoundingSphere value)
public bool get_IsEmpty()
public void AddMember(Transform t, float weight, float radius)
public void RemoveMember(Transform t)
public int FindMember(Transform t)
public BoundingSphere GetWeightedBoundsForMember(int index)
public Bounds GetViewSpaceBoundingBox(Matrix4x4 observer)
private bool get_CachedCountIsValid()
private bool IndexIsValid(int index)
private BoundingSphere WeightedMemberBoundsForValidMember(Target& t, Vector3 avgPos, float maxWeight)
public void DoUpdate()
private void UpdateMemberValidity()
private Vector3 CalculateAveragePosition(Single& maxWeight)
private Bounds CalculateBoundingBox()
private BoundingSphere CalculateBoundingSphere(float maxWeight)
private Quaternion CalculateAverageOrientation()
private void FixedUpdate()
private void Update()
private void LateUpdate()
public void GetViewSpaceAngularBounds(Matrix4x4 observer, Vector2& minAngles, Vector2& maxAngles, Vector2& zRange)
}
public Cinemachine.CinemachineTrackedDolly : CinemachineComponentBase {
public CinemachinePathBase m_Path
public float m_PathPosition
public PositionUnits m_PositionUnits
public Vector3 m_PathOffset
public float m_XDamping
public float m_YDamping
public float m_ZDamping
public CameraUpMode m_CameraUp
public float m_PitchDamping
public float m_YawDamping
public float m_RollDamping
public AutoDolly m_AutoDolly
private float m_PreviousPathPosition
private Quaternion m_PreviousOrientation
private Vector3 m_PreviousCameraPosition
public bool IsValid
public Stage Stage
private Vector3 AngularDamping
public bool get_IsValid()
public Stage get_Stage()
public float GetMaxDampTime()
public void MutateCameraState(CameraState& curState, float deltaTime)
private Quaternion GetCameraOrientationAtPathPoint(Quaternion pathOrientation, Vector3 up)
private Vector3 get_AngularDamping()
}
public Cinemachine.CinemachineTransposer : CinemachineComponentBase {
public BindingMode m_BindingMode
public Vector3 m_FollowOffset
public float m_XDamping
public float m_YDamping
public float m_ZDamping
public AngularDampingMode m_AngularDampingMode
public float m_PitchDamping
public float m_YawDamping
public float m_RollDamping
public float m_AngularDamping
private bool <HideOffsetInInspector>k__BackingField
private Vector3 m_PreviousTargetPosition
private Quaternion m_PreviousReferenceOrientation
private Quaternion m_targetOrientationOnAssign
private Vector3 m_PreviousOffset
private Transform m_previousTarget
public bool HideOffsetInInspector
public Vector3 EffectiveOffset
public bool IsValid
public Stage Stage
protected Vector3 Damping
protected Vector3 AngularDamping
protected void OnValidate()
public bool get_HideOffsetInInspector()
public void set_HideOffsetInInspector(bool value)
public Vector3 get_EffectiveOffset()
public bool get_IsValid()
public Stage get_Stage()
public float GetMaxDampTime()
public void MutateCameraState(CameraState& curState, float deltaTime)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
protected void InitPrevFrameStateInfo(CameraState& curState, float deltaTime)
protected void TrackTarget(float deltaTime, Vector3 up, Vector3 desiredCameraOffset, Vector3& outTargetPosition, Quaternion& outTargetOrient)
protected Vector3 GetOffsetForMinimumTargetDistance(Vector3 dampedTargetPos, Vector3 cameraOffset, Vector3 cameraFwd, Vector3 up, Vector3 actualTargetPos)
protected Vector3 get_Damping()
protected Vector3 get_AngularDamping()
public Vector3 GetTargetCameraPosition(Vector3 worldUp)
public Quaternion GetReferenceOrientation(Vector3 worldUp)
}
public Cinemachine.CinemachineTriggerAction : MonoBehaviour {
public LayerMask m_LayerMask
public string m_WithTag
public string m_WithoutTag
public int m_SkipFirst
public bool m_Repeating
public ActionSettings m_OnObjectEnter
public ActionSettings m_OnObjectExit
private HashSet`1<GameObject> m_ActiveTriggerObjects
private bool Filter(GameObject other)
private void InternalDoTriggerEnter(GameObject other)
private void InternalDoTriggerExit(GameObject other)
private void OnTriggerEnter(Collider other)
private void OnTriggerExit(Collider other)
private void OnCollisionEnter(Collision other)
private void OnCollisionExit(Collision other)
private void OnTriggerEnter2D(Collider2D other)
private void OnTriggerExit2D(Collider2D other)
private void OnCollisionEnter2D(Collision2D other)
private void OnCollisionExit2D(Collision2D other)
private void OnEnable()
}
public Cinemachine.CinemachineVirtualCamera : CinemachineVirtualCameraBase {
public Transform m_LookAt
public Transform m_Follow
public LensSettings m_Lens
public TransitionParams m_Transitions
private BlendHint m_LegacyBlendHint
public string PipelineName
public CreatePipelineDelegate CreatePipelineOverride
public DestroyPipelineDelegate DestroyPipelineOverride
private CameraState m_State
private CinemachineComponentBase[] m_ComponentPipeline
private Transform m_ComponentOwner
private Transform mCachedLookAtTarget
private CinemachineVirtualCameraBase mCachedLookAtTargetVcam
public CameraState State
public Transform LookAt
public Transform Follow
public CameraState get_State()
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public float GetMaxDampTime()
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
protected void OnEnable()
protected void OnDestroy()
protected void OnValidate()
private void OnTransformChildrenChanged()
private void Reset()
internal void DestroyPipeline()
internal Transform CreatePipeline(CinemachineVirtualCamera copyFrom)
public void InvalidateComponentPipeline()
public Transform GetComponentOwner()
public CinemachineComponentBase[] GetComponentPipeline()
public CinemachineComponentBase GetCinemachineComponent(Stage stage)
public T GetCinemachineComponent()
public T AddCinemachineComponent()
public void DestroyCinemachineComponent()
private void UpdateComponentPipeline()
internal void SetFlagsForHiddenChild(GameObject child)
private CameraState CalculateNewState(Vector3 worldUp, float deltaTime)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
internal void SetStateRawPosition(Vector3 pos)
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
internal bool RequiresUserInput()
internal void OnBeforeSerialize()
}
public Cinemachine.CinemachineVirtualCameraBase : MonoBehaviour {
public String[] m_ExcludedPropertiesInInspector
public Stage[] m_LockStageInInspector
private int m_ValidatingStreamVersion
private bool m_OnValidateCalled
private int m_StreamingVersion
public int m_Priority
internal int m_ActivationId
public float FollowTargetAttachment
public float LookAtTargetAttachment
public StandbyUpdateMode m_StandbyUpdate
private List`1<CinemachineExtension> <mExtensions>k__BackingField
private bool <PreviousStateIsValid>k__BackingField
private bool m_WasStarted
private bool mSlaveStatusUpdated
private CinemachineVirtualCameraBase m_parentVcam
private int m_QueuePriority
private float m_blendStartPosition
private Transform m_CachedFollowTarget
private CinemachineVirtualCameraBase m_CachedFollowTargetVcam
private ICinemachineTargetGroup m_CachedFollowTargetGroup
private Transform m_CachedLookAtTarget
private CinemachineVirtualCameraBase m_CachedLookAtTargetVcam
private ICinemachineTargetGroup m_CachedLookAtTargetGroup
private bool <FollowTargetChanged>k__BackingField
private bool <LookAtTargetChanged>k__BackingField
public int ValidatingStreamVersion
internal List`1<CinemachineExtension> mExtensions
public string Name
public string Description
public int Priority
public GameObject VirtualCameraGameObject
public bool IsValid
public CameraState State
public ICinemachineCamera ParentCamera
public Transform LookAt
public Transform Follow
public bool PreviousStateIsValid
public bool FollowTargetChanged
public bool LookAtTargetChanged
public ICinemachineTargetGroup AbstractFollowTargetGroup
public CinemachineVirtualCameraBase FollowTargetAsVcam
public ICinemachineTargetGroup AbstractLookAtTargetGroup
public CinemachineVirtualCameraBase LookAtTargetAsVcam
public int get_ValidatingStreamVersion()
private void set_ValidatingStreamVersion(int value)
public float GetMaxDampTime()
public float DetachedFollowTargetDamp(float initial, float dampTime, float deltaTime)
public Vector3 DetachedFollowTargetDamp(Vector3 initial, Vector3 dampTime, float deltaTime)
public Vector3 DetachedFollowTargetDamp(Vector3 initial, float dampTime, float deltaTime)
public float DetachedLookAtTargetDamp(float initial, float dampTime, float deltaTime)
public Vector3 DetachedLookAtTargetDamp(Vector3 initial, Vector3 dampTime, float deltaTime)
public Vector3 DetachedLookAtTargetDamp(Vector3 initial, float dampTime, float deltaTime)
public void AddExtension(CinemachineExtension extension)
public void RemoveExtension(CinemachineExtension extension)
internal List`1<CinemachineExtension> get_mExtensions()
private void set_mExtensions(List`1<CinemachineExtension> value)
protected void InvokePostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& newState, float deltaTime)
protected void InvokePrePipelineMutateCameraStateCallback(CinemachineVirtualCameraBase vcam, CameraState& newState, float deltaTime)
protected bool InvokeOnTransitionInExtensions(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
public string get_Name()
public string get_Description()
public int get_Priority()
public void set_Priority(int value)
protected void ApplyPositionBlendMethod(CameraState& state, BlendHint hint)
public GameObject get_VirtualCameraGameObject()
public bool get_IsValid()
public CameraState get_State()
public ICinemachineCamera get_ParentCamera()
public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly)
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public bool get_PreviousStateIsValid()
public void set_PreviousStateIsValid(bool value)
public void UpdateCameraState(Vector3 worldUp, float deltaTime)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
protected void OnDestroy()
protected void OnTransformParentChanged()
protected void Start()
internal bool RequiresUserInput()
internal void EnsureStarted()
public IInputAxisProvider GetInputAxisProvider()
protected void OnValidate()
protected void OnEnable()
protected void OnDisable()
protected void Update()
private void UpdateSlaveStatus()
public Transform ResolveLookAt(Transform localLookAt)
public Transform ResolveFollow(Transform localFollow)
private void UpdateVcamPoolStatus()
public void MoveToTopOfPrioritySubqueue()
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
public void ForceCameraPosition(Vector3 pos, Quaternion rot)
private bool GetInheritPosition(ICinemachineCamera cam)
protected CinemachineBlend CreateBlend(ICinemachineCamera camA, ICinemachineCamera camB, CinemachineBlendDefinition blendDef, CinemachineBlend activeBlend)
protected CameraState PullStateFromVirtualCamera(Vector3 worldUp, LensSettings& lens)
private void InvalidateCachedTargets()
public bool get_FollowTargetChanged()
private void set_FollowTargetChanged(bool value)
public bool get_LookAtTargetChanged()
private void set_LookAtTargetChanged(bool value)
protected void UpdateTargetCache()
public ICinemachineTargetGroup get_AbstractFollowTargetGroup()
public CinemachineVirtualCameraBase get_FollowTargetAsVcam()
public ICinemachineTargetGroup get_AbstractLookAtTargetGroup()
public CinemachineVirtualCameraBase get_LookAtTargetAsVcam()
private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
protected internal void LegacyUpgrade(int streamedVersion)
internal void OnBeforeSerialize()
public void CancelDamping(bool updateNow)
}
internal Cinemachine.ConfinerOven : object {
private float m_MinFrustumHeightWithBones
private List`1<List`1<IntPoint>> m_OriginalPolygon
private IntPoint m_MidPoint
private List`1<List`1<IntPoint>> m_Skeleton
private long k_FloatToIntScaler
private float k_IntToFloatScaler
private float k_MinStepSize
private Rect m_PolygonRect
private AspectStretcher m_AspectStretcher
private float m_MaxComputationTimeForFullSkeletonBakeInSeconds
private BakingState <State>k__BackingField
public float bakeProgress
private BakingStateCache m_Cache
public BakingState State
public void .ctor(List`1& inputPath, Single& aspectRatio, float maxFrustumHeight)
public BakedSolution GetBakedSolution(float frustumHeight)
public BakingState get_State()
private void set_State(BakingState value)
private void Initialize(List`1& inputPath, Single& aspectRatio, float maxFrustumHeight)
public void BakeConfiner(float maxComputationTimePerFrameInSeconds)
internal Rect <Initialize>g__GetPolygonBoundingBox|23_0(List`1& polygons)
internal IntPoint <Initialize>g__MidPointOfIntRect|23_1(IntRect bounds)
private void <BakeConfiner>g__ComputeSkeleton|24_0(List`1& solutions)
}
internal Cinemachine.Documentation : object {
public string BaseURL
}
public Cinemachine.DocumentationSortingAttribute : Attribute {
private Level <Category>k__BackingField
public Level Category
public Level get_Category()
private void set_Category(Level value)
public void .ctor(Level category)
}
public Cinemachine.GroupWeightManipulator : MonoBehaviour {
public float m_Weight0
public float m_Weight1
public float m_Weight2
public float m_Weight3
public float m_Weight4
public float m_Weight5
public float m_Weight6
public float m_Weight7
private CinemachineTargetGroup m_group
private void Start()
private void OnValidate()
private void Update()
private void UpdateWeights()
}
public Cinemachine.ICameraOverrideStack {
public Vector3 DefaultWorldUp
public int SetCameraOverride(int overrideId, ICinemachineCamera camA, ICinemachineCamera camB, float weightB, float deltaTime)
public void ReleaseCameraOverride(int overrideId)
public Vector3 get_DefaultWorldUp()
}
public Cinemachine.ICinemachineCamera {
public string Name
public string Description
public int Priority
public Transform LookAt
public Transform Follow
public CameraState State
public GameObject VirtualCameraGameObject
public bool IsValid
public ICinemachineCamera ParentCamera
public string get_Name()
public string get_Description()
public int get_Priority()
public void set_Priority(int value)
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public CameraState get_State()
public GameObject get_VirtualCameraGameObject()
public bool get_IsValid()
public ICinemachineCamera get_ParentCamera()
public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly)
public void UpdateCameraState(Vector3 worldUp, float deltaTime)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
}
public Cinemachine.ICinemachineTargetGroup {
public Transform Transform
public Bounds BoundingBox
public BoundingSphere Sphere
public bool IsEmpty
public Transform get_Transform()
public Bounds get_BoundingBox()
public BoundingSphere get_Sphere()
public bool get_IsEmpty()
public Bounds GetViewSpaceBoundingBox(Matrix4x4 observer)
public void GetViewSpaceAngularBounds(Matrix4x4 observer, Vector2& minAngles, Vector2& maxAngles, Vector2& zRange)
}
public Cinemachine.ISignalSource6D {
public float SignalDuration
public float get_SignalDuration()
public void GetSignal(float timeSinceSignalStart, Vector3& pos, Quaternion& rot)
}
public Cinemachine.LensSettings : ValueType {
public LensSettings Default
public float FieldOfView
public float OrthographicSize
public float NearClipPlane
public float FarClipPlane
public float Dutch
public OverrideModes ModeOverride
public Vector2 LensShift
public GateFitMode GateFit
public float FocusDistance
private Vector2 m_SensorSize
private bool m_OrthoFromCamera
private bool m_PhysicalFromCamera
public bool Orthographic
public Vector2 SensorSize
public float Aspect
public bool IsPhysicalCamera
public bool get_Orthographic()
public void set_Orthographic(bool value)
public Vector2 get_SensorSize()
public void set_SensorSize(Vector2 value)
public float get_Aspect()
public bool get_IsPhysicalCamera()
public void set_IsPhysicalCamera(bool value)
public LensSettings FromCamera(Camera fromCamera)
public void SnapshotCameraReadOnlyProperties(Camera camera)
public void SnapshotCameraReadOnlyProperties(LensSettings& lens)
public void .ctor(float verticalFOV, float orthographicSize, float nearClip, float farClip, float dutch)
public LensSettings Lerp(LensSettings lensA, LensSettings lensB, float t)
public void Validate()
}
public Cinemachine.NoiseSettings : SignalSourceAsset {
public TransformNoiseParams[] PositionNoise
public TransformNoiseParams[] OrientationNoise
public float SignalDuration
public Vector3 GetCombinedFilterResults(TransformNoiseParams[] noiseParams, float time, Vector3 timeOffsets)
public float get_SignalDuration()
public void GetSignal(float timeSinceSignalStart, Vector3& pos, Quaternion& rot)
}
public Cinemachine.PostFX.CinemachinePostProcessing : CinemachineExtension {
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
}
public Cinemachine.RuntimeUtility : object {
private RaycastHit[] s_HitBuffer
private Int32[] s_PenetrationIndexBuffer
private SphereCollider s_ScratchCollider
private GameObject s_ScratchColliderGameObject
public void DestroyObject(Object obj)
public bool IsPrefab(GameObject gameObject)
public bool RaycastIgnoreTag(Ray ray, RaycastHit& hitInfo, float rayLength, int layerMask, String& ignoreTag)
public bool SphereCastIgnoreTag(Vector3 rayStart, float radius, Vector3 dir, RaycastHit& hitInfo, float rayLength, int layerMask, String& ignoreTag)
internal SphereCollider GetScratchCollider()
internal void DestroyScratchCollider()
public AnimationCurve NormalizeCurve(AnimationCurve curve, bool normalizeX, bool normalizeY)
}
public Cinemachine.SignalSourceAsset : ScriptableObject {
public float SignalDuration
public float get_SignalDuration()
public void GetSignal(float timeSinceSignalStart, Vector3& pos, Quaternion& rot)
}
internal Cinemachine.StaticPointVirtualCamera : object {
private string <Name>k__BackingField
private int <Priority>k__BackingField
private Transform <LookAt>k__BackingField
private Transform <Follow>k__BackingField
private CameraState <State>k__BackingField
public string Name
public string Description
public int Priority
public Transform LookAt
public Transform Follow
public CameraState State
public GameObject VirtualCameraGameObject
public bool IsValid
public ICinemachineCamera ParentCamera
public void .ctor(CameraState state, string name)
public void SetState(CameraState state)
public string get_Name()
private void set_Name(string value)
public string get_Description()
public int get_Priority()
public void set_Priority(int value)
public Transform get_LookAt()
public void set_LookAt(Transform value)
public Transform get_Follow()
public void set_Follow(Transform value)
public CameraState get_State()
private void set_State(CameraState value)
public GameObject get_VirtualCameraGameObject()
public bool get_IsValid()
public ICinemachineCamera get_ParentCamera()
public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly)
public void UpdateCameraState(Vector3 worldUp, float deltaTime)
public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
}
internal Cinemachine.TargetPositionCache : object {
public bool UseCache
public float CacheStepSize
private Mode m_CacheMode
public float CurrentTime
public int CurrentFrame
public bool IsCameraCut
private Dictionary`2<Transform, CacheEntry> m_Cache
private TimeRange m_CacheTimeRange
private float kWraparoundSlush
public Mode CacheMode
public bool IsRecording
public bool CurrentPlaybackTimeValid
public bool IsEmpty
public TimeRange CacheTimeRange
public bool HasCurrentTime
public Mode get_CacheMode()
public void set_CacheMode(Mode value)
public bool get_IsRecording()
public bool get_CurrentPlaybackTimeValid()
public bool get_IsEmpty()
public TimeRange get_CacheTimeRange()
public bool get_HasCurrentTime()
public void ClearCache()
private void CreatePlaybackCurves()
public Vector3 GetTargetPosition(Transform target)
public Quaternion GetTargetRotation(Transform target)
}
internal Cinemachine.UpdateTracker : object {
private Dictionary`2<Transform, UpdateStatus> mUpdateStatus
private List`1<Transform> sToDelete
private float mLastUpdateTime
private void InitializeModule()
private void UpdateTargets(UpdateClock currentClock)
public UpdateClock GetPreferredUpdate(Transform target)
public void OnUpdate(UpdateClock currentClock)
}
public Cinemachine.Utility.CinemachineDebug : object {
private HashSet`1<Object> mClients
public OnGUIDelegate OnGUIHandlers
private List`1<StringBuilder> mAvailableStringBuilders
public void ReleaseScreenPos(Object client)
public Rect GetScreenPos(Object client, string text, GUIStyle style)
public StringBuilder SBFromPool()
public void ReturnToPool(StringBuilder sb)
}
public Cinemachine.Utility.Damper : object {
private float Epsilon
public float kNegligibleResidual
private float kLogNegligibleResidual
private float DecayConstant(float time, float residual)
private float DecayedRemainder(float initial, float decayConstant, float deltaTime)
public float Damp(float initial, float dampTime, float deltaTime)
public Vector3 Damp(Vector3 initial, Vector3 dampTime, float deltaTime)
public Vector3 Damp(Vector3 initial, float dampTime, float deltaTime)
}
internal Cinemachine.Utility.GaussianWindow1D_CameraRotation : GaussianWindow1d`1<Vector2> {
public void .ctor(float sigma, int maxKernelRadius)
protected Vector2 Compute(int windowPos)
}
internal Cinemachine.Utility.GaussianWindow1D_Quaternion : GaussianWindow1d`1<Quaternion> {
public void .ctor(float sigma, int maxKernelRadius)
protected Quaternion Compute(int windowPos)
}
internal Cinemachine.Utility.GaussianWindow1D_Vector3 : GaussianWindow1d`1<Vector3> {
public void .ctor(float sigma, int maxKernelRadius)
protected Vector3 Compute(int windowPos)
}
internal Cinemachine.Utility.GaussianWindow1d`1 : object {
protected T[] mData
protected Single[] mKernel
protected int mCurrentPos
private float <Sigma>k__BackingField
public float Sigma
public int KernelSize
public int BufferLength
public float get_Sigma()
private void set_Sigma(float value)
public int get_KernelSize()
private void GenerateKernel(float sigma, int maxKernelRadius)
protected T Compute(int windowPos)
public void .ctor(float sigma, int maxKernelRadius)
public void Reset()
public bool IsEmpty()
public void AddValue(T v)
public T Filter(T v)
public T Value()
public int get_BufferLength()
public void SetBufferValue(int index, T value)
public T GetBufferValue(int index)
}
public Cinemachine.Utility.HeadingTracker : object {
private Item[] mHistory
private int mTop
private int mBottom
private int mCount
private Vector3 mHeadingSum
private float mWeightSum
private float mWeightTime
private Vector3 mLastGoodHeading
private float mDecayExponent
public int FilterSize
public void .ctor(int filterSize)
public int get_FilterSize()
private void ClearHistory()
private float Decay(float time)
public void Add(Vector3 velocity)
private void PopBottom()
public void DecayHistory()
public Vector3 GetReliableHeading()
}
public Cinemachine.Utility.PositionPredictor : object {
private Vector3 m_Velocity
private Vector3 m_SmoothDampVelocity
private Vector3 m_Pos
private bool m_HavePos
public float Smoothing
public bool IsEmpty()
public void ApplyTransformDelta(Vector3 positionDelta)
public void Reset()
public void AddPosition(Vector3 pos, float deltaTime, float lookaheadTime)
public Vector3 PredictPositionDelta(float lookaheadTime)
public Vector3 PredictPosition(float lookaheadTime)
}
public Cinemachine.Utility.SplineHelpers : object {
public Vector3 Bezier3(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
public Vector3 BezierTangent3(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
public void BezierTangentWeights3(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, Vector3& w0, Vector3& w1, Vector3& w2)
public float Bezier1(float t, float p0, float p1, float p2, float p3)
public float BezierTangent1(float t, float p0, float p1, float p2, float p3)
public void ComputeSmoothControlPoints(Vector4[]& knot, Vector4[]& ctrl1, Vector4[]& ctrl2)
public void ComputeSmoothControlPointsLooped(Vector4[]& knot, Vector4[]& ctrl1, Vector4[]& ctrl2)
}
public Cinemachine.Utility.UnityQuaternionExtensions : object {
public Quaternion SlerpWithReferenceUp(Quaternion qA, Quaternion qB, float t, Vector3 up)
public Quaternion Normalized(Quaternion q)
public Vector2 GetCameraRotationToTarget(Quaternion orient, Vector3 lookAtDir, Vector3 worldUp)
public Quaternion ApplyCameraRotation(Quaternion orient, Vector2 rot, Vector3 worldUp)
}
public Cinemachine.Utility.UnityRectExtensions : object {
public Rect Inflated(Rect r, Vector2 delta)
}
public Cinemachine.Utility.UnityVectorExtensions : object {
public float Epsilon
public bool IsNaN(Vector2 v)
public bool IsNaN(Vector3 v)
public float ClosestPointOnSegment(Vector3 p, Vector3 s0, Vector3 s1)
public float ClosestPointOnSegment(Vector2 p, Vector2 s0, Vector2 s1)
public Vector3 ProjectOntoPlane(Vector3 vector, Vector3 planeNormal)
public Vector2 SquareNormalize(Vector2 v)
public int FindIntersection(Vector2& p1, Vector2& p2, Vector2& q1, Vector2& q2, Vector2& intersection)
private float Cross(Vector2 v1, Vector2 v2)
public Vector2 Abs(Vector2 v)
public Vector3 Abs(Vector3 v)
public bool IsUniform(Vector2 v)
public bool IsUniform(Vector3 v)
public bool AlmostZero(Vector3 v)
public float Angle(Vector3 v1, Vector3 v2)
public float SignedAngle(Vector3 v1, Vector3 v2, Vector3 up)
public Quaternion SafeFromToRotation(Vector3 v1, Vector3 v2, Vector3 up)
public Vector3 SlerpWithReferenceUp(Vector3 vA, Vector3 vB, float t, Vector3 up)
}
public CinemachineCameraOffset : CinemachineExtension {
public Vector3 m_Offset
public Stage m_ApplyAfter
public bool m_PreserveComposition
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
}
internal CinemachineMixer : PlayableBehaviour {
public MasterDirectorDelegate GetMasterPlayableDirector
private ICameraOverrideStack m_BrainOverrideStack
private int m_BrainOverrideId
private bool m_PreviewPlay
public void OnPlayableDestroy(Playable playable)
public void PrepareFrame(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
private float GetDeltaTime(float deltaTime)
}
public CinemachineRecomposer : CinemachineExtension {
public Stage m_ApplyAfter
public float m_Tilt
public float m_Pan
public float m_Dutch
public float m_ZoomScale
public float m_FollowAttachment
public float m_LookAtAttachment
private void Reset()
private void OnValidate()
public void PrePipelineMutateCameraStateCallback(CinemachineVirtualCameraBase vcam, CameraState& curState, float deltaTime)
protected void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, Stage stage, CameraState& state, float deltaTime)
}
public CinemachineShot : PlayableAsset {
public string DisplayName
public ExposedReference`1<CinemachineVirtualCameraBase> VirtualCamera
public Playable CreatePlayable(PlayableGraph graph, GameObject owner)
public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
}
internal CinemachineShotPlayable : PlayableBehaviour {
public CinemachineVirtualCameraBase VirtualCamera
public bool IsValid
public bool get_IsValid()
}
public CinemachineTouchInputMapper : MonoBehaviour {
public float TouchSensitivityX
public float TouchSensitivityY
public string TouchXInputMapTo
public string TouchYInputMapTo
private void Start()
private float GetInputAxis(string axisName)
}
public CinemachineTrack : TrackAsset {
public Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
}
internal UnitySourceGeneratedAssemblyMonoScriptTypes_v1 : object {
private MonoScriptData Get()
}
