public AboutYou : BaseMonoBehaviour {
public Text username
public RawImage avatar
public Text subtitle
}
public AchievementGroup : object {
public Phrase groupTitle
public AchievementGroup[] All
public AchievementItem[] Items
private Func`2<AchievementItem, bool> <>f__am$cache0
public bool Unlocked
public void .ctor(string token, string english)
public bool get_Unlocked()
private bool <get_Unlocked>m__0(AchievementItem x)
}
public Achievements : SingletonComponent`1<Achievements> {
public SoundDefinition listComplete
public SoundDefinition itemComplete
public SoundDefinition popup
}
public AchievementTodo : BaseMonoBehaviour {
public Text text
public RectTransform checkIcon
public RectTransform checkBox
public Color AliveColor
public Color DeadColor
public Color HighlightColor
}
public ActionPriority : Enum {
public int value__
public ActionPriority Highest
public ActionPriority High
public ActionPriority Medium
public ActionPriority Low
public ActionPriority Lowest
}
public AddSellOrderManager : MonoBehaviour {
public VirtualItemIcon sellItemIcon
public VirtualItemIcon currencyItemIcon
public GameObject itemSearchParent
public ItemSearchEntry itemSearchEntryPrefab
public InputField sellItemInput
public InputField sellItemAmount
public InputField currencyItemInput
public InputField currencyItemAmount
public VendingPanelAdmin adminPanel
}
public AddToHeightMap : ProceduralObject {
public void Process()
}
public AddToWaterMap : ProceduralObject {
public void Process()
}
public AdminExistingSellOrder : MonoBehaviour {
public VirtualItemIcon MerchandiseIcon
public VirtualItemIcon CurrencyIcon
private VendingPanelAdmin adminPanel
private int index
}
public AIHelicopterAnimation : MonoBehaviour {
public PatrolHelicopterAI _ai
public float swayAmount
public float lastStrafeScalar
public float lastForwardBackScalar
public float degreeMax
public Vector3 lastPosition
public float oldMoveSpeed
public float smoothRateOfChange
public float flareAmount
public void Awake()
public Vector3 GetMoveDirection()
public float GetMoveSpeed()
public void Update()
}
public AiManagerLoadBalancer : LoadBalancer {
public ILoadBalancer aiManagerLoadBalancer
}
public AimConeUtil : object {
public Vector3 GetModifiedAimConeDirection(float aimCone, Vector3 inputVec, bool anywhereInside)
public Quaternion GetAimConeQuat(float aimCone)
}
public AlternateAttack : StateMachineBehaviour {
public bool random
public bool dontIncrement
public String[] targetTransitions
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public AmbienceDefinition : ScriptableObject {
public List`1<SoundDefinition> sounds
public ValueRange stingFrequency
public Enum biomes
public Enum topologies
public EnvironmentType environmentType
public bool useEnvironmentType
public AnimationCurve time
public ValueRange rain
public ValueRange wind
public ValueRange snow
}
public AmbienceDefinitionList : ScriptableObject {
public List`1<AmbienceDefinition> defs
}
public AmbienceEmitter : MonoBehaviour {
public AmbienceDefinitionList baseAmbience
public AmbienceDefinitionList stings
public bool isStatic
public bool active
public float cameraDistance
public BoundingSphere boundingSphere
public float crossfadeTime
private Enum <currentTopology>k__BackingField
private Enum <currentBiome>k__BackingField
public Dictionary`2<AmbienceDefinition, float> nextStingTime
public float deactivateTime
public Enum currentTopology
public Enum currentBiome
public Enum get_currentTopology()
private void set_currentTopology(Enum value)
public Enum get_currentBiome()
private void set_currentBiome(Enum value)
public int CompareTo(AmbienceEmitter other)
}
public AmbienceLocalStings : MonoBehaviour {
public float maxDistance
public float stingRadius
public float stingFrequency
public float stingFrequencyVariance
public SoundDefinition[] stingSounds
}
public AmbienceManager : SingletonComponent`1<AmbienceManager> {
public List`1<EmitterTypeLimit> localEmitterLimits
public EmitterTypeLimit catchallEmitterLimit
public int maxActiveLocalEmitters
public int activeLocalEmitters
public List`1<AmbienceEmitter> baseEmitters
public List`1<AmbienceEmitter> emittersInRange
public List`1<AmbienceEmitter> activeEmitters
public List`1<AmbienceEmitter> emitters
public float localEmitterRange
}
public AmbienceSpawnEmitters : MonoBehaviour {
public int baseEmitterCount
public int baseEmitterDistance
public GameObject emitterPrefab
}
public AmbientLightLOD : MonoBehaviour {
public float enabledRadius
protected void OnValidate()
}
public AmplifyOcclusion.VersionInfo : object {
public byte Major
public byte Minor
public byte Release
private string StageSuffix
private int m_major
private int m_minor
private int m_release
public int Number
private void .ctor(byte major, byte minor, byte release)
public string StaticToString()
public string ToString()
public int get_Number()
public VersionInfo Current()
public bool Matches(VersionInfo version)
}
public AmplifyOcclusionBase : MonoBehaviour {
public ApplicationMethod ApplyMethod
public SampleCountLevel SampleCount
public PerPixelNormalSource PerPixelNormals
public float Intensity
public Color Tint
public float Radius
public int PixelRadiusLimit
public float RadiusIntensity
public float PowerExponent
public float Bias
public float Thickness
public bool Downsample
public bool FadeEnabled
public float FadeStart
public float FadeLength
public float FadeToIntensity
public Color FadeToTint
public float FadeToRadius
public float FadeToPowerExponent
public float FadeToThickness
public bool BlurEnabled
public int BlurRadius
public int BlurPasses
public float BlurSharpness
public bool FilterEnabled
public float FilterBlending
public float FilterResponse
public bool TemporalDirections
public bool TemporalOffsets
public bool TemporalDilation
public bool UseMotionVectors
}
public ANDSwitch : IOEntity {
private float input1Amount
private float input2Amount
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
}
public AnimalAnimation : MonoBehaviour {
public BaseNpc Target
public Animator Animator
public MaterialEffect FootstepEffects
public Transform[] Feet
public string BaseFolder
}
public AnimalMultiSkin : object {
public Material[] multiSkin
}
public AnimalSensesLoadBalancer : LoadBalancer {
public ILoadBalancer animalSensesLoadBalancer
}
public AnimalSkin : MonoBehaviour {
public SkinnedMeshRenderer[] animalMesh
public AnimalMultiSkin[] animalSkins
private Model model
public bool dontRandomizeOnStart
private void Start()
public void ChangeSkin(int iSkin)
}
public AnimatedBuildingBlock : StabilityEntity {
private bool animatorNeedsInitializing
private bool animatorIsOpen
private bool isAnimating
public void ServerInit()
public void PostServerLoad()
public void OnFlagsChanged(Flags old, Flags next)
protected void UpdateAnimationParameters(bool init)
protected void OnAnimatorFinished()
private void PutAnimatorToSleep()
protected void OnAnimatorDisabled()
}
public AnimationEventForward : MonoBehaviour {
public GameObject targetObject
public void Event(string type)
}
public AnimationEvents : BaseMonoBehaviour {
public Transform rootObject
public HeldEntity targetEntity
public string effectFolder
public string localFolder
public bool IsBusy
protected void OnEnable()
}
public AntiHack : object {
private int movement_mask
private int grounded_mask
private int player_mask
private Collider[] buffer
private Dictionary`2<ulong, int> kicks
private Dictionary`2<ulong, int> bans
public void ResetTimer(BasePlayer ply)
public bool ShouldIgnore(OBB obb)
public bool ShouldIgnore(Vector3 pos)
public bool ValidateMove(BasePlayer ply, TickInterpolator ticks, float deltaTime)
public bool IsNoClipping(BasePlayer ply, TickInterpolator ticks, float deltaTime)
private bool TestNoClipping(BasePlayer ply, Vector3 oldPos, Vector3 newPos, bool sphereCast)
public bool IsSpeeding(BasePlayer ply, TickInterpolator ticks, float deltaTime)
public bool IsFlying(BasePlayer ply, TickInterpolator ticks, float deltaTime)
private bool TestFlying(BasePlayer ply, Vector3 oldPos, Vector3 newPos, bool verifyGrounded)
public void NoteAdminHack(BasePlayer ply)
public void FadeViolations(BasePlayer ply, float deltaTime)
public void EnforceViolations(BasePlayer ply)
public void Log(BasePlayer ply, AntiHackType type, string message)
private void LogToConsole(BasePlayer ply, AntiHackType type, string message)
private void LogToEAC(BasePlayer ply, AntiHackType type, string message)
public void AddViolation(BasePlayer ply, AntiHackType type, float amount)
public void Kick(BasePlayer ply, string reason)
public void Ban(BasePlayer ply, string reason)
private void AddRecord(BasePlayer ply, Dictionary`2<ulong, int> records)
public int GetKickRecord(BasePlayer ply)
public int GetBanRecord(BasePlayer ply)
private int GetRecord(BasePlayer ply, Dictionary`2<ulong, int> records)
}
public AntiHackType : Enum {
public int value__
public AntiHackType None
public AntiHackType NoClip
public AntiHackType SpeedHack
public AntiHackType FlyHack
public AntiHackType ProjectileHack
public AntiHackType MeleeHack
public AntiHackType EyeHack
public AntiHackType AttackHack
public AntiHackType ReloadHack
public AntiHackType CooldownHack
}
public Apex.AI.AINameMap : object {
public Guid AnimalAction
public Guid AnimalMovement
public Guid AnimalThink
public Guid HTNAllShoot
public Guid HTNOneAttackFromCover
public Guid HTNOneIdle
public Guid HTNOneKillPrimaryThreat
public Guid HTNOneReloadOrSwitchWeapon
public Guid HTNRootScientist
public Guid MurdererAction
public Guid MurdererMove
public Guid MurdererThink
public Guid NpcAnimalGeneric
public Guid NpcHumanBanditGuard
public Guid NpcHumanScientist
public Guid NpcHumanScientistCH47
public Guid NpcHumanScientistJunkpile
public Guid NpcHumanScientistMelee
public Guid NpcHumanScientistTactical
public Guid NpcHumanScientistTacticalMountable
public Guid NpcHumanScientistTargetSelectorCover
public Guid NpcHumanScientistTargetSelectorEnemyHideout
public Guid NpcHumanScientistTargetSelectorOtherEntities
public Guid NpcHumanScientistTargetSelectorPlayer
public Guid NpcHumanScientistTargetSelectorPlayerMounted
public Guid NPCPlayerAction
public Guid NPCPlayerIdle
public Guid NPCPlayerMove
public Guid NPCPlayerThink
public Guid ZombieAction
}
public Apex.AI.CompositeSumMustBeAboveThresholdQualifier : CompositeQualifier {
public float threshold
public float Score(IAIContext context, IList`1<IContextualScorer> scorers)
}
public ApplyTerrainAnchors : MonoBehaviour {
protected void Awake()
}
public ApplyTerrainModifiers : MonoBehaviour {
protected void Awake()
}
public ArmorInformationPanel : ItemInformationPanel {
public ItemTextValue projectileDisplay
public ItemTextValue meleeDisplay
public ItemTextValue coldDisplay
public ItemTextValue explosionDisplay
public ItemTextValue radiationDisplay
public ItemTextValue biteDisplay
public ItemTextValue spacer
public Text areaProtectionText
public Phrase LegText
public Phrase ChestText
public Phrase HeadText
public Phrase ChestLegsText
public Phrase WholeBodyText
}
public ArmorProperties : ScriptableObject {
public HitArea area
public bool Contains(HitArea hitArea)
}
public ArrayEx : object {
public T GetRandom(T[] array)
public T GetRandom(T[] array, UInt32 seed)
public T GetRandom(T[] array, UInt32& seed)
public void Shuffle(T[] array, UInt32 seed)
public void Shuffle(T[] array, UInt32& seed)
public void BubbleSort(T[] array)
}
public ArticulatedOccludee : BaseMonoBehaviour {
private float UpdateBoundsFadeStart
private float UpdateBoundsFadeLength
private float UpdateBoundsMaxFrequency
private float UpdateBoundsMinFrequency
public bool registerCullingOnStart
private LODGroup lodGroup
private List`1<Renderer> renderers
private List`1<Collider> colliders
private OccludeeSphere localOccludee
private bool isVisible
private SkinnedMeshRenderer fixedBoundsRef
public bool IsVisible
public SkinnedMeshRenderer FixedBoundsRef
public bool get_IsVisible()
public SkinnedMeshRenderer get_FixedBoundsRef()
public void set_FixedBoundsRef(SkinnedMeshRenderer value)
protected void OnEnable()
protected void OnDisable()
public void ClearVisibility()
public void ProcessVisibility(LODGroup lod, List`1<Collider> colliders)
public void ProcessVisibility(List`1<Renderer> renderers, List`1<Collider> colliders)
private void RegisterForCulling(Sphere sphere, bool visible)
private void UnregisterFromCulling()
public void UpdateCullingBounds()
protected bool CheckVisibility()
private void ApplyVisibility(bool vis)
protected void OnVisibilityChanged(bool visible)
private void UpdateVisibility(float delay)
private void VisUpdateUsingCulling(float dist, bool visibility)
public void TriggerUpdateVisibilityBounds()
}
public AssetNameCache : object {
private Dictionary`2<Object, string> mixed
private Dictionary`2<Object, string> lower
private Dictionary`2<Object, string> upper
private string LookupName(Object obj)
private string LookupNameLower(Object obj)
private string LookupNameUpper(Object obj)
public string GetName(PhysicMaterial mat)
public string GetNameLower(PhysicMaterial mat)
public string GetNameUpper(PhysicMaterial mat)
public string GetName(Material mat)
public string GetNameLower(Material mat)
public string GetNameUpper(Material mat)
}
public AssetStorage : object {
public void Save(T& asset, string path)
public void Save(Texture2D& asset)
public void Save(Texture2D& asset, string path, bool linear, bool compress)
public void Load(T& asset, string path)
public void Delete(T& asset)
}
public AsyncTerrainNavMeshBake : CustomYieldInstruction {
private List`1<int> indices
private List`1<Vector3> vertices
private List`1<Vector3> normals
private List`1<int> triangles
private Vector3 pivot
private int width
private int height
private bool normal
private bool alpha
private Action worker
public bool keepWaiting
public bool isDone
public Mesh mesh
public void .ctor(Vector3 pivot, int width, int height, bool normal, bool alpha)
public bool get_keepWaiting()
public bool get_isDone()
public NavMeshBuildSource CreateNavMeshBuildSource(bool addSourceObject)
public Mesh get_mesh()
private void DoWork()
private void Invoke()
private void Callback(IAsyncResult result)
}
public AtmosphereVolume : EnvironmentVolume {
public float FadeInDuration
public float FadeOutDuration
public float BoundsAttenuationScale
public FogSettings FogSettings
private BoxCollider collider
public Collider Collider
public Vector3 Extents
public float AttenuationDistance
public Collider get_Collider()
public Vector3 get_Extents()
public float get_AttenuationDistance()
protected void Awake()
}
public AtmosphereVolumeRenderer : MonoBehaviour {
public FogMode Mode
public bool DistanceFog
public bool HeightFog
}
public AttackEntity : HeldEntity {
public float deployDelay
public float repeatDelay
public float animationDelay
public float effectiveRange
public float npcDamageScale
public float attackLengthMin
public float attackLengthMax
public float attackSpacing
public float aiAimSwayOffset
public float aiAimCone
public WeaponTypeEnum effectiveRangeType
public SoundDefinition[] reloadSounds
public SoundDefinition thirdPersonMeleeSound
private float nextAttackTime
public float NextAttackTime
public void ServerUse()
public Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier)
public float get_NextAttackTime()
public void GetAttackStats(HitInfo info)
protected void StartAttackCooldown(float cooldown)
protected void ResetAttackCooldown()
protected bool HasAttackCooldown()
protected float GetAttackCooldown()
protected float GetAttackIdle()
protected float CalculateCooldownTime(float nextTime, float cooldown, bool catchup)
protected bool VerifyClientRPC(BasePlayer player)
protected bool VerifyClientAttack(BasePlayer player)
protected bool ValidateEyePos(BasePlayer player, Vector3 eyePos)
public void OnHeldChanged()
}
public AttractionPoint : PrefabAttribute {
public string groupName
protected Type GetIndexedType()
}
public AudioSettings : MonoBehaviour {
public AudioMixer mixer
private void Update()
private float LinearToDecibel(float linear)
}
public Auth_EAC : object {
public IEnumerator Run(Connection connection)
}
public Auth_Steam : object {
internal List`1<Connection> waitingList
public IEnumerator Run(Connection connection)
public bool ValidateConnecting(ulong steamid, ulong ownerSteamID, Status response)
}
public AutoTurret : StorageContainer {
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public float bulletSpeed
public AmbienceEmitter ambienceEmitter
public BaseCombatEntity target
public Transform eyePos
public Transform muzzlePos
public Vector3 aimDir
public Transform gun_yaw
public Transform gun_pitch
public float sightRange
public SoundDefinition turnLoopDef
public SoundDefinition movementChangeDef
public SoundDefinition ambientLoopDef
public SoundDefinition focusCameraDef
public float focusSoundFreqMin
public float focusSoundFreqMax
public GameObjectRef peacekeeperToggleSound
public GameObjectRef onlineSound
public GameObjectRef offlineSound
public GameObjectRef targetAcquiredEffect
public GameObjectRef targetLostEffect
public float aimCone
public List`1<PlayerNameID> authorizedPlayers
public ItemDefinition ammoType
private float nextShotTime
private float nextVisCheck
public float lastTargetSeenTime
private bool targetVisible
private bool booting
private float nextIdleAimTime
private Vector3 targetAimDir
private Item ammoItem
public float bulletDamage
private float nextForcedAimTime
private Vector3 lastSentAimDir
private Single[] visibilityOffsets
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsOnline()
public bool IsOffline()
public Transform GetCenterMuzzle()
public float AngleToTarget(BaseCombatEntity potentialtarget)
public bool InFiringArc(BaseCombatEntity potentialtarget)
public bool CanPickup(BasePlayer player)
public void Save(SaveInfo info)
public void PostSave(SaveInfo info)
public void Load(LoadInfo info)
public Vector3 AimOffset(BaseCombatEntity aimat)
public float GetAimSpeed()
public void UpdateAiming()
public bool IsAuthed(BasePlayer player)
public bool AnyAuthed()
public bool CanChangeSettings(BasePlayer player)
public bool SupportsPooling()
public bool PeacekeeperMode()
public void SetOnline()
public void SetIsOnline(bool online)
public void InitiateShutdown()
public void InitiateStartup()
public void SetPeacekeepermode(bool isOn)
private void FlipAim(RPCMessage rpc)
private void AddSelfAuthorize(RPCMessage rpc)
private void RemoveSelfAuthorize(RPCMessage rpc)
private void ClearList(RPCMessage rpc)
private void SERVER_TurnOn(RPCMessage rpc)
private void SERVER_TurnOff(RPCMessage rpc)
private void SERVER_Peacekeeper(RPCMessage rpc)
private void SERVER_AttackAll(RPCMessage rpc)
public float TargetScanRate()
public void ServerInit()
public void SendAimDir()
public void SetTarget(BaseCombatEntity targ)
public bool CheckPeekers()
public bool ObjectVisible(BaseCombatEntity obj)
public void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target)
private void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
public void IdleTick()
public bool HasAmmo()
public void Reload()
public void EnsureReloaded()
public void PlayerStoppedLooting(BasePlayer player)
public void TargetTick()
public bool HasTarget()
public void OfflineTick()
public bool IsEntityHostile(BaseCombatEntity ent)
public void TargetScan()
protected bool Ignore(BasePlayer player)
public void ServerTick()
public void OnAttacked(HitInfo info)
public void UpdateFacingToTarget()
}
public AverageVelocity : object {
private Vector3 pos
private float time
private float lastEntry
private float averageSpeed
private Vector3 averageVelocity
public float Speed
public Vector3 Average
public void Record(Vector3 newPos)
public float get_Speed()
public Vector3 get_Average()
}
public Barricade : DecayEntity {
public float reflectDamage
public GameObjectRef reflectEffect
public bool canNpcSmash
public NavMeshModifierVolume NavMeshVolumeAnimals
public NavMeshModifierVolume NavMeshVolumeHumanoids
public NPCBarricadeTriggerBox NpcTriggerBox
private int nonWalkableArea
private int animalAgentTypeId
private int humanoidAgentTypeId
public void ServerInit()
public void OnAttacked(HitInfo info)
}
public BaseAIBrain`1 : EntityComponent`1<T> {
public BasicAIState[] AIStates
public int AIStateIndex_UNSET
public int _currentState
public Vector3 mainInterestPoint
public T GetEntity()
public void Awake()
public void InitializeAI()
public void AddState(BasicAIState<T> newState, int newIndex)
public BasicAIState<T> GetCurrentState()
public BasicAIState<T> GetState(int index)
public void SwitchToState(int newState)
public void AIThink(float delta)
}
public BaseAimable : BaseVehicleMountPoint {
public Transform aimBase
}
public BaseAnimalNPC : BaseNpc {
public void OnKilled(HitInfo hitInfo)
}
public BaseBoat : BaseVehicle {
public float engineThrust
public float steeringScale
public float gasPedal
public float steering
public Rigidbody myRigidBody
public Transform thrustPoint
public Transform centerOfMass
public Buoyancy buoyancy
public GameObject clientCollider
public GameObject serverCollider
public float MaxVelocity()
public bool PhysicsDriven()
public void ServerInit()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void DriverInput(InputState inputState, BasePlayer player)
public bool EngineOn()
public void VehicleFixedUpdate()
public bool EngineInWater()
public float WaterFactorForPlayer(BasePlayer player)
public bool IsFlipped()
public float GetWaterDepth(Vector3 pos)
public List`1<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore, float minWaterDepth)
}
public BaseCar : BaseWheeledVehicle {
public float brakePedal
public float gasPedal
public float steering
public Transform centerOfMass
public Transform steeringWheel
public float motorForceConstant
public float brakeForceConstant
public float GasLerpTime
public float SteeringLerpTime
public Transform driverEye
public Rigidbody myRigidBody
private bool chairtest
public GameObjectRef chairRef
public Transform chairAnchorTest
private float throttle
private float brake
private bool lightsOn
public float MaxVelocity()
public Vector3 EyePositionForPlayer(BasePlayer player)
public float GetComfort()
public void ServerInit()
public void SpawnChairTest()
public void FixedUpdate()
private void DoSteering()
public void ConvertInputToThrottle()
private void ApplyForceAtWheels()
public void NoDriverInput()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void DriverInput(InputState inputState, BasePlayer player)
public void LightToggle(BasePlayer player)
}
public BaseChair : BaseMountable {
public float GetComfort()
}
public BaseCollision : MonoBehaviour {
public BaseEntity Owner
public Model model
}
public BaseCombatEntity : BaseEntity {
public SkeletonProperties skeletonProperties
public ProtectionProperties baseProtection
public float startHealth
public Pickup pickup
public Repair repair
public bool ShowHealthInfo
public LifeState lifestate
public bool sendsHitNotification
public bool sendsMeleeHitNotification
public bool markAttackerHostile
public float _health
public float _maxHealth
public float lastAttackedTime
private Vector3 <LastAttackedDir>k__BackingField
public float lastDealtDamageTime
private int lastNotifyFrame
private float MAX_HEALTH_REPAIR
public DamageType lastDamage
public BaseEntity lastAttacker
public Collider _collider
public bool ResetLifeStateOnSpawn
public DirectionProperties[] propDirection
public float unHostileTime
public float unBanditHostileTime
private Func`2<ItemAmount, float> <>f__am$cache0
public Vector3 LastAttackedDir
public float SecondsSinceAttacked
public float SecondsSinceDealtDamage
public float healthFraction
public float health
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsDead()
public bool IsAlive()
public Vector3 get_LastAttackedDir()
public void set_LastAttackedDir(Vector3 value)
public float get_SecondsSinceAttacked()
public float get_SecondsSinceDealtDamage()
public float get_healthFraction()
public void set_healthFraction(float value)
public void ResetState()
public void DestroyShared()
public float GetThreatLevel()
public float PenetrationResistance(HitInfo info)
public void ScaleDamage(HitInfo info)
public HitArea SkeletonLookup(UInt32 boneID)
public void Save(SaveInfo info)
public void PostServerLoad()
public void Load(LoadInfo info)
public float get_health()
public void set_health(float value)
public float Health()
public float MaxHealth()
public float StartHealth()
public float StartMaxHealth()
public void DoHitNotify(HitInfo info)
public void OnAttacked(HitInfo info)
public bool CanPickup(BasePlayer player)
public void OnPickedUp(Item createdItem, BasePlayer player)
private void RPC_PickupStart(RPCMessage rpc)
public List`1<ItemAmount> BuildCost()
public float RepairCostFraction()
public List`1<ItemAmount> RepairCost(float healthMissingFraction)
public void OnRepair()
public void OnRepairFinished()
public void OnRepairFailed()
public void DoRepair(BasePlayer player)
public void InitializeHealth(float newhealth, float newmax)
public void ServerInit()
public void Hurt(float amount)
public void Hurt(float amount, DamageType type, BaseEntity attacker, bool useProtection)
public void Hurt(HitInfo info)
protected void MarkBanditZoneHurtHostiliy(BaseCombatEntity attacker)
public bool IsHostile()
public void MarkHostileFor(float duration)
public bool IsBanditHostile()
public void MarkBanditHostileFor(float duration)
private void DebugHurt(HitInfo info)
public void ChangeHealth(float amount)
public void OnHealthChanged(float oldvalue, float newvalue)
public void Heal(float amount)
public void OnKilled(HitInfo info)
public void Die(HitInfo info)
public void DieInstantly()
public void UpdateSurroundings()
private float <DoRepair>m__0(ItemAmount x)
}
public BaseCommandBuffer : MonoBehaviour {
private Dictionary`2<Camera, Dictionary`2<int, CommandBuffer>> cameras
protected CommandBuffer GetCommandBuffer(string name, Camera camera, CameraEvent cameraEvent)
protected void CleanupCamera(string name, Camera camera, CameraEvent cameraEvent)
protected void CleanupCommandBuffer(Camera camera, CameraEvent cameraEvent)
protected void Cleanup()
}
public BaseCorpse : BaseCombatEntity {
public GameObjectRef prefabRagdoll
public BaseEntity parentEnt
internal ResourceDispenser resourceDispenser
public TraitFlag Traits
public void ServerInit()
public void InitCorpse(BaseEntity pr)
public bool CanRemove()
public void RemoveCorpse()
public void ResetRemovalTime(float dur)
public float GetRemovalTime()
public void ResetRemovalTime()
public void Save(SaveInfo info)
public void TakeChildren(BaseEntity takeChildrenFrom)
private Rigidbody SetupRigidBody()
public void Load(LoadInfo info)
private void Load(Corpse corpse)
public void OnAttacked(HitInfo info)
public string Categorize()
public TraitFlag get_Traits()
public void Eat(BaseNpc baseNpc, float timeSpent)
}
public BaseEntity : BaseNetworkable {
public Bounds bounds
public GameObjectRef impactEffect
public bool enableSaving
public bool syncPosition
public Model model
public Flags flags
public UInt32 parentBone
public ulong skinID
private EntityComponentBase[] _components
public string _name
private ulong <OwnerID>k__BackingField
private Queue`1<BaseEntity> globalBroadcastQueue
private UInt32 globalBroadcastProtocol
private UInt32 broadcastProtocol
private List`1<EntityLink> links
private bool linkedToNeighbours
public EntityRef parentEntity
private Spawnable _spawnable
public HashSet`1<BaseEntity> saveList
public BaseEntity creatorEntity
private int doneMovingWithoutARigidBodyCheck
private bool isCallingUpdateNetworkGroup
private EntityRef[] entitySlots
protected List`1<TriggerBase> triggers
protected bool isVisible
protected bool isAnimatorVisible
protected bool isShadowVisible
protected OccludeeSphere localOccludee
public EntityComponentBase[] Components
public bool IsNpc
public ulong OwnerID
protected float PositionTickRate
public Vector3 ServerPosition
public Quaternion ServerRotation
public float radiationLevel
public float currentTemperature
public TraitFlag Traits
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnCollision(Collision collision, BaseEntity hitEntity)
protected void ReceiveCollisionMessages(bool b)
public EntityComponentBase[] get_Components()
public BasePlayer ToPlayer()
public bool get_IsNpc()
public void InitShared()
public void DestroyShared()
public void ResetState()
public OBB WorldSpaceBounds()
public Vector3 PivotPoint()
public Vector3 CenterPoint()
public Vector3 ClosestPoint(Vector3 position)
public float Distance(Vector3 position)
public float SqrDistance(Vector3 position)
public float Distance(BaseEntity other)
public float SqrDistance(BaseEntity other)
public float Distance2D(Vector3 position)
public float SqrDistance2D(Vector3 position)
public float Distance2D(BaseEntity other)
public float SqrDistance2D(BaseEntity other)
public bool IsVisible(Ray ray, float maxDistance)
public bool IsVisible(Vector3 position, Vector3 target, float maxDistance)
public bool IsVisible(Vector3 position, float maxDistance)
public bool IsOlderThan(BaseEntity other)
public bool IsOutside()
public bool IsOutside(Vector3 position)
public float WaterFactor()
public float Health()
public float MaxHealth()
public float MaxVelocity()
public float BoundsPadding()
public float PenetrationResistance(HitInfo info)
public GameObjectRef GetImpactEffect(HitInfo info)
public void OnAttacked(HitInfo info)
public Item GetItem()
public Item GetItem(UInt32 itemId)
public void GiveItem(Item item, GiveItemReason reason)
public bool CanBeLooted(BasePlayer player)
public BaseEntity GetEntity()
public string ToString()
public string Categorize()
public void Log(string str)
public void SetModel(Model mdl)
public void SwitchToFastPhysics()
public ulong get_OwnerID()
public void set_OwnerID(ulong value)
public bool ShouldBlockProjectiles()
public void DebugServer(int rep, float time)
public string DebugText()
public void OnDebugStart()
protected void DebugText(Vector3 pos, string str, Color color, float time)
public bool HasFlag(Flags f)
public bool ParentHasFlag(Flags f)
public void SetFlag(Flags f, bool b, bool recursive)
public bool IsOn()
public bool IsOpen()
public bool IsOnFire()
public bool IsLocked()
public bool IsDebugging()
public bool IsDisabled()
public bool IsBroken()
public bool IsBusy()
public string GetLogColor()
public void OnFlagsChanged(Flags old, Flags next)
public bool IsOccupied(Socket_Base socket)
public bool IsOccupied(string socketName)
public EntityLink FindLink(Socket_Base socket)
public EntityLink FindLink(string socketName)
public T FindLinkedEntity()
public void EntityLinkMessage(Action`1<T> action)
public void EntityLinkBroadcast(Action`1<T> action)
public void EntityLinkBroadcast()
public bool ReceivedEntityLinkBroadcast()
public List`1<EntityLink> GetEntityLinks(bool linkToNeighbours)
private void LinkToEntity(BaseEntity other)
private void LinkToNeighbours()
private void InitEntityLinks()
private void FreeEntityLinks()
public void RefreshEntityLinks()
public void SV_RequestFile(RPCMessage msg)
public BaseEntity GetParentEntity()
public void SetParent(BaseEntity entity, string strBone)
public bool HasChild(BaseEntity c)
public bool HasParent()
public void SetParent(BaseEntity entity, UInt32 boneID)
private void DestroyOnClient(Connection connection)
private void SendChildrenNetworkUpdate()
public void ParentBecoming(BaseEntity ent)
public BuildingPrivlidge GetBuildingPrivilege()
public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
public void SV_RPCMessage(UInt32 nameID, Message message)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1)
public void ClientRPC(Connection sourceConnection, string funcName)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName)
private bool ClientRPCStart(Connection sourceConnection, string funcName)
private void ClientRPCWrite(T arg)
private void ClientRPCSend(SendInfo sendInfo)
public void Save(SaveInfo info)
public bool ShouldNetworkOwnerInfo()
public void Load(LoadInfo info)
public void ServerInit()
public void OnSensation(Sensation sensation)
public void OnSensation(Sensation sensation, BasePlayer invoker)
protected float get_PositionTickRate()
protected void NetworkPositionTick()
private void TransformChanged()
public void OnPositionalNetworkUpdate()
public void DoMovingWithoutARigidBodyCheck()
public void SpawnAsMapEntity()
public void PostMapEntitySpawn()
internal void DoServerDestroy()
internal void OnParentRemoved()
public void OnInvalidPosition()
public BaseCorpse DropCorpse(string strCorpsePrefab)
public void UpdateNetworkGroup()
public void Eat(BaseNpc baseNpc, float timeSpent)
public void OnDeployed(BaseEntity parent)
public bool ShouldNetworkTo(BasePlayer player)
public void AttackerInfo(DeathInfo info)
public void Push(Vector3 velocity)
public void SetVelocity(Vector3 velocity)
public void SetAngularVelocity(Vector3 velocity)
public Vector3 GetDropPosition()
public Vector3 GetDropVelocity()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public Vector3 get_ServerPosition()
public void set_ServerPosition(Vector3 value)
public Quaternion get_ServerRotation()
public void set_ServerRotation(Quaternion value)
public float get_radiationLevel()
public float RadiationProtection()
public float RadiationExposureFraction()
public float get_currentTemperature()
private void BroadcastSignalFromClient(RPCMessage msg)
public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection)
public void SignalBroadcast(Signal signal, Connection sourceConnection)
private void OnSkinChanged(ulong oldSkinID, ulong newSkinID)
public bool HasAnySlot()
public BaseEntity GetSlot(Slot slot)
public string GetSlotAnchorName(Slot slot)
public void SetSlot(Slot slot, BaseEntity ent)
public bool HasSlot(Slot slot)
public TraitFlag get_Traits()
public bool HasTrait(TraitFlag f)
public bool HasAnyTrait(TraitFlag f)
public bool EnterTrigger(TriggerBase trigger)
public void LeaveTrigger(TriggerBase trigger)
public void RemoveFromTriggers()
public T FindTrigger()
}
public BaseEntityChild : MonoBehaviour {
public void Setup(GameObject obj, BaseEntity parent)
public void OnDestroy()
}
public BaseEntityEx : object {
public bool IsValid(BaseEntity ent)
}
public BaseFootstepEffect : MonoBehaviour {
public LayerMask validImpactLayers
}
public BaseHelicopter : BaseCombatEntity {
public GameObject rotorPivot
public GameObject mainRotor
public GameObject mainRotor_blades
public GameObject mainRotor_blur
public GameObject tailRotor
public GameObject tailRotor_blades
public GameObject tailRotor_blur
public GameObject rocket_tube_left
public GameObject rocket_tube_right
public GameObject left_gun_yaw
public GameObject left_gun_pitch
public GameObject left_gun_muzzle
public GameObject right_gun_yaw
public GameObject right_gun_pitch
public GameObject right_gun_muzzle
public GameObject spotlight_rotation
public GameObjectRef rocket_fire_effect
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public GameObjectRef explosionEffect
public GameObjectRef fireBall
public GameObjectRef crateToDrop
public int maxCratesToSpawn
public float bulletSpeed
public float bulletDamage
public GameObjectRef servergibs
public GameObjectRef debrisFieldMarker
public SoundDefinition rotorWashSoundDef
public SoundDefinition engineSoundDef
public SoundDefinition rotorSoundDef
private Sound _engineSound
private Sound _rotorSound
private Sound _rotorWashSound
public float spotlightJitterAmount
public float spotlightJitterSpeed
public GameObject[] nightLights
public Vector3 spotlightTarget
public float engineSpeed
public float targetEngineSpeed
public float blur_rotationScale
public ParticleSystem[] _rotorWashParticles
private PatrolHelicopterAI myAI
private float lastNetworkUpdate
private float networkUpdateRate
public weakspot[] weakspots
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float MaxVelocity()
public void InitShared()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ServerInit()
public void OnPositionalNetworkUpdate()
public void CreateExplosionMarker(float durationMinutes)
public void OnKilled(HitInfo info)
public void Update()
public void InitalizeWeakspots()
public void OnAttacked(HitInfo info)
public void Hurt(HitInfo info)
}
public BaseHelicopterVehicle : BaseVehicle {
public Rigidbody rigidBody
public float engineThrustMax
public Vector3 torqueScale
public Transform com
public Transform[] GroundPoints
public Transform[] GroundEffects
public GameObjectRef explosionEffect
public GameObjectRef fireBall
public Flags Flag_InternalLights
private HelicopterInputState_t currentInputState
private float lastPlayerInputTime
public float currentThrottle
public float avgThrust
public float liftDotMax
public float altForceDotMin
public float liftFraction
protected float hoverForceScale
public float MaxVelocity()
public void ServerInit()
public float MouseToBinary(float amount)
public void PilotInput(InputState inputState, BasePlayer player)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public HelicopterInputState_t GetDefaultInputState()
public void VehicleFixedUpdate()
public void LightToggle(BasePlayer player)
public void MovementUpdate()
public void DelayedImpactDamage()
public bool CollisionDamageEnabled()
private void OnCollisionEnter(Collision collision)
public void OnKilled(HitInfo info)
}
public BaseLadder : BaseCombatEntity {
public bool ShouldBlockProjectiles()
}
public BaseLauncher : BaseProjectile {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void SV_Launch(RPCMessage msg)
}
public BaseLiquidVessel : AttackEntity {
public GameObjectRef thrownWaterObject
public GameObjectRef ThrowEffect3P
public SoundDefinition throwSound3P
public GameObjectRef fillFromContainer
public GameObjectRef fillFromWorld
public bool hasLid
public float throwScale
public bool canDrinkFrom
public bool updateVMWater
public float minThrowFrac
public bool useThrowAnim
public float fillMlPerSec
private float lastFillTime
private float nextFreeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void OnHeldChanged()
public void SetFilling(bool isFilling)
public void StartFilling()
public void StopFilling()
public void FillCheck()
public void LoseWater(int amount)
public void AddLiquid(ItemDefinition liquidType, int amount)
public int AmountHeld()
public float HeldFraction()
public int MaxHoldable()
public bool CanDrink()
private bool IsWeaponBusy()
private void SetBusyFor(float dur)
private void ClearBusy()
private void DoDrink(RPCMessage msg)
private void ThrowContents(RPCMessage msg)
public void DoThrow(Vector3 pos, Vector3 velocity)
private void SendFilling(RPCMessage msg)
public bool CanFillFromWorld()
public bool CanThrow()
public LiquidContainer GetFacingLiquidContainer()
}
public BaseLock : BaseEntity {
public ItemDefinition itemType
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool GetPlayerLockPermission(BasePlayer player)
public bool OnTryToOpen(BasePlayer player)
public bool OnTryToClose(BasePlayer player)
public bool HasLockPermission(BasePlayer player)
public void RPC_TakeLock(RPCMessage rpc)
public bool SupportsPooling()
public float BoundsPadding()
}
public BaseMelee : AttackEntity {
public DamageProperties damageProperties
public List`1<DamageTypeEntry> damageTypes
public float maxDistance
public float attackRadius
public bool isAutomatic
public GameObjectRef strikeFX
public bool useStandardHitEffects
public float aiStrikeDelay
public GameObjectRef swingEffect
public List`1<MaterialFX> materialStrikeFX
public float heartStress
public GatherProperties gathering
public bool canThrowAsProjectile
public bool canAiHearIt
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void GetAttackStats(HitInfo info)
public void DoAttackShared(HitInfo info)
public GatherPropertyEntry GetGatherInfoFromIndex(GatherType index)
public bool CanHit(HitTest info)
public float TotalDamage()
public bool IsItemBroken()
public void LoseCondition(float amount)
public float GetConditionLoss()
public void UpdateItemCondition(HitInfo info)
public void PlayerAttack(RPCMessage msg)
public bool CanBeUsedInWater()
public string GetStrikeEffectPath(string materialName)
public void ServerUse()
public void ServerUse_Strike()
private void CLProject(RPCMessage msg)
}
public BaseMetabolism : object {
public float targetHeartRate
}
public BaseMetabolism`1 : EntityComponent`1<T> {
protected T owner
public MetabolismAttribute calories
public MetabolismAttribute hydration
public MetabolismAttribute heartrate
protected float timeSinceLastMetabolism
public void Reset()
protected void OnDisable()
public void ServerInit(T owner)
public void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
protected void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
protected void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
public void ApplyChange(Type type, float amount, float time)
public bool ShouldDie()
public MetabolismAttribute FindAttribute(Type type)
}
public BaseMonoBehaviour : FacepunchBehaviour {
public bool IsDebugging()
public string GetLogColor()
public void LogEntry(LogEntryType log, int level, string str, object arg1)
public void LogEntry(LogEntryType log, int level, string str, object arg1, object arg2)
public void LogEntry(LogEntryType log, int level, string str)
}
public BaseMountable : BaseCombatEntity {
public BasePlayer _mounted
public Transform eyeOverride
public Vector2 pitchClamp
public Vector2 yawClamp
public bool canWieldItems
public MountPoses mountPose
public float maxMountDistance
public Transform mountAnchor
public Transform dismountAnchor
public Transform[] dismountPositions
public Transform dismountCheckEyes
public SoundDefinition mountSoundDef
public SoundDefinition dismountSoundDef
public bool isMobile
public float playerHeight
public float playerRadius
public Vector3 DISMOUNT_POS_INVALID
protected float PositionTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanHoldItems()
public bool DirectlyMountable()
public Vector3 EyePositionForPlayer(BasePlayer player)
public float WaterFactorForPlayer(BasePlayer player)
public float MaxVelocity()
public void PostServerLoad()
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public float GetSteering(BasePlayer player)
public void LightToggle(BasePlayer player)
public bool IsMounted()
public BasePlayer GetMounted()
protected float get_PositionTickRate()
public bool CanPickup(BasePlayer player)
public void OnKilled(HitInfo info)
public void RPC_WantsMount(RPCMessage msg)
public void AttemptMount(BasePlayer player)
public bool AttemptDismount(BasePlayer player)
public void RPC_WantsDismount(RPCMessage msg)
public void MountPlayer(BasePlayer player)
public void DismountAllPlayers()
public void DismountPlayer(BasePlayer player, bool lite)
public BaseVehicle VehicleParent()
public Vector3 DismountVisCheckOrigin()
public bool ValidDismountPosition(Vector3 disPos)
public bool HasValidDismountPosition(BasePlayer player)
public Vector3 GetDismountPosition(BasePlayer player)
public void ServerInit()
public void FixedUpdate()
public void VehicleFixedUpdate()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public float GetComfort()
public bool NearMountPoint(BasePlayer player)
public Vector3 ConvertVector(Vector3 vec)
}
public BaseMovement : MonoBehaviour {
public bool adminCheat
public float adminSpeed
}
public BaseNetworkable : BaseMonoBehaviour {
public UInt32 prefabID
public bool globalBroadcast
public Networkable net
private bool <IsDestroyed>k__BackingField
private string _prefabName
private string _prefabNameWithoutExtension
public EntityRealm serverEntities
private bool isServersideEntity
public bool _limitedNetworking
public List`1<BaseEntity> children
public int creationFrame
public bool isSpawned
private MemoryStream _NetworkCache
public Queue`1<MemoryStream> EntityMemoryStreamPool
private MemoryStream _SaveCache
public bool IsDestroyed
public string PrefabName
public string ShortPrefabName
public bool isServer
public bool isClient
public bool limitNetworking
public GameManager gameManager
public Library prefabAttribute
public Group GlobalNetworkGroup
public Group LimboNetworkGroup
public bool get_IsDestroyed()
private void set_IsDestroyed(bool value)
public string get_PrefabName()
public string get_ShortPrefabName()
public Vector3 GetNetworkPosition()
public Quaternion GetNetworkRotation()
public bool PhysicsDriven()
public float GetNetworkTime()
public string InvokeString()
public BaseEntity LookupPrefab()
public bool EqualNetID(BaseNetworkable other)
public bool SupportsPooling()
public void ResetState()
public void InitShared()
public void PreInitShared()
public void PostInitShared()
public void DestroyShared()
public void OnNetworkGroupEnter(Group group)
public void OnNetworkGroupLeave(Group group)
public void OnNetworkGroupChange()
public void OnNetworkSubscribersEnter(List`1<Connection> connections)
public void OnNetworkSubscribersLeave(List`1<Connection> connections)
private void EntityDestroy()
private void DoEntityDestroy()
private void SpawnShared()
public void Save(SaveInfo info)
public void PostSave(SaveInfo info)
public void InitLoad(UInt32 entityID)
public void PreServerLoad()
public void Load(LoadInfo info)
public void PostServerLoad()
public bool get_isServer()
public bool get_isClient()
public T ToServer()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public IEnumerable`1<Connection> GetConnectionsWithin(Vector3 position, float distance)
public bool get_limitNetworking()
public void set_limitNetworking(bool value)
private void OnNetworkLimitStart()
private void OnNetworkLimitEnd()
public void AddChild(BaseEntity child)
public void RemoveChild(BaseEntity child)
public GameManager get_gameManager()
public Library get_prefabAttribute()
public Group get_GlobalNetworkGroup()
public Group get_LimboNetworkGroup()
public void Spawn()
public void ServerInit()
protected List`1<Connection> GetSubscribers()
public void KillMessage()
public void Kill(DestroyMode mode)
private void Term(DestroyMode mode)
internal void DoServerDestroy()
public bool ShouldNetworkTo(BasePlayer player)
protected void SendNetworkGroupChange()
protected void SendAsSnapshot(Connection connection, bool justCreated)
public void SendNetworkUpdate(NetworkQueue queue)
public void SendNetworkUpdateImmediate(bool justCreated)
protected void SendNetworkUpdate_Position()
private void ToStream(Stream stream, SaveInfo saveInfo)
public bool CanUseNetworkCache(Connection connection)
public void ToStreamForNetwork(Stream stream, SaveInfo saveInfo)
public void InvalidateNetworkCache()
public MemoryStream GetSaveCache()
public void UpdateNetworkGroup()
private bool <OnNetworkLimitStart>m__0(Connection x)
}
public BaseNpc : BaseCombatEntity {
public int agentTypeIndex
public bool NewAI
private bool <IsStuck>k__BackingField
private Vector3 stepDirection
private Vector2i <CurrentCoord>k__BackingField
private Vector2i <PreviousCoord>k__BackingField
private bool <AgencyUpdateRequired>k__BackingField
private bool <IsOnOffmeshLinkAndReachedNewCoord>k__BackingField
private float maxFleeTime
private float fleeHealthThresholdPercentage
private float blockEnemyTargetingTimeout
private float blockFoodTargetingTimeout
private float aggroTimeout
private float lastAggroChanceResult
private float lastAggroChanceCalcTime
private float aggroChanceRecalcTimeout
private float eatTimeout
private float wakeUpBlockMoveTimeout
private BaseEntity blockTargetingThisEnemy
public float waterDepth
public bool swimming
public bool wasSwimming
private AnimationCurve speedFractionResponse
private bool _traversingNavMeshLink
private OffMeshLinkData _currentNavMeshLink
private string _currentNavMeshLinkName
private float _currentNavMeshLinkTraversalTime
private float _currentNavMeshLinkTraversalTimeDelta
private Quaternion _currentNavMeshLinkOrientation
private Vector3 _currentNavMeshLinkEndPos
private float nextAttackTime
public Enum topologyPreference
public Transform ChaseTransform
public GameObjectRef CorpsePrefab
public AiStatistics Stats
public Vector3 AttackOffset
public float AttackDamage
public DamageType AttackDamageType
public float AttackCost
public float AttackRate
public float AttackRange
public NavMeshAgent NavAgent
private UtilityAIComponent utilityAiComponent
public LayerMask movementMask
public BaseContext AiContext
private bool _isDormant
private float lastSetDestinationTime
private BaseEntity <AttackTarget>k__BackingField
private SeenInfo <AttackTargetMemory>k__BackingField
private BaseEntity <FoodTarget>k__BackingField
private Vector3 <SpawnPosition>k__BackingField
public StateTimer BusyTimer
public float Sleep
public VitalLevel Stamina
public VitalLevel Energy
public VitalLevel Hydration
private Behaviour <CurrentBehaviour>k__BackingField
public AiFlags aiFlags
public Byte[] CurrentFacts
public int ForgetUnseenEntityTime
public float SensesTickRate
public BaseEntity[] SensesResults
private List`1<NavPointSample> navPointSamples
private float lastTickTime
private float playerTargetDecisionStartTime
private float animalTargetDecisionStartTime
private bool isAlreadyCheckingPathPending
private int numPathPendingAttempts
private float accumPathPendingDelay
public float TickRate
private Vector3 lastStuckPos
public float stuckDuration
public float lastStuckTime
public float idleDuration
private float nextFlinchTime
private float _lastHeardGunshotTime
private Vector3 <LastHeardGunshotDirection>k__BackingField
private float <TargetSpeed>k__BackingField
private Func`2<BaseEntity, bool> <>f__mg$cache0
private bool Apex.LoadBalancing.ILoadBalanced.repeat
public int AgentTypeIndex
public bool IsStuck
public Vector2i CurrentCoord
public Vector2i PreviousCoord
public bool AgencyUpdateRequired
public bool IsOnOffmeshLinkAndReachedNewCoord
public float GetAttackRate
public bool IsNpc
public bool IsDormant
public float SecondsSinceLastSetDestination
public float LastSetDestinationTime
public Vector3 Destination
public bool IsStopped
public bool AutoBraking
public bool HasPath
public BaseEntity AttackTarget
public SeenInfo AttackTargetMemory
public BaseEntity FoodTarget
public BaseCombatEntity CombatTarget
public Vector3 SpawnPosition
public float AttackTargetVisibleFor
public float TimeAtDestination
public BaseCombatEntity Entity
public NavMeshAgent GetNavAgent
public AiStatistics GetStats
public float GetAttackRange
public Vector3 GetAttackOffset
public float GetStamina
public float GetEnergy
public float GetAttackCost
public float GetSleep
public Vector3 CurrentAimAngles
public float GetStuckDuration
public float GetLastStuckTime
public Vector3 AttackPosition
public Vector3 CrouchedAttackPosition
public float currentBehaviorDuration
public Behaviour CurrentBehaviour
public bool IsSitting
public bool IsChasing
public bool IsSleeping
public float SecondsSinceLastHeardGunshot
public Vector3 LastHeardGunshotDirection
public float TargetSpeed
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int get_AgentTypeIndex()
public void set_AgentTypeIndex(int value)
public bool get_IsStuck()
public void set_IsStuck(bool value)
public Vector2i get_CurrentCoord()
public void set_CurrentCoord(Vector2i value)
public Vector2i get_PreviousCoord()
public void set_PreviousCoord(Vector2i value)
public bool get_AgencyUpdateRequired()
public void set_AgencyUpdateRequired(bool value)
public bool get_IsOnOffmeshLinkAndReachedNewCoord()
public void set_IsOnOffmeshLinkAndReachedNewCoord(bool value)
public string DebugText()
public void TickAi()
private void TickSpeed()
protected void TickMetabolism()
public bool WantsToEat(BaseEntity best)
public float FearLevel(BaseEntity ent)
public float HateLevel(BaseEntity ent)
protected void TickSleep()
public void TickNavigationWater()
public void TickNavigation()
private void UpdateCoords()
private void TickChase()
private void HandleNavMeshLinkTraversal(float delta, Vector3& moveToPosition)
private bool HandleNavMeshLinkTraversalStart(float delta)
private void HandleNavMeshLinkTraversalTick(float delta, Vector3& moveToPosition)
private bool IsNavMeshLinkTraversalComplete(float delta, Vector3& moveToPosition)
private void CompleteNavMeshLink()
private void TickNavMeshLinkTraversal(Vector3& moveToPosition)
private bool IsNavMeshLinkTraversalComplete(Vector3 moveToPosition, Vector3 targetPosition)
private void TraverseLink(Vector3& moveToPosition, Vector3 targetPosition)
private void CompleteNavMeshLinkTraversal(bool failed, Vector3& moveToPosition)
private void TickFollowPath(Vector3& moveToPosition)
private bool ValidateNextPosition(Vector3& moveToPosition)
private void UpdatePositionAndRotation(Vector3 moveToPosition)
private void TickIdle()
public void TickStuck()
public void OnBecomeStuck()
public void OnBecomeUnStuck()
public void UpdateAiRotation()
public float get_GetAttackRate()
public bool AttackReady()
public void StartAttack()
public void StartAttack(AttackType type, BaseCombatEntity target)
public void Eat()
public void AddCalories(float amount)
public void Startled()
private bool IsAfraid()
private bool IsAfraidOf(FamilyEnum family)
private bool CheckHealthThresholdToFlee()
private void TickBehaviourState()
private void WantsToFlee()
private void TickFlee()
public bool BlockEnemyTargeting(float timeout)
private void TickBlockEnemyTargeting()
public bool BlockFoodTargeting(float timeout)
private void TickBlockFoodTargeting()
public bool TryAggro(EnemyRangeEnum range)
public bool StartAggro(float timeout)
private void TickAggro()
public bool StartEating(float timeout)
private void TickEating()
public bool WakeUpBlockMove(float timeout)
private void TickWakeUpBlockMove()
private void OnFactChanged(Facts fact, byte oldValue, byte newValue)
public int TopologyPreference()
public void UpdateDestination(Vector3 position)
public void UpdateDestination(Transform tx)
public void StopMoving()
public bool get_IsNpc()
public bool get_IsDormant()
public void set_IsDormant(bool value)
public float get_SecondsSinceLastSetDestination()
public float get_LastSetDestinationTime()
public Vector3 get_Destination()
public void set_Destination(Vector3 value)
public bool get_IsStopped()
public void set_IsStopped(bool value)
public bool get_AutoBraking()
public void set_AutoBraking(bool value)
public bool get_HasPath()
public bool IsNavRunning()
public void Pause()
public void Resume()
private IEnumerator TryForceToNavmesh()
public BaseEntity get_AttackTarget()
public void set_AttackTarget(BaseEntity value)
public SeenInfo get_AttackTargetMemory()
public void set_AttackTargetMemory(SeenInfo value)
public BaseEntity get_FoodTarget()
public void set_FoodTarget(BaseEntity value)
public BaseCombatEntity get_CombatTarget()
public Vector3 get_SpawnPosition()
public void set_SpawnPosition(Vector3 value)
public float get_AttackTargetVisibleFor()
public float get_TimeAtDestination()
public BaseCombatEntity get_Entity()
public NavMeshAgent get_GetNavAgent()
public float GetWantsToAttack(BaseEntity target)
public AiStatistics get_GetStats()
public float get_GetAttackRange()
public Vector3 get_GetAttackOffset()
public float get_GetStamina()
public float get_GetEnergy()
public float get_GetAttackCost()
public float get_GetSleep()
public Vector3 get_CurrentAimAngles()
public float get_GetStuckDuration()
public float get_GetLastStuckTime()
public bool BusyTimerActive()
public void SetBusyFor(float dur)
public Vector3 get_AttackPosition()
public Vector3 get_CrouchedAttackPosition()
internal float WantsToAttack(BaseEntity target)
protected void SetupAiContext()
public IAIContext GetContext(Guid aiId)
public float get_currentBehaviorDuration()
public Behaviour get_CurrentBehaviour()
public void set_CurrentBehaviour(Behaviour value)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool SupportsPooling()
public float MaxVelocity()
public bool HasAiFlag(AiFlags f)
public void SetAiFlag(AiFlags f, bool set)
public bool get_IsSitting()
public void set_IsSitting(bool value)
public bool get_IsChasing()
public void set_IsChasing(bool value)
public bool get_IsSleeping()
public void set_IsSleeping(bool value)
public void InitFacts()
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public float ToSpeed(SpeedEnum speed)
public EnemyRangeEnum ToEnemyRangeEnum(float range)
public float GetActiveAggressionRangeSqr()
public FoodRangeEnum ToFoodRangeEnum(float range)
public AfraidRangeEnum ToAfraidRangeEnum(float range)
public HealthEnum ToHealthEnum(float healthNormalized)
public byte ToIsTired(float energyNormalized)
public SpeedEnum ToSpeedEnum(float speed)
public float ToSpeed(SpeedEnum speed)
public byte GetPathStatus()
public NavMeshPathStatus ToPathStatus(byte value)
private void TickSenses()
private void TickVision()
private void TickHearing()
private void TickSmell()
private void TickEnemyAwareness()
private void SelectEnemy()
private void AggroClosestEnemy()
private float DecisionMomentumPlayerTarget()
private float DecisionMomentumAnimalTarget()
private void TickFoodAwareness()
private void SelectFood()
private void SelectClosestFood()
private void UpdateSelfFacts()
private byte IsMoving()
private bool AiCaresAbout(BaseEntity ent)
private bool WithinVisionCone(BaseNpc npc, BaseEntity other)
public void SetTargetPathStatus(float pendingDelay)
private void DelayedTargetPathStatus()
public List`1<NavPointSample> RequestNavPointSamplesInCircle(SampleCount sampleCount, float radius, SampleFeatures features)
public List`1<NavPointSample> RequestNavPointSamplesInCircleWaterDepthOnly(SampleCount sampleCount, float radius, float waterDepth)
public void ServerInit()
internal void DoServerDestroy()
private bool Apex.LoadBalancing.ILoadBalanced.get_repeat()
private Nullable`1<float> Apex.LoadBalancing.ILoadBalanced.ExecuteUpdate(float deltaTime, float nextInterval)
public void Hurt(HitInfo info)
public void OnKilled(HitInfo hitInfo)
public void OnSensation(Sensation sensation)
protected void OnSenseGunshot(Sensation sensation)
public float get_SecondsSinceLastHeardGunshot()
public Vector3 get_LastHeardGunshotDirection()
public void set_LastHeardGunshotDirection(Vector3 value)
public float get_TargetSpeed()
public void set_TargetSpeed(float value)
}
public BaseNPCContext : BaseContext {
public NPCPlayerApex Human
public AiLocationManager AiLocationManager
public void .ctor(IAIAgent agent)
}
public BaseOven : StorageContainer {
public TemperatureType temperature
public Option switchOnMenu
public Option switchOffMenu
public ItemAmount[] startupContents
public bool allowByproductCreation
public ItemDefinition fuelType
public bool canModFire
public bool disabledBySplash
private float UpdateRate
public float cookingTemperature
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void PostServerLoad()
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool bAdded)
public void OvenFull()
private Item FindBurnable()
public void Cook()
private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
private void SVSwitch(RPCMessage msg)
public float get_cookingTemperature()
public void UpdateAttachmentTemperature()
public void StartCooking()
public void StopCooking()
public bool wantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public bool HasSlot(Slot slot)
public bool SupportsPooling()
}
public BasePath : MonoBehaviour {
public List`1<BasePathNode> nodes
public List`1<PathInterestNode> interestZones
public List`1<PathSpeedZone> speedZones
public void Start()
public void GetNodesNear(Vector3 point, List`1& nearNodes, float dist)
public BasePathNode GetClosestToPoint(Vector3 point)
public PathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist)
}
public BasePathNode : MonoBehaviour {
public List`1<BasePathNode> linked
public float maxVelocityOnApproach
public bool straightaway
public void OnDrawGizmosSelected()
}
public BasePlayer : BaseCombatEntity {
public GameObjectRef fallDamageEffect
public GameObjectRef drownEffect
public PlayerFlags playerFlags
public PlayerEyes eyes
public PlayerInventory inventory
public PlayerBlueprints blueprints
public PlayerMetabolism metabolism
public PlayerInput input
public BaseMovement movement
public BaseCollision collision
public PlayerBelt Belt
private Collider triggerCollider
private Rigidbody physicsRigidbody
public ulong userID
public string UserIDString
protected string _displayName
private ProtectionProperties cachedProtection
private int displayNameMaxLength
public bool clothingBlocksAiming
public float clothingMoveSpeedReduction
public float clothingWaterSpeedBonus
public bool isInAir
public bool isOnPlayer
public float violationLevel
public float lastViolationTime
public float lastAdminCheatTime
public AntiHackType lastViolationType
public float speedhackPauseTime
public float speedhackDistance
public float flyhackPauseTime
public float flyhackDistanceVertical
public float flyhackDistanceHorizontal
public PlayerModel playerModel
private float drinkRange
private float drinkMovementSpeed
private NetworkQueueList[] networkQueue
private NetworkQueueList SnapshotQueue
private bool lightsOn
public ulong currentTeam
public ModelState modelState
private ModelState modelStateTick
private bool wantsSendModelState
private float nextModelStateUpdate
private EntityRef mounted
private float nextSeatSwapTime
private Dictionary`2<int, FiredProjectile> firedProjectiles
public PlayerStatistics stats
public UInt32 svActiveItemID
public float NextChatTime
public float nextSuicideTime
private Vector3 <estimatedVelocity>k__BackingField
private float <estimatedSpeed>k__BackingField
private float <estimatedSpeed2D>k__BackingField
private int <secondsConnected>k__BackingField
private float <desyncTime>k__BackingField
public Vector3 viewAngles
private float lastPlayerTick
private float playerTickRate
private float sleepStartTime
public List`1<BasePlayer> activePlayerList
public List`1<BasePlayer> sleepingPlayerList
private float cachedCraftLevel
private float nextCheckTime
public PlayerLifeStory lifeStory
public PlayerLifeStory previousLifeStory
private int SpectateOffset
public string spectateFilter
private float lastUpdateTime
private float cachedThreatLevel
public float weaponDrawnDuration
public InputState serverInput
private float lastTickTime
private float lastStallTime
private float lastInputTime
public PlayerTick lastReceivedTick
private float tickDeltaTime
private bool tickNeedsFinalizing
private Vector3 tickViewAngles
private TickInterpolator tickInterpolator
private float woundedDuration
private float woundedStartTime
private float lastWoundedTime
private Predicate`1<BasePlayer> <>f__am$cache0
private Func`2<KeyValuePair`2<int, FiredProjectile>, bool> <>f__am$cache1
private Func`2<BasePlayer, bool> <>f__am$cache2
private Func`2<BasePlayer, string> <>f__am$cache3
public IPlayer IPlayer
public Connection Connection
public string displayName
public TraitFlag Traits
public bool IsReceivingSnapshot
public bool IsAdmin
public bool IsDeveloper
public bool IsAiming
public bool IsFlying
public bool IsConnected
public bool isMounted
public FamilyEnum Family
protected float PositionTickRate
public Vector3 estimatedVelocity
public float estimatedSpeed
public float estimatedSpeed2D
public int secondsConnected
public float desyncTime
public float secondsSleeping
public float currentCraftLevel
public float currentComfort
public float currentSafeLevel
public float currentBanditZoneLevel
public bool hasPreviousLife
public float timeSinceLastTick
public float IdleTime
public bool isStalled
public bool wasStalled
public float secondsSinceWoundedStarted
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public BasePlayer ToPlayer()
public Connection get_Connection()
public string get_displayName()
public void set_displayName(string value)
public Quaternion GetNetworkRotation()
public string GetSubName(int maxlen)
public bool CanInteract()
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public float MaxVelocity()
public void InitShared()
public void DestroyShared()
public void ServerCycle(float deltaTime)
public bool InSafeZone()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public Bounds GetBounds(bool ducked)
public Bounds GetBounds()
public Vector3 GetCenter(bool ducked)
public Vector3 GetCenter()
public Vector3 GetOffset(bool ducked)
public Vector3 GetOffset()
public Vector3 GetSize(bool ducked)
public Vector3 GetSize()
public float GetHeight(bool ducked)
public float GetHeight()
public float GetRadius()
public float GetJumpHeight()
public float MaxDeployDistance(Item item)
public float GetMinSpeed()
public float GetMaxSpeed()
public float GetSpeed(float running, float ducking)
public void OnAttacked(HitInfo info)
public void UpdatePlayerCollider(bool state)
public void UpdatePlayerRigidbody(bool state)
public bool CanAttack()
public bool OnLadder()
public bool IsSwimming()
public bool IsHeadUnderwater()
public bool IsOnGround()
public bool IsRunning()
public bool IsDucked()
public void ChatMessage(string msg)
public void ConsoleMessage(string msg)
public float PenetrationResistance(HitInfo info)
public void ScaleDamage(HitInfo info)
private void UpdateMoveSpeedFromClothing()
public void UpdateProtectionFromClothing()
public string Categorize()
public string ToString()
public string GetDebugStatus()
public Item GetItem(UInt32 itemId)
public TraitFlag get_Traits()
public float WaterFactor()
public bool TriggeredAntiHack(float seconds, float score)
public bool UsedAdminCheat(float seconds)
public void PauseFlyHackDetection(float seconds)
public void PauseSpeedHackDetection(float seconds)
public int GetAntiHackKicks()
public void ResetAntiHack()
public bool CanBeLooted(BasePlayer player)
public void RPC_LootPlayer(RPCMessage msg)
public void RPC_Assist(RPCMessage msg)
public void RPC_KeepAlive(RPCMessage msg)
private void SV_Drink(RPCMessage msg)
public int GetQueuedUpdateCount(NetworkQueue queue)
public void SendSnapshots(ListHashSet`1<Networkable> ents)
public void QueueUpdate(NetworkQueue queue, BaseNetworkable ent)
public void SendEntityUpdate()
public void ClearEntityQueue(Group group)
private void SendEntityUpdates(NetworkQueueList queue)
public void SendEntitySnapshot(BaseNetworkable ent)
public bool HasPlayerFlag(PlayerFlags f)
public bool get_IsReceivingSnapshot()
public bool get_IsAdmin()
public bool get_IsDeveloper()
public bool get_IsAiming()
public bool get_IsFlying()
public bool get_IsConnected()
public void SetPlayerFlag(PlayerFlags f, bool b)
public void LightToggle()
public void SetLightsOn(bool isOn)
public void DelayedTeamUpdate()
public void TeamDeathCleanup()
public void TeamUpdate()
public void UpdateTeam(ulong newTeam)
public void ClearTeam()
public void ClearPendingInvite()
public HeldEntity GetHeldEntity()
public bool IsHoldingEntity()
private void UpdateModelState()
private void SendModelState()
public bool get_isMounted()
public BaseMountable GetMounted()
public void MarkSwapSeat()
public bool SwapSeatCooldown()
public void MountObject(BaseMountable mount, int desiredSeat)
public void EnsureDismounted()
public void DismountObject()
public bool IsSleeping()
public bool IsSpectating()
public bool IsRelaxed()
public bool CanBuild()
public bool CanBuild(Vector3 position, Quaternion rotation, Bounds bounds)
public bool CanBuild(OBB obb)
public bool IsBuildingBlocked()
public bool IsBuildingBlocked(Vector3 position, Quaternion rotation, Bounds bounds)
public bool IsBuildingBlocked(OBB obb)
public bool IsBuildingAuthed()
public bool IsBuildingAuthed(Vector3 position, Quaternion rotation, Bounds bounds)
public bool IsBuildingAuthed(OBB obb)
public bool CanPlaceBuildingPrivilege()
public bool CanPlaceBuildingPrivilege(Vector3 position, Quaternion rotation, Bounds bounds)
public bool CanPlaceBuildingPrivilege(OBB obb)
public bool IsNearEnemyBase()
public bool IsNearEnemyBase(Vector3 position, Quaternion rotation, Bounds bounds)
public bool IsNearEnemyBase(OBB obb)
public void OnProjectileAttack(RPCMessage msg)
public void OnProjectileRicochet(RPCMessage msg)
public void OnProjectileUpdate(RPCMessage msg)
protected void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
public void CleanupExpiredProjectiles()
public bool HasFiredProjectile(int id)
public void NoteFiredProjectile(int projectileid, Vector3 startPos, Vector3 startVel, AttackEntity attackEnt, ItemDefinition firedItemDef, Item pickupItem)
public bool CanUseNetworkCache(Connection connection)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public FamilyEnum get_Family()
protected float get_PositionTickRate()
public bool CanSuicide()
public void MarkSuicide()
public Item GetActiveItem()
public void MovePosition(Vector3 newPos)
public Vector3 get_estimatedVelocity()
private void set_estimatedVelocity(Vector3 value)
public float get_estimatedSpeed()
private void set_estimatedSpeed(float value)
public float get_estimatedSpeed2D()
private void set_estimatedSpeed2D(float value)
public int get_secondsConnected()
private void set_secondsConnected(int value)
public float get_desyncTime()
private void set_desyncTime(float value)
public void OverrideViewAngles(Vector3 newAng)
public void ServerInit()
internal void DoServerDestroy()
protected void ServerUpdate(float deltaTime)
private void ConnectedPlayerUpdate(float deltaTime)
private void EnterGame()
private void ClientKeepConnectionAlive(RPCMessage msg)
private void ClientLoadingComplete(RPCMessage msg)
public void PlayerInit(Connection c)
public void SendDeathInformation()
public void SendRespawnOptions()
public float get_secondsSleeping()
public void StartSleeping()
public void DelayedRigidbodyDisable()
public void EndSleeping()
public void EndLooting()
public void OnDisconnected()
private void InventoryUpdate()
private void OnPlayerLanded(RPCMessage msg)
public void SendGlobalSnapshot()
public void SendFullSnapshot()
public void OnNetworkGroupLeave(Group group)
private void LeaveVisibility(Group group)
public void OnNetworkGroupEnter(Group group)
private void EnterVisibility(Group group)
public void CheckDeathCondition(HitInfo info)
public BaseCorpse CreateCorpse()
public void OnKilled(HitInfo info)
public void RespawnAt(Vector3 position, Quaternion rotation)
public void Respawn()
public bool IsImmortal()
public float TimeAlive()
public void Hurt(HitInfo info)
public BasePlayer FindByID(ulong userID)
public BasePlayer FindSleeping(ulong userID)
public void Command(string strCommand, Object[] arguments)
public void OnInvalidPosition()
private BasePlayer Find(string strNameOrIDOrIP, List`1<BasePlayer> list)
public BasePlayer Find(string strNameOrIDOrIP)
public BasePlayer FindSleeping(string strNameOrIDOrIP)
public void SendConsoleCommand(string command, Object[] obj)
public void UpdateRadiation(float fAmount)
public float RadiationExposureFraction()
public float RadiationProtection()
public void OnHealthChanged(float oldvalue, float newvalue)
public void SV_ClothingChanged()
public bool IsNoob()
public bool HasHostileItem()
public bool IsHostileItem(Item item)
public void GiveItem(Item item, GiveItemReason reason)
public void AttackerInfo(DeathInfo info)
public float get_currentCraftLevel()
public float get_currentComfort()
public float get_currentSafeLevel()
public float get_currentBanditZoneLevel()
protected void MarkBanditZoneHurtHostiliy(BaseCombatEntity attacker)
public void MarkBanditZoneShotHostiliy()
public void MarkBanditSafeZoneHurtHostiliy(BaseCombatEntity attacker)
public bool ShouldDropActiveItem()
public void Die(HitInfo info)
public void Kick(string reason)
public Vector3 GetDropPosition()
public Vector3 GetDropVelocity()
public void SetInfo(string key, string val)
public int GetInfoInt(string key, int defaultVal)
public void PerformanceReport(RPCMessage msg)
public bool ShouldNetworkTo(BasePlayer player)
internal void GiveAchievement(string name)
public bool get_hasPreviousLife()
internal void LifeStoryStart()
public void LifeStoryEnd()
internal void LifeStoryUpdate(float deltaTime)
internal void LifeStoryLogDeath(HitInfo deathBlow, DamageType lastDamage)
private void Tick_Spectator()
public void UpdateSpectateTarget(string strName)
public void StartSpectating()
public void StopSpectating()
public void Teleport(BasePlayer player)
public void Teleport(string strName, bool playersOnly)
public void Teleport(Vector3 position)
public float GetThreatLevel()
public void EnsureUpdated()
public void MarkHostileFor(float duration)
public void MarkWeaponDrawnDuration(float newDuration)
public void AddWeaponDrawnDuration(float duration)
public float get_timeSinceLastTick()
public float get_IdleTime()
public bool get_isStalled()
public bool get_wasStalled()
public void OnReceivedTick(Stream stream)
public void OnReceivedVoice(Byte[] data)
private void EACStateUpdate()
private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
internal void UpdateActiveItem(UInt32 itemID)
internal void UpdateModelStateFromTick(PlayerTick tick)
internal void UpdatePositionFromTick(PlayerTick tick, bool wasPlayerStalled)
internal void UpdateRotationFromTick(PlayerTick tick)
public void UpdateEstimatedVelocity(Vector3 lastPos, Vector3 currentPos, float deltaTime)
private void FinalizeTick(float deltaTime)
public bool IsWounded()
public float get_secondsSinceWoundedStarted()
private bool WoundInsteadOfDying(HitInfo info)
public bool EligibleForWounding(HitInfo info)
public void StartWounded()
public void StopWounded()
public void ProlongWounding(float delay)
private void WoundingTick()
private bool WoundingCausingImmportality()
private bool <ServerCycle>m__0(BasePlayer x)
private bool <CleanupExpiredProjectiles>m__1(KeyValuePair`2<int, FiredProjectile> x)
private bool <UpdateSpectateTarget>m__2(BasePlayer x)
private bool <UpdateSpectateTarget>m__3(BasePlayer x)
private bool <UpdateSpectateTarget>m__4(BasePlayer x)
private string <UpdateSpectateTarget>m__5(BasePlayer x)
}
public BasePrefab : BaseMonoBehaviour {
public UInt32 prefabID
public bool isClient
public bool isServer
public bool get_isServer()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BaseProjectile : AttackEntity {
public float NoiseRadius
public float damageScale
public float distanceScale
public float projectileVelocityScale
public bool automatic
public GameObjectRef attackFX
public GameObjectRef silencedAttack
public GameObjectRef muzzleBrakeAttack
public Transform MuzzlePoint
public float reloadTime
public bool canUnloadAmmo
public Magazine primaryMagazine
public float aimSway
public float aimSwaySpeed
public RecoilProperties recoil
public AnimationCurve aimconeCurve
public float aimCone
public float hipAimCone
public float aimconePenaltyPerShot
public float aimConePenaltyMax
public float aimconePenaltyRecoverTime
public float aimconePenaltyRecoverDelay
public float stancePenaltyScale
public bool hasADS
public bool noAimingWhileCycling
public bool manualCycle
protected bool needsCycle
protected bool isCycling
public bool aiming
private float nextReloadTime
private float stancePenalty
private float aimconePenalty
protected bool reloadStarted
protected bool reloadFinished
private Effect reusableInstance
private Func`2<ProjectileWeaponMod, bool> <>f__am$cache0
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cache1
private Func`2<Modifier, float> <>f__am$cache2
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cache3
private Func`2<Modifier, float> <>f__am$cache4
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cache5
private Func`2<Modifier, float> <>f__am$cache6
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cache7
private Func`2<Modifier, float> <>f__am$cache8
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cache9
private Func`2<Modifier, float> <>f__am$cacheA
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cacheB
private Func`2<Modifier, float> <>f__am$cacheC
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cacheD
private Func`2<Modifier, float> <>f__am$cacheE
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cacheF
private Func`2<Modifier, float> <>f__am$cache10
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cache11
private Func`2<Modifier, float> <>f__am$cache12
private Func`2<ProjectileWeaponMod, Modifier> <>f__am$cache13
private Func`2<Modifier, float> <>f__am$cache14
private Func`2<ProjectileWeaponMod, bool> <>f__am$cache15
private bool UsingInfiniteAmmoCheat
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float GetDamageScale(bool getMax)
public float GetDistanceScale(bool getMax)
public float GetProjectileVelocityScale(bool getMax)
protected void StartReloadCooldown(float cooldown)
protected void ResetReloadCooldown()
protected bool HasReloadCooldown()
protected float GetReloadCooldown()
protected float GetReloadIdle()
private void OnDrawGizmos()
public RecoilProperties GetRecoil()
public void DidAttackServerside()
public void ServerReload()
public Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier)
public float GetAIAimcone()
public void ServerUse()
public void ServerInit()
public void ServerCommand(Item item, string command, BasePlayer player)
public void UnloadAmmo(Item item, BasePlayer player)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
public void SetLightsOn(bool isOn)
public bool CanAiAttack()
public float GetAimCone()
public float ScaleRepeatDelay(float delay)
public Modifier GetProjectileModifier()
protected void ReloadMagazine()
private void SwitchAmmoTo(RPCMessage msg)
private void StartReload(RPCMessage msg)
private void Reload(RPCMessage msg)
private void CLProject(RPCMessage msg)
private void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced, bool forceClientsideEffects)
public void UpdateItemCondition()
public bool IsSilenced()
private bool get_UsingInfiniteAmmoCheat()
public bool CanUseNetworkCache(Connection sendingTo)
public void Save(SaveInfo info)
public bool ForceSendMagazine()
public void Load(LoadInfo info)
private bool <SetLightsOn>m__0(ProjectileWeaponMod x)
private Modifier <GetAimCone>m__1(ProjectileWeaponMod x)
private float <GetAimCone>m__2(Modifier y)
private Modifier <GetAimCone>m__3(ProjectileWeaponMod x)
private float <GetAimCone>m__4(Modifier y)
private Modifier <GetAimCone>m__5(ProjectileWeaponMod x)
private float <GetAimCone>m__6(Modifier y)
private Modifier <GetAimCone>m__7(ProjectileWeaponMod x)
private float <GetAimCone>m__8(Modifier y)
private Modifier <ScaleRepeatDelay>m__9(ProjectileWeaponMod x)
private float <ScaleRepeatDelay>m__A(Modifier y)
private Modifier <ScaleRepeatDelay>m__B(ProjectileWeaponMod x)
private float <ScaleRepeatDelay>m__C(Modifier y)
private Modifier <GetProjectileModifier>m__D(ProjectileWeaponMod x)
private float <GetProjectileModifier>m__E(Modifier y)
private Modifier <GetProjectileModifier>m__F(ProjectileWeaponMod x)
private float <GetProjectileModifier>m__10(Modifier y)
private Modifier <GetProjectileModifier>m__11(ProjectileWeaponMod x)
private float <GetProjectileModifier>m__12(Modifier y)
private Modifier <GetProjectileModifier>m__13(ProjectileWeaponMod x)
private float <GetProjectileModifier>m__14(Modifier y)
private bool <IsSilenced>m__15(ProjectileWeaponMod x)
}
public BaseResourceExtractor : BaseCombatEntity {
public bool canExtractLiquid
public bool canExtractSolid
public void ServerInit()
}
public BaseScreenShake : MonoBehaviour {
public List`1<BaseScreenShake> list
public float length
internal float timeTaken
private int currentFrame
public void Apply(Camera cam, BaseViewModel vm)
protected void OnEnable()
protected void OnDisable()
public void Run(CachedTransform`1& cam, CachedTransform`1& vm)
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public BaseScriptableObject : ScriptableObject {
public UInt32 FilenameStringId
public string LookupFileName()
public bool op_Equality(BaseScriptableObject a, BaseScriptableObject b)
public bool op_Inequality(BaseScriptableObject a, BaseScriptableObject b)
public int GetHashCode()
public bool Equals(object o)
}
public BaseSpawnPoint : MonoBehaviour {
public void GetLocation(Vector3& pos, Quaternion& rot)
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
protected void DropToGround(Vector3& pos, Quaternion& rot)
}
public BaseTrap : DecayEntity {
public void ObjectEntered(GameObject obj)
public void Arm()
public void OnEmpty()
}
public BaseTrapTrigger : TriggerBase {
public BaseTrap _trap
internal GameObject InterestedInObject(GameObject obj)
internal void OnObjectAdded(GameObject obj)
internal void OnEmpty()
}
public BaseVehicle : BaseMountable {
public GameObjectRef serverGibs
public MountPointInfo[] mountPoints
public Flags Flag_Headlights
public bool highFidelityRotation
public bool seatClipCheck
public bool DirectlyMountable()
public bool HasAnyPassengers()
public void VehicleFixedUpdate()
public bool IsSeatClipping(BaseMountable mountable, bool checkWhenEmpty)
public void CheckSeatsForClipping()
public void SeatClippedWorld(BaseMountable mountable)
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void DismountAllPlayers()
public void ServerInit()
public void SpawnSubEntities()
public void Spawn()
public bool HasDriver()
public int GetPlayerSeat(BasePlayer player)
public void SwapSeats(BasePlayer player, int targetSeat)
public bool HasMountPoints()
public BaseMountable GetIdealMountPoint(Vector3 pos)
public bool IsMounted()
public bool MountEligable()
public void AttemptMount(BasePlayer player)
public bool AttemptDismount(BasePlayer player)
public Vector3 GetDismountPosition(BasePlayer player)
}
public BaseVehicleMountPoint : BaseMountable {
public bool DirectlyMountable()
public BaseVehicle GetVehicleParent()
public float WaterFactorForPlayer(BasePlayer player)
}
public BaseVehicleSeat : BaseVehicleMountPoint {
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void LightToggle(BasePlayer player)
public float GetSteering(BasePlayer player)
}
public BaseViewModel : MonoBehaviour {
public LazyAimProperties lazyaimRegular
public LazyAimProperties lazyaimIronsights
public Transform pivot
public bool wantsHeldItemFlags
public GameObject[] hideSightMeshes
public Transform MuzzlePoint
public SubsurfaceProfile subsurfaceProfile
}
public BaseWheeledVehicle : BaseVehicle {
public VehicleWheel[] wheels
}
public Bear : BaseAnimalNPC {
public float Population
public TraitFlag Traits
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public BearTrap : BaseTrap {
protected Animator animator
private GameObject hurtTarget
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool Armed()
public void InitShared()
public bool CanPickup(BasePlayer player)
public void ServerInit()
public void Arm()
public void Fire()
public void ObjectEntered(GameObject obj)
public void DelayedFire()
public void RadialResetCorpses(float duration)
public void OnAttacked(HitInfo info)
private void RPC_Arm(RPCMessage rpc)
public void Load(LoadInfo info)
}
public BigWheelBettingTerminal : StorageContainer {
public BigWheelGame bigWheel
public Vector3 seatedPlayerOffset
public float offsetCheckRadius
public SoundDefinition winSound
public SoundDefinition loseSound
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnDrawGizmos()
public bool IsPlayerValid(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen)
}
public BigWheelGame : SpinnerWheel {
public HitNumber[] hitNumbers
public GameObject indicator
public GameObjectRef winEffect
public float spinFrequencySeconds
protected int spinNumber
protected int lastPaidSpinNumber
protected List`1<BigWheelBettingTerminal> terminals
public bool AllowPlayerSpins()
public bool CanUpdateSign(BasePlayer player)
public float GetMaxSpinSpeed()
public void ServerInit()
public void DoSpin()
public void SetTerminalsLocked(bool isLocked)
protected void InitBettingTerminals()
public void Update_Server()
public float SpinSpacing()
public void QueueSpin()
public void Payout()
public HitNumber GetCurrentHitType()
private void LoadHitNumbers()
}
public Binocular : AttackEntity {
public Single[] fovs
public GameObjectRef fovChangeEffect
}
public BlendedSoundLoops : MonoBehaviour {
public float blend
public float blendSmoothing
public float loopFadeOutTime
public float loopFadeInTime
public float gainModSmoothing
public float pitchModSmoothing
public bool shouldPlay
public List`1<Loop> loops
public float maxDistance
private void OnValidate()
}
public BlendTexture : ProcessedTexture {
public void .ctor(int width, int height, bool linear)
public void Blend(Texture source, Texture target, float alpha)
public void CopyTo(BlendTexture target)
}
public BlueprintButton : MonoBehaviour {
public Text name
public Text subtitle
public Image image
public Button button
public CanvasGroup group
public GameObject newNotification
public string gotColor
public string notGotColor
public float craftableFraction
public GameObject lockedOverlay
public CanvasGroup LockedGroup
public Text LockedPrice
public Image LockedImageBackground
public Color LockedCannotUnlockColor
public Color LockedCanUnlockColor
public GameObject LockedLevel
}
public BlueprintCategoryButton : MonoBehaviour {
public Text amountLabel
public ItemCategory Category
public GameObject BackgroundHighlight
public SoundDefinition clickSound
public SoundDefinition hoverSound
}
public BlueprintCraftGridRow : MonoBehaviour {
public GameObject amount
public GameObject itemName
public GameObject total
public GameObject have
public Color colorOK
public Color colorBad
}
public BlueprintHeader : MonoBehaviour {
public Text categoryName
public Text unlockCount
public void Setup(ItemCategory name, int unlocked, int total)
}
public BlurManager : ImageEffectLayer {
public BlurOptimized blur
public ColorCorrectionCurves color
public float maxBlurScale
internal float blurAmount
internal float desaturationAmount
}
public BlurTexture : ProcessedTexture {
public void .ctor(int width, int height, bool linear)
public void Blur(float radius)
public void Blur(Texture source, float radius)
}
public Boar : BaseAnimalNPC {
public float Population
public TraitFlag Traits
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public BoneInfoComponent : MonoBehaviour {
public Vector3 sizeVariation
public int sizeVariationSeed
}
public Bootstrap : SingletonComponent`1<Bootstrap> {
internal bool bootstrapInitRun
public bool isErrored
public string messageString
public GameObject errorPanel
public Text errorText
public Text statusText
public bool isGameInitRun
private Func`1<int> <>f__mg$cache0
public bool needsSetup
public bool isPresent
public bool get_needsSetup()
public bool get_isPresent()
public void RunDefaults()
public void Init_Tier0()
public void Init_Systems()
public void Init_Config()
public void NetworkInit()
private IEnumerator Start()
private IEnumerator DedicatedServerStartup()
public IEnumerator StartServer(bool doLoad, string saveFileOverride, bool allowOutOfDateSaves)
private void StartupShared()
public void ThrowError(string error)
public void ExitGame()
public IEnumerator LoadingUpdate(string str)
public IEnumerator GameInit_Warmup(Action`1<string> statusFunction)
}
public BoundsEx : object {
public Bounds XZ3D(Bounds bounds)
public Bounds Transform(Bounds bounds, Matrix4x4 matrix)
}
public BowWeapon : BaseProjectile {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void BowReload(RPCMessage msg)
public bool ForceSendMagazine()
}
public BoxStorage : StorageContainer {
public bool SupportsPooling()
}
public BradleyAPC : BaseCombatEntity {
public EngineAudioClip engineAudioClip
public SlicedGranularAudioClip treadAudioClip
public float treadGrainFreqMin
public float treadGrainFreqMax
public AnimationCurve treadFreqCurve
public SoundDefinition chasisLurchSoundDef
public float chasisLurchAngleDelta
public float chasisLurchSpeedDelta
private float lastAngle
private float lastSpeed
public SoundDefinition turretTurnLoopDef
public float turretLoopGainSpeed
public float turretLoopPitchSpeed
public float turretLoopMinAngleDelta
public float turretLoopMaxAngleDelta
public float turretLoopPitchMin
public float turretLoopPitchMax
public float turretLoopGainThreshold
private Sound turretTurnLoop
private Modulator turretTurnLoopGain
private Modulator turretTurnLoopPitch
public float enginePitch
public float rpmMultiplier
private TreadAnimator treadAnimator
public WheelCollider[] leftWheels
public WheelCollider[] rightWheels
public float moveForceMax
public float brakeForce
public float turnForce
public float sideStiffnessMax
public float sideStiffnessMin
public Transform centerOfMass
public float stoppingDist
public float throttle
public float turning
public float rightThrottle
public float leftThrottle
public bool brake
public Rigidbody myRigidBody
public Collider myCollider
public Vector3 destination
private Vector3 finalDestination
public Transform followTest
public TriggerHurtEx impactDamager
public Transform mainTurretEyePos
public Transform mainTurret
public Transform CannonPitch
public Transform CannonMuzzle
public Transform coaxPitch
public Transform coaxMuzzle
public Transform topTurretEyePos
public Transform topTurretYaw
public Transform topTurretPitch
public Transform topTurretMuzzle
public Vector3 turretAimVector
private Vector3 desiredAimVector
public Vector3 topTurretAimVector
private Vector3 desiredTopTurretAimVector
public GameObjectRef explosionEffect
public GameObjectRef servergibs
public GameObjectRef fireBall
public GameObjectRef crateToDrop
public GameObjectRef debrisFieldMarker
public int maxCratesToSpawn
public int patrolPathIndex
public BasePath patrolPath
public bool DoAI
public GameObjectRef mainCannonMuzzleFlash
public GameObjectRef mainCannonProjectile
private float nextFireTime
private int numBursted
public float recoilScale
public NavMeshPath navMeshPath
public int navMeshPathIndex
private float nextPatrolTime
private float nextEngagementPathTime
private float currentSpeedZoneLimit
public List`1<Vector3> currentPath
public int currentPathIndex
public bool pathLooping
public float viewDistance
public float searchRange
public float searchFrequency
public float memoryDuration
public float sightUpdateRate
private BaseCombatEntity mainGunTarget
public List`1<TargetInfo> targetList
private float nextCoaxTime
private float coaxFireRate
private int numCoaxBursted
private float bulletDamage
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
private float lastLateUpdate
protected float PositionTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void SetDestination(Vector3 dest)
public void ServerInit()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public void Initialize()
public BasePlayer FollowPlayer()
public Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom)
protected float get_PositionTickRate()
public bool IsAtDestination()
public bool IsAtFinalDestination()
public Vector3 ClosestPointAlongPath(Vector3 start, Vector3 end, Vector3 fromPos)
public void FireGunTest()
public void InstallPatrolPath(BasePath path)
public void UpdateMovement_Patrol()
public void UpdateMovement_Hunt()
public void DoSimpleAI()
public void FixedUpdate()
public void DoPhysicsMove()
public void ApplyBrakes(float amount)
public float GetMotorTorque(bool rightSide)
public void ScaleSidewaysFriction(float scale)
public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
public void ApplyBrakeTorque(float amount, bool rightSide)
public void CreateExplosionMarker(float durationMinutes)
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
public void OnHealthChanged(float oldvalue, float newvalue)
public void DoHealing()
public bool HasPath()
public void ClearPath()
public bool IndexValid(int index)
public Vector3 GetFinalDestination()
public Vector3 GetCurrentPathDestination()
public bool PathComplete()
public bool AtCurrentPathNode()
public int GetLoopedIndex(int index)
public Vector3 PathDirection(int index)
public Vector3 IdealPathPosition()
public void AdvancePathMovement()
public bool GetPathToClosestTurnableNode(BasePathNode start, Vector3 forward, List`1& nodes)
public bool GetEngagementPath(List`1& nodes)
public void AddOrUpdateTarget(BaseEntity ent, Vector3 pos, float damageFrom)
public void UpdateTargetList()
public int SortTargets(TargetInfo t1, TargetInfo t2)
public Vector3 GetAimPoint(BaseEntity ent)
public bool VisibilityTest(BaseEntity ent)
public void UpdateTargetVisibilities()
public void DoWeaponAiming()
public void DoWeapons()
public void FireGun(Vector3 targetPos, float aimCone, bool isCoax)
private void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
public void AimWeaponAt(Transform weaponYaw, Transform weaponPitch, Vector3 direction, float minPitch, float maxPitch, float maxYaw, Transform parentOverride)
public void LateUpdate()
}
public BradleyMoveTest : MonoBehaviour {
public WheelCollider[] leftWheels
public WheelCollider[] rightWheels
public float moveForceMax
public float brakeForce
public float throttle
public float turnForce
public float sideStiffnessMax
public float sideStiffnessMin
public Transform centerOfMass
public float turning
public bool brake
public Rigidbody myRigidBody
public Vector3 destination
public float stoppingDist
public GameObject followTest
public void Awake()
public void Initialize()
public void SetDestination(Vector3 dest)
public void FixedUpdate()
public void ApplyBrakes(float amount)
public float GetMotorTorque(bool rightSide)
public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
public void ApplyBrakeTorque(float amount, bool rightSide)
public void AdjustFriction()
}
public BradleySpawner : MonoBehaviour {
public BasePath path
public GameObjectRef bradleyPrefab
public BradleyAPC spawned
public bool initialSpawn
public float minRespawnTimeMinutes
public float maxRespawnTimeMinutes
public BradleySpawner singleton
private bool pendingRespawn
public void Start()
public void DelayedStart()
public void CheckIfRespawnNeeded()
public void ScheduleRespawn()
public void DoRespawn()
public void SpawnBradley()
}
public Branding : BaseMonoBehaviour {
public Text versionText
public CanvasGroup canvasGroup
private string oldChangeId
}
public BucketVMFluidSim : MonoBehaviour {
public Animator waterbucketAnim
public ParticleSystem waterPour
public ParticleSystem waterTurbulence
public ParticleSystem waterFill
public float waterLevel
public float targetWaterLevel
public AudioSource waterSpill
private float PlayerEyePitch
private float turb_forward
private float turb_side
private Vector3 lastPosition
protected Vector3 groundSpeedLast
private Vector3 lastAngle
protected Vector3 vecAngleSpeedLast
private Vector3 initialPosition
}
public BuildingBlock : StabilityEntity {
public Construction blockDefinition
private Vector3[] outsideLookupOffsets
private bool forceSkinRefresh
public int modelState
private int lastModelState
public Enum grade
public Enum lastGrade
public ConstructionSkin currentSkin
private DeferredAction skinChange
private MeshRenderer placeholderRenderer
private MeshCollider placeholderCollider
public UpdateSkinWorkQueue updateSkinQueueServer
public ConstructionGrade currentGrade
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public void InitShared()
public void PostInitShared()
public void DestroyShared()
public string Categorize()
public bool SupportsPooling()
public float BoundsPadding()
public bool IsOutside()
public bool CanDemolish(BasePlayer player)
private bool IsDemolishable()
private bool HasDemolishPrivilege(BasePlayer player)
private void DoDemolish(RPCMessage msg)
private void DoImmediateDemolish(RPCMessage msg)
public void StopBeingDemolishable()
public void StartBeingDemolishable()
public void SetConditionalModel(int state)
public bool GetConditionalModel(int index)
public ConstructionGrade get_currentGrade()
private ConstructionGrade GetGrade(Enum iGrade)
private bool CanChangeToGrade(Enum iGrade, BasePlayer player)
private bool HasUpgradePrivilege(Enum iGrade, BasePlayer player)
private bool IsUpgradeBlocked()
private bool CanAffordUpgrade(Enum iGrade, BasePlayer player)
public void SetGrade(Enum iGradeID)
private void UpdateGrade()
public void SetHealthToMax()
private void DoUpgradeToGrade(RPCMessage msg)
private void PayForUpgrade(ConstructionGrade g, BasePlayer player)
private bool NeedsSkinChange()
public void UpdateSkin(bool force)
private void DestroySkin()
private void RefreshNeighbours(bool linkToNeighbours)
private void UpdatePlaceholder(bool state)
private void ChangeSkin()
public void ChangeSkin(GameObjectRef prefab)
public bool ShouldBlockProjectiles()
private void OnHammered()
public float MaxHealth()
public List`1<ItemAmount> BuildCost()
public void OnHealthChanged(float oldvalue, float newvalue)
public float RepairCostFraction()
public bool CanRotate(BasePlayer player)
private bool IsRotatable()
private bool IsRotationBlocked()
private bool HasRotationPrivilege(BasePlayer player)
private void DoRotation(RPCMessage msg)
public void StopBeingRotatable()
public void StartBeingRotatable()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ServerInit()
public void Hurt(HitInfo info)
public void OnKilled(HitInfo info)
}
public BuildingBlockDecay : Decay {
private bool isFoundation
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public bool ShouldDecay(BaseEntity entity)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BuildingGrade : ScriptableObject {
public Enum type
public float baseHealth
public List`1<ItemAmount> baseCost
public PhysicMaterial physicMaterial
public ProtectionProperties damageProtecton
public Option upgradeMenu
}
public BuildingGradeDecay : Decay {
public Enum decayGrade
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public bool ShouldDecay(BaseEntity entity)
}
public BuildingManager : object {
public ServerBuildingManager server
protected ListHashSet`1<DecayEntity> decayEntities
protected ListDictionary`2<UInt32, Building> buildingDictionary
public Building GetBuilding(UInt32 buildingID)
public void Add(DecayEntity ent)
public void Remove(DecayEntity ent)
public void Clear()
}
public BuildingPrivlidge : StorageContainer {
public List`1<PlayerNameID> authorizedPlayers
private float cachedProtectedMinutes
private float nextProtectedCalcTime
private UpkeepBracket[] upkeepBrackets
private List`1<ItemAmount> upkeepBuffer
private Func`2<Item, int> <>f__am$cache0
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public bool IsAuthed(BasePlayer player)
public bool AnyAuthed()
public bool ItemFilter(Item item, int targetSlot)
public void Save(SaveInfo info)
public void PostSave(SaveInfo info)
public void Load(LoadInfo info)
public void BuildingDirty()
protected void OnInventoryDirty()
public void OnItemAddedOrRemoved(Item item, bool bAdded)
public void AddDelayedUpdate()
public void DelayedUpdate()
private bool CanAdministrate(BasePlayer player)
public void AddSelfAuthorize(RPCMessage rpc)
public void RemoveSelfAuthorize(RPCMessage rpc)
public void ClearList(RPCMessage rpc)
public void RPC_Rotate(RPCMessage msg)
public bool HasSlot(Slot slot)
public bool SupportsPooling()
public float CalculateUpkeepPeriodMinutes()
public float CalculateUpkeepCostFraction()
public void CalculateUpkeepCostAmounts(List`1<ItemAmount> itemAmounts)
public float GetProtectedMinutes(bool force)
public void OnKilled(HitInfo info)
public void DecayTick()
private bool EnsurePrimary()
public void MarkProtectedMinutesDirty(float delay)
public float CalculateBuildingTaxRate()
private void ApplyUpkeepPayment()
private void QueueUpkeepPayment(List`1<ItemAmount> itemAmounts)
private bool CanAffordUpkeepPayment(List`1<ItemAmount> itemAmounts)
public float PurchaseUpkeepTime(DecayEntity entity, float deltaTime)
public void PurchaseUpkeepTime(float deltaTime)
private int <GetProtectedMinutes>m__0(Item x)
}
public BuildingProximity : PrefabAttribute {
private float check_radius
private float check_forgiveness
private float foundation_width
private float foundation_extents
public bool Check(BasePlayer player, Construction construction, Vector3 position, Quaternion rotation)
private ProximityInfo GetProximity(Construction construction1, Vector3 position1, Quaternion rotation1, Construction construction2, Vector3 position2, Quaternion rotation2)
public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
protected Type GetIndexedType()
}
public Buoyancy : MonoBehaviour {
public BuoyancyPoint[] points
public GameObjectRef[] waterImpacts
public Rigidbody rigidBody
public float buoyancyScale
public float submergedFraction
public bool doEffects
public bool clientSide
public float waveHeightScale
public string DefaultWaterImpact()
public void FixedUpdate()
public Vector3 GetFlowDirection(Vector3 point)
public void EnsurePointsInitialized()
public void BuoyancyFixedUpdate()
}
public BuoyancyPoint : MonoBehaviour {
public float buoyancyForce
public float size
public float randomOffset
public float waveScale
public float waveFrequency
public bool wasSubmergedLastFrame
public float nexSplashTime
public bool doSplashEffects
public void Start()
public void OnDrawGizmos()
}
public BUTTON : Enum {
public int value__
public BUTTON FORWARD
public BUTTON BACKWARD
public BUTTON LEFT
public BUTTON RIGHT
public BUTTON JUMP
public BUTTON DUCK
public BUTTON SPRINT
public BUTTON USE
public BUTTON FIRE_PRIMARY
public BUTTON FIRE_SECONDARY
public BUTTON RELOAD
public BUTTON FIRE_THIRD
}
public ByteMap : object {
private int size
private int bytes
private Byte[] values
public int Size
public UInt32 Item
public void .ctor(int size, int bytes)
public void .ctor(int size, Byte[] values, int bytes)
public int get_Size()
public UInt32 get_Item(int x, int y)
public void set_Item(int x, int y, UInt32 value)
}
public ByteQuadtree : object {
private int size
private int levels
private ByteMap[] values
public int Size
public Element Root
public void UpdateValues(Byte[] baseValues)
public int get_Size()
public Element get_Root()
private ByteMap CreateLevel(int level)
}
public CachedTransform`1 : ValueType {
public T component
public Vector3 position
public Quaternion rotation
public Vector3 localScale
public Matrix4x4 localToWorldMatrix
public Matrix4x4 worldToLocalMatrix
public Vector3 forward
public Vector3 up
public Vector3 right
public void .ctor(T instance)
public void Apply()
public void RotateAround(Vector3 center, Vector3 axis, float angle)
public Matrix4x4 get_localToWorldMatrix()
public Matrix4x4 get_worldToLocalMatrix()
public Vector3 get_forward()
public Vector3 get_up()
public Vector3 get_right()
public bool op_Implicit(CachedTransform`1<T> instance)
}
public CameraEx : MonoBehaviour {
public bool overrideAmbientLight
public AmbientMode ambientMode
public Color ambientGroundColor
public Color ambientEquatorColor
public Color ambientLight
public float ambientIntensity
internal Color old_ambientLight
internal Color old_ambientGroundColor
internal Color old_ambientEquatorColor
internal float old_ambientIntensity
internal AmbientMode old_ambientMode
public float aspect
}
public CameraMan : SingletonComponent`1<CameraMan> {
public bool OnlyControlWhenCursorHidden
public bool NeedBothMouseButtonsToZoom
public float LookSensitivity
public float MoveSpeed
}
public CameraSettings : MonoBehaviour {
private Camera cam
private void OnEnable()
private void Update()
}
public CameraTool : HeldEntity {
public GameObjectRef screenshotEffect
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void SVNoteScreenshot(RPCMessage msg)
}
public CameraUtil : object {
public void NormalizePlane(Plane& plane)
public void ExtractPlanes(Camera camera, Plane[]& planes)
public void ExtractPlanes(Matrix4x4 viewProjMatrix, Plane[]& planes)
}
public CanvasOrderHack : MonoBehaviour {
private void OnEnable()
}
public CardReader : IOEntity {
public float accessDuration
public int accessLevel
public GameObjectRef accessGrantedEffect
public GameObjectRef accessDeniedEffect
public GameObjectRef swipeEffect
public Transform audioPosition
public Flags AccessLevel1
public Flags AccessLevel2
public Flags AccessLevel3
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public void CancelAccess()
public void FailCard()
public void ServerInit()
public void GrantCard()
public void ServerCardSwiped(RPCMessage msg)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public CargoPlane : BaseEntity {
public GameObjectRef prefabDrop
public SpawnFilter filter
public Vector3 startPos
public Vector3 endPos
public float secondsToTake
public float secondsTaken
public bool dropped
public Vector3 dropPosition
public void InitDropPosition(Vector3 newDropPosition)
public void ServerInit()
public Vector3 RandomDropPosition()
public void UpdateDropPosition(Vector3 newDropPosition)
private void Update()
}
public CeilingLight : BaseFuelLightSource {
public float pushScale
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Hurt(HitInfo info)
public void RefreshPlants()
public void StartCooking()
public void StopCooking()
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
public bool SupportsPooling()
}
public CH47AIBrain : BaseAIBrain`1<CH47HelicopterAIController> {
public int CH47State_Idle
public int CH47State_Patrol
public int CH47State_Land
public int CH47State_Dropoff
public int CH47State_Orbit
public int CH47State_Retreat
public int CH47State_Egress
private float age
public void InitializeAI()
public void FixedUpdate()
public void OnDrawGizmos()
public void AIThink(float delta)
}
public ch47Animator : MonoBehaviour {
public Animator animator
public bool bottomDoorOpen
public bool landingGearDown
public bool leftDoorOpen
public bool rightDoorOpen
public bool rearDoorOpen
public bool rearDoorExtensionOpen
public Transform rearRotorBlade
public Transform frontRotorBlade
public float rotorBladeSpeed
public float wheelTurnSpeed
public float wheelTurnAngle
public SkinnedMeshRenderer[] blurredRotorBlades
public SkinnedMeshRenderer[] RotorBlades
private bool blurredRotorBladesEnabled
public float blurSpeedThreshold
private void Start()
public void SetDropDoorOpen(bool isOpen)
private void Update()
private void LateUpdate()
private void EnableBlurredRotorBlades(bool enabled)
}
public CH47DropZone : MonoBehaviour {
public float lastDropTime
private List`1<CH47DropZone> dropZones
public void Awake()
public CH47DropZone GetClosest(Vector3 pos)
public void OnDestroy()
public float TimeSinceLastDrop()
public void Used()
public void OnDrawGizmos()
}
public CH47FlightTest : MonoBehaviour {
public Rigidbody rigidBody
public float engineThrustMax
public Vector3 torqueScale
public Transform com
public Transform[] GroundPoints
public Transform[] GroundEffects
public Transform AIMoveTarget
private float altitudeTolerance
public float currentThrottle
public float avgThrust
public float liftDotMax
public void Awake()
public HelicopterInputState_t GetHelicopterInputState()
public HelicopterInputState_t GetAIInputState()
public float GetIdealAltitude()
public void FixedUpdate()
public void OnDrawGizmos()
}
public CH47Helicopter : BaseHelicopterVehicle {
public GameObjectRef mapMarkerEntityPrefab
private BaseEntity mapMarkerInstance
public void ServerInit()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void CreateMapMarker()
}
public CH47HelicopterAIController : CH47Helicopter {
public GameObjectRef scientistPrefab
public float maxTiltAngle
public float AiAltitudeForce
public GameObjectRef lockedCratePrefab
public Flags Flag_Damaged
public Flags Flag_NearDeath
public Flags Flag_DropDoorOpen
public int numCrates
public bool aimDirOverride
public Vector3 _aimDirection
public Vector3 _moveTarget
public int lastAltitudeCheckFrame
public float altOverride
public float currentDesiredAltitude
public float hoverHeight
public void DropCrate()
public bool OutOfCrates()
public bool CanDropCrate()
public void SetDropDoorOpen(bool open)
public void TriggeredEventSpawn()
public void AttemptMount(BasePlayer player)
public void ServerInit()
public void SpawnScientist(Vector3 spawnPos)
public void SpawnScientists()
public void EnableFacingOverride(bool enabled)
public void SetMoveTarget(Vector3 position)
public Vector3 GetMoveTarget()
public void SetAimDirection(Vector3 dir)
public Vector3 GetAimDirectionOverride()
public Vector3 GetPosition()
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void CancelAnger()
public void InitiateAnger()
public void UnHostile()
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
public void DelayedKill()
public void DismountAllPlayers()
public float GetDesiredAltitude()
public float CalculateOverrideAltitude()
public HelicopterInputState_t GetDefaultInputState()
public void MaintainAIAltutide()
public void VehicleFixedUpdate()
public void DestroyShared()
}
public Chainsaw : BaseMelee {
public float fuelPerSec
public int maxAmmo
public int ammo
public ItemDefinition fuelType
public float reloadDuration
public SoundPlayer idleLoop
public SoundPlayer attackLoopAir
public SoundPlayer revUp
public SoundPlayer revDown
public SoundPlayer offSound
public float engineStartChance
private float ammoRemainder
public float attackFadeInTime
public float attackFadeInDelay
public float attackFadeOutTime
public float idleFadeInTimeFromOff
public float idleFadeInTimeFromAttack
public float idleFadeInDelay
public float idleFadeOutTime
public Renderer chainRenderer
private MaterialPropertyBlock block
private Vector2 saveST
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool EngineOn()
public bool IsAttacking()
protected bool VerifyClientAttack(BasePlayer player)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void SetHeld(bool bHeld)
public void ReduceAmmo(float firingTime)
public void DoReload(RPCMessage msg)
public void Save(SaveInfo info)
public void SetEngineStatus(bool status)
public void SetAttackStatus(bool status)
public void EngineTick()
public void AttackTick()
public void Server_StartEngine(RPCMessage msg)
public void Server_StopEngine(RPCMessage msg)
public void Server_SetAttacking(RPCMessage msg)
public void ServerCommand(Item item, string command, BasePlayer player)
public void DisableHitEffects()
public void EnableHitEffect(UInt32 hitMaterial)
public void DoAttackShared(HitInfo info)
public void Load(LoadInfo info)
public bool HasAmmo()
public Item GetAmmo()
}
public ChangeSignText : UIDialog {
public Action`1<Texture2D> onUpdateTexture
public GameObject objectContainer
}
public ChatEntry : MonoBehaviour {
public Text text
public RawImage avatar
public CanvasGroup canvasGroup
public float lifeStarted
public ulong steamid
}
public Chicken : BaseAnimalNPC {
public float Population
public TraitFlag Traits
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public ChildrenFromScene : MonoBehaviour {
public string SceneName
public bool StartChildrenDisabled
private IEnumerator Start()
}
public ChildrenScreenshot : MonoBehaviour {
public Vector3 offsetAngle
public int width
public int height
public float fieldOfView
public string folder
public void CreateScreenshots()
public void PositionCamera(Camera cam, GameObject obj)
}
public ChristmasTree : StorageContainer {
public GameObject[] decorations
public bool ItemFilter(Item item, int targetSlot)
public void OnItemAddedOrRemoved(Item item, bool added)
}
public Climate : SingletonComponent`1<Climate> {
private float fadeAngle
private float defaultTemp
private int weatherDurationHours
private int weatherFadeHours
public float BlendingSpeed
public float FogMultiplier
public float FogDarknessDistance
public bool DebugLUTBlending
public WeatherParameters Weather
public ClimateParameters Arid
public ClimateParameters Temperate
public ClimateParameters Tundra
public ClimateParameters Arctic
private ClimateParameters[] climates
private WeatherState state
private WeatherState clamps
public WeatherState Overrides
protected void Update()
public float GetClouds(Vector3 position)
public float GetCloudOpacity(Vector3 position)
public float GetFog(Vector3 position)
public float GetWind(Vector3 position)
public float GetRain(Vector3 position)
public float GetSnow(Vector3 position)
public float GetTemperature(Vector3 position)
private WeatherState GetWeatherState(UInt32 seed)
private float FindBlendParameters(Vector3 pos, ClimateParameters& src, ClimateParameters& dst)
}
public ClimateBlendTexture : ProcessedTexture {
public void .ctor(int width, int height, bool linear)
public bool CheckLostData()
public void Blend(Texture srcLut1, Texture dstLut1, float lerpLut1, Texture srcLut2, Texture dstLut2, float lerpLut2, float lerp, ClimateBlendTexture prevLut, float time)
public void Swap(ClimateBlendTexture& a, ClimateBlendTexture& b)
}
public ClothingMovementProperties : ScriptableObject {
public float speedReduction
public float minSpeedReduction
public float waterSpeedBonus
}
public ClothLOD : FacepunchBehaviour {
public float clothLODDist
public Cloth cloth
}
public ClothWindModify : FacepunchBehaviour {
public Cloth cloth
private Vector3 initialClothForce
public Vector3 worldWindScale
public Vector3 turbulenceScale
}
public CodeLock : BaseLock {
public GameObject keyEnterDialog
public GameObjectRef effectUnlocked
public GameObjectRef effectLocked
public GameObjectRef effectDenied
public GameObjectRef effectCodeChanged
public GameObjectRef effectShock
public bool hasCode
public bool hasGuestCode
public string code
public string guestCode
public List`1<ulong> whitelistPlayers
public List`1<ulong> guestPlayers
public int wrongCodes
public float lastWrongTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
internal void DoEffect(string effect)
public bool OnTryToOpen(BasePlayer player)
public bool OnTryToClose(BasePlayer player)
public void Save(SaveInfo info)
private void RPC_ChangeCode(RPCMessage rpc)
private void TryUnlock(RPCMessage rpc)
private void TryLock(RPCMessage rpc)
private void UnlockWithCode(RPCMessage rpc)
}
public ColdBreath : BaseMonoBehaviour {
public GameObjectRef effect
private BasePlayer player
private Transform jawBone
}
public ColdOverlay : ImageEffectLayer {
internal bool isPlaying
public ScreenOverlayEx screenOverlay
public CC_Frost frost
public LensDirtiness lensDirtyness
}
public CollectibleEntity : BaseEntity {
public Phrase itemName
public ItemAmount[] itemList
public GameObjectRef pickupEffect
public float xpScale
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Pickup(RPCMessage msg)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool SupportsPooling()
}
public ColliderBatch : MonoBehaviour {
private Transform <BatchTransform>k__BackingField
private MeshCollider <BatchCollider>k__BackingField
private Rigidbody <BatchRigidbody>k__BackingField
private ColliderGroup batchGroup
private MeshColliderInstance batchInstance
public Transform BatchTransform
public MeshCollider BatchCollider
public Rigidbody BatchRigidbody
public Transform get_BatchTransform()
public void set_BatchTransform(Transform value)
public MeshCollider get_BatchCollider()
public void set_BatchCollider(MeshCollider value)
public Rigidbody get_BatchRigidbody()
public void set_BatchRigidbody(Rigidbody value)
protected void OnEnable()
protected void OnDisable()
public void Add()
public void Remove()
public void Refresh()
public void AddBatch(ColliderGroup batchGroup)
}
public ColliderCell : object {
public Vector3 position
public ColliderGrid grid
public bool interrupt
private ListDictionary`2<ColliderKey, ColliderGroup> batches
public void .ctor(ColliderGrid grid, Vector3 position)
public bool NeedsRefresh()
public int MeshCount()
public int BatchedMeshCount()
public void Refresh()
public IEnumerator RefreshAsync()
public ColliderGroup FindBatchGroup(ColliderBatch collider)
private ColliderGroup CreateColliderGroup(ColliderGrid grid, ColliderCell cell, ColliderKey key)
private void DestroyColliderGroup(ColliderGroup& grp)
}
public ColliderGrid : SingletonComponent`1<ColliderGrid> {
public bool Paused
public float CellSize
public float MaxMilliseconds
private WorldSpaceGrid`1<ColliderCell> grid
private PrefabPool pool
private Stopwatch watch
public ColliderCell Item
public bool NeedsTimeout
protected void OnEnable()
public void RefreshAll()
public void Refresh()
public ColliderCell get_Item(Vector3 worldPos)
private void Init()
public MeshColliderBatch CreateInstance()
public void RecycleInstance(MeshColliderBatch instance)
public int MeshCount()
public int BatchedMeshCount()
public bool get_NeedsTimeout()
public void ResetTimeout()
private IEnumerator UpdateCoroutine()
}
public ColliderGroup : object {
public bool Invalidated
public bool NeedsRefresh
public bool Processing
public bool Preserving
public ListHashSet`1<ColliderBatch> Colliders
public List`1<ColliderBatch> TempColliders
public List`1<MeshColliderBatch> Batches
public List`1<MeshColliderBatch> TempBatches
public List`1<MeshColliderInstance> TempInstances
private ColliderGrid grid
private ColliderCell cell
private ColliderKey key
private Action updateData
private Action refreshBatches
public float Size
public Vector3 Position
public int Count
public float get_Size()
public Vector3 get_Position()
public int get_Count()
public void Initialize(ColliderGrid grid, ColliderCell cell, ColliderKey key)
public void EnterPool()
public void LeavePool()
public void Add(ColliderBatch collider)
public void Remove(ColliderBatch collider)
public void Invalidate()
public void Add(MeshColliderInstance instance)
public void UpdateData()
public void CreateBatches()
public void RefreshBatches()
public void ApplyBatches()
public void DisplayBatches()
public IEnumerator UpdateDataAsync()
public IEnumerator RefreshBatchesAsync()
public void Start()
public void End()
public void Clear()
public void Cancel()
public int MeshCount()
public int BatchedMeshCount()
public MeshColliderBatch CreateBatch()
}
public ColliderInfo : MonoBehaviour {
public Flags FlagsNone
public Flags FlagsEverything
public Flags FlagsDefault
public Flags flags
public bool HasFlag(Flags f)
public void SetFlag(Flags f, bool b)
public bool Filter(HitTest info)
}
public ColliderKey : ValueType {
public PhysicMaterial material
public int layer
public void .ctor(PhysicMaterial material, int layer)
public void .ctor(Collider collider)
public void .ctor(ColliderBatch batch)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(ColliderKey other)
}
public CombatLog : object {
private string selfname
private string noname
private BasePlayer player
private Queue`1<Event> storage
private Dictionary`2<ulong, Queue`1<Event>> players
public void .ctor(BasePlayer player)
public void Init()
public void Save()
public void Log(AttackEntity weapon, string description)
public void Log(AttackEntity weapon, Projectile projectile, string description)
public void Log(HitInfo info, string description)
public void Log(HitInfo info, float health_old, float health_new, string description)
public void Log(Event val)
public string Get(int count)
public Queue`1<Event> Get(ulong id)
}
public CommandBufferEx : object {
public void BlitArray(CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Material mat, int pass)
public void BlitArray(CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat, int pass)
public void BlitArrayMip(CommandBuffer cb, Mesh blitMesh, Texture source, int sourceMip, Texture target, int targetMip, Material mat, int pass)
public void BlitMip(CommandBuffer cb, Mesh blitMesh, Texture source, Texture target, int mip, Material mat, int pass)
}
public CommentComponent : MonoBehaviour {
public string comment
}
public CommunityEntity : PointEntity {
public CommunityEntity ServerInstance
public CommunityEntity ClientInstance
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void InitShared()
public void DestroyShared()
}
public ComponentInfo : MonoBehaviour {
public void Setup()
public void Reset()
}
public ComponentInfo`1 : ComponentInfo {
public T component
public void Initialize(T source)
}
public CompoundBowWeapon : BowWeapon {
public float stringHoldDurationMax
public float stringBonusDamage
public float stringBonusDistance
public float stringBonusVelocity
public float movementPenaltyRampUpTime
public SoundDefinition chargeUpSoundDef
public SoundDefinition stringHeldSoundDef
public SoundDefinition drawFinishSoundDef
private Sound chargeUpSound
private Sound stringHeldSound
protected float movementPenalty
internal float stringHoldTimeStart
protected float serverMovementCheckTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void UpdateMovementPenalty(float delta)
public void ServerMovementCheck()
public void OnHeldChanged()
public void RPC_StringHoldStatus(RPCMessage msg)
public void DidAttackServerside()
public float GetLastPlayerMovementTime()
public float GetStringBonusScale()
public float GetDamageScale(bool getMax)
public float GetDistanceScale(bool getMax)
public float GetProjectileVelocityScale(bool getMax)
}
public ConditionalModel : PrefabAttribute {
public bool onClient
public bool onServer
public ModelConditionTest[] conditions
public GameObject prefabObject
public string conditionalName
public UInt32 conditionalID
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool RunTests(BaseEntity parent)
public GameObject InstantiateSkin(BaseEntity parent)
protected Type GetIndexedType()
}
public ConnectionAuth : MonoBehaviour {
public List`1<Connection> m_AuthConnection
public bool IsConnected(ulong iSteamID)
public void Reject(Connection connection, string strReason)
public void OnDisconnect(Connection connection)
public void Approve(Connection connection)
public void OnNewConnection(Connection connection)
public IEnumerator AuthorisationRoutine(Connection connection)
}
public ConnectionQueue : object {
public List`1<Connection> queue
public List`1<Connection> joining
public float nextMessageTime
public int Queued
public int Joining
public int get_Queued()
public int get_Joining()
public void SkipQueue(ulong userid)
internal void Join(Connection connection)
public void Cycle(int availableSlots)
private void SendMessages()
private void SendMessage(Connection c, int position)
public void RemoveConnection(Connection connection)
private void JoinGame(Connection connection)
public void JoinedGame(Connection connection)
private bool CanJumpQueue(Connection connection)
}
public ConnectionScreen : SingletonComponent`1<ConnectionScreen> {
public Text statusText
public GameObject disconnectButton
public GameObject retryButton
public ServerBrowserInfo browserInfo
public UnityEvent onShowConnectionScreen
}
public ConsoleGen : object {
public Command[] All
private string <All>m__0()
private void <All>m__1(string str)
private string <All>m__2()
private void <All>m__3(string str)
private string <All>m__4()
private void <All>m__5(string str)
private string <All>m__6()
private void <All>m__7(string str)
private string <All>m__8()
private void <All>m__9(string str)
private void <All>m__A(Arg arg)
private void <All>m__B(Arg arg)
private void <All>m__C(Arg arg)
private void <All>m__D(Arg arg)
private void <All>m__E(Arg arg)
private void <All>m__F(Arg arg)
private void <All>m__10(Arg arg)
private void <All>m__11(Arg arg)
private void <All>m__12(Arg arg)
private void <All>m__13(Arg arg)
private void <All>m__14(Arg arg)
private void <All>m__15(Arg arg)
private void <All>m__16(Arg arg)
private void <All>m__17(Arg arg)
private void <All>m__18(Arg arg)
private void <All>m__19(Arg arg)
private void <All>m__1A(Arg arg)
private void <All>m__1B(Arg arg)
private void <All>m__1C(Arg arg)
private void <All>m__1D(Arg arg)
private void <All>m__1E(Arg arg)
private void <All>m__1F(Arg arg)
private void <All>m__20(Arg arg)
private void <All>m__21(Arg arg)
private void <All>m__22(Arg arg)
private void <All>m__23(Arg arg)
private void <All>m__24(Arg arg)
private void <All>m__25(Arg arg)
private void <All>m__26(Arg arg)
private void <All>m__27(Arg arg)
private void <All>m__28(Arg arg)
private void <All>m__29(Arg arg)
private void <All>m__2A(Arg arg)
private void <All>m__2B(Arg arg)
private string <All>m__2C()
private void <All>m__2D(string str)
private void <All>m__2E(Arg arg)
private void <All>m__2F(Arg arg)
private string <All>m__30()
private void <All>m__31(string str)
private string <All>m__32()
private void <All>m__33(string str)
private string <All>m__34()
private void <All>m__35(string str)
private string <All>m__36()
private void <All>m__37(string str)
private string <All>m__38()
private void <All>m__39(string str)
private string <All>m__3A()
private void <All>m__3B(string str)
private string <All>m__3C()
private void <All>m__3D(string str)
private string <All>m__3E()
private void <All>m__3F(string str)
private string <All>m__40()
private void <All>m__41(string str)
private string <All>m__42()
private void <All>m__43(string str)
private string <All>m__44()
private void <All>m__45(string str)
private string <All>m__46()
private void <All>m__47(string str)
private string <All>m__48()
private void <All>m__49(string str)
private string <All>m__4A()
private void <All>m__4B(string str)
private string <All>m__4C()
private void <All>m__4D(string str)
private string <All>m__4E()
private void <All>m__4F(string str)
private string <All>m__50()
private void <All>m__51(string str)
private string <All>m__52()
private void <All>m__53(string str)
private string <All>m__54()
private void <All>m__55(string str)
private string <All>m__56()
private void <All>m__57(string str)
private string <All>m__58()
private void <All>m__59(string str)
private string <All>m__5A()
private void <All>m__5B(string str)
private string <All>m__5C()
private void <All>m__5D(string str)
private string <All>m__5E()
private void <All>m__5F(string str)
private string <All>m__60()
private void <All>m__61(string str)
private string <All>m__62()
private void <All>m__63(string str)
private string <All>m__64()
private void <All>m__65(string str)
private string <All>m__66()
private void <All>m__67(string str)
private string <All>m__68()
private void <All>m__69(string str)
private string <All>m__6A()
private void <All>m__6B(string str)
private string <All>m__6C()
private void <All>m__6D(string str)
private string <All>m__6E()
private void <All>m__6F(string str)
private string <All>m__70()
private void <All>m__71(string str)
private string <All>m__72()
private void <All>m__73(string str)
private string <All>m__74()
private void <All>m__75(string str)
private string <All>m__76()
private void <All>m__77(string str)
private string <All>m__78()
private void <All>m__79(string str)
private string <All>m__7A()
private void <All>m__7B(string str)
private string <All>m__7C()
private void <All>m__7D(string str)
private void <All>m__7E(Arg arg)
private void <All>m__7F(Arg arg)
private string <All>m__80()
private void <All>m__81(string str)
private string <All>m__82()
private void <All>m__83(string str)
private string <All>m__84()
private void <All>m__85(string str)
private string <All>m__86()
private void <All>m__87(string str)
private string <All>m__88()
private void <All>m__89(string str)
private string <All>m__8A()
private void <All>m__8B(string str)
private string <All>m__8C()
private void <All>m__8D(string str)
private string <All>m__8E()
private void <All>m__8F(string str)
private string <All>m__90()
private void <All>m__91(string str)
private string <All>m__92()
private void <All>m__93(string str)
private string <All>m__94()
private void <All>m__95(string str)
private string <All>m__96()
private void <All>m__97(string str)
private string <All>m__98()
private void <All>m__99(string str)
private string <All>m__9A()
private void <All>m__9B(string str)
private string <All>m__9C()
private void <All>m__9D(string str)
private string <All>m__9E()
private void <All>m__9F(string str)
private string <All>m__A0()
private void <All>m__A1(string str)
private string <All>m__A2()
private void <All>m__A3(string str)
private string <All>m__A4()
private void <All>m__A5(string str)
private string <All>m__A6()
private void <All>m__A7(string str)
private string <All>m__A8()
private void <All>m__A9(string str)
private string <All>m__AA()
private void <All>m__AB(string str)
private string <All>m__AC()
private void <All>m__AD(string str)
private string <All>m__AE()
private void <All>m__AF(string str)
private string <All>m__B0()
private void <All>m__B1(string str)
private string <All>m__B2()
private void <All>m__B3(string str)
private string <All>m__B4()
private void <All>m__B5(string str)
private string <All>m__B6()
private void <All>m__B7(string str)
private string <All>m__B8()
private void <All>m__B9(string str)
private string <All>m__BA()
private void <All>m__BB(string str)
private string <All>m__BC()
private void <All>m__BD(string str)
private string <All>m__BE()
private void <All>m__BF(string str)
private string <All>m__C0()
private void <All>m__C1(string str)
private string <All>m__C2()
private void <All>m__C3(string str)
private string <All>m__C4()
private void <All>m__C5(string str)
private string <All>m__C6()
private void <All>m__C7(string str)
private string <All>m__C8()
private void <All>m__C9(string str)
private string <All>m__CA()
private void <All>m__CB(string str)
private string <All>m__CC()
private void <All>m__CD(string str)
private string <All>m__CE()
private void <All>m__CF(string str)
private string <All>m__D0()
private void <All>m__D1(string str)
private string <All>m__D2()
private void <All>m__D3(string str)
private string <All>m__D4()
private void <All>m__D5(string str)
private string <All>m__D6()
private void <All>m__D7(string str)
private string <All>m__D8()
private void <All>m__D9(string str)
private string <All>m__DA()
private void <All>m__DB(string str)
private string <All>m__DC()
private void <All>m__DD(string str)
private string <All>m__DE()
private void <All>m__DF(string str)
private string <All>m__E0()
private void <All>m__E1(string str)
private string <All>m__E2()
private void <All>m__E3(string str)
private string <All>m__E4()
private void <All>m__E5(string str)
private string <All>m__E6()
private void <All>m__E7(string str)
private string <All>m__E8()
private void <All>m__E9(string str)
private string <All>m__EA()
private void <All>m__EB(string str)
private string <All>m__EC()
private void <All>m__ED(string str)
private string <All>m__EE()
private void <All>m__EF(string str)
private string <All>m__F0()
private void <All>m__F1(string str)
private string <All>m__F2()
private void <All>m__F3(string str)
private void <All>m__F4(Arg arg)
private void <All>m__F5(Arg arg)
private string <All>m__F6()
private void <All>m__F7(string str)
private string <All>m__F8()
private void <All>m__F9(string str)
private void <All>m__FA(Arg arg)
private string <All>m__FB()
private void <All>m__FC(string str)
private string <All>m__FD()
private void <All>m__FE(string str)
private string <All>m__FF()
private void <All>m__100(string str)
private void <All>m__101(Arg arg)
private void <All>m__102(Arg arg)
private string <All>m__103()
private void <All>m__104(string str)
private void <All>m__105(Arg arg)
private void <All>m__106(Arg arg)
private void <All>m__107(Arg arg)
private string <All>m__108()
private void <All>m__109(string str)
private void <All>m__10A(Arg arg)
private void <All>m__10B(Arg arg)
private void <All>m__10C(Arg arg)
private string <All>m__10D()
private void <All>m__10E(string str)
private void <All>m__10F(Arg arg)
private void <All>m__110(Arg arg)
private void <All>m__111(Arg arg)
private string <All>m__112()
private void <All>m__113(string str)
private string <All>m__114()
private void <All>m__115(string str)
private string <All>m__116()
private void <All>m__117(string str)
private void <All>m__118(Arg arg)
private void <All>m__119(Arg arg)
private void <All>m__11A(Arg arg)
private void <All>m__11B(Arg arg)
private string <All>m__11C()
private void <All>m__11D(string str)
private void <All>m__11E(Arg arg)
private void <All>m__11F(Arg arg)
private void <All>m__120(Arg arg)
private void <All>m__121(Arg arg)
private string <All>m__122()
private void <All>m__123(string str)
private string <All>m__124()
private void <All>m__125(string str)
private string <All>m__126()
private void <All>m__127(string str)
private string <All>m__128()
private void <All>m__129(string str)
private string <All>m__12A()
private void <All>m__12B(string str)
private string <All>m__12C()
private void <All>m__12D(string str)
private string <All>m__12E()
private void <All>m__12F(string str)
private string <All>m__130()
private void <All>m__131(string str)
private string <All>m__132()
private void <All>m__133(string str)
private string <All>m__134()
private void <All>m__135(string str)
private string <All>m__136()
private void <All>m__137(string str)
private string <All>m__138()
private void <All>m__139(string str)
private string <All>m__13A()
private void <All>m__13B(string str)
private string <All>m__13C()
private void <All>m__13D(string str)
private string <All>m__13E()
private void <All>m__13F(string str)
private string <All>m__140()
private void <All>m__141(string str)
private string <All>m__142()
private void <All>m__143(string str)
private string <All>m__144()
private void <All>m__145(string str)
private string <All>m__146()
private void <All>m__147(string str)
private string <All>m__148()
private void <All>m__149(string str)
private string <All>m__14A()
private void <All>m__14B(string str)
private string <All>m__14C()
private void <All>m__14D(string str)
private string <All>m__14E()
private void <All>m__14F(string str)
private string <All>m__150()
private void <All>m__151(string str)
private string <All>m__152()
private void <All>m__153(string str)
private string <All>m__154()
private void <All>m__155(string str)
private string <All>m__156()
private void <All>m__157(string str)
private string <All>m__158()
private void <All>m__159(string str)
private string <All>m__15A()
private void <All>m__15B(string str)
private void <All>m__15C(Arg arg)
private void <All>m__15D(Arg arg)
private void <All>m__15E(Arg arg)
private void <All>m__15F(Arg arg)
private void <All>m__160(Arg arg)
private void <All>m__161(Arg arg)
private void <All>m__162(Arg arg)
private void <All>m__163(Arg arg)
private void <All>m__164(Arg arg)
private void <All>m__165(Arg arg)
private void <All>m__166(Arg arg)
private void <All>m__167(Arg arg)
private void <All>m__168(Arg arg)
private void <All>m__169(Arg arg)
private string <All>m__16A()
private void <All>m__16B(string str)
private string <All>m__16C()
private void <All>m__16D(string str)
private string <All>m__16E()
private void <All>m__16F(string str)
private string <All>m__170()
private void <All>m__171(string str)
private string <All>m__172()
private void <All>m__173(string str)
private string <All>m__174()
private void <All>m__175(string str)
private void <All>m__176(Arg arg)
private void <All>m__177(Arg arg)
private void <All>m__178(Arg arg)
private void <All>m__179(Arg arg)
private string <All>m__17A()
private void <All>m__17B(string str)
private void <All>m__17C(Arg arg)
private void <All>m__17D(Arg arg)
private void <All>m__17E(Arg arg)
private void <All>m__17F(Arg arg)
private string <All>m__180()
private void <All>m__181(string str)
private void <All>m__182(Arg arg)
private string <All>m__183()
private void <All>m__184(string str)
private void <All>m__185(Arg arg)
private void <All>m__186(Arg arg)
private void <All>m__187(Arg arg)
private void <All>m__188(Arg arg)
private void <All>m__189(Arg arg)
private void <All>m__18A(Arg arg)
private void <All>m__18B(Arg arg)
private void <All>m__18C(Arg arg)
private void <All>m__18D(Arg arg)
private void <All>m__18E(Arg arg)
private void <All>m__18F(Arg arg)
private void <All>m__190(Arg arg)
private void <All>m__191(Arg arg)
private void <All>m__192(Arg arg)
private void <All>m__193(Arg arg)
private void <All>m__194(Arg arg)
private void <All>m__195(Arg arg)
private void <All>m__196(Arg arg)
private void <All>m__197(Arg arg)
private string <All>m__198()
private void <All>m__199(string str)
private void <All>m__19A(Arg arg)
private string <All>m__19B()
private void <All>m__19C(string str)
private string <All>m__19D()
private void <All>m__19E(string str)
private void <All>m__19F(Arg arg)
private void <All>m__1A0(Arg arg)
private void <All>m__1A1(Arg arg)
private void <All>m__1A2(Arg arg)
private void <All>m__1A3(Arg arg)
private void <All>m__1A4(Arg arg)
private void <All>m__1A5(Arg arg)
private void <All>m__1A6(Arg arg)
private void <All>m__1A7(Arg arg)
private void <All>m__1A8(Arg arg)
private void <All>m__1A9(Arg arg)
private void <All>m__1AA(Arg arg)
private void <All>m__1AB(Arg arg)
private void <All>m__1AC(Arg arg)
private string <All>m__1AD()
private void <All>m__1AE(string str)
private string <All>m__1AF()
private void <All>m__1B0(string str)
private string <All>m__1B1()
private void <All>m__1B2(string str)
private void <All>m__1B3(Arg arg)
private void <All>m__1B4(Arg arg)
private void <All>m__1B5(Arg arg)
private string <All>m__1B6()
private void <All>m__1B7(string str)
private string <All>m__1B8()
private void <All>m__1B9(string str)
private void <All>m__1BA(Arg arg)
private string <All>m__1BB()
private void <All>m__1BC(string str)
private string <All>m__1BD()
private void <All>m__1BE(string str)
private string <All>m__1BF()
private void <All>m__1C0(string str)
private string <All>m__1C1()
private void <All>m__1C2(string str)
private string <All>m__1C3()
private void <All>m__1C4(string str)
private string <All>m__1C5()
private void <All>m__1C6(string str)
private string <All>m__1C7()
private void <All>m__1C8(string str)
private string <All>m__1C9()
private void <All>m__1CA(string str)
private void <All>m__1CB(Arg arg)
private void <All>m__1CC(Arg arg)
private void <All>m__1CD(Arg arg)
private string <All>m__1CE()
private void <All>m__1CF(string str)
private string <All>m__1D0()
private void <All>m__1D1(string str)
private string <All>m__1D2()
private void <All>m__1D3(string str)
private void <All>m__1D4(Arg arg)
private void <All>m__1D5(Arg arg)
private void <All>m__1D6(Arg arg)
private void <All>m__1D7(Arg arg)
private void <All>m__1D8(Arg arg)
private string <All>m__1D9()
private void <All>m__1DA(string str)
private string <All>m__1DB()
private void <All>m__1DC(string str)
private string <All>m__1DD()
private void <All>m__1DE(string str)
private string <All>m__1DF()
private void <All>m__1E0(string str)
private string <All>m__1E1()
private void <All>m__1E2(string str)
private void <All>m__1E3(Arg arg)
private string <All>m__1E4()
private void <All>m__1E5(string str)
private string <All>m__1E6()
private void <All>m__1E7(string str)
private string <All>m__1E8()
private void <All>m__1E9(string str)
private string <All>m__1EA()
private void <All>m__1EB(string str)
private string <All>m__1EC()
private void <All>m__1ED(string str)
private void <All>m__1EE(Arg arg)
private void <All>m__1EF(Arg arg)
private string <All>m__1F0()
private void <All>m__1F1(string str)
private string <All>m__1F2()
private void <All>m__1F3(string str)
private string <All>m__1F4()
private void <All>m__1F5(string str)
private string <All>m__1F6()
private void <All>m__1F7(string str)
private string <All>m__1F8()
private void <All>m__1F9(string str)
private string <All>m__1FA()
private void <All>m__1FB(string str)
private string <All>m__1FC()
private void <All>m__1FD(string str)
private string <All>m__1FE()
private void <All>m__1FF(string str)
private string <All>m__200()
private void <All>m__201(string str)
private string <All>m__202()
private void <All>m__203(string str)
private string <All>m__204()
private void <All>m__205(string str)
private void <All>m__206(Arg arg)
private string <All>m__207()
private void <All>m__208(string str)
private string <All>m__209()
private void <All>m__20A(string str)
private string <All>m__20B()
private void <All>m__20C(string str)
private string <All>m__20D()
private void <All>m__20E(string str)
private string <All>m__20F()
private void <All>m__210(string str)
private string <All>m__211()
private void <All>m__212(string str)
private string <All>m__213()
private void <All>m__214(string str)
private string <All>m__215()
private void <All>m__216(string str)
private string <All>m__217()
private void <All>m__218(string str)
private string <All>m__219()
private void <All>m__21A(string str)
private string <All>m__21B()
private void <All>m__21C(string str)
private string <All>m__21D()
private void <All>m__21E(string str)
private string <All>m__21F()
private void <All>m__220(string str)
private string <All>m__221()
private void <All>m__222(string str)
private string <All>m__223()
private void <All>m__224(string str)
private string <All>m__225()
private void <All>m__226(string str)
private string <All>m__227()
private void <All>m__228(string str)
private string <All>m__229()
private void <All>m__22A(string str)
private string <All>m__22B()
private void <All>m__22C(string str)
private string <All>m__22D()
private void <All>m__22E(string str)
private string <All>m__22F()
private void <All>m__230(string str)
private string <All>m__231()
private void <All>m__232(string str)
private string <All>m__233()
private void <All>m__234(string str)
private string <All>m__235()
private void <All>m__236(string str)
private string <All>m__237()
private void <All>m__238(string str)
private string <All>m__239()
private void <All>m__23A(string str)
private string <All>m__23B()
private void <All>m__23C(string str)
private string <All>m__23D()
private void <All>m__23E(string str)
private string <All>m__23F()
private void <All>m__240(string str)
private string <All>m__241()
private void <All>m__242(string str)
private string <All>m__243()
private void <All>m__244(string str)
private void <All>m__245(Arg arg)
private void <All>m__246(Arg arg)
private void <All>m__247(Arg arg)
private string <All>m__248()
private void <All>m__249(string str)
private string <All>m__24A()
private void <All>m__24B(string str)
private string <All>m__24C()
private void <All>m__24D(string str)
private string <All>m__24E()
private void <All>m__24F(string str)
private void <All>m__250(Arg arg)
private string <All>m__251()
private void <All>m__252(string str)
private string <All>m__253()
private void <All>m__254(string str)
private void <All>m__255(Arg arg)
private string <All>m__256()
private void <All>m__257(string str)
private string <All>m__258()
private void <All>m__259(string str)
private string <All>m__25A()
private void <All>m__25B(string str)
private string <All>m__25C()
private void <All>m__25D(string str)
private string <All>m__25E()
private void <All>m__25F(string str)
private void <All>m__260(Arg arg)
private void <All>m__261(Arg arg)
private string <All>m__262()
private void <All>m__263(string str)
private void <All>m__264(Arg arg)
private string <All>m__265()
private void <All>m__266(string str)
private void <All>m__267(Arg arg)
private string <All>m__268()
private void <All>m__269(string str)
private void <All>m__26A(Arg arg)
private string <All>m__26B()
private void <All>m__26C(string str)
private string <All>m__26D()
private void <All>m__26E(string str)
private string <All>m__26F()
private void <All>m__270(string str)
private string <All>m__271()
private void <All>m__272(string str)
private string <All>m__273()
private void <All>m__274(string str)
private string <All>m__275()
private void <All>m__276(string str)
private void <All>m__277(Arg arg)
private void <All>m__278(Arg arg)
private void <All>m__279(Arg arg)
private void <All>m__27A(Arg arg)
private string <All>m__27B()
private void <All>m__27C(string str)
private string <All>m__27D()
private void <All>m__27E(string str)
private string <All>m__27F()
private void <All>m__280(string str)
private string <All>m__281()
private void <All>m__282(string str)
private string <All>m__283()
private void <All>m__284(string str)
private string <All>m__285()
private void <All>m__286(string str)
private void <All>m__287(Arg arg)
private string <All>m__288()
private void <All>m__289(string str)
private string <All>m__28A()
private void <All>m__28B(string str)
private string <All>m__28C()
private void <All>m__28D(string str)
private void <All>m__28E(Arg arg)
private string <All>m__28F()
private void <All>m__290(string str)
private string <All>m__291()
private void <All>m__292(string str)
private void <All>m__293(Arg arg)
private string <All>m__294()
private void <All>m__295(string str)
private string <All>m__296()
private void <All>m__297(string str)
private string <All>m__298()
private void <All>m__299(string str)
private string <All>m__29A()
private void <All>m__29B(string str)
private void <All>m__29C(Arg arg)
private void <All>m__29D(Arg arg)
private string <All>m__29E()
private void <All>m__29F(string str)
private string <All>m__2A0()
private void <All>m__2A1(string str)
private string <All>m__2A2()
private void <All>m__2A3(string str)
private string <All>m__2A4()
private void <All>m__2A5(string str)
private string <All>m__2A6()
private void <All>m__2A7(string str)
private void <All>m__2A8(Arg arg)
private string <All>m__2A9()
private void <All>m__2AA(string str)
private string <All>m__2AB()
private void <All>m__2AC(string str)
private string <All>m__2AD()
private void <All>m__2AE(string str)
private string <All>m__2AF()
private void <All>m__2B0(string str)
private string <All>m__2B1()
private void <All>m__2B2(string str)
private string <All>m__2B3()
private void <All>m__2B4(string str)
private string <All>m__2B5()
private void <All>m__2B6(string str)
private string <All>m__2B7()
private void <All>m__2B8(string str)
private void <All>m__2B9(Arg arg)
private void <All>m__2BA(Arg arg)
private void <All>m__2BB(Arg arg)
private void <All>m__2BC(Arg arg)
private void <All>m__2BD(Arg arg)
private string <All>m__2BE()
private void <All>m__2BF(string str)
private string <All>m__2C0()
private void <All>m__2C1(string str)
private string <All>m__2C2()
private void <All>m__2C3(string str)
private void <All>m__2C4(Arg arg)
private string <All>m__2C5()
private void <All>m__2C6(string str)
private string <All>m__2C7()
private void <All>m__2C8(string str)
private void <All>m__2C9(Arg arg)
private void <All>m__2CA(Arg arg)
private void <All>m__2CB(Arg arg)
private string <All>m__2CC()
private void <All>m__2CD(string str)
private string <All>m__2CE()
private void <All>m__2CF(string str)
private string <All>m__2D0()
private void <All>m__2D1(string str)
private string <All>m__2D2()
private void <All>m__2D3(string str)
private string <All>m__2D4()
private void <All>m__2D5(string str)
private string <All>m__2D6()
private void <All>m__2D7(string str)
private string <All>m__2D8()
private void <All>m__2D9(string str)
private string <All>m__2DA()
private void <All>m__2DB(string str)
private string <All>m__2DC()
private void <All>m__2DD(string str)
private void <All>m__2DE(Arg arg)
private string <All>m__2DF()
private void <All>m__2E0(string str)
private void <All>m__2E1(Arg arg)
private void <All>m__2E2(Arg arg)
private void <All>m__2E3(Arg arg)
private void <All>m__2E4(Arg arg)
private void <All>m__2E5(Arg arg)
private string <All>m__2E6()
private void <All>m__2E7(string str)
private void <All>m__2E8(Arg arg)
private void <All>m__2E9(Arg arg)
private void <All>m__2EA(Arg arg)
private void <All>m__2EB(Arg arg)
private void <All>m__2EC(Arg arg)
private string <All>m__2ED()
private void <All>m__2EE(string str)
private string <All>m__2EF()
private void <All>m__2F0(string str)
private string <All>m__2F1()
private void <All>m__2F2(string str)
private string <All>m__2F3()
private void <All>m__2F4(string str)
private string <All>m__2F5()
private void <All>m__2F6(string str)
private string <All>m__2F7()
private void <All>m__2F8(string str)
private string <All>m__2F9()
private void <All>m__2FA(string str)
private string <All>m__2FB()
private void <All>m__2FC(string str)
private string <All>m__2FD()
private void <All>m__2FE(string str)
private string <All>m__2FF()
private void <All>m__300(string str)
private string <All>m__301()
private void <All>m__302(string str)
private string <All>m__303()
private void <All>m__304(string str)
private string <All>m__305()
private void <All>m__306(string str)
private string <All>m__307()
private void <All>m__308(string str)
private string <All>m__309()
private void <All>m__30A(string str)
private string <All>m__30B()
private void <All>m__30C(string str)
private string <All>m__30D()
private void <All>m__30E(string str)
private string <All>m__30F()
private void <All>m__310(string str)
private string <All>m__311()
private void <All>m__312(string str)
private string <All>m__313()
private void <All>m__314(string str)
private string <All>m__315()
private void <All>m__316(string str)
private string <All>m__317()
private void <All>m__318(string str)
private string <All>m__319()
private void <All>m__31A(string str)
}
public ConsoleNetwork : object {
internal void Init()
internal void OnClientCommand(Message packet)
internal void SendClientReply(Connection cn, string strCommand)
public void SendClientCommand(Connection cn, string strCommand, Object[] args)
public void SendClientCommand(List`1<Connection> cn, string strCommand, Object[] args)
public void BroadcastToAllClients(string strCommand, Object[] args)
}
public ConsoleUI : SingletonComponent`1<ConsoleUI> {
public Text text
public InputField outputField
public InputField inputField
public GameObject AutocompleteDropDown
public GameObject ItemTemplate
public Color errorColor
public Color warningColor
public Color inputColor
}
public Construction : PrefabAttribute {
public Option info
public bool canBypassBuildingPermission
public bool canRotate
public bool checkVolumeOnRotate
public bool checkVolumeOnUpgrade
public bool canPlaceAtMaxDistance
public Vector3 rotationAmount
public float healthMultiplier
public float costMultiplier
public float maxplaceDistance
public Mesh guideMesh
public Socket_Base[] allSockets
public BuildingProximity[] allProximities
public ConstructionGrade defaultGrade
public SocketHandle socketHandle
public Bounds bounds
public bool isBuildingPrivilege
public ConstructionGrade[] grades
public Deployable deployable
public ConstructionPlaceholder placeholder
public string lastPlacementError
public BaseEntity CreateConstruction(Target target, bool bNeedsValidPlacement)
public bool HasMaleSockets(Target target)
public void FindMaleSockets(Target target, List`1<Socket_Base> sockets)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
public bool UpdatePlacement(Transform transform, Construction common, Target& target)
private bool TestPlacingThroughRock(Placement& placement, Target target)
private bool TestPlacingThroughWall(Placement& placement, Transform transform, Construction common, Target target)
}
public ConstructionGrade : PrefabAttribute {
public Construction construction
public BuildingGrade gradeBase
public GameObjectRef skinObject
internal List`1<ItemAmount> _costToBuild
public float maxHealth
public List`1<ItemAmount> costToBuild
public float get_maxHealth()
public List`1<ItemAmount> get_costToBuild()
protected Type GetIndexedType()
}
public ConstructionPlaceholder : PrefabAttribute {
public Mesh mesh
public Material material
public bool renderer
public bool collider
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
}
public ConstructionSkin : BasePrefab {
private ColliderBatch[] colliderBatches
private List`1<GameObject> conditionals
private void RefreshColliderBatching()
public int DetermineConditionalModelState(BuildingBlock parent)
private void CreateConditionalModels(BuildingBlock parent)
private void DestroyConditionalModels(BuildingBlock parent)
public void Refresh(BuildingBlock parent)
public void Destroy(BuildingBlock parent)
}
public ConstructionSocket : Socket_Base {
public Type socketType
public int rotationDegrees
public int rotationOffset
public bool restrictPlacementAngle
public float faceAngle
public float angleAllowed
public float support
private void OnDrawGizmos()
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public bool IsCompatible(Socket_Base socket)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
public bool TestRestrictedAngles(Vector3 suggestedPos, Quaternion suggestedAng, Target target)
public Placement DoPlacement(Target target)
}
public ConsumableInformationPanel : ItemInformationPanel {
public ItemTextValue[] values
}
public ContainerSourceLocalPlayer : ItemContainerSource {
public Type type
public ItemContainer GetItemContainer()
}
public ContainerSourceLoot : ItemContainerSource {
public int container
public ItemContainer GetItemContainer()
}
public ContainerSourceSelectedItem : ItemContainerSource {
public ItemContainer GetItemContainer()
}
public ConVar.Admin : ConsoleSystem {
private Func`2<BasePlayer, PlayerInfo> <>f__am$cache0
public void status(Arg arg)
public void stats(Arg arg)
public void kick(Arg arg)
public void kickall(Arg arg)
public void ban(Arg arg)
public void moderatorid(Arg arg)
public void ownerid(Arg arg)
public void removemoderator(Arg arg)
public void removeowner(Arg arg)
public void banid(Arg arg)
public void unban(Arg arg)
public void skipqueue(Arg arg)
public void players(Arg arg)
public void say(Arg arg)
public void users(Arg arg)
public void banlist(Arg arg)
public void banlistex(Arg arg)
public void listid(Arg arg)
public void mutevoice(Arg arg)
public void unmutevoice(Arg arg)
public void mutechat(Arg arg)
public void unmutechat(Arg arg)
public void clientperf(Arg arg)
public void entid(Arg arg)
public PlayerInfo[] playerlist()
public User[] Bans()
public ServerInfoOutput ServerInfo()
public BuildInfo BuildInfo()
private PlayerInfo <playerlist>m__0(BasePlayer x)
}
public ConVar.AI : ConsoleSystem {
public bool think
public bool ignoreplayers
public bool move
public float sensetime
public float frametime
public bool npc_enable
public int npc_max_population_military_tunnels
public int npc_spawn_per_tick_max_military_tunnels
public int npc_spawn_per_tick_min_military_tunnels
public float npc_respawn_delay_max_military_tunnels
public float npc_respawn_delay_min_military_tunnels
public float npc_valid_aim_cone
public float npc_valid_mounted_aim_cone
public float npc_cover_compromised_cooldown
public bool npc_cover_use_path_distance
public float npc_cover_path_vs_straight_dist_max_diff
public float npc_door_trigger_size
public float npc_patrol_point_cooldown
public float npc_speed_walk
public float npc_speed_run
public float npc_speed_sprint
public float npc_speed_crouch_walk
public float npc_speed_crouch_run
public float npc_alertness_drain_rate
public float npc_alertness_zero_detection_mod
public float npc_junkpile_a_spawn_chance
public float npc_junkpile_g_spawn_chance
public int npc_max_junkpile_count
public bool npc_families_no_hurt
public bool npc_ignore_chairs
public float npc_sensory_system_tick_rate_multiplier
public float npc_cover_info_tick_rate_multiplier
public float npc_reasoning_system_tick_rate_multiplier
public bool animal_ignore_food
public float npc_gun_noise_silencer_modifier
public bool nav_carve_use_building_optimization
public int nav_carve_min_building_blocks_to_apply_optimization
public float nav_carve_min_base_size
public float nav_carve_size_multiplier
public float nav_carve_height
public float nav_bandit_hurt_hostility_time
public float nav_bandit_shot_hostility_time
public float tickrate
public float TickDelta()
public void aiManagerLoadBalancerUpdateInterval(Arg args)
public void defaultLoadBalancerUpdateInterval(Arg args)
public void aiLoadBalancerUpdateInterval(Arg args)
public void NpcSenseLoadBalancerUpdateInterval(Arg args)
public void AnimalSenseLoadBalancerUpdateInterval(Arg args)
public void aiDebug_toggle(Arg args)
public void aiDebug_LoadBalanceOverdueReportServer(Arg args)
private void AddLBTableEntry(TextTable& table, string name, LoadBalancedQueue lb)
public void selectNPCLookatServer(Arg args)
}
public ConVar.AntiHack : ConsoleSystem {
public bool reporting
public bool admincheat
public bool objectplacement
public bool modelstate
public int userlevel
public int enforcementlevel
public float maxdesync
public float maxdeltatime
public float relaxationrate
public float relaxationpause
public float maxviolation
public int noclip_protection
public bool noclip_reject
public float noclip_penalty
public float noclip_margin
public float noclip_backtracking
public float noclip_stepsize
public int noclip_maxsteps
public int speedhack_protection
public bool speedhack_reject
public float speedhack_penalty
public float speedhack_forgiveness
public float speedhack_slopespeed
public int flyhack_protection
public bool flyhack_reject
public float flyhack_penalty
public float flyhack_forgiveness_vertical
public float flyhack_forgiveness_horizontal
public float flyhack_extrusion
public float flyhack_margin
public float flyhack_stepsize
public int flyhack_maxsteps
public int projectile_protection
public float projectile_penalty
public float projectile_forgiveness
public float projectile_serverframes
public float projectile_clientframes
public float projectile_trajectory_vertical
public float projectile_trajectory_horizontal
public int melee_protection
public float melee_penalty
public float melee_forgiveness
public float melee_serverframes
public float melee_clientframes
public int eye_protection
public float eye_penalty
public float eye_forgiveness
public float eye_serverframes
public float eye_clientframes
public int debuglevel
}
public ConVar.Audio : ConsoleSystem {
public float master
public float musicvolume
public float musicvolumemenu
public float game
public float voices
public bool ambience
public float framebudget
public bool advancedocclusion
public int speakers
public int get_speakers()
public void set_speakers(int value)
}
public ConVar.Batching : ConsoleSystem {
public bool colliders
public bool collider_threading
public int collider_capacity
public int collider_vertices
public int collider_submeshes
public bool renderers
public bool renderer_threading
public int renderer_capacity
public int renderer_vertices
public int renderer_submeshes
public int verbose
public void refresh_colliders(Arg args)
public void print_colliders(Arg args)
}
public ConVar.Bradley : ConsoleSystem {
public float respawnDelayMinutes
public float respawnDelayVariance
public bool enabled
public void quickrespawn(Arg arg)
}
public ConVar.Chat : ConsoleSystem {
private float textRange
private float textVolumeBoost
public bool enabled
private List`1<ChatEntry> History
public bool serverlog
public void Broadcast(string message, string username, string color, ulong userid)
public void say(Arg arg)
public IEnumerable`1<ChatEntry> tail(Arg arg)
public IEnumerable`1<ChatEntry> search(Arg arg)
}
public ConVar.Client : object {
public float tickrate
}
public ConVar.Console : ConsoleSystem {
public IEnumerable`1<Entry> tail(Arg arg)
public IEnumerable`1<Entry> search(Arg arg)
}
public ConVar.Construct : ConsoleSystem {
public float frameminutes
}
public ConVar.Craft : ConsoleSystem {
public bool instant
public void add(Arg args)
public void canceltask(Arg args)
public void cancel(Arg args)
}
public ConVar.Data : ConsoleSystem {
public void export(Arg args)
}
public ConVar.Debugging : ConsoleSystem {
public bool checktriggers
public bool disablecondition
public bool callbacks
private Func`2<BaseNetworkable, bool> <>f__am$cache0
public bool log
public void renderinfo(Arg arg)
public void set_log(bool value)
public bool get_log()
public void stall(Arg arg)
public void flushgroup(Arg arg)
public void breakheld(Arg arg)
public void puzzlereset(Arg arg)
public void puzzleprefabrespawn(Arg arg)
public void breakitem(Arg arg)
public void hurt(Arg arg)
public void eat(Arg arg)
public void drink(Arg arg)
private bool <puzzleprefabrespawn>m__0(BaseNetworkable x)
}
public ConVar.Decay : ConsoleSystem {
public float outside_test_range
public float tick
public float scale
public bool debug
public bool upkeep
public float upkeep_period_minutes
public float upkeep_grief_protection
public float upkeep_heal_scale
public float upkeep_inside_decay_scale
public float delay_override
public float delay_twig
public float delay_wood
public float delay_stone
public float delay_metal
public float delay_toptier
public float duration_override
public float duration_twig
public float duration_wood
public float duration_stone
public float duration_metal
public float duration_toptier
public int bracket_0_blockcount
public float bracket_0_costfraction
public int bracket_1_blockcount
public float bracket_1_costfraction
public int bracket_2_blockcount
public float bracket_2_costfraction
public int bracket_3_blockcount
public float bracket_3_costfraction
}
public ConVar.Entity : ConsoleSystem {
private Func`2<string, string> <>f__mg$cache0
private Func`2<string, string> <>f__am$cache0
private Func`2<ItemDefinition, string> <>f__am$cache1
private TextTable GetEntityTable(Func`2<EntityInfo, bool> filter)
public void find_entity(Arg args)
public void find_id(Arg args)
public void find_group(Arg args)
public void find_parent(Arg args)
public void find_status(Arg args)
public void find_radius(Arg args)
public void find_self(Arg args)
public void debug_toggle(Arg args)
public void nudge(int entID)
public string svspawn(string name, Vector3 pos)
public string svspawnitem(string name, Vector3 pos)
public void spawnlootfrom(Arg args)
public int DeleteBy(ulong SteamId)
private string <svspawn>m__0(string x)
private string <svspawnitem>m__1(ItemDefinition x)
}
public ConVar.Env : ConsoleSystem {
public bool progresstime
public float time
public int day
public int month
public int year
public void set_progresstime(bool value)
public bool get_progresstime()
public void set_time(float value)
public float get_time()
public void set_day(int value)
public int get_day()
public void set_month(int value)
public int get_month()
public void set_year(int value)
public int get_year()
public void addtime(Arg arg)
}
public ConVar.FileConVar : ConsoleSystem {
public bool debug
public bool time
public bool get_debug()
public void set_debug(bool value)
public bool get_time()
public void set_time(bool value)
}
public ConVar.FPS : ConsoleSystem {
private int m_graph
public int limit
public int graph
public int get_limit()
public void set_limit(int value)
public int get_graph()
public void set_graph(int value)
}
public ConVar.GC : ConsoleSystem {
public void collect()
public void unload()
}
public ConVar.Global : ConsoleSystem {
private int _developer
public int maxthreads
public int perf
public bool god
public bool specnet
private Func`2<KeyValuePair`2<Type, long>, long> <>f__am$cache0
private Func`2<Collider, bool> <>f__am$cache1
private Func`2<Collider, bool> <>f__am$cache2
public bool timewarning
public int developer
public bool get_timewarning()
public void set_timewarning(bool value)
public void set_developer(int value)
public int get_developer()
public void restart(Arg args)
public void quit(Arg args)
public void report(Arg args)
public void objects(Arg args)
public void textures(Arg args)
public void colliders(Arg args)
public void error(Arg args)
public void queue(Arg args)
public void setinfo(Arg args)
public void sleep(Arg args)
public void kill(Arg args)
public void respawn(Arg args)
public void injure(Arg args)
public void spectate(Arg args)
public void respawn_sleepingbag(Arg args)
public void respawn_sleepingbag_remove(Arg args)
public void status_sv(Arg args)
public void status_cl(Arg args)
public void teleport(Arg args)
public void teleport2me(Arg args)
public void teleportany(Arg args)
public void teleportpos(Arg args)
public void free(Arg args)
public void version(Arg arg)
public void sysinfo(Arg arg)
public void sysuid(Arg arg)
public void breakitem(Arg args)
public void subscriptions(Arg arg)
private long <objects>m__0(KeyValuePair`2<Type, long> x)
private bool <colliders>m__1(Collider x)
private bool <colliders>m__2(Collider x)
}
public ConVar.Graphics : ConsoleSystem {
private float MinShadowDistance
private float MaxShadowDistance2Split
private float MaxShadowDistance4Split
private float _shadowdistance
public int shadowmode
public int shadowlights
private int _shadowquality
public bool grassshadows
public bool contactshadows
public float drawdistance
private float _fov
public bool hud
public bool chat
public bool branding
public int compass
public bool dof
public float dof_aper
public float dof_blur
private float _uiscale
private int _anisotropic
private int _parallax
public int quality
public float shadowdistance
public int shadowcascades
public int shadowquality
public float fov
public float lodbias
public int shaderlod
public float uiscale
public int af
public int parallax
public bool itemskins
public bool itemskincache
public float itemskintimeout
public int get_quality()
public void set_quality(int value)
public float EnforceShadowDistanceBounds(float distance)
public float get_shadowdistance()
public void set_shadowdistance(float value)
public int get_shadowcascades()
public void set_shadowcascades(int value)
public int get_shadowquality()
public void set_shadowquality(int value)
public float get_fov()
public void set_fov(float value)
public float get_lodbias()
public void set_lodbias(float value)
public int get_shaderlod()
public void set_shaderlod(int value)
public float get_uiscale()
public void set_uiscale(float value)
public int get_af()
public void set_af(int value)
public int get_parallax()
public void set_parallax(int value)
public bool get_itemskins()
public void set_itemskins(bool value)
public bool get_itemskincache()
public void set_itemskincache(bool value)
public float get_itemskintimeout()
public void set_itemskintimeout(float value)
}
public ConVar.Halloween : ConsoleSystem {
public bool enabled
public float murdererpopulation
}
public ConVar.Hierarchy : ConsoleSystem {
private GameObject currentDir
private Transform[] GetCurrent()
public void ls(Arg args)
public void cd(Arg args)
public void del(Arg args)
}
public ConVar.Inventory : ConsoleSystem {
public void lighttoggle(Arg arg)
public void endloot(Arg arg)
public void give(Arg arg)
public void resetbp(Arg arg)
public void unlockall(Arg arg)
public void giveall(Arg arg)
public void giveto(Arg arg)
public void giveid(Arg arg)
public void givearm(Arg arg)
}
public ConVar.Manifest : object {
public object PrintManifest()
public object PrintManifestRaw()
}
public ConVar.Music : ConsoleSystem {
public bool enabled
public int songGapMin
public int songGapMax
public void info(Arg arg)
}
public ConVar.Net : ConsoleSystem {
public bool visdebug
public bool debug
}
public ConVar.PatrolHelicopter : ConsoleSystem {
private string path
public float lifetimeMinutes
public int guns
public float bulletDamageScale
public float bulletAccuracy
public void drop(Arg arg)
public void calltome(Arg arg)
public void call(Arg arg)
public void strafe(Arg arg)
}
public ConVar.Physics : ConsoleSystem {
private float baseGravity
public string droppedmode
public bool sendeffects
public float bouncethreshold
public float sleepthreshold
public int solveriterationcount
public float gravity
public float steps
public float minsteps
public float get_bouncethreshold()
public void set_bouncethreshold(float value)
public float get_sleepthreshold()
public void set_sleepthreshold(float value)
public int get_solveriterationcount()
public void set_solveriterationcount(int value)
public float get_gravity()
public void set_gravity(float value)
internal void ApplyDropped(Rigidbody rigidBody, BaseEntity entity)
public float get_steps()
public void set_steps(float value)
public float get_minsteps()
public void set_minsteps(float value)
}
public ConVar.Pool : ConsoleSystem {
public int mode
public bool debug
public bool collider_batches
private Func`2<KeyValuePair`2<Type, object>, long> <>f__am$cache0
public void print_memory(Arg arg)
public void print_prefabs(Arg arg)
public void print_assets(Arg arg)
public void clear_memory(Arg arg)
public void clear_prefabs(Arg arg)
public void clear_assets(Arg arg)
private long <print_memory>m__0(KeyValuePair`2<Type, object> x)
}
public ConVar.Profile : ConsoleSystem {
public void start(Arg arg)
public void stop(Arg arg)
}
public ConVar.Sentry : ConsoleSystem {
public bool targetall
public float hostileduration
}
public ConVar.Server : ConsoleSystem {
public string ip
public int port
public int queryport
public int maxplayers
public string hostname
public string identity
public string level
public string levelurl
public int seed
public int salt
public int worldsize
public int saveinterval
public bool secure
public int encryption
public int tickrate
public int entityrate
public float schematime
public float cycletime
public bool official
public bool stats
public bool globalchat
public bool stability
public bool radiation
public float itemdespawn
public float corpsedespawn
public bool pve
public string description
public string headerimage
public string url
public string branch
public int queriesPerSecond
public int ipQueriesPerMin
public float meleedamage
public float arrowdamage
public float bulletdamage
public float bleedingdamage
public float meleearmor
public float arrowarmor
public float bulletarmor
public float bleedingarmor
public int updatebatch
public int updatebatchspawn
public float planttick
public float planttickscale
public float metabolismtick
public bool woundingenabled
public bool plantlightdetection
public float respawnresetrange
public int maxunack
public bool netcache
public bool corpses
public bool events
public bool dropitems
public int netcachesize
public int savecachesize
public int combatlogsize
public int combatlogdelay
public int authtimeout
public int playertimeout
public int idlekick
public int idlekickmode
public int idlekickadmins
public bool showHolsteredItems
public int maxrpcspersecond
public int maxcommandspersecond
public int maxtickspersecond
public float maxreceivetime
public int maxpacketspersecond
public string rootFolder
public string backupFolder
public string backupFolder1
public string backupFolder2
public string backupFolder3
public bool compression
public bool netlog
public float TickDelta()
public float TickTime(UInt32 tick)
public void setshowholstereditems(Arg arg)
public float get_maxreceivetime()
public void set_maxreceivetime(float value)
public int get_maxpacketspersecond()
public void set_maxpacketspersecond(int value)
public void start(Arg arg)
public void stop(Arg arg)
public string get_rootFolder()
public string get_backupFolder()
public string get_backupFolder1()
public string get_backupFolder2()
public string get_backupFolder3()
public void backup()
public string GetServerFolder(string folder)
public void writecfg(Arg arg)
public void fps(Arg arg)
public void save(Arg arg)
public string readcfg(Arg arg)
public bool get_compression()
public void set_compression(bool value)
public bool get_netlog()
public void set_netlog(bool value)
public void cheatreport(Arg arg)
public string combatlog(Arg arg)
public string printpos(Arg arg)
public string printrot(Arg arg)
public string printeyes(Arg arg)
public void snapshot(Arg arg)
public void sendnetworkupdate(Arg arg)
}
public ConVar.Spawn : ConsoleSystem {
public float min_rate
public float max_rate
public float min_density
public float max_density
public float player_base
public float player_scale
public bool respawn_populations
public bool respawn_groups
public bool respawn_individuals
public void fill_populations(Arg args)
public void fill_groups(Arg args)
public void fill_individuals(Arg args)
public void report(Arg args)
public void scalars(Arg args)
}
public ConVar.SSS : ConsoleSystem {
public bool enabled
public int quality
public bool halfres
public float scale
}
public ConVar.Stability : ConsoleSystem {
public int verbose
public int strikes
public float collapse
public float accuracy
public float stabilityqueue
public float surroundingsqueue
public void refresh_stability(Arg args)
}
public ConVar.Supply : ConsoleSystem {
private string path
public void drop(Arg arg)
public void call(Arg arg)
}
public ConVar.Terrain : ConsoleSystem {
public float quality
}
public ConVar.Time : ConsoleSystem {
public bool pausewhileloading
public float fixeddelta
public float maxdelta
public float timescale
public float get_fixeddelta()
public void set_fixeddelta(float value)
public float get_maxdelta()
public void set_maxdelta(float value)
public float get_timescale()
public void set_timescale(float value)
}
public ConVar.vehicle : ConsoleSystem {
public float boat_corpse_seconds
public void swapseats(Arg arg)
}
public ConVar.Vis : ConsoleSystem {
public bool lerp
public bool damage
public bool attack
public bool protection
public bool weakspots
public bool triggers
public bool hitboxes
public bool lineofsight
public bool sense
}
public ConVar.Voice : ConsoleSystem {
public bool loopback
public float ui_scale
public float ui_cut
public int ui_samples
public float ui_lerp
}
public ConVar.Water : ConsoleSystem {
public int quality
public int reflections
}
public ConVar.Weather : ConsoleSystem {
public void clouds(Arg args)
public void fog(Arg args)
public void wind(Arg args)
public void rain(Arg args)
}
public ConVar.Workshop : ConsoleSystem {
public void print_approved_skins(Arg arg)
}
public ConVar.World : ConsoleSystem {
public bool cache
public void monuments(Arg arg)
}
public ConVar.XMas : ConsoleSystem {
private string path
public bool enabled
public float spawnRange
public int spawnAttempts
public int giftsPerPlayer
public void refill(Arg arg)
}
public ConvarComponent : MonoBehaviour {
public bool runOnServer
public bool runOnClient
public List`1<ConvarEvent> List
protected void OnEnable()
protected void OnDisable()
protected void OnValidate()
private bool ShouldRun()
}
public ConvarControlledSpawnPopulation : SpawnPopulation {
public string PopulationConvar
private Command _command
protected Command Command
public float TargetDensity
protected Command get_Command()
public float get_TargetDensity()
}
public ConvarToggleChildren : MonoBehaviour {
public string ConvarName
public string ConvarEnabled
private bool state
private Command Command
protected void Awake()
protected void Update()
private void SetState(bool newState)
}
public ConvarWater : MonoBehaviour {
public WaterSystem water
}
public CoreEnvBrdfLut : object {
private Texture2D runtimeEnvBrdfLut
private void OnRuntimeLoad()
private void PrepareTextureForRuntime()
private void UpdateReflProbe()
public Texture2D Generate(bool asset)
private UInt32 ReverseBits(UInt32 Bits)
}
public CoverageQueries : MonoBehaviour {
public float depthBias
private List`1<Query> pool
private List`1<Query> added
private List`1<Query> reused
private List`1<int> removed
private List`1<int> changed
private Queue`1<int> freed
private BufferSet buffer
private Camera camera
private Material coverageMat
private CoverageQueries instance
private bool _debugShow
public bool debug
public CoverageQueries Instance
public bool Supported
public bool DebugShow
public CoverageQueries get_Instance()
public bool get_Supported()
public bool get_DebugShow()
public void set_DebugShow(bool value)
private void Awake()
private void OnEnable()
private void OnDisable()
private void Update()
private void OnPostRender()
private void UpdateCollection()
private void PrepareAndDispatch()
private void IssueRead()
private void FetchAndAnalyseResults()
public void RegisterQuery(Query query)
public void UnregisterQuery(Query query)
public void UpdateQuery(Query query)
}
public CoverageQueryFlare : SimpleFlare {
private Query query
public RadiusSpace coverageRadiusSpace
public float coverageRadius
}
public CraftingNotice : MonoBehaviour {
public RectTransform rotatingIcon
public CanvasGroup canvasGroup
public Text itemName
public Text craftSeconds
}
public CraftingQueue : SingletonComponent`1<CraftingQueue> {
public GameObject queueContainer
public GameObject queueItemPrefab
}
public CraftingQueueIcon : MonoBehaviour {
public CanvasGroup canvasGroup
public Image icon
public GameObject timeLeft
public GameObject craftingCount
}
public Craptography : object {
private Byte[] hash
public void XOR(UInt32 seed, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
}
public CreateEffect : MonoBehaviour {
public GameObjectRef EffectToCreate
public void OnEnable()
}
public CrossbowWeapon : BaseProjectile {
public bool ForceSendMagazine()
}
public Crosshair : MonoBehaviour {
public bool Enabled
}
public cui : object {
public void test(Arg args)
public void endtest(Arg args)
}
public CullingVolume : MonoBehaviour {
public bool Portal
public List`1<CullingVolume> Connections
}
public CursorManager : SingletonComponent`1<CursorManager> {
private int iHoldOpen
private int iPreviousOpen
private void Update()
private void SwitchToGame()
private void SwitchToUI()
public void HoldOpen(bool cursorVisible)
}
public DamageProperties : ScriptableObject {
public DamageProperties fallback
public HitAreaProperty[] bones
public float GetMultiplier(HitArea area)
public void ScaleDamage(HitInfo info)
}
public DamageUtil : object {
public void RadiusDamage(BaseEntity attackingPlayer, BaseEntity weaponPrefab, Vector3 pos, float minradius, float radius, List`1<DamageTypeEntry> damage, int layers, bool useLineOfSight)
}
public DecalComponent : PrefabAttribute {
protected Type GetIndexedType()
}
public DecalCull : LODComponent {
public float Distance
}
public DecalRecycle : BasePrefab {
public float LifeTime
}
public DecalRotate : DecalComponent {
public MinMax range
}
public DecalScale : DecalComponent {
public MinMax range
}
public Decay : PrefabAttribute {
private float hours
private Action`1<DecayEntity> <>f__am$cache0
protected float GetDecayDelay(Enum grade)
protected float GetDecayDuration(Enum grade)
public void BuildingDecayTouch(BuildingBlock buildingBlock)
public void EntityLinkDecayTouch(BaseEntity ent)
public void RadialDecayTouch(Vector3 pos, float radius, int mask)
public bool ShouldDecay(BaseEntity entity)
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
protected Type GetIndexedType()
private void <EntityLinkDecayTouch>m__0(DecayEntity decayEnt)
}
public DecayEntity : BaseCombatEntity {
public UInt32 buildingID
public float decayTimer
public float upkeepTimer
private Upkeep upkeep
public Decay decay
public DecayPoint[] decayPoints
private float lastDecayTick
public float decayVariance
public void ResetState()
public void AttachToBuilding(UInt32 id)
public Building GetBuilding()
public BuildingPrivlidge GetBuildingPrivilege()
public void CalculateUpkeepCostAmounts(List`1<ItemAmount> itemAmounts, float multiplier)
public void ServerInit()
internal void DoServerDestroy()
public void AttachToBuilding(DecayEntity other)
public BuildingBlock GetNearbyBuildingBlock()
public void ResetUpkeepTime()
public void DecayTouch()
public void AddUpkeepTime(float time)
public float GetProtectedSeconds()
public void DecayTick()
public void OnRepairFinished()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public DecayPoint : PrefabAttribute {
public float protection
public Socket_Base socket
public bool IsOccupied(BaseEntity entity)
protected Type GetIndexedType()
}
public DecorAlign : DecorComponent {
public float NormalAlignment
public float GradientAlignment
public Vector3 SlopeOffset
public Vector3 SlopeScale
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorComponent : PrefabAttribute {
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
protected Type GetIndexedType()
}
public DecorComponentEx : object {
public void ApplyDecorComponents(Transform transform, DecorComponent[] components, Vector3& pos, Quaternion& rot, Vector3& scale)
public void ApplyDecorComponents(Transform transform, DecorComponent[] components)
public void ApplyDecorComponentsScaleOnly(Transform transform, DecorComponent[] components)
}
public DecorDeployable : DecayEntity {
public bool SupportsPooling()
}
public DecorFlip : DecorComponent {
public AxisType FlipAxis
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorOffset : DecorComponent {
public Vector3 MinOffset
public Vector3 MaxOffset
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorRotate : DecorComponent {
public Vector3 MinRotation
public Vector3 MaxRotation
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorScale : DecorComponent {
public Vector3 MinScale
public Vector3 MaxScale
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorSpawn : MonoBehaviour {
public SpawnFilter Filter
public string ResourceFolder
public UInt32 Seed
public float ObjectCutoff
public float ObjectTapering
public int ObjectsPerPatch
public float ClusterRadius
public int ClusterSizeMin
public int ClusterSizeMax
public int PatchCount
public int PatchSize
public bool LOD
}
public DecorSwim : DecorComponent {
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorTransform : DecorComponent {
public Vector3 Position
public Vector3 Rotation
public Vector3 Scale
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DeferredAction : object {
private Object sender
private Action action
private ActionPriority priority
private bool <Idle>k__BackingField
public bool Idle
public int Index
public void .ctor(Object sender, Action action, ActionPriority priority)
public bool get_Idle()
private void set_Idle(bool value)
public int get_Index()
public void Action()
public void Invoke()
public bool op_Implicit(DeferredAction obj)
public void Invoke(Object sender, Action action, ActionPriority priority)
}
public DeferredDecal : MonoBehaviour {
public bool StickyGizmos
public Mesh mesh
public Material material
public DeferredDecalQueue queue
}
public DeferredDecalQueue : Enum {
public int value__
public DeferredDecalQueue Background
public DeferredDecalQueue Foreground
}
public DeferredExtension : MonoBehaviour {
public ExtendGBufferParams extendGBuffer
public SubsurfaceScatteringParams subsurfaceScattering
public Texture2D blueNoise
public float depthScale
public bool debug
}
public DeferredExtensionMesh : MonoBehaviour {
public SubsurfaceProfile subsurfaceProfile
}
public Deployable : PrefabAttribute {
public Mesh guideMesh
public Vector3 guideMeshScale
public bool guideLights
public bool wantsInstanceData
public bool copyInventoryFromItem
public bool setSocketParent
public bool toSlot
public Slot slot
public GameObjectRef placeEffect
protected Type GetIndexedType()
}
public DeployableDecay : Decay {
public float decayDelay
public float decayDuration
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public bool ShouldDecay(BaseEntity entity)
}
public DeployableToSlot : MonoBehaviour {
public Slot slot
}
public Deployer : HeldEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ItemModDeployable GetModDeployable()
public Deployable GetDeployable()
public Quaternion GetDeployedRotation(Vector3 normal, Vector3 placeDir)
public bool IsPlacementAngleAcceptable(Vector3 pos, Quaternion rot)
public bool CheckPlacement(Deployable deployable, Ray ray, float fDistance)
private void DoDeploy(RPCMessage msg)
public void DoDeploy_Slot(Deployable deployable, Ray ray, UInt32 entityID)
public void DoDeploy_Regular(Deployable deployable, Ray ray)
}
public DeployGuide : BaseMonoBehaviour {
public DeployGuide current
}
public DeployVolume : PrefabAttribute {
public LayerMask layers
public Flags ignore
protected Type GetIndexedType()
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB test, int mask)
public bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, int mask)
public bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, OBB test, int mask)
public bool CheckSphere(Vector3 pos, float radius, int layerMask, Flags ignore)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, Flags ignore)
public bool CheckOBB(OBB obb, int layerMask, Flags ignore)
public bool CheckBounds(Bounds bounds, int layerMask, Flags ignore)
private bool CheckFlags(List`1<Collider> list, Flags ignore)
}
public DeployVolumeCapsule : DeployVolume {
public Vector3 center
public float radius
public float height
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask)
}
public DeployVolumeEntityBounds : DeployVolume {
private Bounds bounds
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public DeployVolumeEntityBoundsReverse : DeployVolume {
private Bounds bounds
private int layer
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB test, int mask)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public DeployVolumeOBB : DeployVolume {
public Bounds bounds
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB test, int mask)
}
public DeployVolumeSphere : DeployVolume {
public Vector3 center
public float radius
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask)
}
public DestroyOnGroundMissing : MonoBehaviour {
private void OnGroundMissing()
}
public DevBotSpawner : FacepunchBehaviour {
public GameObjectRef bot
public Transform waypointParent
public bool autoSelectLatestSpawnedGameObject
public float spawnRate
public int maxPopulation
private Transform[] waypoints
private List`1<BaseEntity> _spawned
public bool HasFreePopulation()
public void SpawnBot()
public void Start()
}
public DevCamera : MonoBehaviour {
public float movementScale
}
public DevControls : MonoBehaviour {
public GUISkin skin
}
public DevDressPlayer : MonoBehaviour {
public bool DressRandomly
public List`1<ItemAmount> clothesToWear
private Func`2<ItemDefinition, bool> <>f__am$cache0
private Func`2<ItemDefinition, Guid> <>f__am$cache1
private void ServerInitComponent()
private void DoRandomClothes(BasePlayer player)
private bool <DoRandomClothes>m__0(ItemDefinition x)
private Guid <DoRandomClothes>m__1(ItemDefinition x)
}
public DeveloperList : object {
public bool Contains(ulong steamid)
public bool IsDeveloper(BasePlayer ply)
}
public DevEnableDisable : DevControlsTab {
public GameObject[] Objects
public string CookieName
public string TabName
}
public DevEnvironment : DevControlsTab {
public TOD_Sky sky
}
public DevMovePlayer : BaseMonoBehaviour {
public BasePlayer player
public Transform[] Waypoints
public bool moveRandomly
public Vector3 destination
public Vector3 lookPoint
private int waypointIndex
private float randRun
public void Awake()
public void LateSpawn()
public void SetWaypoints(Transform[] wps)
public void Update()
}
public DevTimeAdjust : MonoBehaviour {
private void Start()
private void OnGUI()
}
public DevWeatherAdjust : MonoBehaviour {
protected void Awake()
protected void OnGUI()
}
public DiagnosticsConSys : ConsoleSystem {
private Func`2<IGrouping`2<string, Animator>, int> <>f__mg$cache0
private Func`2<IGrouping`2<string, Animator>, int> <>f__mg$cache1
private Func`2<Animator, string> <>f__am$cache0
private Func`2<Animator, string> <>f__am$cache1
private Func`2<IGrouping`2<UInt32, BaseNetworkable>, int> <>f__mg$cache2
private Func`2<IGrouping`2<UInt32, BaseEntity>, int> <>f__mg$cache3
private Func`2<BaseNetworkable, UInt32> <>f__am$cache2
private Func`2<BaseEntity, UInt32> <>f__am$cache3
private Func`2<IGrouping`2<string, LODGroup>, int> <>f__mg$cache4
private Func`2<LODGroup, string> <>f__am$cache4
private Func`2<IGrouping`2<Type, Object>, int> <>f__mg$cache5
private Func`2<IGrouping`2<Type, Object>, int> <>f__mg$cache6
private Func`2<Object, Type> <>f__am$cache5
private Func`2<Object, bool> <>f__am$cache6
private Func`2<Object, Type> <>f__am$cache7
private Func`2<Collider, bool> <>f__am$cache8
private Func`2<IGrouping`2<string, Collider>, int> <>f__mg$cache7
private Func`2<Collider, string> <>f__am$cache9
private Func`2<Collider, bool> <>f__am$cacheA
private Func`2<Collider, bool> <>f__am$cacheB
private Func`2<IGrouping`2<string, Rigidbody>, int> <>f__mg$cache8
private Func`2<Rigidbody, string> <>f__am$cacheC
private Func`2<Rigidbody, bool> <>f__am$cacheD
private Func`2<Rigidbody, bool> <>f__am$cacheE
private Func`2<Rigidbody, bool> <>f__am$cacheF
private Func`2<IGrouping`2<string, Transform>, int> <>f__mg$cache9
private Func`2<Transform, string> <>f__am$cache10
private Func`2<Transform, string> <>f__am$cache11
private Func`2<IGrouping`2<string, Transform>, KeyValuePair`2<Transform, int>> <>f__am$cache12
private Func`2<KeyValuePair`2<Transform, int>, int> <>f__am$cache13
private Func`2<Transform, int> <>f__am$cache14
private void DumpAnimators(string targetFolder)
public void dump(Arg args)
private void DumpSystemInformation(string targetFolder)
private void WriteTextToFile(string file, string text)
private void DumpEntities(string targetFolder)
private void DumpLODGroups(string targetFolder)
private void DumpLODGroupTotals(string targetFolder)
private void DumpNetwork(string targetFolder)
private void DumpObjects(string targetFolder)
private void DumpPhysics(string targetFolder)
private void DumpTotals(string targetFolder)
private void DumpColliders(string targetFolder)
private void DumpRigidBodies(string targetFolder)
private void DumpGameObjects(string targetFolder)
private void DumpGameObjectRecursive(StringBuilder str, Transform tx, int indent, bool includeComponents)
private string <DumpAnimators>m__0(Animator x)
private string <DumpAnimators>m__1(Animator x)
private UInt32 <DumpEntities>m__2(BaseNetworkable x)
private UInt32 <DumpEntities>m__3(BaseEntity x)
private string <DumpLODGroupTotals>m__4(LODGroup x)
private Type <DumpObjects>m__5(Object x)
private bool <DumpObjects>m__6(Object x)
private Type <DumpObjects>m__7(Object x)
private bool <DumpTotals>m__8(Collider x)
private string <DumpColliders>m__9(Collider x)
private bool <DumpColliders>m__A(Collider x)
private bool <DumpColliders>m__B(Collider x)
private string <DumpRigidBodies>m__C(Rigidbody x)
private bool <DumpRigidBodies>m__D(Rigidbody x)
private bool <DumpRigidBodies>m__E(Rigidbody x)
private bool <DumpRigidBodies>m__F(Rigidbody x)
private string <DumpGameObjects>m__10(Transform x)
private string <DumpGameObjects>m__11(Transform x)
private KeyValuePair`2<Transform, int> <DumpGameObjects>m__12(IGrouping`2<string, Transform> x)
private int <DumpGameObjects>m__13(KeyValuePair`2<Transform, int> x)
private int <DumpGameObjects>m__14(Transform y)
}
public DirectionalDamageTrigger : TriggerBase {
public float repeatRate
public List`1<DamageTypeEntry> damageType
public GameObjectRef attackEffect
internal GameObject InterestedInObject(GameObject obj)
internal void OnObjects()
internal void OnEmpty()
private void OnTick()
}
public DirectionProperties : PrefabAttribute {
private float radius
public Bounds bounds
public ProtectionProperties extraProtection
protected Type GetIndexedType()
private void OnDrawGizmosSelected()
public bool IsWeakspot(Transform tx, HitInfo info)
}
public DirectoryEx : object {
public void Backup(DirectoryInfo parent, String[] names)
public bool MoveToSafe(DirectoryInfo parent, string target, int retries)
public void Backup(String[] names)
public void CopyAll(string sourceDirectory, string targetDirectory)
public void CopyAll(DirectoryInfo source, DirectoryInfo target)
}
public DiveSite : JunkPile {
public Transform bobber
public float TimeoutPlayerCheckRadius()
}
public Door : AnimatedBuildingBlock {
public GameObjectRef knockEffect
public bool canTakeLock
public bool hasHatch
public bool canTakeCloser
public bool canNpcOpen
public bool canHandOpen
public bool isSecurityDoor
private float decayResetTimeLast
public NavMeshModifierVolume NavMeshVolumeAnimals
public NavMeshModifierVolume NavMeshVolumeHumanoids
public NavMeshLink NavMeshLink
public NPCDoorTriggerBox NpcTriggerBox
private int nonWalkableArea
private int animalAgentTypeId
private int humanoidAgentTypeId
private float nextKnockTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void ResetState()
public bool HasSlot(Slot slot)
public bool CanPickup(BasePlayer player)
public void CloseRequest()
public void OnFlagsChanged(Flags old, Flags next)
public void SetOpen(bool open)
public void SetLocked(bool locked)
public bool GetPlayerLockPermission(BasePlayer player)
private void RPC_OpenDoor(RPCMessage rpc)
private void RPC_CloseDoor(RPCMessage rpc)
private void RPC_KnockDoor(RPCMessage rpc)
private void RPC_ToggleHatch(RPCMessage rpc)
public bool SupportsPooling()
public float BoundsPadding()
}
public DoorAnimEvents : MonoBehaviour {
public GameObjectRef openStart
public GameObjectRef openEnd
public GameObjectRef closeStart
public GameObjectRef closeEnd
public Animator animator
public Animator get_animator()
private void DoorOpenStart()
private void DoorOpenEnd()
private void DoorCloseStart()
private void DoorCloseEnd()
}
public DoorCloser : BaseEntity {
public ItemDefinition itemType
public float delay
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float BoundsPadding()
public void Think()
public void SendClose()
public void RPC_Take(RPCMessage rpc)
public Door GetDoor()
}
public DoorManipulator : IOEntity {
public EntityRef entityRef
public Door targetDoor
public DoorEffect powerAction
private bool toggle
public void Init()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public DragMe : MonoBehaviour {
public DragMe dragging
public GameObject dragIcon
public object data
public string dragType
public void OnBeginDrag(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
public void OnEndDrag(PointerEventData eventData)
}
public DrawArrow : MonoBehaviour {
public Color color
public float length
public float arrowLength
private void OnDrawGizmos()
}
public DrawSkeleton : MonoBehaviour {
private void OnDrawGizmos()
private void DrawTransform(Transform t)
}
public DropBox : Mailbox {
public bool PlayerIsOwner(BasePlayer player)
public bool PlayerBehind(BasePlayer player)
public bool PlayerInfront(BasePlayer player)
}
public DropMe : MonoBehaviour {
public String[] droppableTypes
public void OnDrop(PointerEventData eventData)
}
public DroppedItem : WorldItem {
public GameObject itemModel
public void ServerInit()
public float GetDespawnDuration()
public void IdleDestroy()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public void OnDroppedOn(DroppedItem di)
internal void OnParentRemoved()
public void PostInitShared()
}
public DroppedItemContainer : BaseCombatEntity {
public string lootPanelName
public ulong playerSteamID
public string _playerName
public ItemContainer inventory
public string playerName
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public string get_playerName()
public void set_playerName(string value)
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void ServerInit()
public void RemoveMe()
public void ResetRemovalTime(float dur)
public void ResetRemovalTime()
public float CalculateRemovalTime()
internal void DoServerDestroy()
public void TakeFrom(ItemContainer[] source)
private void RPC_OpenLoot(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
public void PreServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public DropUtil : object {
public void DropItems(ItemContainer container, Vector3 position, float chance)
}
public DudTimedExplosive : TimedExplosive {
public GameObjectRef fizzleEffect
public GameObject wickSpark
public AudioSource wickSound
public float dudChance
public ItemDefinition itemToGive
private float explodeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool IsWickBurning()
public float GetRandomTimerTime()
public void RPC_Pickup(RPCMessage msg)
public void SetFuse(float fuseLength)
public void Explode()
public bool CanStickTo(BaseEntity entity)
public void BecomeDud()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public DynamicNavMesh : SingletonComponent`1<DynamicNavMesh> {
public int NavMeshAgentTypeIndex
public string DefaultAreaName
public int AsyncTerrainNavMeshBakeCellSize
public int AsyncTerrainNavMeshBakeCellHeight
public Bounds Bounds
public NavMeshData NavMeshData
public NavMeshDataInstance NavMeshDataInstance
public LayerMask LayerMask
public NavMeshCollectGeometry NavMeshCollectGeometry
private List`1<AsyncTerrainNavMeshBake> terrainBakes
private List`1<NavMeshBuildSource> sources
private AsyncOperation BuildingOperation
private bool HasBuildOperationStarted
private Stopwatch BuildTimer
private int defaultArea
private int agentTypeId
public bool IsBuilding
public bool get_IsBuilding()
private void OnEnable()
private void OnDisable()
public void UpdateNavMeshAsync()
private IEnumerator CollectSourcesAsync(Action callback)
public IEnumerator UpdateNavMeshAndWait()
private void AppendModifierVolumes(List`1& sources)
public void FinishBuildingNavmesh()
}
public DynamicZNear : MonoBehaviour {
public float minimum
public float maximum
}
public EACServer : object {
public ICerberus`1<Client> playerTracker
public Scout eacScout
private Dictionary`2<Client, Connection> client2connection
private Dictionary`2<Connection, Client> connection2client
private Dictionary`2<Connection, ClientStatus> connection2status
private EasyAntiCheatServer`1<Client> easyAntiCheat
private ClientStatusHandler<Client> <>f__mg$cache0
public void Encrypt(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
public void Decrypt(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
public Client GetClient(Connection connection)
public Connection GetConnection(Client client)
public bool IsAuthenticated(Connection connection)
private void OnAuthenticatedLocal(Connection connection)
private void OnAuthenticatedRemote(Connection connection)
public bool ShouldIgnore(Connection connection)
private void HandleClientUpdate(ClientStatusUpdate`1<Client> clientStatus)
private void SendToClient(Client client, Byte[] message, int messageLength)
public void DoStartup()
public void DoUpdate()
public void DoShutdown()
public void OnLeaveGame(Connection connection)
public void OnJoinGame(Connection connection)
public void OnStartLoading(Connection connection)
public void OnFinishLoading(Connection connection)
public void OnMessageReceived(Message message)
}
public Effect : EffectData {
public Vector3 Up
public Vector3 worldPos
public Vector3 worldNrm
public bool attached
public Transform transform
public GameObject gameObject
public string pooledString
public bool broadcast
private Effect reusableInstace
public void .ctor(string effectName, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection)
public void .ctor(string effectName, BaseEntity ent, UInt32 boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection)
public void Init(Type fxtype, BaseEntity ent, UInt32 boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection)
public void Init(Type fxtype, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection)
public void Clear()
}
public EffectDictionary : object {
private Dictionary`2<string, String[]> effectDictionary
public string GetParticle(string impactType, string materialName)
public string GetParticle(DamageType damageType, string materialName)
public string GetDecal(string impactType, string materialName)
public string GetDecal(DamageType damageType, string materialName)
public string GetDisplacement(string impactType, string materialName)
private string LookupEffect(string category, string effect, string material)
}
public EffectMount : EntityComponent`1<BaseEntity> {
public GameObject effectPrefab
public GameObject spawnedEffect
public GameObject mountBone
public void SetOn(bool isOn)
}
public EffectNetwork : object {
public void Send(Effect effect)
public void Send(Effect effect, Connection target)
}
public EffectParentToWeaponBone : MonoBehaviour {
public string boneName
}
public EffectRecycle : BaseMonoBehaviour {
public float detachTime
public float recycleTime
public PlayMode playMode
public ParentDestroyBehaviour onParentDestroyed
}
public EffectRecycleDetach : BaseMonoBehaviour {
public float recycleTime
}
public EffectRecycleLite : BasePrefab {
private float lifeTime
}
public ElectricGenerator : IOEntity {
public float electricAmount
public float GetRootFlow()
public bool IsRootEntity()
public void PostServerLoad()
private void ForcePuzzleReset()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ElectricSwitch : IOEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public void SVSwitch(RPCMessage msg)
}
public EmissionToggle : MonoBehaviour {
private Color emissionColor
public Renderer[] targetRenderers
public int materialIndex
private MaterialPropertyBlock block
}
public EngineAudioClip : MonoBehaviour {
public AudioClip granularClip
public AudioClip accelerationClip
public TextAsset accelerationCyclesJson
public List`1<EngineCycle> accelerationCycles
public List`1<EngineCycleBucket> cycleBuckets
public Dictionary`2<int, EngineCycleBucket> accelerationCyclesByRPM
public Dictionary`2<int, int> rpmBucketLookup
public int sampleRate
public int samplesUntilNextGrain
public int lastCycleId
public List`1<Grain> grains
public int currentRPM
public int targetRPM
public int minRPM
public int maxRPM
public int cyclePadding
public float RPMControl
public AudioSource source
private int GetBucketRPM(int RPM)
}
public EngineSwitch : BaseEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void StopEngine(RPCMessage msg)
public void StartEngine(RPCMessage msg)
}
public EntityCollisionMessage : EntityComponent`1<BaseEntity> {
private void OnCollisionEnter(Collision collision)
}
public EntityComponent`1 : EntityComponentBase {
private T _baseEntity
protected T baseEntity
protected T get_baseEntity()
protected void UpdateBaseEntity()
protected BaseEntity GetBaseEntity()
}
public EntityComponentBase : BaseMonoBehaviour {
protected BaseEntity GetBaseEntity()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public EntityDebug : EntityComponent`1<BaseEntity> {
internal Stopwatch stopwatch
private void Update()
}
public EntityFlag_Toggle : EntityComponent`1<BaseEntity> {
public bool runClientside
public bool runServerside
public Flags flag
private UnityEvent onFlagEnabled
private UnityEvent onFlagDisabled
internal bool hasRunOnce
internal bool lastHasFlag
public void DoUpdate(BaseEntity entity)
public void OnPostNetworkUpdate(BaseEntity entity)
public void OnSendNetworkUpdate(BaseEntity entity)
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public EntityItem_RotateWhenOn : EntityComponent`1<BaseEntity> {
public State on
public State off
internal bool currentlyOn
internal bool stateInitialized
public Flags targetFlag
}
public EntityLink : object {
public BaseEntity owner
public Socket_Base socket
public List`1<EntityLink> connections
public int capacity
public string name
public string get_name()
public void Setup(BaseEntity owner, Socket_Base socket)
public void EnterPool()
public void LeavePool()
public bool Contains(EntityLink entity)
public void Add(EntityLink entity)
public void Remove(EntityLink entity)
public void Clear()
public bool IsEmpty()
public bool IsOccupied()
public bool IsMale()
public bool IsFemale()
public bool CanConnect(EntityLink link)
}
public EntityLinkEx : object {
public void FreeLinks(List`1<EntityLink> links)
public void ClearLinks(List`1<EntityLink> links)
public void AddLinks(List`1<EntityLink> links, BaseEntity entity, Socket_Base[] sockets)
}
public EntityRef : ValueType {
internal BaseEntity ent_cached
internal UInt32 id_cached
public UInt32 uid
public bool IsSet()
public bool IsValid(bool serverside)
public void Set(BaseEntity ent)
public BaseEntity Get(bool serverside)
public UInt32 get_uid()
public void set_uid(UInt32 value)
}
public EntityTimedDestroy : EntityComponent`1<BaseEntity> {
public float secondsTillDestroy
private void OnEnable()
private void TimedDestroy()
}
public EnvironmentManager : SingletonComponent`1<EnvironmentManager> {
public EnvironmentType Get(OBB obb)
public EnvironmentType Get(Vector3 pos, List`1& list)
public EnvironmentType Get(Vector3 pos)
public bool Check(OBB obb, EnvironmentType type)
public bool Check(Vector3 pos, EnvironmentType type)
}
public EnvironmentMultiplier : object {
public EnvironmentType Type
public float Multiplier
}
public EnvironmentType : Enum {
public int value__
public EnvironmentType Underground
public EnvironmentType Building
public EnvironmentType Outdoor
public EnvironmentType Elevator
public EnvironmentType PlayerConstruction
public EnvironmentType Atmosphere
}
public EnvironmentVolume : MonoBehaviour {
public bool StickyGizmos
public EnvironmentType Type
public Vector3 Center
public Vector3 Size
private BoxCollider <trigger>k__BackingField
public BoxCollider trigger
public BoxCollider get_trigger()
private void set_trigger(BoxCollider value)
protected void OnDrawGizmos()
protected void OnDrawGizmosSelected()
private void DrawGizmos()
protected void Awake()
public void UpdateTrigger()
}
public EnvironmentVolumeEx : object {
public bool CheckEnvironmentVolumes(Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
public bool CheckEnvironmentVolumes(Transform transform, EnvironmentType type)
}
public EnvironmentVolumeProperties : ScriptableObject {
public int ReflectionQuality
public LayerMask ReflectionCullingFlags
public EnvironmentMultiplier[] ReflectionMultipliers
public EnvironmentMultiplier[] AmbientMultipliers
public float FindReflectionMultiplier(EnvironmentType type)
public float FindAmbientMultiplier(EnvironmentType type)
}
public EnvironmentVolumePropertiesCollection : ScriptableObject {
public float TransitionSpeed
public EnvironmentVolumeProperties[] Properties
public EnvironmentVolumeProperties FindQuality(int quality)
}
public EnvironmentVolumeTrigger : MonoBehaviour {
private EnvironmentVolume <volume>k__BackingField
public Vector3 Center
public Vector3 Size
public EnvironmentVolume volume
public EnvironmentVolume get_volume()
private void set_volume(EnvironmentVolume value)
protected void Awake()
}
public EnvSync : PointEntity {
private float syncInterval
private float syncIntervalInv
public void ServerInit()
private void UpdateNetwork()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ErrorText : MonoBehaviour {
public Text text
public int maxLength
private Stopwatch stopwatch
public void OnEnable()
public void OnDisable()
internal void CaptureLog(string error, string stacktrace, LogType type)
protected void Update()
}
public EventSchedule : BaseMonoBehaviour {
public float minimumHoursBetween
public float maxmumHoursBetween
private float hoursRemaining
private long lastRun
private void OnEnable()
private void OnDisable()
private void RunSchedule()
private void Trigger()
private void CountHours()
}
public Explosion_Bloom : MonoBehaviour {
public Settings settings
private Shader m_Shader
private Material m_Material
private int kMaxIterations
private RenderTexture[] m_blurBuffer1
private RenderTexture[] m_blurBuffer2
private int m_Threshold
private int m_Curve
private int m_PrefilterOffs
private int m_SampleScale
private int m_Intensity
private int m_BaseTex
public Shader shader
public Material material
public bool supportsDX11
public Shader get_shader()
public Material get_material()
public bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
public Material CheckShaderAndCreateMaterial(Shader s)
public bool get_supportsDX11()
private void Awake()
private void OnEnable()
private void OnDisable()
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public ExplosionDemoGUI : MonoBehaviour {
public GameObject[] Prefabs
public float reactivateTime
public Light Sun
private int currentNomber
private GameObject currentInstance
private GUIStyle guiStyleHeader
private float sunIntensity
private float dpiScale
private void Start()
private void OnGUI()
private void ChangeCurrent(int delta)
}
public ExplosionDemoReactivator : MonoBehaviour {
public float TimeDelayToReactivate
private void Start()
private void Reactivate()
}
public ExplosionPlatformActivator : MonoBehaviour {
public GameObject Effect
public float TimeDelay
public float DefaultRepeatTime
public float NearRepeatTime
private float currentTime
private float currentRepeatTime
private bool canUpdate
private void Start()
private void Init()
private void Update()
private void OnTriggerEnter(Collider coll)
private void OnTriggerExit(Collider other)
}
public ExplosionsBillboard : MonoBehaviour {
public Camera Camera
public bool Active
public bool AutoInitCamera
private GameObject myContainer
private Transform t
private Transform camT
private Transform contT
private void Awake()
private void Update()
}
public ExplosionsDeactivateRendererByTime : MonoBehaviour {
public float TimeDelay
private Renderer rend
private void Awake()
private void DeactivateRenderer()
private void OnEnable()
}
public ExplosionsFPS : MonoBehaviour {
private GUIStyle guiStyleHeader
private float timeleft
private float fps
private int frames
private void Awake()
private void OnGUI()
private void Update()
}
public ExplosionsLightCurves : MonoBehaviour {
public AnimationCurve LightCurve
public float GraphTimeMultiplier
public float GraphIntensityMultiplier
private bool canUpdate
private float startTime
private Light lightSource
private void Awake()
private void OnEnable()
private void Update()
}
public ExplosionsParticleSystemScaler : MonoBehaviour {
public float particlesScale
private void Start()
private void Update()
}
public ExplosionsScaleCurves : MonoBehaviour {
public AnimationCurve ScaleCurveX
public AnimationCurve ScaleCurveY
public AnimationCurve ScaleCurveZ
public Vector3 GraphTimeMultiplier
public Vector3 GraphScaleMultiplier
private float startTime
private Transform t
private float evalX
private float evalY
private float evalZ
private void Awake()
private void OnEnable()
private void Update()
}
public ExplosionsShaderColorGradient : MonoBehaviour {
public string ShaderProperty
public int MaterialID
public Gradient Color
public float TimeMultiplier
private bool canUpdate
private Material matInstance
private int propertyID
private float startTime
private Color oldColor
private void Start()
private void OnEnable()
private void Update()
}
public ExplosionsShaderFloatCurves : MonoBehaviour {
public string ShaderProperty
public int MaterialID
public AnimationCurve FloatPropertyCurve
public float GraphTimeMultiplier
public float GraphScaleMultiplier
private bool canUpdate
private Material matInstance
private int propertyID
private float startTime
private void Start()
private void OnEnable()
private void Update()
}
public ExplosionsShaderQueue : MonoBehaviour {
public int AddQueue
private Renderer rend
private void Start()
private void SetProjectorQueue()
private void OnDisable()
}
internal ExplosionsSpriteSheetAnimation : MonoBehaviour {
public int TilesX
public int TilesY
public float AnimationFPS
public bool IsInterpolateFrames
public int StartFrameOffset
public bool IsLoop
public float StartDelay
public AnimationCurve FrameOverTime
private bool isInizialised
private int index
private int count
private int allCount
private float animationLifeTime
private bool isVisible
private bool isCorutineStarted
private Renderer currentRenderer
private Material instanceMaterial
private float currentInterpolatedTime
private float animationStartTime
private bool animationStoped
private void Start()
private void InitDefaultVariables()
private void Play()
private void PlayDelay()
private void OnEnable()
private void OnDisable()
private IEnumerator UpdateCorutine()
private void UpdateFrame()
private void Update()
private void OnDestroy()
}
public ExplosiveInformationPanel : ItemInformationPanel {
public ItemTextValue explosiveDmgDisplay
public ItemTextValue lethalDmgDisplay
public ItemTextValue throwDistanceDisplay
public ItemTextValue projectileDistanceDisplay
public ItemTextValue fuseLengthDisplay
public ItemTextValue blastRadiusDisplay
public Text unreliableText
}
public ExtendGBufferParams : ValueType {
public bool enabled
public ExtendGBufferParams Default
}
public EyeBlink : MonoBehaviour {
public Transform LeftEye
public Vector3 LeftEyeOffset
public Transform RightEye
public Vector3 RightEyeOffset
public Vector2 TimeWithoutBlinking
public float BlinkSpeed
}
public EyeController : MonoBehaviour {
public float MaxLookDot
public bool debug
public Transform LeftEye
public Transform RightEye
public Transform EyeTransform
public Vector3 Fudge
public Vector3 FlickerRange
private Transform Focus
private float FocusUpdateTime
private Vector3 Flicker
private Vector3 FlickerTarget
private float TimeToUpdateFlicker
private float FlickerSpeed
public void UpdateEyes()
private void UpdateEye(Transform eye, Vector3 LookAt)
private void UpdateFlicker()
private void UpdateFocus(Vector3 defaultLookAtPos)
}
public Facepunch.GUI.Controls : object {
public float labelWidth
public float FloatSlider(string strLabel, float value, float low, float high, string format)
public int IntSlider(string strLabel, int value, int low, int high, string format)
public string TextArea(string strName, string value)
public bool Checkbox(string strName, bool value)
public bool Button(string strName)
}
internal Facepunch.GUI.TabbedPanel : object {
private int selectedTabID
private List`1<Tab> tabs
public Tab selectedTab
public Tab get_selectedTab()
public void Add(Tab tab)
internal void DrawVertical(float width)
internal void DrawContents()
}
public Facepunch.Output : object {
private Action`3<string, string, LogType> OnMessage
public bool installed
public List`1<Entry> HistoryOutput
private LogCallback <>f__mg$cache0
public void add_OnMessage(Action`3<string, string, LogType> value)
public void remove_OnMessage(Action`3<string, string, LogType> value)
public void Install()
internal void LogHandler(string log, string stacktrace, LogType type)
}
public Facepunch.RCon : object {
public string Password
public int Port
public string Ip
public bool Web
public bool Print
internal RConListener listener
internal Listener listenerNew
private Queue`1<Command> Commands
private float lastRunTime
internal List`1<BannedAddresses> bannedAddresses
private int responseIdentifier
private string responseConnection
private bool isInput
internal int SERVERDATA_AUTH
internal int SERVERDATA_EXECCOMMAND
internal int SERVERDATA_AUTH_RESPONSE
internal int SERVERDATA_RESPONSE_VALUE
internal int SERVERDATA_CONSOLE_LOG
internal int SERVERDATA_SWITCH_UTF8
private Action`3<string, string, LogType> <>f__mg$cache0
private Action`3<IPEndPoint, string, string> <>f__am$cache0
private Predicate`1<BannedAddresses> <>f__am$cache1
public void Initialize()
public void Shutdown()
public void Broadcast(LogType type, object obj)
public void Update()
public void BanIP(IPAddress addr, float seconds)
public bool IsBanned(IPAddress addr)
private void OnCommand(Command cmd)
private void OnMessage(string message, string stacktrace, LogType type)
private void <Initialize>m__0(IPEndPoint ip, string id, string msg)
private bool <Update>m__1(BannedAddresses x)
}
public Facepunch.Rust.Analytics : object {
internal void Death(string v)
public void Crafting(string targetItemShortname, int taskSkinId)
}
public Facepunch.UI.ESPCanvas : MonoBehaviour {
public int MaxElements
public float RefreshRate
public ESPPlayerInfo Source
public float MaxDistance
}
public Facepunch.UI.ESPPlayerInfo : MonoBehaviour {
public Vector3 WorldOffset
protected Text Text
protected Image Image
public Gradient gradientNormal
public Gradient gradientTeam
public QueryVis visCheck
private BasePlayer <Entity>k__BackingField
public BasePlayer Entity
public BasePlayer get_Entity()
public void set_Entity(BasePlayer value)
}
public Facepunch.Unity.RenderInfo : object {
public void GenerateReport()
}
public Facepunch.Utility.Compression : object {
public Byte[] Compress(Byte[] data)
public Byte[] Uncompress(Byte[] data)
}
public FileEx : object {
public void Backup(DirectoryInfo parent, String[] names)
public bool MoveToSafe(FileInfo parent, string target, int retries)
public void Backup(String[] names)
}
public FileStorage : object {
private Database db
public int MaxSize
private CRC32 crc
private Dictionary`2<UInt32, CacheData> _cache
public FileStorage server
private Func`2<KeyValuePair`2<UInt32, CacheData>, UInt32> <>f__am$cache0
protected void .ctor(string name, bool server)
protected void Finalize()
public void Dispose()
private UInt32 GetCRC(Byte[] data, Type type)
public UInt32 Store(Byte[] data, Type type, UInt32 entityID, UInt32 numID)
public Byte[] Get(UInt32 crc, Type type, UInt32 entityID)
public void Remove(UInt32 crc, Type type, UInt32 entityID)
public void RemoveEntityNum(UInt32 entityid, UInt32 numid)
internal void RemoveAllByEntity(UInt32 entityid)
private UInt32 <RemoveEntityNum>m__0(KeyValuePair`2<UInt32, CacheData> x)
}
public FileSystem : object {
public bool LogDebug
public bool LogTime
public FileSystemBackend Backend
public GameObject[] LoadPrefabs(string folder)
public GameObject LoadPrefab(string filePath)
public String[] FindAll(string folder, string search)
public T[] LoadAll(string folder, string search)
public T Load(string filePath, bool complain)
}
public FileSystem_Warmup : MonoBehaviour {
private bool run
private bool running
private String[] includeFilter
private String[] excludeFilter
private String[] noPreProcessing
private Func`2<string, IEnumerable`1<string>> <>f__am$cache0
private Func`2<string, bool> <>f__am$cache1
public void Run()
public IEnumerator Run(float deltaTime, Action`1<string> statusFunction)
private bool ShouldPreProcess(string path)
private bool ShouldIgnore(string path)
private String[] GetAssetList()
private void PrefabWarmup(string path)
private void Status(Action`1<string> statusFunction, string status, object obj1)
private void Status(Action`1<string> statusFunction, string status, object obj1, object obj2)
private void Status(Action`1<string> statusFunction, string status, object obj1, object obj2, object obj3)
private void Status(Action`1<string> statusFunction, string status, Object[] objs)
private IEnumerable`1<string> <GetAssetList>m__0(string x)
private bool <GetAssetList>m__1(string x)
}
public FireBall : BaseEntity {
public float lifeTimeMin
public float lifeTimeMax
public ParticleSystem[] movementSystems
public ParticleSystem[] restingSystems
public float generation
public GameObjectRef spreadSubEntity
public float tickRate
public float damagePerSecond
public float radius
public int waterToExtinguish
public bool canMerge
public LayerMask AttackLayers
private Vector3 lastPos
private float deathTime
private int wetness
public void ServerInit()
public float GetDeathTime()
public void AddLife(float amountToAdd)
public float MaxLifeTime()
public float TimeLeft()
public void TryToSpread()
public void SetGeneration(int gen)
public void Think()
public void DoRadialDamage()
public bool CanMerge()
public void SetResting(bool isResting)
public void Extinguish()
public bool wantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public bool IsResting()
public void Load(LoadInfo info)
}
public FireBomb : MonoBehaviour {
public GameObject fireParticle
public float bombRadius
public float particleDuration
public float emitDuration
}
public FireSpot : BaseEntity {
public GameObject flameEffect
public void Load(LoadInfo info)
}
public FirstPersonEffect : MonoBehaviour {
public bool isGunShot
}
public FishingBobber : BaseCombatEntity {
public Transform centerOfMass
public Rigidbody myRigidBody
public void ServerInit()
}
internal FixAtlasMipLevelsState : Enum {
public int value__
public FixAtlasMipLevelsState Skipped
public FixAtlasMipLevelsState Initializing
public FixAtlasMipLevelsState Succeeded
public FixAtlasMipLevelsState Failed
}
public FixedRateStepped : object {
public float rate
public int maxSteps
internal float nextCall
public bool ShouldStep()
}
public FixedSByteNorm3 : ValueType {
private int FracBits
private float MaxFrac
private float RcpMaxFrac
public sbyte x
public sbyte y
public sbyte z
public void .ctor(Vector3 vec)
public Vector3 op_Explicit(FixedSByteNorm3 vec)
}
public FixedSByteNorm4 : ValueType {
private int FracBits
private float MaxFrac
private float RcpMaxFrac
public sbyte x
public sbyte y
public sbyte z
public sbyte w
public void .ctor(Vector4 vec)
public Vector4 op_Explicit(FixedSByteNorm4 vec)
}
public FixedShort3 : ValueType {
private int FracBits
private float MaxFrac
private float RcpMaxFrac
public short x
public short y
public short z
public void .ctor(Vector3 vec)
public Vector3 op_Explicit(FixedShort3 vec)
}
public FlameExplosive : TimedExplosive {
public GameObjectRef createOnExplode
public float numToCreate
public float minVelocity
public float maxVelocity
public float spreadAngle
public void Explode()
public void Explode(Vector3 surfaceNormal)
public void ProjectileImpact(RaycastHit info)
}
public FlameJet : MonoBehaviour {
public LineRenderer line
public float tesselation
private float length
public float maxLength
public float drag
private int numSegments
public bool on
private Vector3[] lastWorldSegments
private Vector3[] currentSegments
public Color startColor
public Color endColor
public Color currentColor
private void Initialize()
private void Awake()
public void LateUpdate()
public void SetOn(bool isOn)
private float curve(float x)
private void UpdateLine()
}
public FlameThrower : AttackEntity {
public int maxAmmo
public int ammo
public ItemDefinition fuelType
public float timeSinceLastAttack
public float nextReadyTime
public float flameRange
public float flameRadius
public ParticleSystem[] flameEffects
public FlameJet jet
public GameObjectRef fireballPrefab
public List`1<DamageTypeEntry> damagePerSec
public SoundDefinition flameStart3P
public SoundDefinition flameLoop3P
public SoundDefinition flameStop3P
public SoundDefinition pilotLoopSoundDef
private float tickRate
private float lastFlameTick
public float fuelPerSec
private float ammoRemainder
private float nextFlameTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool IsWeaponBusy()
private void SetBusyFor(float dur)
private void ClearBusy()
public void ReduceAmmo(float firingTime)
public void PilotLightToggle_Shared()
public bool IsPilotOn()
public bool IsFlameOn()
public bool HasAmmo()
public Item GetAmmo()
public void Load(LoadInfo info)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void Save(SaveInfo info)
public void SetFiring(RPCMessage msg)
public void DoReload(RPCMessage msg)
public void SetFlameState(bool wantsOn)
public void TogglePilotLight(RPCMessage msg)
public void OnHeldChanged()
public void FlameTick()
public void ServerCommand(Item item, string command, BasePlayer player)
}
public flamethrowerFire : MonoBehaviour {
public ParticleSystem pilotLightFX
public ParticleSystem[] flameFX
public FlameJet jet
public AudioSource oneShotSound
public AudioSource loopSound
public AudioClip pilotlightIdle
public AudioClip flameLoop
public AudioClip flameStart
public flamethrowerState flameState
private flamethrowerState previousflameState
public void PilotLightOn()
public void SetFlameStatus(bool status)
public void ShutOff()
public void FlameOn()
private void Start()
private void Update()
}
public flamethrowerState : Enum {
public int value__
public flamethrowerState OFF
public flamethrowerState PILOT_LIGHT
public flamethrowerState FLAME_ON
}
public FlameTurret : StorageContainer {
public Transform upper
public Vector3 aimDir
public float arc
public float triggeredDuration
public float flameRange
public float flameRadius
public float fuelPerSec
public Transform eyeTransform
public List`1<DamageTypeEntry> damagePerSec
public GameObjectRef triggeredEffect
public GameObjectRef fireballPrefab
public GameObjectRef explosionEffect
private float nextFireballTime
private int turnDir
private float lastServerThink
private float triggeredTime
private float triggerCheckRate
private float nextTriggerCheckTime
private float pendingFuel
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsTriggered()
public Vector3 GetEyePosition()
public void Update()
public bool CanPickup(BasePlayer player)
public void SetTriggered(bool triggered)
public void ServerInit()
public void SendAimDir()
public float GetSpinSpeed()
public void OnAttacked(HitInfo info)
public void MovementUpdate(float delta)
public void ServerThink()
public bool CheckTrigger()
public void OnKilled(HitInfo info)
public int GetFuelAmount()
public bool HasFuel()
public bool UseFuel(float seconds)
public void DoFlame(float delta)
public bool SupportsPooling()
}
public FlashlightBeam : MonoBehaviour {
public Vector2 scrollDir
public Vector3 localEndPoint
public LineRenderer beamRenderer
}
public FlintStrikeWeapon : BaseProjectile {
public float successFraction
public RecoilProperties strikeRecoil
public RecoilProperties GetRecoil()
}
public FloatConditions : object {
public Condition[] conditions
public bool AllTrue(float val)
}
public FlybySound : MonoBehaviour {
public SoundDefinition flybySound
public float flybySoundDistance
public SoundDefinition closeFlybySound
public float closeFlybyDistance
}
public FogSettings : ValueType {
public Gradient ColorOverDaytime
public float Density
public float StartDistance
public float Height
public float HeightDensity
public FogSettings Default
public FogSettings Lerp(FogSettings source, FogSettings target, float t)
}
public FoliageDisplacement : MonoBehaviour {
public bool moving
public bool billboard
public Mesh mesh
public Material material
}
public FoliageGrid : SingletonComponent`1<FoliageGrid> {
public bool Paused
public float CellSize
public float MaxMilliseconds
public LayerSelect FoliageLayer
public ShadowCastingMode FoliageShadows
public float MaxRefreshDistance
}
public FoliagePlacement : ScriptableObject {
public float Density
public SpawnFilter Filter
public float FilterCutoff
public float FilterFade
public float FilterScaling
public float RandomScaling
public MinMax Range
public float RangeFade
public float DistanceDensity
public float DistanceScaling
public Material material
public Mesh mesh
public int octaves
public float frequency
public float amplitude
public float offset
}
public FoliageRenderer : MonoBehaviour {
public Material material
public Mesh LOD0
public Mesh LOD1
}
public FoliageSpawn : MonoBehaviour {
public FoliagePlacement Placement
}
public FollowCamera : MonoBehaviour {
private void LateUpdate()
}
public FootstepEffects : BaseFootstepEffect {
public Transform leftFoot
public Transform rightFoot
public string footstepEffectName
public string jumpStartEffectName
public string jumpLandEffectName
}
public FootstepSound : MonoBehaviour {
public SoundDefinition lightSound
public SoundDefinition medSound
public SoundDefinition hardSound
private float panAmount
}
public ForceChildSingletonSetup : MonoBehaviour {
private void Awake()
}
public FPSGraph : Graph {
public void Refresh()
protected void OnEnable()
protected float GetValue()
protected Color GetColor(float value)
}
public FPSText : MonoBehaviour {
public Text text
private Stopwatch fpsTimer
protected void Update()
}
public FreeableLootContainer : LootContainer {
private Flags tiedDown
public Buoyancy buoyancy
public GameObjectRef freedEffect
private Rigidbody rb
public UInt32 skinOverride
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Rigidbody GetRB()
public bool IsTiedDown()
public void ServerInit()
public void RPC_FreeCrate(RPCMessage msg)
}
public FruitScale : MonoBehaviour {
public void SetProgress(float progress)
}
public FuseBox : IOEntity {
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
}
public FXAA : FXAAPostEffectsBase {
public Shader shader
private Material mat
private void CreateMaterials()
private void Start()
public bool IsActive()
public void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public FXAAOverlay : ImageEffectLayer {
public FXAA fxaa
}
public FXAAPostEffectsBase : MonoBehaviour {
protected bool supportHDRTextures
protected bool isSupported
public Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
private Material CreateMaterial(Shader s, Material m2Create)
private void OnEnable()
private bool CheckSupport()
private bool CheckResources()
private void Start()
public bool CheckSupport(bool needDepth)
private bool CheckSupport(bool needDepth, bool needHdr)
private void ReportAutoDisable()
private bool CheckShader(Shader s)
private void NotSupported()
private void DrawBorder(RenderTexture dest, Material material)
}
public GameContentList : MonoBehaviour {
public ResourceType resourceType
public List`1<Object> foundObjects
}
public GameManager : object {
public GameManager server
internal PrefabPreProcess preProcessed
internal PrefabPoolCollection pool
private bool Clientside
private bool Serverside
private Func`2<PrefabProperties, bool> <>f__am$cache0
public void .ctor(bool clientside, bool serverside)
public void Reset()
public UInt32 AddPrefab(string strPrefab, GameObject go)
public GameObject FindPrefab(BaseEntity ent)
public GameObject FindPrefab(string strPrefab)
public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, Vector3 scale, bool active)
public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, bool active)
public GameObject CreatePrefab(string strPrefab, bool active)
public GameObject CreatePrefab(string strPrefab, Transform parent, bool active)
public BaseEntity CreateEntity(string strPrefab, Vector3 pos, Quaternion rot, bool startActive)
private GameObject Instantiate(string strPrefab, Vector3 pos, Quaternion rot)
public void Destroy(Component component, float delay)
public void Destroy(GameObject instance, float delay)
public void DestroyImmediate(Component component, bool allowDestroyingAssets)
public void DestroyImmediate(GameObject instance, bool allowDestroyingAssets)
public void Retire(GameObject instance)
public void Warmup()
private void WarmupInternal()
public void Warmup(UInt32 prefabID)
private bool <WarmupInternal>m__0(PrefabProperties x)
}
public GameManifest : ScriptableObject {
public PooledString[] pooledStrings
public MeshColliderInfo[] meshColliders
public PrefabProperties[] prefabProperties
public EffectCategory[] effectCategories
public String[] skinnables
public String[] entities
internal GameManifest loadedManifest
public Dictionary`2<string, string> guidToPath
public Dictionary`2<string, Object> guidToObject
public GameManifest Current
public GameManifest get_Current()
public void Load()
public void LoadAssets()
private Skinnable[] LoadSkinnableAssets()
internal Dictionary`2<string, String[]> LoadEffectDictionary()
internal string GUIDToPath(string guid)
internal Object GUIDToObject(string guid)
private string GetMetadataStatus()
private string GetAssetStatus()
}
public GameObjectRef : ResourceRef`1<GameObject> {
public GameObject Instantiate(Transform parent)
}
public GameObjectUtil : object {
public void GlobalBroadcast(string messageName, object param)
}
public GamePhysics : object {
public int BufferLength
private RaycastHit[] hitBuffer
private Collider[] colBuffer
private Comparison`1<RaycastHit> <>f__am$cache0
private Comparison`1<RaycastHit> <>f__am$cache1
public bool CheckSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckOBB(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckBounds(Bounds bounds, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapSphere(Vector3 position, float radius, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapOBB(OBB obb, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapBounds(Bounds bounds, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void BufferToList(int count, List`1<Collider> list)
public bool CheckSphere(Vector3 pos, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckOBB(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckBounds(Bounds bounds, int layerMask, QueryTriggerInteraction triggerInteraction)
private bool CheckComponent(List`1<Collider> list)
public void OverlapSphere(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapOBB(OBB obb, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapBounds(Bounds bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void BufferToList(int count, List`1<T> list)
public bool Trace(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction)
public void TraceAll(Ray ray, float radius, List`1<RaycastHit> hits, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction)
public void TraceAllUnordered(Ray ray, float radius, List`1<RaycastHit> hits, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding)
public bool LineOfSight(Vector3 p0, Vector3 p1, Vector3 p2, int layerMask, float padding)
public bool LineOfSight(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, int layerMask, float padding)
public bool LineOfSight(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, int layerMask, float padding)
public bool Verify(RaycastHit hitInfo)
public bool Verify(Collider collider, Vector3 point)
public int HandleTerrainCollision(Vector3 position, int layerMask)
public void Sort(List`1<RaycastHit> hits)
public void Sort(RaycastHit[] hits)
private int <Sort>m__0(RaycastHit a, RaycastHit b)
private int <Sort>m__1(RaycastHit a, RaycastHit b)
}
public GameSetup : MonoBehaviour {
public bool RunOnce
public bool startServer
public string clientConnectCommand
public bool loadMenu
public bool loadLevel
public string loadLevelScene
public bool loadSave
public string loadSaveFile
protected void Awake()
private IEnumerator DoGameSetup()
private IEnumerator StartServer()
}
public GameStat : MonoBehaviour {
public float refreshTime
public Text title
public Text globalStat
public Text localStat
private long globalValue
private long localValue
private long oldGlobalValue
private long oldLocalValue
private float secondsSinceRefresh
private float secondsUntilUpdate
private float secondsUntilChange
public Stat[] stats
}
public GameTip : SingletonComponent`1<GameTip> {
public CanvasGroup canvasGroup
public Text text
}
public GameTips.BaseTip : object {
public bool ShouldShow
public string Type
public Phrase GetPhrase()
public bool get_ShouldShow()
public string get_Type()
}
public GeigerCounter : AttackEntity {
public Transform geigerRod
}
public GenerateBiome : ProceduralComponent {
public void Native_GenerateBiome(Byte[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle, Int16[] heightmap, int heightres)
public void Process(UInt32 seed)
}
public GenerateCliffSplat : ProceduralComponent {
private int filter
public void Process(int x, int z)
public void Process(UInt32 seed)
}
public GenerateCliffTopology : ProceduralComponent {
public bool KeepExisting
private int filter
private int filter_del
public void Process(int x, int z)
private void Process(int x, int z, bool keepExisting)
public void Process(UInt32 seed)
}
public GenerateClutterTopology : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateDecorTopology : ProceduralComponent {
public bool KeepExisting
public void Process(UInt32 seed)
}
public GenerateHeight : ProceduralComponent {
public void Native_GenerateHeight(Int16[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle)
public void Process(UInt32 seed)
}
public GeneratePowerlineLayout : ProceduralComponent {
public float Width
private int MaxDepth
private Func`2<PathNode, Point> <>f__am$cache0
private Func`2<PathNode, Point> <>f__am$cache1
public void Process(UInt32 seed)
private Point <Process>m__0(PathNode x)
private Point <Process>m__1(PathNode x)
}
public GeneratePowerlineTopology : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateRiverLayout : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private Comparison`1<PathList> <>f__am$cache0
public void Process(UInt32 seed)
private int <Process>m__0(PathList a, PathList b)
}
public GenerateRiverMeshes : ProceduralComponent {
public Material RiverMaterial
public PhysicMaterial RiverPhysicMaterial
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateRiverTopology : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateRoadLayout : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private int MaxDepth
private Func`2<PathNode, Point> <>f__am$cache0
private Func`2<PathNode, Point> <>f__am$cache1
public void Process(UInt32 seed)
private Point <Process>m__0(PathNode x)
private Point <Process>m__1(PathNode x)
}
public GenerateRoadMeshes : ProceduralComponent {
public Material RoadMaterial
public PhysicMaterial RoadPhysicMaterial
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateRoadTopology : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateSplat : ProceduralComponent {
public void Native_GenerateSplat(Byte[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle, Int16[] heightmap, int heightres, Byte[] biomemap, int biomeres, Int32[] topologymap, int topologyres)
public void Process(UInt32 seed)
}
public GenerateTerrainMesh : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateTextures : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateTopology : ProceduralComponent {
public void Native_GenerateTopology(Int32[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle, Int16[] heightmap, int heightres, Byte[] biomemap, int biomeres)
public void Process(UInt32 seed)
}
public GenerateWireMeshes : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenericSpawnPoint : BaseSpawnPoint {
public bool dropToGround
public bool randomRot
public GameObjectRef spawnEffect
public UnityEvent OnObjectSpawnedEvent
public UnityEvent OnObjectRetiredEvent
public void GetLocation(Vector3& pos, Quaternion& rot)
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
}
public GenericsUtil : object {
public TDst Cast(TSrc obj)
public void Swap(T& a, T& b)
}
public Gib : MonoBehaviour {
public int gibCount
public string GetEffect(PhysicMaterial physicMaterial)
}
public Gibbable : MonoBehaviour {
public GameObject gibSource
public GameObject materialSource
public bool copyMaterialBlock
public PhysicMaterial physicsMaterial
public GameObjectRef fxPrefab
public bool spawnFxPrefab
public bool important
public float explodeScale
}
public GizmosUtil : object {
public void DrawWireCircleX(Vector3 pos, float radius)
public void DrawWireCircleY(Vector3 pos, float radius)
public void DrawWireCircleZ(Vector3 pos, float radius)
public void DrawCircleX(Vector3 pos, float radius)
public void DrawCircleY(Vector3 pos, float radius)
public void DrawCircleZ(Vector3 pos, float radius)
public void DrawWireCylinderX(Vector3 pos, float radius, float height)
public void DrawWireCylinderY(Vector3 pos, float radius, float height)
public void DrawWireCylinderZ(Vector3 pos, float radius, float height)
public void DrawCylinderX(Vector3 pos, float radius, float height)
public void DrawCylinderY(Vector3 pos, float radius, float height)
public void DrawCylinderZ(Vector3 pos, float radius, float height)
public void DrawWireCapsuleX(Vector3 pos, float radius, float height)
public void DrawWireCapsuleY(Vector3 pos, float radius, float height)
public void DrawWireCapsuleZ(Vector3 pos, float radius, float height)
public void DrawCapsuleX(Vector3 pos, float radius, float height)
public void DrawCapsuleY(Vector3 pos, float radius, float height)
public void DrawCapsuleZ(Vector3 pos, float radius, float height)
public void DrawWireCube(Vector3 pos, Vector3 size, Quaternion rot)
public void DrawCube(Vector3 pos, Vector3 size, Quaternion rot)
public void DrawWirePath(Vector3 a, Vector3 b, float thickness)
public void DrawSemiCircle(float radius)
public void DrawMeshes(Transform transform)
public void DrawBounds(Transform transform)
}
public GranularAudioClip : MonoBehaviour {
public AudioClip sourceClip
private Single[] sourceAudioData
private int sourceChannels
public AudioClip granularClip
public int sampleRate
public float sourceTime
public float sourceTimeVariation
public float grainAttack
public float grainSustain
public float grainRelease
public float grainFrequency
public int grainAttackSamples
public int grainSustainSamples
public int grainReleaseSamples
public int grainFrequencySamples
public int samplesUntilNextGrain
public List`1<Grain> grains
private Random random
private bool inited
private void Update()
private void RefreshCachedData()
private void InitAudioClip()
private void OnAudioRead(Single[] data)
private void SpawnGrain()
private void CleanupFinishedGrains()
}
public Graph : MonoBehaviour {
public Material Material
public int Resolution
public Vector2 ScreenFill
public Vector2 ScreenOrigin
public Vector2 Pivot
public Rect Area
internal float CurrentValue
private int index
private Single[] values
private float max
protected float GetValue()
protected Color GetColor(float value)
protected Vector3 GetVertex(float x, float y)
protected void Update()
protected void OnGUI()
}
public GridLayoutGroupNeat : GridLayoutGroup {
private float IdealCellWidth(float cellSize)
public void SetLayoutHorizontal()
public void SetLayoutVertical()
}
public GroundWatch : MonoBehaviour {
public Vector3 groundPosition
public LayerMask layers
public float radius
private void OnDrawGizmosSelected()
public void PhysicsChanged(GameObject obj)
private void OnPhysicsNeighbourChanged()
private bool OnGround()
}
public GunModInformationPanel : ItemInformationPanel {
public ItemTextValue fireRateDisplay
public ItemTextValue velocityDisplay
public ItemTextValue damageDisplay
public ItemTextValue accuracyDisplay
public ItemTextValue recoilDisplay
public ItemTextValue zoomDisplay
}
public GunTrap : StorageContainer {
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public GameObjectRef triggeredEffect
public Transform muzzlePos
public Transform eyeTransform
public int numPellets
public int aimCone
public float sensorRadius
public ItemDefinition ammoType
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool UseAmmo()
public void FireWeapon()
public void FireBullet()
public void ServerInit()
public void TriggerCheck()
public bool CheckTrigger(float offset, float radius)
public bool IsTriggered()
public Vector3 GetEyePosition()
}
public HackableLockedCrate : LootContainer {
public Flags Flag_Hacking
public Flags Flag_FullyHacked
public Text timerText
public float requiredHackSeconds
public float decaySeconds
public SoundPlayer hackProgressBeep
public float hackSeconds
public GameObjectRef shockEffect
public GameObjectRef mapMarkerEntityPrefab
public GameObjectRef landEffect
private BaseEntity mapMarkerInstance
public bool hasLanded
public bool wasDropped
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsBeingHacked()
public bool IsFullyHacked()
public void DestroyShared()
public void CreateMapMarker(float durationMinutes)
public void RefreshDecay()
public void DelayedDestroy()
public void OnAttacked(HitInfo info)
public void SetWasDropped()
public void ServerInit()
public void LandCheck()
public void PostServerLoad()
public void RPC_Hack(RPCMessage msg)
public void StartHacking()
public void HackProgress()
}
public HairCapMask : Enum {
public int value__
public HairCapMask Head
public HairCapMask Eyebrow
public HairCapMask Facial
public HairCapMask Armpit
public HairCapMask Pubic
}
public HairDye : object {
public Color capBaseColor
public Material sourceMaterial
public CopyPropertyMask copyProperties
private MaterialPropertyDesc[] transferableProps
private int _HairBaseColorUV1
private int _HairBaseColorUV2
private int _HairPackedMapUV1
private int _HairPackedMapUV2
public void Apply(HairDyeCollection collection, MaterialPropertyBlock block)
public void ApplyCap(HairDyeCollection collection, HairType type, MaterialPropertyBlock block)
}
public HairDyeCollection : ScriptableObject {
public Texture capMask
public bool applyCap
public HairDye[] Variations
public HairDye Get(float seed)
}
public HairSet : ScriptableObject {
public MeshReplace[] MeshReplacements
public MaterialReplace[] MaterialReplacements
public void Process(PlayerModelHair playerModelHair, HairDyeCollection dyeCollection, HairDye dye, MaterialPropertyBlock block)
public void ProcessMorphs(GameObject obj, int blendShapeIndex)
}
public HairSetCollection : ScriptableObject {
public HairSetEntry[] Head
public HairSetEntry[] Eyebrow
public HairSetEntry[] Facial
public HairSetEntry[] Armpit
public HairSetEntry[] Pubic
public HairSetEntry[] GetListByType(HairType hairType)
public int GetIndex(HairSetEntry[] list, float typeNum)
public int GetIndex(HairType hairType, float typeNum)
public HairSetEntry Get(HairType hairType, float typeNum)
}
public HairType : Enum {
public int value__
public HairType Head
public HairType Eyebrow
public HairType Facial
public HairType Armpit
public HairType Pubic
public HairType Count
}
public Half3 : ValueType {
public ushort x
public ushort y
public ushort z
public void .ctor(Vector3 vec)
public Vector3 op_Explicit(Half3 vec)
}
public Half4 : ValueType {
public ushort x
public ushort y
public ushort z
public ushort w
public void .ctor(Vector4 vec)
public Vector4 op_Explicit(Half4 vec)
}
public Hammer : BaseMelee {
public bool CanHit(HitTest info)
public void DoAttackShared(HitInfo info)
}
public HeldEntity : BaseEntity {
public Animator worldModelAnimator
public SoundDefinition thirdPersonDeploySound
public SoundDefinition thirdPersonAimSound
public SoundDefinition thirdPersonAimEndSound
public string handBone
public AnimatorOverrideController HoldAnimationOverride
public ToolTypeEnum toolType
public float hostileScore
public HolsterInfo holsterInfo
private bool holsterVisible
private heldEntityVisState currentVisState
internal UInt32 ownerItemUID
public bool hostile
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_hostile()
public bool LightsOn()
public bool IsDeployed()
public BasePlayer GetOwnerPlayer()
public Connection GetOwnerConnection()
public void SetOwnerPlayer(BasePlayer player)
public void ClearOwnerPlayer()
public void SetVisibleWhileHolstered(bool visible)
public UInt32 GetBone(string bone)
public void SetLightsOn(bool isOn)
public void UpdateHeldItemVisibility()
public bool UpdateVisibility_Hand()
public bool UpdateVisiblity_Holster()
public bool UpdateVisiblity_Invis()
public void SetHeld(bool bHeld)
public void OnHeldChanged()
public bool CanBeUsedInWater()
protected Item GetOwnerItem()
public Item GetItem()
public ItemDefinition GetOwnerItemDefinition()
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
public void ServerCommand(Item item, string command, BasePlayer player)
public void SetupHeldEntity(Item item)
public void PostServerLoad()
private void InitOwnerPlayer()
public void Save(SaveInfo info)
public void DestroyThis()
protected bool HasItemAmount()
protected bool UseItemAmount(int iAmount)
public void Load(LoadInfo info)
public void SendPunch(Vector3 amount, float duration)
}
public HelicopterDebris : ServerGib {
public ItemDefinition metalFragments
public ItemDefinition hqMetal
public ItemDefinition charcoal
private ResourceDispenser resourceDispenser
private float tooHotUntil
public void ServerInit()
public void PhysicsInit(Mesh mesh)
public bool IsTooHot()
public void OnAttacked(HitInfo info)
}
public HelicopterTurret : MonoBehaviour {
public PatrolHelicopterAI _heliAI
public float fireRate
public float burstLength
public float timeBetweenBursts
public float maxTargetRange
public float loseTargetAfter
public Transform gun_yaw
public Transform gun_pitch
public Transform muzzleTransform
public bool left
public BaseCombatEntity _target
private float lastBurstTime
private float lastFireTime
private float lastSeenTargetTime
private bool targetVisible
public void SetTarget(BaseCombatEntity newTarget)
public bool NeedsNewTarget()
public bool UpdateTargetFromList(List`1<targetinfo> newTargetList)
public bool TargetVisible()
public float TimeSinceTargetLastSeen()
public bool HasTarget()
public void ClearTarget()
public void TurretThink()
public void FireGun()
public Vector3 GetPositionForEntity(BaseCombatEntity potentialtarget)
public float AngleToTarget(BaseCombatEntity potentialtarget)
public bool InFiringArc(BaseCombatEntity potentialtarget)
public void UpdateTargetVisibility()
}
public HideIfAiming : MonoBehaviour {
public ParticleSystem[] systems
}
public HideIfOwnerFirstPerson : EntityComponent`1<BaseEntity> {
public GameObject[] disableGameObjects
public bool worldModelEffect
}
public HideIfScoped : MonoBehaviour {
public Renderer[] renderers
public void SetVisible(bool vis)
}
public HideUntilMobile : EntityComponent`1<BaseEntity> {
public GameObject[] visuals
private Vector3 startPos
}
public HierarchyUtil : object {
public Dictionary`2<string, GameObject> rootDict
public GameObject GetRoot(string strName, bool groupActive, bool persistant)
}
public HitArea : Enum {
public int value__
public HitArea Head
public HitArea Chest
public HitArea Stomach
public HitArea Arm
public HitArea Hand
public HitArea Leg
public HitArea Foot
}
public HitAreaConst : object {
public HitArea Nothing
public HitArea Everything
}
public HitAreaUtil : object {
public string Format(HitArea area)
}
public HitInfo : object {
public BaseEntity Initiator
public BaseEntity WeaponPrefab
public AttackEntity Weapon
public bool DoHitEffects
public bool DoDecals
public bool IsPredicting
public bool UseProtection
public Connection Predicted
public bool DidHit
public BaseEntity HitEntity
public UInt32 HitBone
public UInt32 HitPart
public UInt32 HitMaterial
public Vector3 HitPositionWorld
public Vector3 HitPositionLocal
public Vector3 HitNormalWorld
public Vector3 HitNormalLocal
public Vector3 PointStart
public Vector3 PointEnd
public int ProjectileID
public float ProjectileDistance
public Vector3 ProjectileVelocity
public Projectile ProjectilePrefab
public PhysicMaterial material
public DamageProperties damageProperties
public DamageTypeList damageTypes
public bool CanGather
public bool DidGather
public float gatherScale
public BasePlayer InitiatorPlayer
public Vector3 attackNormal
public bool hasDamage
public bool isHeadshot
public Phrase bonePhrase
public string boneName
public HitArea boneArea
public void .ctor(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount, Vector3 vhitPosition)
public void .ctor(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount)
public bool IsProjectile()
public BasePlayer get_InitiatorPlayer()
public Vector3 get_attackNormal()
public bool get_hasDamage()
public void LoadFromAttack(Attack attack, bool serverSide)
public bool get_isHeadshot()
public Phrase get_bonePhrase()
public string get_boneName()
public HitArea get_boneArea()
public Vector3 PositionOnRay(Vector3 position)
public Vector3 HitPositionOnRay()
public bool IsNaNOrInfinity()
}
public HitNumber : MonoBehaviour {
public HitType hitType
public int ColorToMultiplier(HitType type)
public void OnDrawGizmos()
}
public HitTest : object {
public Type type
public Ray AttackRay
public float Radius
public float Forgiveness
public float MaxDistance
public RaycastHit RayHit
public bool MultiHit
public bool BestHit
public bool DidHit
public DamageProperties damageProperties
public GameObject gameObject
public Collider collider
public BaseEntity ignoreEntity
public BaseEntity HitEntity
public Vector3 HitPoint
public Vector3 HitNormal
public float HitDistance
public Transform HitTransform
public UInt32 HitPart
public string HitMaterial
public Vector3 HitPointWorld()
public Vector3 HitNormalWorld()
public void Clear()
}
public HolosightReticlePositioning : MonoBehaviour {
public IronsightAimPoint aimPoint
public RectTransform rectTransform
public RectTransform get_rectTransform()
private void Update()
private void UpdatePosition(Camera cam)
}
public Horse : BaseAnimalNPC {
public float Population
public TraitFlag Traits
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public HostileNote : MonoBehaviour {
public CanvasGroup warnGroup
public CanvasGroup group
public CanvasGroup timerGroup
public Text timerText
public float unhostileTime
public float weaponDrawnDuration
public Color warnColor
public Color hostileColor
}
public HotOverlay : ImageEffectLayer {
public LensDirtiness lensDirtyness
public VignetteAndChromaticAberration vingette
}
public HudElement : MonoBehaviour {
public Text[] ValueText
public Image[] FilledImage
private float LastValue
public void SetValue(float value, float max)
private void SetText(string v)
private void SetImage(float f)
}
public HumanBodyResourceDispenser : ResourceDispenser {
public bool OverrideOwnership(Item item, AttackEntity weapon)
}
public HurtOverlay : ImageEffectLayer {
public ScreenOverlayEx bloodOverlay
public VignetteAndChromaticAberration vignetting
public CC_Grayscale grayScale
}
public IAIAgent {
public AiStatistics GetStats
public NavMeshAgent GetNavAgent
public Vector2i CurrentCoord
public Vector2i PreviousCoord
public bool AgencyUpdateRequired
public bool IsOnOffmeshLinkAndReachedNewCoord
public Vector3 Destination
public bool IsStopped
public bool AutoBraking
public bool HasPath
public bool IsDormant
public float TimeAtDestination
public bool IsStuck
public float TargetSpeed
public BaseEntity FoodTarget
public float GetAttackRate
public float GetAttackRange
public Vector3 GetAttackOffset
public BaseEntity AttackTarget
public float AttackTargetVisibleFor
public SeenInfo AttackTargetMemory
public BaseCombatEntity CombatTarget
public Vector3 AttackPosition
public Vector3 CrouchedAttackPosition
public Vector3 CurrentAimAngles
public Vector3 SpawnPosition
public BaseCombatEntity Entity
public float GetAttackCost
public float GetStamina
public float GetEnergy
public float GetSleep
public float GetStuckDuration
public float GetLastStuckTime
public float currentBehaviorDuration
public Behaviour CurrentBehaviour
public int AgentTypeIndex
public AiStatistics get_GetStats()
public NavMeshAgent get_GetNavAgent()
public IAIContext GetContext(Guid aiId)
public Vector2i get_CurrentCoord()
public void set_CurrentCoord(Vector2i value)
public Vector2i get_PreviousCoord()
public void set_PreviousCoord(Vector2i value)
public bool get_AgencyUpdateRequired()
public void set_AgencyUpdateRequired(bool value)
public bool get_IsOnOffmeshLinkAndReachedNewCoord()
public void set_IsOnOffmeshLinkAndReachedNewCoord(bool value)
public Vector3 get_Destination()
public void set_Destination(Vector3 value)
public bool get_IsStopped()
public void set_IsStopped(bool value)
public bool get_AutoBraking()
public void set_AutoBraking(bool value)
public bool get_HasPath()
public bool IsNavRunning()
public void Pause()
public void Resume()
public bool get_IsDormant()
public void set_IsDormant(bool value)
public void SetTargetPathStatus(float pendingDelay)
public void UpdateDestination(Vector3 newDestination)
public void UpdateDestination(Transform tx)
public void StopMoving()
public float get_TimeAtDestination()
public bool get_IsStuck()
public float get_TargetSpeed()
public void set_TargetSpeed(float value)
public bool WantsToEat(BaseEntity eatable)
public BaseEntity get_FoodTarget()
public void set_FoodTarget(BaseEntity value)
public void Eat()
public float get_GetAttackRate()
public float get_GetAttackRange()
public Vector3 get_GetAttackOffset()
public void StartAttack()
public void StartAttack(AttackType type, BaseCombatEntity target)
public bool AttackReady()
public BaseEntity get_AttackTarget()
public void set_AttackTarget(BaseEntity value)
public float get_AttackTargetVisibleFor()
public SeenInfo get_AttackTargetMemory()
public void set_AttackTargetMemory(SeenInfo value)
public BaseCombatEntity get_CombatTarget()
public Vector3 get_AttackPosition()
public Vector3 get_CrouchedAttackPosition()
public Vector3 get_CurrentAimAngles()
public float GetWantsToAttack(BaseEntity target)
public float FearLevel(BaseEntity ent)
public Vector3 get_SpawnPosition()
public void set_SpawnPosition(Vector3 value)
public float GetActiveAggressionRangeSqr()
public BaseCombatEntity get_Entity()
public float get_GetAttackCost()
public float get_GetStamina()
public float get_GetEnergy()
public float get_GetSleep()
public bool BusyTimerActive()
public void SetBusyFor(float dur)
public float get_GetStuckDuration()
public float get_GetLastStuckTime()
public float get_currentBehaviorDuration()
public Behaviour get_CurrentBehaviour()
public void set_CurrentBehaviour(Behaviour value)
public int get_AgentTypeIndex()
public void set_AgentTypeIndex(int value)
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public float ToSpeed(SpeedEnum speed)
public List`1<NavPointSample> RequestNavPointSamplesInCircle(SampleCount sampleCount, float radius, SampleFeatures features)
public List`1<NavPointSample> RequestNavPointSamplesInCircleWaterDepthOnly(SampleCount sampleCount, float radius, float waterDepth)
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public float ToSpeed(SpeedEnum speed)
public int TopologyPreference()
}
public IClientComponentEx {
public void PreClientComponentCull(IPrefabProcessor p)
}
public IconSkin : MonoBehaviour {
public Image icon
public Text text
}
public IconSkinPicker : MonoBehaviour {
public GameObjectRef pickerIcon
public GameObject container
public Action skinChangedEvent
}
public IgnoreCollision : MonoBehaviour {
public Collider collider
protected void OnTriggerEnter(Collider other)
}
public IInstanceDataReceiver {
public void ReceiveInstanceData(InstanceData data)
}
public IItemSetup {
public void OnItemSetup(Item item)
}
public IItemUpdate {
public void OnItemUpdate(Item item)
}
public ILerpTarget {
public float GetExtrapolationTime()
public float GetInterpolationDelay()
public float GetInterpolationSmoothing()
public Vector3 GetNetworkPosition()
public Quaternion GetNetworkRotation()
public void SetNetworkPosition(Vector3 pos)
public void SetNetworkRotation(Quaternion rot)
public void DrawInterpolationState(Segment segment, List`1<Entry> entries)
}
public ImagePainter : MonoBehaviour {
public OnDrawingEvent onDrawing
public MonoBehaviour redirectRightClick
public float spacingScale
internal Brush brush
internal PointerState[] pointerState
public RectTransform rectTransform
public RectTransform get_rectTransform()
public void OnPointerDown(PointerEventData eventData)
public void OnPointerUp(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
public void OnBeginDrag(PointerEventData eventData)
public void OnEndDrag(PointerEventData eventData)
public void OnInitializePotentialDrag(PointerEventData eventData)
private void DrawAt(Vector2 position, InputButton button)
private void Start()
public void UpdateBrush(Brush brush)
}
public ImageProcessing : object {
private Byte[] signature
public void GaussianBlur2D(Single[] data, int len1, int len2, int iterations)
public void GaussianBlur2D(Single[] data, int len1, int len2, int len3, int iterations)
public void Average2D(Single[] data, int len1, int len2, int iterations)
public void Average2D(Single[] data, int len1, int len2, int len3, int iterations)
public void Upsample2D(Single[] src, int srclen1, int srclen2, Single[] dst, int dstlen1, int dstlen2)
public void Upsample2D(Single[] src, int srclen1, int srclen2, int srclen3, Single[] dst, int dstlen1, int dstlen2, int dstlen3)
public void Dilate2D(Int32[] src, int len1, int len2, int srcmask, int radius, Action`2<int, int> action)
public void FloodFill2D(int x, int y, Int32[] data, int len1, int len2, int mask_any, int mask_not, Func`2<int, int> action)
public bool IsValidPNG(Byte[] data, int maxWidth, int maxHeight)
}
public Imposter : MonoBehaviour {
public ImposterAsset asset
public GameObject reference
public float angle
public int resolution
public int padding
}
public ImposterAsset : ScriptableObject {
public TextureEntry[] textures
public Vector2 size
public Vector2 pivot
public Mesh mesh
public Texture2D FindTexture(string name)
}
public InfrastructureType : Enum {
public int value__
public InfrastructureType Road
public InfrastructureType Power
}
public IngameMenuBackground : MonoBehaviour {
public bool Enabled
public CanvasGroup canvasGroup
}
public InputState : object {
public InputMessage current
public InputMessage previous
private int SwallowedButtons
public bool IsDown(BUTTON btn)
public bool WasDown(BUTTON btn)
public bool WasJustPressed(BUTTON btn)
public bool WasJustReleased(BUTTON btn)
public void SwallowButton(BUTTON btn)
private Quaternion AimAngle()
public void Flip(InputMessage newcurrent)
public void Clear()
}
public InspectorNameAttribute : PropertyAttribute {
public string name
public void .ctor(string name)
}
public InstrumentEffect : SoundPlayer {
public float pitch
}
public InstrumentTool : HeldEntity {
public GameObjectRef[] soundEffect
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void SVPlayNote(RPCMessage msg)
}
public InvisibleVendingMachine : NPCVendingMachine {
public GameObjectRef buyEffect
public NPCVendingOrderManifest vmoManifest
public NPCShopKeeper GetNPCShopKeeper()
public void KeeperLookAt(Vector3 pos)
public bool HasVendingSounds()
public float GetBuyDuration()
public void CompletePendingOrder()
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public IOEntity : BaseCombatEntity {
public Transform debugOrigin
public int lastResetIndex
public Flags HasPower
public IOSlot[] inputs
public IOSlot[] outputs
public IOType ioType
public bool IsPowered()
public void ResetIOState()
public void Init()
public void Shutdown()
public void MarkDirtyUpwards()
public bool IsRootEntity()
public void MarkDirty()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public float GetRootFlow()
public void Solve()
public void Spawn()
public void PostServerLoad()
public void PostMapEntitySpawn()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public IOnParentDestroying {
public void OnParentDestroying()
}
public IOnPostNetworkUpdate {
public void OnPostNetworkUpdate(BaseEntity entity)
}
public IOnSendNetworkUpdate {
public void OnSendNetworkUpdate(BaseEntity entity)
}
public IPrefabPreProcess {
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public IPrefabProcessor {
public void RemoveComponent(Component component)
public void NominateForDeletion(GameObject obj)
}
public IronsightAimPoint : MonoBehaviour {
public Transform targetPoint
private void OnDrawGizmos()
private void DrawArrow(Vector3 start, Vector3 end, float arrowLength)
}
public IronSightOverride : MonoBehaviour {
public IronsightAimPoint aimPoint
public float fieldOfViewOffset
public float fovBias
}
public IronSights : MonoBehaviour {
public bool Enabled
public IronsightAimPoint aimPoint
public float fieldOfViewOffset
public float introSpeed
public AnimationCurve introCurve
public float outroSpeed
public AnimationCurve outroCurve
public SoundDefinition upSound
public SoundDefinition downSound
public IronSightOverride ironsightsOverride
}
public IServerComponentEx {
public void PreServerComponentCull(IPrefabProcessor p)
}
public ISoundBudgetedUpdate {
public void DoUpdate()
}
public ISplashable {
public bool wantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
}
public Item : object {
public float _condition
public float _maxCondition
public ItemDefinition info
public UInt32 uid
public bool dirty
public int amount
public int position
public float busyTime
public float removeTime
public float fuel
public bool isServer
public InstanceData instanceData
public ulong skin
public string name
public string text
private Action`1<Item> OnDirty
public Flag flags
public ItemContainer contents
public ItemContainer parent
private EntityRef worldEnt
private EntityRef heldEntity
private Action`2<Item, float> onCycle
private Func`2<Item, int> <>f__am$cache0
public float condition
public float maxCondition
public float maxConditionNormalized
public float conditionNormalized
public bool hasCondition
public bool isBroken
public int despawnMultiplier
public ItemDefinition blueprintTargetDef
public int blueprintTarget
public int blueprintAmount
public Item parentItem
public float temperature
public TraitFlag Traits
public void set_condition(float value)
public float get_condition()
public void set_maxCondition(float value)
public float get_maxCondition()
public float get_maxConditionNormalized()
public float get_conditionNormalized()
public void set_conditionNormalized(float value)
public bool get_hasCondition()
public bool get_isBroken()
public void LoseCondition(float amount)
public void RepairCondition(float amount)
public void DoRepair(float maxLossFraction)
public ItemContainer GetRootContainer()
public void OnBroken()
public int get_despawnMultiplier()
public ItemDefinition get_blueprintTargetDef()
public int get_blueprintTarget()
public void set_blueprintTarget(int value)
public int get_blueprintAmount()
public void set_blueprintAmount(int value)
public bool IsBlueprint()
public void add_OnDirty(Action`1<Item> value)
public void remove_OnDirty(Action`1<Item> value)
public bool HasFlag(Flag f)
public void SetFlag(Flag f, bool b)
public bool IsOn()
public bool IsOnFire()
public bool IsCooking()
public bool IsLocked()
public Item get_parentItem()
public void MarkDirty()
public void OnChanged()
public void CollectedForCrafting(BasePlayer crafter)
public void ReturnedFromCancelledCraft(BasePlayer crafter)
public void Initialize(ItemDefinition template)
public void OnItemCreated()
public void OnVirginSpawn()
public void RemoveFromWorld()
public void OnRemovedFromWorld()
public void RemoveFromContainer()
public void SetParent(ItemContainer target)
public void OnAttacked(HitInfo hitInfo)
public bool IsChildContainer(ItemContainer c)
public bool CanMoveTo(ItemContainer newcontainer, int iTargetPos, bool allowStack)
public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos, bool allowStack)
public BaseEntity CreateWorldObject(Vector3 pos, Quaternion rotation, BaseEntity parentEnt, UInt32 parentBone)
public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation)
public bool IsBusy()
public void BusyFor(float fTime)
public void Remove(float fTime)
public void DoRemove()
public void SwitchOnOff(bool bNewState, BasePlayer player)
public void LockUnlock(bool bNewState, BasePlayer player)
public float get_temperature()
public BasePlayer GetOwnerPlayer()
public Item SplitItem(int split_Amount)
public bool CanBeHeld()
public bool CanStack(Item item)
public bool IsValid()
public void SetWorldEntity(BaseEntity ent)
public void OnMovedToWorld()
public BaseEntity GetWorldEntity()
public void SetHeldEntity(BaseEntity ent)
public BaseEntity GetHeldEntity()
public void add_onCycle(Action`2<Item, float> value)
public void remove_onCycle(Action`2<Item, float> value)
public void OnCycle(float delta)
public void ServerCommand(string command, BasePlayer player)
public void UseItem(int amountToConsume)
public bool HasAmmo(AmmoTypes ammoType)
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public string ToString()
public Item FindItem(UInt32 iUID)
public int MaxStackable()
public TraitFlag get_Traits()
public Item Save(bool bIncludeContainer, bool bIncludeOwners)
public void Load(Item load)
private int <MoveToContainer>m__0(Item x)
}
public ItemAmount : object {
public ItemDefinition itemDef
public float amount
public float startAmount
public int itemid
public void .ctor(ItemDefinition item, float amt)
public int get_itemid()
public float GetAmount()
public void OnAfterDeserialize()
public void OnBeforeSerialize()
}
public ItemAmountRandom : object {
public ItemDefinition itemDef
public AnimationCurve amount
public int RandomAmount()
}
public ItemAmountRanged : ItemAmount {
public float maxAmount
public void .ctor(ItemDefinition item, float amt, float max)
public void OnAfterDeserialize()
public float GetAmount()
}
public ItemBasedFlowRestrictor : IOEntity {
public ItemDefinition passthroughItem
public ContentsType allowedContents
public int maxStackSize
public int numSlots
public string lootPanelName
public Flags HasPassthrough
public Flags Sparks
public float passthroughItemConditionLossPerSec
private ItemContainer inventory
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public bool HasPassthroughItem()
public void TickPassthroughItem()
public void ServerInit()
public void PreServerLoad()
public void CreateInventory(bool giveUID)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool added)
private void RPC_OpenLoot(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
}
public ItemBlueprint : MonoBehaviour {
public List`1<ItemAmount> ingredients
public bool defaultBlueprint
public bool userCraftable
public bool isResearchable
public Rarity rarity
public int workbenchLevelRequired
public int scrapRequired
public int scrapFromRecycle
public bool NeedsSteamItem
public int blueprintStackSize
public float time
public int amountToCreate
public string UnlockAchievment
public ItemDefinition targetItem
public ItemDefinition get_targetItem()
}
public ItemButtonTools : MonoBehaviour {
public Image image
public ItemDefinition itemDef
public void GiveSelf(int amount)
public void GiveArmed()
public void GiveBlueprint()
}
public ItemCategory : Enum {
public int value__
public ItemCategory Weapon
public ItemCategory Construction
public ItemCategory Items
public ItemCategory Resources
public ItemCategory Attire
public ItemCategory Tool
public ItemCategory Medical
public ItemCategory Food
public ItemCategory Ammunition
public ItemCategory Traps
public ItemCategory Misc
public ItemCategory All
public ItemCategory Common
public ItemCategory Component
public ItemCategory Search
}
public ItemContainer : object {
public Flag flags
public ContentsType allowedContents
public ItemDefinition onlyAllowedItem
public List`1<ItemSlot> availableSlots
public int capacity
public UInt32 uid
public bool dirty
public List`1<Item> itemList
public float temperature
public Item parent
public BasePlayer playerOwner
public BaseEntity entityOwner
public bool isServer
public int maxStackSize
private Action onDirty
public Func`3<Item, int, bool> canAcceptItem
public Action`2<Item, bool> onItemAddedRemoved
public Action`1<Item> onPreItemRemove
public Vector3 dropPosition
public Vector3 dropVelocity
public bool HasFlag(Flag f)
public void SetFlag(Flag f, bool b)
public bool IsLocked()
public bool PlayerItemInputBlocked()
public void add_onDirty(Action value)
public void remove_onDirty(Action value)
public void ServerInitialize(Item parentItem, int iMaxCapacity)
public void GiveUID()
public void MarkDirty()
public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot)
public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, ItemContainer[] containers)
public void OnChanged()
public Item FindItemByUID(UInt32 iUID)
public bool IsFull()
public bool CanTake(Item item)
public bool Insert(Item item)
public bool SlotTaken(int i)
public Item GetSlot(int slot)
public bool FindPosition(Item item)
public void SetLocked(bool isLocked)
public bool Remove(Item item)
public void Clear()
public void Kill()
public int GetAmount(int itemid, bool onlyUsableAmounts)
public Item FindItemByItemID(int itemid)
public Item FindItemsByItemName(string name)
public List`1<Item> FindItemsByItemID(int itemid)
public ItemContainer Save()
public void Load(ItemContainer container)
public BasePlayer GetOwnerPlayer()
public int Take(List`1<Item> collect, int itemid, int iAmount)
public Vector3 get_dropPosition()
public Vector3 get_dropVelocity()
public void OnCycle(float delta)
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public bool HasAmmo(AmmoTypes ammoType)
public void AddItem(ItemDefinition itemToCreate, int p)
public void OnMovedToWorld()
public void OnRemovedFromWorld()
public UInt32 ContentsHash()
public ItemContainer FindContainer(UInt32 id)
public CanAcceptResult CanAcceptItem(Item item, int targetPos)
}
public ItemContainerSource : MonoBehaviour {
public ItemContainer GetItemContainer()
}
public ItemCrafter : EntityComponent`1<BasePlayer> {
public List`1<ItemContainer> containers
public Queue`1<ItemCraftTask> queue
public int taskUID
public void AddContainer(ItemContainer container)
public float GetScaledDuration(ItemBlueprint bp, float workbenchLevel)
public void ServerUpdate(float delta)
private void CollectIngredient(int item, int amount, List`1<Item> collect)
private void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player)
public bool CraftItem(ItemBlueprint bp, BasePlayer owner, InstanceData instanceData, int amount, int skinID, Item fromTempBlueprint)
public void FinishCrafting(ItemCraftTask task)
public bool CancelTask(int iID, bool ReturnItems)
public bool CancelBlueprint(int itemid)
public void CancelAll(bool returnItems)
private bool DoesHaveUsableItem(int item, int iAmount)
public bool CanCraft(ItemBlueprint bp, int amount)
public bool CanCraft(ItemDefinition def, int amount)
}
public ItemCraftTask : object {
public ItemBlueprint blueprint
public float endTime
public int taskUID
public BasePlayer owner
public bool cancelled
public InstanceData instanceData
public int amount
public int skinID
public List`1<ulong> potentialOwners
public List`1<Item> takenItems
public int numCrafted
public float conditionScale
public float workSecondsComplete
public float worksecondsRequired
}
public ItemDefinition : MonoBehaviour {
public int itemid
public string shortname
public Phrase displayName
public Phrase displayDescription
public Sprite iconSprite
public ItemCategory category
public ItemSelectionPanel selectionPanel
public int maxDraggable
public ContentsType itemType
public AmountType amountType
public ItemSlot occupySlots
public int stackable
public bool quickDespawn
public Rarity rarity
public bool spawnAsBlueprint
public SoundDefinition inventorySelectSound
public SoundDefinition inventoryGrabSound
public SoundDefinition inventoryDropSound
public SoundDefinition physImpactSoundDef
public Condition condition
public bool hidden
public Flag flags
public SteamInventoryItem steamItem
public ItemDefinition Parent
public GameObjectRef worldModelPrefab
public ItemMod[] itemMods
public TraitFlag Traits
public Skin[] skins
public Definition[] _skins2
public GameObject panel
private ItemModWearable <ItemModWearable>k__BackingField
private bool <isHoldable>k__BackingField
private bool <isUsable>k__BackingField
private bool <CraftableWithSkin>k__BackingField
public ItemDefinition[] Children
public Definition[] skins2
public ItemBlueprint Blueprint
public int craftingStackable
public bool isWearable
public ItemModWearable ItemModWearable
public bool isHoldable
public bool isUsable
public bool HasSkins
public bool CraftableWithSkin
public Definition[] get_skins2()
public void InvalidateWorkshopSkinCache()
public ulong FindSkin(int itemID, int skinID)
public ItemBlueprint get_Blueprint()
public int get_craftingStackable()
public bool HasFlag(Flag f)
public void Initialize(List`1<ItemDefinition> itemList)
public bool get_isWearable()
public ItemModWearable get_ItemModWearable()
private void set_ItemModWearable(ItemModWearable value)
public bool get_isHoldable()
private void set_isHoldable(bool value)
public bool get_isUsable()
private void set_isUsable(bool value)
public bool get_HasSkins()
public bool get_CraftableWithSkin()
private void set_CraftableWithSkin(bool value)
private bool <Initialize>m__0(ItemDefinition x)
}
public ItemDropCommand : MonoBehaviour {
public string command
}
public ItemEventFlag : MonoBehaviour {
public Flag flag
public UnityEvent onEnabled
public UnityEvent onDisable
internal bool firstRun
internal bool lastState
public void OnItemUpdate(Item item)
}
public ItemFootstepSounds : MonoBehaviour {
public string effectFolder
}
public ItemIcon : BaseMonoBehaviour {
public Color defaultBackgroundColor
public Color selectedBackgroundColor
public ItemContainerSource containerSource
public int slotOffset
public int slot
public bool setSlotFromSiblingIndex
public GameObject slots
public CanvasGroup iconContents
public Image iconImage
public Image underlayImage
public Text amountText
public Image hoverOutline
public Image cornerIcon
public Image lockedImage
public Image progressImage
public Image backgroundImage
public CanvasGroup conditionObject
public Image conditionFill
public Image maxConditionFill
public bool allowSelection
public bool allowDropping
public Item item
public bool invalidSlot
public SoundDefinition hoverSound
public void OnPointerClick(PointerEventData eventData)
public void OnPointerEnter(PointerEventData eventData)
public void OnPointerExit(PointerEventData eventData)
}
public ItemInformationPanel : MonoBehaviour {
public bool EligableForDisplay(ItemDefinition info)
public void SetupForItem(ItemDefinition info, Item item)
}
public ItemListTools : MonoBehaviour {
public GameObject categoryButton
public GameObject itemButton
internal Button lastCategory
private Func`2<ItemDefinition, ItemCategory> <>f__am$cache0
private Func`2<IGrouping`2<ItemCategory, ItemDefinition>, ItemCategory> <>f__am$cache1
private Func`2<ItemDefinition, string> <>f__am$cache2
public void OnPanelOpened()
public void Refresh()
private void RebuildCategories()
private void SwitchItemCategory(ItemDefinition[] defs)
private ItemCategory <RebuildCategories>m__0(ItemDefinition x)
private ItemCategory <RebuildCategories>m__1(IGrouping`2<ItemCategory, ItemDefinition> x)
private string <SwitchItemCategory>m__2(ItemDefinition x)
}
public ItemManager : object {
public List`1<ItemDefinition> itemList
public Dictionary`2<int, ItemDefinition> itemDictionary
public List`1<ItemBlueprint> bpList
public Int32[] defaultBlueprints
private List`1<ItemRemove> ItemRemoves
private Func`2<GameObject, ItemDefinition> <>f__am$cache0
private Func`2<ItemDefinition, bool> <>f__am$cache1
private Func`2<GameObject, ItemBlueprint> <>f__am$cache2
private Func`2<ItemBlueprint, bool> <>f__am$cache3
private Func`2<ItemBlueprint, bool> <>f__am$cache4
private Func`2<ItemBlueprint, int> <>f__am$cache5
public void InvalidateWorkshopSkinCache()
public void Initialize()
public Item CreateByName(string strName, int iAmount, ulong skin)
public Item CreateByPartialName(string strName, int iAmount)
public Item CreateByItemID(int itemID, int iAmount, ulong skin)
public Item Create(ItemDefinition template, int iAmount, ulong skin)
public Item Load(Item load, Item created, bool isServer)
public ItemDefinition FindItemDefinition(int itemID)
public ItemDefinition FindItemDefinition(string shortName)
public ItemBlueprint FindBlueprint(ItemDefinition item)
public List`1<ItemDefinition> GetItemDefinitions()
public List`1<ItemBlueprint> GetBlueprints()
public void DoRemoves()
public void Heartbeat()
public void RemoveItem(Item item, float fTime)
private ItemDefinition <Initialize>m__0(GameObject x)
private bool <Initialize>m__1(ItemDefinition x)
private ItemBlueprint <Initialize>m__2(GameObject x)
private bool <Initialize>m__3(ItemBlueprint x)
private bool <Initialize>m__4(ItemBlueprint x)
private int <Initialize>m__5(ItemBlueprint x)
}
public ItemMod : MonoBehaviour {
private ItemMod[] siblingMods
public void ModInit()
public void OnItemCreated(Item item)
public void OnVirginItem(Item item)
public void ServerCommand(Item item, string command, BasePlayer player)
public void DoAction(Item item, BasePlayer player)
public void OnRemove(Item item)
public void OnParentChanged(Item item)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
public void OnAttacked(Item item, HitInfo info)
public void OnChanged(Item item)
public bool CanDoAction(Item item, BasePlayer player)
public bool Passes(Item item)
public void OnRemovedFromWorld(Item item)
public void OnMovedToWorld(Item item)
}
public ItemModActionChange : ItemMod {
public ItemMod[] actions
public void OnChanged(Item item)
private void OnValidate()
}
public ItemModActionContainerChange : ItemMod {
public ItemMod[] actions
public void OnParentChanged(Item item)
private void OnValidate()
}
public ItemModAlterCondition : ItemMod {
public float conditionChange
public void DoAction(Item item, BasePlayer player)
}
public ItemModBlueprintCraft : ItemMod {
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModBurnable : ItemMod {
public float fuelAmount
public ItemDefinition byproductItem
public int byproductAmount
public float byproductChance
public void OnItemCreated(Item item)
}
public ItemModConditionContainerFlag : ItemMod {
public Flag flag
public bool requiredState
public bool Passes(Item item)
}
public ItemModConditionHasContents : ItemMod {
public ItemDefinition itemDef
public bool requiredState
public bool Passes(Item item)
private bool <Passes>m__0(Item x)
}
public ItemModConditionHasFlag : ItemMod {
public Flag flag
public bool requiredState
public bool Passes(Item item)
}
public ItemModConditionInWater : ItemMod {
public bool requiredState
public bool Passes(Item item)
}
public ItemModConsumable : MonoBehaviour {
public int amountToConsume
public float conditionFractionToLose
public List`1<ConsumableEffect> effects
}
public ItemModConsume : ItemMod {
public GameObjectRef consumeEffect
public string eatGesture
public ItemAmountRandom[] product
public ItemModConsumable primaryConsumable
public ItemModConsumable GetConsumable()
public GameObjectRef GetConsumeEffect()
public void DoAction(Item item, BasePlayer player)
public bool CanDoAction(Item item, BasePlayer player)
}
public ItemModConsumeChance : ItemModConsume {
public float chanceForSecondaryConsume
public GameObjectRef secondaryConsumeEffect
public ItemModConsumable secondaryConsumable
private bool GetChance()
public ItemModConsumable GetConsumable()
public GameObjectRef GetConsumeEffect()
}
public ItemModConsumeContents : ItemMod {
public GameObjectRef consumeEffect
public void DoAction(Item item, BasePlayer player)
public bool CanDoAction(Item item, BasePlayer player)
}
public ItemModContainer : ItemMod {
public int capacity
public int maxStackSize
public Flag containerFlags
public ContentsType onlyAllowedContents
public ItemDefinition onlyAllowedItemType
public List`1<ItemSlot> availableSlots
public bool openInDeployed
public bool openInInventory
public List`1<ItemAmount> defaultContents
public void OnItemCreated(Item item)
public void OnVirginItem(Item item)
public void CollectedForCrafting(Item item, BasePlayer crafter)
}
public ItemModContainerRestriction : ItemMod {
public SlotFlags slotFlags
public bool CanExistWith(ItemModContainerRestriction other)
}
public ItemModCookable : ItemMod {
public ItemDefinition becomeOnCooked
public float cookTime
public int amountOfBecome
public int lowTemp
public int highTemp
public bool setCookingFlag
public void OnValidate()
public void OnItemCreated(Item itemcreated)
}
public ItemModCycle : ItemMod {
public ItemMod[] actions
public float timeBetweenCycles
public float timerStart
public bool onlyAdvanceTimerWhenPass
public void OnItemCreated(Item itemcreated)
private bool CanCycle(Item item)
public void CustomCycle(Item item, float delta)
private void OnValidate()
}
public ItemModDeployable : MonoBehaviour {
public GameObjectRef entityPrefab
public bool showCrosshair
public string UnlockAchievement
public Deployable GetDeployable(BaseEntity entity)
internal void OnDeployed(BaseEntity ent, BasePlayer player)
}
public ItemModEntity : ItemMod {
public GameObjectRef entityPrefab
public string defaultBone
public void OnItemCreated(Item item)
public void OnRemove(Item item)
private bool ParentToParent(Item item, BaseEntity ourEntity)
private bool ParentToPlayer(Item item, BaseEntity ourEntity)
public void OnParentChanged(Item item)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
}
public ItemModGiveOxygen : ItemMod {
public int amountToConsume
public GameObjectRef inhaleEffect
public GameObjectRef exhaleEffect
public GameObjectRef bubblesEffect
private bool inhaled
public void DoAction(Item item, BasePlayer player)
}
public ItemModKeycard : ItemMod {
public int accessLevel
}
public ItemModMenuOption : ItemMod {
public string commandName
public ItemMod actionTarget
public Option option
public bool isPrimaryOption
public void ServerCommand(Item item, string command, BasePlayer player)
private void OnValidate()
}
public ItemModProjectile : MonoBehaviour {
public GameObjectRef projectileObject
public ItemModProjectileMod[] mods
public AmmoTypes ammoType
public int numProjectiles
public float projectileSpread
public float projectileVelocity
public float projectileVelocitySpread
public bool useCurve
public AnimationCurve spreadScalar
public string category
public float GetRandomVelocity()
public float GetSpreadScalar()
public float GetIndexedSpreadScalar(int shotIndex, int maxShots)
public float GetAverageVelocity()
public float GetMinVelocity()
public float GetMaxVelocity()
public bool IsAmmo(AmmoTypes ammo)
public void ServerProjectileHit(HitInfo info)
}
public ItemModProjectileMod : MonoBehaviour {
public void ServerProjectileHit(HitInfo info)
}
public ItemModProjectileRadialDamage : ItemModProjectileMod {
public float radius
public DamageTypeEntry damage
public GameObjectRef effect
public bool ignoreHitObject
public void ServerProjectileHit(HitInfo info)
}
public ItemModProjectileSpawn : ItemModProjectile {
public float createOnImpactChance
public GameObjectRef createOnImpact
public float spreadAngle
public float spreadVelocityMin
public float spreadVelocityMax
public int numToCreateChances
public void ServerProjectileHit(HitInfo info)
}
public ItemModRecycleInto : ItemMod {
public ItemDefinition recycleIntoItem
public int numRecycledItemMin
public int numRecycledItemMax
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModRepair : ItemMod {
public float conditionLost
public GameObjectRef successEffect
public int workbenchLvlRequired
public bool HasCraftLevel(BasePlayer player)
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModReveal : ItemMod {
public int numForReveal
public ItemDefinition revealedItemOverride
public int revealedItemAmount
public LootSpawn revealList
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModSound : ItemMod {
public GameObjectRef effect
public Type actionType
public void OnParentChanged(Item item)
}
public ItemModStudyBlueprint : ItemMod {
public GameObjectRef studyEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModSwap : ItemMod {
public GameObjectRef actionEffect
public ItemAmount[] becomeItem
public bool sendPlayerPickupNotification
public bool sendPlayerDropNotification
public float xpScale
public void DoAction(Item item, BasePlayer player)
}
public ItemModSwitchFlag : ItemMod {
public Flag flag
public bool state
public void DoAction(Item item, BasePlayer player)
}
public ItemModUnwrap : ItemMod {
public LootSpawn revealList
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModUpgrade : ItemMod {
public int numForUpgrade
public float upgradeSuccessChance
public int numToLoseOnFail
public ItemDefinition upgradedItem
public int numUpgradedItem
public GameObjectRef successEffect
public GameObjectRef failEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModUseContent : ItemMod {
public int amountToConsume
public void DoAction(Item item, BasePlayer player)
}
public ItemModWearable : ItemMod {
public GameObjectRef entityPrefab
public ProtectionProperties protectionProperties
public ArmorProperties armorProperties
public ClothingMovementProperties movementProperties
public blackoutType occlusionType
public bool blocksAiming
public bool emissive
public GameObjectRef viewmodelAddition
public Wearable targetWearable
public Wearable get_targetWearable()
private void DoPrepare()
public void ModInit()
public bool ProtectsArea(HitArea area)
public bool HasProtections()
internal float GetProtection(Item item, DamageType damageType)
public float ConditionProtectionScale(Item item)
public void CollectProtection(Item item, ProtectionProperties protection)
private bool IsHeadgear()
public bool IsFootwear()
public void OnAttacked(Item item, HitInfo info)
public bool CanExistWith(ItemModWearable wearable)
}
public ItemModXMasTreeDecoration : ItemMod {
public xmasFlags flagsToChange
}
public ItemModXPWhenUsed : ItemMod {
public float xpPerUnit
public int unitSize
public void GiveConsumeXP(Item item)
}
public ItemOptionButton : MonoBehaviour {
public Text name
public Image icon
}
public ItemPickup : DroppedItem {
public ItemDefinition itemDef
public int amount
public ulong skinOverride
public float GetDespawnDuration()
public void Spawn()
public void PostServerLoad()
}
public ItemPickupNotice : MonoBehaviour {
public GameObject objectDeleteOnFinish
public Text Text
public Text Amount
public ItemDefinition itemInfo
public int amount
public void set_itemInfo(ItemDefinition value)
public void set_amount(int value)
public void PopupNoticeEnd()
}
public ItemSearchEntry : MonoBehaviour {
public Button button
public Text text
public RawImage image
public RawImage bpImage
private ItemDefinition itemInfo
private AddSellOrderManager manager
}
public ItemSelectionPanel : Enum {
public int value__
public ItemSelectionPanel None
public ItemSelectionPanel Vessel
public ItemSelectionPanel Modifications
public ItemSelectionPanel GunInformation
}
public ItemSelector : PropertyAttribute {
public ItemCategory category
public void .ctor(ItemCategory category)
}
public ItemSkin : SteamInventoryItem {
public Skinnable Skinnable
public Material[] Materials
public void ApplySkin(GameObject obj)
}
public ItemSkinDirectory : ScriptableObject {
private ItemSkinDirectory _Instance
public Skin[] skins
public ItemSkinDirectory Instance
public ItemSkinDirectory get_Instance()
public Skin[] ForItem(ItemDefinition item)
public Skin FindByInventoryDefinitionId(int id)
}
public ItemSlot : Enum {
public int value__
public ItemSlot None
public ItemSlot Barrel
public ItemSlot Silencer
public ItemSlot Scope
public ItemSlot UnderBarrel
}
public ItemSplitter : MonoBehaviour {
public Slider slider
public Text textValue
public Text splitAmountText
}
public ItemSplitterDragOut : MonoBehaviour {
public ItemSplitter rootSplitter
}
public ItemStatValue : MonoBehaviour {
public Text text
public Slider slider
public bool selectedItem
public bool smallerIsBetter
public bool asPercentage
}
public ItemTextValue : MonoBehaviour {
public Text text
public Color bad
public Color good
public bool negativestat
public bool asPercentage
public bool useColors
public bool signed
public string suffix
public void SetValue(float val, int numDecimals, string overrideText)
}
public Jackhammer : BaseMelee {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasAmmo()
public void Server_SetEngineStatus(RPCMessage msg)
public void SetEngineStatus(bool on)
public void SetHeld(bool bHeld)
}
public JunkPile : BaseEntity {
public GameObjectRef sinkEffect
public SpawnGroup[] spawngroups
private float lifetimeMinutes
private List`1<NPCPlayerApex> _npcs
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public bool SpawnGroupsEmpty()
public void CheckEmpty()
public float TimeoutPlayerCheckRadius()
public void TimeOut()
public void SinkAndDestroy()
public void KillMe()
public void AddNpc(NPCPlayerApex npc)
}
public JunkPileWater : JunkPile {
public void Spawn()
}
public KeyBindUI : MonoBehaviour {
public GameObject blockingCanvas
public Button btnA
public Button btnB
public string bindString
}
public Keycard : AttackEntity {
public int accessLevel
public int get_accessLevel()
}
public KeyCodeEntry : UIDialog {
public Text textDisplay
public Action`1<string> onCodeEntered
public Text typeDisplay
public Phrase masterCodePhrase
public Phrase guestCodePhrase
}
public KeyLock : BaseLock {
public ItemDefinition keyItemType
public int keyCode
public bool firstKeyCreated
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasLockPermission(BasePlayer player)
private bool CanKeyUnlockUs(Item key)
public void Load(LoadInfo info)
public bool ShouldNetworkOwnerInfo()
public void PostServerLoad()
public void Save(SaveInfo info)
public void OnDeployed(BaseEntity parent)
public bool OnTryToOpen(BasePlayer player)
public bool OnTryToClose(BasePlayer player)
private void RPC_Unlock(RPCMessage rpc)
private void RPC_Lock(RPCMessage rpc)
private void RPC_CreateKey(RPCMessage rpc)
public void LockLock(BasePlayer player)
}
public LakeInfo : MonoBehaviour {
protected void Awake()
}
public Landmine : BaseTrap {
public GameObjectRef explosionEffect
public GameObjectRef triggeredEffect
public float minExplosionRadius
public float explosionRadius
public bool blocked
private ulong triggerPlayerID
public List`1<DamageTypeEntry> damageTypes
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool Triggered()
public bool Armed()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ServerInit()
public void ObjectEntered(GameObject obj)
public void Trigger(BasePlayer ply)
public void OnEmpty()
public void Explode()
public void OnKilled(HitInfo info)
private void OnGroundMissing()
private void TryExplode()
public void Arm()
private void RPC_Disarm(RPCMessage rpc)
}
public LanguageSelection : MonoBehaviour {
public GameObject languagePopup
public GameObject buttonContainer
public Image flagImage
}
public LaserBeam : MonoBehaviour {
public float scrollSpeed
public LineRenderer beamRenderer
public GameObject dotObject
public Renderer dotRenderer
public GameObject dotSpotlight
public Vector2 scrollDir
public float maxDistance
public float stillBlendFactor
public float movementBlendFactor
public float movementThreshhold
public bool isFirstPerson
public Transform emissionOverride
private MaterialPropertyBlock block
}
public LayerCullDistance : MonoBehaviour {
public string Layer
public float Distance
protected void OnEnable()
}
public LayerSelect : ValueType {
private int layer
public int Mask
public string Name
public void .ctor(int layer)
public int op_Implicit(LayerSelect layer)
public LayerSelect op_Implicit(int layer)
public int get_Mask()
public string get_Name()
}
public LazyAimProperties : ScriptableObject {
public float snapStrength
public float deadzoneAngle
}
public LeavesBlowing : MonoBehaviour {
public ParticleSystem m_psLeaves
public float m_flSwirl
public float m_flSpeed
public float m_flEmissionRate
private void Start()
private void Update()
}
public LerpBetweenPointsBool : MonoBehaviour {
public Vector3 offsetPosLocal
public float speed
public void SetAtOffset(bool should)
}
public LevelInfo : SingletonComponent`1<LevelInfo> {
public string shortName
public string displayName
public string description
public Texture2D image
public int version
}
public LevelManager : object {
public string CurrentLevelName
public bool isLoaded
public bool get_isLoaded()
public bool IsValid(string strName)
public void LoadLevel(string strName, bool keepLoadingScreenOpen)
public IEnumerator LoadLevelAsync(string strName, bool keepLoadingScreenOpen)
public void UnloadLevel()
}
public LifeInfographic : MonoBehaviour {
public PlayerLifeStory life
public GameObject container
}
public LifeInfographicStat : MonoBehaviour {
public DataType dataSource
}
public LifeScale : BaseMonoBehaviour {
private bool initialized
private Vector3 initialScale
public Vector3 finalScale
private Vector3 targetLerpScale
public void OnEnable()
public void SetProgress(float progress)
public void Init()
public void UpdateScale()
}
public Lift : AnimatedBuildingBlock {
public float resetDelay
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void RPC_UseLift(RPCMessage rpc)
private void MoveUp()
private void MoveDown()
protected void OnAnimatorDisabled()
}
public LightCloneShadow : MonoBehaviour {
public bool cloneShadowMap
public string shaderPropNameMap
public int cloneShadowMapDownscale
public RenderTexture map
public bool cloneShadowMask
public string shaderPropNameMask
public int cloneShadowMaskDownscale
public RenderTexture mask
}
public LightEx : UpdateBehaviour {
public bool alterColor
public float colorTimeScale
public Color colorA
public Color colorB
public AnimationCurve blendCurve
public bool loopColor
public bool alterIntensity
public float intensityTimeScale
public AnimationCurve intenseCurve
public float intensityCurveScale
public bool loopIntensity
public bool randomOffset
protected void OnValidate()
public bool CheckConflict(GameObject go)
}
public LightLOD : MonoBehaviour {
public float DistanceBias
public bool ToggleLight
public bool ToggleShadows
protected void OnValidate()
}
public LinearFog : MonoBehaviour {
public Material fogMaterial
public Color fogColor
public float fogStart
public float fogRange
public float fogDensity
public bool fogSky
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public LineRendererActivate : MonoBehaviour {
private void OnEnable()
}
public LinqEx : object {
public int MaxIndex(IEnumerable`1<T> sequence)
}
public LiquidContainer : StorageContainer {
public ItemDefinition defaultLiquid
public int startingAmount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
protected void UpdateOnFlag()
protected void OnInventoryDirty()
public void OpenTap(float duration)
public void ShutTap()
public bool HasLiquidItem()
public Item GetLiquidItem()
public bool wantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public void SVDrink(RPCMessage rpc)
public bool SupportsPooling()
}
public LiquidVessel : HeldEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanDrink()
private void DoEmpty(RPCMessage msg)
public void AddLiquid(ItemDefinition liquidType, int amount)
public bool CanFillHere(Vector3 pos)
public int AmountHeld()
public float HeldFraction()
public bool IsFull()
public int MaxHoldable()
}
public LoadBalancer : SingletonComponent`1<LoadBalancer> {
public bool Paused
private float MinMilliseconds
private float MaxMilliseconds
private int MinBacklog
private int MaxBacklog
private Queue`1[] queues
private Stopwatch watch
protected void LateUpdate()
public int Count()
public void ProcessAll()
public void Enqueue(DeferredAction action)
private void CreateInstance()
}
public LoadingScreen : SingletonComponent`1<LoadingScreen> {
private bool <WantsSkip>k__BackingField
private string <Text>k__BackingField
public CanvasRenderer panel
public Text title
public Text subtitle
public Button skipButton
public AudioSource music
public bool isOpen
public bool WantsSkip
public string Text
public bool get_isOpen()
public bool get_WantsSkip()
private void set_WantsSkip(bool value)
private void set_Text(string value)
public string get_Text()
protected void Awake()
public void Show()
public void Hide()
public void ShowSkip()
public void HideSkip()
public void Update(string strType)
public void UpdateFromServer(string strTitle, string strSubtitle)
public void CancelLoading()
public void SkipLoading()
}
public LocalClock : object {
public List`1<TimedEvent> events
public void Add(float delta, float variance, Action action)
public void Tick()
}
public LocalizeText : MonoBehaviour {
public string token
public string english
public string append
public SpecialMode specialMode
}
public LocalPositionAnimation : MonoBehaviour {
public Vector3 centerPosition
public bool worldSpace
public float scaleX
public float timeScaleX
public AnimationCurve movementX
public float scaleY
public float timeScaleY
public AnimationCurve movementY
public float scaleZ
public float timeScaleZ
public AnimationCurve movementZ
}
public LockedByEntCrate : LootContainer {
public GameObject lockingEnt
public void SetLockingEnt(GameObject ent)
public void SetLocked(bool isLocked)
public void Think()
}
public Locker : StorageContainer {
public GameObjectRef equipSound
private int rowSize
private int columnSize
private Item[] clothingBuffer
public bool equippingActive
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsEquipping()
public void ServerInit()
public bool LockerItemFilter(Item item, int targetSlot)
public void ClearEquipping()
public void RPC_Equip(RPCMessage msg)
public bool SupportsPooling()
}
public LODComponent : BaseMonoBehaviour {
public LODDistanceMode DistanceMode
public OccludeeParameters OccludeeParams
}
public LODDistanceMode : Enum {
public int value__
public LODDistanceMode XYZ
public LODDistanceMode XZ
}
public LODGrid : SingletonComponent`1<LODGrid> {
public bool Paused
public float CellSize
public float MaxMilliseconds
public float MaxRefreshDistance
}
public LODManager : SingletonComponent`1<LODManager> {
public float MaxMilliseconds
}
public LODUtil : object {
public float GetDistance(Transform transform, LODDistanceMode mode)
public float GetDistance(Vector3 worldPos, LODDistanceMode mode)
public float VerifyDistance(float distance)
}
public LookAt : MonoBehaviour {
public Transform target
private void Update()
}
public LookatHealth : MonoBehaviour {
public bool Enabled
public GameObject container
public Text textHealth
public Text textStability
public Image healthBar
public Image healthBarBG
public Color barBGColorNormal
public Color barBGColorUnstable
}
public LookAtPlant : MonoBehaviour {
public CanvasGroup group
public Text waterText
public Text ageText
public Text maturityText
public Text yieldText
public Color defaultColor
public Color goodColor
public Color avgColor
public Color badColor
}
public LookatTooltip : MonoBehaviour {
public bool Enabled
public Animator tooltipAnimator
public BaseEntity currentlyLookingAt
public Text textLabel
public Image icon
}
public LootableCorpse : BaseCorpse {
public string lootPanelName
public ulong playerSteamID
public string _playerName
public ItemContainer[] containers
public string playerName
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public string get_playerName()
public void set_playerName(string value)
public void ServerInit()
internal void DoServerDestroy()
public void TakeFrom(ItemContainer[] source)
public bool CanRemove()
public bool CanLoot()
private void RPC_LootCorpse(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
public void DropItems()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public LootContainer : StorageContainer {
public bool destroyOnEmpty
public LootSpawn lootDefinition
public int maxDefinitionsToSpawn
public float minSecondsBetweenRefresh
public float maxSecondsBetweenRefresh
public bool initialLootSpawn
public float xpLootedScale
public float xpDestroyedScale
public bool BlockPlayerItemInput
public int scrapAmount
public string deathStat
public spawnType SpawnType
private ItemDefinition scrapDef
public LootSpawnSlot[] LootSpawnSlots
public bool shouldRefreshContents
public bool get_shouldRefreshContents()
public void ServerInit()
public void PostServerLoad()
public void SpawnLoot()
public int ScoreForRarity(Rarity rarity)
public void PopulateLoot()
public void GenerateScrap()
public void PlayerStoppedLooting(BasePlayer player)
public void RemoveMe()
public bool ShouldDropItemsIndividually()
public bool SupportsPooling()
public void OnAttacked(HitInfo info)
public void InitShared()
}
public LootPanel : MonoBehaviour {
public Text Title
}
public LootPanelBigWheelTerminal : LootPanel {
public Text timeRemainingText
}
public LootPanelContainer : MonoBehaviour {
public string containerName
public GameObject NoLootPanel
}
public LootPanelLocker : LootPanel {
public GameObject[] controls
}
public LootPanelOven : LootPanel {
public GameObject controlsOn
public GameObject controlsOff
}
public LootPanelRecycler : LootPanel {
public GameObject controlsOn
public GameObject controlsOff
}
public LootPanelToolCupboard : LootPanel {
public List`1<VirtualItemIcon> costIcons
public Text costPerTimeText
public Text protectedText
public GameObject baseNotProtectedObj
public GameObject baseProtectedObj
public Phrase protectedPrefix
public Tooltip costToolTip
public Phrase blocksPhrase
}
public LootPanelVendingMachine : LootPanel {
public GameObject sellOrderPrefab
public GameObject sellOrderContainer
public GameObject busyOverlayPrefab
private GameObject busyOverlayInstance
}
public LootPanelWaterCatcher : LootPanel {
public ItemIcon sourceItem
public Image capacityImage
public CanvasGroup helpCanvas
public CanvasGroup buttonsCanvas
public Button fromButton
public Button toButton
public Button drinkButton
}
public LootSpawn : ScriptableObject {
public ItemAmountRanged[] items
public Entry[] subSpawn
private Func`2<Entry, int> <>f__am$cache0
public ItemDefinition GetBlueprintBaseDef()
public void SpawnIntoContainer(ItemContainer container)
private void SubCategoryIntoContainer(ItemContainer container)
private int <SubCategoryIntoContainer>m__0(Entry x)
}
public m2bradleyAnimator : MonoBehaviour {
public Animator m2Animator
public Material treadLeftMaterial
public Material treadRightMaterial
private Rigidbody mainRigidbody
public Transform turret
public Transform mainCannon
public Transform coaxGun
public Transform rocketsPitch
public Transform spotLightYaw
public Transform spotLightPitch
public Transform sideMG
public Transform[] sideguns
public Transform[] ShocksBones
public Transform[] ShockTraceLineBegin
public Vector3[] vecShocksOffsetPosition
public Transform targetTurret
public Transform targetSpotLight
public Transform[] targetSideguns
private Vector3 vecTurret
private Vector3 vecMainCannon
private Vector3 vecCoaxGun
private Vector3 vecRocketsPitch
private Vector3 vecSpotLightBase
private Vector3 vecSpotLight
private float sideMGPitchValue
public GameObject muzzleflashCannon
public GameObject muzzleflashCoaxGun
public GameObject muzzleflashSideMG
public GameObject[] muzzleflashRockets
public GameObject spotLightHaloSawnpoint
public GameObject[] muzzleflashSideguns
public GameObjectRef machineGunMuzzleFlashFX
public GameObjectRef mainCannonFireFX
public GameObjectRef rocketLaunchFX
public bool rocketsOpen
public Vector3[] vecSideGunRotation
public float treadConstant
public float wheelSpinConstant
public float sidegunsTurnSpeed
public float turretTurnSpeed
public float cannonPitchSpeed
public float rocketPitchSpeed
public float spotLightTurnSpeed
public float machineGunSpeed
private float wheelAngle
private void Start()
private void Update()
private void AnimateWheelsTreads()
private void AdjustShocksHeight()
private void TrackTurret()
private void TrackSpotLight()
private void TrackSideGuns()
public void CalculateYawPitchOffset(Transform objectTransform, Vector3 vecStart, Vector3 vecEnd, Single& yaw, Single& pitch)
public float NormalizeYaw(float flYaw)
}
public M2BradleyPhysics : MonoBehaviour {
private m2bradleyAnimator m2Animator
public WheelCollider[] Wheels
public WheelCollider[] TurningWheels
public Rigidbody mainRigidbody
public Transform[] waypoints
private Vector3 currentWaypoint
private Vector3 nextWaypoint
}
public Mailbox : StorageContainer {
public string ownerPanel
public GameObjectRef mailDropSound
public bool autoSubmitWhenClosed
public bool shouldMarkAsFull
public int mailInputSlot
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int get_mailInputSlot()
public bool PlayerIsOwner(BasePlayer player)
public bool IsFull()
public void MarkFull(bool full)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
private bool HasFreeSpace()
private int GetFreeSlot()
public bool MoveItemToStorage(Item item)
public void PlayerStoppedLooting(BasePlayer player)
public void RPC_Submit(RPCMessage msg)
public void SubmitInputItems(BasePlayer fromPlayer)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool CanMoveFrom(BasePlayer player, Item item)
}
public MainCamera : SingletonComponent`1<MainCamera> {
public Camera mainCamera
public DepthOfField dof
public AmplifyOcclusionEffect ssao
public Motion motionBlur
public TOD_Rays shafts
public TonemappingColorGrading tonemappingColorGrading
public FXAA fxaa
public SMAA smaa
public PostProcessLayer post
public CC_SharpenAndVignette sharpenAndVignette
public SEScreenSpaceShadows contactShadows
public VisualizeTexelDensity visualizeTexelDensity
public EnvironmentVolumePropertiesCollection environmentVolumeProperties
public bool isValid
public Vector3 position
public Vector3 forward
public Vector3 right
public Vector3 up
public Quaternion rotation
public Ray Ray
public RaycastHit Raycast
public bool get_isValid()
public Vector3 get_position()
public void set_position(Vector3 value)
public Vector3 get_forward()
public void set_forward(Vector3 value)
public Vector3 get_right()
public void set_right(Vector3 value)
public Vector3 get_up()
public void set_up(Vector3 value)
public Quaternion get_rotation()
public Ray get_Ray()
public RaycastHit get_Raycast()
}
public MainMenuSystem : SingletonComponent`1<MainMenuSystem> {
public bool isOpen
}
public ManagedNoise : object {
private Int32[] hash
private int hashMask
private double sqrt2
private double rsqrt2
private double squaresToTriangles
private double trianglesToSquares
private double simplexScale1D
private double simplexScale2D
private double gradientScale2D
private Double[] gradients1D
private int gradientsMask1D
private Double[] gradients2Dx
private Double[] gradients2Dy
private int gradientsMask2D
public double Simplex1D(double x)
public double Simplex1D(double x, Double& dx)
public double Simplex2D(double x, double y)
public double Simplex2D(double x, double y, Double& dx, Double& dy)
public double Turbulence(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double Billow(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double Ridge(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double Sharp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double TurbulenceIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double BillowIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double RidgeIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double SharpIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double TurbulenceWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double BillowWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double RidgeWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double SharpWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double Jordan(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp, double damp, double damp_scale)
private int Floor(double x)
private double Abs(double x)
private double Saturate(double x)
}
public MapEntity : HeldEntity {
public UInt32[] fogImages
public UInt32[] paintImages
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ImageUpdate(RPCMessage msg)
}
public MapGrid : MonoBehaviour {
public Text coordinatePrefab
public int gridCellSize
public float lineThickness
public CanvasGroup group
public float visibleAlphaLevel
public RawImage TargetImage
public bool show
}
public MapInterface : SingletonComponent`1<MapInterface> {
public bool IsOpen
public RawImage mapImage
public Image cameraPositon
public ScrollRectEx scrollRect
public PaintableImageGrid paintGrid
public UIPaintBox paintBox
public Toggle showGridToggle
public Button FocusButton
public GameObject monumentMarkerContainer
public GameObject monumentMarkerPrefab
public CanvasGroup CanvasGroup
public bool followingPlayer
}
public MapMarker : BaseEntity {
public List`1<MapMarker> mapMarkers
public GameObject markerObj
}
public MapMarkerCH47 : MapMarker {
private GameObject createdMarker
}
public MapMarkerExplosion : MapMarker {
private float duration
public void SetDuration(float newDuration)
public void Load(LoadInfo info)
public void DelayedDestroy()
}
public MapMarkerGenericRadius : MapMarker {
public float radius
public Color color1
public Color color2
public float alpha
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SendUpdate(bool fullUpdate)
}
public MaterialColorLerp : MonoBehaviour {
public Color startColor
public Color endColor
public Color currentColor
public float delta
}
public MaterialConfig : ScriptableObject {
public ShaderParametersFloat[] Floats
public ShaderParametersColor[] Colors
public ShaderParametersTexture[] Textures
public String[] ScaleUV
private MaterialPropertyBlock properties
public MaterialPropertyBlock GetMaterialPropertyBlock(Material mat, Vector3 pos, Vector3 scale)
}
public MaterialEffect : ScriptableObject {
public GameObjectRef DefaultEffect
public Entry[] Entries
public void SpawnOnRay(Ray ray, int mask, float length, Vector3 forward)
}
public MaterialOverlay : MonoBehaviour {
public Material material
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public MaterialPropertyDesc : ValueType {
public int nameID
public Type type
public void .ctor(string name, Type type)
}
public MaterialSetup : MonoBehaviour {
public bool destroy
public MaterialConfig config
}
public MaterialSound : ScriptableObject {
public SoundDefinition DefaultSound
public Entry[] Entries
}
public MaterialSwap : MonoBehaviour {
public int materialIndex
public Renderer myRenderer
public Material OverrideMaterial
}
public MaxSpawnDistance : MonoBehaviour {
public float maxDistance
}
public MedicalTool : AttackEntity {
public float healDurationSelf
public float healDurationOther
public float maxDistanceOther
public bool canUseOnOther
public bool canRevive
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void UseOther(RPCMessage msg)
private void UseSelf(RPCMessage msg)
private void GiveEffectsTo(BasePlayer player)
}
public MeleeWeaponInformationPanel : ItemInformationPanel {
public ItemStatValue damageDisplay
public ItemStatValue attackRateDisplay
public ItemStatValue attackSizeDisplay
public ItemStatValue attackRangeDisplay
public ItemStatValue oreGatherDisplay
public ItemStatValue treeGatherDisplay
public ItemStatValue fleshGatherDisplay
}
public MenuFriendPanel : MonoBehaviour {
public Text friendName
public Text friendSubtitle
public RawImage friendAvatar
public SteamFriend friend
}
public MenuServerPanel : MonoBehaviour {
private void Start()
private void Update()
}
public MenuTip : MonoBehaviour {
public Text text
public LoadingScreen screen
public TokenisedPhrase[] MenuTips
private int currentTipIndex
private float nextTipTime
public void OnEnable()
public void Update()
public void UpdateTip()
}
public MeshBatch : MonoBehaviour {
private bool <NeedsRefresh>k__BackingField
private int <Count>k__BackingField
private int <BatchedCount>k__BackingField
private int <VertexCount>k__BackingField
public bool NeedsRefresh
public int Count
public int BatchedCount
public int VertexCount
public int VertexCapacity
public int VertexCutoff
public int AvailableVertices
public bool get_NeedsRefresh()
private void set_NeedsRefresh(bool value)
public int get_Count()
private void set_Count(int value)
public int get_BatchedCount()
private void set_BatchedCount(int value)
public int get_VertexCount()
private void set_VertexCount(int value)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
public int get_VertexCapacity()
public int get_VertexCutoff()
public int get_AvailableVertices()
public void Alloc()
public void Free()
public void Refresh()
public void Apply()
public void Display()
public void Invalidate()
protected void AddVertices(int vertices)
protected void OnEnable()
protected void OnDisable()
}
public MeshCache : object {
public Dictionary`2<Mesh, Data> dictionary
public Data Get(Mesh mesh)
}
public MeshColliderBatch : MeshBatch {
private Vector3 position
private Mesh meshBatch
private MeshCollider meshCollider
private MeshColliderData meshData
private MeshColliderGroup meshGroup
public MeshColliderLookup meshLookup
public int VertexCapacity
public int VertexCutoff
public int get_VertexCapacity()
public int get_VertexCutoff()
public GameObject CreateInstance()
public Transform LookupTransform(int triangleIndex)
public Rigidbody LookupRigidbody(int triangleIndex)
public Collider LookupCollider(int triangleIndex)
public void LookupColliders(Vector3 position, float distance, List`1<T> list)
protected void Awake()
public void Setup(Vector3 position, LayerMask layer, PhysicMaterial material)
public void Add(MeshColliderInstance instance)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
}
public MeshColliderData : object {
public List`1<int> triangles
public List`1<Vector3> vertices
public List`1<Vector3> normals
public void Alloc()
public void Free()
public void Clear()
public void Apply(Mesh mesh)
public void Combine(MeshColliderGroup meshGroup)
public void Combine(MeshColliderGroup meshGroup, MeshColliderLookup colliderLookup)
}
public MeshColliderInstance : ValueType {
public Transform transform
public Rigidbody rigidbody
public Collider collider
public OBB bounds
public Vector3 position
public Quaternion rotation
public Vector3 scale
public Data data
public Mesh mesh
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public MeshColliderLookup : object {
public LookupGroup src
public LookupGroup dst
public void Apply()
public void Add(MeshColliderInstance instance)
public LookupEntry Get(int index)
}
public MeshCull : LODComponent {
public float Distance
}
public MeshData : object {
public List`1<int> triangles
public List`1<Vector3> vertices
public List`1<Vector3> normals
public List`1<Vector4> tangents
public List`1<Color32> colors32
public List`1<Vector2> uv
public List`1<Vector2> uv2
public List`1<Vector4> positions
public void Alloc()
public void Free()
public void Clear()
public void Apply(Mesh mesh)
public void Combine(MeshGroup meshGroup)
}
public MeshDataBatch : MeshBatch {
private Vector3 position
private Mesh meshBatch
private MeshFilter meshFilter
private MeshRenderer meshRenderer
private MeshData meshData
private MeshGroup meshGroup
public int VertexCapacity
public int VertexCutoff
public int get_VertexCapacity()
public int get_VertexCutoff()
public GameObject CreateInstance()
protected void Awake()
public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
public void Add(MeshInstance instance)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
}
public MeshGroupCull : LODComponent {
public float Distance
}
public MeshHolder : object {
public Vector3[] _vertices
public Vector3[] _normals
public Int32[] _triangles
public trisPerSubmesh[] _TrianglesOfSubs
public Matrix4x4[] _bindPoses
public BoneWeight[] _boneWeights
public Bounds _bounds
public int _subMeshCount
public Vector4[] _tangents
public Vector2[] _uv
public Vector2[] _uv2
public Vector2[] _uv3
public Color[] _colors
public Vector2[] _uv4
public void setAnimationData(Mesh mesh)
}
public MeshInstance : ValueType {
public Vector3 position
public Quaternion rotation
public Vector3 scale
public Data data
public Mesh mesh
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public MeshLOD : LODComponent {
public State[] States
}
public MeshPaintable : MonoBehaviour {
public string replacementTextureName
public int textureWidth
public int textureHeight
public Color clearColor
public Texture2D targetTexture
public bool hasChanges
}
public MeshPaintableSource : MonoBehaviour {
public int texWidth
public int texHeight
public string replacementTextureName
public float cameraFOV
public float cameraDistance
public Texture2D texture
public GameObject sourceObject
public Mesh collisionMesh
public Vector3 localPosition
public Vector3 localRotation
private MaterialPropertyBlock block
public void Init()
public void Free()
public void UpdateFrom(Texture2D input)
public void Load(Byte[] data)
}
public MeshPaintController : MonoBehaviour {
public Camera pickerCamera
public Texture2D brushTexture
public Vector2 brushScale
public Color brushColor
public float brushSpacing
public RawImage brushImage
private Vector3 lastPosition
}
public MeshRendererBatch : MeshBatch {
private Vector3 position
private Mesh meshBatch
private MeshFilter meshFilter
private MeshRenderer meshRenderer
private MeshRendererData meshData
private MeshRendererGroup meshGroup
private MeshRendererLookup meshLookup
public int VertexCapacity
public int VertexCutoff
public int get_VertexCapacity()
public int get_VertexCutoff()
public GameObject CreateInstance()
protected void Awake()
public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
public void Add(MeshRendererInstance instance)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
}
public MeshRendererData : object {
public List`1<int> triangles
public List`1<Vector3> vertices
public List`1<Vector3> normals
public List`1<Vector4> tangents
public List`1<Color32> colors32
public List`1<Vector2> uv
public List`1<Vector2> uv2
public List`1<Vector4> positions
public void Alloc()
public void Free()
public void Clear()
public void Apply(Mesh mesh)
public void Combine(MeshRendererGroup meshGroup)
public void Combine(MeshRendererGroup meshGroup, MeshRendererLookup rendererLookup)
}
public MeshRendererInfo : ComponentInfo`1<MeshRenderer> {
public ShadowCastingMode shadows
public Material material
public Mesh mesh
public void Reset()
public void Setup()
}
public MeshRendererInstance : ValueType {
public Renderer renderer
public OBB bounds
public Vector3 position
public Quaternion rotation
public Vector3 scale
public Data data
public Mesh mesh
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public MeshRendererLookup : object {
public LookupGroup src
public LookupGroup dst
public void Apply()
public void Clear()
public void Add(MeshRendererInstance instance)
public LookupEntry Get(int index)
}
public MeshReplacement : MonoBehaviour {
public SkinnedMeshRenderer Female
internal void Process(GameObject go, bool IsFemale)
}
public MeshToggle : MonoBehaviour {
public Mesh[] RendererMeshes
public Mesh[] ColliderMeshes
public void SwitchRenderer(int index)
public void SwitchRenderer(float factor)
public void SwitchCollider(int index)
public void SwitchCollider(float factor)
public void SwitchAll(int index)
public void SwitchAll(float factor)
}
public MetabolismAttribute : object {
public float startMin
public float startMax
public float min
public float max
public float value
public float lastValue
internal float lastGreatFraction
private float greatInterval
public float greatFraction
public float get_greatFraction()
public void Reset()
public float Fraction()
public float InverseFraction()
public void Add(float val)
public void Subtract(float val)
public void Increase(float fTarget)
public void MoveTowards(float fTarget, float fRate)
public bool HasChanged()
public bool HasGreatlyChanged()
public void SetValue(float newValue)
}
public MiningQuarry : BaseResourceExtractor {
public Animator beltAnimator
public Renderer beltScrollRenderer
public int scrollMatIndex
public SoundPlayer[] onSounds
public float processRate
public float workToAdd
public GameObjectRef bucketDropEffect
public GameObject bucketDropTransform
public ChildPrefab engineSwitchPrefab
public ChildPrefab hopperPrefab
public ChildPrefab fuelStoragePrefab
public bool isStatic
public ResourceDeposit _linkedDeposit
public QuarryType staticType
public bool IsEngineOn()
public void SetOn(bool isOn)
public void EngineSwitch(bool isOn)
public void ServerInit()
public void UpdateStaticDeposit()
public void PostServerLoad()
public void SpawnChildEntities()
public void ProcessResources()
public bool FuelCheck()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void Update()
}
public MinMax : object {
public float x
public float y
public void .ctor(float x, float y)
public float Random()
public float Lerp(float t)
public float Lerp(float a, float b, float t)
}
public MinMaxAttribute : PropertyAttribute {
public float min
public float max
public void .ctor(float min, float max)
}
public MixerSnapshotManager : MonoBehaviour {
public AudioMixerSnapshot defaultSnapshot
public AudioMixerSnapshot underwaterSnapshot
public AudioMixerSnapshot loadingSnapshot
public AudioMixerSnapshot woundedSnapshot
public SoundDefinition underwaterInSound
public SoundDefinition underwaterOutSound
public SoundDefinition woundedLoop
private Sound woundedLoopSound
}
public Model : MonoBehaviour {
public SphereCollider collision
public Transform rootBone
public Transform headBone
public Transform eyeBone
public Animator animator
public Transform[] boneTransforms
public String[] boneNames
internal int skin
protected void OnEnable()
public int GetSkin()
}
public ModelConditionTest : PrefabAttribute {
public bool DoTest(BaseEntity ent)
protected Type GetIndexedType()
}
public ModelConditionTest_FoundationSide : ModelConditionTest {
private string square_south
private string square_north
private string square_west
private string square_east
private string triangle_south
private string triangle_northwest
private string triangle_northeast
private string socket
protected void OnDrawGizmosSelected()
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofBottom : ModelConditionTest {
private string socket
private string socket_female
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofLeft : ModelConditionTest {
private string socket
private string socket_female
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofRight : ModelConditionTest {
private string socket
private string socket_female
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofTop : ModelConditionTest {
private string socket
private string socket_male
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_Wall : ModelConditionTest {
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallTriangleLeft : ModelConditionTest {
private string socket_1
private string socket_2
private string socket_3
private string socket_4
private string socket
public bool CheckCondition(BaseEntity ent)
private bool CheckSocketOccupied(BaseEntity ent, string socket)
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallTriangleRight : ModelConditionTest {
private string socket_1
private string socket_2
private string socket_3
private string socket_4
private string socket
public bool CheckCondition(BaseEntity ent)
private bool CheckSocketOccupied(BaseEntity ent, string socket)
public bool DoTest(BaseEntity ent)
}
public Monument : TerrainPlacement {
public float Radius
public float Fade
protected void OnDrawGizmosSelected()
protected void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
}
public MonumentInfo : MonoBehaviour {
public MonumentType Type
public MonumentTier Tier
public Bounds Bounds
public bool HasNavmesh
public bool shouldDisplayOnMap
public Phrase displayPhrase
private Dictionary`2<InfrastructureType, List`1<TerrainPathConnect>> targets
protected void Awake()
public bool CheckPlacement(Vector3 pos, Quaternion rot, Vector3 scale)
protected void OnDrawGizmosSelected()
public void AddTarget(TerrainPathConnect target)
public List`1<TerrainPathConnect> GetTargets(InfrastructureType type)
public MonumentNavMesh GetMonumentNavMesh()
}
public MonumentMarker : MonoBehaviour {
public Text text
public void Setup(MonumentInfo info)
}
public MonumentNavMesh : FacepunchBehaviour {
public int NavMeshAgentTypeIndex
public string DefaultAreaName
public int CellCount
public int CellSize
public int Height
public float NavmeshResolutionModifier
public Bounds Bounds
public NavMeshData NavMeshData
public NavMeshDataInstance NavMeshDataInstance
public LayerMask LayerMask
public NavMeshCollectGeometry NavMeshCollectGeometry
private List`1<AsyncTerrainNavMeshBake> terrainBakes
private List`1<NavMeshBuildSource> sources
private AsyncOperation BuildingOperation
private bool HasBuildOperationStarted
private Stopwatch BuildTimer
private int defaultArea
private int agentTypeId
public bool IsBuilding
public bool get_IsBuilding()
private void OnEnable()
private void OnDisable()
public void UpdateNavMeshAsync()
private IEnumerator CollectSourcesAsync(Action callback)
public IEnumerator UpdateNavMeshAndWait()
private void AppendModifierVolumes(List`1& sources)
public void FinishBuildingNavmesh()
public void OnDrawGizmosSelected()
}
public MonumentTier : Enum {
public int value__
public MonumentTier Tier0
public MonumentTier Tier1
public MonumentTier Tier2
}
public MonumentType : Enum {
public int value__
public MonumentType Cave
public MonumentType Airport
public MonumentType Building
public MonumentType Town
public MonumentType Radtown
public MonumentType Lighthouse
public MonumentType WaterWell
}
public MorphCache : MonoBehaviour {
public bool fallback
public int blendShape
public Single[] blendWeights
}
public MotorRowboat : MotorBoat {
protected Flags Flag_EngineOn
protected Flags Flag_ThrottleOn
protected Flags Flag_TurnLeft
protected Flags Flag_TurnRight
protected Flags Flag_Submerged
protected Flags Flag_HasFuel
protected Flags Flag_Stationary
protected Flags Flag_RecentlyPushed
private float submergeFractionMinimum
public GameObjectRef fuelStoragePrefab
public Transform fuelStoragePoint
public EntityRef fuelStorageInstance
public float fuelPerSec
public GameObjectRef storageUnitPrefab
public Transform storageUnitPoint
public EntityRef storageUnitInstance
public Transform boatRear
public ParticleSystemContainer wakeEffect
public ParticleSystemContainer engineEffectIdle
public ParticleSystemContainer engineEffectThrottle
public Projector causticsProjector
public Transform causticsDepthTest
public Transform engineLeftHandPosition
public Transform engineRotate
public Transform propellerRotate
public float population
public float outsidedecayminutes
public Transform[] stationaryDismounts
public Collider mainCollider
private float nextFuelCheckTime
private bool cachedHasFuel
private float pendingFuel
private float nextPushTime
private float lastHadDriverTime
public float angularDragBase
public float angularDragVelocity
public float landDrag
public float waterDrag
public float offAxisDrag
public float offAxisDot
private bool dying
private float maxVelForStationaryDismount
public BlendedSoundLoops engineLoops
public BlendedSoundLoops waterLoops
public SoundDefinition engineStartSoundDef
public SoundDefinition engineStopSoundDef
public SoundDefinition movementSplashAccentSoundDef
public SoundDefinition engineSteerSoundDef
public GameObjectRef pushLandEffect
public GameObjectRef pushWaterEffect
public float waterSpeedDivisor
public float turnPitchModScale
public float tiltPitchModScale
public float splashAccentFrequencyMin
public float splashAccentFrequencyMax
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void SpawnSubEntities()
public void BoatDecay()
public int GetFuelAmount()
public bool HasFuel(bool forceCheck)
public bool UseFuel(float seconds)
public bool RecentlyPushed()
public void RPC_WantsPush(RPCMessage msg)
public void RPC_OpenFuel(RPCMessage msg)
public bool IsDriver(BasePlayer player)
public void RPC_EngineToggle(RPCMessage msg)
public void EngineToggle(bool wantsOn)
public void PostServerLoad()
public void CheckInvalidBoat()
public void AttemptMount(BasePlayer player)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public float GetSteering(BasePlayer player)
public bool EngineOn()
public float TimeSinceDriver()
public void DriverInput(InputState inputState, BasePlayer player)
public void VehicleFixedUpdate()
public void SeatClippedWorld(BaseMountable mountable)
public void UpdateDrag()
public void OnKilled(HitInfo info)
public void ActualDeath()
public bool MountEligable()
public bool HasValidDismountPosition(BasePlayer player)
public Vector3 GetDismountPosition(BasePlayer player)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public Mountain : TerrainPlacement {
public float Fade
protected void OnDrawGizmosSelected()
protected void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
}
public MoveForward : MonoBehaviour {
public float Speed
protected void Update()
}
public MovementSounds : MonoBehaviour {
public SoundDefinition waterMovementDef
public float waterMovementFadeInSpeed
public float waterMovementFadeOutSpeed
private Sound waterMovement
private Modulator waterGainMod
private Vector3 lastPos
public bool mute
}
public MovementSoundTrigger : TriggerBase {
public SoundDefinition softSound
public SoundDefinition medSound
public SoundDefinition hardSound
public Collider collider
public void PreClientComponentCull(IPrefabProcessor p)
}
public MoveOverTime : MonoBehaviour {
public float speed
public Vector3 position
public Vector3 rotation
public Vector3 scale
private void Update()
}
public MurmurHash : object {
private UInt32 seed
public int Signed(Stream stream)
public UInt32 Unsigned(Stream stream)
private UInt32 rot(UInt32 x, byte r)
private UInt32 mix(UInt32 h)
}
public MurmurHashEx : object {
public int MurmurHashSigned(string str)
public UInt32 MurmurHashUnsigned(string str)
private MemoryStream StringToStream(string str)
}
public MusicChangeIntensity : MonoBehaviour {
public float raiseTo
public List`1<DistanceIntensity> distanceIntensities
public float tickInterval
}
public MusicClip : ScriptableObject {
public AudioClip audioClip
public int lengthInBars
public int lengthInBarsWithTail
public List`1<float> fadeInPoints
public float GetNextFadeInPoint(float currentClipTimeBars)
}
public MusicClipLoader : object {
public List`1<LoadedAudioClip> loadedClips
public Dictionary`2<AudioClip, LoadedAudioClip> loadedClipDict
public List`1<AudioClip> clipsToLoad
public List`1<AudioClip> clipsToUnload
public void Update()
public void Refresh()
private LoadedAudioClip FindLoadedClip(AudioClip clip)
}
public MusicManager : MonoBehaviour {
public AudioMixerGroup mixerGroup
public List`1<MusicTheme> themes
public MusicTheme currentTheme
public List`1<AudioSource> sources
public double nextMusic
public double nextMusicForced
public float intensity
public Dictionary`2<PositionedClip, ClipPlaybackData> clipPlaybackData
public MusicManager instance
public int holdIntensityUntilBar
public bool musicPlaying
public bool loadingFirstClips
public MusicTheme nextTheme
public double lastClipUpdate
public float clipUpdateInterval
public double themeStartTime
public int lastActiveClipRefresh
public int activeClipRefreshInterval
public bool forceThemeChange
public float randomIntensityJumpChance
public List`1<PositionedClip> activeClips
public List`1<PositionedClip> activeMusicClips
public List`1<PositionedClip> activeControlClips
public int currentBar
public double currentThemeTime
public double get_currentThemeTime()
public void RaiseIntensityTo(float amount, int holdLengthBars)
public void StopMusic()
}
public MusicTheme : ScriptableObject {
public float tempo
public int intensityHoldBars
public int lengthInBars
public bool canPlayInMenus
public ValueRange rain
public ValueRange wind
public ValueRange snow
public Enum biomes
public Enum topologies
public AnimationCurve time
public List`1<PositionedClip> clips
public List`1<Layer> layers
private Dictionary`2<int, List`1<PositionedClip>> activeClips
private List`1<AudioClip> firstAudioClips
private Dictionary`2<AudioClip, bool> audioClipDict
public int layerCount
public int samplesPerBar
public int get_layerCount()
public int get_samplesPerBar()
private void OnValidate()
public List`1<PositionedClip> GetActiveClipsForBar(int bar)
private int ActiveClipCollectionID(int bar)
public Layer LayerById(int id)
public void AddLayer()
private void UpdateLengthInBars()
public bool CanPlayInEnvironment(int currentBiome, int currentTopology, float currentRain, float currentSnow, float currentWind)
public bool FirstClipsLoaded()
public bool ContainsAudioClip(AudioClip clip)
}
public MusicUtil : object {
public float OneSixteenth
public double BeatsToSeconds(float tempo, float beats)
public double BarsToSeconds(float tempo, float bars)
public int SecondsToSamples(double seconds)
public int SecondsToSamples(double seconds, int sampleRate)
public int SecondsToSamples(float seconds)
public int SecondsToSamples(float seconds, int sampleRate)
public int BarsToSamples(float tempo, float bars, int sampleRate)
public int BarsToSamples(float tempo, float bars)
public int BeatsToSamples(float tempo, float beats)
public float SecondsToBeats(float tempo, double seconds)
public float SecondsToBars(float tempo, double seconds)
public float Quantize(float position, float gridSize)
public float FlooredQuantize(float position, float gridSize)
}
public Muzzleflash_AlphaRandom : MonoBehaviour {
public ParticleSystem[] muzzleflashParticles
private Gradient grad
private GradientColorKey[] gck
private GradientAlphaKey[] gak
private void Start()
private void OnEnable()
}
public MuzzleFlash_Flamelet : MonoBehaviour {
public ParticleSystem flameletParticle
private void OnEnable()
}
public NamedObjectList : ScriptableObject {
public NamedObject[] objects
}
public nametags : ConsoleSystem {
public bool enabled
}
public NativeNoise : object {
public float Simplex1D(float x)
public float Simplex1D(float x, Single& dx)
public float Simplex2D(float x, float y)
public float Simplex2D(float x, float y, Single& dx, Single& dy)
public float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale)
}
public NaturalBloomAndDirtyLens : MonoBehaviour {
public Shader shader
public Texture2D lensDirtTexture
public float range
public float cutoff
public float bloomIntensity
public float lensDirtIntensity
public float spread
public int iterations
public int mips
public Single[] mipWeights
public bool highPrecision
public bool downscaleSource
public bool debug
}
public NeedsCursor : MonoBehaviour {
private void Update()
}
public NeedsMouseWheel : ListComponent`1<NeedsMouseWheel> {
public bool AnyActive()
}
public NeighbourSocket : Socket_Base {
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
}
public Network.Channel.Client : object {
public byte Default
public byte Tick
}
public Network.Channel.Server : object {
public byte Default
public byte Positions
}
public NetworkCryptography : object {
private MemoryStream buffer
public MemoryStream EncryptCopy(Connection connection, MemoryStream stream, int offset)
public MemoryStream DecryptCopy(Connection connection, MemoryStream stream, int offset)
public void Encrypt(Connection connection, MemoryStream stream, int offset)
public void Decrypt(Connection connection, MemoryStream stream, int offset)
public bool IsEnabledIncoming(Connection connection)
public bool IsEnabledOutgoing(Connection connection)
protected void EncryptionHandler(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
protected void DecryptionHandler(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
}
public NetworkCryptographyServer : NetworkCryptography {
protected void EncryptionHandler(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
protected void DecryptionHandler(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
}
public NetworkInfoGeneralText : MonoBehaviour {
public Text text
private void Update()
private void UpdateText()
private string ChannelStat(int window, int left)
}
public NetworkSleep : MonoBehaviour {
public int totalBehavioursDisabled
public int totalCollidersDisabled
public Behaviour[] behaviours
public Collider[] colliders
internal int BehavioursDisabled
internal int CollidersDisabled
}
public NetworkVisibilityGrid : MonoBehaviour {
public int startID
public int gridSize
public int cellCount
public int visibilityRadius
public float switchTolerance
private void Awake()
private void OnDisable()
private void OnDrawGizmosSelected()
private int PositionToGrid(float f)
private float GridToPosition(int i)
public UInt32 CoordToID(int x, int y)
public UInt32 GetID(Vector3 vPos)
public Vector3 GetPosition(UInt32 uid)
public Bounds GetBounds(UInt32 uid)
public float CellSize()
public void OnGroupAdded(Group group)
public bool IsInside(Group group, Vector3 vPos)
public Group GetGroup(Vector3 vPos)
public void GetVisibleFrom(Group group, List`1<Group> groups)
}
public NetworkWriteEx : object {
public void WriteObject(Write write, T obj)
}
public NewsButton : MonoBehaviour {
public int storyNumber
public Story story
public CanvasGroup canvasGroup
public Text text
public Text author
public RawImage image
private float randomness
}
public NewsSource : MonoBehaviour {
public Story[] story
public Text title
public Text date
public Text text
public Text authorName
public RawImage image
public VerticalLayoutGroup layoutGroup
public Button button
private void OnEnable()
public void SetStory(int i)
private void SetHeadlineTexture(Texture tex)
private IEnumerator LoadHeaderImage(string url, int i)
private IEnumerator UpdateNews()
}
public NGSS_Directional : MonoBehaviour {
public float PCSS_GLOBAL_SOFTNESS
public float PCSS_FILTER_DIR_MIN
public float PCSS_FILTER_DIR_MAX
public float BANDING_NOISE_AMOUNT
public SAMPLER_COUNT SAMPLERS_COUNT
private void Update()
private void SetGlobalSettings(bool enabled)
}
public Noise : object {
public float MIN
public float MAX
public float Simplex1D(float x)
public float Simplex2D(float x, float y)
public float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale)
}
public NoiseParameters : ValueType {
public int Octaves
public float Frequency
public float Amplitude
public float Offset
public void .ctor(int octaves, float frequency, float amplitude, float offset)
}
public NonDrawingGraphic : Graphic {
public void SetMaterialDirty()
public void SetVerticesDirty()
protected void OnPopulateMesh(VertexHelper vh)
}
public note : ConsoleSystem {
public void update(Arg arg)
}
public NotePanel : MonoBehaviour {
public InputField input
private Item item
}
public NoticeArea : SingletonComponent`1<NoticeArea> {
public GameObject itemPickupPrefab
public GameObject itemDroppedPrefab
public void ItemPickUp(ItemDefinition def, int amount, string nameOverride)
}
public NPCAutoTurret : AutoTurret {
public Transform centerMuzzle
public Transform muzzleLeft
public Transform muzzleRight
private bool useLeftMuzzle
public float sleeperhostiledelay
public void ServerInit()
public bool HasAmmo()
public bool CheckPeekers()
public float TargetScanRate()
public bool InFiringArc(BaseCombatEntity potentialtarget)
public Transform GetCenterMuzzle()
public void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target)
protected bool Ignore(BasePlayer player)
public bool IsEntityHostile(BaseCombatEntity ent)
}
public NPCBarricadeTriggerBox : MonoBehaviour {
private Barricade target
private int playerServerLayer
public void Setup(Barricade t)
private void OnTriggerEnter(Collider other)
}
public NPCDoorTriggerBox : MonoBehaviour {
private Door door
private int playerServerLayer
public void Setup(Door d)
private void OnTriggerEnter(Collider other)
}
public NPCFootstepEffects : BaseFootstepEffect {
public string impactEffectDirectory
public Transform frontLeftFoot
public Transform frontRightFoot
public Transform backLeftFoot
public Transform backRightFoot
}
public NPCHumanContext : BaseNPCContext {
public List`1<BaseChair> Chairs
public BaseChair ChairTarget
private CoverPointVolume <CurrentCoverVolume>k__BackingField
private List`1<CoverPoint> <sampledCoverPoints>k__BackingField
private List`1<CoverType> <sampledCoverPointTypes>k__BackingField
private List`1<CoverPoint> <EnemyCoverPoints>k__BackingField
private CoverPoint <EnemyHideoutGuess>k__BackingField
private List`1<HideoutPoint> <CheckedHideoutPoints>k__BackingField
private PathInterestNode <CurrentPatrolPoint>k__BackingField
public float LastNavigationTime
public TacticalCoverPointSet CoverSet
public BaseEntity LastAttacker
public CoverPointVolume CurrentCoverVolume
public List`1<CoverPoint> sampledCoverPoints
public List`1<CoverType> sampledCoverPointTypes
public List`1<CoverPoint> EnemyCoverPoints
public CoverPoint EnemyHideoutGuess
public List`1<HideoutPoint> CheckedHideoutPoints
public PathInterestNode CurrentPatrolPoint
public void .ctor(NPCPlayerApex human)
public BaseEntity get_LastAttacker()
public void set_LastAttacker(BaseEntity value)
public CoverPointVolume get_CurrentCoverVolume()
public void set_CurrentCoverVolume(CoverPointVolume value)
public List`1<CoverPoint> get_sampledCoverPoints()
private void set_sampledCoverPoints(List`1<CoverPoint> value)
public List`1<CoverType> get_sampledCoverPointTypes()
private void set_sampledCoverPointTypes(List`1<CoverType> value)
public List`1<CoverPoint> get_EnemyCoverPoints()
private void set_EnemyCoverPoints(List`1<CoverPoint> value)
public CoverPoint get_EnemyHideoutGuess()
public void set_EnemyHideoutGuess(CoverPoint value)
public List`1<HideoutPoint> get_CheckedHideoutPoints()
public void set_CheckedHideoutPoints(List`1<HideoutPoint> value)
public PathInterestNode get_CurrentPatrolPoint()
public void set_CurrentPatrolPoint(PathInterestNode value)
protected void Finalize()
public void ForgetCheckedHideouts(float forgetTime)
public bool HasCheckedHideout(CoverPoint hideout)
}
public NPCMurderer : NPCPlayerApex {
public LootSpawnSlot[] LootSpawnSlots
public FamilyEnum Family
public string Categorize()
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public FamilyEnum get_Family()
public bool ShouldDropActiveItem()
public BaseCorpse CreateCorpse()
}
public NPCPlayer : BasePlayer {
public Vector3 finalDestination
private float randomOffset
private Vector3 spawnPos
public PlayerInventoryProperties[] loadouts
public LayerMask movementMask
public NavMeshAgent NavAgent
private Vector2i <CurrentCoord>k__BackingField
private Vector2i <PreviousCoord>k__BackingField
private bool <AgencyUpdateRequired>k__BackingField
private bool <IsOnOffmeshLinkAndReachedNewCoord>k__BackingField
private bool _isDormant
private float triggerEndTime
protected float nextTriggerTime
private float lastThinkTime
protected bool _traversingNavMeshLink
protected OffMeshLinkData _currentNavMeshLink
protected string _currentNavMeshLinkName
protected float _currentNavMeshLinkTraversalTime
protected float _currentNavMeshLinkTraversalTimeDelta
protected Quaternion _currentNavMeshLinkOrientation
protected Vector3 _currentNavMeshLinkEndPos
private Vector3 lastPos
public bool IsNpc
public Vector2i CurrentCoord
public Vector2i PreviousCoord
public bool AgencyUpdateRequired
public bool IsOnOffmeshLinkAndReachedNewCoord
public bool IsDormant
protected float PositionTickRate
public bool IsOnNavMeshLink
public bool HasPath
public bool get_IsNpc()
public Vector2i get_CurrentCoord()
public void set_CurrentCoord(Vector2i value)
public Vector2i get_PreviousCoord()
public void set_PreviousCoord(Vector2i value)
public bool get_AgencyUpdateRequired()
public void set_AgencyUpdateRequired(bool value)
public bool get_IsOnOffmeshLinkAndReachedNewCoord()
public void set_IsOnOffmeshLinkAndReachedNewCoord(bool value)
public bool get_IsDormant()
public void set_IsDormant(bool value)
protected float get_PositionTickRate()
public void ServerInit()
public void RandomMove()
public void SetDestination(Vector3 newDestination)
public AttackEntity GetAttackEntity()
public bool ShotTest()
public bool MeleeAttack()
public void TriggerDown()
public void EquipTest()
public void ServerThink_Internal()
public void ServerThink(float delta)
public void Resume()
public bool IsNavRunning()
public bool get_IsOnNavMeshLink()
public bool get_HasPath()
public void TickAi(float delta)
public void MovementUpdate(float delta)
private void HandleNavMeshLinkTraversal(float delta, Vector3& moveToPosition)
private bool HandleNavMeshLinkTraversalStart(float delta)
private void HandleNavMeshLinkTraversalTick(float delta, Vector3& moveToPosition)
private bool IsNavMeshLinkTraversalComplete(float delta, Vector3& moveToPosition)
private void CompleteNavMeshLink()
private void TickNavMeshLinkTraversal(float delta, Vector3& moveToPosition)
private bool IsNavMeshLinkTraversalComplete(Vector3 moveToPosition, Vector3 targetPosition)
private void TraverseLink(float delta, Vector3& moveToPosition, Vector3 targetPosition)
private void CompleteNavMeshLinkTraversal(bool failed, Vector3& moveToPosition)
private bool ValidateNextPosition(Vector3& moveToPosition)
private void UpdateSpeed(float delta)
protected void UpdatePositionAndRotation(Vector3 moveToPosition)
public Vector3 GetPosition()
public float DesiredMoveSpeed()
public bool EligibleForWounding(HitInfo info)
public Vector3 GetAimDirection()
public void SetAimDirection(Vector3 newAim)
}
public NPCPlayerApex : NPCPlayer {
public Vector2 RadioEffectRepeatRange
public GameObjectRef RadioEffect
public GameObjectRef DeathEffect
public int agentTypeIndex
private bool <IsStuck>k__BackingField
private Vector3 lastStuckPos
public float stuckDuration
public float lastStuckTime
private float timeAtDestination
public float TickRate
public bool IsInvinsible
public float lastInvinsibleStartTime
public float InvinsibleTime
public HashSet`1<NPCPlayerApex> AllJunkpileNPCs
public HashSet`1<NPCPlayerApex> AllBanditCampNPCs
private float nextSensorySystemTick
private float nextReasoningSystemTick
private float attackTargetVisibleFor
private BaseEntity lastAttackTarget
public AiStatistics Stats
public UtilityAIComponent utilityAiComponent
public bool NewAI
public bool NeverMove
public bool IsMountableAgent
public float WeaponSwitchFrequency
public float ToolSwitchFrequency
public WaypointSet WaypointSet
public Transform[] LookAtInterestPointsStationary
private NPCHumanContext _aiContext
public StateTimer BusyTimer
private float maxFleeTime
private float fleeHealthThresholdPercentage
private float aggroTimeout
private float lastAggroChanceResult
private float lastAggroChanceCalcTime
private float aggroChanceRecalcTimeout
private BaseEntity blockTargetingThisEnemy
public float NextWeaponSwitchTime
public float NextToolSwitchTime
public float NextDetectionCheck
private bool wasAggro
public float TimeLastMoved
public float TimeLastMovedToCover
public float AllyAttackedRecentlyTimeout
public float LastHasEnemyTime
public bool LastDetectionCheckResult
private int <WaypointDirection>k__BackingField
private bool <IsWaitingAtWaypoint>k__BackingField
private int <CurrentWaypointIndex>k__BackingField
private float <WaypointDelayTime>k__BackingField
private Vector3 <SpawnPosition>k__BackingField
private BaseEntity <AttackTarget>k__BackingField
private SeenInfo <AttackTargetMemory>k__BackingField
public Behaviour _currentBehavior
private float <currentBehaviorDuration>k__BackingField
private BaseEntity <FoodTarget>k__BackingField
private float <TargetSpeed>k__BackingField
protected float lastInRangeOfSpawnPositionTime
private Vector3[] pathCornerCache
private NavMeshPath _pathCache
private ActionCallback <OnFleeExplosive>k__BackingField
private ActionCallback <OnTakeCover>k__BackingField
private ActionCallback <OnAggro>k__BackingField
private ActionCallback <OnChatter>k__BackingField
private ActionCallback <OnDeath>k__BackingField
private ActionCallback <OnReload>k__BackingField
private float nextLookAtPointTime
public Transform LookAtPoint
public PlayerEyes LookAtEyes
public float CommunicationRadius
public Byte[] CurrentFacts
public int ForgetUnseenEntityTime
public float SensesTickRate
public float MaxDistanceToCover
public float MinDistanceToRetreatCover
public float VisionRangeScore
public float AggroRangeScore
public float LongRangeScore
public float MediumRangeScore
public float CloseRangeScore
public BaseEntity[] SensesResults
private List`1<NavPointSample> navPointSamples
private CoverPointComparer coverPointComparer
private float lastTickTime
private int sensesTicksPerCoverSweep
private int sensesTicksSinceLastCoverSweep
private float alertness
protected float lastSeenPlayerTime
private bool isAlreadyCheckingPathPending
private int numPathPendingAttempts
private float accumPathPendingDelay
public bool OnlyTargetSensations
private int MaxPlayers
public BasePlayer[] PlayerQueryResults
public int PlayerQueryResultCount
private NavMeshPath PathToPlayerTarget
private PlayerTargetContext _playerTargetContext
public BaseEntity[] EntityQueryResults
public int EntityQueryResultCount
private EntityTargetContext _entityTargetContext
private CoverContext _coverContext
private BaseAiUtilityClient _selectPlayerTargetAI
private BaseAiUtilityClient _selectPlayerTargetMountedAI
private BaseAiUtilityClient _selectEntityTargetAI
private BaseAiUtilityClient _selectCoverTargetsAI
private BaseAiUtilityClient _selectEnemyHideoutAI
public AIStorage SelectPlayerTargetUtility
public AIStorage SelectPlayerTargetMountedUtility
public AIStorage SelectEntityTargetsUtility
public AIStorage SelectCoverTargetsUtility
public AIStorage SelectEnemyHideoutUtility
private float playerTargetDecisionStartTime
private float animalTargetDecisionStartTime
private float nextCoverInfoTick
private float nextCoverPosInfoTick
private float _lastHeardGunshotTime
private Vector3 <LastHeardGunshotDirection>k__BackingField
private Func`2<BaseEntity, bool> <>f__mg$cache0
private Func`2<BaseEntity, bool> <>f__mg$cache1
private Func`2<BaseEntity, bool> <>f__am$cache0
private bool Apex.LoadBalancing.ILoadBalanced.repeat
public FamilyEnum Family
public int AgentTypeIndex
public bool IsStuck
public bool IsDormant
public NPCHumanContext AiContext
public float TimeAtDestination
public int WaypointDirection
public bool IsWaitingAtWaypoint
public int CurrentWaypointIndex
public float WaypointDelayTime
public Vector3 Destination
public float StoppingDistance
public float SqrStoppingDistance
public bool IsStopped
public bool AutoBraking
public Vector3 SpawnPosition
public float AttackTargetVisibleFor
public BaseEntity AttackTarget
public SeenInfo AttackTargetMemory
public BaseCombatEntity CombatTarget
public Vector3 AttackPosition
public Vector3 CrouchedAttackPosition
public Behaviour CurrentBehaviour
public float currentBehaviorDuration
public BaseCombatEntity Entity
public NavMeshAgent GetNavAgent
public AiStatistics GetStats
public float GetAttackRate
public float GetAttackRange
public Vector3 GetAttackOffset
public Vector3 CurrentAimAngles
public float GetStamina
public float GetEnergy
public float GetAttackCost
public float GetSleep
public float GetStuckDuration
public float GetLastStuckTime
public BaseEntity FoodTarget
public float TargetSpeed
public float SecondsSinceLastInRangeOfSpawnPosition
public ActionCallback OnFleeExplosive
public ActionCallback OnTakeCover
public ActionCallback OnAggro
public ActionCallback OnChatter
public ActionCallback OnDeath
public ActionCallback OnReload
public float SecondsSinceSeenPlayer
private PlayerTargetContext PlayerTargetContext
private EntityTargetContext EntityTargetContext
private CoverContext CoverContext
private BaseAiUtilityClient SelectPlayerTargetAI
private BaseAiUtilityClient SelectPlayerTargetMountedAI
private BaseAiUtilityClient SelectEntityTargetAI
private BaseAiUtilityClient SelectCoverTargetsAI
private BaseAiUtilityClient SelectEnemyHideoutAI
public float SecondsSinceLastHeardGunshot
public Vector3 LastHeardGunshotDirection
public FamilyEnum get_Family()
public int get_AgentTypeIndex()
public void set_AgentTypeIndex(int value)
public bool get_IsStuck()
public void set_IsStuck(bool value)
public bool get_IsDormant()
public void set_IsDormant(bool value)
private void DelayedSpawnPosition()
public void ServerInit()
private void DelayedReloadOnInit()
internal void DoServerDestroy()
private bool Apex.LoadBalancing.ILoadBalanced.get_repeat()
private Nullable`1<float> Apex.LoadBalancing.ILoadBalanced.ExecuteUpdate(float deltaTime, float nextInterval)
public void RadioChatter()
public void OnKilled(HitInfo info)
public void Hurt(HitInfo info)
public void TickAi(float delta)
public void MovementUpdate(float delta)
protected void UpdatePositionAndRotation(Vector3 moveToPosition)
public void TickStuck(float delta)
public void OnBecomeStuck()
public void OnBecomeUnStuck()
public void BehaviourChanged()
public void ServerThink(float delta)
public void UpdateAttackTargetVisibility(float delta)
public void UpdateDestination(Vector3 newDest)
public void UpdateDestination(Transform tx)
public void SetDestination(Vector3 newDestination)
public float WeaponAttackRange()
public void StopMoving()
public float DesiredMoveSpeed()
public Vector3 GetAimDirection()
public void SetAimDirection(Vector3 newAim)
public void StartAttack()
public SeenInfo UpdateTargetMemory(BaseEntity target, float dmg, ExtendedInfo& extendedInfo)
public SeenInfo UpdateTargetMemory(BaseEntity target, float dmg, Vector3 lastKnownPosition, ExtendedInfo& extendedInfo)
public void StartAttack(AttackType type, BaseCombatEntity target)
public bool ShotTest()
public void TriggerDown()
public bool AttackReady()
public string Categorize()
public NPCHumanContext get_AiContext()
protected void SetupAiContext()
public IAIContext GetContext(Guid aiId)
public float get_TimeAtDestination()
public int get_WaypointDirection()
public void set_WaypointDirection(int value)
public bool get_IsWaitingAtWaypoint()
public void set_IsWaitingAtWaypoint(bool value)
public int get_CurrentWaypointIndex()
public void set_CurrentWaypointIndex(int value)
public float get_WaypointDelayTime()
public void set_WaypointDelayTime(float value)
public Vector3 get_Destination()
public void set_Destination(Vector3 value)
public float get_StoppingDistance()
public void set_StoppingDistance(float value)
public float get_SqrStoppingDistance()
public bool get_IsStopped()
public void set_IsStopped(bool value)
public bool get_AutoBraking()
public void set_AutoBraking(bool value)
public bool IsNavRunning()
public void Pause()
public void Resume()
public void Mount(BaseMountable mountable)
public void Dismount()
public void DismountObject()
private IEnumerator TryForceToNavmesh()
public Vector3 get_SpawnPosition()
public void set_SpawnPosition(Vector3 value)
public float get_AttackTargetVisibleFor()
public BaseEntity get_AttackTarget()
public void set_AttackTarget(BaseEntity value)
public SeenInfo get_AttackTargetMemory()
public void set_AttackTargetMemory(SeenInfo value)
public BaseCombatEntity get_CombatTarget()
public Vector3 get_AttackPosition()
public Vector3 get_CrouchedAttackPosition()
public float FearLevel(BaseEntity ent)
public Behaviour get_CurrentBehaviour()
public void set_CurrentBehaviour(Behaviour value)
public float get_currentBehaviorDuration()
public void set_currentBehaviorDuration(float value)
public BaseCombatEntity get_Entity()
public NavMeshAgent get_GetNavAgent()
public float GetWantsToAttack(BaseEntity target)
public AiStatistics get_GetStats()
public float get_GetAttackRate()
public float get_GetAttackRange()
public Vector3 get_GetAttackOffset()
public Vector3 get_CurrentAimAngles()
public float get_GetStamina()
public float get_GetEnergy()
public float get_GetAttackCost()
public float get_GetSleep()
public float get_GetStuckDuration()
public float get_GetLastStuckTime()
public bool BusyTimerActive()
public void SetBusyFor(float dur)
public bool WantsToEat(BaseEntity ent)
public BaseEntity get_FoodTarget()
public void set_FoodTarget(BaseEntity value)
public void Eat()
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public float ToSpeed(SpeedEnum speed)
public float get_TargetSpeed()
public void set_TargetSpeed(float value)
public List`1<NavPointSample> RequestNavPointSamplesInCircle(SampleCount sampleCount, float radius, SampleFeatures features)
public List`1<NavPointSample> RequestNavPointSamplesInCircleWaterDepthOnly(SampleCount sampleCount, float radius, float waterDepth)
private void OnFactChanged(Facts fact, byte oldValue, byte newValue)
private void TickBehaviourState()
public bool TryAggro(float sqrRange)
public bool TryAggro(EnemyRangeEnum range)
public bool StartAggro(float timeout, bool broadcastEvent)
private void TickAggro()
private bool CheckHealthThresholdToFlee()
private void WantsToFlee()
private void TickFlee()
public float get_SecondsSinceLastInRangeOfSpawnPosition()
private void FindCoverFromEnemy()
private void FindCoverFromPosition(Vector3 position)
public bool PathDistanceIsValid(Vector3 from, Vector3 to, bool allowCloseRange)
private float PathDistance(int count, Vector3[]& path, float maxDistance)
private void FindClosestCoverToUs()
public ActionCallback get_OnFleeExplosive()
public void set_OnFleeExplosive(ActionCallback value)
public ActionCallback get_OnTakeCover()
public void set_OnTakeCover(ActionCallback value)
public ActionCallback get_OnAggro()
public void set_OnAggro(ActionCallback value)
public ActionCallback get_OnChatter()
public void set_OnChatter(ActionCallback value)
public ActionCallback get_OnDeath()
public void set_OnDeath(ActionCallback value)
public ActionCallback get_OnReload()
public void set_OnReload(ActionCallback value)
public int PeekNextWaypointIndex()
public int GetNextWaypointIndex()
public Transform GetLookatPointFromWaypoints()
private Transform GetLookatPoint(Transform[]& points)
public void LookAtRandomPoint(float nextTimeAddition)
public int TopologyPreference()
public bool IsInCommunicationRange(NPCPlayerApex npc)
public int GetAlliesInRange(List`1& allies)
public void SendStatement(AiStatement_EnemyEngaged statement)
public void SendStatement(AiStatement_EnemySeen statement)
public void OnAiStatement(NPCPlayerApex source, AiStatement_EnemyEngaged statement)
public void OnAiStatement(NPCPlayerApex source, AiStatement_EnemySeen statement)
public int AskQuestion(AiQuestion_ShareEnemyTarget question, List`1& answers)
public AiAnswer_ShareEnemyTarget OnAiQuestion(NPCPlayerApex source, AiQuestion_ShareEnemyTarget question)
public void InitFacts()
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public EnemyRangeEnum ToEnemyRangeEnum(float sqrRange)
public EnemyEngagementRangeEnum ToEnemyEngagementRangeEnum(float sqrRange)
public float ToSqrRange(EnemyRangeEnum range)
public float ToSqrRange(EnemyEngagementRangeEnum range)
public float GetActiveAggressionRangeSqr()
public bool IsWithinAggroRange(EnemyRangeEnum range)
public bool IsWithinAggroRange(float sqrRange)
public bool IsBeyondDeaggroRange(EnemyRangeEnum range)
public AfraidRangeEnum ToAfraidRangeEnum(float sqrRange)
public HealthEnum ToHealthEnum(float healthNormalized)
public SpeedEnum ToSpeedEnum(float speed)
public float ToSpeed(SpeedEnum speed)
public AmmoStateEnum GetCurrentAmmoStateEnum()
public WeaponTypeEnum GetCurrentWeaponTypeEnum()
public WeaponTypeEnum GetWeaponTypeEnum(BaseProjectile proj)
public EnemyRangeEnum WeaponToEnemyRange(WeaponTypeEnum weapon)
public EnemyRangeEnum CurrentWeaponToEnemyRange()
public byte GetPathStatus()
public NavMeshPathStatus ToPathStatus(byte value)
public ToolTypeEnum GetCurrentToolTypeEnum()
public void TickReasoningSystem()
private void _GatherPlayerTargetFacts()
private void _NoEnemyFacts()
private void _UpdateMountedSelfFacts()
private void _UpdateGroundedSelfFacts()
private void _UpdateCoverFacts()
public float get_SecondsSinceSeenPlayer()
private void TickSenses()
public float Distance2DSqr(Vector3 a, Vector3 b)
private void TickVision()
public bool IsVisibleMounted(BasePlayer player)
public bool IsVisibleStanding(BasePlayer player)
public bool IsVisibleCrouched(BasePlayer player)
public bool IsVisibleStanding(BaseNpc npc)
public bool IsVisibleCrouched(BaseNpc npc)
private void FindCoverPoints()
private void TickHearing()
private void TickSmell()
private void TickMountableAwareness()
private void SelectMountable()
private void TargetClosestChair()
private void TickEnemyAwareness()
private void SelectEnemy()
private void AggroClosestPlayerMounted()
private void AggroBestScorePlayerOrClosestAnimal()
protected void SetAttackTarget(BasePlayer player, float score, float sqrDistance, bool lineOfSightStanding, bool lineOfSightCrouched)
private float VisibilityScoreModifier(BasePlayer target, Vector3 dir, float dist, bool losStand, bool losCrouch)
public bool HostilityConsideration(BasePlayer target)
private void UpdateMountedSelfFacts()
private void UpdateSelfFacts()
private EnemyRangeEnum GetRangeToSpawnPoint()
private byte IsMoving()
private float NextAttackTime()
public void SetTargetPathStatus(float pendingDelay)
private void DelayedTargetPathStatus()
private bool AiCaresAbout(BaseEntity ent)
private bool AiCaresAboutIgnoreChairs(BaseEntity ent)
private bool WithinVisionCone(NPCPlayerApex npc, BaseEntity other)
private PlayerTargetContext get_PlayerTargetContext()
private EntityTargetContext get_EntityTargetContext()
private CoverContext get_CoverContext()
private BaseAiUtilityClient get_SelectPlayerTargetAI()
private BaseAiUtilityClient get_SelectPlayerTargetMountedAI()
private BaseAiUtilityClient get_SelectEntityTargetAI()
private BaseAiUtilityClient get_SelectCoverTargetsAI()
private BaseAiUtilityClient get_SelectEnemyHideoutAI()
private void ShutdownSensorySystem()
public void TickSensorySystem()
private float DecisionMomentumPlayerTarget()
private float DecisionMomentumAnimalTarget()
private void _FindPlayersInVisionRange()
private void _FindEntitiesInCloseRange()
private bool _FindCoverPointsInVolume()
private bool _FindCoverPointsInVolume(Vector3 position)
private bool _FindCoverPointsInVolume(Vector3 position, List`1<CoverPoint> coverPoints, CoverPointVolume& volume, Single& timer)
public void OnSensation(Sensation sensation, BasePlayer invoker)
protected void OnSenseItemOfInterest(Sensation sensation)
protected void OnSenseGunshot(Sensation sensation, BasePlayer invoker)
public float get_SecondsSinceLastHeardGunshot()
public Vector3 get_LastHeardGunshotDirection()
public void set_LastHeardGunshotDirection(Vector3 value)
private bool <_FindPlayersInVisionRange>m__0(BasePlayer player)
private bool <_FindEntitiesInCloseRange>m__1(BaseEntity entity)
}
public NPCPlayerCorpse : PlayerCorpse {
private bool lootEnabled
public float GetRemovalTime()
public bool CanLoot()
public void SetLootableIn(float when)
public void EnableLooting()
}
public NPCSensesLoadBalancer : LoadBalancer {
public ILoadBalancer NpcSensesLoadBalancer
}
public NPCShopKeeper : NPCPlayer {
private float greetDir
private Vector3 initialFacingDir
private BasePlayer lastWavedAtPlayer
public void OnDrawGizmos()
public void UpdateProtectionFromClothing()
public void Hurt(HitInfo info)
public void ServerInit()
public void PostServerLoad()
public void DelayedSleepEnd()
public void Greeting()
}
public NPCVendingMachine : VendingMachine {
public NPCVendingOrder vendingOrders
public byte GetBPState(bool sellItemAsBP, bool currencyItemAsBP)
public void TakeCurrencyItem(Item takenCurrencyItem)
public void GiveSoldItem(Item soldItem, BasePlayer buyer)
public void PostServerLoad()
public void ServerInit()
public void InstallFromVendingOrders()
public void InstallDefaultSellOrders()
public void ClearSellOrders()
public bool CanPlayerAdmin(BasePlayer player)
public void AddItemForSale(int itemID, int amountToSell, int currencyID, int currencyPerTransaction, byte bpState)
public void RefreshStock()
}
public NPCVendingOrder : ScriptableObject {
public Entry[] orders
}
public NPCVendingOrderManifest : ScriptableObject {
public NPCVendingOrder[] orderList
public int GetIndex(NPCVendingOrder sample)
public NPCVendingOrder GetFromIndex(int index)
}
public NpcWalkAnimation : MonoBehaviour {
public Vector3 HipFudge
public BaseNpc Npc
public Animator Animator
public Transform HipBone
public Transform LookBone
public bool UpdateWalkSpeed
public bool UpdateFacingDirection
public bool UpdateGroundNormal
public Transform alignmentRoot
public bool LaggyAss
public bool LookAtTarget
public float MaxLaggyAssRotation
public float MaxWalkAnimSpeed
public bool UseDirectionBlending
}
public ObjectList : ScriptableObject {
public Object[] objects
}
public ObjectRotation : MonoBehaviour {
public Camera cam
}
public ObjectSpam : MonoBehaviour {
public GameObject source
public int amount
public float radius
private void Start()
}
public ObjWriter : object {
public string MeshToString(Mesh mesh)
public void Write(Mesh mesh, string path)
}
public Occludee : MonoBehaviour {
public float minTimeVisible
public bool isStatic
public bool autoRegister
public bool stickyGizmos
public OccludeeState state
protected int occludeeId
protected Vector3 center
protected float radius
protected Renderer renderer
protected Collider collider
protected void Awake()
public void OnEnable()
public void OnDisable()
public void Register()
public void Unregister()
protected void OnVisibilityChanged(bool visible)
}
public OccludeeSphere : ValueType {
public int id
public OccludeeState state
public Sphere sphere
public bool IsRegistered
public void .ctor(int id)
public void .ctor(int id, Sphere sphere)
public bool get_IsRegistered()
public void Invalidate()
}
public OccludeeState : SmartListValue {
public int slot
public bool isStatic
public OnVisibilityChanged onVisibilityChanged
public Cell cell
public SimpleList`1<State> states
public bool isVisible
public bool get_isVisible()
public OccludeeState Initialize(SimpleList`1<State> states, BufferSet set, int slot, Vector4 sphereBounds, bool isVisible, float minTimeVisible, bool isStatic, OnVisibilityChanged onVisibilityChanged)
public void Invalidate()
public void MakeVisible()
}
public OcclusionCulling : MonoBehaviour {
public ComputeShader computeShader
public bool usePixelShaderFallback
public bool useAsyncReadAPI
private Camera camera
private int ComputeThreadsPerGroup
private int InputBufferStride
private int ResultBufferStride
private int OccludeeMaxSlotsPerPool
private int OccludeePoolGranularity
private int StateBufferGranularity
private int GridBufferGranularity
private Queue`1<OccludeeState> statePool
private SimpleList`1<OccludeeState> staticOccludees
private SimpleList`1<State> staticStates
private SimpleList`1<int> staticVisibilityChanged
private SimpleList`1<OccludeeState> dynamicOccludees
private SimpleList`1<State> dynamicStates
private SimpleList`1<int> dynamicVisibilityChanged
private List`1<int> staticChanged
private Queue`1<int> staticRecycled
private List`1<int> dynamicChanged
private Queue`1<int> dynamicRecycled
private BufferSet staticSet
private BufferSet dynamicSet
private BufferSet gridSet
private Vector4[] frustumPlanes
private String[] frustumPropNames
private Single[] matrixToFloatTemp
private Material fallbackMat
private Material depthCopyMat
private Matrix4x4 viewMatrix
private Matrix4x4 projMatrix
private Matrix4x4 viewProjMatrix
private Matrix4x4 prevViewProjMatrix
private Matrix4x4 invViewProjMatrix
private bool useNativePath
private OcclusionCulling instance
private GraphicsDeviceType[] supportedDeviceTypes
private bool _enabled
private bool _safeMode
private DebugFilter _debugShow
public DebugSettings debugSettings
private Material debugMipMat
private float debugDrawDuration
private Material downscaleMat
private Material blitCopyMat
private int hiZLevelCount
private int hiZWidth
private int hiZHeight
private RenderTexture depthTexture
private RenderTexture hiZTexture
private RenderTexture[] hiZLevels
private int GridCellsPerAxis
private int GridHalfCellsPerAxis
private int GridMinHalfCellsPerAxis
private int GridMaxHalfCellsPerAxis
private float GridCellSize
private float GridHalfCellSize
private float GridRcpCellSize
private int GridPoolCapacity
private int GridPoolGranularity
private HashedPool`1<Cell> grid
private Queue`1<Cell> gridChanged
public OcclusionCulling Instance
public bool Supported
public bool Enabled
public bool SafeMode
public DebugFilter DebugShow
public bool HiZReady
public OcclusionCulling get_Instance()
public bool get_Supported()
public bool get_Enabled()
public void set_Enabled(bool value)
public bool get_SafeMode()
public void set_SafeMode(bool value)
public DebugFilter get_DebugShow()
public void set_DebugShow(DebugFilter value)
private void GrowStatePool()
private OccludeeState Allocate()
private void Release(OccludeeState state)
private void Awake()
private void OnEnable()
private bool SupportsNativePath()
private void OnDisable()
public void MakeAllVisible()
private void Update()
public void RecursiveAddOccludees(Transform transform, float minTimeVisible, bool isStatic, bool stickyGizmos)
private int FindFreeSlot(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, Queue`1<int> recycled)
public OccludeeState GetStateById(int id)
public int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, OnVisibilityChanged onVisibilityChanged)
private int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, OnVisibilityChanged onVisibilityChanged, SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, Queue`1<int> recycled, List`1<int> changed, BufferSet set, SimpleList`1<int> visibilityChanged)
public void UnregisterOccludee(int id)
private void UnregisterOccludee(int slot, SimpleList`1<OccludeeState> occludees, Queue`1<int> recycled, List`1<int> changed)
public void UpdateDynamicOccludee(int id, Vector3 center, float radius)
private void UpdateBuffers(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, BufferSet set, List`1<int> changed, bool isStatic)
private void UpdateCameraMatrices(bool starting)
private void OnPreCull()
private void OnPostRender()
private Single[] MatrixToFloatArray(Matrix4x4 m)
private void PrepareAndDispatch()
private void IssueRead()
public void ResetTiming(SmartList bucket)
public void ResetTiming()
private bool FrustumCull(Vector4[] planes, Vector4 testSphere)
private int ProcessOccludees_Safe(SimpleList`1<State> states, SmartList bucket, Color32[] results, SimpleList`1<int> changed, Vector4[] frustumPlanes, float time, UInt32 frame)
private int ProcessOccludees_Fast(State[] states, Int32[] bucket, int bucketCount, Color32[] results, int resultCount, Int32[] changed, Int32& changedCount, Vector4[] frustumPlanes, float time, UInt32 frame)
private int ProcessOccludees_Native(State& states, Int32& bucket, int bucketCount, Color32& results, int resultCount, Int32& changed, Int32& changedCount, Vector4& frustumPlanes, float time, UInt32 frame)
private void ApplyVisibility_Safe(float time, UInt32 frame)
private void ApplyVisibility_Fast(float time, UInt32 frame)
private void ApplyVisibility_Native(float time, UInt32 frame)
private void ProcessCallbacks(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, SimpleList`1<int> changed)
public void RetrieveAndApplyVisibility()
public bool DebugFilterIsDynamic(int filter)
public bool DebugFilterIsStatic(int filter)
public bool DebugFilterIsGrid(int filter)
private void DebugInitialize()
private void DebugShutdown()
private void DebugUpdate()
private void DebugDraw()
public void NormalizePlane(Vector4& plane)
public void ExtractFrustum(Matrix4x4 viewProjMatrix, Vector4[]& planes)
public bool get_HiZReady()
public void CheckResizeHiZMap()
private void InitializeHiZMap()
private void FinalizeHiZMap()
private void InitializeHiZMap(int width, int height)
private void DestroyHiZMap()
private RenderTexture CreateDepthTexture(string name, int width, int height, bool mips)
private RenderTexture CreateDepthTextureMip(string name, int width, int height, int mip)
public void GrabDepthTexture()
public void GenerateHiZMipChain()
private void DebugDrawGizmos()
private int floor(float x)
public Cell RegisterToGrid(OccludeeState occludee)
public void UpdateInGrid(OccludeeState occludee)
public void UnregisterFromGrid(OccludeeState occludee)
public void UpdateGridBuffers()
}
public OneActiveSibling : MonoBehaviour {
private void OnEnable()
}
public OnePoleLowpassFilter : MonoBehaviour {
public float frequency
}
public OnParentDestroyingEx : object {
public void BroadcastOnParentDestroying(GameObject go)
public void SendOnParentDestroying(GameObject go)
}
public OnPostNetworkUpdateEx : object {
public void BroadcastOnPostNetworkUpdate(GameObject go, BaseEntity entity)
public void SendOnPostNetworkUpdate(GameObject go, BaseEntity entity)
}
public OnSendNetworkUpdateEx : object {
public void BroadcastOnSendNetworkUpdate(GameObject go, BaseEntity entity)
public void SendOnSendNetworkUpdate(GameObject go, BaseEntity entity)
}
public OpenSteamURL : MonoBehaviour {
public bool openInSteam
}
public OptimizeAnimator : ArticulatedOccludee {
public Bounds fixedLocalBounds
public Transform followBone
public Vector3 followBoneOffset
public bool optimizeOnStart
private HashSet`1<SkinnedMeshRenderer> rendererSet
protected void OnEnable()
public void ClearSkinnedRenderers()
public void ProcessRootOptimization(List`1<SkinnedMeshRenderer> skinnedRenderers, Transform reference)
public void UpdateSkinnedRenderers()
public void TriggerUpdateVisibilityBounds()
}
public OreHotSpot : BaseCombatEntity {
public float visualDistance
public GameObjectRef visualEffect
public GameObjectRef finishEffect
public GameObjectRef damageEffect
public OreResourceEntity owner
public void OreOwner(OreResourceEntity newOwner)
public void ServerInit()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public void FireFinishEffect()
public bool SupportsPooling()
}
public OreResourceEntity : StagedResourceEntity {
public GameObjectRef bonusPrefab
public GameObjectRef finishEffect
public GameObjectRef bonusFailEffect
public OreHotSpot _hotSpot
private int bonusesKilled
private int bonusesSpawned
private Vector3 lastNodeDir
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected void UpdateNetworkStage()
public void CleanupBonus()
public void OnKilled(HitInfo info)
public void ServerInit()
public void FinishBonusAssigned()
public void OnAttacked(HitInfo info)
public void DelayedBonusSpawn()
public void RespawnBonus()
public OreHotSpot SpawnBonusSpot(Vector3 lastDirection)
public Vector3 RandomCircle(float distance, bool allowInside)
public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset, bool allowInside, bool changeHeight)
public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight, float maxHeight, bool allowInside)
public Vector3 ClampToCylinder(Vector3 localPos, Vector3 cylinderAxis, float cylinderDistance, float minHeight, float maxHeight)
}
public ORSwitch : IOEntity {
private float input1Amount
private float input2Amount
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
}
public OutlineManager : MonoBehaviour {
public Material blurMat
public List`1<OutlineObject> objectsToRender
public float blurAmount
public Material glowSolidMaterial
public Material blendGlowMaterial
}
public OutlineObject : MonoBehaviour {
public Mesh[] meshes
public Transform[] meshTransforms
}
public PaintableImageGrid : UIBehaviour {
public UIPaintableImage templateImage
public int cols
public int rows
}
public Painting.Brush : object {
public float spacing
public Vector2 brushSize
public Texture2D texture
public Color color
public bool erase
}
public PaperDollSegment : BaseMonoBehaviour {
public HitArea selectedAreas
public HitArea area
public Image overlayImg
}
public ParticleCollisionLOD : LODComponentParticleSystem {
public State[] States
}
public ParticleDisableOnParentDestroy : MonoBehaviour {
public float destroyAfterSeconds
public void OnParentDestroying()
}
public ParticleEmitFromParentObject : MonoBehaviour {
public string bonename
private Bounds bounds
private Transform bone
private BaseEntity entity
private float lastBoundsUpdate
}
public ParticleRandomLifetime : MonoBehaviour {
public ParticleSystem mySystem
public float minScale
public float maxScale
public void Awake()
}
public ParticleSystemContainer : MonoBehaviour {
public void Play()
public void Pause()
public void Stop()
public void Clear()
}
public ParticleSystemCull : LODComponentParticleSystem {
public float Distance
}
public ParticleSystemLOD : LODComponentParticleSystem {
public State[] States
}
public ParticleSystemPlayer : MonoBehaviour {
protected void OnEnable()
public void OnParentDestroying()
}
public PathFinder : object {
private Int32[0...,0...] costmap
private Boolean[0...,0...] visited
private Point[] neighbors
private Point[] mooreNeighbors
private Point[] neumannNeighbors
public void .ctor(Int32[0...,0...] costmap, bool diagonals)
public Node FindPath(Point start, Point end, int depth)
private Node FindPathReversed(Point start, Point end, int depth)
public Node FindPathDirected(List`1<Point> startList, List`1<Point> endList, int depth)
public Node FindPathUndirected(List`1<Point> startList, List`1<Point> endList, int depth)
private Node FindPathReversed(List`1<Point> startList, List`1<Point> endList, int depth)
public Node FindClosestWalkable(Point start, int depth)
public Node Reverse(Node start)
public Node FindEnd(Node start)
public int Heuristic(Point a)
public int Heuristic(Point a, Point b)
public int Heuristic(Point a, List`1<Point> b)
}
public PathInterestNode : MonoBehaviour {
private float <NextVisitTime>k__BackingField
public float NextVisitTime
public float get_NextVisitTime()
public void set_NextVisitTime(float value)
public void OnDrawGizmos()
}
public PathInterpolator : object {
public Vector3[] Points
public Vector3[] Tangents
private int <MinIndex>k__BackingField
private int <MaxIndex>k__BackingField
private float <Length>k__BackingField
private float <StepSize>k__BackingField
private bool initialized
public int MinIndex
public int MaxIndex
public float Length
public float StepSize
public int DefaultMinIndex
public int DefaultMaxIndex
public float StartOffset
public float EndOffset
public void .ctor(Vector3[] points)
public int get_MinIndex()
public void set_MinIndex(int value)
public int get_MaxIndex()
public void set_MaxIndex(int value)
public float get_Length()
private void set_Length(float value)
public float get_StepSize()
private void set_StepSize(float value)
public int get_DefaultMinIndex()
public int get_DefaultMaxIndex()
public float get_StartOffset()
public float get_EndOffset()
public void RecalculateTangents()
public void Resample(float distance)
public void Smoothen(int iterations)
public Vector3 GetStartPoint()
public Vector3 GetEndPoint()
public Vector3 GetStartTangent()
public Vector3 GetEndTangent()
public Vector3 GetPoint(float distance)
public Vector3 GetTangent(float distance)
public Vector3 GetPointCubicHermite(float distance)
}
public PathList : object {
private Quaternion rot90
private Quaternion rot180
public string Name
public PathInterpolator Path
public bool Spline
public bool Start
public bool End
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
public int Topology
public int Splat
public float StepSize
public float MeshStepSize
public float MeshNormalSmoothing
public int SubMeshVerts
private Single[] placements
public void .ctor(string name, Vector3[] points)
private void SpawnObjectsNeighborAligned(UInt32& seed, Prefab[] prefabs, List`1<Vector3> positions, SpawnFilter filter)
private bool SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter)
private bool CheckObjects(Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter)
private void SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
private bool CheckObjects(Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
public void SpawnSide(UInt32& seed, SideObject obj)
public void SpawnAlong(UInt32& seed, PathObject obj)
public void SpawnBridge(UInt32& seed, BridgeObject obj)
public void SpawnStart(UInt32& seed, BasicObject obj)
public void SpawnEnd(UInt32& seed, BasicObject obj)
public void TrimStart(BasicObject obj)
public void TrimEnd(BasicObject obj)
public void ResetTrims()
public void AdjustTerrainHeight()
public void AdjustTerrainTexture()
public void AdjustTerrainTopology()
public List`1<Mesh> CreateMesh()
}
public PathSpeedZone : MonoBehaviour {
public Bounds bounds
public OBB obbBounds
public float maxVelocityPerSec
public OBB WorldSpaceBounds()
public float GetMaxSpeed()
public void OnDrawGizmosSelected()
}
public PatrolHelicopterAI : BaseMonoBehaviour {
public Vector3 interestZoneOrigin
public Vector3 destination
public bool hasInterestZone
public float moveSpeed
public float maxSpeed
public float courseAdjustLerpTime
public Quaternion targetRotation
public Vector3 windVec
public Vector3 targetWindVec
public float windForce
public float windFrequency
public float targetThrottleSpeed
public float throttleSpeed
public float maxRotationSpeed
public float rotationSpeed
public float terrainPushForce
public float obstaclePushForce
public HelicopterTurret leftGun
public HelicopterTurret rightGun
public PatrolHelicopterAI heliInstance
public BaseHelicopter helicopterBase
public aiState _currentState
private Vector3 _aimTarget
private bool movementLockingAiming
private bool hasAimTarget
private bool aimDoorSide
private Vector3 pushVec
private Vector3 _lastPos
private Vector3 _lastMoveDir
public bool isDead
private bool isRetiring
public float spawnTime
public float lastDamageTime
public List`1<targetinfo> _targetList
private float deathTimeout
private float destination_min_dist
private float currentOrbitDistance
private float currentOrbitTime
private bool hasEnteredOrbit
private float orbitStartTime
private float maxOrbitDuration
private bool breakingOrbit
public List`1<MonumentInfo> _visitedMonuments
public float arrivalTime
public GameObjectRef rocketProjectile
public GameObjectRef rocketProjectile_Napalm
public bool leftTubeFiredLast
public float lastRocketTime
public float timeBetweenRockets
public int numRocketsLeft
public int maxRockets
public Vector3 strafe_target_position
private bool puttingDistance
public float strafe_approach_range
public float strafe_firing_range
private bool useNapalm
public float lastNapalmTime
public float lastStrafeTime
private float _lastThinkTime
public void Awake()
public void SetInitialDestination(Vector3 dest, float mapScaleDistance)
public void Retire()
public void SetIdealRotation(Quaternion newTargetRot, float rotationSpeedOverride)
public Quaternion GetYawRotationTo(Vector3 targetDest)
public void SetTargetDestination(Vector3 targetDest, float minDist, float minDistForFacingRotation)
public bool AtDestination()
public void MoveToDestination()
public void TerrainPushback()
public void UpdateRotation()
public void UpdateSpotlight()
public void Update()
public void WeakspotDamaged(weakspot weak, HitInfo info)
public void CriticalDamage()
public void DoMachineGuns()
public void FireGun(Vector3 targetPos, float aimCone, bool left)
public bool CanInterruptState()
public bool IsAlive()
public void DestroyMe()
public Vector3 GetLastMoveDir()
public Vector3 GetMoveDirection()
public float GetMoveSpeed()
public float GetMaxRotationSpeed()
public bool IsTargeting()
public void UpdateWind()
public void SetAimTarget(Vector3 aimTarg, bool isDoorSide)
public void ClearAimTarget()
public void UpdateTargetList()
public bool PlayerVisible(BasePlayer ply)
public void WasAttacked(HitInfo info)
public void State_Death_Think(float timePassed)
public void State_Death_Enter()
public void State_Death_Leave()
public void State_Idle_Think(float timePassed)
public void State_Idle_Enter()
public void State_Idle_Leave()
public void State_Move_Think(float timePassed)
public void State_Move_Enter(Vector3 newPos)
public void State_Move_Leave()
public void State_Orbit_Think(float timePassed)
public Vector3 GetOrbitPosition(float rate)
public void State_Orbit_Enter(float orbitDistance)
public void State_Orbit_Leave()
public Vector3 GetRandomPatrolDestination()
public void State_Patrol_Think(float timePassed)
public void State_Patrol_Enter()
public void State_Patrol_Leave()
public int ClipRocketsLeft()
public bool CanStrafe()
public bool CanUseNapalm()
public void State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm)
public void State_Strafe_Think(float timePassed)
public bool ValidStrafeTarget(BasePlayer ply)
public void State_Strafe_Leave()
public void FireRocket()
public void InitializeAI()
public void OnCurrentStateExit()
public void ExitCurrentState()
public float GetTime()
public void AIThink()
public Vector3 GetRandomOffset(Vector3 origin, float minRange, float maxRange, float minHeight, float maxHeight)
public Vector3 GetAppropriatePosition(Vector3 origin, float minHeight, float maxHeight)
public float GetThrottleForDistance(float distToTarget)
}
public Performance : SingletonComponent`1<Performance> {
public Tick current
public Tick report
private long cycles
private Int32[] frameRateHistory
private Single[] frameTimeHistory
private int frames
private float time
private void Update()
private void FPSTimer()
private float AverageFrameRate()
private float AverageFrameTime()
}
public PerformanceText : MonoBehaviour {
public Text text
}
public PhysicsEffects : MonoBehaviour {
public BaseEntity entity
public SoundDefinition physImpactSoundDef
public float minTimeBetweenEffects
public float minDistBetweenEffects
public float hardnessScale
public float lowMedThreshold
public float medHardThreshold
public float enableDelay
public LayerMask ignoreLayers
private float lastEffectPlayed
private float enabledAt
private float ignoreImpactThreshold
private Vector3 lastCollisionPos
public void OnEnable()
public void OnCollisionEnter(Collision collision)
}
public PickAFriend : UIDialog {
public InputField input
public Action`1<ulong> onSelected
}
public PieMenu : UIBehaviour {
public PieMenu Instance
public Image middleBox
public PieShape pieBackgroundBlur
public PieShape pieBackground
public PieShape pieSelection
public GameObject pieOptionPrefab
public GameObject optionsCanvas
public MenuOption[] options
public GameObject scaleTarget
public float sliceGaps
public float outerSize
public float innerSize
public float iconSize
public float startRadius
public float radiusSize
public Image middleImage
public Text middleTitle
public Text middleDesc
public Text middleRequired
public Color colorIconActive
public Color colorIconHovered
public Color colorIconDisabled
public Color colorBackgroundDisabled
public SoundDefinition clipOpen
public SoundDefinition clipCancel
public SoundDefinition clipChanged
public SoundDefinition clipSelected
public MenuOption defaultOption
private bool isClosing
private CanvasGroup canvasGroup
public bool IsOpen
internal MenuOption selectedOption
private AnimationCurve easePunch
private Func`2<MenuOption, int> <>f__am$cache0
protected void Start()
public void Clear()
public void AddOption(MenuOption option)
public void FinishAndOpen()
protected void OnEnable()
public void SetDefaultOption()
public void PlayOpenSound()
public void PlayCancelSound()
public void Close(bool success)
private void Update()
public void Rebuild()
public void UpdateInteraction(bool allowLerp)
public bool DoSelect()
private int <Rebuild>m__0(MenuOption x)
}
public PieOption : MonoBehaviour {
public PieShape background
public Image imageIcon
public void UpdateOption(float startSlice, float sliceSize, float border, string optionTitle, float outerSize, float innerSize, float imageSize, Sprite sprite)
}
public PieShape : Graphic {
public float outerSize
public float innerSize
public float startRadius
public float endRadius
public float border
public bool debugDrawing
protected void OnPopulateMesh(VertexHelper vbo)
}
public PlaceDecorUniform : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public float ObjectDistance
public float ObjectDithering
public void Process(UInt32 seed)
}
public PlaceDecorValueNoise : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public NoiseParameters Cluster
public float ObjectDensity
public void Process(UInt32 seed)
}
public PlaceDecorWhiteNoise : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public float ObjectDensity
public void Process(UInt32 seed)
}
public PlacementTest : MonoBehaviour {
public MeshCollider myMeshCollider
public Transform testTransform
public Transform visualTest
public float hemisphere
public float clampTest
public float testDist
private float nextTest
public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset)
public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight, float maxHeight)
public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
private void Update()
public void OnDrawGizmos()
}
public PlaceMonument : ProceduralComponent {
public SpawnFilter Filter
public GameObjectRef Monument
private int Attempts
public void Process(UInt32 seed)
}
public PlaceMonuments : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public int Distance
public int MinSize
private int Candidates
private int Attempts
public void Process(UInt32 seed)
private bool CheckRadius(List`1<SpawnInfo> spawns, Vector3 pos, float radius)
}
public PlacePowerlineObjects : ProceduralComponent {
public BasicObject[] Start
public BasicObject[] End
public SideObject[] Side
public PathObject[] Path
public void Process(UInt32 seed)
}
public PlaceRiverObjects : ProceduralComponent {
public BasicObject[] Start
public BasicObject[] End
public SideObject[] Side
public PathObject[] Path
public void Process(UInt32 seed)
}
public PlaceRoadObjects : ProceduralComponent {
public BasicObject[] Start
public BasicObject[] End
public SideObject[] Side
public PathObject[] Path
public void Process(UInt32 seed)
}
public Planner : HeldEntity {
public BaseEntity[] buildableList
public bool isTypeDeployable
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ItemModDeployable GetModDeployable()
public Deployable GetDeployable()
public bool get_isTypeDeployable()
private void DoPlace(RPCMessage msg)
public Socket_Base FindSocket(string name, UInt32 prefabIDToFind)
public void DoBuild(CreateBuilding msg)
public void DoBuild(Target target, Construction component)
public GameObject DoPlacement(Target placement, Construction component)
public void PayForPlacement(BasePlayer player, Construction component)
public bool CanAffordToPlace(Construction component)
}
public PlantEntity : BaseCombatEntity {
public PlantProperties plantProperty
public int water
public int consumedWater
public State state
public float realAge
public float growthAge
private float stageAge
private float groundConditions
private float lightExposure
private int genetics
private int seasons
private int harvests
private Stage currentStage
public float stageAgeFraction
protected float thinkDeltaTime
protected float growDeltaTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private Stage get_currentStage()
public float get_stageAgeFraction()
public void ResetState()
public bool CanPick()
public float GetGrowthAge()
public float GetStageAge()
public float GetRealAge()
public bool CanClone()
public void ReceiveInstanceData(InstanceData data)
public float YieldBonusScale()
public void ServerInit()
public void Save(SaveInfo info)
public void RPC_TakeClone(RPCMessage msg)
public void RPC_PickFruit(RPCMessage msg)
public void Load(LoadInfo info)
private void BecomeState(State state, bool resetAge)
public bool SupportsPooling()
protected float get_thinkDeltaTime()
protected float get_growDeltaTime()
public void ResetSeason()
public string DebugText()
public void RefreshLightExposure()
public float CalculateArtificialLightExposure()
public float CalculateSunExposure()
private void RunUpdate()
private bool PlacedInPlanter()
private float Happiness()
private float Energy_Light()
private float Energy_Temperature()
private float Energy_Water()
private float GetTemperature()
public float WorkoutGroundConditions(Vector3 pos)
}
public PlanterBox : BaseCombatEntity {
public int soilSaturation
public int soilSaturationMax
public MeshRenderer soilRenderer
public float soilSaturationFraction
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float get_soilSaturationFraction()
public int UseWater(int amount)
public bool wantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
}
public PlantProperties : ScriptableObject {
public Stage[] stages
public AnimationCurve timeOfDayHappiness
public AnimationCurve temperatureHappiness
public AnimationCurve fruitCurve
public int maxSeasons
public int maxHeldWater
public int lifetimeWaterConsumption
public float waterConsumptionLifetime
public int waterYieldBonus
public Option pickOption
public ItemDefinition pickupItem
public int pickupAmount
public GameObjectRef pickEffect
public int maxHarvests
public bool disappearAfterHarvest
public Option cloneOption
public ItemDefinition cloneItem
public int maxClones
}
public PlayAudioEx : MonoBehaviour {
public float delay
private void Start()
private void OnEnable()
}
public PlayerBelt : object {
public int SelectedSlot
protected BasePlayer player
public int MaxBeltSlots
public void .ctor(BasePlayer player)
public int get_MaxBeltSlots()
public void DropActive(Vector3 velocity)
}
public PlayerBlueprints : EntityComponent`1<BasePlayer> {
public SteamInventory steamInventory
public void Reset()
public void UnlockAll()
public bool IsUnlocked(ItemDefinition itemDef)
public void Unlock(ItemDefinition itemDef)
public bool HasUnlocked(ItemDefinition targetItem)
public bool CanCraft(int itemid, int skinItemId)
}
public PlayerCorpse : LootableCorpse {
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void Save(SaveInfo info)
public string Categorize()
}
public PlayerEyes : EntityComponent`1<BasePlayer> {
public Vector3 EyeOffset
public Vector3 DuckOffset
public Vector3 thirdPersonSleepingOffset
public LazyAimProperties defaultLazyAim
private Vector3 viewOffset
public Quaternion rotation
public Quaternion headRotation
public Quaternion rotationLook
public Vector3 worldMountedPosition
public Vector3 worldStandingPosition
public Vector3 worldCrouchedPosition
public Vector3 position
public Vector3 center
public Vector3 get_worldMountedPosition()
public Vector3 get_worldStandingPosition()
public Vector3 get_worldCrouchedPosition()
public Vector3 get_position()
public Vector3 get_center()
public void NetworkUpdate(Quaternion rot)
public Ray BodyRay()
public Vector3 BodyForward()
public Vector3 BodyRight()
public Vector3 BodyUp()
public Ray HeadRay()
public Vector3 HeadForward()
public Vector3 HeadRight()
public Vector3 HeadUp()
}
public PlayerInput : EntityComponent`1<BasePlayer> {
public InputState state
public bool hadInputBuffer
protected void OnDisable()
}
public PlayerInventory : EntityComponent`1<BasePlayer> {
public ItemContainer containerMain
public ItemContainer containerBelt
public ItemContainer containerWear
public ItemCrafter crafting
public PlayerLoot loot
private Func`2<HeldEntity, float> <>f__am$cache0
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected void Initialize()
public void DoDestroy()
public void ServerInit(BasePlayer owner)
public void OnItemAddedOrRemoved(Item item, bool bAdded)
public void UpdatedVisibleHolsteredItems()
private void OnContentsDirty()
private bool CanMoveItemsFrom(BaseEntity entity, Item item)
private void ItemCmd(RPCMessage msg)
private void MoveItem(RPCMessage msg)
private void OnClothingChanged(Item item, bool bAdded)
private void OnItemRemoved(Item item)
private bool CanEquipItem(Item item, int targetSlot)
private bool CanWearItem(Item item, int targetSlot)
public void ServerUpdate(float delta)
public void UpdateContainer(float delta, Type type, ItemContainer container, bool bSendInventoryToEveryone, float temperature)
public void SendSnapshot()
public void SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone)
public Item FindItemUID(UInt32 id)
public Item FindItemID(string itemName)
public Item FindItemID(int id)
public List`1<Item> FindItemIDs(int id)
public ItemContainer FindContainer(UInt32 id)
public ItemContainer GetContainer(Type id)
public bool GiveItem(Item item, ItemContainer container)
protected void GetIdealPickupContainer(Item item, ItemContainer& container, Int32& position)
public void Strip()
public void GiveDefaultItems()
public PlayerInventory Save(bool bForDisk)
public void Load(PlayerInventory msg)
public int Take(List`1<Item> collect, int itemid, int amount)
public int GetAmount(int itemid)
public Item[] AllItems()
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public bool HasAmmo(AmmoTypes ammoType)
private float <UpdatedVisibleHolsteredItems>m__0(HeldEntity x)
}
public PlayerInventoryProperties : ScriptableObject {
public string niceName
public int order
public List`1<ItemAmount> belt
public List`1<ItemAmount> main
public List`1<ItemAmount> wear
public List`1<ItemAmountSkinned> skinnedWear
public void GiveToPlayer(BasePlayer player)
}
public PlayerLoot : EntityComponent`1<BasePlayer> {
public BaseEntity entitySource
public Item itemSource
public List`1<ItemContainer> containers
public bool PositionChecks
private bool isInvokingSendUpdate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsLooting()
public void Clear()
public ItemContainer FindContainer(UInt32 id)
public Item FindItem(UInt32 id)
public void Check()
public void MarkDirty()
public void SendImmediate()
private void SendUpdate()
public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks)
public void AddContainer(ItemContainer container)
public void StartLootingItem(Item item)
}
public PlayerMetabolism : BaseMetabolism`1<BasePlayer> {
public float HotThreshold
public float ColdThreshold
public MetabolismAttribute temperature
public MetabolismAttribute poison
public MetabolismAttribute radiation_level
public MetabolismAttribute radiation_poison
public MetabolismAttribute wetness
public MetabolismAttribute dirtyness
public MetabolismAttribute oxygen
public MetabolismAttribute bleeding
public MetabolismAttribute comfort
public MetabolismAttribute pending_health
public bool isDirty
private float lastConsumeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Reset()
public void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
internal bool HasChanged()
protected void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
public bool SignificantBleeding()
protected void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
private float DeltaHot()
private float DeltaCold()
private float DeltaWet()
public void UseHeart(float frate)
public void SendChangesToClient()
public bool CanConsume()
public void MarkConsumption()
public PlayerMetabolism Save()
public void Load(PlayerMetabolism s)
public MetabolismAttribute FindAttribute(Type type)
}
public PlayerModel : ListComponent`1<PlayerModel> {
protected int speed
protected int acceleration
protected int rotationYaw
protected int forward
protected int right
protected int up
protected int ducked
protected int grounded
protected int waterlevel
protected int attack
protected int attack_alt
protected int deploy
protected int reload
protected int throwWeapon
protected int holster
protected int aiming
protected int onLadder
protected int posing
protected int poseType
protected int relaxGunPose
protected int vehicle_aim_yaw
protected int vehicle_aim_speed
protected int leftFootIK
protected int rightFootIK
public BoxCollider collision
public GameObject censorshipCube
public GameObject censorshipCubeBreasts
public GameObject jawBone
public GameObject neckBone
public GameObject headBone
public SkeletonScale skeletonScale
public EyeController eyeController
public Transform[] SpineBones
public Transform leftFootBone
public Transform rightFootBone
public Vector3 rightHandTarget
public Vector3 leftHandTargetPosition
public Quaternion leftHandTargetRotation
public RuntimeAnimatorController DefaultHoldType
public RuntimeAnimatorController SleepGesture
public RuntimeAnimatorController WoundedGesture
public RuntimeAnimatorController CurrentGesture
public SkinSetCollection MaleSkin
public SkinSetCollection FemaleSkin
public SubsurfaceProfile subsurfaceProfile
public float voiceVolume
public float skinColor
public float skinNumber
public float meshNumber
public float hairNumber
public int skinType
public MovementSounds movementSounds
private Quaternion <LookAngles>k__BackingField
public bool IsFemale
public SkinSetCollection SkinSet
public Quaternion LookAngles
public bool get_IsFemale()
public SkinSetCollection get_SkinSet()
public Quaternion get_LookAngles()
public void set_LookAngles(Quaternion value)
}
public PlayerModelHair : MonoBehaviour {
public HairType type
private Dictionary`2<Renderer, RendererMaterials> materials
public Dictionary`2<Renderer, RendererMaterials> Materials
public Dictionary`2<Renderer, RendererMaterials> get_Materials()
private void CacheOriginalMaterials()
private void Setup(HairType type, HairSetCollection hair, int meshIndex, float typeNum, float dyeNum, MaterialPropertyBlock block)
public void Setup(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
public void GetRandomVariation(float hairNum, int typeIndex, int meshIndex, Single& typeNum, Single& dyeNum)
}
public PlayerModelHairCap : MonoBehaviour {
public HairCapMask hairCapMask
public void SetupHairCap(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
}
public PlayerModelSkin : MonoBehaviour {
public void Setup(SkinSetCollection skin, float materialNum, float meshNum)
}
public PlayerNameTag : MonoBehaviour {
public CanvasGroup canvasGroup
public Text text
public Gradient color
public float minDistance
public float maxDistance
public Vector3 positionOffset
public Transform parentBone
}
public PlayerStatistics : object {
public SteamStatistics steam
public ServerStatistics server
public CombatLog combat
public void .ctor(BasePlayer player)
public void Init()
public void Save()
public void Add(string name, int val, Stats stats)
}
public PlayerVoiceSpeaker : EntityComponent`1<BasePlayer> {
public AudioSource mouthSpeaker
}
public PlayerWalkMovement : BaseMovement {
public float WaterLevelHead
public float WaterLevelNeck
public PhysicMaterial zeroFrictionMaterial
public PhysicMaterial highFrictionMaterial
public float capsuleHeight
public float capsuleCenter
public float capsuleHeightDucked
public float capsuleCenterDucked
public float gravityTestRadius
public float gravityMultiplier
public float gravityMultiplierSwimming
public float maxAngleWalking
public float maxAngleClimbing
public float maxAngleSliding
}
public PooledList`1 : object {
public List`1<T> data
public void Alloc()
public void Free()
public void Clear()
}
public PositionLerp : ListComponent`1<PositionLerp> {
public bool DebugLog
public bool DebugDraw
private Action idleDisable
private TransformInterpolator interpolator
private ILerpTarget target
private float timeOffset0
private float timeOffset1
private float timeOffset2
private float timeOffset3
private float lastUpdate
private float extrapolatedTime
public void Initialize(ILerpTarget target)
public void Snapshot(Vector3 position, Quaternion rotation, float serverTime)
public void SnapTo(Vector3 position, Quaternion rotation, float serverTime)
public void SnapToEnd()
protected void DoCycle()
private void IdleDisable()
public void Cycle()
}
public PostOpaqueDepth : MonoBehaviour {
public RenderTexture postOpaqueDepth
public RenderTexture PostOpaque
public RenderTexture get_PostOpaque()
}
public PowerBar : MonoBehaviour {
public PowerBar Instance
public Image powerInner
public float fullSize
public CanvasGroup group
}
public PowerlineNode : MonoBehaviour {
public Material WireMaterial
public float MaxDistance
protected void Awake()
}
public Prefab : object {
public UInt32 ID
public string Name
public GameObject Object
public GameManager Manager
public Library Attribute
public PrefabParameters Parameters
public Library DefaultAttribute
public GameManager DefaultManager
public void .ctor(string name, GameObject prefab, GameManager manager, Library attribute)
public GameObject op_Implicit(Prefab prefab)
public int CompareTo(Prefab that)
public bool ApplyTerrainAnchors(Vector3& pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter)
public bool ApplyTerrainAnchors(Vector3& pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public bool ApplyTerrainChecks(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public bool ApplyTerrainFilters(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public void ApplyTerrainModifiers(Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyTerrainPlacements(Vector3 pos, Quaternion rot, Vector3 scale)
public bool ApplyWaterChecks(Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyDecorComponents(Vector3& pos, Quaternion& rot, Vector3& scale)
public bool CheckEnvironmentVolumes(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
public GameObject Spawn(Transform transform)
public GameObject Spawn(Vector3 pos, Quaternion rot)
public GameObject Spawn(Vector3 pos, Quaternion rot, Vector3 scale)
public BaseEntity SpawnEntity(Vector3 pos, Quaternion rot)
public Prefab`1<T> Load(UInt32 id, GameManager manager, Library attribute)
public Prefab[] Load(string folder, GameManager manager, Library attribute, bool useProbabilities)
public Prefab`1[] Load(string folder, GameManager manager, Library attribute, bool useProbabilities)
public Prefab`1[] Load(String[] names, GameManager manager, Library attribute)
public Prefab LoadRandom(string folder, UInt32& seed, GameManager manager, Library attribute, bool useProbabilities)
public Prefab`1<T> LoadRandom(string folder, UInt32& seed, GameManager manager, Library attribute, bool useProbabilities)
public Library get_DefaultAttribute()
public GameManager get_DefaultManager()
private String[] FindPrefabNames(string strPrefab, bool useProbabilities)
}
public Prefab`1 : Prefab {
public T Component
public void .ctor(string name, GameObject prefab, T component, GameManager manager, Library attribute)
public int CompareTo(Prefab`1<T> that)
}
public PrefabAttribute : MonoBehaviour {
public Vector3 worldPosition
public Quaternion worldRotation
public Vector3 worldForward
public Vector3 localPosition
public Vector3 localScale
public Quaternion localRotation
public string fullName
public string hierachyName
public UInt32 prefabID
public int instanceID
public Library prefabAttribute
public GameManager gameManager
public bool isServer
public Library server
public bool isClient
public bool get_isClient()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
public bool op_Equality(PrefabAttribute x, PrefabAttribute y)
public bool op_Inequality(PrefabAttribute x, PrefabAttribute y)
public bool Equals(object o)
public int GetHashCode()
public bool op_Implicit(PrefabAttribute exists)
internal bool ComparePrefabAttribute(PrefabAttribute x, PrefabAttribute y)
public string ToString()
}
public PrefabInfo : MonoBehaviour {
internal UInt32 prefabID
internal Behaviour[] behaviours
internal Rigidbody[] rigidbodies
internal Collider[] colliders
internal LODGroup[] lodgroups
internal Renderer[] renderers
internal ParticleSystem[] particles
internal Boolean[] behaviourStates
internal Boolean[] rigidbodyStates
internal Boolean[] colliderStates
internal Boolean[] lodgroupStates
internal Boolean[] rendererStates
public void EnterPool()
public void LeavePool()
public void Initialize()
public void SetBehaviourEnabled(bool state)
public void SetComponentEnabled(bool state)
}
public PrefabInfoEx : object {
public bool SupportsPooling(GameObject gameObject)
public void EnablePooling(GameObject gameObject, UInt32 prefabID)
public void AwakeFromInstantiate(GameObject gameObject)
}
public PrefabInformation : PrefabAttribute {
public ItemDefinition associatedItemDefinition
public Phrase title
public Phrase description
public Sprite sprite
protected Type GetIndexedType()
}
public PrefabInstantiate : MonoBehaviour {
public GameObjectRef Prefab
}
public PrefabParameters : MonoBehaviour {
public PrefabPriority Priority
public int Count
}
public PrefabPool : object {
public Stack`1<PrefabInfo> stack
public int Count
public int get_Count()
public void Push(PrefabInfo info)
public void Push(GameObject instance)
public GameObject Pop(Vector3 pos, Quaternion rot)
public void Clear()
}
public PrefabPoolCollection : object {
public Dictionary`2<UInt32, PrefabPool> storage
public void Push(GameObject instance)
public GameObject Pop(UInt32 id, Vector3 pos, Quaternion rot)
public void Clear()
}
public PrefabPreProcess : object {
public Type[] clientsideOnlyTypes
public Type[] serversideOnlyTypes
public bool isClientside
public bool isServerside
internal Dictionary`2<string, GameObject> prefabList
private List`1<Component> destroyList
private List`1<GameObject> cleanupList
public void .ctor(bool clientside, bool serverside)
public GameObject Find(string strPrefab)
public bool NeedsProcessing(GameObject go)
public bool ProcessObject(string name, GameObject go, bool isBundling, bool resetLocalTransform)
public void Process(string name, GameObject go)
public void AddPrefab(string name, GameObject go)
private void DestroyComponents(Type t, GameObject go, bool client, bool server)
private bool HasComponents(Transform transform)
private bool HasComponents(Transform transform, Type t)
public List`1<T> FindComponents(Transform transform)
public void FindComponents(Transform transform, List`1<T> list)
public List`1<Component> FindComponents(Transform transform, Type t)
public void FindComponents(Transform transform, List`1<Component> list, Type t)
public void RemoveComponent(Component c)
public void RemoveComponents(GameObject gameObj)
public void NominateForDeletion(GameObject gameObj)
private void RunCleanupQueue()
private void DoCleanup(GameObject go)
}
public PrefabPriority : Enum {
public int value__
public PrefabPriority Lowest
public PrefabPriority Low
public PrefabPriority Default
public PrefabPriority High
public PrefabPriority Highest
}
public PressButton : IOEntity {
public float pressDuration
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public void PostServerLoad()
public void Press(RPCMessage msg)
public void Unpress()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ProceduralComponent : MonoBehaviour {
public Realm Mode
public string Description
public bool RunOnCache
public bool get_RunOnCache()
public bool ShouldRun()
public void Process(UInt32 seed)
}
public ProceduralLift : BaseEntity {
public float movementSpeed
public float resetDelay
public ProceduralLiftCabin cabin
public ProceduralLiftStop[] stops
private int floorIndex
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void RPC_UseLift(RPCMessage rpc)
public void ServerInit()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
private void ResetLift()
private void MoveToFloor(int floor)
private void SnapToFloor(int floor)
private void OnFinishedMoving()
protected void Update()
}
public ProceduralObject : MonoBehaviour {
protected void Awake()
public void Process()
}
public ProcessedTexture : object {
protected RenderTexture result
protected Material material
public void Dispose()
protected RenderTexture CreateRenderTexture(string name, int width, int height, bool linear)
protected void DestroyRenderTexture(RenderTexture& rt)
protected RenderTexture CreateTemporary()
protected void ReleaseTemporary(RenderTexture rt)
protected Material CreateMaterial(string shader)
protected Material CreateMaterial(Shader shader)
protected void DestroyMaterial(Material& mat)
public Texture op_Implicit(ProcessedTexture t)
}
public ProcessProceduralObjects : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public Profile : object {
public Stopwatch watch
public string category
public string name
public float warnTime
public void .ctor(string cat, string nam, float WarnTime)
public void Start()
public void Stop()
}
public ProgressBar : UIBehaviour {
public ProgressBar Instance
private Action`1<BasePlayer> action
private float timeFinished
private float timeCounter
public GameObject scaleTarget
public Image progressField
public Image iconField
public Text leftField
public Text rightField
public SoundDefinition clipOpen
public SoundDefinition clipCancel
public bool IsOpen
}
public ProgressDoor : IOEntity {
public float storedEnergy
public float energyForOpen
public float secondsToClose
public float openProgress
public void ResetIOState()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public void NoEnergy()
public void AddEnergy(float amount)
public void UpdateProgress()
}
public Projectile : BaseMonoBehaviour {
public float lifeTime
public Vector3 initialVelocity
public float drag
public float gravityModifier
public float thickness
public float initialDistance
public bool remainInWorld
public float stickProbability
public float breakProbability
public float conditionLoss
public float ricochetChance
public float penetrationPower
public DamageProperties damageProperties
public MinMax damageDistances
public MinMax damageMultipliers
public List`1<DamageTypeEntry> damageTypes
public ScaleRenderer rendererToScale
public ScaleRenderer firstPersonRenderer
public bool createDecals
public SoundDefinition flybySound
public float flybySoundDistance
public SoundDefinition closeFlybySound
public float closeFlybyDistance
public float tumbleSpeed
public Vector3 tumbleAxis
public BasePlayer owner
public AttackEntity sourceWeaponPrefab
public Projectile sourceProjectilePrefab
public ItemModProjectile mod
public int projectileID
public int seed
public bool clientsideEffect
public bool clientsideAttack
public float integrity
public float maxDistance
public Modifier modifier
public bool invisible
private UInt32 _fleshMaterialID
private UInt32 _waterMaterialID
private UInt32 cachedWaterString
public void CalculateDamage(HitInfo info, Modifier mod, float scale)
public UInt32 FleshMaterialID()
public UInt32 WaterMaterialID()
public bool IsWaterMaterial(string hitMaterial)
}
public ProjectileWeaponInformationPanel : ItemInformationPanel {
public ItemStatValue damageDisplay
public ItemStatValue recoilDisplay
public ItemStatValue rofDisplay
public ItemStatValue accuracyDisplay
public ItemStatValue rangeDisplay
}
public ProjectileWeaponMod : BaseEntity {
public GameObjectRef defaultSilencerEffect
public bool isSilencer
public Modifier repeatDelay
public Modifier projectileVelocity
public Modifier projectileDamage
public Modifier projectileDistance
public Modifier aimsway
public Modifier aimswaySpeed
public Modifier recoil
public Modifier sightAimCone
public Modifier hipAimCone
public bool isLight
public bool isMuzzleBrake
public bool isMuzzleBoost
public bool isScope
public float zoomAmountDisplayOnly
public bool needsOnForEffects
private Func`2<ProjectileWeaponMod, bool> <>f__am$cache0
private Func`2<Modifier, bool> <>f__am$cache1
private Func`2<ProjectileWeaponMod, bool> <>f__am$cache2
public void ServerInit()
public void PostServerLoad()
public float Sum(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Average(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Max(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Min(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public IEnumerable`1<float> GetMods(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value)
public bool HasBrokenWeaponMod(BaseEntity parentEnt)
private bool <GetMods>m__0(ProjectileWeaponMod x)
private bool <GetMods>m__1(Modifier x)
private bool <HasBrokenWeaponMod>m__2(ProjectileWeaponMod x)
}
public ProtectionProperties : ScriptableObject {
public string comments
public float density
public Single[] amounts
public void OnValidate()
public void Clear()
public void Add(float amount)
public void Add(DamageType index, float amount)
public void Add(ProtectionProperties other, float scale)
public void Add(List`1<Item> items, HitArea area)
public void Multiply(float multiplier)
public void Multiply(DamageType index, float multiplier)
public void Scale(DamageTypeList damageList, float ProtectionAmount)
public float Get(DamageType damageType)
}
public ProtectionValue : MonoBehaviour {
public CanvasGroup group
public Text text
public DamageType damageType
public bool selectedItem
public bool displayBaseProtection
}
public PuzzleReset : FacepunchBehaviour {
public SpawnGroup[] respawnGroups
public bool playersBlockReset
public float playerDetectionRadius
public Transform playerDetectionOrigin
public float timeBetweenResets
public bool scaleWithServerPopulation
public float GetResetSpacing()
public void Start()
public void ResetTimer()
public bool PassesResetCheck()
public void TimedReset()
public void DoReset()
public void ResetIOEntRecursive(IOEntity target, int resetIndex)
}
public QueryVis : BaseMonoBehaviour {
public Collider checkCollider
private Query query
public RadiusSpace coverageRadiusSpace
public float coverageRadius
}
public QuickCraft : MonoBehaviour {
public GameObjectRef craftButton
public GameObject empty
}
public QuickCraftButton : MonoBehaviour {
public Image icon
public Tooltip tooltip
public Text CraftCount
}
public RadialSpawnPoint : BaseSpawnPoint {
public float radius
public void GetLocation(Vector3& pos, Quaternion& rot)
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
}
public RadiationOverlay : ImageEffectLayer {
public SoundDefinition[] geigerSounds
private Sound sound
private ColorCorrectionCurves colourCorrection
private NoiseAndGrain noiseAndGrain
}
public RadixSorter : object {
private UInt32[] histogram
private UInt32[] offset
public void SortU8(UInt32[] values, UInt32[] remap, UInt32 num)
public void SortU24(UInt32[] values, UInt32[] remap, UInt32[] remapTemp, UInt32 num)
}
public Ragdoll : BaseMonoBehaviour {
public Transform eyeTransform
public Transform centerBone
public Rigidbody primaryBody
public PhysicMaterial physicMaterial
public SpringJoint corpseJoint
public GameObject GibEffect
}
public RagdollEditor : SingletonComponent`1<RagdollEditor> {
private Vector3 view
private Rigidbody grabbedRigid
private Vector3 grabPos
private Vector3 grabOffset
private void OnGUI()
protected void Awake()
private void Update()
private void FixedUpdate()
private void StartGrab()
private void UpdateGrab()
private void StopGrab()
}
public RainSurfaceAmbience : MonoBehaviour {
public float tickRate
public float gridSize
public float gridSamples
public float startHeight
public float rayLength
public LayerMask layerMask
public float spreadScale
public float maxDistance
public float lerpSpeed
public List`1<SurfaceSound> surfaces
}
public RandomDestroy : MonoBehaviour {
public UInt32 Seed
public float Probability
protected void Start()
}
public RandomDynamicObject : MonoBehaviour {
public UInt32 Seed
public float Distance
public float Probability
public GameObject[] Candidates
}
public RandomDynamicPrefab : MonoBehaviour {
public UInt32 Seed
public float Distance
public float Probability
public string ResourceFolder
}
public RandomParameterNumber : StateMachineBehaviour {
public string parameterName
public int min
public int max
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public RandomParameterNumberFloat : StateMachineBehaviour {
public string parameterName
public int min
public int max
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public RandomStaticObject : MonoBehaviour {
public UInt32 Seed
public float Probability
public GameObject[] Candidates
protected void Start()
}
public RandomStaticPrefab : MonoBehaviour {
public UInt32 Seed
public float Probability
public string ResourceFolder
protected void Start()
}
public RawWriter : object {
public void Write(IEnumerable`1<byte> data, string path)
public void Write(IEnumerable`1<int> data, string path)
public void Write(IEnumerable`1<short> data, string path)
public void Write(IEnumerable`1<float> data, string path)
}
public RaycastHitEx : object {
public Transform GetTransform(RaycastHit hit)
public Rigidbody GetRigidbody(RaycastHit hit)
public Collider GetCollider(RaycastHit hit)
public BaseEntity GetEntity(RaycastHit hit)
}
public ReactiveTarget : DecayEntity {
public Animator myAnimator
public GameObjectRef bullseyeEffect
public GameObjectRef knockdownEffect
private float lastToggleTime
private float knockdownHealth
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnHitShared(HitInfo info)
public bool IsKnockedDown()
public void OnAttacked(HitInfo info)
public bool CanPickup(BasePlayer player)
public bool CanToggle()
public void QueueReset()
public void ResetTarget()
public void RPC_Reset(RPCMessage msg)
public void RPC_Lower(RPCMessage msg)
}
public RealmedCollider : BasePrefab {
public Collider ServerCollider
public Collider ClientCollider
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public RealmedNavMeshObstacle : BasePrefab {
public NavMeshObstacle Obstacle
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public RealmedRemove : MonoBehaviour {
public GameObject[] removedFromClient
public Component[] removedComponentFromClient
public GameObject[] removedFromServer
public Component[] removedComponentFromServer
public Component[] doNotRemoveFromServer
public Component[] doNotRemoveFromClient
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool ShouldDelete(Component comp, bool client, bool server)
}
public RecoilProperties : ScriptableObject {
public float recoilYawMin
public float recoilYawMax
public float recoilPitchMin
public float recoilPitchMax
public float timeToTakeMin
public float timeToTakeMax
public float ADSScale
public float movementPenalty
public float clampPitch
public AnimationCurve pitchCurve
public AnimationCurve yawCurve
public bool useCurves
public int shotsUntilMax
}
public Recycler : StorageContainer {
public float recycleEfficiency
public SoundDefinition grindingLoopDef
public GameObjectRef startSound
public GameObjectRef stopSound
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void SVSwitch(RPCMessage msg)
public bool MoveItemToOutput(Item newItem)
public bool HasRecyclable()
public void RecycleThink()
public void StartRecycling()
public void StopRecycling()
public bool SupportsPooling()
}
public ReflectionProbeEx : MonoBehaviour {
private UInt32[0...,0...] qualitySamples
private Vector4[] sampleData
public ReflectionProbeRefreshMode refreshMode
public bool timeSlicing
public int resolution
public bool hdr
public float shadowDistance
public ReflectionProbeClearFlags clearFlags
public Color background
public float nearClip
public float farClip
public Transform attachToTarget
public Light directionalLight
public float textureMipBias
public bool highPrecision
public ConvolutionQuality convolutionQuality
public List`1<RenderListEntry> staticRenderList
public Cubemap reflectionCubemap
public float reflectionIntensity
private List`1<RenderListEntry> dynamicRenderList
private ReflectionProbe probe
private RenderTexture probeTexture
private int probeResolution
private bool probeHdr
private float probeNearClip
private float probeFarClip
private int probeDepth
private bool probeHighPrecision
private TimeSlicingState timeSlicedRenderState
private bool scriptingRenderQueued
private Matrix4x4 faceProjMatrix
private Matrix4x4 faceProjInvMatrix
private int prevFrame
private ReflectionProbeRefreshMode savedProbeRefresh
private ReflectionProbeMode savedProbeMode
private Texture savedProbeCustomTexture
private Mesh blitMesh
private Mesh skyboxMesh
private Single[] octaVerts
private CubemapFaceMatrices[] cubemapFaceMatrices
private CubemapFaceMatrices[] cubemapFaceMatricesD3D11
private CubemapFaceMatrices[] shadowCubemapFaceMatrices
private CubemapFaceMatrices[] platformCubemapFaceMatrices
private HashSet`1<string> supportedShaderNames
private Dictionary`2<Shader, Shader> supportedShaders
private Dictionary`2<Material, Material> matchingMaterials
private RenderTexture probeTempTexture
private RenderTexture probeShadowTexture
private RenderTexture arrayTexture
private RenderTexture arrayTempTexture
private RenderTexture arrayDepthTexture
private int mipmapCount
private Material blitMaterial
private Material downsampleMaterial
private Material filterMaterial
private Material shadowMaterial
private CommandBuffer forwardCB
private CommandBuffer shadowCB
private Matrix4x4[] viewProjMatrixArray
private Matrix4x4[] objectToWorldArray
private Matrix4x4[] cameraToWorldArray
private Int32[] tab32
public RenderTexture Texture
private Vector2 Hammersley(UInt32 index, UInt32 numSamples)
private float D_GGX(float roughness, float NdotH)
private Vector3 ImportanceSampleGGX(Vector2 Xi, float roughness)
private void GenerateMips(Texture target)
private void ApplyConvolution(Texture target)
public RenderTexture get_Texture()
public void ClearRenderList()
public void AddToRenderList(Renderer renderer, bool alwaysEnabled)
private void Awake()
private void OnEnable()
private void OnDisable()
private void OnCameraPreRender(Camera cam)
public void RenderProbe()
public bool IsFinishedRendering()
private void ModifyProbeProperties()
private void RestoreProbeSettings()
private bool CheckUpdateCaptureSettings(Int32& resolution, Boolean& hdr, Single& nearClip, Single& farClip)
private bool UpdateProperties()
private void CreateMeshes()
private void DestroyMeshes()
private Mesh CreateBlitMesh()
private CubemapSkyboxVertex SubDivVert(CubemapSkyboxVertex v1, CubemapSkyboxVertex v2)
private void Subdivide(List`1<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
private void SubdivideYOnly(List`1<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
private Mesh CreateSkyboxMesh()
private bool InitializeCubemapFaceMatrices()
private void CreateTextures()
private void DestroyTextures()
private Material RegisterMaterialReplacement(Material material)
private Material FindMaterialReplacement(Material material)
private void CreateMaterials()
private void DestroyMaterials()
private void CreateCommandBuffers()
private void DestroyCommandBuffers()
private void ClearCommandBuffers()
private void AttachToLight()
private void DetachFromLight()
private void FindEnvironmentReflection()
private void BindGlobalProperties()
private void BindGlobalLight()
private void BindGlobalAmbient()
private void BindGlobalReflection()
private void RenderObjects()
private void RenderSkybox()
private void IssueRender()
private void IssueGenerateMips()
private void IssueConvolution()
private void IssueShadow()
private void PrepareFullRender()
private void PrepareTimeSlicedRender(TimeSlicingState state)
private void ExecuteRender()
private int FastLog2(int value)
private UInt32 ReverseBits(UInt32 bits)
private void SafeCreateMaterial(Material& mat, Shader shader)
private void SafeCreateMaterial(Material& mat, string shaderName)
private void SafeCreateCubeRT(RenderTexture& rt, string name, int size, int depth, bool mips, TextureDimension dim, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite)
private void SafeCreateCB(CommandBuffer& cb, string name)
private void SafeDestroy(T& obj)
private void SafeDispose(T& obj)
}
public RelationshipManager : BaseEntity {
public int maxTeamSize
public RelationshipManager _instance
public Dictionary`2<ulong, BasePlayer> cachedPlayers
public Dictionary`2<ulong, PlayerTeam> playerTeams
private ulong lastTeamIndex
public RelationshipManager Instance
public RelationshipManager get_Instance()
public void OnEnable()
public void OnDestroy()
public void Save(SaveInfo info)
public void DisbandTeam(PlayerTeam teamToDisband)
public BasePlayer FindByID(ulong userID)
public PlayerTeam FindTeam(ulong TeamID)
public PlayerTeam CreateTeam()
public void trycreateteam(Arg arg)
public void promote(Arg arg)
public void leaveteam(Arg arg)
public void acceptinvite(Arg arg)
public void rejectinvite(Arg arg)
public BasePlayer GetLookingAtPlayer(BasePlayer source)
public void sleeptoggle(Arg arg)
public void kickmember(Arg arg)
public void sendinvite(Arg arg)
public void fakeinvite(Arg arg)
public void addtoteam(Arg arg)
public bool TeamsEnabled()
public void Load(LoadInfo info)
}
public RenameSleepingBag : UIDialog {
public InputField input
public SleepingBag bag
}
public RendererGrid : SingletonComponent`1<RendererGrid> {
public bool Paused
public float CellSize
public float MaxMilliseconds
}
public RendererLOD : LODComponent {
public State[] States
}
public RepairBench : StorageContainer {
public float maxConditionLostOnRepair
public GameObjectRef skinchangeEffect
private float nextSkinChangeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float GetRepairFraction(Item itemToRepair)
public float RepairCostFraction(Item itemToRepair)
public List`1<ItemAmount> GetRepairCostList(ItemBlueprint bp)
public void debugprint(string toPrint)
public void ChangeSkin(RPCMessage msg)
public void RepairItem(RPCMessage msg)
public bool SupportsPooling()
}
public RepairBenchPanel : LootPanel {
public Text infoText
public Button repairButton
public Color gotColor
public Color notGotColor
public Phrase phraseEmpty
public Phrase phraseNotRepairable
public Phrase phraseRepairNotNeeded
public Phrase phraseNoBlueprint
public GameObject skinsPanel
public GameObject changeSkinDialog
public IconSkinPicker picker
}
public ResearchTable : StorageContainer {
public float researchFinishedTime
public float researchCostFraction
public float researchDuration
public int requiredPaper
public GameObjectRef researchStartEffect
public GameObjectRef researchFailEffect
public GameObjectRef researchSuccessEffect
public ItemDefinition researchResource
public BasePlayer user
public ItemDefinition blueprintBaseDef
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public bool IsResearching()
public int RarityMultiplier(Rarity rarity)
public int GetBlueprintStacksize(Item sourceItem)
public int ScrapForResearch(Item item)
public bool IsItemResearchable(Item item)
public void ServerInit()
public bool ItemFilter(Item item, int targetSlot)
public Item GetTargetItem()
public Item GetScrapItem()
public void PostServerLoad()
public bool PlayerOpenLoot(BasePlayer player)
public void PlayerStoppedLooting(BasePlayer player)
public void DoResearch(RPCMessage msg)
public ItemDefinition GetBlueprintTemplate()
public void ResearchAttemptFinished()
public void CancelResearch()
public void EndResearch()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool SupportsPooling()
}
public ResearchTablePanel : LootPanel {
public Button researchButton
public Text timerText
public GameObject itemDescNoItem
public GameObject itemDescTooBroken
public GameObject itemDescNotResearchable
public GameObject itemDescTooMany
public GameObject itemTakeBlueprint
public Text successChanceText
public ItemIcon scrapIcon
public bool wasResearching
public GameObject[] workbenchReqs
}
public ResourceContainer : EntityComponent`1<BaseEntity> {
public bool lootable
public ItemContainer container
public float lastAccessTime
public int accessedSecondsAgo
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int get_accessedSecondsAgo()
private void StartLootingContainer(RPCMessage msg)
}
public ResourceDepositManager : BaseEntity {
public ResourceDepositManager _manager
private int resolution
public Dictionary`2<Vector2i, ResourceDeposit> _deposits
public Vector2i GetIndexFrom(Vector3 pos)
public ResourceDepositManager Get()
public ResourceDeposit CreateFromPosition(Vector3 pos)
public ResourceDeposit GetFromPosition(Vector3 pos)
public ResourceDeposit GetOrCreate(Vector3 pos)
}
public ResourceDispenser : EntityComponent`1<BaseEntity> {
public GatherType gatherType
public List`1<ItemAmount> containedItems
public float maxDestroyFractionForFinishBonus
public List`1<ItemAmount> finishBonus
public float fractionRemaining
private float categoriesRemaining
private float startingItemCounts
private Func`2<ItemAmount, float> <>f__am$cache0
private Func`2<ItemAmount, float> <>f__am$cache1
private Func`2<ItemAmount, float> <>f__am$cache2
public void Start()
public void Initialize()
public void DoGather(HitInfo info)
public void AssignFinishBonus(BasePlayer player, float fraction)
public void OnAttacked(HitInfo info)
private void GiveResources(BaseEntity entity, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
public void DestroyFraction(float fraction)
private void GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
public bool OverrideOwnership(Item item, AttackEntity weapon)
private void UpdateVars()
public void UpdateRemainingCategories()
public void CountAllItems()
private void UpdateFraction()
private float <CountAllItems>m__0(ItemAmount x)
private float <UpdateFraction>m__1(ItemAmount x)
private float <UpdateFraction>m__2(ItemAmount x)
}
public ResourceEntity : BaseEntity {
public float startHealth
public ProtectionProperties baseProtection
protected float health
internal ResourceDispenser resourceDispenser
protected bool isKilled
public void Load(LoadInfo info)
public void InitShared()
public void ServerInit()
public void Save(SaveInfo info)
public float MaxHealth()
public float Health()
protected void OnHealthChanged()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public float BoundsPadding()
public bool SupportsPooling()
}
public ResourceExtractorFuelStorage : StorageContainer {
public bool SupportsPooling()
}
public ResourceRef`1 : object {
public string guid
private Object _cachedObject
public bool isValid
public string resourcePath
public UInt32 resourceID
public bool get_isValid()
public T Get()
public string get_resourcePath()
public UInt32 get_resourceID()
}
public ReverbSettings : ScriptableObject {
public int room
public int roomHF
public int roomLF
public float decayTime
public float decayHFRatio
public int reflections
public float reflectionsDelay
public int reverb
public float reverbDelay
public float HFReference
public float LFReference
public float diffusion
public float density
}
public ReverbZoneTrigger : TriggerBase {
public Collider trigger
public AudioReverbZone reverbZone
public float lodDistance
public bool inRange
public ReverbSettings reverbSettings
public void PreClientComponentCull(IPrefabProcessor p)
}
public RHIB : MotorRowboat {
public GameObject steeringWheel
public float rhibpopulation
private float targetGasPedal
public void VehicleFixedUpdate()
public bool EngineOn()
public bool HasFuel(bool forceCheck)
public bool UseFuel(float seconds)
public void DriverInput(InputState inputState, BasePlayer player)
}
public RHIBAIController : FacepunchBehaviour {
public List`1<Vector3> nodes
public void SetupPatrolPath()
public float GetWaterDepth(Vector3 pos)
public void OnDrawGizmosSelected()
}
public RigidbodyLOD : LODComponent {
public float Distance
}
public RiverInfo : MonoBehaviour {
protected void Awake()
}
public RotateCameraAroundObject : MonoBehaviour {
public GameObject m_goObjectToRotateAround
public float m_flRotateSpeed
private void FixedUpdate()
}
public RotateObject : MonoBehaviour {
public float rotateSpeed_X
public float rotateSpeed_Y
public float rotateSpeed_Z
private void Update()
}
public RotateToCamera : MonoBehaviour {
public float maxDistance
}
public rottest : MonoBehaviour {
public Transform turretBase
public Vector3 aimDir
private void Start()
private void Update()
public void UpdateAiming()
}
public RottingFlies : MonoBehaviour {
public GameObjectRef effect
public SoundDefinition soundDef
public Transform rootBone
}
public RunConsoleCommand : MonoBehaviour {
public void ClientRun(string command)
}
public Rust.Ai.AggressionRangeFromTargetEntity : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.AiAnswer_ShareEnemyTarget : ValueType {
private NPCPlayerApex <Source>k__BackingField
public BasePlayer PlayerTarget
public Nullable`1<Vector3> LastKnownPosition
public NPCPlayerApex Source
public NPCPlayerApex get_Source()
public void set_Source(NPCPlayerApex value)
}
public Rust.Ai.AiLocationManager : FacepunchBehaviour {
public List`1<AiLocationManager> Managers
public AiLocationSpawner MainSpawner
public SquadSpawnerLocation LocationWhenMainSpawnerIsNull
public Transform CoverPointGroup
public Transform PatrolPointGroup
private List`1<PathInterestNode> patrolPoints
public SquadSpawnerLocation LocationType
public SquadSpawnerLocation get_LocationType()
private void Awake()
private void OnDestroy()
public PathInterestNode GetFirstPatrolPointInRange(Vector3 from, float minRange, float maxRange)
public PathInterestNode GetRandomPatrolPointInRange(Vector3 from, float minRange, float maxRange, PathInterestNode currentPatrolPoint)
}
public Rust.Ai.AiLocationSpawner : SpawnGroup {
public SquadSpawnerLocation Location
public AiLocationManager Manager
public JunkPile Junkpile
public bool IsMainSpawner
public float chance
private int defaultMaxPopulation
private int defaultNumToSpawnPerTickMax
private int defaultNumToSpawnPerTickMin
public void SpawnInitial()
protected void Spawn(int numToSpawn)
protected BaseSpawnPoint GetSpawnPoint(Vector3& pos, Quaternion& rot)
}
public Rust.Ai.AiManagedAgent : FacepunchBehaviour {
public int AgentTypeIndex
public Vector2i NavmeshGridCoord
private IAIAgent agent
private bool isRegistered
private void OnEnable()
private void DelayedRegistration()
private void OnDisable()
}
public Rust.Ai.AiManager : SingletonComponent`1<AiManager> {
private HashSet`1<IAIAgent> activeAgents
private List`1<IAIAgent> dormantAgents
private HashSet`1<IAIAgent> pendingAddToActive
private HashSet`1<IAIAgent> pendingAddToDormant
private HashSet`1<IAIAgent> pendingRemoveFromActive
private HashSet`1<IAIAgent> pendingRemoveFromDormant
private int lastWakeUpDormantIndex
public bool UseCover
public float CoverPointVolumeCellSize
public float CoverPointVolumeCellHeight
public float CoverPointRayLength
public CoverPointVolume cpvPrefab
public LayerMask DynamicCoverPointVolumeLayerMask
private WorldSpaceGrid`1<CoverPointVolume> coverPointVolumeGrid
public bool nav_wait
public bool nav_disable
public bool nav_grid
public bool ai_dormant
public bool nav_grid_kill_dormant_cells
public int nav_grid_max_bakes_per_frame
public int nav_grid_max_links_generated_per_frame
public bool nav_grid_links_enabled
public bool nav_grid_rebake_cells_enabled
public bool nav_grid_agents_expand_domain_enabled
public float nav_grid_rebake_cooldown
public int nav_grid_cell_width
public int nav_grid_cell_height
public int pathfindingIterationsPerFrame
public float ai_to_player_distance_wakeup_range
public int nav_obstacles_carve_state
public int ai_dormant_max_wakeup_per_tick
private BasePlayer[] playerVicinityQuery
private Func`2<BasePlayer, bool> filter
public bool UseIntensity
public float IntensityCellSize
public AnimationCurve HitResponse
public float hitResponseOutputMultiplier
public AnimationCurve HurtResponse
public float maxHurtResponseInput
public float hurtResponseOutputMultiplier
public float OnDeathIntensityBonus
public float IntensityDecayRate
public float NoEngagementToDecayTime
public float DebugIntensityHeightMultiplier
public Color DebugMinColor
public Color DebugMaxColor
private WorldSpaceGrid`1<EngagementInfo> intensityGrid
public bool UseNavMesh
public LayerMask LayerMask
public NavMeshCollectGeometry NavMeshCollectGeometry
public float CellTimeoutThreshold
public GameObjectRef NavMeshLinkPrefab
internal WorldSpaceGrid`1<NavMeshGridCell> NavMeshGrid
private Dictionary`2<int, NavMeshLinkInfo> AgentLinks
internal PrefabPool LinkPool
internal int NumCellsCurrentlyBaking
internal int NumLinksCurrentlyGenerating
private BinaryHeap`1<BakeInfo> bakeHeap
public Vector2i[] Directions
private Func`2<BasePlayer, bool> <>f__mg$cache0
public bool repeat
internal void OnEnableAgency()
internal void OnDisableAgency()
public void Add(IAIAgent agent)
internal void InternalAdd(IAIAgent agent)
internal void InternalAddPlusAdjacents(IAIAgent agent)
internal void UpdateAgentSurroundings()
public void Remove(IAIAgent agent)
internal void AddActiveAgency(IAIAgent agent)
internal void AddDormantAgency(IAIAgent agent)
internal void RemoveActiveAgency(IAIAgent agent)
internal void RemoveDormantAgency(IAIAgent agent)
internal void UpdateAgency()
private void AgencyCleanup()
private void AgencyAddPending()
private void TryWakeUpDormantAgents()
private void TryMakeAgentsDormant()
internal void ForceAgentsDormant(Vector2i coord)
internal void OnEnableCover()
internal void OnDisableCover()
public CoverPointVolume CreateNewCoverVolume(Vector3 point, Transform coverPointGroup)
public CoverPointVolume GetCoverVolumeContaining(Vector3 point)
public bool get_repeat()
public void Initialize()
private void OnDisable()
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
private bool IsAgentCloseToPlayers(IAIAgent agent)
private bool InterestedInPlayersOnly(BaseEntity entity)
private bool IsCoordCloseToPlayers(Vector2i coord)
internal void OnEnableIntensity()
internal void OnDisableIntensity()
public void UpdateIntensityGridCellLifetimes()
public void OnHit(HitInfo info)
private float fearEstimate(BasePlayer initiator, BaseCombatEntity victim)
internal void OnEnableNavMeshGrid()
internal void OnDisableNavMeshGrid()
internal NavMeshAddResult NavMeshAddAgent(IAIAgent agent, Action`1<IAIAgent> onAsyncDoneCallback)
internal NavMeshAddResult NavMeshAddAtCoord(IAIAgent agent, Vector2i coord, float y, int agentTypeIndex)
private void OnNavMeshBuildDoneCallback(Layer layer, IAIAgent agent, NavMeshGridCell cell, Action`1<IAIAgent> onAsyncDoneCallback)
internal void UpdateNavMeshGridCell()
private void TryBake()
private void TryGenerateLinks()
private void UpdateCellTimeouts()
private void UpdateCellPlayerTimestamps()
private void TryQueueCellRebakes()
private void DecreaseNumCellsCurrentlyBaking(Layer layer)
private void DecreaseNumCellsCurrentlyBaking()
private IEnumerator LinkGeneration(IAIAgent agent, NavMeshGridCell cell)
public bool HasReadyNeighbour(Vector2i coord, Vector2i direction)
private void RemoveAgentLinkReference(IAIAgent agent, bool removeAgentFromCache)
private void RemoveAgentLinkReference(IAIAgent agent, NavMeshLinkInfo info, bool removeAgentFromCache)
internal bool HasActiveAgents(NavMeshGridCell cell)
public Vector2i GetCoord(Vector3 position)
public bool IsAnyNavmeshBuilding(Vector3 position)
public bool IsAnyNavmeshBuilding(Vector2i coord)
public bool IsNavmeshBuilding(int agentTypeIndex, Vector3 position)
public bool IsNavmeshBuilding(int agentTypeIndex, Vector2i coord)
public bool IsNavmeshBuilding(Layer layer)
public bool IsCoordEqualOrAdjacentToOther(Vector2i coord, Vector2i other)
}
public Rust.Ai.AimingAtPoint : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext context, Vector3 position)
}
public Rust.Ai.AimingAtTarget : BaseScorer {
public float arc
public bool PerfectKnowledge
public float GetScore(BaseContext c)
}
public Rust.Ai.AiStatement_EnemyEngaged : ValueType {
public BasePlayer Enemy
public float Score
public Nullable`1<Vector3> LastKnownPosition
}
public Rust.Ai.AiStatement_EnemySeen : ValueType {
public BasePlayer Enemy
public float Score
public Nullable`1<Vector3> LastKnownPosition
}
public Rust.Ai.AllowBreaking : BaseAction {
public bool Allow
public void DoExecute(BaseContext c)
}
public Rust.AI.AStarNode : object {
public AStarNode Parent
public float G
public float H
public BasePathNode Node
public float F
public void .ctor(float g, float h, AStarNode parent, BasePathNode node)
public float get_F()
public void Update(float g, float h, AStarNode parent, BasePathNode node)
public bool Satisfies(BasePathNode node)
public bool op_LessThan(AStarNode lhs, AStarNode rhs)
public bool op_GreaterThan(AStarNode lhs, AStarNode rhs)
}
public Rust.AI.AStarNodeList : List`1<AStarNode> {
private AStarNodeComparer comparer
public bool Contains(BasePathNode n)
public AStarNode GetAStarNodeOf(BasePathNode n)
public void AStarNodeSort()
}
public Rust.AI.AStarPath : object {
private float Heuristic(BasePathNode from, BasePathNode to)
public bool FindPath(BasePathNode start, BasePathNode goal, Stack`1& path, Single& pathCost)
}
public Rust.Ai.AtDestinationFor : BaseScorer {
public float Duration
public float GetScore(BaseContext c)
}
public Rust.Ai.AtDestinationForRandom : BaseScorer {
public float MinDuration
public float MaxDuration
public float GetScore(BaseContext c)
}
public Rust.Ai.AttackOperator : BaseAction {
public AttackType Type
public AttackTargetType Target
public void DoExecute(BaseContext c)
public void AttackEnemy(BaseContext c, AttackType type)
}
public Rust.Ai.AttackReady : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.AverageSumOfChildren : CompositeQualifier {
private bool normalize
private float postNormalizeMultiplier
private float MaxAverageScore
private bool FailIfAnyScoreZero
public float Score(IAIContext context, IList`1<IContextualScorer> scorers)
}
public Rust.Ai.BaseAction : ActionBase {
private string DebugName
public void Execute(IAIContext context)
public void DoExecute(BaseContext context)
}
public Rust.Ai.BaseActionWithOptions`1 : ActionWithOptions`1<T> {
private string DebugName
public void Execute(IAIContext context)
public void DoExecute(BaseContext context)
public bool TryGetBest(BaseContext context, IList`1<T> options, bool allScorersMustScoreAboveZero, T& best, Single& bestScore)
}
public Rust.Ai.BaseAiUtilityClient : UtilityAIClient {
public void .ctor(Guid aiId, IContextProvider contextProvider)
public void .ctor(IUtilityAI ai, IContextProvider contextProvider)
protected void OnPause()
protected void OnResume()
protected void OnStart()
protected void OnStop()
public void Initialize()
public void Kill()
}
public Rust.Ai.BaseContext : object {
private Vector3 <lastSampledPosition>k__BackingField
private List`1<Vector3> <sampledPositions>k__BackingField
private IAIAgent <AIAgent>k__BackingField
private BaseCombatEntity <Entity>k__BackingField
public Memory Memory
public BasePlayer ClosestPlayer
public List`1<BasePlayer> Players
public List`1<BaseNpc> Npcs
public List`1<BasePlayer> PlayersBehindUs
public List`1<BaseNpc> NpcsBehindUs
public List`1<TimedExplosive> DeployedExplosives
public BasePlayer EnemyPlayer
public BaseNpc EnemyNpc
public float LastTargetScore
public float LastEnemyPlayerScore
public float LastEnemyNpcScore
public float NextRoamTime
public Vector3 lastSampledPosition
public List`1<Vector3> sampledPositions
public IAIAgent AIAgent
public BaseCombatEntity Entity
public Vector3 Position
public Vector3 EnemyPosition
public void .ctor(IAIAgent agent)
public Vector3 get_lastSampledPosition()
public void set_lastSampledPosition(Vector3 value)
public List`1<Vector3> get_sampledPositions()
private void set_sampledPositions(List`1<Vector3> value)
public IAIAgent get_AIAgent()
private void set_AIAgent(IAIAgent value)
public BaseCombatEntity get_Entity()
private void set_Entity(BaseCombatEntity value)
public Vector3 get_Position()
public Vector3 get_EnemyPosition()
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value)
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
}
public Rust.Ai.BaseScorer : ContextualScorerBase {
public bool InvertScore
private string DebugName
protected float ProcessScore(float s)
public float Score(IAIContext context)
public float GetScore(BaseContext context)
}
public Rust.Ai.BehaviorDuration : BaseScorer {
public Behaviour Behaviour
public float duration
public float GetScore(BaseContext c)
}
public Rust.Ai.BehaviorDurationLessThan : BaseScorer {
public Behaviour Behaviour
public float duration
public float GetScore(BaseContext c)
}
public Rust.Ai.BehaviouralPointDirectnessToTarget : PointDirectnessToTarget {
private float minDirectness
private float maxDirectness
private Guide guide
public float GetScore(BaseContext c, Vector3 point)
}
public Rust.Ai.BeingAimedAt : BaseScorer {
public float arc
public Equality EqualityType
public float GetScore(BaseContext c)
}
public Rust.Ai.BestHostility : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
}
public Rust.Ai.BestLineOfSight : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public byte Evaluate(NPCPlayerApex self, BasePlayer option, Int32& standing, Int32& crouched)
}
public Rust.Ai.BestMountedLineOfSight : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public byte Evaluate(NPCPlayerApex self, BasePlayer option)
}
public Rust.Ai.BestMountedPlayerDirection : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public bool Evaluate(BasePlayer self, Vector3 optionPosition, Vector3& dir, Single& dot)
}
public Rust.Ai.BestPlayerDirection : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public bool Evaluate(IAIAgent self, Vector3 optionPosition, Vector3& dir, Single& dot)
}
public Rust.Ai.BestPlayerDistance : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public void Evaluate(IAIAgent self, Vector3 optionPosition, Single& distanceSqr, Single& aggroRangeSqr)
}
public Rust.Ai.BestPlayerFamily : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
}
public Rust.Ai.BestPlayerHostileBanditAct : OptionScorerBase`1<BasePlayer> {
private float score
public float Timeout
public float Score(IAIContext context, BasePlayer option)
}
public Rust.Ai.CanAffordAttack : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.CanAiAttack : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.CanPathToEntity : WeightedScorerBase`1<BaseEntity> {
private NavMeshPath pathToEntity
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.CanReachBeforeTarget : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext c, Vector3 point)
}
public Rust.Ai.ChaseTarget : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.CheatRealDirectionToTargetScorer : OptionScorerBase`1<CoverPoint> {
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option)
}
public Rust.Ai.CheatRealDistanceToTargetScorer : OptionScorerBase`1<CoverPoint> {
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option)
}
public Rust.Ai.CoverContext : object {
public IAIAgent Self
public Vector3 DangerPoint
public List`1<CoverPoint> SampledCoverPoints
public float BestRetreatValue
public float BestFlankValue
public float BestAdvanceValue
public CoverPoint BestRetreatCP
public CoverPoint BestFlankCP
public CoverPoint BestAdvanceCP
public float HideoutValue
public CoverPoint HideoutCP
public void Refresh(IAIAgent self, Vector3 dangerPoint, List`1<CoverPoint> sampledCoverPoints)
}
public Rust.Ai.CoverPoint : object {
private CoverPointVolume <Volume>k__BackingField
public Vector3 Position
public Vector3 Normal
public CoverType NormalCoverType
private BaseEntity <ReservedFor>k__BackingField
private bool <IsCompromised>k__BackingField
private float <Score>k__BackingField
public CoverPointVolume Volume
public BaseEntity ReservedFor
public bool IsReserved
public bool IsCompromised
public float Score
public void .ctor(CoverPointVolume volume, float score)
public CoverPointVolume get_Volume()
private void set_Volume(CoverPointVolume value)
public BaseEntity get_ReservedFor()
public void set_ReservedFor(BaseEntity value)
public bool get_IsReserved()
public bool get_IsCompromised()
public void set_IsCompromised(bool value)
public float get_Score()
public void set_Score(float value)
public void CoverIsCompromised(float cooldown)
private IEnumerator StartCooldown(float cooldown)
public bool ProvidesCoverFromPoint(Vector3 point, float arcThreshold)
}
public Rust.Ai.CoverPointVolume : MonoBehaviour {
public float DefaultCoverPointScore
public float CoverPointRayLength
public LayerMask CoverLayerMask
public Transform BlockerGroup
public Transform ManualCoverPointGroup
public float cover_point_sample_step_size
public float cover_point_sample_step_height
public List`1<CoverPoint> CoverPoints
private List`1<CoverPointBlockerVolume> _coverPointBlockers
private float _dynNavMeshBuildCompletionTime
private int _genAttempts
private Bounds bounds
public bool repeat
public bool get_repeat()
private void OnEnable()
private void OnDisable()
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
private void ClearCoverPoints()
public Bounds GetBounds()
public void PreGenerateCoverPoints()
public void ConvertToManualCoverPoints()
public void GenerateCoverPoints(Transform coverPointGroup)
private CoverPoint CalculateCoverPoint(NavMeshHit info)
internal CoverType ProvidesCoverInDir(Ray ray, float maxDistance, RaycastHit& rayHit)
public bool Contains(Vector3 point)
}
public Rust.Ai.CoverScorer : OptionScorerBase`1<CoverPoint> {
public float coverFromPointArcThreshold
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option, float arcThreshold)
private bool EvaluateAdvancement(CoverContext c, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness, Single& result)
private bool EvaluateRetreat(CoverContext c, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, Single& directness, Single& result)
private bool EvaluateFlanking(CoverContext c, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness, Single& result)
}
public Rust.Ai.Crouch : BaseAction {
public bool crouch
public void DoExecute(BaseContext ctx)
}
public Rust.Ai.Defensiveness : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.DistanceFromDestination : WeightedScorerBase`1<Vector3> {
public float Range
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.DistanceFromFoodTarget : BaseScorer {
public float MaxDistance
public float GetScore(BaseContext c)
}
public Rust.Ai.DistanceFromHome : BaseScorer {
public float Range
public AnimationCurve ResponseCurve
public bool UseResponseCurve
public float GetScore(BaseContext c)
}
public Rust.Ai.DistanceFromSelf : WeightedScorerBase`1<Vector3> {
public float Range
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.DistanceFromSpawnToTargetInRange : BaseScorer {
private EnemyRangeEnum range
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c, EnemyRangeEnum range)
}
public Rust.Ai.DistanceFromTargetDestination : BaseScorer {
public float MaxDistance
public float GetScore(BaseContext c)
}
public Rust.Ai.DistanceFromTargetEntity : BaseScorer {
public float MaxDistance
public float GetScore(BaseContext c)
}
public Rust.Ai.Eat : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.EnergyLevel : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.EntityDangerLevel : WeightedScorerBase`1<BaseEntity> {
public float MinScore
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.EntityDistance : WeightedScorerBase`1<BaseEntity> {
public float DistanceScope
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.EntityLOS : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.EntityProximityToCover : BaseScorer {
public float MaxDistance
public CoverType _coverType
public AnimationCurve Response
public float GetScore(BaseContext ctx)
}
public Rust.Ai.EntitySizeDifference : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.EntityTargetContext : object {
public IAIAgent Self
public BaseEntity[] Entities
public int EntityCount
public BaseNpc AnimalTarget
public float AnimalScore
public TimedExplosive ExplosiveTarget
public float ExplosiveScore
public void Refresh(IAIAgent self, BaseEntity[] entities, int entityCount)
}
public Rust.Ai.FacesAwayFromDanger : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.FeelsThreatenedByAttackTarget : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.FindBestAttackTarget : BaseActionWithOptions`1<BaseEntity> {
public float ScoreThreshold
public bool AllScorersMustScoreAboveZero
public void DoExecute(BaseContext c)
}
public Rust.Ai.FindBestFoodTarget : BaseActionWithOptions`1<BaseEntity> {
public void DoExecute(BaseContext c)
}
public Rust.Ai.FleeDirectionOfGunshots : WeightedScorerBase`1<Vector3> {
public float WithinSeconds
public float Arc
public float GetScore(BaseContext c, Vector3 option)
}
public Rust.Ai.GetHumanPathToTargetStatus : BaseScorer {
public NavMeshPathStatus Status
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c, NavMeshPathStatus s)
}
public Rust.Ai.HasAllyInLineOfFire : BaseScorer {
public float GetScore(BaseContext ctx)
}
public Rust.Ai.HasAlreadyCheckedHideoutPointScorer : OptionScorerBase`1<CoverPoint> {
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option)
}
public Rust.Ai.HasAttackTarget : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HasBeenStuckFor : BaseScorer {
public float StuckSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasChairTarget : BaseScorer {
public float GetScore(BaseContext context)
public float Test(NPCHumanContext c)
}
public Rust.Ai.HasCurrentWeaponType : BaseScorer {
public WeaponTypeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactBoolean : BaseScorer {
public Facts fact
public bool value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactEnemyRange : BaseScorer {
public EnemyRangeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactFoodRange : BaseScorer {
public FoodRangeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactSpeed : BaseScorer {
public SpeedEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactValue : BaseScorer {
public Facts fact
public byte value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFoodTarget : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHadEnemyRecently : BaseScorer {
public float GetScore(BaseContext ctx)
}
public Rust.Ai.HasHideout : BaseScorer {
public float GetScore(BaseContext context)
}
public Rust.Ai.HasHumanFactAmmo : BaseScorer {
public AmmoStateEnum value
public bool requireRanged
public EqualityEnum Equality
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactBodyState : BaseScorer {
public BodyState value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactBoolean : BaseScorer {
public Facts fact
public bool value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactEnemyRange : BaseScorer {
public EnemyRangeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactHealth : BaseScorer {
public HealthEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactSpeed : BaseScorer {
public SpeedEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactValue : BaseScorer {
public Facts fact
public byte value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasIdleFor : BaseScorer {
public float StuckSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasNotDealtDamageForTime : BaseScorer {
public float ForSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasPathStatus : BaseScorer {
private NavMeshPathStatus Status
public float GetScore(BaseContext c)
}
public Rust.Ai.HasPatrolPointsInRoamRange : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.HasPlayerTarget : ContextualScorerBase`1<PlayerTargetContext> {
private bool Not
public float Score(PlayerTargetContext c)
}
public Rust.Ai.HasRecentlyBeenAttacked : BaseScorer {
public float WithinSeconds
public bool BooleanResult
public float GetScore(BaseContext c)
}
public Rust.Ai.HasRecentlyDealtDamage : BaseScorer {
public float WithinSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasRecentlyHeardGunshots : BaseScorer {
public float WithinSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasSeenThreatsLately : BaseScorer {
public float WithinSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasThreats : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HasThreatsNearby : BaseScorer {
public float range
public float GetScore(BaseContext c)
}
public Rust.Ai.HasWeaponEquipped : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HealthFraction : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HealthFractionCurve : BaseScorer {
private AnimationCurve ResponseCurve
public float GetScore(BaseContext c)
}
public Rust.Ai.HideoutScorer : OptionScorerBase`1<CoverPoint> {
public float coverFromPointArcThreshold
public float maxRange
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option, float arcThreshold, float maxRange)
}
public Rust.Ai.Hostility : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HumanAttackOperator : BaseAction {
public AttackType Type
public AttackTargetType Target
public void DoExecute(BaseContext c)
public void AttackEnemy(NPCHumanContext c, AttackType type)
}
public Rust.Ai.HumanNavigateToOperator : BaseAction {
public OperatorType Operator
public void DoExecute(BaseContext c)
public void MakeUnstuck(NPCHumanContext c)
public void NavigateToEnemy(NPCHumanContext c)
public void NavigateToLastEnemy(NPCHumanContext c)
public void NavigateToHideout(NPCHumanContext c)
public void NavigateToRandomLoc(NPCHumanContext c)
public void NavigateToPatrolLoc(NPCHumanContext c)
public void NavigateToSpawnLoc(NPCHumanContext c)
public void NavigateToMountableLoc(NPCHumanContext c, OperatorType mountableType)
private void UpdateRoamTime(NPCHumanContext c)
private void NavigateToWaypointLoc(NPCHumanContext c)
private bool IsWaitingAtWaypoint(NPCHumanContext c, Waypoint& waypoint)
public void NavigateToCover(NPCHumanContext c, TakeCoverIntention intention)
public void PathToCover(NPCHumanContext c, Vector3 coverPosition)
public void FleeEnemy(NPCHumanContext c)
public void FleeExplosive(NPCHumanContext c)
public void FleeHurtDir(NPCHumanContext c)
public void Sidestep(NPCHumanContext c)
private bool NavigateInDirOfBestSample(NPCHumanContext c, SampleCount sampleCount, float radius, SampleFeatures features, float minRange, float maxRange)
}
public Rust.Ai.HumanVoiceOperator : BaseAction {
public void DoExecute(BaseContext ctx)
}
public Rust.Ai.IAiAnswer {
public NPCPlayerApex Source
public NPCPlayerApex get_Source()
public void set_Source(NPCPlayerApex value)
}
public Rust.Ai.InInCoverFromEntity : WeightedScorerBase`1<BaseEntity> {
public float CoverArcThreshold
public float GetScore(BaseContext ctx, BaseEntity option)
}
public Rust.Ai.InMountRangeOfChair : BaseScorer {
public float GetScore(BaseContext context)
public float Test(NPCHumanContext c)
private float IsInRange(NPCHumanContext c, BaseMountable mountable)
}
public Rust.Ai.IsAnimal : OptionScorerBase`1<BaseEntity> {
public float Score(IAIContext context, BaseEntity option)
}
public Rust.Ai.IsAtLastKnownEnemyLocation : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.IsAtLocation : BaseScorer {
public SquadSpawnerLocation Location
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c, SquadSpawnerLocation location)
}
public Rust.Ai.IsAtLocationPlayerTargeting : ContextualScorerBase`1<PlayerTargetContext> {
public SquadSpawnerLocation Location
public float Score(PlayerTargetContext c)
public bool Test(PlayerTargetContext c, SquadSpawnerLocation location)
}
public Rust.Ai.IsAtSpawnLocation : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.IsBusy : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.IsClosestPlayerWithinDistance : BaseScorer {
private float distance
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c, float distance)
}
public Rust.Ai.IsCrouched : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.IsCurrentAttackEntity : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.IsCurrentFoodTarget : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.IsExplosive : OptionScorerBase`1<BaseEntity> {
public float Score(IAIContext context, BaseEntity option)
}
public Rust.Ai.IsHumanFactInEngagementRange : BaseScorer {
public EnemyEngagementRangeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.IsHumanRoamReady : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.IsInCoverFromTarget : BaseScorer {
public float CoverArcThreshold
public float GetScore(BaseContext ctx)
}
public Rust.Ai.IsInWater : WeightedScorerBase`1<Vector3> {
public float MaxDepth
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.IsLastAttacker : WeightedScorerBase`1<BaseEntity> {
public float MinScore
public float GetScore(BaseContext context, BaseEntity option)
}
public Rust.Ai.IsMountedToType : BaseScorer {
public MountPoses MountableType
public float GetScore(BaseContext context)
public float Test(NPCHumanContext c, MountPoses mountableType)
}
public Rust.Ai.IsPathDistanceBetweenHideoutAndLKPValid : OptionScorerBase`1<CoverPoint> {
public float Score(IAIContext context, CoverPoint option)
public bool Evaluate(CoverContext c, CoverPoint option)
}
public Rust.Ai.IsPathDistanceToTargetValid : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.IsRoamReady : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(BaseContext c)
}
public Rust.Ai.IsSleeping : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.IsSleepy : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.IsTargetAlive : BaseScorer {
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c)
}
public Rust.Ai.IsTargetDead : BaseScorer {
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c)
}
public Rust.Ai.LastSetDestinationTimeGreaterThan : BaseScorer {
private float Timeout
public float GetScore(BaseContext c)
}
public Rust.Ai.LastSetDestinationTimeLessThan : BaseScorer {
private float Timeout
public float GetScore(BaseContext c)
}
public Rust.Ai.LineOfSightToTarget : WeightedScorerBase`1<Vector3> {
private CoverType Cover
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.LineOfSightToTargetEntity : BaseScorer {
private CoverType Cover
public float GetScore(BaseContext c)
}
public Rust.Ai.LookAtClosestPlayer : BaseAction {
public void DoExecute(BaseContext context)
public void Do(NPCHumanContext c)
}
public Rust.Ai.LookAtRandomPoint : BaseAction {
public float MinTimeout
public float MaxTimeout
public void DoExecute(BaseContext context)
}
public Rust.Ai.ManualCoverPoint : FacepunchBehaviour {
public float Score
public CoverPointVolume Volume
public Vector3 Normal
public CoverType NormalCoverType
public Vector3 Position
public float DirectionMagnitude
public Vector3 get_Position()
public float get_DirectionMagnitude()
private void Awake()
public CoverPoint ToCoverPoint(CoverPointVolume volume)
}
public Rust.Ai.MemorisedHostilePlayerTarget : ActionBase`1<PlayerTargetContext> {
public float HostilityTimeout
public void Execute(PlayerTargetContext context)
}
public Rust.Ai.MemorisedPlayerTarget : ActionBase`1<PlayerTargetContext> {
public void Execute(PlayerTargetContext context)
}
public Rust.Ai.Memory : object {
public List`1<BaseEntity> Visible
public List`1<SeenInfo> All
public List`1<ExtendedInfo> AllExtended
public SeenInfo Update(BaseEntity entity, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, ExtendedInfo& extendedInfo)
public SeenInfo Update(BaseEntity entity, Vector3 position, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, ExtendedInfo& extendedInfo)
public SeenInfo Update(BaseEntity ent, float danger)
public SeenInfo Update(BaseEntity ent, Vector3 position, float danger)
public void AddDanger(Vector3 position, float amount)
public SeenInfo GetInfo(BaseEntity entity)
public SeenInfo GetInfo(Vector3 position)
public ExtendedInfo GetExtendedInfo(BaseEntity entity)
internal void Forget(float maxSecondsOld)
}
public Rust.Ai.MountOperator : BaseAction {
public MountOperationType Type
public void DoExecute(BaseContext c)
public void MountOperation(NPCHumanContext c, MountOperationType type)
}
public Rust.Ai.MoveToBestPosition : BaseActionWithOptions`1<Vector3> {
public void DoExecute(BaseContext c)
}
public Rust.Ai.MoveToFoodTarget : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.MoveToTargetEntity : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.NavigateToOperator : BaseAction {
public OperatorType Operator
public void DoExecute(BaseContext c)
public void MakeUnstuck(BaseContext c)
public void NavigateToEnemy(BaseContext c)
public void NavigateToRandomLoc(BaseContext c)
public void NavigateToTopologyPreference(BaseContext c)
public void NavigateToSpawn(BaseContext c)
public void NavigateToFood(BaseContext c)
public void FleeEnemy(BaseContext c)
public void FleeHurtDir(BaseContext c)
private bool NavigateInDirOfBestSample(BaseContext c, SampleCount sampleCount, float radius, SampleFeatures features, float minRange, float maxRange)
}
public Rust.Ai.NavMeshGridCell : FacepunchBehaviour {
public List`1<Layer> Layers
public float TimeLastSeenByPlayer
public Bounds Bounds
private AsyncTerrainNavMeshBake terrainSource
public float LastBakeTime
private Vector2i <Coord>k__BackingField
public int LayerCount
public Vector2i Coord
public bool IsAwaitingBake
public int get_LayerCount()
public Vector2i get_Coord()
internal void set_Coord(Vector2i value)
public bool get_IsAwaitingBake()
public void set_IsAwaitingBake(bool value)
public void Setup(Vector2i coord, Vector3 position, Vector3 size, LayerMask layerMask, NavMeshCollectGeometry navMeshCollectGeometry)
public Layer GetLayer(int agentTypeIndex)
public Layer CreateLayer(int agentTypeIndex, int area)
public IEnumerator CreateNavMeshLayerAsync(Layer layer, LayerMask layerMask, Action`1<Layer> onAsyncDoneCallback)
public IEnumerator WaitForBuildToFinish(int agentTypeIndex, Action`1<Layer> onAsyncDoneCallback)
public void RebakeCell()
public IEnumerator RebakeCellAsync(Action onAsyncDoneCallback)
private Vector3 Quantize(Vector3 v, Vector3 quant)
public void KeepAlive()
public bool Timeout(float timeoutThreshold)
public void Kill()
public bool IsAtBorder(Vector3 position, float threshold, bool mustHaveValidNeighbour)
public NavMeshLinkInfo GetOrCreateLink(int agentTypeIndex, Vector3 position, float threshold)
public bool RemoveLink(NavMeshLinkInfo info)
}
public Rust.Ai.NavmeshPrefabInstantiator : MonoBehaviour {
public GameObjectRef NavmeshPrefab
private void Start()
}
public Rust.Ai.NavPointSample : ValueType {
public Vector3 Position
public float Score
}
public Rust.Ai.NavPointSampleComparer : object {
public int Compare(NavPointSample a, NavPointSample b)
}
public Rust.Ai.NavPointSampler : object {
private float HalfPI
private NavPointSampleComparer NavPointSampleComparer
public bool SampleCircleWaterDepthOnly(SampleCount sampleCount, Vector3 center, float radius, SampleScoreParams scoreParams, List`1& samples)
public bool SampleCircle(SampleCount sampleCount, Vector3 center, float radius, SampleScoreParams scoreParams, List`1& samples)
public int GetFeatureCount(int features)
public Vector3 GetPointOnCircle(Vector3 center, float radius, float degrees)
public NavPointSample SamplePointWaterDepthOnly(Vector3 pos, float depth)
public NavPointSample SamplePoint(Vector3 pos, SampleScoreParams scoreParams)
private bool _SampleNavMesh(Vector3& pos, IAIAgent agent)
private float _WaterDepth(Vector3 pos, float maxDepth)
private float _DiscourageSharpTurns(Vector3 pos, IAIAgent agent)
public bool IsValidPointDirectness(Vector3 point, Vector3 pos, Vector3 targetPos)
public bool PointDirectnessToTarget(Vector3 point, Vector3 pos, Vector3 targetPos, Single& value)
public float RetreatPointValue(Vector3 point, IAIAgent agent)
public float RetreatPointValueExplosive(Vector3 point, IAIAgent agent)
public float ApproachPointValue(Vector3 point, IAIAgent agent)
public float FlankPointValue(Vector3 point, IAIAgent agent)
public float RetreatFromDirection(Vector3 point, IAIAgent agent)
public float TopologyPreference(Vector3 point, IAIAgent agent)
}
public Rust.Ai.NeverMoves : BaseScorer {
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c)
}
public Rust.Ai.Patience : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.PlayerDetectionChance : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public bool Evaluate(IAIAgent self, float dot, BasePlayer option)
private float FovDetection(float dot, BasePlayer option)
private float NoiseLevel(BasePlayer option)
private float LightDetection(BasePlayer option)
}
public Rust.Ai.PlayerTargetContext : object {
public IAIAgent Self
public int CurrentOptionsIndex
public int PlayerCount
public BasePlayer[] Players
public Vector3[] Direction
public Single[] Dot
public Single[] DistanceSqr
public Byte[] LineOfSight
public BasePlayer Target
public float Score
public int Index
public Vector3 LastKnownPosition
public void Refresh(IAIAgent self, BasePlayer[] players, int playerCount)
}
public Rust.Ai.PointDirectnessToTarget : WeightedScorerBase`1<Vector3> {
private bool UsePerfectInfo
public float GetScore(BaseContext c, Vector3 point)
}
public Rust.Ai.PositionInAttackRangeOfTarget : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.PreventPickingInvalidPositionAgain : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext c, Vector3 option)
}
public Rust.Ai.PrintDebug : BaseAction {
private string debugMessage
public void DoExecute(BaseContext c)
}
public Rust.Ai.ProximityToCover : WeightedScorerBase`1<Vector3> {
public float MaxDistance
public CoverType _coverType
public AnimationCurve Response
public float GetScore(BaseContext ctx, Vector3 option)
internal CoverPoint GetClosestCover(NPCHumanContext c, Vector3 point, float MaxDistance, CoverType _coverType, Single& bestDistance)
}
public Rust.Ai.ProximityToDanger : WeightedScorerBase`1<Vector3> {
public float Range
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.ProximityToDangers : ProximityToPeers {
protected float Test(SeenInfo memory, BaseContext c)
}
public Rust.Ai.ProximityToPeers : WeightedScorerBase`1<Vector3> {
public float desiredRange
public float GetScore(BaseContext c, Vector3 position)
protected float Test(SeenInfo memory, BaseContext c)
}
public Rust.Ai.RangeFromHome : WeightedScorerBase`1<Vector3> {
public float Range
public AnimationCurve ResponseCurve
public bool UseResponseCurve
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.RecentlyStuck : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.ReloadOperator : BaseAction {
public void DoExecute(BaseContext c)
public void Reload(NPCHumanContext c)
}
public Rust.Ai.ReloadWeapon : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.ReloadWeaponNeed : BaseScorer {
private AnimationCurve ResponseCurve
private bool UseResponseCurve
public float GetScore(BaseContext c)
}
public Rust.Ai.ScanForCover : BaseAction {
public float MaxDistanceToCover
public float CoverArcThreshold
public void DoExecute(BaseContext ctx)
public bool ProvidesCoverFromDirection(CoverPoint cp, Vector3 directionTowardCover, float arcThreshold)
}
public Rust.Ai.ScanForEntities : BaseAction {
public BaseEntity[] Results
public int forgetTime
private Func`2<BaseEntity, bool> <>f__mg$cache0
public void DoExecute(BaseContext c)
private bool WithinVisionCone(IAIAgent agent, BaseEntity other)
private bool AiCaresAbout(BaseEntity ent)
}
public Rust.Ai.ScanForPositions : BaseAction {
public float SamplingRange
public int SampleRings
public bool CalculatePath
public float CalculatePathInnerCirclePercentageThreshold
public bool ScanAllAreas
public string AreaName
public bool SampleTerrainHeight
private NavMeshPath reusablePath
public void DoExecute(BaseContext c)
private void TryAddPoint(BaseContext c, Vector3 p, bool calculatePath, bool scanAllAreas, string areaName, bool sampleTerrainHeight)
}
public Rust.Ai.ScientistSpawner : SpawnGroup {
public bool Mobile
public bool NeverMove
public bool SpawnHostile
public bool OnlyAggroMarkedTargets
public bool IsPeacekeeper
public bool IsBandit
public bool IsMilitaryTunnelLab
public EnemyRangeEnum MaxRangeToSpawnLoc
public WaypointSet Waypoints
public Transform[] LookAtInterestPointsStationary
public Vector2 RadioEffectRepeatRange
public Model Model
private AiLocationManager _mgr
private float _nextForcedRespawn
private bool _lastSpawnCallHadAliveMembers
private bool _lastSpawnCallHadMaxAliveMembers
protected void Spawn(int numToSpawn)
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
protected void OnDrawGizmos()
}
public Rust.Ai.SelectCoverPoint : ActionWithOptions`1<CoverPoint> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool Evaluate(CoverContext context, IList`1<IOptionScorer`1<CoverPoint>> scorers, List`1<CoverPoint> options, int numOptions, bool allScorersMustScoreAboveZero)
}
public Rust.Ai.SelectEnemyHideout : ActionWithOptions`1<CoverPoint> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool Evaluate(CoverContext context, IList`1<IOptionScorer`1<CoverPoint>> scorers, List`1<CoverPoint> options, int numOptions, bool allScorersMustScoreAboveZero)
}
public Rust.Ai.SelfDefence : BaseScorer {
public float WithinSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.Sensation : ValueType {
public SensationType Type
public Vector3 Position
public float Radius
public float DamagePotential
}
public Rust.Ai.SensationType : Enum {
public int value__
public SensationType Gunshot
public SensationType ThrownWeapon
}
public Rust.Ai.Sense : object {
private BaseEntity[] query
private Func`2<BaseEntity, bool> <>f__mg$cache0
public void Stimulate(Sensation sensation, BasePlayer invoker)
private bool IsAbleToBeStimulated(BaseEntity ent)
}
public Rust.Ai.SetBehaviour : BaseAction {
public Behaviour Behaviour
public float BusyTime
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetBusyFor : BaseAction {
public float BusyTime
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetFactBoolean : BaseAction {
public Facts fact
public bool value
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetHumanFactBodyState : BaseAction {
public BodyState value
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetHumanFactBoolean : BaseAction {
public Facts fact
public bool value
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetHumanSpeed : BaseAction {
public SpeedEnum value
public void DoExecute(BaseContext c)
public void Set(BaseContext c, SpeedEnum speed)
}
public Rust.Ai.SetSpeed : BaseAction {
public SpeedEnum value
public void DoExecute(BaseContext c)
}
public Rust.Ai.SharePlayerTargetComm : ActionBase`1<PlayerTargetContext> {
public void Execute(PlayerTargetContext c)
}
public Rust.Ai.ShouldReturnToSpawnPoint : BaseScorer {
public float GetScore(BaseContext ctx)
}
public Rust.Ai.StaminaLevel : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.StartAttack : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.StopMoving : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.SwitchToolOperator : BaseAction {
private ToolTypeEnum ToolTypeDay
private ToolTypeEnum ToolTypeNight
public void DoExecute(BaseContext c)
public bool TrySwitchToolTo(NPCHumanContext c, ToolTypeEnum toolDay, ToolTypeEnum toolNight)
public Item FindTool(NPCHumanContext c, ToolTypeEnum tool)
}
public Rust.Ai.SwitchWeaponOperator : BaseAction {
private WeaponTypeEnum WeaponType
public void DoExecute(BaseContext c)
public bool TrySwitchWeaponTo(NPCHumanContext c, WeaponTypeEnum WeaponType)
private Item FindBestMelee(NPCHumanContext c)
private Item FindBestProjInRange(WeaponTypeEnum from, WeaponTypeEnum to, NPCHumanContext c)
}
public Rust.Ai.TargetAlive : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.TargetEntityVisibleFor : BaseScorer {
public float duration
public float GetScore(BaseContext c)
}
public Rust.Ai.TargetHealthFraction : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.TargetSelectorAnimal : ActionWithOptions`1<BaseEntity> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool Evaluate(EntityTargetContext context, IList`1<IOptionScorer`1<BaseEntity>> scorers, BaseEntity[] options, int numOptions, bool allScorersMustScoreAboveZero, BaseNpc& best, Single& bestScore)
}
public Rust.Ai.TargetSelectorExplosives : ActionWithOptions`1<BaseEntity> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool TryGetBest(EntityTargetContext context, IList`1<IOptionScorer`1<BaseEntity>> scorers, BaseEntity[] options, int numOptions, bool allScorersMustScoreAboveZero, TimedExplosive& best, Single& bestScore)
}
public Rust.Ai.TargetSelectorPlayer : ActionWithOptions`1<BasePlayer> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool Evaluate(PlayerTargetContext context, IList`1<IOptionScorer`1<BasePlayer>> scorers, BasePlayer[] options, int numOptions, bool allScorersMustScoreAboveZero, BasePlayer& best, Single& bestScore, Int32& bestIndex, Vector3& bestLastKnownPosition)
}
public Rust.Ai.TestBehaviour : BaseScorer {
public Behaviour Behaviour
public float GetScore(BaseContext c)
}
public Rust.Ai.TimeAtDestination : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.TimeSinceLastMoveThreshold : BaseScorer {
public float minThreshold
public float maxThreshold
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c, float minThreshold, float maxThreshold)
}
public Rust.Ai.TimeSinceLastMoveToCoverThreshold : BaseScorer {
public float minThreshold
public float maxThreshold
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c, float minThreshold, float maxThreshold)
}
public Rust.Ai.ValidDistance : OptionScorerBase`1<BaseEntity> {
public float Score(IAIContext context, BaseEntity option)
}
public Rust.Ai.ValidLineOfSight : OptionScorerBase`1<BaseEntity> {
public float Score(IAIContext context, BaseEntity option)
}
public Rust.Ai.WantsToAttackEntity : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.WantsToEatEntity : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.WaypointSet : MonoBehaviour {
private List`1<Waypoint> _points
private NavModes navMode
public List`1<Waypoint> Points
public NavModes NavMode
public List`1<Waypoint> get_Points()
public void set_Points(List`1<Waypoint> value)
public NavModes get_NavMode()
private void OnDrawGizmos()
}
public Rust.Ai.WeightedScorerBase`1 : OptionScorerBase`1<T> {
public bool InvertScore
public float ScoreScale
private string DebugName
protected float ProcessScore(float s)
public float Score(IAIContext context, T option)
public float GetScore(BaseContext context, T option)
}
public Rust.Ai.WithinAttackRangeOfTargetEntity : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.DamageType : Enum {
public int value__
public DamageType Generic
public DamageType Hunger
public DamageType Thirst
public DamageType Cold
public DamageType Drowned
public DamageType Heat
public DamageType Bleeding
public DamageType Poison
public DamageType Suicide
public DamageType Bullet
public DamageType Slash
public DamageType Blunt
public DamageType Fall
public DamageType Radiation
public DamageType Bite
public DamageType Stab
public DamageType Explosion
public DamageType RadiationExposure
public DamageType ColdExposure
public DamageType Decay
public DamageType ElectricShock
public DamageType Arrow
public DamageType LAST
}
public Rust.DamageTypeEntry : object {
public DamageType type
public float amount
}
public Rust.DamageTypeList : object {
public Single[] types
public void Set(DamageType index, float amount)
public float Get(DamageType index)
public void Add(DamageType index, float amount)
public void Scale(DamageType index, float amount)
public bool Has(DamageType index)
public float Total()
public void Add(List`1<DamageTypeEntry> entries)
public void ScaleAll(float amount)
public DamageType GetMajorityDamageType()
public bool IsMeleeType()
public bool IsBleedCausing()
}
public Rust.Defines : object {
public UInt32 appID
public string resourceFolder
}
internal Rust.GameInfo : object {
internal bool IsOfficialServer
internal bool HasAchievements
internal bool get_IsOfficialServer()
internal bool get_HasAchievements()
}
public Rust.Generic : object {
private Scene _batchingScene
public Scene BatchingScene
public Scene get_BatchingScene()
}
public Rust.Protocol : object {
public int network
public int save
public int report
public int persistance
public int storage
public string printable
public string get_printable()
}
public Rust.Server : object {
public float UseDistance
private Scene _entityScene
public Scene EntityScene
public Scene get_EntityScene()
}
internal Rust.UI.Utility.ForceWeather : MonoBehaviour {
private Toggle component
public bool Rain
public bool Fog
public bool Wind
public bool Clouds
public void OnEnable()
public void Update()
}
public Sandstorm : MonoBehaviour {
public ParticleSystem m_psSandStorm
public float m_flSpeed
public float m_flSwirl
public float m_flEmissionRate
private void Start()
private void Update()
}
public SavePause : MonoBehaviour {
private bool tracked
protected void OnEnable()
protected void OnDisable()
}
public SaveRestore : SingletonComponent`1<SaveRestore> {
public bool IsSaving
public bool timedSave
public int timedSavePause
public DateTime SaveCreatedTime
private MemoryStream SaveBuffer
private Func`2<BaseNetworkable, bool> <>f__am$cache0
private Func`2<BaseNetworkable, BaseEntity> <>f__am$cache1
private Func`2<BaseNetworkable, bool> <>f__am$cache2
private Func`2<BaseNetworkable, StabilityEntity> <>f__am$cache3
private Func`2<BaseNetworkable, bool> <>f__am$cache4
private Func`2<BaseNetworkable, BuildingBlock> <>f__am$cache5
public IEnumerator Save(string strFilename, bool AndWait)
private void Start()
private IEnumerator SaveRegularly()
private IEnumerator DoAutomatedSave(bool AndWait)
public bool Save(bool AndWait)
internal void ClearMapEntities()
public bool Load(string strFilename, bool allowOutOfDateSaves)
public void GetSaveCache()
public void InitializeEntityLinks()
public void InitializeEntitySupports()
public void InitializeEntityConditionals()
private bool <InitializeEntityLinks>m__0(BaseNetworkable x)
private BaseEntity <InitializeEntityLinks>m__1(BaseNetworkable x)
private bool <InitializeEntitySupports>m__2(BaseNetworkable x)
private StabilityEntity <InitializeEntitySupports>m__3(BaseNetworkable x)
private bool <InitializeEntityConditionals>m__4(BaseNetworkable x)
private BuildingBlock <InitializeEntityConditionals>m__5(BaseNetworkable x)
}
public ScaleByIntensity : MonoBehaviour {
public Vector3 initialScale
public Light intensitySource
public float maxIntensity
private void Start()
private void Update()
}
public ScaleParticleSystem : ScaleRenderer {
public ParticleSystem pSystem
public bool scaleGravity
private float startSize
private float startLifeTime
private float startSpeed
private float startGravity
public void GatherInitialValues()
public void SetScale_Internal(float scale)
}
public ScaleRenderer : MonoBehaviour {
public bool useRandomScale
public float scaleMin
public float scaleMax
private float lastScale
protected bool hasInitialValues
public Renderer myRenderer
private bool ScaleDifferent(float newScale)
public void Start()
public void SetScale(float scale)
public void SetScale_Internal(float scale)
public void SetRendererEnabled(bool isEnabled)
public void GatherInitialValues()
}
public ScaleTrailRenderer : ScaleRenderer {
private TrailRenderer trailRenderer
private float startWidth
private float endWidth
private float duration
public void GatherInitialValues()
public void SetScale_Internal(float scale)
}
public ScaleTransform : ScaleRenderer {
private Vector3 initialScale
public void SetScale_Internal(float scale)
public void GatherInitialValues()
}
public SceneToPrefab : MonoBehaviour {
public bool flattenHierarchy
public GameObject outputPrefab
}
public Scientist : NPCPlayerApex {
public LootSpawnSlot[] LootSpawnSlots
private HashSet`1<Scientist> AllScientists
private List`1<Scientist> CommQueryCache
private List`1<AiAnswer_ShareEnemyTarget> CommTargetCache
public FamilyEnum Family
public string Categorize()
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public FamilyEnum get_Family()
public void ServerInit()
internal void DoServerDestroy()
public bool ShouldDropActiveItem()
public BaseCorpse CreateCorpse()
public void Load(LoadInfo info)
private void InitComm()
private void OnDestroyComm()
public int GetAlliesInRange(List`1& allies)
public void SendStatement(AiStatement_EnemyEngaged statement)
public void SendStatement(AiStatement_EnemySeen statement)
public void OnAiStatement(NPCPlayerApex source, AiStatement_EnemyEngaged statement)
public void OnAiStatement(NPCPlayerApex source, AiStatement_EnemySeen statement)
public int AskQuestion(AiQuestion_ShareEnemyTarget question, List`1& answers)
private void OnAggroComm()
}
public ScreenBounce : BaseScreenShake {
public AnimationCurve bounceScale
public AnimationCurve bounceSpeed
public AnimationCurve bounceViewmodel
private float bounceTime
private Vector3 bounceVelocity
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public ScreenBounceFade : BaseScreenShake {
public AnimationCurve bounceScale
public AnimationCurve bounceSpeed
public AnimationCurve bounceViewmodel
public AnimationCurve distanceFalloff
public AnimationCurve timeFalloff
private float bounceTime
private Vector3 bounceVelocity
public float maxDistance
public float scale
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public ScreenFov : BaseScreenShake {
public AnimationCurve FovAdjustment
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public ScreenRotate : BaseScreenShake {
public AnimationCurve Pitch
public AnimationCurve Yaw
public AnimationCurve Roll
public AnimationCurve ViewmodelEffect
public bool useViewModelEffect
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public Screenshot : MonoBehaviour {
public string screenshotPath
public int sizeMultiplier
}
public ScrollRectZoom : MonoBehaviour {
public ScrollRectEx scrollRect
public float zoom
public bool smooth
public float max
public float min
public float velocity
public RectTransform rectTransform
public RectTransform get_rectTransform()
private void OnEnable()
public void OnScroll(PointerEventData data)
private void Update()
private void SetZoom(float z)
}
public SearchLight : StorageContainer {
public GameObject pitchObject
public GameObject yawObject
public GameObject eyePoint
public GameObject lightEffect
public SoundPlayer turnLoop
public ItemDefinition fuelType
public Vector3 aimDir
public BasePlayer mountedPlayer
public float secondsRemaining
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public bool IsMounted()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void PlayerEnter(BasePlayer player)
public void PlayerExit()
public void MountedUpdate()
public void SetTargetAimpoint(Vector3 worldPos)
public void RPC_UseLight(RPCMessage msg)
public void RPC_Switch(RPCMessage msg)
public void OnKilled(HitInfo info)
public void FuelUpdate()
public void Update()
public bool SupportsPooling()
}
public sedanAnimation : MonoBehaviour {
public Transform[] frontAxles
public Transform FL_shock
public Transform FL_wheel
public Transform FR_shock
public Transform FR_wheel
public Transform RL_shock
public Transform RL_wheel
public Transform RR_shock
public Transform RR_wheel
public WheelCollider FL_wheelCollider
public WheelCollider FR_wheelCollider
public WheelCollider RL_wheelCollider
public WheelCollider RR_wheelCollider
public Transform steeringWheel
public float motorForceConstant
public float brakeForceConstant
public float brakePedal
public float gasPedal
public float steering
private Rigidbody myRigidbody
public float GasLerpTime
public float SteeringLerpTime
private float wheelSpinConstant
private float shockRestingPosY
private float shockDistance
private float traceDistanceNeutralPoint
private void Start()
private void Update()
private void InputPlayer()
private void DoSteering()
private void ApplyForceAtWheels()
private void UpdateTireAnimation()
private float GetShockHeightDelta(WheelCollider wheel)
}
public SeedInformationPanel : ItemInformationPanel {
public ItemTextValue durationDisplay
public ItemTextValue waterRequiredDisplay
public ItemTextValue yieldDisplay
public ItemTextValue maxHarvestsDisplay
}
public SegmentMaskPositioning : MonoBehaviour {
public PlayerModel source
public GameObject headMask
public GameObject chestMask
public GameObject legsMask
public float xOffset
}
public SelectedBlueprint : SingletonComponent`1<SelectedBlueprint> {
public ItemBlueprint blueprint
public InputField craftAmountText
public GameObject ingredientGrid
public IconSkinPicker skinPicker
public Image iconImage
public Text titleText
public Text descriptionText
public CanvasGroup CraftArea
public Button CraftButton
public Text CraftTime
public Text CraftAmount
public GameObject[] workbenchReqs
private ItemInformationPanel[] informationPanels
public bool isOpen
public bool get_isOpen()
}
public SelectedItem : SingletonComponent`1<SelectedItem> {
public Image icon
public Image iconSplitter
public Text title
public Text description
public GameObject splitPanel
public GameObject itemProtection
public GameObject menuOption
public GameObject optionsParent
public GameObject innerPanelContainer
}
public SelfCheck : object {
public bool Run()
private bool Failed(string Message)
private bool TestRustNative()
private bool RustNative_VersionCheck(int version)
}
public SellOrderEntry : MonoBehaviour {
public VirtualItemIcon MerchandiseIcon
public VirtualItemIcon CurrencyIcon
private ItemDefinition merchandiseInfo
private ItemDefinition currencyInfo
public GameObject buyButton
public GameObject cantaffordNotification
public GameObject outOfStockNotification
private LootPanelVendingMachine vendingPanel
public UIIntegerEntry intEntry
}
public SendMessageToEntityOnAnimationFinish : StateMachineBehaviour {
public string messageToSendToEntity
public float repeatRate
private float lastMessageSent
public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public SeparableSSS : object {
private Vector3 Gaussian(float variance, float r, Color falloffColor)
private Vector3 Profile(float r, Color falloffColor)
public void CalculateKernel(Color[] target, int targetStart, int targetSize, Color subsurfaceColor, Color falloffColor)
}
public ServerBrowser : MonoBehaviour {
public string orderBy
}
public ServerBrowserCategory : MonoBehaviour {
public Text serverCountText
}
public ServerBrowserInfo : SingletonComponent`1<ServerBrowserInfo> {
public bool isMain
public Text serverName
public Text serverMeta
public Text serverText
public RawImage headerImage
public Button viewWebpage
public Button refresh
public Server currentServer
public Texture defaultServerImage
}
public ServerBrowserItem : MonoBehaviour {
public Text serverName
public Text mapName
public Text playerCount
public Text ping
public Toggle favourited
}
public ServerBrowserList : BaseMonoBehaviour {
public ServerBrowserCategory categoryButton
public bool startActive
public ServerBrowserItem itemTemplate
public int refreshOrder
public bool UseOfficialServers
public ServerBrowserItem[] items
public Rules[] rules
public QueryType queryType
public string VersionTag
public ServerKeyvalues[] keyValues
}
public ServerBuildingManager : BuildingManager {
private int decayTickBuildingIndex
private int decayTickEntityIndex
private int decayTickWorldIndex
private int navmeshCarveTickBuildingIndex
private UInt32 maxBuildingID
public void CheckSplit(DecayEntity ent)
private bool ShouldSplit(Building building)
private void Split(Building building)
public void CheckMerge(DecayEntity ent)
private void Merge(Building building1, Building building2)
public void Cycle()
public void UpdateNavMeshCarver(Building building, Int32& ticks, int i)
public UInt32 NewBuildingID()
public void LoadBuildingID(UInt32 id)
}
public ServerConsole : SingletonComponent`1<ServerConsole> {
private ConsoleWindow console
private ConsoleInput input
private float nextUpdate
private DateTime currentGameTime
private int currentPlayerCount
private int maxPlayerCount
private int currentEntityCount
private int currentSleeperCount
public void OnEnable()
private void OnDisable()
private void OnInputText(string obj)
public void PrintColoured(Object[] objects)
private void HandleLog(string message, string stackTrace, LogType type)
private void Update()
private void UpdateStatus()
private DateTime get_currentGameTime()
private int get_currentPlayerCount()
private int get_maxPlayerCount()
private int get_currentEntityCount()
private int get_currentSleeperCount()
}
public ServerGib : BaseCombatEntity {
public GameObject _gibSource
public string _gibName
public PhysicMaterial physicsMaterial
private MeshCollider meshCollider
private Rigidbody rigidBody
public float BoundsPadding()
public List`1<ServerGib> CreateGibs(string entityToCreatePath, GameObject creator, GameObject gibSource, Vector3 inheritVelocity, float spreadVelocity)
public void Save(SaveInfo info)
public MeshCollider GetCollider()
public void ServerInit()
public void RemoveMe()
public void PhysicsInit(Mesh mesh)
}
public ServerHistory : MonoBehaviour {
public ServerHistoryItem prefab
public GameObject panelList
internal Request Request
}
public ServerHistoryItem : MonoBehaviour {
private Server serverInfo
public Text serverName
public Text players
public Text lastJoinDate
public UInt32 order
}
public ServerMgr : SingletonComponent`1<ServerMgr> {
private ConnectionAuth auth
private bool runFrameUpdate
private bool useQueryPort
public UserPersistance persistance
private string _AssemblyHash
private IEnumerator restartCoroutine
public ConnectionQueue connectionQueue
private Stopwatch queryTimer
private Dictionary`2<UInt32, int> unconnectedQueries
private Stopwatch queriesPerSeconTimer
private int NumQueriesLastSecond
private MemoryStream queryBuffer
private Action`1<object> <>f__mg$cache0
public int AvailableSlots
private string AssemblyHash
public bool Restarting
public void Initialize(bool loadSave, string saveFile, bool allowOutOfDateSaves, bool skipInitialSpawn)
public void OpenConnection()
private void CloseConnection()
private void OnDisable()
private void OnApplicationQuit()
private void CreateImportantEntities()
private void CreateImportantEntity(string prefabName)
private void StartSteamServer()
private void DebugPrintSteamCallback(object obj)
private void OnInventoryDefinitionsUpdated()
private void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, Status Status)
private void EACUpdate()
public int get_AvailableSlots()
private void Update()
private void SteamQueryResponse()
private void DoTick()
private void DoHeartbeat()
private string get_AssemblyHash()
private void UpdateServerInformation()
private void OnDisconnected(string strReason, Connection connection)
public void OnEnterVisibility(Connection connection, Group group)
public void OnLeaveVisibility(Connection connection, Group group)
internal void SpawnMapEntities()
public SpawnPoint FindSpawnPoint()
public void JoinGame(Connection connection)
public bool get_Restarting()
internal void Shutdown()
private IEnumerator ServerRestartWarning(string info, int iSeconds)
public void RestartServer(string strNotice, int iSeconds)
private void Log(Exception e)
private void OnNetworkMessage(Message packet)
public void ProcessUnhandledPacket(Message packet)
public void ReadDisconnectReason(Message packet)
private bool SpawnPlayerSleeping(Connection connection)
private void SpawnNewPlayer(Connection connection)
private void ClientReady(Message packet)
private void OnRPCMessage(Message packet)
private void OnPlayerTick(Message packet)
private void OnPlayerVoice(Message packet)
private void OnGiveUserInformation(Message packet)
private bool OnUnconnectedMessage(int type, Read read, UInt32 ip, int port)
private bool <CreateImportantEntity`1>m__0(BaseNetworkable x)
}
public ServerPerformance : BaseMonoBehaviour {
public ulong deaths
public ulong spawns
public ulong position_changes
private string fileName
private int lastFrame
private Func`2<Collider, bool> <>f__am$cache0
private Func`2<Collider, bool> <>f__am$cache1
private Func`2<IGrouping`2<string, Object>, int> <>f__mg$cache0
private Func`2<Object, string> <>f__am$cache2
private Func`2<Object, Object> <>f__am$cache3
private void Start()
private void WriteLine()
public void DoReport()
public string WorkoutPrefabName(GameObject obj)
public void ComponentReport(string filename, string Title, Object[] objects)
private bool <DoReport>m__0(Collider x)
private bool <DoReport>m__1(Collider x)
private string <ComponentReport>m__2(Object x)
private Object <ComponentReport>m__3(Object x)
}
public ServerProjectile : EntityComponent`1<BaseEntity> {
public Vector3 initialVelocity
public float drag
public float gravityModifier
public float speed
public float scanRange
public Vector3 _currentVelocity
private void Update()
public void DoMovement()
public void InitializeVelocity(Vector3 overrideVel)
}
public ServerStatistics : object {
private BasePlayer player
private Storage storage
private Dictionary`2<ulong, Storage> players
public void .ctor(BasePlayer player)
public void Init()
public void Save()
public void Add(string name, int val)
public Storage Get(ulong id)
}
public ServerUsers : object {
private Dictionary`2<ulong, User> users
private Func`2<KeyValuePair`2<ulong, User>, User> <>f__am$cache0
public void Remove(ulong uid)
public void Set(ulong uid, UserGroup group, string username, string notes)
public User Get(ulong uid)
public bool Is(ulong uid, UserGroup group)
public IEnumerable`1<User> GetAll(UserGroup group)
public void Clear()
public void Load()
public void Save()
public string BanListString(bool bHeader)
public string BanListStringEx()
private User <GetAll>m__0(KeyValuePair`2<ulong, User> x)
}
public SEScreenSpaceShadows : MonoBehaviour {
private CommandBuffer blendShadowsCommandBuffer
private CommandBuffer renderShadowsCommandBuffer
private Camera attachedCamera
public Light sun
private Material material
private object initChecker
private bool sunInitialized
private int temporalJitterCounter
public float blendStrength
public float accumulation
public float lengthFade
public float range
public float zThickness
public int samples
public float nearSampleQuality
public float traceBias
public bool stochasticSampling
public bool leverageTemporalAA
public bool bilateralBlur
public int blurPasses
public float blurDepthTolerance
private bool previousBilateralBlurSetting
private int previousBlurPassesSetting
private Texture2D noBlendTex
private void AddCommandBufferClean(Light light, CommandBuffer commandBuffer, LightEvent lightEvent)
private void AddCommandBufferClean(Camera camera, CommandBuffer commandBuffer, CameraEvent cameraEvent)
private void RemoveCommandBuffer(Light light, CommandBuffer commandBuffer, LightEvent lightEvent)
private void RemoveCommandBuffer(Camera camera, CommandBuffer commandBuffer, CameraEvent cameraEvent)
private void RemoveCommandBuffers()
public bool GetCompatibleRenderPath()
private void Init()
private void OnEnable()
private void OnDisable()
private void OnPreRender()
private void OnPostRender()
}
public SharpenAndVignetteOverlay : ImageEffectLayer {
public CC_SharpenAndVignette sharpenAndVignette
}
public ShopFront : StorageContainer {
public BasePlayer vendorPlayer
public BasePlayer customerPlayer
public GameObjectRef transactionCompleteEffect
public ItemContainer customerInventory
public ItemContainer vendorInventory
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ItemContainer get_vendorInventory()
public bool TradeLocked()
public bool IsTradingPlayer(BasePlayer player)
public bool IsPlayerCustomer(BasePlayer player)
public bool IsPlayerVendor(BasePlayer player)
public bool PlayerInVendorPos(BasePlayer player)
public bool PlayerInCustomerPos(BasePlayer player)
public bool LootEligable(BasePlayer player)
public void ResetTrade()
public void CompleteTrade()
public void AcceptClicked(RPCMessage msg)
public void CancelClicked(RPCMessage msg)
public void PreServerLoad()
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
private bool CanAcceptVendorItem(Item item, int targetSlot)
private bool CanAcceptCustomerItem(Item item, int targetSlot)
public bool CanMoveFrom(BasePlayer player, Item item)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public void ReturnPlayerItems(BasePlayer player)
public void PlayerStoppedLooting(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen)
public void UpdatePlayers()
}
public ShopFrontLootPanel : LootPanel {
public Text playerLabelA
public Text playerLabelB
public GameObject confirmButton
public GameObject confirmHelp
public GameObject denyButton
public GameObject denyHelp
public GameObject waitingText
public GameObject exchangeInProgressImage
public Phrase acceptedPhrase
public Phrase noOnePhrase
}
public Signage : BaseCombatEntity {
public GameObject changeTextDialog
public MeshPaintableSource paintableSource
public UInt32 textureID
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanUpdateSign(BasePlayer player)
public bool CanUnlockSign(BasePlayer player)
public bool CanLockSign(BasePlayer player)
public void Load(LoadInfo info)
public void LockSign(RPCMessage msg)
public void UnLockSign(RPCMessage msg)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public bool ShouldNetworkOwnerInfo()
public string Categorize()
public void UpdateSign(RPCMessage msg)
}
public SimpleBuildingBlock : StabilityEntity {
public bool SupportsPooling()
}
public SimpleFlare : BaseMonoBehaviour {
public bool timeShimmer
public bool positionalShimmer
public bool rotate
public float fadeSpeed
public Collider checkCollider
public float maxVisibleDistance
public bool lightScaled
public bool alignToCameraViaScript
protected float tickRate
private Vector3 fullSize
public bool faceCameraPos
public bool billboardViaShader
private float artificialLightExposure
private float privateRand
private List`1<BasePlayer> players
private Renderer myRenderer
private MaterialPropertyBlock block
public float dotMin
public float dotMax
}
public SimpleLight : IOEntity {
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
}
public SimpleList`1 : object {
private int defaultCapacity
private T[] emptyArray
private T[] array
private int count
public T[] Array
public int Count
public int Capacity
public T Item
public void .ctor(int capacity)
public T[] get_Array()
public int get_Count()
public int get_Capacity()
public void set_Capacity(int value)
public T get_Item(int index)
public void set_Item(int index, T value)
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array)
public void EnsureCapacity(int min)
}
public SingleSpawn : SpawnGroup {
public bool WantsInitialSpawn()
public void FillDelay(float delay)
}
public SkeletonProperties : ScriptableObject {
public GameObject boneReference
public BoneProperty[] bones
private Dictionary`2<UInt32, BoneProperty> quickLookup
public void OnValidate()
private void BuildDictionary()
public BoneProperty FindBone(UInt32 id)
}
public SkeletonScale : MonoBehaviour {
protected BoneInfoComponent[] bones
public int seed
public GameObject leftShoulder
public GameObject rightShoulder
public GameObject spine
protected void Awake()
public void UpdateBones(int seedNumber)
public void Reset()
}
public SkinnedMeshCollider : MonoBehaviour {
public MeshColliderInfo colliderInfo
}
public SkinnedMeshRendererCache : object {
public Dictionary`2<Mesh, RigInfo> dictionary
private Func`2<Transform, string> <>f__am$cache0
private Func`2<Transform, Matrix4x4> <>f__am$cache1
public void Add(Mesh mesh, RigInfo info)
public RigInfo Get(SkinnedMeshRenderer renderer)
private string <Get>m__0(Transform x)
private Matrix4x4 <Get>m__1(Transform x)
}
public SkinnedMeshRendererInfo : ComponentInfo`1<SkinnedMeshRenderer> {
public ShadowCastingMode shadows
public Material material
public Mesh mesh
public Bounds bounds
public Mesh cachedMesh
public RigInfo cachedRig
private Transform root
private Transform[] bones
public void Reset()
public void Setup()
private void RefreshCache()
public void BuildRig()
}
public SkinnedMultiMesh : MonoBehaviour {
public bool shadowOnly
public List`1<Part> parts
public Dictionary`2<string, Transform> boneDict
public List`1<Part> createdParts
public long lastBuildHash
public MaterialPropertyBlock sharedPropertyBlock
public MaterialPropertyBlock hairPropertyBlock
public float skinNumber
public float meshNumber
public float hairNumber
public int skinType
public SkinSetCollection SkinCollection
private OptimizeAnimator optimizeAnimator
private LODGroup lodGroup
private List`1<Renderer> renderers
private List`1<Animator> animators
public List`1<Renderer> Renderers
public List`1<Animator> Animators
public List`1<Renderer> get_Renderers()
public List`1<Animator> get_Animators()
}
public SkinSet : ScriptableObject {
public string Label
public MeshReplace[] MeshReplacements
public MaterialReplace[] MaterialReplacements
public Gradient SkinColour
public HairSetCollection HairCollection
public void Process(GameObject obj, float Seed)
internal Color GetSkinColor(float skinNumber)
}
public SkinSetCollection : ScriptableObject {
public SkinSet[] Skins
public int GetIndex(float MeshNumber)
public SkinSet Get(float MeshNumber)
}
public SleepingBag : DecayEntity {
public ulong deployerUserID
public GameObject renameDialog
public GameObject assignDialog
public float secondsBetweenReuses
public string niceName
public Vector3 spawnOffset
public bool canBePublic
public float unlockTime
public List`1<SleepingBag> sleepingBags
public float unlockSeconds
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPublic()
public float get_unlockSeconds()
public SleepingBag[] FindForPlayer(ulong playerID, bool ignoreTimers)
public SleepingBag FindForPlayer(ulong playerID, UInt32 sleepingBagID, bool ignoreTimers)
public bool SpawnPlayer(BasePlayer player, UInt32 sleepingBag)
public bool DestroyBag(BasePlayer player, UInt32 sleepingBag)
public void SetPublic(bool isPublic)
private void SetDeployedBy(BasePlayer player)
public void ServerInit()
internal void DoServerDestroy()
public void Save(SaveInfo info)
public void Rename(RPCMessage msg)
public void AssignToFriend(RPCMessage msg)
public void RPC_MakePublic(RPCMessage msg)
public void RPC_MakeBed(RPCMessage msg)
public void Load(LoadInfo info)
public bool CanPickup(BasePlayer player)
public bool SupportsPooling()
private bool <DoServerDestroy>m__0(SleepingBag x)
}
public SleepingBagButton : MonoBehaviour {
public GameObject timerInfo
public Text BagName
public Text LockTime
internal Button button
internal SpawnOptions spawnOptions
internal float releaseTime
public float timerSeconds
public string friendlyName
public float get_timerSeconds()
public string get_friendlyName()
public void Setup(SpawnOptions options)
public void Update()
public void DoSpawn()
public void DeleteBag()
}
public SlicedGranularAudioClip : MonoBehaviour {
public AudioClip sourceClip
public AudioClip granularClip
public int sampleRate
public float grainAttack
public float grainSustain
public float grainRelease
public float grainFrequency
public int grainAttackSamples
public int grainSustainSamples
public int grainReleaseSamples
public int grainFrequencySamples
public int samplesUntilNextGrain
public List`1<Grain> grains
public List`1<int> startPositions
public int lastStartPositionIdx
}
public SlidingProgressDoor : ProgressDoor {
public Vector3 openPosition
public Vector3 closedPosition
public GameObject doorObject
private float lastEnergyTime
private float lastServerUpdateTime
public void Spawn()
public void NoEnergy()
public void AddEnergy(float amount)
public void ServerUpdate()
public void UpdateProgress()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
}
public Smaa.DebugPass : Enum {
public int value__
public DebugPass Off
public DebugPass Edges
public DebugPass Weights
}
public Smaa.EdgeDetectionMethod : Enum {
public int value__
public EdgeDetectionMethod Luma
public EdgeDetectionMethod Color
public EdgeDetectionMethod Depth
}
public Smaa.MinAttribute : PropertyAttribute {
public float min
public void .ctor(float min)
}
public Smaa.PredicationPreset : object {
public float Threshold
public float Scale
public float Strength
}
public Smaa.Preset : object {
public bool DiagDetection
public bool CornerDetection
public float Threshold
public float DepthThreshold
public int MaxSearchSteps
public int MaxSearchStepsDiag
public int CornerRounding
public float LocalContrastAdaptationFactor
}
public Smaa.QualityPreset : Enum {
public int value__
public QualityPreset Low
public QualityPreset Medium
public QualityPreset High
public QualityPreset Ultra
public QualityPreset Custom
}
public Smaa.SMAA : MonoBehaviour {
public DebugPass DebugPass
public QualityPreset Quality
public EdgeDetectionMethod DetectionMethod
public bool UsePredication
public Preset CustomPreset
public PredicationPreset CustomPredicationPreset
public Shader Shader
public Texture2D AreaTex
public Texture2D SearchTex
protected Camera m_Camera
protected Preset m_LowPreset
protected Preset m_MediumPreset
protected Preset m_HighPreset
protected Preset m_UltraPreset
protected Material m_Material
public Material Material
public Material get_Material()
}
public Socket_Base : PrefabAttribute {
public bool male
public bool maleDummy
public bool female
public bool femaleDummy
public bool monogamous
public Vector3 position
public Quaternion rotation
public Vector3 selectSize
public Vector3 selectCenter
public string socketName
public SocketMod[] socketMods
public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
public OBB GetSelectBounds(Vector3 position, Quaternion rotation)
protected Type GetIndexedType()
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool TestTarget(Target target)
public bool IsCompatible(Socket_Base socket)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
public Placement DoPlacement(Target target)
public bool CheckSocketMods(Placement placement)
}
public Socket_Free : Socket_Base {
public Vector3 idealPlacementNormal
public bool useTargetNormal
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public Placement DoPlacement(Target target)
}
public Socket_Specific : Socket_Base {
public bool useFemaleRotation
public string targetSocketName
private void OnDrawGizmos()
public bool TestTarget(Target target)
public Placement DoPlacement(Target target)
}
public Socket_Specific_Female : Socket_Base {
public int rotationDegrees
public int rotationOffset
public String[] allowedMaleSockets
private void OnDrawGizmos()
private void OnDrawGizmosSelected()
public bool CanAccept(Socket_Specific socket)
}
public Socket_Terrain : Socket_Base {
public float placementHeight
public bool alignToNormal
private void OnDrawGizmos()
public bool TestTarget(Target target)
public Placement DoPlacement(Target target)
}
public SocketHandle : PrefabAttribute {
protected Type GetIndexedType()
internal void AdjustTarget(Target& target, float maxplaceDistance)
}
public SocketMod : PrefabAttribute {
public Socket_Base baseSocket
public Phrase FailedPhrase
public bool DoCheck(Placement place)
public void ModifyPlacement(Placement place)
protected Type GetIndexedType()
}
public SocketMod_AngleCheck : SocketMod {
public bool wantsAngle
public Vector3 worldNormal
public float withinDegrees
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_AreaCheck : SocketMod {
public Bounds bounds
public LayerMask layerMask
public bool wantsInside
private void OnDrawGizmosSelected()
public bool IsInArea(Vector3 position, Quaternion rotation, Bounds bounds, LayerMask layerMask)
public bool DoCheck(Vector3 position, Quaternion rotation)
public bool DoCheck(Placement place)
}
public SocketMod_Attraction : SocketMod {
public float outerRadius
public float innerRadius
public string groupName
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
public void ModifyPlacement(Placement place)
}
public SocketMod_EntityCheck : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public BaseEntity[] entityTypes
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_EntityType : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public BaseEntity searchType
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_HotSpot : SocketMod {
public float spotSize
private void OnDrawGizmos()
public void ModifyPlacement(Placement place)
}
public SocketMod_InWater : SocketMod {
public bool wantsInWater
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_PlantCheck : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_SphereCheck : SocketMod {
public float sphereRadius
public LayerMask layerMask
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_TerrainCheck : SocketMod {
public bool wantsInTerrain
private void OnDrawGizmos()
public bool IsInTerrain(Vector3 vPoint)
public bool DoCheck(Placement place)
}
public Sound : MonoBehaviour {
public float volumeExponent
public SoundDefinition definition
public SoundModifier[] modifiers
public SoundSource soundSource
public AudioSource[] audioSources
private SoundFade _fade
private SoundModulation _modulation
private SoundOcclusion _occlusion
public SoundFade fade
public SoundModulation modulation
public SoundOcclusion occlusion
public SoundFade get_fade()
public SoundModulation get_modulation()
public SoundOcclusion get_occlusion()
}
public SoundClass : ScriptableObject {
public AudioMixerGroup output
public AudioMixerGroup firstPersonOutput
public bool enableOcclusion
public bool playIfOccluded
public float occlusionGain
public AudioMixerGroup occludedOutput
public int globalVoiceMaxCount
public List`1<SoundDefinition> definitions
}
public SoundClassTest : MonoBehaviour {
public SoundClass soundClass
public float soundInterval
}
public SoundDefinition : ScriptableObject {
public GameObjectRef template
public List`1<WeightedAudioClip> weightedAudioClips
public List`1<DistanceAudioClipList> distanceAudioClips
public SoundClass soundClass
public bool defaultToFirstPerson
public bool loop
public bool randomizeStartPosition
public float volume
public float volumeVariation
public float pitch
public float pitchVariation
public bool dontVoiceLimit
public int globalVoiceMaxCount
public int localVoiceMaxCount
public float localVoiceRange
public float voiceLimitFadeOutTime
public float localVoiceDebounceTime
public bool forceOccludedPlayback
public AnimationCurve falloffCurve
public bool useCustomFalloffCurve
public AnimationCurve spatialBlendCurve
public bool useCustomSpatialBlendCurve
public AnimationCurve spreadCurve
public bool useCustomSpreadCurve
public float maxDistance
public float get_maxDistance()
public float GetLength()
}
public SoundManager : SingletonComponent`1<SoundManager> {
public SoundClass defaultSoundClass
}
public SoundModifier : MonoBehaviour {
public Sound sound
}
public SoundModulation : MonoBehaviour {
private int parameterCount
}
public SoundOcclusion : MonoBehaviour {
public LayerMask occlusionLayerMask
}
public SoundPlayer : BaseMonoBehaviour {
public SoundDefinition soundDefinition
public bool playImmediately
public bool debugRepeat
public bool pending
public Vector3 soundOffset
}
public SoundPlayerCull : MonoBehaviour {
public SoundPlayer soundPlayer
public float cullDistance
}
public SoundRepeater : MonoBehaviour {
public float interval
public SoundPlayer player
}
public SoundSource : MonoBehaviour {
public bool handleOcclusionChecks
public LayerMask occlusionLayerMask
public List`1<OcclusionPoint> occlusionPoints
public bool isOccluded
public float occlusionAmount
public float lodDistance
public bool inRange
public void PreClientComponentCull(IPrefabProcessor p)
}
public SoundVoiceLimiter : MonoBehaviour {
public int maxSimultaneousSounds
}
public Spawnable : MonoBehaviour {
public SpawnPopulation Population
internal UInt32 PrefabID
internal bool SpawnIndividual
internal Vector3 SpawnPosition
internal Quaternion SpawnRotation
protected void OnEnable()
protected void OnDisable()
private void Add()
private void Remove()
internal void Save(SaveInfo info)
internal void Load(LoadInfo info)
protected void OnValidate()
}
public SpawnDistribution : object {
internal SpawnHandler Handler
public float Density
internal int Count
private WorldSpaceGrid`1<int> grid
private Dictionary`2<UInt32, int> dict
private ByteQuadtree quadtree
private Vector3 origin
private Vector3 area
public void .ctor(SpawnHandler handler, Byte[] baseValues, Vector3 origin, Vector3 area)
public bool Sample(Vector3& spawnPos, Quaternion& spawnRot, bool alignToNormal, float dithering)
public bool Sample(Vector3& spawnPos, Quaternion& spawnRot, Element node, bool alignToNormal, float dithering)
public Element SampleNode()
public void AddInstance(Spawnable spawnable)
public void RemoveInstance(Spawnable spawnable)
private void UpdateCount(Spawnable spawnable, int delta)
public int GetCount(UInt32 prefabID)
public int GetCount(Vector3 position)
public float GetGridCellArea()
}
public SpawnFilter : object {
public Enum SplatType
public Enum BiomeType
public Enum TopologyAny
public Enum TopologyAll
public Enum TopologyNot
public bool Test(Vector3 worldPos)
public bool Test(float normX, float normZ)
public float GetFactor(Vector3 worldPos)
public float GetFactor(float normX, float normZ)
}
public SpawnGroup : BaseMonoBehaviour {
public List`1<SpawnEntry> prefabs
public int maxPopulation
public int numToSpawnPerTickMin
public int numToSpawnPerTickMax
public float respawnDelayMin
public float respawnDelayMax
public bool wantsInitialSpawn
public bool temporary
private bool fillOnSpawn
public BaseSpawnPoint[] spawnPoints
private List`1<SpawnPointInstance> spawnInstances
private LocalClock spawnClock
private Func`2<SpawnEntry, int> <>f__am$cache0
public int currentPopulation
public int get_currentPopulation()
public bool WantsInitialSpawn()
public bool WantsTimedSpawn()
public float GetSpawnDelta()
public float GetSpawnVariance()
protected void Awake()
public void Fill()
public void Clear()
public void SpawnInitial()
public void SpawnRepeating()
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
public void Spawn()
protected void Spawn(int numToSpawn)
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
protected string GetPrefab()
protected BaseSpawnPoint GetSpawnPoint(Vector3& pos, Quaternion& rot)
protected void OnDrawGizmos()
private int <GetPrefab>m__0(SpawnEntry x)
}
public SpawnHandler : SingletonComponent`1<SpawnHandler> {
public float TickInterval
public int MinSpawnsPerTick
public int MaxSpawnsPerTick
public LayerMask PlacementMask
public LayerMask PlacementCheckMask
public float PlacementCheckHeight
public LayerMask RadiusCheckMask
public float RadiusCheckDistance
public LayerMask BoundsCheckMask
public SpawnFilter CharacterSpawn
public SpawnPopulation[] SpawnPopulations
public SpawnDistribution[] SpawnDistributions
internal SpawnDistribution CharDistribution
public List`1<SpawnGroup> SpawnGroups
internal Queue`1<SpawnIndividual> SpawnIndividuals
public SpawnPopulation[] ConvarSpawnPopulations
private Dictionary`2<SpawnPopulation, SpawnDistribution> population2distribution
private bool spawnTick
public SpawnPopulation[] AllSpawnPopulations
protected void OnEnable()
public SpawnPoint GetSpawnPoint()
public void UpdateDistributions()
public void FillPopulations()
public void FillGroups()
public void FillIndividuals()
public void InitialSpawn()
public void StartSpawnTick()
private IEnumerator SpawnTick()
private IEnumerator SpawnGroupTick()
private IEnumerator SpawnIndividualTick()
public void SpawnInitial(SpawnPopulation population, SpawnDistribution distribution)
public void SpawnRepeating(SpawnPopulation population, SpawnDistribution distribution)
private void Spawn(SpawnPopulation population, SpawnDistribution distribution, int targetCount, int numToFill, int numToTry)
private GameObject Spawn(SpawnPopulation population, Vector3 pos, Quaternion rot)
private GameObject Spawn(Prefab`1<Spawnable> prefab, Vector3 pos, Quaternion rot)
private bool CheckBounds(Prefab`1<Spawnable> prefab, Vector3 pos, Quaternion rot, Vector3 scale)
public void EnforceLimits(bool forceAll)
private void EnforceLimits(SpawnPopulation population, SpawnDistribution distribution)
public Spawnable[] FindAll(SpawnPopulation population)
public int GetTargetCount(SpawnPopulation population, SpawnDistribution distribution)
public int GetCurrentCount(SpawnPopulation population, SpawnDistribution distribution)
public void AddInstance(Spawnable spawnable)
public void RemoveInstance(Spawnable spawnable)
public float PlayerFraction()
public float PlayerLerp(float min, float max)
public float PlayerExcess()
public float PlayerScale(float scalar)
public void DumpReport(string filename)
public string GetReport(bool detailed)
}
public SpawnIndividual : ValueType {
public UInt32 PrefabID
public Vector3 Position
public Quaternion Rotation
public void .ctor(UInt32 prefabID, Vector3 position, Quaternion rotation)
}
public SpawnPointInstance : MonoBehaviour {
public SpawnGroup parentSpawnGroup
public BaseSpawnPoint parentSpawnPoint
public void Notify()
protected void OnDestroy()
}
public SpawnPopulation : BaseScriptableObject {
public string ResourceFolder
public GameObjectRef[] ResourceList
public float _targetDensity
public float SpawnRate
public int ClusterSizeMin
public int ClusterSizeMax
public int ClusterDithering
public int SpawnAttemptsInitial
public int SpawnAttemptsRepeating
public bool EnforcePopulationLimits
public bool ScaleWithSpawnFilter
public bool ScaleWithServerPopulation
public bool AlignToNormal
public SpawnFilter Filter
public Prefab`1[] Prefabs
private Int32[] numToSpawn
private int sumToSpawn
private Func`2<GameObjectRef, string> <>f__am$cache0
public float TargetDensity
public float get_TargetDensity()
public bool Initialize()
public void UpdateWeights(SpawnDistribution distribution, int targetCount)
public Prefab`1<Spawnable> GetRandomPrefab()
public float GetCurrentSpawnRate()
public float GetCurrentSpawnDensity()
public float GetMaximumSpawnDensity()
private string <Initialize>m__0(GameObjectRef x)
}
public SphereEntity : BaseEntity {
public float currentRadius
public float lerpRadius
public float lerpSpeed
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void LerpRadiusTo(float radius, float speed)
protected void UpdateScale()
protected void Update()
}
public SpinnerWheel : Signage {
public Transform wheel
public float velocity
public Quaternion targetRotation
public SoundDefinition spinLoopSoundDef
public SoundDefinition spinStartSoundDef
public SoundDefinition spinAccentSoundDef
public SoundDefinition spinStopSoundDef
public float minTimeBetweenSpinAccentSounds
public float spinAccentAngleDelta
private Sound spinSound
private Modulator spinSoundGain
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool AllowPlayerSpins()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float GetMaxSpinSpeed()
public void Update_Server()
public void Update_Client()
public void Update()
private void RPC_Spin(RPCMessage rpc)
private void RPC_AnyoneSpin(RPCMessage rpc)
public bool AnyoneSpin()
}
public Splitter : IOEntity {
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
}
public sRGB : object {
public Byte[] to_linear
public Byte[] to_srgb
public float linear_to_srgb(float linear)
public float srgb_to_linear(float srgb)
}
public StabilityEntity : DecayEntity {
public bool grounded
public float cachedStability
public int cachedDistanceFromGround
private List`1<Support> supports
private int stabilityStrikes
private bool dirty
public StabilityCheckWorkQueue stabilityCheckQueue
public UpdateSurroundingsQueue updateSurroundingsQueue
public void ResetState()
public void InitializeSupports()
public int DistanceFromGround(StabilityEntity ignoreEntity)
public float SupportValue(StabilityEntity ignoreEntity)
public int CachedDistanceFromGround(StabilityEntity ignoreEntity)
public float CachedSupportValue(StabilityEntity ignoreEntity)
public void StabilityCheck()
public void UpdateStability()
public void UpdateSurroundingEntities()
public void UpdateConnectedEntities()
protected void OnPhysicsNeighbourChanged()
protected void DebugNudge()
public void ServerInit()
internal void DoServerDestroy()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public StabilitySocket : Socket_Base {
public float support
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
}
public Stag : BaseAnimalNPC {
public float Population
public TraitFlag Traits
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public StagedResourceEntity : ResourceEntity {
public List`1<ResourceStage> stages
public int stage
public GameObjectRef changeStageEffect
public GameObject gibSourceTest
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
protected void OnHealthChanged()
protected void UpdateNetworkStage()
private int FindBestStage()
public T GetStageComponent()
private void UpdateStage()
}
public StashContainer : StorageContainer {
public Transform visuals
public float burriedOffset
public float raisedOffset
public GameObjectRef buryEffect
public float uncoverRange
private float lastToggleTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool PlayerInRange(BasePlayer ply)
public void SetHidden(bool isHidden)
public void Decay()
public void ServerInit()
public void ToggleHidden()
public void RPC_HideStash(RPCMessage rpc)
public void RPC_WantsUnhide(RPCMessage rpc)
public bool SupportsPooling()
public bool IsHidden()
}
public StateTimer : ValueType {
public float ReleaseTime
public Action OnFinished
public bool IsActive
public void Activate(float seconds, Action onFinished)
public bool get_IsActive()
}
public Stats : Enum {
public int value__
public Stats Steam
public Stats Server
public Stats All
}
public SteamFriendsList : MonoBehaviour {
public RectTransform targetPanel
public SteamUserButton userButton
public bool IncludeFriendsList
public bool IncludeRecentlySeen
public onFriendSelectedEvent onFriendSelected
}
public SteamInventory : EntityComponent`1<BasePlayer> {
private Item[] Items
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasItem(int itemid)
private void UpdateSteamInventory(RPCMessage msg)
private IEnumerator ProcessInventoryResult(Result result)
}
public SteamInventoryCategory : ScriptableObject {
public bool canBeSoldToOtherUsers
public bool canBeTradedWithOtherUsers
public bool isCommodity
public Price price
public DropChance dropChance
public bool CanBeInCrates
}
public SteamInventoryCrafting : MonoBehaviour {
public void Clear()
internal void Refresh()
}
public SteamInventoryIcon : MonoBehaviour {
private Item <WorkshopItem>k__BackingField
private Item WorkshopItem
private Item get_WorkshopItem()
private void set_WorkshopItem(Item value)
}
public SteamInventoryInfo : SingletonComponent`1<SteamInventoryInfo> {
public GameObject inventoryItemPrefab
public GameObject inventoryCanvas
public GameObject missingItems
public WorkshopInventoryCraftingControls CraftControl
}
public SteamInventoryItem : ScriptableObject {
public int id
public Sprite icon
public Phrase displayName
public Phrase displayDescription
public Category category
public SubCategory subcategory
public SteamInventoryCategory steamCategory
public bool PreventBreakingDown
public string itemname
public ulong workshopID
public ItemDefinition itemDefinition
public ItemDefinition get_itemDefinition()
}
public SteamStatistics : object {
private BasePlayer player
public Dictionary`2<string, int> intStats
private bool hasRefreshed
public void .ctor(BasePlayer p)
public void Init()
public void Save()
public void OnStatsRefreshed(ulong steamid, bool state)
public void Add(string name, int var)
}
public SteamUserButton : MonoBehaviour {
public Text steamName
public RawImage avatar
public Color textColorInGame
public Color textColorOnline
public Color textColorNormal
}
public Stocking : LootContainer {
public ListHashSet`1<Stocking> stockings
public void ServerInit()
internal void DoServerDestroy()
public bool IsEmpty()
public void SpawnLoot()
public void PlayerStoppedLooting(BasePlayer player)
}
public StorageContainer : DecayEntity {
public int inventorySlots
public float dropChance
public bool isLootable
public bool isLockable
public string panelName
public ContentsType allowedContents
public ItemDefinition allowedItem
public int maxStackSize
public bool needsBuildingPrivilegeToUse
public SoundDefinition openSound
public SoundDefinition closeSound
public Vector3 dropPosition
public Vector3 dropVelocity
public ItemCategory onlyAcceptCategory
public bool onlyOneUser
public ItemContainer inventory
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnDrawGizmos()
public void MoveAllInventoryItems(ItemContainer source, ItemContainer dest)
public void ReceiveInventoryFromItem(Item item)
public bool CanPickup(BasePlayer player)
public void OnPickedUp(Item createdItem, BasePlayer player)
public void ResetState()
public void ServerInit()
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool ItemFilter(Item item, int targetSlot)
public void CreateInventory(bool giveUID)
public void PreServerLoad()
protected void OnInventoryDirty()
public void PostServerLoad()
internal void DoServerDestroy()
public bool HasSlot(Slot slot)
private void RPC_OpenLoot(RPCMessage rpc)
public string GetPanelName()
public bool CanMoveFrom(BasePlayer player, Item item)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public bool PlayerOpenLoot(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen)
public void PlayerStoppedLooting(BasePlayer player)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public void DropItems()
public Vector3 GetDropPosition()
public Vector3 GetDropVelocity()
public bool ShouldDropItemsIndividually()
public void Load(LoadInfo info)
public bool OccupiedCheck(BasePlayer player)
}
public StreamEx : object {
private Byte[] StaticBuffer
public void WriteToOtherStream(Stream self, Stream target)
}
public StringFormatCache : object {
private Dictionary`2<Key1, string> dict1
private Dictionary`2<Key2, string> dict2
private Dictionary`2<Key3, string> dict3
private Dictionary`2<Key4, string> dict4
public string Get(string format, string value1)
public string Get(string format, string value1, string value2)
public string Get(string format, string value1, string value2, string value3)
public string Get(string format, string value1, string value2, string value3, string value4)
}
public StringPool : object {
public Dictionary`2<UInt32, string> toString
public Dictionary`2<string, UInt32> toNumber
private bool initialized
public UInt32 closest
private void Init()
public string Get(UInt32 i)
public UInt32 Get(string str)
public UInt32 Add(string str)
}
public SubsurfaceProfile : ScriptableObject {
private SubsurfaceProfileTexture profileTexture
public SubsurfaceProfileData Data
private int id
public Texture2D Texture
public int Id
public Texture2D get_Texture()
public int get_Id()
private void OnEnable()
private void OnDisable()
public void Update()
}
public SubsurfaceProfileData : ValueType {
public float ScatterRadius
public Color SubsurfaceColor
public Color FalloffColor
public SubsurfaceProfileData Default
public SubsurfaceProfileData Invalid
public SubsurfaceProfileData get_Default()
public SubsurfaceProfileData get_Invalid()
}
public SubsurfaceProfileTexture : object {
public int SUBSURFACE_RADIUS_SCALE
public int SUBSURFACE_KERNEL_SIZE
private List`1<SubsurfaceProfileEntry> entries
private Texture2D texture
public Texture2D Texture
public Texture2D get_Texture()
public int FindEntryIndex(SubsurfaceProfile profile)
public int AddProfile(SubsurfaceProfileData data, SubsurfaceProfile profile)
public void UpdateProfile(int id, SubsurfaceProfileData data)
public void RemoveProfile(int id)
public Color ColorClamp(Color color, float min, float max)
private Texture2D CreateTexture()
private void CheckReleaseTexture()
private void ReleaseTexture()
}
public SubsurfaceScatteringParams : ValueType {
public bool enabled
public Quality quality
public bool halfResolution
public float radiusScale
public SubsurfaceScatteringParams Default
}
public SunSettings : MonoBehaviour {
private Light light
private void OnEnable()
private void Update()
}
public SupplyDrop : LootContainer {
public GameObjectRef parachutePrefab
public BaseEntity parachute
public void ServerInit()
public void PostServerLoad()
public void RemoveParachute()
private void OnCollisionEnter(Collision collision)
}
public SupplySignal : TimedExplosive {
public GameObjectRef smokeEffectPrefab
public GameObjectRef EntityToCreate
public GameObject smokeEffect
public void Explode()
public void FinishUp()
}
public SurveyCharge : TimedExplosive {
public GameObjectRef craterPrefab
public GameObjectRef craterPrefab_Oil
public void Explode()
}
public SurveyCrater : BaseCombatEntity {
private ResourceDispenser resourceDispenser
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void OnAttacked(HitInfo info)
public void RemoveMe()
public void AnalysisComplete(RPCMessage msg)
public float BoundsPadding()
}
public SwapArrows : MonoBehaviour {
public GameObject[] arrowModels
private string curAmmoType
public void SelectArrowType(int iType)
public void HideAllArrowHeads()
public void UpdateAmmoType(ItemDefinition ammoType)
private void Cleanup()
public void OnDisable()
public void OnEnable()
}
public SwapKeycard : MonoBehaviour {
public GameObject[] accessLevels
public void UpdateAccessLevel(int level)
}
public SwapRPG : MonoBehaviour {
public GameObject[] rpgModels
private string curAmmoType
public void SelectRPGType(int iType)
public void UpdateAmmoType(ItemDefinition ammoType)
private void Start()
}
public SynchronizedClock : object {
public List`1<TimedEvent> events
private long Ticks
private float DayLengthInMinutes
private long get_Ticks()
private float get_DayLengthInMinutes()
public void Add(float delta, float variance, Action`1<UInt32> action)
public void Tick()
}
public SystemInfoEx : object {
public int systemMemoryUsed
private ulong System_GetMemoryUsage()
public int get_systemMemoryUsed()
}
public SystemInfoGeneralText : MonoBehaviour {
public Text text
public string currentInfo
public string get_currentInfo()
protected void Update()
private long MB(long bytes)
private long MB(ulong bytes)
private int KM2(float meters)
}
public TeamMemberElement : MonoBehaviour {
public Text nameText
public RawImage icon
public Color onlineColor
public Color offlineColor
public Color deadColor
public GameObject hoverOverlay
public RawImage memberIcon
public RawImage leaderIcon
public RawImage deadIcon
public int teamIndex
}
public TeamMemberMapMarker : MonoBehaviour {
public RectTransform rectTransform
public Text nameTagText
public Tooltip toolTip
}
public TeamUI : MonoBehaviour {
public RectTransform MemberPanel
public GameObject memberEntryPrefab
public TeamMemberElement[] elements
public GameObject NoTeamPanel
public GameObject TeamPanel
public GameObject LeaveTeamButton
public GameObject InviteAcceptPanel
public Text inviteText
public bool dirty
public ulong pendingTeamID
public string pendingTeamLeaderName
}
public TerrainAlphaMap : TerrainMap`1<byte> {
public Texture2D AlphaTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetAlpha(Vector3 worldPos)
public float GetAlpha(float normX, float normZ)
public float GetAlpha(int x, int z)
public void SetAlpha(Vector3 worldPos, float a)
public void SetAlpha(float normX, float normZ, float a)
public void SetAlpha(int x, int z, float a)
public void SetAlpha(int x, int z, float a, float opacity)
public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade)
public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade)
}
public TerrainAnchor : PrefabAttribute {
public float Extents
public float Offset
protected void OnDrawGizmosSelected()
public void Apply(Single& height, Single& min, Single& max, Vector3 pos)
protected Type GetIndexedType()
}
public TerrainAnchorEx : object {
public bool ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors, Vector3& pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public bool ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors, Vector3& pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter)
public void ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors)
}
public TerrainAnchorGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementPadding
public float PlacementFade
public float PlacementDistance
public float AnchorExtentsMin
public float AnchorExtentsMax
public float AnchorOffsetMin
public float AnchorOffsetMax
}
public TerrainAnchorMode : Enum {
public int value__
public TerrainAnchorMode MinimizeError
public TerrainAnchorMode MinimizeMovement
}
public TerrainAtlasSet : ScriptableObject {
public int SplatCount
public int SplatSize
public int MaxSplatSize
public int SplatPadding
public int AtlasSize
public int RegionSize
public int SplatsPerLine
public int SourceTypeCount
public int AtlasMipCount
public String[] sourceTypeNames
public String[] sourceTypeNamesExt
public String[] sourceTypePostfix
public String[] splatNames
public Boolean[] albedoHighpass
public String[] albedoPaths
public Color[] defaultValues
public SourceMapSet[] sourceMaps
public bool highQualityCompression
public bool generateTextureAtlases
public bool generateTextureArrays
public string splatSearchPrefix
public string splatSearchFolder
public string albedoAtlasSavePath
public string normalAtlasSavePath
public string albedoArraySavePath
public string normalArraySavePath
public void CheckReset()
}
public TerrainBiomeMap : TerrainMap`1<byte> {
public Texture2D BiomeTexture
internal int num
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetBiomeMax(Vector3 worldPos, int mask)
public float GetBiomeMax(float normX, float normZ, int mask)
public float GetBiomeMax(int x, int z, int mask)
public int GetBiomeMaxIndex(Vector3 worldPos, int mask)
public int GetBiomeMaxIndex(float normX, float normZ, int mask)
public int GetBiomeMaxIndex(int x, int z, int mask)
public int GetBiomeMaxType(Vector3 worldPos, int mask)
public int GetBiomeMaxType(float normX, float normZ, int mask)
public int GetBiomeMaxType(int x, int z, int mask)
public float GetBiome(Vector3 worldPos, int mask)
public float GetBiome(float normX, float normZ, int mask)
public float GetBiome(int x, int z, int mask)
public void SetBiome(Vector3 worldPos, int id)
public void SetBiome(float normX, float normZ, int id)
public void SetBiome(int x, int z, int id)
public void SetBiome(Vector3 worldPos, int id, float v)
public void SetBiome(float normX, float normZ, int id, float v)
public void SetBiome(int x, int z, int id, float v)
public void SetBiomeRaw(int x, int z, Vector4 v, float opacity)
private void SetBiome(int x, int z, int id, float old_val, float new_val)
}
public TerrainBlendMap : TerrainMap`1<byte> {
public Texture2D BlendTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetAlpha(Vector3 worldPos)
public float GetAlpha(float normX, float normZ)
public float GetAlpha(int x, int z)
public void SetAlpha(Vector3 worldPos, float a)
public void SetAlpha(float normX, float normZ, float a)
public void SetAlpha(int x, int z, float a)
public void SetAlpha(int x, int z, float a, float opacity)
public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade)
public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade)
}
public TerrainCarve : TerrainModifier {
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainCheck : PrefabAttribute {
public bool Rotate
public float Extents
protected void OnDrawGizmosSelected()
public bool Check(Vector3 pos)
protected Type GetIndexedType()
}
public TerrainCheckEx : object {
public bool ApplyTerrainChecks(Transform transform, TerrainCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
}
public TerrainCheckGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementPadding
public float PlacementFade
public float PlacementDistance
public float CheckExtentsMin
public float CheckExtentsMax
public bool CheckRotate
}
public TerrainCheckGeneratorVolumes : MonoBehaviour {
public float PlacementRadius
protected void OnDrawGizmosSelected()
}
public TerrainCollision : TerrainExtension {
private ListDictionary`2<Collider, List`1<Collider>> ignoredColliders
private TerrainCollider terrainCollider
public void Setup()
public void Clear()
public void Reset(Collider collider)
public bool GetIgnore(Vector3 pos, float radius)
public bool GetIgnore(RaycastHit hit)
public bool GetIgnore(Collider collider)
public void SetIgnore(Collider collider, Collider trigger, bool ignore)
protected void LateUpdate()
}
public TerrainCollisionProxy : MonoBehaviour {
public WheelCollider[] colliders
}
public TerrainCollisionTrigger : EnvironmentVolumeTrigger {
protected void OnTriggerEnter(Collider other)
protected void OnTriggerExit(Collider other)
private void UpdateCollider(Collider other, bool state)
}
public TerrainColors : TerrainExtension {
private TerrainSplatMap splatMap
private TerrainBiomeMap biomeMap
public void Setup()
public Color GetColor(Vector3 worldPos, int mask)
public Color GetColor(float normX, float normZ, int mask)
}
public TerrainConfig : ScriptableObject {
public bool CastShadows
public LayerMask GroundMask
public LayerMask WaterMask
public PhysicMaterial GenericMaterial
public Material Material
public Texture AlbedoArray
public Texture NormalArray
public float HeightMapErrorMin
public float HeightMapErrorMax
public float BaseMapDistanceMin
public float BaseMapDistanceMax
public float ShaderLodMin
public float ShaderLodMax
public SplatType[] Splats
public PhysicMaterial[] GetPhysicMaterials()
public Color[] GetAridColors()
public Color[] GetTemperateColors()
public Color[] GetTundraColors()
public Color[] GetArcticColors()
public Single[] GetSplatTiling()
public float GetMaxSplatTiling()
public float GetMinSplatTiling()
public Vector3[] GetPackedUVMIX()
}
public TerrainExtension : MonoBehaviour {
public bool isInitialized
internal Terrain terrain
internal TerrainConfig config
public void Init(Terrain terrain, TerrainConfig config)
public void Setup()
public void PostSetup()
public void LogSize(object obj, ulong size)
}
public TerrainFilter : PrefabAttribute {
public SpawnFilter Filter
protected void OnDrawGizmosSelected()
public bool Check(Vector3 pos)
protected Type GetIndexedType()
}
public TerrainFilterEx : object {
public bool ApplyTerrainFilters(Transform transform, TerrainFilter[] filters, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter globalFilter)
}
public TerrainGenerator : SingletonComponent`1<TerrainGenerator> {
public TerrainConfig config
private float HeightMapRes
private float SplatMapRes
private float BaseMapRes
public GameObject CreateTerrain()
}
public TerrainHeightAdd : TerrainModifier {
public float Delta
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainHeightMap : TerrainMap`1<short> {
public Texture2D HeightTexture
public Texture2D NormalTexture
private float normY
public void Setup()
public void ApplyToTerrain()
public void GenerateTextures(bool heightTexture, bool normalTexture)
public void ApplyTextures()
public float GetHeight(Vector3 worldPos)
public float GetHeight(float normX, float normZ)
public float GetHeight(int x, int z)
public float GetHeight01(Vector3 worldPos)
public float GetHeight01(float normX, float normZ)
public float GetHeight01(int x, int z)
private float GetSrcHeight01(int x, int z)
private float GetDstHeight01(int x, int z)
public Vector3 GetNormal(Vector3 worldPos)
public Vector3 GetNormal(float normX, float normZ)
public Vector3 GetNormal(int x, int z)
private Vector3 GetNormalSobel(int x, int z)
public float GetSlope(Vector3 worldPos)
public float GetSlope(float normX, float normZ)
public float GetSlope(int x, int z)
public float GetSlope01(Vector3 worldPos)
public float GetSlope01(float normX, float normZ)
public float GetSlope01(int x, int z)
public void SetHeight(Vector3 worldPos, float height)
public void SetHeight(float normX, float normZ, float height)
public void SetHeight(int x, int z, float height)
public void SetHeight(Vector3 worldPos, float height, float opacity)
public void SetHeight(float normX, float normZ, float height, float opacity)
public void SetHeight(int x, int z, float height, float opacity)
public void AddHeight(Vector3 worldPos, float delta)
public void AddHeight(float normX, float normZ, float delta)
public void AddHeight(int x, int z, float delta)
public void LowerHeight(Vector3 worldPos, float height, float opacity)
public void LowerHeight(float normX, float normZ, float height, float opacity)
public void LowerHeight(int x, int z, float height, float opacity)
public void RaiseHeight(Vector3 worldPos, float height, float opacity)
public void RaiseHeight(float normX, float normZ, float height, float opacity)
public void RaiseHeight(int x, int z, float height, float opacity)
public void SetHeight(Vector3 worldPos, float opacity, float radius, float fade)
public void SetHeight(float normX, float normZ, float height, float opacity, float radius, float fade)
public void LowerHeight(Vector3 worldPos, float opacity, float radius, float fade)
public void LowerHeight(float normX, float normZ, float height, float opacity, float radius, float fade)
public void RaiseHeight(Vector3 worldPos, float opacity, float radius, float fade)
public void RaiseHeight(float normX, float normZ, float height, float opacity, float radius, float fade)
public void AddHeight(Vector3 worldPos, float delta, float radius, float fade)
public void AddHeight(float normX, float normZ, float delta, float radius, float fade)
}
public TerrainHeightSet : TerrainModifier {
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainMap : TerrainExtension {
internal int res
public void ApplyFilter(float normX, float normZ, float radius, float fade, Action`3<int, int, float> action)
public void ForEach(Vector3 worldPos, float radius, Action`2<int, int> action)
public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Action`2<int, int> action)
public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action)
public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Action`2<int, int> action)
public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action)
private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action, Vector2i min, Vector2i max)
public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action`2<int, int> action)
public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action)
public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action`2<int, int> action)
public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action)
private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action, Vector2i min, Vector2i max)
public void ForEach(int x_min, int x_max, int z_min, int z_max, Action`2<int, int> action)
public void ForEach(Action`2<int, int> action)
public int Index(float normalized)
public float Coordinate(int index)
}
public TerrainMap`1 : TerrainMap {
internal T[] src
internal T[] dst
public void Push()
public void Pop()
public IEnumerable`1<T> ToEnumerable()
public int BytesPerElement()
public long GetMemoryUsage()
public Byte[] ToByteArray()
public void FromByteArray(Byte[] dat)
}
public TerrainMargin : object {
public void Create()
private void Create(Vector3 position, Vector3 size, Material material)
}
public TerrainMeta : MonoBehaviour {
public Terrain terrain
public TerrainConfig config
public PaintMode paint
public PaintMode currentPaintMode
private TerrainConfig <Config>k__BackingField
private Terrain <Terrain>k__BackingField
private Transform <Transform>k__BackingField
private Vector3 <Position>k__BackingField
private Vector3 <Size>k__BackingField
private Vector3 <OneOverSize>k__BackingField
private Vector3 <HighestPoint>k__BackingField
private Vector3 <LowestPoint>k__BackingField
private float <LootAxisAngle>k__BackingField
private float <BiomeAxisAngle>k__BackingField
private TerrainData <Data>k__BackingField
private TerrainCollider <Collider>k__BackingField
private TerrainCollision <Collision>k__BackingField
private TerrainPhysics <Physics>k__BackingField
private TerrainColors <Colors>k__BackingField
private TerrainQuality <Quality>k__BackingField
private TerrainPath <Path>k__BackingField
private TerrainBiomeMap <BiomeMap>k__BackingField
private TerrainAlphaMap <AlphaMap>k__BackingField
private TerrainBlendMap <BlendMap>k__BackingField
private TerrainHeightMap <HeightMap>k__BackingField
private TerrainSplatMap <SplatMap>k__BackingField
private TerrainTopologyMap <TopologyMap>k__BackingField
private TerrainWaterMap <WaterMap>k__BackingField
private TerrainTexturing <Texturing>k__BackingField
public TerrainConfig Config
public Terrain Terrain
public Transform Transform
public Vector3 Position
public Vector3 Size
public Vector3 Center
public Vector3 OneOverSize
public Vector3 HighestPoint
public Vector3 LowestPoint
public float LootAxisAngle
public float BiomeAxisAngle
public TerrainData Data
public TerrainCollider Collider
public TerrainCollision Collision
public TerrainPhysics Physics
public TerrainColors Colors
public TerrainQuality Quality
public TerrainPath Path
public TerrainBiomeMap BiomeMap
public TerrainAlphaMap AlphaMap
public TerrainBlendMap BlendMap
public TerrainHeightMap HeightMap
public TerrainSplatMap SplatMap
public TerrainTopologyMap TopologyMap
public TerrainWaterMap WaterMap
public TerrainTexturing Texturing
public TerrainConfig get_Config()
private void set_Config(TerrainConfig value)
public Terrain get_Terrain()
private void set_Terrain(Terrain value)
public Transform get_Transform()
private void set_Transform(Transform value)
public Vector3 get_Position()
private void set_Position(Vector3 value)
public Vector3 get_Size()
private void set_Size(Vector3 value)
public Vector3 get_Center()
public Vector3 get_OneOverSize()
private void set_OneOverSize(Vector3 value)
public Vector3 get_HighestPoint()
public void set_HighestPoint(Vector3 value)
public Vector3 get_LowestPoint()
public void set_LowestPoint(Vector3 value)
public float get_LootAxisAngle()
private void set_LootAxisAngle(float value)
public float get_BiomeAxisAngle()
private void set_BiomeAxisAngle(float value)
public TerrainData get_Data()
private void set_Data(TerrainData value)
public TerrainCollider get_Collider()
private void set_Collider(TerrainCollider value)
public TerrainCollision get_Collision()
private void set_Collision(TerrainCollision value)
public TerrainPhysics get_Physics()
private void set_Physics(TerrainPhysics value)
public TerrainColors get_Colors()
private void set_Colors(TerrainColors value)
public TerrainQuality get_Quality()
private void set_Quality(TerrainQuality value)
public TerrainPath get_Path()
private void set_Path(TerrainPath value)
public TerrainBiomeMap get_BiomeMap()
private void set_BiomeMap(TerrainBiomeMap value)
public TerrainAlphaMap get_AlphaMap()
private void set_AlphaMap(TerrainAlphaMap value)
public TerrainBlendMap get_BlendMap()
private void set_BlendMap(TerrainBlendMap value)
public TerrainHeightMap get_HeightMap()
private void set_HeightMap(TerrainHeightMap value)
public TerrainSplatMap get_SplatMap()
private void set_SplatMap(TerrainSplatMap value)
public TerrainTopologyMap get_TopologyMap()
private void set_TopologyMap(TerrainTopologyMap value)
public TerrainWaterMap get_WaterMap()
private void set_WaterMap(TerrainWaterMap value)
public TerrainTexturing get_Texturing()
private void set_Texturing(TerrainTexturing value)
public bool OutOfBounds(Vector3 worldPos)
public bool OutOfMargin(Vector3 worldPos)
public Vector3 Normalize(Vector3 worldPos)
public float NormalizeX(float x)
public float NormalizeY(float y)
public float NormalizeZ(float z)
public Vector3 Denormalize(Vector3 normPos)
public float DenormalizeX(float normX)
public float DenormalizeY(float normY)
public float DenormalizeZ(float normZ)
protected void Awake()
public void Init(Terrain terrainOverride, TerrainConfig configOverride)
public void InitNoTerrain()
public void SetupComponents()
public void PostSetupComponents()
public void BindShaderProperties()
}
public TerrainModifier : PrefabAttribute {
public float Opacity
public float Radius
public float Fade
protected void OnDrawGizmosSelected()
public void Apply(Vector3 pos, float scale)
protected void Apply(Vector3 position, float opacity, float radius, float fade)
protected Type GetIndexedType()
}
public TerrainModifierEx : object {
public void ApplyTerrainModifiers(Transform transform, TerrainModifier[] modifiers, Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyTerrainModifiers(Transform transform, TerrainModifier[] modifiers)
}
public TerrainPath : TerrainExtension {
public List`1<PathList> Roads
public List`1<PathList> Rivers
public List`1<PathList> Powerlines
public List`1<MonumentInfo> Monuments
public List`1<RiverInfo> RiverObjs
public List`1<LakeInfo> LakeObjs
internal List`1<Vector3> OceanPatrolClose
internal List`1<Vector3> OceanPatrolFar
private Dictionary`2<string, List`1<PowerlineNode>> wires
public void Clear()
public void AddWire(PowerlineNode node)
public void CreateWires()
private void CreateWire(string name, List`1<GameObject> objects, Material material)
}
public TerrainPathChildObjects : MonoBehaviour {
public bool Spline
public float Width
public float Offset
public float Fade
public Enum Splat
public Enum Topology
public InfrastructureType Type
protected void Awake()
protected void OnDrawGizmos()
}
public TerrainPathConnect : MonoBehaviour {
public InfrastructureType Type
public Point GetPoint(int res)
}
public TerrainPhysics : TerrainExtension {
private TerrainSplatMap splat
private PhysicMaterial[] materials
public void Setup()
public PhysicMaterial GetMaterial(Vector3 worldPos)
}
public TerrainPlacement : PrefabAttribute {
public Vector3 size
public Vector3 extents
public Vector3 offset
public bool HeightMap
public bool AlphaMap
public bool WaterMap
public Enum SplatMask
public Enum BiomeMask
public Enum TopologyMask
public Texture2D heightmap
public Texture2D splatmap0
public Texture2D splatmap1
public Texture2D alphamap
public Texture2D biomemap
public Texture2D topologymap
public Texture2D watermap
public Texture2D blendmap
public void RefreshTerrainData()
public void Apply(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected bool ShouldHeight()
protected bool ShouldSplat(int id)
protected bool ShouldAlpha()
protected bool ShouldBiome(int id)
protected bool ShouldTopology(int id)
protected bool ShouldWater()
protected void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected Type GetIndexedType()
}
public TerrainPlacementEx : object {
public void ApplyTerrainPlacements(Transform transform, TerrainPlacement[] placements, Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyTerrainPlacements(Transform transform, TerrainPlacement[] placements)
}
public TerrainSplatMap : TerrainMap`1<byte> {
public Texture2D SplatTexture0
public Texture2D SplatTexture1
internal int num
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetSplatMax(Vector3 worldPos, int mask)
public float GetSplatMax(float normX, float normZ, int mask)
public float GetSplatMax(int x, int z, int mask)
public int GetSplatMaxIndex(Vector3 worldPos, int mask)
public int GetSplatMaxIndex(float normX, float normZ, int mask)
public int GetSplatMaxIndex(int x, int z, int mask)
public int GetSplatMaxType(Vector3 worldPos, int mask)
public int GetSplatMaxType(float normX, float normZ, int mask)
public int GetSplatMaxType(int x, int z, int mask)
public float GetSplat(Vector3 worldPos, int mask)
public float GetSplat(float normX, float normZ, int mask)
public float GetSplat(int x, int z, int mask)
public void SetSplat(Vector3 worldPos, int id)
public void SetSplat(float normX, float normZ, int id)
public void SetSplat(int x, int z, int id)
public void SetSplat(Vector3 worldPos, int id, float v)
public void SetSplat(float normX, float normZ, int id, float v)
public void SetSplat(int x, int z, int id, float v)
public void SetSplatRaw(int x, int z, Vector4 v1, Vector4 v2, float opacity)
public void SetSplat(Vector3 worldPos, int id, float opacity, float radius, float fade)
public void SetSplat(float normX, float normZ, int id, float opacity, float radius, float fade)
public void AddSplat(Vector3 worldPos, int id, float delta, float radius, float fade)
public void AddSplat(float normX, float normZ, int id, float delta, float radius, float fade)
private void SetSplat(int x, int z, int id, float old_val, float new_val)
}
public TerrainSplatSet : TerrainModifier {
public Enum SplatType
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainTexturing : TerrainExtension {
private int coarseHeightDownscale
public bool debugFoliageDisplacement
private int CoarseSlopeBlurPasses
private float CoarseSlopeBlurRadius
}
public TerrainTopologyAdd : TerrainModifier {
public Enum TopologyType
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainTopologyMap : TerrainMap`1<int> {
public Texture2D TopologyTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public bool GetTopology(Vector3 worldPos, int mask)
public bool GetTopology(float normX, float normZ, int mask)
public bool GetTopology(int x, int z, int mask)
public int GetTopology(Vector3 worldPos)
public int GetTopology(float normX, float normZ)
public int GetTopology(int x, int z)
public void SetTopology(Vector3 worldPos, int mask)
public void SetTopology(float normX, float normZ, int mask)
public void SetTopology(int x, int z, int mask)
public void AddTopology(Vector3 worldPos, int mask)
public void AddTopology(float normX, float normZ, int mask)
public void AddTopology(int x, int z, int mask)
public void RemoveTopology(Vector3 worldPos, int mask)
public void RemoveTopology(float normX, float normZ, int mask)
public void RemoveTopology(int x, int z, int mask)
public int GetTopology(Vector3 worldPos, float radius)
public int GetTopology(float normX, float normZ, float radius)
public void SetTopology(Vector3 worldPos, int mask, float radius, float fade)
public void SetTopology(float normX, float normZ, int mask, float radius, float fade)
public void AddTopology(Vector3 worldPos, int mask, float radius, float fade)
public void AddTopology(float normX, float normZ, int mask, float radius, float fade)
}
public TerrainTopologySet : TerrainModifier {
public Enum TopologyType
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainWaterMap : TerrainMap`1<short> {
public Texture2D WaterTexture
private float normY
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetHeight(Vector3 worldPos)
public float GetHeight(float normX, float normZ)
public float GetHeight(int x, int z)
public float GetHeight01(Vector3 worldPos)
public float GetHeight01(float normX, float normZ)
public float GetHeight01(int x, int z)
public Vector3 GetNormal(Vector3 worldPos)
public Vector3 GetNormal(float normX, float normZ)
public Vector3 GetNormal(int x, int z)
public float GetSlope(Vector3 worldPos)
public float GetSlope(float normX, float normZ)
public float GetSlope(int x, int z)
public float GetSlope01(Vector3 worldPos)
public float GetSlope01(float normX, float normZ)
public float GetSlope01(int x, int z)
public float GetDepth(Vector3 worldPos)
public float GetDepth(float normX, float normZ)
public void SetHeight(Vector3 worldPos, float height)
public void SetHeight(float normX, float normZ, float height)
public void SetHeight(int x, int z, float height)
}
public TextEntryCookie : MonoBehaviour {
public InputField control
public InputField get_control()
private void OnEnable()
private void OnDisable()
}
internal TextureCacheState : Enum {
public int value__
public TextureCacheState Skipped
public TextureCacheState Initializing
public TextureCacheState Uncached
public TextureCacheState CachedRaw
}
public TextureColorPicker : MonoBehaviour {
public Texture2D texture
public onColorSelectedEvent onColorSelected
public void OnPointerDown(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
}
public TextureData : ValueType {
public int width
public int height
public Color32[] colors
public void .ctor(Texture2D tex)
public Color32 GetColor(int x, int y)
public int GetShort(int x, int y)
public int GetInt(int x, int y)
public float GetFloat(int x, int y)
public float GetHalf(int x, int y)
public Vector4 GetVector(int x, int y)
public Vector3 GetNormal(int x, int y)
public Color32 GetInterpolatedColor(float x, float y)
public int GetInterpolatedInt(float x, float y)
public int GetInterpolatedShort(float x, float y)
public float GetInterpolatedFloat(float x, float y)
public float GetInterpolatedHalf(float x, float y)
public Vector4 GetInterpolatedVector(float x, float y)
public Vector3 GetInterpolatedNormal(float x, float y)
}
public ThrownWeapon : AttackEntity {
public GameObjectRef prefabToThrow
public float maxThrowVelocity
public float tumbleVelocity
public Vector3 overrideAngle
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void DoThrow(RPCMessage msg)
private void DoDrop(RPCMessage msg)
}
public TickInterpolator : object {
private List`1<Segment> points
private int index
public float Length
public Vector3 CurrentPoint
public Vector3 StartPoint
public Vector3 EndPoint
public void Reset()
public void Reset(Vector3 point)
public void AddPoint(Vector3 point)
public bool MoveNext(float distance)
public bool HasNext()
}
public TimeBasedSoundSpread : SoundModifier {
public AnimationCurve spreadCurve
public AnimationCurve wanderIntensityCurve
}
public TimedExplosive : BaseEntity {
public float timerAmountMin
public float timerAmountMax
public float minExplosionRadius
public float explosionRadius
public bool canStick
public bool onlyDamageParent
public GameObjectRef explosionEffect
public GameObjectRef stickEffect
public GameObjectRef bounceEffect
public bool explosionUsesForward
public bool waterCausesExplosion
public List`1<DamageTypeEntry> damageTypes
private float lastBounceTime
public void ServerInit()
public void WaterCheck()
public void SetFuse(float fuseLength)
public float GetRandomTimerTime()
public void ProjectileImpact(RaycastHit info)
public void Explode()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public bool CanStickTo(BaseEntity entity)
private void DoBounceEffect()
private void DoCollisionStick(Collision collision, BaseEntity ent)
public void SetMotionEnabled(bool wantsMotion)
public bool IsStuck()
public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent)
private void UnStick()
internal void OnParentRemoved()
public void SetCollisionEnabled(bool wantsCollision)
}
public TimedRemoval : MonoBehaviour {
public Object objectToDestroy
public float removeDelay
private void OnEnable()
}
public TimedUnlootableCrate : LootContainer {
public bool unlootableOnSpawn
public float unlootableDuration
public void ServerInit()
public void SetUnlootableFor(float duration)
public void MakeLootable()
}
public TimerSwitch : IOEntity {
public float timerLength
public Transform timerDrum
private float timePassed
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public void SVSwitch(RPCMessage msg)
public void AdvanceTime()
public void EndTimer()
public float GetPassedTime()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public TimeSlider : MonoBehaviour {
private Slider slider
private void Start()
private void Update()
public void OnValue(float f)
}
public TimeSpanEx : object {
public string ToShortString(TimeSpan timeSpan)
}
public Timing : ValueType {
private Stopwatch sw
private string name
public void .ctor(string name)
public Timing Start(string name)
public void End()
}
public ToggleGroupCookie : MonoBehaviour {
private Func`2<Toggle, bool> <>f__am$cache0
private Func`2<Toggle, bool> <>f__am$cache1
public ToggleGroup group
public ToggleGroup get_group()
private void OnEnable()
private void OnDisable()
private void SetupListeners()
private void OnToggleChanged(bool b)
private bool <OnEnable>m__0(Toggle x)
private bool <OnToggleChanged>m__1(Toggle x)
}
public ToggleLayer : MonoBehaviour {
public Toggle toggleControl
public Text textControl
public LayerSelect layer
protected void OnEnable()
public void OnToggleChanged()
protected void OnValidate()
}
public ToggleTerrainRenderer : MonoBehaviour {
public Toggle toggleControl
public Text textControl
protected void OnEnable()
public void OnToggleChanged()
protected void OnValidate()
}
public ToggleTerrainTrees : MonoBehaviour {
public Toggle toggleControl
public Text textControl
protected void OnEnable()
public void OnToggleChanged()
protected void OnValidate()
}
public TonemappingOverlay : ImageEffectLayer {
public TonemappingColorGrading tonemapping
}
public Tooltip : BaseMonoBehaviour {
public GameObject Current
public string Text
public GameObject TooltipObject
public string token
public string english
public string get_english()
}
public TorchWeapon : BaseMelee {
public float fuelTickAmount
public AnimatorOverrideController LitHoldAnimationOverride
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void GetAttackStats(HitInfo info)
public float GetConditionLoss()
private void Ignite(RPCMessage msg)
private void Extinguish(RPCMessage msg)
public void UseFuel()
public void OnHeldChanged()
}
public TransformInterpolator : object {
public List`1<Entry> list
public Entry last
public void Add(Entry tick)
public void Cull(float beforeTime)
public void Clear()
public Segment Query(float time, float interpolation, float extrapolation, float smoothing)
}
public TransformUtil : object {
private Func`2<RaycastHit, float> <>f__am$cache0
private Func`2<Transform, bool> <>f__am$cache1
public bool GetGroundInfo(Vector3 startPos, RaycastHit& hit, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, RaycastHit& hit, float range, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, RaycastHit& hitOut, float range, LayerMask mask, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, float range, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, float range, LayerMask mask, Transform ignoreTransform)
public bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal)
public bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal, float range)
public bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal, float range, LayerMask mask)
public Transform[] GetRootObjects()
private float <GetGroundInfo>m__0(RaycastHit h)
private bool <GetRootObjects>m__1(Transform x)
}
public Translate : object {
public string TranslateMouseButton(string mouseButton)
}
public TrappableWildlife : ScriptableObject {
public GameObjectRef worldObject
public ItemDefinition inventoryObject
public int minToCatch
public int maxToCatch
public List`1<BaitType> baitTypes
public int caloriesForInterest
public float successRate
public float xpScale
}
public TreadAnimator : MonoBehaviour {
public Animator mainBodyAnimator
public Transform[] wheelBones
public Vector3[] vecShocksOffsetPosition
public Vector3[] wheelBoneOrigin
public float wheelBoneDistMax
public Renderer treadRenderer
public Material leftTread
public Material rightTread
public TreadEffects treadEffects
}
public TreadEffects : MonoBehaviour {
public ParticleSystem[] rearTreadDirt
public ParticleSystem[] rearTreadSmoke
public ParticleSystem[] middleTreadSmoke
}
public TreeEntity : ResourceEntity {
public GameObjectRef prefab
public bool hasBonusGame
public GameObjectRef bonusHitEffect
public GameObjectRef bonusHitSound
public Collider serverCollider
public Collider clientCollider
public SoundDefinition smallCrackSoundDef
public SoundDefinition medCrackSoundDef
private float lastAttackDamage
protected BaseEntity xMarker
private int currentBonusLevel
private float lastDirection
private float lastHitTime
public bool fallOnKilled
public float fallDuration
public GameObjectRef fallStartSound
public GameObjectRef fallImpactSound
public GameObjectRef fallImpactParticles
public SoundDefinition fallLeavesLoopDef
public Boolean[] usedHeights
public bool impactSoundPlayed
public float treeDistanceUponFalling
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void DestroyShared()
public float BoundsPadding()
public bool SupportsPooling()
public void ServerInit()
public bool DidHitMarker(HitInfo info)
public void StartBonusGame()
public void StopBonusGame()
public bool BonusActive()
public void OnAttacked(HitInfo info)
public void CleanupMarker()
public Collider GetCollider()
public void OnKilled(HitInfo info)
public void DelayedKill()
}
public TreeLOD : LODComponent {
public State[] States
}
public TreeMarker : BaseEntity {
public GameObjectRef hitEffect
public SoundDefinition hitEffectSound
public GameObjectRef spawnEffect
public DeferredDecal myDecal
private Vector3 initialPosition
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public TriggerBanditZone : TriggerBase {
public float GetBanditZoneLevel(Vector3 pos)
}
public TriggerBase : BaseMonoBehaviour {
public LayerMask interestLayers
public HashSet`1<GameObject> contents
public HashSet`1<BaseEntity> entityContents
internal GameObject InterestedInObject(GameObject obj)
protected void OnDisable()
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
internal void OnObjectAdded(GameObject obj)
internal void OnObjectRemoved(GameObject obj)
internal void RemoveInvalidEntities()
internal bool CheckEntity(BaseEntity ent)
internal void OnObjects()
internal void OnEmpty()
public void RemoveObject(GameObject obj)
public void RemoveEntity(BaseEntity obj)
private void OnTriggerEnter(Collider collider)
private void OnTriggerExit(Collider collider)
private void OnTriggerExit(GameObject targetObj)
}
public TriggerComfort : TriggerBase {
public float triggerSize
public float baseComfort
public float minComfortRange
private float perPlayerComfortBonus
private float bonusComfort
private List`1<BasePlayer> _players
private void OnValidate()
internal GameObject InterestedInObject(GameObject obj)
public float CalculateComfort(Vector3 position, BasePlayer forPlayer)
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
}
public TriggeredEventPrefab : TriggeredEvent {
public GameObjectRef targetPrefab
private void RunEvent()
}
public TriggerHurt : TriggerBase {
public float DamagePerSecond
public float DamageTickRate
public DamageType damageType
internal GameObject InterestedInObject(GameObject obj)
internal void OnObjects()
internal void OnEmpty()
private void OnTick()
}
public TriggerHurtEx : TriggerBase {
public float repeatRate
public List`1<DamageTypeEntry> damageOnEnter
public GameObjectRef effectOnEnter
public HurtType hurtTypeOnEnter
public List`1<DamageTypeEntry> damageOnTimer
public GameObjectRef effectOnTimer
public HurtType hurtTypeOnTimer
public List`1<DamageTypeEntry> damageOnMove
public GameObjectRef effectOnMove
public HurtType hurtTypeOnMove
public List`1<DamageTypeEntry> damageOnLeave
public GameObjectRef effectOnLeave
public HurtType hurtTypeOnLeave
public bool damageEnabled
internal Dictionary`2<BaseEntity, EntityTriggerInfo> entityInfo
internal List`1<BaseEntity> entityAddList
internal List`1<BaseEntity> entityLeaveList
internal GameObject InterestedInObject(GameObject obj)
internal void DoDamage(BaseEntity ent, HurtType type, List`1<DamageTypeEntry> damage, GameObjectRef effect, float multiply)
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
internal void OnObjects()
internal void OnEmpty()
private void OnTick()
private void ProcessQueues()
}
public TriggerLadder : TriggerBase {
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerMovement : TriggerBase {
public MovementModify movementModify
}
public TriggerRadiation : TriggerBase {
public RadiationTier radiationTier
public float RadiationAmountOverride
public float radiationSize
public float falloff
public float GetRadiationAmount()
private void OnValidate()
public float GetRadiation(Vector3 position, float radProtection)
internal GameObject InterestedInObject(GameObject obj)
public void OnDrawGizmosSelected()
}
public TriggerSafeZone : TriggerBase {
public float GetSafeLevel(Vector3 pos)
}
public TriggerTemperature : TriggerBase {
public float Temperature
public float triggerSize
private void OnValidate()
public float WorkoutTemperature(Vector3 position, float oldTemperature)
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerWorkbench : TriggerBase {
public Workbench parentBench
internal GameObject InterestedInObject(GameObject obj)
public float WorkbenchLevel()
}
public trisPerSubmesh : object {
public Int32[] triangles
}
public TweakUI : SingletonComponent`1<TweakUI> {
public bool isOpen
private void Update()
protected bool CanToggle()
public void SetVisible(bool b)
}
public TweakUIDropdown : MonoBehaviour {
public Button Left
public Button Right
public Text Current
public Image BackgroundImage
public NameValue[] nameValues
public string convarName
public bool assignImageColor
internal Command conVar
public int currentValue
protected void Awake()
protected void OnEnable()
public void OnValueChanged()
public void ChangeValue(int change)
private void UpdateConVar()
private void UpdateState()
}
public TweakUIMultiSelect : MonoBehaviour {
public ToggleGroup toggleGroup
public string convarName
internal Command conVar
private Func`2<Toggle, bool> <>f__am$cache0
protected void Awake()
protected void OnEnable()
public void OnChanged()
private void UpdateToggleGroup()
private void UpdateConVar()
private bool <UpdateConVar>m__0(Toggle x)
}
public TweakUISlider : MonoBehaviour {
public Slider sliderControl
public Text textControl
public string convarName
internal Command conVar
protected void Awake()
protected void OnEnable()
public void OnChanged()
private void UpdateConVar()
private void UpdateSliderValue()
private void UpdateTextValue()
}
public TweakUIToggle : MonoBehaviour {
public Toggle toggleControl
public string convarName
public bool inverse
internal Command conVar
protected void Awake()
protected void OnEnable()
public void OnToggleChanged()
private void UpdateConVar()
private void UpdateToggleState()
}
public UI_LocalVoice : SingletonComponent`1<UI_LocalVoice> {
public CanvasGroup voiceCanvas
public CanvasGroup levelImage
}
public UIBackgroundBlur : ListComponent`1<UIBackgroundBlur> {
public float amount
public float currentMax
public float get_currentMax()
}
public UIBlackoutOverlay : MonoBehaviour {
public CanvasGroup group
public Dictionary`2<blackoutType, UIBlackoutOverlay> instances
public blackoutType overlayType
}
public UIBlueprints : ListComponent`1<UIBlueprints> {
public GameObjectRef buttonPrefab
public ScrollRect scrollRect
public InputField searchField
public GameObject listAvailable
public GameObject listLocked
public GameObject Categories
}
public UIChat : SingletonComponent`1<UIChat> {
public GameObject inputArea
public GameObject chatArea
public InputField inputField
public ScrollRect scrollRect
public CanvasGroup canvasGroup
public GameObjectRef chatItemPlayer
public bool isOpen
}
public UICrafting : SingletonComponent`1<UICrafting> {
public bool isOpen
public float LastOpened
}
public UIDeathScreen : SingletonComponent`1<UIDeathScreen> {
public GameObject sleepingBagIconPrefab
public GameObject sleepingBagContainer
public LifeInfographic previousLifeInfographic
public Animator screenAnimator
public bool fadeIn
public Button ReportCheatButton
}
public UIDialog : ListComponent`1<UIDialog> {
public bool isOpen
public bool get_isOpen()
}
public UIEscapeCapture : ListComponent`1<UIEscapeCapture> {
public UnityEvent onEscape
public bool EscapePressed()
}
public UIFadeOut : MonoBehaviour {
public float secondsToFadeOut
public bool destroyOnFaded
public CanvasGroup targetGroup
private float timeStarted
private void Start()
private void Update()
}
public UIHUD : SingletonComponent`1<UIHUD> {
public UIChat chatPanel
public HudElement Hunger
public HudElement Thirst
public HudElement Health
public HudElement PendingHealth
public RawImage compassStrip
public CanvasGroup compassGroup
}
public UIIntegerEntry : MonoBehaviour {
public InputField textEntry
private Action textChanged
public void add_textChanged(Action value)
public void remove_textChanged(Action value)
public void OnAmountTextChanged()
public void SetAmount(int amount)
public int GetIntAmount()
public void PlusMinus(int delta)
}
public UIInventory : SingletonComponent`1<UIInventory> {
public Text PlayerName
public bool isOpen
public float LastOpened
public VerticalLayoutGroup rightContents
public GameObject QuickCraft
}
public UIMapGenericRadius : MonoBehaviour {
public Image radialImage
public Image outlineImage
public float radius
public CanvasGroup fade
public RectTransform rect
}
public UIMapVendingMachineMarker : MonoBehaviour {
public Color inStock
public Color outOfStock
public Image colorBackground
public string displayName
public Tooltip toolTip
private bool isInStock
public void SetOutOfStock(bool stock)
public void UpdateDisplayName(string newName, SellOrderContainer sellOrderContainer)
}
public UIPaintableImage : MonoBehaviour {
public RawImage image
public int texSize
public Color clearColor
public FilterMode filterMode
public bool mipmaps
public RectTransform rectTransform
public RectTransform get_rectTransform()
}
public UIPaintBox : MonoBehaviour {
public OnBrushChanged onBrushChanged
public Brush brush
public void UpdateBrushSize(int size)
public void UpdateBrushTexture(Texture2D tex)
public void UpdateBrushColor(Color col)
public void UpdateBrushAlpha(float a)
public void UpdateBrushEraser(bool b)
private void OnChanged()
}
public UIParticle : BaseMonoBehaviour {
public Vector2 LifeTime
public Vector2 Gravity
public Vector2 InitialX
public Vector2 InitialY
public Vector2 InitialScale
public Vector2 InitialDelay
public Vector2 ScaleVelocity
public Gradient InitialColor
private float lifetime
private float gravity
private Vector2 velocity
private float scaleVelocity
public void Add(UIParticle particleSource, RectTransform spawnPosition, RectTransform particleCanvas)
private void Start()
private void Update()
private void Die()
}
public uiPlayerPreview : SingletonComponent`1<uiPlayerPreview> {
public Camera previewCamera
public PlayerModel playermodel
public ReflectionProbe reflectionProbe
public SegmentMaskPositioning segmentMask
}
public UIPrefab : MonoBehaviour {
public GameObject prefabSource
internal GameObject createdGameObject
private void Awake()
public void SetVisible(bool visible)
}
public UIRoot : MonoBehaviour {
private GraphicRaycaster[] graphicRaycasters
public Canvas overlayCanvas
private void ToggleRaycasters(bool state)
protected void Awake()
protected void Start()
protected void Update()
protected void Refresh()
}
public UIRootPixel : UIRoot {
protected void Refresh()
}
public UIRootScaled : UIRoot {
private UIRootScaled Instance
public CanvasScaler scaler
public Canvas DragOverlayCanvas
public Canvas get_DragOverlayCanvas()
protected void Awake()
protected void Refresh()
}
public UIScale : MonoBehaviour {
public CanvasScaler scaler
private void Update()
}
public UIScopeOverlay : MonoBehaviour {
public CanvasGroup group
public UIScopeOverlay instance
}
public UISleepingScreen : SingletonComponent`1<UISleepingScreen> {
protected CanvasGroup canvasGroup
protected void Awake()
public void SetVisible(bool b)
}
public UISound : object {
private AudioSource source
private AudioSource GetAudioSource()
public void Play(AudioClip clip, float volume)
}
public UIStyle_Menu_Button_ListItem : MonoBehaviour {
public bool apply
private void OnValidate()
}
public UIStyle_Menu_Input : MonoBehaviour {
public bool apply
private void OnValidate()
}
public UIStyle_Menu_Panel : MonoBehaviour {
public bool toggle
private void OnValidate()
}
public UIUnderlay : SingletonComponent`1<UIUnderlay> {
public GameObject damageDirectional
}
public UIVoiceIcon : MonoBehaviour {
public Text nameText
public RawImage avatar
}
public UIWounded : MonoBehaviour {
public CanvasGroup group
}
public UnityEngine.ArgEx : object {
public BasePlayer Player(Arg arg)
public BasePlayer GetPlayer(Arg arg, int iArgNum)
public BasePlayer GetSleeper(Arg arg, int iArgNum)
public BasePlayer GetPlayerOrSleeper(Arg arg, int iArgNum)
}
public UnityEngine.ColliderEx : object {
public PhysicMaterial GetMaterialAt(Collider obj, Vector3 pos)
}
public UnityEngine.CollisionEx : object {
public BaseEntity GetEntity(Collision col)
}
public UnityEngine.ColorEx : object {
public string ToHex(Color32 color)
public Color Parse(string str)
}
public UnityEngine.ComponentEx : object {
public T Instantiate(T component)
}
public UnityEngine.CoroutineEx : object {
public WaitForEndOfFrame waitForEndOfFrame
public WaitForFixedUpdate waitForFixedUpdate
private Dictionary`2<float, WaitForSeconds> waitForSecondsBuffer
public WaitForSeconds waitForSeconds(float seconds)
public WaitForSecondsRealtime waitForSecondsRealtime(float seconds)
}
public UnityEngine.GameObjectEx : object {
public BaseEntity ToBaseEntity(GameObject go)
private IEntity GetEntityFromRegistry(GameObject go)
private IEntity GetEntityFromComponent(GameObject go)
public void SetHierarchyGroup(GameObject obj, string strRoot, bool groupActive, bool persistant)
}
public UnityEngine.NetworkPacketEx : object {
public BasePlayer Player(Message v)
}
public UnityEngine.QuaternionEx : object {
public Quaternion AlignToNormal(Quaternion rot, Vector3 normal)
public Quaternion LookRotationWithOffset(Vector3 offset, Vector3 forward, Vector3 up)
public Quaternion LookRotationForcedUp(Vector3 forward, Vector3 up)
public Quaternion LookRotationGradient(Vector3 normal, Vector3 up)
public Quaternion LookRotationNormal(Vector3 normal, Vector3 up)
}
public UnityEngine.RayEx : object {
public Vector3 ClosestPoint(Ray ray, Vector3 pos)
public float Distance(Ray ray, Vector3 pos)
public float SqrDistance(Ray ray, Vector3 pos)
public bool IsNaNOrInfinity(Ray r)
}
public UnityEngine.SkinnedMeshRendererEx : object {
public Transform FindRig(SkinnedMeshRenderer renderer)
}
public UnityEngine.TextureEx : object {
private Color32[] buffer
public void Clear(Texture2D tex, Color32 color)
public int GetSizeInBytes(Texture texture)
public int GetBitsPerPixel(TextureFormat format)
}
public UnityEngine.TransformEx : object {
public string GetRecursiveName(Transform transform, string strEndName)
public void RemoveComponent(Transform transform)
public void DestroyAllChildren(Transform transform, bool immediate)
public void RetireAllChildren(Transform transform, GameManager gameManager)
public List`1<Transform> GetChildren(Transform transform)
public void OrderChildren(Transform tx, Func`2<Transform, object> selector)
public List`1<Transform> GetAllChildren(Transform transform)
public void AddAllChildren(Transform transform, List`1<Transform> list)
public Transform[] GetChildrenWithTag(Transform transform, string strTag)
public void Identity(GameObject go)
public GameObject CreateChild(GameObject go)
public GameObject InstantiateChild(GameObject go, GameObject prefab)
public void SetLayerRecursive(GameObject go, int Layer)
public bool DropToGround(Transform transform, bool alignToNormal, float fRange)
public bool GetGroundInfo(Transform transform, Vector3& pos, Vector3& normal, float range)
public bool GetGroundInfoTerrainOnly(Transform transform, Vector3& pos, Vector3& normal, float range)
public Bounds WorkoutRenderBounds(Transform tx)
public List`1<T> GetSiblings(Transform transform, bool includeSelf)
public void DestroyChildren(Transform transform)
public void SetChildrenActive(Transform transform, bool b)
public Transform ActiveChild(Transform transform, string name, bool bDisableOthers)
public T GetComponentInChildrenIncludeDisabled(Transform transform)
public void SetHierarchyGroup(Transform transform, string strRoot, bool groupActive, bool persistant)
public Bounds GetBounds(Transform transform, bool includeRenderers, bool includeColliders, bool includeInactive)
}
public UnityEngine.UI.ScrollRectEx : UIBehaviour {
public InputButton scrollButton
public InputButton altScrollButton
private RectTransform m_Content
private bool m_Horizontal
private bool m_Vertical
private MovementType m_MovementType
private float m_Elasticity
private bool m_Inertia
private float m_DecelerationRate
private float m_ScrollSensitivity
private RectTransform m_Viewport
private Scrollbar m_HorizontalScrollbar
private Scrollbar m_VerticalScrollbar
private ScrollbarVisibility m_HorizontalScrollbarVisibility
private ScrollbarVisibility m_VerticalScrollbarVisibility
private float m_HorizontalScrollbarSpacing
private float m_VerticalScrollbarSpacing
private ScrollRectEvent m_OnValueChanged
private Vector2 m_PointerStartLocalCursor
private Vector2 m_ContentStartPosition
private RectTransform m_ViewRect
private Bounds m_ContentBounds
private Bounds m_ViewBounds
private Vector2 m_Velocity
private bool m_Dragging
private Vector2 m_PrevPosition
private Bounds m_PrevContentBounds
private Bounds m_PrevViewBounds
private bool m_HasRebuiltLayout
private bool m_HSliderExpand
private bool m_VSliderExpand
private float m_HSliderHeight
private float m_VSliderWidth
private RectTransform m_Rect
private RectTransform m_HorizontalScrollbarRect
private RectTransform m_VerticalScrollbarRect
private DrivenRectTransformTracker m_Tracker
private Vector3[] m_Corners
public RectTransform content
public bool horizontal
public bool vertical
public MovementType movementType
public float elasticity
public bool inertia
public float decelerationRate
public float scrollSensitivity
public RectTransform viewport
public Scrollbar horizontalScrollbar
public Scrollbar verticalScrollbar
public ScrollbarVisibility horizontalScrollbarVisibility
public ScrollbarVisibility verticalScrollbarVisibility
public float horizontalScrollbarSpacing
public float verticalScrollbarSpacing
public ScrollRectEvent onValueChanged
protected RectTransform viewRect
public Vector2 velocity
private RectTransform rectTransform
public Vector2 normalizedPosition
public float horizontalNormalizedPosition
public float verticalNormalizedPosition
private bool hScrollingNeeded
private bool vScrollingNeeded
public RectTransform get_content()
public void set_content(RectTransform value)
public bool get_horizontal()
public void set_horizontal(bool value)
public bool get_vertical()
public void set_vertical(bool value)
public MovementType get_movementType()
public void set_movementType(MovementType value)
public float get_elasticity()
public void set_elasticity(float value)
public bool get_inertia()
public void set_inertia(bool value)
public float get_decelerationRate()
public void set_decelerationRate(float value)
public float get_scrollSensitivity()
public void set_scrollSensitivity(float value)
public RectTransform get_viewport()
public void set_viewport(RectTransform value)
public Scrollbar get_horizontalScrollbar()
public void set_horizontalScrollbar(Scrollbar value)
public Scrollbar get_verticalScrollbar()
public void set_verticalScrollbar(Scrollbar value)
public ScrollbarVisibility get_horizontalScrollbarVisibility()
public void set_horizontalScrollbarVisibility(ScrollbarVisibility value)
public ScrollbarVisibility get_verticalScrollbarVisibility()
public void set_verticalScrollbarVisibility(ScrollbarVisibility value)
public float get_horizontalScrollbarSpacing()
public void set_horizontalScrollbarSpacing(float value)
public float get_verticalScrollbarSpacing()
public void set_verticalScrollbarSpacing(float value)
public ScrollRectEvent get_onValueChanged()
public void set_onValueChanged(ScrollRectEvent value)
protected RectTransform get_viewRect()
public Vector2 get_velocity()
public void set_velocity(Vector2 value)
private RectTransform get_rectTransform()
public void Rebuild(CanvasUpdate executing)
private void UpdateCachedData()
protected void OnEnable()
protected void OnDisable()
public bool IsActive()
private void EnsureLayoutHasRebuilt()
public void StopMovement()
public void OnScroll(PointerEventData data)
public void OnInitializePotentialDrag(PointerEventData eventData)
public void OnBeginDrag(PointerEventData eventData)
public void OnEndDrag(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
protected void SetContentAnchoredPosition(Vector2 position)
protected void LateUpdate()
private void UpdatePrevData()
private void UpdateScrollbars(Vector2 offset)
public Vector2 get_normalizedPosition()
public void set_normalizedPosition(Vector2 value)
public float get_horizontalNormalizedPosition()
public void set_horizontalNormalizedPosition(float value)
public float get_verticalNormalizedPosition()
public void set_verticalNormalizedPosition(float value)
private void SetHorizontalNormalizedPosition(float value)
private void SetVerticalNormalizedPosition(float value)
private void SetNormalizedPosition(float value, int axis)
private float RubberDelta(float overStretching, float viewSize)
protected void OnRectTransformDimensionsChange()
private bool get_hScrollingNeeded()
private bool get_vScrollingNeeded()
public void SetLayoutHorizontal()
public void SetLayoutVertical()
private void UpdateScrollbarVisibility()
private void UpdateScrollbarLayout()
private void UpdateBounds()
private Bounds GetBounds()
private Vector2 CalculateOffset(Vector2 delta)
protected void SetDirty()
protected void SetDirtyCaching()
public void CenterOnPosition(Vector2 pos)
public void LayoutComplete()
public void GraphicUpdateComplete()
private Transform UnityEngine.UI.ICanvasElement.get_transform()
private bool UnityEngine.UI.ICanvasElement.IsDestroyed()
}
public UnityEngine.UIEx : object {
public Vector2 Unpivot(RectTransform rect, Vector2 localPos)
public void CenterOnPosition(ScrollRect scrollrect, Vector2 pos)
}
public UnityStandardAssets.CinematicEffects.ImageEffectHelper : object {
public bool supportsDX11
public bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
public Material CheckShaderAndCreateMaterial(Shader s)
public bool get_supportsDX11()
}
public UnityStandardAssets.CinematicEffects.MinAttribute : PropertyAttribute {
public float min
public void .ctor(float min)
}
public UnityStandardAssets.CinematicEffects.RenderTextureUtility : object {
private List`1<RenderTexture> m_TemporaryRTs
public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer, RenderTextureFormat format, FilterMode filterMode)
public void ReleaseTemporaryRenderTexture(RenderTexture rt)
public void ReleaseAllTemporaryRenderTextures()
}
public UnityStandardAssets.CinematicEffects.TonemappingColorGrading : MonoBehaviour {
private EyeAdaptationSettings m_EyeAdaptation
private TonemappingSettings m_Tonemapping
private ColorGradingSettings m_ColorGrading
private LUTSettings m_Lut
private Texture2D m_IdentityLut
private RenderTexture m_InternalLut
private Texture2D m_CurveTexture
private Texture2D m_TonemapperCurve
private float m_TonemapperCurveRange
private Shader m_Shader
private Material m_Material
private bool <validRenderTextureFormat>k__BackingField
private bool <validUserLutSize>k__BackingField
private bool m_Dirty
private bool m_TonemapperDirty
private RenderTexture m_SmallAdaptiveRt
private RenderTextureFormat m_AdaptiveRtFormat
private RenderTexture[] rts
public EyeAdaptationSettings eyeAdaptation
public TonemappingSettings tonemapping
public ColorGradingSettings colorGrading
public LUTSettings lut
private Texture2D identityLut
private RenderTexture internalLutRt
private Texture2D curveTexture
private Texture2D tonemapperCurve
public Shader shader
public Material material
public bool isGammaColorSpace
public int lutSize
public bool validRenderTextureFormat
public bool validUserLutSize
public EyeAdaptationSettings get_eyeAdaptation()
public void set_eyeAdaptation(EyeAdaptationSettings value)
public TonemappingSettings get_tonemapping()
public void set_tonemapping(TonemappingSettings value)
public ColorGradingSettings get_colorGrading()
public void set_colorGrading(ColorGradingSettings value)
public LUTSettings get_lut()
public void set_lut(LUTSettings value)
private Texture2D get_identityLut()
private RenderTexture get_internalLutRt()
private Texture2D get_curveTexture()
private Texture2D get_tonemapperCurve()
public Shader get_shader()
public Material get_material()
public bool get_isGammaColorSpace()
public int get_lutSize()
public bool get_validRenderTextureFormat()
private void set_validRenderTextureFormat(bool value)
public bool get_validUserLutSize()
private void set_validUserLutSize(bool value)
public void SetDirty()
public void SetTonemapperDirty()
private void OnEnable()
private void OnDisable()
private void OnValidate()
private Texture2D GenerateIdentityLut(int dim)
private float StandardIlluminantY(float x)
private Vector3 CIExyToLMS(float x, float y)
private Vector3 GetWhiteBalance()
private Color NormalizeColor(Color c)
private void GenerateLiftGammaGain(Color& lift, Color& gamma, Color& gain)
private void GenCurveTexture()
private bool CheckUserLut()
private bool CheckSmallAdaptiveRt()
public void OnRenderImage(RenderTexture source, RenderTexture destination)
public Texture2D BakeLUT()
}
public UnityStandardAssets.ImageEffects.ScopeEffect : PostEffectsBase {
public Material overlayMaterial
public bool CheckResources()
public bool IsActive()
public void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public UnparentOnDestroy : MonoBehaviour {
public float destroyAfterSeconds
public void OnParentDestroying()
protected void OnValidate()
}
public Upkeep : PrefabAttribute {
public float upkeepMultiplier
protected Type GetIndexedType()
}
public UserPersistance : object {
public Database blueprints
public Database deaths
public void .ctor(string strFolder)
public void Dispose()
public PersistantPlayer GetPlayerInfo(ulong playerID)
private PersistantPlayer FetchFromDatabase(ulong playerID)
public void SetPlayerInfo(ulong playerID, PersistantPlayer info)
public void AddLifeStory(ulong playerID, PlayerLifeStory lifeStory)
public PlayerLifeStory GetLastLifeStory(ulong playerID)
}
internal UVTextureAnimator : MonoBehaviour {
public int Rows
public int Columns
public float Fps
public int OffsetMat
public bool IsLoop
public float StartDelay
private bool isInizialised
private int index
private int count
private int allCount
private float deltaFps
private bool isVisible
private bool isCorutineStarted
private Renderer currentRenderer
private Material instanceMaterial
private void Start()
private void InitDefaultVariables()
private void Play()
private void PlayDelay()
private void OnEnable()
private void OnDisable()
private IEnumerator UpdateCorutine()
private void UpdateCorutineFrame()
private void OnDestroy()
}
public v_chainsaw : MonoBehaviour {
public bool bAttacking
public bool bHitMetal
public bool bHitWood
public bool bHitFlesh
public bool bEngineOn
public ParticleSystem[] hitMetalFX
public ParticleSystem[] hitWoodFX
public ParticleSystem[] hitFleshFX
public SoundDefinition hitMetalSoundDef
public SoundDefinition hitWoodSoundDef
public SoundDefinition hitFleshSoundDef
public Sound hitSound
public GameObject hitSoundTarget
public float hitSoundFadeTime
public ParticleSystem smokeEffect
public Animator chainsawAnimator
public Renderer chainRenderer
public Material chainlink
private MaterialPropertyBlock block
private Vector2 saveST
private float chainSpeed
private float chainAmount
public float temp1
public float temp2
public void OnEnable()
private void Awake()
private void Start()
private void ScrollChainTexture()
private void Update()
private void DoHitSound(SoundDefinition soundDef)
}
public ValidBounds : SingletonComponent`1<ValidBounds> {
public Bounds worldBounds
public bool Test(Vector3 vPos)
private void OnDrawGizmosSelected()
internal bool IsInside(Vector3 vPos)
}
public VendingMachine : StorageContainer {
public GameObject adminMenuPrefab
public string customerPanel
public SellOrderContainer sellOrders
public SoundPlayer buySound
public string shopName
public GameObjectRef mapMarkerPrefab
public ItemDefinition blueprintBaseDef
protected BasePlayer vend_Player
private int vend_sellOrderID
private int vend_numberOfTransactions
public bool transactionActive
private VendingMachineMapMarker myMarker
private Func`2<Item, int> <>f__am$cache0
private Func`2<Item, int> <>f__am$cache1
private Func`2<Item, int> <>f__am$cache2
private Func`2<Item, bool> <>f__am$cache3
private Func`2<Item, int> <>f__am$cache4
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ServerInit()
public void DestroyShared()
public void OnItemAddedOrRemoved(Item item, bool added)
public void FullUpdate()
protected void OnInventoryDirty()
public void RefreshSellOrderStockLevel(ItemDefinition itemDef)
public bool OutOfStock()
public void PostServerLoad()
public void UpdateEmptyFlag()
public void PlayerStoppedLooting(BasePlayer player)
public void InstallDefaultSellOrders()
public bool HasVendingSounds()
public float GetBuyDuration()
public void SetPendingOrder(BasePlayer buyer, int sellOrderId, int numberOfTransactions)
public void ClearPendingOrder()
public void BuyItem(RPCMessage rpc)
public void CompletePendingOrder()
public void TransactionStart(RPCMessage rpc)
public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions)
public void TakeCurrencyItem(Item takenCurrencyItem)
public void GiveSoldItem(Item soldItem, BasePlayer buyer)
public void SendSellOrders(BasePlayer player)
public void RPC_Broadcast(RPCMessage msg)
public void RPC_UpdateShopName(RPCMessage msg)
public void UpdateMapMarker()
public void RPC_OpenShop(RPCMessage msg)
public void RPC_OpenAdmin(RPCMessage msg)
public bool CanAcceptItem(Item item, int targetSlot)
public bool CanMoveFrom(BasePlayer player, Item item)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public void RPC_DeleteSellOrder(RPCMessage msg)
public void RPC_RotateVM(RPCMessage msg)
public void RPC_AddSellOrder(RPCMessage msg)
public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
public void RefreshAndSendNetworkUpdate()
public void UpdateOrCreateSalesSheet()
public bool IsBroadcasting()
public bool IsInventoryEmpty()
public bool IsVending()
public bool PlayerBehind(BasePlayer player)
public bool PlayerInfront(BasePlayer player)
public bool CanPlayerAdmin(BasePlayer player)
private int <RefreshSellOrderStockLevel>m__0(Item x)
private int <RefreshSellOrderStockLevel>m__1(Item x)
private int <DoTransaction>m__2(Item x)
private bool <DoTransaction>m__3(Item x)
private int <DoTransaction>m__4(Item x)
}
public VendingMachineMapMarker : MapMarker {
public string markerShopName
public VendingMachine server_vendingMachine
public SellOrderContainer client_sellOrders
public void Save(SaveInfo info)
}
public VendingMachineScreen : MonoBehaviour {
public RawImage largeIcon
public RawImage blueprintIcon
public Text mainText
public Text lowerText
public Text centerText
public RawImage smallIcon
public VendingMachine vendingMachine
public Sprite outOfStockSprite
public Renderer fadeoutMesh
public CanvasGroup screenCanvas
public Renderer light1
public Renderer light2
public float nextImageTime
public int currentImageIndex
}
public VendingPanelAdmin : UIDialog {
public GameObject sellOrderAdminContainer
public GameObject sellOrderAdminPrefab
public InputField storeNameInputField
}
public VertexColorAnimator : MonoBehaviour {
public List`1<MeshHolder> animationMeshes
public List`1<float> animationKeyframes
public float timeScale
public int mode
private float elapsedTime
public void initLists()
public void addMesh(Mesh mesh, float atPosition)
private void Start()
public void replaceKeyframe(int frameIndex, Mesh mesh)
public void deleteKeyframe(int frameIndex)
public void scrobble(float scrobblePos)
private void Update()
}
public VertexColorStream : MonoBehaviour {
public Mesh originalMesh
public Mesh paintedMesh
public MeshHolder meshHold
public Vector3[] _vertices
public Vector3[] _normals
public Int32[] _triangles
public Int32[][] _Subtriangles
public Matrix4x4[] _bindPoses
public BoneWeight[] _boneWeights
public Bounds _bounds
public int _subMeshCount
public Vector4[] _tangents
public Vector2[] _uv
public Vector2[] _uv2
public Vector2[] _uv3
public Color[] _colors
public Vector2[] _uv4
private void OnDidApplyAnimationProperties()
public void init(Mesh origMesh, bool destroyOld)
public void setWholeMesh(Mesh tmpMesh)
public Vector3[] setVertices(Vector3[] _deformedVertices)
public Vector3[] getVertices()
public Vector3[] getNormals()
public Int32[] getTriangles()
public void setTangents(Vector4[] _meshTangents)
public Vector4[] getTangents()
public void setColors(Color[] _vertexColors)
public Color[] getColors()
public Vector2[] getUVs()
public void setUV4s(Vector2[] _uv4s)
public Vector2[] getUV4s()
public void unlink()
public void rebuild()
private void Start()
}
public ViewModel : MonoBehaviour {
public GameObjectRef viewModelPrefab
}
public ViewmodelAttachment : EntityComponent`1<BaseEntity> {
public GameObjectRef modelObject
public string targetBone
public bool hideViewModelIronSights
}
public ViewmodelClothing : MonoBehaviour {
public SkeletonSkin[] SkeletonSkins
internal void CopyToSkeleton(Skeleton skeleton, GameObject parent, Item item)
}
public ViewmodelLower : MonoBehaviour {
public void SetShouldLower(bool shouldLower)
}
public ViewmodelScope : MonoBehaviour {
public float smoothSpeed
}
public ViewmodelSway : MonoBehaviour {
public float positionalSwaySpeed
public float positionalSwayAmount
public float rotationSwaySpeed
public float rotationSwayAmount
}
public VirtualItemIcon : MonoBehaviour {
public ItemDefinition itemDef
public int itemAmount
public bool asBlueprint
public Image iconImage
public Image bpUnderlay
public Text amountText
public CanvasGroup iconContents
public CanvasGroup conditionObject
public Image conditionFill
public Image maxConditionFill
public Image cornerIcon
}
public Vis : object {
public Collider[] colBuffer
public void Colliders(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Components(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Entities(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void EntityComponents(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
}
public VisualizeTexelDensity : MonoBehaviour {
public Shader shader
public string shaderTag
public int texelsPerMeter
public float overlayOpacity
public bool showHUD
private Camera mainCamera
private bool initialized
private int screenWidth
private int screenHeight
private Camera texelDensityCamera
private RenderTexture texelDensityRT
private Texture texelDensityGradTex
private Material texelDensityOverlayMat
private VisualizeTexelDensity instance
public VisualizeTexelDensity Instance
public VisualizeTexelDensity get_Instance()
private void Awake()
private void OnEnable()
private void OnDisable()
private void LoadResources()
private void SafeDestroyViewTexelDensity()
private void SafeDestroyViewTexelDensityRT()
private void UpdateViewTexelDensity(bool screenResized)
private bool CheckScreenResized(int width, int height)
private void OnRenderImage(RenderTexture source, RenderTexture destination)
private void DrawGUIText(float x, float y, Vector2 size, string text, GUIStyle fontStyle)
private void OnGUI()
}
public VisualStorageContainer : LootContainer {
public VisualStorageContainerNode[] displayNodes
public DisplayModel[] displayModels
public Transform nodeParent
public GameObject defaultDisplayModel
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
public void PopulateLoot()
public void ClearRigidBodies()
public void SetItemsVisible(bool vis)
public void ItemUpdateComplete()
public void UpdateVisibleItems(ItemContainer msg)
}
public VisualStorageContainerNode : MonoBehaviour {
private void Start()
private void Update()
}
public VitalInfo : MonoBehaviour {
public Vital VitalType
public Animator animator
public Text text
}
public VitalLevel : ValueType {
public float Level
private float lastUsedTime
public float TimeSinceUsed
internal void Add(float f)
public float get_TimeSinceUsed()
internal void Use(float f)
}
public VitalNote : MonoBehaviour {
public Vital VitalType
public FloatConditions showIf
public Text valueText
public Animator animator
}
public VitalRadial : MonoBehaviour {
private void Awake()
}
public VTP : MonoBehaviour {
public Color getSingleVertexColorAtHit(Transform transform, RaycastHit hit)
public Color getFaceVerticesColorAtHit(Transform transform, RaycastHit hit)
public void paintSingleVertexOnHit(Transform transform, RaycastHit hit, Color color, float strength)
public void paintFaceVerticesOnHit(Transform transform, RaycastHit hit, Color color, float strength)
public void deformSingleVertexOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
public void deformFaceVerticesOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
private void recalculateMeshForFlow(Transform transform, Vector3[] currentVertices, Vector3[] currentNormals, Vector4[] currentTangents)
private Vector4[] calculateMeshTangents(Int32[] triangles, Vector3[] vertices, Vector2[] uv, Vector3[] normals)
public Color VertexColorLerp(Color colorA, Color colorB, float value)
}
public WaterBall : BaseEntity {
public ItemDefinition liquidType
public int waterAmount
public GameObjectRef waterExplosion
public Rigidbody myRigidBody
public void ServerInit()
public void Extinguish()
public void FixedUpdate()
public void DoSplash()
private void OnCollisionEnter(Collision collision)
}
public WaterBody : MonoBehaviour {
public WaterBodyType Type
public Renderer Renderer
public Collider[] Triggers
}
public WaterBodyType : Enum {
public int value__
public WaterBodyType Ocean
public WaterBodyType River
public WaterBodyType Lake
}
public WaterCatcher : LiquidContainer {
public ItemDefinition itemToCreate
public float maxItemToCreate
public Vector3 rainTestPosition
public float rainTestSize
private float collectInterval
public void ServerInit()
private void CollectWater()
private bool IsFull()
private bool TestIsOutside()
private void AddResource(int iAmount)
}
public WaterCheck : PrefabAttribute {
public bool Rotate
protected void OnDrawGizmosSelected()
public bool Check(Vector3 pos)
protected Type GetIndexedType()
}
public WaterCheckEx : object {
public bool ApplyWaterChecks(Transform transform, WaterCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale)
}
public WaterCheckGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementDistance
public bool CheckRotate
}
public WaterCollision : MonoBehaviour {
private ListDictionary`2<Collider, List`1<Collider>> ignoredColliders
private HashSet`1<Collider> waterColliders
private void Awake()
public void Clear()
public void Reset(Collider collider)
public bool GetIgnore(Vector3 pos, float radius)
public bool GetIgnore(Bounds bounds)
public bool GetIgnore(RaycastHit hit)
public bool GetIgnore(Collider collider)
public void SetIgnore(Collider collider, Collider trigger, bool ignore)
protected void LateUpdate()
}
public WaterCullingVolume : MonoBehaviour {
public bool isDynamic
}
public WaterLevel : object {
public float Factor(Bounds bounds)
public bool Test(Vector3 pos)
public float GetWaterDepth(Vector3 pos)
public float GetOverallWaterDepth(Vector3 pos)
public WaterInfo GetWaterInfo(Vector3 pos)
public WaterInfo GetWaterInfo(Bounds bounds)
}
public WaterMesh : object {
private Mesh borderMesh
private Mesh centerPatch
private int borderRingCount
private float borderRingSpacingFalloff
private int resolution
private Vector3[] borderVerticesLocal
private Vector3[] borderVerticesWorld
private bool initialized
public Mesh BorderMesh
public Mesh CenterPatch
public bool IsInitialized
public Mesh get_BorderMesh()
public Mesh get_CenterPatch()
public bool get_IsInitialized()
public void Initialize(int patchResolution, float patchSizeInWorld, int borderRingCount, float borderRingSpacingFalloff)
public void Destroy()
public void UpdateBorderMesh(Matrix4x4 centerLocalToWorld, Matrix4x4 borderLocalToWorld, bool collapseCenter)
private Mesh CreateSortedBorderPatch(int resolution, int ringCount, float sizeInWorld)
private Mesh CreateSortedCenterPatch(int resolution, float sizeInWorld, bool borderOnly)
}
public WaterOverlay : ImageEffectLayer {
public bool goggles
public EffectParams gogglesParams
public void Awake()
protected void Update()
}
public WaterPurifier : LiquidContainer {
public GameObjectRef storagePrefab
public Transform storagePrefabAnchor
public ItemDefinition freshWater
public int waterToProcessPerMinute
public int freshWaterRatio
public LiquidContainer waterStorage
public float dirtyWaterProcssed
public float pendingFreshWater
public void ServerInit()
public void PostServerLoad()
public void SpawnStorageEnt()
internal void OnParentRemoved()
public void OnKilled(HitInfo info)
public void ParentTemperatureUpdate(float temp)
public void CheckCoolDown()
public bool HasDirtyWater()
public void Cook(float timeCooked)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool IsBoiling()
}
public WaterQuality : Enum {
public int value__
public WaterQuality Low
public WaterQuality Medium
public WaterQuality High
}
public WaterRadialMesh : object {
private float AlignmentGranularity
private float MaxHorizontalDisplacement
private Mesh[] meshes
private bool initialized
public Mesh[] Meshes
public bool IsInitialized
public Mesh[] get_Meshes()
public bool get_IsInitialized()
public void Initialize(int vertexCount)
public void Destroy()
private Mesh CreateMesh(string name, Vector3[] vertices, Int32[] indices)
private Mesh[] GenerateMeshes(int vertexCount, bool volume)
private Vector3 RaycastPlane(Camera camera, float planeHeight, Vector3 pos)
public Matrix4x4 ComputeLocalToWorldMatrix(Camera camera, float oceanWaterLevel)
}
public WaterResource : object {
public ItemDefinition GetAtPoint(Vector3 pos)
public bool IsFreshWater(Vector3 pos)
public ItemDefinition Merge(ItemDefinition first, ItemDefinition second)
}
public WaterSystem : MonoBehaviour {
public WaterQuality Quality
public bool showDebug
public bool showGizmos
public SimulationSettings Simulation
public RenderingSettings Rendering
private WaterCollision <Collision>k__BackingField
private bool <IsInitialized>k__BackingField
private WaterSystem instance
public WaterCollision Collision
public bool IsInitialized
public WaterSystem Instance
public WaterCollision get_Collision()
private void set_Collision(WaterCollision value)
private void set_IsInitialized(bool value)
public bool get_IsInitialized()
public WaterSystem get_Instance()
private void CheckInstance()
private void Awake()
}
public WaterVisibilityTrigger : EnvironmentVolumeTrigger {
private long enteredTick
private long ticks
private SortedList`2<long, WaterVisibilityTrigger> tracker
public void Reset()
protected void OnDestroy()
private int GetVisibilityMask()
private void ToggleVisibility()
private void ResetVisibility()
private void ToggleCollision(Collider other)
private void ResetCollision(Collider other)
protected void OnTriggerEnter(Collider other)
protected void OnTriggerExit(Collider other)
}
public WaterWell : LiquidContainer {
public Animator animator
private Flags Pumping
private Flags WaterFlow
public float caloriesPerPump
public float pressurePerPump
public float pressureForProduction
public float currentPressure
public int waterPerPump
public GameObject waterLevelObj
public float waterLevelObjFullOffset
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void RPC_Pump(RPCMessage msg)
public void StopPump()
protected void OnInventoryDirty()
public void Produce()
public void ScheduleTapOff()
private void TapOff()
public void ReducePressure()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float GetWaterAmount()
}
public Wearable : MonoBehaviour {
public RemoveSkin removeSkin
public RemoveHair removeHair
public DeformHair deformHair
public bool showCensorshipCube
public bool showCensorshipCubeBreasts
public bool forceHideCensorshipBreasts
public OccupationSlots occupationUnder
public OccupationSlots occupationOver
public string followBone
private LOD[] emptyLOD
public void OnItemSetup(Item item)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void SetupRendererCache(IPrefabProcessor preProcess)
}
public WearableHolsterOffset : MonoBehaviour {
public offsetInfo[] Offsets
}
public WeatherEffect : MonoBehaviour {
public ParticleSystem[] emitOnStart
public ParticleSystem[] emitOnStop
public ParticleSystem[] emitOnLoop
}
public WeightedAudioClip : object {
public AudioClip audioClip
public int weight
}
public WheelSwitch : IOEntity {
public Transform wheelObj
public float rotateSpeed
public Flags BeingRotated
public Flags RotatingLeft
public Flags RotatingRight
public float rotateProgress
public Animator animator
public float kineticEnergyPerSec
private BasePlayer rotatorPlayer
private float progressTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public void BeginRotate(RPCMessage msg)
public void CancelPlayerRotation()
public void RotateProgress()
public void SetRotateProgress(float newValue)
public void StoppedRotatingCheck()
public void CancelRotate(RPCMessage msg)
public void Powered()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public bool IsBeingRotated()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
}
public WildlifeTrap : StorageContainer {
public float tickRate
public GameObjectRef trappedEffect
public float trappedEffectRepeatRate
public float trapSuccessRate
public List`1<ItemDefinition> ignoreBait
public List`1<WildlifeWeight> targetWildlife
private Func`2<WildlifeWeight, int> <>f__am$cache0
public void SetTrapActive(bool trapOn)
public int GetBaitCalories()
public void DestroyRandomFoodItem()
public void UseBaitCalories(int numToUse)
public int GetItemCalories(Item item)
public void TrapThink()
public void TrapWildlife(TrappableWildlife trapped)
public void ClearTrap()
public bool HasBait()
public void PlayerStoppedLooting(BasePlayer player)
public bool OnStartBeingLooted(BasePlayer baseEntity)
public TrappableWildlife GetRandomWildlife()
public bool SupportsPooling()
public bool HasCatch()
public bool IsTrapActive()
private int <GetRandomWildlife>m__0(WildlifeWeight x)
}
public Windows.ConsoleInput : object {
private Action`1<string> OnInputText
public string inputString
public String[] statusText
internal float nextUpdate
public bool valid
public int lineWidth
public void add_OnInputText(Action`1<string> value)
public void remove_OnInputText(Action`1<string> value)
public bool get_valid()
public int get_lineWidth()
public void ClearLine(int numLines)
public void RedrawInputLine()
internal void OnBackspace()
internal void OnEscape()
internal void OnEnter()
public void Update()
}
public Windows.ConsoleWindow : object {
private TextWriter oldOutput
private int STD_INPUT_HANDLE
private int STD_OUTPUT_HANDLE
public void Initialize()
public void Shutdown()
public void SetTitle(string strName)
private bool AttachConsole(UInt32 dwProcessId)
private bool AllocConsole()
private bool FreeConsole()
private IntPtr GetStdHandle(int nStdHandle)
private bool SetConsoleTitleA(string lpConsoleTitle)
}
public WindZoneExManager : MonoBehaviour {
public float maxAccumMain
public float maxAccumTurbulence
public float globalMainScale
public float globalTurbulenceScale
public Transform testPosition
}
public Wolf : BaseAnimalNPC {
public float Population
public TraitFlag Traits
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public WordFilter : object {
public string Filter(string str)
}
public Workbench : StorageContainer {
public int blueprintSlot
public int experimentSlot
public int Workbenchlevel
public LootSpawn experimentalItems
public GameObjectRef experimentStartEffect
public GameObjectRef experimentSuccessEffect
public ItemDefinition experimentResource
public ItemDefinition blueprintBaseDef
private ItemDefinition pendingBlueprint
private bool creatingBlueprint
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetScrapForExperiment()
public bool IsWorking()
public void RPC_Rotate(RPCMessage msg)
public ItemDefinition GetBlueprintTemplate()
public void RPC_BeginExperiment(RPCMessage msg)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public int GetAvailableExperimentResources()
public Item GetExperimentResourceItem()
public void ExperimentComplete()
public void PostServerLoad()
public void ServerInit()
public bool ItemFilter(Item item, int targetSlot)
}
public WorkbenchPanel : LootPanel {
public Button experimentButton
public Text timerText
public Text costText
public GameObject expermentCostParent
public GameObject controlsParent
public GameObject allUnlockedNotification
public GameObject informationParent
public GameObject cycleIcon
}
public WorkshopIconRender : MonoBehaviour {
public int MinimumId
}
public World : object {
private UInt32 <Seed>k__BackingField
private UInt32 <Salt>k__BackingField
private UInt32 <Size>k__BackingField
private string <Checksum>k__BackingField
private string <Url>k__BackingField
private bool <Procedural>k__BackingField
private bool <Cached>k__BackingField
private WorldSerialization <Serialization>k__BackingField
private Converter`2<Vector3, VectorData> <>f__am$cache0
private Converter`2<VectorData, Vector3> <>f__am$cache1
private Func`2<PathData, PathList> <>f__mg$cache0
public UInt32 Seed
public UInt32 Salt
public UInt32 Size
public string Checksum
public string Url
public bool Procedural
public bool Cached
public WorldSerialization Serialization
public string Name
public string MapFileName
public string MapFolderName
public string SaveFileName
public string SaveFolderName
public UInt32 get_Seed()
public void set_Seed(UInt32 value)
public UInt32 get_Salt()
public void set_Salt(UInt32 value)
public UInt32 get_Size()
public void set_Size(UInt32 value)
public string get_Checksum()
public void set_Checksum(string value)
public string get_Url()
public void set_Url(string value)
public bool get_Procedural()
public void set_Procedural(bool value)
public bool get_Cached()
public void set_Cached(bool value)
public WorldSerialization get_Serialization()
public void set_Serialization(WorldSerialization value)
public string get_Name()
public bool CanLoadFromUrl()
public bool CanLoadFromDisk()
public void CleanupOldFiles()
public string get_MapFileName()
public string get_MapFolderName()
public string get_SaveFileName()
public string get_SaveFolderName()
public void InitSeed(int seed)
public void InitSeed(UInt32 seed)
private string SeedIdentifier()
public void InitSalt(int salt)
public void InitSalt(UInt32 salt)
private string SaltIdentifier()
public void InitSize(int size)
public void InitSize(UInt32 size)
public Byte[] GetMap(string name)
public void AddMap(string name, Byte[] data)
public void AddPrefab(string category, UInt32 id, Vector3 position, Quaternion rotation, Vector3 scale)
public PathData PathListToPathData(PathList src)
public PathList PathDataToPathList(PathData src)
public IEnumerable`1<PathList> GetPaths(string name)
public void AddPaths(IEnumerable`1<PathList> paths)
public void AddPath(PathList path)
public IEnumerator Spawn(float deltaTime, Action`1<string> statusFunction)
public void Spawn()
private void Spawn(PrefabData prefab)
private void Spawn(string category, UInt32 id, Vector3 position, Quaternion rotation, Vector3 scale)
private void Status(Action`1<string> statusFunction, string status, object obj1)
private void Status(Action`1<string> statusFunction, string status, object obj1, object obj2)
private void Status(Action`1<string> statusFunction, string status, object obj1, object obj2, object obj3)
private void Status(Action`1<string> statusFunction, string status, Object[] objs)
private VectorData <PathListToPathData>m__0(Vector3 item)
private Vector3 <PathDataToPathList>m__1(VectorData item)
}
public WorldItem : BaseEntity {
public bool allowPickup
public Item item
protected float eatSeconds
protected float caloriesPerSecond
private bool _isInvokingSendItemUpdate
public TraitFlag Traits
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Item GetItem()
public void InitializeItem(Item in_item)
public void RemoveItem()
public void DestroyItem()
protected void OnItemDirty(Item in_item)
public void Load(LoadInfo info)
public TraitFlag get_Traits()
public void Eat(BaseNpc baseNpc, float timeSpent)
public string ToString()
public void ServerInit()
private void DoItemNetworking()
private void SendItemUpdate()
public void Pickup(RPCMessage msg)
public void Save(SaveInfo info)
public void OnInvalidPosition()
internal void DoServerDestroy()
public void ParentBecoming(BaseEntity ent)
}
public WorldModel : MonoBehaviour {
public float mass
}
public WorldSetup : SingletonComponent`1<WorldSetup> {
public bool AutomaticallySetup
public GameObject terrain
public GameObject decorPrefab
public GameObject grassPrefab
public GameObject spawnPrefab
private TerrainMeta terrainMeta
public UInt32 EditorSeed
public UInt32 EditorSalt
public UInt32 EditorSize
public string EditorUrl
internal List`1<ProceduralObject> ProceduralObjects
private void OnValidate()
protected void Awake()
protected void CreateObject(GameObject prefab)
public IEnumerator InitCoroutine()
private void CancelSetup(string msg)
}
public XMasRefill : BaseEntity {
public GameObjectRef[] giftPrefabs
public List`1<BasePlayer> goodKids
public List`1<Stocking> stockings
public AudioSource bells
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float GiftRadius()
public int GiftsPerPlayer()
public int GiftSpawnAttempts()
public void ServerInit()
public void SendBells()
public void RemoveMe()
public void DistributeLoot()
protected bool DropToGround(Vector3& pos)
public bool DistributeGiftsForPlayer(BasePlayer player)
}
public YourFriends : BaseMonoBehaviour {
public Transform PanelList
}
public Zombie : BaseAnimalNPC {
public float Population
public TraitFlag Traits
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
protected void TickSleep()
public string Categorize()
}
