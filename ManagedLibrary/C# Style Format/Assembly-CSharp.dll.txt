public AboutYou : BaseMonoBehaviour {
public Text username
public RawImage avatar
public Text subtitle
}
public Achievements : SingletonComponent`1<Achievements> {
public SoundDefinition listComplete
public SoundDefinition itemComplete
public SoundDefinition popup
public Canvas Canvas
public Text titleText
}
public AchievementTodo : BaseMonoBehaviour {
public Text text
public RectTransform checkIcon
public RectTransform checkBox
public Color AliveColor
public Color DeadColor
public Color HighlightColor
}
public ActionPriority : Enum {
public int value__
public ActionPriority Highest
public ActionPriority High
public ActionPriority Medium
public ActionPriority Low
public ActionPriority Lowest
}
public AdaptMeshToTerrain : MonoBehaviour {
public LayerMask LayerMask
public float RayHeight
public float RayMaxDistance
public float MinDisplacement
public float MaxDisplacement
public int PlaneResolution
}
public AddSellOrderManager : MonoBehaviour {
public VirtualItemIcon sellItemIcon
public VirtualItemIcon currencyItemIcon
public GameObject itemSearchParent
public ItemSearchEntry itemSearchEntryPrefab
public InputField sellItemInput
public InputField sellItemAmount
public InputField currencyItemInput
public InputField currencyItemAmount
public VendingPanelAdmin adminPanel
}
public AddToAlphaMap : ProceduralObject {
public Bounds bounds
public void Process()
}
public AddToHeightMap : ProceduralObject {
public bool DestroyGameObject
public void Apply()
public void Process()
}
public AddToWaterMap : ProceduralObject {
public bool isOcean
public void Process()
}
public AdminExistingSellOrder : MonoBehaviour {
public VirtualItemIcon MerchandiseIcon
public VirtualItemIcon CurrencyIcon
private VendingPanelAdmin adminPanel
private int index
}
public AdminUI : MonoBehaviour {
public bool AllowInDemo
public GameObject TargetGameObject
}
public AdvancedChristmasLights : IOEntity {
public GameObjectRef bulbPrefab
public LineRenderer lineRenderer
public List`1<pointEntry> points
public List`1<BaseBulb> bulbs
public float bulbSpacing
public float wireThickness
public Transform wireEmission
public AnimationType animationStyle
public RendererLOD _lod
public float lengthToPowerRatio
private bool finalized
private int lengthUsed
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ClearPoints()
public void FinishEditing()
public bool IsFinalized()
public void AddPoint(Vector3 newPoint, Vector3 newNormal, float slackLevel)
public int ConsumptionAmount()
protected int GetPickupCount()
public void AddLengthUsed(int addLength)
public void ServerInit()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool CanPlayerManipulate(BasePlayer player)
public void SetAnimationStyle(RPCMessage msg)
}
public AdventCalendar : BaseCombatEntity {
public int startMonth
public int startDay
public DayReward[] days
public GameObject[] crosses
public List`1<AdventCalendar> all
public Dictionary`2<ulong, List`1<int>> playerRewardHistory
public Phrase CheckLater
public Phrase EventOver
public GameObjectRef giftEffect
public GameObjectRef boxCloseEffect
public int overrideAdventCalendarDay
public int overrideAdventCalendarMonth
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void DestroyShared()
public void AwardGift(BasePlayer player)
public bool WasAwardedTodaysGift(BasePlayer player)
public void RPC_RequestGift(RPCMessage msg)
}
public AggressionTimerAIEvent : BaseAIEvent {
private float <Value>k__BackingField
public float Value
public float get_Value()
private void set_Value(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public AIArenaNameTag : MonoBehaviour {
public BasePlayer Entity
public bool ShowHealth
public bool ShowName
private string trimmedName
}
public AIBrainSenses : object {
public float UpdateInterval
public float HumanKnownPlayersLOSUpdateInterval
public float KnownPlayersLOSUpdateInterval
public float knownPlayersLOSUpdateInterval
public float MemoryDuration
public float LastThreatTimestamp
public float TimeInAgressiveState
private SimpleAIMemory <Memory>k__BackingField
public BaseEntity[] queryResults
public BasePlayer[] playerQueryResults
public float nextUpdateTime
public float nextKnownPlayersLOSUpdateTime
public BaseEntity owner
public BasePlayer playerOwner
public IAISenses ownerSenses
public float maxRange
public float targetLostRange
public float visionCone
public bool checkVision
public bool checkLOS
public bool ignoreNonVisionSneakers
public float listenRange
public bool hostileTargetsOnly
public bool senseFriendlies
public bool refreshKnownLOS
private bool <ignoreSafeZonePlayers>k__BackingField
public bool ignoreTutorialPlayers
public EntityType senseTypes
public IAIAttack ownerAttack
public BaseAIBrain brain
private Func`2<BaseEntity, bool> aiCaresAbout
public float TimeSinceThreat
public SimpleAIMemory Memory
public float TargetLostRange
public bool ignoreSafeZonePlayers
public List`1<BaseEntity> Players
public float get_TimeSinceThreat()
public SimpleAIMemory get_Memory()
public void set_Memory(SimpleAIMemory value)
public float get_TargetLostRange()
public bool get_ignoreSafeZonePlayers()
public void set_ignoreSafeZonePlayers(bool value)
public void Init(BaseEntity owner, BaseAIBrain brain, float memoryDuration, float range, float targetLostRange, float visionCone, bool checkVision, bool checkLOS, bool ignoreNonVisionSneakers, float listenRange, bool hostileTargetsOnly, bool senseFriendlies, bool ignoreSafeZonePlayers, EntityType senseTypes, bool refreshKnownLOS)
public void DelaySenseUpdate(float delay)
public void Update()
private void UpdateSenses()
public void UpdateKnownPlayersLOS()
private void SensePlayers()
private void SenseBrains()
private bool AiCaresAbout(BaseEntity entity)
private bool IsValidSenseType(BaseEntity ent)
private bool IsTargetInVision(BaseEntity target)
public BaseEntity GetNearestPlayer(float rangeFraction)
public List`1<BaseEntity> get_Players()
public BaseEntity GetNearestThreat(float rangeFraction)
public BaseEntity GetNearestTarget(float rangeFraction)
private BaseEntity GetNearest(List`1<BaseEntity> entities, float rangeFraction)
}
public AICoverPoint : AIPoint {
public float coverDot
public void OnDrawGizmos()
}
public AICoverPointTool : MonoBehaviour {
public void PlaceCoverPoints()
private TestResult TestPoint(Vector3 pos)
private void PlacePoint(TestResult result)
private void PlacePoint(Vector3 pos, Vector3 dir)
public bool HitsCover(Ray ray, int layerMask, float maxDistance)
}
public AIDesign : object {
private AIDesignScope <Scope>k__BackingField
private string <Description>k__BackingField
public List`1<AIState> AvailableStates
public int DefaultStateContainerID
private Dictionary`2<int, AIStateContainer> stateContainers
public AIDesignScope Scope
public string Description
public AIDesignScope get_Scope()
private void set_Scope(AIDesignScope value)
public string get_Description()
private void set_Description(string value)
public void SetAvailableStates(List`1<AIState> states)
public void Load(AIDesign design, BaseEntity owner)
private void InitStateContainers(AIDesign design, BaseEntity owner)
public AIStateContainer GetDefaultStateContainer()
public AIStateContainer GetStateContainerByID(int id)
public AIStateContainer GetFirstStateContainerOfType(AIState stateType)
public AIDesign ToProto(int currentStateID)
}
public AIDesigns : object {
public string DesignFolderPath
private Dictionary`2<string, AIDesign> designs
public AIDesign GetByNameOrInstance(string designName, AIDesign entityDesign)
public void RefreshCache(string designName, AIDesign design)
private AIDesign GetByName(string designName)
}
public AIDesignScope : Enum {
public int value__
public AIDesignScope Default
public AIDesignScope EntityServerWide
public AIDesignScope EntityInstance
}
public AIDesignSO : BaseScriptableObject {
public string Filename
}
public AIEvents : object {
public AIMemory Memory
private int <CurrentInputMemorySlot>k__BackingField
public List`1<BaseAIEvent> events
private IAIEventListener eventListener
public AIBrainSenses senses
private int currentEventIndex
private bool inBlock
public int CurrentInputMemorySlot
public int get_CurrentInputMemorySlot()
private void set_CurrentInputMemorySlot(int value)
public void Init(IAIEventListener listener, AIStateContainer stateContainer, BaseEntity owner, AIBrainSenses senses)
public void RemoveAll()
public void AddStateEvents(List`1<BaseAIEvent> events, BaseEntity owner)
public void Add(BaseAIEvent aiEvent)
public void Tick(float deltaTime, StateStatus stateStatus)
private int FindNextEventBlock()
}
public AIEventType : Enum {
public int value__
public AIEventType Timer
public AIEventType PlayerDetected
public AIEventType StateError
public AIEventType Attacked
public AIEventType StateFinished
public AIEventType InAttackRange
public AIEventType HealthBelow
public AIEventType InRange
public AIEventType PerformedAttack
public AIEventType TirednessAbove
public AIEventType HungerAbove
public AIEventType ThreatDetected
public AIEventType TargetDetected
public AIEventType AmmoBelow
public AIEventType BestTargetDetected
public AIEventType IsVisible
public AIEventType AttackTick
public AIEventType IsMounted
public AIEventType And
public AIEventType Chance
public AIEventType TargetLost
public AIEventType TimeSinceThreat
public AIEventType OnPositionMemorySet
public AIEventType AggressionTimer
public AIEventType Reloading
public AIEventType InRangeOfHome
public AIEventType IsBlinded
}
public AIHelicopterAnimation : MonoBehaviour {
public PatrolHelicopterAI _ai
public float swayAmount
public float impactSwayAmount
public float lastStrafeScalar
public float lastForwardBackScalar
public float degreeMax
public Vector3 lastPosition
public float oldMoveSpeed
public float smoothRateOfChange
public float flareAmount
public float swaySmoothingFactor
private float smoothedTime
private void Awake()
public void UpdateAnimation()
public void UpdateLastPosition()
private void UpdateForwardBackTilting()
private void UpdateStrafeTilting()
private void ModifyHelicopterAngles()
private Vector3 GetCurrentMoveDirection()
}
public AIInformationCell : object {
public Bounds BoundingBox
public List`1<AIInformationCell> NeighbourCells
public AIInformationCellContents`1<AIMovePoint> MovePoints
public AIInformationCellContents`1<AICoverPoint> CoverPoints
private int <X>k__BackingField
private int <Z>k__BackingField
public int X
public int Z
public int get_X()
public int get_Z()
public void .ctor(Bounds bounds, GameObject root, int x, int z)
public void DebugDraw(Color color, bool points, float scale)
}
public AIInformationCellContents`1 : object {
public HashSet`1<T> Items
public int Count
public bool Empty
public int get_Count()
public bool get_Empty()
public void Init(Bounds cellBounds, GameObject root)
public void Clear()
public void Add(T item)
public void Remove(T item)
}
public AIInformationGrid : MonoBehaviour {
public int CellSize
public Bounds BoundingBox
public AIInformationCell[] Cells
private Vector3 origin
private int xCellCount
private int zCellCount
private int maxPointResults
private AIMovePoint[] movePointResults
private AICoverPoint[] coverPointResults
private int maxCellResults
private AIInformationCell[] resultCells
public void Init()
private int GetIndex(int x, int z)
public AIInformationCell CellAt(int x, int z)
public AIMovePoint[] GetMovePointsInRange(Vector3 position, float maxRange, Int32& pointCount)
public AICoverPoint[] GetCoverPointsInRange(Vector3 position, float maxRange, Int32& pointCount)
public AIInformationCell[] GetCellsInRange(Vector3 position, float maxRange, Int32& cellCount)
public AIInformationCell GetCell(Vector3 position)
public void OnDrawGizmos()
public void DebugDraw()
}
public AIInformationGridTester : MonoBehaviour {
public AIInformationGrid Grid
public float Range
}
public AIInformationZone : BaseMonoBehaviour {
public bool RenderBounds
public bool ShouldSleepAI
public bool Virtual
public bool UseCalculatedCoverDistances
public List`1<AIInformationZone> zones
public List`1<AICoverPoint> coverPoints
public List`1<AIMovePoint> movePoints
private AICoverPoint[] coverPointArray
private AIMovePoint[] movePointArray
public List`1<NavMeshLink> navMeshLinks
public List`1<AIMovePointPath> paths
public Bounds bounds
public bool SetMovePointTerrainYOnEnable
private AIInformationGrid grid
public bool UseSimpleLOSCheck
private bool <Sleeping>k__BackingField
private List`1<IAISleepable> sleepables
private OBB areaBox
private bool isDirty
private int processIndex
private int halfPaths
private int pathSuccesses
private int pathFails
private bool initd
private bool lastFrameAnyDirty
private float rebuildStartTime
public float buildTimeTest
private float lastNavmeshBuildTime
public bool Sleeping
public int SleepingCount
public AIInformationZone Merge(List`1<AIInformationZone> zones, GameObject newRoot)
public Bounds EncapsulateBounds(List`1<AIInformationZone> zones)
public bool get_Sleeping()
private void set_Sleeping(bool value)
public int get_SleepingCount()
public void Start()
private void OnEnable()
private void OnDisable()
public void Init()
private void SetMovePointsY(int layerMask, float yStartOffset, float yDistance, float localYDefault)
public void RegisterSleepableEntity(IAISleepable sleepable)
public void UnregisterSleepableEntity(IAISleepable sleepable)
public void SleepAI()
public void WakeAI()
private void AddCoverPoint(AICoverPoint point)
private void RemoveCoverPoint(AICoverPoint point, bool markDirty)
private void AddMovePoint(AIMovePoint point)
private void RemoveMovePoint(AIMovePoint point, bool markDirty)
public void MarkDirty(bool completeRefresh)
private bool PassesBudget(float startTime, float budgetSeconds)
public bool ProcessDistancesAttempt()
private bool ProcessDistances()
public void BudgetedTick()
public void NavmeshBuildingComplete()
public Vector3 ClosestPointTo(Vector3 target)
public void AddInitialPoints()
private void RefreshPointArrays()
public void AddDynamicAIPoints(AIMovePoint[] movePoints, AICoverPoint[] coverPoints, Func`2<Vector3, bool> validatePoint)
public void RemoveDynamicAIPoints(AIMovePoint[] movePoints, AICoverPoint[] coverPoints)
public AIMovePointPath GetNearestPath(Vector3 position)
public AIInformationZone GetForPoint(Vector3 point, bool fallBackToNearest)
public bool PointInside(Vector3 point)
public AIMovePoint GetBestMovePointNear(BaseEntity targetEntity, BaseEntity fromEntity, float minRange, float maxRange, bool checkLOS, BaseEntity forObject, bool returnClosest, bool returnRandom)
public AIPoint[] GetMovePointsInRange(Vector3 currentPos, float maxRange, Int32& pointCount)
private AIMovePoint GetClosestRaw(Vector3 pos, bool onlyIncludeWithCover)
public AICoverPoint GetBestCoverPoint(Vector3 currentPosition, Vector3 hideFromPosition, float minRange, float maxRange, BaseEntity forObject, bool allowObjectToReuse)
private AICoverPoint[] GetCoverPointsInRange(Vector3 position, float maxRange, Int32& pointCount)
public NavMeshLink GetClosestNavMeshLink(Vector3 pos)
}
public AimConeUtil : object {
public Vector3 GetModifiedAimConeDirection(float aimCone, Vector3 inputVec, bool anywhereInside)
public Quaternion GetAimConeQuat(float aimCone)
}
public AIMemory : object {
public AIMemoryBank`1<BaseEntity> Entity
public AIMemoryBank`1<Vector3> Position
public AIMemoryBank`1<AIPoint> AIPoint
public void Clear()
}
public AIMemoryBank`1 : object {
private MemoryBankType type
private T[] slots
private Single[] slotSetTimestamps
private int slotCount
public void .ctor(MemoryBankType type, int slots)
public void Init(MemoryBankType type, int slots)
public void Set(T item, int index)
public T Get(int index)
public float GetTimeSinceSet(int index)
public void Remove(int index)
public void Clear()
}
public AIMovePoint : AIPoint {
public ListDictionary`2<AIMovePoint, float> distances
public ListDictionary`2<AICoverPoint, float> distancesToCover
public float radius
public float WaitTime
public List`1<Transform> LookAtPoints
public void OnDrawGizmos()
public void DrawLookAtPoints()
public void Clear()
public void AddLookAtPoint(Transform transform)
public bool HasLookAtPoints()
public Transform GetRandomLookAtPoint()
}
public AIMovePointPath : MonoBehaviour {
public Color DebugPathColor
public Mode LoopMode
public List`1<AIMovePoint> Points
public void Clear()
public void AddPoint(AIMovePoint point)
public AIMovePoint FindNearestPoint(Vector3 position)
public int FindNearestPointIndex(Vector3 position)
public AIMovePoint GetPointAtIndex(int index)
public int GetNextPointIndex(int currentPointIndex, PathDirection& pathDirection)
private void OnDrawGizmos()
private void OnDrawGizmosSelected()
public void AddChildPoints()
}
public AIPoint : BaseMonoBehaviour {
private BaseEntity currentUser
public bool InUse()
public bool IsUsedBy(BaseEntity user)
public bool CanBeUsedBy(BaseEntity user)
public void SetUsedBy(BaseEntity user, float duration)
public void SetUsedBy(BaseEntity user)
public void ClearUsed()
public void ClearIfUsedBy(BaseEntity user)
}
public AIState : Enum {
public int value__
public AIState None
public AIState Idle
public AIState Roam
public AIState Chase
public AIState Cover
public AIState Combat
public AIState Mounted
public AIState Exfil
public AIState Patrol
public AIState Orbit
public AIState Egress
public AIState Land
public AIState DropCrate
public AIState MoveTowards
public AIState Flee
public AIState Attack
public AIState Sleep
public AIState Reload
public AIState TakeCover
public AIState Dismounted
public AIState FollowPath
public AIState NavigateHome
public AIState CombatStationary
public AIState Cooldown
public AIState MoveToPoint
public AIState MoveToVector3
public AIState Blinded
public AIState KillSelf
public AIState MountAPC
}
public AIStateContainer : object {
private int <ID>k__BackingField
private AIState <State>k__BackingField
public List`1<BaseAIEvent> Events
private int <InputMemorySlot>k__BackingField
public int ID
public AIState State
public int InputMemorySlot
public int get_ID()
private void set_ID(int value)
public AIState get_State()
private void set_State(AIState value)
public int get_InputMemorySlot()
private void set_InputMemorySlot(int value)
public void Init(AIStateContainer container, BaseEntity owner)
public AIStateContainer ToProto()
}
public AIThinkManager : BaseMonoBehaviour {
public ListHashSet`1<IThinker> _processQueue
public ListHashSet`1<IThinker> _removalQueue
public ListHashSet`1<IThinker> _animalProcessQueue
public ListHashSet`1<IThinker> _animalremovalQueue
public ListHashSet`1<IThinker> _petProcessQueue
public ListHashSet`1<IThinker> _petRemovalQueue
public float framebudgetms
public float animalframebudgetms
public float petframebudgetms
private int lastIndex
private int lastAnimalIndex
private int lastPetIndex
public void ProcessQueue(QueueType queueType)
private void DoRemoval(ListHashSet`1<IThinker> removal, ListHashSet`1<IThinker> process)
private void DoProcessing(ListHashSet`1<IThinker> process, float budgetSeconds, Int32& last)
public void Add(IThinker toAdd)
public void Remove(IThinker toRemove)
public void AddAnimal(IThinker toAdd)
public void RemoveAnimal(IThinker toRemove)
public void AddPet(IThinker toAdd)
public void RemovePet(IThinker toRemove)
}
public AIThinkMode : Enum {
public int value__
public AIThinkMode FixedUpdate
public AIThinkMode Interval
}
public AITraversalArea : TriggerBase {
public Transform entryPoint1
public Transform entryPoint2
public AITraversalWaitPoint[] waitPoints
public Bounds movementArea
public Transform activeEntryPoint
public float nextFreeTime
public void OnValidate()
public GameObject InterestedInObject(GameObject obj)
public bool CanTraverse(BaseEntity ent)
public Transform GetClosestEntry(Vector3 position)
public Transform GetFarthestEntry(Vector3 position)
public void SetBusyFor(float dur)
public bool CanUse(Vector3 dirFrom)
public void OnEntityEnter(BaseEntity ent)
public AITraversalWaitPoint GetEntryPointNear(Vector3 pos)
public bool EntityFilter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
public void OnDrawGizmos()
}
public AITraversalWaitPoint : MonoBehaviour {
public float nextFreeTime
public bool Occupied()
public void Occupy(float dur)
}
public AlignedLineDrawer : MonoBehaviour {
public MeshFilter Filter
public MeshRenderer Renderer
public float LineWidth
public float SurfaceOffset
public float SprayThickness
public float uvTilingFactor
public bool DrawEndCaps
public bool DrawSideMesh
public bool DrawBackMesh
public SprayCanSpray_Freehand Spray
}
public AlignedLineDrawerDecal : AlignedLineDrawer {
public DeferredDecal decalComponent
}
public AlphaSinPulse : MonoBehaviour {
public CanvasGroup target
public float speed
public float amplitude
public bool preview
}
public AlternateAttack : StateMachineBehaviour {
public bool random
public bool dontIncrement
public String[] targetTransitions
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public AmbienceDefinition : ScriptableObject {
public List`1<SoundDefinition> sounds
public ValueRange stingFrequency
public Enum biomes
public Enum topologies
public EnvironmentType environmentType
public bool useEnvironmentType
public AnimationCurve time
public ValueRange rain
public ValueRange wind
public ValueRange snow
public ValueRange waves
}
public AmbienceDefinitionList : ScriptableObject {
public List`1<AmbienceDefinition> defs
}
public AmbienceEmitter : MonoBehaviour {
public AmbienceDefinitionList baseAmbience
public AmbienceDefinitionList stings
public bool isStatic
public bool followCamera
public bool isBaseEmitter
public bool active
public float cameraDistanceSq
public BoundingSphere boundingSphere
public float crossfadeTime
private Enum <currentTopology>k__BackingField
private Enum <currentBiome>k__BackingField
public Dictionary`2<AmbienceDefinition, float> nextStingTime
public float deactivateTime
public bool playUnderwater
public bool playAbovewater
public Enum currentTopology
public Enum currentBiome
public Enum get_currentTopology()
private void set_currentTopology(Enum value)
public Enum get_currentBiome()
private void set_currentBiome(Enum value)
public int CompareTo(AmbienceEmitter other)
}
public AmbienceLocalStings : MonoBehaviour {
public float maxDistance
public float stingRadius
public float stingFrequency
public float stingFrequencyVariance
public SoundDefinition[] stingSounds
}
public AmbienceManager : SingletonComponent`1<AmbienceManager> {
public List`1<EmitterTypeLimit> localEmitterLimits
public EmitterTypeLimit catchallEmitterLimit
public int maxActiveLocalEmitters
public int activeLocalEmitters
public List`1<AmbienceEmitter> cameraEmitters
public List`1<AmbienceEmitter> emittersInRange
public List`1<AmbienceEmitter> activeEmitters
public float localEmitterRange
public List`1<AmbienceZone> currentAmbienceZones
public bool isUnderwater
private float <ambienceZoneGain>k__BackingField
public float ambienceZoneGain
public float get_ambienceZoneGain()
private void set_ambienceZoneGain(float value)
}
public AmbienceSpawnEmitters : MonoBehaviour {
public int baseEmitterCount
public int baseEmitterDistance
public GameObjectRef emitterPrefab
}
public AmbienceWaveSounds : SingletonComponent`1<AmbienceWaveSounds> {
public int emitterCount
public float emitterDistance
public List`1<WaveLayer> waveLayers
}
public AmbienceWaveSoundZone : TriggerBase {
public float priority
public float gain
public void PreClientComponentCull(IPrefabProcessor p)
}
public AmbienceZone : TriggerBase {
public AmbienceDefinitionList baseAmbience
public AmbienceDefinitionList stings
public float priority
public bool overrideCrossfadeTime
public float crossfadeTime
public float ambienceGain
public void PreClientComponentCull(IPrefabProcessor p)
}
public AmbientLightLOD : FacepunchBehaviour {
public bool isDynamic
public float enabledRadius
public bool toggleFade
public float toggleFadeDuration
protected void OnValidate()
}
public AmmoBelowAIEvent : BaseAIEvent {
private float <Value>k__BackingField
public float Value
public float get_Value()
private void set_Value(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public AmmoInformationPanel : ItemInformationPanel {
public ItemStatValue damageDisplay
public ItemStatValue velocityDisplay
public ItemStatValue spreadDisplay
public ItemTextValue pelletsDisplay
public ItemStatValue falloffRangeDisplay
public ItemTextValue thicknessDisplay
}
public AmplifyOcclusion.VersionInfo : object {
public byte Major
public byte Minor
public byte Release
private string StageSuffix
private int m_major
private int m_minor
private int m_release
public int Number
public string StaticToString()
public string ToString()
public int get_Number()
private void .ctor(byte major, byte minor, byte release)
public VersionInfo Current()
public bool Matches(VersionInfo version)
}
public AmplifyOcclusionBase : MonoBehaviour {
public ApplicationMethod ApplyMethod
public SampleCountLevel SampleCount
public PerPixelNormalSource PerPixelNormals
public float Intensity
public Color Tint
public float Radius
public int PixelRadiusLimit
public float RadiusIntensity
public float PowerExponent
public float Bias
public float Thickness
public bool Downsample
public bool FadeEnabled
public float FadeStart
public float FadeLength
public float FadeToIntensity
public Color FadeToTint
public float FadeToRadius
public float FadeToPowerExponent
public float FadeToThickness
public bool BlurEnabled
public int BlurRadius
public int BlurPasses
public float BlurSharpness
public bool FilterEnabled
public float FilterBlending
public float FilterResponse
public bool TemporalDirections
public bool TemporalOffsets
public bool TemporalDilation
public bool UseMotionVectors
}
public AndAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public ANDSwitch : IOEntity {
private int input1Amount
private int input2Amount
public int ConsumptionAmount()
public bool WantsPower(int inputIndex)
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int slot)
}
public AnimalAnimation : MonoBehaviour {
public BaseEntity Entity
public BaseNpc Target
public Animator Animator
public MaterialEffect FootstepEffects
public Transform[] Feet
public SoundDefinition saddleMovementSoundDef
public SoundDefinition saddleMovementSoundDefWood
public SoundDefinition saddleMovementSoundDefRoadsign
public AnimationCurve saddleMovementGainCurve
public bool hasIdleOffset
public string BaseFolder
public Flags Flag_WoodArmor
public Flags Flag_RoadsignArmor
}
public AnimalBrain : BaseAIBrain {
public int Count
public NavigationSpeed ControlTestAnimalSpeed
public void AddStates()
public void InitializeAI()
public void OnDestroy()
public BaseAnimalNPC GetEntity()
}
public AnimalFootIK : MonoBehaviour {
public Transform[] Feet
public Animator animator
public float maxWeightDistance
public float minWeightDistance
public float actualFootOffset
public bool GroundSample(Vector3 origin, RaycastHit& hit)
public void Start()
public AvatarIKGoal GoalFromIndex(int index)
private void OnAnimatorIK(int layerIndex)
}
public AnimalMultiSkin : object {
public Material[] multiSkin
}
public AnimalRagdoll : Ragdoll {
public SkinnedMeshRenderer[] bodyRenderers
public SkinnedMeshRenderer[] hairRenderers
}
public AnimalSkin : MonoBehaviour {
public SkinnedMeshRenderer[] animalMesh
public AnimalMultiSkin[] animalSkins
private Model model
public bool dontRandomizeOnStart
private void Start()
public void ChangeSkin(int iSkin)
}
public AnimatedBuildingBlock : StabilityEntity {
private bool animatorNeedsInitializing
private bool animatorIsOpen
public bool isAnimating
private int Open
public void ServerInit()
public void PostServerLoad()
public void OnFlagsChanged(Flags old, Flags next)
protected void ApplySubAnimationParameters(bool init, Animator toAnimator)
protected void UpdateAnimationParameters(bool init)
protected void OnAnimatorFinished()
private void PutAnimatorToSleep()
protected void OnAnimatorDisabled()
}
public AnimatedScreenShake : BaseScreenShake {
public AnimationClip TargetClip
public AnimationCurve rotX
public AnimationCurve rotY
public AnimationCurve rotZ
public AnimationCurve posX
public AnimationCurve posY
public AnimationCurve posZ
private float VALID_RANGE
private bool canPlay
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public AnimationEventForward : MonoBehaviour {
public GameObject targetObject
public void Event(string type)
}
public AnimationEvents : BaseMonoBehaviour {
public Transform rootObject
public HeldEntity targetEntity
public string effectFolder
public bool enforceClipWeights
public string localFolder
public bool customLocalFolder
public bool IsBusy
protected void OnEnable()
}
public AnimationFlagHandler : MonoBehaviour {
public Animator animator
public void SetBoolTrue(string name)
public void SetBoolFalse(string name)
}
public AnimatorLOD : LODComponent {
public float Distance
}
public AntiHack : object {
private int movement_mask
private int vehicle_mask
private int grounded_mask
private int player_mask
private Collider[] buffer
private Dictionary`2<ulong, int> kicks
private Dictionary`2<ulong, int> bans
private float LOG_GROUP_SECONDS
private Queue`1<GroupedLog> groupedLogs
public RaycastHit isInsideRayHit
public bool TestNoClipping(Vector3 oldPos, Vector3 newPos, float radius, float backtracking, bool sphereCast, Collider& collider, bool vehicleLayer, BaseEntity ignoreEntity)
public void Cycle()
public void ResetTimer(BasePlayer ply)
public bool ShouldIgnore(BasePlayer ply)
public bool ValidateMove(BasePlayer ply, TickInterpolator ticks, float deltaTime)
public void ValidateEyeHistory(BasePlayer ply)
public bool IsInsideTerrain(BasePlayer ply)
public bool TestInsideTerrain(Vector3 pos)
public bool IsInsideMesh(Vector3 pos)
public bool IsNoClipping(BasePlayer ply, TickInterpolator ticks, float deltaTime, Collider& collider)
public bool IsSpeeding(BasePlayer ply, TickInterpolator ticks, float deltaTime)
public bool IsFlying(BasePlayer ply, TickInterpolator ticks, float deltaTime)
public bool TestFlying(BasePlayer ply, Vector3 oldPos, Vector3 newPos, bool verifyGrounded)
public bool TestServerSideFallDamage(BasePlayer ply, Vector3 oldPos, Vector3 newPos, float deltaTime)
public void ResetServerFall(BasePlayer ply)
public bool TestIsBuildingInsideSomething(Target target, Vector3 deployPos)
public void NoteAdminHack(BasePlayer ply)
public void FadeViolations(BasePlayer ply, float deltaTime)
public void EnforceViolations(BasePlayer ply)
public void Log(BasePlayer ply, AntiHackType type, string message, bool logToAnalytics)
public void LogToConsoleBatched(BasePlayer ply, AntiHackType type, string message, float maxDistance)
private void LogToConsole(BasePlayer ply, AntiHackType type, string message)
private void LogToConsole(string plyName, AntiHackType type, string message, Vector3 pos)
private void LogToEAC(BasePlayer ply, AntiHackType type, string message)
public void AddViolation(BasePlayer ply, AntiHackType type, float amount)
public void Kick(BasePlayer ply, string reason)
public void Ban(BasePlayer ply, string reason)
private void AddRecord(BasePlayer ply, Dictionary`2<ulong, int> records)
public int GetKickRecord(BasePlayer ply)
public int GetBanRecord(BasePlayer ply)
private int GetRecord(BasePlayer ply, Dictionary`2<ulong, int> records)
}
public AntiHackType : Enum {
public int value__
public AntiHackType None
public AntiHackType NoClip
public AntiHackType SpeedHack
public AntiHackType FlyHack
public AntiHackType ProjectileHack
public AntiHackType MeleeHack
public AntiHackType EyeHack
public AntiHackType AttackHack
public AntiHackType ReloadHack
public AntiHackType CooldownHack
public AntiHackType InsideTerrain
public AntiHackType InsideGeometry
public AntiHackType EffectHack
}
public AppIOEntity : IOEntity {
private float _cacheTime
private BuildingPrivlidge _cache
public AppEntityType Type
public bool Value
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public AppEntityType get_Type()
public bool get_Value()
public void set_Value(bool value)
protected void BroadcastValueChange()
internal void FillEntityPayload(AppEntityPayload payload)
public BuildingPrivlidge GetBuildingPrivilege()
public EntityTarget GetTarget()
public void PairWithApp(RPCMessage msg)
protected void OnPairedWithPlayer(BasePlayer player)
}
public ApplyTerrainAnchors : MonoBehaviour {
protected void Awake()
}
public ApplyTerrainModifiers : MonoBehaviour {
protected void Awake()
}
public ApplyTweakUIChanges : MonoBehaviour {
public Button ApplyButton
public TweakUIBase[] Options
private void OnEnable()
public void Apply()
public void SetDirty()
public void SetClean()
}
public ArcadeClientAuthTest : ArcadeEntityController {
public float speed
public float maxSpeed
public BaseArcadeGame myGame
public ArcadeEntity myEntity
}
public ArcadeEntity : BaseMonoBehaviour {
public UInt32 id
public UInt32 spriteID
public UInt32 soundID
public bool visible
public Vector3 heading
public bool isEnabled
public bool dirty
public float alpha
public BoxCollider boxCollider
public bool host
public bool localAuthorativeOverride
public ArcadeEntity arcadeEntityParent
public UInt32 prefabID
public bool takesDamage
public float health
public float maxHealth
public bool mapLoadedEntiy
}
public ArcadeEntityController : BaseMonoBehaviour {
public BaseArcadeGame parentGame
public ArcadeEntity arcadeEntity
public ArcadeEntity sourceEntity
public Vector3 heading
public Vector3 positionLocal
public Vector3 positionWorld
public Vector3 get_heading()
public void set_heading(Vector3 value)
public Vector3 get_positionLocal()
public void set_positionLocal(Vector3 value)
public Vector3 get_positionWorld()
public void set_positionWorld(Vector3 value)
}
public ArcadeNetworkTrigger : TriggerBase {
public GameObject InterestedInObject(GameObject obj)
}
public ArmorInformationPanel : ItemInformationPanel {
public ItemTextValue projectileDisplay
public ItemTextValue meleeDisplay
public ItemTextValue coldDisplay
public ItemTextValue explosionDisplay
public ItemTextValue radiationDisplay
public ItemTextValue biteDisplay
public ItemTextValue spacer
public Text areaProtectionText
public Phrase LegText
public Phrase ChestText
public Phrase HeadText
public Phrase ChestLegsText
public Phrase WholeBodyText
public ItemTextValue eggVision
}
public ArmorProperties : ScriptableObject {
public HitArea area
public bool Contains(HitArea hitArea)
}
public ArrayEx : object {
public T[] New(int length)
public T GetRandom(T[] array)
public T GetRandom(T[] array, UInt32 seed)
public T GetRandom(T[] array, UInt32& seed)
public void Shuffle(T[] array, UInt32 seed)
public void Shuffle(T[] array, UInt32& seed)
public void BubbleSort(T[] array)
}
public ArticulatedOccludee : BaseMonoBehaviour {
private float UpdateBoundsFadeStart
private float UpdateBoundsFadeLength
private float UpdateBoundsMaxFrequency
private float UpdateBoundsMinFrequency
private LODGroup lodGroup
public List`1<Collider> colliders
private OccludeeSphere localOccludee
private List`1<Renderer> renderers
private bool isVisible
private Action TriggerUpdateVisibilityBoundsDelegate
public bool IsVisible
public bool get_IsVisible()
protected void OnDisable()
private void ClearVisibility()
public void ProcessVisibility(LODGroup lod)
private void RegisterForCulling(Sphere sphere, bool visible)
private void UnregisterFromCulling()
public void UpdateCullingBounds()
protected bool CheckVisibility()
private void ApplyVisibility(bool vis)
protected void OnVisibilityChanged(bool visible)
private void UpdateVisibility(float delay)
private void VisUpdateUsingCulling(float dist, bool visibility)
public void TriggerUpdateVisibilityBounds()
}
public AspectRatioGuide : MonoBehaviour {
public AspectRatioFitter aspectRatioFitter
public RustText label
public float aspect
public float ratio
private void Populate()
public void Awake()
public void Update()
}
public AssetNameCache : object {
private Dictionary`2<Object, string> mixed
private Dictionary`2<Object, string> lower
private Dictionary`2<Object, string> upper
private string LookupName(Object obj)
private string LookupNameLower(Object obj)
private string LookupNameUpper(Object obj)
public string GetName(PhysicMaterial mat)
public string GetNameLower(PhysicMaterial mat)
public string GetNameUpper(PhysicMaterial mat)
public string GetName(Material mat)
public string GetNameLower(Material mat)
public string GetNameUpper(Material mat)
}
public AssetStorage : object {
public void Save(T& asset, string path)
public void Save(Texture2D& asset)
public void Save(Texture2D& asset, string path, bool linear, bool compress)
public void Load(T& asset, string path)
public void Delete(T& asset)
}
public AsyncTerrainNavMeshBake : CustomYieldInstruction {
private List`1<int> indices
private List`1<Vector3> vertices
private List`1<Vector3> normals
private List`1<int> triangles
private Vector3 pivot
private int width
private int height
private bool normal
private bool alpha
private Action worker
public bool keepWaiting
public bool isDone
public Mesh mesh
public bool get_keepWaiting()
public bool get_isDone()
public NavMeshBuildSource CreateNavMeshBuildSource()
public NavMeshBuildSource CreateNavMeshBuildSource(int area)
public Mesh get_mesh()
public void .ctor(Vector3 pivot, int width, int height, bool normal, bool alpha)
private void DoWork()
private void Invoke()
private void Callback(IAsyncResult result)
}
public AtmosphereVolume : MonoBehaviour {
public float MaxVisibleDistance
public float BoundsAttenuationDecay
public FogSettings FogSettings
}
public AtmosphereVolumeRenderer : MonoBehaviour {
public FogMode Mode
public bool DistanceFog
public bool HeightFog
public AtmosphereVolume Volume
private bool isSupported
private bool get_isSupported()
}
public AttackedAIEvent : BaseAIEvent {
protected float lastExecuteTime
private BaseCombatEntity combatEntity
public void Reset()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public AttackEntity : HeldEntity {
public float deployDelay
public float repeatDelay
public float animationDelay
public float effectiveRange
public float npcDamageScale
public float attackLengthMin
public float attackLengthMax
public float attackSpacing
public float aiAimSwayOffset
public float aiAimCone
public bool aiOnlyInRange
public float CloseRangeAddition
public float MediumRangeAddition
public float LongRangeAddition
public bool CanUseAtMediumRange
public bool CanUseAtLongRange
public SoundDefinition[] reloadSounds
public SoundDefinition thirdPersonMeleeSound
public float recoilCompDelayOverride
public bool wantsRecoilComp
public bool showCrosshairOnTutorial
public bool noHeadshots
public EncryptedValue`1<float> nextAttackTime
protected bool UsingInfiniteAmmoCheat
public float NextAttackTime
public Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
public float AmmoFraction()
public bool CanReload()
public bool ServerIsReloading()
public void ServerReload()
public bool ServerTryReload(IAmmoContainer ammoSource)
public void TopUpAmmo()
public Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier)
protected bool get_UsingInfiniteAmmoCheat()
public float get_NextAttackTime()
public void GetAttackStats(HitInfo info)
public void StartAttackCooldownRaw(float cooldown)
public void StartAttackCooldown(float cooldown)
public void ResetAttackCooldown()
public bool HasAttackCooldown()
protected float GetAttackCooldown()
protected float GetAttackIdle()
protected float CalculateCooldownTime(float nextTime, float cooldown, bool catchup)
protected bool VerifyClientRPC(BasePlayer player)
protected bool VerifyClientAttack(BasePlayer player)
protected bool ValidateEyePos(BasePlayer player, Vector3 eyePos, bool checkLineOfSight)
public void OnHeldChanged()
}
public AttackHeliCamOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
}
public AttackHelicopter : PlayerHelicopter {
public Transform gunnerEyePos
private Transform turbofanBone
private GameObjectRef turretStoragePrefab
private GameObjectRef rocketStoragePrefab
private GameObjectRef gunCamUIPrefab
private GameObjectRef gunCamUIDialogPrefab
private GameObject gunCamUIParent
private ParticleSystemContainer fxLightDamage
private ParticleSystemContainer fxMediumDamage
private ParticleSystemContainer fxHeavyDamage
private SoundDefinition damagedLightLoop
private SoundDefinition damagedHeavyLoop
private GameObject damageSoundTarget
private MeshRenderer monitorStaticRenderer
private Material monitorStatic
private Material monitorStaticSafeZone
public GameObjectRef flareFireFX
public GameObjectRef pilotFlare
public Transform leftFlareLaunchPos
public Transform rightFlareLaunchPos
public float flareLaunchVel
private Renderer rocketLightOff
private Renderer rocketLightRed
private Renderer rocketLightGreen
private Renderer flareLightOff
private Renderer flareLightRed
private Renderer flareLightGreen
public Vector2 turretPitchClamp
public Vector2 turretYawClamp
public Flags IN_GUNNER_VIEW_FLAG
public Flags IN_SAFE_ZONE_FLAG
protected int headingGaugeIndex
protected int altGaugeIndex
protected int altShakeIndex
public EntityRef`1<AttackHelicopterTurret> turretInstance
public EntityRef`1<AttackHelicopterRockets> rocketsInstance
public GunnerInputState gunnerInputState
public TimeSince timeSinceLastGunnerInput
public TimeSince timeSinceFailedWeaponFireRPC
public TimeSince timeSinceFailedFlareRPC
public bool HasSafeZoneFlag
public bool GunnerIsInGunnerView
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_HasSafeZoneFlag()
public bool get_GunnerIsInGunnerView()
public void OnFlagsChanged(Flags old, Flags next)
protected void OnChildAdded(BaseEntity child)
public void Load(LoadInfo info)
public AttackHelicopterTurret GetTurret()
public AttackHelicopterRockets GetRockets()
public void PilotInput(InputState inputState, BasePlayer player)
public void PassengerInput(InputState inputState, BasePlayer player)
public void WeaponFireFailed(int ammo, BasePlayer player)
public void FlareFireFailed(BasePlayer player)
public void VehicleFixedUpdate()
public bool EnterTrigger(TriggerBase trigger)
public void LeaveTrigger(TriggerBase trigger)
public void PrePlayerDismount(BasePlayer player, BaseMountable seat)
internal void DoServerDestroy()
public void Save(SaveInfo info)
public void MarkAllMountedPlayersAsHostile()
public bool AdminFixUp(int tier)
public void LaunchFlare()
public void RPC_OpenTurret(RPCMessage msg)
public void RPC_OpenStorage(RPCMessage msg)
public void RPC_OpenGunnerView(RPCMessage msg)
public void RPC_CloseGunnerView(RPCMessage msg)
}
public AttackHelicopterRockets : StorageContainer {
private Transform[] rocketMuzzlePositions
private GameObjectRef rocketFireTubeFX
public float timeBetweenRockets
private float timeBetweenFlares
public float reloadTime
public int rocketsPerReload
private ItemDefinition incendiaryRocketDef
private ItemDefinition hvRocketDef
private ItemDefinition flareItemDef
public AttackHelicopter owner
private AmmoTypes ammoType
public TimeSince timeSinceRocketFired
private TimeSince timeSinceFlareFired
private float ROCKET_LAUNCH_OFFSET
private int rocketsSinceReload
private bool leftSide
public bool CanFireRocket
public bool IsReloading
public bool CanFireFlare
private bool HasOwner
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_CanFireRocket()
public bool get_IsReloading()
public bool get_CanFireFlare()
private bool get_HasOwner()
public void InitShared()
public int GetRocketAmount()
public bool HasFlareAmmo()
public int GetAmmoBeforeReload()
public bool TryGetAmmoDef(ItemDefinition& ammoDef)
public Vector3 MuzzleMidPoint()
public float GetMinRocketSpeed()
public Vector3 GetProjectedHitPos()
private void ResetFiringTimes()
public void Save(SaveInfo info)
public BasePlayer ToPlayer()
public bool ItemFilter(Item item, int targetSlot)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool InputTick(GunnerInputState input, BasePlayer gunner)
public bool TryFireRocket(BasePlayer shooter)
public bool TryFireFlare()
private bool <ItemFilter>g__IsValidRocket|36_0(<>c__DisplayClass36_0& )
private bool <ItemFilter>g__IsValidFlare|36_1(<>c__DisplayClass36_0& )
}
public AttackHelicopterTurret : StorageContainer {
public Transform turretSocket
public Transform turretHorizontal
public Transform turretVertical
public AttackHelicopter owner
private GunStatus <GunState>k__BackingField
public EntityRef`1<HeldEntity> attachedHeldEntity
public bool forceAcceptAmmo
public float WEAPON_Z_OFFSET_SCALE
public float muzzleYOffset
public float lastSentX
public float lastSentY
public bool HasOwner
public GunStatus GunState
public float GunXAngle
public float GunYAngle
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_HasOwner()
public GunStatus get_GunState()
public void set_GunState(GunStatus value)
public float get_GunXAngle()
public float get_GunYAngle()
public void Load(LoadInfo info)
public void SetGunRotation(float xRot, float yRot)
public HeldEntity GetAttachedHeldEntity()
public void GetAmmoAmounts(Int32& clip, Int32& available)
public Vector3 GetProjectedHitPos()
public void ServerInit()
public void Save(SaveInfo info)
public BasePlayer ToPlayer()
public bool CanAcceptItem(Item item, int targetSlot)
public bool IsValidWeapon(Item item)
public bool InputTick(GunnerInputState input)
public Vector3 ClampEyeAngle(Transform heliTransform, Vector3 eyeDir, Vector2 pitchRange, Vector2 yawRange)
public void OnItemAddedOrRemoved(Item item, bool added)
public void UpdateAttachedWeapon()
public bool TryReload()
public bool TryFireWeapon()
public void RefreshGunState()
}
public AttackHeliDriverSeat : BaseVehicleSeat {
private Sprite rocketCrosshair
private Sprite incendRocketCrosshair
private Sprite hvRocketCrosshair
private Sprite reloadingCrosshair
private GameObjectRef rocketHVItem
private GameObjectRef rocketIncenItem
private AttackHelicopter _owner
private AttackHelicopter Owner
private AttackHelicopter get_Owner()
}
public AttackHeliGunnerSeat : BaseVehicleSeat {
private AttackHelicopter _owner
private AttackHelicopter Owner
private AttackHelicopter get_Owner()
public bool CanHoldItems()
public Transform GetEyeOverride()
public Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot)
public Vector3 EyeCenterForPlayer(BasePlayer player, Quaternion lookRot)
public Vector2 GetPitchClamp()
public Vector2 GetYawClamp()
}
public AttackHeliPilotFlare : MonoBehaviour {
protected void Start()
protected void OnDestroy()
public void Init(Vector3 initialVelocity)
public Vector3 CenterPoint()
public bool IsVisible(Vector3 from, float maxDistance)
public bool InSafeZone()
public bool IsValidHomingTarget()
public void OnEntityMessage(BaseEntity from, string msg)
}
public AttackHeliUIDialog : UIDialog {
private Material compassStripMat
private Canvas mainCanvas
private CanvasGroup gunCrosshair
private CanvasGroup gunNoAmmoCrosshair
private CanvasGroup gunCrosshairGhost
private RectTransform gunCrosshairGhostRect
private Canvas rocketCrosshairDefaultCanvas
private RectTransform rocketCrosshairDefaultRect
private Canvas rocketCrosshairHVCanvas
private RectTransform rocketCrosshairHVRect
private Canvas rocketCrosshairIncenCanvas
private RectTransform rocketCrosshairIncenRect
private GameObjectRef rocketHVItem
private GameObjectRef rocketIncenItem
private CanvasGroup crosshairHitMarkerGroup
private RectTransform zoomIndicator
private RectTransform positionBox
private RustText ammoTextGunMag
private RustText ammoTextGunRest
private RustText ammoTextRocketMag
private RustText ammoTextRocketRest
private RustText rangeText
private float zoomIndicatorMinY
private float zoomIndicatorMaxY
private float positionBoxXMult
private float positionBoxYMult
private Animator damageWarning
}
public AttackTickAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public AttractionPoint : PrefabAttribute {
public string groupName
protected Type GetIndexedType()
}
public AudioSettings : MonoBehaviour {
public float duckingFactor
public AudioMixer mixer
private void Update()
private float LinearToDecibel(float linear)
}
public AudioVisualisationEntity : IOEntity {
private EntityRef`1<BaseEntity> connectedTo
private LightColour <currentColour>k__BackingField
private VolumeSensitivity <currentVolumeSensitivity>k__BackingField
private Speed <currentSpeed>k__BackingField
public GameObjectRef SettingsDialog
private int <currentGradient>k__BackingField
public LightColour currentColour
public VolumeSensitivity currentVolumeSensitivity
public Speed currentSpeed
public int currentGradient
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public LightColour get_currentColour()
private void set_currentColour(LightColour value)
public VolumeSensitivity get_currentVolumeSensitivity()
private void set_currentVolumeSensitivity(VolumeSensitivity value)
public Speed get_currentSpeed()
private void set_currentSpeed(Speed value)
public int get_currentGradient()
private void set_currentGradient(int value)
public void OnFlagsChanged(Flags old, Flags next)
private IOEntity GetAudioSource(IOEntity entity, Int32& depth)
public void Save(SaveInfo info)
public void ServerUpdateSettings(RPCMessage msg)
public void Load(LoadInfo info)
}
public AudioVisualisationEntityLight : AudioVisualisationEntity {
public Light TargetLight
public Light SecondaryLight
public MeshRenderer[] TargetRenderer
public LightColourSet RedColour
public LightColourSet GreenColour
public LightColourSet BlueColour
public LightColourSet YellowColour
public LightColourSet PinkColour
public float lightMinIntensity
public float lightMaxIntensity
}
public Auth_CentralizedBans : object {
private BanPayload payloadData
public IEnumerator Run(Connection connection)
private bool CheckIfPlayerBanned(ulong steamId, Connection connection, UnityWebRequest request)
internal void <CheckIfPlayerBanned>g__Reject|2_0(string reason, <>c__DisplayClass2_0& )
}
public Auth_EAC : object {
public IEnumerator Run(Connection connection)
}
public Auth_Nexus : object {
public IEnumerator Run(Connection connection)
}
public Auth_Steam : object {
internal List`1<Connection> waitingList
public IEnumerator Run(Connection connection)
public bool ValidateConnecting(ulong steamid, ulong ownerSteamID, AuthResponse response)
}
public AutoTurret : ContainerIOEntity {
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public float bulletSpeed
public AmbienceEmitter ambienceEmitter
public bool playAmbientSounds
public GameObject assignDialog
public LaserBeam laserBeam
public BaseCombatEntity target
public Transform eyePos
public Transform muzzlePos
public Vector3 aimDir
public Transform gun_yaw
public Transform gun_pitch
public float sightRange
public SoundDefinition turnLoopDef
public SoundDefinition movementChangeDef
public SoundDefinition ambientLoopDef
public SoundDefinition focusCameraDef
public float focusSoundFreqMin
public float focusSoundFreqMax
public GameObjectRef peacekeeperToggleSound
public GameObjectRef onlineSound
public GameObjectRef offlineSound
public GameObjectRef targetAcquiredEffect
public GameObjectRef targetLostEffect
public GameObjectRef reloadEffect
public float aimCone
public Flags Flag_Equipped
public Flags Flag_MaxAuths
public HashSet`1<PlayerNameID> authorizedPlayers
public float auto_turret_budget_ms
public UpdateAutoTurretScanQueue updateAutoTurretScanQueue
public float rcTurnSensitivity
public Transform RCEyes
public GameObjectRef IDPanelPrefab
public RemoteControllableControls rcControls
public string rcIdentifier
private int <ViewerCount>k__BackingField
private Nullable`1<CameraViewerId> <ControllingViewerId>k__BackingField
public TargetTrigger targetTrigger
public TriggerBase interferenceTrigger
public float maxInterference
public float attachedWeaponZOffsetScale
public Transform socketTransform
public bool authDirty
public bool hasPotentialUnauthedTarget
public float nextShotTime
public float lastShotTime
public float nextVisCheck
public float lastTargetSeenTime
public bool targetVisible
public bool booting
public float nextIdleAimTime
public Vector3 targetAimDir
public float bulletDamage
public RealTimeSinceEx timeSinceLastServerTick
public HashSet`1<AutoTurret> nearbyTurrets
public HashSet`1<AutoTurret> interferenceUpdateList
public float nextForcedAimTime
public Vector3 lastSentAimDir
public Single[] visibilityOffsets
public int peekIndex
public int numConsecutiveMisses
public int totalAmmo
public float nextAmmoCheckTime
public bool totalAmmoDirty
public float currentAmmoGravity
public float currentAmmoVelocity
public HeldEntity AttachedWeapon
public int consumptionAmount
public bool CanPing
public bool RequiresMouse
public float MaxRange
public RemoteControllableControls RequiredControls
public int ViewerCount
public Nullable`1<CameraViewerId> ControllingViewerId
public bool IsBeingControlled
public bool PreventDuplicatesInQueue
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_CanPing()
public bool IsOnline()
public bool IsOffline()
public void ResetState()
public Transform GetCenterMuzzle()
public float AngleToTarget(BaseCombatEntity potentialtarget, bool use2D)
public bool InFiringArc(BaseCombatEntity potentialtarget)
public bool CanPickup(BasePlayer player)
public bool CanUseNetworkCache(Connection connection)
public void Save(SaveInfo info)
public void PostSave(SaveInfo info)
public void Load(LoadInfo info)
public Vector3 AimOffset(BaseCombatEntity aimat)
public float GetAimSpeed()
public void UpdateAiming(float dt)
public bool IsAuthed(ulong id)
public bool IsAuthed(BasePlayer player)
public bool AnyAuthed()
public bool CanChangeSettings(BasePlayer player)
public bool PeacekeeperMode()
public Transform GetEyes()
public float GetFovScale()
public BaseEntity GetEnt()
public bool CanControl(ulong playerID)
public bool get_RequiresMouse()
public float get_MaxRange()
public RemoteControllableControls get_RequiredControls()
public int get_ViewerCount()
public void set_ViewerCount(int value)
public Nullable`1<CameraViewerId> get_ControllingViewerId()
public void set_ControllingViewerId(Nullable`1<CameraViewerId> value)
public bool get_IsBeingControlled()
public bool InitializeControl(CameraViewerId viewerID)
public void StopControl(CameraViewerId viewerID)
public void UserInput(InputState inputState, CameraViewerId viewerID)
public bool UpdateManualAim(InputState inputState)
public void InitShared()
public void DestroyShared()
public void RCSetup()
public void RCShutdown()
public void Server_SetID(RPCMessage msg)
public void UpdateIdentifier(string newID, bool clientSend)
public string GetIdentifier()
public bool CanChangeID(BasePlayer player)
public int ConsumptionAmount()
public void SetOnline()
public void SetIsOnline(bool online)
public void ProcessInterferenceQueue()
public int GetPassthroughAmount(int outputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void InitiateShutdown()
public void InitiateStartup()
public void SetPeacekeepermode(bool isOn)
public bool IsValidWeapon(Item item)
public bool CanAcceptItem(Item item, int targetSlot)
public bool AtMaxAuthCapacity()
public void UpdateMaxAuthCapacity()
private void FlipAim(RPCMessage rpc)
private void AddSelfAuthorize(RPCMessage rpc)
public void AddSelfAuthorize(BasePlayer player)
private void RemoveSelfAuthorize(RPCMessage rpc)
private void ClearList(RPCMessage rpc)
public void AssignToFriend(RPCMessage msg)
private void SERVER_Peacekeeper(RPCMessage rpc)
private void SERVER_AttackAll(RPCMessage rpc)
public float TargetScanRate()
public void ServerInit()
internal void DoServerDestroy()
public void OnEntityEnterTrigger(BaseNetworkable entity)
public void SendAimDir()
public void SendAimDirImmediate()
public void SetTarget(BaseCombatEntity targ)
public bool CheckPeekers()
public bool ObjectVisible(BaseCombatEntity obj)
public void FireAttachedGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target)
public void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target)
public void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
public void IdleTick(float dt)
public bool HasClipAmmo()
public bool HasReserveAmmo()
public int GetTotalAmmo()
public AmmoTypes GetValidAmmoTypes()
public ItemDefinition GetDesiredAmmo()
public void Reload()
public void PostServerLoad()
public void UpdateTotalAmmo()
public void OnItemAddedOrRemoved(Item item, bool added)
public bool EnsureReloaded(bool onlyReloadIfEmpty)
public BaseProjectile GetAttachedWeapon()
public bool HasFallbackWeapon()
public bool HasGenericFireable()
public void UpdateAttachedWeapon()
public HeldEntity TryAddWeaponToTurret(Item weaponItem, Transform parent, BaseEntity entityParent, float zOffsetScale)
public void OnKilled(HitInfo info)
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void PlayerStoppedLooting(BasePlayer player)
public float GetMaxAngleForEngagement()
public void TargetTick()
public bool HasTarget()
public void OfflineTick()
public bool IsEntityHostile(BaseCombatEntity ent)
public bool ShouldTarget(BaseCombatEntity targ)
public void ScheduleForTargetScan()
public bool HasInterference()
public void TryRegisterForInterferenceUpdate()
public void UpdateInterference()
public bool get_PreventDuplicatesInQueue()
public void UpdateInterferenceOnOthers()
public void UpdateNearbyTurrets(bool created)
public void TargetScan()
public bool Ignore(BasePlayer player)
public void ServerTick()
public void OnAttacked(HitInfo info)
public void UpdateFacingToTarget(float dt)
public float GetAngle(Vector3 launchPosition, Vector3 targetPosition, float launchVelocity, float gravityScale)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
}
public AvatarSwitcher : StateMachineBehaviour {
public Avatar ToApply
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public AverageVelocity : object {
private Vector3 pos
private float time
private float lastEntry
private float averageSpeed
private Vector3 averageVelocity
public float Speed
public Vector3 Average
public void Record(Vector3 newPos)
public float get_Speed()
public Vector3 get_Average()
}
public BackpackInventoryPanel : MonoBehaviour {
private ItemIcon icon
public GameObject[] ShowWhenSelected
public GameObject[] HideWhenSelected
public Vector3 BackpackTargetRotation
public Vector3 BackpackTargetUIShift
public AnimationCurve BackpackModelRotateCurve
public AnimationCurve BackpackUIShiftCurve
public AnimationCurve BackpackTransparencyCurve
public AnimationCurve FadeOutWhenOpenCurve
public float OpenScale
public float CloseScale
public float BackpackAlphaActiveThreshold
public RectTransform PreviewModelRectTransform
public CanvasGroup BackpackInventoryCanvas
public CanvasGroup[] FadeOutWhenOpen
}
public Ballistics : object {
public Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, Single& requiredGravity)
public Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, float minRange, Single& requiredGravity)
public bool TryGetPhysicsProjectileHitPos(Vector3 origin, Vector3 direction, float speed, float gravity, Vector3& result, float flightTimePerUpwardCheck, float flightTimePerDownwardCheck, float maxRays, BaseNetworkable owner)
public Vector3 GetBulletHitPoint(Vector3 origin, Vector3 direction)
public Vector3 GetBulletHitPoint(Ray aimRay)
private bool NextRayHitSomething(TheoreticalProjectile& projectile, float dt, BaseNetworkable owner)
private float ProjectileDistToGravity(float x, float y, float θ, float v)
}
public Barricade : DecayEntity {
public float reflectDamage
public GameObjectRef reflectEffect
public bool canNpcSmash
public NavMeshModifierVolume NavMeshVolumeAnimals
public NavMeshModifierVolume NavMeshVolumeHumanoids
public NPCBarricadeTriggerBox NpcTriggerBox
private int nonWalkableArea
private int animalAgentTypeId
private int humanoidAgentTypeId
public void ServerInit()
public void OnAttacked(HitInfo info)
}
public BaseAIBrain : EntityComponent`1<BaseEntity> {
public bool SendClientCurrentState
public bool UseQueuedMovementUpdates
public bool AllowedToSleep
public AIDesignSO DefaultDesignSO
public List`1<AIDesignSO> Designs
public AIDesign InstanceSpecificDesign
public float SenseRange
public float AttackRangeMultiplier
public float TargetLostRange
public float VisionCone
public bool CheckVisionCone
public bool CheckLOS
public bool IgnoreNonVisionSneakers
public float IgnoreSneakersMaxDistance
public float IgnoreNonVisionMaxDistance
public float ListenRange
public EntityType SenseTypes
public bool HostileTargetsOnly
public bool IgnoreSafeZonePlayers
public int MaxGroupSize
public float MemoryDuration
public bool RefreshKnownLOS
public bool CanBeBlinded
public float BlindDurationMultiplier
public float MovementTickStartDelay
private BasicAIState <CurrentState>k__BackingField
public AIState ClientCurrentState
public Vector3 mainInterestPoint
private AIThinkMode <ThinkMode>k__BackingField
private float <Age>k__BackingField
private AIBrainSenses <Senses>k__BackingField
private BasePathFinder <PathFinder>k__BackingField
public bool UseAIDesign
private AIEvents <Events>k__BackingField
private AIDesign <AIDesign>k__BackingField
private BasePlayer <DesigningPlayer>k__BackingField
private BasePlayer <OwningPlayer>k__BackingField
private bool <IsGroupLeader>k__BackingField
private bool <IsGrouped>k__BackingField
private IAIGroupable <GroupLeader>k__BackingField
public bool Pet
public List`1<IAIGroupable> groupMembers
public bool CanUseHealingItems
public float HealChance
public float HealBelowHealthFraction
protected int loadedDesignIndex
private BaseNavigator <Navigator>k__BackingField
public int currentStateContainerID
private float lastMovementTickTime
public bool sleeping
private bool disabled
public Dictionary`2<AIState, BasicAIState> states
protected float thinkRate
protected float lastThinkTime
protected float unblindTime
public BasicAIState CurrentState
public AIThinkMode ThinkMode
public float Age
public AIBrainSenses Senses
public BasePathFinder PathFinder
public AIEvents Events
public AIDesign AIDesign
public BasePlayer DesigningPlayer
public BasePlayer OwningPlayer
public bool IsGroupLeader
public bool IsGrouped
public IAIGroupable GroupLeader
public BaseNavigator Navigator
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public BasicAIState get_CurrentState()
public void set_CurrentState(BasicAIState value)
public AIThinkMode get_ThinkMode()
public void set_ThinkMode(AIThinkMode value)
public float get_Age()
public void set_Age(float value)
public void ForceSetAge(float age)
public AIBrainSenses get_Senses()
public void set_Senses(AIBrainSenses value)
public BasePathFinder get_PathFinder()
public void set_PathFinder(BasePathFinder value)
public AIEvents get_Events()
public void set_Events(AIEvents value)
public AIDesign get_AIDesign()
public void set_AIDesign(AIDesign value)
public BasePlayer get_DesigningPlayer()
public void set_DesigningPlayer(BasePlayer value)
public BasePlayer get_OwningPlayer()
public void set_OwningPlayer(BasePlayer value)
public bool get_IsGroupLeader()
public void set_IsGroupLeader(bool value)
public bool get_IsGrouped()
public void set_IsGrouped(bool value)
public IAIGroupable get_GroupLeader()
public void set_GroupLeader(IAIGroupable value)
public int LoadedDesignIndex()
public BaseNavigator get_Navigator()
public void set_Navigator(BaseNavigator value)
public void SetEnabled(bool flag)
private bool IAIDesign.CanPlayerDesignAI(BasePlayer player)
private bool PlayerCanDesignAI(BasePlayer player)
private void RequestAIDesign(RPCMessage msg)
private void SubmitAIDesign(RPCMessage msg)
public void IAIDesign.StopDesigning()
public void IAIDesign.LoadAIDesign(AIDesign design, BasePlayer player)
public bool LoadDefaultAIDesign()
public bool LoadAIDesignAtIndex(int index)
public void OnAIDesignLoadedAtIndex(int index)
protected bool LoadAIDesign(AIDesign design, BasePlayer player, int index)
public void SaveDesign()
private void StopAIDesign(RPCMessage msg)
private void ClearDesigningPlayer()
public void SetOwningPlayer(BasePlayer owner)
public bool ShouldServerThink()
public void DoThink()
public List`1<AIState> GetStateList()
public bool Blinded()
public void SetBlinded(float duration)
public void Start()
public void AddStates()
public void InitializeAI()
public BaseEntity GetBrainBaseEntity()
public void OnDestroy()
private void StartMovementTick()
private void StopMovementTick()
public void TickMovement()
public void DoMovementTick()
public void AddState(BasicAIState newState)
public bool HasState(AIState state)
public bool SwitchToState(AIState newState, int stateContainerID)
private bool SwitchToState(BasicAIState newState, int stateContainerID)
protected void OnStateChanged()
private void AddEvents(int stateContainerID)
public void Think(float delta)
private void UpdateAgressionTimer(float delta)
private bool IAISleepable.AllowedToSleep()
private void IAISleepable.SleepAI()
private void IAISleepable.WakeAI()
private void UpdateGroup()
public bool AddMember(IAIGroupable member)
public void JoinGroup(IAIGroupable leader, BaseEntity leaderEntity)
public void SetGroupRoamRootPosition(Vector3 rootPos)
public bool InGroup()
public void LeaveGroup()
public void RemoveMember(IAIGroupable member)
public void SetUngrouped()
public void LoadComponent(LoadInfo info)
public void SaveComponent(SaveInfo info)
private void SendStateChangeEvent(int previousStateID, int newStateID, int sourceEventID)
public void EventTriggeredStateChange(int newStateContainerID, int sourceEventID)
public bool IsPet()
public void SetPetOwner(BasePlayer player)
public bool IsOwnedBy(BasePlayer player)
public bool IssuePetCommand(PetCommandType cmd, int param, Nullable`1<Ray> ray)
}
public BaseAIEvent : object {
private AIEventType <EventType>k__BackingField
private int <TriggerStateContainerID>k__BackingField
private ExecuteRate <Rate>k__BackingField
private bool <ShouldExecute>k__BackingField
private bool <Result>k__BackingField
private bool <Inverted>k__BackingField
private int <OutputEntityMemorySlot>k__BackingField
private int <InputEntityMemorySlot>k__BackingField
private int <ID>k__BackingField
private BaseEntity <Owner>k__BackingField
private float executeTimer
protected float deltaTime
public AIEventType EventType
public int TriggerStateContainerID
public ExecuteRate Rate
public float ExecutionRate
public bool ShouldExecute
public bool Result
public bool Inverted
public int OutputEntityMemorySlot
public bool ShouldSetOutputEntityMemory
public int InputEntityMemorySlot
public int ID
public BaseEntity Owner
public bool HasValidTriggerState
public AIEventType get_EventType()
private void set_EventType(AIEventType value)
public int get_TriggerStateContainerID()
private void set_TriggerStateContainerID(int value)
public ExecuteRate get_Rate()
protected void set_Rate(ExecuteRate value)
public float get_ExecutionRate()
public bool get_ShouldExecute()
protected void set_ShouldExecute(bool value)
public bool get_Result()
protected void set_Result(bool value)
public bool get_Inverted()
private void set_Inverted(bool value)
public int get_OutputEntityMemorySlot()
protected void set_OutputEntityMemorySlot(int value)
public bool get_ShouldSetOutputEntityMemory()
public int get_InputEntityMemorySlot()
protected void set_InputEntityMemorySlot(int value)
public int get_ID()
protected void set_ID(int value)
public BaseEntity get_Owner()
private void set_Owner(BaseEntity value)
public bool get_HasValidTriggerState()
public void .ctor(AIEventType type)
public void Init(AIEventData data, BaseEntity owner)
public void Init(int triggerStateContainer, int id, BaseEntity owner, int inputMemorySlot, int outputMemorySlot, bool inverted)
public AIEventData ToProto()
public void Reset()
public void Tick(float deltaTime, IAIEventListener listener)
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
public void PostExecute()
public void TriggerStateChange(IAIEventListener listener, int sourceEventID)
public BaseAIEvent CreateEvent(AIEventType eventType)
}
public BaseAimable : BaseVehicleMountPoint {
public Transform aimBase
}
public BaseAnimalNPC : BaseNpc {
public string deathStatName
public AnimalBrain brain
public void ServerInit()
internal void DoServerDestroy()
public void TryThink()
public void OnKilled(HitInfo hitInfo)
public void OnAttacked(HitInfo info)
public void PostServerLoad()
public bool CanAttack(BaseEntity entity)
public bool NeedsToReload()
public float EngagementRange()
public bool IsTargetInRange(BaseEntity entity, Single& dist)
public bool CanSeeTarget(BaseEntity entity)
public bool Reload()
public bool StartAttacking(BaseEntity target)
public void StopAttacking()
public float CooldownDuration()
public bool IsOnCooldown()
public bool IsTirednessAbove(float value)
public void StartSleeping()
public void StopSleeping()
public bool IsHungerAbove(float value)
public bool IsThreat(BaseEntity entity)
public bool IsTarget(BaseEntity entity)
public bool IsFriendly(BaseEntity entity)
public float GetAmmoFraction()
public BaseEntity GetBestTarget()
public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
}
public BaseArcadeGame : BaseMonoBehaviour {
public List`1<BaseArcadeGame> globalActiveGames
public Camera cameraToRender
public RenderTexture renderTexture
public Texture2D distantTexture
public Transform center
public int frameRate
public Dictionary`2<UInt32, ArcadeEntity> activeArcadeEntities
public Sprite[] spriteManifest
public ArcadeEntity[] entityManifest
public bool clientside
public bool clientsideInput
public int spriteIndexInvisible
public GameObject arcadeEntityPrefab
public BaseArcadeMachine ownerMachine
public int gameOffsetIndex
private bool isAuthorative
public Canvas canvas
public BasePlayer GetHostPlayer()
}
public BaseArcadeMachine : BaseVehicle {
public BaseArcadeGame arcadeGamePrefab
public BaseArcadeGame activeGame
public ArcadeNetworkTrigger networkTrigger
public float broadcastRadius
public Transform gameScreen
public RawImage RTImage
public Transform leftJoystick
public Transform rightJoystick
public SoundPlayer musicPlayer
public Flags Flag_P1
public Flags Flag_P2
public List`1<ScoreEntry> scores
private int inputFrameRate
private int snapshotFrameRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void AddScore(BasePlayer player, int score)
public void RequestAddScore(RPCMessage msg)
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
protected bool CanPushNow(BasePlayer pusher)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void NearbyClientMessage(string msg)
public void DestroyMessageFromHost(RPCMessage msg)
public void BroadcastEntityMessage(RPCMessage msg)
public void GetSnapshotFromClient(RPCMessage msg)
}
public BaseBoat : BaseVehicle {
public float engineThrust
public float steeringScale
public Transform thrustPoint
public Transform centerOfMass
public Buoyancy buoyancy
public bool preventDecayIndoors
public bool applyCorrectionForces
public Transform[] planeFitPoints
public Vector3 inAirPID
public float inAirDesiredPitch
public Vector3 wavePID
public MinMax correctionRange
public float correctionSpringForce
public float correctionSpringDamping
private Vector3[] worldAnchors
private PidQuaternionController pidController
public bool generate_paths
public bool do_shore_drift
private int secondsUntilShoreDrift
private int secondsBetweenShoreDrift
public float drift_speed
public float gasPedal
public float steering
private TimeSince shoreDriftTimer
private string lastDriftCheckStatus
protected bool AllowKinematicDrift
public int seconds_until_shore_drift(Arg arg)
public int seconds_between_shore_drift(Arg arg)
public bool InDryDock()
public float MaxVelocity()
protected bool get_AllowKinematicDrift()
public void ServerInit()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void DriverInput(InputState inputState, BasePlayer player)
public void OnPoolDestroyed()
public void WakeUp()
protected void OnServerWake()
public bool EngineOn()
public void VehicleFixedUpdate()
protected void ApplyCorrectionForces()
public void WaterVehicleDecay(BaseCombatEntity entity, float decayTickRate, float timeSinceLastUsed, float outsideDecayMinutes, float deepWaterDecayMinutes, float decayStartDelayMinutes, bool preventDecayIndoors)
private void CheckDriftToShore()
private void GoToSleep()
public bool AnyPlayersOnBoat()
public string GetDriftStatus()
private void UpdateShoreDriftInvokeOnAll()
private void UpdateShoreDriftInvoke()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool EngineInWater()
public float WaterFactorForPlayer(BasePlayer player)
public float GetWaterDepth(Vector3 pos)
public List`1<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore, float minWaterDepth)
}
public BaseBulb : MonoBehaviour {
public Renderer bulbRenderer
}
public BaseCardGameEntity : BaseVehicle {
private GameObjectRef uiPrefab
public ItemDefinition scrapItemDef
private GameObjectRef potPrefab
public PlayerStorageInfo[] playerStoragePoints
private GameObjectRef playerStoragePrefab
private CardGameController _gameCont
public CardGameOption gameOption
public EntityRef PotInstance
private bool storageLinked
public int ScrapItemID
public CardGameController GameController
protected float MaxStorageInteractionDist
public bool CanSwapSeats
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int get_ScrapItemID()
public CardGameController get_GameController()
protected float get_MaxStorageInteractionDist()
public void Load(LoadInfo info)
private CardGameController GetGameController()
public void DestroyShared()
public bool get_CanSwapSeats()
public void Save(SaveInfo info)
public void PostServerLoad()
internal void DoServerDestroy()
public void PrePlayerDismount(BasePlayer player, BaseMountable seat)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public StorageContainer GetPot()
public BasePlayer IDToPlayer(ulong id)
public void PlayerStorageChanged()
public CardGamePlayerStorage GetPlayerStorage(int storageIndex)
public CardGamePlayerStorage GetPlayerStorage(ulong playerID)
public int GetMountPointIndex(ulong playerID)
public void SpawnSubEntities()
private void RPC_PlayerInput(RPCMessage msg)
private void RPC_LeaveTable(RPCMessage msg)
private void RPC_OpenLoot(RPCMessage msg)
public void RPC_Editor_SpawnTestPlayer(RPCMessage msg)
public void RPC_Editor_MakeRandomMove(RPCMessage msg)
private void RPC_Play(RPCMessage msg)
}
public BaseChair : BaseMountable {
public float GetComfort()
}
public BaseCollision : MonoBehaviour {
public BaseEntity Owner
public Model model
}
public BaseCombatEntity : BaseEntity {
public SkeletonProperties skeletonProperties
public ProtectionProperties baseProtection
public float startHealth
public Pickup pickup
public Repair repair
public bool ShowHealthInfo
public LifeState lifestate
public bool sendsHitNotification
public bool sendsMeleeHitNotification
public bool markAttackerHostile
public float _health
public float _maxHealth
public Faction faction
public float lastAttackedTime
private Vector3 <LastAttackedDir>k__BackingField
public float lastDealtDamageTime
public int lastNotifyFrame
private float MAX_HEALTH_REPAIR
public DamageType lastDamage
public BaseEntity lastAttacker
public BaseEntity lastDealtDamageTo
public bool ResetLifeStateOnSpawn
public DirectionProperties[] propDirection
public float unHostileTime
private ActionVolume <LastNoiseVolume>k__BackingField
private Vector3 <LastNoisePosition>k__BackingField
public float lastNoiseTime
public Vector3 LastAttackedDir
public float SecondsSinceAttacked
public float SecondsSinceDealtDamage
public float healthFraction
public float health
public float TimeSinceLastNoise
public ActionVolume LastNoiseVolume
public Vector3 LastNoisePosition
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsDead()
public bool IsAlive()
public Faction GetFaction()
public bool IsFriendly(BaseCombatEntity other)
public Vector3 get_LastAttackedDir()
public void set_LastAttackedDir(Vector3 value)
public float get_SecondsSinceAttacked()
public float get_SecondsSinceDealtDamage()
public float get_healthFraction()
public void ResetState()
public void DestroyShared()
public float GetThreatLevel()
public float PenetrationResistance(HitInfo info)
public void ScaleDamage(HitInfo info)
public HitArea SkeletonLookup(UInt32 boneID)
public void Save(SaveInfo info)
public void PostServerLoad()
public void SetJustAttacked()
public void Load(LoadInfo info)
public float get_health()
public void set_health(float value)
public float Health()
public float MaxHealth()
public float StartHealth()
public float StartMaxHealth()
public void SetMaxHealth(float newMax)
public void DoHitNotify(HitInfo info)
public void OnAttacked(HitInfo info)
protected int GetPickupCount()
public bool CanPickup(BasePlayer player)
public void OnPickedUp(Item createdItem, BasePlayer player)
public void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
private void RPC_PickupStart(RPCMessage rpc)
public List`1<ItemAmount> BuildCost()
public float RepairCostFraction()
public List`1<ItemAmount> RepairCost(float healthMissingFraction)
public void OnRepair()
public void OnRepairFinished()
public void OnRepairFailed(BasePlayer player, string reason)
public void OnRepairFailedResources(BasePlayer player, List`1<ItemAmount> requirements)
public void DoRepair(BasePlayer player)
public void InitializeHealth(float newhealth, float newmax)
public void ServerInit()
public void OnHealthChanged(float oldvalue, float newvalue)
public void Hurt(float amount)
public void Hurt(float amount, DamageType type, BaseEntity attacker, bool useProtection)
public void Hurt(HitInfo info)
public bool IsHostile()
public void MarkHostileFor(float duration)
private void DebugHurt(HitInfo info)
public void SetHealth(float hp)
public void Heal(float amount)
public void OnKilled(HitInfo info)
public void Die(HitInfo info)
public void DieInstantly()
public void UpdateSurroundings()
public float get_TimeSinceLastNoise()
public ActionVolume get_LastNoiseVolume()
private void set_LastNoiseVolume(ActionVolume value)
public Vector3 get_LastNoisePosition()
private void set_LastNoisePosition(Vector3 value)
public void MakeNoise(Vector3 position, ActionVolume loudness)
public bool CanLastNoiseBeHeard(Vector3 listenPosition, float listenRange)
}
public BaseCommandBuffer : MonoBehaviour {
private Dictionary`2<Camera, Dictionary`2<int, CommandBuffer>> cameras
protected CommandBuffer GetCommandBuffer(string name, Camera camera, CameraEvent cameraEvent)
protected void CleanupCamera(string name, Camera camera, CameraEvent cameraEvent)
protected void CleanupCommandBuffer(Camera camera, CameraEvent cameraEvent)
protected void Cleanup()
}
public BaseCorpse : BaseCombatEntity {
public GameObjectRef prefabRagdoll
public BaseEntity parentEnt
public ResourceDispenser resourceDispenser
public float CORPSE_SLEEP_THRESHOLD
protected Rigidbody rigidBody
public bool blockDamageIfNotGather
public SpawnGroup spawnGroup
private float RAGDOLL_PUSH_DIST
private float RAGDOLL_PUSH_FORCE
public bool CorpseIsRagdoll
public TraitFlag Traits
public bool get_CorpseIsRagdoll()
public void ResetState()
public void ServerInit()
public void ServerInitCorpse(BaseEntity pr, Vector3 posOnDeah, Quaternion rotOnDeath, PlayerFlags playerFlagsOnDeath, ModelState modelState)
public bool CanRemove()
public void RemoveCorpse()
public void ResetRemovalTime(float dur)
public float GetRemovalTime()
public void ResetRemovalTime()
public void Save(SaveInfo info)
public void TakeChildren(BaseEntity takeChildrenFrom)
public void ApplyInheritedVelocity(Vector3 velocity)
private Rigidbody SetupRigidBody()
public void Load(LoadInfo info)
private void Load(Corpse corpse)
public void OnAttacked(HitInfo info)
protected void PushRagdoll(HitInfo info)
protected void PushRigidbodies(List`1<Rigidbody> rbs, Vector3 hitPos, Vector3 hitNormal)
public string Categorize()
public TraitFlag get_Traits()
public void Eat(BaseNpc baseNpc, float timeSpent)
public bool ShouldInheritNetworkGroup()
}
public BaseDetector : IOEntity {
public PlayerDetectionTrigger myTrigger
public Flags Flag_HasContents
public int ConsumptionAmount()
public bool ShouldTrigger()
public void OnObjects()
public void OnEmpty()
public void OnDetectorTriggered()
public void OnDetectorReleased()
public int GetPassthroughAmount(int outputSlot)
}
public BaseDiggableEntity : BaseCombatEntity {
public bool RequiresShovel
public Vector3 DropOffset
public Vector3 DropVelocity
public int RequiredDigCount
public bool DestroyOnDug
public List`1<DiggableEntityLoot> LootLists
public int digsRemaining
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void Hurt(HitInfo info)
public void Dig(BasePlayer player)
public void OnFirstDig(BasePlayer player)
public void OnSingleDig(BasePlayer player)
public void OnFullyDug(BasePlayer player)
public BaseEntity SpawnItem()
private Nullable`1<ItemEntry> GetItem(Vector3 digWorldPos)
}
public BaseEntity : BaseNetworkable {
public Bounds bounds
public GameObjectRef impactEffect
public bool enableSaving
public bool syncPosition
public Model model
public Flags flags
public UInt32 parentBone
public ulong skinID
private EntityComponentBase[] _components
public bool HasBrain
public string _name
private ulong <OwnerID>k__BackingField
private Queue`1<BaseEntity> globalBroadcastQueue
private UInt32 globalBroadcastProtocol
private UInt32 broadcastProtocol
public List`1<EntityLink> links
private bool linkedToNeighbours
private TimeUntil _transferProtectionRemaining
private Action _disableTransferProtectionAction
public string RpcClientDeprecationNotice
public Spawnable _spawnable
public HashSet`1<BaseEntity> saveList
public BaseEntity creatorEntity
public int ticksSinceStopped
public bool isCallingUpdateNetworkGroup
private EntityRef[] entitySlots
public List`1<TriggerBase> triggers
protected bool isVisible
protected bool isAnimatorVisible
protected bool isShadowVisible
protected OccludeeSphere localOccludee
private float <Weight>k__BackingField
public float RealisticMass
public EntityComponentBase[] Components
public bool IsNpc
public ulong OwnerID
protected float TransferProtectionRemaining
protected Action DisableTransferProtectionAction
public bool ShouldTransferAssociatedFiles
public float PositionTickRate
public bool PositionTickFixedTime
public Vector3 ServerPosition
public Quaternion ServerRotation
public float radiationLevel
public float currentTemperature
public float currentEnvironmentalWetness
public TraitFlag Traits
public float Weight
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float get_RealisticMass()
public void OnCollision(Collision collision, BaseEntity hitEntity)
protected void ReceiveCollisionMessages(bool b)
public EntityComponentBase[] get_Components()
public BasePlayer ToPlayer()
public bool get_IsNpc()
public void InitShared()
public void DestroyShared()
public void ResetState()
public float InheritedVelocityScale()
public bool InheritedVelocityDirection()
public Vector3 GetInheritedProjectileVelocity(Vector3 direction)
public Vector3 GetInheritedThrowVelocity(Vector3 direction)
public Vector3 GetInheritedDropVelocity()
public Vector3 GetParentVelocity()
public Vector3 GetWorldVelocity()
public Vector3 GetLocalVelocity()
public Quaternion GetAngularVelocity()
public OBB WorldSpaceBounds()
public Vector3 PivotPoint()
public Vector3 CenterPoint()
public Vector3 ClosestPoint(Vector3 position)
public Vector3 TriggerPoint()
public float Distance(Vector3 position)
public float SqrDistance(Vector3 position)
public float Distance(BaseEntity other)
public float SqrDistance(BaseEntity other)
public float Distance2D(Vector3 position)
public float SqrDistance2D(Vector3 position)
public float Distance2D(BaseEntity other)
public float SqrDistance2D(BaseEntity other)
public bool IsVisible(Ray ray, int layerMask, float maxDistance)
public bool IsVisibleSpecificLayers(Vector3 position, Vector3 target, int layerMask, float maxDistance)
public bool IsVisible(Vector3 position, Vector3 target, float maxDistance)
public bool IsVisible(Vector3 position, float maxDistance)
public bool IsVisibleAndCanSee(Vector3 position)
public bool IsVisibleAndCanSeeLegacy(Vector3 position, float maxDistance)
public bool CanSee(Vector3 fromPos, Vector3 targetPos)
public bool IsOlderThan(BaseEntity other)
public bool IsOutside()
public bool IsOutside(Vector3 position)
public float WaterFactor()
public float AirFactor()
public bool WaterTestFromVolumes(Vector3 pos, WaterInfo& info)
public bool IsInWaterVolume(Vector3 pos)
public bool WaterTestFromVolumes(Bounds bounds, WaterInfo& info)
public bool WaterTestFromVolumes(Vector3 start, Vector3 end, float radius, WaterInfo& info)
public bool BlocksWaterFor(BasePlayer player)
public float Health()
public float MaxHealth()
public float MaxVelocity()
public float BoundsPadding()
public float PenetrationResistance(HitInfo info)
public GameObjectRef GetImpactEffect(HitInfo info)
public void OnAttacked(HitInfo info)
public Item GetItem()
public Item GetItem(ItemId itemId)
public void GiveItem(Item item, GiveItemReason reason)
public bool CanBeLooted(BasePlayer player)
public BaseEntity GetEntity()
public string ToString()
public string Categorize()
public void Log(string str)
public void SetModel(Model mdl)
public Model GetModel()
public Transform[] GetBones()
public Transform FindBone(string strName)
public UInt32 FindBoneID(Transform boneTransform)
public Transform FindClosestBone(Vector3 worldPos)
public ulong get_OwnerID()
public void set_OwnerID(ulong value)
public bool ShouldBlockProjectiles()
public bool ShouldInheritNetworkGroup()
public bool SupportsChildDeployables()
public bool ForceDeployableSetParent()
public bool IsOnMovingObject()
public void BroadcastEntityMessage(string msg, float radius, int layerMask)
public void OnEntityMessage(BaseEntity from, string msg)
public void DebugServer(int rep, float time)
public string DebugText()
public void OnDebugStart()
protected void DebugText(Vector3 pos, string str, Color color, float time)
public bool HasFlag(Flags f)
public bool HasAny(Flags f)
public bool ParentHasFlag(Flags f)
public void SetFlag(Flags f, bool b, bool recursive, bool networkupdate)
public bool IsOn()
public bool IsOpen()
public bool IsOnFire()
public bool IsLocked()
public bool IsDebugging()
public bool IsDisabled()
public bool IsBroken()
public bool IsBusy()
public bool IsTransferProtected()
public bool IsTransferring()
public string GetLogColor()
public void OnFlagsChanged(Flags old, Flags next)
public void SendNetworkUpdate_Flags()
public bool IsOccupied(Socket_Base socket)
public bool IsOccupied(string socketName)
public EntityLink FindLink(Socket_Base socket)
public EntityLink FindLink(string socketName)
public EntityLink FindLink(String[] socketNames)
public T FindLinkedEntity()
public void EntityLinkMessage(Action`1<T> action)
public void EntityLinkBroadcast(Action`1<T> action, Func`2<S, bool> canTraverseSocket)
public void EntityLinkBroadcast(Action`1<T> action)
public void EntityLinkBroadcast()
public bool ReceivedEntityLinkBroadcast()
public List`1<EntityLink> GetEntityLinks(bool linkToNeighbours)
private void LinkToEntity(BaseEntity other)
private void LinkToNeighbours()
private void InitEntityLinks()
private void FreeEntityLinks()
public void RefreshEntityLinks()
public void SV_RequestFile(RPCMessage msg)
protected float get_TransferProtectionRemaining()
protected Action get_DisableTransferProtectionAction()
public void EnableTransferProtection()
public void DisableTransferProtection()
public void SetParent(BaseEntity entity, bool worldPositionStays, bool sendImmediate)
public void SetParent(BaseEntity entity, string strBone, bool worldPositionStays, bool sendImmediate)
public bool HasChild(BaseEntity c)
public void SetParent(BaseEntity entity, UInt32 boneID, bool worldPositionStays, bool sendImmediate)
public void DestroyOnClient(Connection connection)
public void SendChildrenNetworkUpdate()
public void SendChildrenNetworkUpdateImmediate()
public void SwitchParent(BaseEntity ent)
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
public EntityPrivilege GetEntityBuildingPrivilege()
public BuildingPrivlidge GetBuildingPrivilege()
public BuildingPrivlidge GetNearestBuildingPrivledge()
public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
public void SV_RPCMessage(UInt32 nameID, Message message)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1)
public void ClientRPC(Connection sourceConnection, string funcName)
public void ClientRPC(RpcTarget target)
public void ClientRPC(RpcTarget target, T1 arg1)
public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2)
public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
private void GetRpcTargetNetworkGroup(RpcTarget& target)
private void FreeRPCTarget(RpcTarget target)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName)
protected NetWrite ClientRPCStart(string funcName)
private void ClientRPCWrite(NetWrite write, T arg)
protected void ClientRPCSend(NetWrite write, SendInfo sendInfo)
public void ClientRPCPlayerList(Connection sourceConnection, BasePlayer player, string funcName, List`1<T1> list)
public void Save(SaveInfo info)
public bool ShouldNetworkOwnerInfo()
public bool get_ShouldTransferAssociatedFiles()
public void Load(LoadInfo info)
public void SetCreatorEntity(BaseEntity newCreatorEntity)
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public void EnableGlobalBroadcast(bool wants)
public void EnableSaving(bool wants)
public void ServerInit()
public void OnPlaced(BasePlayer player)
public float get_PositionTickRate()
public bool get_PositionTickFixedTime()
protected bool ShouldUpdateNetworkGroup()
protected bool ShouldUpdateNetworkPosition()
public void NetworkPositionTick()
public void TransformChanged()
public void OnPositionalNetworkUpdate()
public void Spawn()
public void OnParentSpawning()
public void SpawnAsMapEntity()
public void PostMapEntitySpawn()
internal void DoServerDestroy()
internal void OnParentRemoved()
public void OnInvalidPosition()
public BaseCorpse DropCorpse(string strCorpsePrefab, PlayerFlags playerFlagsOnDeath, ModelState modelState)
public BaseCorpse DropCorpse(string strCorpsePrefab, Vector3 posOnDeath, Quaternion rotOnDeath, PlayerFlags playerFlagsOnDeath, ModelState modelState)
public void UpdateNetworkGroup()
public void Eat(BaseNpc baseNpc, float timeSpent)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public bool ShouldNetworkTo(BasePlayer player)
public void AttackerInfo(DeathInfo info)
public void Push(Vector3 velocity)
public void ApplyInheritedVelocity(Vector3 velocity)
public void SetVelocity(Vector3 velocity)
public void SetAngularVelocity(Vector3 velocity)
public Vector3 GetDropPosition()
public Vector3 GetDropVelocity()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public Vector3 get_ServerPosition()
public void set_ServerPosition(Vector3 value)
public Quaternion get_ServerRotation()
public void set_ServerRotation(Quaternion value)
public string Admin_Who()
public bool BuoyancyWake()
public bool BuoyancySleep(bool inWater)
public float get_radiationLevel()
public float RadiationProtection()
public float RadiationExposureFraction()
public float get_currentTemperature()
public float get_currentEnvironmentalWetness()
private void BroadcastSignalFromClient(RPCMessage msg)
protected void OnReceivedSignalServer(Signal signal, string arg)
public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection)
public void SignalBroadcast(Signal signal, Connection sourceConnection)
protected void OnSkinChanged(ulong oldSkinID, ulong newSkinID)
protected void OnSkinPreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool HasAnySlot()
public BaseEntity GetSlot(Slot slot)
public string GetSlotAnchorName(Slot slot)
public void SetSlot(Slot slot, BaseEntity ent)
public EntityRef[] GetSlots()
public void SetSlots(EntityRef[] newSlots)
public bool HasSlot(Slot slot)
public TraitFlag get_Traits()
public bool HasTrait(TraitFlag f)
public bool HasAnyTrait(TraitFlag f)
public bool EnterTrigger(TriggerBase trigger)
public void LeaveTrigger(TriggerBase trigger)
public void RemoveFromTriggers()
public T FindTrigger()
public bool FindTrigger(T& result)
private void ForceUpdateTriggersAction()
public void ForceUpdateTriggers(bool enter, bool exit, bool invoke)
public bool InSafeZone()
public TriggerParent FindSuitableParent()
public float get_Weight()
protected void set_Weight(float value)
}
public BaseEntityChild : MonoBehaviour {
public void Setup(GameObject obj, BaseEntity parent)
public void OnDestroy()
}
public BaseEntityEx : object {
public bool IsValidEntityReference(T obj)
public bool HasEntityInParents(BaseEntity ent, BaseEntity toFind)
}
public BaseEntityRef : ResourceRef`1<BaseEntity> {
public BaseEntity Get()
}
public BaseEventUI : MonoBehaviour {
public RustText TextEventType
public RustText TextOutput
public RustButton ToggleInvert
public Dropdown DropdownInputMemorySlot
public Dropdown DropdownOutputMemorySlot
public RustInput InputFloatValue
public RustInput InputFloatValue2
public AIEventType EventType
public BaseStateUI Output
}
public BaseFirework : BaseCombatEntity {
public float fuseLength
public float activityLength
public Flags Flag_Spent
public float corpseDuration
public bool limitActiveCount
public int maxActiveFireworks
public HashSet`1<BaseFirework> _activeFireworks
public bool IsLit()
public bool IsExhausted()
public int NumActiveFireworks()
public void TryLightFuse()
public void Begin()
public void OnExhausted()
public void Cleanup()
internal void DoServerDestroy()
public void OnAttacked(HitInfo info)
public void Ignite(Vector3 fromPos)
public void StaggeredTryLightFuse()
public bool CanIgnite()
public bool CanPickup(BasePlayer player)
}
public BaseFishingRod : HeldEntity {
public GameObjectRef FishingBobberRef
public float FishCatchDistance
public LineRenderer ReelLineRenderer
public Transform LineRendererWorldStartPos
private CatchState <CurrentState>k__BackingField
private FishState currentFishState
private EntityRef`1<FishingBobber> currentBobber
public float ConditionLossOnSuccess
public float ConditionLossOnFail
public float GlobalStrainSpeedMultiplier
public float MaxCastDistance
public Flags Straining
public ItemModFishable ForceFish
public Flags PullingLeftFlag
public Flags PullingRightFlag
public Flags ReelingInFlag
public GameObjectRef BobberPreview
public SoundDefinition onLineSoundDef
public SoundDefinition strainSoundDef
public AnimationCurve strainGainCurve
public SoundDefinition tensionBreakSoundDef
public UpdateFishingRod updateFishingRodQueue
private TimeUntil nextFishStateChange
private TimeSince fishCatchDuration
private float strainTimer
private float strainMax
private TimeSince lastStrainUpdate
private TimeUntil catchTime
private TimeSince lastSightCheck
private Vector3 playerStartPosition
private WaterBody surfaceBody
private ItemDefinition lureUsed
private ItemDefinition currentFishTarget
private ItemModFishable fishableModifier
private ItemModFishable lastFish
private bool inQueue
public bool ForceSuccess
public bool ForceFail
public bool ImmediateHook
public CatchState CurrentState
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public CatchState get_CurrentState()
private void set_CurrentState(CatchState value)
public void Load(LoadInfo info)
public bool BlocksGestures()
private bool AllowPullInDirection(Vector3 worldDirection, Vector3 bobberPosition)
private bool EvaluateFishingPosition(Vector3& pos, BasePlayer ply, FailReason& reason, WaterBody& waterBody)
private Item GetCurrentLure()
private bool HasReelInInput(InputState state)
private void Server_RequestCast(RPCMessage msg)
private void FailedCast(FailReason reason)
private void CatchProcess()
private void CatchProcessBudgeted()
private void ResetLine()
private void Server_Cancel(RPCMessage msg)
private void Server_Cancel(FailReason reason)
public void OnHeldChanged()
public void Save(SaveInfo info)
private void UpdateFlags(bool inputLeft, bool inputRight, bool back)
}
public BaseFishNPC : BaseNpc {
protected FishBrain brain
public void ServerInit()
internal void DoServerDestroy()
public void TryThink()
public bool CanAttack(BaseEntity entity)
public bool NeedsToReload()
public float EngagementRange()
public bool IsTargetInRange(BaseEntity entity, Single& dist)
public bool CanSeeTarget(BaseEntity entity)
public bool Reload()
public bool StartAttacking(BaseEntity target)
public void StopAttacking()
public float CooldownDuration()
public bool IsOnCooldown()
public bool IsThreat(BaseEntity entity)
public bool IsTarget(BaseEntity entity)
public bool IsFriendly(BaseEntity entity)
public float GetAmmoFraction()
public BaseEntity GetBestTarget()
public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
}
public BaseFootstepEffect : MonoBehaviour {
public LayerMask validImpactLayers
}
public BaseGameMode : BaseEntity {
private GameMode gameModeScores
public String[] scoreColumns
public bool globalChat
public bool localChat
public bool teamSystem
public bool safeZone
public bool ingameMap
public bool compass
public bool contactSystem
public bool crawling
public bool rustPlus
public bool wipeBpsOnProtocol
public int maximumSleepingBags
public bool returnValidCombatlog
public bool missionSystem
public bool mlrs
public Flags Flag_Warmup
public Flags Flag_GameOver
public Flags Flag_WaitingForPlayers
public Phrase[] addedFeatures
public Phrase[] removedFeatures
public Phrase[] changedFeatures
public List`1<string> convars
private Action`1<BaseGameMode> GameModeChanged
public string shortname
public float matchDuration
public float warmupDuration
public float timeBetweenMatches
public int minPlayersToStart
public bool useCustomSpawns
public string victoryScoreName
public string teamScoreName
public int numScoreForVictory
public string gamemodeTitle
public SoundDefinition[] warmupMusics
public SoundDefinition[] lossMusics
public SoundDefinition[] winMusics
private float warmupStartTime
private float matchStartTime
private float matchEndTime
public List`1<string> gameModeTags
public CameraMode deathCameraMode
public bool permanent
public bool limitTeamAuths
public bool allowSleeping
public bool allowWounding
public bool allowBleeding
public bool allowTemperature
public bool quickRespawn
public bool quickDeploy
public float respawnDelayOverride
public float startHealthOverride
public float autoHealDelay
public float autoHealDuration
public float corpseRemovalTimeOverride
public bool hasKillFeed
public bool allowPings
public BaseGameMode svActiveGameMode
public List`1<BaseGameMode> svGameModeManifest
private GameObject[] allspawns
private GameModeSpawnGroup[] gameModeSpawnGroups
public PlayerInventoryProperties[] loadouts
public bool useStaticLoadoutPerPlayer
public bool topUpMagazines
public bool sendKillNotifications
public GameModeTeam[] teams
private bool isResetting
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public GameMode GetGameScores()
public int ScoreColumnIndex(string scoreName)
public void InitScores()
public void CopyGameModeScores(GameMode from, GameMode to)
public PlayerScore GetPlayerScoreForPlayer(BasePlayer player)
public int GetScoreIndexByName(string name)
public bool IsDraw()
public string GetWinnerName()
public int GetPlayerTeamPosition(BasePlayer player)
public int GetPlayerRank(BasePlayer player)
public int GetWinningTeamIndex()
public bool DidPlayerWin(BasePlayer player)
public bool IsTeamGame()
public bool KeepScores()
public void ModifyTeamScore(int teamIndex, int modifyAmount)
public void SetTeamScore(int teamIndex, int score)
public void ResetPlayerScores(BasePlayer player)
public void ModifyPlayerGameScore(BasePlayer player, string scoreName, int modifyAmount)
public void ModifyPlayerGameScore(BasePlayer player, int scoreIndex, int modifyAmount)
public int GetPlayerGameScore(BasePlayer player, int scoreIndex)
public void SetPlayerTeam(BasePlayer player, int newTeam)
public void SetPlayerGameScore(BasePlayer player, int scoreIndex, int scoreValue)
public int GetMaxBeds(BasePlayer player)
protected void SetupTags()
public ResearchCostResult GetScrapCostForResearch(ItemDefinition item, ResearchType researchType)
public Nullable`1<float> EvaluateSleepingBagReset(SleepingBag bag, Vector3 position, SleepingBagResetReason reason)
private void DeleteEntities()
protected void OnCreated_Vanilla()
public void add_GameModeChanged(Action`1<BaseGameMode> value)
public void remove_GameModeChanged(Action`1<BaseGameMode> value)
public bool HasAnyGameModeTag(String[] tags)
public bool HasGameModeTag(string tag)
public bool AllowsSleeping()
public bool HasLoadouts()
public int GetNumTeams()
public int GetTeamScore(int teamIndex)
public void CreateGameMode(string overrideMode)
public void SetActiveGameMode(BaseGameMode newActive, bool serverside)
public BaseGameMode GetActiveGameMode(bool serverside)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public float CorpseRemovalTime(BaseCorpse corpse)
public bool InWarmup()
public bool IsWaitingForPlayers()
public bool IsMatchOver()
public bool IsMatchActive()
public void InitShared()
public void DestroyShared()
protected void OnCreated()
protected void OnMatchBegin()
public void ResetMatch()
public void ResetTeamScores()
public void ShutdownGame()
private void Update()
protected void OnThink(float delta)
public void OnMatchEnd()
public void OnNewPlayer(BasePlayer player)
public void PostPlayerRespawn(BasePlayer player)
public void OnPlayerConnected(BasePlayer player)
public void UnassignAllPlayers()
public void AutoAssignTeam(BasePlayer player)
public void OnPlayerDisconnected(BasePlayer player)
public void OnPlayerWounded(BasePlayer instigator, BasePlayer victim, HitInfo info)
public void OnPlayerRevived(BasePlayer instigator, BasePlayer victim)
public void OnPlayerHurt(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo)
public void OnPlayerDeath(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo)
public bool CanPlayerRespawn(BasePlayer player)
public void OnPlayerRespawn(BasePlayer player)
public void CheckGameConditions(bool force)
public void LoadoutPlayer(BasePlayer player)
public void InstallSpawnpoints()
public SpawnPoint GetPlayerSpawn(BasePlayer forPlayer)
public int GetMaxRelationshipTeamSize()
public SleepingBag[] FindSleepingBagsForPlayer(ulong playerID, bool ignoreTimers)
public bool CanMoveItemsFrom(PlayerInventory inv, BaseEntity source, Item item)
}
public BaseHelicopter : BaseVehicle {
public float engineThrustMax
public Vector3 torqueScale
protected Transform com
public GameObject[] killTriggers
protected GroundEffect[] groundEffects
public GameObjectRef serverGibs
public GameObjectRef explosionEffect
public GameObjectRef fireBall
public GameObjectRef crashEffect
public float liftDotMax
public float altForceDotMin
public float liftFraction
public float thrustLerpSpeed
public Flags Flag_InternalLights
public float currentThrottle
public float avgThrust
public float avgTerrainHeight
private bool <autoHover>k__BackingField
public HelicopterInputState currentInputState
public float lastPlayerInputTime
public float hoverForceScale
public Vector3 damageTorque
public float nextDamageTime
public float nextEffectTime
public float pendingImpactDamage
public bool autoHover
public bool ForceMovementHandling
public bool get_autoHover()
public void set_autoHover(bool value)
public float GetServiceCeiling()
public float MaxVelocity()
public void ServerInit()
internal void DoServerDestroy()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public bool ToggleAutoHover(BasePlayer player)
public void PilotInput(InputState inputState, BasePlayer player)
public void PassengerInput(InputState inputState, BasePlayer player)
public void SetDefaultInputState()
public bool IsEnginePowered()
public void VehicleFixedUpdate()
public void LightToggle(BasePlayer player)
public bool IsEngineOn()
public bool get_ForceMovementHandling()
protected void TryStartEngine(BasePlayer player)
protected void ApplyHandbrake()
public void ClearDamageTorque()
public void SetDamageTorque(Vector3 newTorque)
public void AddDamageTorque(Vector3 torqueToAdd)
public void MovementUpdate()
public void DelayedImpactDamage()
public bool CollisionDamageEnabled()
public void ProcessCollision(Collision collision)
public void OnCollisionEnter(Collision collision)
public void OnKilled(HitInfo info)
public bool IsValidHomingTarget()
internal float <PilotInput>g__MouseToBinary|31_0(float amount)
}
public BaseHuntEvent : BaseEntity {
public GameObjectRef[] HuntablePrefab
protected List`1<string> HuntableResourcePathCached
public AudioSource huntStartSound
public void ServerInit()
}
public BaseLadder : BaseCombatEntity {
public bool ShouldBlockProjectiles()
}
public BaseLauncher : BaseProjectile {
public float initialSpeedMultiplier
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool ForceSendMagazine(SaveInfo saveInfo)
public void ServerUse()
public void ServerUse(float damageModifier, Transform originOverride, bool useBulletThickness)
private void SV_Launch(RPCMessage msg)
public void ProjectileLaunched_Server(ServerProjectile justLaunched)
}
public BaseLiquidVessel : AttackEntity {
public GameObjectRef thrownWaterObject
public GameObjectRef ThrowEffect3P
public SoundDefinition throwSound3P
public GameObjectRef fillFromContainer
public GameObjectRef fillFromWorld
public SoundDefinition fillFromContainerStartSoundDef
public SoundDefinition fillFromContainerSoundDef
public SoundDefinition fillFromWorldStartSoundDef
public SoundDefinition fillFromWorldSoundDef
public bool hasLid
public float throwScale
public bool canDrinkFrom
public bool updateVMWater
public float minThrowFrac
public bool useThrowAnim
public float fillMlPerSec
private float lastFillTime
private float nextFreeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void OnHeldChanged()
public void SetFilling(bool isFilling)
public void OnSetFilling(bool flag)
public void StartFilling()
public void StopFilling()
public void FillCheck()
public void LoseWater(int amount)
public void AddLiquid(ItemDefinition liquidType, int amount)
public int AmountHeld()
public float HeldFraction()
public int MaxHoldable()
public bool CanDrink()
private bool IsWeaponBusy()
private void SetBusyFor(float dur)
private void ClearBusy()
private void DoDrink(RPCMessage msg)
private void ThrowContents(RPCMessage msg)
public void DoThrow(Vector3 pos, Vector3 velocity)
private void SendFilling(RPCMessage msg)
public bool CanFillFromWorld()
public bool CanThrow()
public LiquidContainer GetFacingLiquidContainer()
}
public BaseLock : BaseEntity {
public ItemDefinition itemType
public bool CanRemove
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool GetPlayerLockPermission(BasePlayer player)
public bool OnTryToOpen(BasePlayer player)
public bool OnTryToClose(BasePlayer player)
public bool HasLockPermission(BasePlayer player)
public void RPC_TakeLock(RPCMessage rpc)
public float BoundsPadding()
}
public BaseMagnet : MonoBehaviour {
public BaseEntity entityOwner
public Flags magnetFlag
public TriggerMagnet magnetTrigger
public FixedJoint fixedJoint
public Rigidbody kinematicAttachmentBody
public float magnetForce
public Transform attachDepthPoint
public GameObjectRef attachEffect
public bool isMagnetOn
public GameObject colliderSource
private BasePlayer associatedPlayer
public bool HasConnectedObject()
public OBB GetConnectedOBB(float scale)
public void SetCollisionsEnabled(GameObject other, bool wants)
public void SetMagnetEnabled(bool wantsOn, BasePlayer forPlayer)
public void OnMagnetEnabled()
public void OnMagnetDisabled()
public bool IsMagnetOn()
public void MagnetThink(float delta)
}
public BaseMelee : AttackEntity {
public DamageProperties damageProperties
public List`1<DamageTypeEntry> damageTypes
public List`1<DamageTypeEntry> deployableDamageOverrides
public float maxDistance
public float attackRadius
public bool isAutomatic
public bool blockSprintOnAttack
public bool canUntieCrates
public bool longResourceForgiveness
public GameObjectRef strikeFX
public bool useStandardHitEffects
public float aiStrikeDelay
public GameObjectRef swingEffect
public List`1<MaterialFX> materialStrikeFX
public float heartStress
public GatherProperties gathering
public bool canThrowAsProjectile
public bool canAiHearIt
public bool onlyThrowAsProjectile
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void GetAttackStats(HitInfo info)
public void DoAttackShared(HitInfo info)
public GatherPropertyEntry GetGatherInfoFromIndex(GatherType index)
public bool CanHit(HitTest info)
public float TotalDamage()
public bool IsItemBroken()
public void LoseCondition(float amount)
public float GetConditionLoss()
public void UpdateItemCondition(HitInfo info)
public void PlayerAttack(RPCMessage msg)
public bool CanBeUsedInWater()
public string GetStrikeEffectPath(string materialName)
public void ServerUse()
public void ServerUse_OnHit(HitInfo info)
public void ServerUse_Strike()
public Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
private void CLProject(RPCMessage msg)
}
public BaseMetabolism : object {
public float targetHeartRate
}
public BaseMetabolism`1 : EntityComponent`1<T> {
protected T owner
public MetabolismAttribute calories
public MetabolismAttribute hydration
public MetabolismAttribute heartrate
protected float timeSinceLastMetabolism
public void Reset()
protected void OnDisable()
public void ServerInit(T owner)
public void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
protected void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
protected void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
public void ApplyChange(Type type, float amount, float time)
public bool ShouldDie()
public MetabolismAttribute FindAttribute(Type type)
}
public BaseMetalDetector : HeldEntity {
public DetectState State
public float LongRangeDetectionRange
public float SweetSpotDetectionRange
public SoundDefinition BeepSoundEffect
public float NearestDistanceTick
public float DetectLongRangeTick
public float DetectMinMovementDistance
private List`1<IMetalDetectable> inRangeSources
public IMetalDetectable nearestSource
private float nearestSourceDistanceSqr
private Vector3 lastDetectPlayerPos
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnHeldChanged()
private void StartDetecting()
private void StopDetecting()
private void SendNearestDistance()
private float GetDistanceToCenterOrNearestSubSource(IMetalDetectable source)
private void ProcessDetectedSources()
private void DetectLongRange()
private void DetectSources(BasePlayer player)
private void ClearSources()
private void RPC_RequestFlag(RPCMessage rpc)
public void SV_SetSweetspotScanning(RPCMessage msg)
public Vector3 GetDetectionPoint()
public float GetSweetSpotDistancePercent(float distance, float sourceSpawnRadius)
}
public BaseMission : BaseScriptableObject {
public bool missionsenabled
public string shortname
public Phrase missionName
public Phrase missionDesc
public bool canBeAbandoned
public bool completeSilently
public bool blockMissionStat
public TutorialMissionHelpSet showHelpInfo
public MissionObjectiveEntry[] objectives
public List`1<Vector3> blockedPoints
public string MISSION_COMPLETE_STAT
public GameObjectRef acceptEffect
public GameObjectRef failedEffect
public GameObjectRef victoryEffect
public TutorialItemAllowance AllowedTutorialItems
public BaseMission followupMission
public int repeatDelaySecondsSuccess
public int repeatDelaySecondsFailed
public float timeLimitSeconds
public Sprite icon
public Sprite providerIcon
public bool hideStagesNotStarted
public MissionDependancy[] acceptDependancies
public MissionEntityEntry[] missionEntities
public PositionGenerator[] positionGenerators
public ItemAmount[] baseRewards
public UInt32 id
public bool isRepeatable
public UInt32 get_id()
public void PlayerDisconnected(BasePlayer player)
public void PlayerKilled(BasePlayer player)
public bool get_isRepeatable()
public Sprite GetIcon(MissionInstance instance)
public void AddBlocker(Vector3 point)
public void RemoveBlockers(MissionInstance instance)
public void DoMissionEffect(string effectString, BasePlayer assignee)
public void MissionStart(MissionInstance instance, BasePlayer assignee)
public void CheckObjectives(MissionInstance instance, BasePlayer assignee)
public void Think(MissionInstance instance, BasePlayer assignee, float delta)
public void MissionComplete(MissionInstance instance, BasePlayer assignee)
public void MissionSuccess(MissionInstance instance, BasePlayer assignee)
public void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)
public void MissionEnded(MissionInstance instance, BasePlayer assignee)
public void OnObjectiveCompleted(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
public void OnObjectiveFailed(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
public bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
public bool IsEligableForMission(BasePlayer player, IMissionProvider provider)
internal void <MissionComplete>g__GiveReward|47_0(BasePlayer player, ItemAmount reward)
}
public BaseModifiers`1 : EntityComponent`1<T> {
public List`1<Modifier> All
protected Dictionary`2<ModifierType, float> totalValues
protected Dictionary`2<ModifierType, float> modifierVariables
protected T owner
protected bool dirty
protected float timeSinceLastTick
protected float lastTickTime
public int ActiveModifierCoount
public int get_ActiveModifierCoount()
public void Add(List`1<ModifierDefintion> modDefs)
protected void Add(ModifierDefintion def)
protected void Add(Modifier modifier)
private bool CanAdd(Modifier modifier)
private int GetMaxModifiersForSourceType(ModifierSource source)
private int GetTypeSourceCount(ModifierType type, ModifierSource source)
private Modifier GetShortestLifeModifier(ModifierType type, ModifierSource source)
private void Remove(Modifier modifier)
public void RemoveAll()
public float GetValue(ModifierType type, float defaultValue)
public float GetVariableValue(ModifierType type, float defaultValue)
public void SetVariableValue(ModifierType type, float value)
public void RemoveVariable(ModifierType type)
protected void OnDisable()
protected void SetDirty(bool flag)
public void ServerInit(T owner)
public void ResetTicking()
public void ServerUpdate(BaseCombatEntity ownerEntity)
protected void TickModifiers(BaseCombatEntity ownerEntity, float delta)
}
public BaseModularVehicle : GroundVehicle {
public List`1<ModularVehicleSocket> moduleSockets
public Transform centreOfMassTransform
public Transform waterSample
public LODGroup lodGroup
public GameObjectRef keyEnterDialog
private List`1<BaseVehicleModule> <AttachedModuleEntities>k__BackingField
private float _mass
private float <TotalMass>k__BackingField
private bool <HasInited>k__BackingField
public Flags FLAG_KINEMATIC
public Dictionary`2<BaseVehicleModule, Action> moduleAddActions
public bool inEditableLocation
public bool prevEditable
public bool immuneToDecay
private ModularVehicleInventory <Inventory>k__BackingField
public Vector3 realLocalCOM
public Item AssociatedItemInstance
private bool disablePhysics
public Vector3 CentreOfMass
public int NumAttachedModules
public bool HasAnyModules
public List`1<BaseVehicleModule> AttachedModuleEntities
public int TotalSockets
public int NumFreeSockets
private float Mass
public float TotalMass
public bool IsKinematic
public bool IsLockable
public bool HasInited
public ItemDefinition AssociatedItemDef
public bool IsEditableNow
public ModularVehicleInventory Inventory
public Vector3 get_CentreOfMass()
public int get_NumAttachedModules()
public bool get_HasAnyModules()
public List`1<BaseVehicleModule> get_AttachedModuleEntities()
public int get_TotalSockets()
public int get_NumFreeSockets()
private float get_Mass()
public float get_TotalMass()
public void set_TotalMass(float value)
public bool get_IsKinematic()
public bool get_IsLockable()
public bool get_HasInited()
private void set_HasInited(bool value)
public ItemDefinition get_AssociatedItemDef()
public bool get_IsEditableNow()
public void InitShared()
public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
public bool TryDeduceSocketIndex(BaseVehicleModule addedModule, Int32& index)
public void AddMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
public void RemoveMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
public bool TryGetModuleAt(int socketIndex, BaseVehicleModule& result)
public ModularVehicleSocket GetSocket(int index)
public void Load(LoadInfo info)
public bool CanPushNow(BasePlayer pusher)
public void OnChildAdded(BaseEntity childEntity)
public void OnChildRemoved(BaseEntity childEntity)
public void ModuleEntityAdded(BaseVehicleModule addedModule)
public void ModuleEntityRemoved(BaseVehicleModule removedModule)
public void RefreshModulesExcept(BaseVehicleModule ignoredModule)
public ModularVehicleInventory get_Inventory()
public void set_Inventory(ModularVehicleInventory value)
public void ServerInit()
public void PreServerLoad()
public void PostServerLoad()
public void DoServerDestroy()
public float MaxVelocity()
public bool IsComplete()
public bool CouldBeEdited()
public void DisablePhysics()
public void EnablePhysics()
public void VehicleFixedUpdate()
public bool MountEligable(BasePlayer player)
public void Save(SaveInfo info)
public bool CanMoveFrom(BasePlayer player, Item item)
protected Vector3 GetCOMMultiplier()
public void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info)
public void ModuleReachedZeroHealth()
public bool TryAddModule(Item moduleItem, int socketIndex)
public bool TryAddModule(Item moduleItem)
public bool ModuleCanBeAdded(Item moduleItem, int socketIndex, String& failureReason)
public BaseVehicleModule CreatePhysicalModuleEntity(Item moduleItem, ItemModVehicleModule itemModModule, int socketIndex)
public void SetUpModule(BaseVehicleModule moduleEntity, Item moduleItem)
public Item GetVehicleItem(ItemId itemUID)
public BaseVehicleModule GetModuleForItem(Item item)
public void SetMass(float mass)
public void SetCOM(Vector3 com)
}
public BaseMonoBehaviour : FacepunchBehaviour {
public bool IsDebugging()
public string GetLogColor()
public void LogEntry(LogEntryType log, int level, string str, object arg1)
public void LogEntry(LogEntryType log, int level, string str, object arg1, object arg2)
public void LogEntry(LogEntryType log, int level, string str)
}
public BaseMountable : BaseCombatEntity {
public Phrase dismountPhrase
public Transform eyePositionOverride
public Transform eyeCenterOverride
public Vector2 pitchClamp
public Vector2 yawClamp
public bool canWieldItems
public bool relativeViewAngles
public bool AllowForceMountWhenRestrained
public Transform mountAnchor
public float mountLOSVertOffset
public MountPoses mountPose
public float maxMountDistance
public Transform[] dismountPositions
public bool checkPlayerLosOnMount
public bool disableMeshCullingForPlayers
public bool allowHeadLook
public bool ignoreVehicleParent
public bool legacyDismount
public ItemModWearable wearWhileMounted
public bool modifiesPlayerCollider
public CapsuleColliderInfo customPlayerCollider
public float clippingCheckRadius
public bool clippingAndVisChecks
public ClippingCheckLocation clippingChecksLocation
public SoundDefinition mountSoundDef
public SoundDefinition swapSoundDef
public SoundDefinition dismountSoundDef
public DismountConvarType dismountHoldType
public MountStatType mountTimeStatType
public MountGestureType allowedGestures
public bool canDrinkWhileMounted
public bool allowSleeperMounting
public bool animateClothInLocalSpace
public CameraMode MountedCameraMode
public Rigidbody rigidBody
public bool isMobile
public float SideLeanAmount
public float playerHeight
public float playerRadius
public BasePlayer _mounted
public ListHashSet`1<BaseMountable> FixedUpdateMountables
public float MOUNTABLE_TICK_RATE
protected float PositionTickRate
public bool IsSummerDlcVehicle
protected bool BypassClothingMountBlocks
public bool BlocksDoors
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanHoldItems()
public CameraMode GetMountedCameraMode()
public bool DirectlyMountable()
public Transform GetEyeOverride()
public bool ModifiesThirdPersonCamera()
public Vector2 GetPitchClamp()
public Vector2 GetYawClamp()
public bool AnyMounted()
public bool IsMounted()
public Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot)
public Vector3 EyeCenterForPlayer(BasePlayer player, Quaternion lookRot)
public float WaterFactorForPlayer(BasePlayer player)
public float MaxVelocity()
public bool PlayerIsMounted(BasePlayer player)
public BaseVehicle VehicleParent()
public bool HasValidDismountPosition(BasePlayer player)
public bool ValidDismountPosition(BasePlayer player, Vector3 disPos)
public BasePlayer GetMounted()
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void LightToggle(BasePlayer player)
public void OnWeaponFired(BaseProjectile weapon)
public bool CanSwapToThis(BasePlayer player)
protected float get_PositionTickRate()
public bool CanPickup(BasePlayer player)
public void OnKilled(HitInfo info)
public void RPC_WantsMount(RPCMessage msg)
public void WantsMount(BasePlayer player)
public void AttemptMount(BasePlayer player, bool doMountChecks)
public bool AttemptDismount(BasePlayer player)
public void RPC_WantsDismount(RPCMessage msg)
public void MountPlayer(BasePlayer player)
public void OnPlayerMounted()
public void OnPlayerDismounted(BasePlayer player)
public void UpdateMountFlags()
public void DismountAllPlayers()
public void DismountPlayer(BasePlayer player, bool lite)
public bool GetDismountPosition(BasePlayer player, Vector3& res)
public void ServerInit()
internal void DoServerDestroy()
public void FixedUpdateCycle()
public void VehicleFixedUpdate()
public void PostVehicleFixedUpdate()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public float GetComfort()
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public bool TryFireProjectile(StorageContainer ammoStorage, AmmoTypes ammoType, Vector3 firingPos, Vector3 firingDir, BasePlayer shooter, float launchOffset, float minSpeed, ServerProjectile& projectile)
public void DisableTransferProtection()
protected int GetClipCheckMask()
public bool IsSeatClipping(BaseMountable mountable)
public Vector3 GetMountRagdollVelocity(BasePlayer player)
protected bool IsSeatClipping(BaseMountable mountable, Vector3 startPos, float radius, int mask, Vector3 seatPos, Vector3 direction)
public bool get_IsSummerDlcVehicle()
public bool IsInstrument()
public Vector3 GetDismountCheckStart(BasePlayer player)
public Vector3 GetMountedPosition()
public float GetSpeed()
public bool CanPlayerSeeMountPoint(Ray ray, BasePlayer player, float maxDistance)
public bool NearMountPoint(BasePlayer player)
protected bool ClothingBlocksMounting(BasePlayer player)
protected bool get_BypassClothingMountBlocks()
public Vector3 ConvertVector(Vector3 vec)
public bool get_BlocksDoors()
}
public BaseMovement : MonoBehaviour {
public bool adminCheat
public float adminSpeed
}
public BaseNavigator : BaseMonoBehaviour {
public float maxStepUpDistance
public int baseNavMovementFrameInterval
public float stuckTriggerDuration
public float navTypeHeightOffset
public float navTypeDistance
public bool CanNavigateMounted
public bool CanUseNavMesh
public bool CanUseAStar
public bool CanUseBaseNav
public bool CanUseCustomNav
public float StoppingDistance
public string DefaultArea
public bool CanPathFindToChaseTargetIfNoMovePoint
public int PathFindChaseLOSAttemptCount
public float PathFindChaseLOSDistanceMultiplier
public bool TriggerStuckEvent
public float StuckDistance
public float Speed
public float Acceleration
public float TurnSpeed
public NavigationSpeed MoveTowardsSpeed
public bool FaceMoveTowardsTarget
public float SlowestSpeedFraction
public float SlowSpeedFraction
public float NormalSpeedFraction
public float FastSpeedFraction
public float LowHealthSpeedReductionTriggerFraction
public float LowHealthMaxSpeedFraction
public float SwimmingSpeedMultiplier
public float BestMovementPointMaxDistance
public float BestCoverPointMaxDistance
public float BestRoamPointMaxDistance
public float MaxRoamDistanceFromHome
public float FaceTargetChaseDistance
public bool CanUseRandomMovePointIfNonFound
public float MaxWaterDepth
public bool SpeedBasedAvoidancePriority
private NavMeshPath path
private NavMeshQueryFilter navMeshQueryFilter
private AIMovePointPath <Path>k__BackingField
private BasePath <AStarGraph>k__BackingField
private int defaultAreaMask
public Enum biomePreference
public bool UseBiomePreference
public Enum topologyPreference
public Enum topologyPrevent
public Enum biomeRequirement
private NavMeshAgent <Agent>k__BackingField
private BaseCombatEntity <BaseEntity>k__BackingField
private Vector3 <Destination>k__BackingField
private NavigationType <CurrentNavigationType>k__BackingField
private NavigationType <LastUsedNavigationType>k__BackingField
public float stuckTimer
public Vector3 stuckCheckPosition
private bool <StuckOffNavmesh>k__BackingField
protected bool traversingNavMeshLink
protected string currentNavMeshLinkName
protected Vector3 currentNavMeshLinkEndPos
protected Stack`1<IAIPathNode> currentAStarPath
protected IAIPathNode targetNode
protected float currentSpeedFraction
private float lastSetDestinationTime
protected OverrideFacingDirectionMode overrideFacingDirectionMode
protected BaseEntity facingDirectionEntity
protected bool overrideFacingDirection
protected Vector3 facingDirectionOverride
protected bool paused
private int frameCount
private float accumDelta
public AIMovePointPath Path
public BasePath AStarGraph
public NavMeshAgent Agent
public BaseCombatEntity BaseEntity
public Vector3 Destination
public bool IsOnNavMeshLink
public bool Moving
public NavigationType CurrentNavigationType
public NavigationType LastUsedNavigationType
public bool StuckOffNavmesh
public bool HasPath
public bool IsOverridingFacingDirection
public Vector3 FacingDirectionOverride
public AIMovePointPath get_Path()
public void set_Path(AIMovePointPath value)
public BasePath get_AStarGraph()
public void set_AStarGraph(BasePath value)
public int TopologyPreference()
public int TopologyPrevent()
public int BiomeRequirement()
public NavMeshAgent get_Agent()
private void set_Agent(NavMeshAgent value)
public BaseCombatEntity get_BaseEntity()
private void set_BaseEntity(BaseCombatEntity value)
public Vector3 get_Destination()
public void set_Destination(Vector3 value)
public bool get_IsOnNavMeshLink()
public bool get_Moving()
public NavigationType get_CurrentNavigationType()
private void set_CurrentNavigationType(NavigationType value)
public NavigationType get_LastUsedNavigationType()
private void set_LastUsedNavigationType(NavigationType value)
public bool get_StuckOffNavmesh()
private void set_StuckOffNavmesh(bool value)
public bool get_HasPath()
public void Init(BaseCombatEntity entity, NavMeshAgent agent)
public void SetNavMeshEnabled(bool flag)
protected bool CanEnableNavMeshNavigation()
protected bool CanUpdateMovement()
public void ForceToGround()
private void DelayedForceToGround()
public bool PlaceOnNavMesh(float yOffset)
public void OnPlacedOnNavmesh()
public void OnFailedToPlaceOnNavmesh()
public bool Warp(Vector3 position)
public bool GetNearestNavmeshPosition(Vector3 target, Vector3& position, float maxRange)
public bool SetBaseDestination(Vector3 pos, float speedFraction)
public bool SetDestination(BasePath path, IAIPathNode newTargetNode, float speedFraction)
public bool SetDestination(Vector3 pos, NavigationSpeed speed, float updateInterval, float navmeshSampleDistance)
public bool SetCustomDestination(Vector3 pos, float speedFraction, float updateInterval)
public bool SetDestination(Vector3 pos, float speedFraction, float updateInterval, float navmeshSampleDistance)
private NavigationType DetermineNavigationType(Vector3 location, Vector3& navMeshPos)
public void SetCurrentSpeed(NavigationSpeed speed)
public bool UpdateIntervalElapsed(float updateInterval)
public float GetSpeedFraction(NavigationSpeed speed)
public void SetCurrentNavigationType(NavigationType navType)
public void Pause()
public void Resume()
public void Stop()
private void StopNavMesh()
private void StopAStar()
protected void StopCustom()
public void Think(float delta)
public void UpdateNavigation(float delta)
private void UpdateMovement(float delta)
public void OnStuck()
public bool IsSwimming()
private Vector3 GetNextPathPosition()
private bool ValidateNextPosition(Vector3& moveToPosition)
private void UpdateSpeed(float delta, bool swimming)
protected float GetTargetSpeed()
protected void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
public void ApplyFacingDirectionOverride()
public void SetFacingDirectionEntity(BaseEntity entity)
public void SetFacingDirectionOverride(Vector3 direction)
public void ClearFacingDirectionOverride()
public bool get_IsOverridingFacingDirection()
public Vector3 get_FacingDirectionOverride()
protected bool ReachedPosition(Vector3 position)
private void HandleNavMeshLinkTraversal(float delta, Vector3& moveToPosition)
private bool HandleNavMeshLinkTraversalStart(float delta)
private void HandleNavMeshLinkTraversalTick(float delta, Vector3& moveToPosition)
private bool IsNavMeshLinkTraversalComplete(float delta, Vector3& moveToPosition)
private void CompleteNavMeshLink()
public bool IsPositionATopologyPreference(Vector3 position)
public bool IsPositionPreventTopology(Vector3 position)
public bool IsPositionABiomePreference(Vector3 position)
public bool IsPositionABiomeRequirement(Vector3 position)
public bool IsAcceptableWaterDepth(Vector3 pos)
public void SetBrakingEnabled(bool flag)
public int GetNavMeshAgentID(string name)
}
public BaseNetworkable : BaseMonoBehaviour {
public UInt32 prefabID
public bool globalBroadcast
public bool globalBuildingBlock
public Networkable net
private bool <IsDestroyed>k__BackingField
private string _prefabName
private string _prefabNameWithoutExtension
public EntityRealm serverEntities
private bool isServersideEntity
public List`1<Connection> connectionsInSphereList
public List`1<Component> postNetworkUpdateComponents
public bool _limitedNetworking
public EntityRef parentEntity
public List`1<BaseEntity> children
public bool canTriggerParent
public int creationFrame
public bool isSpawned
public MemoryStream _NetworkCache
public Queue`1<MemoryStream> EntityMemoryStreamPool
private MemoryStream _SaveCache
public bool IsDestroyed
public string PrefabName
public string ShortPrefabName
public bool isServer
public bool isClient
public bool limitNetworking
public GameManager gameManager
public Library prefabAttribute
public Group GlobalNetworkGroup
public Group LimboNetworkGroup
public bool get_IsDestroyed()
private void set_IsDestroyed(bool value)
public string get_PrefabName()
public string get_ShortPrefabName()
public Vector3 GetNetworkPosition()
public Quaternion GetNetworkRotation()
public string InvokeString()
public BaseEntity LookupPrefab()
public bool EqualNetID(BaseNetworkable other)
public bool EqualNetID(NetworkableId otherID)
public void ResetState()
public void InitShared()
public void PreInitShared()
public void PostInitShared()
public void DestroyShared()
public void OnNetworkGroupEnter(Group group)
public void OnNetworkGroupLeave(Group group)
public void OnNetworkGroupChange()
public void OnNetworkSubscribersEnter(List`1<Connection> connections)
public void OnNetworkSubscribersLeave(List`1<Connection> connections)
private void EntityDestroy()
private void DoEntityDestroy()
private void SpawnShared()
public void Save(SaveInfo info)
public void PostSave(SaveInfo info)
public void InitLoad(NetworkableId entityID)
public void PreServerLoad()
public void Load(LoadInfo info)
public void PostServerLoad()
public bool get_isServer()
public bool get_isClient()
public T ToServer()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public List`1<Connection> GetConnectionsWithin(Vector3 position, float distance)
public void GetCloseConnections(Vector3 position, float distance, List`1<Connection> foundConnections)
public void GetCloseConnections(Vector3 position, float distance, List`1<BasePlayer> players)
public bool HasCloseConnections(Vector3 position, float distance)
public bool HasConnections(Vector3 position)
public void BroadcastOnPostNetworkUpdate(BaseEntity entity)
public void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool get_limitNetworking()
public void set_limitNetworking(bool value)
private void OnNetworkLimitStart()
private void OnNetworkLimitEnd()
public BaseEntity GetParentEntity()
public bool HasParent()
public void AddChild(BaseEntity child)
protected void OnChildAdded(BaseEntity child)
public void RemoveChild(BaseEntity child)
protected void OnChildRemoved(BaseEntity child)
public GameManager get_gameManager()
public Library get_prefabAttribute()
public Group get_GlobalNetworkGroup()
public Group get_LimboNetworkGroup()
public float GetNetworkTime()
public void Spawn()
private void SendGlobalNetworkUpdate()
public bool IsFullySpawned()
public void ServerInit()
public void ServerInitPostNetworkGroupAssign()
public List`1<Connection> GetSubscribers()
public void KillMessage()
public void AdminKill()
public void Kill(DestroyMode mode)
public void KillAsMapEntity()
public void TerminateOnClient(DestroyMode mode)
private void TerminateOnServer()
internal void DoServerDestroy()
public bool ShouldNetworkTo(BasePlayer player)
public void SendNetworkGroupChange()
public void SendAsSnapshot(Connection connection, bool justCreated)
public void SendNetworkUpdate(NetworkQueue queue)
public void SendNetworkUpdateImmediate(bool justCreated)
public void SendNetworkUpdate_Position()
public void ToStream(Stream stream, SaveInfo saveInfo)
public bool CanUseNetworkCache(Connection connection)
public void ToStreamForNetwork(Stream stream, SaveInfo saveInfo)
public void InvalidateNetworkCache()
public MemoryStream GetSaveCache()
public void UpdateNetworkGroup()
private bool <OnNetworkLimitStart>b__65_0(Connection x)
}
public BaseNetworkableEx : object {
public bool IsValid(BaseNetworkable ent)
public bool IsRealNull(BaseNetworkable ent)
}
public BaseNpc : BaseCombatEntity {
public int agentTypeIndex
public bool NewAI
public bool LegacyNavigation
public bool canSwim
private bool <IsStuck>k__BackingField
private Vector3 stepDirection
private bool <AgencyUpdateRequired>k__BackingField
private bool <IsOnOffmeshLinkAndReachedNewCoord>k__BackingField
private float maxFleeTime
private float fleeHealthThresholdPercentage
private float blockEnemyTargetingTimeout
private float blockFoodTargetingTimeout
private float aggroTimeout
private float lastAggroChanceResult
private float lastAggroChanceCalcTime
private float aggroChanceRecalcTimeout
private float eatTimeout
private float wakeUpBlockMoveTimeout
private BaseEntity blockTargetingThisEnemy
public float waterDepth
public bool swimming
public bool wasSwimming
private AnimationCurve speedFractionResponse
private bool _traversingNavMeshLink
private OffMeshLinkData _currentNavMeshLink
private string _currentNavMeshLinkName
private float _currentNavMeshLinkTraversalTime
private float _currentNavMeshLinkTraversalTimeDelta
private Quaternion _currentNavMeshLinkOrientation
private Vector3 _currentNavMeshLinkEndPos
public float nextAttackTime
public Enum topologyPreference
public Transform ChaseTransform
public GameObjectRef CorpsePrefab
public AiStatistics Stats
public Vector3 AttackOffset
public float AttackDamage
public DamageType AttackDamageType
public float MinimumTargetHealthFraction
public float AttackCost
public float AttackRate
public float AttackRange
public NavMeshAgent NavAgent
public LayerMask movementMask
public float stuckDuration
public float lastStuckTime
public float idleDuration
private bool _isDormant
private float lastSetDestinationTime
private BaseEntity <AttackTarget>k__BackingField
private SeenInfo <AttackTargetMemory>k__BackingField
private BaseEntity <FoodTarget>k__BackingField
private Vector3 <SpawnPosition>k__BackingField
public StateTimer BusyTimer
public float Sleep
public VitalLevel Stamina
public VitalLevel Energy
public VitalLevel Hydration
private Behaviour <CurrentBehaviour>k__BackingField
public AiFlags aiFlags
public Byte[] CurrentFacts
public int ForgetUnseenEntityTime
public float SensesTickRate
public BaseEntity[] SensesResults
private float lastTickTime
public float playerTargetDecisionStartTime
private float animalTargetDecisionStartTime
private bool isAlreadyCheckingPathPending
private int numPathPendingAttempts
private float accumPathPendingDelay
public float TickRate
private Vector3 lastStuckPos
private float nextFlinchTime
private float <TargetSpeed>k__BackingField
public int AgentTypeIndex
public bool IsStuck
public bool AgencyUpdateRequired
public bool IsOnOffmeshLinkAndReachedNewCoord
public float GetAttackRate
public bool IsNpc
public bool IsDormant
public float SecondsSinceLastSetDestination
public float LastSetDestinationTime
public Vector3 Destination
public bool IsStopped
public bool AutoBraking
public bool HasPath
public BaseEntity AttackTarget
public SeenInfo AttackTargetMemory
public BaseEntity FoodTarget
public BaseCombatEntity CombatTarget
public Vector3 SpawnPosition
public float AttackTargetVisibleFor
public float TimeAtDestination
public BaseCombatEntity Entity
public NavMeshAgent GetNavAgent
public AiStatistics GetStats
public float GetAttackRange
public Vector3 GetAttackOffset
public float GetStamina
public float GetEnergy
public float GetAttackCost
public float GetSleep
public Vector3 CurrentAimAngles
public float GetStuckDuration
public float GetLastStuckTime
public Vector3 AttackPosition
public Vector3 CrouchedAttackPosition
public float currentBehaviorDuration
public Behaviour CurrentBehaviour
public bool IsSitting
public bool IsChasing
public bool IsSleeping
public float TargetSpeed
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int get_AgentTypeIndex()
public void set_AgentTypeIndex(int value)
public bool get_IsStuck()
public void set_IsStuck(bool value)
public bool get_AgencyUpdateRequired()
public void set_AgencyUpdateRequired(bool value)
public bool get_IsOnOffmeshLinkAndReachedNewCoord()
public void set_IsOnOffmeshLinkAndReachedNewCoord(bool value)
public string DebugText()
public void TickAi()
private void TickSpeed()
protected void TickMetabolism()
public bool WantsToEat(BaseEntity best)
public float FearLevel(BaseEntity ent)
public float HateLevel(BaseEntity ent)
protected void TickSleep()
public void TickNavigationWater()
public void TickNavigation()
private void TickChase()
private void HandleNavMeshLinkTraversal(float delta, Vector3& moveToPosition)
private bool HandleNavMeshLinkTraversalStart(float delta)
private void HandleNavMeshLinkTraversalTick(float delta, Vector3& moveToPosition)
private bool IsNavMeshLinkTraversalComplete(float delta, Vector3& moveToPosition)
private void CompleteNavMeshLink()
private void TickFollowPath(Vector3& moveToPosition)
private bool ValidateNextPosition(Vector3& moveToPosition)
private void UpdatePositionAndRotation(Vector3 moveToPosition)
private void TickIdle()
public void TickStuck()
public void OnBecomeStuck()
public void OnBecomeUnStuck()
public void UpdateAiRotation()
public float get_GetAttackRate()
public bool AttackReady()
public void StartAttack()
public void Attack(BaseCombatEntity target)
public void Eat()
public void AddCalories(float amount)
public void Startled()
private bool IsAfraid()
protected bool IsAfraidOf(FamilyEnum family)
private bool CheckHealthThresholdToFlee()
private void TickBehaviourState()
private void WantsToFlee()
private void TickFlee()
public bool BlockEnemyTargeting(float timeout)
private void TickBlockEnemyTargeting()
public bool BlockFoodTargeting(float timeout)
private void TickBlockFoodTargeting()
public bool TryAggro(EnemyRangeEnum range)
public bool StartAggro(float timeout)
private void TickAggro()
public bool StartEating(float timeout)
private void TickEating()
public bool WakeUpBlockMove(float timeout)
private void TickWakeUpBlockMove()
private void OnFactChanged(Facts fact, byte oldValue, byte newValue)
public int TopologyPreference()
public void UpdateDestination(Vector3 position)
public void UpdateDestination(Transform tx)
public void StopMoving()
public void ApplyInheritedVelocity(Vector3 velocity)
public Vector3 GetNewNavPosWithVelocity(BaseEntity ent, Vector3 velocity)
public bool get_IsNpc()
public bool get_IsDormant()
public void set_IsDormant(bool value)
public float get_SecondsSinceLastSetDestination()
public float get_LastSetDestinationTime()
public Vector3 get_Destination()
public void set_Destination(Vector3 value)
public bool get_IsStopped()
public void set_IsStopped(bool value)
public bool get_AutoBraking()
public void set_AutoBraking(bool value)
public bool get_HasPath()
public bool IsNavRunning()
public void Pause()
public void Resume()
private IEnumerator TryForceToNavmesh()
public BaseEntity get_AttackTarget()
public void set_AttackTarget(BaseEntity value)
public SeenInfo get_AttackTargetMemory()
public void set_AttackTargetMemory(SeenInfo value)
public BaseEntity get_FoodTarget()
public void set_FoodTarget(BaseEntity value)
public BaseCombatEntity get_CombatTarget()
public Vector3 get_SpawnPosition()
public void set_SpawnPosition(Vector3 value)
public float get_AttackTargetVisibleFor()
public float get_TimeAtDestination()
public BaseCombatEntity get_Entity()
public NavMeshAgent get_GetNavAgent()
public float GetWantsToAttack(BaseEntity target)
public AiStatistics get_GetStats()
public float get_GetAttackRange()
public Vector3 get_GetAttackOffset()
public float get_GetStamina()
public float get_GetEnergy()
public float get_GetAttackCost()
public float get_GetSleep()
public Vector3 get_CurrentAimAngles()
public float get_GetStuckDuration()
public float get_GetLastStuckTime()
public bool BusyTimerActive()
public void SetBusyFor(float dur)
public Vector3 get_AttackPosition()
public Vector3 get_CrouchedAttackPosition()
internal float WantsToAttack(BaseEntity target)
public float get_currentBehaviorDuration()
public Behaviour get_CurrentBehaviour()
public void set_CurrentBehaviour(Behaviour value)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float MaxVelocity()
public bool HasAiFlag(AiFlags f)
public void SetAiFlag(AiFlags f, bool set)
public bool get_IsSitting()
public void set_IsSitting(bool value)
public bool get_IsChasing()
public void set_IsChasing(bool value)
public bool get_IsSleeping()
public void set_IsSleeping(bool value)
public void InitFacts()
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public EnemyRangeEnum ToEnemyRangeEnum(float range)
public float GetActiveAggressionRangeSqr()
public FoodRangeEnum ToFoodRangeEnum(float range)
public AfraidRangeEnum ToAfraidRangeEnum(float range)
public HealthEnum ToHealthEnum(float healthNormalized)
public byte ToIsTired(float energyNormalized)
public SpeedEnum ToSpeedEnum(float speed)
public float ToSpeed(SpeedEnum speed)
public byte GetPathStatus()
public NavMeshPathStatus ToPathStatus(byte value)
private void TickSenses()
private void TickHearing()
private void TickSmell()
private float DecisionMomentumPlayerTarget()
private float DecisionMomentumAnimalTarget()
private void TickFoodAwareness()
private void SelectFood()
private void SelectClosestFood()
private void UpdateSelfFacts()
private byte IsMoving()
private bool AiCaresAbout(BaseEntity ent)
private bool WithinVisionCone(BaseNpc npc, BaseEntity other)
public void SetTargetPathStatus(float pendingDelay)
private void DelayedTargetPathStatus()
public void ServerInit()
internal void DoServerDestroy()
public void Hurt(HitInfo info)
public void OnKilled(HitInfo hitInfo)
public float get_TargetSpeed()
public void set_TargetSpeed(float value)
}
public BaseOven : StorageContainer {
private Dictionary`2<float, HashSet`1<ItemDefinition>> _materialOutputCache
public TemperatureType temperature
public Option switchOnMenu
public Option switchOffMenu
public ItemAmount[] startupContents
public bool allowByproductCreation
public ItemDefinition fuelType
public bool canModFire
public bool disabledBySplash
public int smeltSpeed
public int fuelSlots
public int inputSlots
public int outputSlots
public IndustrialSlotMode IndustrialMode
public Flags Flag_CookingPaused
public int _activeCookingSlot
public int _inputSlotIndex
public int _outputSlotIndex
public float UpdateRate
public bool CanRunWithNoFuel
public ItemContainer Container
public BaseEntity IndustrialEntity
public float cookingTemperature
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void PreInitShared()
public void ServerInit()
public void PostServerLoad()
public void Save(SaveInfo info)
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool bAdded)
public bool ItemFilter(Item item, int targetSlot)
public Nullable`1<MinMax> GetAllowedSlots(Item item)
public MinMax GetOutputSlotRange()
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public void OvenFull()
public int GetFuelRate()
public int GetCharcoalRate()
public bool get_CanRunWithNoFuel()
public void Cook()
protected void OnCooked()
public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
protected void SVSwitch(RPCMessage msg)
public float GetTemperature(int slot)
public void UpdateAttachmentTemperature()
public void StartCooking()
public void StopCooking()
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public Item FindBurnable()
public void IncreaseCookTime(float amount)
public ItemContainer get_Container()
public Vector2i InputSlotRange(int slotIndex)
public Vector2i OutputSlotRange(int slotIndex)
public void OnStorageItemTransferBegin()
public void OnStorageItemTransferEnd()
public BaseEntity get_IndustrialEntity()
public float GetSmeltingSpeed()
public float get_cookingTemperature()
public bool IsBurnableItem(Item item)
public bool IsBurnableByproduct(Item item)
public bool IsMaterialInput(Item item)
public bool IsMaterialOutput(Item item)
public bool IsOutputItem(Item item)
private void BuildMaterialOutputCache()
public bool HasSlot(Slot slot)
public bool SupportsChildDeployables()
public bool CanPickup(BasePlayer player)
protected bool CanPickupOven()
}
public BasePath : MonoBehaviour {
public List`1<BasePathNode> nodes
public List`1<PathInterestNode> interestZones
public List`1<PathSpeedZone> speedZones
private Nullable`1<float> cachedLength
public IEnumerable`1<IAIPathInterestNode> InterestNodes
public IEnumerable`1<IAIPathSpeedZone> SpeedZones
public IEnumerable`1<IAIPathInterestNode> get_InterestNodes()
public IEnumerable`1<IAIPathSpeedZone> get_SpeedZones()
private void AddChildren()
private void ClearChildren()
public void AutoGenerateLinks(BasePath path, float maxRange)
public void GetNodesNear(Vector3 point, List`1& nearNodes, float dist)
public IAIPathNode GetClosestToPoint(Vector3 point)
public IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist)
public void AddInterestNode(IAIPathInterestNode interestZone)
public void AddSpeedZone(IAIPathSpeedZone speedZone)
public float GetPathLength()
public float GetPathProgress(Vector3 position)
public void GetPointInPath(float normalisedTime, Vector3& pos, Vector3& rotation)
}
public BasePathFinder : object {
private Vector3[] preferedTopologySamples
private Vector3[] topologySamples
private Vector3 chosenPosition
private float halfPI
public Vector3 GetRandomPatrolPoint()
public AIMovePoint GetBestRoamPoint(Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float anchorClampDistance, float lookupMaxRange)
public void DebugDraw()
public Vector3 GetRandomPositionAround(Vector3 position, float minDistFrom, float maxDistFrom)
public Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
public Vector3 GetBestRoamPositionFromAnchor(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
public bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, Vector3& result)
private bool TestFleeDirection(BaseNavigator navigator, Vector3 dirFromThreat, float offsetDegrees, float minRange, float maxRange, Vector3& result)
public Vector3 GetPointOnCircle(Vector3 center, float radius, float degrees)
}
public BasePathNode : MonoBehaviour {
public BasePath Path
public List`1<BasePathNode> linked
public float maxVelocityOnApproach
public bool straightaway
public Vector3 Position
public bool Straightaway
public IEnumerable`1<IAIPathNode> Linked
public Vector3 get_Position()
public bool get_Straightaway()
public IEnumerable`1<IAIPathNode> get_Linked()
public bool IsValid()
public void AddLink(IAIPathNode link)
public void OnDrawGizmosSelected()
}
public BasePet : NPCPlayer {
public Dictionary`2<ulong, BasePet> ActivePetByOwnerID
public bool queuedMovementsAllowed
public bool onlyQueueBaseNavMovements
public float movementupdatebudgetms
public float BaseAttackRate
public float BaseAttackDamge
public DamageType AttackDamageType
private PetBrain <Brain>k__BackingField
public GameObjectRef mapMarkerPrefab
private BaseEntity _mapMarkerInstance
public bool inQueue
public Queue`1<BasePet> _movementProcessQueue
public PetBrain Brain
public PetBrain get_Brain()
protected void set_Brain(PetBrain value)
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public void ProcessMovementQueue()
public void DoBudgetedMoveUpdate()
public bool IsLoadBalanced()
public void ServerInit()
public void CreateMapMarker()
internal void DoServerDestroy()
public void TryThink()
public void ServerThink(float delta)
public void ApplyPetStatModifiers()
private void OnPhysicsNeighbourChanged()
}
public BasePlayer : BaseCombatEntity {
public bool isInAir
public bool isOnPlayer
public float violationLevel
public float lastViolationTime
public float lastAdminCheatTime
public AntiHackType lastViolationType
public float vehiclePauseTime
public float speedhackPauseTime
public float speedhackDistance
public float flyhackPauseTime
public float flyhackDistanceVertical
public float flyhackDistanceHorizontal
public Vector3 lastGroundedPosition
public float fallingVelocity
public float fallingDistance
public float timeInAir
public float waterDelay
public Vector3 initialVelocity
public TimeAverageValueLookup`1<UInt32> rpcHistory
public Phrase ClanInviteSuccess
public Phrase ClanInviteFailure
public Phrase ClanInviteFull
public long clanId
public IClan serverClan
public ViewModel GestureViewModel
public float drinkRange
public float drinkMovementSpeed
private NetworkQueueList[] networkQueue
private NetworkQueueList SnapshotQueue
public string GestureCancelString
public GestureCollection gestureList
public TimeUntil gestureFinishedTime
public TimeSince blockHeldInputTimer
public GestureConfig currentGesture
private HashSet`1<NetworkableId> recentWaveTargets
public string WAVED_PLAYERS_STAT
public ulong currentTeam
public Phrase MaxTeamSizeToast
private bool sentInstrumentTeamAchievement
private bool sentSummerTeamAchievement
private int TEAMMATE_INSTRUMENT_COUNT_ACHIEVEMENT
private int TEAMMATE_SUMMER_FLOATING_COUNT_ACHIEVEMENT
private string TEAMMATE_INSTRUMENT_ACHIEVEMENT
private string TEAMMATE_SUMMER_ACHIEVEMENT
public Phrase MarkerLimitPhrase
public int MaxMapNoteLabelLength
public List`1<MissionInstance> missions
private float thinkEvery
private float timeSinceMissionThink
private BaseMission followupMission
private IMissionProvider followupMissionProvider
private int _activeMission
public ModelState modelState
private ModelState <modelStateTick>k__BackingField
private bool wantsSendModelState
public float nextModelStateUpdate
public EntityRef mounted
public float nextSeatSwapTime
public BaseEntity PetEntity
public IPet Pet
private float lastPetCommandIssuedTime
private Phrase HostileTitle
private Phrase HostileDesc
private PingStyle HostileMarker
private Phrase GoToTitle
private Phrase GoToDesc
private PingStyle GoToMarker
private Phrase DollarTitle
private Phrase DollarDesc
private PingStyle DollarMarker
private Phrase LootTitle
private Phrase LootDesc
private PingStyle LootMarker
private Phrase NodeTitle
private Phrase NodeDesc
private PingStyle NodeMarker
private Phrase GunTitle
private Phrase GunDesc
private PingStyle GunMarker
private PingStyle BuildMarker
private TimeSince lastTick
private List`1<ValueTuple`2<ItemDefinition, PingType>> tutorialDesiredResource
private List`1<ValueTuple`2<NetworkableId, PingType>> pingedEntities
private TimeSince lastResourcePingUpdate
private bool _playerStateDirty
private string _wipeId
private BaseEntity cachedPrivilegeFromOther
private float cachedPrivilegeFromOtherTime
public Dictionary`2<int, FiredProjectile> firedProjectiles
public PlayerStatistics stats
public ItemId svActiveItemID
public float NextChatTime
public float nextSuicideTime
public float nextRespawnTime
public string respawnId
private RealTimeUntil timeUntilLoadingExpires
private int <DebugMapMarkerIndex>k__BackingField
private UInt32 <LastBlockColourChangeId>k__BackingField
private bool <PlayHeavyLandingAnimation>k__BackingField
private Vector3 <estimatedVelocity>k__BackingField
private float <estimatedSpeed>k__BackingField
private float <estimatedSpeed2D>k__BackingField
private int <secondsConnected>k__BackingField
private float <desyncTimeRaw>k__BackingField
private float <desyncTimeClamped>k__BackingField
public Vector3 viewAngles
public float lastSubscriptionTick
public float lastPlayerTick
public float sleepStartTime
public float fallTickRate
public float lastFallTime
public float fallVelocity
private HitInfo cachedNonSuicideHitInfo
public ListHashSet`1<BasePlayer> activePlayerList
public ListHashSet`1<BasePlayer> sleepingPlayerList
public ListHashSet`1<BasePlayer> bots
public float cachedCraftLevel
public float nextCheckTime
private Workbench _cachedWorkbench
public PersistantPlayer cachedPersistantPlayer
private OceanPaths cachedOceanPaths
private int WILDERNESS
private int MONUMENT
private int BASE
private int FLYING
private int BOATING
private int SWIMMING
private int DRIVING
public float lifeStoryFramebudgetms
public PlayerLifeStory lifeStory
public PlayerLifeStory previousLifeStory
public float TimeCategoryUpdateFrequency
public float nextTimeCategoryUpdate
private int <currentTimeCategory>k__BackingField
private bool hasSentPresenceState
private bool LifeStoryInWilderness
private bool LifeStoryInMonument
private bool LifeStoryInBase
private bool LifeStoryFlying
private bool LifeStoryBoating
private bool LifeStorySwimming
private bool LifeStoryDriving
private bool waitingForLifeStoryUpdate
public LifeStoryWorkQueue lifeStoryQueue
private DeathInfo cachedOverrideDeathInfo
private bool IsSpectatingTeamInfo
private TimeSince lastSpectateTeamInfoUpdate
public int SpectateOffset
public string spectateFilter
private bool <IsBeingSpectated>k__BackingField
private List`1<NearbyStash> nearbyStashes
public float lastUpdateTime
public float cachedThreatLevel
public float weaponDrawnDuration
private InputState <serverInput>k__BackingField
public float lastTickTime
public float lastStallTime
public float lastInputTime
private float tutorialKickTime
public Nullable`1<ItemId> restraintItemId
public PlayerTick lastReceivedTick
private float tickDeltaTime
private bool tickNeedsFinalizing
private Vector3 <tickViewAngles>k__BackingField
private TimeAverageValue ticksPerSecond
private TickInterpolator tickInterpolator
public Deque`1<Vector3> eyeHistory
public TickHistory tickHistory
private TutorialItemAllowance <CurrentTutorialAllowance>k__BackingField
private float startTutorialCooldown
public float nextUnderwearValidationTime
public UInt32 lastValidUnderwearSkin
public float woundedDuration
public float lastWoundedStartTime
public float healingWhileCrawling
public bool woundedByFallDamage
private float INCAPACITATED_HEALTH_MIN
private float INCAPACITATED_HEALTH_MAX
public int MaxBotIdRange
public GameObjectRef fallDamageEffect
public GameObjectRef drownEffect
public PlayerFlags playerFlags
private HiddenValue`1<PlayerEyes> eyesValue
private HiddenValue`1<PlayerInventory> inventoryValue
public PlayerBlueprints blueprints
public PlayerMetabolism metabolism
public PlayerModifiers modifiers
private HiddenValue`1<CapsuleCollider> colliderValue
public PlayerBelt Belt
public Rigidbody playerRigidbody
public EncryptedValue`1<ulong> userID
public string UserIDString
public int gamemodeteam
public int reputation
protected string _displayName
public string _lastSetName
public float crouchSpeed
public float walkSpeed
public float runSpeed
public float crawlSpeed
public CapsuleColliderInfo playerColliderStanding
public CapsuleColliderInfo playerColliderDucked
public CapsuleColliderInfo playerColliderCrawling
public CapsuleColliderInfo playerColliderLyingDown
public ProtectionProperties cachedProtection
public float nextColliderRefreshTime
public float weaponMoveSpeedScale
public bool clothingBlocksAiming
public float clothingMoveSpeedReduction
public float clothingWaterSpeedBonus
public float clothingAccuracyBonus
public bool equippingBlocked
public float eggVision
public PhoneController activeTelephone
public BaseEntity designingAIEntity
public IPlayer IPlayer
public Phrase LootPanelTitle
public bool IsReceivingSnapshot
public bool IsAdmin
public bool IsDeveloper
public bool IsInCreativeMode
public bool UnlockAllSkins
public bool IsAiming
public bool IsFlying
public bool IsConnected
public bool IsInTutorial
public bool IsRestrained
public bool IsRestrainedOrSurrendering
public bool InGesture
private bool CurrentGestureBlocksMovement
public bool CurrentGestureIsDance
public bool CurrentGestureIsFullBody
public bool CurrentGestureIsUpperBody
public bool CurrentGestureIsSurrendering
private bool InGestureCancelCooldown
public PlayerTeam Team
public MapNote ServerCurrentDeathNote
public bool HasPendingFollowupMission
public ModelState modelStateTick
public bool isMounted
public bool isMountingHidingWeapon
private int TotalPingCount
public PlayerState State
public string WipeId
public FamilyEnum Family
protected float PositionTickRate
public int DebugMapMarkerIndex
public UInt32 LastBlockColourChangeId
public bool PlayHeavyLandingAnimation
public Vector3 estimatedVelocity
public float estimatedSpeed
public float estimatedSpeed2D
public int secondsConnected
public float desyncTimeRaw
public float desyncTimeClamped
public float secondsSleeping
public IEnumerable`1<BasePlayer> allPlayerList
public float currentCraftLevel
public float currentComfort
public PersistantPlayer PersistantPlayerInfo
public bool hasPreviousLife
public int currentTimeCategory
public bool IsBeingSpectated
public InputState serverInput
public float timeSinceLastTick
public float timeSinceLastStall
public float IdleTime
public bool isStalled
public bool wasStalled
public Vector3 tickViewAngles
public int tickHistoryCapacity
public Matrix4x4 tickHistoryMatrix
public TutorialItemAllowance CurrentTutorialAllowance
public float TimeSinceWoundedStarted
public Connection Connection
public bool IsBot
public PlayerEyes eyes
public PlayerInventory inventory
public CapsuleCollider playerCollider
public string displayName
public TraitFlag Traits
public bool HasActiveTelephone
public bool IsDesigningAI
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool TriggeredAntiHack(float seconds, float score)
public bool UsedAdminCheat(float seconds)
public void PauseVehicleNoClipDetection(float seconds)
public void PauseFlyHackDetection(float seconds)
public void PauseSpeedHackDetection(float seconds)
public int GetAntiHackKicks()
public void ResetAntiHack()
public bool CanModifyClan()
public void LoadClanInfo()
public void UpdateClanLastSeen()
public void AddClanScore(ClanScoreEventType type, int multiplier, BasePlayer otherPlayer, IClan otherClan, string arg1, string arg2)
private void HandleClanPlayerKilled(BasePlayer killedByPlayer)
public bool CanBeLooted(BasePlayer player)
public Phrase get_LootPanelTitle()
public void RPC_LootPlayer(RPCMessage msg)
public void RPC_Assist(RPCMessage msg)
public void RPC_KeepAlive(RPCMessage msg)
private void SV_Drink(RPCMessage msg)
public void RPC_StartClimb(RPCMessage msg)
private void RequestServerEmoji()
private void ServerRequestEmojiData(RPCMessage msg)
public int GetQueuedUpdateCount(NetworkQueue queue)
public void SendSnapshots(ListHashSet`1<Networkable> ents)
public void QueueUpdate(NetworkQueue queue, BaseNetworkable ent)
public void SendEntityUpdate()
public void ClearEntityQueue(Group group)
private void SendEntityUpdates(NetworkQueueList queue)
public void SendEntitySnapshot(BaseNetworkable ent)
public bool HasPlayerFlag(PlayerFlags f)
public bool get_IsReceivingSnapshot()
public bool get_IsAdmin()
public bool get_IsDeveloper()
public bool get_IsInCreativeMode()
public bool get_UnlockAllSkins()
public bool get_IsAiming()
public bool get_IsFlying()
public bool get_IsConnected()
public void SetPlayerFlag(PlayerFlags f, bool b)
public void LightToggle(bool mask)
public bool get_IsInTutorial()
public bool get_IsRestrained()
public bool get_IsRestrainedOrSurrendering()
public bool get_InGesture()
private bool get_CurrentGestureBlocksMovement()
public bool get_CurrentGestureIsDance()
public bool get_CurrentGestureIsFullBody()
public bool get_CurrentGestureIsUpperBody()
public bool get_CurrentGestureIsSurrendering()
private bool get_InGestureCancelCooldown()
public void Server_StartGesture(RPCMessage msg)
public void Server_StartGesture(UInt32 gestureId)
public void Server_StartGesture(GestureConfig toPlay, GestureStartSource startSource)
private void TimeoutGestureServer()
public void Server_CancelGesture()
private void MonitorLoopingGesture()
private void NotifyGesturesNewItemEquipped()
public int CountWaveTargets(Vector3 position, float distance, float minimumDot, Vector3 forward, HashSet`1<NetworkableId> workingList, int maxCount)
private bool IsGestureBlocked()
public PlayerTeam get_Team()
public void DelayedTeamUpdate()
public void TeamUpdate()
public void TeamUpdate(bool fullTeamUpdate)
public void UpdateTeam(ulong newTeam)
public void ClearTeam()
public void ClearPendingInvite()
public HeldEntity GetHeldEntity()
public bool IsHoldingEntity()
public bool IsHostileItem(Item item)
public bool IsItemHoldRestricted(Item item)
public MapNote get_ServerCurrentDeathNote()
public void set_ServerCurrentDeathNote(MapNote value)
public void ClearDeathMarker(bool sendToClient)
public void Server_LogDeathMarker(Vector3 position)
public void Server_AddMarker(RPCMessage msg)
private int FindUnusedPointOfInterestColour()
public void Server_UpdateMarker(RPCMessage msg)
private void ValidateMapNote(MapNote n)
public void Server_RemovePointOfInterest(RPCMessage msg)
public void Server_RequestMarkers(RPCMessage msg)
public void Server_ClearMapMarkers(RPCMessage msg)
public void SendMarkersToClient()
public bool HasAttemptedMission(UInt32 missionID)
public bool CanAcceptMission(BaseMission mission)
public bool CanAcceptMission(UInt32 missionID)
public bool IsMissionActive(UInt32 missionID)
public bool HasCompletedMission(UInt32 missionID)
public bool HasFailedMission(UInt32 missionID)
private void WipeMissions()
public void AbandonActiveMission()
public void ThinkMissions(float delta)
public void MissionDirty(bool shouldSendNetworkUpdate)
public void ProcessMissionEvent(MissionEventType type, UInt32 identifier, float amount)
public void ProcessMissionEvent(MissionEventType type, UInt32 identifier, float amount, Vector3 worldPos)
public void ProcessMissionEvent(MissionEventType type, int identifier, float amount)
public void ProcessMissionEvent(MissionEventType type, NetworkableId identifier, float amount)
public void ProcessMissionEvent(MissionEventType type, MissionEventPayload payload, float amount)
private void AssignFollowUpMission()
public void RegisterFollowupMission(BaseMission targetMission, IMissionProvider provider)
public bool get_HasPendingFollowupMission()
private Missions SaveMissions()
public void SetActiveMission(int index)
public int GetActiveMission()
public bool HasActiveMission()
public MissionInstance GetActiveMissionInstance()
private void LoadMissions(Missions loadedMissions)
public ModelState get_modelStateTick()
private void set_modelStateTick(ModelState value)
private void UpdateModelState()
public void SendModelState(bool force)
public bool get_isMounted()
public bool get_isMountingHidingWeapon()
public BaseMountable GetMounted()
public BaseVehicle GetMountedVehicle()
public void MarkSwapSeat()
public bool SwapSeatCooldown()
public bool CanMountMountablesNow()
public void MountObject(BaseMountable mount, int desiredSeat)
public void EnsureDismounted()
public void DismountObject()
public void HandleMountedOnLoad()
public bool AllowSleeperMounting(BaseMountable mountable)
public PlayerSecondaryData SaveSecondaryData()
public void LoadSecondaryData(PlayerSecondaryData data)
public void DisableTransferProtection()
public void KickAfterServerTransfer()
private void RequestParachuteDeploy(RPCMessage msg)
public void RequestParachuteDeploy()
public bool CheckParachuteClearance()
public bool HasValidParachuteEquipped()
public void ClearClientPetLink()
public void SendClientPetLink()
public void SendClientPetStateIndex()
private void IssuePetCommand(RPCMessage msg)
private void IssuePetCommandRaycast(RPCMessage msg)
private void ParsePetCommand(RPCMessage msg, bool raycast)
public bool CanPing(bool disregardHeldEntity)
public PingStyle GetPingStyle(PingType t)
private void ApplyPingStyle(MapNote note, PingType type)
private void Server_AddPing(RPCMessage msg)
public void AddPingAtLocation(PingType type, Vector3 location, float time, NetworkableId associatedId)
public void RemovePingAtLocation(PingType type, Vector3 location, float tolerance, NetworkableId associatedId)
private void Server_RemovePing(RPCMessage msg)
public void SendPingsToClient()
private int get_TotalPingCount()
private void TickPings()
public void RegisterPingedEntity(BaseEntity entity, PingType type)
public void DeregisterPingedEntitiesOfType(PingType type)
public void DeregisterPingedEntity(NetworkableId id, PingType type)
public void EnableResourcePings(ItemDefinition forItem, PingType pingType)
private void UpdateResourcePings()
private MapNote CreatePingForEntity(BaseEntity baseEntity, PingType type)
private bool HasPingForEntity(BaseEntity ent)
private bool HasPingForEntity(NetworkableId id)
public void DisableResourcePings(ItemDefinition forItem, PingType type)
private void ClearAllPings()
public PlayerState get_State()
public string get_WipeId()
public void DirtyPlayerState()
public void SavePlayerState()
public void ResetPlayerState()
public bool IsSleeping()
public bool IsSpectating()
public bool IsRelaxed()
public bool IsServerFalling()
public bool IsLoadingAfterTransfer()
public bool CanBuild()
public bool CanBuild(Vector3 position, Quaternion rotation, Bounds bounds)
public bool CanBuild(OBB obb)
public bool IsBuildingBlocked()
public bool IsBuildingBlocked(Vector3 position, Quaternion rotation, Bounds bounds)
public bool IsBuildingBlocked(OBB obb)
public bool IsBuildingAuthed()
public bool IsBuildingAuthed(Vector3 position, Quaternion rotation, Bounds bounds)
public bool IsBuildingAuthed(OBB obb)
public bool CanPlaceBuildingPrivilege()
public bool CanPlaceBuildingPrivilege(Vector3 position, Quaternion rotation, Bounds bounds)
public bool CanPlaceBuildingPrivilege(OBB obb)
public bool IsNearEnemyBase()
public bool IsNearEnemyBase(Vector3 position, Quaternion rotation, Bounds bounds)
public bool IsNearEnemyBase(OBB obb)
public bool IsBuildingBlockedByVehicle()
public bool IsBuildingBlockedByEntity()
public bool HasPrivilegeFromOther()
private bool IsBuildingBlockedByVehicle(OBB obb)
private bool IsBuildingBlockedByEntity(OBB obb)
public void OnProjectileAttack(RPCMessage msg)
public void OnProjectileRicochet(RPCMessage msg)
public void OnProjectileUpdate(RPCMessage msg)
private void SimulateProjectile(Vector3& position, Vector3& velocity, Single& partialTime, float travelTime, Vector3 gravity, float drag, Vector3& prevPosition, Vector3& prevVelocity)
protected void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
public void CleanupExpiredProjectiles()
public bool HasFiredProjectile(int id)
public void NoteFiredProjectile(int projectileid, Vector3 startPos, Vector3 startVel, AttackEntity attackEnt, ItemDefinition firedItemDef, Guid projectileGroupId, Vector3 positionOffset, Item pickupItem)
public void ServerNoteFiredProjectile(int projectileid, Vector3 startPos, Vector3 startVel, AttackEntity attackEnt, ItemDefinition firedItemDef, Item pickupItem)
public bool CanUseNetworkCache(Connection connection)
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public FamilyEnum get_Family()
protected float get_PositionTickRate()
public int get_DebugMapMarkerIndex()
public void set_DebugMapMarkerIndex(int value)
public UInt32 get_LastBlockColourChangeId()
public void set_LastBlockColourChangeId(UInt32 value)
public bool get_PlayHeavyLandingAnimation()
public void set_PlayHeavyLandingAnimation(bool value)
internal void OnParentRemoved()
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
private void TransformState(Matrix4x4 matrix)
public bool CanSuicide()
public void MarkSuicide()
public bool CanRespawn()
public void MarkRespawn(float nextSpawnDelay)
public Item GetActiveItem()
public void MovePosition(Vector3 newPos)
public Vector3 get_estimatedVelocity()
private void set_estimatedVelocity(Vector3 value)
public float get_estimatedSpeed()
private void set_estimatedSpeed(float value)
public float get_estimatedSpeed2D()
private void set_estimatedSpeed2D(float value)
public int get_secondsConnected()
private void set_secondsConnected(int value)
public float get_desyncTimeRaw()
private void set_desyncTimeRaw(float value)
public float get_desyncTimeClamped()
private void set_desyncTimeClamped(float value)
public void OverrideViewAngles(Vector3 newAng)
public void ServerInit()
internal void DoServerDestroy()
protected void ServerUpdate(float deltaTime)
private void ServerUpdateBots(float deltaTime)
private void ConnectedPlayerUpdate(float deltaTime)
private void EnterGame()
private void HandleTutorialOnGameEnter()
private void ClientKeepConnectionAlive(RPCMessage msg)
private void ClientLoadingComplete(RPCMessage msg)
public void PlayerInit(Connection c)
public void StatSave()
public void SendDeathInformation()
public void SendRespawnOptions()
public void GetRespawnOptionsForPlayer(List`1<SpawnOptions> spawnOptions, ulong userID)
private void RequestRespawnInformation(RPCMessage msg)
public float get_secondsSleeping()
public void ScheduledDeath()
public void StartSleeping()
private void TurnOffAllLights()
private void OnPhysicsNeighbourChanged()
private void DelayedServerFall()
public void SetServerFall(bool wantsOn)
public void ServerFall()
public void DelayedRigidbodyDisable()
public void EndSleeping()
public void EndLooting()
public void OnDisconnected()
private void InventoryUpdate()
public void ApplyFallDamageFromVelocity(float velocity)
private void OnPlayerLanded(RPCMessage msg)
public void SendGlobalSnapshot()
public void SendFullSnapshot()
public void OnNetworkGroupLeave(Group group)
private void LeaveVisibility(Group group)
public void OnNetworkGroupEnter(Group group)
private void EnterVisibility(Group group)
public void CheckDeathCondition(HitInfo info)
public BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List`1<TriggerBase> triggersOnDeath)
public void OnKilled(HitInfo info)
public void RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity)
public void Respawn()
public bool IsImmortalTo(HitInfo info)
public float TimeAlive()
public void Hurt(HitInfo info)
public void Heal(float amount)
public IEnumerable`1<BasePlayer> get_allPlayerList()
public BasePlayer FindBot(ulong userId)
public BasePlayer FindBotClosestMatch(string name)
public BasePlayer FindByID(ulong userID)
public bool TryFindByID(ulong userID, BasePlayer& basePlayer)
public BasePlayer FindSleeping(ulong userID)
public BasePlayer FindAwakeOrSleepingByID(ulong userID)
public void Command(string strCommand, Object[] arguments)
public void OnInvalidPosition()
public BasePlayer Find(string strNameOrIDOrIP, IEnumerable`1<BasePlayer> list)
public BasePlayer Find(string strNameOrIDOrIP)
public BasePlayer FindSleeping(string strNameOrIDOrIP)
public BasePlayer FindAwakeOrSleeping(string strNameOrIDOrIP)
public void SendConsoleCommand(string command, Object[] obj)
public void UpdateRadiation(float fAmount)
public float RadiationExposureFraction()
public float RadiationProtection()
public void OnHealthChanged(float oldvalue, float newvalue)
public void SV_ClothingChanged()
public bool IsNoob()
public bool HasHostileItem()
public void GiveItem(Item item, GiveItemReason reason)
public void AttackerInfo(DeathInfo info)
public void InvalidateWorkbenchCache()
public Workbench GetCachedCraftLevelWorkbench()
public float get_currentCraftLevel()
public float get_currentComfort()
public bool ShouldDropActiveItem()
public void Die(HitInfo info)
public void Kick(string reason)
public Vector3 GetDropPosition()
public Vector3 GetDropVelocity()
public void ApplyInheritedVelocity(Vector3 velocity)
public void SetInfo(string key, string val)
public int GetInfoInt(string key, int defaultVal)
public bool GetInfoBool(string key, bool defaultVal)
public string GetInfoString(string key, string defaultVal)
public void PerformanceReport(RPCMessage msg)
public void PerformanceReport_Frametime(RPCMessage msg)
public bool ShouldNetworkTo(BasePlayer player)
internal void GiveAchievement(string name, bool allowTutorial)
public void OnPlayerReported(RPCMessage msg)
public void OnFeedbackReport(RPCMessage msg)
public void StartDemoRecording()
public void StopDemoRecording()
public void MonitorDemoRecording()
public void InvalidateCachedPeristantPlayer()
public PersistantPlayer get_PersistantPlayerInfo()
public void set_PersistantPlayerInfo(PersistantPlayer value)
public bool IsPlayerVisibleToUs(BasePlayer otherPlayer, Vector3 fromOffset, int layerMask)
protected void OnKilledByPlayer(BasePlayer p)
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public ItemContainerId GetIdealContainer(BasePlayer looter, Item item, ItemMoveModifier modifier)
private BaseVehicle GetVehicleParent()
private void RemoveLoadingPlayerFlag()
public bool InNoRespawnZone()
private void SendCargoPatrolPath()
private void RPC_ReqDoPush(RPCMessage rpc)
private void RPC_ReqRemoveCuffs(RPCMessage rpc)
private void RPC_ReqRemoveHood(RPCMessage rpc)
private void RemoveAndReturnPrisonerHood(BasePlayer returnToPlayer)
private void RPC_ReqEquipHood(RPCMessage rpc)
private void EquipPrisonerHood(BasePlayer placingPlayer)
private void RPC_ReqForceMountNearest(RPCMessage rpc)
private void ForceRestrainedMountNearest(BasePlayer forcingPlayer)
private void RPC_ReqForceSwapSeat(RPCMessage rpc)
public bool CanMoveFrom(BasePlayer player, Item item)
public bool get_hasPreviousLife()
public int get_currentTimeCategory()
private void set_currentTimeCategory(int value)
internal void LifeStoryStart()
public void LifeStoryEnd()
internal void LifeStoryUpdate(float deltaTime, float moveSpeed)
public void UpdateTimeCategory()
public void LifeStoryShotFired(BaseEntity withWeapon)
public void LifeStoryShotHit(BaseEntity withWeapon)
public void LifeStoryKill(BaseCombatEntity killed)
public void LifeStoryGenericStat(string key, int value)
public void LifeStoryHurt(float amount)
public void LifeStoryHeal(float amount)
public void SetOverrideDeathBlow(DeathInfo info)
internal void LifeStoryLogDeath(HitInfo deathBlow, DamageType lastDamage)
public bool get_IsBeingSpectated()
private void set_IsBeingSpectated(bool value)
public void SetSpectateTeamInfo(bool state)
private void Tick_Spectator()
public void UpdateSpectateTarget(string strName)
public void UpdateSpectateTarget(ulong id)
private void SpectatePlayer(BaseEntity target)
public void StartSpectating()
public void StopSpectating()
public void Teleport(BasePlayer player)
public void Teleport(string strName, bool playersOnly)
public void Teleport(Vector3 position)
public void CopyRotation(BasePlayer player)
protected void OnChildAdded(BaseEntity child)
protected void OnChildRemoved(BaseEntity child)
private void UpdateSpectatePositionFromDebugCamera(RPCMessage msg)
private void NotifyDebugCameraEnded(RPCMessage msg)
public void AddNeabyStash(StashContainer newStash)
public void RemoveNearbyStash(StashContainer stash)
private void CheckStashRevealInvoke()
public float GetThreatLevel()
public void EnsureUpdated()
public bool IsHostile()
public float GetHostileDuration()
public void MarkHostileFor(float duration)
public void MarkWeaponDrawnDuration(float newDuration)
public void AddWeaponDrawnDuration(float duration)
public InputState get_serverInput()
private void set_serverInput(InputState value)
public float get_timeSinceLastTick()
public float get_timeSinceLastStall()
public float get_IdleTime()
public bool get_isStalled()
public bool get_wasStalled()
public void OnReceivedTick(Stream stream)
public void OnReceivedVoice(Byte[] data)
public void ResetInputIdleTime()
private void EACStateUpdate()
private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
public void UpdateActiveItem(ItemId itemID)
internal void UpdateModelStateFromTick(PlayerTick tick)
internal void UpdatePositionFromTick(PlayerTick tick, bool wasPlayerStalled)
internal void UpdateRotationFromTick(PlayerTick tick)
public void UpdateEstimatedVelocity(Vector3 lastPos, Vector3 currentPos, float deltaTime)
public Vector3 get_tickViewAngles()
private void set_tickViewAngles(Vector3 value)
public int get_tickHistoryCapacity()
public Matrix4x4 get_tickHistoryMatrix()
private void FinalizeTick(float deltaTime)
public TutorialItemAllowance get_CurrentTutorialAllowance()
private void set_CurrentTutorialAllowance(TutorialItemAllowance value)
public bool IsCraftingTutorialBlocked(ItemDefinition def, Boolean& forceUnlock)
public bool CanModifyCraftAmountDuringTutorial()
public TutorialIsland GetCurrentTutorialIsland()
public void ClearTutorial()
public void ClearTutorial_PostDeath()
public void OnStartedTutorial()
public void SetTutorialAllowance(TutorialItemAllowance newAllowance)
private void StartTutorial(RPCMessage msg)
public void StartTutorial(bool triggerAnalytics)
private void PlayerRequestedTutorialStart(RPCMessage msg)
public UInt32 GetUnderwearSkin()
public void ServerRPC_UnderwearChange(RPCMessage msg)
public bool IsWounded()
public bool IsCrawling()
public bool IsIncapacitated()
public float get_TimeSinceWoundedStarted()
public bool WoundInsteadOfDying(HitInfo info)
public void ResetWoundingVars()
public bool EligibleForWounding(HitInfo info)
public void BecomeWounded(HitInfo info)
public void StopWounded(BasePlayer source)
public void ProlongWounding(float delay)
public void SendWoundedInformation(float timeLeft)
public float GetRecoveryChance()
public void WoundingTick()
public void GoToCrawling(HitInfo info)
public void GoToIncapacitated(HitInfo info)
public void WoundedStartSharedCode(HitInfo info)
public void StartWoundedTick(int minTime, int maxTime)
public void ApplyWoundedStartTime()
public void RecoverFromWounded()
public bool WoundingCausingImmortality(HitInfo info)
public BasePlayer ToPlayer()
public Connection get_Connection()
public bool get_IsBot()
public PlayerEyes get_eyes()
public void set_eyes(PlayerEyes value)
public PlayerInventory get_inventory()
public CapsuleCollider get_playerCollider()
public string get_displayName()
public void set_displayName(string value)
public string SanitizePlayerNameString(string playerName, ulong userId)
public bool IsGod()
public Quaternion GetNetworkRotation()
public bool CanInteract()
public bool CanInteract(bool usableWhileCrawling)
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public float MaxVelocity()
public OBB WorldSpaceBounds()
public Vector3 GetMountVelocity()
public Vector3 GetInheritedProjectileVelocity(Vector3 direction)
public Vector3 GetInheritedThrowVelocity(Vector3 direction)
public Vector3 GetInheritedDropVelocity()
public void PreInitShared()
public void DestroyShared()
public bool InSafeZone()
public bool IsInNoRespawnZone()
public bool IsOnATugboat()
public void ServerCycle(float deltaTime)
private bool ManuallyCheckSafezone()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public Bounds GetBounds(bool ducked)
public Bounds GetBounds()
public Vector3 GetCenter(bool ducked)
public Vector3 GetCenter()
public Vector3 GetOffset(bool ducked)
public Vector3 GetOffset()
public Vector3 GetSize(bool ducked)
public Vector3 GetSize()
public float GetHeight(bool ducked)
public float GetHeight()
public float GetRadius()
public float GetJumpHeight()
public Vector3 TriggerPoint()
public Vector3 NoClipOffset()
public float NoClipRadius(float margin)
public float MaxDeployDistance(Item item)
public float GetMinSpeed()
public float GetMaxSpeed()
public float GetSpeed(float running, float ducking, float crawling)
public void OnAttacked(HitInfo info)
public void EnablePlayerCollider()
public void DisablePlayerCollider()
public void RefreshColliderSize(bool forced)
private void SetPlayerRigidbodyState(bool isEnabled)
public void AddPlayerRigidbody()
public void RemovePlayerRigidbody()
public bool IsEnsnared()
public bool IsAttacking()
public bool CanAttack()
public bool OnLadder()
public bool IsSwimming()
public bool IsHeadUnderwater()
public bool IsOnGround()
public bool IsRunning()
public bool IsDucked()
public void ShowToast(Styles style, Phrase phrase, String[] arguments)
public void ChatMessage(string msg)
public void ConsoleMessage(string msg)
public float PenetrationResistance(HitInfo info)
public void ScaleDamage(HitInfo info)
public void ResetWeaponMoveSpeedScale()
private void UpdateMoveSpeedFromClothing()
public void UpdateProtectionFromClothing()
public string Categorize()
public string ToString()
public string GetDebugStatus()
public Item GetItem(ItemId itemId)
public TraitFlag get_Traits()
public float WaterFactor()
public float AirFactor()
public float GetOxygenTime(AirSupplyType& airSupplyType)
public bool ShouldInheritNetworkGroup()
public bool AnyPlayersVisibleToEntity(Vector3 pos, float radius, BaseEntity source, Vector3 entityEyePos, bool ignorePlayersWithPriv)
public bool IsStandingOnEntity(BaseEntity standingOn, int layerMask)
public void SetActiveTelephone(PhoneController t)
public bool get_HasActiveTelephone()
public bool get_IsDesigningAI()
public void ClearDesigningAIEntity()
private bool <CountWaveTargets>g__CheckPlayer|118_0(BasePlayer player, <>c__DisplayClass118_0& )
private bool <FindUnusedPointOfInterestColour>g__HasColour|149_0(int index)
private ArraySegment`1<byte> <SaveSecondaryData>g__GetPoolableMugshotData|212_0(PlayerRelationshipInfo relationshipInfo)
private void <SendRespawnOptions>g__CollectExternalAndSend|400_0()
private void <SendRespawnOptions>g__SendToPlayer|400_1(List`1<SpawnOptions> spawnOptions, bool loading)
internal float <CreateCorpse>g__GetFloatBasedOnUserID|430_0(ulong steamid, ulong seed)
private int <ForceRestrainedMountNearest>b__515_0(BaseMountable a, BaseMountable b)
private bool <UpdateSpectateTarget>b__571_1(BaseNetworkable x)
private bool <UpdateSpectateTarget>b__571_3(BasePlayer x)
private bool <UpdateSpectateTarget>b__571_4(BasePlayer x)
}
public BasePortal : BaseCombatEntity {
public bool isUsablePortal
private Vector3 destination_pos
private Quaternion destination_rot
public BasePortal targetPortal
public NetworkableId targetID
public Transform localEntryExitPos
public Transform relativeAnchor
public bool isMirrored
public GameObjectRef appearEffect
public GameObjectRef disappearEffect
public GameObjectRef transitionSoundEffect
public string useTagString
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ServerInit()
public void LinkPortal()
public void PostServerLoad()
public void SetDestination(Vector3 destPos, Quaternion destRot)
public Vector3 GetLocalEntryExitPosition()
public Quaternion GetLocalEntryExitRotation()
public BasePortal GetPortal()
public void UsePortal(BasePlayer player)
public void RPC_UsePortal(RPCMessage msg)
public bool IsActive()
}
public BasePrefab : BaseMonoBehaviour {
public UInt32 prefabID
public bool isClient
public bool isServer
public bool get_isServer()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BaseProjectile : AttackEntity {
public float NoiseRadius
public float damageScale
public float distanceScale
public float projectileVelocityScale
public bool automatic
public bool usableByTurret
public float turretDamageScale
public GameObjectRef attackFX
public GameObjectRef silencedAttack
public GameObjectRef muzzleBrakeAttack
public Transform MuzzlePoint
public float reloadTime
public bool canUnloadAmmo
public Magazine primaryMagazine
public bool fractionalReload
public float reloadStartDuration
public float reloadFractionDuration
public float reloadEndDuration
public float aimSway
public float aimSwaySpeed
public RecoilProperties recoil
public AnimationCurve aimconeCurve
public float aimCone
public float hipAimCone
public float aimconePenaltyPerShot
public float aimConePenaltyMax
public float aimconePenaltyRecoverTime
public float aimconePenaltyRecoverDelay
public float stancePenaltyScale
public bool hasADS
public bool noAimingWhileCycling
public bool manualCycle
protected bool needsCycle
protected bool isCycling
public bool aiming
public bool useEmptyAmmoState
public bool isBurstWeapon
public bool canChangeFireModes
public bool defaultOn
public float internalBurstRecoilScale
public float internalBurstFireRateScale
public float internalBurstAimConeScale
public float resetDuration
public int numShotsFired
public float maxDistance
private EncryptedValue`1<float> nextReloadTime
private EncryptedValue`1<float> startReloadTime
private float lastReloadTime
private bool modsChangedInitialized
private float stancePenalty
private float aimconePenalty
private UInt32 cachedModHash
private float sightAimConeScale
private float sightAimConeOffset
private float hipAimConeScale
private float hipAimConeOffset
protected bool reloadStarted
protected bool reloadFinished
private int fractionalInsertCounter
private Effect reusableInstance
public RecoilProperties recoilProperties
public bool isSemiAuto
public Transform MuzzleTransform
public bool IsUsableByTurret
protected bool CanRefundAmmo
protected ItemDefinition PrimaryMagazineAmmo
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected bool TryReload(IAmmoContainer ammoSource, int desiredAmount, bool canRefundAmmo)
public void SwitchAmmoTypesIfNeeded(IAmmoContainer ammoSource)
public void StripAmmoToType(List`1& ammos, ItemDefinition onlyAllowed)
public void SetAmmoCount(int newCount)
public void ModifyAmmoCount(int amount)
public RecoilProperties get_recoilProperties()
public Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
public float GetDamageScale(bool getMax)
public float GetDistanceScale(bool getMax)
public float GetProjectileVelocityScale(bool getMax)
public float GetOverrideProjectileThickness(Projectile projectile)
protected void StartReloadCooldown(float cooldown)
protected void ResetReloadCooldown()
protected bool HasReloadCooldown()
protected float GetReloadCooldown()
protected float GetReloadIdle()
private void OnDrawGizmos()
public RecoilProperties GetRecoil()
public bool get_isSemiAuto()
public Transform get_MuzzleTransform()
public float AmmoFraction()
public bool get_IsUsableByTurret()
public void DidAttackServerside()
public bool ServerIsReloading()
public bool CanReload()
public void TopUpAmmo()
public void ServerReload()
public bool ServerTryReload(IAmmoContainer ammoSource)
public Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier)
public float GetAIAimcone()
public void ServerUse()
public void ServerUse(float damageModifier, Transform originOverride, bool useBulletThickness)
private void AssignInitiator(HitInfo info)
public void ServerInit()
public void DelayedModSetup()
public void DestroyShared()
public void ModsChanged(Item item, bool added)
public void ForceModsChanged()
public void DelayedModsChanged()
public void ServerCommand(Item item, string command, BasePlayer player)
public void UnloadAmmo(Item item, BasePlayer player)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
public void SetLightsOn(bool isOn)
public void UpdateAttachmentsState()
private bool ShouldLightsBeOn()
protected void OnChildRemoved(BaseEntity child)
public bool CanAiAttack()
public float GetAimCone()
public float ScaleRepeatDelay(float delay)
public Modifier GetProjectileModifier()
public bool UsingBurstMode()
public bool UsingInternalBurstMode()
public bool IsBurstEligable()
public float TimeBetweenBursts()
public bool CanAttack()
public float GetReloadDuration()
public int GetAvailableAmmo()
public bool IsBurstDisabled()
private void ToggleFireMode(RPCMessage msg)
public bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount)
private void SwitchAmmoTo(RPCMessage msg)
public void OnHeldChanged()
private void StartReload(RPCMessage msg)
protected void OnReloadStarted()
protected bool get_CanRefundAmmo()
private void ServerFractionalReloadInsert(RPCMessage msg)
private void Reload(RPCMessage msg)
private void CLProject(RPCMessage msg)
protected ItemDefinition get_PrimaryMagazineAmmo()
public void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced, bool forceClientsideEffects)
public void UpdateItemCondition()
public bool IsSilenced()
public bool CanUseNetworkCache(Connection sendingTo)
public void Save(SaveInfo info)
public bool ForceSendMagazine(SaveInfo saveInfo)
public void Load(LoadInfo info)
}
public BaseResourceExtractor : BaseCombatEntity {
public bool canExtractLiquid
public bool canExtractSolid
public void ServerInit()
}
public BaseRidableAnimal : BaseVehicle {
public ItemDefinition onlyAllowedItem
public ContentsType allowedContents
public int maxStackSize
public int numStorageSlots
public int equipmentSlots
public string lootPanelName
public string storagePanelName
public bool needsBuildingPrivilegeToUse
public bool isLootable
public ItemContainer storageInventory
public ItemContainer equipmentInventory
public Flags Flag_ForSale
public Phrase SingleHorseTitle
public Phrase SingleHorseDescription
public Phrase DoubleHorseTitle
public Phrase DoubleHorseDescription
private Vector3 lastMoveDirection
public GameObjectRef saddlePrefab
public EntityRef saddleRef
public Transform movementLOSOrigin
public SoundPlayer sprintSounds
public SoundPlayer largeWhinny
public Flags Flag_Lead
public Flags Flag_HasRider
public List`1<PurchaseOption> PurchaseOptions
public ItemDefinition purchaseToken
public GameObjectRef eatEffect
public GameObjectRef CorpsePrefab
public Transform animalFront
public Transform animalNeck
public Transform animalRear
public Transform animalHead
public float obstacleDetectionRadius
public float obstacleHeadDetectionRadius
public float maxWaterDepth
public float roadSpeedBonus
public float maxWallClimbSlope
public float maxStepHeight
public float maxStepDownHeight
public RunState currentRunState
public float walkSpeed
public float trotSpeed
public float runSpeed
public float turnSpeed
public float maxSpeed
public Transform[] groundSampleOffsets
public ItemDefinition Dung
public float CaloriesToDigestPerHour
public float DungProducedPerCalorie
private float pendingDungCalories
private float dungProduction
protected float prevStamina
protected float prevMaxStamina
protected int prevRunState
protected float prevMaxSpeed
public float staminaSeconds
public float currentMaxStaminaSeconds
public float maxStaminaSeconds
public float staminaCoreLossRatio
public float staminaCoreSpeedBonus
public float staminaReplenishRatioMoving
public float staminaReplenishRatioStanding
public float calorieToStaminaRatio
public float hydrationToStaminaRatio
public float maxStaminaCoreFromWater
public bool debugMovement
private float normalOffsetDist
private Vector3[] normalOffsets
public float decayminutes
public float currentSpeed
public float desiredRotation
public float animalPitchClamp
public float animalRollClamp
public Queue`1<BaseRidableAnimal> _processQueue
public float framebudgetms
public float dungTimeScale
private BaseEntity leadTarget
public float nextDecayTime
private float lastMovementUpdateTime
private bool inQueue
protected float nextEatTime
public float lastEatTime
public float lastInputTime
private float forwardHeldSeconds
private float backwardHeldSeconds
private float sprintHeldSeconds
private float noHeldSeconds
private float lastSprintPressedTime
private float lastForwardPressedTime
private float lastBackwardPressedTime
private float timeInMoveState
protected bool onIdealTerrain
private float nextIdealTerrainCheckTime
private float nextStandTime
private InputState aiInputState
public Vector3 currentVelocity
private Vector3 averagedUp
private float nextGroundNormalUpdateTime
private Vector3 targetUp
private float nextObstacleCheckTime
private float cachedObstacleDistance
private int maxObstacleCheckSpeed
private float timeAlive
private TimeUntil dropUntilTime
public bool IsNpc
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsForSale()
public void ContainerServerInit()
private void CreateInventories(bool giveUID)
private void CreateEquipmentInventory(bool giveUID)
private void CreateStorageInventory(bool giveUID)
public ItemContainer CreateInventory(bool giveUID, int slots)
public void SaveContainer(SaveInfo info)
public void OnInventoryFirstCreated(ItemContainer container)
public void OnInventoryDirty()
public void OnItemAddedOrRemoved(Item item, bool added)
public bool ItemFilter(Item item, int targetSlot)
public bool CanAnimalAcceptItem(Item item, int targetSlot)
private void RPC_OpenLoot(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
public bool CanOpenStorage(BasePlayer player)
public void LoadContainer(LoadInfo info)
public float GetBreathingDelay()
public bool IsLeading()
public float UnitsToKPH(float unitsPerSecond)
public bool get_IsNpc()
public void ProcessQueue()
public void SetLeading(BaseEntity newLeadTarget)
public float GetNetworkTime()
public void Save(SaveInfo info)
private void OnPhysicsNeighbourChanged()
public void DelayedDropToGround()
public void Load(LoadInfo info)
public bool HasValidSaddle()
public bool HasSeatAvailable()
public void AttemptMount(BasePlayer player, bool doMountChecks)
public void LeadingChanged()
public void RPC_Claim(RPCMessage msg)
public void RPC_Lead(RPCMessage msg)
public void OnClaimedWithToken(Item tokenItem)
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void SetDecayActive(bool isActive)
public float TimeUntilNextDecay()
public void AddDecayDelay(float amount)
public void Hurt(HitInfo info)
public void AnimalDecay()
public void UseStamina(float amount)
public bool CanInitiateSprint()
public bool CanSprint()
public void ReplenishStamina(float amount)
public float ReplenishRatio()
public void ReplenishStaminaCore(float calories, float hydration)
public void UpdateStamina(float delta)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void DismountHeavyPlayers()
public BaseMountable GetSaddle()
public void BudgetedUpdate()
public void ApplyDungCalories(float calories)
private void UpdateDung(float delta)
private void DoDung()
public void VehicleFixedUpdate()
public float StaminaCoreFraction()
public void DoEatEvent()
public void ReplenishFromFood(ItemModConsumable consumable)
public void EatNearbyFood()
public void SwitchMoveState(RunState newState)
public void UpdateOnIdealTerrain()
public float MoveStateToVelocity(RunState stateToCheck)
public float GetDesiredVelocity()
public RunState StateFromSpeed(float speedToUse)
public void ModifyRunState(int dir)
public bool CanStand()
public bool IsStandCollisionClear()
public void DoDebugMovement()
public void RiderInput(InputState inputState, BasePlayer player)
public float MaxVelocity()
private float NormalizeAngle(float angle)
public void UpdateGroundNormal(bool force)
public void MarkObstacleDistanceDirty()
public float GetObstacleDistance()
public float ObstacleDistanceCheck(float speed)
public void MarkDistanceTravelled(float amount)
public void UpdateMovement(float delta)
public bool DropToGround(Vector3 targetPos, bool force)
public void DoNetworkUpdate()
public void PreServerLoad()
public void ServerInit()
public void OnKilled(HitInfo hitInfo)
public void SetupCorpse(BaseCorpse corpse)
public Vector3 GetLocalVelocityServer()
public void UpdateDropToGroundForDuration(float duration)
public void InitShared()
public bool PlayerHasToken(BasePlayer player, int tokenItemID)
public Item GetPurchaseToken(BasePlayer player, int tokenItemID)
public float GetWalkSpeed()
public float GetTrotSpeed()
public float GetRunSpeed()
public bool IsPlayerTooHeavy(BasePlayer player)
}
public BaseSaddle : BaseMountable {
public BaseRidableAnimal animal
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void SetAnimal(BaseRidableAnimal newAnimal)
}
public BaseScreenShake : MonoBehaviour {
public List`1<BaseScreenShake> list
internal float punchFadeScale
internal float bobScale
internal float animPunchMagnitude
internal AnimationCurve InverseCurve
public float length
internal float timeTaken
private int currentFrame
public void Apply(Camera cam, BaseViewModel vm)
protected void OnEnable()
protected void OnDisable()
public void Run(CachedTransform`1& cam, CachedTransform`1& vm)
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public BaseScriptableObject : ScriptableObject {
public UInt32 FilenameStringId
public string LookupFileName()
public bool op_Equality(BaseScriptableObject a, BaseScriptableObject b)
public bool op_Inequality(BaseScriptableObject a, BaseScriptableObject b)
public int GetHashCode()
public bool Equals(object o)
}
public BaseSpawnPoint : MonoBehaviour {
public SpawnPointType spawnPointType
public Dictionary`2<SpawnPointType, List`1<BaseSpawnPoint>> spawnPoints
public void GetLocation(Vector3& pos, Quaternion& rot)
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
protected void OnEnable()
protected void OnDisable()
public bool IsAvailableTo(GameObject prefab)
public bool HasPlayersIntersecting()
protected void DropToGround(Vector3& pos, Quaternion& rot)
}
public BaseStateUI : MonoBehaviour {
public Dropdown DropdownInputMemorySlot
public Transform PrefabAddNewEvent
public Transform PrefabTimerEvent
public Transform PrefabPlayerDetectedEvent
public Transform PrefabStateErrorEvent
public Transform PrefabStateFinishedEvent
public Transform PrefabAttackedEvent
public Transform PrefabInAttackRangeEvent
public Transform PrefabHealthBelowEvent
public Transform PrefabInRangeEvent
public Transform PrefabPerformedAttackEvent
public Transform PrefabTirednessAboveEvent
public Transform PrefabHungerAboveEvent
public Transform PrefabThreatDetectevEvent
public Transform PrefabTargetDetectevEvent
public Transform PrefabAmmoBelowEvent
public Transform PrefabBestTargetDetectedEvent
public Transform PrefabIsVisibleEvent
public Transform PrefabAttackTickEvent
public Transform PrefabIsMountedEvent
public Transform PrefabAndEvent
public Transform PrefabChanceEvent
public Transform PrefabTargetLostEvent
public Transform PrefabTimeSinceThreatEvent
public Transform PrefabOnPositionMemorySetEvent
public Transform PrefabAggressionTimerEvent
public Transform PrefabReloadingEvent
public Transform PrefabInRangeOfHomeEvent
public Transform PrefabIsBlindedEvent
public RustText TextStateName
public Transform EventContainer
public ScrollRect Scroll
}
public BaseSubmarine : BaseVehicle {
private Transform centreOfMassTransform
public Buoyancy buoyancy
public float maxRudderAngle
private Transform rudderVisualTransform
private Transform rudderDetailedColliderTransform
private Transform propellerTransform
public float timeUntilAutoSurface
private Renderer[] interiorRenderers
private SonarObject sonarObject
private GameObjectRef fuelStoragePrefab
public float engineKW
public float turnPower
public float engineStartupTime
private GameObjectRef itemStoragePrefab
public float depthChangeTargetSpeed
public float idleFuelPerSec
public float maxFuelPerSec
private bool internalAccessStorage
public GameObjectRef torpedoStoragePrefab
public Transform torpedoFiringPoint
public float reloadTime
protected SubmarineAudio submarineAudio
private ParticleSystem fxTorpedoFire
private GameObject internalFXContainer
private GameObject internalOnFXContainer
private ParticleSystem fxIntAmbientBubbleLoop
private ParticleSystem fxIntInitialDiveBubbles
private ParticleSystem fxIntWaterDropSpray
private ParticleSystem fxIntWindowFilm
private ParticleSystemContainer fxIntMediumDamage
private ParticleSystemContainer fxIntHeavyDamage
private GameObject externalFXContainer
private GameObject externalOnFXContainer
private ParticleSystem fxExtAmbientBubbleLoop
private ParticleSystem fxExtInitialDiveBubbles
private ParticleSystem fxExtAboveWaterEngineThrustForward
private ParticleSystem fxExtAboveWaterEngineThrustReverse
private ParticleSystem fxExtUnderWaterEngineThrustForward
private ParticleSystem[] fxExtUnderWaterEngineThrustForwardSubs
private ParticleSystem fxExtUnderWaterEngineThrustReverse
private ParticleSystem[] fxExtUnderWaterEngineThrustReverseSubs
private ParticleSystem fxExtBowWave
private ParticleSystem fxExtWakeEffect
public GameObjectRef aboveWatercollisionEffect
public GameObjectRef underWatercollisionEffect
private VolumetricLightBeam spotlightVolumetrics
private float mountedAlphaInside
private float mountedAlphaOutside
public float outsidedecayminutes
public float deepwaterdecayminutes
public float oxygenminutes
private Vector3 <Velocity>k__BackingField
public Flags Flag_Ammo
private float _throttle
private float _rudder
private float _upDown
private float _oxygen
public VehicleEngineController`1<BaseSubmarine> engineController
public float cachedFuelAmount
protected Vector3 steerAngle
public float waterSurfaceY
public float curSubDepthY
public EntityRef`1<StorageContainer> torpedoStorageInstance
private EntityRef`1<StorageContainer> itemStorageInstance
public int waterLayerMask
public float targetClimbSpeed
public float maxDamageThisTick
private float nextCollisionDamageTime
private bool prevPrimaryFireInput
private bool primaryFireInput
private float DECAY_TICK_TIME
public TimeSince timeSinceLastUsed
public TimeSince timeSinceTorpedoFired
private TimeSince timeSinceFailRPCSent
private float normalDrag
private float highDrag
private bool wasOnSurface
public AirSupplyType AirType
public EngineState<BaseSubmarine> EngineState
public Vector3 Velocity
public bool LightsAreOn
public bool HasAmmo
public float ThrottleInput
public float RudderInput
public float UpDownInput
public float Oxygen
protected float PhysicalRudderAngle
protected bool IsInWater
protected bool IsSurfaced
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public AirSupplyType get_AirType()
public EngineState<BaseSubmarine> get_EngineState()
public Vector3 get_Velocity()
private void set_Velocity(Vector3 value)
public bool get_LightsAreOn()
public bool get_HasAmmo()
public float get_ThrottleInput()
protected void set_ThrottleInput(float value)
public float get_RudderInput()
protected void set_RudderInput(float value)
public float get_UpDownInput()
protected void set_UpDownInput(float value)
public float get_Oxygen()
protected void set_Oxygen(float value)
protected float get_PhysicalRudderAngle()
protected bool get_IsInWater()
protected bool get_IsSurfaced()
public void InitShared()
public void Load(LoadInfo info)
public void OnFlagsChanged(Flags old, Flags next)
public float WaterFactorForPlayer(BasePlayer player)
public float AirFactor()
public bool BlocksWaterFor(BasePlayer player)
public float GetFuelAmount()
public float GetSpeed()
public bool CanBeLooted(BasePlayer player)
public float GetAirTimeRemaining()
protected bool CanPushNow(BasePlayer pusher)
private void UpdatePhysicalRudder(float turnInput, float deltaTime)
private bool CanMount(BasePlayer player)
private void UpdateWaterInfo()
private float GetWaterSurfaceY()
public void ServerInit()
protected void OnChildAdded(BaseEntity child)
private void ServerFlagsChanged(Flags old, Flags next)
internal void DoServerDestroy()
protected void OnCollisionEnter(Collision collision)
public float MaxVelocity()
public IFuelSystem GetFuelSystem()
public int StartingFuelUnits()
public void AttemptMount(BasePlayer player, bool doMountChecks)
public void OnPoolDestroyed()
public void WakeUp()
protected void OnServerWake()
public void OnKilled(HitInfo info)
public void VehicleFixedUpdate()
public void LightToggle(BasePlayer player)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void Save(SaveInfo info)
public bool MeetsEngineRequirements()
public void OnEngineStartFailed()
public StorageContainer GetTorpedoContainer()
public StorageContainer GetItemContainer()
private void ProcessCollision(Collision collision)
public void UpdateClients()
public void SubmarineDecay()
public void RPC_OpenFuel(RPCMessage msg)
public void RPC_OpenTorpedoStorage(RPCMessage msg)
public void RPC_OpenItemStorage(RPCMessage msg)
public void OnSurfacedInMoonpool()
private void IEngineControllerUser.Invoke(Action action, float time)
private void IEngineControllerUser.CancelInvoke(Action action)
}
public BaseTrap : DecayEntity {
public void ObjectEntered(GameObject obj)
public void Arm()
public void OnEmpty()
}
public BaseTrapTrigger : TriggerBase {
public BaseTrap _trap
public GameObject InterestedInObject(GameObject obj)
internal void OnObjectAdded(GameObject obj, Collider col)
public void OnEmpty()
}
public BaseVehicle : BaseMountable {
public bool mountChaining
public bool checkVehicleClipping
public LayerMask excludeCollisionLayers
public DismountStyle dismountStyle
public bool shouldShowHudHealth
public bool ignoreDamageFromOutside
public List`1<MountPointInfo> mountPoints
public RagdollMode mountedPlayerRagdolls
public ClippingCheckMode clippingChecks
public DamageRenderer damageRenderer
public float explosionForceMultiplier
public float explosionForceMax
public Flags Flag_OnlyOwnerEntry
public Flags Flag_Headlights
public Flags Flag_Stationary
public Flags Flag_SeatsFull
protected Flags Flag_AnyMounted
private List`1<BaseVehicle> childVehicles
private float MIN_TIME_BETWEEN_PUSHES
public TimeSince timeSinceLastPush
private bool prevSleeping
private float nextCollisionFXTime
private CollisionDetectionMode savedCollisionDetectionMode
private BaseVehicle pendingLoad
public Queue`1<BasePlayer> recentDrivers
public Action clearRecentDriverAction
public float safeAreaRadius
public Vector3 safeAreaOrigin
public float spawnTime
public bool IsMovingOrOn
public float RealisticMass
public Enumerable allMountPoints
public bool IsClient
public bool AlwaysAllowBradleyTargeting
protected bool RecentlyPushed
protected bool PositionTickFixedTime
protected bool CanSwapSeats
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsStationary()
public bool IsMoving()
public bool get_IsMovingOrOn()
public float get_RealisticMass()
public bool IsAuthed(BasePlayer player)
public bool AnyMounted()
public bool PlayerIsMounted(BasePlayer player)
public bool CanPushNow(BasePlayer pusher)
public bool HasMountPoints()
public bool CanBeLooted(BasePlayer player)
public bool IsFlipped()
public bool IsVehicleRoot()
public bool DirectlyMountable()
public BaseVehicle VehicleParent()
protected void OnChildAdded(BaseEntity child)
protected void OnChildRemoved(BaseEntity child)
public Enumerable get_allMountPoints()
public MountPointInfo GetMountPoint(int index)
public float GetSpeed()
public bool get_IsClient()
public bool get_AlwaysAllowBradleyTargeting()
protected bool get_RecentlyPushed()
public void OnAttacked(HitInfo info)
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float GetNetworkTime()
protected bool get_PositionTickFixedTime()
public void VehicleFixedUpdate()
protected int GetClipCheckMask()
protected bool DetermineIfStationary()
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public int StartingFuelUnits()
public bool IsSeatVisible(BaseMountable mountable, Vector3 eyePos, int mask)
protected bool IsSeatClipping(BaseMountable mountable, Vector3 startPos, float radius, int mask, Vector3 seatPos, Vector3 direction)
public void CheckSeatsForClipping()
public void SeatClippedWorld(BaseMountable mountable)
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void DismountAllPlayers()
public void ServerInit()
public void SpawnSubEntities()
public bool AdminFixUp(int tier)
private void OnPhysicsNeighbourChanged()
private void CheckAndSpawnMountPoints()
public void Spawn()
public void Hurt(HitInfo info)
public void DoExplosionForce(HitInfo info)
public int NumMounted()
public int MaxMounted()
public bool HasDriver()
public bool IsDriver(BasePlayer player)
public bool HasPassenger()
public bool IsPassenger(BasePlayer player)
public BasePlayer GetDriver()
public BasePlayer GetPassenger()
public void GetDrivers(List`1<BasePlayer> drivers)
public void GetMountedPlayers(List`1<BasePlayer> players)
public BasePlayer GetPlayerDamageInitiator()
public int GetPlayerSeat(BasePlayer player)
public MountPointInfo GetPlayerSeatInfo(BasePlayer player)
public bool IsVehicleMountPoint(BaseMountable bm)
protected bool get_CanSwapSeats()
public bool IsPlayerSeatSwapValid(BasePlayer player, int fromIndex, int toIndex, bool forcingRestrainedPlayer)
public void SwapSeats(BasePlayer player, int targetSeat, bool forcingRestrainedPlayer)
public int NumSwappableSeats()
public bool HasDriverMountPoints()
public bool OnlyOwnerAccessible()
public bool IsDespawnEligable()
public void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius)
public void ClearOwnerEntry()
private void DisableTransferProtectionIfEmpty()
public IFuelSystem GetFuelSystem()
public bool IsSafe()
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public BaseMountable GetIdealMountPoint(Vector3 eyePos, Vector3 pos, BasePlayer playerFor)
public bool MountEligable(BasePlayer player)
public int GetIndexFromSeat(BaseMountable seat)
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public void PrePlayerDismount(BasePlayer player, BaseMountable seat)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void TryShowCollisionFX(Collision collision, GameObjectRef effectGO)
public void TryShowCollisionFX(Vector3 contactPoint, GameObjectRef effectGO)
public void SetToKinematic()
public void SetToNonKinematic()
public void UpdateMountFlags()
public void ClearRecentDriver()
public void AttemptMount(BasePlayer player, bool doMountChecks)
public BaseMountable GetIdealMountPointFor(BasePlayer player)
public bool GetDismountPosition(BasePlayer player, Vector3& res)
public BaseMountable SpawnMountPoint(MountPointInfo mountToSpawn, Model model)
public void RPC_WantsPush(RPCMessage msg)
public void DoPushAction(BasePlayer player)
protected void OnServerWake()
protected void OnServerSleep()
public bool ShouldDisableTransferProtectionOnLoad(BasePlayer player)
public void DisableTransferProtection()
public bool AllowPlayerInstigatedDismount(BasePlayer player)
}
public BaseVehicleModule : BaseVehicle {
private Transform centreOfMassTransform
private float mass
public VisualGroup visualGroup
private VehicleLight[] lights
private BaseModularVehicle <Vehicle>k__BackingField
private int <FirstSocketIndex>k__BackingField
public LODLevel[] lodRenderers
private List`1<ConditionalObject> conditionals
private TriggerParent[] triggerParents
private VehicleModuleSlidingComponent[] slidingComponents
private VehicleModuleButtonComponent[] buttonComponents
private TimeSince TimeSinceAddedToVehicle
private float prevRefreshHealth
private bool prevRefreshVehicleIsDead
private bool prevRefreshVehicleIsLockable
public Item AssociatedItemInstance
private bool <PropagateDamage>k__BackingField
private TimeSince timeSinceItemLockRefresh
private float TIME_BETWEEN_LOCK_REFRESH
public BaseModularVehicle Vehicle
public int FirstSocketIndex
public Vector3 CentreOfMass
public float Mass
public NetworkableId ID
public bool IsOnAVehicle
public ItemDefinition AssociatedItemDef
public bool HasSeating
public bool HasAnEngine
public bool PropagateDamage
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public BaseModularVehicle get_Vehicle()
private void set_Vehicle(BaseModularVehicle value)
public int get_FirstSocketIndex()
private void set_FirstSocketIndex(int value)
public Vector3 get_CentreOfMass()
public float get_Mass()
public NetworkableId get_ID()
public bool get_IsOnAVehicle()
public ItemDefinition get_AssociatedItemDef()
public bool get_HasSeating()
public bool get_HasAnEngine()
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void RefreshParameters()
public BaseVehicle VehicleParent()
public void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
public void ModuleRemoved()
public void OtherVehicleModulesChanged()
public bool CanBeLooted(BasePlayer player)
public bool KeycodeEntryBlocked(BasePlayer player)
public void OnEngineStateChanged(EngineState<GroundVehicle> oldState, EngineState<GroundVehicle> newState)
public float MaxHealth()
public float StartHealth()
public int GetNumSocketsTaken()
public List`1<ConditionalObject> GetConditionals()
public float GetMaxDriveForce()
public void RefreshConditionals(bool canGib)
protected void PostConditionalRefresh()
private void RefreshConditional(ConditionalObject conditional, bool canGib)
private bool TryGetAdjacentModuleInFront(BaseVehicleModule& result)
private bool TryGetAdjacentModuleBehind(BaseVehicleModule& result)
private bool InSameVisualGroupAs(BaseVehicleModule moduleEntity, AdjacentMatchType matchType)
private bool CanBeUsedNowBy(BasePlayer player)
public bool PlayerIsLookingAtUsable(string lookingAtColldierName, string usableColliderName)
public void Load(LoadInfo info)
public bool IsVehicleRoot()
public bool get_PropagateDamage()
private void set_PropagateDamage(bool value)
public void VehicleFixedUpdate()
public void Hurt(HitInfo info)
public void OnHealthChanged(float oldValue, float newValue)
public bool CanBeMovedNow()
protected bool CanBeMovedNowOnVehicle()
public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
public void AcceptPropagatedDamage(float amount, DamageType type, BaseEntity attacker, bool useProtection)
public void Die(HitInfo info)
public void RPC_Use(RPCMessage msg)
public void AdminKill()
public bool AdminFixUp(int tier)
public void OnPlayerDismountedVehicle(BasePlayer player)
public void Save(SaveInfo info)
}
public BaseVehicleMountPoint : BaseMountable {
public bool DirectlyMountable()
public BaseVehicle VehicleParent()
public bool BlocksWaterFor(BasePlayer player)
public float WaterFactorForPlayer(BasePlayer player)
public float AirFactor()
}
public BaseVehicleSeat : BaseVehicleMountPoint {
public float mountedAnimationSpeed
public bool sendClientInputToVehicleParent
public bool forcePlayerModelUpdate
public bool giveCrosshair
public bool canTeamInteract
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void LightToggle(BasePlayer player)
public void SwitchParent(BaseEntity ent)
public Vector3 GetMountRagdollVelocity(BasePlayer player)
}
public BaseViewModel : FacepunchBehaviour {
public LazyAimProperties lazyaimRegular
public LazyAimProperties lazyaimIronsights
public Transform pivot
public bool useViewModelCamera
public bool wantsHeldItemFlags
public GameObject[] hideSightMeshes
public bool isGestureViewModel
public Transform MuzzlePoint
public SubsurfaceProfile subsurfaceProfile
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BasicCar : BaseVehicle {
public VehicleWheel[] wheels
public float brakePedal
public float gasPedal
public float steering
public Transform centerOfMass
public Transform steeringWheel
public float motorForceConstant
public float brakeForceConstant
public float GasLerpTime
public float SteeringLerpTime
public Transform driverEye
public GameObjectRef chairRef
public Transform chairAnchorTest
public SoundPlayer idleLoopPlayer
public Transform engineOffset
public SoundDefinition engineSoundDef
private bool chairtest
public float throttle
public float brake
public bool lightsOn
public float MaxVelocity()
public Vector3 EyePositionForPlayer(BasePlayer player, Quaternion viewRot)
public void ServerInit()
public void SpawnChairTest()
public void VehicleFixedUpdate()
public void DoSteering()
public void ConvertInputToThrottle()
public void ApplyForceAtWheels()
public void NoDriverInput()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void DriverInput(InputState inputState, BasePlayer player)
public void LightToggle(BasePlayer player)
}
public BasicZoneController : ZoneController {
public void .ctor(NexusZoneClient zoneClient)
public string ChooseSpawnZone(ulong steamId, bool isAlreadyAssignedToThisZone)
private void GetStarterZones(List`1<NexusZoneDetails> zones)
}
public Bear : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public BearTrap : BaseTrap {
protected Animator animator
private GameObject hurtTarget
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool Armed()
public void InitShared()
public bool CanPickup(BasePlayer player)
public void ServerInit()
public void Arm()
public void Fire()
public void ObjectEntered(GameObject obj)
public void DelayedFire()
public void RadialResetCorpses(float duration)
public void OnAttacked(HitInfo info)
private void RPC_Arm(RPCMessage rpc)
public void Load(LoadInfo info)
}
public BenchmarkInfo : SingletonComponent`1<BenchmarkInfo> {
public string BenchmarkTitle
public string BenchmarkSubtitle
public TextMeshProUGUI PerformanceText
public TextMeshProUGUI SystemInfoText
private StringBuilder sb
private RealTimeSince timeSinceUpdated
private void Start()
private void Update()
}
public BenchmarkScene : MonoBehaviour {
public string BenchmarkTitle
public string BenchmarkIdent
public int MaxNumberOfFrames
public int MaxNumberOfSeconds
}
public BestTargetDetectedAIEvent : BaseAIEvent {
public void Init(AIEventData data, BaseEntity owner)
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public Bezier : object {
public void ApplyLineSlack(Vector3[]& positions, Single[] slackLevels, int tesselationLevel, Transform referenceTransform)
public void ApplyLineSlack(Vector3[] positions, Single[] slackLevels, Vector3[]& result, int tesselationLevel, Transform referenceTransform)
public void ApplyLineSlack(Vector3[] positions, Single[] slackLevels, List`1& result, int tesselationLevel, Transform referenceTransform)
}
public BicycleAudio : BikeVehicleAudio {
private SoundDefinition pedalActiveSoundDef
private SoundDefinition pedalCoastSoundDef
private SoundDefinition pedalStartDef
private SoundDefinition pedalStopDef
private SoundDefinition bellSoundDef
private AnimationCurve pedalGainCurve
private AnimationCurve pedalPitchCurve
private SlicedGranularAudioClip pedalClicks
private AnimationCurve pedalClickFrequencyCurve
}
public BigWheelBettingTerminal : StorageContainer {
public BigWheelGame bigWheel
public Vector3 seatedPlayerOffset
public float offsetCheckRadius
public SoundDefinition winSound
public SoundDefinition loseSound
public BasePlayer lastPlayer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPlayerValid(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public bool TrySetBigWheel(BigWheelGame newWheel)
}
public BigWheelGame : SpinnerWheel {
public float baseSpeed
public float offset
public AnimationCurve decelerationCurve
public AnimationCurve speedCurve
public HitNumber[] hitNumbers
private float targetAngle
private float minimumSpinTime
private bool isSpinning
private bool decelerating
private float elapsedTime
private Random random
public float spinFrequencySeconds
public int spinNumber
protected int targetNumber
public int lastPaidSpinNumber
public List`1<BigWheelBettingTerminal> terminals
public bool AllowPlayerSpins()
public bool CanUpdateSign(BasePlayer player)
public void ServerInit()
public void DoSpin()
public void SetTerminalsLocked(bool isLocked)
public void RemoveTerminal(BigWheelBettingTerminal terminal)
public void InitBettingTerminals()
public float GetMaxSpinSpeed(float time)
public void Update_Server()
private float NormalizeAngle(float angle)
public float SpinSpacing()
public void QueueSpin()
public void Payout()
public HitNumber GetCurrentHitType()
}
public Bike : GroundVehicle {
public Phrase sprintPhrase
public Phrase boostPhrase
private Transform centreOfMassTransform
private VisualCarWheel wheelFront
private VisualCarWheel wheelRear
private VisualCarWheel wheelExtra
private bool snowmobileDrivingStyle
private CarSettings carSettings
private int engineKW
public float idleFuelPerSec
public float maxFuelPerSec
private float pitchStabP
private float pitchStabD
private float twoWheelRollStabP
private float twoWheelRollStabD
private float manyWheelStabP
private float manyWheelStabD
private float airControlTorquePower
public float sprintTime
private float sprintRegenTime
private float sprintBoostPercent
private ProtectionProperties riderProtection
private float hurtTriggerMinSpeed
private TriggerHurtNotChild hurtTriggerFront
private TriggerHurtNotChild hurtTriggerRear
private float maxLeanSpeed
private float leftMaxLean
private float rightMaxLean
private float midairRotationForce
private Vector3 customInertiaTensor
public PoweredBy poweredBy
private float percentFood
private float playerDamageThreshold
private float playerDeathThreshold
private bool hasBell
public float minGroundFXSpeed
private BikeChassisVisuals chassisVisuals
private VehicleLight[] lights
private ParticleSystemContainer exhaustFX
private Transform steeringLeftIK
private Transform steeringRightIK
private Transform steeringRightIKAcclerating
private Transform leftFootIK
private Transform rightFootIK
private Transform passengerLeftHandIK
private Transform passengerRightHandIK
private Transform passengerLeftFootIK
private Transform passengerRightFootIK
private ParticleSystemContainer fxMediumDamage
private GameObject fxMediumDamageInstLight
private ParticleSystemContainer fxHeavyDamage
private GameObject fxHeavyDamageInstLight
private Rigidbody sidecarRigidBody
private Transform sidecarPhysicsHinge
public float outsideDecayMinutes
public float pedalRoadsidePopulation
private Transform realSidecarCapsule
public float pedalMonumentPopulation
private Transform duplicateSidecarCapsule
public float motorbikeMonumentPopulation
public bool doPlayerDamage
private bool hasExtraWheel
public bool hasSidecar
private bool hasDamageFX
private float _throttle
private float _brake
public Flags Flag_SprintInput
public Flags Flag_DuckInput
public Flags Flag_IsSprinting
private float <SprintPercentRemaining>k__BackingField
private float _mass
private float cachedFuelFraction
private float FORCE_MULTIPLIER
private float _steer
private CarPhysics`1<Bike> carPhysics
private VehicleTerrainHandler serverTerrainHandler
private CarWheel[] wheels
private TimeSince timeSinceLastUsed
private float DECAY_TICK_TIME
private float prevPitchStabError
private float prevRollStabError
private float prevRollStabRoll
private float lastCrashDamage
private TimeSince timeSinceBellDing
private bool wasWantingSlopeSprint
public float ThrottleInput
public float BrakeInput
public bool IsBraking
public bool SprintInput
public bool DuckInput
public bool CanSprint
public bool IsSprinting
public float SprintPercentRemaining
public float SteerAngle
public float DriveWheelVelocity
public float DriveWheelSlip
public float SidecarAngle
public float MaxSteerAngle
private float Mass
public float SteerInput
public Surface OnSurface
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float get_ThrottleInput()
protected void set_ThrottleInput(float value)
public float get_BrakeInput()
protected void set_BrakeInput(float value)
public bool get_IsBraking()
public bool get_SprintInput()
private void set_SprintInput(bool value)
public bool get_DuckInput()
private void set_DuckInput(bool value)
public bool get_CanSprint()
public bool get_IsSprinting()
private void set_IsSprinting(bool value)
public float get_SprintPercentRemaining()
protected void set_SprintPercentRemaining(float value)
public float get_SteerAngle()
public float get_DriveWheelVelocity()
public float get_DriveWheelSlip()
public float get_SidecarAngle()
public float get_MaxSteerAngle()
private float get_Mass()
public void PreInitShared()
public void Load(LoadInfo info)
public float GetMaxDriveForce()
public float GetMaxForwardSpeed()
public float GetThrottleInput()
public float GetBrakeInput()
public bool GetSteerModInput()
public float GetPerformanceFraction()
public float GetFuelFraction()
public bool CanBeLooted(BasePlayer player)
protected IFuelSystem CreateFuelSystem()
public float get_SteerInput()
protected void set_SteerInput(float value)
public Surface get_OnSurface()
public float GetSteerInput()
public void ServerInit()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public void VehicleFixedUpdate()
protected void AwakeBikePhysicsTick(float speed)
private void PDPitchStab()
private void PDDirectionStab()
private void PDRollStab(float speed)
private float AngleDifference(float a, float b)
private void StabiliseSnowmobileStyle()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
public float MaxVelocity()
public CarWheel[] GetWheels()
public float GetWheelsMidPos()
public void Save(SaveInfo info)
protected void DoCollisionDamage(BaseEntity hitEntity, float damage)
public Vector3 GetMountRagdollVelocity(BasePlayer player)
public int StartingFuelUnits()
public bool MeetsEngineRequirements()
public void BikeDecay()
public float GetModifiedDrag()
private void UpdateClients()
public void SendClientRPC(byte throttleAndBrake)
public void OnEngineStartFailed()
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
private bool WantsSprint(float speed)
public void RPC_OpenFuel(RPCMessage msg)
}
public BikeChassisVisuals : VehicleChassisVisuals`1<Bike> {
private SuspensionSettings suspension
private PedalBikeSettings pedals
private KickstandSettiongs kickstand
private BikeVehicleAudio audioScript
private ChainRenderer[] chainRenderers
private float chainSpeedMultiplier
private Animator animator
private float minGroundFXSpeed
}
public BikeDriverSeat : MouseSteerableSeat {
private Vector3 sprintPosOffset
}
public BikeVehicleAudio : GroundVehicleAudio {
private EngineAudioSet engineAudioSet
private SoundDefinition suspensionDef
private float suspensionMinExtensionDelta
private float suspensionMinTimeBetweenSounds
private SoundDefinition tireDirtSoundDef
private SoundDefinition tireGrassSoundDef
private SoundDefinition tireSnowSoundDef
private SoundDefinition tireWaterSoundDef
private AnimationCurve tireGainCurve
private SoundDefinition skidSoundLoop
private SoundDefinition skidSoundDirtLoop
private SoundDefinition skidSoundSnowLoop
private float skidMinSlip
private float skidMaxSlip
}
public BindSubsurfaceProfile : MonoBehaviour {
public SubsurfaceProfile subsurfaceProfile
}
public Binocular : AttackEntity {
public Single[] fovs
public GameObjectRef fovChangeEffect
public float smoothSpeed
}
public BiomeVisuals : MonoBehaviour {
public GameObject Arid
public GameObject Temperate
public GameObject Tundra
public GameObject Arctic
public bool OverrideBiome
public Enum ToOverride
public EnvironmentVolumeOverride[] EnvironmentVolumeOverrides
protected void Start()
private void SetChoice(GameObject selection)
private void ApplyChoice(GameObject selection, GameObject target, bool shouldDestroy)
}
public BirthdayBalloonHandler : MonoBehaviour {
public float checkOffset
public float checkRadius
}
public BlackjackMachine : BaseCardGameEntity {
private GameObjectRef mainScreenPrefab
private GameObjectRef smallScreenPrefab
private Transform mainScreenParent
private Transform[] smallScreenParents
private int _maxbet
private BlackjackController controller
private BlackjackMainScreenUI mainScreenUI
private BlackjackSmallScreenUI[] smallScreenUIs
public int maxbet
protected float MaxStorageInteractionDist
public int get_maxbet()
public void set_maxbet(int value)
protected float get_MaxStorageInteractionDist()
public void InitShared()
public void Load(LoadInfo info)
public void PlayerStorageChanged()
}
public BlackjackMainScreenUI : FacepunchBehaviour {
private Canvas inGameDisplay
private Canvas notInGameDisplay
private Sprite faceNeutral
private Sprite faceShocked
private Sprite faceSad
private Sprite faceCool
private Sprite faceHappy
private Sprite faceLove
private Image faceInGame
private Image faceNotInGame
private Sprite[] faceNeutralVariants
private Sprite[] faceHalloweenVariants
private RustText cardCountText
private RustText payoutText
private RustText insuranceText
private Canvas placeBetsCanvas
private HorizontalLayoutGroup cardsLayout
private BlackjackScreenCardUI[] cards
private Phrase phraseBust
}
public BlackjackScreenCardUI : FacepunchBehaviour {
private Canvas baseCanvas
private Canvas cardFront
private Canvas cardBack
private Image image
private RustText text
private Sprite heartSprite
private Sprite diamondSprite
private Sprite spadeSprite
private Sprite clubSprite
}
public BlackjackScreenInputUI : MonoBehaviour {
private Canvas availableOption
private Canvas unavailableOption
private RustText availableOptionText
}
public BlackjackSmallScreenUI : FacepunchBehaviour {
private Canvas notInGameDisplay
private Canvas inGameDisplay
private RustText cardCountText
private RustText betText
private RustText splitBetText
private RustText insuranceText
private RustText bankText
private RustText splitText
private Canvas infoTextCanvas
private RustText inGameText
private RustText notInGameText
private HorizontalLayoutGroup cardsLayout
private BlackjackScreenCardUI[] cards
private BlackjackScreenInputUI[] inputs
private Phrase phraseBust
private Phrase phraseBet
private Phrase phrasePlaceYourBet
private Phrase phraseStandoff
private Phrase phraseYouWin
private Phrase phraseYouLose
private Phrase phraseWaitingForOtherPlayers
private Phrase phraseAddFunds
private Phrase phraseWaitingForPlayer
private Phrase phraseSplitStored
private Phrase phraseSplitActive
private Phrase phraseHand
}
public BlackjackUI : MonoBehaviour {
private Image[] playerCardImages
private Image[] dealerCardImages
private Image[] splitCardImages
private Image[] playerCardBackings
private Image[] dealerCardBackings
private Image[] splitCardBackings
private CardGamePlayerWidget[] playerWidgets
private GameObject dealerValueObj
private RustText dealerValueText
private GameObject yourValueObj
private RustText yourValueText
private Phrase phrasePlaceYourBet
private Phrase phraseHit
private Phrase phraseStand
private Phrase phraseSplit
private Phrase phraseDouble
private Phrase phraseInsurance
private Phrase phraseBust
private Phrase phraseBlackjack
private Phrase phraseStandoff
private Phrase phraseYouWin
private Phrase phraseYouLose
private Phrase phraseWaitingForOtherPlayers
private Phrase phraseHand
private Phrase phraseInsurancePaidOut
private Sprite insuranceIcon
private Sprite noIcon
private Color bustTextColour
}
public BlendedEngineLoopDefinition : ScriptableObject {
public EngineLoopDefinition[] engineLoops
public float minRPM
public float maxRPM
public float RPMChangeRateUp
public float RPMChangeRateDown
}
public BlendedLoopEngineSound : MonoBehaviour {
public BlendedEngineLoopDefinition loopDefinition
public bool engineOn
public float RPMControl
public float smoothedRPMControl
private EngineLoop[] engineLoops
public bool debugPlayImmediately
public float maxDistance
public EngineLoop[] GetEngineLoops()
public float GetLoopGain(int idx)
public float GetLoopPitch(int idx)
public float get_maxDistance()
}
public BlendedSoundLoops : MonoBehaviour {
public float blend
public float blendSmoothing
public float loopFadeOutTime
public float loopFadeInTime
public float gainModSmoothing
public float pitchModSmoothing
public bool shouldPlay
public float gain
public List`1<Loop> loops
public float maxDistance
}
public BlendedSoundLoopSpeedControl : MonoBehaviour {
public BlendedSoundLoops loops
public float speed
public float speedMax
}
public BlendModeType : Enum {
public int value__
public BlendModeType Screen
public BlendModeType Add
}
public BlendShapeController : MonoBehaviour {
public SkinnedMeshRenderer TargetRenderer
public BlendState[] States
public float LerpSpeed
public BlendMode CurrentMode
}
public BlendTexture : ProcessedTexture {
public void .ctor(int width, int height, bool linear)
public void Blend(Texture source, Texture target, float alpha)
public void CopyTo(BlendTexture target)
}
public BlueprintButton : MonoBehaviour {
public Image image
public Image imageFavourite
public Button button
public CanvasGroup group
public GameObject newNotification
public GameObject lockedOverlay
public Tooltip Tip
public Image FavouriteIcon
public PingWidget TutorialHighlight
}
public BlueprintCategoryButton : MonoBehaviour {
public TextMeshProUGUI amountLabel
public ItemCategory Category
public bool AlwaysShow
public bool ShowItemCount
public GameObject BackgroundHighlight
public SoundDefinition clickSound
public SoundDefinition hoverSound
public PingWidget tutorialHighlight
}
public BlueprintCraftGridRow : MonoBehaviour {
public GameObject amount
public GameObject itemName
public GameObject total
public GameObject have
public Color colorOK
public Color colorBad
}
public BlueprintHeader : MonoBehaviour {
public Text categoryName
public Text unlockCount
public void Setup(ItemCategory name, int unlocked, int total)
}
public BlueprintInformationPanel : ItemInformationPanel {
public GameObject LearnedRoot
public GameObject NotLearnedRoot
public GameObject NotLearnableRoot
}
public BlurManager : MonoBehaviour {
public PostProcessVolume postProcessVolume
}
public BlurOptimized : PostProcessEffectSettings {
public FixedIntParameter downsample
public FixedIntParameter blurIterations
public FloatParameter blurSize
public FloatParameter fadeToBlurDistance
public BlurTypeParameter blurType
}
public BlurOptimizedRenderer : PostProcessEffectRenderer`1<BlurOptimized> {
private int dataProperty
private Shader blurShader
public void Init()
public void Render(PostProcessRenderContext context)
}
public BlurTexture : ProcessedTexture {
public void .ctor(int width, int height, bool linear)
public void Blur(float radius)
public void Blur(Texture source, float radius)
}
public BlurType : Enum {
public int value__
public BlurType StandardGauss
public BlurType SgxGauss
}
public Boar : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public BobberPreview : MonoBehaviour {
public Material ValidMaterial
public Material InvalidMaterial
public MeshRenderer TargetRenderer
}
public BoneDictionary : object {
public Transform transform
public Transform[] transforms
public String[] names
private Dictionary`2<string, Transform> nameDict
private Dictionary`2<UInt32, Transform> hashDict
private Dictionary`2<Transform, UInt32> transformDict
public int Count
public int get_Count()
public void .ctor(Transform rootBone)
public void .ctor(Transform rootBone, Transform[] boneTransforms, String[] boneNames)
private void BuildBoneDictionary()
public Transform FindBone(string name, bool defaultToRoot)
public Transform FindBone(UInt32 hash, bool defaultToRoot)
public UInt32 FindBoneID(Transform transform)
}
public BoneRetarget : MonoBehaviour {
public bool preserveInFirstPerson
public bool restoreBeforePooling
}
public BoomBox : EntityComponent`1<BaseEntity> {
public AudioSource SoundSource
public float ConditionLossRate
public ItemDefinition[] ValidCassettes
public SoundDefinition PlaySfx
public SoundDefinition StopSfx
public Flags HasCassette
public int BacktrackLength
public Action`1<float> HurtCallback
public Dictionary`2<string, string> ValidStations
public Dictionary`2<string, string> ServerValidStations
public string ServerUrlList
public string lastParsedServerList
public ShoutcastStreamer ShoutcastStreamer
public GameObjectRef RadioIpDialog
private string <CurrentRadioIp>k__BackingField
public ulong AssignedRadioBy
public BaseEntity BaseEntity
private bool isClient
public string CurrentRadioIp
public void ClearRadioByUser(Arg arg)
public BaseEntity get_BaseEntity()
public void ServerTogglePlay(RPCMessage msg)
public void DeductCondition()
public void ServerTogglePlay(bool play)
public void OnCassetteInserted(Cassette c)
public void OnCassetteRemoved(Cassette c)
public bool IsPowered()
public bool IsOn()
public bool HasFlag(Flags f)
public void SetFlag(Flags f, bool state)
private bool get_isClient()
public void LoadStations()
public Dictionary`2<string, string> GetStationData()
public bool IsStationValid(string url)
public void ParseServerUrlList()
public string get_CurrentRadioIp()
public void set_CurrentRadioIp(string value)
public void Server_UpdateRadioIP(RPCMessage msg)
public void Save(SaveInfo info)
public bool ClearRadioByUserId(ulong id)
public void Load(LoadInfo info)
}
public Bootstrap : SingletonComponent`1<Bootstrap> {
internal bool bootstrapInitRun
public bool isErrored
public string messageString
public CanvasGroup BootstrapUiCanvas
public GameObject errorPanel
public TextMeshProUGUI errorText
public TextMeshProUGUI statusText
private string lastWrittenValue
public bool needsSetup
public bool isPresent
public bool get_needsSetup()
public bool get_isPresent()
public void RunDefaults()
public void Init_Tier0()
public void Init_Systems()
public void Init_Config()
public void NetworkInitRaknet()
public void NetworkInitSteamworks(bool enableSteamDatagramRelay)
private IEnumerator Start()
private IEnumerator DedicatedServerStartup()
private void EnsureRootFolderCreated()
public IEnumerator StartNexusServer()
public IEnumerator StartServer(bool doLoad, string saveFileOverride, bool allowOutOfDateSaves)
private void StartupShared()
public void ThrowError(string error)
public void ExitGame()
public IEnumerator LoadingUpdate(string str)
public void WriteToLog(string str)
}
public BossFormController : ArcadeEntityController {
public float animationSpeed
public Sprite[] animationFrames
public Vector2 roamDistance
public Transform colliderParent
public BossDamagePoint[] damagePoints
public ArcadeEntityController flashController
public float health
}
public BoundsCheck : PrefabAttribute {
public BlockType IsType
protected Type GetIndexedType()
}
public BoundsCheckEx : object {
public bool ApplyBoundsChecks(BaseEntity entity, BoundsCheck[] bounds, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer)
}
public BoundsEx : object {
private Vector3[] pts
public Bounds XZ3D(Bounds bounds)
public Bounds Transform(Bounds bounds, Matrix4x4 matrix)
public Rect ToScreenRect(Bounds b, Camera cam)
public Rect ToCanvasRect(Bounds b, RectTransform target, Camera cam)
public float InnerDistToEdge2D(Bounds b, Vector3 point)
public float MaxExtent(Bounds b)
}
public BowWeapon : BaseProjectile {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void BowReload(RPCMessage msg)
public bool ForceSendMagazine(SaveInfo saveInfo)
}
public BoxStorage : StorageContainer {
public Vector3 GetDropPosition()
public bool SupportsChildDeployables()
public bool CanPickup(BasePlayer player)
}
public BradleyAPC : BaseCombatEntity {
public BlendedLoopEngineSound engineSound
public SoundDefinition treadLoopDef
public AnimationCurve treadGainCurve
public AnimationCurve treadPitchCurve
public AnimationCurve treadFreqCurve
private Sound treadLoop
private Modulator treadGain
private Modulator treadPitch
public SoundDefinition chasisLurchSoundDef
public float chasisLurchAngleDelta
public float chasisLurchSpeedDelta
public float lastAngle
public float lastSpeed
public SoundDefinition turretTurnLoopDef
public float turretLoopGainSpeed
public float turretLoopPitchSpeed
public float turretLoopMinAngleDelta
public float turretLoopMaxAngleDelta
public float turretLoopPitchMin
public float turretLoopPitchMax
public float turretLoopGainThreshold
private Sound turretTurnLoop
private Modulator turretTurnLoopGain
private Modulator turretTurnLoopPitch
public float enginePitch
public float rpmMultiplier
private TreadAnimator treadAnimator
public WheelCollider[] leftWheels
public WheelCollider[] rightWheels
public float moveForceMax
public float brakeForce
public float turnForce
public float sideStiffnessMax
public float sideStiffnessMin
public Transform centerOfMass
public float stoppingDist
public float throttle
public float turning
public float rightThrottle
public float leftThrottle
public bool brake
public Rigidbody myRigidBody
public Collider myCollider
public Vector3 destination
public Vector3 finalDestination
public Transform followTest
public TriggerHurtEx impactDamager
public Transform mainTurretEyePos
public Transform mainTurret
public Transform CannonPitch
public Transform CannonMuzzle
public Transform coaxPitch
public Transform coaxMuzzle
public Transform topTurretEyePos
public Transform topTurretYaw
public Transform topTurretPitch
public Transform topTurretMuzzle
public GameObjectRef SmokeGrenadePrefab
public Vector3 turretAimVector
public Vector3 desiredAimVector
public Vector3 topTurretAimVector
public Vector3 desiredTopTurretAimVector
public GameObjectRef explosionEffect
public GameObjectRef servergibs
public GameObjectRef fireBall
public GameObjectRef crateToDrop
public GameObjectRef debrisFieldMarker
public int maxCratesToSpawn
public int patrolPathIndex
public IAIPath patrolPath
public bool DoAI
public GameObjectRef mainCannonMuzzleFlash
public GameObjectRef mainCannonProjectile
public float recoilScale
public NavMeshPath navMeshPath
public int navMeshPathIndex
private LayerMask obstacleHitMask
private TimeSince timeSinceSeemingStuck
private TimeSince timeSinceStuckReverseStart
private string prefabPath
public float nextFireTime
public int numBursted
public float nextPatrolTime
public float nextEngagementPathTime
public float currentSpeedZoneLimit
public List`1<Vector3> currentPath
public int currentPathIndex
public bool pathLooping
public GameObject AIRoot
public GameObjectRef MonumentScientistPrefab
public GameObjectRef RoadScientistPrefab
public int ScientistSpawnCount
public float ScientistSpawnRadius
public List`1<GameObject> ScientistSpawnPoints
public List`1<ScientistSpawnGroup> ScientistSpawns
public bool SetScientistChaseBasedOnWeapon
public float DeployHealthRangeMin
public float DeployHealthRangeMax
public float DeployAttackDistanceMax
public float DeployInterval
public float DeployOnDamageCheckInterval
public float ScientistRedeploymentMinInterval
public float MountAfterNotAttackedDuration
public float MountAfterNotTargetsDuration
public float MountAfterNotFiredDuration
public bool UseSmokeGrenades
public bool KillScientistsOnBradleyDeath
public bool RoadSpawned
private List`1<ScientistNPC> activeScientists
private List`1<GameObjectRef> mountedScientistPrefabs
private List`1<Vector3> scientistSpawnPositions
private int numberOfScientistsToSpawn
private TimeSince timeSinceScientistDeploy
private TimeSince timeSinceDeployCheck
private TimeSince timeSinceValidTarget
private TimeSince deployedTimeSinceBradleyAttackedTarget
private int walkableAreaMask
private bool mountingScientists
private bool inDeployedState
private bool deployingScientists
private Dictionary`2<UInt32, GameObjectRef> scientistPrefabLookUp
public float viewDistance
public float searchRange
public float searchFrequency
public float memoryDuration
public float sightUpdateRate
public List`1<TargetInfo> targetList
public BaseCombatEntity mainGunTarget
public float coaxFireRate
public int coaxBurstLength
public float coaxAimCone
public float bulletDamage
public float topTurretFireRate
public float nextCoaxTime
public int numCoaxBursted
public float nextTopTurretTime
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public float lastLateUpdate
protected float PositionTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void BuildingCheck()
public void Save(SaveInfo info)
public BradleyAPC SpawnRoadDrivingBradley(Vector3 spawnPos, Quaternion spawnRot)
public string svspawnroadbradley(Vector3 pos, Vector3 dir)
public void SetDestination(Vector3 dest)
public void ServerInit()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public void Initialize()
public BasePlayer FollowPlayer()
public Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom)
protected float get_PositionTickRate()
public bool IsAtDestination()
public bool IsAtFinalDestination()
public Vector3 ClosestPointAlongPath(Vector3 start, Vector3 end, Vector3 fromPos)
public void FireGunTest()
public void InstallPatrolPath(IAIPath path)
public void UpdateMovement_Patrol()
public void UpdateMovement_Hunt()
public void DoSimpleAI()
private void SetTarget()
public void FixedUpdate()
private void AvoidObstacles(Single& throttleScaleFromTurn)
public void DoPhysicsMove()
public void ApplyBrakes(float amount)
public float GetMotorTorque(bool rightSide)
public void ScaleSidewaysFriction(float scale)
public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
public void ApplyBrakeTorque(float amount, bool rightSide)
public void CreateExplosionMarker(float durationMinutes)
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
public void Hurt(HitInfo info)
public void OnHealthChanged(float oldvalue, float newvalue)
public void DoHealing()
public BasePlayer GetPlayerDamageInitiator()
public float GetDamageMultiplier(BaseEntity ent)
public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
public bool HasPath()
public void ClearPath()
public bool IndexValid(int index)
public Vector3 GetFinalDestination()
public Vector3 GetCurrentPathDestination()
public bool PathComplete()
public bool AtCurrentPathNode()
public int GetLoopedIndex(int index)
public Vector3 PathDirection(int index)
public Vector3 IdealPathPosition()
public void AdvancePathMovement(bool force)
public bool GetPathToClosestTurnableNode(IAIPathNode start, Vector3 forward, List`1& nodes)
public bool GetEngagementPath(List`1& nodes)
private void CacheSpawnPrefabIDS()
private void TrySpawnScientists(BasePlayer triggeringPlayer)
private List`1<ScientistSpawnGroup> GetTriggereringSpawnGroups()
private void AddMountedScientistsToSpawn(List`1<GameObjectRef> scientists)
private void ClearMountedScientists()
private void AddSpawnGroupSpawns(List`1<ScientistSpawnGroup> spawnGroups, List`1<GameObjectRef> scientists)
private void SetSpawnGroupsAsSpawned(List`1<ScientistSpawnGroup> spawnGroups)
private void UpdateDeployed()
private bool UnableToFireAtPlayers()
private void UpdateMountScientists()
public int ActiveScientistCount()
public int AliveScientistCount()
private bool CanDeployScientists(BaseEntity attacker, List`1<GameObjectRef> scientistPrefabs, List`1<Vector3> spawnPositions)
private IEnumerator DeployScientists(BasePlayer triggerPlayer, List`1<GameObjectRef> scientistPrefabs, List`1<Vector3> spawnPositions)
private void SetDeployingScientists(bool flag)
private void SetMountingScientists(bool flag)
private ScientistNPC SpawnScientist(GameObjectRef scientistPrefab, Vector3 spawnPos, bool roadSpawned)
private void InitScientist(ScientistNPC scientist, Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing)
private void DropSmokeGrenade(Vector3 position, float duration)
private void KillSpawnedScientists()
private IEnumerator RecallSpawnedScientists()
public void OnScientistMounted(ScientistNPC scientist)
public void AddOrUpdateTarget(BaseEntity ent, Vector3 pos, float damageFrom)
public void UpdateTargetList()
public int SortTargets(TargetInfo t1, TargetInfo t2)
public Vector3 GetAimPoint(BaseEntity ent)
public bool VisibilityTest(BaseEntity ent)
public void UpdateTargetVisibilities()
public void DoWeaponAiming()
public void DoWeapons()
public void FireGun(Vector3 targetPos, float aimCone, bool isCoax)
public void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
public void AimWeaponAt(Transform weaponYaw, Transform weaponPitch, Vector3 direction, float minPitch, float maxPitch, float maxYaw, Transform parentOverride)
public void LateUpdate()
}
public BradleyMoveTest : MonoBehaviour {
public WheelCollider[] leftWheels
public WheelCollider[] rightWheels
public float moveForceMax
public float brakeForce
public float throttle
public float turnForce
public float sideStiffnessMax
public float sideStiffnessMin
public Transform centerOfMass
public float turning
public bool brake
public Rigidbody myRigidBody
public Vector3 destination
public float stoppingDist
public GameObject followTest
public void Awake()
public void Initialize()
public void SetDestination(Vector3 dest)
public void FixedUpdate()
public void ApplyBrakes(float amount)
public float GetMotorTorque(bool rightSide)
public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
public void ApplyBrakeTorque(float amount, bool rightSide)
public void AdjustFriction()
}
public BradleySpawner : MonoBehaviour {
public BasePath path
public GameObjectRef bradleyPrefab
public BradleyAPC spawned
public bool initialSpawn
public float minRespawnTimeMinutes
public float maxRespawnTimeMinutes
public BradleySpawner singleton
private bool pendingRespawn
public void Start()
public void DelayedStart()
public void CheckIfRespawnNeeded()
public void ScheduleRespawn()
public void DoRespawn()
public void SpawnBradley()
}
public Branding : BaseMonoBehaviour {
public TextMeshProUGUI versionText
public CanvasGroup canvasGroup
private string oldChangeId
}
public BucketVMFluidSim : MonoBehaviour {
public Animator waterbucketAnim
public ParticleSystem waterPour
public ParticleSystem waterTurbulence
public ParticleSystem waterFill
public float waterLevel
public float targetWaterLevel
public AudioSource waterSpill
}
public BuildingBlock : StabilityEntity {
public Construction blockDefinition
private Vector3[] outsideLookupOffsets
private bool forceSkinRefresh
private ulong lastSkinID
private int <modelState>k__BackingField
public int lastModelState
private UInt32 <customColour>k__BackingField
private UInt32 lastCustomColour
public UInt32 playerCustomColourToApply
public Enum grade
public Enum lastGrade
public ConstructionSkin currentSkin
private DeferredAction skinChange
private MeshRenderer placeholderRenderer
private MeshCollider placeholderCollider
public UpdateSkinWorkQueue updateSkinQueueServer
public Phrase RotateTitle
public Phrase RotateDesc
private bool globalNetworkCooldown
public bool CullBushes
public bool CheckForPipesOnModelChange
public OBBComponent AlternativePipeBounds
public bool CanBeDemolished
public int modelState
public UInt32 customColour
public ConstructionGrade currentGrade
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_CanBeDemolished()
public void ResetState()
public void InitShared()
public void PostInitShared()
public void DestroyShared()
public string Categorize()
public float BoundsPadding()
public bool IsOutside()
public bool SupportsChildDeployables()
public int get_modelState()
public void set_modelState(int value)
public UInt32 get_customColour()
private void set_customColour(UInt32 value)
public void SetConditionalModel(int state)
public bool GetConditionalModel(int index)
public ConstructionGrade get_currentGrade()
public bool CanChangeToGrade(Enum iGrade, ulong iSkin, BasePlayer player)
public bool HasUpgradePrivilege(Enum iGrade, ulong iSkin, BasePlayer player)
public bool IsUpgradeBlocked()
public bool CanAffordUpgrade(Enum iGrade, ulong iSkin, BasePlayer player)
public void SetGrade(Enum iGrade)
public void UpdateGrade()
protected void OnSkinChanged(ulong oldSkinID, ulong newSkinID)
protected void OnSkinPreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void SetHealthToMax()
public void DoUpgradeToGrade_Delayed(RPCMessage msg)
public void DoUpgradeToGrade(RPCMessage msg)
public void ChangeGradeAndSkin(Enum targetGrade, ulong skin, bool playEffect, bool updateSkin)
public void ChangeGrade(Enum targetGrade, bool playEffect, bool updateSkin)
public void PayForUpgrade(ConstructionGrade g, BasePlayer player)
public void SetCustomColour(UInt32 newColour)
public bool NeedsSkinChange()
public void UpdateSkin(bool force)
private void DestroySkin()
public void RefreshNeighbours(bool linkToNeighbours)
private void UpdatePlaceholder(bool state)
private void ChangeSkin()
public void ChangeSkin(GameObjectRef prefab)
public bool ShouldBlockProjectiles()
public void CheckForPipes()
private void OnHammered()
public float MaxHealth()
public List`1<ItemAmount> BuildCost()
public void OnHealthChanged(float oldvalue, float newvalue)
public float RepairCostFraction()
public bool CanRotate(BasePlayer player)
public bool IsRotatable()
public bool IsRotationBlocked()
public bool HasRotationPrivilege(BasePlayer player)
public void DoRotation(RPCMessage msg)
private void ResetGlobalNetworkCooldown()
public void StopBeingRotatable()
public void StartBeingRotatable()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void AttachToBuilding(DecayEntity other)
public void ServerInit()
public void Hurt(HitInfo info)
}
public BuildingBlockDecay : Decay {
private bool isFoundation
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public bool ShouldDecay(BaseEntity entity)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BuildingBlockedGuide : MonoBehaviour {
public Mesh BoxMesh
public Mesh SphereMesh
public Mesh CapsuleMesh
public MeshRenderer Renderer
public MeshFilter Filter
public Collider LargestVolume
}
public BuildingGrade : ScriptableObject {
public Enum type
public ulong skin
public bool enabledInStandalone
public bool alwaysUnlock
public float baseHealth
public List`1<ItemAmount> baseCost
public PhysicMaterial physicMaterial
public ProtectionProperties damageProtecton
public bool supportsColourChange
public Option upgradeMenu
}
public BuildingGradeDecay : Decay {
public Enum decayGrade
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public bool ShouldDecay(BaseEntity entity)
}
public BuildingManager : object {
public ServerBuildingManager server
public ListHashSet`1<DecayEntity> decayEntities
public ListDictionary`2<UInt32, Building> buildingDictionary
public Building GetBuilding(UInt32 buildingID)
public void Add(DecayEntity ent)
public void Remove(DecayEntity ent)
public void Clear()
protected Building CreateBuilding(UInt32 id)
protected void DisposeBuilding(Building& building)
}
public BuildingPrivilegeRetro : BuildingPrivlidge {
public BuildingPrivilegeRetroScreen screens
public GameObjectRef[] boxPrefabs
public GameObjectRef[] doubleBoxPrefabs
public int boxesAmount
public Transform boxesParent
public Vector3 boxSpacing
public ToolSetting[] toolSettings
public ToolModel[] toolCustomModels
public Material hammerOriginalMaterial
public void Save(SaveInfo info)
private float GetResourceProportion(int id)
public void Load(LoadInfo info)
}
public BuildingPrivilegeRetroScreen : FacepunchBehaviour {
private CanvasGroup screenCanvas
public RustText protectedTimeText
public int decayWarningThreshold
public GameObject decayWarningGroup
public GameObject decayingGroup
public VirtualItemIcon[] costIcons
public RustText[] paginationTexts
public GameObject[] blocksType
public RustText blockCountText
public RustText doorCountText
public Renderer screenRenderer
public Color fromScreenEmissionColor
public Color screenEmissionColor
public AnimationCurve tweenCurve
public float animDuration
public Animation screensAnim
public Screen[] screens
}
public BuildingPrivlidge : StorageContainer {
public GameObject assignDialog
public HashSet`1<PlayerNameID> authorizedPlayers
public Flags Flag_MaxAuths
public List`1<ItemDefinition> allowedConstructionItems
public float cachedProtectedMinutes
public float nextProtectedCalcTime
public UpkeepBracket[] upkeepBrackets
public List`1<ItemAmount> upkeepBuffer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public bool IsAuthed(BasePlayer player)
public bool IsAuthed(ulong userId)
public bool AnyAuthed()
public bool ItemFilter(Item item, int targetSlot)
public void Save(SaveInfo info)
public bool CanUseNetworkCache(Connection connection)
public void Load(LoadInfo info)
public void BuildingDirty()
public bool AtMaxAuthCapacity()
public void UpdateMaxAuthCapacity()
protected void OnInventoryDirty()
public void OnItemAddedOrRemoved(Item item, bool bAdded)
public void AddDelayedUpdate()
public void DelayedUpdate()
public bool CanAdministrate(BasePlayer player)
private void AddAuthorize(RPCMessage rpc)
public void AddPlayer(BasePlayer granter, ulong targetPlayerId)
public void RemoveSelfAuthorize(RPCMessage rpc)
public void ClearList(RPCMessage rpc)
public void RPC_Rotate(RPCMessage msg)
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
private void UnlinkDoorControllers()
public bool HasSlot(Slot slot)
public bool SupportsChildDeployables()
public float CalculateUpkeepPeriodMinutes()
public float CalculateUpkeepCostFraction()
public void CalculateUpkeepCostAmounts(List`1<ItemAmount> itemAmounts)
public float GetProtectedMinutes(bool force)
public void OnKilled(HitInfo info)
private void HandleKilledByClanMember(BasePlayer player)
public void DecayTick()
public bool EnsurePrimary()
public void MarkProtectedMinutesDirty(float delay)
public float CalculateBuildingTaxRate()
public void ApplyUpkeepPayment()
public void QueueUpkeepPayment(List`1<ItemAmount> itemAmounts)
public bool CanAffordUpkeepPayment(List`1<ItemAmount> itemAmounts)
public float PurchaseUpkeepTime(DecayEntity entity, float deltaTime)
public void PurchaseUpkeepTime(float deltaTime)
public string FormatUpkeepMinutes(float minutes)
}
public BuildingProximity : PrefabAttribute {
private float check_radius
private float check_forgiveness
private float foundation_width
private float foundation_extents
public bool Check(BasePlayer player, Construction construction, Vector3 position, Quaternion rotation)
public ProximityInfo GetProximity(Construction construction1, Vector3 position1, Quaternion rotation1, Construction construction2, Vector3 position2, Quaternion rotation2)
public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
protected Type GetIndexedType()
}
public Bulb : BaseBulb {
public MaterialSwap swap
}
public BunkerEntrance : BaseEntity {
public GameObjectRef portalPrefab
public GameObjectRef doorPrefab
public Transform portalSpawnPoint
public Transform doorSpawnPoint
public Door doorInstance
public BasePortal portalInstance
public void ServerInit()
public void MissionStarted(BasePlayer assignee, MissionInstance instance)
public void MissionEnded(BasePlayer assignee, MissionInstance instance)
}
public BunnyEntry : MonoBehaviour {
public Text nameText
public Text amountText
public RawImage starImage
public RawImage selfImage
}
public Buoyancy : ListComponent`1<Buoyancy> {
public BuoyancyPoint[] points
public GameObjectRef[] waterImpacts
public Rigidbody rigidBody
public float buoyancyScale
public bool scaleForceWithMass
public bool doEffects
public float flowMovementScale
public float requiredSubmergedFraction
public bool useUnderwaterDrag
public float underwaterDrag
public float wavesEffect
private float <timeOutOfWater>k__BackingField
public Action`1<bool> SubmergedChanged
public BaseEntity forEntity
public float submergedFraction
private BuoyancyPointData[] pointData
private bool initedPointArrays
private Vector2[] pointPositionArray
private Vector2[] pointPositionUVArray
private Vector3[] pointShoreVectorArray
private Single[] pointTerrainHeightArray
private Single[] pointWaterHeightArray
private float defaultDrag
private float defaultAngularDrag
private float timeInWater
public Nullable`1<float> ArtificialHeight
private BaseVehicle forVehicle
private bool hasLocalPlayers
private bool hadLocalPlayers
public float timeOutOfWater
public bool InWater
public float get_timeOutOfWater()
private void set_timeOutOfWater(float value)
public bool get_InWater()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void SavePointData()
public string DefaultWaterImpact()
private void Awake()
public void Sleep()
public void Wake()
public void CheckSleepState()
public bool ShouldWake()
public bool ShouldWake(bool hasLocalPlayers)
private bool HasLocalPlayers()
protected void DoCycle(bool forced)
public void Cycle()
public Vector3 GetFlowDirection(Vector2 posUV)
public void BuoyancyFixedUpdate()
private void InitPointArrays()
}
public BuoyancyPoint : MonoBehaviour {
public float buoyancyForce
public float size
public float waveScale
public float waveFrequency
public bool doSplashEffects
public float randomOffset
public bool wasSubmergedLastFrame
public float nexSplashTime
private Color gizmoColour
public void Start()
public void OnDrawGizmos()
}
public BurstClothCollider : MonoBehaviour {
public float Height
public float Radius
public CapsuleParams GetParams()
}
public BurstClothHitBoxCollision : BurstCloth {
public bool UseLocalGravity
public float GravityStrength
public float DefaultLength
public float MountedLengthMultiplier
public float DuckedLengthMultiplier
public float CorpseLengthMultiplier
public Transform UpAxis
public Transform ColliderRoot
public String[] IgnoreKeywords
protected void GatherColliders(List`1<CapsuleParams> colliders)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BushEntity : BaseEntity {
public GameObjectRef prefab
public bool globalBillboard
public void InitShared()
public void ServerInit()
internal void DoServerDestroy()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BUTTON : Enum {
public int value__
public BUTTON FORWARD
public BUTTON BACKWARD
public BUTTON LEFT
public BUTTON RIGHT
public BUTTON JUMP
public BUTTON DUCK
public BUTTON SPRINT
public BUTTON USE
public BUTTON FIRE_PRIMARY
public BUTTON FIRE_SECONDARY
public BUTTON RELOAD
public BUTTON FIRE_THIRD
}
public ButtonIcon : RustButton {
public Image Image
}
public ByteMap : object {
private int size
private int bytes
private Byte[] values
public int Size
public UInt32 Item
public void .ctor(int size, int bytes)
public void .ctor(int size, Byte[] values, int bytes)
public int get_Size()
public UInt32 get_Item(int x, int y)
public void set_Item(int x, int y, UInt32 value)
}
public ByteQuadtree : object {
private int size
private int levels
private ByteMap[] values
public int Size
public Element Root
public void UpdateValues(Byte[] baseValues)
public int get_Size()
public Element get_Root()
private ByteMap CreateLevel(int level)
}
public CableTunnel : IOEntity {
private int numChannels
private Int32[] inputAmounts
public bool WantsPower(int inputIndex)
public void IOStateChanged(int inputAmount, int inputSlot)
public void UpdateOutputs()
}
public CachedTransform`1 : ValueType {
public T component
public Vector3 position
public Quaternion rotation
public Vector3 localScale
public Matrix4x4 localToWorldMatrix
public Matrix4x4 worldToLocalMatrix
public Vector3 forward
public Vector3 up
public Vector3 right
public void .ctor(T instance)
public void Apply()
public void RotateAround(Vector3 center, Vector3 axis, float angle)
public Matrix4x4 get_localToWorldMatrix()
public Matrix4x4 get_worldToLocalMatrix()
public Vector3 get_forward()
public Vector3 get_up()
public Vector3 get_right()
public bool op_Implicit(CachedTransform`1<T> instance)
}
public CameraEx : MonoBehaviour {
public bool overrideAmbientLight
public AmbientMode ambientMode
public Color ambientGroundColor
public Color ambientEquatorColor
public Color ambientLight
public float ambientIntensity
public ReflectionProbe reflectionProbe
internal Color old_ambientLight
internal Color old_ambientGroundColor
internal Color old_ambientEquatorColor
internal float old_ambientIntensity
internal AmbientMode old_ambientMode
public float aspect
}
public CameraFocusMode : Enum {
public int value__
public CameraFocusMode Off
public CameraFocusMode Auto
public CameraFocusMode Manual
}
public CameraMan : SingletonComponent`1<CameraMan> {
public string DefaultSaveName
public string SavePositionExtension
public string SavePositionDirectory
public bool OnlyControlWhenCursorHidden
public bool NeedBothMouseButtonsToZoom
public float LookSensitivity
public float MoveSpeed
public float GuideAspect
public float GuideRatio
public Canvas canvas
public Graphic[] guides
}
public CameraSettings : MonoBehaviour {
private Camera cam
private void OnEnable()
private void Update()
}
public CameraTool : HeldEntity {
public GameObjectRef screenshotEffect
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void SVNoteScreenshot(RPCMessage msg)
}
public CameraUpdateHook : MonoBehaviour {
public Action PreCull
public Action PreRender
public Action PostRender
public Action RustCamera_PreRender
public float LastFrameFOV
private void Awake()
}
public CameraUtil : object {
public void NormalizePlane(Plane& plane)
public void ExtractPlanes(Camera camera, Plane[]& planes)
public void ExtractPlanes(Matrix4x4 viewProjMatrix, Plane[]& planes)
}
public CameraViewerId : ValueType {
public ulong SteamId
public long ConnectionId
public void .ctor(ulong steamId, long connectionId)
public bool Equals(CameraViewerId other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CameraViewerId left, CameraViewerId right)
public bool op_Inequality(CameraViewerId left, CameraViewerId right)
}
public CamperSeatConfig : MonoBehaviour {
public Transform[] SeatPositions
public Transform StovePosition
public Transform StoragePosition
}
public Candle : BaseCombatEntity {
public float lifeTimeSeconds
public float burnRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SetWantsOn(RPCMessage msg)
public void PostServerLoad()
public void UpdateInvokes()
public void Burn()
public void OnAttacked(HitInfo info)
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public void Ignite(Vector3 fromPos)
public bool CanIgnite()
}
public CanvasLOD : LODComponent {
public float Distance
}
public CanvasOrderHack : MonoBehaviour {
private void OnEnable()
}
public CapturePointTrigger : TriggerBase {
internal GameObject InterestedInObject(GameObject obj)
}
public CardGamePlayerStorage : StorageContainer {
private EntityRef cardTableRef
public BaseCardGameEntity GetCardGameEntity()
public void Load(LoadInfo info)
protected void OnInventoryDirty()
public void Save(SaveInfo info)
public void SetCardTable(BaseCardGameEntity cardGameEntity)
}
public CardGamePlayerWidget : MonoBehaviour {
private GameObjectRef cardImageSmallPrefab
private RawImage avatar
private RustText playerName
private RustText scrapTotal
private RustText betText
private Image background
private Color inactiveBackground
private Color activeBackground
private Color foldedBackground
private Color winnerBackground
private Animation actionShowAnimation
private RustText actionText
private Sprite canSeeIcon
private Sprite cannotSeeIcon
private Sprite blankSprite
private Image cornerIcon
private Transform cardDisplayParent
private GridLayoutGroup cardDisplayGridLayout
private GameObject circle
private RustText circleText
}
public CardGameSounds : PrefabAttribute {
public SoundDefinition ChipsSfx
public SoundDefinition DrawSfx
public SoundDefinition PlaySfx
public SoundDefinition ShuffleSfx
public SoundDefinition WinSfx
public SoundDefinition LoseSfx
public SoundDefinition YourTurnSfx
public SoundDefinition CheckSfx
public SoundDefinition HitSfx
public SoundDefinition StandSfx
public SoundDefinition BetSfx
public SoundDefinition IncreaseBetSfx
public SoundDefinition DecreaseBetSfx
public SoundDefinition AllInSfx
public SoundDefinition UIInteractSfx
public SoundDefinition DealerCoolSfx
public SoundDefinition DealerHappySfx
public SoundDefinition DealerLoveSfx
public SoundDefinition DealerSadSfx
public SoundDefinition DealerShockedSfx
protected Type GetIndexedType()
public void PlaySound(SoundType sound, GameObject forGameObject)
}
public CardGameUI : UIDialog {
private InfoTextUI primaryInfo
private InfoTextUI secondaryInfo
private InfoTextUI playerLeaveInfo
private GameObject playingUI
private PlayingCardImage[] cardImages
private CardInputWidget[] inputWidgets
private RustSlider dismountProgressSlider
private Phrase phraseLoading
private Phrase phraseWaitingForNextRound
private Phrase phraseNotEnoughPlayers
private Phrase phrasePlayerLeftGame
private Phrase phraseNotEnoughBuyIn
private Phrase phraseTooMuchBuyIn
public Phrase phraseYourTurn
public Phrase phraseYouWinTheRound
public Phrase phraseRoundWinner
public Phrase phraseRoundWinners
public Phrase phraseScrapWon
public Phrase phraseScrapReturned
public Phrase phraseChangeBetAmount
public Phrase phraseBet
public Phrase phraseBetAdd
public Phrase phraseAllIn
public GameObject amountChangeRoot
public RustText amountChangeText
public Color colourNeutralUI
public Color colourGoodUI
public Color colourBadUI
private CanvasGroup timerCanvas
private RustSlider timerSlider
private UIChat chat
private HudElement Hunger
private HudElement Thirst
private HudElement Health
private HudElement PendingHealth
public Sprite cardNone
public Sprite cardBackLarge
public Sprite cardBackSmall
private Sprite cardBackLargeStatic
private Sprite cardBackSmallStatic
private TexasHoldEmUI texasHoldEmUI
private BlackjackUI blackjackUI
}
public CardInputWidget : MonoBehaviour {
public RustText InputText
public RustText ActionText
public RustText ExtraText
}
public CardReader : IOEntity {
public float accessDuration
public int accessLevel
public GameObjectRef accessGrantedEffect
public GameObjectRef accessDeniedEffect
public GameObjectRef swipeEffect
public Transform audioPosition
public Flags AccessLevel1
public Flags AccessLevel2
public Flags AccessLevel3
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void CancelAccess()
public void FailCard()
public void ServerInit()
public void GrantCard()
public void ServerCardSwiped(RPCMessage msg)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public CardTable : BaseCardGameEntity {
private ViewModel viewModel
private PlayingCardImage[] tableCards
private Renderer[] tableCardBackings
private Canvas cardUICanvas
private Image[] tableCardImages
private Sprite blankCard
private ChipStack[] chipStacks
private ChipStack[] fillerStacks
protected float MaxStorageInteractionDist
public void Load(LoadInfo info)
protected float get_MaxStorageInteractionDist()
}
public CardTableSeat : BaseChair {
public Transform CardsMesh
}
public CargoMoveTest : FacepunchBehaviour {
public int targetNodeIndex
private float currentThrottle
private float turnScale
private void Awake()
public void FindInitialNode()
private void Update()
public void UpdateMovement()
public int GetClosestNodeToUs()
public void OnDrawGizmosSelected()
}
public CargoNotifier : MonoBehaviour {
private BasePath cargoPath
private void Start()
}
public CargoPlane : BaseEntity {
public GameObjectRef prefabDrop
public SpawnFilter filter
public Vector3 startPos
public Vector3 endPos
public float secondsToTake
public float secondsTaken
public bool dropped
public Vector3 dropPosition
public void ServerInit()
public void PostServerLoad()
private void Initialize()
public void InitDropPosition(Vector3 newDropPosition)
public Vector3 RandomDropPosition()
public void UpdateDropPosition(Vector3 newDropPosition)
private void Update()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public CargoShip : BaseEntity {
public int targetNodeIndex
public GameObject wakeParent
public GameObjectRef scientistTurretPrefab
public Transform[] scientistSpawnPoints
public List`1<Transform> crateSpawns
public GameObjectRef lockedCratePrefab
public GameObjectRef militaryCratePrefab
public GameObjectRef eliteCratePrefab
public GameObjectRef junkCratePrefab
public Transform waterLine
public Transform rudder
public Transform propeller
public GameObjectRef escapeBoatPrefab
public Transform escapeBoatPoint
public GameObjectRef microphonePrefab
public Transform microphonePoint
public GameObjectRef speakerPrefab
public Transform[] speakerPoints
public GameObject radiation
public GameObjectRef mapMarkerEntityPrefab
public GameObject hornOrigin
public SoundDefinition hornDef
public CargoShipSounds cargoShipSounds
public GameObject[] layouts
public GameObjectRef playerTest
public Transform bowPoint
private UInt32 layoutChoice
public Flags IsDocked
public Flags HasDocked
public Flags DockedHarborIndex0
public Flags DockedHarborIndex1
public Flags Egressing
public bool docking_debug
public bool should_dock
public float dock_time
public bool event_enabled
public float event_duration_minutes
public float egress_duration_minutes
public int loot_rounds
public float loot_round_spacing_minutes
public bool refresh_loot_on_dock
public List`1<HarborInfo> harbors
public int currentHarborApproachNode
public int harborIndex
public bool isDoingHarborApproach
private int dockCount
private bool shouldLookAhead
private float lifetime
private CargoShipContainerDestination[] containerDestinations
private HashSet`1<ulong> boardedPlayerIds
public bool hasCalculatedApproaches
public BaseEntity mapMarkerInstance
public Vector3 currentVelocity
public float currentThrottle
public float currentTurnSpeed
public float turnScale
public int lootRoundsPassed
public int hornCount
public float currentRadiation
public bool egressing
public BasePath harborApproachPath
public HarborProximityManager proxManager
private float lastSpeed
public bool IsShipDocked
public int TotalAvailableHarborDockingPaths
private bool HasFinishedDocking
private float EventTimeRemaining
public bool get_IsShipDocked()
public int get_TotalAvailableHarborDockingPaths()
public List`1<Vector3> GetCargoApproachPath(int index)
public float GetNetworkTime()
public void debug_info(Arg arg)
public void debug_cargo_status(Arg arg)
public void Load(LoadInfo info)
public void RefreshActiveLayout()
public void RegisterHarbor(BasePath path, Transform tf)
public void TriggeredEventSpawn()
public void TriggeredEventSpawnDockingTest(int index)
private void CalculateHarborApproachNodes()
public void OnArrivedAtHarbor()
private void ClearAllHarborEntitiesOnShip()
public void CreateMapMarker()
public void DisableCollisionTest()
public void SpawnCrate(string resourcePath)
public void RespawnLoot()
public void SpawnSubEntities()
protected void OnChildAdded(BaseEntity child)
public void Save(SaveInfo info)
public void PostServerLoad()
public void PlayHorn()
public void Spawn()
public void ServerInit()
public void UpdateRadiation()
public void StartEgress()
public void DelayedDestroy()
public void FindInitialNode()
private int GetHackableCrateCount()
public void BuildingCheck()
public void FixedUpdate()
public void UpdateMovement()
public void Break()
private void UpdateShip(float desiredThrottle, Vector3 desiredWaypoint, Vector3 approachRotationNode)
private void UpdateHarborApproachProgress()
private void InitializeHarborApproach(bool forceInit)
private float CalculateDesiredThrottle(Vector3 desiredMoveNode)
private void CalculateDesiredNodes(Vector3& desiredMoveNode, Vector3& approachRotationNode)
private bool get_HasFinishedDocking()
private void HandleNodeArrival(Vector3 waypointPosition)
public void StartHarborApproach(CargoNotifier cn)
private float GetTimeRemainingFromCrates()
private void EndHarborApproach()
private float get_EventTimeRemaining()
private void AdvanceHarborApproach()
private bool IsOceanPatrolPathAvailable()
private bool IsValidTargetNode()
private void PreHarborLeaveHorn()
private void LeaveHarbor()
public int GetClosestNodeToUs()
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public float InheritedVelocityScale()
public bool BlocksWaterFor(BasePlayer player)
public float MaxVelocity()
public bool SupportsChildDeployables()
public bool ForceDeployableSetParent()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public CargoShipContainer : BaseEntity {
public GameObject[] DressingVariants
public Flags Descending
public Flags Targeted
private int dressingVariant
public float MaxVelocity()
public void PreInitShared()
public void ServerInit()
public void PostMapEntitySpawn()
public void Save(SaveInfo info)
private void AssignVariant()
public void ToggleHurtCollider(bool state)
public void SetTargeted(bool state)
public void Load(LoadInfo info)
private void UpdateDressingVariant()
}
public CargoShipContainerSounds : FacepunchBehaviour {
public SoundDefinition liftDef
public SoundDefinition dropDef
}
public CargoShipDevTrigger : MonoBehaviour {
public float TimeTrigger
}
public CargoShipInteriorSoundTrigger : MonoBehaviour {
public CargoShipSounds cargoShipSounds
}
public CargoShipSounds : MonoBehaviour {
public CargoShip cargoShip
public SoundDefinition waveSoundDef
public AnimationCurve waveSoundYGainCurve
public AnimationCurve waveSoundEdgeDistanceGainCurve
private Sound waveSoundL
private Sound waveSoundR
private Modulator waveSoundLGainMod
private Modulator waveSoundRGainMod
public SoundDefinition sternWakeSoundDef
private Sound sternWakeSound
private Modulator sternWakeSoundGainMod
public SoundDefinition idleWaveSoundDef
public SoundDefinition engineHumSoundDef
private Sound engineHumSound
private Modulator enginePitchMod
public GameObject engineHumTarget
public float enginePitchChangeSpeed
public SoundDefinition hugeRumbleSoundDef
public AnimationCurve hugeRumbleYDiffCurve
public AnimationCurve hugeRumbleRelativeSpeedCurve
private Sound hugeRumbleSound
private Modulator hugeRumbleGainMod
private Vector3 lastCameraPos
private Vector3 lastRumblePos
private Vector3 lastRumbleLocalPos
public Collider soundFollowCollider
public Collider soundFollowColliderL
public Collider soundFollowColliderR
public Collider sternSoundFollowCollider
public SoundDefinition metalGroanSoundDef
public float metalGroanMinInterval
public float metalGroanMaxInterval
}
public CarPhysics`1 : object {
private float <DriveWheelVelocity>k__BackingField
private float <DriveWheelSlip>k__BackingField
private float <SteerAngle>k__BackingField
private float <TankThrottleLeft>k__BackingField
private float <TankThrottleRight>k__BackingField
private ServerWheelData[] wheelData
private TCar car
private Transform transform
private Rigidbody rBody
private CarSettings vehicleSettings
private float speedAngle
private bool wasSleeping
private bool hasDriver
private bool hadDriver
private float steerLerpSpeed
private float lastMovingTime
private WheelFrictionCurve zeroFriction
private Vector3 prevLocalCOM
private float midWheelPos
private bool WHEEL_HIT_CORRECTION
private float SLEEP_SPEED
private float SLEEP_DELAY
private float AIR_DRAG
private float DEFAULT_GROUND_GRIP
private float ROAD_GROUND_GRIP
private float ICE_GROUND_GRIP
private bool slowSpeedExitFlag
private float SLOW_SPEED_EXIT_SPEED
public TimeSince timeSinceWaterCheck
public float DriveWheelVelocity
public float DriveWheelSlip
public float SteerAngle
public float TankThrottleLeft
public float TankThrottleRight
private bool InSlowSpeedExitMode
public float get_DriveWheelVelocity()
private void set_DriveWheelVelocity(float value)
public float get_DriveWheelSlip()
private void set_DriveWheelSlip(float value)
public float get_SteerAngle()
private void set_SteerAngle(float value)
public float get_TankThrottleLeft()
private void set_TankThrottleLeft(float value)
public float get_TankThrottleRight()
private void set_TankThrottleRight(float value)
private bool get_InSlowSpeedExitMode()
public void .ctor(TCar car, Transform transform, Rigidbody rBody, CarSettings vehicleSettings)
public void FixedUpdate(float dt, float speed)
public bool IsGrounded()
private void COMChanged()
private void ComputeSteerAngle(float throttleInput, float steerInput, float dt, float speed)
private float GetWheelForceDistance(WheelCollider col)
private void UpdateSuspension(ServerWheelData<TCar> wd)
private void AdjustHitForces(int groundedWheels, float neutralForcePerWheel)
private void UpdateLocalFrame(ServerWheelData<TCar> wd, float dt)
private void ComputeTyreForces(ServerWheelData<TCar> wd, float speed, float maxDriveForce, float maxSpeed, float throttleInput, float steerInput, float brakeInput, float driveForceMultiplier)
private void ComputeTankSteeringThrottle(float throttleInput, float steerInput, float speed)
private float ComputeDriveForce(float speed, float absSpeed, float demandedForce, float maxForce, float maxForwardSpeed, float driveForceMultiplier)
private void ComputeOverallForces()
private float ComputeCombinedSlip(Vector2 localVelocity, Vector2 tyreSlip)
private void ApplyTyreForces(ServerWheelData<TCar> wd)
private Vector3 GetSidewaysForceAppPoint(ServerWheelData<TCar> wd, Vector3 contactPoint)
private float GetTankSteerInvert(float throttleInput, float speed)
private ServerWheelData<TCar> <.ctor>g__AddWheel|48_0(CarWheel wheel, <>c__DisplayClass48_0& )
}
public CarSettings : object {
public float rollingResistance
public float antiRoll
public bool canSleep
public bool tankSteering
public float maxSteerAngle
public bool steeringAssist
public float steeringAssistRatio
public bool steeringLimit
public float minSteerLimitAngle
public float minSteerLimitSpeed
public float rearWheelSteer
public float steerMinLerpSpeed
public float steerMaxLerpSpeed
public float steerReturnLerpSpeed
public bool retainLerpSpeed
public float maxDriveSlip
public float driveForceToMaxSlip
public float reversePercentSpeed
public float brakeForceMultiplier
public float handlingBias
}
public CarvablePumpkin : BaseOven {
private List`1<ulong> editHistory
private float TextureRequestTimeout
public GameObjectRef changeTextDialog
public MeshPaintableSource[] paintableSources
public UInt32[] textureIDs
public Type FileType
public NetworkableId NetworkID
public UGCType ContentType
public List`1<ulong> EditingHistory
public UInt32[] GetContentCRCs
public bool ShouldTransferAssociatedFiles
public BaseNetworkable UgcEntity
public Vector2i TextureSize
public int TextureCount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Type get_FileType()
public UInt32[] GetTextureCRCs()
public NetworkableId get_NetworkID()
public bool CanUpdateSign(BasePlayer player)
public bool CanUnlockSign(BasePlayer player)
public bool CanLockSign(BasePlayer player)
public void Load(LoadInfo info)
public UGCType get_ContentType()
public void LockSign(RPCMessage msg)
public void UnLockSign(RPCMessage msg)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public bool ShouldNetworkOwnerInfo()
public void SetTextureCRCs(UInt32[] crcs)
public List`1<ulong> get_EditingHistory()
private void LogEdit(BasePlayer byPlayer)
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public bool get_ShouldTransferAssociatedFiles()
public BaseNetworkable get_UgcEntity()
public string Categorize()
public Vector2i get_TextureSize()
public int get_TextureCount()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void UpdateSign(RPCMessage msg)
public void EnsureInitialized()
private void SignDebugLog(string str)
}
public CarWheel : object {
public WheelCollider wheelCollider
public float tyreFriction
public bool steerWheel
public bool brakeWheel
public bool powerWheel
}
public Cassette : BaseEntity {
public float MaxCassetteLength
public float MaxCassetteFileSizeMB
private UInt32 <AudioId>k__BackingField
public ulong CreatorSteamId
public PreloadType PreloadType
public PreloadedCassetteContent PreloadContent
public SoundDefinition InsertCassetteSfx
public int ViewmodelIndex
public Sprite HudSprite
public int MaximumVoicemailSlots
public int preloadedAudioId
public ICassettePlayer currentCassettePlayer
public UInt32 AudioId
public SoundDefinition PreloadedAudio
public bool ShouldTransferAssociatedFiles
public UInt32[] GetContentCRCs
public UGCType ContentType
public List`1<ulong> EditingHistory
public BaseNetworkable UgcEntity
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ClearCassettes(Arg arg)
public void ClearCassettesByUser(Arg arg)
public UInt32 get_AudioId()
private void set_AudioId(UInt32 value)
public SoundDefinition get_PreloadedAudio()
public void Load(LoadInfo info)
public void AssignPreloadContent()
public bool get_ShouldTransferAssociatedFiles()
public void Save(SaveInfo info)
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
public void DelayedCassetteInserted()
public void SetAudioId(UInt32 id, ulong userId)
public void Server_MakeNewFile(RPCMessage msg)
public bool ClearSavedAudio()
internal void DoServerDestroy()
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public UGCType get_ContentType()
public List`1<ulong> get_EditingHistory()
public BaseNetworkable get_UgcEntity()
public bool IsOggValid(Byte[] data, Cassette c)
public bool IsOggValid(Byte[] data, float maxLength)
public float ByteToMegabyte(int byteSize)
public double GetOggLength(Byte[] t)
}
public CassettePanel : NotePanel {
public GameObject[] CassetteSprites
}
public Cathode : PostProcessEffectSettings {
public FloatParameter intensity
public IntParameter downscale
public IntParameter downscaleTemporal
public FloatParameter horizontalBlur
public FloatParameter verticalBlur
public FloatParameter chromaSubsampling
public FloatParameter sharpen
public FloatParameter sharpenRadius
public FloatParameter colorNoise
public FloatParameter restlessFoot
public FloatParameter footAmplitude
public FloatParameter chromaIntensity
public FloatParameter chromaInstability
public FloatParameter chromaOffset
public FloatParameter responseCurve
public FloatParameter saturation
public FloatParameter cometTrailing
public FloatParameter burnIn
public FloatParameter tapeDust
public FloatParameter wobble
public Vector2Parameter blackWhiteLevels
public Vector2Parameter dynamicRange
public FloatParameter whiteBallance
}
public CathodeRenderer : PostProcessEffectRenderer`1<Cathode> {
private Texture2D noiseTex
private RenderTexture temporalRT
private Shader grayShader
private Shader primaryShader
private Shader tvShader
private Shader postTVShader
private Shader trailShader
private int _CathodeRT1
private int _CathodeRT2
private int _Intensity
private int _SizeX
private int _SizeY
private int _ChromaSubsampling
private int _Sharpen
private int _SharpenRadius
private int _ColorNoise
private int _RestlessFoot
private int _FootAmplitude
private int _ChromaOffset
private int _ChromaIntensity
private int _ChromaInstability
private int _BurnIn
private int _TapeDust
private int _TrailTex
private int _NoiseTex
private int _Gamma
private int _ResponseCurve
private int _Saturation
private int _Wobble
private int _Black
private int _White
private int _DynamicRangeMin
private int _DynamicRangeMax
private int _ScreenWhiteBal
private int _Trailing
public void Init()
public void Release()
public void Render(PostProcessRenderContext context)
}
public CCTV_RC : PoweredRemoteControlEntity {
public Transform pivotOrigin
public Transform yaw
public Transform pitch
public Vector2 pitchClamp
public Vector2 yawClamp
public float turnSpeed
public float serverLerpSpeed
public float clientLerpSpeed
public float zoomLerpSpeed
public Single[] fovScales
public float pitchAmount
public float yawAmount
public int fovScaleIndex
public float fovScaleLerped
public bool hasPTZ
public AnimationCurve dofCurve
public float dofApertureMax
public Flags Flag_HasViewer
public SoundDefinition movementLoopSoundDef
public AnimationCurve movementLoopGainCurve
public float movementLoopSmoothing
public float movementLoopReference
private Sound movementLoop
private Modulator movementLoopGainModulator
public SoundDefinition zoomInSoundDef
public SoundDefinition zoomOutSoundDef
public RealTimeSinceEx timeSinceLastServerTick
public bool RequiresMouse
protected bool EntityCanPing
public bool CanAcceptInput
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int ConsumptionAmount()
public bool get_RequiresMouse()
protected bool get_EntityCanPing()
public bool get_CanAcceptInput()
public void ServerInit()
public void PostServerLoad()
public void UserInput(InputState inputState, CameraViewerId viewerID)
public void Save(SaveInfo info)
public void Server_SetDir(RPCMessage msg)
public bool InitializeControl(CameraViewerId viewerID)
public void StopControl(CameraViewerId viewerID)
public void UpdateViewers()
public void ServerTick()
public bool UpdateManualAim(InputState inputState)
public void UpdateRotation(float delta)
public void Load(LoadInfo info)
public float GetFovScale()
}
public CCTVOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
}
public CeilingLight : IOEntity {
public float pushScale
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int ConsumptionAmount()
public void Hurt(HitInfo info)
public void RefreshGrowables()
public void IOStateChanged(int inputAmount, int inputSlot)
public void LightsOn()
public void LightsOff()
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
}
public CH47AIBrain : BaseAIBrain {
public void AddStates()
public void InitializeAI()
public void FixedUpdate()
}
public ch47Animator : MonoBehaviour {
public Animator animator
public bool bottomDoorOpen
public bool landingGearDown
public bool leftDoorOpen
public bool rightDoorOpen
public bool rearDoorOpen
public bool rearDoorExtensionOpen
public Transform rearRotorBlade
public Transform frontRotorBlade
public float rotorBladeSpeed
public float wheelTurnSpeed
public float wheelTurnAngle
public SkinnedMeshRenderer[] blurredRotorBlades
public SkinnedMeshRenderer[] RotorBlades
private bool blurredRotorBladesEnabled
public float blurSpeedThreshold
private void Start()
public void SetDropDoorOpen(bool isOpen)
private void Update()
private void LateUpdate()
private void EnableBlurredRotorBlades(bool enabled)
}
public CH47DropZone : MonoBehaviour {
public float lastDropTime
public List`1<CH47DropZone> dropZones
public void Awake()
public CH47DropZone GetClosest(Vector3 pos)
public void OnDestroy()
public float TimeSinceLastDrop()
public void Used()
public void OnDrawGizmos()
}
public CH47FlightTest : MonoBehaviour {
public Rigidbody rigidBody
public float engineThrustMax
public Vector3 torqueScale
public Transform com
public Transform[] GroundPoints
public Transform[] GroundEffects
public float currentThrottle
public float avgThrust
public float liftDotMax
public Transform AIMoveTarget
private float altitudeTolerance
public void Awake()
public HelicopterInputState_t GetHelicopterInputState()
public HelicopterInputState_t GetAIInputState()
public float GetIdealAltitude()
public void FixedUpdate()
public void OnDrawGizmos()
}
public CH47Helicopter : BaseHelicopter {
public GameObjectRef mapMarkerEntityPrefab
public SoundDefinition flightEngineSoundDef
public SoundDefinition flightThwopsSoundDef
public float rotorGainModSmoothing
public float engineGainMin
public float engineGainMax
public float thwopGainMin
public float thwopGainMax
public BaseEntity mapMarkerInstance
public void ServerInit()
public void CreateMapMarker()
public bool IsValidHomingTarget()
protected void ApplyHandbrake()
protected bool CanPushNow(BasePlayer pusher)
}
public CH47HelicopterAIController : CH47Helicopter {
public GameObjectRef scientistPrefab
public GameObjectRef dismountablePrefab
public GameObjectRef weakDismountablePrefab
public float maxTiltAngle
public float AiAltitudeForce
public GameObjectRef lockedCratePrefab
public Flags Flag_Damaged
public Flags Flag_NearDeath
public Flags Flag_DropDoorOpen
public GameObject triggerHurt
public Vector3 landingTarget
public int numCrates
private bool shouldLand
public bool aimDirOverride
public Vector3 _aimDirection
public Vector3 _moveTarget
public int lastAltitudeCheckFrame
public float altOverride
public float currentDesiredAltitude
private bool altitudeProtection
public float hoverHeight
public void DropCrate()
public bool OutOfCrates()
public bool CanDropCrate()
public bool IsDropDoorOpen()
public void SetDropDoorOpen(bool open)
public bool ShouldLand()
public void SetLandingTarget(Vector3 target)
public void ClearLandingTarget()
public void TriggeredEventSpawn()
public void AttemptMount(BasePlayer player, bool doMountChecks)
public void ServerInit()
public void SpawnPassenger(Vector3 spawnPos, string prefabPath)
public void SpawnPassenger(Vector3 spawnPos)
public void SpawnScientist(Vector3 spawnPos)
private void OnSpawnedHuman(HumanNPC human)
private void CheckSpawnScientists()
public void SpawnScientists()
public void EnableFacingOverride(bool enabled)
public void SetMoveTarget(Vector3 position)
public Vector3 GetMoveTarget()
public void SetAimDirection(Vector3 dir)
public Vector3 GetAimDirectionOverride()
public Vector3 GetPosition()
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void CancelAnger()
public void InitiateAnger()
public void UnHostile()
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
public void DelayedKill()
public void DismountAllPlayers()
public void SetAltitudeProtection(bool on)
public void CalculateDesiredAltitude()
public void SetMinHoverHeight(float newHeight)
public float CalculateOverrideAltitude()
public void SetDefaultInputState()
public void MaintainAIAltutide()
public void VehicleFixedUpdate()
public void DestroyShared()
}
public CH47LandingZone : MonoBehaviour {
public float lastDropTime
public List`1<CH47LandingZone> landingZones
public float dropoffScale
public bool HasAnyLandingZones
public bool get_HasAnyLandingZones()
public void Awake()
public CH47LandingZone GetClosest(Vector3 pos)
public void OnDestroy()
public float TimeSinceLastDrop()
public void Used()
public void OnDrawGizmos()
}
public CH47PathFinder : BasePathFinder {
public List`1<Vector3> visitedPatrolPoints
public Vector3 GetRandomPatrolPoint()
private MonumentInfo GetRandomValidMonumentInfo()
}
public CH47ReinforcementListener : BaseEntity {
public string listenString
public GameObjectRef heliPrefab
public float startDist
public void OnEntityMessage(BaseEntity from, string msg)
public void Call()
public bool TryCall(string resourcePath, Vector3 ourPos, float startDist)
}
public Chainsaw : BaseMelee {
public float attackFadeInTime
public float attackFadeInDelay
public float attackFadeOutTime
public float idleFadeInTimeFromOff
public float idleFadeInTimeFromAttack
public float idleFadeInDelay
public float idleFadeOutTime
public Renderer chainRenderer
private MaterialPropertyBlock block
private Vector2 saveST
public Phrase UnloadAmmoTitle
public Phrase UnloadAmmoDesc
public float fuelPerSec
public int maxAmmo
public int ammo
public ItemDefinition fuelType
public float reloadDuration
public SoundPlayer idleLoop
public SoundPlayer attackLoopAir
public SoundPlayer revUp
public SoundPlayer revDown
public SoundPlayer offSound
private int failedAttempts
public float engineStartChance
private TimeSince lastReloadSignalFromClient
private float ammoRemainder
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool EngineOn()
public bool IsAttacking()
protected void OnReceivedSignalServer(Signal signal, string arg)
public void ServerNPCStart()
public void ServerUse()
public void ServerUse_OnHit(HitInfo info)
private void DelayedStopAttack()
protected bool VerifyClientAttack(BasePlayer player)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void SetHeld(bool bHeld)
public void ReduceAmmo(float firingTime)
public void DoReload(RPCMessage msg)
public void Save(SaveInfo info)
public void SetEngineStatus(bool status)
public void SetAttackStatus(bool status)
public void EngineTick()
public void AttackTick()
public void Server_StartEngine(RPCMessage msg)
public void Server_StopEngine(RPCMessage msg)
public void Server_SetAttacking(RPCMessage msg)
public void ServerCommand(Item item, string command, BasePlayer player)
public void DisableHitEffects()
public void EnableHitEffect(UInt32 hitMaterial)
public void DoAttackShared(HitInfo info)
public void Load(LoadInfo info)
public bool HasAmmo()
public Item GetAmmo()
}
public ChanceAIEvent : BaseAIEvent {
private float <Chance>k__BackingField
public float Chance
public float get_Chance()
public void set_Chance(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public ChangelogButton : MonoBehaviour {
public RustButton Button
public CanvasGroup CanvasGroup
private void Update()
}
public ChangelogPanel : MonoBehaviour {
public GameObject AddedHeader
public GameObject RemovedHeader
public GameObject ChangedHeader
public RustText AddedContent
public RustText RemovedContent
public RustText ChangedContent
}
public ChangeSignText : UIDialog {
public Action`2<int, Texture2D> onUpdateTexture
public Action onClose
public GameObject objectContainer
public Transform panTransform
public Transform rotateTransform
public GameObject currentFrameSection
public GameObject[] frameOptions
public Canvas canvas
public RectTransform rightPanelRect
public Camera cameraPreview
public Camera camera3D
public Light previewLight
public Vector3 homeRotation
public RectTransform toolsContainer
public RectTransform brushesContainer
public RustSlider brushSizeSlider
public RustSlider brushSpacingSlider
public RustSlider brushOpacitySlider
public FlexElement rootElement
public FlexElement bodyElement
public FlexElement controlsElement
public FlexElement floatElement
}
public ChatEntry : MonoBehaviour {
public TextMeshProUGUI text
public RawImage avatar
public CanvasGroup canvasGroup
public float lifeStarted
public ulong steamid
public Phrase LocalPhrase
public Phrase CardsPhrase
public Phrase TeamPhrase
public TmProEmojiRedirector EmojiRedirector
public Phrase ClanPhrase
}
public Chicken : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public ChildrenFromScene : MonoBehaviour {
public string SceneName
public bool StartChildrenDisabled
private IEnumerator Start()
}
public ChildrenScreenshot : MonoBehaviour {
public Vector3 offsetAngle
public int width
public int height
public float fieldOfView
public string folder
public void CreateScreenshots()
public void PositionCamera(Camera cam, GameObject obj)
}
public ChineseLantern : BaseFuelLightSource {
public Transform pivotRotator
public float swaySpeed
public float swayDistance
public float lerpSpeed
}
public ChippyArcadeGame : BaseArcadeGame {
public ChippyMainCharacter mainChar
public SpriteArcadeEntity mainCharAim
public ChippyBoss currentBoss
public ChippyBoss[] bossPrefabs
public SpriteArcadeEntity mainMenuLogo
public Transform respawnPoint
public Vector2 mouseAim
public TextArcadeEntity levelIndicator
public TextArcadeEntity gameOverIndicator
public TextArcadeEntity playGameButton
public TextArcadeEntity highScoresButton
public bool OnMainMenu
public bool GameActive
public int level
public TextArcadeEntity[] scoreDisplays
public MenuButtonArcadeEntity[] mainMenuButtons
public int selectedButtonIndex
public bool OnHighScores
}
public ChippyBoss : SpriteArcadeEntity {
public Vector2 roamDistance
public float animationSpeed
public Sprite[] animationFrames
public ArcadeEntity bulletTest
public SpriteRenderer flashRenderer
public BossDamagePoint[] damagePoints
}
public ChippyBulletEntity : SpriteArcadeEntity {
public float speed
public float maxSpeed
public float radius
public float damage
public ArcadeEntity bulletImpact
}
public ChippyMainCharacter : SpriteArcadeEntity {
public float speed
public float maxSpeed
public ChippyBulletEntity bulletPrefab
public float fireRate
public Vector3 aimDir
}
public ChippyMoveTest : MonoBehaviour {
public Vector3 heading
public float speed
public float maxSpeed
private void FixedUpdate()
}
public ChristmasTree : StorageContainer {
public GameObject[] decorations
public bool ItemFilter(Item item, int targetSlot)
public void OnItemAddedOrRemoved(Item item, bool added)
}
public CinematicDialog : UIDialog {
public CanvasGroup FullFadeGroup
}
public CinematicEntity : BaseEntity {
private Flags HideMesh
private Flags HideMesh2
private Flags HideMesh3
private Flags HideMesh4
public List`1<DisableGroup> DisableObjects
private List`1<CinematicEntity> serverList
public void ServerInit()
public void HideObjects(Arg args)
public void DestroyShared()
public void OnFlagsChanged(Flags old, Flags next)
private void ToggleObjects(bool state)
public void HideObjectShared(Arg args, List`1<CinematicEntity> entList)
}
public CinematicScenePlaybackEntity : BaseEntity {
public Animator RootAnimator
public GameObjectRef CinematicUI
public float Duration
public GameObject DebugRoot
public bool ShowDebugRoot
public Transform LookPosition
public bool UseCinemachineBrain
public bool HidePlayerLegs
public float FadeToBlackTime
private EntityRef`1<BasePlayer> currentPlayer
public void SignalKillPlayer()
public void SignalFadeToBlack()
public void AssignPlayer(BasePlayer bp)
public void ServerInit()
private void Timeout()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ClanAsyncResult`1 : object {
private List`1<Action`1<T>> _callbacks
private Stopwatch _sinceStarted
private bool _isComplete
private T _result
public bool IsStarted
public float Elapsed
public bool IsComplete
public bool get_IsStarted()
public float get_Elapsed()
public bool get_IsComplete()
public void Start()
public bool TrySetResult(T result)
public void OnComplete(Action`1<T> callback)
private void Reset()
private void Facepunch.Pool.IPooled.EnterPool()
private void Facepunch.Pool.IPooled.LeavePool()
}
public ClanChangeTracker : object {
private ClanManager _clanManager
private List`1<ClanChangedEvent> _clanChangedEvents
private List`1<ClanDisbandedEvent> _clanDisbandedEvents
private List`1<InvitationCreatedEvent> _invitationCreatedEvents
private List`1<MembershipChangedEvent> _membershipChangedEvents
private List`1<ChatMessageEvent> _chatMessageEvents
public void .ctor(ClanManager clanManager)
public void HandleEvents()
private void HandleClanChanged(ClanChangedEvent& data)
private void HandleClanDisbanded(ClanDisbandedEvent& data)
private void HandleInvitationCreated(InvitationCreatedEvent& data)
private void HandleMembershipChanged(MembershipChangedEvent& data)
private void HandleChatMessageEvent(ChatMessageEvent& data)
public void ClanChanged(long clanId, ClanDataSource dataSources)
public void ClanDisbanded(long clanId)
public void InvitationCreated(ulong steamId, long clanId)
public void MembershipChanged(ulong steamId, Nullable`1<long> clanId)
public void ClanChatMessage(long clanId, ClanChatEntry entry)
}
public ClanInfoExtensions : object {
public ClanInfo ToProto(IClan clan)
private Role ToProto(ClanRole role)
public ClanRole FromProto(Role proto)
private Member ToProto(ClanMember member)
private Invite ToProto(ClanInvite invite)
}
public ClanInvitationExtensions : object {
public ClanInvitations ToProto(List`1<ClanInvitation> invitations)
public Invitation ToProto(ClanInvitation invitation)
}
public ClanLeaderboardExtensions : object {
public ClanLeaderboard ToProto(List`1<ClanLeaderboardEntry> leaderboard)
public Entry ToProto(ClanLeaderboardEntry entry)
}
public ClanLogExtensions : object {
public ClanLog ToProto(ClanLogs clanLogs)
public ClanScoreEvents ToProto(ClanScoreEvents clanScoreEvents)
}
public ClanManager : BaseEntity {
private RealTimeSince _sinceLastLeaderboardUpdate
private List`1<ClanLeaderboardEntry> _leaderboardCache
public TokenisedPhrase InvitationToast
public int LogoSize
private ClanManager <ServerInstance>k__BackingField
private string _backendType
private ClanChangeTracker _changeTracker
private IClanBackend <Backend>k__BackingField
private int MaxMetadataRequestsPerSecond
private float MaxMetadataRequestInterval
private float MetadataExpiry
private Dictionary`2<long, List`1<Connection>> _clanMemberConnections
public ClanManager ServerInstance
public IClanBackend Backend
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Server_CreateClan(RPCMessage msg)
public void Server_GetClan(RPCMessage msg)
public void Server_GetLogs(RPCMessage msg)
public void Server_GetScoreEvents(RPCMessage msg)
public void Server_GetInvitations(RPCMessage msg)
public void Server_GetLeaderboard(RPCMessage msg)
public void Server_SetLogo(RPCMessage msg)
public void Server_SetColor(RPCMessage msg)
public void Server_SetMotd(RPCMessage msg)
public void Server_Invite(RPCMessage msg)
public void Server_CancelInvite(RPCMessage msg)
public void Server_AcceptInvitation(RPCMessage msg)
public void Server_CancelInvitation(RPCMessage msg)
public void Server_Kick(RPCMessage msg)
public void Server_SetPlayerRole(RPCMessage msg)
public void Server_SetPlayerNotes(RPCMessage msg)
public void Server_CreateRole(RPCMessage msg)
public void Server_UpdateRole(RPCMessage msg)
public void Server_DeleteRole(RPCMessage msg)
public void Server_SwapRoles(RPCMessage msg)
private bool CheckClanResult(int requestId, BasePlayer player, ClanValueResult`1<IClan> result, IClan& clan)
private ClanActionResult BuildActionResult(int requestId, ClanResult result, IClan clan, bool hasClanInfo)
public ClanManager get_ServerInstance()
private void set_ServerInstance(ClanManager value)
public IClanBackend get_Backend()
private void set_Backend(IClanBackend value)
public Task Initialize()
public void Shutdown()
public void Spawn()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
private string ChooseBackendType()
private IClanBackend CreateBackendInstance(string type)
public void InitShared()
public void OnDestroy()
public void Server_GetClanMetadata(RPCMessage msg)
public void AddScore(IClan clan, ClanScoreEvent entry)
public void SendClanChanged(IClan clan)
public void SendClanInvitation(ulong steamId, long clanId)
public bool TryGetClanMemberConnections(long clanId, List`1& connections)
public void ClanMemberConnectionsChanged(long clanId)
public void LoadClanInfoForSleepers()
private void <Initialize>b__37_0()
private void <Spawn>b__39_0()
}
public ClanMetadata : ValueType {
public long ClanId
public string Name
public int Members
public Color32 Color
}
public ClanPushNotifications : object {
public void SendClanAnnouncement(IClan clan, long previousTimestamp, ulong ignorePlayer)
}
public Client : SingletonComponent`1<Client> {
public Phrase loading_loading
public Phrase loading_connecting
public Phrase loading_connectionaccepted
public Phrase loading_connecting_negotiate
public Phrase loading_level
public Phrase loading_skinnablewarmup
public Phrase loading_preloadcomplete
public Phrase loading_openingscene
public Phrase loading_clientready
public Phrase loading_prefabwarmup
}
public ClientFrametimeReport : object {
public int request_id
public int start_frame
public List`1<int> frame_times
}
public ClientFrametimeRequest : object {
public int request_id
public int start_frame
public int max_frames
}
public ClientIOLine : BaseMonoBehaviour {
public LineRenderer _line
public NotifyLOD lod
public Material directionalMaterial
public Material defaultMaterial
public IOType lineType
public WireColour colour
public List`1<ClientIOLine> allLines
public IOEntity ownerIOEnt
}
public ClientIOLine_Pipe : ClientIOLine {
public NotifyLOD NotifyLod
public PipeMesh PipeRenderer
}
public ClientIOLineParent : FacepunchBehaviour {
public AnimatedBuildingBlock parentEntity
public string boneName
public bool ignoreForPlugConnections
}
public ClientPerformanceReport : ValueType {
public int request_id
public string user_id
public float fps_average
public int fps
public int frame_id
public float frame_time
public float frame_time_average
public long memory_system
public long memory_collections
public long memory_managed_heap
public float realtime_since_startup
public bool streamer_mode
public int ping
public int tasks_invokes
public int tasks_load_balancer
public int workshop_skins_queued
}
public Climate : SingletonComponent`1<Climate> {
private float fadeAngle
private float defaultTemp
private int weatherDurationHours
private int weatherFadeHours
public float BlendingSpeed
public float FogMultiplier
public float FogDarknessDistance
public bool DebugLUTBlending
public WeatherParameters Weather
public WeatherPreset[] WeatherPresets
public ClimateParameters Arid
public ClimateParameters Temperate
public ClimateParameters Tundra
public ClimateParameters Arctic
private float <WeatherStateBlend>k__BackingField
private UInt32 <WeatherSeedPrevious>k__BackingField
private UInt32 <WeatherSeedTarget>k__BackingField
private UInt32 <WeatherSeedNext>k__BackingField
private WeatherPreset <WeatherStatePrevious>k__BackingField
private WeatherPreset <WeatherStateTarget>k__BackingField
private WeatherPreset <WeatherStateNext>k__BackingField
private WeatherPreset <WeatherState>k__BackingField
private WeatherPreset <WeatherClampsMin>k__BackingField
private WeatherPreset <WeatherClampsMax>k__BackingField
private WeatherPreset <WeatherOverrides>k__BackingField
private LegacyWeatherState <Overrides>k__BackingField
public Dictionary`2<WeatherPresetType, WeatherPreset[]> presetLookup
private ClimateParameters[] climateLookup
public float WeatherStateBlend
public UInt32 WeatherSeedPrevious
public UInt32 WeatherSeedTarget
public UInt32 WeatherSeedNext
public WeatherPreset WeatherStatePrevious
public WeatherPreset WeatherStateTarget
public WeatherPreset WeatherStateNext
public WeatherPreset WeatherState
public WeatherPreset WeatherClampsMin
public WeatherPreset WeatherClampsMax
public WeatherPreset WeatherOverrides
public LegacyWeatherState Overrides
public float get_WeatherStateBlend()
public void set_WeatherStateBlend(float value)
public UInt32 get_WeatherSeedPrevious()
public void set_WeatherSeedPrevious(UInt32 value)
public UInt32 get_WeatherSeedTarget()
public void set_WeatherSeedTarget(UInt32 value)
public UInt32 get_WeatherSeedNext()
public void set_WeatherSeedNext(UInt32 value)
public WeatherPreset get_WeatherStatePrevious()
public void set_WeatherStatePrevious(WeatherPreset value)
public WeatherPreset get_WeatherStateTarget()
public void set_WeatherStateTarget(WeatherPreset value)
public WeatherPreset get_WeatherStateNext()
public void set_WeatherStateNext(WeatherPreset value)
public WeatherPreset get_WeatherState()
public void set_WeatherState(WeatherPreset value)
public WeatherPreset get_WeatherClampsMin()
private void set_WeatherClampsMin(WeatherPreset value)
public WeatherPreset get_WeatherClampsMax()
private void set_WeatherClampsMax(WeatherPreset value)
public WeatherPreset get_WeatherOverrides()
public void set_WeatherOverrides(WeatherPreset value)
public LegacyWeatherState get_Overrides()
public void set_Overrides(LegacyWeatherState value)
protected void Awake()
protected void OnDestroy()
public void Update()
private bool Initialized()
public float GetClouds(Vector3 position)
public float GetFog(Vector3 position)
public float GetWind(Vector3 position)
public float GetThunder(Vector3 position)
public float GetRainbow(Vector3 position)
public float GetAurora(Vector3 position)
public float GetRain(Vector3 position)
public float GetSnow(Vector3 position)
public float GetTemperature(Vector3 position)
private UInt32 GetSeedFromLong(long val)
private WeatherPreset GetWeatherPreset(UInt32 seed)
private WeatherPreset GetWeatherPreset(UInt32 seed, WeatherPresetType type)
public WeatherPreset[] CacheWeatherPresets(WeatherPresetType type)
private float FindBlendParameters(Vector3 pos, ClimateParameters& src, ClimateParameters& dst)
}
public ClimateBlendTexture : ProcessedTexture {
public void .ctor(int width, int height, bool linear)
public bool CheckLostData()
public void Blend(Texture srcLut1, Texture dstLut1, float lerpLut1, Texture srcLut2, Texture dstLut2, float lerpLut2, float lerp, ClimateBlendTexture prevLut, float time)
public void Swap(ClimateBlendTexture& a, ClimateBlendTexture& b)
}
public ClimateOverlay : MonoBehaviour {
public float blendingSpeed
public PostProcessVolume[] biomeVolumes
}
public ClothingBenchmarkScene : BenchmarkScene {
public GameObjectRef PlayerModelPrefab
public bool ChangeClothingEveryFrame
}
public ClothingMovementProperties : ScriptableObject {
public float speedReduction
public float minSpeedReduction
public float waterSpeedBonus
}
public ClothLOD : FacepunchBehaviour {
public float clothLODDist
public Cloth cloth
}
public ClothWindModify : FacepunchBehaviour {
public Cloth cloth
private Vector3 initialClothForce
public Vector3 worldWindScale
public Vector3 turbulenceScale
}
public CoalingTower : IOEntity {
private BoxCollider unloadingBounds
private GameObjectRef oreStoragePrefab
private GameObjectRef fuelStoragePrefab
private MeshRenderer[] signalLightsExterior
private MeshRenderer[] signalLightsInterior
public Color greenLightOnColour
public Color yellowLightOnColour
private Animator vacuumAnimator
private float vacuumStartDelay
private ParticleSystemContainer unloadingFXContainerOre
private ParticleSystem[] unloadingFXMain
private ParticleSystem[] unloadingFXDust
private ParticleSystemContainer unloadingFXContainerFuel
private TokenisedPhrase noTraincar
private TokenisedPhrase noNextTraincar
private TokenisedPhrase noPrevTraincar
private TokenisedPhrase trainIsMoving
private TokenisedPhrase outputIsFull
private TokenisedPhrase trainHasThrottle
private GameObject buttonSoundPos
private SoundDefinition buttonPressSound
private SoundDefinition buttonReleaseSound
private SoundDefinition failedActionSound
private SoundDefinition failedShuntAlarmSound
private SoundDefinition armMovementLower
private SoundDefinition armMovementRaise
private SoundDefinition suctionAirStart
private SoundDefinition suctionAirStop
private SoundDefinition suctionAirLoop
private SoundDefinition suctionOreStart
private SoundDefinition suctionOreLoop
private SoundDefinition suctionOreStop
private SoundDefinition suctionOreInteriorLoop
private SoundDefinition oreBinLoop
private SoundDefinition suctionFluidStart
private SoundDefinition suctionFluidLoop
private SoundDefinition suctionFluidStop
private SoundDefinition suctionFluidInteriorLoop
private SoundDefinition fluidTankLoop
private GameObject interiorPipeSoundLocation
private GameObject armMovementSoundLocation
private GameObject armSuctionSoundLocation
private GameObject oreBinSoundLocation
private GameObject fluidTankSoundLocation
private NetworkedProperty`1<int> LootTypeIndex
private EntityRef`1<TrainCar> activeTrainCarRef
private EntityRef`1<TrainCarUnloadable> activeUnloadableRef
private Flags LinedUpFlag
private Flags HasUnloadableFlag
private Flags UnloadingInProgressFlag
private Flags MoveToNextInProgressFlag
private Flags MoveToPrevInProgressFlag
private EntityRef`1<OreHopper> oreStorageInstance
private EntityRef`1<PercentFullStorageContainer> fuelStorageInstance
public float TIME_TO_EMPTY
private Vector3 <UnloadingPos>k__BackingField
private List`1<CoalingTower> unloadersInWorld
private Sound armMovementLoopSound
private Sound suctionAirLoopSound
private Sound suctionMaterialLoopSound
private Sound interiorPipeLoopSound
private Sound unloadDestinationSound
private TrainCarUnloadable tcUnloadingNow
private bool HasTrainCar
private bool HasUnloadable
private bool HasUnloadableLinedUp
public Vector3 UnloadingPos
private bool get_HasTrainCar()
private bool get_HasUnloadable()
private bool get_HasUnloadableLinedUp()
public Vector3 get_UnloadingPos()
private void set_UnloadingPos(Vector3 value)
public void InitShared()
public void DestroyShared()
public void Load(LoadInfo info)
public bool IsUnderAnUnloader(TrainCar trainCar, Boolean& isLinedUp, Vector3& unloaderPos)
public bool TrainCarIsUnder(TrainCar trainCar, Boolean& isLinedUp)
private OreHopper GetOreStorage()
private PercentFullStorageContainer GetFuelStorage()
private TrainCar GetActiveTrainCar()
private TrainCarUnloadable GetActiveUnloadable()
private bool OutputBinIsFull()
private bool WagonIsEmpty()
private bool CanUnloadNow(ActionAttemptStatus& attemptStatus)
public void Save(SaveInfo info)
public void PostServerLoad()
protected void OnChildAdded(BaseEntity child)
public void OnEmpty()
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
private void SetActiveTrainCar(TrainCar trainCar)
private void ClearActiveTrainCar()
private void CheckWagonLinedUp()
private void CheckWagonLinedUp(bool networkUpdate)
private bool TryUnloadActiveWagon(ActionAttemptStatus& attemptStatus)
private void WagonBeginUnloadAnim()
private void EmptyTenPercent()
private void EndEmptyProcess(ActionAttemptStatus status)
private bool TryShuntTrain(bool next, ActionAttemptStatus& attemptStatus)
private void ShuntEnded(ActionAttemptStatus status)
private void RPC_Unload(RPCMessage msg)
private void RPC_Next(RPCMessage msg)
private void RPC_Prev(RPCMessage msg)
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public CodeLock : BaseLock {
public GameObjectRef keyEnterDialog
public GameObjectRef effectUnlocked
public GameObjectRef effectLocked
public GameObjectRef effectDenied
public GameObjectRef effectCodeChanged
public GameObjectRef effectShock
public bool hasCode
public Flags Flag_CodeEntryBlocked
public Phrase blockwarning
public float maxFailedAttempts
public float lockoutCooldown
public bool hasGuestCode
public string code
public string guestCode
public List`1<ulong> whitelistPlayers
public List`1<ulong> guestPlayers
public int wrongCodes
public float lastWrongTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsCodeEntryBlocked()
public void Load(LoadInfo info)
internal void DoEffect(string effect)
public bool OnTryToOpen(BasePlayer player)
public bool OnTryToClose(BasePlayer player)
public bool CanUseNetworkCache(Connection connection)
public void Save(SaveInfo info)
private void RPC_ChangeCode(RPCMessage rpc)
private void TryUnlock(RPCMessage rpc)
private void TryLock(RPCMessage rpc)
public void ClearCodeEntryBlocked()
private void UnlockWithCode(RPCMessage rpc)
public void PostServerLoad()
}
public ColdBreath : BaseMonoBehaviour {
public GameObjectRef effect
private BasePlayer player
private Transform jawBone
}
public ColdOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
public float smoothTime
public bool preventInstantiation
}
public CollateTrainTracks : ProceduralComponent {
private float MAX_NODE_DIST
private float MAX_NODE_DIST_SQR
private float MAX_NODE_ANGLE
public bool RunOnCache
public bool get_RunOnCache()
public void Process(UInt32 seed)
internal bool <Process>g__CompareNodes|5_1(Vector3 theirPos, Vector3 theirTangent, <>c__DisplayClass5_0& , <>c__DisplayClass5_1& , <>c__DisplayClass5_2& )
internal bool <Process>g__CompareNodes|5_2(bool ourStart, bool theirStart, <>c__DisplayClass5_3& , <>c__DisplayClass5_4& , <>c__DisplayClass5_5& , <>c__DisplayClass5_6& )
internal bool <Process>g__NodesConnect|5_0(Vector3 ourPos, Vector3 theirPos, Vector3 ourTangent, Vector3 theirTangent)
}
public CollectableEasterEgg : BaseEntity {
public Transform artwork
public float bounceRange
public float bounceSpeed
public GameObjectRef pickupEffect
public ItemDefinition itemToGive
public ulong ownerUserID
private float lastPickupStartTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void RPC_StartPickUp(RPCMessage msg)
public void RPC_PickUp(RPCMessage msg)
}
public CollectibleEntity : BaseEntity {
public Phrase EatTitle
public Phrase itemName
public ItemAmount[] itemList
public GameObjectRef pickupEffect
public float xpScale
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsFood(bool checkConsumeMod)
public void DoPickup(BasePlayer reciever, bool eat)
public void Pickup(RPCMessage msg)
public void PickupEat(RPCMessage msg)
public bool HasItem(ItemDefinition def)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public CollectionEx : object {
public bool IsNullOrEmpty(ICollection`1<T> collection)
public bool IsEmpty(ICollection`1<T> collection)
}
public ColliderInfo : MonoBehaviour {
public Flags FlagsNone
public Flags FlagsEverything
public Flags FlagsDefault
public Flags flags
public bool HasFlag(Flags f)
public void SetFlag(Flags f, bool b)
public bool Filter(HitTest info)
}
public ColliderInfo_Pipe : ColliderInfo {
public int OutputSlotIndex
public IOEntity ParentEntity
}
public CombatLog : object {
private string selfname
private string noname
private BasePlayer player
private Queue`1<Event> storage
private float <LastActive>k__BackingField
private Dictionary`2<ulong, Queue`1<Event>> players
public float LastActive
public float get_LastActive()
private void set_LastActive(float value)
public void .ctor(BasePlayer player)
public void Init()
public void Save()
public void LogInvalid(BasePlayer player, AttackEntity weapon, string description)
public void LogInvalid(HitInfo info, string description)
public void LogAttack(HitInfo info, string description, float oldHealth)
public void Log(BaseEntity attacker, AttackEntity weapon, BaseCombatEntity hitEntity, string description, Projectile projectilePrefab, int projectileId, float healthOld, HitInfo hitInfo)
private void Log(Event val)
public string Get(int count, NetworkableId filterByAttacker, bool json, bool isAdmin, ulong requestingUser)
public Queue`1<Event> Get(ulong id)
}
public CommandBufferDesc : object {
private CameraEvent <CameraEvent>k__BackingField
private int <OrderId>k__BackingField
private Action`1<CommandBuffer> <FillDelegate>k__BackingField
public CameraEvent CameraEvent
public int OrderId
public Action`1<CommandBuffer> FillDelegate
public CameraEvent get_CameraEvent()
private void set_CameraEvent(CameraEvent value)
public int get_OrderId()
private void set_OrderId(int value)
public Action`1<CommandBuffer> get_FillDelegate()
private void set_FillDelegate(Action`1<CommandBuffer> value)
public void .ctor(CameraEvent cameraEvent, int orderId, FillCommandBuffer fill)
}
public CommandBufferEx : object {
public void BlitArray(CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Material mat, int slice, int pass)
public void BlitArray(CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Texture target, Material mat, int slice, int pass)
public void BlitArrayMip(CommandBuffer cb, Mesh blitMesh, Texture source, int sourceMip, int sourceSlice, Texture target, int targetMip, int targetSlice, Material mat, int pass)
public void BlitMip(CommandBuffer cb, Mesh blitMesh, Texture source, Texture target, int mip, int slice, Material mat, int pass)
}
public CommentComponent : MonoBehaviour {
public string comment
}
public CommunityEntity : PointEntity {
public CommunityEntity ServerInstance
public CommunityEntity ClientInstance
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void InitShared()
public void DestroyShared()
}
public CompanionServer.AppPlayerExtensions : object {
public AppTeamInfo GetAppTeamInfo(BasePlayer player, ulong steamId)
public AppTeamInfo GetAppTeamInfo(PlayerTeam team, ulong requesterSteamId)
private List`1<Note> GetMapNotes(ulong playerId, bool personalNotes)
private void AddMapNote(List`1<Note> result, MapNote note, MapNoteType type)
}
public CompanionServer.BanList`1 : object {
private Dictionary`2<TKey, double> _bans
public void Ban(TKey key, double timeInSeconds)
public bool IsBanned(TKey key)
public void Cleanup()
}
public CompanionServer.CameraRendererManager : SingletonComponent`1<CameraRendererManager> {
private Stack`1<CameraRenderTask> _taskPool
private int _tasksTaken
private int _tasksReturned
private int _tasksCreated
private Stopwatch _stopwatch
private List`1<CameraRenderer> _renderers
private int _renderIndex
private int _completeIndex
protected void OnDestroy()
public void StartRendering(IRemoteControllable rc)
public void Tick()
public CameraRenderTask BorrowTask()
public void ReturnTask(CameraRenderTask& task)
public void pool_stats(Arg arg)
private void DispatchRenderers()
private void CompleteRenderers()
private void CleanupRenderers()
}
internal CompanionServer.Cameras.CameraBurstUtil : object {
public int GetColliderId(RaycastHit hit)
public Collider GetCollider(int colliderInstanceId)
}
public CompanionServer.Cameras.CameraRenderer : object {
public bool enabled
public float completionFrameBudgetMs
public int maxRendersPerFrame
public int maxRaysPerFrame
public int width
public int height
public float verticalFov
public float nearPlane
public float farPlane
public int layerMask
public float renderInterval
public int samplesPerRender
public int entityMaxAge
public int entityMaxDistance
public int playerMaxDistance
public int playerNameMaxDistance
private Dictionary`2<NetworkableId, NetworkableId> _entityIdMap
private Dictionary`2<int, ValueTuple`2<byte, int>> _knownColliders
private Dictionary`2<int, BaseEntity> _colliderToEntity
private double _lastRenderTimestamp
private float _fieldOfView
private int _sampleOffset
private int _nextSampleOffset
private int _sampleCount
private CameraRenderTask _task
private Nullable`1<ulong> _cachedViewerSteamId
private BasePlayer _cachedViewer
public CameraRendererState state
public IRemoteControllable rc
public BaseEntity entity
public void EnterPool()
public void LeavePool()
public void Reset()
public void Init(IRemoteControllable remoteControllable)
public bool CanRender()
public void Render(int maxSampleCount)
public void CompleteRender()
private void UpdateCollidersMap(List`1<int> foundColliderIds)
private NetworkableId RandomizeEntityId(NetworkableId realId)
private byte GetMaterialIndex(PhysicMaterial material, BaseEntity entity)
}
public CompanionServer.Cameras.CameraRendererState : Enum {
public int value__
public CameraRendererState Invalid
public CameraRendererState WaitingToRender
public CameraRendererState Rendering
}
public CompanionServer.Cameras.CameraRenderTask : CustomYieldInstruction {
public int MaxSamplesPerRender
public int MaxColliders
private Dictionary`2<ValueTuple`2<int, int>, NativeArray`1<int2>> _samplePositions
private NativeArray`1<RaycastCommand> _raycastCommands
private NativeArray`1<RaycastHit> _raycastHits
private NativeArray`1<int> _colliderIds
private NativeArray`1<byte> _colliderMaterials
private NativeArray`1<int> _colliderHits
private NativeArray`1<int> _raycastOutput
private NativeArray`1<int> _foundCollidersLength
private NativeArray`1<int> _foundColliders
private NativeArray`1<int> _outputDataLength
private NativeArray`1<byte> _outputData
private Nullable`1<JobHandle> _pendingJob
private int _sampleCount
private int _colliderLength
public bool keepWaiting
protected void Finalize()
public void Dispose()
public void Reset()
public bool get_keepWaiting()
public int Start(int width, int height, float verticalFov, float nearPlane, float farPlane, int layerMask, Transform cameraTransform, int sampleCount, int sampleOffset, Dictionary`2<int, ValueTuple`2<byte, int>> knownColliders)
public int ExtractRayData(Byte[] buffer, List`1<int> hitColliderIds, List`1<int> foundColliderIds)
private NativeArray`1<int2> GetSamplePositions(int width, int height)
public void FreeCachedSamplePositions()
}
public CompanionServer.Cameras.RaycastBufferSetupJob : ValueType {
public NativeArray`1<int> colliderIds
public NativeArray`1<byte> colliderMaterials
public NativeArray`1<int> colliderHits
public void Execute()
private void SortByAscending(NativeArray`1& colliderIds, NativeArray`1& colliderMaterials, int leftIndex, int rightIndex)
}
public CompanionServer.Cameras.RaycastColliderProcessingJob : ValueType {
public NativeArray`1<int> foundCollidersLength
public NativeArray`1<int> foundColliders
public void Execute()
private void SortByDescending(NativeArray`1& colliders, NativeArray`1& counts, int leftIndex, int rightIndex)
private void SortAscending(NativeArray`1& array, int leftIndex, int rightIndex)
}
public CompanionServer.Cameras.RaycastOutputCompressJob : ValueType {
public NativeArray`1<int> rayOutputs
public NativeArray`1<int> dataLength
public NativeArray`1<byte> data
public void Execute()
private ushort RayDistance(int ray)
private byte RayAlignment(int ray)
private byte RayMaterial(int ray)
}
public CompanionServer.Cameras.RaycastRayProcessingJob : ValueType {
public float3 cameraForward
public float farPlane
public NativeArray`1<RaycastHit> raycastHits
public NativeArray`1<int> colliderIds
public NativeArray`1<byte> colliderMaterials
public NativeArray`1<int> colliderHits
public NativeArray`1<int> outputs
public NativeArray`1<int> foundCollidersIndex
public NativeArray`1<int> foundColliders
public void Execute(int index)
private int BinarySearch(NativeArray`1<int> haystack, int needle)
private int Compare(int x, int y)
}
public CompanionServer.Cameras.RaycastRaySetupJob : ValueType {
public float2 res
public float2 halfRes
public float aspectRatio
public float worldHeight
public float3 cameraPos
public quaternion cameraRot
public float nearPlane
public float farPlane
public int layerMask
public int sampleOffset
public NativeArray`1<int2> samplePositions
public NativeArray`1<RaycastCommand> raycastCommands
public void Execute(int index)
}
public CompanionServer.Cameras.RaycastSamplePositionsJob : ValueType {
public int2 res
public Random random
public NativeArray`1<int2> positions
public void Execute()
}
public CompanionServer.CameraTarget : ValueType {
private NetworkableId <EntityId>k__BackingField
public NetworkableId EntityId
public NetworkableId get_EntityId()
public void .ctor(NetworkableId entityId)
public bool Equals(CameraTarget other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CameraTarget left, CameraTarget right)
public bool op_Inequality(CameraTarget left, CameraTarget right)
}
public CompanionServer.ChatLog : object {
private int MaxBacklog
private Dictionary`2<ulong, ChatState> States
public void Record(ulong teamId, ulong steamId, string name, string message, string color, UInt32 time)
public void Remove(ulong teamId)
public IReadOnlyList`1<Entry> GetHistory(ulong teamId)
}
public CompanionServer.ClanTarget : ValueType {
private long <ClanId>k__BackingField
public long ClanId
public long get_ClanId()
public void .ctor(long clanId)
public bool Equals(ClanTarget other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(ClanTarget left, ClanTarget right)
public bool op_Inequality(ClanTarget left, ClanTarget right)
}
public CompanionServer.Connection : object {
private MemoryStream MessageStream
private Listener _listener
private IWebSocketConnection _connection
private Nullable`1<PlayerTarget> _subscribedPlayer
private HashSet`1<EntityTarget> _subscribedEntities
private HashSet`1<ClanTarget> _subscribedClans
private IRemoteControllable _currentCamera
private ulong _cameraViewerSteamId
private bool _isControllingCamera
private long <ConnectionId>k__BackingField
private InputState <InputState>k__BackingField
public long ConnectionId
public IPAddress Address
public IRemoteControllable CurrentCamera
public bool IsControllingCamera
public ulong ControllingSteamId
public InputState InputState
public long get_ConnectionId()
private void set_ConnectionId(long value)
public IPAddress get_Address()
public void .ctor(long connectionId, Listener listener, IWebSocketConnection connection)
public void OnClose()
public void OnMessage(Span`1<byte> data)
public void Close()
public void Send(AppResponse response)
public void Subscribe(PlayerTarget target)
public void Subscribe(EntityTarget target)
public IRemoteControllable get_CurrentCamera()
public bool get_IsControllingCamera()
public ulong get_ControllingSteamId()
public InputState get_InputState()
public void set_InputState(InputState value)
public bool BeginViewing(IRemoteControllable camera)
public void EndViewing()
public void Subscribe(ClanTarget target)
public void Unsubscribe(ClanTarget target)
public void SendRaw(MemoryBuffer data)
private bool TryGetCameraTarget(IRemoteControllable camera, CameraTarget& target)
}
public CompanionServer.ConnectionLimiter : object {
private object _sync
private Dictionary`2<IPAddress, int> _addressCounts
private int _overallCount
public bool TryAdd(IPAddress address)
public void Remove(IPAddress address)
public void Clear()
public string ToString()
}
public CompanionServer.EntityTarget : ValueType {
private NetworkableId <EntityId>k__BackingField
public NetworkableId EntityId
public NetworkableId get_EntityId()
public void .ctor(NetworkableId entityId)
public bool Equals(EntityTarget other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(EntityTarget left, EntityTarget right)
public bool op_Inequality(EntityTarget left, EntityTarget right)
}
public CompanionServer.Handlers.BaseClanHandler`1 : BasePlayerHandler`1<T> {
private IClanBackend <ClanBackend>k__BackingField
protected IClanBackend ClanBackend
protected IClanBackend get_ClanBackend()
private void set_ClanBackend(IClanBackend value)
protected ValueTask`1<IClan> GetClan()
public void EnterPool()
public ValidationResult Validate()
protected void SendError(ClanResult result)
private string GetErrorString(ClanResult result)
}
public CompanionServer.Handlers.BaseEntityHandler`1 : BasePlayerHandler`1<T> {
private AppIOEntity <Entity>k__BackingField
protected AppIOEntity Entity
protected AppIOEntity get_Entity()
private void set_Entity(AppIOEntity value)
public void EnterPool()
public ValidationResult Validate()
}
public CompanionServer.Handlers.BaseHandler`1 : object {
private TokenBucketList`1<ulong> <PlayerBuckets>k__BackingField
private IConnection <Client>k__BackingField
private AppRequest <Request>k__BackingField
private T <Proto>k__BackingField
protected TokenBucketList`1<ulong> PlayerBuckets
protected double TokenCost
public IConnection Client
public AppRequest Request
public T Proto
protected TokenBucketList`1<ulong> get_PlayerBuckets()
private void set_PlayerBuckets(TokenBucketList`1<ulong> value)
protected double get_TokenCost()
public IConnection get_Client()
private void set_Client(IConnection value)
public AppRequest get_Request()
private void set_Request(AppRequest value)
public T get_Proto()
private void set_Proto(T value)
public void Initialize(TokenBucketList`1<ulong> playerBuckets, IConnection client, AppRequest request, T proto)
public void EnterPool()
public void LeavePool()
public ValidationResult Validate()
public void Execute()
protected void SendSuccess()
public void SendError(string code)
public void SendFlag(bool value)
protected void Send(AppResponse response)
}
public CompanionServer.Handlers.BasePlayerHandler`1 : BaseHandler`1<T> {
private ulong <UserId>k__BackingField
private BasePlayer <Player>k__BackingField
protected ulong UserId
protected BasePlayer Player
protected ulong get_UserId()
private void set_UserId(ulong value)
protected BasePlayer get_Player()
private void set_Player(BasePlayer value)
public void EnterPool()
public ValidationResult Validate()
}
public CompanionServer.Handlers.CameraInput : BaseHandler`1<AppCameraInput> {
protected double TokenCost
protected double get_TokenCost()
public void Execute()
private Vector3 Sanitize(Vector3 value)
private float Sanitize(float value)
}
public CompanionServer.Handlers.CameraSubscribe : BasePlayerHandler`1<AppCameraSubscribe> {
public void Execute()
}
public CompanionServer.Handlers.CameraUnsubscribe : BaseHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.CheckSubscription : BaseEntityHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.ClanChat : BaseClanHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.ClanInfo : BaseClanHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.EntityInfo : BaseEntityHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.IHandler {
public AppRequest Request
public AppRequest get_Request()
public ValidationResult Validate()
public void Execute()
public void SendError(string code)
}
public CompanionServer.Handlers.Info : BasePlayerHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.Map : BasePlayerHandler`1<AppEmpty> {
private int _width
private int _height
private Byte[] _imageData
private string _background
protected double TokenCost
protected double get_TokenCost()
public void Execute()
public void PopulateCache()
private void RenderToCache()
}
public CompanionServer.Handlers.MapMarkers : BasePlayerHandler`1<AppEmpty> {
public void Execute()
private AppMarker GetPlayerMarker(BasePlayer player)
}
public CompanionServer.Handlers.NexusAuth : BaseHandler`1<AppGetNexusAuth> {
public ValidationResult Validate()
public void Execute()
}
public CompanionServer.Handlers.PromoteToLeader : BasePlayerHandler`1<AppPromoteToLeader> {
public void Execute()
}
public CompanionServer.Handlers.SendClanChat : BaseClanHandler`1<AppSendMessage> {
protected double TokenCost
protected double get_TokenCost()
public void Execute()
}
public CompanionServer.Handlers.SendTeamChat : BasePlayerHandler`1<AppSendMessage> {
protected double TokenCost
protected double get_TokenCost()
public void Execute()
}
public CompanionServer.Handlers.SetClanMotd : BaseClanHandler`1<AppSendMessage> {
public void Execute()
}
public CompanionServer.Handlers.SetEntityValue : BaseEntityHandler`1<AppSetEntityValue> {
public void Execute()
}
public CompanionServer.Handlers.SetSubscription : BaseEntityHandler`1<AppFlag> {
public void Execute()
}
public CompanionServer.Handlers.TeamChat : BasePlayerHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.TeamInfo : BasePlayerHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.Time : BasePlayerHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.ValidationResult : Enum {
public int value__
public ValidationResult Success
public ValidationResult NotFound
public ValidationResult RateLimit
public ValidationResult Banned
public ValidationResult Rejected
}
public CompanionServer.IBroadcastSender`2 {
public void BroadcastTo(List`1<TTarget> targets, TMessage message)
}
public CompanionServer.IConnection {
public long ConnectionId
public IRemoteControllable CurrentCamera
public bool IsControllingCamera
public ulong ControllingSteamId
public InputState InputState
public long get_ConnectionId()
public void Send(AppResponse response)
public void Subscribe(PlayerTarget target)
public void Subscribe(EntityTarget target)
public void Subscribe(ClanTarget target)
public void Unsubscribe(ClanTarget target)
public IRemoteControllable get_CurrentCamera()
public bool get_IsControllingCamera()
public ulong get_ControllingSteamId()
public InputState get_InputState()
public void set_InputState(InputState value)
public bool BeginViewing(IRemoteControllable camera)
public void EndViewing()
}
public CompanionServer.ITokenBucketSettings {
public double MaxTokens
public double TokensPerSec
public double get_MaxTokens()
public double get_TokensPerSec()
}
public CompanionServer.Listener : object {
private ByteArrayStream Stream
private TokenBucketList`1<IPAddress> _ipTokenBuckets
private BanList`1<IPAddress> _ipBans
private TokenBucketList`1<ulong> _playerTokenBuckets
private TokenBucketList`1<ulong> _pairingTokenBuckets
private Queue`1<Message> _messageQueue
private WebSocketServer _server
private Stopwatch _stopwatch
private RealTimeSince _lastCleanup
private long _nextConnectionId
public IPAddress Address
public int Port
public ConnectionLimiter Limiter
public SubscriberList`3<PlayerTarget, Connection, AppBroadcast> PlayerSubscribers
public SubscriberList`3<EntityTarget, Connection, AppBroadcast> EntitySubscribers
public SubscriberList`3<ClanTarget, Connection, AppBroadcast> ClanSubscribers
public SubscriberList`3<CameraTarget, Connection, AppBroadcast> CameraSubscribers
public void .ctor(IPAddress ipAddress, int port)
public void Dispose()
internal void Enqueue(Connection connection, MemoryBuffer data)
public void Update()
private void Dispatch(Message message)
public void BroadcastTo(List`1<Connection> targets, AppBroadcast broadcast)
private MemoryBuffer GetBroadcastBuffer(AppBroadcast broadcast)
public bool CanSendPairingNotification(ulong playerId)
private bool <Dispatch>g__Handle|22_20(Func`2<AppRequest, TProto> protoSelector, IHandler& requestHandler, <>c__DisplayClass22_0& )
}
public CompanionServer.NotificationChannel : Enum {
public int value__
public NotificationChannel Pairing
public NotificationChannel PlayerLoggedIn
public NotificationChannel PlayerDied
public NotificationChannel SmartAlarm
public NotificationChannel ClanAnnouncement
}
public CompanionServer.NotificationList : object {
private string ApiEndpoint
private HttpClient Http
private HashSet`1<ulong> _subscriptions
private double _lastSend
public bool AddSubscription(ulong steamId)
public bool RemoveSubscription(ulong steamId)
public bool HasSubscription(ulong steamId)
public List`1<ulong> ToList()
public void LoadFrom(List`1<ulong> steamIds)
public void IntersectWith(HashSet`1<PlayerNameID> players)
public Task`1<NotificationSendResult> SendNotification(NotificationChannel channel, string title, string body, string type)
public Task`1<NotificationSendResult> SendNotificationTo(ICollection`1<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data)
public Task`1<NotificationSendResult> SendNotificationTo(ulong steamId, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data)
private Task`1<NotificationSendResult> SendNotificationImpl(ICollection`1<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data)
private Task`1<NotificationSendResult> SendNotificationBatchImpl(IEnumerable`1<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data)
}
public CompanionServer.NotificationSendResult : Enum {
public int value__
public NotificationSendResult Failed
public NotificationSendResult Sent
public NotificationSendResult Empty
public NotificationSendResult Disabled
public NotificationSendResult RateLimited
public NotificationSendResult ServerError
public NotificationSendResult NoTargetsFound
public NotificationSendResult TooManySubscribers
}
public CompanionServer.PlayerTarget : ValueType {
private ulong <SteamId>k__BackingField
public ulong SteamId
public ulong get_SteamId()
public void .ctor(ulong steamId)
public bool Equals(PlayerTarget other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(PlayerTarget left, PlayerTarget right)
public bool op_Inequality(PlayerTarget left, PlayerTarget right)
}
public CompanionServer.PushRequest : object {
public string ServerToken
public List`1<ulong> SteamIds
public NotificationChannel Channel
public string Title
public string Body
public Dictionary`2<string, string> Data
public void EnterPool()
public void LeavePool()
}
public CompanionServer.Server : object {
private string ApiEndpoint
private HttpClient Http
public ChatLog TeamChat
internal string Token
private Listener <Listener>k__BackingField
public Listener Listener
public bool IsEnabled
public Listener get_Listener()
private void set_Listener(Listener value)
public bool get_IsEnabled()
public void Initialize()
public void Shutdown()
public void Update()
public void Broadcast(PlayerTarget target, AppBroadcast broadcast)
public void Broadcast(EntityTarget target, AppBroadcast broadcast)
public void Broadcast(ClanTarget target, AppBroadcast broadcast)
public void Broadcast(CameraTarget target, AppBroadcast broadcast)
public bool HasAnySubscribers(CameraTarget target)
public bool CanSendPairingNotification(ulong playerId)
private void PostInitializeServer()
private Task SetupServerRegistration()
private bool TryLoadServerRegistration(String& serverId, String& serverToken)
private void SetServerRegistration(string responseJson)
private Task CheckConnectivity()
private Task`1<HttpResponseMessage> AutoRetry(Func`1<Task`1<HttpResponseMessage>> action)
private void SetServerId(string serverId)
private string GetServerIdPath()
}
public CompanionServer.SubscriberList`3 : object {
private object _syncRoot
private Dictionary`2<TKey, Dictionary`2<TTarget, double>> _subscriptions
private IBroadcastSender`2<TTarget, TMessage> _sender
private Nullable`1<double> _timeoutSeconds
private Stopwatch _lastCleanup
public void .ctor(IBroadcastSender`2<TTarget, TMessage> sender, Nullable`1<double> timeoutSeconds)
public void Add(TKey key, TTarget value)
public void Remove(TKey key, TTarget value)
public void Clear(TKey key)
public void Send(TKey key, TMessage message)
public bool HasAnySubscribers(TKey key)
public bool HasSubscriber(TKey key, TTarget target)
private void CleanupExpired()
}
public CompanionServer.TokenBucket : object {
private double _lastUpdate
private double _tokens
public ITokenBucketSettings Settings
public bool IsFull
public bool IsNaughty
public bool get_IsFull()
public bool get_IsNaughty()
public void Reset()
public bool TryTake(double requestedTokens)
private void Update()
}
public CompanionServer.TokenBucketList`1 : object {
private Dictionary`2<TKey, TokenBucket> _buckets
private double <MaxTokens>k__BackingField
private double <TokensPerSec>k__BackingField
public double MaxTokens
public double TokensPerSec
public double get_MaxTokens()
public double get_TokensPerSec()
public void .ctor(double maxTokens, double tokensPerSec)
public TokenBucket Get(TKey key)
public void Cleanup()
}
public CompanionServer.Util : object {
public int OceanMargin
public Phrase NotificationEmpty
public Phrase NotificationDisabled
public Phrase NotificationRateLimit
public Phrase NotificationServerError
public Phrase NotificationNoTargets
public Phrase NotificationTooManySubscribers
public Phrase NotificationUnknown
public Vector2 WorldToMap(Vector3 worldPos)
public void SendSignedInNotification(BasePlayer player)
public void SendDeathNotification(BasePlayer player, BaseEntity killer)
public Task`1<NotificationSendResult> SendPairNotification(string type, BasePlayer player, string title, string message, Dictionary`2<string, string> data)
public Dictionary`2<string, string> GetServerPairingData()
public Dictionary`2<string, string> GetPlayerPairingData(BasePlayer player)
public void BroadcastAppTeamRemoval(BasePlayer player)
public void BroadcastAppTeamUpdate(PlayerTeam team)
public void BroadcastTeamChat(PlayerTeam team, ulong steamId, string name, string message, string color)
public void SendNotification(PlayerTeam team, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data, ulong ignorePlayer)
public string ToErrorCode(ValidationResult result)
public string ToErrorMessage(NotificationSendResult result)
}
public CompanionSetupScreen : SingletonComponent`1<CompanionSetupScreen> {
public string PairedKey
public GameObject instructionsBody
public GameObject detailsPanel
public GameObject loadingMessage
public GameObject errorMessage
public GameObject notSupportedMessage
public GameObject disabledMessage
public GameObject enabledMessage
public GameObject refreshButton
public GameObject enableButton
public GameObject disableButton
public GameObject pairButton
public RustText serverName
public RustButton helpButton
}
public CompassMapMarker : MonoBehaviour {
public Image MarkerImage
public Image MarkerImageOuter
public GameObject LeaderRoot
public RustText MarkerLabel
}
public CompassMissionMarker : MonoBehaviour {
public Image Icon
}
public CompleteTrain : object {
private TrainCar <PrimaryTrainCar>k__BackingField
private float <TotalForces>k__BackingField
private float <TotalMass>k__BackingField
private int <LinedUpToUnload>k__BackingField
private Vector3 unloaderPos
public float trackSpeed
private float prevTrackSpeed
public List`1<TrainCar> trainCars
public TriggerTrainCollisions frontCollisionTrigger
public TriggerTrainCollisions rearCollisionTrigger
public bool ranUpdateTick
public bool disposed
public float IMPACT_ENERGY_FRACTION
public float MIN_COLLISION_FORCE
public float lastMovingTime
public float SLEEP_SPEED
public float SLEEP_DELAY
public TimeSince timeSinceLastChange
private bool isShunting
private TimeSince timeSinceShuntStart
private float MAX_SHUNT_TIME
private float SHUNT_SPEED
private float SHUNT_SPEED_CHANGE_RATE
private Action`1<ActionAttemptStatus> shuntEndCallback
private float shuntDistance
private Vector3 shuntDirection
private Vector2 shuntStartPos2D
private Vector2 shuntTargetPos2D
private TrainCar shuntTarget
public StaticCollisionState staticCollidingAtFront
private HashSet`1<GameObject> monitoredStaticContentF
public StaticCollisionState staticCollidingAtRear
private HashSet`1<GameObject> monitoredStaticContentR
public Dictionary`2<Rigidbody, float> prevTrackSpeeds
public TrainCar PrimaryTrainCar
public bool TrainIsReversing
public float TotalForces
public float TotalMass
public int NumTrainCars
public int LinedUpToUnload
public bool IsLinedUpToUnload
public TrainCar get_PrimaryTrainCar()
public void set_PrimaryTrainCar(TrainCar value)
public bool get_TrainIsReversing()
public float get_TotalForces()
public void set_TotalForces(float value)
public float get_TotalMass()
public void set_TotalMass(float value)
public int get_NumTrainCars()
public int get_LinedUpToUnload()
private void set_LinedUpToUnload(int value)
public bool get_IsLinedUpToUnload()
public void .ctor(TrainCar trainCar)
public void .ctor(List`1<TrainCar> allTrainCars)
private void Init(List`1<TrainCar> allTrainCars)
protected void Finalize()
public void Dispose()
private void Cleanup()
public void RemoveTrainCar(TrainCar trainCar)
public float GetTrackSpeedFor(TrainCar trainCar)
public float GetPrevTrackSpeedFor(TrainCar trainCar)
public void UpdateTick(float dt)
public bool IncludesAnEngine()
protected bool HasAnyCollisions()
private bool HasAnyEnginesOn()
private bool IsAllAsleep()
private void SleepAll()
public bool TryShuntCarTo(Vector3 shuntDirection, float shuntDistance, TrainCar shuntTarget, Action`1<ActionAttemptStatus> shuntEndCallback, ActionAttemptStatus& status)
private void EndShunting(ActionAttemptStatus status)
public bool ContainsOnly(TrainCar trainCar)
public int IndexOf(TrainCar trainCar)
public bool TryGetAdjacentTrainCar(TrainCar trainCar, bool next, Vector3 forwardDir, TrainCar& result)
private void ParamsTick()
private void MovementTick(float dt)
private void MoveOtherTrainCar(TrainCar trainCar, TrainCar prevTrainCar)
public void ResetUpdateTick()
public bool Matches(List`1<TrainCar> listToCompare)
public void ReduceSpeedBy(float velChange)
public bool AnyPlayersOnTrain()
private int CheckLinedUpToUnload(Vector3& unloaderPos)
public bool IsCoupledBackwards(TrainCar trainCar)
private bool IsCoupledBackwards(int trainCarIndex)
private bool HasThrottleInput()
private TrackSelection GetTrackSelection()
public void FreeStaticCollision()
private float ApplyCollisionsToTrackSpeed(float trackSpeed, float totalMass, float deltaTime)
private float ApplyCollisions(float trackSpeed, TrainCar ourTrainCar, Vector3 forwardVector, bool atOurFront, TriggerTrainCollisions trigger, float ourTotalMass, StaticCollisionState& wasStaticColliding, StaticCollisionState otherEndStaticColliding, float deltaTime)
private float HandleStaticCollisions(bool staticColliding, bool front, float trackSpeed, StaticCollisionState& wasStaticColliding, TriggerTrainCollisions trigger)
private float HandleTrainCollision(bool front, Vector3 forwardVector, float trackSpeed, Transform ourTransform, TrainCar theirTrain, float deltaTime, StaticCollisionState& wasStaticColliding)
private float HandleRigidbodyCollision(bool atOurFront, float trackSpeed, Vector3 forwardVector, float ourTotalMass, Rigidbody theirRB, float theirTotalMass, float deltaTime, bool calcSecondaryForces)
private float GetTotalPushingMass(Vector3 pushDirection, Vector3 ourForward, List`1& prevTrains)
private float GetTotalPushingForces(Vector3 pushDirection, Vector3 ourForward, List`1& prevTrains)
}
public ComponentInfo : MonoBehaviour {
public void Setup()
public void Reset()
}
public ComponentInfo`1 : ComponentInfo {
public T component
public void Initialize(T source)
}
public Composter : StorageContainer {
public ItemDefinition FertilizerDef
public bool CompostEntireStack
public float fertilizerProductionProgress
protected float UpdateInterval
protected float get_UpdateInterval()
public void ServerInit()
public bool InventoryItemFilter(Item item, int targetSlot)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool ItemIsFertilizer(Item item)
public void UpdateComposting()
public void CompostItem(Item item)
public void ProduceFertilizer(int amount)
}
public CompoundBowWeapon : BowWeapon {
public float stringHoldDurationMax
public float stringBonusDamage
public float stringBonusDistance
public float stringBonusVelocity
public float movementPenaltyRampUpTime
public float conditionLossPerSecondHeld
public float conditionLossHeldDelay
public SoundDefinition chargeUpSoundDef
public SoundDefinition stringHeldSoundDef
public SoundDefinition drawFinishSoundDef
private Sound chargeUpSound
private Sound stringHeldSound
protected float movementPenalty
internal float stringHoldTimeStart
protected float conditionLossCheckTickRate
protected float serverMovementCheckTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void UpdateMovementPenalty(float delta)
public void UpdateConditionLoss()
public void ServerMovementCheck()
public void OnHeldChanged()
public void RPC_StringHoldStatus(RPCMessage msg)
public void DidAttackServerside()
public float GetLastPlayerMovementTime()
public float GetStringBonusScale()
public float GetDamageScale(bool getMax)
public float GetDistanceScale(bool getMax)
public float GetProjectileVelocityScale(bool getMax)
}
public ComputerMenu : UIDialog {
public RectTransform bookmarkContainer
public GameObject bookmarkPrefab
public List`1<RCBookmarkEntry> activeEntries
}
public ComputerStation : BaseMountable {
public Flags Flag_HasFullControl
public GameObjectRef menuPrefab
public ComputerMenu computerMenu
public EntityRef currentlyControllingEnt
public List`1<string> controlBookmarks
public Transform leftHandIKPosition
public Transform rightHandIKPosition
public SoundDefinition turnOnSoundDef
public SoundDefinition turnOffSoundDef
public SoundDefinition onLoopSoundDef
public bool isStatic
public float autoGatherRadius
public ulong currentPlayerID
public float nextAddTime
public Char[] BookmarkSplit
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool AllowPings()
public bool IsValidIdentifier(string str)
public void DestroyShared()
public void ServerInit()
public void GatherStaticCameras()
public void PostServerLoad()
public void StopControl(BasePlayer ply)
public bool IsPlayerAdmin(BasePlayer player)
public void DeleteBookmark(RPCMessage msg)
public void Server_DisconnectControl(RPCMessage msg)
public void BeginControllingBookmark(RPCMessage msg)
public void CheckCCTVAchievement()
public bool CanAddBookmark(BasePlayer player)
public void ForceAddBookmark(string identifier)
public void AddBookmark(RPCMessage msg)
public void ControlCheck()
public string GenerateControlBookmarkString()
public void SendControlBookmarks(BasePlayer player)
public void OnPlayerMounted()
public void OnPlayerDismounted(BasePlayer player)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ConditionalGibbable : MonoBehaviour {
public int id
}
public ConditionalModel : PrefabAttribute {
public GameObjectRef prefab
public bool onClient
public bool onServer
public bool IsImportant
public ModelConditionTest[] conditions
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool RunTests(BaseEntity parent)
public bool RunTestsExceptFoundationSide(BaseEntity parent)
public GameObject InstantiateSkin(BaseEntity parent)
protected Type GetIndexedType()
}
public ConfettiCannon : DecayEntity {
public float InitialBlastDelay
public float BlastCooldown
public GameObjectRef ConfettiPrefab
public Transform ConfettiPrefabSpawnPoint
public Flags Ignited
public float DamagePerBlast
private Action blastAction
private Action clearBusy
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void Blast(RPCMessage msg)
private void TriggerBlast()
private void ClearBusy()
public void PostServerLoad()
public void Ignite(Vector3 fromPos)
public bool CanIgnite()
public void OnAttacked(HitInfo info)
}
public ConnectedSpeaker : IOEntity {
public AudioSource SoundSource
private EntityRef`1<IOEntity> connectedTo
public VoiceProcessor VoiceProcessor
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnFlagsChanged(Flags old, Flags next)
public void Load(LoadInfo info)
private IAudioConnectionSource GetConnectionSource(IOEntity entity, int depth)
public void Save(SaveInfo info)
}
public ConnectionAuth : MonoBehaviour {
public List`1<Connection> m_AuthConnection
private RealTimeSince _sinceClientRequirementRefresh
private Nullable`1<ValueTuple`2<int, int>> _clientRequirementCache
private string _clientVersionMismatchMessage
public bool IsAuthed(ulong iSteamID)
public void Reject(Connection connection, string strReason, string strReasonPrivate)
public void OnDisconnect(Connection connection)
public void Approve(Connection connection)
public void OnNewConnection(Connection connection)
public IEnumerator AuthorisationRoutine(Connection connection)
private Nullable`1<ValueTuple`2<int, int>> GetMinClientRequirement()
private string GetClientVersionMismatchMessage()
}
public ConnectionQueue : object {
public List`1<Connection> queue
public List`1<Connection> joining
private List`1<ReservedServerSlot> reservedSlots
private float nextCleanupReservedSlots
public float nextMessageTime
public int ReservedCount
public int Queued
public int Joining
public int get_ReservedCount()
public int get_Queued()
public int get_Joining()
public void SkipQueue(ulong userid)
internal void Join(Connection connection)
public void Cycle(int availableSlots)
public void SendMessages()
public void SendMessage(Connection c, int position)
public void RemoveConnection(Connection connection)
private void JoinGame(Connection connection)
public void JoinedGame(Connection connection)
private void AddReservation(ulong userId)
private void CleanupExpiredReservedSlots()
private ReservedServerSlot FindQueueSpot(ulong userId)
private void RemoveReservedSlot(ulong userId)
private bool CanJumpQueue(Connection connection)
public bool IsQueued(ulong userid)
public bool IsJoining(ulong userid)
}
public ConnectionScreen : SingletonComponent`1<ConnectionScreen> {
public Text statusText
public GameObject disconnectButton
public GameObject retryButton
public ServerBrowserInfo browserInfo
}
public ConsoleGen : object {
public Command[] All
}
public ConsoleNetwork : object {
private Stopwatch timer
internal void Init()
internal void OnClientCommand(Message packet)
internal void SendClientReply(Connection cn, string strCommand)
public void SendClientCommand(Connection cn, string strCommand, Object[] args)
public void SendClientCommandImmediate(Connection cn, string strCommand, Object[] args)
public void SendClientCommand(List`1<Connection> cn, string strCommand, Object[] args)
public void BroadcastToAllClients(string strCommand, Object[] args)
}
public ConsoleUI : SingletonComponent`1<ConsoleUI> {
public RustText text
public InputField outputField
public InputField inputField
public GameObject AutocompleteDropDown
public GameObject ItemTemplate
public Color errorColor
public Color warningColor
public Color inputColor
}
public Construction : PrefabAttribute {
public Option info
public bool canBypassBuildingPermission
public bool showBuildingBlockedPreview
public bool canPlaceOnRoads
public bool canRotateBeforePlacement
public bool canRotateAfterPlacement
public bool checkVolumeOnRotate
public bool checkVolumeOnUpgrade
public bool canPlaceAtMaxDistance
public bool placeOnWater
public Vector3 rotationAmount
public Vector3 applyStartingRotation
public Transform deployOffset
public bool enforceLineOfSightCheckAgainstParentEntity
public bool canSnap
public float holdToPlaceDuration
public bool canFloodFillSockets
public float healthMultiplier
public float costMultiplier
public float maxplaceDistance
public Mesh guideMesh
public Socket_Base[] allSockets
public BuildingProximity[] allProximities
public ConstructionGrade defaultGrade
public SocketHandle socketHandle
public Bounds bounds
public bool isBuildingPrivilege
public bool isSleepingBag
public ConstructionGrade[] grades
public Deployable deployable
public ConstructionPlaceholder placeholder
public string lastPlacementError
public Phrase placementError
public BaseEntity CreateConstruction(Target target, bool bNeedsValidPlacement)
public bool HasMaleSockets(Target target)
public void FindMaleSockets(Target target, List`1<Socket_Base> sockets)
public ConstructionGrade GetGrade(Enum iGrade, ulong iSkin)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
public void set_placementError(Phrase value)
public bool UpdatePlacement(Transform transform, Construction common, Target& target)
private bool TestPlacingThroughRock(Placement& placement, Target target)
private bool TestPlacingThroughWall(Placement& placement, Transform transform, Construction common, Target target)
private bool TestPlacingCloseToRoad(Placement& placement, Target target, Construction construction)
public bool ShowAsNeutral(Target target)
}
public ConstructionErrors : object {
public Phrase MustPlaceOnConstruction
public Phrase CantPlaceOnConstruction
public Phrase CantPlaceOnMonument
public Phrase NotInTerrain
public Phrase MustPlaceOnRoad
public Phrase CantPlaceOnRoad
}
public ConstructionGrade : PrefabAttribute {
public Construction construction
public BuildingGrade gradeBase
public GameObjectRef skinObject
private Dictionary`2<Enum, List`1<ItemAmount>> _costs
public float maxHealth
public float get_maxHealth()
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public List`1<ItemAmount> CostToBuild(Enum fromGrade)
protected Type GetIndexedType()
}
public ConstructionPlaceholder : PrefabAttribute {
public Mesh mesh
public Material material
public bool renderer
public bool collider
public MeshRenderer MeshRenderer
public MeshFilter MeshFilter
public MeshCollider MeshCollider
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
}
public ConstructionSkin : BasePrefab {
public List`1<GameObject> conditionals
public int DetermineConditionalModelState(BuildingBlock parent)
private void CreateConditionalModels(BuildingBlock parent)
private void DestroyConditionalModels(BuildingBlock parent)
public void Refresh(BuildingBlock parent)
public void Destroy(BuildingBlock parent)
public UInt32 GetStartingDetailColour(UInt32 playerColourIndex)
}
public ConstructionSkin_ColourLookup : ScriptableObject {
public Texture2D Sample
public Color[] AllColours
}
public ConstructionSkin_CustomDetail : ConstructionSkin {
public ConstructionSkin_ColourLookup ColourLookup
public UInt32 GetStartingDetailColour(UInt32 playerColourIndex)
}
public ConstructionSocket : Socket_Base {
public Type socketType
public int rotationDegrees
public int rotationOffset
public bool restrictPlacementRotation
public bool restrictPlacementAngle
public float faceAngle
public float angleAllowed
public float support
private void OnDrawGizmos()
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public bool IsCompatible(Socket_Base socket)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
public bool TestRestrictedAngles(Vector3 suggestedPos, Quaternion suggestedAng, Target target)
public Placement DoPlacement(Target target)
protected bool CanConnectToEntity(Target target)
private bool ShouldInheritFemaleSocketRotation(Type type)
}
public ConstructionSocket_Elevator : ConstructionSocket {
public int MaxFloor
protected bool CanConnectToEntity(Target target)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
}
public ConsumableInformationPanel : ItemInformationPanel {
public ItemTextValue[] values
public UIGenesDisplay Genes
public Text TextUnknownGenetics
public Text LabelGenetics
public GameObject GeneticsGameObject
public ItemTextValue durationValue
public ItemTextValue baitValue
public ItemTextValue baitStackSize
}
public ContactsEntry : MonoBehaviour {
public RustText nameText
public RustText reputationText
public RawImage smallMugshot
public PlayerRelationshipInfo info
}
public ContactsPanel : SingletonComponent`1<ContactsPanel> {
public RectTransform alliesBucket
public RectTransform seenBucket
public RectTransform enemiesBucket
public RectTransform contentsBucket
public ContactsEntry contactEntryPrefab
public RawImage mugshotTest
public RawImage fullBodyTest
public RustButton[] filterButtons
public RelationshipType selectedRelationshipType
public RustButton lastSeenToggle
public Phrase sortingByLastSeenPhrase
public Phrase sortingByFirstSeen
public RustText sortText
}
public ContainerIOEntity : IOEntity {
public ItemDefinition onlyAllowedItem
public ContentsType allowedContents
public int maxStackSize
public int numSlots
public string lootPanelName
public Phrase panelTitle
public bool needsBuildingPrivilegeToUse
public bool isLootable
public bool dropsLoot
public bool dropFloats
public bool onlyOneUser
public SoundDefinition openSound
public SoundDefinition closeSound
private ItemContainer <inventory>k__BackingField
private ulong <LastLootedBy>k__BackingField
public Phrase LootPanelTitle
public ItemContainer inventory
public Transform Transform
public bool DropsLoot
public bool DropFloats
public float DestroyLootPercent
public ulong LastLootedBy
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Phrase get_LootPanelTitle()
public ItemContainer get_inventory()
private void set_inventory(ItemContainer value)
public Transform get_Transform()
public bool get_DropsLoot()
public bool get_DropFloats()
public float get_DestroyLootPercent()
public ulong get_LastLootedBy()
public void set_LastLootedBy(ulong value)
public bool CanPickup(BasePlayer player)
public void ServerInit()
public void PreServerLoad()
public void PostServerLoad()
public void CreateInventory(bool giveUID)
public void Save(SaveInfo info)
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool added)
protected void OnInventoryDirty()
public void OnKilled(HitInfo info)
public void DropItems(BaseEntity initiator)
private void RPC_OpenLoot(RPCMessage rpc)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public bool ShouldDropItemsIndividually()
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
public void DropBonusItems(BaseEntity initiator, ItemContainer container)
public bool OccupiedCheck(BasePlayer player)
public void Load(LoadInfo info)
}
public ContainerSourceLocalPlayer : ItemContainerSource {
public Type type
public bool hideInvalidIcons
private ItemIcon[] allIcons
public ItemContainer GetItemContainer()
}
public ContainerSourceLoot : ItemContainerSource {
public int container
public ItemContainer GetItemContainer()
}
public ContainerSourceSelectedItem : ItemContainerSource {
public ItemContainer GetItemContainer()
}
public ConVar.Admin : ConsoleSystem {
public bool allowAdminUI
public void status(Arg arg)
public void stats(Arg arg)
public void upgrade_radius(Arg arg)
public void skin_radius(Arg arg)
public BuildingGrade FindBuildingSkin(string name, String& error)
private void SkinRadiusInternal(Arg arg, bool changeAnyGrade)
public void killplayer(Arg arg)
public void injureplayer(Arg arg)
public void recoverplayer(Arg arg)
public void kick(Arg arg)
public void kickall(Arg arg)
public void ban(Arg arg)
public void moderatorid(Arg arg)
public void ownerid(Arg arg)
public void removemoderator(Arg arg)
public void removeowner(Arg arg)
public void banid(Arg arg)
private bool TryGetBanExpiry(Arg arg, int n, Int64& expiry, String& durationSuffix)
public void unban(Arg arg)
public void skipqueue(Arg arg)
public void skipqueueid(Arg arg)
public void removeskipqueue(Arg arg)
public void players(Arg arg)
public void say(Arg arg)
public void users(Arg arg)
public void sleepingusers(Arg arg)
public void sleepingusersinrange(Arg arg)
public void usersinrange(Arg arg)
public void usersinrangeofplayer(Arg arg)
public void banlist(Arg arg)
public void banlistex(Arg arg)
public void listid(Arg arg)
public void mute(Arg arg)
public void unmute(Arg arg)
public void mutelist(Arg arg)
public void clientperf(Arg arg)
public void clientperf_frametime(Arg arg)
public void carstats(Arg arg)
public string teaminfo(Arg arg)
public void authradius(Arg arg)
public void deauthradius(Arg arg)
private void SetAuthInRadius(BasePlayer player, float radius, bool auth)
private bool SetUserAuthorized(BaseEntity entity, ulong userId, bool state)
public void entid(Arg arg)
private string AuthList(BaseEntity ent)
private string CodeLockAuthList(CodeLock codeLock)
private string CodeLockAuthList(BaseVehicleModule vehicleModule)
public string GetPlayerName(ulong steamId)
public string ChangeGrade(BaseEntity entity, int increaseBy, int decreaseBy, Enum targetGrade, ulong skin, float radius)
private bool RunInRadius(float radius, BaseEntity initial, Action`1<T> callback, Func`2<T, bool> filter)
public PlayerInfo[] playerlist()
public User[] Bans()
public ServerInfoOutput ServerInfo()
public BuildInfo BuildInfo()
public void AdminUI_FullRefresh(Arg arg)
public void AdminUI_RequestPlayerList(Arg arg)
public void AdminUI_RequestServerInfo(Arg arg)
public void AdminUI_RequestServerConvars(Arg arg)
public void AdminUI_RequestUGCList(Arg arg)
public void AdminUI_RequestUGCContent(Arg arg)
public void AdminUI_DeleteUGCContent(Arg arg)
public void AdminUI_RequestFireworkPattern(Arg arg)
public void clearugcentity(Arg arg)
public void clearugcentitiesinrange(Arg arg)
public void getugcinfo(Arg arg)
public void authcount(Arg arg)
public void entcount(Arg arg)
private void FindEntityAssociationsForPlayer(BasePlayer ply, bool useOwnerId, bool useAuth, string filter, List`1<EntityAssociation> results)
}
public ConVar.AI : ConsoleSystem {
public bool allowdesigning
public bool think
public bool navthink
public bool ignoreplayers
public bool groups
public bool spliceupdates
public bool setdestinationsamplenavmesh
public bool usecalculatepath
public bool usesetdestinationfallback
public bool npcswimming
public bool accuratevisiondistance
public bool move
public bool usegrid
public bool sleepwake
public float sensetime
public float frametime
public int ocean_patrol_path_iterations
public bool npc_enable
public int npc_max_population_military_tunnels
public int npc_spawn_per_tick_max_military_tunnels
public int npc_spawn_per_tick_min_military_tunnels
public float npc_respawn_delay_max_military_tunnels
public float npc_respawn_delay_min_military_tunnels
public float npc_valid_aim_cone
public float npc_valid_mounted_aim_cone
public float npc_cover_compromised_cooldown
public bool npc_cover_use_path_distance
public float npc_cover_path_vs_straight_dist_max_diff
public float npc_door_trigger_size
public float npc_patrol_point_cooldown
public float npc_speed_walk
public float npc_speed_run
public float npc_speed_sprint
public float npc_speed_crouch_walk
public float npc_speed_crouch_run
public float npc_alertness_drain_rate
public float npc_alertness_zero_detection_mod
public float npc_junkpilespawn_chance
public float npc_junkpile_a_spawn_chance
public float npc_junkpile_g_spawn_chance
public float npc_junkpile_dist_aggro_gate
public int npc_max_junkpile_count
public bool npc_families_no_hurt
public bool npc_ignore_chairs
public float npc_sensory_system_tick_rate_multiplier
public float npc_cover_info_tick_rate_multiplier
public float npc_reasoning_system_tick_rate_multiplier
public bool animal_ignore_food
public float npc_gun_noise_silencer_modifier
public bool nav_carve_use_building_optimization
public int nav_carve_min_building_blocks_to_apply_optimization
public float nav_carve_min_base_size
public float nav_carve_size_multiplier
public float nav_carve_height
public bool npc_only_hurt_active_target_in_safezone
public bool npc_use_new_aim_system
public bool npc_use_thrown_weapons
public float npc_max_roam_multiplier
public float npc_alertness_to_aim_modifier
public float npc_deliberate_miss_to_hit_alignment_time
public float npc_deliberate_miss_offset_multiplier
public float npc_deliberate_hit_randomizer
public float npc_htn_player_base_damage_modifier
public bool npc_spawn_on_cargo_ship
public int npc_htn_player_frustration_threshold
public float tickrate
public void sleepwakestats(Arg args)
public void wakesleepingai(Arg args)
public void brainstats(Arg args)
public void aizonestats(Arg args)
public void killscientists(Arg args)
public void killanimals(Arg args)
public void addignoreplayer(Arg args)
public void removeignoreplayer(Arg args)
public void clearignoredplayers(Arg args)
public void printignoredplayers(Arg args)
public float TickDelta()
public void selectNPCLookatServer(Arg args)
}
public ConVar.AntiHack : ConsoleSystem {
public float noclip_margin_dismount
public float noclip_backtracking
public bool reporting
public bool admincheat
public bool objectplacement
public bool modelstate
public bool forceposition
public int rpcstallmode
public float rpcstallfade
public float rpcstallthreshold
public int userlevel
public int enforcementlevel
public float maxdesync
public float maxdeltatime
public float tickhistorytime
public float tickhistoryforgiveness
public float relaxationrate
public float relaxationpause
public float maxviolation
public int terrain_protection
public int terrain_timeslice
public float terrain_padding
public float terrain_penalty
public bool terrain_kill
public bool terrain_check_geometry
public int noclip_protection
public bool noclip_reject
public float noclip_penalty
public float noclip_margin
public float noclip_stepsize
public int noclip_maxsteps
public int speedhack_protection
public bool speedhack_reject
public float speedhack_penalty
public float speedhack_forgiveness
public float speedhack_forgiveness_inertia
public float speedhack_slopespeed
public int flyhack_protection
public bool flyhack_reject
public float flyhack_penalty
public float flyhack_forgiveness_vertical
public float flyhack_forgiveness_vertical_inertia
public float flyhack_forgiveness_horizontal
public float flyhack_forgiveness_horizontal_inertia
public float flyhack_extrusion
public float flyhack_margin
public float flyhack_stepsize
public int flyhack_maxsteps
public bool serverside_fall_damage
public int projectile_protection
public float projectile_penalty
public float projectile_forgiveness
public float projectile_serverframes
public float projectile_clientframes
public float projectile_trajectory
public float projectile_anglechange
public float projectile_velocitychange
public float projectile_desync
public float projectile_backtracking
public float projectile_losforgiveness
public int projectile_damagedepth
public int projectile_impactspawndepth
public bool projectile_terraincheck
public bool projectile_vehiclecheck
public bool projectile_positionoffset
public float projectile_distance_forgiveness_minimum
public int projectile_update_limit
public int melee_protection
public float melee_penalty
public float melee_forgiveness
public float melee_serverframes
public float melee_clientframes
public float melee_backtracking
public float melee_losforgiveness
public bool melee_terraincheck
public bool melee_vehiclecheck
public int eye_protection
public float eye_penalty
public float eye_forgiveness
public float eye_distance_parented_mounted_forgiveness
public float eye_serverframes
public float eye_clientframes
public bool eye_terraincheck
public bool eye_vehiclecheck
public float eye_noclip_cutoff
public float eye_noclip_margin
public float eye_noclip_backtracking
public float eye_losradius
public float eye_history_penalty
public float eye_history_forgiveness
public float impact_effect_distance_forgiveness
public float build_losradius
public float build_losradius_sleepingbag
public bool build_terraincheck
public bool build_vehiclecheck
public int build_inside_check
public int debuglevel
}
public ConVar.App : ConsoleSystem {
public string listenip
public int port
public string publicip
public bool update
public bool notifications
public int queuelimit
public string serverid
public float alarmcooldown
public int maxconnections
public int maxconnectionsperip
public int maxmessagesize
public void pair(Arg arg)
public void regeneratetoken(Arg arg)
public void info(Arg arg)
public void retry_initialize(Arg arg)
public void resetlimiter(Arg arg)
public void connections(Arg arg)
public void appban(Arg arg)
public void appunban(Arg arg)
public IPAddress GetListenIP()
public ValueTask`1<string> GetPublicIPAsync()
public string GetPublicIP()
}
public ConVar.Audio : ConsoleSystem {
public float master
public float musicvolume
public float musicvolumemenu
public float game
public float voices
public float instruments
public float voiceProps
public float eventAudio
public bool ambience
public float framebudget
public float minupdatefraction
public bool advancedocclusion
public bool hqsoundfade
public bool debugVoiceLimiting
public int speakers
public int get_speakers()
public void set_speakers(int value)
public void printSounds(Arg arg)
public void printEngineSounds(Arg arg)
}
public ConVar.Batching : ConsoleSystem {
public bool renderers
public bool renderer_threading
public int renderer_capacity
public int renderer_vertices
public int renderer_submeshes
public int verbose
}
public ConVar.Bradley : ConsoleSystem {
public float respawnDelayMinutes
public float respawnDelayVariance
public bool enabled
public void quickrespawn(Arg arg)
}
public ConVar.Chat : ConsoleSystem {
public float localChatRange
public bool globalchat
public bool localchat
private float textVolumeBoost
public bool hideChatInTutorial
public bool enabled
public int historysize
public CircularBuffer`1<ChatEntry> History
public bool serverlog
public void Broadcast(string message, string username, string color, ulong userid)
public void say(Arg arg)
public void localsay(Arg arg)
public void teamsay(Arg arg)
public void cardgamesay(Arg arg)
public void clansay(Arg arg)
private void sayImpl(ChatChannel targetChannel, Arg arg)
internal string GetNameColor(ulong userId, BasePlayer player)
internal ValueTask`1<bool> sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player)
public IEnumerable`1<ChatEntry> tail(Arg arg)
public IEnumerable`1<ChatEntry> search(Arg arg)
public void Record(ChatEntry ce)
}
public ConVar.Clan : ConsoleSystem {
public bool editsRequireClanTable
public bool enabled
public int maxMemberCount
public int scoreForKillingPlayerInOtherClan
public int scoreForKilledByPlayerInOtherClan
public int scoreForKillingUnarmedPlayer
public int scoreForDestroyingToolCupboards
public int scoreForHackingCrates
public int scoreForOpeningHackedCrates
public int scoreForDestroyingBradley
public int scoreForRunningExcavator
public int scoreForReachingCargoShip
public int scoreForLootingEliteCrate
public void Info(Arg arg)
private ValueTask`1<IClan> GetPlayerClan(BasePlayer player)
private ValueTask`1<IClan> GetClanByID(long clanId, BasePlayer player)
public int GetScoreForEvent(ClanScoreEventType eventType)
internal void <Info>g__SendClanInfoConsole|13_1(long id)
internal string <Info>g__FormatClan|13_2(IClan clan)
internal int <GetScoreForEvent>g__Unknown|16_0(ClanScoreEventType type)
}
public ConVar.Console : ConsoleSystem {
public IEnumerable`1<Entry> tail(Arg arg)
public IEnumerable`1<Entry> search(Arg arg)
}
public ConVar.Construct : ConsoleSystem {
public float frameminutes
}
public ConVar.Craft : ConsoleSystem {
public bool instant
public void add(Arg args)
public void canceltask(Arg args)
public void cancel(Arg args)
public void fasttracktask(Arg args)
}
public ConVar.Creative : ConsoleSystem {
public bool allUsers
public bool freeRepair
public bool freeBuild
public bool freePlacement
public bool unlimitedIo
public void toggleCreativeModeUser(Arg arg)
}
public ConVar.Data : ConsoleSystem {
public void export(Arg args)
}
public ConVar.Debugging : ConsoleSystem {
public bool checktriggers
public bool checkparentingtriggers
public bool DebugDismounts
public bool disablecondition
public int tutorial_start_cooldown
public bool printMissionSpeakInfo
public bool callbacks
public bool log
public void renderinfo(Arg arg)
public void set_log(bool value)
public bool get_log()
public void enable_player_movement(Arg arg)
public void stall(Arg arg)
public void repair_inventory(Arg args)
public void spawnParachuteTester(Arg arg)
public string testTutorialCinematic(Arg arg)
public void clearTutorialForPlayer(Arg arg)
public void deleteEntitiesByShortname(Arg arg)
public void printgroups(Arg arg)
public void flushgroup(Arg arg)
public void breakheld(Arg arg)
public void breakheld_almost(Arg arg)
public void puzzlereset(Arg arg)
public void puzzleprefabrespawn(Arg arg)
public void breakitem(Arg arg)
public void refillvitals(Arg arg)
public void heal(Arg arg)
public void hurt(Arg arg)
public void eat(Arg arg)
public void drink(Arg arg)
public void sethealth(Arg arg)
public void setdamage(Arg arg)
public void setfood(Arg arg)
public void setwater(Arg arg)
public void setradiation(Arg arg)
private void AdjustHealth(BasePlayer player, float amount, string bone)
private void AdjustCalories(BasePlayer player, float amount, float time)
private void AdjustHydration(BasePlayer player, float amount, float time)
private void AdjustRadiation(BasePlayer player, float amount, float time)
private void setattribute(Arg arg, Type type)
private BasePlayer GetUsePlayer(Arg arg, int playerArgument)
public void ResetSleepingBagTimers(Arg arg)
public void bench_io(Arg arg)
public void completeMissionStage(Arg arg)
public void completeMission(Arg arg)
public void startTutorial(Arg arg)
public void completeTutorial(Arg arg)
public void quitTutorial(Arg arg)
public void tutorialStatus(Arg arg)
internal void <bench_io>g__Connect|39_0(IOEntity InputIOEnt, IOEntity OutputIOEnt)
}
public ConVar.Decay : ConsoleSystem {
public float outside_test_range
public float tick
public float scale
public bool debug
public bool upkeep
public float upkeep_period_minutes
public float upkeep_grief_protection
public float upkeep_heal_scale
public float upkeep_inside_decay_scale
public float delay_override
public float delay_twig
public float delay_wood
public float delay_stone
public float delay_metal
public float delay_toptier
public float duration_override
public float duration_twig
public float duration_wood
public float duration_stone
public float duration_metal
public float duration_toptier
public int bracket_0_blockcount
public float bracket_0_costfraction
public int bracket_1_blockcount
public float bracket_1_costfraction
public int bracket_2_blockcount
public float bracket_2_costfraction
public int bracket_3_blockcount
public float bracket_3_costfraction
}
public ConVar.Demo : ConsoleSystem {
public UInt32 Version
public float splitseconds
public float splitmegabytes
public string recordlist
private int _recordListModeValue
public bool UploadDemos
public string UploadUrl
public bool ServerDemosEnabled
public int ServerDemoFlushInterval
public float UploadBandwidthLimitRatio
public string ServerDemoDirectory
public bool DeleteDemoAfterUpload
public bool ZipServerDemos
public int MaxDemoDiskSpaceGB
public int DemoDiskCleanupIntervalMinutes
public int DemoUploadConcurrency
public int recordlistmode
public bool get_UploadDemos()
public void set_UploadDemos(bool value)
public string get_UploadUrl()
public void set_UploadUrl(string value)
public bool get_ServerDemosEnabled()
public void set_ServerDemosEnabled(bool value)
public int get_ServerDemoFlushInterval()
public void set_ServerDemoFlushInterval(int value)
public float get_UploadBandwidthLimitRatio()
public void set_UploadBandwidthLimitRatio(float value)
public string get_ServerDemoDirectory()
public void set_ServerDemoDirectory(string value)
public bool get_DeleteDemoAfterUpload()
public void set_DeleteDemoAfterUpload(bool value)
public bool get_ZipServerDemos()
public void set_ZipServerDemos(bool value)
public int get_MaxDemoDiskSpaceGB()
public void set_MaxDemoDiskSpaceGB(int value)
public int get_DemoDiskCleanupIntervalMinutes()
public void set_DemoDiskCleanupIntervalMinutes(int value)
public int get_DemoUploadConcurrency()
public void set_DemoUploadConcurrency(int value)
public void BenchmarkDemoUpload(Arg arg)
public int get_recordlistmode()
public void set_recordlistmode(int value)
public string record(Arg arg)
public string stop(Arg arg)
}
public ConVar.Entity : ConsoleSystem {
private TextTable GetEntityTable(Func`2<EntityInfo, bool> filter)
public void find_entity(Arg args)
public void find_id(Arg args)
public void find_group(Arg args)
public void find_parent(Arg args)
public void find_status(Arg args)
public void find_radius(Arg args)
public void find_self(Arg args)
public void debug_toggle(Arg args)
public void nudge(Arg args)
public EntitySpawnRequest GetSpawnEntityFromName(string name)
public string svspawn(string name, Vector3 pos, Vector3 dir, int forceUp)
public string svspawnitem(string name, Vector3 pos)
public string svspawngrid(string name, int width, int height, int spacing)
public void spawnlootfrom(Arg args)
public int DeleteBy(ulong id)
public int DeleteBy(Arg arg)
private int DeleteBy(List`1<ulong> ids)
public void DeleteByTextBlock(Arg arg)
}
public ConVar.Env : ConsoleSystem {
public bool nightlight_enabled
public bool nightlight_debugcamera_enabled
private float nightlight_distance_internal
private float nightlight_fadefraction_internal
private float nightlight_brightness_internal
public bool progresstime
public float time
public int day
public int month
public int year
public float oceanlevel
public float nightlight_distance
public float nightlight_fadefraction
public float nightlight_brightness
public void set_progresstime(bool value)
public bool get_progresstime()
public void set_time(float value)
public float get_time()
public void set_day(int value)
public int get_day()
public void set_month(int value)
public int get_month()
public void set_year(int value)
public int get_year()
public void addtime(Arg arg)
public float get_oceanlevel()
public void set_oceanlevel(float value)
public float get_nightlight_distance()
public void set_nightlight_distance(float value)
public float get_nightlight_fadefraction()
public void set_nightlight_fadefraction(float value)
public float get_nightlight_brightness()
public void set_nightlight_brightness(float value)
}
public ConVar.FileConVar : ConsoleSystem {
public bool debug
public bool time
public bool get_debug()
public void set_debug(bool value)
public bool get_time()
public void set_time(bool value)
}
public ConVar.FPS : ConsoleSystem {
private int _limit
private int m_graph
public int limit
public int graph
public int get_limit()
public void set_limit(int value)
public int get_graph()
public void set_graph(int value)
}
public ConVar.gamemode : ConsoleSystem {
public void setteam(Arg arg)
public void set(Arg arg)
}
public ConVar.GC : ConsoleSystem {
public bool buffer_enabled
public int debuglevel
public int buffer
public int safeBuffer
public bool incremental_enabled
public int incremental_milliseconds
public bool enabled
public int get_safeBuffer()
public void set_safeBuffer(int value)
public bool get_incremental_enabled()
public void set_incremental_enabled(bool value)
public int get_incremental_milliseconds()
public void set_incremental_milliseconds(int value)
public bool get_enabled()
public void set_enabled(bool value)
public void collect()
public void unload()
public void alloc(Arg args)
}
public ConVar.Global : ConsoleSystem {
private int _developer
public bool skipAssetWarmup_crashes
public int maxthreads
private int DefaultWarmupConcurrency
private int DefaultPreloadConcurrency
public int warmupConcurrency
public int preloadConcurrency
public bool forceUnloadBundles
private bool DefaultAsyncWarmupEnabled
public bool asyncWarmup
public int asyncLoadingPreset
public bool updateNetworkPositionWithDebugCameraWhileSpectating
public int perf
public bool god
public bool cinematicGingerbreadCorpses
private UInt32 _gingerbreadMaterialID
public float SprayOutOfAuthMultiplier
public float SprayDuration
public int MaxSpraysPerPlayer
public bool disableBagDropping
public bool blockEmojiAnimations
public bool blockEmoji
public bool blockServerEmoji
public bool showEmojiErrors
public int developer
public int job_system_threads
public void set_developer(int value)
public int get_developer()
public int get_job_system_threads()
public void set_job_system_threads(int value)
public void ApplyAsyncLoadingPreset()
public void restart(Arg args)
public void quit(Arg args)
public void report(Arg args)
public void objects(Arg args)
public void textures(Arg args)
public void colliders(Arg args)
public void error(Arg args)
public void queue(Arg args)
public void setinfo(Arg args)
public void sleep(Arg args)
public void sleeptarget(Arg args)
public void kill(Arg args)
public void respawn(Arg args)
public void injure(Arg args)
public void InjurePlayer(BasePlayer ply)
public void recover(Arg args)
public void RecoverPlayer(BasePlayer ply)
public void spectate(Arg args)
public void toggleSpectateTeamInfo(Arg args)
public void spectateid(Arg args)
public void respawn_sleepingbag(Arg args)
public void respawn_sleepingbag_remove(Arg args)
public void status_sv(Arg args)
public void status_cl(Arg args)
public void teleport(Arg args)
public void teleport2me(Arg args)
public void teleporteveryone2me(Arg args)
public void teleportsleepers2me(Arg args)
public void teleportnonsleepers2me(Arg args)
private void TeleportPlayersToMe(BasePlayer player, bool includeSleepers, bool includeNonSleepers)
public void teleportany(Arg args)
public void teleportpos(Arg args)
public void teleportlos(Arg args)
public void teleport2owneditem(Arg arg)
public void teleport2autheditem(Arg arg)
public void teleport2marker(Arg arg)
private void TeleportToMarker(MapNote marker, BasePlayer player)
public void teleport2death(Arg arg)
public void free(Arg args)
public void version(Arg arg)
public void sysinfo(Arg arg)
public void sysuid(Arg arg)
public void breakitem(Arg args)
public void breakclothing(Arg args)
public void subscriptions(Arg arg)
public UInt32 GingerbreadMaterialID()
public void ClearAllSprays()
public void ClearAllSpraysByPlayer(Arg arg)
public void ClearSpraysInRadius(Arg arg)
private int ClearSpraysInRadius(Vector3 position, float radius)
public void ClearSpraysAtPositionInRadius(Arg arg)
public void ClearDroppedItems()
public string printAllScenesInBuild(Arg args)
public void UpdateManifest(Arg args)
internal void <respawn_sleepingbag>g__NexusRespawn|39_0(BasePlayer player, NexusZoneDetails toZone, NetworkableId sleepingBag)
internal void <respawn_sleepingbag_remove>g__NexusRemoveBag|40_0(BasePlayer player, string zoneKey, NetworkableId sleepingBag)
}
public ConVar.Graphics : ConsoleSystem {
private float MinShadowDistance
private float MaxShadowDistance2Split
private float MaxShadowDistance4Split
private float _shadowdistance
public int shadowmode
public int shadowlights
private int _shadowquality
public bool grassshadows
public bool contactshadows
public float drawdistance
private EncryptedValue`1<float> _fov
public bool hud
public bool chat
public bool branding
public int compass
public bool dof
public float dof_aper
public float dof_blur
public int dof_mode
public float dof_focus_dist
public float dof_focus_time
public float dof_squeeze
public float dof_barrel
public bool dof_debug
public int dof_kernel_count
public BaseEntity dof_focus_target_entity
public bool vm_fov_scale
public bool vm_horizontal_flip
private float _uiscale
private int _anisotropic
private int _parallax
public int quality
public float shadowdistance
public int shadowcascades
public int shadowquality
public float fov
public float lodbias
public int shaderlod
public float uiscale
public int af
public int parallax
public bool itemskins
public bool itemskinunload
public float itemskintimeout
public int get_quality()
public void set_quality(int value)
public float EnforceShadowDistanceBounds(float distance)
public float get_shadowdistance()
public void set_shadowdistance(float value)
public int get_shadowcascades()
public void set_shadowcascades(int value)
public int get_shadowquality()
public void set_shadowquality(int value)
public float get_fov()
public void set_fov(float value)
public float get_lodbias()
public void set_lodbias(float value)
public void dof_focus_target(Arg arg)
public void dof_nudge(Arg arg)
public int get_shaderlod()
public void set_shaderlod(int value)
public float get_uiscale()
public void set_uiscale(float value)
public int get_af()
public void set_af(int value)
public int get_parallax()
public void set_parallax(int value)
public bool get_itemskins()
public void set_itemskins(bool value)
public bool get_itemskinunload()
public void set_itemskinunload(bool value)
public float get_itemskintimeout()
public void set_itemskintimeout(float value)
}
public ConVar.Halloween : ConsoleSystem {
public bool enabled
public float murdererpopulation
public float scarecrowpopulation
public bool scarecrows_throw_beancans
public float scarecrow_throw_beancan_global_delay
public float scarecrow_beancan_vs_player_dmg_modifier
public float scarecrow_body_dmg_modifier
public float scarecrow_chase_stopping_distance
}
public ConVar.Harmony : ConsoleSystem {
public void Load(Arg args)
public void Unload(Arg args)
}
public ConVar.Hierarchy : ConsoleSystem {
private GameObject currentDir
private Transform[] GetCurrent()
public void ls(Arg args)
public void cd(Arg args)
public void del(Arg args)
}
public ConVar.instruments : ConsoleSystem {
public string InstrumentsFolder
}
public ConVar.Inventory : ConsoleSystem {
public bool disableAttireLimitations
private string LoadoutDirectory
public void lighttoggle(Arg arg)
public void endloot(Arg arg)
public void give(Arg arg)
public void resetbp(Arg arg)
public void unlockall(Arg arg)
public void giveall(Arg arg)
public void giveto(Arg arg)
public void giveid(Arg arg)
public void givearm(Arg arg)
public void pipetteid(Arg arg)
public void copyTo(Arg arg)
public void copyTo(BasePlayer from, BasePlayer toply)
public void deployLoadoutInRange(Arg arg)
public void deployLoadout(Arg arg)
public void clearInventory(Arg arg)
private string GetLoadoutPath(string loadoutName)
public void saveloadout(Arg arg)
public bool LoadLoadout(string name, SavedLoadout& so)
public void listloadouts(Arg arg)
public void defs(Arg arg)
public void reloaddefs(Arg arg)
public void equipslottarget(Arg arg)
public void equipslot(Arg arg)
public void EquipItemInSlot(BasePlayer player, int slot)
private int GetSlotIndex(BasePlayer player)
public void giveBp(Arg arg)
}
public ConVar.Manifest : object {
public object PrintManifest()
public object PrintManifestRaw()
}
public ConVar.MemSnap : ConsoleSystem {
private string NeedProfileFolder()
public void managed(Arg arg)
public void native(Arg arg)
public void full(Arg arg)
}
public ConVar.Music : ConsoleSystem {
public bool enabled
public int songGapMin
public int songGapMax
public void info(Arg arg)
}
public ConVar.Net : ConsoleSystem {
public bool visdebug
public bool debug
public int visibilityRadiusFarOverride
public int visibilityRadiusNearOverride
public bool globalNetworkedBases
public bool global_network_debug
public bool network_group_debug
public bool limit_global_update_broadcast
}
public ConVar.Nexus : ConsoleSystem {
public Phrase RedirectPhrase
private string DefaultEndpoint
public string endpoint
public bool logging
public string secretKey
public string zoneController
public int messageLockDuration
public int transferFlushTime
public float islandSpawnDistance
public float defaultZoneContactRadius
public float timeOffset
public float rpcTimeoutMultiplier
public float loadingTimeout
public float pingInterval
public float protectionDuration
public float clanClatBatchDuration
public float playerManifestInterval
public float mapImageScale
public void transfer(Arg arg)
public void refreshislands(Arg arg)
public void ping(Arg arg)
public void broadcast_ping(Arg arg)
public void playeronline(Arg arg)
public void uploadmap(Arg arg)
internal void <ping>g__SendPing|20_0(BasePlayer requester, string to)
internal void <broadcast_ping>g__SendBroadcastPing|21_0(BasePlayer requester)
}
public ConVar.PatrolHelicopter : ConsoleSystem {
private string path
public float lifetimeMinutes
public int guns
public float bulletDamageScale
public float bulletAccuracy
public void drop(Arg arg)
public void calltome(Arg arg)
public void call(Arg arg)
public void strafe(Arg arg)
public void orbit(Arg arg)
public void orbitstrafe(Arg arg)
public void move(Arg arg)
public void flee(Arg arg)
public void patrol(Arg arg)
public void death(Arg arg)
public void testpuzzle(Arg arg)
}
public ConVar.Physics : ConsoleSystem {
public int droppedmode
public bool sendeffects
public bool groundwatchdebug
public int groundwatchfails
public float groundwatchdelay
public int serverragdollmode
private float baseGravity
private bool _serversideragdolls
public bool batchsynctransforms
private bool _treecollision
public float bouncethreshold
public float sleepthreshold
public int solveriterationcount
public float gravity
public bool serversideragdolls
public bool autosynctransforms
public bool treecollision
public float get_bouncethreshold()
public void set_bouncethreshold(float value)
public float get_sleepthreshold()
public void set_sleepthreshold(float value)
public int get_solveriterationcount()
public void set_solveriterationcount(int value)
internal void ApplyDropped(Rigidbody rigidBody)
public float get_gravity()
public void set_gravity(float value)
public bool get_serversideragdolls()
public void set_serversideragdolls(bool value)
public bool get_autosynctransforms()
public void set_autosynctransforms(bool value)
public bool get_treecollision()
public void set_treecollision(bool value)
}
public ConVar.Ping : ConsoleSystem {
public int ping_samples
public bool ping_parallel
public int ping_refresh_interval
public bool auto_refresh_region
public bool ping_estimate_logging
public bool ping_estimation
public int get_ping_samples()
public void set_ping_samples(int value)
public bool get_ping_parallel()
public void set_ping_parallel(bool value)
public int get_ping_refresh_interval()
public void set_ping_refresh_interval(int value)
public bool get_auto_refresh_region()
public void set_auto_refresh_region(bool value)
public bool get_ping_estimate_logging()
public void set_ping_estimate_logging(bool value)
public bool get_ping_estimation()
public void set_ping_estimation(bool value)
}
public ConVar.Player : ConsoleSystem {
public string serverTickRateDefaultString
public int serverTickRate
public int serverTickRateDefault
public int serverTickRateMin
public int serverTickRateMax
public float serverTickInterval
public string clientTickRateDefaultString
public int clientTickRateDefault
public int clientTickRateMin
public int clientTickRateMax
public EncryptedValue`1<int> clientTickRate
public EncryptedValue`1<float> clientTickInterval
public bool InfiniteAmmo
public bool woundforever
public int tickrate_sv
public int tickrate_cl
public int get_tickrate_sv()
public void set_tickrate_sv(int value)
public int get_tickrate_cl()
public void set_tickrate_cl(int value)
public void cinematic_play(Arg arg)
public void cinematic_stop(Arg arg)
public void cinematic_gesture(Arg arg)
public void copyrotation(Arg arg)
public void abandonmission(Arg arg)
public void mount(Arg arg)
public void gotosleep(Arg arg)
public void dismount(Arg arg)
public void swapseat(Arg arg)
public void wakeup(Arg arg)
public void wakeupall(Arg arg)
public void printstats(Arg arg)
public void printpresence(Arg arg)
public void resetstate(Arg args)
public void fillwater(Arg arg)
public void reloadweapons(Arg arg)
public void createskull(Arg arg)
public string createTrophy(Arg arg)
public void trigger_wildlife_trap(Arg arg)
public void gesture_radius(Arg arg)
public void gesture_radius_notme(Arg arg)
public void gesture_radius(Arg arg, bool includeMe)
public void stopgesture_radius(Arg arg)
public void markhostile(Arg arg)
}
public ConVar.Pool : ConsoleSystem {
public int mode
public bool prewarm
public bool enabled
public bool debug
public void print_memory(Arg arg)
public void print_arraypool(Arg arg)
public void print_prefabs(Arg arg)
public void print_assets(Arg arg)
public void clear_memory(Arg arg)
public void clear_prefabs(Arg arg)
public void clear_assets(Arg arg)
public void export_prefabs(Arg arg)
public void fill_prefabs(Arg arg)
}
public ConVar.Profile : ConsoleSystem {
private void NeedProfileFolder()
public void start(Arg arg)
public void stop(Arg arg)
public void flush_analytics(Arg arg)
}
public ConVar.Render : ConsoleSystem {
public bool use_normal_rendering
private bool <show_building_blocked_client>k__BackingField
private float <building_blocked_preview_distance>k__BackingField
private bool <show_building_blocked_server>k__BackingField
public int instanced_rendering
public bool instanced_toggle_all
public bool instanced_toggle_cliffs
public bool instanced_toggle_buildings
public bool instanced_toggle_other
public bool multidraw
public int upload_multidraw_meshes_mode
public bool render_shadows
public bool computebuffer_setdata_immediate
public int max_renderers
public float instancing_render_distance
public bool IsInstancingDisabled
public bool IsInstancingEnabled
public bool show_building_blocked_client
public float building_blocked_preview_distance
public bool show_building_blocked_server
public bool IsMultidrawEnabled
public bool get_IsInstancingDisabled()
public bool get_IsInstancingEnabled()
public bool get_show_building_blocked_client()
public void set_show_building_blocked_client(bool value)
public float get_building_blocked_preview_distance()
public void set_building_blocked_preview_distance(float value)
public bool get_show_building_blocked_server()
public void set_show_building_blocked_server(bool value)
public bool get_IsMultidrawEnabled()
public void tree_entities(Arg arg)
public void print_global_entities(Arg arg)
private void global_entities_client(StringBuilder builder)
public void instanced_memory_usage(Arg arg)
public void test_instancing_culling(Arg arg)
public void instanced_renderers_debug(Arg arg)
public void print_instanced_grid(Arg arg)
public void expand_instancing(Arg arg)
}
public ConVar.Sentry : ConsoleSystem {
public bool targetall
public float hostileduration
public float interferenceradius
public int maxinterference
public bool debugPreventDuplicates
}
public ConVar.Server : ConsoleSystem {
public string ip
public int port
public int queryport
public int maxplayers
public string hostname
public string identity
public string level
public string levelurl
public bool leveltransfer
public int seed
public int salt
public int worldsize
public int saveinterval
public bool secure
public int encryption
public string anticheatid
public string anticheatkey
public bool anticheattoken
public bool strictauth_eac
public bool strictauth_steam
public int tickrate
public int entityrate
public float schematime
public float cycletime
public bool official
public bool stats
public bool stability
public bool radiation
public float itemdespawn
public float itemdespawn_container_scale
public int itemdespawn_container_max_multiplier
public float itemdespawn_quick
public float corpsedespawn
public float debrisdespawn
public bool pve
public bool cinematic
public string description
public string url
public string branch
public int queriesPerSecond
public int ipQueriesPerMin
public bool statBackup
public int rejoin_delay
public string ping_region_code_override
private string _favoritesEndpoint
public string headerimage
public string logoimage
public int saveBackupCount
public string motd
public float meleedamage
public float arrowdamage
public float bulletdamage
public float bleedingdamage
public float oilrig_radiation_amount_scale
public float oilrig_radiation_time_scale
public float oilrig_radiation_alarm_threshold
public float funWaterDamageThreshold
public float funWaterWetnessGain
public float meleearmor
public float arrowarmor
public float bulletarmor
public float bleedingarmor
public int updatebatch
public int updatebatchspawn
public int entitybatchsize
public float entitybatchtime
public float composterUpdateInterval
public float planttick
public float planttickscale
public bool useMinimumPlantCondition
public float nonPlanterDeathChancePerTick
public float ceilingLightGrowableRange
public float artificialTemperatureGrowableRange
public float ceilingLightHeightOffset
public float sprinklerRadius
public float sprinklerEyeHeightOffset
public float optimalPlanterQualitySaturation
public float metabolismtick
public float modifierTickRate
public float rewounddelay
public bool woundingenabled
public bool crawlingenabled
public float woundedrecoverchance
public float incapacitatedrecoverchance
public float woundedmaxfoodandwaterbonus
public int crawlingminimumhealth
public int crawlingmaximumhealth
public bool playerserverfall
public bool plantlightdetection
public float respawnresetrange
public int max_sleeping_bags
public int max_shelters
public bool bag_quota_item_amount
public int maxunack
public bool netcache
public bool corpses
public bool events
public bool dropitems
public int netcachesize
public int savecachesize
public int combatlogsize
public int combatlogdelay
public int authtimeout
public int playertimeout
public int idlekick
public int idlekickmode
public int idlekickadmins
public string gamemode
private string _tags
public bool censorplayerlist
public string bansServerEndpoint
public int bansServerFailureMode
public int bansServerTimeout
public string reportsServerEndpoint
public string reportsServerEndpointKey
public bool printReportsToConsole
public bool respawnAtDeathPosition
public bool respawnWithLoadout
public bool waterContainersLeaveWaterBehind
public float conveyorMoveFrequency
public float industrialCrafterFrequency
public int defaultBlueprintResearchCost
public bool enforcePipeChecksOnBuildingBlockChanges
public int maxItemStacksMovedPerTickIndustrial
public float industrialFrameBudgetMs
public bool industrialTransferStrictTimeLimits
public bool industrialAllowQuickMove
public int maximumMapMarkers
public int maximumPings
public float pingDuration
public bool canEquipBackpacksInAir
public float parachuteRepackTime
public bool emojiOwnershipCheck
public bool skipDeathScreenFade
public bool tutorialEnabled
public float workbench1TaxRate
public bool autoUploadMap
public float workbench2TaxRate
public float workbench3TaxRate
public bool showHolsteredItems
public int maxpacketspersecond_world
public int maxpacketspersecond_rpc
public int maxpacketspersecond_rpc_signal
public int maxpacketspersecond_command
public int maxpacketsize_command
public int maxpacketsize_globaltrees
public int maxpacketsize_globalentities
public int maxpacketspersecond_tick
public int maxpacketspersecond_voice
public bool packetlog_enabled
public bool rpclog_enabled
public string server_id
public string favoritesEndpoint
public int anticheatlog
public string tags
public int maxclientinfosize
public int maxconnectionsperip
public int maxreceivetime
public int maxmainthreadwait
public int maxreadthreadwait
public int maxwritethreadwait
public int maxdecryptthreadwait
public int maxreadqueuelength
public int maxwritequeuelength
public int maxdecryptqueuelength
public int maxreadqueuebytes
public int maxwritequeuebytes
public int maxdecryptqueuebytes
public int player_state_cache_size
public int maxpacketspersecond
public string rootFolder
public string backupFolder
public string backupFolder1
public string backupFolder2
public string backupFolder3
public bool compression
public bool netlog
public string get_server_id()
public void set_server_id(string value)
public string get_favoritesEndpoint()
public void set_favoritesEndpoint(string value)
public int get_anticheatlog()
public void set_anticheatlog(int value)
public string get_tags()
public void set_tags(string value)
public float GetTaxRateForWorkbenchUnlock(int workbenchLevel)
public float TickDelta()
public float TickTime(UInt32 tick)
public void setshowholstereditems(Arg arg)
public int get_maxclientinfosize()
public void set_maxclientinfosize(int value)
public int get_maxconnectionsperip()
public void set_maxconnectionsperip(int value)
public int get_maxreceivetime()
public void set_maxreceivetime(int value)
public int get_maxmainthreadwait()
public void set_maxmainthreadwait(int value)
public int get_maxreadthreadwait()
public void set_maxreadthreadwait(int value)
public int get_maxwritethreadwait()
public void set_maxwritethreadwait(int value)
public int get_maxdecryptthreadwait()
public void set_maxdecryptthreadwait(int value)
public int get_maxreadqueuelength()
public void set_maxreadqueuelength(int value)
public int get_maxwritequeuelength()
public void set_maxwritequeuelength(int value)
public int get_maxdecryptqueuelength()
public void set_maxdecryptqueuelength(int value)
public int get_maxreadqueuebytes()
public void set_maxreadqueuebytes(int value)
public int get_maxwritequeuebytes()
public void set_maxwritequeuebytes(int value)
public int get_maxdecryptqueuebytes()
public void set_maxdecryptqueuebytes(int value)
public int get_player_state_cache_size()
public void set_player_state_cache_size(int value)
public void player_state_cache_count(Arg args)
public void player_state_cache_evictions(Arg args)
public string printreadqueue(Arg arg)
public string printwritequeue(Arg arg)
public string printdecryptqueue(Arg arg)
public int get_maxpacketspersecond()
public void set_maxpacketspersecond(int value)
public string packetlog(Arg arg)
public string rpclog(Arg arg)
public void start(Arg arg)
public void stop(Arg arg)
public string get_rootFolder()
public string get_backupFolder()
public string get_backupFolder1()
public string get_backupFolder2()
public string get_backupFolder3()
public void backup()
public string GetServerFolder(string folder)
public void writecfg(Arg arg)
public void fps(Arg arg)
public void save(Arg arg)
public string readcfg(Arg arg)
public bool get_compression()
public void set_compression(bool value)
public bool get_netlog()
public void set_netlog(bool value)
public string netprotocol(Arg arg)
public void cheatreport(Arg arg)
public void corpseinfo(Arg arg)
public string combatlog(Arg arg)
public string combatlog_outgoing(Arg arg)
public string printpos(Arg arg)
public string printrot(Arg arg)
public string printeyes(Arg arg)
public void snapshot(Arg arg)
public void sendnetworkupdate(Arg arg)
public void playerlistpos(Arg arg)
public void listvendingmachines(Arg arg)
public void listtoolcupboards(Arg arg)
public void BroadcastPlayVideo(Arg arg)
public void ResetServerEmoji()
private string AutoCorrectTags(string value)
internal void <AutoCorrectTags>g__Add|258_1(String[] options, <>c__DisplayClass258_0& )
}
public ConVar.Spawn : ConsoleSystem {
public float min_rate
public float max_rate
public float min_density
public float max_density
public float player_base
public float player_scale
public bool respawn_populations
public bool respawn_groups
public bool respawn_individuals
public float tick_populations
public float tick_individuals
public void fill_populations(Arg args)
public void fill_groups(Arg args)
public void fill_individuals(Arg args)
public void report(Arg args)
public void scalars(Arg args)
public void cargoshipevent(Arg args)
public void ch47event(Arg args)
public void cargoshipdockingtest(Arg args)
}
public ConVar.SSS : ConsoleSystem {
public bool enabled
public int quality
public bool halfres
public float scale
}
public ConVar.Stability : ConsoleSystem {
public int verbose
public int strikes
public float collapse
public float accuracy
public float stabilityqueue
public float surroundingsqueue
public void refresh_stability(Arg args)
}
public ConVar.Steam : object {
private bool <server_allow_steam_nicknames>k__BackingField
public bool server_allow_steam_nicknames
public bool get_server_allow_steam_nicknames()
public void set_server_allow_steam_nicknames(bool value)
}
public ConVar.Supply : ConsoleSystem {
private string path
public void drop(Arg arg)
public void call(Arg arg)
}
public ConVar.SystemCommands : object {
public void cpu_affinity(Arg arg)
public void cpu_priority(Arg arg)
}
public ConVar.Terrain : ConsoleSystem {
public float quality
}
public ConVar.Texture : ConsoleSystem {
public int streamingBudgetOverride
public bool streaming
public bool get_streaming()
public void set_streaming(bool value)
public void stats(Arg arg)
}
public ConVar.Time : ConsoleSystem {
public bool pausewhileloading
private int _cl_steps
private int _cl_maxstepsperframe
public int sv_steps
public int sv_maxstepsperframe
public float timescale
public int cl_steps
public int cl_maxstepsperframe
public int get_sv_steps()
public void set_sv_steps(int value)
public int get_sv_maxstepsperframe()
public void set_sv_maxstepsperframe(int value)
public float get_timescale()
public void set_timescale(float value)
public int get_cl_steps()
public void set_cl_steps(int value)
public int get_cl_maxstepsperframe()
public void set_cl_maxstepsperframe(int value)
}
public ConVar.Tree : ConsoleSystem {
public bool global_broadcast
public bool simplified_collider
}
public ConVar.vehicle : ConsoleSystem {
public float boat_corpse_seconds
public bool cinematictrains
public bool trainskeeprunning
public bool carwrecks
public bool vehiclesdroploot
public void swapseats(Arg arg)
public void fixcars(Arg arg)
public void autohover(Arg arg)
public void stop_all_trains(Arg arg)
public void killcars(Arg args)
public void killpushbikes(Arg args)
public void killmotorbikes(Arg args)
public void killminis(Arg args)
public void killscraphelis(Arg args)
public void killtrains(Arg args)
public void killboats(Arg args)
public void killdrones(Arg args)
public void boatdriftinfo(Arg args)
}
public ConVar.Vis : ConsoleSystem {
public bool lerp
public bool damage
public bool attack
public bool protection
public bool weakspots
public bool triggers
public bool hitboxes
public bool lineofsight
public bool sense
}
public ConVar.Voice : ConsoleSystem {
public bool loopback
private float _voiceRangeBoostAmount
public float voiceRangeBoostAmount
public float get_voiceRangeBoostAmount()
public void set_voiceRangeBoostAmount(float value)
public void ToggleVoiceRangeBoost(Arg arg)
}
public ConVar.Water : ConsoleSystem {
public int quality
public int MaxQuality
public int MinQuality
public int reflections
public int MaxReflections
public int MinReflections
public bool scaled_time
}
public ConVar.Weather : ConsoleSystem {
public float wetness_rain
public float wetness_snow
public float ocean_time
public float clear_chance
public float dust_chance
public float fog_chance
public float overcast_chance
public float storm_chance
public float rain_chance
public float rain
public float wind
public float thunder
public float rainbow
public float fog
public float atmosphere_rayleigh
public float atmosphere_mie
public float atmosphere_brightness
public float atmosphere_contrast
public float atmosphere_directionality
public float cloud_size
public float cloud_opacity
public float cloud_coverage
public float cloud_sharpness
public float cloud_coloring
public float cloud_attenuation
public float cloud_saturation
public float cloud_scattering
public float cloud_brightness
public float ocean_scale
public void load(Arg args)
public WeatherPreset GetWeatherPreset(string withName)
public void reset(Arg args)
public void report(Arg args)
public float get_clear_chance()
public void set_clear_chance(float value)
public float get_dust_chance()
public void set_dust_chance(float value)
public float get_fog_chance()
public void set_fog_chance(float value)
public float get_overcast_chance()
public void set_overcast_chance(float value)
public float get_storm_chance()
public void set_storm_chance(float value)
public float get_rain_chance()
public void set_rain_chance(float value)
public float get_rain()
public void set_rain(float value)
public float get_wind()
public void set_wind(float value)
public float get_thunder()
public void set_thunder(float value)
public float get_rainbow()
public void set_rainbow(float value)
public float get_fog()
public void set_fog(float value)
public float get_atmosphere_rayleigh()
public void set_atmosphere_rayleigh(float value)
public float get_atmosphere_mie()
public void set_atmosphere_mie(float value)
public float get_atmosphere_brightness()
public void set_atmosphere_brightness(float value)
public float get_atmosphere_contrast()
public void set_atmosphere_contrast(float value)
public float get_atmosphere_directionality()
public void set_atmosphere_directionality(float value)
public float get_cloud_size()
public void set_cloud_size(float value)
public float get_cloud_opacity()
public void set_cloud_opacity(float value)
public float get_cloud_coverage()
public void set_cloud_coverage(float value)
public float get_cloud_sharpness()
public void set_cloud_sharpness(float value)
public float get_cloud_coloring()
public void set_cloud_coloring(float value)
public float get_cloud_attenuation()
public void set_cloud_attenuation(float value)
public float get_cloud_saturation()
public void set_cloud_saturation(float value)
public float get_cloud_scattering()
public void set_cloud_scattering(float value)
public float get_cloud_brightness()
public void set_cloud_brightness(float value)
public float get_ocean_scale()
public void set_ocean_scale(float value)
}
public ConVar.Workshop : ConsoleSystem {
public void print_approved_skins(Arg arg)
}
public ConVar.World : ConsoleSystem {
public bool cache
public bool streaming
public string configString
public string configFile
public void monuments(Arg arg)
public void rendermap(Arg arg)
public void rendertunnels(Arg arg)
public void renderlabs(Arg arg)
private void RenderMapLayerToFile(Arg arg, string name, MapLayer layer)
}
public ConVar.XMas : ConsoleSystem {
private string path
public bool enabled
public float spawnRange
public int spawnAttempts
public int giftsPerPlayer
public void refill(Arg arg)
}
public ConvarComponent : MonoBehaviour {
public bool runOnServer
public bool runOnClient
public List`1<ConvarEvent> List
protected void OnEnable()
protected void OnDisable()
private bool ShouldRun()
}
public ConvarControlledSpawnPopulation : DensitySpawnPopulation {
public string PopulationConvar
private Command _command
protected Command Command
public float TargetDensity
protected Command get_Command()
public float get_TargetDensity()
}
public ConvarControlledSpawnPopulationRail : ConvarControlledSpawnPopulation {
private float MIN_MARGIN
public bool GetSpawnPosOverride(Prefab`1<Spawnable> prefab, Vector3& newPos, Quaternion& newRot)
public void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
protected int GetPrefabWeight(Prefab`1<Spawnable> prefab)
private bool TryGetRandomPointOnSpline(TrainTrackSpline spline, TrainCar trainCar, Vector3& pos, Quaternion& rot)
}
public ConvarControllerSpawnPointPopulation : ConvarControlledSpawnPopulation {
public SpawnPointType spawnPointType
private List`1<BaseSpawnPoint> spawnPoints
public bool GetSpawnPosOverride(Prefab`1<Spawnable> prefab, Vector3& newPos, Quaternion& newRot)
private bool TryGetSpawnPoints(List`1& result)
}
public ConvarToggleChildren : MonoBehaviour {
public string ConvarName
public string ConvarEnabled
private bool state
private Command Command
protected void Awake()
protected void Update()
private void SetState(bool newState)
}
public ConvarWater : MonoBehaviour {
public WaterSystem water
}
public ConversationData : ScriptableObject {
public string shortname
public Phrase providerNameTranslated
public Sprite providerIcon
public bool canBeCancelled
public SpeechNode[] speeches
public string providerName
public string get_providerName()
public int GetSpeechNodeIndex(string speechShortName)
public void FindAllMissionAssignments(List`1<BaseMission> results)
}
public CopyLODValues : MonoBehaviour {
private LODGroup source
private LODGroup destination
private bool scale
public bool CanCopy()
public void Copy()
}
public CopyText : MonoBehaviour {
public RustText TargetText
public void TriggerCopy()
}
public CoverageQueries : MonoBehaviour {
public float depthBias
public bool debug
}
public CoverageQueryFlare : BaseMonoBehaviour {
public bool isDynamic
public bool timeShimmer
public bool positionalShimmer
public bool rotate
public float maxVisibleDistance
public bool lightScaled
public float dotMin
public float dotMax
public RadiusSpace coverageRadiusSpace
public float coverageRadius
public LODDistanceMode DistanceMode
}
public CraftingNotice : MonoBehaviour {
public CanvasGroup canvasGroup
public TextMeshProUGUI itemName
public TextMeshProUGUI craftSeconds
}
public CraftingQueue : SingletonComponent`1<CraftingQueue> {
public GameObject queueContainer
public GameObject queueItemPrefab
private ScrollRect scrollRect
}
public CraftingQueueIcon : MonoBehaviour {
public CanvasGroup canvasGroup
public Image icon
public Image iconCancel
public GameObject timeLeft
public GameObject craftingCount
}
public Craptography : object {
private Byte[] hash
public void XOR(UInt32 seed, ArraySegment`1<byte> src, ArraySegment`1& dst)
}
public CreateEffect : MonoBehaviour {
public GameObjectRef EffectToCreate
public void OnEnable()
}
public CreationGibSpawner : BaseMonoBehaviour {
private GameObject gibSource
public GameObject gibsInstance
public float startTime
public float duration
public float buildScaleAdditionalAmount
public AnimationCurve scaleCurve
public AnimationCurve buildCurve
public AnimationCurve buildScaleCurve
public AnimationCurve xCurve
public AnimationCurve yCurve
public AnimationCurve zCurve
public Vector3[] spawnPositions
public GameObject[] particles
public Single[] gibProgress
public PhysicMaterial physMaterial
public List`1<Transform> gibs
public bool started
public GameObjectRef placeEffect
public GameObject smokeEffect
public float effectSpacing
public bool invert
public Vector3 buildDirection
public GibReplacement[] GibReplacements
public EffectMaterialPair[] effectLookup
private float startDelay
public List`1<ConditionalGibSource> conditionalGibSources
private float nextEffectTime
public GameObjectRef GetEffectForMaterial(PhysicMaterial mat)
public void SetDelay(float newDelay)
public void FinishSpawn()
public float GetProgress(float delay)
public void AddConditionalGibSource(GameObject cGibSource, Vector3 pos, Quaternion rot)
public void SetGibSource(GameObject newGibSource)
private int SortsGibs(Transform a, Transform b)
public void Init()
public float GetPushDir(Vector3 spawnPos, Transform theGib)
public void DestroyMe()
public float GetStartDelay(Transform gib)
public void Update()
}
public CrossbowWeapon : BaseProjectile {
public bool ForceSendMagazine(SaveInfo saveInfo)
public void DidAttackServerside()
}
public Crosshair : BaseMonoBehaviour {
public bool Enabled
public Image Image
public RectTransform reticleTransform
public CanvasGroup reticleAlpha
public RectTransform hitNotifyMarker
public CanvasGroup hitNotifyAlpha
public Crosshair instance
public float lastHitTime
public float crosshairAlpha
public float aimconeMultiplier
public float aimconeLerpSpeed
public GameObjectRef pointsSplashEffect
}
public CrushTrigger : TriggerHurt {
public bool includeNPCs
public bool requireCentreBelowPosition
internal GameObject InterestedInObject(GameObject obj)
protected bool CanHurt(BaseCombatEntity ent)
}
public cui : object {
public void cui_test(Arg args)
public void cui_test_update(Arg args)
public void endtest(Arg args)
}
public CullingVolume : MonoBehaviour {
public GameObject OccludeeRoot
public bool Invert
public bool Portal
public List`1<CullingVolume> Connections
}
public CursorManager : SingletonComponent`1<CursorManager> {
private int iHoldOpen
private int iPreviousOpen
private float lastTimeVisible
private float lastTimeInvisible
private void Update()
public void SwitchToGame()
private void SwitchToUI()
public void HoldOpen(bool cursorVisible)
public bool WasVisible(float deltaTime)
public bool WasInvisible(float deltaTime)
}
public CustomDoorManipulator : DoorManipulator {
public Phrase pairAttemptPhrase
private int inputOpenAmount
private int inputCloseAmount
private DoorEffect delayedAction
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPaired()
public void SetupInitialDoorConnection()
public void SetTargetDoor(Door newTargetDoor)
public void DoAction(DoorEffect action)
private void DoDelayedAction()
public void DoActionDoorMissing()
public Door FindDoor(bool allowLocked)
public void RPC_DoPair(RPCMessage msg)
private void PairDoorAttempt(Door door, BasePlayer byPlayer)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int inputSlot)
private int GetPowerAtInput(int slotIndex)
public void Load(LoadInfo info)
}
public CustomPostEffectsResources : ScriptableObject {
public Shader[] shaders
}
public CustomTimerSwitch : TimerSwitch {
public GameObjectRef timerPanelPrefab
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SERVER_SetTime(RPCMessage msg)
public bool CanPlayerAdmin(BasePlayer player)
}
public DamageProperties : ScriptableObject {
public DamageProperties fallback
public HitAreaProperty[] bones
public float GetMultiplier(HitArea area)
public void ScaleDamage(HitInfo info)
}
public DamageRenderer : MonoBehaviour {
private List`1<Material> damageShowingMats
private float maxDamageOpacity
private List`1<DamageShowingRenderer> damageShowingRenderers
private List`1<GlassPane> damageShowingGlassRenderers
}
public DamageToggle : MonoBehaviour {
public Toggle toggle
private void Reset()
}
public DamageUtil : object {
public void RadiusDamage(BaseEntity attackingPlayer, BaseEntity weaponPrefab, Vector3 pos, float minradius, float radius, List`1<DamageTypeEntry> damage, int layers, bool useLineOfSight, bool ignoreAI, bool ignoreAttackingPlayer)
private bool IsIgnoredAI(BaseEntity ent)
}
public DebrisEntity : BaseCombatEntity {
public float DebrisDespawnOverride
public void ServerInit()
public void RemoveCorpse()
public void ResetRemovalTime(float dur)
public float GetRemovalTime()
public void ResetRemovalTime()
public string Categorize()
}
public DebugCameraInfoReadout : SingletonComponent`1<DebugCameraInfoReadout> {
public RustText ReadoutText
}
public DebugWorldPosition : ListComponent`1<DebugWorldPosition> {
public WorldPositionGenerator GeneratorToFake
}
public DecalComponent : PrefabAttribute {
protected Type GetIndexedType()
}
public DecalCull : LODComponent {
public float Distance
}
public DecalRecycle : BasePrefab {
public float LifeTime
public int WarmedUpAmount
}
public DecalRotate : DecalComponent {
public MinMax range
}
public DecalScale : DecalComponent {
public MinMax range
}
public Decay : PrefabAttribute {
private float hours
protected float GetDecayDelay(Enum grade)
protected float GetDecayDuration(Enum grade)
public void BuildingDecayTouch(BuildingBlock buildingBlock)
public void EntityLinkDecayTouch(BaseEntity ent)
public void RadialDecayTouch(Vector3 pos, float radius, int mask)
public bool ShouldDecay(BaseEntity entity)
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public float GetDecayTickOverride()
public float GetHealScale(BaseEntity entity)
public float GetHealDelay(DecayEntity decayEntity)
protected Type GetIndexedType()
}
public DecayEntity : BaseCombatEntity {
public GameObjectRef debrisPrefab
public Vector3 debrisRotationOffset
public DebrisPosition[] DebrisPositions
public UInt32 buildingID
public float decayTimer
public float upkeepTimer
public Upkeep upkeep
public Decay decay
public DecayPoint[] decayPoints
public float lastDecayTick
public float decayVariance
public Upkeep Upkeep
public bool BypassInsideDecayMultiplier
public bool AllowOnCargoShip
public Upkeep get_Upkeep()
public void ResetState()
public void AttachToBuilding(UInt32 id)
public Building GetBuilding()
public BuildingPrivlidge GetBuildingPrivilege()
public void CalculateUpkeepCostAmounts(List`1<ItemAmount> itemAmounts, float multiplier)
public void ServerInit()
internal void DoServerDestroy()
public void AttachToBuilding(DecayEntity other)
public BuildingBlock GetNearbyBuildingBlock()
public void ResetUpkeepTime()
public void DecayTouch()
public void AddUpkeepTime(float time)
public float GetProtectedSeconds()
public float GetEntityDecayDuration()
public float GetEntityHealScale()
public float GetEntityDecayDelay()
public void DecayTick()
public void OnRepairFinished()
public void OnKilled(HitInfo info)
private void SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain)
public bool get_BypassInsideDecayMultiplier()
public bool get_AllowOnCargoShip()
public bool SupportsChildDeployables()
public bool ForceDeployableSetParent()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public DecayPoint : PrefabAttribute {
public float protection
public Socket_Base socket
public bool IsOccupied(BaseEntity entity)
protected Type GetIndexedType()
}
public DecorAlign : DecorComponent {
public float NormalAlignment
public float GradientAlignment
public Vector3 SlopeOffset
public Vector3 SlopeScale
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorComponent : PrefabAttribute {
internal bool isRoot
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
}
public DecorComponentEx : object {
public void ApplyDecorComponents(Transform transform, DecorComponent[] components, Vector3& pos, Quaternion& rot, Vector3& scale)
public void ApplyDecorComponents(Transform transform, DecorComponent[] components)
public void ApplyDecorComponentsScaleOnly(Transform transform, DecorComponent[] components)
}
public DecorFlip : DecorComponent {
public AxisType FlipAxis
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorOffset : DecorComponent {
public Vector3 MinOffset
public Vector3 MaxOffset
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorRotate : DecorComponent {
public Vector3 MinRotation
public Vector3 MaxRotation
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorScale : DecorComponent {
public Vector3 MinScale
public Vector3 MaxScale
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorSocketFemale : PrefabAttribute {
protected Type GetIndexedType()
protected void OnDrawGizmosSelected()
}
public DecorSocketMale : PrefabAttribute {
protected Type GetIndexedType()
protected void OnDrawGizmosSelected()
}
public DecorSpawn : MonoBehaviour {
public SpawnFilter Filter
public string ResourceFolder
public UInt32 Seed
public float ObjectCutoff
public float ObjectTapering
public int ObjectsPerPatch
public float ClusterRadius
public int ClusterSizeMin
public int ClusterSizeMax
public int PatchCount
public int PatchSize
public bool LOD
}
public DecorSwim : DecorComponent {
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorTransform : DecorComponent {
public Vector3 Position
public Vector3 Rotation
public Vector3 Scale
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DeferredAction : object {
private Object sender
private Action action
private ActionPriority priority
private bool <Idle>k__BackingField
public bool Idle
public int Index
public bool get_Idle()
private void set_Idle(bool value)
public int get_Index()
public void .ctor(Object sender, Action action, ActionPriority priority)
public void Action()
public void Invoke()
public bool op_Implicit(DeferredAction obj)
public void Invoke(Object sender, Action action, ActionPriority priority)
}
public DeferredDecal : MonoBehaviour {
public Mesh mesh
public Material material
public DeferredDecalQueue queue
public bool applyImmediately
}
public DeferredDecalQueue : Enum {
public int value__
public DeferredDecalQueue Background
public DeferredDecalQueue Foreground
}
public DeferredExtension : MonoBehaviour {
public ExtendGBufferParams extendGBuffer
public SubsurfaceScatteringParams subsurfaceScattering
public ScreenSpaceRefractionParams screenSpaceRefraction
public float depthScale
public bool debug
public bool forceToCameraResolution
public bool excludeMainLight
}
public DeferredExtensionMesh : MonoBehaviour {
public SubsurfaceProfile subsurfaceProfile
}
public DeleteEventButton : MonoBehaviour {
public void OnPointerDown(PointerEventData eventData)
}
public DeliveryDrone : Drone {
public float stateTimeout
public float targetPositionTolerance
public float preferredCruiseHeight
public float preferredHeightAboveObstacle
public float marginAbovePreferredHeight
public float obstacleHeightLockDuration
public int pickUpDelayInTicks
public DeliveryDroneConfig config
public GameObjectRef mapMarkerPrefab
public EntityRef`1<Marketplace> sourceMarketplace
public EntityRef`1<MarketTerminal> sourceTerminal
public EntityRef`1<VendingMachine> targetVendingMachine
public State _state
public RealTimeSince _sinceLastStateChange
public Nullable`1<Vector3> _stateGoalPosition
public Nullable`1<float> _goToY
public TimeSince _sinceLastObstacleBlock
public Nullable`1<float> _minimumYLock
public int _pickUpTicks
public BaseEntity _mapMarkerInstance
public void Setup(Marketplace marketplace, MarketTerminal terminal, VendingMachine vendingMachine)
public void ServerInit()
public void CreateMapMarker()
public void Think()
public void ForceRemove()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool CanControl(ulong playerID)
public float <Think>g__CalculatePreferredY|24_0(Boolean& isBlocked, <>c__DisplayClass24_0& )
public float <Think>g__GetMinimumHeight|24_1(Vector3 offset, <>c__DisplayClass24_0& )
public Vector3 <Think>g__LandingPosition|24_2(<>c__DisplayClass24_0& )
public void <Think>g__SetGoalPosition|24_3(Vector3 position, <>c__DisplayClass24_0& )
public bool <Think>g__IsAtGoalPosition|24_4(<>c__DisplayClass24_0& )
public void <Think>g__SetGoToY|24_5(float y, <>c__DisplayClass24_0& )
public bool <Think>g__IsAtGoToY|24_6(<>c__DisplayClass24_0& )
public void <Think>g__SetState|24_7(State newState, <>c__DisplayClass24_0& )
}
public DeliveryDroneConfig : BaseScriptableObject {
public Vector3 vendingMachineOffset
public float maxDistanceFromVendingMachine
public Vector3 halfExtents
public float testHeight
public LayerMask layerMask
public void FindDescentPoints(VendingMachine vendingMachine, float currentY, Vector3& waitPosition, Vector3& descendPosition)
public bool IsVendingMachineAccessible(VendingMachine vendingMachine, Vector3 offset, RaycastHit& hitInfo)
}
public DemoItem : RustButton {
public Demos demos
public int itemId
public RustText nameText
public RustText dateText
public RustText lengthText
}
public DemoPlaybackUI : SingletonComponent`1<DemoPlaybackUI> {
public GameObject Root
}
public DemoPlaybackWidget : MonoBehaviour {
public RustSlider DemoProgress
public RustText DemoName
public RustText DemoDuration
public RustText DemoCurrentTime
public GameObject PausedRoot
public GameObject PlayingRoot
public RectTransform DemoPlaybackHandle
public RectTransform ShotPlaybackWindow
public RustButton LoopButton
public GameObject ShotButtonRoot
public RustText ShotNameText
public GameObject ShotNameRoot
public RectTransform ShotRecordWindow
}
public DemoRecorder : SingletonComponent`1<DemoRecorder> {
public RustInput nameInputField
public GameObject RecordingUnderlay
public GameObject Panel
public CanvasGroup CanvasGroup
public UIConfirmationPopup confirmationPopup
public RustButton autofillButton
private bool autoFill
public Phrase overwritePhrase
}
public DemoRecorderProgress : SingletonComponent`1<DemoRecorderProgress> {
public RustText RecordingLabel
public RustText ProgressLabel
public GameObject RecordingUnderlay
}
public DemoRootFade : MonoBehaviour {
public CanvasGroup Canvas
}
public Demos : MonoBehaviour {
public VirtualScroll virtualScroll
public GameObject deletePopup
}
public DemoShotButton : RustButton {
public bool FireEventOnClicked
public void OnPointerDown(PointerEventData eventData)
public void OnPointerUp(PointerEventData eventData)
public void OnPointerClick(PointerEventData eventData)
}
public DemoShotEntry : MonoBehaviour {
public RustButton PlayButton
public Sprite DragSprite
public RustInput RenameInput
}
public DemoShotListFolderWidget : MonoBehaviour {
public RustButton FolderName
public Transform ChildRoot
public GameObject UpArrow
public GameObject DownArrow
public RustText CountText
public GameObject OpenRoot
public GameObject ModifyRoot
public RustInput FolderRenameInput
}
public DemoShotListWidget : SingletonComponent`1<DemoShotListWidget> {
public GameObjectRef ShotListEntry
public GameObjectRef FolderEntry
public Transform ShotListParent
public RustInput FolderNameInput
public GameObject ShotsRoot
public GameObject NoShotsRoot
public GameObject TopUpArrow
public GameObject TopDownArrow
public Canvas DragCanvas
}
public DemoShotRecordWidget : MonoBehaviour {
public RustInput NameInput
public GameObject RecordingRoot
public GameObject PreRecordingRoot
public RustButton CountdownToggle
public RustButton PauseOnSaveToggle
public RustButton ReturnToStartToggle
public RustButton RecordDofToggle
public RustOption FolderDropdown
public GameObject RecordingUnderlay
public AudioSource CountdownAudio
public GameObject ShotRecordTime
public RustText ShotRecordTimeText
public RustText ShotNameText
public GameObject RecordingInProcessRoot
public GameObject CountdownActiveRoot
public GameObject CountdownActiveSliderRoot
public RustSlider CountdownActiveSlider
public RustText CountdownActiveText
}
public DemoText : MonoBehaviour {
public RustText TimeText
public RustText TotalSecondText
public RustText TimeScaleText
public RustText FilenameText
public RustText DateTimeText
public RustText ParentText
public RustText DofText
public GameObject InternalRoot
public GameObject ParentRoot
public GameObject DofRoot
}
public DemoTimelineController : MonoBehaviour {
public PlayableDirector Director
}
public DemoTrackBehaviour : PlayableBehaviour {
public string DemoName
}
public DensitySpawnPopulation : SpawnPopulationBase {
public float _targetDensity
public int ClusterSizeMin
public int ClusterSizeMax
public int ClusterDithering
public int SpawnAttemptsInitial
public int SpawnAttemptsRepeating
public bool ScaleWithLargeMaps
public bool ScaleWithSpawnFilter
public bool AlignToNormal
public SpawnFilter Filter
public float FilterCutoff
public float FilterRadius
public bool FilterOutTutorialIslands
private int sumToSpawn
public float TargetDensity
public float get_TargetDensity()
public void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
public void UpdateWeights(SpawnDistribution distribution, int targetCount)
protected int GetPrefabWeight(Prefab`1<Spawnable> prefab)
public bool TryTakeRandomPrefab(Prefab`1& result)
public void ReturnPrefab(Prefab`1<Spawnable> prefab)
public float GetCurrentSpawnDensity()
public float GetMaximumSpawnDensity()
public bool GetSpawnPosOverride(Prefab`1<Spawnable> prefab, Vector3& newPos, Quaternion& newRot)
public Byte[] GetBaseMapValues(int populationRes)
public int GetTargetCount(SpawnDistribution distribution)
public SpawnFilter GetSpawnFilter()
}
public Deployable : PrefabAttribute {
public Mesh guideMesh
public Vector3 guideMeshScale
public bool overrideRotation
public Vector3 guideMeshOrientation
public bool guideLights
public bool wantsInstanceData
public bool copyInventoryFromItem
public bool setSocketParent
public bool toSlot
public Slot slot
public GameObjectRef placeEffect
public Transform[] guideTargets
public Bounds bounds
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
public bool IsGuideTarget(Transform t)
}
public DeployableBoomBox : ContainerIOEntity {
public BoomBox BoxController
public int PowerUsageWhilePlaying
public int MaxBacktrackHopsClient
public bool IsStatic
public BaseEntity ToBaseEntity
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public BaseEntity get_ToBaseEntity()
public IOEntity ToEntity()
public int ConsumptionAmount()
public int DesiredPower(int inputIndex)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void ServerInit()
public bool ItemFilter(Item item, int count)
public int GetPassthroughAmount(int outputSlot)
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
public void ServerTogglePlay(RPCMessage msg)
public void Server_UpdateRadioIP(RPCMessage msg)
public void Save(SaveInfo info)
public bool ClearRadioByUserId(ulong id)
public void OnCassetteInserted(Cassette c)
public void OnCassetteRemoved(Cassette c)
public void HurtCallback(float amount)
public void Load(LoadInfo info)
}
public DeployableDecay : Decay {
public float decayDelay
public float decayDuration
public bool overrideHealRate
public float decayTickOverride
public bool decayIndoors
public float healRate
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public float GetHealScale(BaseEntity entity)
public float GetDecayTickOverride()
public bool ShouldDecay(BaseEntity entity)
}
public DeployableToSlot : MonoBehaviour {
public Slot slot
}
public DeployedFigurine : BaseCombatEntity {
public float UseCooldown
public float HurtPerUse
public Animator WobbleAnimator
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void Server_Poke(RPCMessage msg)
private void ClearBusy()
public void PostServerLoad()
private bool CanWobble()
}
public DeployedRecorder : StorageContainer {
public AudioSource SoundSource
public ItemDefinition[] ValidCassettes
public SoundDefinition PlaySfx
public SoundDefinition StopSfx
public SwapKeycard TapeSwapper
private Nullable`1<CollisionDetectionMode> initialCollisionDetectionMode
public BaseEntity ToBaseEntity
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public BaseEntity get_ToBaseEntity()
public void ServerTogglePlay(RPCMessage msg)
private void ServerTogglePlay(bool play)
public void OnCassetteInserted(Cassette c)
public void OnCassetteRemoved(Cassette c)
public bool ItemFilter(Item item, int targetSlot)
public void OnCollision(Collision collision, BaseEntity hitEntity)
private void DoCollisionStick(Collision collision, BaseEntity ent)
public void SetMotionEnabled(bool wantsMotion)
public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent, Collider hitCollider)
private void UnStick()
internal void OnParentRemoved()
public void SetCollisionEnabled(bool wantsCollision)
public void ResetState()
}
public Deployer : HeldEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ItemModDeployable GetModDeployable()
public Deployable GetDeployable()
public Quaternion GetDeployedRotation(Vector3 normal, Vector3 placeDir)
public bool IsPlacementAngleAcceptable(Vector3 pos, Quaternion rot)
public bool CheckPlacement(Deployable deployable, Ray ray, float fDistance)
private void DoDeploy(RPCMessage msg)
public void DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)
public void DoDeploy_Regular(Deployable deployable, Ray ray)
}
public DeployGuide : BaseMonoBehaviour {
public DeployGuide current
}
public DeployShell : PrefabAttribute {
public Bounds bounds
public OBB WorldSpaceBounds(Transform transform)
public float LineOfSightPadding()
protected Type GetIndexedType()
}
public DeployVolume : PrefabAttribute {
public LayerMask layers
public Flags ignore
public EntityMode entityMode
public BaseEntity[] entityList
public EntityListScriptableObject[] entityGroups
private bool <IsBuildingBlock>k__BackingField
private Collider <LastDeployHit>k__BackingField
public bool IsBuildingBlock
public Collider LastDeployHit
public bool get_IsBuildingBlock()
public void set_IsBuildingBlock(bool value)
protected Type GetIndexedType()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB test, int mask)
public bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, int mask)
public bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, OBB test, int mask)
public bool CheckSphere(Vector3 pos, float radius, int layerMask, DeployVolume volume)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, DeployVolume volume)
public bool CheckOBB(OBB obb, int layerMask, DeployVolume volume)
public bool CheckBounds(Bounds bounds, int layerMask, DeployVolume volume)
public Collider get_LastDeployHit()
private void set_LastDeployHit(Collider value)
private bool CheckFlags(List`1<Collider> list, DeployVolume volume)
private bool CheckEntityList(BaseEntity entity, BaseEntity[] entities, bool trueIfAnyFound)
}
public DeployVolumeCapsule : DeployVolume {
public Vector3 center
public float radius
public float height
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask)
}
public DeployVolumeEntityBounds : DeployVolume {
public Bounds bounds
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public DeployVolumeEntityBoundsReverse : DeployVolume {
public Bounds bounds
public int layer
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB test, int mask)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public DeployVolumeOBB : DeployVolume {
public Bounds bounds
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB test, int mask)
}
public DeployVolumeSphere : DeployVolume {
public Vector3 center
public float radius
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask)
}
public DepthOfFieldEffect : PostProcessEffectSettings {
public FloatParameter focalLength
public FloatParameter focalSize
public FloatParameter aperture
public FloatParameter anamorphicSqueeze
public FloatParameter anamorphicBarrel
public FloatParameter maxBlurSize
public BoolParameter highResolution
public DOFBlurSampleCountParameter blurSampleCount
public Transform focalTransform
}
public DepthOfFieldEffectRenderer : PostProcessEffectRenderer`1<DepthOfFieldEffect> {
private float focalDistance01
private float internalBlurWidth
private Shader dofShader
public void Init()
private float FocalDistance01(Camera cam, float worldDist)
private void WriteCoc(PostProcessRenderContext context, PropertySheet sheet)
public void Render(PostProcessRenderContext context)
}
public DestroyArcadeEntity : BaseMonoBehaviour {
public ArcadeEntity ent
public float TimeToDie
public float TimeToDieVariance
private void Start()
private void DestroyAction()
}
public DestroyOnGroundMissing : MonoBehaviour {
private void OnGroundMissing()
}
public DestroyOutsideMonument : FacepunchBehaviour {
private BaseCombatEntity baseCombatEntity
private float checkEvery
private MonumentInfo ourMonument
private Vector3 OurPos
private Vector3 get_OurPos()
protected void OnEnable()
protected void OnDisable()
private MonumentInfo GetOurMonument()
private void CheckPosition()
private void DoOutsideMonument()
}
public DetachMonumentChildren : MonoBehaviour {
private void Awake()
}
public Detonator : HeldEntity {
public int frequency
private float timeSinceDeploy
public GameObjectRef frequencyPanelPrefab
public GameObjectRef attackEffect
public GameObjectRef unAttackEffect
private float nextChangeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SetPressed(RPCMessage msg)
internal void InternalSetPressed(bool pressed)
public Vector3 GetPosition()
public float GetMaxRange()
public void RFSignalUpdate(bool on)
public void SetHeld(bool bHeld)
public void ServerSetFrequency(RPCMessage msg)
public void ServerSetFrequency(BasePlayer player, int freq)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public int GetFrequency()
}
public DevBotSpawner : FacepunchBehaviour {
public GameObjectRef bot
public Transform waypointParent
public bool autoSelectLatestSpawnedGameObject
public float spawnRate
public int maxPopulation
private Transform[] waypoints
private List`1<BaseEntity> _spawned
public bool HasFreePopulation()
public void SpawnBot()
public void Start()
}
public DevCamera : MonoBehaviour {
public float movementScale
}
public DevControls : MonoBehaviour {
public GUISkin skin
}
public DevDressPlayer : MonoBehaviour {
public bool DressRandomly
public List`1<ItemAmount> clothesToWear
private void ServerInitComponent()
private void DoRandomClothes(BasePlayer player)
}
public DeveloperList : object {
public bool Contains(string steamid)
public bool Contains(ulong steamid)
public bool IsDeveloper(BasePlayer ply)
}
public DeveloperTools : SingletonComponent`1<DeveloperTools> {
public GameObject developerTools
public GameObject navButton
public GameObject panelContainer
public Text ConsoleInput
}
public DevEnableDisable : DevControlsTab {
public GameObject[] Objects
public string CookieName
public string TabName
}
public DevEnvironment : DevControlsTab {
public TOD_Sky sky
}
public DevMovePlayer : BaseMonoBehaviour {
public BasePlayer player
public Transform[] Waypoints
public bool moveRandomly
public Vector3 destination
public Vector3 lookPoint
private int waypointIndex
private float randRun
public void Awake()
public void LateSpawn()
public void SetWaypoints(Transform[] wps)
public void Update()
}
public DevTimeAdjust : MonoBehaviour {
private void Start()
private void OnGUI()
}
public DevWeatherAdjust : MonoBehaviour {
protected void Awake()
protected void OnGUI()
}
public DiagnosticsConSys : ConsoleSystem {
private void DumpAnimators(string targetFolder)
public void dump(Arg args)
private void DumpSystemInformation(string targetFolder)
private void WriteTextToFile(string file, string text)
private void DumpEntities(string targetFolder)
private void DumpLODGroups(string targetFolder)
private void DumpLODGroupTotals(string targetFolder)
private void DumpNetwork(string targetFolder)
private void DumpObjects(string targetFolder)
private void DumpPhysics(string targetFolder)
private void DumpTotals(string targetFolder)
private void DumpColliders(string targetFolder)
private void DumpRigidBodies(string targetFolder)
private void DumpGameObjects(string targetFolder)
private void DumpGameObjectRecursive(StringBuilder str, Transform tx, int indent, bool includeComponents)
private void DumpWarmup(string targetFolder)
private void DumpWarmupTimings(string targetFolder)
private void DumpWorldSpawnTimings(string targetFolder)
}
public DieselEngine : StorageContainer {
public GameObjectRef rumbleEffect
public Transform rumbleOrigin
public Flags Flag_HasFuel
public float runningTimePerFuelUnit
public float cachedFuelTime
private float rumbleMaxDistSq
private string EXCAVATOR_ACTIVATED_STAT
private BasePlayer startedByPlayer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void FixedUpdate()
public void EngineSwitch(RPCMessage msg)
public void TimedShutdown()
public bool ConsumeFuelItem(int amount)
public int GetFuelAmount()
public void UpdateHasFuelFlag()
public void PlayerStoppedLooting(BasePlayer player)
public void EngineOff()
public void EngineOn()
public void RescheduleEngineShutdown()
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool HasFuel()
}
public DiggableEntityLoot : ScriptableObject {
public List`1<ItemEntry> Items
public Enum Biomes
public Enum Topology
public bool VerifyLootListForWorldPosition(Vector3 worldPos)
}
public DirectionalDamageTrigger : TriggerBase {
public float repeatRate
public List`1<DamageTypeEntry> damageType
public GameObjectRef attackEffect
public GameObject InterestedInObject(GameObject obj)
public void OnObjects()
public void OnEmpty()
private void OnTick()
}
public DirectionProperties : PrefabAttribute {
private float radius
public Bounds bounds
public ProtectionProperties extraProtection
protected Type GetIndexedType()
public bool IsWeakspot(Transform tx, HitInfo info)
private bool CheckWeakpointRoof(BaseEntity hitEntity)
private bool IsWeakspotVisible(BaseEntity hitEntity, Vector3 playerEyes, Vector3 weakspotPos)
}
public DirectoryEx : object {
public void Backup(DirectoryInfo parent, String[] names)
public bool MoveToSafe(DirectoryInfo parent, string target, int retries)
public void Backup(String[] names)
public void CopyAll(string sourceDirectory, string targetDirectory)
public void CopyAll(DirectoryInfo source, DirectoryInfo target)
}
public DisableSave : MonoBehaviour {
private void OnValidate()
}
public DiscoFloor : AudioVisualisationEntity {
public float GradientDuration
public float VolumeSensitivityMultiplier
public float BaseSpeed
public Light[] LightSources
public DiscoFloorMesh FloorMesh
}
public DiscoFloorColourLookups : PrefabAttribute {
public Single[] InOutLookup
public Single[] RadialLookup
public Single[] RippleLookup
public Single[] CheckerLookup
public Single[] BlockLookup
public Gradient[] ColourGradients
protected Type GetIndexedType()
}
public DiscoFloorMesh : MonoBehaviour {
public int GridRows
public int GridColumns
public float GridSize
public float TestOffset
public Color OffColor
public MeshRenderer Renderer
public bool DrawInEditor
public MeshFilter Filter
public AnimationCurve customCurveX
public AnimationCurve customCurveY
}
public DistanceField : object {
private Int32[] GaussOffsets
private Single[] GaussWeights
public void Generate(Int32& size, Byte& threshold, Byte[]& image, Single[]& distanceField)
private float SampleClamped(Single[] data, int size, int x, int y)
private Vector3 SampleClamped(Vector3[] data, int size, int x, int y)
private ushort SampleClamped(UInt16[] data, int size, int x, int y)
public void GenerateVectors(Int32& size, Single[]& distanceField, Vector3[]& vectorField)
public void ApplyGaussianBlur(int size, Single[] distanceField, int steps)
}
public DistanceFlareLOD : FacepunchBehaviour {
public bool isDynamic
public float minEnabledDistance
public float maxEnabledDistance
public bool toggleFade
public float toggleFadeDuration
}
public DiveSite : JunkPile {
public Transform bobber
public float TimeoutPlayerCheckRadius()
}
public DOFBlurSampleCount : Enum {
public int value__
public DOFBlurSampleCount Low
public DOFBlurSampleCount Medium
public DOFBlurSampleCount High
public DOFBlurSampleCount VeryHigh
}
public DofExposer : ListComponent`1<DofExposer> {
public PostProcessVolume PostVolume
public bool DofEnabled
public float FocalLength
public float Blur
public float FocalAperture
public float AnamorphicSqueeze
public float AnamorphicBarrel
public bool debug
}
public Door : AnimatedBuildingBlock {
public GameObjectRef knockEffect
public bool canTakeLock
public bool hasHatch
public bool canTakeCloser
public bool canTakeKnocker
public bool canNpcOpen
public bool canHandOpen
public bool isSecurityDoor
public bool canReverseOpen
public TriggerNotify[] vehiclePhysBoxes
public bool checkPhysBoxesOnOpen
public SoundDefinition vehicleCollisionSfx
public GameObject[] ClosedColliderRoots
public bool allowOnCargoShip
private float openAnimLength
private float closeAnimLength
public Flags ReverseOpen
public NavMeshModifierVolume NavMeshVolumeAnimals
public NavMeshModifierVolume NavMeshVolumeHumanoids
public NPCDoorTriggerBox NpcTriggerBox
public NavMeshLink NavMeshLink
private int nonWalkableArea
private int animalAgentTypeId
private int humanoidAgentTypeId
private float decayResetTimeLast
private Dictionary`2<BasePlayer, TimeSince> woundedOpens
private Dictionary`2<BasePlayer, TimeSince> woundedCloses
private float nextKnockTime
private int openHash
private int closeHash
private int reverseOpenHash
public bool AllowOnCargoShip
private bool HasVehiclePushBoxes
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public bool get_AllowOnCargoShip()
public void ServerInit()
public bool HasSlot(Slot slot)
public bool CanPickup(BasePlayer player)
public void CloseRequest()
public void SetOpen(bool open, bool suppressBlockageChecks)
public void SetLocked(bool locked)
public bool GetPlayerLockPermission(BasePlayer player)
public void SetNavMeshLinkEnabled(bool wantsOn)
protected void RPC_OpenDoor(RPCMessage rpc)
private void DelayedDoorOpening()
protected void OnPlayerOpenedDoor(BasePlayer p)
protected bool ShouldDelayOpen(BasePlayer forPlayer, Single& delay)
private void StartCheckingForBlockages(bool isOpening)
private void StopCheckingForBlockages()
private void RPC_CloseDoor(RPCMessage rpc)
private void RPC_KnockDoor(RPCMessage rpc)
private void RPC_ToggleHatch(RPCMessage rpc)
private void EnableVehiclePhysBoxes()
private void DisableVehiclePhysBox()
private bool get_HasVehiclePushBoxes()
private void ToggleVehiclePushBoxes(bool state)
private void Server_NotifyWoundedOpen(RPCMessage msg)
private void CheckTimedOutPlayers(Dictionary`2<BasePlayer, TimeSince> dictionary)
private void Server_NotifyWoundedClose(RPCMessage msg)
public bool SupportsChildDeployables()
private void ReverseDoorAnimation(bool wasOpening)
public float BoundsPadding()
public void OnObjects(TriggerNotify trigger)
public void OnEmpty()
protected void ApplySubAnimationParameters(bool init, Animator toAnimator)
public void OnFlagsChanged(Flags old, Flags next)
private void <Server_NotifyWoundedOpen>b__54_0()
private void <Server_NotifyWoundedClose>b__56_0()
}
public DoorAnimEvents : MonoBehaviour {
public GameObjectRef openStart
public GameObjectRef openEnd
public GameObjectRef closeStart
public GameObjectRef closeEnd
public GameObject soundTarget
public bool checkAnimSpeed
public Animator animator
public Animator get_animator()
public void DoorOpenStart()
public void DoorOpenEnd()
public void DoorCloseStart()
public void DoorCloseEnd()
}
public DoorCloser : BaseEntity {
public ItemDefinition itemType
public float delay
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float BoundsPadding()
public void Think()
public void SendClose()
public void RPC_Take(RPCMessage rpc)
public Door GetDoor()
}
public DoorKnocker : BaseCombatEntity {
public Animator knocker1
public Animator knocker2
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Knock(BasePlayer player)
}
public DoorManipulator : IOEntity {
public EntityRef entityRef
public Door targetDoor
public DoorEffect powerAction
private bool toggle
public bool CanPairWithLockedDoors()
public void Init()
public void SetupInitialDoorConnection()
public void SetTargetDoor(Door newTargetDoor)
public Door FindDoor(bool allowLocked)
public void DoActionDoorMissing()
public void DoAction(DoorEffect action)
public void IOStateChanged(int inputAmount, int inputSlot)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public DoorWithLock : Door {
public GameObjectRef lockObject
}
public DoubleShotgunViewModel : BaseViewModel {
public GameObject NoSkinRoot
}
public DoubleVision : PostProcessEffectSettings {
public Vector2Parameter displace
public FloatParameter amount
}
public DoubleVisionRenderer : PostProcessEffectRenderer`1<DoubleVision> {
private int displaceProperty
private int amountProperty
private Shader doubleVisionShader
public void Init()
public void Render(PostProcessRenderContext context)
}
public DragMe : MonoBehaviour {
public DragMe dragging
public GameObject dragIcon
public object data
public string dragType
protected Canvas TopCanvas
public void OnBeginDrag(PointerEventData eventData)
protected Canvas get_TopCanvas()
public void OnDrag(PointerEventData eventData)
public void OnEndDrag(PointerEventData eventData)
public void CancelDrag()
}
public DragMeCustomParent : DragMe {
public Canvas OverrideCanvas
public bool ShouldCancelOnDrop
}
public DragReceiver : MonoBehaviour {
public TriggerEvent onEndDrag
}
public DrawArrow : MonoBehaviour {
public Color color
public float length
public float arrowLength
private void OnDrawGizmos()
}
public DrawCameraFrustum : MonoBehaviour {
private Material lineMaterial
}
public DrawSkeleton : MonoBehaviour {
private void OnDrawGizmos()
private void DrawTransform(Transform t)
}
public Drone : RemoteControlEntity {
public float maxControlRange
public float movementSpeedOverride
public float altitudeSpeedOverride
public float windTimeDivisor
public float windPositionDivisor
public float windPositionScale
public float windRotationMultiplier
public float windLerpSpeed
public Flags Flag_ThrottleUp
public Flags Flag_Flying
public Rigidbody body
public Transform modelRoot
public bool killInWater
public bool enableGrounding
public bool keepAboveTerrain
public float groundTraceDist
public float groundCheckInterval
public float altitudeAcceleration
public float movementAcceleration
public float yawSpeed
public float uprightSpeed
public float uprightPrediction
public float uprightDot
public float leanWeight
public float leanMaxVelocity
public float hurtVelocityThreshold
public float hurtDamagePower
public float collisionDisableTime
public float pitchMin
public float pitchMax
public float pitchSensitivity
public bool disableWhenHurt
public float disableWhenHurtChance
public float playerCheckInterval
public float playerCheckRadius
public float deployYOffset
public SoundDefinition movementLoopSoundDef
public SoundDefinition movementStartSoundDef
public SoundDefinition movementStopSoundDef
public AnimationCurve movementLoopPitchCurve
public float movementSpeedReference
public float propellerMaxSpeed
public float propellerAcceleration
public Transform propellerA
public Transform propellerB
public Transform propellerC
public Transform propellerD
public float pitch
public Nullable`1<Vector3> targetPosition
public DroneInputState currentInput
public float lastInputTime
public double lastCollision
public TimeSince lastGroundCheck
public bool isGrounded
public RealTimeSinceEx lastPlayerCheck
public bool RequiresMouse
public float MaxRange
public bool CanAcceptInput
protected bool PositionTickFixedTime
public bool get_RequiresMouse()
public float get_MaxRange()
public void Spawn()
public bool get_CanAcceptInput()
public void StopControl(CameraViewerId viewerID)
public void UserInput(InputState inputState, CameraViewerId viewerID)
public void Update_Server()
public void FixedUpdate()
public void OnCollisionEnter(Collision collision)
public void OnCollisionStay()
public void Hurt(HitInfo info)
public float GetNetworkTime()
protected bool get_PositionTickFixedTime()
public Vector3 GetLocalVelocityServer()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void Update()
public bool CanChangeID(BasePlayer player)
public bool CanPickup(BasePlayer player)
public void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public bool ShouldNetworkOwnerInfo()
public bool ShouldInheritNetworkGroup()
public float MaxVelocity()
}
public DroneInformationPanel : ItemInformationPanel {
public RustText identifierLabel
}
public DropBox : Mailbox {
public Transform EyePoint
public bool PlayerIsOwner(BasePlayer player)
public bool PlayerBehind(BasePlayer player)
public bool PlayerInfront(BasePlayer player)
public bool SupportsChildDeployables()
}
public DropMe : MonoBehaviour {
public String[] droppableTypes
public void OnDrop(PointerEventData eventData)
}
public DroppedItem : WorldItem {
public GameObject itemModel
private Collider childCollider
private Flags FLAG_STUCK
private int originalLayer
public DropReasonEnum DropReason
public ulong DroppedBy
public DateTime DroppedTime
public bool NeverCombine
private Rigidbody rB
private CollisionDetectionMode originalCollisionMode
private Vector3 prevLocalPos
private float SLEEP_CHECK_FREQUENCY
private bool hasLastPos
private Vector3 lastGoodColliderCentre
private Vector3 lastGoodPos
private Quaternion lastGoodRot
private Action cachedSleepCheck
private float maxBoundsExtent
private Vector3 smallVerticalOffset
private bool StuckInSomething
public SoundDefinition OpenSound
public SoundDefinition CloseSound
private bool get_StuckInSomething()
public SoundDefinition get_OpenSound()
public SoundDefinition get_CloseSound()
public float GetNetworkTime()
public void ServerInit()
public float GetDespawnDuration()
public void IdleDestroy()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public void OnDroppedOn(DroppedItem di)
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
internal void OnParentRemoved()
public void StickIn()
public void Unstick()
private void SleepCheck()
private void OnPhysicsNeighbourChanged()
public void OnPositionalNetworkUpdate()
protected bool ShouldUpdateNetworkPosition()
private void CheckValidPosition()
private void OnUnparented()
private void OnParented()
public void PostInitShared()
public void OnFlagsChanged(Flags old, Flags next)
private void BecomeActive()
private void BecomeInactive()
private void EnableCollider()
public void UpdateItemMass()
public bool ShouldInheritNetworkGroup()
}
public DroppedItemContainer : BaseCombatEntity {
public string lootPanelName
public int maxItemCount
public ulong playerSteamID
public string _playerName
public bool ItemBasedDespawn
public bool onlyOwnerLoot
public SoundDefinition openSound
public SoundDefinition closeSound
public Flags HasItems
public Flags HasBeenOpened
private ulong <LastLootedBy>k__BackingField
public ItemContainer inventory
public Phrase LootPanelTitle
public string playerName
public ulong LastLootedBy
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Phrase get_LootPanelTitle()
public string get_playerName()
public void set_playerName(string value)
public ulong get_LastLootedBy()
public void set_LastLootedBy(ulong value)
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void ServerInit()
public void RemoveMe()
private void EvaluateBagConditions()
public void ResetRemovalTime(float dur)
public void ResetRemovalTime()
public float CalculateRemovalTime()
internal void DoServerDestroy()
public void TakeFrom(ItemContainer[] source, float destroyPercent)
private void RPC_OpenLoot(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
public void PreServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public DropUtil : object {
public void DropItems(ItemContainer container, Vector3 position)
}
public DudTimedExplosive : TimedExplosive {
public GameObjectRef fizzleEffect
public GameObject wickSpark
public AudioSource wickSound
public float dudChance
public ItemDefinition itemToGive
private float explodeTime
public bool becomeDudInWater
protected bool AlwaysRunWaterCheck
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool IsWickBurning()
protected bool get_AlwaysRunWaterCheck()
public void WaterCheck()
public float GetRandomTimerTime()
public void RPC_Pickup(RPCMessage msg)
public void SetFuse(float fuseLength)
public void Explode()
public bool CanStickTo(BaseEntity entity)
public void BecomeDud()
public void Save(SaveInfo info)
public void Ignite(Vector3 fromPos)
public bool CanIgnite()
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public void Load(LoadInfo info)
}
public DummySwitch : IOEntity {
public string listenString
public string listenStringOff
public float duration
public bool WantsPower(int inputIndex)
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void SetOn(bool wantsOn)
public void SetOff()
public void OnEntityMessage(BaseEntity from, string msg)
}
public DungeonBaseFloor : object {
public List`1<DungeonBaseLink> Links
public float Distance(Vector3 position)
public float SignedDistance(Vector3 position)
}
public DungeonBaseInfo : LandmarkInfo {
public List`1<GameObject> Links
public List`1<DungeonBaseFloor> Floors
public float Distance(Vector3 position)
public float SqrDistance(Vector3 position)
public void Add(DungeonBaseLink link)
protected void Awake()
protected void Start()
private int <Add>b__4_0(DungeonBaseFloor l, DungeonBaseFloor r)
}
public DungeonBaseLandmarkInfo : LandmarkInfo {
private DungeonBaseLink baseLink
private Nullable`1<MapLayer> layer
public MapLayer MapLayer
protected void Awake()
public MapLayer get_MapLayer()
}
public DungeonBaseLink : MonoBehaviour {
public DungeonBaseLinkType Type
public int Cost
public int MaxFloor
public int MaxCountLocal
public int MaxCountGlobal
public int MaxCountIdentifier
public DungeonBaseInfo Dungeon
public RendererLOD[] MapRendererLods
private List`1<DungeonBaseSocket> sockets
private List`1<DungeonVolume> volumes
internal List`1<DungeonBaseSocket> Sockets
internal List`1<DungeonVolume> Volumes
internal List`1<DungeonBaseSocket> get_Sockets()
internal List`1<DungeonVolume> get_Volumes()
protected void Awake()
internal void Initialize()
}
public DungeonBaseLinkType : Enum {
public int value__
public DungeonBaseLinkType Room
public DungeonBaseLinkType Corridor
public DungeonBaseLinkType End
}
public DungeonBaseSocket : MonoBehaviour {
public DungeonBaseSocketType Type
public bool Male
public bool Female
}
public DungeonBaseSocketType : Enum {
public int value__
public DungeonBaseSocketType Horizontal
public DungeonBaseSocketType Vertical
public DungeonBaseSocketType Pillar
}
public DungeonBaseTransition : MonoBehaviour {
public DungeonBaseSocketType Type
public DungeonBaseLinkType Neighbour1
public DungeonBaseLinkType Neighbour2
}
public DungeonGridCell : MonoBehaviour {
public DungeonGridConnectionType North
public DungeonGridConnectionType South
public DungeonGridConnectionType West
public DungeonGridConnectionType East
public DungeonGridConnectionVariant NorthVariant
public DungeonGridConnectionVariant SouthVariant
public DungeonGridConnectionVariant WestVariant
public DungeonGridConnectionVariant EastVariant
public GameObjectRef[] AvoidNeighbours
public RendererLOD[] MapRendererLods
public bool Replaceable
public bool ShouldAvoid(UInt32 id)
protected void Awake()
}
public DungeonGridConnectionHash : ValueType {
public bool North
public bool South
public bool West
public bool East
public int Value
public int get_Value()
}
public DungeonGridConnectionType : Enum {
public int value__
public DungeonGridConnectionType None
public DungeonGridConnectionType TrainTunnel
}
public DungeonGridConnectionVariant : Enum {
public int value__
public DungeonGridConnectionVariant A
public DungeonGridConnectionVariant B
}
public DungeonGridInfo : LandmarkInfo {
public int CellSize
public float LinkHeight
public float LinkRadius
internal List`1<GameObject> Links
public float MinDistance
public float get_MinDistance()
public float Distance(Vector3 position)
public float SqrDistance(Vector3 position)
public bool IsValidSpawnPosition(Vector3 position)
public Vector3 SnapPosition(Vector3 pos)
protected void Awake()
protected void Start()
}
public DungeonGridLink : MonoBehaviour {
public Transform UpSocket
public Transform DownSocket
public DungeonGridLinkType UpType
public DungeonGridLinkType DownType
public int Priority
public int Rotation
protected void Start()
}
public DungeonGridLinkType : Enum {
public int value__
public DungeonGridLinkType Default
public DungeonGridLinkType Elevator
public DungeonGridLinkType Transition
}
public DungeonNavmesh : FacepunchBehaviour {
public int NavMeshAgentTypeIndex
public string DefaultAreaName
public float NavmeshResolutionModifier
public Bounds Bounds
public NavMeshData NavMeshData
public NavMeshDataInstance NavMeshDataInstance
public LayerMask LayerMask
public NavMeshCollectGeometry NavMeshCollectGeometry
public List`1<DungeonNavmesh> Instances
public bool use_baked_terrain_mesh
private List`1<NavMeshBuildSource> sources
private AsyncOperation BuildingOperation
private bool HasBuildOperationStarted
private Stopwatch BuildTimer
private int defaultArea
private int agentTypeId
public bool IsBuilding
public bool NavReady()
public bool get_IsBuilding()
private void OnEnable()
private void OnDisable()
public void UpdateNavMeshAsync()
public void NotifyInformationZonesOfCompletion()
public void SourcesCollected()
public IEnumerator UpdateNavMeshAndWait()
private void AppendModifierVolumes(List`1<NavMeshBuildSource> sources)
public void FinishBuildingNavmesh()
}
public DungeonVolume : MonoBehaviour {
public Bounds bounds
public OBB GetBounds(Vector3 position, Quaternion rotation)
public OBB GetBounds(Vector3 position, Quaternion rotation, Vector3 extrude)
}
public DynamicDungeon : BaseEntity {
public Transform exitEntitySpawn
public GameObjectRef exitEntity
public string exitString
public MonumentNavMesh monumentNavMesh
private List`1<DynamicDungeon> _dungeons
public GameObjectRef portalPrefab
public Transform portalSpawnPoint
public BasePortal exitPortal
public GameObjectRef doorPrefab
public Transform doorSpawnPoint
public Door doorInstance
public Vector3 nextDungeonPos
public Vector3 dungeonStartPoint
public float dungeonSpacing
public SpawnGroup[] spawnGroups
public bool AutoMergeAIZones
public void AddDungeon(DynamicDungeon newDungeon)
public void RemoveDungeon(DynamicDungeon dungeon)
public Vector3 GetNextDungeonPoint()
public IEnumerator UpdateNavMesh()
public void DestroyShared()
public void ServerInit()
private void MergeAIZones()
public void MissionStarted(BasePlayer assignee, MissionInstance instance)
public void MissionEnded(BasePlayer assignee, MissionInstance instance)
}
public DynamicMouseCursor : MonoBehaviour {
public Texture2D RegularCursor
public Vector2 RegularCursorPos
public Texture2D HoverCursor
public Vector2 HoverCursorPos
private Texture2D current
private void LateUpdate()
private void UpdateCursor(Texture2D cursor, Vector2 offs)
private GameObject CurrentlyHoveredItem()
}
public DynamicNavMesh : SingletonComponent`1<DynamicNavMesh> {
public int NavMeshAgentTypeIndex
public string DefaultAreaName
public int AsyncTerrainNavMeshBakeCellSize
public int AsyncTerrainNavMeshBakeCellHeight
public Bounds Bounds
public NavMeshData NavMeshData
public NavMeshDataInstance NavMeshDataInstance
public LayerMask LayerMask
public NavMeshCollectGeometry NavMeshCollectGeometry
public bool use_baked_terrain_mesh
private List`1<NavMeshBuildSource> sources
private AsyncOperation BuildingOperation
private bool HasBuildOperationStarted
private Stopwatch BuildTimer
private int defaultArea
private int agentTypeId
public bool IsBuilding
public bool get_IsBuilding()
private void OnEnable()
private void OnDisable()
public void UpdateNavMeshAsync()
public IEnumerator UpdateNavMeshAndWait()
private void AppendModifierVolumes(List`1<NavMeshBuildSource> sources)
public void FinishBuildingNavmesh()
}
public DynamicZNear : MonoBehaviour {
public float minimum
public float maximum
}
public EACServer : object {
private AntiCheatServerInterface Interface
private ReportsInterface Reports
private ConcurrentDictionary`2<UInt32, Connection> client2connection
private ConcurrentDictionary`2<Connection, UInt32> connection2client
private ConcurrentDictionary`2<Connection, AntiCheatCommonClientAuthStatus> connection2status
private UInt32 clientHandleCounter
private bool CanEnableGameplayData
private bool CanSendAnalytics
private bool CanSendReports
private bool get_CanEnableGameplayData()
private bool get_CanSendAnalytics()
private bool get_CanSendReports()
private IntPtr GenerateCompatibilityClient()
public void Encrypt(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst)
public void Decrypt(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst)
private IntPtr GetClient(Connection connection)
private Connection GetConnection(IntPtr client)
public bool IsAuthenticated(Connection connection)
private void OnAuthenticatedLocal(Connection connection)
private void OnAuthenticatedRemote(Connection connection)
private void OnVerifyIdToken(VerifyIdTokenCallbackInfo& data)
private void OnClientAuthStatusChanged(OnClientAuthStatusChangedCallbackInfo& data)
private void OnClientActionRequired(OnClientActionRequiredCallbackInfo& data)
private void SendToClient(OnMessageToClientCallbackInfo& data)
public void DoStartup()
public void DoUpdate()
public void DoShutdown()
public void OnLeaveGame(Connection connection)
public void OnJoinGame(Connection connection)
public void OnStartLoading(Connection connection)
public void OnFinishLoading(Connection connection)
public void OnMessageReceived(Message message)
public void LogPlayerUseWeapon(BasePlayer player, BaseProjectile weapon)
public void LogPlayerSpawn(BasePlayer player)
public void LogPlayerDespawn(BasePlayer player)
public void LogPlayerTakeDamage(BasePlayer player, HitInfo info)
public void LogPlayerTick(BasePlayer player)
public void LogPlayerRevive(BasePlayer source, BasePlayer target)
public void SendPlayerBehaviorReport(BasePlayer reporter, PlayerReportsCategory reportCategory, string reportedID, string reportText)
public void SendPlayerBehaviorReport(PlayerReportsCategory reportCategory, string reportedID, string reportText)
}
public EasterBasket : AttackEntity {
public GameObjectRef eggProjectile
public ItemDefinition ammoType
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
public Item GetAmmo()
public bool HasAmmo()
public void UseAmmo()
public void ThrowEgg(RPCMessage msg)
}
public Effect : EffectData {
public Vector3 Up
public Vector3 worldPos
public Vector3 worldNrm
public bool attached
public Transform transform
public GameObject gameObject
public string pooledString
public bool broadcast
private Effect reusableInstace
public void .ctor(string effectName, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection)
public void .ctor(string effectName, BaseEntity ent, UInt32 boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection)
public void Init(Type fxtype, BaseEntity ent, UInt32 boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection)
public void Init(Type fxtype, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection)
public void Clear()
}
public EffectAudioPerspectiveSwitcher : MonoBehaviour {
public EffectParentToWeaponBone parentToWeaponComponent
}
public EffectBlood : EffectRecycle {
public GameObjectRef ReplacementEffect
}
public EffectDictionary : object {
private Dictionary`2<string, String[]> effectDictionary
public string GetParticle(string impactType, string materialName)
public string GetParticle(DamageType damageType, string materialName)
public string GetDecal(string impactType, string materialName)
public string GetDecal(DamageType damageType, string materialName)
public string GetDisplacement(string impactType, string materialName)
private string LookupEffect(string category, string effect, string material)
}
public EffectMount : EntityComponent`1<BaseEntity> {
public bool firstPerson
public GameObject effectPrefab
public GameObject spawnedEffect
public GameObject mountBone
public SoundDefinition onSoundDef
public SoundDefinition offSoundDef
public bool blockOffSoundWhenGettingDisabled
}
public EffectNetwork : object {
public void Send(Effect effect)
public void Send(Effect effect, Connection target)
}
public EffectParent : EntityComponent`1<BaseEntity> {
public GameObject effect
public bool separatedEffect
}
public EffectParentToWeaponBone : BaseMonoBehaviour {
public string boneName
public bool singleFrame
}
public EffectRecycle : BaseMonoBehaviour {
public float detachTime
public float recycleTime
public PlayMode playMode
public ParentDestroyBehaviour onParentDestroyed
public int WarmedUpAmount
}
public EffectRecycleDetach : BaseMonoBehaviour {
public float recycleTime
}
public EffectRecycleLite : BasePrefab {
private float lifeTime
}
public EffectsBenchmarkScene : BenchmarkScene {
public GameObjectRef[] effectPrefabs
}
public EffectScaleWithCameraDistance : MonoBehaviour {
public float minScale
public float maxScale
public float scaleStartDistance
public float scaleEndDistance
}
public EggAmmoRepresentation : MonoBehaviour {
public GameObject[] eggAmmo
}
public EggHuntEvent : BaseHuntEvent {
public float warmupTime
public float warnTime
public float timeAlive
public EggHuntEvent serverEvent
public EggHuntEvent clientEvent
public float durationSeconds
public Dictionary`2<ulong, EggHunter> _eggHunters
public ItemAmount[] placementAwards
private Dictionary`2<ulong, List`1<CollectableEasterEgg>> _spawnedEggs
private float eggSpawningFrameBudget
private int maxEggPerPlayer
private int initialSpawnIndex
private Stopwatch stopwatch
public Phrase topBunnyPhrase
public Phrase noPlayersPhrase
public Phrase placePhrase
public Phrase rewardPhrase
public bool IsEventActive()
public void Update()
public void DestroyShared()
public void ServerInit()
private void StartEvent()
private void EnableEggs()
public void SpawnEggs()
private IEnumerator SpawnInitialEggs()
private CollectableEasterEgg SpawnEggAtPoint(Vector3 pos, bool active)
private Vector3 GetRandomSpawnPoint(Vector3 pos, Vector3 aimDir, float minDist, float maxDist)
public void OnEggCollected(BasePlayer player, CollectableEasterEgg collectedEgg)
private void IncrementScore(BasePlayer player)
private void QueueUpdate()
private void DoNetworkUpdate()
private List`1<CollectableEasterEgg> TryGetPlayerEggs(ulong userID)
protected List`1<EggHunter> GetTopHunters()
protected Phrase GetTopBunnyPhrase()
protected Phrase GetNoPlayersPhrase()
protected Phrase GetPlacePhrase()
protected Phrase GetRewardPhrase()
protected void PrintWinnersAndAward()
protected void ReportEggsCollected(int numEggs)
protected void ReportPlayerParticipated(int topCount)
private void CleanupEggs()
private void Cooldown()
public void Save(SaveInfo info)
}
public EggHuntNote : MonoBehaviour {
public CanvasGroup mainGroup
public CanvasGroup timerGroup
public RustText timerText
public Phrase startsInPhrase
}
public EggSwap : MonoBehaviour {
public Renderer[] eggRenderers
public void Show(int index)
public void HideAll()
}
public ElectricalBlocker : IOEntity {
protected int input1Amount
protected int input2Amount
public int ConsumptionAmount()
public int GetPassthroughAmount(int outputSlot)
public bool WantsPower(int inputIndex)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void UpdateBlocked()
public void UpdateFromInput(int inputAmount, int inputSlot)
}
public ElectricalBranch : IOEntity {
public int branchAmount
public GameObjectRef branchPanelPrefab
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int ConsumptionAmount()
public void RPC_SetBranchOffPower(RPCMessage msg)
public void SetBranchOffPower(int power)
public bool AllowDrainFrom(int outputSlot)
public int GetPassthroughAmount(int outputSlot)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ElectricalCombiner : IOEntity {
public int input1Amount
public int input2Amount
public int input3Amount
public bool BlockFluidDraining
public bool IsRootEntity()
public int ConsumptionAmount()
public bool get_BlockFluidDraining()
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int slot)
}
public ElectricalDFlipFlop : IOEntity {
private int setAmount
private int resetAmount
private int toggleAmount
public int ConsumptionAmount()
public void UpdateHasPower(int inputAmount, int inputSlot)
public bool GetDesiredState()
public void UpdateState()
public void UpdateFromInput(int inputAmount, int inputSlot)
public int GetPassthroughAmount(int outputSlot)
public void UpdateOutputs()
public bool AllowDrainFrom(int outputSlot)
public bool WantsPower(int inputIndex)
}
public ElectricalHeater : IOEntity {
public float fadeDuration
public Light sourceLight
public GrowableHeatSource growableHeatSource
public int ConsumptionAmount()
public void ResetState()
public void OnFlagsChanged(Flags old, Flags next)
public void OnKilled(HitInfo info)
}
public ElectricBattery : IOEntity {
public int maxOutput
public float maxCapactiySeconds
public float rustWattSeconds
private int activeDrain
public bool rechargable
public float maximumInboundEnergyRatio
public float chargeRatio
private float tickRateSeconds
public Flags Flag_HalfFull
public Flags Flag_VeryFull
private bool wasLoaded
private HashSet`1<ValueTuple`2<IOEntity, int>> connectedList
private Queue`1<int> inputHistory
private int inputHistorySize
public bool IsRootEntity()
public int ConsumptionAmount()
public int MaximalPowerOutput()
public int GetActiveDrain()
public void ReceiveInstanceData(InstanceData data)
public void PostServerLoad()
public void OnPickedUp(Item createdItem, BasePlayer player)
public int GetCurrentEnergy()
public int DesiredPower(int inputIndex)
public void SendAdditionalData(BasePlayer player, int slot, bool input)
public void ServerInit()
public int GetDrainFor(IOEntity ent)
public void AddConnectedRecursive(IOEntity root, int inputIndex, HashSet`1& listToUse)
public int GetDrain()
public void OnCircuitChanged(bool forceUpdate)
public void CheckDischarge()
public void SetDischarging(bool wantsOn)
public int GetPassthroughAmount(int outputSlot)
public bool WantsPower(int inputIndex)
private int GetHighestInputFromHistory()
public void IOStateChanged(int inputAmount, int inputSlot)
public void TickUsage()
public void ChargeChanged(float oldCharge)
public void AddCharge()
public void SetPassthroughOn(bool wantsOn)
public void Unbusy()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void batteryid(Arg arg)
}
public ElectricFurnaceIO : IOEntity {
public int PowerConsumption
public ItemContainer Container
public BaseEntity IndustrialEntity
public int ConsumptionAmount()
public int DesiredPower(int inputIndex)
public void UpdateHasPower(int inputAmount, int inputSlot)
private ElectricOven GetParentOven()
public ItemContainer get_Container()
public Vector2i InputSlotRange(int slotIndex)
public Vector2i OutputSlotRange(int slotIndex)
public void OnStorageItemTransferBegin()
public void OnStorageItemTransferEnd()
public BaseEntity get_IndustrialEntity()
}
public ElectricGenerator : IOEntity {
public float electricAmount
public bool IsRootEntity()
public int MaximalPowerOutput()
public int ConsumptionAmount()
public int GetCurrentEnergy()
public int GetPassthroughAmount(int outputSlot)
public void UpdateOutputs()
public void IOStateChanged(int inputAmount, int inputSlot)
public void PostServerLoad()
private void ForcePuzzleReset()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ElectricOven : BaseOven {
public GameObjectRef IoEntity
public Transform IoEntityAnchor
public EntityRef`1<IOEntity> spawnedIo
public bool CanRunWithNoFuel
public void ServerInit()
public void SpawnIOEnt()
public bool get_CanRunWithNoFuel()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void OvenFull()
private void PauseCooking()
public void OnItemAddedOrRemoved(Item item, bool bAdded)
protected bool CanPickupOven()
}
public ElectricSwitch : IOEntity {
public bool isToggleSwitch
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool WantsPower(int inputIndex)
public int ConsumptionAmount()
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void ServerInit()
public void SetSwitch(bool state)
public void Flip()
public void RPC_Switch(RPCMessage msg)
private void UnBusy()
}
public ElectricWindmill : IOEntity {
public Animator animator
public int maxPowerGeneration
public Transform vaneRot
public SoundDefinition wooshSound
public Transform wooshOrigin
public float targetSpeed
public float serverWindSpeed
public int MaximalPowerOutput()
public bool IsRootEntity()
public float GetWindSpeedScale()
public void Load(LoadInfo info)
public void ServerInit()
public void Save(SaveInfo info)
public bool AmIVisible()
public void WindUpdate()
public int GetPassthroughAmount(int outputSlot)
public Vector3 GetWindAimDir(float time)
}
public Elevator : IOEntity {
public Transform LiftRoot
public GameObjectRef LiftEntityPrefab
public GameObjectRef IoEntityPrefab
public Transform IoEntitySpawnPoint
public GameObject FloorBlockerVolume
public float LiftSpeedPerMetre
public GameObject[] PoweredObjects
public MeshRenderer PoweredMesh
public Color PoweredLightColour
public Color UnpoweredLightColour
public SkinnedMeshRenderer[] CableRenderers
public LODGroup CableLod
public Transform CableRoot
public float LiftMoveDelay
private int <Floor>k__BackingField
protected Flags TopFloorFlag
public Flags ElevatorPowered
public ElevatorLift liftEntity
public IOEntity ioEntity
public Int32[] previousPowerAmount
public bool IsStatic
public int Floor
public bool IsTop
public float FloorHeight
public bool get_IsStatic()
public int get_Floor()
public void set_Floor(int value)
public bool get_IsTop()
public void Load(LoadInfo info)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public void CallElevator()
public void Server_RaiseLowerElevator(Direction dir, bool goTopBottom)
public bool RequestMoveLiftTo(int targetFloor, Single& timeToTravel, Elevator fromElevator)
protected void OpenLiftDoors()
public void OnMoveBegin()
public float TimeToTravelDistance(float distance)
public Vector3 GetWorldSpaceFloorPosition(int targetFloor)
public float get_FloorHeight()
public void ClearBusy()
public bool IsValidFloor(int targetFloor)
public Elevator GetElevatorInDirection(Direction dir)
public void UpdateChildEntities(bool isTop)
public void FindExistingIOChild()
public void Save(SaveInfo info)
public int LiftPositionToFloor()
public void DestroyShared()
private void Cleanup()
public void PostServerLoad()
public void UpdateHasPower(int inputAmount, int inputSlot)
private void OnPhysicsNeighbourChanged()
public bool HasFloorSocketConnection()
public void NotifyLiftEntityDoorsOpen(bool state)
protected void OpenDoorsAtFloor(int floor)
public void OnFlagsChanged(Flags old, Flags next)
public void FindExistingLiftChild()
public void OnFlagToggled(bool state)
private void <CallElevator>b__29_0(Elevator elevatorEnt)
}
public ElevatorIOEntity : IOEntity {
public int Consumption
public int ConsumptionAmount()
}
public ElevatorLift : BaseCombatEntity {
public GameObject DescendingHurtTrigger
public GameObject MovementCollider
public Transform UpButtonPoint
public Transform DownButtonPoint
public TriggerNotify VehicleTrigger
public GameObjectRef LiftArrivalScreenBounce
public SoundDefinition liftMovementLoopDef
public SoundDefinition liftMovementStartDef
public SoundDefinition liftMovementStopDef
public SoundDefinition liftMovementAccentSoundDef
public GameObjectRef liftButtonPressedEffect
public float movementAccentMinInterval
public float movementAccentMaxInterval
private Sound liftMovementLoopSound
private float nextMovementAccent
public Vector3 lastPosition
private Flags PressedUp
private Flags PressedDown
private Elevator owner
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private Elevator get_owner()
public void ServerInit()
public void ToggleHurtTrigger(bool state)
public void Server_RaiseLowerFloor(RPCMessage msg)
private void ClearDirection()
public void Hurt(HitInfo info)
public void AdminKill()
public void PostServerLoad()
public bool CanMove()
public void NotifyNewFloor(int newFloor, int totalFloors)
public void ToggleMovementCollider(bool state)
}
public ElevatorLiftStatic : ElevatorLift {
public GameObjectRef ElevatorDoorRef
public Transform ElevatorDoorLocation
public bool BlockPerFloorMovement
private Flags CanGoUp
private Flags CanGoDown
public void ServerInit()
public void NotifyNewFloor(int newFloor, int totalFloors)
}
public ElevatorStatic : Elevator {
public bool StaticTop
public Flags LiftRecentlyArrived
public List`1<ElevatorStatic> floorPositions
public ElevatorStatic ownerElevator
public bool IsStatic
public bool get_IsStatic()
public void Spawn()
private void UpdateFloorPositions()
public void PostServerLoad()
public void PostMapEntitySpawn()
public bool IsValidFloor(int targetFloor)
public Vector3 GetWorldSpaceFloorPosition(int targetFloor)
public void SetFloorDetails(int floor, ElevatorStatic owner)
public void CallElevator()
public ElevatorStatic ElevatorAtFloor(int floor)
protected void OpenDoorsAtFloor(int floor)
public void OnMoveBegin()
public void OnLiftLeavingFloor()
public void ClearBusy()
protected void OpenLiftDoors()
public void OnLiftArrivedAtFloor()
public void ClearPowerOutput()
public int GetPassthroughAmount(int outputSlot)
public void Load(LoadInfo info)
}
public EmissionBlink : FacepunchBehaviour {
public EmissionToggle emissionToggle
public float blinkDuration
public float blinkInterval
}
public EmissionOffsetStepped : MonoBehaviour {
public Material material
public float offsetAmount
public float minInterval
public float maxInterval
}
public EmissionScaledByLight : MonoBehaviour {
private Color emissionColor
public Renderer[] targetRenderers
public int materialIndex
private MaterialPropertyBlock block
public Light lightToFollow
public float maxEmissionValue
}
public EmissionToggle : MonoBehaviour {
private Color emissionColor
public Renderer[] targetRenderers
public int materialIndex
}
public EmojiAutocomplete : MonoBehaviour {
public RectTransform Parent
public GameObjectRef EmojiPrefab
public RectTransform Selector
}
public EmojiController : ListComponent`1<EmojiController> {
public Image Image
public RawImage VideoImage
public RectTransform rectTransform
}
public EmojiControllerGallery : EmojiController {
public RustText NameText
}
public EmojiGallery : MonoBehaviour {
public GameObjectRef EmojiPrefab
public Transform Parent
public RustEmojiLibrary Library
public GameObject HighlightRoot
public RustText HighlightText
public EmojiController SkinIndicator
public EmojiController[] SkinToneGallery
public RustEmojiConfig SkinDemoConfig
public GameObject SkinPickerRoot
public TmProEmojiInputField TargetInputField
}
public EmojiResult : ValueType {
public Sprite Sprite
public VideoClip Video
}
public EncryptedValue`1 : ValueType {
private TInner _value
public TInner Get()
public void Set(TInner value)
public string ToString()
public EncryptedValue`1<TInner> op_Implicit(TInner value)
public TInner op_Implicit(EncryptedValue`1<TInner> encrypted)
}
public EngineAudioClip : MonoBehaviour {
public AudioClip granularClip
public AudioClip accelerationClip
public TextAsset accelerationCyclesJson
public List`1<EngineCycle> accelerationCycles
public List`1<EngineCycleBucket> cycleBuckets
public Dictionary`2<int, EngineCycleBucket> accelerationCyclesByRPM
public Dictionary`2<int, int> rpmBucketLookup
public int sampleRate
public int samplesUntilNextGrain
public int lastCycleId
public List`1<Grain> grains
public int currentRPM
public int targetRPM
public int minRPM
public int maxRPM
public int cyclePadding
public float RPMControl
public AudioSource source
public float rpmLerpSpeed
public float rpmLerpSpeedDown
private int GetBucketRPM(int RPM)
}
public EngineAudioSet : ScriptableObject {
public BlendedEngineLoopDefinition[] engineAudioLoops
public int priority
public float idleRpm
public float gearUpRpm
public float gearDownRpm
public int numGears
public float minRpm
public float maxRpm
public float gearUpRpmRate
public float gearDownRpmRate
public SoundDefinition badPerformanceLoop
public BlendedEngineLoopDefinition GetEngineLoopDef(int numEngines)
}
public EngineDamageOverTime : object {
private List`1<RecentDamage> recentDamage
private float maxSeconds
private float triggerDamage
private Action trigger
public void .ctor(float triggerDamage, float maxSeconds, Action trigger)
public void TakeDamage(float amount)
private float GetRecentDamage()
}
public EngineItemInformationPanel : ItemInformationPanel {
private Text tier
private Phrase low
private Phrase medium
private Phrase high
private GameObject accelerationRoot
private GameObject topSpeedRoot
private GameObject fuelEconomyRoot
}
public EngineSwitch : BaseEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void StopEngine(RPCMessage msg)
public void StartEngine(RPCMessage msg)
}
public EntityCollisionMessage : EntityComponent`1<BaseEntity> {
private void OnCollisionEnter(Collision collision)
}
public EntityComponent`1 : EntityComponentBase {
public T _baseEntity
public T baseEntity
public T get_baseEntity()
protected void UpdateBaseEntity()
public BaseEntity GetBaseEntity()
}
public EntityComponentBase : BaseMonoBehaviour {
public BaseEntity GetBaseEntity()
public void SaveComponent(SaveInfo info)
public void LoadComponent(LoadInfo info)
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public EntityDebug : EntityComponent`1<BaseEntity> {
internal Stopwatch stopwatch
private void Update()
}
public EntityFlag_Animator : EntityFlag_Toggle {
public Animator TargetAnimator
public string ParamName
public AnimatorMode AnimationMode
public float FloatOnState
public float FloatOffState
public int IntegerOnState
public int IntegerOffState
}
public EntityFlag_TOD : EntityComponent`1<BaseEntity> {
public Flags desiredFlag
public bool onAtNight
public void Start()
public void Initialize()
public bool WantsOn()
private void DoTimeCheck()
}
public EntityFlag_Toggle : EntityComponent`1<BaseEntity> {
public bool runClientside
public bool runServerside
public Flags flag
private FlagCheck flagCheck
private Flags notFlag
private UnityEvent onFlagEnabled
private UnityEvent onFlagDisabled
internal bool hasRunOnce
internal bool lastToggleOn
protected void OnDisable()
public void DoUpdate(BaseEntity entity)
protected void OnStateToggled(bool state)
public void OnPostNetworkUpdate(BaseEntity entity)
public void OnSendNetworkUpdate(BaseEntity entity)
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public EntityFlag_ToggleNotify : EntityFlag_Toggle {
public bool UseEntityParent
protected void OnStateToggled(bool state)
}
public EntityFuelSystem : object {
public bool isServer
private bool editorGiveFreeFuel
private UInt32 fuelStorageID
public EntityRef`1<StorageContainer> fuelStorageInstance
public float nextFuelCheckTime
public bool cachedHasFuel
public float pendingFuel
public void .ctor(bool isServer, GameObjectRef fuelStoragePrefab, List`1<BaseEntity> children, bool editorGiveFreeFuel)
public bool HasValidInstance(bool isServer)
public NetworkableId GetInstanceID()
public void SetInstanceID(NetworkableId uid)
public bool IsInFuelInteractionRange(BasePlayer player)
public StorageContainer GetFuelContainer()
public void CheckNewChild(BaseEntity child)
public Item GetFuelItem()
public int GetFuelAmount()
public float GetFuelFraction()
public bool HasFuel(bool forceCheck)
public int TryUseFuel(float seconds, float fuelUsedPerSecond)
public void LootFuel(BasePlayer player)
public void AddFuel(int amount)
public void FillFuel()
public int GetFuelCapacity()
}
public EntityItem_RotateWhenOn : EntityComponent`1<BaseEntity> {
public State on
public State off
internal bool currentlyOn
internal bool stateInitialized
public Flags targetFlag
}
public EntityLink : object {
public BaseEntity owner
public Socket_Base socket
public List`1<EntityLink> connections
public int capacity
public string name
public string get_name()
public void Setup(BaseEntity owner, Socket_Base socket)
public void EnterPool()
public void LeavePool()
public bool Contains(EntityLink entity)
public void Add(EntityLink entity)
public void Remove(EntityLink entity)
public void Clear()
public bool IsEmpty()
public bool IsOccupied()
public bool IsMale()
public bool IsFemale()
public bool CanConnect(EntityLink link)
}
public EntityLinkEx : object {
public void FreeLinks(List`1<EntityLink> links)
public void ClearLinks(List`1<EntityLink> links)
public void AddLinks(List`1<EntityLink> links, BaseEntity entity, Socket_Base[] sockets)
}
public EntityListScriptableObject : ScriptableObject {
public BaseEntity[] entities
public bool blockIfAny
public bool IsInList(UInt32 prefabId)
}
public EntityPrivilege : SimplePrivilege {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void AddSelfAuthorize(RPCMessage rpc)
public void AddPlayer(BasePlayer player)
private void RemoveSelfAuthorize(RPCMessage rpc)
private void ClearList(RPCMessage rpc)
}
public EntityRef : ValueType {
internal BaseEntity ent_cached
internal NetworkableId id_cached
public NetworkableId uid
public bool IsSet()
public bool IsValid(bool serverside)
public void Set(BaseEntity ent)
public BaseEntity Get(bool serverside)
public NetworkableId get_uid()
public void set_uid(NetworkableId value)
}
public EntityRef`1 : ValueType {
private EntityRef entityRef
public bool IsSet
public NetworkableId uid
public void .ctor(NetworkableId uid)
public bool get_IsSet()
public bool IsValid(bool serverside)
public void Set(T entity)
public T Get(bool serverside)
public bool TryGet(bool serverside, T& entity)
public NetworkableId get_uid()
public void set_uid(NetworkableId value)
}
public EntityTimedDestroy : EntityComponent`1<BaseEntity> {
public float secondsTillDestroy
private void OnEnable()
private void TimedDestroy()
}
public EntityType : Enum {
public int value__
public EntityType Player
public EntityType NPC
public EntityType WorldItem
public EntityType Corpse
public EntityType TimedExplosive
public EntityType Chair
public EntityType BasePlayerNPC
}
public EnumListItemUI : MonoBehaviour {
public object Value
public RustText TextValue
private EnumListUI list
public void Init(object value, string valueText, EnumListUI list)
public void Clicked()
}
public EnumListUI : MonoBehaviour {
public Transform PrefabItem
public Transform Container
private Action`1<object> clickedAction
private CanvasScaler canvasScaler
private void Awake()
public void Show(List`1<object> values, Action`1<object> clicked)
public void ItemClicked(object value)
public void Hide()
}
public EnvironmentManager : SingletonComponent`1<EnvironmentManager> {
public EnvironmentType Get(OBB obb)
public EnvironmentType Get(Vector3 pos, List`1& list, float radius)
public EnvironmentType Get(Vector3 pos, float radius)
public bool Check(OBB obb, EnvironmentType type)
public bool Check(Vector3 pos, EnvironmentType type, float radius)
}
public EnvironmentType : Enum {
public int value__
public EnvironmentType Underground
public EnvironmentType Building
public EnvironmentType Outdoor
public EnvironmentType Elevator
public EnvironmentType PlayerConstruction
public EnvironmentType TrainTunnels
public EnvironmentType UnderwaterLab
public EnvironmentType Submarine
public EnvironmentType BuildingDark
public EnvironmentType BuildingVeryDark
public EnvironmentType NoSunlight
}
public EnvironmentVolume : MonoBehaviour {
public EnvironmentType Type
public Vector3 Center
public Vector3 Size
private Collider <trigger>k__BackingField
public Collider trigger
public Collider get_trigger()
private void set_trigger(Collider value)
protected void Awake()
protected void OnEnable()
protected void OnDisable()
public void UpdateTrigger()
}
public EnvironmentVolumeEx : object {
public bool CheckEnvironmentVolumes(Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
public bool CheckEnvironmentVolumes(Transform transform, EnvironmentType type)
public bool CheckEnvironmentVolumesInsideTerrain(Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type, float padding)
public bool CheckEnvironmentVolumesInsideTerrain(Transform transform, EnvironmentType type)
public bool CheckEnvironmentVolumesOutsideTerrain(Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type, float padding)
public bool CheckEnvironmentVolumesOutsideTerrain(Transform transform, EnvironmentType type)
}
public EnvironmentVolumePropertiesCollection : ScriptableObject {
public float TransitionSpeed
public LayerMask ReflectionMask
public EnvironmentMultiplier[] ReflectionMultipliers
public float DefaultReflectionMultiplier
public EnvironmentMultiplier[] AmbientMultipliers
public float DefaultAmbientMultiplier
public OceanParameters OceanOverrides
}
public EnvironmentVolumeTrigger : MonoBehaviour {
private EnvironmentVolume <volume>k__BackingField
public Vector3 Center
public Vector3 Size
public EnvironmentVolume volume
public EnvironmentVolume get_volume()
private void set_volume(EnvironmentVolume value)
protected void Awake()
}
public EnvSync : PointEntity {
private float syncInterval
private float syncIntervalInv
public void ServerInit()
private void UpdateNetwork()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ErrorText : MonoBehaviour {
public TextMeshProUGUI text
public int maxLength
private Stopwatch stopwatch
public void OnEnable()
public void OnDisable()
internal void CaptureLog(string error, string stacktrace, LogType type)
protected void Update()
}
public ERVegetationStudio : ScriptableObject {
public bool VegetationStudio()
public bool VegetationStudioPro()
public void CreateVegetationMaskLine(GameObject go, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
public void UpdateVegetationMaskLine(GameObject go, ERVSData[] vsData, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
public void UpdateHeightmap(Bounds bounds)
public void RemoveVegetationMaskLine(GameObject go)
public void CreateBiomeArea(GameObject go, float distance, float blendDistance, float noise)
public void UpdateBiomeArea(GameObject go, ERVSData[] vsData, float distance, float blendDistance, float noise)
public void RemoveBiomeArea(GameObject go)
}
public EventSchedule : BaseMonoBehaviour {
public float minimumHoursBetween
public float maxmumHoursBetween
public HashSet`1<EventSchedule> allEvents
public float hoursRemaining
public long lastRun
public void TriggerEvent(Arg arg)
public void KillAllEvents()
public string GetName()
private void OnEnable()
private void OnDisable()
public void RunSchedule()
private void Trigger()
private void CountHours()
}
public EventScheduleWipeOffset : EventSchedule {
public float hoursBeforeWipeRealtime
public void RunSchedule()
}
public ExcavatorArm : BaseEntity {
public float yaw1
public float yaw2
public Transform wheel
public float wheelSpeed
public float turnSpeed
public Transform miningOffset
public GameObjectRef bounceEffect
public LightGroupAtTime lights
public Material conveyorMaterial
public float beltSpeedMax
public Flags Flag_HasPower
public List`1<ExcavatorOutputPile> outputPiles
public SoundDefinition miningStartButtonSoundDef
public ItemAmount[] resourcesToMine
public float resourceProductionTickRate
public float timeForFullResources
public ItemAmount[] pendingResources
public Phrase excavatorPhrase
public float movedAmount
public float currentTurnThrottle
public float lastMoveYaw
private float excavatorStartTime
private float nextNotificationTime
public int resourceMiningIndex
protected float PositionTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPowered()
public bool IsMining()
protected float get_PositionTickRate()
public float GetNetworkTime()
public void FixedUpdate()
public void BeginMining()
public void StopMining()
public void ProduceResources()
public void OnEntityMessage(BaseEntity from, string msg)
public void RPC_SetResourceTarget(RPCMessage msg)
public void RPC_StopMining(RPCMessage msg)
public void Spawn()
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void PostMapEntitySpawn()
public void Init()
}
public ExcavatorEffects : MonoBehaviour {
public ExcavatorEffects instance
public ParticleSystemContainer[] miningParticles
public SoundPlayer[] miningSounds
public SoundFollowCollider[] beltSounds
public SoundPlayer[] miningStartSounds
public GameObject[] ambientMetalRattles
public bool wasMining
}
public ExcavatorEngineSounds : MonoBehaviour {
public SoundPlayer[] engineStartClunks
public void PlayStartClunks()
}
public ExcavatorServerEffects : MonoBehaviour {
public ExcavatorServerEffects instance
public TriggerBase[] miningTriggers
public void Awake()
public void OnDestroy()
public void SetMining(bool isMining, bool force)
}
public ExcavatorSignalComputer : BaseCombatEntity {
public float chargePower
public Flags Flag_Ready
public Flags Flag_HasPower
public GameObjectRef supplyPlanePrefab
public Transform[] dropPoints
public Text statusText
public Text timerText
public Phrase readyphrase
public Phrase chargephrase
public float chargeNeededForSupplies
private float lastChargeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Save(SaveInfo info)
public void ServerInit()
public void PostServerLoad()
public void ChargeThink()
public void OnEntityMessage(BaseEntity from, string msg)
public void RequestSupplies(RPCMessage rpc)
public bool IsPowered()
public void Load(LoadInfo info)
}
public ExcavatorYawSounds : MonoBehaviour {
public SoundPlayer[] miningStartClunks
public void PlayStartClunks()
}
public ExecComponent : MonoBehaviour {
public string ExecToRun
public void Run()
}
public ExpandedLifeStats : MonoBehaviour {
public GameObject DisplayRoot
public GameObjectRef GenericStatRow
public Transform ResourcesStatRoot
public List`1<GenericStatDisplay> ResourceStats
public GameObjectRef WeaponStatRow
public Transform WeaponsRoot
public Transform MiscRoot
public List`1<GenericStatDisplay> MiscStats
public LifeInfographic Infographic
public RectTransform MoveRoot
public Vector2 OpenPosition
public Vector2 ClosedPosition
public GameObject OpenButtonRoot
public GameObject CloseButtonRoot
public GameObject ScrollGradient
public ScrollRect Scroller
}
public Explosion_Bloom : MonoBehaviour {
public Settings settings
private Shader m_Shader
private Material m_Material
private int kMaxIterations
private RenderTexture[] m_blurBuffer1
private RenderTexture[] m_blurBuffer2
private int m_Threshold
private int m_Curve
private int m_PrefilterOffs
private int m_SampleScale
private int m_Intensity
private int m_BaseTex
public Shader shader
public Material material
public bool supportsDX11
public Shader get_shader()
public Material get_material()
public bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
public Material CheckShaderAndCreateMaterial(Shader s)
public bool get_supportsDX11()
private void Awake()
private void OnEnable()
private void OnDisable()
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public ExplosionDemoGUI : MonoBehaviour {
public GameObject[] Prefabs
public float reactivateTime
public Light Sun
private int currentNomber
private GameObject currentInstance
private GUIStyle guiStyleHeader
private float sunIntensity
private float dpiScale
private void Start()
private void OnGUI()
private void ChangeCurrent(int delta)
}
public ExplosionDemoReactivator : MonoBehaviour {
public float TimeDelayToReactivate
private void Start()
private void Reactivate()
}
public ExplosionPlatformActivator : MonoBehaviour {
public GameObject Effect
public float TimeDelay
public float DefaultRepeatTime
public float NearRepeatTime
private float currentTime
private float currentRepeatTime
private bool canUpdate
private void Start()
private void Init()
private void Update()
private void OnTriggerEnter(Collider coll)
private void OnTriggerExit(Collider other)
}
public ExplosionsBillboard : MonoBehaviour {
public Camera Camera
public bool Active
public bool AutoInitCamera
private GameObject myContainer
private Transform t
private Transform camT
private Transform contT
private void Awake()
private void Update()
}
public ExplosionsDeactivateRendererByTime : MonoBehaviour {
public float TimeDelay
private Renderer rend
private void Awake()
private void DeactivateRenderer()
private void OnEnable()
}
public ExplosionsFPS : MonoBehaviour {
private GUIStyle guiStyleHeader
private float timeleft
private float fps
private int frames
private void Awake()
private void OnGUI()
private void Update()
}
public ExplosionsLightCurves : MonoBehaviour {
public AnimationCurve LightCurve
public float GraphTimeMultiplier
public float GraphIntensityMultiplier
private bool canUpdate
private float startTime
private Light lightSource
private void Awake()
private void OnEnable()
private void Update()
}
public ExplosionsParticleSystemScaler : MonoBehaviour {
public float particlesScale
private void Start()
private void Update()
}
public ExplosionsScaleCurves : MonoBehaviour {
public AnimationCurve ScaleCurveX
public AnimationCurve ScaleCurveY
public AnimationCurve ScaleCurveZ
public Vector3 GraphTimeMultiplier
public Vector3 GraphScaleMultiplier
private float startTime
private Transform t
private float evalX
private float evalY
private float evalZ
private void Awake()
private void OnEnable()
private void Update()
}
public ExplosionsShaderColorGradient : MonoBehaviour {
public string ShaderProperty
public int MaterialID
public Gradient Color
public float TimeMultiplier
private bool canUpdate
private Material matInstance
private int propertyID
private float startTime
private Color oldColor
private void Start()
private void OnEnable()
private void Update()
}
public ExplosionsShaderFloatCurves : MonoBehaviour {
public string ShaderProperty
public int MaterialID
public AnimationCurve FloatPropertyCurve
public float GraphTimeMultiplier
public float GraphScaleMultiplier
private bool canUpdate
private Material matInstance
private int propertyID
private float startTime
private void Start()
private void OnEnable()
private void Update()
}
public ExplosionsShaderQueue : MonoBehaviour {
public int AddQueue
private Renderer rend
private void Start()
private void SetProjectorQueue()
private void OnDisable()
}
internal ExplosionsSpriteSheetAnimation : MonoBehaviour {
public int TilesX
public int TilesY
public float AnimationFPS
public bool IsInterpolateFrames
public int StartFrameOffset
public bool IsLoop
public float StartDelay
public AnimationCurve FrameOverTime
private bool isInizialised
private int index
private int count
private int allCount
private float animationLifeTime
private bool isVisible
private bool isCorutineStarted
private Renderer currentRenderer
private Material instanceMaterial
private float currentInterpolatedTime
private float animationStartTime
private bool animationStoped
private void Start()
private void InitDefaultVariables()
private void Play()
private void PlayDelay()
private void OnEnable()
private void OnDisable()
private IEnumerator UpdateCorutine()
private void UpdateFrame()
private void Update()
private void OnDestroy()
}
public ExplosiveInformationPanel : ItemInformationPanel {
public ItemTextValue explosiveDmgDisplay
public ItemTextValue lethalDmgDisplay
public ItemTextValue throwDistanceDisplay
public ItemTextValue projectileDistanceDisplay
public ItemTextValue fuseLengthDisplay
public ItemTextValue blastRadiusDisplay
public Text unreliableText
}
public ExtendGBufferParams : ValueType {
public bool enabled
public ExtendGBufferParams Default
}
public EyeBlink : MonoBehaviour {
public Transform LeftEye
public Transform LeftEyelid
public Vector3 LeftEyeOffset
public Transform RightEye
public Transform RightEyelid
public Vector3 RightEyeOffset
public Vector3 ClosedEyelidPosition
public Vector3 ClosedEyelidRotation
public Vector2 TimeWithoutBlinking
public float BlinkSpeed
public Vector3 LeftEyeInitial
public Vector3 RightEyeInitial
}
public EyeController : MonoBehaviour {
public float MaxLookDot
public bool debug
public Transform LeftEye
public Transform RightEye
public Transform EyeTransform
public Vector3 Fudge
public Vector3 FlickerRange
private Transform Focus
private float FocusUpdateTime
}
public EZSoftBoneHitboxSystemCollider : EZSoftBoneColliderBase {
public float radius
public void Collide(Vector3& position, float spacing)
}
public F15 : BaseCombatEntity {
public float speed
public float defaultAltitude
public float altitude
public float altitudeLerpSpeed
public float turnRate
public float flybySoundLengthUntilMax
public SoundPlayer flybySound
public GameObject body
public float rollSpeed
public Vector3 movePosition
public GameObjectRef missilePrefab
private float nextMissileTime
private float blockTurningFor
private bool isRetiring
private CH47PathFinder pathFinder
private float turnSeconds
protected float PositionTickRate
protected bool PositionTickFixedTime
protected float get_PositionTickRate()
protected bool get_PositionTickFixedTime()
public float GetNetworkTime()
public float GetDesiredAltitude()
public void ServerInit()
public void RetireToSunset()
public void PickNewPatrolPoint()
private void FixedUpdate()
public void DelayedDestroy()
}
public Facepunch.CardGames.BlackjackController : CardGameController {
public List`1<PlayingCard> dealerCards
public float BLACKJACK_PAYOUT_RATIO
public float INSURANCE_PAYOUT_RATIO
private float DEALER_MOVE_TIME
private BlackjackInputOption <LastAction>k__BackingField
private ulong <LastActionTarget>k__BackingField
private int <LastActionValue>k__BackingField
private int NUM_DECKS
private StackOfCards cardStack
public int MinPlayers
public int MinBuyIn
public int MaxBuyIn
public int MinToPlay
public int EndRoundDelay
public int TimeBetweenRounds
public BlackjackInputOption LastAction
public ulong LastActionTarget
public int LastActionValue
public bool AllBetsPlaced
public void .ctor(BaseCardGameEntity owner)
public int get_MinPlayers()
public int get_MinBuyIn()
public int get_MaxBuyIn()
public int get_MinToPlay()
public int get_EndRoundDelay()
public int get_TimeBetweenRounds()
public BlackjackInputOption get_LastAction()
private void set_LastAction(BlackjackInputOption value)
public ulong get_LastActionTarget()
private void set_LastActionTarget(ulong value)
public int get_LastActionValue()
private void set_LastActionValue(int value)
public bool get_AllBetsPlaced()
protected int GetFirstPlayerRelIndex(bool startOfRound)
public List`1<PlayingCard> GetTableCards()
public void InputsToList(int availableInputs, List`1<BlackjackInputOption> result)
public bool WaitingForOtherPlayers(CardPlayerData pData)
public int GetCardsValue(List`1<PlayingCard> cards, CardsValueMode mode)
public int GetOptimalCardsValue(List`1<PlayingCard> cards)
public int GetCardValue(PlayingCard card, CardsValueMode mode)
public bool Has21(List`1<PlayingCard> cards)
public bool HasBlackjack(List`1<PlayingCard> cards)
public bool HasBusted(List`1<PlayingCard> cards)
private bool CanSplit(CardPlayerDataBlackjack pData)
private bool HasAnyAces(List`1<PlayingCard> cards)
private bool CanDoubleDown(CardPlayerDataBlackjack pData)
private bool CanTakeInsurance(CardPlayerDataBlackjack pData)
private bool HasSplit(CardPlayerDataBlackjack pData)
protected CardPlayerData GetNewCardPlayerData(int mountIndex)
public bool TryGetCardPlayerDataBlackjack(int index, CardPlayerDataBlackjack& cpBlackjack)
public int ResultsToInt(BlackjackRoundResult mainResult, BlackjackRoundResult splitResult, int insurancePayout)
public void ResultsFromInt(int result, BlackjackRoundResult& mainResult, BlackjackRoundResult& splitResult, Int32& insurancePayout)
public void Save(CardGame syncData)
private void EditorMakeRandomMove(CardPlayerDataBlackjack pdBlackjack)
protected int GetAvailableInputsForPlayer(CardPlayerData pData)
protected void SubEndGameplay()
protected void SubEndRound()
private int PayOut(CardPlayerData pData, int winnings)
protected void HandlePlayerLeavingTable(CardPlayerData pData)
protected void SubReceivedInputFromPlayer(CardPlayerData pData, int input, int value, bool countAsAction)
private void DoInRoundPlayerInput(CardPlayerDataBlackjack pdBlackjack, BlackjackInputOption& selectedMove, Int32& selectedMoveValue)
private void DoBettingPhasePlayerInput(CardPlayerDataBlackjack pdBlackjack, int value, bool countAsAction, BlackjackInputOption& selectedMove, Int32& selectedMoveValue)
private int TryMakeBet(CardPlayerDataBlackjack pdBlackjack, int maxAmount, BetType betType)
protected void SubStartRound()
protected void OnTurnTimeout(CardPlayerData pData)
protected void StartNextCycle()
protected bool ShouldEndCycle()
protected void EndCycle()
private void DealerPlayInvoke()
private void DealInitialCards()
private void ClearLastAction()
private BlackjackRoundResult <SubEndRound>g__CheckResult|59_0(List`1<PlayingCard> cards, int betAmount, Int32& winnings, <>c__DisplayClass59_0& )
}
public Facepunch.CardGames.CardGameController : object {
private CardGameState <State>k__BackingField
private CardPlayerData[] <PlayerData>k__BackingField
public int IDLE_KICK_SECONDS
private BaseCardGameEntity <Owner>k__BackingField
private RoundResults <resultInfo>k__BackingField
public CardList localPlayerCards
protected int activePlayerIndex
public int STD_RAISE_INCREMENTS
protected bool isWaitingBetweenTurns
public CardGameState State
public bool HasGameInProgress
public bool HasRoundInProgressOrEnding
public bool HasActiveRound
public CardPlayerData[] PlayerData
public int MinPlayers
public int MinBuyIn
public int MaxBuyIn
public int MinToPlay
public float MaxTurnTime
public int EndRoundDelay
public int TimeBetweenRounds
protected float TimeBetweenTurns
public BaseCardGameEntity Owner
public int ScrapItemID
protected bool IsServer
protected bool IsClient
public RoundResults resultInfo
public CardGameState get_State()
public void set_State(CardGameState value)
public bool get_HasGameInProgress()
public bool get_HasRoundInProgressOrEnding()
public bool get_HasActiveRound()
public CardPlayerData[] get_PlayerData()
private void set_PlayerData(CardPlayerData[] value)
public int get_MinPlayers()
public int get_MinBuyIn()
public int get_MaxBuyIn()
public int get_MinToPlay()
public float get_MaxTurnTime()
public int get_EndRoundDelay()
public int get_TimeBetweenRounds()
protected float get_TimeBetweenTurns()
public BaseCardGameEntity get_Owner()
public void set_Owner(BaseCardGameEntity value)
public int get_ScrapItemID()
protected bool get_IsServer()
protected bool get_IsClient()
public RoundResults get_resultInfo()
private void set_resultInfo(RoundResults value)
public void .ctor(BaseCardGameEntity owner)
public IEnumerable`1<CardPlayerData> PlayersInRound()
protected int GetFirstPlayerRelIndex(bool startOfRound)
public void Dispose()
public int NumPlayersAllowedToPlay(CardPlayerData ignore)
public Playability GetPlayabilityStatus(CardPlayerData cpd)
public bool TryGetActivePlayer(CardPlayerData& activePlayer)
protected bool ToCardPlayerData(int relIndex, bool includeOutOfRound, CardPlayerData& result)
public int RelToAbsIndex(int relIndex, bool includeFolded)
public int GameToRoundIndex(int gameRelIndex)
public int NumPlayersInGame()
public int NumPlayersInCurrentRound()
public int MaxPlayersAtTable()
public bool PlayerIsInGame(BasePlayer player)
public bool IsAtTable(BasePlayer player)
public List`1<PlayingCard> GetTableCards()
public void StartTurnTimer(CardPlayerData pData, float turnTime)
public bool IsAtTable(ulong userID)
public int GetScrapInPot()
public bool TryGetCardPlayerData(int index, CardPlayerData& cardPlayer)
public bool TryGetCardPlayerData(ulong forPlayer, CardPlayerData& cardPlayer)
public bool TryGetCardPlayerData(BasePlayer forPlayer, CardPlayerData& cardPlayer)
public bool IsAllowedToPlay(CardPlayerData cpd)
protected void ClearResultsInfo()
protected CardPlayerData GetNewCardPlayerData(int mountIndex)
protected void OnTurnTimeout(CardPlayerData playerData)
protected void SubStartRound()
protected void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction)
protected int GetAvailableInputsForPlayer(CardPlayerData playerData)
protected void HandlePlayerLeavingTable(CardPlayerData pData)
protected void SubEndRound()
protected void SubEndGameplay()
protected void EndCycle()
protected bool ShouldEndCycle()
public void EditorMakeRandomMove()
public void JoinTable(BasePlayer player)
protected void SyncAllLocalPlayerCards()
protected void SyncLocalPlayerCards(CardPlayerData pData)
public void JoinTable(ulong userID)
public void LeaveTable(ulong userID)
public void LeaveTable(CardPlayerData pData)
protected int TryAddBet(CardPlayerData playerData, int maxAmount)
protected int GoAllIn(CardPlayerData playerData)
protected int TryMoveToPotStorage(CardPlayerData playerData, int maxAmount)
protected int PayOutFromPot(CardPlayerData playerData, int maxAmount)
protected int PayOutAllFromPot(CardPlayerData playerData)
protected void ClearPot()
public int RemoveScrapFromStorage(CardPlayerData data)
public void Save(CardGame syncData)
public void InvokeStartNewRound()
public bool TryStartNewRound()
protected void BeginRoundEnd()
protected void EndRoundWithDelay()
public void EndRound()
protected void AddRoundResult(CardPlayerData pData, int winnings, int resultCode)
protected void EndGameplay()
public void ReceivedInputFromPlayer(BasePlayer player, int input, bool countAsAction, int value)
public void ReceivedInputFromPlayer(CardPlayerData pData, int input, bool countAsAction, int value, bool playerInitiated)
public void UpdateAllAvailableInputs()
public void PlayerStorageChanged()
public void ServerPlaySound(SoundType type)
public void GetConnectionsInGame(List`1<Connection> connections)
public void OnTableDestroyed()
protected bool TryMoveToNextPlayerWithInputs(int startIndex, CardPlayerData& newActivePlayer)
protected void StartNextCycle()
protected void QueueNextCycleInvoke()
private void CancelNextCycleInvoke()
}
public Facepunch.CardGames.CardPlayerData : object {
private ulong <UserID>k__BackingField
public List`1<PlayingCard> Cards
private CardPlayerState <State>k__BackingField
public int mountIndex
private bool isServer
public int availableInputs
public int betThisRound
public int betThisTurn
private bool <LeftRoundEarly>k__BackingField
private bool <SendCardDetails>k__BackingField
public int finalScore
private bool <hasCompletedTurn>k__BackingField
public float lastActionTime
public int remainingToPayOut
private Func`2<int, StorageContainer> getStorage
public int scrapItemID
private Action`1<CardPlayerData> turnTimerCallback
public ulong UserID
public CardPlayerState State
public bool HasUser
public bool HasUserInGame
public bool HasUserInCurrentRound
public bool HasAvailableInputs
public bool AllCardsAreKnown
private bool IsClient
public bool LeftRoundEarly
public bool SendCardDetails
public bool hasCompletedTurn
public ulong get_UserID()
public void set_UserID(ulong value)
public CardPlayerState get_State()
public void set_State(CardPlayerState value)
public bool get_HasUser()
public bool get_HasUserInGame()
public bool get_HasUserInCurrentRound()
public bool get_HasAvailableInputs()
public bool get_AllCardsAreKnown()
private bool get_IsClient()
public bool get_LeftRoundEarly()
public void set_LeftRoundEarly(bool value)
public bool get_SendCardDetails()
public void set_SendCardDetails(bool value)
public void .ctor(int mountIndex, bool isServer)
public void .ctor(int scrapItemID, Func`2<int, StorageContainer> getStorage, int mountIndex, bool isServer)
public void Dispose()
public int GetScrapAmount()
public int GetTotalBetThisRound()
public List`1<PlayingCard> GetMainCards()
public List`1<PlayingCard> GetSecondaryCards()
public bool get_hasCompletedTurn()
private void set_hasCompletedTurn(bool value)
public void SetHasCompletedTurn(bool hasActed)
public bool HasBeenIdleFor(int seconds)
public StorageContainer GetStorage()
public void AddUser(ulong userID)
public void ClearAllData()
public void JoinRound()
protected void ClearPerRoundData()
public void LeaveCurrentRound(bool clearBets, bool leftRoundEarly)
public void LeaveGame()
public void EnableSendingCards()
public string HandToString()
public string HandToString(List`1<PlayingCard> cards)
public void Save(CardGame syncData)
public void StartTurnTimer(Action`1<CardPlayerData> callback, float maxTurnTime)
public void CancelTurnTimer()
public void TimeoutTurn()
}
public Facepunch.CardGames.CardPlayerDataBlackjack : CardPlayerData {
public List`1<PlayingCard> SplitCards
public int splitBetThisRound
public int insuranceBetThisRound
public bool playingSplitCards
public void .ctor(int mountIndex, bool isServer)
public void .ctor(int scrapItemID, Func`2<int, StorageContainer> getStorage, int mountIndex, bool isServer)
public void Dispose()
public int GetTotalBetThisRound()
public List`1<PlayingCard> GetSecondaryCards()
protected void ClearPerRoundData()
public void LeaveCurrentRound(bool clearBets, bool leftRoundEarly)
public void LeaveGame()
public void Save(CardGame syncData)
public bool TrySwitchToSplitHand()
private void SwapSplitCardsWithMain()
}
public Facepunch.CardGames.PlayingCard : object {
public bool IsUnknownCard
public Suit Suit
public Rank Rank
public PlayingCard[] cards
public PlayingCard unknownCard
private void .ctor(Suit suit, Rank rank)
public PlayingCard GetCard(Suit suit, Rank rank)
public PlayingCard GetCard(int suit, int rank)
public PlayingCard GetCard(int index)
public int GetIndex()
public int GetIndex(Suit suit, Rank rank)
public int GetPokerEvaluationValue()
private int GetPokerSuitCode()
private PlayingCard[] GenerateAllCards()
}
public Facepunch.CardGames.Rank : Enum {
public int value__
public Rank Two
public Rank Three
public Rank Four
public Rank Five
public Rank Six
public Rank Seven
public Rank Eight
public Rank Nine
public Rank Ten
public Rank Jack
public Rank Queen
public Rank King
public Rank Ace
}
public Facepunch.CardGames.StackOfCards : object {
private List`1<PlayingCard> cards
public void .ctor(int numDecks)
public bool TryTakeCard(PlayingCard& card)
public void AddCard(PlayingCard card)
public void ShuffleDeck()
public void Print()
}
public Facepunch.CardGames.Suit : Enum {
public int value__
public Suit Spades
public Suit Hearts
public Suit Diamonds
public Suit Clubs
}
public Facepunch.CardGames.TexasHoldEmController : CardGameController {
public List`1<PlayingCard> communityCards
public int SMALL_BLIND
public int BIG_BLIND
public string WON_HAND_STAT
private PokerInputOption <LastAction>k__BackingField
private ulong <LastActionTarget>k__BackingField
private int <LastActionValue>k__BackingField
private int <BiggestRaiseThisTurn>k__BackingField
private int dealerIndex
private StackOfCards deck
public int MinPlayers
public int MinBuyIn
public int MaxBuyIn
public int MinToPlay
public PokerInputOption LastAction
public ulong LastActionTarget
public int LastActionValue
public int BiggestRaiseThisTurn
public int get_MinPlayers()
public int get_MinBuyIn()
public int get_MaxBuyIn()
public int get_MinToPlay()
public PokerInputOption get_LastAction()
private void set_LastAction(PokerInputOption value)
public ulong get_LastActionTarget()
private void set_LastActionTarget(ulong value)
public int get_LastActionValue()
private void set_LastActionValue(int value)
public int get_BiggestRaiseThisTurn()
private void set_BiggestRaiseThisTurn(int value)
public void .ctor(BaseCardGameEntity owner)
public int GetCurrentBet()
public bool TryGetDealer(CardPlayerData& dealer)
public bool TryGetSmallBlind(CardPlayerData& smallBlind)
public bool TryGetBigBlind(CardPlayerData& bigBlind)
protected int GetFirstPlayerRelIndex(bool startOfRound)
public ushort EvaluatePokerHand(List`1<PlayingCard> cards)
public int GetCurrentMinRaise(CardPlayerData playerData)
public List`1<PlayingCard> GetTableCards()
public void InputsToList(int availableInputs, List`1<PokerInputOption> result)
protected CardPlayerData GetNewCardPlayerData(int mountIndex)
public void Save(CardGame syncData)
protected void SubStartRound()
protected void SubEndRound()
protected void AddRoundResult(CardPlayerData pData, int winnings, int winState)
protected void SubEndGameplay()
private void IncrementDealer()
private void DealHoleCards()
private bool DealCommunityCards()
private void ClearLastAction()
protected void OnTurnTimeout(CardPlayerData pData)
protected void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction)
protected void StartNextCycle()
protected bool ShouldEndCycle()
protected void EndCycle()
protected int GetAvailableInputsForPlayer(CardPlayerData playerData)
protected void HandlePlayerLeavingTable(CardPlayerData pData)
private bool AnyoneElseCanBetMore(CardPlayerData excluding)
}
public Facepunch.FPNativeList`1 : object {
private NativeArray`1<T> _array
private int _length
private int _capacity
public NativeArray`1<T> Array
public int Count
public int Capacity
public T Item
public NativeArray`1<T> get_Array()
public int get_Count()
public int get_Capacity()
public T get_Item(int index)
public void set_Item(int index, T value)
public void Add(T item)
public void RemoveLast()
public void SetLength(int newLength)
public void Clear()
public void Resize(int count)
public void EnsureCapacity(int requiredCapacity)
public void EnterPool()
public void LeavePool()
}
public Facepunch.GUI.Controls : object {
public float labelWidth
public float FloatSlider(string strLabel, float value, float low, float high, string format)
public int IntSlider(string strLabel, int value, int low, int high, string format)
public string TextArea(string strName, string value)
public bool Checkbox(string strName, bool value)
public bool Button(string strName)
}
internal Facepunch.GUI.TabbedPanel : object {
private int selectedTabID
private List`1<Tab> tabs
public Tab selectedTab
public Tab get_selectedTab()
public void Add(Tab tab)
internal void DrawVertical(float width)
internal void DrawContents()
}
public Facepunch.Output : object {
private Action`3<string, string, LogType> OnMessage
private Action`3<string, string, LogType> OnPostMessage
public bool installed
public List`1<Entry> HistoryOutput
public void add_OnMessage(Action`3<string, string, LogType> value)
public void remove_OnMessage(Action`3<string, string, LogType> value)
public void add_OnPostMessage(Action`3<string, string, LogType> value)
public void remove_OnPostMessage(Action`3<string, string, LogType> value)
public void Install()
public void LogHandler(string log, string stacktrace, LogType type)
}
public Facepunch.RCon : object {
public string Password
public int Port
public string Ip
public bool Web
public bool Print
internal RConListener listener
public Listener listenerNew
private Queue`1<Command> Commands
private float lastRunTime
internal List`1<BannedAddresses> bannedAddresses
private int responseIdentifier
private int responseConnection
private bool isInput
internal int SERVERDATA_AUTH
internal int SERVERDATA_EXECCOMMAND
internal int SERVERDATA_AUTH_RESPONSE
internal int SERVERDATA_RESPONSE_VALUE
internal int SERVERDATA_CONSOLE_LOG
internal int SERVERDATA_SWITCH_UTF8
public void Initialize()
public void Shutdown()
public void Broadcast(LogType type, object obj)
public void Broadcast(LogType type, string message)
public void Update()
public void BanIP(IPAddress addr, float seconds)
public bool IsBanned(IPAddress addr)
private void OnCommand(Command cmd)
private void OnMessage(string message, string stacktrace, LogType type)
}
public Facepunch.Rust.Analytics : object {
public HashSet`1<string> StatsBlacklist
private HashSet`1<NetworkableId> trackedSpawnedIds
private string <ClientAnalyticsUrl>k__BackingField
private string <ServerAnalyticsUrl>k__BackingField
private string <AnalyticsHeader>k__BackingField
private bool <UploadAnalytics>k__BackingField
private string <AnalyticsSecret>k__BackingField
private string <AnalyticsPublicKey>k__BackingField
private string <BulkUploadConnectionString>k__BackingField
private bool <HighFrequencyStats>k__BackingField
public string stats_blacklist
public string ClientAnalyticsUrl
public string ServerAnalyticsUrl
public string AnalyticsHeader
public bool UploadAnalytics
public string AnalyticsSecret
public string AnalyticsPublicKey
public string BulkUploadConnectionString
public bool HighFrequencyStats
public string get_stats_blacklist()
public void set_stats_blacklist(string value)
public string get_ClientAnalyticsUrl()
public void set_ClientAnalyticsUrl(string value)
public string get_ServerAnalyticsUrl()
public void set_ServerAnalyticsUrl(string value)
public string get_AnalyticsHeader()
public void set_AnalyticsHeader(string value)
public bool get_UploadAnalytics()
public void set_UploadAnalytics(bool value)
public string get_AnalyticsSecret()
public void set_AnalyticsSecret(string value)
public string get_AnalyticsPublicKey()
public void set_AnalyticsPublicKey(string value)
public string get_BulkUploadConnectionString()
public void set_BulkUploadConnectionString(string value)
public bool get_HighFrequencyStats()
public void set_HighFrequencyStats(bool value)
public void GetPendingAnalytics(Arg arg)
}
public Facepunch.Rust.AnalyticsDocumentMode : Enum {
public int value__
public AnalyticsDocumentMode JSON
public AnalyticsDocumentMode CSV
}
public Facepunch.Rust.AzureAnalyticsUploader : object {
private TimeSpan <LoopDelay>k__BackingField
private DateTime <Expiry>k__BackingField
private bool <StrictMode>k__BackingField
private AnalyticsDocumentMode <DocumentMode>k__BackingField
private bool <UseJsonDataObject>k__BackingField
private ConcurrentQueue`1<EventRecord> queue
private BlobClient _blobClient
private Stream Stream
private GZipStream ZipStream
private StreamWriter Writer
private bool readyToFlush
private bool invalid
public TimeSpan LoopDelay
public DateTime Expiry
public bool StrictMode
public AnalyticsDocumentMode DocumentMode
public bool UseJsonDataObject
public TimeSpan get_LoopDelay()
public void set_LoopDelay(TimeSpan value)
public DateTime get_Expiry()
private void set_Expiry(DateTime value)
public bool get_StrictMode()
public void set_StrictMode(bool value)
public AnalyticsDocumentMode get_DocumentMode()
private void set_DocumentMode(AnalyticsDocumentMode value)
public bool get_UseJsonDataObject()
public void set_UseJsonDataObject(bool value)
public void EnterPool()
public void LeavePool()
public bool TryFlush()
public AzureAnalyticsUploader Create(string table, TimeSpan timeout, AnalyticsDocumentMode mode)
public void Append(EventRecord record)
private Task CreateBlobAsync()
private Task UploadThread()
}
public Facepunch.Rust.AzureAnalyticsUploaderEx : object {
public bool NeedsCreation(AzureAnalyticsUploader uploader)
}
public Facepunch.Rust.EventRecord : object {
public long TicksToNS
public DateTime Timestamp
public bool IsServer
private string <EventType>k__BackingField
public List`1<EventRecordField> Data
public int TimesCreated
public int TimesSubmitted
public string EventType
public string get_EventType()
private void set_EventType(string value)
public void EnterPool()
public void LeavePool()
public EventRecord CSV()
public EventRecord New(string type, bool isServer)
public EventRecord AddObject(string key, object data)
public EventRecord SetTimestamp(DateTime timestamp)
public EventRecord AddField(string key, DateTime time)
public EventRecord AddField(string key, bool value)
public EventRecord AddField(string key, string value)
public EventRecord AddField(string key, int value)
public EventRecord AddField(string key, UInt32 value)
public EventRecord AddField(string key, ulong value)
public EventRecord AddField(string key, long value)
public EventRecord AddField(string key, float value)
public EventRecord AddField(string key, double value)
public EventRecord AddField(string key, TimeSpan value)
public EventRecord AddLegacyTimespan(string key, TimeSpan value)
public EventRecord AddField(string key, Guid value)
public EventRecord AddField(string key, Vector3 value)
public EventRecord AddField(string key, BaseEntity entity)
public EventRecord AddField(string key, Item item)
public void MarkSubmitted()
public void Submit()
public void SerializeAsCSV(StreamWriter writer)
public void SerializeAsJson(StreamWriter writer, bool useDataObject)
}
public Facepunch.Rust.EventRecordField : ValueType {
public string Key1
public string Key2
public string String
public Nullable`1<long> Number
public Nullable`1<double> Float
public Nullable`1<Vector3> Vector
public Nullable`1<Guid> Guid
public DateTime DateTime
public bool IsObject
public void .ctor(string key1)
public void .ctor(string key1, string key2)
public void Serialize(StreamWriter writer)
}
public Facepunch.Rust.PerformanceLogging : object {
public PerformanceLogging server
public PerformanceLogging client
private TimeSpan ClientInterval
private TimeSpan ServerInterval
private TimeSpan PublicServerInterval
private TimeSpan PingInterval
private List`1<TimeSpan> Frametimes
private List`1<int> PingHistory
private List`1<LagSpike> lagSpikes
private List`1<GarbageCollect> garbageCollections
private Dictionary`2<string, int> pendingTimings
private bool isClient
private Stopwatch frameWatch
private DateTime nextPingTime
private DateTime nextFlushTime
private DateTime connectedTime
private int serverIndex
private Guid totalSessionId
private Guid sessionId
private int lastFrameGC
private Type oxideType
private bool hasOxideType
public void .ctor(bool client)
private TimeSpan GetLagSpikeThreshold()
public void OnFrame()
private Dictionary`2<string, string> FindModifiedConvars()
public void FlushMainThread()
private TimeSpan GetFlushInterval()
private void ResetMeasurements()
private Task ProcessPerformanceData(EventRecord record, List`1<TimeSpan> frametimes, List`1<int> ping)
public void SetTiming(string category, TimeSpan elapsed)
}
public Facepunch.Rust.Profiling.EntityProfiler : object {
public int mode
public TimeSpan aggregateEntityCountDelay
public int spawned
public int killed
public Dictionary`2<UInt32, EntityCounter> counts
public List`1<EntityCounter> list
private DateTime aggregateEntityCountCooldown
public void OnSpawned(BaseNetworkable entity)
public void OnKilled(BaseNetworkable entity)
public void Reset()
public void TrySerializeEntityAggregates(int frameIndex, DateTime timestamp, AzureAnalyticsUploader uploader)
public void Serialize(EventRecord record, int frameIndex, DateTime timestamp, AzureAnalyticsUploader uploader)
}
public Facepunch.Rust.Profiling.LagSpikeProfiler : object {
public bool enabled
private List`1<EventRecord> pendingEvents
public void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
public void Reset()
private void AddPendingRecord(EventRecord record)
public void RPC(TimeSpan time, Message packet, BaseEntity entity, UInt32 rpcId)
public void ConsoleCommand(TimeSpan time, Message packet, string command)
private EventRecord CreateRecord(TimeSpan duration, string reason)
}
public Facepunch.Rust.Profiling.RuntimeProfiler : object {
private TimeSpan <RpcWarningThreshold>k__BackingField
private TimeSpan <ConsoleCommandWarningThreshold>k__BackingField
private int profilingPreset
private int _profilingInterval
private bool _init
private Stopwatch serializationTimer
private AzureAnalyticsUploader frameProfilingUploader
private AzureAnalyticsUploader entityProfilingUploader
private AzureAnalyticsUploader entityAggregateUploader
private AzureAnalyticsUploader invokeDetailsUploader
private AzureAnalyticsUploader methodUploader
private AzureAnalyticsUploader objectWorkQueueUploader
private AzureAnalyticsUploader packetUploader
private AzureAnalyticsUploader lagSpikeUploader
public TimeSpan ServerMgr_Update
public TimeSpan Net_Cycle
public TimeSpan Physics_SyncTransforms
public TimeSpan Companion_Tick
public TimeSpan BasePlayer_ServerCycle
private ProfilerRecorderOptions PhysicsRecorderOptions
private List`1<RustProfilerRecorder> recorders
private Stopwatch invokeExecutionResetTimer
public int rpc_lagspike_threshold
public int command_lagspike_threshold
public TimeSpan RpcWarningThreshold
public TimeSpan ConsoleCommandWarningThreshold
public int runtime_profiling
public bool profiling_lagspikes
public bool profiling_packets
public int profiling_invokes
public int profiling_fixed_invokes
public int profiling_entities
public int profiling_entity_count_interval
public bool profiling_work_queue
public int runtime_profiling_interval
public void dump_profile_recorders(Arg arg)
public int get_rpc_lagspike_threshold()
public void set_rpc_lagspike_threshold(int value)
public int get_command_lagspike_threshold()
public void set_command_lagspike_threshold(int value)
public TimeSpan get_RpcWarningThreshold()
private void set_RpcWarningThreshold(TimeSpan value)
public TimeSpan get_ConsoleCommandWarningThreshold()
private void set_ConsoleCommandWarningThreshold(TimeSpan value)
public int get_runtime_profiling()
public void set_runtime_profiling(int value)
public bool get_profiling_lagspikes()
public void set_profiling_lagspikes(bool value)
public bool get_profiling_packets()
public void set_profiling_packets(bool value)
public int get_profiling_invokes()
public void set_profiling_invokes(int value)
public int get_profiling_fixed_invokes()
public void set_profiling_fixed_invokes(int value)
public int get_profiling_entities()
public void set_profiling_entities(int value)
public int get_profiling_entity_count_interval()
public void set_profiling_entity_count_interval(int value)
public bool get_profiling_work_queue()
public void set_profiling_work_queue(bool value)
public int get_runtime_profiling_interval()
public void set_runtime_profiling_interval(int value)
private void Start()
private void OnProfilingPresetChanged()
public void Update()
private void EnsureUploadersCreated()
private void CollectLastFrameStats()
private void WriteFrameData(int frameIndex)
private void ResetAllMeasurements()
private void SerializeCommon(EventRecord record)
private void SerializeNetworking(EventRecord frameRecord, int frameIndex, DateTime timestamp)
private void SerializeInvokes(EventRecord record)
private void SerializeInvokeExecutionTime(InvokeProfiler profiler, AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, bool reset)
private void SerializeProfilingSamples(EventRecord record)
}
public Facepunch.Rust.Profiling.RustProfilerRecorder : ValueType {
public string ColumnName
public ProfilerRecorder Recorder
public void .ctor(string column, ProfilerCategory category, string sample, int sampleCount, ProfilerRecorderOptions options)
}
public Facepunch.Rust.Profiling.UnityProfiler : object {
private List`1<RecorderInfo> ActiveRecorders
private bool _enabled
public bool enabled
public bool get_enabled()
public void set_enabled(bool value)
private void SetEnabled(bool state)
public void Unload()
public void Serialize(AzureAnalyticsUploader uploader, DateTime timestamp, int frameIndex)
}
public Facepunch.Rust.Profiling.WorkQueueProfiler : object {
public bool enabled
public void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
public void Reset()
}
public Facepunch.UI.ESPCanvas : SingletonComponent`1<ESPCanvas> {
public float RefreshRate
public ESPPlayerInfo Source
private int NameplateCount
public float OverrideMaxDisplayDistance
public bool DisableOcclusionChecks
public bool ShowHealth
public bool ColourCodeTeams
public float DisplayDistanceMultiplier
public int MaxNameplates
public int get_MaxNameplates()
public void set_MaxNameplates(int value)
}
public Facepunch.UI.ESPPlayerInfo : MonoBehaviour {
public Vector3 WorldOffset
public RustText Text
public TextMeshProUGUI[] TextElements
public RustIcon Loading
public GameObject ClanElement
public RustText ClanText
public CanvasGroup group
public Gradient gradientNormal
public Gradient gradientTeam
private Color TeamColor
private Color ClanColor
private Color AllyColor
private Color EnemyColor
public QueryVis visCheck
private BasePlayer <Entity>k__BackingField
public BasePlayer Entity
public BasePlayer get_Entity()
public void set_Entity(BasePlayer value)
}
public Facepunch.Unity.RenderInfo : object {
public void GenerateReport()
}
public Facepunch.Utility.Compression : object {
public Byte[] Compress(Byte[] data)
public Byte[] Uncompress(Byte[] data)
public int PackVector3ToInt(Vector3 vector, float minValue, float maxValue)
public Vector3 UnpackVector3FromInt(int packed, float minValue, float maxValue)
}
public Facepunch.VirtualScroll : MonoBehaviour {
public int ItemHeight
public int ItemSpacing
public RectOffset Padding
public GameObject DataSourceObject
public GameObject SourceObject
public ScrollRect ScrollRect
public RectTransform OverrideContentRoot
private IDataSource dataSource
private Dictionary`2<int, GameObject> ActivePool
private Stack`1<GameObject> InactivePool
private int BlockHeight
public void Awake()
public void OnDestroy()
private void OnScrollChanged(Vector2 pos)
public void SetDataSource(IDataSource source, bool forceRebuild)
private int get_BlockHeight()
public void FullRebuild()
public void DataChanged()
public void Rebuild()
public void Update()
private void RecycleOutOfRange(int startVisible, float endVisible)
private void Recycle(int key)
private void BuildItem(int i)
private GameObject GetItem()
}
public FavouriteRadioStation : MonoBehaviour {
public RustText UrlText
public GameObject XmasRoot
}
public FileEx : object {
public void Backup(DirectoryInfo parent, String[] names)
public bool MoveToSafe(FileInfo parent, string target, int retries)
public void Backup(String[] names)
}
public FileStorage : object {
private FileDatabase db
private CRC32 crc
private MruDictionary`2<UInt32, CacheData> _cache
public FileStorage server
protected void .ctor(string name, bool server)
protected void Finalize()
public void Dispose()
private UInt32 GetCRC(Byte[] data, Type type)
public UInt32 Store(Byte[] data, Type type, NetworkableId entityID, UInt32 numID)
public Byte[] Get(UInt32 crc, Type type, NetworkableId entityID, UInt32 numID)
public void Remove(UInt32 crc, Type type, NetworkableId entityID)
public void RemoveExact(UInt32 crc, Type type, NetworkableId entityID, UInt32 numid)
public void RemoveEntityNum(NetworkableId entityid, UInt32 numid)
public void RemoveAllByEntity(NetworkableId entityid)
public void ReassignEntityId(NetworkableId oldId, NetworkableId newId)
public IEnumerable`1<AssociatedFile> QueryAllByEntity(NetworkableId entityID)
}
public FileSystem_Warmup : MonoBehaviour {
public bool ranInBackground
public Coroutine warmupTask
private List`1<ValueTuple`2<string, TimeSpan>> warmupTimes
private bool run
public String[] ExcludeFilter
private Stopwatch warmupTimer
public IEnumerable`1<ValueTuple`2<string, TimeSpan>> GetWarmupTimes()
public void Run()
public IEnumerator Run(String[] assetList, Action`1<string> statusFunction, string format, int priority)
private IEnumerator RunAsyncImpl(String[] assetList, Action`1<string> statusFunction, string format, int priority)
private IEnumerator RunImpl(String[] assetList, Action`1<string> statusFunction, string format)
private float CalculateFrameBudget()
private bool ShouldIgnore(string path)
public String[] GetAssetList(Nullable`1<bool> poolFilter)
private void PrefabWarmup(string path)
}
public FireBall : BaseEntity {
public float lifeTimeMin
public float lifeTimeMax
public ParticleSystem[] movementSystems
public ParticleSystem[] restingSystems
public float generation
public GameObjectRef spreadSubEntity
public float tickRate
public float damagePerSecond
public float radius
public int waterToExtinguish
public bool canMerge
public LayerMask AttackLayers
public bool ignoreNPC
private Vector3 lastPos
private float deathTime
private int wetness
private float spawnTime
private Vector3 delayedVelocity
public void SetDelayedVelocity(Vector3 delayed)
private void ApplyDelayedVelocity()
public void ServerInit()
public float GetDeathTime()
public void AddLife(float amountToAdd)
public float MaxLifeTime()
public float TimeLeft()
public void TryToSpread()
public void SetGeneration(int gen)
public void Think()
public void DoRadialDamage()
public bool CanMerge()
public float TimeAlive()
public void SetResting(bool isResting)
public void Extinguish()
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public bool IsResting()
public void Load(LoadInfo info)
}
public FireBomb : MonoBehaviour {
public GameObject fireParticle
public float bombRadius
public float particleDuration
public float emitDuration
}
public FirecrackerRepeater : BaseMonoBehaviour {
public GameObjectRef singleExplosionEffect
public Transform[] parts
public float partWidth
public float partLength
public Quaternion[] targetRotations
public Quaternion[] initialRotations
public Renderer[] renderers
public Material materialSource
public float explodeRepeatMin
public float explodeRepeatMax
public float explodeLerpSpeed
public Vector3 twistAmount
public float fuseLength
public float explodeStrength
public float explodeDirBlend
public float duration
public ParticleSystemContainer smokeParticle
}
public FireSpot : BaseEntity {
public GameObject flameEffect
public void Load(LoadInfo info)
}
public FireworkBenchmarkScene : BenchmarkScene {
public GameObjectRef[] shellTypes
public int fireworkCount
}
public FireworkShell : BaseMonoBehaviour {
public float fuseLengthMin
public float fuseLengthMax
public float speedMin
public float speedMax
public ParticleSystem explodePFX
public SoundPlayer explodeSound
public float inaccuracyDegrees
public LightEx explosionLight
public float lifetime
}
public FirstPersonEffect : MonoBehaviour {
public bool isGunShot
public EffectParentToWeaponBone parentToWeaponComponent
}
public FishBrain : BaseAIBrain {
public int Count
public void AddStates()
public void InitializeAI()
public void OnDestroy()
}
public FishingBobber : BaseCombatEntity {
public Transform centerOfMass
public Rigidbody myRigidBody
public Transform lineAttachPoint
public Transform bobberRoot
public Flags CaughtFish
public float HorizontalMoveSpeed
public float PullAwayMoveSpeed
public float SidewaysInputForce
public float ReelInMoveSpeed
private float bobberForcePingPong
private Vector3 initialDirection
private float <TireAmount>k__BackingField
private Vector3 initialTargetPosition
private Vector3 spawnPosition
private TimeSince initialCastTime
private float initialDistance
public float TireAmount
public float get_TireAmount()
private void set_TireAmount(float value)
public void ServerInit()
public void InitialiseBobber(BasePlayer forPlayer, WaterBody forBody, Vector3 targetPos, float maxDuration)
private void ProcessInitialCast()
public void ServerMovementUpdate(bool inputLeft, bool inputRight, bool inputBack, FishState& state, Vector3 playerPos, ItemModFishable fishableModifier)
private bool IsDirectionValid(Vector3 pos, float checkLength, Vector3 playerPos)
private void TimeOutBobber()
}
public FishingRodViewmodel : MonoBehaviour {
public Transform PitchTransform
public Transform YawTransform
public float YawLerpSpeed
public float PitchLerpSpeed
public Transform LineRendererStartPos
public ParticleSystem[] StrainParticles
public bool ApplyTransformRotation
public GameObject CatchRoot
public Transform CatchLinePoint
public FishViewmodel[] FishViewmodels
public float ShakeMaxScale
}
public FishLookup : BaseScriptableObject {
public ItemModFishable FallbackFish
private FishLookup _instance
private ItemModFishable[] AvailableFish
public ItemDefinition[] BaitItems
private TimeSince lastShuffle
public int ALL_FISH_COUNT
public string ALL_FISH_ACHIEVEMENT_NAME
public FishLookup Instance
public FishLookup get_Instance()
public void LoadFish()
public ItemDefinition GetFish(Vector3 worldPos, WaterBody bodyType, Item lure, ItemModFishable& fishable, ItemModFishable ignoreFish, Int32& usedLureAmount, float overrideDepth)
public void CheckCatchAllAchievement(BasePlayer player)
}
public FishMount : StorageContainer {
public Animator[] FishRoots
public GameObjectRef FishInteractSound
public float UseCooldown
public Flags HasFish
private int GetCurrentFishItemIndex
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Save(SaveInfo info)
private int get_GetCurrentFishItemIndex()
public bool ItemFilter(Item item, int targetSlot)
public void PostServerLoad()
public void OnItemAddedOrRemoved(Item item, bool added)
private void UseFish(RPCMessage msg)
private void ClearBusy()
}
public FishNavigator : BaseNavigator {
private BaseNpc <NPC>k__BackingField
public BaseNpc NPC
public BaseNpc get_NPC()
private void set_NPC(BaseNpc value)
public void Init(BaseCombatEntity entity, NavMeshAgent agent)
protected bool SetCustomDestination(Vector3 pos, float speedFraction, float updateInterval)
protected void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
private void UpdateRotation(Vector3 moveToPosition, float delta)
}
public FishShoal : object {
private float maxFishDistance
private FishType fishType
private JobHandle jobHandle
private NativeArray`1<RaycastCommand> castCommands
private NativeArray`1<RaycastHit> castResults
private NativeArray`1<int> fishCastIndices
private NativeArray`1<FishData> fishData
private NativeArray`1<FishRenderData> fishRenderData
private NativeArray`1<int> fishCount
private MaterialPropertyBlock materialPropertyBlock
private ComputeBuffer fishBuffer
public void .ctor(FishType fishType)
private float3 GetTarget(float3 spawnPos, Random& random)
private int GetPopulationScaleForPoint(float3 cameraPosition)
public void TrySpawn(float3 cameraPosition)
public void OnUpdate(float3 cameraPosition)
private void UpdateJobs(float3 cameraPosition)
public void OnLateUpdate(float3 cameraPosition)
public void Dispose()
public void OnDrawGizmosSelected()
}
public FishStateExtensions : object {
public bool Contains(FishState state, FishState check)
public FishState FlipHorizontal(FishState state)
}
public FishSwarm : MonoBehaviour {
public FishType[] fishTypes
public FishShoal[] fishShoals
private void Awake()
private IEnumerator SpawnFish()
private void Update()
private void LateUpdate()
private void OnDestroy()
private void OnDrawGizmosSelected()
}
public FixedRateStepped : object {
public float rate
public int maxSteps
internal float nextCall
public bool ShouldStep()
}
public FixedSByteNorm3 : ValueType {
private int FracBits
private float MaxFrac
private float RcpMaxFrac
public sbyte x
public sbyte y
public sbyte z
public void .ctor(Vector3 vec)
public Vector3 op_Explicit(FixedSByteNorm3 vec)
}
public FixedSByteNorm4 : ValueType {
private int FracBits
private float MaxFrac
private float RcpMaxFrac
public sbyte x
public sbyte y
public sbyte z
public sbyte w
public void .ctor(Vector4 vec)
public Vector4 op_Explicit(FixedSByteNorm4 vec)
}
public FixedShort3 : ValueType {
private int FracBits
private float MaxFrac
private float RcpMaxFrac
public short x
public short y
public short z
public void .ctor(Vector3 vec)
public Vector3 op_Explicit(FixedShort3 vec)
}
public FlameExplosive : TimedExplosive {
public GameObjectRef createOnExplode
public bool blockCreateUnderwater
public float numToCreate
public float minVelocity
public float maxVelocity
public float spreadAngle
public bool forceUpForExplosion
public AnimationCurve velocityCurve
public AnimationCurve spreadCurve
public void Explode()
public void FlameExplode(Vector3 surfaceNormal)
public void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
}
public FlameJet : MonoBehaviour {
public LineRenderer line
public float tesselation
private float length
public float maxLength
public float drag
private int numSegments
private float spacing
public bool on
private Vector3[] lastWorldSegments
private Vector3[] currentSegments
public Color startColor
public Color endColor
public Color currentColor
public bool externalUpdate
private void Initialize()
private void Awake()
public void LateUpdate()
public void SetOn(bool isOn)
private float curve(float x)
public void UpdateLine()
}
public FlameThrower : AttackEntity {
public int maxAmmo
public int ammo
public ItemDefinition fuelType
public float timeSinceLastAttack
public float nextReadyTime
public float flameRange
public float flameRadius
public ParticleSystem[] flameEffects
public FlameJet jet
public GameObjectRef fireballPrefab
public List`1<DamageTypeEntry> damagePerSec
public float playerDamageMultiplier
public SoundDefinition flameStart3P
public SoundDefinition flameLoop3P
public SoundDefinition flameStop3P
public SoundDefinition pilotLoopSoundDef
private float tickRate
private float lastFlameTick
public float fuelPerSec
private float ammoRemainder
public float reloadDuration
private float lastReloadTime
private float nextFlameTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool IsWeaponBusy()
private void SetBusyFor(float dur)
private void ClearBusy()
public void ReduceAmmo(float firingTime)
public void PilotLightToggle_Shared()
public bool IsPilotOn()
public bool IsFlameOn()
public bool HasAmmo()
public Item GetAmmo()
public void Load(LoadInfo info)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void Save(SaveInfo info)
public void SetFiring(RPCMessage msg)
public void ServerUse()
public void TopUpAmmo()
public float AmmoFraction()
public bool ServerIsReloading()
public bool CanReload()
public void ServerReload()
public void StopFlameState()
public void DoReload(RPCMessage msg)
public void SetFlameState(bool wantsOn)
public void TogglePilotLight(RPCMessage msg)
public void OnHeldChanged()
public void FlameTick()
public void ServerCommand(Item item, string command, BasePlayer player)
}
public flamethrowerFire : MonoBehaviour {
public ParticleSystem pilotLightFX
public ParticleSystem[] flameFX
public FlameJet jet
public AudioSource oneShotSound
public AudioSource loopSound
public AudioClip pilotlightIdle
public AudioClip flameLoop
public AudioClip flameStart
public flamethrowerState flameState
private flamethrowerState previousflameState
public void PilotLightOn()
public void SetFlameStatus(bool status)
public void ShutOff()
public void FlameOn()
private void Start()
private void Update()
}
public FlameThrowerInformationPanel : ItemInformationPanel {
public ItemStatValue damageDisplay
public ItemStatValue rangeDisplay
}
public flamethrowerState : Enum {
public int value__
public flamethrowerState OFF
public flamethrowerState PILOT_LIGHT
public flamethrowerState FLAME_ON
}
public FlameTurret : StorageContainer {
public Transform upper
public Vector3 aimDir
public float arc
public float triggeredDuration
public float flameRange
public float flameRadius
public float fuelPerSec
public Transform eyeTransform
public List`1<DamageTypeEntry> damagePerSec
public GameObjectRef triggeredEffect
public GameObjectRef fireballPrefab
public GameObjectRef explosionEffect
public TargetTrigger trigger
private float nextFireballTime
private int turnDir
private float lastMovementUpdate
private float triggeredTime
private float lastServerThink
private float triggerCheckRate
private float nextTriggerCheckTime
private float pendingFuel
public UpdateFlameTurretWorkQueue updateFlameTurretQueueServer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsTriggered()
public Vector3 GetEyePosition()
public bool CanPickup(BasePlayer player)
public void SetTriggered(bool triggered)
public void ServerInit()
public void SendAimDir()
public float GetSpinSpeed()
public void OnAttacked(HitInfo info)
public void MovementUpdate(float delta)
public void ServerThink()
public bool CheckTrigger()
public void OnKilled(HitInfo info)
public int GetFuelAmount()
public bool HasFuel()
public bool UseFuel(float seconds)
public void DoFlame(float delta)
}
public Flashbang : TimedExplosive {
public SoundDefinition deafLoopDef
public float flashReductionPerSecond
public float flashToAdd
public float flashMinRange
public float flashMaxRange
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Explode()
public void DelayedDestroy()
}
public FlashbangEffect : PostProcessEffectSettings {
public FloatParameter burnIntensity
public FloatParameter whiteoutIntensity
}
public FlashbangEffectRenderer : PostProcessEffectRenderer`1<FlashbangEffect> {
public bool needsCapture
private Shader flashbangEffectShader
private RenderTexture screenRT
public void Init()
public void Render(PostProcessRenderContext context)
public void Release()
private void CheckCreateRenderTexture(RenderTexture& rt, string name, int width, int height, RenderTextureFormat format)
private void SafeDestroyRenderTexture(RenderTexture& rt)
}
public FlashbangOverlay : MonoBehaviour {
public FlashbangOverlay Instance
public PostProcessVolume postProcessVolume
public AnimationCurve burnIntensityCurve
public AnimationCurve whiteoutIntensityCurve
public SoundDefinition deafLoopDef
}
public FlasherLight : IOEntity {
public EmissionToggle toggler
public Light myLight
public float flashSpacing
public float flashBurstSpacing
public float flashOnTime
public int numFlashesPerBurst
public void ResetState()
}
public FlashlightBeam : MonoBehaviour {
public Vector2 scrollDir
public Vector3 localEndPoint
public LineRenderer beamRenderer
}
public FlintStrikeWeapon : BaseProjectile {
public float successFraction
public float successIncrease
public RecoilProperties strikeRecoil
public RecoilProperties GetRecoil()
}
public Float4x4Ex : object {
public float3 ToPosition(float4x4 m)
public Quaternion ToRotation(float4x4 m)
}
public FloatConditions : object {
public Condition[] conditions
public bool AllTrue(float val)
}
public FloodedSpawnHandler : object {
private Int32[] SpreadSteps
public bool GetSpawnPoint(SpawnPoint spawnPoint, float searchHeight)
private Vector3 FindSpawnPoint(float searchHeight)
private Vector3 Step(float angle, float distance)
private float RandomAngle()
}
public FluidSwitch : ElectricSwitch {
private Flags Flag_PumpPowered
public Animator PumpAnimator
private bool pumpEnabled
private int lastToggleInput
public bool IsGravitySource
protected bool DisregardGravityRestrictionsOnLiquid
public void ResetState()
public void IOStateChanged(int inputAmount, int inputSlot)
public void SetSwitch(bool wantsOn)
private void DelayedSendChanged()
public int GetPassthroughAmount(int outputSlot)
public int ConsumptionAmount()
public bool get_IsGravitySource()
protected bool get_DisregardGravityRestrictionsOnLiquid()
public bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement)
}
public FlybySound : MonoBehaviour {
public SoundDefinition flybySound
public float flybySoundDistance
public SoundDefinition closeFlybySound
public float closeFlybyDistance
}
public FogMachine : ContainerIOEntity {
public Flags FogFieldOn
public Flags MotionMode
public Flags Emitting
public Flags Flag_HasJuice
public float fogLength
public float nozzleBlastDuration
public float fuelPerSec
private float pendingFuel
public bool IsEmitting()
public bool HasJuice()
public void SetFogOn(RPCMessage msg)
public void SetFogOff(RPCMessage msg)
public void SetMotionDetection(RPCMessage msg)
public void UpdateMotionMode()
public void CheckTrigger()
public void StartFogging()
public void EnableFogField()
public void DisableNozzle()
public void FinishFogging()
public void PostServerLoad()
public void PlayerStoppedLooting(BasePlayer player)
public int GetFuelAmount()
public bool HasFuel()
public bool UseFuel(float seconds)
public void UpdateHasPower(int inputAmount, int inputSlot)
public int ConsumptionAmount()
public bool MotionModeEnabled()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public FogSettings : ValueType {
public Gradient ColorOverDaytime
public float Density
public float StartDistance
public float Height
public float HeightDensity
}
public FoliageBaker : MonoBehaviour {
public FoliageGridBaked BakedGrid
}
public FoliageDisplacement : MonoBehaviour {
public bool moving
public bool billboard
public Mesh mesh
public Material material
}
public FoliageGrid : SingletonComponent`1<FoliageGrid> {
public bool Paused
public GameObjectRef BatchPrefab
public float CellSize
public LayerSelect FoliageLayer
public ShadowCastingMode FoliageShadows
}
public FoliageGridBaked : FoliageGrid {
public BakedFoliagePlacement[] BakedData
}
public FoliageGridBatch : MeshBatch {
private Vector3 position
private Mesh meshBatch
private MeshFilter meshFilter
private MeshRenderer meshRenderer
private FoliageGridMeshData meshData
private MeshGroup meshGroup
private bool hasRunAwake
public int VertexCapacity
public int VertexCutoff
public int get_VertexCapacity()
public int get_VertexCutoff()
protected void Awake()
public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
public void Add(MeshInstance instance)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
}
public FoliageGridBenchmarkScene : BenchmarkScene {
private TerrainMeta terrainMeta
public GameObjectRef foliagePrefab
private GameObject foliageInstance
public GameObjectRef lodPrefab
private GameObject lodInstance
public GameObjectRef batchingPrefab
private GameObject batchingInstance
public Terrain terrain
public Transform viewpointA
public Transform viewpointB
public bool moveVantangePoint
}
public FoliageGridMeshData : object {
public List`1<FoliageVertex> vertices
public List`1<int> triangles
public Bounds bounds
public void Alloc()
public void Free()
public void Clear()
public void Combine(MeshGroup meshGroup)
public void Apply(Mesh mesh)
}
public FoliagePlacement : ScriptableObject {
public float Density
public SpawnFilter Filter
public float FilterCutoff
public float FilterFade
public float FilterScaling
public float RandomScaling
public MinMax Range
public float RangeFade
public float DistanceDensity
public float DistanceScaling
public Material material
public Mesh mesh0
public Mesh mesh1
public Mesh mesh2
public int lods
public int octaves
public float frequency
public float amplitude
public float offset
}
public FoliageRenderer : MonoBehaviour {
public Material material
public Mesh LOD0
public Mesh LOD1
}
public FoliageSpawn : MonoBehaviour {
public FoliagePlacement Placement
}
public FollowCamera : MonoBehaviour {
private void LateUpdate()
}
public FootstepEffects : BaseFootstepEffect {
public Transform leftFoot
public Transform rightFoot
public string footstepEffectName
public string jumpStartEffectName
public string jumpLandEffectName
public SoundDefinition accentSound
}
public FootstepSound : MonoBehaviour {
public SoundDefinition lightSound
public SoundDefinition medSound
public SoundDefinition hardSound
private float panAmount
}
public ForceChildSingletonSetup : MonoBehaviour {
private void Awake()
}
public FPSGraph : Graph {
public void Refresh()
protected void OnEnable()
protected float GetValue()
protected Color GetColor(float value)
}
public FpStandaloneInputModule : StandaloneInputModule {
public PointerEventData CurrentData
public PointerEventData get_CurrentData()
}
public FPSText : MonoBehaviour {
public Text text
private Stopwatch fpsTimer
protected void Update()
}
public FrankensteinBrain : PetBrain {
public float MoveTowardsRate
public void AddStates()
public void InitializeAI()
public FrankensteinPet GetEntity()
public void OnDestroy()
}
public FrankensteinPartInformationPanel : ItemInformationPanel {
public ItemTextValue healthDisplay
public ItemTextValue speedDisplay
public ItemTextValue attackRateDisplay
public ItemTextValue attackDamageDisplay
}
public FrankensteinPet : BasePet {
public float decayminutes
public SoundDefinition AttackVocalSFX
public float nextAttackTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public IEnumerator DelayEquipWeapon(ItemDefinition item, float delay)
private void TickDecay()
public float EngagementRange()
public bool IsThreat(BaseEntity entity)
public bool IsTarget(BaseEntity entity)
public bool IsFriendly(BaseEntity entity)
public bool CanAttack(BaseEntity entity)
public bool IsTargetInRange(BaseEntity entity, Single& dist)
public bool CanSeeTarget(BaseEntity entity)
public bool NeedsToReload()
public bool Reload()
public float CooldownDuration()
public bool IsOnCooldown()
public bool StartAttacking(BaseEntity target)
private void Attack(BaseCombatEntity target)
public void StopAttacking()
public float GetAmmoFraction()
public BaseEntity GetBestTarget()
public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
public bool ShouldDropActiveItem()
public BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List`1<TriggerBase> triggersOnDeath)
protected string OverrideCorpseName()
}
public FrankensteinTable : StorageContainer {
public GameObjectRef FrankensteinPrefab
public Transform SpawnLocation
public ItemDefinition WeaponItem
public List`1<ItemDefinition> HeadItems
public List`1<ItemDefinition> TorsoItems
public List`1<ItemDefinition> LegItems
public List`1<ItemDefinition> ItemsToUse
public FrankensteinTableVisuals TableVisuals
public float TableDownDuration
private bool waking
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsHeadItem(ItemDefinition itemDef)
public bool IsTorsoItem(ItemDefinition itemDef)
public bool IsLegsItem(ItemDefinition itemDef)
public bool HasValidItems(ItemContainer container)
public List`1<ItemDefinition> GetValidItems(ItemContainer container)
public bool HasAllValidItems(List`1<ItemDefinition> items)
private void CheckItem(ItemDefinition item, List`1<ItemDefinition> itemList, List`1<ItemDefinition> validItems, Boolean& set)
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
private bool CanAcceptItem(Item item, int targetSlot)
private void CreateFrankenstein(RPCMessage msg)
private bool CanStartCreating(BasePlayer player)
private bool IsInventoryEmpty()
private void ConsumeInventory()
private void RequestWakeFrankenstein(RPCMessage msg)
private void WakeFrankenstein(BasePlayer owner)
private IEnumerator DelayWakeFrankenstein(BasePlayer owner)
private void EquipFrankenstein(FrankensteinPet frank)
private void RequestSleepFrankenstein(RPCMessage msg)
private void SleepFrankenstein(BasePlayer owner)
private void ReturnFrankensteinItems(FrankensteinPet frank)
private IEnumerator WaitForFrankensteinBrainInit(BasePet frankenstein, BasePlayer player)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public FrankensteinTableVisuals : MonoBehaviour {
public GameObject FXReady
public GameObject FXNotReady
public GameObject FXWake
public Transform HeadVisualAnchor
public Transform TorsoVisualAnchor
public Transform LegsVisualAnchor
public Animator Animator
}
public FreeableLootContainer : LootContainer {
private Flags tiedDown
public Buoyancy buoyancy
public GameObjectRef freedEffect
private Rigidbody rb
public UInt32 skinOverride
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Rigidbody GetRB()
public bool IsTiedDown()
public void ServerInit()
public void OnAttacked(HitInfo info)
public void Release(BasePlayer ply)
public void RPC_FreeCrate(RPCMessage msg)
}
public Frost : PostProcessEffectSettings {
public FloatParameter scale
public BoolParameter enableVignette
public FloatParameter sharpness
public FloatParameter darkness
}
public FrostRenderer : PostProcessEffectRenderer`1<Frost> {
private int scaleProperty
private int sharpnessProperty
private int darknessProperty
private Shader frostShader
public void Init()
public void Render(PostProcessRenderContext context)
}
public FruitScale : MonoBehaviour {
public void SetProgress(float progress)
}
public FuelElectricGenerator : IOEntity {
public float electricAmount
}
public FuelGenerator : ContainerIOEntity {
public int outputEnergy
public float fuelPerSec
protected float fuelTickRate
private float pendingFuel
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsRootEntity()
public int MaximalPowerOutput()
public int ConsumptionAmount()
public void Init()
public void UpdateFromInput(int inputAmount, int inputSlot)
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
public void UpdateCurrentEnergy()
public int GetPassthroughAmount(int outputSlot)
public bool AllowDrainFrom(int outputSlot)
public void RPC_EngineSwitch(RPCMessage msg)
public void SetGeneratorState(bool wantsOn)
public int GetFuelAmount()
public bool HasFuel()
public bool UseFuel(float seconds)
public void TurnOn()
public void FuelConsumption()
public void TurnOff()
}
public FuseBox : IOEntity {
public void IOStateChanged(int inputAmount, int inputSlot)
}
public FXAA : FXAAPostEffectsBase {
public Shader shader
private Material mat
private void CreateMaterials()
private void Start()
public bool IsActive()
public void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public FXAAPostEffectsBase : MonoBehaviour {
protected bool supportHDRTextures
protected bool isSupported
public Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
private Material CreateMaterial(Shader s, Material m2Create)
private void OnEnable()
private bool CheckSupport()
private bool CheckResources()
private void Start()
public bool CheckSupport(bool needDepth)
private bool CheckSupport(bool needDepth, bool needHdr)
private void ReportAutoDisable()
private bool CheckShader(Shader s)
private void NotSupported()
private void DrawBorder(RenderTexture dest, Material material)
}
public GameContentList : MonoBehaviour {
public ResourceType resourceType
public List`1<Object> foundObjects
}
public GameManager : object {
public GameManager server
public PrefabPreProcess preProcessed
public PrefabPoolCollection pool
public bool Clientside
public bool Serverside
public void Reset()
public void .ctor(bool clientside, bool serverside)
public GameObject FindPrefab(UInt32 prefabID)
public GameObject FindPrefab(BaseEntity ent)
public GameObject FindPrefab(string strPrefab)
public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, Vector3 scale, bool active)
public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, bool active)
public GameObject CreatePrefab(string strPrefab, bool active)
public GameObject CreatePrefab(string strPrefab, Transform parent, bool active)
public BaseEntity CreateEntity(string strPrefab, Vector3 pos, Quaternion rot, bool startActive)
private GameObject Instantiate(string strPrefab, Vector3 pos, Quaternion rot)
public void Destroy(Component component, float delay)
public void Destroy(GameObject instance, float delay)
public void DestroyImmediate(Component component, bool allowDestroyingAssets)
public void DestroyImmediate(GameObject instance, bool allowDestroyingAssets)
public void Retire(GameObject instance)
}
public GameManifest : ScriptableObject {
internal GameManifest loadedManifest
public Dictionary`2<string, string> guidToPath
public Dictionary`2<string, string> pathToGuid
public Dictionary`2<string, Object> guidToObject
public PooledString[] pooledStrings
public PrefabProperties[] prefabProperties
public EffectCategory[] effectCategories
public GuidPath[] guidPaths
public String[] entities
public GameManifest Current
public GameManifest get_Current()
public void Load()
public void LoadAssets()
internal Dictionary`2<string, String[]> LoadEffectDictionary()
internal string GUIDToPath(string guid)
internal Object GUIDToObject(string guid)
public void Invalidate(string path)
private string GetMetadataStatus()
private string GetAssetStatus()
}
public GameModeCapturePoint : BaseEntity {
public CapturePointTrigger captureTrigger
public float timeToCapture
public int scorePerSecond
public string scoreName
private float captureFraction
private int captureTeam
private int capturingTeam
public EntityRef capturingPlayer
public EntityRef capturedPlayer
public Flags Flag_Contested
public RustText capturePointText
public RustText captureOwnerName
public Image captureProgressImage
public GameObjectRef progressBeepEffect
public GameObjectRef progressCompleteEffect
public Transform computerPoint
private float nextBeepTime
public bool IsContested()
public void ServerInit()
public void Update()
public void AssignPoints()
public void DoCaptureEffect()
public void DoProgressEffect()
public void UpdateCaptureAmount()
public void Save(SaveInfo info)
}
public GameModeHardcore : GameModeVanilla {
protected void OnCreated()
public ResearchCostResult GetScrapCostForResearch(ItemDefinition item, ResearchType researchType)
}
public GameModeManifest : ScriptableObject {
public GameModeManifest instance
public List`1<GameObjectRef> gameModePrefabs
public GameModeManifest Get()
}
public GameModeObjectToggle : BaseMonoBehaviour {
public String[] gameModeTags
public String[] tagsToDisable
public GameObject[] toToggle
public bool defaultState
public void Awake()
public void OnDestroy()
public void OnGameModeChanged(BaseGameMode newGameMode)
public void SetToggle(bool wantsOn)
public bool ShouldBeVisible(BaseGameMode newGameMode)
}
public GameModeSoftcore : GameModeVanilla {
public GameObjectRef reclaimManagerPrefab
public GameObjectRef reclaimBackpackPrefab
public Phrase ReclaimToast
public ItemAmount[] startingGear
public float reclaim_fraction_belt
public float reclaim_fraction_wear
public float reclaim_fraction_main
protected void OnCreated()
public void AddFractionOfContainer(ItemContainer from, List`1& to, float fraction, bool takeLastItem)
public List`1<Item> RemoveItemsFrom(ItemContainer itemContainer, ItemAmount[] types)
public void ReturnItemsTo(List`1& source, ItemContainer itemContainer)
public void OnPlayerDeath(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo)
public void OnPlayerRespawn(BasePlayer player)
public SleepingBag[] FindSleepingBagsForPlayer(ulong playerID, bool ignoreTimers)
public float CorpseRemovalTime(BaseCorpse corpse)
public void SetInventoryLocked(BasePlayer player, bool wantsLocked)
public void OnPlayerWounded(BasePlayer instigator, BasePlayer victim, HitInfo info)
public void OnPlayerRevived(BasePlayer instigator, BasePlayer victim)
public bool CanMoveItemsFrom(PlayerInventory inv, BaseEntity source, Item item)
}
public GameModeSpawnGroup : SpawnGroup {
public String[] gameModeTags
public void ResetSpawnGroup()
public bool ShouldSpawn()
protected void Spawn(int numToSpawn)
}
public GameObjectLOD : LODComponent {
public float Distance
public GameObject TargetGameObject
}
public GameObjectRef : ResourceRef`1<GameObject> {
public GameObject Instantiate(Transform parent)
public BaseEntity GetEntity()
}
public GameObjectTag : Enum {
public int value__
public GameObjectTag AllowBarricadePlacement
public GameObjectTag Road
public GameObjectTag BlockBarricadePlacement
}
public GameObjectToggleState : StateMachineBehaviour {
public Vector2 ValidNormalisedRange
public bool TargetState
public string GameObjectName
public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public GameObjectUtil : object {
public void GlobalBroadcast(string messageName, object param)
}
public GamePhysics : object {
public int BufferLength
private RaycastHit[] hitBuffer
private RaycastHit[] hitBufferB
private Collider[] colBuffer
public bool CheckSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckOBB(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckOBBAndEntity(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction, BaseEntity ignoreEntity)
public bool CheckBounds(Bounds bounds, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckInsideNonConvexMesh(Vector3 point, int layerMask)
public bool CheckInsideAnyCollider(Vector3 point, int layerMask)
public void OverlapSphere(Vector3 position, float radius, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool OverlapSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public void CapsuleSweep(Vector3 position0, Vector3 position1, float radius, Vector3 direction, float distance, List`1<RaycastHit> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapOBB(OBB obb, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapBounds(Bounds bounds, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void BufferToList(Collider[] buffer, int count, List`1<Collider> list)
public bool CheckSphere(Vector3 pos, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckOBB(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckBounds(Bounds bounds, int layerMask, QueryTriggerInteraction triggerInteraction)
private bool CheckComponent(List`1<Collider> list)
public void OverlapSphere(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapOBB(OBB obb, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapBounds(Bounds bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void BufferToList(Collider[] buffer, int count, List`1<T> list)
private void HitBufferToList(int count, List`1<RaycastHit> list)
public bool Trace(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction, BaseEntity ignoreEntity)
public void TraceAll(Ray ray, float radius, List`1<RaycastHit> hits, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction, BaseEntity ignoreEntity)
public void TraceAllUnordered(Ray ray, float radius, List`1<RaycastHit> hits, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction, BaseEntity ignoreEntity)
public bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity)
public bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding, BaseEntity ignoreEntity)
public bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, BaseEntity ignoreEntity)
public bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding0, float padding1, BaseEntity ignoreEntity)
public bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding, BaseEntity ignoreEntity)
public bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, BaseEntity ignoreEntity)
private bool LineOfSightInternal(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity)
public bool Verify(RaycastHit hitInfo, BaseEntity ignoreEntity)
public bool Verify(Collider collider, Vector3 point, BaseEntity ignoreEntity)
private bool CompareEntity(BaseEntity a, BaseEntity b)
public int HandleIgnoreCollision(Vector3 position, int layerMask)
public void Sort(List`1<RaycastHit> hits)
public void Sort(RaycastHit[] hits)
}
public GameSetup : MonoBehaviour {
public bool RunOnce
public bool startServer
public string clientConnectCommand
public bool loadMenu
public bool loadLevel
public string loadLevelScene
public bool loadSave
public string loadSaveFile
public string initializationCommands
public bool normalRendering
protected void Awake()
private IEnumerator DoGameSetup()
private IEnumerator StartServer()
}
public GameStat : MonoBehaviour {
public float refreshTime
public Text title
public Text globalStat
public Text localStat
private long globalValue
private long localValue
private float secondsSinceRefresh
private float secondsUntilUpdate
private float secondsUntilChange
public Stat[] stats
}
public GameTip : SingletonComponent`1<GameTip> {
public CanvasGroup canvasGroup
public RustIcon icon
public Image background
public RustText text
public Theme[] themes
}
public GameTips.BaseTip : object {
public bool ShouldShow
public string Type
public bool CanShowInTutorial
protected bool PlayerIsInTutorial
public Phrase GetPhrase()
public bool get_ShouldShow()
public string get_Type()
public bool get_CanShowInTutorial()
protected bool get_PlayerIsInTutorial()
}
public GeigerCounter : AttackEntity {
public Transform geigerRod
}
public GenerateBiome : ProceduralComponent {
public void Native_GenerateBiome(Byte[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, Int16[] heightmap, int heightres)
public void Process(UInt32 seed)
}
public GenerateCliffSplat : ProceduralComponent {
private int filter
public void Process(int x, int z)
public void Process(UInt32 seed)
}
public GenerateCliffTopology : ProceduralComponent {
public bool KeepExisting
private int filter
public void Process(int x, int z)
private void Process(int x, int z, bool keepExisting)
public void Process(UInt32 seed)
}
public GenerateClutterTopology : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateDecorTopology : ProceduralComponent {
public bool KeepExisting
public void Process(UInt32 seed)
}
public GenerateDungeonBase : ProceduralComponent {
public string EntranceFolder
public string LinkFolder
public string EndFolder
public string TransitionFolder
public InfrastructureType ConnectionType
private Vector3 VolumeExtrudePositive
private Vector3 VolumeExtrudeNegative
private int MaxCount
private int MaxDepth
private int MaxFloor
private List`1<DungeonSegment> segmentsTotal
private Quaternion[] horizontalRotations
private Quaternion[] pillarRotations
private Quaternion[] verticalRotations
public bool RunOnCache
public bool get_RunOnCache()
public void Process(UInt32 seed)
private Quaternion[] GetRotationList(DungeonBaseSocketType type)
private int GetSocketFloor(DungeonBaseSocketType type)
private bool IsFullyOccupied(List`1<DungeonSegment> segments, DungeonSegment segment)
private bool NeighbourMatches(List`1<DungeonSegment> segments, DungeonBaseTransition transition, Vector3 transitionPos, Quaternion transitionRot)
private int SocketMatches(List`1<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot)
private bool IsOccupied(List`1<DungeonSegment> segments, DungeonBaseSocket socket, Vector3 socketPos, Quaternion socketRot)
private int CountLocal(List`1<DungeonSegment> segments, DungeonBaseLink link)
private int CountGlobal(List`1<DungeonSegment> segments, DungeonBaseLink link)
private bool IsBlocked(List`1<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot)
private void PlaceSegments(UInt32& seed, int count, int budget, int floors, bool attachToFemale, bool attachToMale, List`1<DungeonSegment> segments, Prefab`1[] prefabs)
private void PlaceTransitions(UInt32& seed, List`1<DungeonSegment> segments, Prefab`1[] prefabs)
private bool Place(UInt32& seed, List`1<DungeonSegment> segments, DungeonBaseSocket targetSocket, Vector3 targetPos, Quaternion targetRot, Prefab`1<DungeonBaseLink> prefab, Quaternion[] rotations, DungeonBaseSocket& linkSocket, Vector3& linkPos, Quaternion& linkRot, Int32& linkScore)
public void SetupAI()
}
public GenerateDungeonGrid : ProceduralComponent {
public string TunnelFolder
public string StationFolder
public string UpwardsFolder
public string TransitionFolder
public string LinkFolder
public InfrastructureType ConnectionType
public int CellSize
public float LinkHeight
public float LinkRadius
public float LinkTransition
private int MaxDepth
public bool RunOnCache
public bool get_RunOnCache()
public void Process(UInt32 seed)
private float GetDistanceToAboveGroundRail(Vector3 pos)
}
public GenerateHeight : ProceduralComponent {
public void Native_GenerateHeight(Int16[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic)
public void Process(UInt32 seed)
}
public GeneratePowerlineLayout : ProceduralComponent {
private int MaxDepth
public void Process(UInt32 seed)
}
public GeneratePowerlineTopology : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateRailBranching : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private Quaternion rot90
private int MaxDepth
private PathList CreateSegment(int number, Vector3[] points)
public void Process(UInt32 seed)
}
public GenerateRailLayout : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private Quaternion rot90
private int MaxDepth
private PathList CreateSegment(int number, Vector3[] points)
public void Process(UInt32 seed)
internal float <Process>g__DistanceToRail|13_0(Vector3 vec)
}
public GenerateRailMeshes : ProceduralComponent {
public float NormalSmoothing
public bool SnapToTerrain
public Mesh RailMesh
public Mesh[] RailMeshes
public Material RailMaterial
public PhysicMaterial RailPhysicMaterial
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
private void AddTrackSpline(PathList rail)
}
public GenerateRailRing : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private int MaxDepth
public int MinWorldSize
public void Process(UInt32 seed)
}
public GenerateRailSiding : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private Quaternion rotRight
private Quaternion rotLeft
private int MaxDepth
private PathList CreateSegment(int number, Vector3[] points)
public void Process(UInt32 seed)
}
public GenerateRailTerrain : ProceduralComponent {
public int SmoothenLoops
public int SmoothenIterations
public int SmoothenY
public int SmoothenXZ
public int TransitionSteps
public void Process(UInt32 seed)
}
public GenerateRailTexture : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateRailTopology : ProceduralComponent {
public void Process(UInt32 seed)
private void MarkRailside()
}
public GenerateRiverLayout : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
public void Process(UInt32 seed)
}
public GenerateRiverMeshes : ProceduralComponent {
public float NormalSmoothing
public bool SnapToTerrain
public Mesh RiverMesh
public Mesh[] RiverMeshes
public Material RiverMaterial
public PhysicMaterial RiverPhysicMaterial
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateRiverTerrain : ProceduralComponent {
public int SmoothenLoops
public int SmoothenIterations
public int SmoothenY
public int SmoothenXZ
public void Process(UInt32 seed)
}
public GenerateRiverTexture : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateRiverTopology : ProceduralComponent {
public void Process(UInt32 seed)
public void MarkRiverside()
}
public GenerateRoadLayout : ProceduralComponent {
public InfrastructureType RoadType
public float RoadWidth
public float TrailWidth
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private int MaxDepth
private PathList CreateSegment(int number, Vector3[] points)
public void Process(UInt32 seed)
}
public GenerateRoadMeshes : ProceduralComponent {
public float NormalSmoothing
public bool SnapToTerrain
public Mesh RoadMesh
public Mesh[] RoadMeshes
public Material RoadMaterial
public Material RoadRingMaterial
public PhysicMaterial RoadPhysicMaterial
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateRoadRing : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private int MaxDepth
public int MinWorldSize
public void Process(UInt32 seed)
}
public GenerateRoadTerrain : ProceduralComponent {
public int SmoothenLoops
public int SmoothenIterations
public int SmoothenY
public int SmoothenXZ
public void Process(UInt32 seed)
}
public GenerateRoadTexture : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateRoadTopology : ProceduralComponent {
public void Process(UInt32 seed)
private void MarkRoadside()
}
public GenerateSplat : ProceduralComponent {
public void Native_GenerateSplat(Byte[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle, Int16[] heightmap, int heightres, Byte[] biomemap, int biomeres, Int32[] topologymap, int topologyres)
public void Process(UInt32 seed)
}
public GenerateTerrainMesh : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateTextures : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateTopology : ProceduralComponent {
public void Native_GenerateTopology(Int32[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, Int16[] heightmap, int heightres, Byte[] biomemap, int biomeres)
public void Process(UInt32 seed)
}
public GenerateWireMeshes : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenericSpawnPoint : BaseSpawnPoint {
public bool dropToGround
public bool randomRot
public float randomRotSnapDegrees
public GameObjectRef spawnEffect
public UnityEvent OnObjectSpawnedEvent
public UnityEvent OnObjectRetiredEvent
public Quaternion GetRandomRotation()
public void GetLocation(Vector3& pos, Quaternion& rot)
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
}
public GestureCollection : ScriptableObject {
public UInt32 HeavyLandingId
public GestureConfig[] AllGestures
public float GestureVmInDuration
public AnimationCurve GestureInCurve
public float GestureVmOutDuration
public AnimationCurve GestureOutCurve
public float GestureViewmodelDeployDelay
public GestureConfig IdToGesture(UInt32 id)
public GestureConfig StringToGesture(string gestureName)
}
public GestureConfig : ScriptableObject {
public UInt32 gestureId
public string gestureCommand
public string convarName
public Phrase gestureName
public Phrase gestureDescription
public Sprite icon
public int order
public float duration
public bool canCancel
public PlayerModelLayer playerModelLayer
public GestureType gestureType
public bool hideHeldEntity
public bool canDuckDuringGesture
public bool hideInWheel
public bool hasViewmodelAnimation
public float viewmodelHolsterDelay
public MovementCapabilities movementMode
public AnimationType animationType
public CameraMode viewMode
public bool useRootMotion
public bool forceForwardRotation
public GestureActionType actionType
public bool forceUnlock
public SteamDLCItem dlcItem
public SteamInventoryItem inventoryItem
public bool IsOwnedBy(BasePlayer player)
public bool CanBeUsedBy(BasePlayer player)
}
public GestureDoor : Door {
public GestureConfig OpenGesture
public GestureConfig KickGesture
public float KickAnimationDelay
public float PushAnimationDelay
public float WeaponAdditiveDelay
private bool wasKick
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected void OnPlayerOpenedDoor(BasePlayer p)
protected bool ShouldDelayOpen(BasePlayer player, Single& delay)
private void ServerKick(RPCMessage msg)
}
public GhostSheetSystemSpaceUpdater : MonoBehaviour {
private EZSoftBone[] ezSoftBones
private BasePlayer player
public void Awake()
public void Update()
private void SetSimulateSpace(Transform transform, bool collisionEnabled)
}
public Gib : ListComponent`1<Gib> {
public int gibCount
public MeshFilter _meshFilter
public MeshRenderer _meshRenderer
public MeshCollider _meshCollider
public BoxCollider _boxCollider
public SphereCollider _sphereCollider
public CapsuleCollider _capsuleCollider
public Rigidbody _rigidbody
public string GetEffect(PhysicMaterial physicMaterial)
}
public Gibbable : PrefabAttribute {
public GameObject gibSource
public Material[] customMaterials
public GameObject materialSource
public bool copyMaterialBlock
public bool applyDamageTexture
public PhysicMaterial physicsMaterial
public GameObjectRef fxPrefab
public bool spawnFxPrefab
public bool important
public bool useContinuousCollision
public float explodeScale
public float scaleOverride
public int uniqueId
public BoundsEffectType boundsEffectType
public bool isConditional
public Bounds effectBounds
public List`1<OverrideMesh> MeshOverrides
public bool UsePerGibWaterCheck
protected Type GetIndexedType()
}
public GingerbreadBrain : BaseAIBrain {
public void AddStates()
public void InitializeAI()
public void OnDestroy()
}
public GingerbreadNPC : HumanNPC {
public GameObjectRef OverrideCorpseMale
public GameObjectRef OverrideCorpseFemale
public PhysicMaterial HitMaterial
public bool RoamAroundHomePoint
protected string CorpseResourcePath
public void OnAttacked(HitInfo info)
public string Categorize()
public bool ShouldDropActiveItem()
public BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List`1<TriggerBase> triggersOnDeath)
public void AttackerInfo(DeathInfo info)
protected string get_CorpseResourcePath()
public void OnClientStateChanged(AIState state)
internal float <get_CorpseResourcePath>g__GetFloatBasedOnUserID|10_0(ulong steamid, ulong seed)
}
public GizmosUtil : object {
public void DrawWireCircleX(Vector3 pos, float radius)
public void DrawWireCircleY(Vector3 pos, float radius)
public void DrawWireCircleZ(Vector3 pos, float radius)
public void DrawCircleX(Vector3 pos, float radius)
public void DrawCircleY(Vector3 pos, float radius)
public void DrawCircleZ(Vector3 pos, float radius)
public void DrawWireCylinderX(Vector3 pos, float radius, float height)
public void DrawWireCylinderY(Vector3 pos, float radius, float height)
public void DrawWireCylinderZ(Vector3 pos, float radius, float height)
public void DrawCylinderX(Vector3 pos, float radius, float height)
public void DrawCylinderY(Vector3 pos, float radius, float height)
public void DrawCylinderZ(Vector3 pos, float radius, float height)
public void DrawWireCapsuleX(Vector3 pos, float radius, float height)
public void DrawWireCapsuleY(Vector3 pos, float radius, float height)
public void DrawWireCapsuleZ(Vector3 pos, float radius, float height)
public void DrawCapsuleX(Vector3 pos, float radius, float height)
public void DrawCapsuleY(Vector3 pos, float radius, float height)
public void DrawCapsuleZ(Vector3 pos, float radius, float height)
public void DrawWireCube(Vector3 pos, Vector3 size, Quaternion rot)
public void DrawCube(Vector3 pos, Vector3 size, Quaternion rot)
public void DrawWirePath(Vector3 a, Vector3 b, float thickness)
public void DrawSemiCircle(float radius)
public void DrawArrowHead(Vector3 pos, Vector3 dir, float arrowHeadLength, float arrowHeadAngle)
public void DrawMeshes(Transform transform)
public void DrawBounds(Transform transform)
}
public GlassPane : BaseMonoBehaviour {
public Renderer glassRendereer
private BaseVehicleModule module
private float showFullDamageAt
}
public GlobalNetworkHandler : PointEntity {
public GlobalNetworkHandler server
public Dictionary`2<NetworkableId, GlobalEntityData> serverData
private List`1<Connection> globalConnections
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool ShouldSendEntity(BaseEntity entity)
public void ServerInit()
public void PostServerLoad()
public void OnClientConnected(Connection connection)
public void OnClientDisconnected(Connection connection)
private void LoadEntitiesOnStartup()
public void TrySendNetworkUpdate(BaseNetworkable net)
private void OnEntityUpdate(BaseEntity entity, bool sendNetworkUpdate)
public void OnEntityKilled(BaseNetworkable entity)
public void StartSendingSnapshot(BasePlayer player)
private void SendSnapshot(BasePlayer player)
private void SendEntityDelete(NetworkableId networkableId, SendInfo info)
private void SendGlobalEntities(GlobalEntityCollection entities, SendInfo info)
private void SendGlobalEntity(GlobalEntityData entity, SendInfo info)
}
public GodRays : PostProcessEffectSettings {
public BoolParameter UseDepth
public BlendModeTypeParameter BlendMode
public FloatParameter Intensity
public ResolutionTypeParameter Resolution
public IntParameter BlurIterations
public FloatParameter BlurRadius
public FloatParameter MaxRadius
}
public GodRaysRenderer : PostProcessEffectRenderer`1<GodRays> {
private int PASS_SCREEN
private int PASS_ADD
public Shader GodRayShader
public Shader ScreenClearShader
public Shader SkyMaskShader
public void Init()
private void DrawBorder(PostProcessRenderContext context, RenderTargetIdentifier buffer1)
private int GetSkyMask(PostProcessRenderContext context, ResolutionType resolution, Vector3 lightPos, int blurIterations, float blurRadius, float maxRadius)
public void Render(PostProcessRenderContext context)
}
public GranularAudioClip : MonoBehaviour {
public AudioClip sourceClip
private Single[] sourceAudioData
private int sourceChannels
public AudioClip granularClip
public int sampleRate
public float sourceTime
public float sourceTimeVariation
public float grainAttack
public float grainSustain
public float grainRelease
public float grainFrequency
public int grainAttackSamples
public int grainSustainSamples
public int grainReleaseSamples
public int grainFrequencySamples
public int samplesUntilNextGrain
public List`1<Grain> grains
private Random random
private bool inited
private void Update()
private void RefreshCachedData()
private void InitAudioClip()
private void OnAudioRead(Single[] data)
private void SpawnGrain()
private void CleanupFinishedGrains()
}
public Graph : MonoBehaviour {
public Material Material
public int Resolution
public Vector2 ScreenFill
public Vector2 ScreenOrigin
public Vector2 Pivot
public Rect Area
internal float CurrentValue
private int index
private Single[] values
private float max
protected float GetValue()
protected Color GetColor(float value)
protected Vector3 GetVertex(float x, float y)
protected void Update()
protected void OnGUI()
}
public GraveyardFence : SimpleBuildingBlock {
public BoxCollider[] pillars
public void ServerInit()
public void DestroyShared()
public void UpdatePillars()
}
public GreyScale : PostProcessEffectSettings {
public FloatParameter redLuminance
public FloatParameter greenLuminance
public FloatParameter blueLuminance
public FloatParameter amount
public ColorParameter color
}
public GreyScaleRenderer : PostProcessEffectRenderer`1<GreyScale> {
private int dataProperty
private int colorProperty
private Shader greyScaleShader
public void Init()
public void Render(PostProcessRenderContext context)
}
public GridLayoutGroupNeat : GridLayoutGroup {
private float IdealCellWidth(float cellSize)
public void SetLayoutHorizontal()
public void SetLayoutVertical()
}
public GroundVehicle : BaseVehicle {
protected GroundVehicleAudio gvAudio
private GameObjectRef fuelStoragePrefab
public Transform waterloggedPoint
public GameObjectRef collisionEffect
public float engineStartupTime
private float minCollisionDamageForce
private float maxCollisionDamageForce
private float collisionDamageMultiplier
private Rigidbody secondaryRigidbody
private Vector3 <Velocity>k__BackingField
public VehicleEngineController`1<GroundVehicle> engineController
private Dictionary`2<BaseEntity, float> damageSinceLastTick
private float nextCollisionDamageTime
private float dragMod
private float dragModDuration
private TimeSince timeSinceDragModSet
public Vector3 Velocity
public float DriveWheelVelocity
public bool LightsAreOn
public EngineState<GroundVehicle> CurEngineState
public Vector3 get_Velocity()
private void set_Velocity(Vector3 value)
public float get_DriveWheelVelocity()
public bool get_LightsAreOn()
public EngineState<GroundVehicle> get_CurEngineState()
public void InitShared()
public void OnFlagsChanged(Flags old, Flags next)
public float GetSpeed()
public float GetMaxForwardSpeed()
public float GetThrottleInput()
public float GetBrakeInput()
protected bool CanPushNow(BasePlayer pusher)
protected IFuelSystem CreateFuelSystem()
public void ServerInit()
public void OnEngineStartFailed()
public bool MeetsEngineRequirements()
protected void ServerFlagsChanged(Flags old, Flags next)
protected void OnCollisionEnter(Collision collision)
public void VehicleFixedUpdate()
public void LightToggle(BasePlayer player)
public float GetDamageMultiplier(BaseEntity ent)
public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
private float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude)
protected void DoCollisionDamage(BaseEntity hitEntity, float damage)
protected void ProcessCollision(Collision collision, Rigidbody ourRigidbody)
public float GetModifiedDrag()
public IFuelSystem GetFuelSystem()
protected void OnChildAdded(BaseEntity child)
private void SetTempDrag(float drag, float duration)
private void IEngineControllerUser.Invoke(Action action, float time)
private void IEngineControllerUser.CancelInvoke(Action action)
}
public GroundVehicleAudio : MonoBehaviour {
protected GroundVehicle groundVehicle
private SoundDefinition engineStartSound
private SoundDefinition engineStopSound
private SoundDefinition engineStartFailSound
private BlendedLoopEngineSound blendedEngineLoops
private float wheelRatioMultiplier
private float overallVolume
private SoundDefinition waterSplashSoundDef
private BlendedSoundLoops waterLoops
private float waterSoundsMaxSpeed
private SoundDefinition brakeSoundDef
private SoundDefinition brakeStartSoundDef
private SoundDefinition brakeStopSoundDef
private SoundDefinition lightsToggleSound
}
public GroundWatch : BaseMonoBehaviour {
public Vector3 groundPosition
public LayerMask layers
public float radius
public BaseEntity[] whitelist
public int fails
private void OnDrawGizmosSelected()
public void PhysicsChanged(GameObject obj)
public void PhysicsChanged(Vector3 origin, float radius, int layerMask)
public void OnPhysicsNeighbourChanged()
public bool OnGround()
}
public GrowableEntity : BaseCombatEntity {
public PlantProperties Properties
public ItemDefinition SourceItemDef
private State <State>k__BackingField
private float <Age>k__BackingField
private float <LightQuality>k__BackingField
private float <GroundQuality>k__BackingField
private float <WaterQuality>k__BackingField
private float <WaterConsumption>k__BackingField
private bool <Fertilized>k__BackingField
private float <TemperatureQuality>k__BackingField
private float <OverallQuality>k__BackingField
private float <Yield>k__BackingField
public float stageAge
public GrowableGenes Genes
public float startingHealth
public float artificalLightQuality
public float planterGroundModifierBase
public float fertilizerGroundModifierBonus
public float growthGeneSpeedMultiplier
public float waterGeneRequirementMultiplier
public float hardinessGeneModifierBonus
public float hardinessGeneTemperatureModifierBonus
public float baseYieldIncreaseMultiplier
public float yieldGeneBonusMultiplier
public float maxNonPlanterGroundQuality
public float deathRatePerQuality
public TimeCachedValue`1<float> sunExposure
public TimeCachedValue`1<float> artificialLightExposure
public TimeCachedValue`1<float> artificialTemperatureExposure
public float framebudgetms
public GrowableEntityUpdateQueue growableEntityUpdateQueue
public bool underWater
public int seasons
public int harvests
public float terrainTypeValue
public float yieldPool
public PlanterBox planter
public State State
public float Age
public float LightQuality
public float GroundQuality
public float WaterQuality
public float WaterConsumption
public bool Fertilized
public float TemperatureQuality
public float OverallQuality
public float Yield
public float StageProgressFraction
public Stage currentStage
public float ThinkDeltaTime
public float growDeltaTime
public int CurrentPickAmount
public float CurrentPickAmountFloat
public float CurrentTemperature
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public State get_State()
public void set_State(State value)
public float get_Age()
public void set_Age(float value)
public float get_LightQuality()
public void set_LightQuality(float value)
public float get_GroundQuality()
public void set_GroundQuality(float value)
public float get_WaterQuality()
public void set_WaterQuality(float value)
public float get_WaterConsumption()
public void set_WaterConsumption(float value)
public bool get_Fertilized()
public void set_Fertilized(bool value)
public float get_TemperatureQuality()
public void set_TemperatureQuality(float value)
public float get_OverallQuality()
public void set_OverallQuality(float value)
public float get_Yield()
public void set_Yield(float value)
public float get_StageProgressFraction()
public Stage get_currentStage()
public float get_ThinkDeltaTime()
public float get_growDeltaTime()
public void ReceiveInstanceData(InstanceData data)
public void ResetState()
public bool CanPick()
public int get_CurrentPickAmount()
public float get_CurrentPickAmountFloat()
public bool CanTakeSeeds()
public bool CanClone()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ChangeState(State state, bool resetAge, bool loading)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public void QueueForQualityUpdate()
public void CalculateQualities(bool firstTime, bool forceArtificialLightUpdates, bool forceArtificialTemperatureUpdates)
private void CalculateQualities_Water()
public void CalculateLightQuality(bool forceArtificalUpdate)
public float CalculateSunExposure(bool force)
public float SunRaycast()
public float GetArtificialLightExposure(bool force)
public float CalculateArtificialLightExposure()
public float CalculateArtificialLightExposure(Transform forTransform)
public float SunRaycast(Vector3 checkPosition)
public void CalculateWaterQuality()
public void CalculateGroundQuality(bool firstCheck)
public float GetGroundTypeValue(Vector3 pos)
public void CalculateTemperatureQuality()
public float CalculateOverallQuality()
public void CalculateWaterConsumption()
public float CalculateArtificialTemperature()
public float CalculateArtificialTemperature(Transform forTransform)
public int CalculateMarketValue()
private float RemapValue(float inValue, float minA, float maxA, float minB, float maxB)
public bool IsFood()
public float get_CurrentTemperature()
public void ServerInit()
public PlanterBox GetPlanter()
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
public void PostServerLoad()
public void ResetSeason()
public void RunUpdate()
public float UpdateAge(float overallQuality)
public void UpdateHealthAndYield(float overallQuality, float actualStageAgeIncrease)
public void ApplyDeathRate()
public float GetGrowthBonus(float overallQuality)
public State UpdateState()
public void ConsumeWater()
public void Fertilize()
public void RPC_TakeClone(RPCMessage msg)
public void RPC_TakeCloneAll(RPCMessage msg)
public void TakeClones(BasePlayer player)
public void PickFruit(BasePlayer player, bool eat)
public void GiveFruit(BasePlayer player, int amount, bool eat)
public void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)
public void RPC_PickFruit(RPCMessage msg)
public void RPC_EatFruit(RPCMessage msg)
public void RPC_PickFruitAll(RPCMessage msg)
public void RPC_RemoveDying(RPCMessage msg)
public void RPC_RemoveDyingAll(RPCMessage msg)
public void RemoveDying(BasePlayer receiver)
public void GrowAll(Arg arg)
private void RPC_RequestQualityUpdate(RPCMessage msg)
}
public GrowableGene : object {
private GeneType <Type>k__BackingField
private GeneType <PreviousType>k__BackingField
public GeneType Type
public GeneType PreviousType
public GeneType get_Type()
private void set_Type(GeneType value)
public GeneType get_PreviousType()
private void set_PreviousType(GeneType value)
public void Set(GeneType geneType, bool firstSet)
public void SetPrevious(GeneType type)
public string GetDisplayCharacter()
public string GetDisplayCharacter(GeneType type)
public string GetColourCodedDisplayCharacter()
public string GetColourCodedDisplayCharacter(GeneType type)
public bool IsPositive(GeneType type)
public bool IsPositive()
}
public GrowableGeneEncoding : object {
public void EncodeGenesToItem(GrowableEntity sourceGrowable, Item targetItem)
public void EncodeGenesToItem(int genes, Item targetItem)
public int EncodeGenesToInt(GrowableGenes genes)
public int EncodePreviousGenesToInt(GrowableGenes genes)
public void DecodeIntToGenes(int data, GrowableGenes genes)
public void DecodeIntToPreviousGenes(int data, GrowableGenes genes)
public string DecodeIntToGeneString(int data)
private int Set(int storage, int slot, int value)
private int Get(int storage, int slot)
}
public GrowableGeneProperties : ScriptableObject {
public GeneWeight[] Weights
}
public GrowableGenes : object {
public GrowableGene[] Genes
private GeneWeighting[] baseWeights
private GeneWeighting[] slotWeights
private void Clear()
public void GenerateRandom(GrowableEntity growable)
private void CalculateBaseWeights(GrowableGeneProperties properties)
private void CalculateSlotWeights(GrowableGeneProperties properties, int slot)
private GeneType PickWeightedGeneType()
public int GetGeneTypeCount(GeneType geneType)
public int GetPositiveGeneCount()
public int GetNegativeGeneCount()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void DebugPrint()
private string GetDisplayString(bool previousGenes)
}
public GrowableGenetics : object {
public int GeneSlotCount
public float CrossBreedingRadius
private GeneWeighting[] neighbourWeights
private GeneWeighting dominant
public void CrossBreed(GrowableEntity growable)
private GeneWeighting GetDominantGeneWeighting(GrowableEntity crossBreedingGrowable, List`1<GrowableEntity> neighbours, int slot)
}
public GrowableHeatSource : EntityComponent`1<BaseEntity> {
public float heatAmount
public AnimationCurve HeatFalloff
public float ApplyHeat(Vector3 forPosition)
public void ForceUpdateGrowablesInRange()
}
public GunModInformationPanel : ItemInformationPanel {
public ItemTextValue fireRateDisplay
public ItemTextValue velocityDisplay
public ItemTextValue damageDisplay
public ItemTextValue accuracyDisplay
public ItemTextValue recoilDisplay
public ItemTextValue zoomDisplay
public ItemTextValue ammoDisplay
}
public GunTrap : StorageContainer {
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public GameObjectRef triggeredEffect
public Transform muzzlePos
public Transform eyeTransform
public int numPellets
public int aimCone
public float sensorRadius
public ItemDefinition ammoType
public TargetTrigger trigger
private float triggerCooldown
private BuildingPrivlidge _cachedTc
private float _cacheTimeout
public float gun_trap_budget_ms
public GunTrapScanWorkQueue updateGunTrapWorkQueue
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public string Categorize()
public bool UseAmmo()
public void FireWeapon()
public void FireBullet()
public void ServerInit()
internal void DoServerDestroy()
public void TriggerCheck()
private BuildingPrivlidge GetCachedTc()
public bool CheckTrigger()
public bool IsTriggered()
public Vector3 GetEyePosition()
}
public HackableLockedCrate : LootContainer {
public Flags Flag_Hacking
public Flags Flag_FullyHacked
public Text timerText
public float requiredHackSeconds
public float decaySeconds
public SoundPlayer hackProgressBeep
public float hackSeconds
public GameObjectRef shockEffect
public GameObjectRef mapMarkerEntityPrefab
public GameObjectRef landEffect
public bool shouldDecay
public BasePlayer originalHackerPlayer
public ulong originalHackerPlayerId
public bool hasBeenOpened
public BaseEntity mapMarkerInstance
public bool hasLanded
public bool wasDropped
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsBeingHacked()
public bool IsFullyHacked()
public void DestroyShared()
public void CreateMapMarker(float durationMinutes)
public void RefreshDecay()
public void DelayedDestroy()
public void OnAttacked(HitInfo info)
public void SetWasDropped()
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
public void LandCheck()
public void PostServerLoad()
public void RPC_Hack(RPCMessage msg)
public void StartHacking()
public void HackProgress()
public bool OnStartBeingLooted(BasePlayer player)
}
public HairCapMask : Enum {
public int value__
public HairCapMask Head
public HairCapMask Eyebrow
public HairCapMask Facial
public HairCapMask Armpit
public HairCapMask Pubic
}
public HairDye : object {
public Color capBaseColor
public Material sourceMaterial
public CopyPropertyMask copyProperties
private MaterialPropertyDesc[] transferableProps
public int _HairBaseColorUV1
public int _HairBaseColorUV2
public int _HairPackedMapUV1
public int _HairPackedMapUV2
public void Apply(HairDyeCollection collection, MaterialPropertyBlock block)
public void ApplyCap(HairDyeCollection collection, HairType type, MaterialPropertyBlock block)
}
public HairDyeCollection : ScriptableObject {
public Texture capMask
public bool applyCap
public HairDye[] Variations
public HairDye Get(float seed)
}
public HairSet : ScriptableObject {
public MeshReplace[] MeshReplacements
public void Process(PlayerModelHair playerModelHair, HairDyeCollection dyeCollection, HairDye dye, MaterialPropertyBlock block)
public void ProcessMorphs(GameObject obj, int blendShapeIndex)
}
public HairSetCollection : ScriptableObject {
public HairSetEntry[] Head
public HairSetEntry[] Eyebrow
public HairSetEntry[] Facial
public HairSetEntry[] Armpit
public HairSetEntry[] Pubic
public HairSetEntry[] GetListByType(HairType hairType)
public int GetIndex(HairSetEntry[] list, float typeNum)
public int GetIndex(HairType hairType, float typeNum)
public HairSetEntry Get(HairType hairType, float typeNum)
}
public HairType : Enum {
public int value__
public HairType Head
public HairType Eyebrow
public HairType Facial
public HairType Armpit
public HairType Pubic
public HairType Count
}
public Half3 : ValueType {
public ushort x
public ushort y
public ushort z
public void .ctor(Vector3 vec)
public Vector3 op_Explicit(Half3 vec)
}
public Half4 : ValueType {
public ushort x
public ushort y
public ushort z
public ushort w
public void .ctor(Vector4 vec)
public Vector4 op_Explicit(Half4 vec)
}
public HalloweenDungeon : BasePortal {
public GameObjectRef dungeonPrefab
public EntityRef`1<ProceduralDynamicDungeon> dungeonInstance
public float population
public float lifetime
private float secondsUsed
private float timeAlive
public AnimationCurve radiationCurve
public Phrase collapsePhrase
public Phrase mountPhrase
private bool anyplayers_cached
private float nextPlayerCheckTime
public float GetLifetime()
public void Load(LoadInfo info)
public float GetLifeFraction()
public void Update()
public void KillIfNoPlayers()
public bool AnyPlayersInside()
private void ClearAllEntitiesInRadius(float radius)
public void Save(SaveInfo info)
public void PostServerLoad()
public void UsePortal(BasePlayer player)
public void Spawn()
public void ServerInit()
public void CheckBlocked()
public Vector3 GetDungeonSpawnPoint()
internal void DoServerDestroy()
public void DelayedDestroy()
public void SpawnSubEntities()
}
public HalloweenHunt : EggHuntEvent {
public Phrase topCreepPhrase
public Phrase placeCreepPhrase
protected Phrase GetTopBunnyPhrase()
protected Phrase GetPlacePhrase()
protected void ReportPlayerParticipated(int topCount)
protected void ReportEggsCollected(int numEggs)
}
public Hammer : BaseMelee {
public bool CanHit(HitTest info)
public void DoAttackShared(HitInfo info)
}
public Handcuffs : BaseMelee {
public int PrisonerHoodItemID
public float restrainedPushDamage
public float maxConditionRepairLossOnPush
public AnimatorOverrideController CaptiveHoldAnimationOverride
public GameObjectRef lockEffect
public GameObjectRef escapeEffect
public bool BlockInventory
public bool BlockSuicide
public bool BlockUse
public bool BlockCrafting
public float UnlockMiniGameDuration
public float UseDistance
public float ConditionLossPerSecond
private float unlockStartTime
private float startCondition
public bool Locked
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_Locked()
public void Load(LoadInfo info)
private void SetWMLocked(bool flag)
private void StartUnlockMiniGame()
public void HeldWhenOwnerDied(BasePlayer player)
public void SetLocked(bool flag, BasePlayer player, Item handcuffsItem)
public void togglecuffslocked(Arg args)
private void ModifyConditionForElapsedTime(float elapsed)
public void RepairOnPush()
public void InterruptUnlockMiniGame(bool wasPushedOrDamaged)
private void RPC_ReqStartUnlockMiniGame(RPCMessage rpc)
private void SV_StartUnlockMiniGame(BasePlayer player)
private void RPC_ReqCancelUnlockMiniGame(RPCMessage rpc)
private void SV_CancelUnlockMiniGame(BasePlayer player)
private void RPC_ReqCompleteUnlockMiniGame(RPCMessage rpc)
private void SV_ReqCompleteUnlockMiniGame(BasePlayer player)
private void RPC_ReqLock(RPCMessage rpc)
private void SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer)
public void UnlockAndReturnToPlayer(BasePlayer returnToPlayer)
public bool CanHit(HitTest info)
public void DoAttackShared(HitInfo info)
}
public HandcuffsViewModel : BaseViewModel {
public SkinnedMeshRenderer handcuffsRenderer
}
public HarborBridgeSounds : MonoBehaviour {
public HarborProximityEntity bridge
public SoundDefinition rootRotationLoopDef
public SoundDefinition rootRotationStartDef
public SoundDefinition rootRotationStopDef
}
public HarborCrane : HarborProximityEntity {
public Transform CraneGrab
public Transform ArmRoot
public TransformLineRenderer[] LineRenderers
}
public HarborCraneContainerPickup : HarborCrane {
public Transform ServerTowerGrab
public float LockTime
public float MaxMoveDistance
public float PickedUpObjectRotationSpeed
private List`1<ContainerStack> Stacks
public GameObjectRef ContainerPrefab
private float ContainerSize
public int MaxContainerStackSize
public bool DebugContainerSpawns
public bool DebugContainerDestinations
private Vector3 grabOffset
public ListHashSet`1<HarborCraneContainerPickup> AllCranes
private Vector3 startForward
private List`1<QueuedMove> movesToMake
private Nullable`1<QueuedMove> moveInProcess
private EntityRef`1<CargoShip> toParent
private float moveDelay
private PickupState currentPickupState
private float lockOnTime
private float maxTargetHeight
public void ServerInit()
public void PostMapEntitySpawn()
internal void DoServerDestroy()
private void FindNearbyContainerSpawns(List`1<HarborCraneContainerSpawnPoint> foundPoints)
private void ReplenishContainers(int totalContainers)
public void Save(SaveInfo info)
private QueuedMove CreateMove(QueuedMove from)
private void CreateMove(QueuedMove move, QueuedMove target)
private void CountdownDelay()
private void CheckMoveQueue()
private void ProcessCraneMovement()
public void ReplenishContainers()
public void AssignDestination(List`1<Transform> destinations, CargoShip targetShip, float delay)
public bool IsDestinationValidForCrane(CargoShipContainerDestination destination)
public void Load(LoadInfo info)
private void UpdateArm()
private bool <ReplenishContainers>g__SpawnContainerOnStack|23_0(ContainerStack stack)
}
public HarborCraneContainerSpawnPoint : MonoBehaviour {
public int MaxStackSize
}
public HarborCraneSounds : MonoBehaviour {
public HarborCrane crane
public SoundDefinition rootRotationLoopDef
public SoundDefinition rootRotationStartDef
public SoundDefinition rootRotationStopDef
public SoundDefinition armRotationLoopDef
public SoundDefinition armRotationStartDef
public SoundDefinition armRotationStopDef
public Transform grabSoundPosition
public SoundDefinition grabMoveLoopDef
public SoundDefinition grabMoveStartDef
public SoundDefinition grabMoveStopDef
}
public HarborCraneStatic : HarborCrane {
public float StartingDepth
public float StartingHeight
public float StartingAngle
public Transform HangingLadder
public void PostMapEntitySpawn()
public void Save(SaveInfo info)
private void SetArmPos(float angle, float height, float depth)
public void Load(LoadInfo info)
}
public HarborProximityEntity : BaseEntity {
private ListHashSet`1<HarborProximityEntity> harborEntities
public void ServerInit()
internal void DoServerDestroy()
public HarborProximityEntity GetEntity(Vector3 worldPos)
}
public HarborProximityManager : MonoBehaviour {
public MoveToMake[] Moves
public bool DebugCargo
public float DebugVisPoint
private float localNormalisedState
public void StartMovement()
public void UpdateNormalisedState(float f)
public void EndMovement()
private void Apply(float f)
}
public HBHFConfig : UIDialog {
public RustButton authButton
public RustButton nonAuthButton
}
public HBHFSensor : BaseDetector {
public GameObjectRef detectUp
public GameObjectRef detectDown
public GameObjectRef panelPrefab
public Flags Flag_IncludeOthers
public Flags Flag_IncludeAuthed
private int detectedPlayers
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetPassthroughAmount(int outputSlot)
public void OnObjects()
public void OnEmpty()
public void UpdatePassthroughAmount()
public void SetConfig(RPCMessage msg)
public bool CanUse(BasePlayer player)
public bool ShouldIncludeAuthorized()
public bool ShouldIncludeOthers()
}
public HeadDispenser : EntityComponent`1<BaseEntity> {
public ItemDefinition HeadDef
public GameObjectRef SourceEntity
private bool hasDispensed
private BaseEntity <overrideEntity>k__BackingField
public BaseEntity overrideEntity
public BaseEntity get_overrideEntity()
public void set_overrideEntity(BaseEntity value)
public void DispenseHead(HitInfo info, BaseCorpse corpse)
}
public HeadEntity : BaseEntity {
public HeadData CurrentTrophyData
private OccupationSlots HeadMask
public void Save(SaveInfo info)
public void SetupSourceId(UInt32 sourceID)
public void SetupPlayerId(string playerName, ulong playerId)
public void AssignClothing(ItemContainer container)
public void AssignHorseBreed(int breed)
private void InitTrophyData()
public void Load(LoadInfo info)
public GameObject GetHeadSource()
}
public HeadInformationPanel : ItemInformationPanel {
public ItemDefinition HeadInfo
public GameObject PlayerRoot
public GameObject NPCRoot
public GameObject HorseRoot
public Image NPCImage
public Text NPCText
public Text PlayerNameText
public Text PlayerIdText
public Text HorseBreedText
}
public HealthBelowAIEvent : BaseAIEvent {
private float <HealthFraction>k__BackingField
private BaseCombatEntity combatEntity
public float HealthFraction
public float get_HealthFraction()
public void set_HealthFraction(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public HeldBoomBox : HeldEntity {
public BoomBox BoxController
public SwapKeycard cassetteSwapper
public BaseEntity ToBaseEntity
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public BaseEntity get_ToBaseEntity()
public void ServerInit()
public void ServerTogglePlay(RPCMessage msg)
private void Server_UpdateRadioIP(RPCMessage msg)
public void Save(SaveInfo info)
public void OnCassetteInserted(Cassette c)
public void OnCassetteRemoved(Cassette c)
public bool ClearRadioByUserId(ulong id)
public void HurtCallback(float amount)
public void OnHeldChanged()
public void Load(LoadInfo info)
}
public HeldEntity : BaseEntity {
public Animator worldModelAnimator
public SoundDefinition thirdPersonDeploySound
public SoundDefinition thirdPersonAimSound
public SoundDefinition thirdPersonAimEndSound
public Flags Flag_ForceVisible
public string handBone
public AnimatorOverrideController HoldAnimationOverride
public bool isBuildingTool
public float hostileScore
public HolsterInfo holsterInfo
public CameraMode HeldCameraMode
public Vector3 FirstPersonArmOffset
public Vector3 FirstPersonArmRotation
public float FirstPersonRotationStrength
public bool holsterVisible
public bool genericVisible
private heldEntityVisState currentVisState
private TimeSince lastHeldEvent
public ItemId ownerItemUID
private Item cachedItem
public bool hostile
public Transform MuzzleTransform
public ItemModWearable WearableWhileEquipped
public bool IsUsableByTurret
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_hostile()
public Transform get_MuzzleTransform()
public bool LightsOn()
public bool IsDeployed()
public BasePlayer GetOwnerPlayer()
public Connection GetOwnerConnection()
public ItemModWearable get_WearableWhileEquipped()
public void SetOwnerPlayer(BasePlayer player)
public void ClearOwnerPlayer()
public void SetVisibleWhileHolstered(bool visible)
public void SetGenericVisible(bool wantsVis)
public UInt32 GetBone(string bone)
public void SetLightsOn(bool isOn)
public void UpdateHeldItemVisibility()
public bool UpdateVisibility_Hand()
public bool UpdateVisibility_GenericVis()
public bool UpdateVisiblity_Holster()
public bool UpdateVisiblity_Invis()
public void SetHeld(bool bHeld)
public void OnHeldChanged()
public bool get_IsUsableByTurret()
public bool CanBeUsedInWater()
public bool BlocksGestures()
protected Item GetOwnerItem()
public Item GetItem()
public ItemDefinition GetOwnerItemDefinition()
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
public void ServerCommand(Item item, string command, BasePlayer player)
public void SetupHeldEntity(Item item)
public Item GetCachedItem()
public void OnItemChanged(Item item)
public void PostServerLoad()
private void InitOwnerPlayer()
public void Save(SaveInfo info)
public void DestroyThis()
protected bool HasItemAmount()
protected bool UseItemAmount(int iAmount)
public void ServerUse()
public void ServerUse(float damageModifier, Transform originOverride, bool useBulletThickness)
public bool IsInstrument()
public void Load(LoadInfo info)
public void SendPunch(Vector3 amount, float duration)
}
public HelicopterDebris : ServerGib {
public ItemDefinition metalFragments
public ItemDefinition hqMetal
public ItemDefinition charcoal
public float massReductionScalar
private ResourceDispenser resourceDispenser
public float tooHotUntil
public void ServerInit()
public void PhysicsInit(Mesh mesh)
public bool IsTooHot()
public void OnAttacked(HitInfo info)
}
public HelicopterTurret : MonoBehaviour {
public PatrolHelicopterAI _heliAI
public float fireRate
public float burstLength
public float timeBetweenBursts
public float maxTargetRange
public float loseTargetAfter
public Transform gun_yaw
public Transform gun_pitch
public Transform muzzleTransform
public bool left
public BaseCombatEntity _target
private float lastBurstTime
private float lastFireTime
private float lastSeenTargetTime
private bool targetVisible
public void SetTarget(BaseCombatEntity newTarget)
public bool NeedsNewTarget()
public bool UpdateTargetFromList(List`1<targetinfo> newTargetList)
public bool TargetVisible()
public float TimeSinceTargetLastSeen()
public bool HasTarget()
public void ClearTarget()
public void TurretThink()
public void FireGun()
public Vector3 GetPositionForEntity(BaseCombatEntity potentialtarget)
public float AngleToTarget(BaseCombatEntity potentialtarget)
public bool InFiringArc(BaseCombatEntity potentialtarget)
public void UpdateTargetVisibility()
}
public HiddenValue`1 : HiddenValueBase {
private EncryptedValue`1<T, ulong> _key
private int _accessCount
public void .ctor(T value)
public T Get()
public HiddenValue`1<T> Set(T value)
private void Facepunch.Pool.IPooled.EnterPool()
private void Facepunch.Pool.IPooled.LeavePool()
public void Dispose()
public T op_Implicit(HiddenValue`1<T> hidden)
}
public HiddenValueBase : object {
private ulong _nextKey
private Dictionary`2<ulong, object> _values
protected ulong TakeKey()
protected object Get(ulong key)
protected void Set(ulong key, object value)
}
public HideIfAiming : MonoBehaviour {
public ParticleSystem[] systems
}
public HideIfOwnerFirstPerson : EntityComponent`1<BaseEntity> {
public GameObject[] disableGameObjects
public bool worldModelEffect
}
public HideIfScoped : MonoBehaviour {
public Renderer[] renderers
public void SetVisible(bool vis)
}
public HideUntilMobile : EntityComponent`1<BaseEntity> {
public GameObject[] visuals
private Vector3 startPos
}
public HierarchyUtil : object {
public Dictionary`2<string, GameObject> rootDict
public GameObject GetRoot(string strName, bool groupActive, bool persistant)
}
public HitArea : Enum {
public int value__
public HitArea Head
public HitArea Chest
public HitArea Stomach
public HitArea Arm
public HitArea Hand
public HitArea Leg
public HitArea Foot
}
public HitAreaConst : object {
public HitArea Nothing
public HitArea Everything
}
public HitAreaUtil : object {
public string Format(HitArea area)
}
public HitboxDefinition : MonoBehaviour {
public Vector3 center
public Vector3 rotation
public Type type
public int priority
public PhysicMaterial physicMaterial
private Vector3 scale
public Vector3 Scale
public Matrix4x4 LocalMatrix
public Vector3 get_Scale()
public void set_Scale(Vector3 value)
public Matrix4x4 get_LocalMatrix()
private void OnValidate()
protected void OnDrawGizmosSelected()
protected void OnDrawGizmos()
}
public HitboxSystem : MonoBehaviour {
public List`1<HitboxShape> hitboxes
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public HitchTrough : StorageContainer {
public HitchSpot[] hitchSpots
public float caloriesToDecaySeconds
public Item GetFoodItem()
public bool ValidHitchPosition(Vector3 pos)
public bool HasSpace()
public HitchSpot GetClosest(Vector3 testPos, bool includeOccupied, float maxRadius)
public void Unhitch(RidableHorse horse)
public int NumHitched()
public bool AttemptToHitch(RidableHorse horse, HitchSpot hitch)
public void Save(SaveInfo info)
public void PostServerLoad()
public void UnhitchAll()
public void DestroyShared()
public void OnKilled(HitInfo info)
public void Load(LoadInfo info)
}
public HitDetectionBenchmark : BenchmarkScene {
private int PlayerCount
public GameObjectRef PlayerModelPrefab
public GameObjectRef PlayerCollisionPrefab
}
public HitInfo : object {
public BaseEntity Initiator
public BaseEntity WeaponPrefab
public AttackEntity Weapon
public bool DoHitEffects
public bool DoDecals
public bool IsPredicting
public bool UseProtection
public Connection Predicted
public bool DidHit
public BaseEntity HitEntity
public UInt32 HitBone
public UInt32 HitPart
public UInt32 HitMaterial
public Vector3 HitPositionWorld
public Vector3 HitPositionLocal
public Vector3 HitNormalWorld
public Vector3 HitNormalLocal
public Vector3 PointStart
public Vector3 PointEnd
public int ProjectileID
public int ProjectileHits
public float ProjectileDistance
public float ProjectileIntegrity
public float ProjectileTravelTime
public float ProjectileTrajectoryMismatch
public Vector3 ProjectileVelocity
public Projectile ProjectilePrefab
public PhysicMaterial material
public DamageProperties damageProperties
public DamageTypeList damageTypes
public bool CanGather
public bool DidGather
public float gatherScale
public BasePlayer InitiatorPlayer
public Vector3 attackNormal
public bool hasDamage
public bool InitiatorParented
public bool HitEntityParented
public bool isHeadshot
public Phrase bonePhrase
public string boneName
public HitArea boneArea
public bool IsProjectile()
public BasePlayer get_InitiatorPlayer()
public Vector3 get_attackNormal()
public bool get_hasDamage()
public void .ctor(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount, Vector3 vhitPosition)
public void .ctor(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount)
public void LoadFromAttack(Attack attack, bool serverSide)
public bool get_InitiatorParented()
public bool get_HitEntityParented()
public bool get_isHeadshot()
public Phrase get_bonePhrase()
public string get_boneName()
public HitArea get_boneArea()
public Vector3 PositionOnRay(Vector3 position)
public Vector3 HitPositionOnRay()
public bool IsNaNOrInfinity()
}
public HitNumber : MonoBehaviour {
public HitType hitType
public int ColorToMultiplier(HitType type)
public void OnDrawGizmosSelected()
}
public HitTest : object {
public Type type
public Ray AttackRay
public float Radius
public float Forgiveness
public float MaxDistance
public RaycastHit RayHit
public bool MultiHit
public bool BestHit
public bool DidHit
public DamageProperties damageProperties
public GameObject gameObject
public Collider collider
public BaseEntity ignoreEntity
public Type ignoredType
public BaseEntity HitEntity
public Vector3 HitPoint
public Vector3 HitNormal
public float HitDistance
public Transform HitTransform
public UInt32 HitPart
public string HitMaterial
public void CopyFrom(HitTest other, bool copyHitInfo)
public Vector3 HitPointWorld()
public Vector3 HitNormalWorld()
public void Clear()
}
public HLODBounds : MonoBehaviour {
public Bounds MeshBounds
public string MeshPrefix
public float CullDistance
public float OverrideLodDistance
public float CullBelowHeight
public bool ApplyMeshTrimming
public MeshTrimSettings Settings
public LODComponent DebugComponent
public bool ShowTrimSettings
public bool DebugMode
}
public HolosightReticlePositioning : MonoBehaviour {
public IronsightAimPoint aimPoint
public RectTransform rectTransform
public RectTransform get_rectTransform()
private void Update()
private void UpdatePosition(Camera cam)
}
public HomingLauncherCamOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
public NVGCamera nvgCameraOverlay
}
public HomingLauncherUIDialog : UIDialog {
private Canvas canvas
private GameObject mainUI
private GameObject scopeCircle
private RawImage blackScreen
private AnimationCurve fadeEffectCurve
private float visualSwapTime
private Image lockPercentImage
private Image trackingImage
private GameObject armedObj
private GameObject lockedObj
private GameObject noAmmoObj
}
public Horse : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public void ServerInit()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public HorseBreed : ScriptableObject {
public Phrase breedName
public Phrase breedDesc
public Sprite trophyHeadSprite
public Material[] materialOverrides
public float maxHealth
public float maxSpeed
public float staminaDrain
public float maxStamina
}
public HorseCorpse : LootableCorpse {
public int breedIndex
public Phrase lootPanelTitle
public string playerName
public string get_playerName()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public HorseEquipmentInformationPanel : ItemInformationPanel {
public ItemTextValue horseProtectionDisplay
public ItemTextValue riderProtectionDisplay
public ItemTextValue maxSpeedDisplay
public ItemTextValue storageAmountDisplay
}
public HorseIdleMultiConditionCrossfade : StateMachineBehaviour {
public string TargetState
public float NormalizedTransitionDuration
}
public HorseRagdoll : AnimalRagdoll {
public GameObject mane
public GameObject woodArmor
public GameObject roadsignArmor
public HorseBreed overrideBreed
public GameObject singleSaddle
public GameObject doubleSaddle
public GameObjectRef breedSource
}
public HorseSpawner : VehicleSpawner {
public float respawnDelay
public float respawnDelayVariance
public bool spawnForSale
protected bool LogAnalytics
public void ServerInit()
public int GetOccupyLayer()
public void RespawnHorse()
protected bool get_LogAnalytics()
}
public HostileNote : MonoBehaviour {
public CanvasGroup warnGroup
public CanvasGroup group
public CanvasGroup timerGroup
public CanvasGroup smallWarning
public Text timerText
public RustText smallWarningText
public float unhostileTime
public float weaponDrawnDuration
public Color warnColor
public Color hostileColor
public float requireDistanceToSafeZone
}
public HotAirBalloon : BaseCombatEntity {
public Flags Flag_HasFuel
public Flags Flag_Grounded
public Flags Flag_CanModifyEquipment
public Flags Flag_HalfInflated
public Flags Flag_FullInflated
public Flags Flag_OnlyOwnerEntry
public Transform centerOfMass
public Rigidbody myRigidbody
public Transform buoyancyPoint
public float liftAmount
public Transform windSock
public Transform[] windFlags
public GameObject staticBalloonDeflated
public GameObject staticBalloon
public GameObject animatedBalloon
public Animator balloonAnimator
public Transform groundSample
public float inflationLevel
public GameObjectRef fuelStoragePrefab
public float fuelPerSec
public GameObjectRef storageUnitPrefab
public EntityRef`1<StorageContainer> storageUnitInstance
public DamageRenderer damageRenderer
public Transform engineHeight
public GameObject[] killTriggers
public List`1<UpgradeOption> UpgradeOptions
public EntityFuelSystem fuelSystem
public float population
public float outsidedecayminutes
public float NextUpgradeTime
public float windForce
public Vector3 currentWindVec
public Bounds collapsedBounds
public Bounds raisedBounds
public GameObject[] balloonColliders
public float serviceCeiling
public Vector3 lastFailedDecayPosition
public float currentBuoyancy
public float lastBlastTime
public float avgTerrainHeight
public bool grounded
public float spawnTime
public float safeAreaRadius
public Vector3 safeAreaOrigin
public bool IsFullyInflated
public bool Grounded
public SamTargetType SAMTargetType
public bool IsClient
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_IsFullyInflated()
public void InitShared()
public bool get_Grounded()
public void Load(LoadInfo info)
public bool CanModifyEquipment()
public void DelayNextUpgrade(float delay)
public int GetEquipmentCount(ItemModHABEquipment item)
public void RemoveItemsOfType(ItemModHABEquipment item)
public bool WaterLogged()
public bool OnlyOwnerAccessible()
public SamTargetType get_SAMTargetType()
public bool get_IsClient()
public void OnAttacked(HitInfo info)
protected void OnChildAdded(BaseEntity child)
protected void OnChildRemoved(BaseEntity child)
internal void DoServerDestroy()
public bool IsValidSAMTarget(bool staticRespawn)
public float GetNetworkTime()
public void PostServerLoad()
public void RPC_OpenFuel(RPCMessage msg)
public void Save(SaveInfo info)
public void ServerInit()
public void DecayTick()
public void EngineSwitch(RPCMessage msg)
public void ScheduleOff()
public void UpdateIsGrounded()
public void OnFlagsChanged(Flags old, Flags next)
public void CheckGlobal(Flags flags)
protected void FixedUpdate()
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public void ClearOwnerEntry()
public bool IsSafe()
public void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius)
public bool IsDespawnEligable()
public IFuelSystem GetFuelSystem()
public int StartingFuelUnits()
public Vector3 GetWindAtPos(Vector3 pos)
public bool PlayerHasEquipmentItem(BasePlayer player, int tokenItemID)
public Item GetEquipmentItem(BasePlayer player, int tokenItemID)
public float MaxHealth()
public List`1<ItemAmount> BuildCost()
public void RPC_ReqEquipItem(RPCMessage msg)
}
public HotAirBalloonArmor : HotAirBalloonEquipment {
public float AdditionalHealth
public void Added(HotAirBalloon hab, bool fromSave)
public void Removed(HotAirBalloon hab)
public void Hurt(HitInfo info)
}
public HotAirBalloonEquipment : BaseCombatEntity {
private DamageRenderer damageRenderer
public float DelayNextUpgradeOnRemoveDuration
private EntityRef`1<HotAirBalloon> hotAirBalloon
public void Added(HotAirBalloon hab, bool fromSave)
public void Removed(HotAirBalloon hab)
public void DoRepair(BasePlayer player)
}
public HotOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
public float smoothTime
public bool preventInstantiation
}
public HudElement : MonoBehaviour {
public Text[] ValueText
public Image[] FilledImage
public float lastValue
private float lastMax
public void SetValue(float value, float max)
private void SetText(string v)
private void SetImage(float f)
}
public HumanBodyResourceDispenser : ResourceDispenser {
public bool OverrideOwnership(Item item, AttackEntity weapon)
public string CreateSkullName(string playerName)
}
public HumanFuelSystem : object {
private bool isServer
private float percentFood
private EntityRef`1<BaseVehicle> vehilceRef
private float pendingFuel
public void .ctor(bool isServer, BaseVehicle owner, float percentFood)
public bool HasValidInstance(bool isServer)
public NetworkableId GetInstanceID()
public void SetInstanceID(NetworkableId uid)
private BaseVehicle GetVehilce()
public int GetFuelCapacity()
public void CheckNewChild(BaseEntity child)
public int GetFuelAmount()
public float GetFuelFraction()
public bool HasFuel(bool forceCheck)
public int TryUseFuel(float seconds, float fuelUsedPerSecond)
public void LootFuel(BasePlayer player)
public void AddFuel(int amount)
public void FillFuel()
private bool TryGetHuman(BasePlayer& driver)
}
public HumanNPC : NPCPlayer {
public int AdditionalLosBlockingLayer
public LootSpawnSlot[] LootSpawnSlots
public float aimConeScale
public float lastDismountTime
private ScientistBrain <Brain>k__BackingField
public bool lightsOn
public float nextZoneSearchTime
public AIInformationZone cachedInfoZone
public float targetAimedDuration
private float lastAimSetTime
public Vector3 aimOverridePosition
public ScientistBrain Brain
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public ScientistBrain get_Brain()
public void set_Brain(ScientistBrain value)
public bool IsLoadBalanced()
public void ServerInit()
internal void DoServerDestroy()
public void LightCheck()
public float GetAimConeScale()
public void EquipWeapon(bool skipDeployDelay)
public void DismountObject()
public bool RecentlyDismounted()
public float GetIdealDistanceFromTarget()
public AIInformationZone GetInformationZone(Vector3 pos)
public float EngagementRange()
public void SetDucked(bool flag)
public void TryThink()
public void ServerThink(float delta)
public void TickAttack(float delta, BaseCombatEntity target, bool targetIsLOS)
public void Hurt(HitInfo info)
public float GetAimSwayScalar()
public Vector3 GetAimDirection()
public void SetAimDirection(Vector3 newAim)
public void SetStationaryAimPoint(Vector3 aimAt)
public void ClearStationaryAimPoint()
public bool ShouldDropActiveItem()
public BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List`1<TriggerBase> triggersOnDeath)
protected string OverrideCorpseName()
public void AttackerInfo(DeathInfo info)
public bool IsThreat(BaseEntity entity)
public bool IsTarget(BaseEntity entity)
public bool IsFriendly(BaseEntity entity)
public bool CanAttack(BaseEntity entity)
public bool IsTargetInRange(BaseEntity entity, Single& dist)
public bool CanSeeTarget(BaseEntity entity)
public bool CanSeeTarget(BaseEntity entity, Vector3 fromOffset)
public bool NeedsToReload()
public bool Reload()
public float CooldownDuration()
public bool IsOnCooldown()
public bool StartAttacking(BaseEntity entity)
public void StopAttacking()
public float GetAmmoFraction()
public BaseEntity GetBestTarget()
public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
public void UseHealingItem(Item item)
private IEnumerator Heal(Item item)
public Item FindHealingItem()
public bool IsOnGround()
}
public HumanPathFinder : BasePathFinder {
private BaseEntity npc
public void Init(BaseEntity npc)
public AIMovePoint GetBestRoamPoint(Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float anchorClampDistance, float lookupMaxRange)
private AIMovePoint GetBestRoamPoint(AIInformationZone aiZone, Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float clampDistance, float lookupMaxRange)
}
public HungerAboveAIEvent : BaseAIEvent {
private float <Value>k__BackingField
public float Value
public float get_Value()
private void set_Value(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public HuntingTrophy : StorageContainer {
public HeadData CurrentTrophyData
public PlayerModel Player
public GameObject MaleRope
public GameObject FemaleRope
public Renderer[] HorseRenderers
public Renderer[] HorseHairRenderers
public UInt32 HORSE_PREFAB_ID
public GameObject NameRoot
public RustText NameText
public TrophyRoot[] Trophies
public HeadData TrophyData
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public HeadData get_TrophyData()
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public bool ItemFilter(Item item, int targetSlot)
private void ServerRequestSubmit()
private void ServerRequestClear(RPCMessage msg)
public void Save(SaveInfo info)
public bool CanSubmitHead(HeadEntity headEnt)
public void Load(LoadInfo info)
public void ResetState()
private GameObject <CanSubmitHead>g__GetCurrentTrophyDataSource|19_0()
}
public HurtOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
public float smoothTime
}
public HurtPunch : MonoBehaviour {
public PostProcessVolume postProcessVolume
public float punchHurtDuration
}
public IAIAttack {
public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
public BaseEntity GetBestTarget()
public bool CanAttack(BaseEntity entity)
public float EngagementRange()
public bool IsTargetInRange(BaseEntity entity, Single& dist)
public bool CanSeeTarget(BaseEntity entity)
public float GetAmmoFraction()
public bool NeedsToReload()
public bool Reload()
public float CooldownDuration()
public bool IsOnCooldown()
public bool StartAttacking(BaseEntity entity)
public void StopAttacking()
}
internal IAIDesign {
public void LoadAIDesign(AIDesign design, BasePlayer player)
public void StopDesigning()
public bool CanPlayerDesignAI(BasePlayer player)
}
public IAIEventListener {
public void EventTriggeredStateChange(int newStateContainerID, int sourceEventID)
}
public IAIGroupable {
public bool AddMember(IAIGroupable member)
public void RemoveMember(IAIGroupable member)
public void JoinGroup(IAIGroupable leader, BaseEntity leaderEntity)
public void SetGroupRoamRootPosition(Vector3 rootPos)
public bool InGroup()
public void LeaveGroup()
public void SetUngrouped()
}
public IAIHungerAbove {
public bool IsHungerAbove(float val)
}
public IAIMounted {
public bool IsMounted()
}
public IAIPath {
public IEnumerable`1<IAIPathSpeedZone> SpeedZones
public IEnumerable`1<IAIPathInterestNode> InterestNodes
public IEnumerable`1<IAIPathSpeedZone> get_SpeedZones()
public IEnumerable`1<IAIPathInterestNode> get_InterestNodes()
public void GetNodesNear(Vector3 point, List`1& nearNodes, float dist)
public IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist)
public IAIPathNode GetClosestToPoint(Vector3 point)
public void AddInterestNode(IAIPathInterestNode interestNode)
public void AddSpeedZone(IAIPathSpeedZone speedZone)
}
public IAIPathInterestNode {
public Vector3 Position
public float NextVisitTime
public Vector3 get_Position()
public float get_NextVisitTime()
public void set_NextVisitTime(float value)
}
public IAIPathNode {
public Vector3 Position
public bool Straightaway
public IEnumerable`1<IAIPathNode> Linked
public Vector3 get_Position()
public bool get_Straightaway()
public IEnumerable`1<IAIPathNode> get_Linked()
public bool IsValid()
public void AddLink(IAIPathNode link)
}
public IAIPathSpeedZone {
public OBB WorldSpaceBounds()
public float GetMaxSpeed()
}
public IAirSupply {
public AirSupplyType AirType
public AirSupplyType get_AirType()
public float GetAirTimeRemaining()
}
public IAISenses {
public bool IsThreat(BaseEntity entity)
public bool IsTarget(BaseEntity entity)
public bool IsFriendly(BaseEntity entity)
}
public IAISleep {
public void StartSleeping()
public void StopSleeping()
}
public IAISleepable {
public bool AllowedToSleep()
public void SleepAI()
public void WakeAI()
}
public IAITirednessAbove {
public bool IsTirednessAbove(float val)
}
public IAmmoContainer {
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public List`1<Item> FindItemsByItemID(int id)
public Item FindItemByItemName(string name)
public bool HasAmmo(AmmoTypes ammoType)
public Item FindItemByUID(ItemId iUID)
public bool GiveItem(Item item, ItemContainer container)
}
public IAudioConnectionSource {
public IOEntity ToEntity()
}
public ICassettePlayer {
public BaseEntity ToBaseEntity
public void OnCassetteInserted(Cassette c)
public void OnCassetteRemoved(Cassette c)
public BaseEntity get_ToBaseEntity()
}
public IceFence : GraveyardFence {
public GameObject[] styles
private bool init
public AdaptMeshToTerrain snowMesh
public int GetStyleFromID()
public void ServerInit()
public void InitStyle()
public void SetStyle(int style)
public void UpdatePillars()
}
internal IClientBrainStateListener {
public void OnClientStateChanged(AIState state)
}
public IconSkin : MonoBehaviour {
public Image icon
public Text text
}
public IconSkinPicker : MonoBehaviour {
public GameObjectRef pickerIcon
public GameObject container
public Action skinChangedEvent
public ScrollRect scroller
public SearchFilterInput searchFilter
}
public IConversationProvider {
public bool ProviderBusy()
}
public IdentifierConfig : IOConfig`1<IRemoteControllable> {
public string id
}
public IEngineControllerUser {
public bool HasFlag(Flags f)
public bool IsDead()
public void SetFlag(Flags f, bool b, bool recursive, bool networkupdate)
public void Invoke(Action action, float time)
public void CancelInvoke(Action action)
public void OnEngineStartFailed()
public bool MeetsEngineRequirements()
}
public IEntityPingSource {
public bool IsPingValid(MapNote note)
}
public IFlagNotify {
public void OnFlagToggled(bool state)
}
public IFuelSystem {
public bool HasValidInstance(bool isServer)
public NetworkableId GetInstanceID()
public void SetInstanceID(NetworkableId uid)
public void CheckNewChild(BaseEntity child)
public int GetFuelAmount()
public float GetFuelFraction()
public bool HasFuel(bool forceCheck)
public int TryUseFuel(float seconds, float fuelUsedPerSecond)
public int GetFuelCapacity()
public void LootFuel(BasePlayer player)
public void AddFuel(int amount)
public void FillFuel()
}
public Igniter : IOEntity {
public float IgniteRange
public float IgniteFrequency
public float IgniteStartDelay
public Transform LineOfSightEyes
public float SelfDamagePerIgnite
public int PowerConsumption
public int ConsumptionAmount()
public bool CanIgnite()
public void UpdateFromInput(int inputAmount, int inputSlot)
private void IgniteInRange()
public int DesiredPower(int inputIndex)
public void OnRepair()
}
public IgnoreCollision : MonoBehaviour {
public Collider collider
protected void OnTriggerEnter(Collider other)
}
public IIdealSlotEntity {
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifiers)
}
public IIgniteable {
public void Ignite(Vector3 fromPos)
public bool CanIgnite()
}
public IIndustrialStorage {
public ItemContainer Container
public BaseEntity IndustrialEntity
public ItemContainer get_Container()
public Vector2i InputSlotRange(int slotIndex)
public Vector2i OutputSlotRange(int slotIndex)
public void OnStorageItemTransferBegin()
public void OnStorageItemTransferEnd()
public BaseEntity get_IndustrialEntity()
}
public IInstanceDataReceiver {
public void ReceiveInstanceData(InstanceData data)
}
public IItemContainerEntity {
public ItemContainer inventory
public Transform Transform
public bool DropsLoot
public float DestroyLootPercent
public bool DropFloats
public ItemContainer get_inventory()
public Transform get_Transform()
public bool get_DropsLoot()
public float get_DestroyLootPercent()
public bool get_DropFloats()
public void DropItems(BaseEntity initiator)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public bool ShouldDropItemsIndividually()
public void DropBonusItems(BaseEntity initiator, ItemContainer container)
public Vector3 GetDropPosition()
}
public IItemSetup {
public void OnItemSetup(Item item)
}
public IItemUpdate {
public void OnItemUpdate(Item item)
}
public ILerpInfo {
public float GetExtrapolationTime()
public float GetInterpolationDelay()
public float GetInterpolationSmoothing()
}
public ILootableEntity {
public ulong LastLootedBy
public ulong get_LastLootedBy()
public void set_LastLootedBy(ulong value)
}
public ImagePainter : MonoBehaviour {
public OnDrawingEvent onDrawing
public MonoBehaviour redirectRightClick
public float spacingScale
internal Brush brush
internal PointerState[] pointerState
public RectTransform rectTransform
public RectTransform get_rectTransform()
public void OnPointerDown(PointerEventData eventData)
public void OnPointerUp(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
public void OnBeginDrag(PointerEventData eventData)
public void OnEndDrag(PointerEventData eventData)
public void OnInitializePotentialDrag(PointerEventData eventData)
private void DrawAt(Vector2 position, InputButton button)
private void Start()
public void UpdateBrush(Brush brush)
}
public ImageProcessing : object {
private Byte[] signaturePNG
private Byte[] signatureIHDR
public void GaussianBlur2D(Single[] data, int len1, int len2, int iterations)
public void GaussianBlur2D(Single[] data, int len1, int len2, int len3, int iterations)
public void Average2D(Single[] data, int len1, int len2, int iterations)
public void Average2D(Single[] data, int len1, int len2, int len3, int iterations)
public void Upsample2D(Single[] src, int srclen1, int srclen2, Single[] dst, int dstlen1, int dstlen2)
public void Upsample2D(Single[] src, int srclen1, int srclen2, int srclen3, Single[] dst, int dstlen1, int dstlen2, int dstlen3)
public void Dilate2D(Int32[] src, int len1, int len2, int srcmask, int radius, Action`2<int, int> action)
public void FloodFill2D(int x, int y, Int32[] data, int len1, int len2, int mask_any, int mask_not, Func`2<int, int> action)
public bool IsValidPNG(Byte[] data, int maxSizeSquare)
public bool IsValidPNG(Byte[] data, int maxWidth, int maxHeight)
public bool IsValidJPG(Byte[] data, int maxSizeSquare)
public bool IsValidJPG(Byte[] data, int maxWidth, int maxHeight)
public bool IsClear(Color32[] data)
}
public ImageRenderController : SingletonComponent`1<ImageRenderController> {
public Camera Camera
}
public ImageStorageEntity : BaseEntity {
private List`1<ImageRequest> _requests
protected Type StorageType
protected UInt32 CrcToLoad
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected Type get_StorageType()
protected UInt32 get_CrcToLoad()
private void ImageRequested(RPCMessage msg)
}
public IMagnetLiftable : MonoBehaviour {
private void Start()
private void Update()
}
public IMetalDetectable {
public List`1<Vector3> GetScanLocations()
public Vector3 GetNearestPosition(Vector3 pos)
public bool VerifyScanPosition(Vector3 playerPos, Vector3 pos, Vector3& spotPos)
public void Detected(Vector3 pos)
public float GetRadius()
}
public IMissionEntityListener {
public void MissionStarted(BasePlayer assignee, MissionInstance instance)
public void MissionEnded(BasePlayer assignee, MissionInstance instance)
}
public IMissionProvider {
public NetworkableId ProviderID()
public Vector3 ProviderPosition()
public BaseEntity Entity()
}
public Impostor : MonoBehaviour {
public ImpostorAsset asset
public GameObject reference
public float angle
public int resolution
public int padding
public bool spriteOutlineAsMesh
private void OnEnable()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public ImpostorAsset : ScriptableObject {
public TextureEntry[] textures
public Vector2 size
public Vector2 pivot
public Mesh mesh
public Texture2D FindTexture(string name)
}
public ImpostorBatch : object {
private Mesh <Mesh>k__BackingField
private Material <Material>k__BackingField
private ComputeBuffer <PositionBuffer>k__BackingField
public FPNativeList`1<Vector4> Positions
private ComputeBuffer <ArgsBuffer>k__BackingField
private FPNativeList`1<UInt32> args
private bool <IsDirty>k__BackingField
private Queue`1<int> recycle
public Mesh Mesh
public Material Material
public ComputeBuffer PositionBuffer
public ComputeBuffer ArgsBuffer
public bool IsDirty
public int Count
public bool Visible
private void set_Mesh(Mesh value)
public Mesh get_Mesh()
private void set_Material(Material value)
public Material get_Material()
private void set_PositionBuffer(ComputeBuffer value)
public ComputeBuffer get_PositionBuffer()
private void set_ArgsBuffer(ComputeBuffer value)
public ComputeBuffer get_ArgsBuffer()
public bool get_IsDirty()
public void set_IsDirty(bool value)
public int get_Count()
public bool get_Visible()
private ComputeBuffer SafeRelease(ComputeBuffer buffer)
public void Initialize(Mesh mesh, Material material)
public void Release()
public void AddInstance(ImpostorInstanceData data)
public void RemoveInstance(ImpostorInstanceData data)
public void UpdateBuffers()
}
public ImpostorInstanceData : object {
private Renderer <Renderer>k__BackingField
private Mesh <Mesh>k__BackingField
private Material <Material>k__BackingField
public ImpostorBatch Batch
public int BatchIndex
private int hash
private Vector4 positionAndScale
public Renderer Renderer
public Mesh Mesh
public Material Material
private void set_Renderer(Renderer value)
public Renderer get_Renderer()
private void set_Mesh(Mesh value)
public Mesh get_Mesh()
private void set_Material(Material value)
public Material get_Material()
public void .ctor(Renderer renderer, Mesh mesh, Material material)
public void .ctor(Vector3 position, Vector3 scale, Mesh mesh, Material material)
private int GenerateHashCode()
public bool Equals(object obj)
public int GetHashCode()
public Vector4 PositionAndScale()
public void Update()
}
public ImpostorRenderer : MonoBehaviour {
public string MainPassName
}
public InAttackRangeAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public IndependentScale : MonoBehaviour {
public Transform scaleParent
public Vector3 initialScale
}
public IndependentScaleImagePPU : MonoBehaviour {
public Transform scaleParent
public Image image
}
public IndividualSpawner : BaseMonoBehaviour {
public GameObjectRef entityPrefab
public float respawnDelayMin
public float respawnDelayMax
public bool useCustomBoundsCheckMask
public LayerMask customBoundsCheckMask
public bool oneTimeSpawner
internal bool isSpawnerActive
public SpawnPointInstance spawnInstance
public float nextSpawnTime
public int currentPopulation
public bool IsSpawned
public int get_currentPopulation()
public bool get_IsSpawned()
protected void Awake()
protected void OnDestroy()
protected void OnDrawGizmosSelected()
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
public void Fill()
public void SpawnInitial()
public void Clear()
public void SpawnRepeating()
public bool HasSpaceToSpawn()
public void TrySpawnEntity()
public bool TryGetEntityBounds(Bounds& result)
}
public IndividualSpawnerNexusOnly : IndividualSpawner {
protected void TrySpawnEntity()
}
public IndustrialConveyor : IndustrialEntity {
public int MaxStackSizePerMove
public GameObjectRef FilterDialog
private float ScreenUpdateRange
public Flags FilterPassFlag
public Flags FilterFailFlag
public int MaxContainerDepth
public SoundDefinition transferItemSoundDef
public SoundDefinition transferItemStartSoundDef
public List`1<ItemFilter> filterItems
public ConveyorMode mode
public int MAX_FILTER_SIZE
public Image IconTransferImage
private bool refreshInputOutputs
private IIndustrialStorage workerOutput
private Func`3<IIndustrialStorage, int, bool> filterFunc
private List`1<ContainerInputOutput> splitOutputs
private List`1<ContainerInputOutput> splitInputs
private Nullable`1<bool> lastFilterState
private Stopwatch transferStopWatch
private bool multiFrameTransferInProcess
private int multiFrameOutputIndex
private int multiFrameInputIndex
private bool isFirstTransfer
private bool wasOnWhenPowerLost
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnFlagsChanged(Flags old, Flags next)
private void ScheduleMove()
private Item GetItemToMove(IIndustrialStorage storage, ItemFilter& associatedFilter, int slot, ItemContainer targetContainer)
private bool FilterHasItem(Item item, ValueTuple`2& filter)
private bool FilterMatches(ItemFilter filter, Item item)
private bool FilterContainerInput(IIndustrialStorage storage, int slot)
protected void RunJob()
protected void OnIndustrialNetworkChanged()
public void PostServerLoad()
private bool CheckIfAnyInputPassesFilters(List`1<ContainerInputOutput> inputs)
public void Save(SaveInfo info)
private void RPC_ChangeFilters(RPCMessage msg)
private void SvSwitch(RPCMessage msg)
public void SetSwitch(bool wantsOn)
public void Unbusy()
public void UpdateHasPower(int inputAmount, int inputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public int GetPassthroughAmount(int outputSlot)
public bool ShouldDrainBattery(IOEntity battery)
private void Server_RequestUpToDateFilters(RPCMessage msg)
public void Load(LoadInfo info)
internal bool <RunJob>g__FilterMatchItem|32_1(ItemFilter filter, Item item)
internal void <RunJob>g__AddTransfer|32_2(int itemId, int amount, BaseEntity fromEntity, BaseEntity toEntity, <>c__DisplayClass32_1& )
private void <RunJob>g__UpdateFilterPassthroughs|32_0(<>c__DisplayClass32_0& )
}
public IndustrialCrafter : IndustrialEntity {
public string LootPanelName
public bool NeedsBuildingPrivilegeToUse
public bool OnlyOneUser
public SoundDefinition ContainerOpenSound
public SoundDefinition ContainerCloseSound
public AnimationCurve MaterialOffsetCurve
public Flags Crafting
public Flags FullOutput
public Renderer MeshRenderer
public ParticleSystemContainer JobCompleteFx
public SoundDefinition JobCompleteSoundDef
private TimeUntilWithDuration <jobFinishes>k__BackingField
public int BlueprintSlotStart
public int BlueprintSlotEnd
private ItemContainer <inventory>k__BackingField
private bool <DropFloats>k__BackingField
private ulong <LastLootedBy>k__BackingField
private ItemDefinition currentlyCrafting
private int currentlyCraftingAmount
private int StorageSize
private int InputSlotStart
private int InputSlotEnd
private int OutputSlotStart
private int OutputSlotEnd
public TimeUntilWithDuration jobFinishes
public ItemContainer inventory
public Transform Transform
public bool DropsLoot
public float DestroyLootPercent
public bool DropFloats
public ulong LastLootedBy
public ItemContainer Container
public BaseEntity IndustrialEntity
public Phrase LootPanelTitle
public SoundDefinition OpenSound
public SoundDefinition CloseSound
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public TimeUntilWithDuration get_jobFinishes()
private void set_jobFinishes(TimeUntilWithDuration value)
public void OnFlagsChanged(Flags old, Flags next)
public ItemContainer get_inventory()
public void set_inventory(ItemContainer value)
public Transform get_Transform()
public bool get_DropsLoot()
public float get_DestroyLootPercent()
public bool get_DropFloats()
public ulong get_LastLootedBy()
public void set_LastLootedBy(ulong value)
public void OnKilled(HitInfo info)
public void DropItems(BaseEntity initiator)
public bool ShouldDropItemsIndividually()
public void DropBonusItems(BaseEntity initiator, ItemContainer container)
private void RPC_OpenLoot(RPCMessage rpc)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public void ServerInit()
public void CreateInventory(bool giveUID)
private bool CanAcceptItem(Item item, int index)
private void CheckCraft()
private Item GetTargetBlueprint(int index)
protected void RunJob()
private void CompleteCraft()
private int GetInputAmount(ItemDefinition def)
private bool ConsumeInputIngredient(ItemAmount am)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public ItemContainer get_Container()
public Vector2i InputSlotRange(int slotIndex)
public Vector2i OutputSlotRange(int slotIndex)
public void OnStorageItemTransferBegin()
public void OnStorageItemTransferEnd()
public BaseEntity get_IndustrialEntity()
public void UpdateHasPower(int inputAmount, int inputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public bool ShouldDrainBattery(IOEntity battery)
public bool WantsPassthroughPower()
public bool WantsPower(int inputIndex)
public void SetSwitch(bool wantsOn)
public void Unbusy()
private void SvSwitch(RPCMessage msg)
public bool CanPickup(BasePlayer player)
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
public Phrase get_LootPanelTitle()
public SoundDefinition get_OpenSound()
public SoundDefinition get_CloseSound()
public Workbench GetWorkbench()
}
public IndustrialEntity : IOEntity {
public IndustrialProcessQueue Queue
protected void RunJob()
}
public IndustrialFilterBuffer : MonoBehaviour {
public RustText ItemName
public Image ItemIcon
public GameObject BlueprintRoot
public RustSlider BufferSlider
public RustText BufferProgressText
}
public IndustrialFilterDialog : UIDialog {
public GameObjectRef ItemPrefab
public Transform ItemParent
public GameObject ItemSearchParent
public ItemSearchEntry ItemSearchEntryPrefab
public GameObject NoItemsPrompt
public Dropdown FilterModeDropdown
public GameObject[] FilterModeExplanations
public GameObject FilterModeBlocker
public RustText FilterCountText
public GameObject BufferRoot
public GameObjectRef BufferItemPrefab
public Transform BufferTransform
public RustButton PasteButton
public GameObject[] RegularCopyPasteButtons
public GameObject[] JsonCopyPasteButtons
public bool closeWhenClicked
public int count
}
public IndustrialFilterItemIcon : MonoBehaviour {
public Image ItemIcon
public RustText ItemName
public RustInput MaxInput
public RustInput BufferInput
public RustInput MinInput
public GameObject BlueprintIcon
public GameObject InverseModeBlocker
}
public IndustrialStorageAdaptor : IndustrialEntity {
public GameObject GreenLight
public GameObject RedLight
public BaseEntity _cachedParent
public ItemContainer cachedContainer
public BaseEntity cachedParent
public ItemContainer Container
public BaseEntity IndustrialEntity
public BaseEntity get_cachedParent()
public ItemContainer get_Container()
public void ServerInit()
public Vector2i InputSlotRange(int slotIndex)
public Vector2i OutputSlotRange(int slotIndex)
public void OnStorageItemTransferBegin()
public void OnStorageItemTransferEnd()
public BaseEntity get_IndustrialEntity()
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
public int ConsumptionAmount()
public void ClientNotifyItemAddRemoved(bool add)
}
public INexusTransferTriggerController {
public bool CanTransfer(BaseEntity entity)
public ValueTuple`2<string, string> GetTransferDestination()
}
public InfoBar : MonoBehaviour {
public Text TextValue
public Image ImageFill
public Color GoodColor
public Color BadColor
}
public InfrastructureType : Enum {
public int value__
public InfrastructureType Road
public InfrastructureType Power
public InfrastructureType Trail
public InfrastructureType Tunnel
public InfrastructureType UnderwaterLab
public InfrastructureType Boat
public InfrastructureType Rail
}
public IngameMenuBackground : MonoBehaviour {
public bool Enabled
public CanvasGroup canvasGroup
}
public INotifyEntityTrigger {
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
}
public INotifyTrigger {
public void OnObjects(TriggerNotify trigger)
public void OnEmpty()
}
public InputState : object {
public InputMessage current
public InputMessage previous
private int SwallowedButtons
public bool IsDown(BUTTON btn)
public bool WasDown(BUTTON btn)
public bool IsAnyDown()
public bool WasJustPressed(BUTTON btn)
public bool WasJustReleased(BUTTON btn)
public void SwallowButton(BUTTON btn)
public Quaternion AimAngle()
public Vector3 MouseDelta()
public void Flip(InputMessage newcurrent)
public void Clear()
public void SetMouseDelta(Vector3 d)
}
public InRangeAIEvent : BaseAIEvent {
private float <Range>k__BackingField
public float Range
public float get_Range()
public void set_Range(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public InRangeOfHomeAIEvent : BaseAIEvent {
private float <Range>k__BackingField
public float Range
public float get_Range()
public void set_Range(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public InspectorNameAttribute : PropertyAttribute {
public string name
public void .ctor(string name)
}
public InstancedCameraComponent : MonoBehaviour {
public bool IsMirror
}
public InstancedEntityComponent : PrefabAttribute {
public bool HideInsideNetworkRange
protected Type GetIndexedType()
}
public InstancedMeshFilter : PrefabAttribute {
public MeshRenderer MeshRenderer
public RendererLOD RendererLOD
public MeshLOD MeshLOD
public InstancedMeshConfig Config
protected Type GetIndexedType()
}
public InstancedScheduler : SingletonComponent`1<InstancedScheduler> {
public ComputeShader CullShader
public ComputeShader SimplePostCullShader
public ComputeShader ClearBufferShader
public ComputeShader WriteIndirectArgsShader
public ComputeShader CopyMeshShader
public ConstructionSkin_ColourLookup ContainerColorLookup
public List`1<BuildingGrade> coloredSkins
}
public Instancing.BuildingBlockConfig : object {
public UInt32 PrefabId
public List`1<BuildingBlockSkin> Skins
}
public Instancing.BuildingBlockSkin : object {
public UInt32 SkinPrefabId
public int Grade
public ulong Skin
public Matrix4x4 LocalToWorld
}
public Instancing.BuildingSkinConfig : object {
public UInt32 PrefabId
public List`1<ConditionalModelConfig> Conditionals
}
public Instancing.CellHeader : ValueType {
public int StartIndex
public int Count
public int PartitionKey
}
public Instancing.CellId : ValueType {
public int Index
public void .ctor(int index)
public string ToString()
}
public Instancing.CellMeshAllocator : object {
public int CellCapacity
private int initialCellCount
public int InitialCapacity
private Dictionary`2<int, CellPartition> partitions
private List`1<CellId> recycledCells
private int <CellCount>k__BackingField
private Dictionary`2<long, int> meshLookup
public Dictionary`2<long, int> sliceIndexLookup
private Dictionary`2<int, List`1<long>> sliceLists
public NativeArray`1<CellHeader> Cells
public NativeArray`1<InstancedCullData> CullData
public NativeArray`1<float4x4> PositionData
public NativeArray`1<MeshOverrideData> OverrideArray
public GPUBuffer`1<float4x4> PositionBuffer
public GPUBuffer`1<InstancedCullData> CullingDataBuffer
public GPUBuffer`1<MeshOverrideData> OverrideBuffer
private bool dirty
public int CellCount
public int get_CellCount()
private void set_CellCount(int value)
public void Initialize()
public void OnDestroy()
private void AllocateNativeMemory()
private void FreeNativeMemory()
public CellId AddMesh(InstancedCullData data, int partitionKey, float4x4 localToWorld)
public bool TryRemoveMesh(long virtualMeshId, InstancedCullData& removedData)
public Nullable`1<InstancedMeshData> TryGetMeshData(long virtualMeshId)
public void SetMeshVisible(long virtualMeshId, bool visible)
public void SetOverride(long virtualMeshId, MeshOverrideData newData)
private CellId CreateCell(int sortingKey)
public void ExpandData()
private void RecycleCell(CellId cellId)
private CellId GetCellId(int index)
public void PrintMemoryUsage(StringBuilder builder)
public void FlushComputeBuffers()
}
public Instancing.ComputeBufferEx : object {
public void SetBuffer(ComputeShader shader, int kernel, int name, GPUBuffer`1<T> buffer)
}
public Instancing.ConditionalModelConfig : object {
public int ModelStateMask
public UInt32 TargetPrefabId
public Matrix4x4 LocalToWorld
}
public Instancing.CullingManager : object {
public NativeArray`1<RenderSlice> RenderSlicesArray
public GPUBuffer`1<RenderSlice> RenderSlicesBuffer
public void Initialize()
public void OnDestroy()
private void AllocateNativeMemory()
private void FreeNativeMemory()
public void EnsureCapacity(int rendererCount)
public void PrintMemoryUsage(StringBuilder builder)
public void UpdateComputeBuffers()
}
public Instancing.DrawCallJobData : ValueType {
public int DrawCallIndex
public int RendererIndex
public UInt32 IndexCount
public UInt32 IndexStart
public UInt32 VertexStart
public UInt32 MultidrawIndexStart
public UInt32 MultidrawVertexStart
public int Padding1
}
public Instancing.DrawCallKey : ValueType {
public Material Material
public ShadowCastingMode ShadowMode
public bool ReceiveShadows
public LightProbeUsage LightProbes
public void .ctor(Material material, ShadowCastingMode shadowMode, bool receiveShadows, LightProbeUsage lightProbes)
public int CompareTo(DrawCallKey other)
public int CompareTo(object obj)
public bool Equals(DrawCallKey other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(DrawCallKey a, DrawCallKey b)
public bool op_Inequality(DrawCallKey a, DrawCallKey b)
}
public Instancing.DrawCallManager : object {
private CellMeshAllocator cellAllocator
private GeometryBuffers GeometryBuffers
public NativeArray`1<DrawCallJobData> DrawCallArray
public GPUBuffer`1<DrawCallJobData> DrawCallBuffer
public GPUBuffer`1<UInt32> IndirectArgsBuffer
public GPUBuffer`1<UInt32> IndirectExtraArgBuffer
public GPUBuffer`1<UInt32> RenderBuffer
private int _overrideBufferVersion
private int _positionBufferVersion
private List`1<DrawCall> DrawCalls
private bool _needsDrawCallRebuild
private int IndirectArgCapacity
private int <DrawCallsLastFrame>k__BackingField
private int renderLayer
private int initialCapacity
private Bounds cullingBounds
public int DrawCallsLastFrame
public int DrawCallCount
public int get_DrawCallsLastFrame()
private void set_DrawCallsLastFrame(int value)
public int get_DrawCallCount()
public void .ctor(CellMeshAllocator cellAllocator, GeometryBuffers geometryBuffers)
public void Initialize()
public void OnDestroy()
private void AllocateNativeMemory()
private void FreeNativeMemory()
public void AddDrawCall(InstancedMeshRenderer renderer, int submeshIndex, UInt32 indicies, UInt32 indiciesIndex, UInt32 vertexIndex, MultidrawMeshInfo multidraw)
private bool NeedsToRebuildMaterialBlocks()
private void RebuildAllMaterialBlocks()
private void UpdateMaterialBlock(DrawCall drawCall)
public void EnsureCapacity(int totalMeshCount)
private void EnsureDrawCallCapcity()
public void UpdateComputeBuffers()
private void SortAndBatchDrawCalls()
public void SubmitDrawCalls()
private void SubmitDrawCallsInternal(Camera camera)
public void PrintMemoryUsage(StringBuilder builder)
}
public Instancing.GeometryBuffers : object {
private int _meshCopyMode
public GPUBuffer`1<VertexData> VertexBuffer
public GPUBuffer`1<int> TriangleBuffer
private int VertexIndex
private int TriangleIndex
private bool <IsDirty>k__BackingField
private Dictionary`2<Mesh, MultidrawMeshInfo[]> _meshes
public bool IsDirty
public bool get_IsDirty()
public void set_IsDirty(bool value)
public void Initialize(int meshCopyMode)
private void ResetStreamPosition()
public void Destroy()
private void AllocateNativeMemory()
private void FreeNativeMemory()
public MultidrawMeshInfo[] CopyMesh(Mesh mesh)
private void CopyMeshViaShader(Mesh mesh)
public void Rebuild()
private MultidrawMeshInfo[] CalculateSubmeshInfo(Mesh mesh)
private void CopyMeshViaCPU(Mesh mesh)
public void PrintMemoryUsage(StringBuilder builder)
}
public Instancing.GPUBuffer`1 : GPUBuffer {
private int <BufferVersion>k__BackingField
private GraphicsBuffer <Buffer>k__BackingField
private Target _type
private Target <Type>k__BackingField
private int <count>k__BackingField
private int <stride>k__BackingField
public int BufferVersion
public GraphicsBuffer Buffer
public Target Type
public int count
public int stride
public int ByteLength
public int get_BufferVersion()
private void set_BufferVersion(int value)
public GraphicsBuffer get_Buffer()
private void set_Buffer(GraphicsBuffer value)
public Target get_Type()
private void set_Type(Target value)
public int get_count()
private void set_count(int value)
public int get_stride()
private void set_stride(int value)
public int get_ByteLength()
public void .ctor(int length, Target target)
public void SetData(List`1<T> data)
public void SetData(List`1<int> data, int nativeArrayIndex, int computeBufferIndex, int length)
public void SetData(T[] data)
public void SetData(T[] data, int nativeArrayIndex, int computeBufferIndex, int length)
public void SetData(NativeArray`1<T> data)
public void SetData(NativeArray`1<T> data, int nativeArrayIndex, int computeBufferIndex, int length)
public void ClearData()
public void Expand(int newCapacity, bool preserveData)
public void EnsureCapacity(int size, bool preserveData, float expandRatio)
public void Dispose()
}
public Instancing.GPUInstancedCulling : object {
private int Param_InputBuffer
private int Param_OutputBuffer
private int Param_ComputeBuffer
private int Param_IndirectArgs
private int Param_IndirectExtraArgs
private int Param_RenderSlices
private int Param_SliceCounts
private int Param_FrustumPlanes
private int Param_ShadowFrustumCount
private int Param_CameraPosition
private int Param_MaxDistance
private int Param_DistanceScale
private int Param_SliceCount
private int Param_Length
private int Param_DrawCalls
private int Param_DrawCallCount
private int Param_Multidraw_Enabled
private int Param_FrustumCullingEnabled
private GPUBuffer`1<UInt32> tempBuffer
private GPUBuffer`1<UInt32> postCullMeshCounts
public void Initialize()
public void OnDestroy()
private void AllocateNativeMemory()
private void FreeNativeMemory()
public void SimpleCulling(CullingParameters options)
private void CullingShader(ComputeShader shader, GPUBuffer`1<InstancedCullData> inputBuffer, int inputLength, GPUBuffer`1<UInt32> outputBuffer, GPUBuffer`1<RenderSlice> renderSlices, GPUBuffer`1<float4> frustumPlanes, int shadowCameras, Vector3 cameraPosition, float maxDistance, float distanceScale, bool frustumCulling)
private void SimplePostCull(ComputeShader shader, GPUBuffer`1<UInt32> inputBuffer, GPUBuffer`1<UInt32> outputBuffer, GPUBuffer`1<RenderSlice> renderSlices, int sliceCount, GPUBuffer`1<UInt32> sliceCounts)
private void WriteIndirectArgs(ComputeShader shader, GPUBuffer`1<UInt32> sliceCounts, GPUBuffer`1<RenderSlice> renderSlices, GPUBuffer`1<DrawCallJobData> drawCalls, int drawCallCount, GPUBuffer`1<UInt32> indirectArgs, GPUBuffer`1<UInt32> indirectExtraArgs)
private void ClearBuffer(ComputeShader shader, GPUBuffer`1<UInt32> buffer)
private int GetIterationCount(int count, int threads)
}
public Instancing.GridAllocation : ValueType {
public int StartIndex
public int Capacity
}
public Instancing.GridJobData : ValueType {
public int GridId
public int StartIndex
public int Count
public int Capacity
public float3 MinBounds
public float3 MaxBounds
public bool CanBeFrustumCulled
public bool CanBeDistanceCulled
}
public Instancing.InstancedCommandBufferManager : object {
private CommandBuffer normalCommandBuffer
private CommandBuffer shadowCommandBuffer
public void OnCameraEnabled(Camera camera)
public void OnCameraDisabled(Camera camera)
public void UpdateCameraHook()
}
public Instancing.InstancedCullData : ValueType {
public float3 CullPosition
public float3 BoundsMin
public float3 BoundsMax
public float MinDistance
public float MaxDistance
public int RendererId
public int SliceIndex
public BitFlags Flags
public long VirtualMeshId
public bool IsVisible
public bool HasShadow
public bool HasMesh
public bool LastLOD
public bool get_IsVisible()
public void set_IsVisible(bool value)
public bool get_HasShadow()
public void set_HasShadow(bool value)
public bool get_HasMesh()
public void set_HasMesh(bool value)
public bool get_LastLOD()
public void set_LastLOD(bool value)
}
public Instancing.InstancedCullingManager : object {
public NativeArray`1<int> RenderSliceIndexes
public NativeArray`1<int> PostCullingMeshCounts
}
public Instancing.InstancedEntityConfig : object {
public UInt32 PrefabId
public bool HideInsideNetworkRange
}
public Instancing.InstancedLODState : object {
public Mesh Mesh
public Material[] Materials
public Matrix4x4 LocalToWorld
public ShadowCastingMode CastShadows
public bool RecieveShadows
public LightProbeUsage LightProbes
public int LodLevel
public int TotalLodLevels
public InstancedMeshCategory MeshCategory
public float MinimumDistance
public float MaximumDistance
public void .ctor(Matrix4x4 localToWorld, MeshRenderer renderer, float minDistance, float maxDistance, int lodLevel, int lodLevels, InstancedMeshCategory category)
}
public Instancing.InstancedMeshCategory : Enum {
public int value__
public InstancedMeshCategory BuildingBlock
public InstancedMeshCategory Cliff
public InstancedMeshCategory Other
}
public Instancing.InstancedMeshConfig : object {
public List`1<InstancedLODState> states
}
public Instancing.InstancedMeshData : ValueType {
public InstancedCullData CullData
public float4x4 LocalToWorld
}
public Instancing.InstancedMeshRenderer : object {
private int <RendererId>k__BackingField
private int <DrawCallIndex>k__BackingField
private int <DrawCallCount>k__BackingField
private Mesh <Mesh>k__BackingField
private Material[] <Materials>k__BackingField
private Material[] <MultidrawMaterials>k__BackingField
private ShadowCastingMode <CastShadows>k__BackingField
private bool <RecieveShadows>k__BackingField
private LightProbeUsage <LightProbes>k__BackingField
private int <Verticies>k__BackingField
private int <Triangles>k__BackingField
private int <VertexStart>k__BackingField
private int <IndexStart>k__BackingField
private int <LodLevel>k__BackingField
private int <TotalLodLevels>k__BackingField
private bool <IsLastLod>k__BackingField
private InstancedMeshCategory <MeshCategory>k__BackingField
private MultidrawMeshInfo[] <MultidrawSubmeshes>k__BackingField
private Vector3[] <BoundsPoints>k__BackingField
public int RendererId
public int DrawCallIndex
public int DrawCallCount
public string MeshName
public Mesh Mesh
public Material[] Materials
public Material[] MultidrawMaterials
public ShadowCastingMode CastShadows
public bool RecieveShadows
public LightProbeUsage LightProbes
public int Verticies
public int Triangles
public int VertexStart
public int IndexStart
public int LodLevel
public int TotalLodLevels
public bool IsLastLod
public InstancedMeshCategory MeshCategory
public MultidrawMeshInfo[] MultidrawSubmeshes
public bool HasShadow
public bool HasMesh
public Vector3[] BoundsPoints
public int get_RendererId()
public int get_DrawCallIndex()
public int get_DrawCallCount()
public string get_MeshName()
public Mesh get_Mesh()
public Material[] get_Materials()
private void set_Materials(Material[] value)
public Material[] get_MultidrawMaterials()
private void set_MultidrawMaterials(Material[] value)
public ShadowCastingMode get_CastShadows()
public bool get_RecieveShadows()
public LightProbeUsage get_LightProbes()
public int get_Verticies()
public int get_Triangles()
public int get_VertexStart()
private void set_VertexStart(int value)
public int get_IndexStart()
private void set_IndexStart(int value)
public int get_LodLevel()
public int get_TotalLodLevels()
public bool get_IsLastLod()
public InstancedMeshCategory get_MeshCategory()
public MultidrawMeshInfo[] get_MultidrawSubmeshes()
public bool get_HasShadow()
public bool get_HasMesh()
public Vector3[] get_BoundsPoints()
public void .ctor(int rendererIndex, int drawCallIndex, MeshRenderKey key, Material[] multidrawMaterials, int lodLevel, int lodLevels, InstancedMeshCategory meshCategory, GeometryBuffers buffers)
public void SetMaterials(Material[] materials)
public void SetPlaceholderMaterials(Material[] materials)
public int GetDrawCallIndex(int submesh)
public int GetIndirectArgIndex(int submesh)
public int GetIndirectArgByteIndex(int submesh)
}
public Instancing.InstancedPrefabConfig : object {
public UInt32 PrefabId
public List`1<InstancedMeshConfig> Meshes
public void .ctor(UInt32 prefabId)
}
public Instancing.InstancedPrefabConverter : object {
private InstancedMeshCategory GetMeshCategory(string prefabPath)
public InstancedPrefabConfig ExtractInstancedRenderers(GameObject prefab, UInt32 prefabId, IEnumerable`1<InstancedMeshFilter> instancedFilters)
}
public Instancing.InstancedRendererJobData : ValueType {
public int Id
public int DrawCallCount
public float MinDistance
public float MaxDistance
public ShadowCastingMode ShadowMode
public bool HasMesh
public bool HasShadow
public bool get_HasMesh()
public bool get_HasShadow()
}
internal Instancing.InstancingUtil : object {
public int PositionBufferProperty
public int RenderBufferProperty
public int IndirectExtraArgProperty
public int Param_MeshOverrideBuffer
public int Param_RenderSliceIndexes
public int DrawCallIndexProperty
public int Param_RendererIndex
public int Param_Verticies
public int Param_Triangles
public GlobalKeyword Keyword_Rust_Procedural_Rendering
public int CullingGPUThreads
public float MB(int bytes)
public StringBuilder MemoryUsage(StringBuilder builder, string name, ComputeBuffer buffer)
public StringBuilder MemoryUsage(StringBuilder builder, string name, GraphicsBuffer buffer)
public StringBuilder MemoryUsage(StringBuilder builder, string name, NativeArray`1<T> array, int count)
public StringBuilder MemoryUsage(StringBuilder builder, string name, ICollection`1<T> array)
public int GetIterationCount(int count, int threads)
}
public Instancing.JobInt : ValueType {
private NativeArray`1<int> Array
public int Value
public int get_Value()
public void set_Value(int value)
public JobInt Create()
public void Destroy(JobInt instance)
}
public Instancing.MaterialCache : object {
public Dictionary`2<Material, Material> modifiedMaterials
public Material EnableProceduralInstancing(Material material)
private void RequestTextureStreaming(Material material)
private void RequestMipmap(Material material, string textureName)
public void FreeMemory()
}
public Instancing.MeshGridManager : object {
public NativeArray`1<GridJobData> Grids
private float HalfWorldSize
private float GridSize
private int GridCount
private int normalGridCount
private int shadowGridCount
private int outOfBoundsGrid
private int lastGridId
public void Initialize()
public void OnDestroy()
private void AllocateNativeMemory()
private void FreeNativeMemory()
public int GetPartitionKey(float3 position, bool hasShadow)
public void SetWorldSize(float worldSize)
private void UpdateGridBounds()
private int GetGridId(float3 point)
private float3 GetGridCenter(int gridId)
private Bounds GetGridBounds(int gridId)
public void PrintMemoryUsage(StringBuilder builder)
}
public Instancing.MeshOverrideData : ValueType {
public float4 Color
public bool Equals(MeshOverrideData other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(MeshOverrideData left, MeshOverrideData right)
public bool op_Inequality(MeshOverrideData left, MeshOverrideData right)
}
public Instancing.MeshRenderKey : ValueType {
public Mesh Mesh
public Material[] Materials
public ShadowCastingMode CastShadows
public bool RecieveShadows
public LightProbeUsage LightProbeUsages
public void .ctor(Mesh mesh, Material[] materials, ShadowCastingMode castShadows, bool recieveShadows, LightProbeUsage lightProbes)
public bool Equals(MeshRenderKey other)
public bool Equals(object obj)
public int GetHashCode()
}
public Instancing.MultidrawMeshInfo : ValueType {
public int VertexStart
public int VertexCount
public int IndexStart
}
public Instancing.PreCullingJob : ValueType {
public NativeArray`1<InstancedRendererJobData> Meshes
public int RendererCount
public NativeArray`1<UInt32> CountPerMesh
public NativeArray`1<DrawCallJobData> DrawCalls
public int DrawCallCount
public NativeArray`1<RenderSlice> RenderSlices
public void Execute()
private void CalculateRenderSlices()
}
public Instancing.PrefabRenderKey : ValueType {
public UInt32 PrefabId
public int Grade
public ulong Skin
public void .ctor(UInt32 prefabId, int grade, ulong skin)
public bool Equals(PrefabRenderKey other)
public bool Equals(object obj)
public int GetHashCode()
}
public Instancing.RenderManager : object {
public NativeArray`1<InstancedRendererJobData> RendererArray
public NativeArray`1<UInt32> MeshCountArray
private Dictionary`2<MeshRenderKey, InstancedMeshRenderer> rendererLookup
public List`1<InstancedMeshRenderer> Renderers
public GeometryBuffers GeometryBuffers
private int <TotalMeshCount>k__BackingField
private int <TotalDrawCallCount>k__BackingField
private int initialRendererCapacity
private DrawCallManager drawCallManager
private MaterialCache _materialCache
public int TotalMeshCount
public int TotalDrawCallCount
public int RendererCount
public int get_TotalMeshCount()
private void set_TotalMeshCount(int value)
public int get_TotalDrawCallCount()
private void set_TotalDrawCallCount(int value)
public int get_RendererCount()
public void .ctor(DrawCallManager drawCalls, GeometryBuffers geometryBuffers, MaterialCache materialCache)
public void Initialize()
public void OnDestroy()
private void AllocateNativeMemory()
private void FreeNativeMemory()
public void OnMeshAdded(int rendererId)
public void OnMeshRemoved(int rendererId)
public Bounds CalculateMeshBounds(int meshId, Matrix4x4 localToWorld)
public bool DoesRendererHaveShadow(int meshId)
public bool DoesRendererHaveMesh(int rendererId)
public bool IsLastLOD(int rendererId)
public int GetRendererId(InstancedLODState lod)
public float GetMinDistance(int rendererId)
public float GetMaxDistance(int rendererId)
public Mesh GetMeshForRenderer(int rendererId)
private InstancedMeshRenderer GetRenderer(InstancedLODState lod)
private InstancedMeshRenderer RegisterRenderer(InstancedLODState lod)
private void EnsureJobDataCapacity()
public void PrintMemoryUsage(StringBuilder builder)
private Material <RegisterRenderer>b__34_0(Material x)
}
public Instancing.RenderSlice : ValueType {
public UInt32 StartIndex
public UInt32 Length
}
public Instancing.RenderUpdate : ValueType {
public UInt32 PrefabId
public NetworkableId NetworkId
public int Grade
public ulong Skin
public int ModelState
public Vector3 Position
public Quaternion Rotation
public Color CustomColor
public int CustomColorIndex
public bool IsGlobalUpdate
public bool InsideNetworkRange
}
public Instancing.TextureAtlasScheduler : object {
public TextureAtlasScheduler Instanced
private Dictionary`2<int, TextureAtlas> textureAtlases
private int AddTexture(TextureAtlas atlas, Texture texture)
private void UpdateTexture(TextureAtlas atlas, Texture texture, int index)
public int AddTextureToAtlas(Texture texture)
public void ReplaceTextureInAtlas(Texture texture, int index)
private TextureAtlas GetOrCreateAtlas(int width, int height)
private int GetResolutionKey(int xSize, int ySize)
}
public Instancing.VirtualMeshScheduler : object {
public VirtualMeshScheduler Instance
}
public Instancing.WorkshopSkinScheduler : object {
private Dictionary`2<ulong, SkinData> skinLookup
private Dictionary`2<ulong, Skinnable> skinnableLookup
public SkinTexture[] GetTextures(Skin skinDef, ulong skinId)
private SkinnableData GetOrCreateSkinnable(Skin skinDef)
private SkinData InitializeSkin(Skin skinDef, ulong skinId)
private string FindSkinTexturePath(ulong workshopSkin)
private void LoadTextureAsync(string path, int resolution, int textureIndex)
}
public InstancingConfigComponent : PrefabAttribute {
public bool DisableInstancing
protected Type GetIndexedType()
}
public InstantCameraTool : HeldEntity {
public ItemDefinition photoItem
public GameObjectRef screenshotEffect
public SoundDefinition startPhotoSoundDef
public SoundDefinition finishPhotoSoundDef
public int resolutionX
public int resolutionY
public int quality
public float cooldownSeconds
public TimeSince _sinceLastPhoto
private bool hasSentAchievement
public string PhotographPlayerAchievement
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void TakePhoto(RPCMessage msg)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
}
public InstrumentDebugInput : MonoBehaviour {
public InstrumentKeyController KeyController
public KeySet Note
public float Frequency
public float StopAfter
public SoundDefinition OverrideDefinition
}
public InstrumentIKController : MonoBehaviour {
public Vector3 HitRotationVector
public Transform[] LeftHandIkTargets
public Transform[] LeftHandIKTargetHitRotations
public Transform[] RightHandIkTargets
public Transform[] RightHandIKTargetHitRotations
public Transform[] RightFootIkTargets
public AnimationCurve HandHeightCurve
public float HandHeightMultiplier
public float HandMoveLerpSpeed
public bool DebugHitRotation
public AnimationCurve HandHitCurve
public float NoteHitTime
public float BodyLookWeight
public float HeadLookWeight
public float LookWeightLimit
public bool HoldHandsAtPlay
}
public InstrumentKeyController : MonoBehaviour {
public float DEFAULT_NOTE_VELOCITY
public NoteBindingCollection Bindings
public NoteBinding[] NoteBindings
public Transform[] NoteSoundPositions
public InstrumentIKController IKController
public Transform LeftHandProp
public Transform RightHandProp
public Animator InstrumentAnimator
public BaseEntity RPCHandler
public UInt32 overrideAchievementId
private bool <PlayedNoteThisFrame>k__BackingField
private string ALL_NOTES_STATNAME
public bool PlayedNoteThisFrame
public bool get_PlayedNoteThisFrame()
private void set_PlayedNoteThisFrame(bool value)
public void ProcessServerPlayedNote(BasePlayer forPlayer)
}
public InstrumentTool : HeldEntity {
public InstrumentKeyController KeyController
public SoundDefinition DeploySound
public Vector2 PitchClamp
public bool UseAnimationSlotEvents
public Transform MuzzleT
public bool UsableByAutoTurrets
private NoteData lastPlayedTurretData
public Transform MuzzleTransform
public bool IsUsableByTurret
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Transform get_MuzzleTransform()
private void Server_PlayNote(RPCMessage msg)
private void Server_StopNote(RPCMessage msg)
public void ServerUse()
private void StopAfterTime()
public bool get_IsUsableByTurret()
public bool IsInstrument()
}
public InstrumentToolGuitar : InstrumentTool {
public Transform InUseAligner
public Transform DeployAligner
public string DeployBone
}
public InstrumentViewmodel : MonoBehaviour {
public Animator ViewAnimator
public bool UpdateA
public bool UpdateB
public bool UpdateC
public bool UpdateD
public bool UpdateE
public bool UpdateF
public bool UpdateG
public bool UpdateRecentlyPlayed
public bool UpdatePlayedNoteTrigger
public bool UseTriggers
private int note_a
private int note_b
private int note_c
private int note_d
private int note_e
private int note_f
private int note_g
private int recentlyPlayedHash
private int playedNoteHash
public void UpdateSlots(AnimationSlot currentSlot, bool recentlyPlayed, bool playedNoteThisFrame)
private void UpdateState(int param, bool state)
}
public InventoryUI : MonoBehaviour {
public GameObject ContactsButton
public GameObject ClanButton
}
public InvisibleVendingMachine : NPCVendingMachine {
public GameObjectRef buyEffect
public NPCVendingOrderManifest vmoManifest
public NPCShopKeeper GetNPCShopKeeper()
public void KeeperLookAt(Vector3 pos)
public bool HasVendingSounds()
public float GetBuyDuration()
public void CompletePendingOrder()
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void Save(SaveInfo info)
public void ServerInit()
public void Load(LoadInfo info)
}
public InvokeSpammer : MonoBehaviour {
public int InvokeMilliseconds
public float RepeatTime
private void Start()
private void TestInvoke()
}
public IOConfig`1 : UIDialog {
public RustInput input
public float minValue
public float maxValue
}
public IOEntity : DecayEntity {
public Transform debugOrigin
public ItemDefinition sourceItem
public int lastResetIndex
public float frameBudgetElectricHighPriorityMs
public float frameBudgetElectricLowPriorityMs
public float frameBudgetFluidMs
public float frameBudgetKineticMs
public float frameBudgetGenericMs
public float frameBudgetIndustrialMs
public float responsetime
public int backtracking
public bool debugBudget
public float debugBudgetThreshold
public Flags Flag_ShortCircuit
public Flags Flag_HasPower
public IOSlot[] inputs
public IOSlot[] outputs
public IOType ioType
public Dictionary`2<QueueType, Queue`1<IOEntity>> _processQueues
public Dictionary`2<QueueType, string> _processQueueProfilerString
private List`1<FrameTiming> timings
public int cachedOutputsUsed
public int lastPassthroughEnergy
public int lastEnergy
public int currentEnergy
private int changedCount
private float lastChangeTime
public float lastUpdateTime
public int lastUpdateBlockedFrame
public bool ensureOutputsUpdated
public int MaxContainerSourceCount
private List`1<Collider> spawnedColliders
public bool IsGravitySource
protected bool PreventDuplicatesInQueue
private bool HasBlockedUpdatedOutputsThisFrame
public bool BlockFluidDraining
protected float LiquidPassthroughGravityThreshold
protected bool DisregardGravityRestrictionsOnLiquid
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public string GetDisplayName()
public bool IsRootEntity()
public bool get_IsGravitySource()
public IOEntity FindGravitySource(Vector3& worldHandlePosition, int depth, bool ignoreSelf)
public void SetFuelType(ItemDefinition def, IOEntity source)
public bool WantsPower(int inputIndex)
public bool AllowWireConnections()
public bool WantsPassthroughPower()
public int ConsumptionAmount()
public bool ShouldDrainBattery(IOEntity battery)
public bool ShouldBlockCircuit(IOEntity battery)
public int MaximalPowerOutput()
public bool AllowDrainFrom(int outputSlot)
public QueueType GetQueueType()
public float GetFrameBudgetForQueue(QueueType type)
public bool IsPowered()
public bool IsConnectedToAnySlot(IOEntity entity, int slot, int depth, bool defaultReturn)
public bool IsConnectedTo(IOEntity entity, int slot, int depth, bool defaultReturn)
public bool IsConnectedTo(IOEntity entity, int depth, bool defaultReturn)
protected bool ConsiderConnectedTo(IOEntity entity)
private void Server_RequestData(RPCMessage msg)
public void SendAdditionalData(BasePlayer player, int slot, bool input)
protected int GetPassthroughAmountForAnySlot(int slot, bool isInputSlot)
public void ProcessQueue()
public void DebugQueue()
public void ResetIOState()
public void Init()
internal void DoServerDestroy()
public void ClearConnections()
public void Shutdown()
public void MarkDirtyForceUpdateOutputs()
public void UpdateUsedOutputs()
public void MarkDirty()
public int DesiredPower(int inputIndex)
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
public int GetCurrentEnergy()
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void TouchInternal()
protected bool get_PreventDuplicatesInQueue()
public void UpdateFromInput(int inputAmount, int inputSlot)
public void TouchIOState()
public void SendIONetworkUpdate()
public bool IsFlickering()
public void IOStateChanged(int inputAmount, int inputSlot)
public void OnCircuitChanged(bool forceUpdate)
public void SendChangedToRoot(bool forceUpdate)
public void SendChangedToRootRecursive(bool forceUpdate, List`1& existing)
public void NotifyIndustrialNetworkChanged()
private void NotifyIndustrialNetworkChanged(List`1<IOEntity> existing, bool input, int maxDepth)
protected void OnIndustrialNetworkChanged()
public bool ShouldUpdateOutputs()
private bool get_HasBlockedUpdatedOutputsThisFrame()
public void UpdateOutputs()
public void Spawn()
public void PostServerLoad()
public void PostMapEntitySpawn()
public void Save(SaveInfo info)
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public bool get_BlockFluidDraining()
public bool Disconnect(int index, bool isInput)
public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex)
public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex, List`1<Vector3> points, List`1<float> slackLevels, LineAnchor[] lineAnchors, WireColour colour)
public void FindContainerSource(List`1<ContainerInputOutput> found, int depth, bool input, List`1<IOEntity> ignoreList, int parentId, int stackSize)
protected float get_LiquidPassthroughGravityThreshold()
protected bool get_DisregardGravityRestrictionsOnLiquid()
public bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement)
public void Load(LoadInfo info)
public int GetConnectedInputCount()
public int GetConnectedOutputCount()
public bool HasConnections()
public void DestroyShared()
public void RefreshIndustrialPreventBuilding()
private void ClearIndustrialPreventBuilding()
internal int <FindContainerSource>g__GetExistingCount|107_0(IIndustrialStorage storage, <>c__DisplayClass107_0& )
}
public IOEntityInformationPanel : ItemInformationPanel {
public ItemTextValue requiredPowerDisplay
public ItemTextValue requiredFluidDisplay
public ItemTextValue generatedPowerDisplay
public ItemTextValue capacityDisplay
public ItemTextValue chargeDisplay
public ItemTextValue rangeDisplay
}
public IOEntityMovementChecker : FacepunchBehaviour {
private IOEntity ioEntity
private Vector3 prevPos
private float MAX_MOVE
private float MAX_MOVE_SQR
protected void Awake()
protected void OnEnable()
protected void OnDisable()
private void CheckPosition()
}
public IOEntityUISlotEntry : MonoBehaviour {
public RawImage icon
public Text leftText
public Text rightText
}
public IOnParentDestroying {
public void OnParentDestroying()
}
public IOnParentSpawning {
public void OnParentSpawning()
}
public IOnPostNetworkUpdate {
public void OnPostNetworkUpdate(BaseEntity entity)
}
public IOnSendNetworkUpdate {
public void OnSendNetworkUpdate(BaseEntity entity)
}
public IPAddressJsonConverter : JsonConverter {
public bool CanConvert(Type objectType)
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
}
public IPet {
public bool IsPet()
public void SetPetOwner(BasePlayer player)
public bool IsOwnedBy(BasePlayer player)
public bool IssuePetCommand(PetCommandType cmd, int param, Nullable`1<Ray> ray)
}
public IPoolVehicle {
public void OnPoolDestroyed()
public void WakeUp()
}
public IPosLerpTarget {
public float GetInterpolationInertia()
public Vector3 GetNetworkPosition()
public Quaternion GetNetworkRotation()
public void SetNetworkPosition(Vector3 pos)
public void SetNetworkRotation(Quaternion rot)
public void DrawInterpolationState(Segment<TransformSnapshot> segment, List`1<TransformSnapshot> entries)
public void LerpIdleDisable()
}
public IRemoteControllable {
public bool RequiresMouse
public float MaxRange
public RemoteControllableControls RequiredControls
public Nullable`1<CameraViewerId> ControllingViewerId
public bool CanPing
public Transform GetEyes()
public float GetFovScale()
public BaseEntity GetEnt()
public string GetIdentifier()
public float Health()
public float MaxHealth()
public void UpdateIdentifier(string newID, bool clientSend)
public void RCSetup()
public void RCShutdown()
public bool CanControl(ulong playerID)
public bool get_RequiresMouse()
public float get_MaxRange()
public RemoteControllableControls get_RequiredControls()
public Nullable`1<CameraViewerId> get_ControllingViewerId()
public void UserInput(InputState inputState, CameraViewerId viewerID)
public bool InitializeControl(CameraViewerId viewerID)
public void StopControl(CameraViewerId viewerID)
public bool get_CanPing()
}
public IRFObject {
public Vector3 GetPosition()
public float GetMaxRange()
public void RFSignalUpdate(bool on)
public int GetFrequency()
}
public IronsightAimPoint : MonoBehaviour {
public Transform targetPoint
private void OnDrawGizmos()
private void DrawArrow(Vector3 start, Vector3 end, float arrowLength)
}
public IronSightOverride : MonoBehaviour {
public IronsightAimPoint aimPoint
public float fieldOfViewOffset
public float zoomFactor
public float fovBias
}
public IronSights : MonoBehaviour {
public IronsightAimPoint aimPoint
public float fieldOfViewOffset
public float zoomFactor
public float introSpeed
public AnimationCurve introCurve
public float outroSpeed
public AnimationCurve outroCurve
public SoundDefinition upSound
public SoundDefinition downSound
public IronSightOverride ironsightsOverride
public bool processUltrawideOffset
}
public IsBlindedAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public ISignage {
public Vector2i TextureSize
public int TextureCount
public NetworkableId NetworkID
public Type FileType
public bool CanUpdateSign(BasePlayer player)
public float Distance(Vector3 position)
public Vector2i get_TextureSize()
public int get_TextureCount()
public UInt32[] GetTextureCRCs()
public NetworkableId get_NetworkID()
public Type get_FileType()
public void SetTextureCRCs(UInt32[] crcs)
}
public IsMountedAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public ISoundBudgetedUpdate {
public void DoUpdate()
public bool IsSyncedToParent()
}
public ISpawnGroup {
public int currentPopulation
public void Clear()
public void Fill()
public void SpawnInitial()
public void SpawnRepeating()
public int get_currentPopulation()
}
public ISpawnPointUser {
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
}
public ISplashable {
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
}
public ISubscribable {
public bool AddSubscription(ulong steamId)
public bool RemoveSubscription(ulong steamId)
public bool HasSubscription(ulong steamId)
}
public IsVisibleAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public Item : object {
private string DefaultArmourBreakEffectPath
public float _condition
public float _maxCondition
public ItemDefinition info
public ItemId uid
public bool dirty
public int amount
public int position
public float busyTime
public float removeTime
public float fuel
public bool isServer
public InstanceData instanceData
public ulong skin
public string name
public string streamerName
public string text
private Nullable`1<int> <ammoCount>k__BackingField
public float cookTimeLeft
private Action`1<Item> OnDirty
public Flag flags
public ItemContainer contents
public ItemContainer parent
private EntityRef worldEnt
private EntityRef heldEntity
private Action`2<Item, float> onCycle
public float condition
public float maxCondition
public float maxConditionNormalized
public float conditionNormalized
public bool hasCondition
public bool isBroken
public Nullable`1<int> ammoCount
public int despawnMultiplier
public ItemDefinition blueprintTargetDef
public int blueprintTarget
public int blueprintAmount
public Item parentItem
public float temperature
public TraitFlag Traits
public void set_condition(float value)
public float get_condition()
public void set_maxCondition(float value)
public float get_maxCondition()
public float get_maxConditionNormalized()
public float get_conditionNormalized()
public void set_conditionNormalized(float value)
public bool get_hasCondition()
public bool get_isBroken()
public void LoseCondition(float amount)
public void RepairCondition(float amount)
public void DoRepair(float maxLossFraction)
public ItemContainer GetRootContainer()
public void OnBroken()
public Nullable`1<int> get_ammoCount()
public void set_ammoCount(Nullable`1<int> value)
public string GetName(Nullable`1<bool> streamerModeOverride)
public int get_despawnMultiplier()
public ItemDefinition get_blueprintTargetDef()
public int get_blueprintTarget()
public void set_blueprintTarget(int value)
public int get_blueprintAmount()
public void set_blueprintAmount(int value)
public bool IsBlueprint()
public void add_OnDirty(Action`1<Item> value)
public void remove_OnDirty(Action`1<Item> value)
public bool HasFlag(Flag f)
public void SetFlag(Flag f, bool b)
public bool IsOn()
public bool IsOnFire()
public bool IsCooking()
public bool IsLocked()
public Item get_parentItem()
public void MarkDirty()
public void OnChanged()
public void CollectedForCrafting(BasePlayer crafter)
public void ReturnedFromCancelledCraft(BasePlayer crafter)
public void Initialize(ItemDefinition template)
public void OnItemCreated()
public void OnVirginSpawn()
public float GetDespawnDuration()
public void RemoveFromWorld()
public void OnRemovedFromWorld()
public void RemoveFromContainer()
public bool DoItemSlotsConflict(Item other)
public void SetParent(ItemContainer target)
public void RecalulateParentEntity(bool children)
public void OnAttacked(HitInfo hitInfo)
public BaseEntity GetEntityOwner()
public bool IsChildContainer(ItemContainer c)
public bool CanMoveTo(ItemContainer newcontainer, int iTargetPos)
public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos, bool allowStack, bool ignoreStackLimit, BasePlayer sourcePlayer, bool allowSwap)
private void RemoveConflictingSlots(ItemContainer container, BaseEntity entityOwner, BasePlayer sourcePlayer)
public BaseEntity CreateWorldObject(Vector3 pos, Quaternion rotation, BaseEntity parentEnt, UInt32 parentBone)
public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation)
public BaseEntity DropAndTossUpwards(Vector3 vPos, float force)
public bool IsBusy()
public void BusyFor(float fTime)
public bool IsRemoved()
public void Remove(float fTime)
public void DoRemove()
public void SwitchOnOff(bool bNewState)
public void LockUnlock(bool bNewState)
public float get_temperature()
public BasePlayer GetOwnerPlayer()
public bool IsBackpack()
public int GetChildItemCount()
public int GetItemVolume()
public Item SplitItem(int split_Amount)
public void UnloadAmmo()
public bool CanBeHeld()
public bool CanStack(Item item)
public bool IsValid()
public bool IsDroppedInWorld(bool serverside)
public void SetWorldEntity(BaseEntity ent)
public void OnMovedToWorld()
public BaseEntity GetWorldEntity()
public void SetHeldEntity(BaseEntity ent)
public BaseEntity GetHeldEntity()
public void add_onCycle(Action`2<Item, float> value)
public void remove_onCycle(Action`2<Item, float> value)
public void OnCycle(float delta)
public void ServerCommand(string command, BasePlayer player)
public void UseItem(int amountToConsume)
public bool HasAmmo(AmmoTypes ammoType)
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public int GetAmmoAmount(AmmoTypes ammoType)
public string ToString()
public Item FindItem(ItemId iUID)
public int MaxStackable()
public TraitFlag get_Traits()
public GameObjectRef GetWorldModel()
public Item Save(bool bIncludeContainer, bool bIncludeOwners)
public void Load(Item load)
}
public ItemAmount : object {
public ItemDefinition itemDef
public float amount
public float startAmount
public bool ignoreInTutorial
public bool isBP
public int itemid
public void .ctor(ItemDefinition item, float amt)
public int get_itemid()
public float GetAmount()
public void OnAfterDeserialize()
public void OnBeforeSerialize()
public ItemAmountList SerialiseList(List`1<ItemAmount> list)
public void DeserialiseList(List`1<ItemAmount> target, ItemAmountList source)
}
public ItemAmountRandom : object {
public ItemDefinition itemDef
public AnimationCurve amount
public int RandomAmount()
}
public ItemAmountRanged : ItemAmount {
public float maxAmount
public void OnAfterDeserialize()
public void .ctor(ItemDefinition item, float amt, float max)
public float GetAmount()
}
public ItemBasedFlowRestrictor : IOEntity {
public ItemDefinition passthroughItem
public ContentsType allowedContents
public int maxStackSize
public int numSlots
public string lootPanelName
public Flags HasPassthrough
public Flags Sparks
public float passthroughItemConditionLossPerSec
public SoundDefinition openSound
public SoundDefinition closeSound
public ItemContainer inventory
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public bool HasPassthroughItem()
public void TickPassthroughItem()
public void ServerInit()
public void PreServerLoad()
public void CreateInventory(bool giveUID)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool added)
private void RPC_OpenLoot(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
}
public ItemBlueprint : MonoBehaviour {
public List`1<ItemAmount> ingredients
public List`1<ItemDefinition> additionalUnlocks
public bool defaultBlueprint
public bool userCraftable
public bool isResearchable
public bool forceShowInConveyorFilter
public Rarity rarity
public int workbenchLevelRequired
public int scrapRequired
public int scrapFromRecycle
public bool NeedsSteamItem
public int blueprintStackSize
public float time
public int amountToCreate
public string UnlockAchievment
public string RecycleStat
public ItemDefinition targetItem
public bool NeedsSteamDLC
public ItemDefinition get_targetItem()
public bool get_NeedsSteamDLC()
}
public ItemButtonTools : MonoBehaviour {
public Image image
public ItemDefinition itemDef
public void GiveSelf(int amount)
public void GiveArmed()
public void GiveBlueprint()
}
public ItemCategory : Enum {
public int value__
public ItemCategory Weapon
public ItemCategory Construction
public ItemCategory Items
public ItemCategory Resources
public ItemCategory Attire
public ItemCategory Tool
public ItemCategory Medical
public ItemCategory Food
public ItemCategory Ammunition
public ItemCategory Traps
public ItemCategory Misc
public ItemCategory All
public ItemCategory Common
public ItemCategory Component
public ItemCategory Search
public ItemCategory Favourite
public ItemCategory Electrical
public ItemCategory Fun
}
public ItemContainer : object {
public int BackpackSlotIndex
public Flag flags
public ContentsType allowedContents
public ItemDefinition[] onlyAllowedItems
public HashSet`1<ItemDefinition> blockedItems
public List`1<ItemSlot> availableSlots
public int capacity
public ItemContainerId uid
public bool dirty
public List`1<Item> itemList
public float temperature
public Item parent
public BasePlayer playerOwner
public BaseEntity entityOwner
public bool isServer
public int maxStackSize
public int containerVolume
private Action onDirty
public Func`3<Item, int, bool> canAcceptItem
public Func`3<Item, int, bool> slotIsReserved
public Action`2<Item, bool> onItemAddedRemoved
public Action`2<Item, int> onItemAddedToStack
public Action`2<Item, int> onItemRemovedFromStack
public Action`1<Item> onPreItemRemove
public bool HasLimitedAllowedItems
public Vector3 dropPosition
public Vector3 dropVelocity
public bool HasFlag(Flag f)
public void SetFlag(Flag f, bool b)
public bool IsLocked()
public bool PlayerItemInputBlocked()
public bool get_HasLimitedAllowedItems()
public void add_onDirty(Action value)
public void remove_onDirty(Action value)
public float GetTemperature(int slot)
public void ServerInitialize(Item parentItem, int iMaxCapacity)
public void GiveUID()
public void MarkDirty()
public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, float destroyPercent)
public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, ItemContainer[] containers)
public BaseEntity GetEntityOwner(bool returnHeldEntity)
public void OnChanged()
public Item FindItemByUID(ItemId iUID)
public bool IsFull()
public bool HasSpaceFor(Item item)
public bool IsEmpty()
public bool HasPartialStack(Item toStack, Int32& slot)
public bool HasPartialStack(Item toStack)
public bool CanAccept(Item item)
public int GetMaxTransferAmount(ItemDefinition def)
public void SetOnlyAllowedItem(ItemDefinition def)
public void SetOnlyAllowedItems(ItemDefinition[] defs)
public void SetBlacklist(ItemDefinition[] defs)
public bool Insert(Item item)
public bool SlotTaken(Item item, int i)
public Item GetSlot(int slot)
public bool QuickIndustrialPreCheck(Item toTransfer, Vector2i range, Int32& foundSlot)
public bool FindPosition(Item item)
public bool HasItem(ItemDefinition searchFor)
public void SetLocked(bool isLocked)
public bool Remove(Item item)
public void Clear()
public void Kill()
public int GetAmount(int itemid, bool onlyUsableAmounts)
public int GetOkConditionAmount(int itemid, bool onlyUsableAmounts)
public Item FindItemByItemID(int itemid)
public Item FindItemByItemName(string name)
public Item FindBySubEntityID(NetworkableId subEntityID)
public List`1<Item> FindItemsByItemID(int itemid)
public ItemContainer Save(bool bIncludeContainer)
public void Load(ItemContainer container)
public BasePlayer GetOwnerPlayer()
public int ContainerMaxStackSize()
public int Take(List`1<Item> collect, int itemid, int iAmount)
public bool TryTakeOne(int itemid, Item& item)
public bool GiveItem(Item item, ItemContainer container)
public Vector3 get_dropPosition()
public Vector3 get_dropVelocity()
public void OnCycle(float delta)
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public bool HasAmmo(AmmoTypes ammoType)
public int GetAmmoAmount(ItemDefinition specificAmmo)
public int GetAmmoAmount(AmmoTypes ammoType)
public int TotalItemAmount()
public bool HasAny(ItemDefinition itemDef)
public int GetTotalItemAmount(Item item, int slotStartInclusive, int slotEndInclusive)
public int TotalItemAmount(ItemDefinition itemDef)
public int GetTotalCategoryAmount(ItemCategory category, int slotStartInclusive, int slotEndInclusive)
public void AddItem(ItemDefinition itemToCreate, int amount, ulong skin, LimitStack limitStack)
public void OnMovedToWorld()
public void OnRemovedFromWorld()
public UInt32 ContentsHash()
public ItemContainer FindContainer(ItemContainerId id)
public CanAcceptResult CanAcceptItem(Item item, int targetPos)
public bool HasBackpackItem()
}
public ItemContainerSource : MonoBehaviour {
public ItemContainer GetItemContainer()
}
public ItemCorpseOverride : MonoBehaviour {
public GameObjectRef MaleCorpse
public GameObjectRef FemaleCorpse
public bool BlockWearableCopy
}
public ItemCrafter : EntityComponent`1<BasePlayer> {
public List`1<ItemContainer> containers
public LinkedList`1<ItemCraftTask> queue
public int taskUID
public BasePlayer owner
public void AddContainer(ItemContainer container)
public float GetScaledDuration(ItemBlueprint bp, float workbenchLevel, bool isInTutorial)
public void ServerUpdate(float delta)
public void CollectIngredient(int item, int amount, List`1<Item> collect)
public void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player)
public bool CraftItem(ItemBlueprint bp, BasePlayer owner, InstanceData instanceData, int amount, int skinID, Item fromTempBlueprint, bool free)
public void FinishCrafting(ItemCraftTask task)
public bool CancelTask(int iID, bool ReturnItems)
public bool CancelBlueprint(int itemid)
public void CancelAll(bool returnItems)
private bool DoesHaveOKConditionItem(int item, int iAmount)
public bool DoesHaveUsableItem(int item, int iAmount)
public bool CanCraft(ItemBlueprint bp, int amount, bool free)
public bool CanCraft(ItemDefinition def, int amount, bool free)
public bool FastTrackTask(int taskID)
public ItemCrafter Save()
public void Load(ItemCrafter proto)
public void SendToOwner()
internal List`1<Item> <Save>g__SaveItems|19_0(List`1<Item> items)
internal List`1<Item> <Load>g__LoadItems|20_0(List`1<Item> itemProtos)
}
public ItemCraftTask : object {
public ItemBlueprint blueprint
public float endTime
public int taskUID
public bool cancelled
public InstanceData instanceData
public int amount
public int skinID
public List`1<Item> takenItems
public int numCrafted
public float conditionScale
public BaseEntity workbenchEntity
}
public ItemDefinition : MonoBehaviour {
public int itemid
public string shortname
public Phrase displayName
public Phrase displayDescription
public Sprite iconSprite
public ItemCategory category
public ItemSelectionPanel selectionPanel
public int maxDraggable
public ContentsType itemType
public AmountType amountType
public ItemSlot occupySlots
public int stackable
public int volume
public bool quickDespawn
public bool blockStealingInSafeZone
public TutorialItemAllowance tutorialAllowance
public Rarity rarity
public Rarity despawnRarity
public bool spawnAsBlueprint
public SoundDefinition inventoryGrabSound
public SoundDefinition inventoryDropSound
public SoundDefinition physImpactSoundDef
public Condition condition
public bool hidden
public Flag flags
public bool hideSelectedPanel
public SteamInventoryItem steamItem
public SteamDLCItem steamDlc
public ItemDefinition Parent
public GameObjectRef worldModelPrefab
public OverrideWorldModel[] worldModelOverrides
public bool treatAsComponentForRepairs
public bool AlignWorldModelOnDrop
public Vector3 WorldModelDropOffset
public ItemDefinition isRedirectOf
public RedirectVendingBehaviour redirectVendingBehaviour
public ItemMod[] itemMods
public TraitFlag Traits
public Skin[] skins
public IPlayerItemDefinition[] _skins2
private float _worldModelMass
public GameObject panel
private ItemModWearable <ItemModWearable>k__BackingField
private ItemModBurnable <ItemModBurnable>k__BackingField
private ItemModCookable <ItemModCookable>k__BackingField
private bool <isHoldable>k__BackingField
private bool <isUsable>k__BackingField
private bool <CraftableWithSkin>k__BackingField
public ItemDefinition[] Children
public IPlayerItemDefinition[] skins2
public ItemBlueprint Blueprint
public int craftingStackable
public bool isWearable
public ItemModWearable ItemModWearable
public ItemModBurnable ItemModBurnable
public ItemModCookable ItemModCookable
public bool isHoldable
public bool isUsable
public bool HasSkins
public bool CraftableWithSkin
public IPlayerItemDefinition[] get_skins2()
public void InvalidateWorkshopSkinCache()
public ulong FindSkin(int itemID, int skinID)
public float GetWorldModelMass()
public ItemBlueprint get_Blueprint()
public int get_craftingStackable()
public bool HasFlag(Flag f)
public void Initialize(List`1<ItemDefinition> itemList)
public bool get_isWearable()
public ItemModWearable get_ItemModWearable()
public void set_ItemModWearable(ItemModWearable value)
public ItemModBurnable get_ItemModBurnable()
public void set_ItemModBurnable(ItemModBurnable value)
public ItemModCookable get_ItemModCookable()
public void set_ItemModCookable(ItemModCookable value)
public bool get_isHoldable()
private void set_isHoldable(bool value)
public bool get_isUsable()
private void set_isUsable(bool value)
public bool get_HasSkins()
public bool get_CraftableWithSkin()
private void set_CraftableWithSkin(bool value)
public GameObjectRef GetWorldModel(int amount)
public int GetWorldModelIndex(int amount)
private bool <Initialize>b__57_0(ItemDefinition x)
}
public ItemDropCommand : MonoBehaviour {
public string command
}
public ItemEventFlag : MonoBehaviour {
public Flag flag
public UnityEvent onEnabled
public UnityEvent onDisable
internal bool firstRun
internal bool lastState
public void OnItemUpdate(Item item)
}
public ItemFootstepSounds : MonoBehaviour {
public bool setEffectFolder
public string effectFolder
public SoundDefinition accentSound
}
public ItemIcon : BaseMonoBehaviour {
private Color backgroundColor
public Color selectedBackgroundColor
public float unoccupiedAlpha
public Color unoccupiedColor
public ItemContainerSource containerSource
public int slotOffset
public int slot
public bool setSlotFromSiblingIndex
public GameObject slots
public CanvasGroup iconContents
public CanvasGroup canvasGroup
public Image iconImage
public Image underlayImage
public Text amountText
public Text hoverText
public Image hoverOutline
public Image cornerIcon
public Image lockedImage
public Image progressImage
public Image backgroundImage
public Image backgroundUnderlayImage
public Image progressPanel
public Sprite emptySlotBackgroundSprite
public CanvasGroup conditionObject
public Image conditionFill
public Image maxConditionFill
public GameObject lightEnabled
public GameObject burstEnabled
public bool allowSelection
public bool allowDropping
public bool allowMove
public bool showCountDropShadow
public Item item
public bool invalidSlot
public SoundDefinition hoverSound
public void OnPointerClick(PointerEventData eventData)
public void OnPointerEnter(PointerEventData eventData)
public void OnPointerExit(PointerEventData eventData)
}
public ItemInformationPanel : MonoBehaviour {
public bool ForceHidden(ItemDefinition info)
public bool EligableForDisplay(ItemDefinition info)
public void SetupForItem(ItemDefinition info, Item item)
}
public ItemListTools : MonoBehaviour {
public GameObject categoryButton
public GameObject itemButton
public RustInput searchInputText
internal Button lastCategory
private IOrderedEnumerable`1<ItemDefinition> currentItems
private IOrderedEnumerable`1<ItemDefinition> allItems
public void OnPanelOpened()
private void OnOpenDevTools()
private void CacheAllItems()
public void Refresh()
private void RebuildCategories()
private void SwitchItemCategory(ItemDefinition[] defs)
public void FilterItems(string searchText)
}
public ItemManager : object {
public List`1<ItemDefinition> itemList
public Dictionary`2<int, ItemDefinition> itemDictionary
public Dictionary`2<string, ItemDefinition> itemDictionaryByName
public List`1<ItemBlueprint> bpList
public Int32[] defaultBlueprints
public ItemDefinition blueprintBaseDef
private List`1<ItemRemove> ItemRemoves
public void InvalidateWorkshopSkinCache()
public void Initialize()
public Item CreateByName(string strName, int iAmount, ulong skin)
public Item CreateByPartialName(string strName, int iAmount, ulong skin)
public ItemDefinition FindDefinitionByPartialName(string strName, int iAmount, ulong skin)
public Item CreateByItemID(int itemID, int iAmount, ulong skin)
public Item Create(ItemDefinition template, int iAmount, ulong skin)
private void TrySkinChangeItem(ItemDefinition& template, UInt64& skinId)
public Item Load(Item load, Item created, bool isServer)
public ItemDefinition FindItemDefinition(int itemID)
public ItemDefinition FindItemDefinition(string shortName)
public ItemBlueprint FindBlueprint(ItemDefinition item)
public List`1<ItemDefinition> GetItemDefinitions()
public List`1<ItemBlueprint> GetBlueprints()
public void DoRemoves()
public void Heartbeat()
public void RemoveItem(Item item, float fTime)
}
public ItemMod : MonoBehaviour {
protected ItemMod[] siblingMods
public void ModInit()
public void OnItemCreated(Item item)
public void OnVirginItem(Item item)
public void ServerCommand(Item item, string command, BasePlayer player)
public void DoAction(Item item, BasePlayer player)
public void OnRemove(Item item)
public void OnParentChanged(Item item)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
public void OnAttacked(Item item, HitInfo info)
public void OnChanged(Item item)
public bool CanDoAction(Item item, BasePlayer player)
public bool Passes(Item item)
public void OnRemovedFromWorld(Item item)
public void OnMovedToWorld(Item item)
}
public ItemModActionChange : ItemMod {
public ItemMod[] actions
public void OnChanged(Item item)
private void OnValidate()
}
public ItemModActionContainerChange : ItemMod {
public ItemMod[] actions
public void OnParentChanged(Item item)
private void OnValidate()
}
public ItemModAlterCondition : ItemMod {
public float conditionChange
public void DoAction(Item item, BasePlayer player)
}
public ItemModAnimalEquipment : ItemMod {
public Flags WearableFlag
public bool hideHair
public ProtectionProperties animalProtection
public ProtectionProperties riderProtection
public int additionalInventorySlots
public float speedModifier
public float staminaUseModifier
public SlotType slot
}
public ItemModAssociatedEntity`1 : ItemMod {
public GameObjectRef entityPrefab
protected bool AllowNullParenting
protected bool AllowHeldEntityParenting
protected bool ShouldAutoCreateEntity
protected bool OwnedByParentPlayer
protected bool get_AllowNullParenting()
protected bool get_AllowHeldEntityParenting()
protected bool get_ShouldAutoCreateEntity()
protected bool get_OwnedByParentPlayer()
public void OnItemCreated(Item item)
public T CreateAssociatedEntity(Item item)
protected void OnAssociatedItemCreated(T ent)
public void OnRemove(Item item)
public void OnMovedToWorld(Item item)
public void OnRemovedFromWorld(Item item)
public void UpdateParent(Item item)
public void OnParentChanged(Item item)
public BaseEntity GetEntityForParenting(Item item)
public bool GetAssociatedEntity(Item item, T& result, bool isServer)
public T GetAssociatedEntity(Item item, bool isServer)
}
public ItemModAssociatedEntityMobile : ItemModAssociatedEntity`1<MobileInventoryEntity> {
protected bool AllowNullParenting
protected bool get_AllowNullParenting()
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModBackpack : ItemMod {
public SoundDefinition ZipSound
public bool hideSelectedPanel
public int containerVolumeWhenFilled
public bool DropWhenDowned
public void OnItemCreated(Item item)
public bool CanAcceptItem(Item backpack, Item item, int slot)
}
public ItemModBaitContainer : ItemModContainer {
protected bool ForceAcceptItemCheck
protected bool get_ForceAcceptItemCheck()
protected bool CanAcceptItem(Item item, int count)
protected void SetAllowedItems(ItemContainer container)
}
public ItemModBlueprintCraft : ItemMod {
public Phrase CraftItemTitle
public Phrase CraftItemDesc
public Phrase CraftAllTitle
public Phrase CraftAllDesc
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModBurnable : ItemMod {
public float fuelAmount
public ItemDefinition byproductItem
public int byproductAmount
public float byproductChance
public void OnItemCreated(Item item)
}
public ItemModCassette : ItemModAssociatedEntity`1<Cassette> {
public int noteSpriteIndex
public PreloadedCassetteContent PreloadedContent
protected bool AllowNullParenting
protected bool AllowHeldEntityParenting
protected bool get_AllowNullParenting()
protected bool get_AllowHeldEntityParenting()
protected void OnAssociatedItemCreated(Cassette ent)
}
public ItemModCassetteContainer : ItemModContainer {
public ItemDefinition[] CassetteItems
protected bool ForceAcceptItemCheck
protected bool get_ForceAcceptItemCheck()
protected void SetAllowedItems(ItemContainer container)
}
public ItemModChildIO : ItemMod {
public GameObjectRef TargetChildIO
}
public ItemModCompostable : MonoBehaviour {
public float TotalFertilizerProduced
public float BaitValue
public int MaxBaitStack
}
public ItemModConditionContainerFlag : ItemMod {
public Flag flag
public bool requiredState
public bool Passes(Item item)
}
public ItemModConditionHasCondition : ItemMod {
public float conditionTarget
public float conditionFractionTarget
public bool lessThan
public bool Passes(Item item)
}
public ItemModConditionHasContents : ItemMod {
public ItemDefinition itemDef
public bool requiredState
public bool Passes(Item item)
private bool <Passes>b__2_0(Item x)
}
public ItemModConditionHasFlag : ItemMod {
public Flag flag
public bool requiredState
public bool Passes(Item item)
}
public ItemModConditionInWater : ItemMod {
public bool requiredState
public bool Passes(Item item)
}
public ItemModConditionIsSleeping : ItemMod {
public bool requiredState
public bool Passes(Item item)
}
public ItemModConsumable : MonoBehaviour {
public int amountToConsume
public float conditionFractionToLose
public string achievementWhenEaten
public List`1<ConsumableEffect> effects
public List`1<ModifierDefintion> modifiers
public float GetIfType(Type typeToPick)
}
public ItemModConsume : ItemMod {
public GameObjectRef consumeEffect
public string eatGesture
public ItemAmountRandom[] product
public ItemModConsumable primaryConsumable
public ItemModConsumable GetConsumable()
public GameObjectRef GetConsumeEffect()
public void DoAction(Item item, BasePlayer player)
public bool CanDoAction(Item item, BasePlayer player)
}
public ItemModConsumeChance : ItemModConsume {
public float chanceForSecondaryConsume
public GameObjectRef secondaryConsumeEffect
public ItemModConsumable secondaryConsumable
private bool GetChance()
public ItemModConsumable GetConsumable()
public GameObjectRef GetConsumeEffect()
}
public ItemModConsumeContents : ItemMod {
public GameObjectRef consumeEffect
public void DoAction(Item item, BasePlayer player)
public bool CanDoAction(Item item, BasePlayer player)
}
public ItemModContainer : ItemMod {
public int capacity
public int maxStackSize
public int containerVolume
public bool canLootInWorld
public float pickupInWorldDelay
public float maxWeight
public float worldWeightScale
public Flag containerFlags
public ContentsType onlyAllowedContents
public ItemDefinition onlyAllowedItemType
public List`1<ItemSlot> availableSlots
public ItemDefinition[] validItemWhitelist
public bool openInDeployed
public bool openInInventory
public List`1<ItemAmount> defaultContents
public bool blockAmmoSource
public SoundDefinition openSound
public SoundDefinition closeSound
protected bool ForceAcceptItemCheck
public void OnItemCreated(Item item)
protected void SetAllowedItems(ItemContainer container)
protected bool get_ForceAcceptItemCheck()
protected bool CanAcceptItem(Item item, int count)
private void OnItemAddedOrRemoved(Item item, bool added)
public void OnVirginItem(Item item)
public void CollectedForCrafting(Item item, BasePlayer crafter)
}
public ItemModContainerRestriction : ItemMod {
public SlotFlags slotFlags
public bool CanExistWith(ItemModContainerRestriction other)
}
public ItemModConversation : ItemMod {
public Phrase SquakTitle
public Phrase SquakDesc
public ConversationData conversationData
public GameObjectRef conversationEntity
public GameObjectRef squakEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModCookable : ItemMod {
public ItemDefinition becomeOnCooked
public float cookTime
public int amountOfBecome
public int lowTemp
public int highTemp
public bool setCookingFlag
public void OnValidate()
public bool CanBeCookedByAtTemperature(float temperature)
private void CycleCooking(Item item, float delta)
public void OnItemCreated(Item itemcreated)
}
public ItemModCrackOpen : ItemModUnwrap {
public Phrase CrackOpenTitle
public Phrase CrackOpenDesc
}
public ItemModCycle : ItemMod {
public ItemMod[] actions
public float timeBetweenCycles
public float timerStart
public bool onlyAdvanceTimerWhenPass
public void OnItemCreated(Item itemcreated)
private bool CanCycle(Item item)
public void CustomCycle(Item item, float delta)
private void OnValidate()
}
public ItemModDeployable : MonoBehaviour {
public GameObjectRef entityPrefab
public bool showCrosshair
public string UnlockAchievement
public Deployable GetDeployable(BaseEntity entity)
internal void OnDeployed(BaseEntity ent, BasePlayer player)
}
public ItemModEntity : ItemMod {
public GameObjectRef entityPrefab
public string defaultBone
public bool playerOnlyEntity
public void OnChanged(Item item)
public void OnItemCreated(Item item)
private void CreateEntity(Item item)
public void OnRemove(Item item)
private bool ParentToParent(Item item, BaseEntity ourEntity)
private bool ParentToPlayer(Item item, BaseEntity ourEntity)
public void OnParentChanged(Item item)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
}
public ItemModEntityReference : MonoBehaviour {
public GameObjectRef entityPrefab
}
public ItemModFishable : ItemMod {
public bool CanBeFished
public float StrainModifier
public float MoveMultiplier
public float ReelInSpeedMultiplier
public float CatchWaitTimeMultiplier
public float MinimumBaitLevel
public float MaximumBaitLevel
public float MinimumWaterDepth
public float MaximumWaterDepth
public FishingTag RequiredTag
public float Chance
public string SteamStatName
public bool CanBeMounted
public int FishMountIndex
}
public ItemModForceSelectFromBelt : ItemMod {
public bool IfIsOn
public bool IfPlayerRestrained
}
public ItemModForceWearFromBelt : ItemMod {
public bool IfPlayerRestrained
}
public ItemModGiveOxygen : ItemMod {
public AirSupplyType airType
public int amountToConsume
public GameObjectRef inhaleEffect
public GameObjectRef exhaleEffect
public GameObjectRef bubblesEffect
private float timeRemaining
private float cycleTime
private bool inhaled
public AirSupplyType AirType
public AirSupplyType get_AirType()
public float GetAirTimeRemaining()
public void ModInit()
public void DoAction(Item item, BasePlayer player)
public void OnChanged(Item item)
}
public ItemModHABEquipment : ItemMod {
public SlotType slot
public GameObjectRef Prefab
public int MaxEquipCount
public bool GroundEquipOnly
public float DelayNextUpgradeOnRemoveDuration
public Phrase MenuOptionTitle
public Phrase MenuOptionDesc
public bool CanEquipToHAB(HotAirBalloon hab)
public void ApplyToHAB(HotAirBalloon hab)
}
public ItemModHead : ItemModAssociatedEntity`1<HeadEntity> {
protected bool AllowNullParenting
protected bool get_AllowNullParenting()
}
public ItemModKeycard : ItemMod {
public int accessLevel
}
public ItemModMenuOption : ItemMod {
public string commandName
public ItemMod actionTarget
public Option option
public bool isPrimaryOption
public void ServerCommand(Item item, string command, BasePlayer player)
private void OnValidate()
}
public ItemModOpenLootBag : ItemModUnwrap {
public Phrase OpenLootBagTitle
public Phrase OpenLootBagDesc
}
public ItemModOpenWrapped : ItemMod {
public GameObjectRef successEffect
public Phrase open_wrapped_gift
public Phrase open_wrapped_gift_desc
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModPager : ItemModRFListener {
public Phrase SilentOffTitle
public Phrase SilentOffDesc
public Phrase SilentOnTitle
public Phrase SilentOnDesc
public Phrase StopTitle
public Phrase StopDesc
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModPaintable : ItemModAssociatedEntity`1<PaintedItemStorageEntity> {
public Phrase ItemPaintTitle
public Phrase ItemPaintDesc
public GameObjectRef ChangeSignTextDialog
public MeshPaintableSource[] PaintableSources
protected bool AllowNullParenting
protected bool OwnedByParentPlayer
protected bool get_AllowNullParenting()
protected bool get_OwnedByParentPlayer()
}
public ItemModParachute : ItemModBackpack {
public GameObjectRef ParachuteVehiclePrefab
}
public ItemModPetStats : ItemMod {
public float SpeedModifier
public float MaxHealthModifier
public float AttackDamageModifier
public float AttackRateModifier
public void Apply(BasePet pet)
}
public ItemModPhoto : ItemModAssociatedEntity`1<PhotoEntity> {
protected bool AllowNullParenting
protected bool get_AllowNullParenting()
}
public ItemModProjectile : MonoBehaviour {
public GameObjectRef projectileObject
public ItemModProjectileMod[] mods
public AmmoTypes ammoType
public int numProjectiles
public float projectileSpread
public float projectileVelocity
public float projectileVelocitySpread
public bool useCurve
public AnimationCurve spreadScalar
public GameObjectRef attackEffectOverride
public float barrelConditionLoss
public string category
public float GetRandomVelocity()
public float GetSpreadScalar()
public float GetIndexedSpreadScalar(int shotIndex, int maxShots)
public float GetAverageVelocity()
public float GetMinVelocity()
public float GetMaxVelocity()
public bool IsAmmo(AmmoTypes ammo)
public void ServerProjectileHit(HitInfo info)
}
public ItemModProjectileMod : MonoBehaviour {
public void ServerProjectileHit(HitInfo info)
}
public ItemModProjectileRadialDamage : ItemModProjectileMod {
public float radius
public DamageTypeEntry damage
public GameObjectRef effect
public bool ignoreHitObject
public int vibrationLevel
public void ServerProjectileHit(HitInfo info)
}
public ItemModProjectileSpawn : ItemModProjectile {
public float createOnImpactChance
public GameObjectRef createOnImpact
public float spreadAngle
public float spreadVelocityMin
public float spreadVelocityMax
public int numToCreateChances
public void ServerProjectileHit(HitInfo info)
}
public ItemModRecycleInto : ItemMod {
public Phrase RecycleIntoTitle
public Phrase RecycleIntoDesc
public ItemDefinition recycleIntoItem
public int numRecycledItemMin
public int numRecycledItemMax
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModReload : ItemMod {
public float conditionLost
public GameObjectRef successEffect
public int workbenchLvlRequired
public Phrase reloadPhrase
public bool HasCraftLevel(BasePlayer player)
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModRepair : ItemMod {
public Phrase RefillItemTitle
public Phrase RefillItemDesc
public float conditionLost
public GameObjectRef successEffect
public int workbenchLvlRequired
public bool canUseRepairBench
public bool HasCraftLevel(BasePlayer player)
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModReveal : ItemMod {
public Phrase RevealItemTitle
public Phrase RevealItemDesc
public int numForReveal
public ItemDefinition revealedItemOverride
public int revealedItemAmount
public LootSpawn revealList
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModRFListener : ItemModAssociatedEntity`1<BaseEntity> {
public Phrase SetFreqTitle
public Phrase SetFreqDesc
public GameObjectRef frequencyPanelPrefab
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModSetFrequency : ItemMod {
public Phrase RfOffTitle
public Phrase RfOffDesc
public Phrase RfOnTitle
public Phrase RfOnDesc
public GameObjectRef frequencyPanelPrefab
public bool allowArmDisarm
public bool onlyFrequency
public int defaultFrequency
public bool loseConditionOnChange
private List`1<ItemTime> itemsOnCooldown
public void ServerCommand(Item item, string command, BasePlayer player)
public void OnItemCreated(Item item)
}
public ItemModSign : ItemModAssociatedEntity`1<SignContent> {
protected bool AllowNullParenting
protected bool ShouldAutoCreateEntity
protected bool get_AllowNullParenting()
protected bool get_ShouldAutoCreateEntity()
public void OnSignPickedUp(ISignage s, IUGCBrowserEntity ugc, Item toItem)
}
public ItemModSound : ItemMod {
public GameObjectRef effect
public Type actionType
public void OnParentChanged(Item item)
}
public ItemModStudyBlueprint : ItemMod {
public GameObjectRef studyEffect
public void ServerCommand(Item item, string command, BasePlayer player)
private bool IsBlueprintUnlocked(Item item, BasePlayer player, ItemDefinition& blueprintTargetDef, ItemBlueprint& blueprint)
public bool IsBlueprintUnlocked(ItemDefinition def, BasePlayer player)
}
public ItemModSummerSunglassesEquip : ItemMod {
public float SunsetTime
public float SunriseTime
public string AchivementName
public void DoAction(Item item, BasePlayer player)
}
public ItemModSwap : ItemMod {
public GameObjectRef actionEffect
public ItemAmount[] becomeItem
public bool sendPlayerPickupNotification
public bool sendPlayerDropNotification
public float xpScale
public ItemAmount[] RandomOptions
public void DoAction(Item item, BasePlayer player)
}
public ItemModSwitchFlag : ItemMod {
public Flag flag
public bool state
public void DoAction(Item item, BasePlayer player)
}
public ItemModUnwrap : ItemMod {
public Phrase UnwrapGiftTitle
public Phrase UnwrapGiftDesc
public LootSpawn revealList
public GameObjectRef successEffect
public int minTries
public int maxTries
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModUpgrade : ItemMod {
public Phrase UpgradeItemTitle
public Phrase UpgradeItemDesc
public int numForUpgrade
public float upgradeSuccessChance
public int numToLoseOnFail
public ItemDefinition upgradedItem
public int numUpgradedItem
public GameObjectRef successEffect
public GameObjectRef failEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModUseContent : ItemMod {
public int amountToConsume
public void DoAction(Item item, BasePlayer player)
}
public ItemModWearable : ItemMod {
public GameObjectRef entityPrefab
public GameObjectRef entityPrefabFemale
public ProtectionProperties protectionProperties
public ArmorProperties armorProperties
public ClothingMovementProperties movementProperties
public blackoutType occlusionType
public bool blocksAiming
public bool emissive
public float accuracyBonus
public bool blocksEquipping
public float eggVision
public float weight
public bool equipOnRightClick
public bool equipOnPickup
public bool npcOnly
public GameObjectRef breakEffect
public bool preventsMounting
public bool preventsMap
public GameObjectRef viewmodelAddition
public Wearable targetWearable
public Wearable get_targetWearable()
private void DoPrepare()
public void ModInit()
public bool ProtectsArea(HitArea area)
public bool HasProtections()
internal float GetProtection(Item item, DamageType damageType)
public float ConditionProtectionScale(Item item)
public void CollectProtection(Item item, ProtectionProperties protection)
private bool IsHeadgear()
public bool IsFootwear()
public void OnAttacked(Item item, HitInfo info)
public bool CanExistWith(ItemModWearable wearable)
}
public ItemModWrap : ItemMod {
public GameObjectRef successEffect
public ItemDefinition wrappedDefinition
public Phrase wrap_gift
public Phrase wrap_gift_desc
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModXMasTreeDecoration : ItemMod {
public xmasFlags flagsToChange
}
public ItemModXPWhenUsed : ItemMod {
public float xpPerUnit
public int unitSize
public void GiveConsumeXP(Item item)
}
public ItemOptionButton : MonoBehaviour {
public TextMeshProUGUI name
public Image icon
}
public ItemPickup : DroppedItem {
public ItemDefinition itemDef
public int amount
public ulong skinOverride
public float GetDespawnDuration()
public void Spawn()
internal void DoServerDestroy()
public void PostServerLoad()
}
public ItemPickupNotice : MonoBehaviour {
public TextMeshProUGUI Text
public TextMeshProUGUI Amount
}
public ItemPreviewIcon : BaseMonoBehaviour {
public ItemContainerSource containerSource
public int slot
public bool setSlotFromSiblingIndex
public CanvasGroup iconContents
public Image iconImage
public Text amountText
public Item item
}
public ItemSearchEntry : MonoBehaviour {
public Button button
public Text text
public RawImage image
public RawImage bpImage
}
public ItemSearchUtils : object {
public IOrderedEnumerable`1<ItemDefinition> SearchForItems(string searchString, Func`2<ItemDefinition, bool> validFilter)
public bool IsValidSearchResult(string search, ItemDefinition target, bool checkItemIsValid)
private float ScoreSearchResult(string search, ItemDefinition target)
}
public ItemSelectionPanel : Enum {
public int value__
public ItemSelectionPanel None
public ItemSelectionPanel Vessel
public ItemSelectionPanel Modifications
public ItemSelectionPanel GunInformation
}
public ItemSelector : PropertyAttribute {
public ItemCategory category
public void .ctor(ItemCategory category)
}
public ItemSkin : SteamInventoryItem {
public Skinnable Skinnable
public Material[] Materials
public ItemDefinition Redirect
public SteamInventoryItem UnlockedViaSteamItem
public void ApplySkin(GameObject obj)
public bool HasUnlocked(ulong playerId)
}
public ItemSkinDirectory : ScriptableObject {
private ItemSkinDirectory _Instance
public Skin[] skins
public ItemSkinDirectory Instance
public ItemSkinDirectory get_Instance()
public Skin[] ForItem(ItemDefinition item)
public Skin FindByInventoryDefinitionId(int id)
public bool TryGetItemFromDefinitionID(int id, ItemDefinition& result)
}
public ItemSlot : Enum {
public int value__
public ItemSlot None
public ItemSlot Barrel
public ItemSlot Silencer
public ItemSlot Scope
public ItemSlot UnderBarrel
public ItemSlot Magazine
public ItemSlot Internal
}
public ItemSplitter : MonoBehaviour {
public Slider slider
public TextMeshProUGUI textValue
public TextMeshProUGUI splitAmountText
public TMP_InputField amountInputField
}
public ItemSplitterDragOut : MonoBehaviour {
public ItemSplitter rootSplitter
}
public ItemStatValue : MonoBehaviour {
public Text text
public Slider slider
public bool selectedItem
public bool smallerIsBetter
public bool asPercentage
}
public ItemStore : SingletonComponent`1<ItemStore> {
public Phrase CartEmptyPhrase
public Phrase CartSingularPhrase
public Phrase CartPluralPhrase
public GameObject LimitedItemPrefab
public GameObject GeneralItemPrefab
public float TransitionDelayPerItem
public RectTransform LimitedItemParent
public RectTransform GeneralItemParent
public List`1<IPlayerItemDefinition> Cart
public ItemStoreItemInfoModal ItemStoreInfoModal
public GameObject BuyingModal
public ItemStoreBuyFailedModal ItemStoreBuyFailedModal
public ItemStoreBuySuccessModal ItemStoreBuySuccessModal
public SoundDefinition AddToCartSound
public RustText CartButtonLabel
public RustText QuantityValue
public RustText TotalValue
public RectTransform TakeoverParent
public ItemStoreTakeover[] Takeovers
public int GetItemCount()
public void SetItemData(int i, GameObject obj)
}
public ItemStoreBuyButton : ListComponent`1<ItemStoreBuyButton> {
public RectTransform Buy
public RectTransform InCart
public RectTransform AlreadyPurchased
public UnityEvent OnAddedToCart
}
public ItemStoreBuyFailedModal : MonoBehaviour {
public void Show(ulong orderid)
public void Hide()
private void <Hide>b__1_0()
}
public ItemStoreBuySuccessModal : MonoBehaviour {
public void Show(ulong orderId)
public void Hide()
private void <Hide>b__1_0()
}
public ItemStoreCartItem : MonoBehaviour {
public int Index
public TextMeshProUGUI Name
public TextMeshProUGUI Price
public void Init(int index, IPlayerItemDefinition def)
}
public ItemStoreItem : MonoBehaviour {
public Button Button
public HttpImage Icon
public RawImage IconImage
public Material IconImageDisabledMaterial
public RustText Name
public GameObject PriceButton
public TextMeshProUGUI Price
public GameObject AlreadyOwnedButton
public RustText ItemName
public GameObject NewTag
public GameObject InInventoryTag
public RustText InInventoryText
public GameObject InCartTag
public GameObject Footer
}
public ItemStoreItemInfoModal : FacepunchBehaviour {
public HttpImage Icon
public TextMeshProUGUI Name
public TextMeshProUGUI Price
public TextMeshProUGUI Description
public RustText itemCategory
public RawImage skinViewerImage
public GameObjectRef skinViewerPrefab
public RectTransform sectionReplaces
public Image replacesIcon
public RustText replacesName
public RectTransform sectionBreakdown
public RectTransform breakdownCloth
public RectTransform breakdownMetal
public RectTransform breakdownWood
private GameObject icon2D
private GameObject icon3D
private Image loadingSpinner
}
public ItemStorePack : RevealTransitionBase {
public ScrollRect ScrollRect
public RustText[] PriceTags
}
public ItemStorePackItem : FacepunchBehaviour {
private GameObjectRef skinViewerPrefab
private Image iconImage2D
private RawImage iconImage3D
private ItemDefinition modelItemDef
private GameObjectRef modelPrefab
}
public ItemStoreTakeover : ValueType {
public string Name
public SteamInventoryItem Item
public GameObjectRef Prefab
public Sprite IconOverride
public string Subtitle
}
public ItemTextValue : MonoBehaviour {
public Text text
public Color bad
public Color good
public bool negativestat
public bool asPercentage
public bool useColors
public bool signed
public string suffix
public float multiplier
public void SetValue(float val, int numDecimals, string overrideText)
}
public IThinker {
public void TryThink()
}
public ITrainCollidable {
public bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger)
public bool EqualNetID(BaseNetworkable other)
}
public IUGCBrowserEntity {
public UInt32[] GetContentCRCs
public UGCType ContentType
public List`1<ulong> EditingHistory
public BaseNetworkable UgcEntity
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public UGCType get_ContentType()
public List`1<ulong> get_EditingHistory()
public BaseNetworkable get_UgcEntity()
}
public IVehicleLockUser {
public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)
public bool PlayerHasUnlockPermission(BasePlayer player)
public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
public void RemoveLock()
}
public Jackhammer : BaseMelee {
public float HotspotBonusScale
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasAmmo()
public void Server_SetEngineStatus(RPCMessage msg)
public void SetEngineStatus(bool on)
public void SetHeld(bool bHeld)
}
public JesseStiller.TerrainFormerExtension.TerrainFormer : MonoBehaviour {
private void Awake()
}
public JesseStiller.TerrainFormerExtension.TerrainSetNeighbours : MonoBehaviour {
private Terrain leftTerrain
private Terrain topTerrain
private Terrain rightTerrain
private Terrain bottomTerrain
private void Awake()
public void SetNeighbours(Terrain leftTerrain, Terrain topTerrain, Terrain rightTerrain, Terrain bottomTerrain)
}
public JiggleBone : BaseMonoBehaviour {
public bool debugMode
private Vector3 targetPos
private Vector3 dynamicPos
public Vector3 boneAxis
public float targetDistance
public float bStiffness
public float bMass
public float bDamping
public float bGravity
private Vector3 force
private Vector3 acc
private Vector3 vel
public bool SquashAndStretch
public float sideStretch
public float frontStretch
public float disableDistance
private void Awake()
private void LateUpdate()
}
public JunkPile : BaseEntity {
public GameObjectRef sinkEffect
public SpawnGroup[] spawngroups
public NPCSpawner NPCSpawn
private float lifetimeMinutes
protected bool isSinking
private float sunkAmount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
internal void DoServerDestroy()
private void SpawnInitial()
public bool SpawnGroupsEmpty()
public void CheckEmpty()
public float TimeoutPlayerCheckRadius()
public void TimeOut()
public void SinkAndDestroy()
public void SinkThink()
public void KillMe()
}
public JunkpileNPCSpawner : NPCSpawner {
public bool UseSpawnChance
protected void Spawn(int numToSpawn)
}
public JunkPileWater : JunkPile {
public Transform[] buoyancyPoints
public bool debugDraw
public float updateCullRange
public float VehicleCheckRadius
private Quaternion baseRotation
private bool first
private TimeUntil nextPlayerCheck
private bool hasPlayersNearby
public JunkpileWaterWorkQueue junkpileWaterWorkQueue
public float framebudgetms
public void Spawn()
public void FixedUpdate()
public void UpdateMovement()
public void UpdateNearbyPlayers()
}
public JunkPileWaterSpawner : SpawnGroup {
public BaseEntity attachToParent
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
}
public Kayak : BaseBoat {
public ItemDefinition OarItem
public float maxPaddleFrequency
public float forwardPaddleForce
public float multiDriverPaddleForceMultiplier
public float rotatePaddleForce
public GameObjectRef forwardSplashEffect
public GameObjectRef backSplashEffect
public ParticleSystem moveSplashEffect
public float animationLerpSpeed
public BlendedSoundLoops waterLoops
public float waterSoundSpeedDivisor
public GameObjectRef pushLandEffect
public GameObjectRef pushWaterEffect
public MountPoses noPaddlePose
public TimeSince[] playerPaddleCooldowns
public TimeCachedValue`1<float> fixedDragUpdate
public TimeSince timeSinceLastUsed
private float DECAY_TICK_TIME
private Vector3 lastTravelPos
private bool inCinematic
private Quaternion cinematicWorldRotation
private float distanceRemainder
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public void OnPlayerMounted()
public void OnPlayerDismounted(BasePlayer player)
public void DriverInput(InputState inputState, BasePlayer player)
private void TravelDistanceUpdate()
public bool EngineOn()
public void DoPushAction(BasePlayer player)
public void VehicleFixedUpdate()
public float CalculateDesiredDrag()
public void BoatDecay()
public bool CanPickup(BasePlayer player)
public void PrepareForTutorialCinematic(Quaternion worldRotation)
public bool IsPlayerHoldingPaddle(BasePlayer player)
public Vector3 GetPaddlePoint(int index, PaddleDirection direction)
public bool IsInWater()
}
public KayakSeat : BaseVehicleSeat {
public ItemDefinition PaddleItem
public void OnPlayerMounted()
public void OnPlayerDismounted(BasePlayer player)
}
public KeybindCategory : MonoBehaviour {
private List`1<KeyBindUI> keybinds
private void Awake()
public void UpdateVisibility()
}
public KeybindSearch : MonoBehaviour {
public GameObject rootPanel
public TMP_InputField input
}
public KeyBindUI : MonoBehaviour {
public GameObject blockingCanvas
public Text Label
public Button btnA
public Button btnB
public string bindString
private bool <IsBinding>k__BackingField
public bool IsBinding
public bool get_IsBinding()
private void set_IsBinding(bool value)
}
public Keycard : AttackEntity {
public int accessLevel
public int get_accessLevel()
}
public KeyCodeEntry : UIDialog {
public Text textDisplay
public Action onClosed
public Text typeDisplay
public Phrase masterCodePhrase
public Phrase guestCodePhrase
public GameObject memoryKeycodeButton
}
public KeyframeView : MonoBehaviour {
public ScrollRect Scroller
public GameObjectRef KeyframePrefab
public RectTransform KeyframeRoot
public Transform CurrentPositionIndicator
public bool LockScrollToCurrentPosition
public RustText TrackName
}
public KeyframeWidget : MonoBehaviour {
public Tooltip AttachedTooltip
}
public KeyInformationPanel : ItemInformationPanel {
private Text id
}
public KeyLock : BaseLock {
public ItemDefinition keyItemType
public int keyCode
public bool firstKeyCreated
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasLockPermission(BasePlayer player)
private bool CanKeyUnlockUs(Item key)
public void Load(LoadInfo info)
public bool ShouldNetworkOwnerInfo()
public void PostServerLoad()
public void Save(SaveInfo info)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public bool OnTryToOpen(BasePlayer player)
public bool OnTryToClose(BasePlayer player)
private void RPC_Unlock(RPCMessage rpc)
private void RPC_Lock(RPCMessage rpc)
private void Lock(BasePlayer player)
private void RPC_CreateKey(RPCMessage rpc)
public void LockLock(BasePlayer player)
}
public LadderMinMountHeight : MonoBehaviour {
private void Start()
private void Update()
}
public LakeInfo : MonoBehaviour {
protected void Awake()
}
public LandmarkInfo : MonoBehaviour {
public bool shouldDisplayOnMap
public bool isLayerSpecific
public Phrase displayPhrase
public Sprite mapIcon
public MapLayer MapLayer
public MapLayer get_MapLayer()
protected void Awake()
}
public Landmine : BaseTrap {
public GameObjectRef explosionEffect
public GameObjectRef triggeredEffect
public float minExplosionRadius
public float explosionRadius
public int vibrationLevel
public bool blocked
private ulong triggerPlayerID
public List`1<DamageTypeEntry> damageTypes
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool Triggered()
public bool Armed()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ServerInit()
public void ObjectEntered(GameObject obj)
public void Trigger(BasePlayer ply)
public void OnEmpty()
public void Explode()
public void OnKilled(HitInfo info)
private void OnGroundMissing()
private void TryExplode()
public void Arm()
private void RPC_Disarm(RPCMessage rpc)
}
public LanguageSelection : MonoBehaviour {
public GameObject buttonContainer
}
public LargeShredder : BaseEntity {
public Transform shredRail
public Transform shredRailStartPos
public Transform shredRailEndPos
public Vector3 shredRailStartRotation
public Vector3 shredRailEndRotation
public LargeShredderTrigger trigger
public float shredDurationRotation
public float shredDurationPosition
public float shredSwayAmount
public float shredSwaySpeed
public BaseEntity currentlyShredding
public GameObject[] shreddingWheels
public float shredRotorSpeed
public GameObjectRef shredSoundEffect
public Transform resourceSpawnPoint
private Quaternion entryRotation
public string SHRED_STAT
public bool isShredding
public float shredStartTime
public void OnEntityEnteredTrigger(BaseEntity ent)
public void CreateShredResources()
public void UpdateBonePosition(float delta)
public void SetShredding(bool isShredding)
public void FireShredEffect()
public void ServerUpdate()
private void Update()
}
public LargeShredderTrigger : TriggerBase {
public LargeShredder shredder
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
}
public LaserBeam : MonoBehaviour {
public float scrollSpeed
public LineRenderer beamRenderer
public GameObject dotObject
public Renderer dotRenderer
public GameObject dotSpotlight
public Vector2 scrollDir
public float maxDistance
public float stillBlendFactor
public float movementBlendFactor
public float movementThreshhold
public bool isFirstPerson
public Transform emissionOverride
}
public LaserDetector : BaseDetector {
public void OnObjects()
}
public LaserLight : AudioVisualisationEntity {
public Animator LaserAnimator
public LineRenderer[] LineRenderers
public MeshRenderer[] DotRenderers
public MeshRenderer FlareRenderer
public Light[] LightSources
public ColourSetting RedSettings
public ColourSetting GreenSettings
public ColourSetting BlueSettings
public ColourSetting YellowSettings
public ColourSetting PinkSettings
public void OnFlagsChanged(Flags old, Flags next)
}
public LayerCullDistance : MonoBehaviour {
public string Layer
public float Distance
protected void OnEnable()
}
public LayerSelect : ValueType {
private int layer
public int Mask
public string Name
public void .ctor(int layer)
public int op_Implicit(LayerSelect layer)
public LayerSelect op_Implicit(int layer)
public int get_Mask()
public string get_Name()
}
public LazyAimProperties : ScriptableObject {
public float snapStrength
public float deadzoneAngle
}
public LeavesBlowing : MonoBehaviour {
public ParticleSystem m_psLeaves
public float m_flSwirl
public float m_flSpeed
public float m_flEmissionRate
private void Start()
private void Update()
}
public LegacyShelter : DecayEntity {
private Dictionary`2<ulong, List`1<LegacyShelter>> sheltersPerPlayer
public int FpShelterDefault
public Phrase shelterLimitPhrase
public Phrase shelterLimitReachedPhrase
public GameObjectRef smallPrivilegePrefab
public GameObjectRef includedDoorPrefab
public GameObjectRef includedLockPrefab
public EntityRef`1<EntityPrivilege> entityPrivilege
private EntityRef`1<LegacyShelterDoor> childDoorInstance
private EntityRef`1<BaseLock> lockEntityInstance
private Decay decayReference
private float lastShelterDecayTick
public float lastInteractedWithDoor
private ulong shelterOwnerID
public Dictionary`2<ulong, List`1<LegacyShelter>> SheltersPerPlayer
public Dictionary`2<ulong, List`1<LegacyShelter>> get_SheltersPerPlayer()
public Nullable`1<CanBuildResult> CanBuildShelter(BasePlayer player, Construction construction)
internal void DoServerDestroy()
public int GetShelterCount(ulong userId)
private void AddToShelterList(ulong id)
private bool IsShelterInList(List`1<LegacyShelter> shelters, LegacyShelter& thisShelter)
public EntityPrivilege GetEntityBuildingPrivilege()
public EntityPrivilege GetEntityPrivilege()
protected void OnChildAdded(BaseEntity child)
public void Load(LoadInfo info)
public void DecayTick()
public void HasInteracted()
public void SetupDecay()
public float GetEntityDecayDuration()
public LegacyShelterDoor GetChildDoor()
public void Save(SaveInfo info)
public void OnPlaced(BasePlayer player)
public void Hurt(HitInfo info)
public void OnKilled(HitInfo info)
public void OnRepair()
public void OnRepairFinished()
public void ProtectedHurt(HitInfo info)
public void PostServerLoad()
private void Setup(BaseEntity child)
private void UpdateDoorHp()
}
public LegacyShelterDoor : Door {
public GameObjectRef includedLockPrefab
private LegacyShelter shelter
public void SetupDoor(LegacyShelter shelter)
public void DecayTick()
protected void OnChildAdded(BaseEntity child)
protected void OnPlayerOpenedDoor(BasePlayer p)
public void OnRepair()
public void OnRepairFinished()
public void Hurt(HitInfo info)
public void OnKilled(HitInfo info)
public void ProtectedHurt(HitInfo info)
private void UpdateShelterHp()
}
public LegacyWeatherState : object {
private WeatherPreset preset
public float Wind
public float Rain
public float Clouds
public float Fog
public void .ctor(WeatherPreset preset)
public float get_Wind()
public void set_Wind(float value)
public float get_Rain()
public void set_Rain(float value)
public float get_Clouds()
public void set_Clouds(float value)
public float get_Fog()
public void set_Fog(float value)
}
public LensDirtinessEffect : PostProcessEffectSettings {
public TextureParameter dirtinessTexture
public BoolParameter sceneTintsBloom
public FloatParameter gain
public FloatParameter threshold
public FloatParameter bloomSize
public FloatParameter dirtiness
public ColorParameter bloomColor
}
public LensDirtinessRenderer : PostProcessEffectRenderer`1<LensDirtinessEffect> {
private int dataProperty
private Shader lensDirtinessShader
public void Init()
public void Render(PostProcessRenderContext context)
}
public LerpBetweenPointsBool : MonoBehaviour {
public Vector3 offsetPosLocal
public float speed
public bool UseAsOffset
public void SetAtOffset(bool should)
}
public LevelInfo : SingletonComponent`1<LevelInfo> {
public string shortName
public string displayName
public string description
public Texture2D image
public int version
}
public LevelManager : object {
public string CurrentLevelName
public bool isLoaded
public bool get_isLoaded()
public bool IsValid(string strName)
public void LoadLevel(string strName, bool keepLoadingScreenOpen)
public IEnumerator LoadLevelAsync(string strName, bool keepLoadingScreenOpen)
public void UnloadLevel(bool loadingScreen)
}
public LifeInfographic : MonoBehaviour {
public PlayerLifeStory life
public GameObject container
public RawImage AttackerAvatarImage
public Image DamageSourceImage
public LifeInfographicStat[] Stats
public Animator[] AllAnimators
public GameObject WeaponRoot
public GameObject DistanceRoot
public GameObject DistanceDivider
public Image WeaponImage
public DamageSetting[] DamageDisplays
public Texture2D defaultAvatarTexture
public bool ShowDebugData
}
public LifeInfographicStat : MonoBehaviour {
public DataType dataSource
public string genericStatKey
public string targetWeaponName
public WeaponInfoType weaponInfoType
public TextMeshProUGUI targetText
public Image StatImage
}
public LifeInfographicStatDynamicRow : LifeInfographicStat {
public RustText StatName
public void SetStatName(Phrase phrase)
}
public LifeInfographicStatWeapon : MonoBehaviour {
public RustText WeaponName
public RustText ShotsFired
public RustText ShotsHit
public RustText ShotsPercent
public Image WeaponIcon
}
public LifeScale : BaseMonoBehaviour {
private bool initialized
private Vector3 initialScale
public Vector3 finalScale
private Vector3 targetLerpScale
private Action updateScaleAction
protected void Awake()
public void OnEnable()
public void SetProgress(float progress)
public void Init()
public void UpdateScale()
}
public Lift : AnimatedBuildingBlock {
public GameObjectRef triggerPrefab
public string triggerBone
public float resetDelay
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void RPC_UseLift(RPCMessage rpc)
private void MoveUp()
private void MoveDown()
protected void OnAnimatorDisabled()
public void Spawn()
}
public LightCloneShadow : MonoBehaviour {
public bool cloneShadowMap
public bool cloneShadowMask
public int shadowMaskDownscale
}
public LightEx : UpdateBehaviour {
public bool alterColor
public float colorTimeScale
public Color colorA
public Color colorB
public AnimationCurve blendCurve
public bool loopColor
public bool alterIntensity
public float intensityTimeScale
public AnimationCurve intenseCurve
public float intensityCurveScale
public bool loopIntensity
public bool randomOffset
public float randomIntensityStartScale
public List`1<Light> syncLights
protected void OnValidate()
public bool CheckConflict(GameObject go)
}
public LightGroupAtTime : FacepunchBehaviour {
public float IntensityOverride
public AnimationCurve IntensityScaleOverTime
public Transform SearchRoot
public bool requiresPower
public Transform powerOverrideTransform
public LayerMask checkLayers
public GameObject enableWhenLightsOn
public float timeBetweenPowerLookup
}
public LightListener : BaseEntity {
public string onMessage
public string offMessage
public LightGroupAtTime onLights
public LightGroupAtTime offLights
public void OnEntityMessage(BaseEntity from, string msg)
}
public LightLOD : MonoBehaviour {
public float DistanceBias
public bool ToggleLight
public bool ToggleShadows
protected void OnValidate()
}
public LightOccludee : MonoBehaviour {
public float RadiusScale
public float MinTimeVisible
public bool IsDynamic
}
public LightPulse : MonoBehaviour {
public Light TargetLight
public float PulseSpeed
public float Lifetime
public float MaxIntensity
public float FadeOutSpeed
}
public LinearFog : MonoBehaviour {
public Material fogMaterial
public Color fogColor
public float fogStart
public float fogRange
public float fogDensity
public bool fogSky
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public LineRendererActivate : MonoBehaviour {
private void OnEnable()
}
public LinqEx : object {
public int MaxIndex(IEnumerable`1<T> sequence)
}
public LiquidContainer : ContainerIOEntity {
public ItemDefinition defaultLiquid
public int startingAmount
public bool autofillOutputs
public float autofillTickRate
public int autofillTickAmount
public int maxOutputFlow
public ItemDefinition[] ValidItems
private int currentDrainAmount
private HashSet`1<IOEntity> connectedList
private HashSet`1<ContainerIOEntity> pushTargets
private int maxPushTargets
private IOEntity considerConnectedTo
private Action updateDrainAmountAction
private Action updatePushLiquidTargetsAction
private Action pushLiquidAction
private Action deductFuelAction
private TimeUntil waterTransferStartTime
private float lastOutputDrainUpdate
private HashSet`1<IOEntity> pushLiquidCheckEntityHash
public bool IsGravitySource
protected bool DisregardGravityRestrictionsOnLiquid
public bool BlockFluidDraining
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_IsGravitySource()
protected bool get_DisregardGravityRestrictionsOnLiquid()
public bool AllowWireConnections()
public bool IsRootEntity()
private bool CanAcceptItem(Item item, int count)
public void ServerInit()
public void OnCircuitChanged(bool forceUpdate)
public void OnItemAddedOrRemoved(Item item, bool added)
private void ClearDrains()
public int GetCurrentEnergy()
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
private void UpdateDrainAmount()
public bool get_BlockFluidDraining()
private void CalculateDrain(IOEntity ent, Vector3 fromSlotWorld, int depth, Int32& amount, IOEntity lastEntity, ItemDefinition waterType)
public void UpdateOutputs()
private void DeductFuel()
protected void UpdateOnFlag()
public void OpenTap(float duration)
public void ShutTap()
public bool HasLiquidItem()
public Item GetLiquidItem()
public int GetLiquidCount()
public void SVDrink(RPCMessage rpc)
private void UpdatePushLiquidTargets()
private void PushLiquidThroughOutputs()
private void CheckPushLiquid(IOEntity connected, Item ourFuel, IOEntity fromSource, int depth, HashSet`1<IOEntity> checkEntities)
public void SetConnectedTo(IOEntity entity)
protected bool ConsiderConnectedTo(IOEntity entity)
}
public LiquidVessel : HeldEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanDrink()
private void DoEmpty(RPCMessage msg)
public void AddLiquid(ItemDefinition liquidType, int amount)
public bool CanFillHere(Vector3 pos)
public int AmountHeld()
public float HeldFraction()
public bool IsFull()
public int MaxHoldable()
}
public LiquidWeapon : BaseLiquidVessel {
public float FireRate
public float MaxRange
public int FireAmountML
public int MaxPressure
public int PressureLossPerTick
public int PressureGainedPerPump
public float MinDmgRadius
public float MaxDmgRadius
public float SplashRadius
public GameObjectRef ImpactSplashEffect
public AnimationCurve PowerCurve
public List`1<DamageTypeEntry> Damage
public LiquidWeaponEffects EntityWeaponEffects
public bool RequiresPumping
public bool AutoPump
public bool WaitForFillAnim
public bool UseFalloffCurve
public AnimationCurve FalloffCurve
public float PumpingBlockDuration
public float StartFillingBlockDuration
public float StopFillingBlockDuration
public float cooldownTime
public bool HoldFireInput
public int pressure
public string RadiationFightAchievement
public string SoakedAchievement
public string LiquidatorAchievement
public string NoPressureAchievement
public float PressureFraction
public float MinimumPressureFraction
public float CurrentRange
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void StartFiring(RPCMessage msg)
private void StopFiring()
private bool CanFire(BasePlayer player)
public void PumpWater(RPCMessage msg)
private void PumpWater()
private void FireTick()
private void DoSplash(BasePlayer attacker, Vector3 position, Vector3 direction, int amount)
public void OnHeldChanged()
public float get_PressureFraction()
public float get_MinimumPressureFraction()
public float get_CurrentRange()
private void StartCooldown(float duration)
private bool OnCooldown()
private bool Firing()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public LiquidWeaponEffects : MonoBehaviour {
public ParticleSystem RootPS
public ParticleSystem EmissionPS
public ParticleSystem InnerEmissionPS
public LiquidWobble Liquid
public float MinPressureSpeed
public float MaxPressureSpeed
public AnimationCurve PressureSpeedCurve
public Vector2 StreamSize
public AnimationCurve PressureSizeMultiplierCurve
public float MinPressureInnerSpeed
public float MaxPressureInnerSpeed
public AnimationCurve InnerPressureSpeedCurve
public Vector2 InnerStreamSize
public AnimationCurve InnerPressureSizeMultiplierCurve
public bool UseImpactSplashEffect
public GameObjectRef ImpactSplashEffect
public float ImpactSplashEffectInterval
public float FillSpeed
public bool firstPersonSounds
public SoundDefinition shootStartSoundDef
public SoundDefinition shootLoopSoundDef
public SoundDefinition shootLowPressureLoopSoundDef
public SoundDefinition impactStartSoundDef
public SoundDefinition impactLoopSoundDef
}
public LiquidWobble : MonoBehaviour {
public float CurrentWaterLevelFraction
public float MinWaterLevel
public float MaxWaterLevel
public float MaxWobble
public float WobbleSpeed
public float Recovery
}
public LoadBalancer : SingletonComponent`1<LoadBalancer> {
public bool Paused
private float MinMilliseconds
private float MaxMilliseconds
private int MinBacklog
private int MaxBacklog
private Queue`1[] queues
private Stopwatch watch
protected void LateUpdate()
public int Count()
public void ProcessAll()
public void Enqueue(DeferredAction action)
private void CreateInstance()
}
public LoadingScreen : SingletonComponent`1<LoadingScreen> {
private bool <WantsSkip>k__BackingField
private string <Text>k__BackingField
public CanvasRenderer panel
public TextMeshProUGUI title
public TextMeshProUGUI subtitle
public Button skipButton
public Button cancelButton
public GameObject performanceWarning
public AudioSource music
public RectTransform serverInfo
public RustText serverName
public RustText serverPlayers
public RustLayout serverModeSection
public RustText serverMode
public RustText serverMap
public RustLayout serverTagsSection
public ServerBrowserTagList serverTags
public RectTransform demoInfo
public RustText demoName
public RustText demoLength
public RustText demoDate
public RustText demoMap
public RawImage backgroundImage
public Texture2D defaultBackground
public GameObject pingWarning
public RustText pingWarningText
public int minPingDiffToShowWarning
public float pingDiffFactorToShowWarning
public int requiredPingSampleCount
public GameObject blackout
public bool isOpen
public bool WantsSkip
public string Text
public bool get_isOpen()
public bool get_WantsSkip()
private void set_WantsSkip(bool value)
private void set_Text(string value)
public string get_Text()
public void Update(string strType)
public void Update(string strType, string strSubtitle)
}
public LocalClock : object {
public List`1<TimedEvent> events
public void Add(float delta, float variance, Action action)
public void Tick()
}
public LocalizeText : MonoBehaviour {
public string token
public string english
public string append
public SpecialMode specialMode
public string LanguageToken
public string LanguageEnglish
public string get_LanguageToken()
public void set_LanguageToken(string value)
public string get_LanguageEnglish()
public void set_LanguageEnglish(string value)
}
public LocalPositionAnimation : MonoBehaviour {
public Vector3 centerPosition
public bool worldSpace
public float scaleX
public float timeScaleX
public AnimationCurve movementX
public float scaleY
public float timeScaleY
public AnimationCurve movementY
public float scaleZ
public float timeScaleZ
public AnimationCurve movementZ
}
public LockedByEntCrate : LootContainer {
public GameObject lockingEnt
public void SetLockingEnt(GameObject ent)
public void SetLocked(bool isLocked)
public void Think()
}
public Locker : StorageContainer {
public GameObjectRef equipSound
public int maxGearSets
public int attireSize
public int beltSize
public int columnSize
public int backpackSlotIndex
public Item[] clothingBuffer
public int setSize
public bool isTransferringIndustrialItem
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsEquipping()
public RowType GetRowType(int slot)
public void ServerInit()
public void ClearEquipping()
public void OnIndustrialItemTransferBegin()
public void OnIndustrialItemTransferEnd()
public bool ItemFilter(Item item, int targetSlot)
public bool IsBackpackSlot(int slot)
public void RPC_Equip(RPCMessage msg)
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public bool DoesWearableConflictWithRow(Item item, int pos)
public Vector2i GetIndustrialSlotRange(Vector3 localPosition)
public bool SupportsChildDeployables()
public bool CanPickup(BasePlayer player)
}
public LockOnLauncher : BaseLauncher {
public float lockRange
public float lockConeDot
public float timeToLock
private float currentLockTime
public float timeToLoseLock
private GameObjectRef camUIDialogPrefab
private SeekerTarget currentLockTarget
private SeekingServerProjectile projectile
private float lockTickRate
private float lastSentLockTime
private bool HasProjectile
private bool get_HasProjectile()
public void OnHeldChanged()
public bool CanLock()
public void UpdateLockedEntity()
public bool HasTarget()
protected void OnReloadStarted()
public void ProjectileLaunched_Server(ServerProjectile justLaunched)
public void Save(SaveInfo info)
private void LetExistingProjectileGo()
public bool HasLock()
}
public LocomotiveExtraVisuals : MonoBehaviour {
private TrainEngine trainEngine
private Transform needleA
private Transform needleB
private Transform needleC
private float maxAngle
private float speedoMoveSpeed
private float pressureMoveSpeed
private float fanAcceleration
private float fanMaxSpeed
private float speedoMax
private Transform[] engineFans
}
public LODComponent : BaseMonoBehaviour {
public LODDistanceMode DistanceMode
public OccludeeParameters OccludeeParams
}
public LODComponentParticleSystem : LODComponent {
public bool playOnShow
}
public LODDistanceMode : Enum {
public int value__
public LODDistanceMode XYZ
public LODDistanceMode XZ
public LODDistanceMode Y
}
public LODEnvironmentMode : Enum {
public int value__
public LODEnvironmentMode Default
public LODEnvironmentMode Underground
}
public LODGrid : SingletonComponent`1<LODGrid> {
public bool Paused
public float CellSize
public float MaxMilliseconds
public float MaxRefreshDistance
public float TreeMeshDistance
public float MinTimeBetweenRefreshes
}
public LodLevelDisplay : MonoBehaviour {
public Color TextColor
public float TextScaleMultiplier
}
public LODManager : SingletonComponent`1<LODManager> {
public float MaxMilliseconds
}
public LODMasterMesh : LODComponent {
public MeshRenderer ReplacementMesh
public float Distance
public LODComponent[] ChildComponents
public bool Block
public Bounds MeshBounds
}
public LODUtil : object {
public float DefaultDistance
public float GetDistance(Transform transform, LODDistanceMode mode)
public float GetDistance(Vector3 worldPos, LODDistanceMode mode)
public float VerifyDistance(float distance)
public LODEnvironmentMode DetermineEnvironmentMode(Transform transform)
}
public LookAt : MonoBehaviour {
public Transform target
private void Update()
}
public LookatHealth : MonoBehaviour {
public bool Enabled
public GameObject container
public Text textHealth
public Text textStability
public Image healthBar
public Image healthBarBG
public Color barBGColorNormal
public Color barBGColorUnstable
}
public LookAtIOEnt : MonoBehaviour {
public Text objectTitle
public RectTransform slotToolTip
public Text slotTitle
public Text slotConnection
public Text slotPower
public Text powerText
public Text passthroughText
public Text chargeLeftText
public Text capacityText
public Text maxOutputText
public Text activeOutputText
public Text turretInterferenceText
public IOEntityUISlotEntry[] inputEntries
public IOEntityUISlotEntry[] outputEntries
public Color NoPowerColor
public GameObject GravityWarning
public GameObject DistanceWarning
public GameObject LineOfSightWarning
public GameObject TooManyInputsWarning
public GameObject TooManyOutputsWarning
public GameObject BuildPrivilegeWarning
public CanvasGroup group
public HandleSet[] handleSets
public RectTransform clearNotification
public CanvasGroup wireInfoGroup
public Text wireLengthText
public Text wireClipsText
public Text errorReasonTextTooFar
public Text errorReasonTextNoSurface
public Text errorShortCircuit
public RawImage ConnectionTypeIcon
public Texture ElectricSprite
public Texture FluidSprite
public Texture IndustrialSprite
}
public LookAtPlant : MonoBehaviour {
public CanvasGroup group
public UIGenesDisplay GeneDisplay
public UIGenesDisplay GeneDisplay2
public Text TextPlant
public Image PlantIcon
public InfoBar Age
public InfoBar Stage
public InfoBar WaterIntake
public Text TextYieldLabel
public InfoBar Yield
public InfoBar Health
public InfoBar Light
public InfoBar WaterSaturation
public InfoBar Ground
public InfoBar Temperature
public InfoBar Overall
}
public LookAtPlanter : MonoBehaviour {
public CanvasGroup group
public Text waterText
}
public LookatTooltip : MonoBehaviour {
public bool Enabled
public BaseEntity currentlyLookingAt
public RustText textLabel
public RustText moreOptionsLabel
public Image icon
public Phrase moreOptionsDefaultPhrase
public CanvasGroup canvasGroup
public CanvasGroup infoGroup
public CanvasGroup minimiseGroup
}
public LookAtWeaponRack : MonoBehaviour {
public CanvasGroup weaponInfoGroup
public CanvasGroup rotationGroup
public Text TextWeapon
public Image IconWeapon
public Image IconAmmo
public RawImage IconHorizontal
public RawImage IconVertical
public InfoBar AmmoBar
public InfoBar ConditionBar
public Color ValidRotationColor
public Color InvalidRotationColor
}
public LootableCorpse : BaseCorpse {
public string lootPanelName
public ulong playerSteamID
public string _playerName
private string <streamerName>k__BackingField
private bool <blockBagDrop>k__BackingField
public ItemContainer[] containers
private bool firstLooted
public string playerName
public string streamerName
public Phrase LootPanelTitle
public Phrase LootPanelName
public bool blockBagDrop
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public string get_playerName()
public void set_playerName(string value)
public string get_streamerName()
public void set_streamerName(string value)
public Phrase get_LootPanelTitle()
public Phrase get_LootPanelName()
public void ResetState()
public bool get_blockBagDrop()
public void set_blockBagDrop(bool value)
public void ServerInit()
internal void DoServerDestroy()
public void TakeFrom(BaseEntity fromEntity, ItemContainer[] source)
public bool CanRemove()
public bool CanLoot()
public bool OnStartBeingLooted(BasePlayer baseEntity)
protected bool CanLootContainer(ItemContainer c, int index)
private void RPC_LootCorpse(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
protected void PreDropItems()
public void DropItems()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public LootAllButton : MonoBehaviour {
public Func`2<Item, bool> Filter
public OvenLootPanel inventoryGrid
}
public LootContainer : StorageContainer {
public bool destroyOnEmpty
public LootSpawn lootDefinition
public int maxDefinitionsToSpawn
public float minSecondsBetweenRefresh
public float maxSecondsBetweenRefresh
public bool initialLootSpawn
public float xpLootedScale
public float xpDestroyedScale
public bool BlockPlayerItemInput
public int scrapAmount
public string deathStat
public LootSpawnSlot[] LootSpawnSlots
public spawnType SpawnType
public ClanScoreEventType clanScoreEventForFirstLooter
public ulong FirstLooterId
private ItemDefinition scrapDef
public bool shouldRefreshContents
public bool get_shouldRefreshContents()
public void ResetState()
public void ServerInit()
public void PostServerLoad()
public void SpawnLoot()
public int ScoreForRarity(Rarity rarity)
public void PopulateLoot()
public void GenerateScrap()
public void DropBonusItems(BaseEntity initiator, ItemContainer container)
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void PlayerStoppedLooting(BasePlayer player)
public void RemoveMe()
public bool ShouldDropItemsIndividually()
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
public void InitShared()
}
public LootContainerAchievement : LootContainer {
public string AchievementName
public bool AllowDuringTutorial
public bool OnStartBeingLooted(BasePlayer baseEntity)
}
public LootDistanceOverride : MonoBehaviour {
public float amount
}
public LootGrid : MonoBehaviour {
public int Container
public int Offset
public int Count
public GameObject ItemIconPrefab
public Sprite BackgroundImage
public ItemContainerSource Inventory
private List`1<ItemIcon> _icons
public void CreateInventory(ItemContainerSource inventory, Nullable`1<int> slots, Nullable`1<int> offset)
}
public LootPanel : MonoBehaviour {
public Text Title
public RustText TitleText
public bool hideInvalidIcons
public CanvasGroup canvasGroup
}
public LootPanelBigWheelTerminal : LootPanel {
public Text timeRemainingText
}
public LootPanelCardTableTerminal : LootPanel {
private Text buyInInfoText
private Phrase phraseMin
private Phrase phraseMax
}
public LootPanelContainer : MonoBehaviour {
public string containerName
public GameObject NoLootPanel
}
public LootPanelEngine : LootPanel {
private Image engineImage
private ItemIcon[] icons
private GameObject warning
private RustText hp
private RustText power
private RustText acceleration
private RustText topSpeed
private RustText fuelEconomy
}
public LootPanelFrankensteinTable : LootPanel {
public Button StartCreatingButton
}
public LootPanelHorse : LootPanel {
public Text breedTitle
public Text maxSpeedText
public Text staminaText
public Text healthText
public GameObject[] storageSlots
}
public LootPanelIndustrialCrafter : LootPanel {
public GameObject CraftingRoot
public RustSlider ProgressSlider
public Transform Spinner
public float SpinSpeed
public GameObject WorkbenchLevelRoot
}
public LootPanelLocker : LootPanel {
public GameObject[] controls
}
public LootPanelMixingTable : LootPanel {
public GameObject controlsOn
public GameObject controlsOff
public Button StartMixingButton
public InfoBar ProgressBar
public GameObject recipeItemPrefab
public RectTransform recipeContentRect
public ScrollRect ScrollView
}
public LootPanelPlayerCorpse : LootPanel {
public GameObject[] BeltRoots
public GameObject[] ClothingRoots
}
public LootPanelReclaim : LootPanel {
public int oldOverflow
public Text overflowText
public GameObject overflowObject
public Phrase MorePhrase
}
public LootPanelRecycler : LootPanel {
public GameObject controlsOn
public GameObject controlsOff
public GameObject recycle_efficiency_safezone
public GameObject recycle_efficiency_radtown
}
public LootPanelToolCupboard : LootPanel {
public List`1<VirtualItemIcon> costIcons
public Text costPerTimeText
public Text protectedText
public GameObject baseNotProtectedObj
public GameObject baseProtectedObj
public Phrase protectedPrefix
public Tooltip costToolTip
public Phrase blocksPhrase
public GameObject toolsRow
}
public LootPanelTrophyStand : LootPanel {
public GameObject SubmitButton
public GameObject NonMatchingTrophyButton
public Text CountText
public GameObject CountRoot
public GameObject NameRoot
public RustText NameText
public GameObject ClearButton
}
public LootPanelVendingMachine : LootPanel {
public GameObjectRef sellOrderPrefab
public GameObject sellOrderContainer
public GameObject busyOverlayPrefab
private GameObject busyOverlayInstance
}
public LootPanelWaterCatcher : LootPanel {
public ItemIcon sourceItem
public Image capacityImage
public CanvasGroup helpCanvas
public CanvasGroup buttonsCanvas
public Button fromButton
public Button toButton
public Button drinkButton
}
public LootSpawn : ScriptableObject {
public ItemAmountRanged[] items
public Entry[] subSpawn
public ItemDefinition GetBlueprintBaseDef()
public void SpawnIntoContainer(ItemContainer container)
private void SubCategoryIntoContainer(ItemContainer container)
}
public m2bradleyAnimator : MonoBehaviour {
public Animator m2Animator
public Material treadLeftMaterial
public Material treadRightMaterial
private Rigidbody mainRigidbody
public Transform turret
public Transform mainCannon
public Transform coaxGun
public Transform rocketsPitch
public Transform spotLightYaw
public Transform spotLightPitch
public Transform sideMG
public Transform[] sideguns
public Transform[] ShocksBones
public Transform[] ShockTraceLineBegin
public Vector3[] vecShocksOffsetPosition
public Transform targetTurret
public Transform targetSpotLight
public Transform[] targetSideguns
private Vector3 vecTurret
private Vector3 vecMainCannon
private Vector3 vecCoaxGun
private Vector3 vecRocketsPitch
private Vector3 vecSpotLightBase
private Vector3 vecSpotLight
private float sideMGPitchValue
public GameObject muzzleflashCannon
public GameObject muzzleflashCoaxGun
public GameObject muzzleflashSideMG
public GameObject[] muzzleflashRockets
public GameObject spotLightHaloSawnpoint
public GameObject[] muzzleflashSideguns
public GameObjectRef machineGunMuzzleFlashFX
public GameObjectRef mainCannonFireFX
public GameObjectRef rocketLaunchFX
public bool rocketsOpen
public Vector3[] vecSideGunRotation
public float treadConstant
public float wheelSpinConstant
public float sidegunsTurnSpeed
public float turretTurnSpeed
public float cannonPitchSpeed
public float rocketPitchSpeed
public float spotLightTurnSpeed
public float machineGunSpeed
private float wheelAngle
private void Start()
private void Update()
private void AnimateWheelsTreads()
private void AdjustShocksHeight()
private void TrackTurret()
private void TrackSpotLight()
private void TrackSideGuns()
public void CalculateYawPitchOffset(Transform objectTransform, Vector3 vecStart, Vector3 vecEnd, Single& yaw, Single& pitch)
public float NormalizeYaw(float flYaw)
}
public M2BradleyPhysics : MonoBehaviour {
private m2bradleyAnimator m2Animator
public WheelCollider[] Wheels
public WheelCollider[] TurningWheels
public Rigidbody mainRigidbody
public Transform[] waypoints
private Vector3 currentWaypoint
private Vector3 nextWaypoint
}
public MagnetCrane : GroundVehicle {
public Animator animator
private Transform COM
public float arm1Speed
public float arm2Speed
public float turnYawSpeed
public BaseMagnet Magnet
private MagnetCraneAudio mcAudio
public Rigidbody myRigidbody
private Transform[] collisionTestingPoints
public float maxDistanceFromOrigin
public GameObjectRef selfDamageEffect
private GameObjectRef explosionEffect
private Transform explosionPoint
private CapsuleCollider driverCollision
private Transform leftHandTarget
private Transform rightHandTarget
private Transform leftFootTarget
private Transform rightFootTarget
public float idleFuelPerSec
public float maxFuelPerSec
private GameObject[] OnTriggers
public TriggerHurtEx magnetDamage
public int engineKW
private CarWheel[] wheels
public CarSettings carSettings
private ParticleSystem exhaustInner
private ParticleSystem exhaustOuter
private EmissionToggle lightToggle
public Phrase ReturnMessage
private Flags Flag_ArmMovement
private Flags Flag_BaseMovementInput
private int leftTreadParam
private int rightTreadParam
private int yawParam
private int arm1Param
private int arm2Param
public float steerInput
public float throttleInput
private float brakeInput
public float yawInput
public float extensionInput
public float raiseArmInput
public float extensionMove
public float yawMove
public float raiseArmMove
public float nextToggleTime
public Vector3 spawnOrigin
public float lastExtensionArmState
public float lastRaiseArmState
public float lastYawState
public bool handbrakeOn
public float nextSelfHealTime
public Vector3 lastDamagePos
public float lastDrivenTime
public float lastFixedUpdateTime
public CarPhysics`1<MagnetCrane> carPhysics
public VehicleTerrainHandler serverTerrainHandler
private Vector3 customInertiaTensor
public float extensionArmState
public float raiseArmState
public float yawState
public float DriveWheelVelocity
public Surface OnSurface
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float get_DriveWheelVelocity()
public float GetThrottleInput()
public float GetBrakeInput()
public void Load(LoadInfo info)
public float GetMaxForwardSpeed()
public bool CanBeLooted(BasePlayer player)
public Surface get_OnSurface()
public void ServerInit()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public float MaxVelocity()
public float GetSteerInput()
public bool GetSteerModInput()
public void OnEngineStartFailed()
public bool MeetsEngineRequirements()
public void VehicleFixedUpdate()
public void Save(SaveInfo info)
public void UpdateParams()
public void LateUpdate()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public bool IsColliding()
public float GetMaxDriveForce()
public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
public CarWheel[] GetWheels()
public float GetWheelsMidPos()
public void UpdateAnimator(float dt)
public void RPC_OpenFuel(RPCMessage msg)
internal float <VehicleFixedUpdate>g__UpdateMoveInput|78_0(float input, float move, float slowRate, float dt)
}
public MagnetCraneAudio : MonoBehaviour {
public MagnetCrane crane
public SoundDefinition engineStartSoundDef
public SoundDefinition engineStopSoundDef
public BlendedLoopEngineSound engineLoops
public SoundDefinition cabinRotationStartDef
public SoundDefinition cabinRotationStopDef
public SoundDefinition cabinRotationLoopDef
private Sound cabinRotationLoop
public SoundDefinition turningLoopDef
private Sound turningLoop
public SoundDefinition trackMovementLoopDef
private Sound trackMovementLoop
private Modulator trackGainMod
private Modulator trackPitchMod
public SoundDefinition armMovementLoopDef
public SoundDefinition armMovementStartDef
public SoundDefinition armMovementStopDef
private Sound armMovementLoop01
private Modulator armMovementLoop01PitchMod
public GameObject arm01SoundPosition
public GameObject arm02SoundPosition
private Sound armMovementLoop02
private Modulator armMovementLoop02PitchMod
}
public MagnetLiftable : EntityComponent`1<BaseEntity> {
public ItemAmount[] shredResources
public Vector3 shredDirection
private BasePlayer <associatedPlayer>k__BackingField
public BasePlayer associatedPlayer
public BasePlayer get_associatedPlayer()
private void set_associatedPlayer(BasePlayer value)
public void SetMagnetized(bool wantsOn, BaseMagnet magnetSource, BasePlayer player)
}
public MagnetSnap : object {
private Transform snapLocation
private Vector3 prevSnapLocation
public void .ctor(Transform snapLocation)
public void FixedUpdate(Transform target)
public void PositionTarget(Transform target)
}
public Mailbox : StorageContainer {
public string ownerPanel
public GameObjectRef mailDropSound
public ItemDefinition[] allowedItems
public bool autoSubmitWhenClosed
public bool shouldMarkAsFull
public int mailInputSlot
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int get_mailInputSlot()
public bool PlayerIsOwner(BasePlayer player)
public bool IsFull()
public void MarkFull(bool full)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
private bool HasFreeSpace()
private int GetFreeSlot()
public bool MoveItemToStorage(Item item)
public void PlayerStoppedLooting(BasePlayer player)
public void RPC_Submit(RPCMessage msg)
public void SubmitInputItems(BasePlayer fromPlayer)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool CanMoveFrom(BasePlayer player, Item item)
public bool ItemFilter(Item item, int targetSlot)
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
}
public MainCamera : RustCamera`1<MainCamera> {
public Camera mainCamera
public Transform mainCameraTransform
public Action PreCullCallback
private Vector3 <velocity>k__BackingField
public bool isValid
public Vector3 velocity
public Vector3 position
public Vector3 forward
public Vector3 right
public Vector3 up
public Quaternion rotation
public Ray Ray
public bool get_isValid()
public Vector3 get_velocity()
private void set_velocity(Vector3 value)
public Vector3 get_position()
public void set_position(Vector3 value)
public Vector3 get_forward()
public void set_forward(Vector3 value)
public Vector3 get_right()
public void set_right(Vector3 value)
public Vector3 get_up()
public void set_up(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public Ray get_Ray()
}
public MainMenuSystem : SingletonComponent`1<MainMenuSystem> {
public bool isOpen
public Action OnOpenStateChanged
public RustButton SessionButton
public GameObject SessionPanel
public GameObject NewsStoriesAlert
public GameObject ItemStoreAlert
public GameObject CompanionAlert
public GameObject DemoBrowser
public GameObject DemoBrowserButton
public GameObject SuicideButton
public GameObject EndDemoButton
public GameObject ReflexModeOption
public GameObject ReflexLatencyMarkerOption
private GameObject QuitConfirmation
public GameObject QuitTutorialOption
private GameObject Connection
private UISafeZoneWarning safeZoneWarning
}
public ManagedNoise : object {
private Int32[] hash
private int hashMask
private double sqrt2
private double rsqrt2
private double squaresToTriangles
private double trianglesToSquares
private double simplexScale1D
private double simplexScale2D
private double gradientScale2D
private Double[] gradients1D
private int gradientsMask1D
private Double[] gradients2Dx
private Double[] gradients2Dy
private int gradientsMask2D
public double Simplex1D(double x)
public double Simplex1D(double x, Double& dx)
public double Simplex2D(double x, double y)
public double Simplex2D(double x, double y, Double& dx, Double& dy)
public double Turbulence(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double Billow(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double Ridge(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double Sharp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double TurbulenceIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double BillowIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double RidgeIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double SharpIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double TurbulenceWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double BillowWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double RidgeWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double SharpWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double Jordan(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp, double damp, double damp_scale)
private int Floor(double x)
private double Abs(double x)
private double Saturate(double x)
}
public MapEntity : HeldEntity {
public UInt32[] fogImages
public UInt32[] paintImages
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ImageUpdate(RPCMessage msg)
}
public MapImageRenderer : object {
private Vector4 StartColor
private Vector4 WaterColor
private Vector4 GravelColor
private Vector4 DirtColor
private Vector4 SandColor
private Vector4 GrassColor
private Vector4 ForestColor
private Vector4 RockColor
private Vector4 SnowColor
private Vector4 PebbleColor
private Vector4 OffShoreColor
private Vector3 SunDirection
private float SunPower
private float Brightness
private float Contrast
private float OceanWaterLevel
private Vector4 Half
public Byte[] Render(Int32& imageWidth, Int32& imageHeight, Color& background, float scale, bool lossy, bool transparent, int oceanMargin)
private Byte[] EncodeToFile(int width, int height, Color[] pixels, bool lossy)
private Vector3 UnpackNormal(Vector4 value)
}
public MapInterface : SingletonComponent`1<MapInterface> {
public bool IsOpen
public Image cameraPositon
public ScrollRectEx scrollRect
public ScrollRectZoom scrollRectZoom
public RustButton showGridToggle
public RustButton FocusButton
public CanvasGroup CanvasGroup
public SoundDefinition PlaceMarkerSound
public SoundDefinition ClearMarkerSound
public MapView View
public UINexusMap NexusMap
public GameObject NexusButtonGroup
public RustButton NexusToggle
public Color[] PointOfInterestColours
public PointOfInterestSpriteConfig[] PointOfInterestSprites
public Sprite PingBackground
public bool DebugStayOpen
public GameObject MarkerListSection
public GameObject ControlsRoot
public GameObjectRef MarkerListPrefab
public GameObject MarkerHeader
public Transform LocalPlayerMarkerListParent
public Transform TeamMarkerListParent
public GameObject TeamLeaderHeader
public GameObject MissionListHeader
public Transform MissionListContent
public GameObjectRef MissionListPrefab
public VendorList VendorList
public RustButton HideTeamLeaderMarkersToggle
public CanvasGroup TeamMarkersCanvas
public RustImageButton ShowSleepingBagsButton
public RustImageButton ShowVendingMachinesButton
public RustImageButton ShowMissionProvidersButton
public UIEscapeCapture EscapeCapture
}
public MapLayer : Enum {
public int value__
public MapLayer Overworld
public MapLayer TrainTunnels
public MapLayer Underwater1
public MapLayer Underwater2
public MapLayer Underwater3
public MapLayer Underwater4
public MapLayer Underwater5
public MapLayer Underwater6
public MapLayer Underwater7
public MapLayer Underwater8
public MapLayer Dungeons
}
public MapLayerRenderer : SingletonComponent`1<MapLayerRenderer> {
public Camera renderCamera
public CameraEvent cameraEvent
public Material renderMaterial
private Nullable`1<MapLayer> _currentlyRenderedLayer
private Nullable`1<NetworkableId> _currentlyRenderedDungeon
private Nullable`1<int> _underwaterLabFloorCount
public bool DebugLabs
public void Render(MapLayer layer)
private void RenderImpl(CommandBuffer cb)
public MapLayerRenderer GetOrCreate()
private void RenderDungeonsLayer()
private CommandBuffer BuildCommandBufferDungeons(ProceduralDynamicDungeon closest)
public ProceduralDynamicDungeon FindDungeon(Vector3 position, float maxDist)
private void RenderTrainLayer()
private CommandBuffer BuildCommandBufferTrainTunnels()
private void RenderUnderwaterLabs(int floor)
public int GetUnderwaterLabFloorCount()
private CommandBuffer BuildCommandBufferUnderwaterLabs(int floor)
}
public MapMarker : BaseEntity {
public AppMarkerType appType
public GameObjectRef markerObj
public List`1<MapMarker> serverMapMarkers
public void InitShared()
public void DestroyShared()
public AppMarker GetAppMarkerData()
}
public MapMarkerCH47 : MapMarker {
public bool IsCargoShip
public bool AutomaticallySetRotationToParent
public bool UseEntityRotation
private float GetRotation(BaseEntity forEntity)
public AppMarker GetAppMarkerData()
}
public MapMarkerDeliveryDrone : MapMarker {
public void ServerInit()
public bool ShouldNetworkTo(BasePlayer player)
}
public MapMarkerExplosion : MapMarker {
private float duration
public void SetDuration(float newDuration)
public void Load(LoadInfo info)
public void DelayedDestroy()
}
public MapMarkerGenericRadius : MapMarker {
public float radius
public Color color1
public Color color2
public float alpha
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SendUpdate(bool fullUpdate)
public AppMarker GetAppMarkerData()
}
public MapMarkerIconSelector : MonoBehaviour {
public Image OuterImage
public Image InnerImage
public GameObject Selected
}
public MapMarkerMissionProvider : MapMarker {
private List`1<BaseMission> missionsProvided
private string providerToken
public void Load(LoadInfo info)
public void AssignMissions(List`1<BaseMission> missions, string token)
public void Save(SaveInfo info)
}
public MapMarkerMLRSRocket : MapMarker {
public void ServerInit()
public bool ShouldNetworkTo(BasePlayer player)
}
public MapMarkerPet : MapMarker {
public void ServerInit()
public bool ShouldNetworkTo(BasePlayer player)
}
public MapUploader : object {
private bool <IsUploaded>k__BackingField
private string <OriginalName>k__BackingField
private string <OriginalMapFileName>k__BackingField
private string <OriginalSaveFileName>k__BackingField
private HttpClient Http
public bool IsUploaded
public string OriginalName
public string OriginalMapFileName
public string OriginalSaveFileName
public bool get_IsUploaded()
private void set_IsUploaded(bool value)
public string get_OriginalName()
private void set_OriginalName(string value)
public string get_OriginalMapFileName()
private void set_OriginalMapFileName(string value)
public string get_OriginalSaveFileName()
private void set_OriginalSaveFileName(string value)
public void UploadMap()
private Task`1<string> UploadMapImpl(Stream stream, string mapFileName)
}
public MapView : FacepunchBehaviour {
public RawImage mapImage
public Image cameraPositon
public ScrollRectEx scrollRect
public GameObject monumentMarkerContainer
public Transform clusterMarkerContainer
public GameObjectRef monumentMarkerPrefab
public GameObject missionMarkerContainer
public GameObjectRef missionMarkerPrefab
public Transform activeInteractionParent
public Transform localPlayerInterestPointRoot
public GameObject shelterMarkerContainer
public GameObjectRef shelterMapMarkerPrefab
public TeamMemberMapMarker[] teamPositions
public TeamMemberMapMarker[] clanPositions
public List`1<PointOfInterestMapMarker> PointOfInterestMarkers
public List`1<PointOfInterestMapMarker> TeamPointOfInterestMarkers
public List`1<PointOfInterestMapMarker> LocalPings
public List`1<PointOfInterestMapMarker> TeamPings
public GameObject PlayerDeathMarker
public List`1<SleepingBagMapMarker> SleepingBagMarkers
public List`1<SleepingBagClusterMapMarker> SleepingBagClusters
public RawImage UndergroundLayer
public bool ShowGrid
public bool ShowPointOfInterestMarkers
public bool ShowDeathMarker
public bool ShowSleepingBags
public bool AllowSleepingBagDeletion
public bool ShowLocalPlayer
public bool ShowTeamMembers
public bool ShowBagsOnBottom
public bool ShowTrainLayer
public bool ShowMissions
public bool ForceShowVendingMachines
public bool ShowUndergroundLayers
public bool MLRSMarkerMode
public RustImageButton LockButton
public RustImageButton OverworldButton
public RustImageButton TrainButton
public RustImageButton[] UnderwaterButtons
public RustImageButton DungeonButton
public CanvasLineRenderer CargoPatrolPath
public CanvasLineRenderer[] HarborPaths
public CanvasLineRenderer FerryPath
public UnityEvent onClicked
public void OnPointerDown(PointerEventData eventData)
}
public Marketplace : BaseEntity {
public GameObjectRef terminalPrefab
public Transform[] terminalPoints
public Transform droneLaunchPoint
public GameObjectRef deliveryDronePrefab
public EntityRef`1[] terminalEntities
public NetworkableId SendDrone(BasePlayer player, MarketTerminal sourceTerminal, VendingMachine vendingMachine)
public void ReturnDrone(DeliveryDrone deliveryDrone)
public void Spawn()
private void SpawnSubEntities()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
}
public MarketTerminal : StorageContainer {
public Flags Flag_HasItems
public Flags Flag_InventoryFull
public GameObjectRef menuPrefab
public ulong lockToCustomerDuration
public ulong orderTimeout
public ItemDefinition deliveryFeeCurrency
public int deliveryFeeAmount
public DeliveryDroneConfig config
public RustText userLabel
private ulong _customerSteamId
private string _customerName
private TimeUntil _timeUntilCustomerExpiry
private EntityRef`1<Marketplace> _marketplace
public List`1<PendingOrder> pendingOrders
public Action`2<BasePlayer, Item> _onCurrencyRemovedCached
public Action`2<BasePlayer, Item> _onItemPurchasedCached
private Action _checkForExpiredOrdersCached
private bool _transactionActive
private List`1<NetworkableId> _deliveryEligible
private RealTimeSince _deliveryEligibleLastCalculated
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanPlayerAffordOrderAndDeliveryFee(BasePlayer player, SellOrder sellOrder, int numberOfTransactions)
public bool HasPendingOrderFor(NetworkableId vendingMachineId)
public bool CanPlayerInteract(BasePlayer player)
public void Load(LoadInfo info)
public void Setup(Marketplace marketplace)
public void ServerInit()
private void RegisterOrder(BasePlayer player, VendingMachine vendingMachine)
public void CompleteOrder(NetworkableId vendingMachineId)
private void CheckForExpiredOrders()
private void RestrictToPlayer(BasePlayer player)
private void ClearRestriction()
public void Server_TryOpenMarket(RPCMessage msg)
public void Server_Purchase(RPCMessage msg)
private void UpdateHasItems(bool sendNetworkUpdate)
private void OnCurrencyRemoved(BasePlayer player, Item currencyItem)
private void OnItemPurchased(BasePlayer player, Item purchasedItem)
public void Save(SaveInfo info)
public bool ItemFilter(Item item, int targetSlot)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
private void RemoveAnyLooters()
public void GetDeliveryEligibleVendingMachines(List`1<NetworkableId> vendingMachineIds)
private bool <GetDeliveryEligibleVendingMachines>g__IsEligible|42_0(VendingMachine vendingMachine, Vector3 offset, int n)
}
public MaterialColorLerp : MonoBehaviour {
public Color startColor
public Color endColor
public Color currentColor
public float delta
}
public MaterialConfig : ScriptableObject {
public ShaderParametersFloat[] Floats
public ShaderParametersColor[] Colors
public ShaderParametersTexture[] Textures
public ShaderParametersToggle[] Toggles
public String[] ScaleUV
public EnvironmentVolumeOverride[] EnvironmentVolumeOverrides
private MaterialPropertyBlock properties
public MaterialPropertyBlock GetMaterialPropertyBlock(Material mat, Vector3 pos, Vector3 scale)
}
public MaterialEffect : ScriptableObject {
public GameObjectRef DefaultEffect
public SoundDefinition DefaultSoundDefinition
public Entry[] Entries
public int waterFootstepIndex
public Entry deepWaterEntry
public float deepWaterDepth
public Entry submergedWaterEntry
public float submergedWaterDepth
public bool ScaleVolumeWithSpeed
public AnimationCurve SpeedGainCurve
public Entry GetEntryFromMaterial(PhysicMaterial mat)
public Entry GetWaterEntry()
public void SpawnOnRay(Ray ray, int mask, float length, Vector3 forward, float speed)
public void PlaySound(SoundDefinition definition, Vector3 position, float velocity)
}
public MaterialOverlay : MonoBehaviour {
public Material material
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public MaterialParameterToggle : MonoBehaviour {
public ToggleMode Toggle
public Renderer[] TargetRenderers
public Color EmissionColor
}
public MaterialPropertyDesc : ValueType {
public int nameID
public Type type
public void .ctor(string name, Type type)
}
public MaterialSetup : ProceduralObject {
public MaterialConfig config
public bool IncludeChildren
protected void OnEnable()
public void Process()
private void Setup()
}
public MaterialSound : ScriptableObject {
public SoundDefinition DefaultSound
public Entry[] Entries
}
public MaterialSwap : MonoBehaviour {
public int materialIndex
public Renderer myRenderer
public Material OverrideMaterial
}
public MaxSpawnDistance : MonoBehaviour {
public float maxDistance
}
public MedicalTool : AttackEntity {
public float healDurationSelf
public float healDurationOther
public float healDurationOtherWounded
public float maxDistanceOther
public bool canUseOnOther
public bool canRevive
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void UseOther(RPCMessage msg)
private void UseSelf(RPCMessage msg)
public void ServerUse()
private void GiveEffectsTo(BasePlayer player)
}
public Megaphone : HeldEntity {
public VoiceProcessor voiceProcessor
public float VoiceDamageMinFrequency
public float VoiceDamageAmount
public AudioSource VoiceSource
public SoundDefinition StartBroadcastingSfx
public SoundDefinition StopBroadcastingSfx
private float <MegaphoneVoiceRange>k__BackingField
public float MegaphoneVoiceRange
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float get_MegaphoneVoiceRange()
public void set_MegaphoneVoiceRange(float value)
public void UpdateItemCondition()
private void Server_ToggleBroadcasting(RPCMessage msg)
}
public MeleeWeaponInformationPanel : ItemInformationPanel {
public ItemStatValue damageDisplay
public ItemStatValue attackRateDisplay
public ItemStatValue attackSizeDisplay
public ItemStatValue attackRangeDisplay
public ItemStatValue oreGatherDisplay
public ItemStatValue treeGatherDisplay
public ItemStatValue fleshGatherDisplay
public GameObject untieCrateDisplay
}
public MemoryBankType : Enum {
public int value__
public MemoryBankType Entity
public MemoryBankType Position
public MemoryBankType AIPoint
}
public MemorySlotUI : MonoBehaviour {
public RustText Label
}
public MenuBackgroundOverride : MonoBehaviour {
public Texture2D Background
public Color Tint
}
public MenuBackgroundPanel : SingletonComponent`1<MenuBackgroundPanel> {
public CoverImage Image
public float FadeDuration
}
public MenuBackgroundVideo : SingletonComponent`1<MenuBackgroundVideo> {
private String[] videos
private int index
private bool errored
protected void Awake()
private void OnVideoError(VideoPlayer source, string message)
public void LoadVideoList()
public void Update()
private void NextVideo()
internal IEnumerator ReadyVideo()
}
public MenuButtonArcadeEntity : TextArcadeEntity {
public string titleText
public string selectionSuffix
public string clickMessage
public bool IsHighlighted()
}
public MenuHelp : MonoBehaviour {
public TutorialFullScreenHelpInfo[] AllHelp
public RectTransform CategoriesParent
public RectTransform ContentParent
public GameObjectRef CategoryWidget
public GameObjectRef HelpWidget
public MenuCategory StartingCategory
}
public MenuHelpCategory : MonoBehaviour {
public RustText CategoryText
}
public MenuHelpWidget : MonoBehaviour {
public RustText HelpText
public Image HelpImage
public VideoPlayer HelpVideo
public RawImage HelpVideoTexture
}
public MenuServerPanel : MonoBehaviour {
private void Start()
private void Update()
}
public MenuTip : MonoBehaviour {
public TextMeshProUGUI text
public LoadingScreen screen
public Phrase[] MenuTips
private int currentTipIndex
private float nextTipTime
public void OnEnable()
public void Update()
public void UpdateTip()
}
public MeshBatch : MonoBehaviour {
private bool <NeedsRefresh>k__BackingField
private int <Count>k__BackingField
private int <BatchedCount>k__BackingField
private int <VertexCount>k__BackingField
public bool NeedsRefresh
public int Count
public int BatchedCount
public int VertexCount
public int VertexCapacity
public int VertexCutoff
public int AvailableVertices
public bool get_NeedsRefresh()
private void set_NeedsRefresh(bool value)
public int get_Count()
private void set_Count(int value)
public int get_BatchedCount()
private void set_BatchedCount(int value)
public int get_VertexCount()
private void set_VertexCount(int value)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
public int get_VertexCapacity()
public int get_VertexCutoff()
public int get_AvailableVertices()
public void Alloc()
public void Free()
public void Refresh()
public void Apply()
public void Display()
public void Invalidate()
protected void AddVertices(int vertices)
protected void OnEnable()
protected void OnDisable()
}
public MeshCache : object {
public Dictionary`2<Mesh, Data> dictionary
public Data Get(Mesh mesh)
}
public MeshColliderData : object {
public List`1<int> triangles
public List`1<Vector3> vertices
public List`1<Vector3> normals
public void Alloc()
public void Free()
public void Clear()
public void Apply(Mesh mesh)
public void Combine(MeshColliderGroup meshGroup)
public void Combine(MeshColliderGroup meshGroup, MeshColliderLookup colliderLookup)
}
public MeshColliderInstance : ValueType {
public Transform transform
public Rigidbody rigidbody
public Collider collider
public OBB bounds
public Vector3 position
public Quaternion rotation
public Vector3 scale
public Data data
public Mesh mesh
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public MeshColliderLookup : object {
public LookupGroup src
public LookupGroup dst
public void Apply()
public void Add(MeshColliderInstance instance)
public LookupEntry Get(int index)
}
public MeshCull : LODComponent {
public float Distance
}
public MeshData : object {
public List`1<int> triangles
public List`1<Vector3> vertices
public List`1<Vector3> normals
public List`1<Vector4> tangents
public List`1<Color32> colors32
public List`1<Vector2> uv
public List`1<Vector2> uv2
public List`1<Vector4> positions
public void AllocMinimal()
public void Alloc()
public void Free()
public void Clear()
public void Apply(Mesh mesh)
public void Combine(MeshGroup meshGroup)
}
public MeshDataBatch : MeshBatch {
private Vector3 position
private Mesh meshBatch
private MeshFilter meshFilter
private MeshRenderer meshRenderer
private MeshData meshData
private MeshGroup meshGroup
public int VertexCapacity
public int VertexCutoff
public int get_VertexCapacity()
public int get_VertexCutoff()
protected void Awake()
public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
public void Add(MeshInstance instance)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
}
public MeshGroupCull : LODComponent {
public float Distance
}
public MeshHolder : object {
public Vector3[] _vertices
public Vector3[] _normals
public Int32[] _triangles
public trisPerSubmesh[] _TrianglesOfSubs
public Matrix4x4[] _bindPoses
public BoneWeight[] _boneWeights
public Bounds _bounds
public int _subMeshCount
public Vector4[] _tangents
public Vector2[] _uv
public Vector2[] _uv2
public Vector2[] _uv3
public Color[] _colors
public Vector2[] _uv4
public void setAnimationData(Mesh mesh)
}
public MeshInstance : ValueType {
public Vector3 position
public Quaternion rotation
public Vector3 scale
public Data data
public Mesh mesh
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public MeshLOD : LODComponent {
public State[] States
}
public MeshPaintable : BaseMeshPaintable {
public string replacementTextureName
public int textureWidth
public int textureHeight
public Color clearColor
public Texture2D targetTexture
public bool hasChanges
}
public MeshPaintable3D : BaseMeshPaintable {
public float brushScale
public float uvBufferScale
public string replacementTextureName
public int textureWidth
public int textureHeight
public Camera cameraPreview
public Camera camera3D
}
public MeshPaintableSource : MonoBehaviour {
public Vector4 uvRange
public int texWidth
public int texHeight
public string replacementTextureName
public float cameraFOV
public float cameraDistance
public Texture2D texture
public GameObject sourceObject
public Mesh collisionMesh
public Vector3 localPosition
public Vector3 localRotation
public bool applyToAllRenderers
public Renderer[] extraRenderers
public bool paint3D
public bool applyToSkinRenderers
public bool applyToFirstPersonLegs
public bool isSelected
public Renderer legRenderer
private MaterialPropertyBlock block
public void Init()
public void Free()
public void OnDestroy()
public void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride, bool forEditing, bool isSelected)
public Color32[] UpdateFrom(Texture2D input)
public void Load(Byte[] data)
public void Clear()
}
public MeshPaintController : MonoBehaviour {
public Camera pickerCamera
public Tool currentTool
public Texture2D brushTexture
public Vector2 brushScale
public Color brushColor
public float brushSpacing
public float brushSpacingFactor
public RawImage brushImage
public float brushPreviewScaleMultiplier
public Texture2D stampTexture
public RotateMode brushRotation
public bool applyDefaults
public Texture2D defaltBrushTexture
public float defaultBrushSize
public Color defaultBrushColor
public float defaultBrushAlpha
public float maxBrushScale
public RustButton UndoButton
public RustButton RedoButton
public GameObject BackgroundBlocker
private Vector3 lastPosition
}
public MeshRendererBatch : MeshBatch {
private Vector3 position
private Mesh meshBatch
private MeshFilter meshFilter
private MeshRenderer meshRenderer
private MeshRendererData meshData
private MeshRendererGroup meshGroup
private MeshRendererLookup meshLookup
private MaterialPropertyBlock propertyBlock
public int VertexCapacity
public int VertexCutoff
public int get_VertexCapacity()
public int get_VertexCutoff()
protected void Awake()
public void SetupColor(Color color)
public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer, Color color)
public void Add(MeshRendererInstance instance)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
}
public MeshRendererData : object {
public List`1<int> triangles
public List`1<Vector3> vertices
public List`1<Vector3> normals
public List`1<Vector4> tangents
public List`1<Color32> colors32
public List`1<Vector2> uv
public List`1<Vector2> uv2
public List`1<Vector4> positions
public void Alloc()
public void Free()
public void Clear()
public void Apply(Mesh mesh)
public void Combine(MeshRendererGroup meshGroup)
public void Combine(MeshRendererGroup meshGroup, MeshRendererLookup rendererLookup)
}
public MeshRendererInstance : ValueType {
public Renderer renderer
public OBB bounds
public Vector3 position
public Quaternion rotation
public Vector3 scale
public Data data
public Mesh mesh
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public MeshRendererLookup : object {
public LookupGroup src
public LookupGroup dst
public void Apply()
public void Clear()
public void Add(MeshRendererInstance instance)
public LookupEntry Get(int index)
}
public MeshReplacement : MonoBehaviour {
public SkinnedMeshRenderer Female
internal void Process(GameObject go, bool IsFemale)
}
public MeshTerrainRoot : MonoBehaviour {
public GameObject TerrainBlendSearchRoot
public Mesh TerrainMeshAsset
public Material TerrainMaterial
}
public MeshToggle : MonoBehaviour {
public Mesh[] RendererMeshes
public Mesh[] ColliderMeshes
public void SwitchRenderer(int index)
public void SwitchRenderer(float factor)
public void SwitchCollider(int index)
public void SwitchCollider(float factor)
public void SwitchAll(int index)
public void SwitchAll(float factor)
}
public MeshTrimTester : MonoBehaviour {
public MeshTrimSettings Settings
public Mesh SourceMesh
public MeshFilter TargetMeshFilter
public int SubtractIndex
}
public Meta : ConsoleSystem {
public void add(Arg args)
public void if_true(Arg args)
public void if_false(Arg args)
public void reset_cycle(Arg args)
public void exec(Arg args)
private Command Find(string name)
}
public MetabolismAttribute : object {
public float startMin
public float startMax
public float min
public float max
public float value
public float lastValue
internal float lastGreatFraction
private float greatInterval
public float greatFraction
public float get_greatFraction()
public void Reset()
public float Fraction()
public float InverseFraction()
public void Add(float val)
public void Subtract(float val)
public void Set(float val)
public void Increase(float fTarget)
public void MoveTowards(float fTarget, float fRate)
public bool HasChanged()
public bool HasGreatlyChanged()
public void SetValue(float newValue)
}
public MetalDetectorFlag : BaseDiggableEntity {
public Collider Collision
public GameObject FlagModel
public float MoveUpBy
public float TimeoutDuration
public void ServerInit()
private void ResetTimeout()
private void Timeout()
public void OnFullyDug(BasePlayer player)
public void OnSingleDig(BasePlayer player)
public void OnFirstDig(BasePlayer player)
}
public MetalDetectorSource : BaseEntity {
public float Population
public int AttemptsPerSubSourceSpawn
public float MinDistanceBetweenSubSources
public float TimeoutDuration
public int ServerCount
public bool DrawEditorGizmos
public int MinSources
public int MaxSources
public float SpawnRadiusMin
public float SpawnRadiusMax
public float SpawnRadiusBuffer
public GameObjectRef FlagPrefab
public GameObjectRef EffectPrefab
private float <SpawnRadius>k__BackingField
private List`1<Vector3> <SpawnLocations>k__BackingField
public int placementMask
public int blockMask
public float SpawnRadius
public List`1<Vector3> SpawnLocations
public float get_SpawnRadius()
private void set_SpawnRadius(float value)
public List`1<Vector3> get_SpawnLocations()
private void set_SpawnLocations(List`1<Vector3> value)
public void ServerCountSources()
public void ServerInit()
internal void DoServerDestroy()
private void SpawnSources()
private void TrySpawnSource()
private bool ValidateSourcePosition(Vector3& pos)
private void ResetTimeout()
private void Timeout()
private void KillIfNoSources()
private void AddSource(Vector3 pos)
private void RemoveSource(Vector3 pos)
public Vector3 FindNearestSubSource(Vector3 scanPosition)
public void RemoveSweetSpotAndCreateFlag(Vector3 position)
private void CreateFlag(Vector3 pos)
public bool VerifySweetSpotPosition(Vector3 playerPos, Vector3 pos, Vector3& spotPos)
public List`1<Vector3> GetScanLocations()
public Vector3 GetNearestPosition(Vector3 pos)
public bool VerifyScanPosition(Vector3 playerPos, Vector3 pos, Vector3& spotPos)
public void Detected(Vector3 pos)
public float GetRadius()
}
public MetalDetectorViewmodel : BaseViewModel {
public GameObject[] LongRangeLights
public GameObject[] SweetspotLights
public GameObject LongRangeLight
public Transform YawTransform
public Transform DetectPos
public MetalDetectorViewmodelAnimEvents viewmodelAnimEvents
public SkinnedMeshRenderer MeshRenderer
public Color BulbOffColor
public Color BulbOnColor
}
public MetalDetectorViewmodelAnimEvents : BaseMonoBehaviour {
public float scanAmount
public SoundDefinition scanSwingSoundDef
}
public MicrophoneStand : BaseMountable {
public VoiceProcessor VoiceProcessor
public AudioSource VoiceSource
private SpeechMode currentSpeechMode
public AudioMixerGroup NormalMix
public AudioMixerGroup HighPitchMix
public AudioMixerGroup LowPitchMix
public Phrase NormalPhrase
public Phrase NormalDescPhrase
public Phrase HighPitchPhrase
public Phrase HighPitchDescPhrase
public Phrase LowPitchPhrase
public Phrase LowPitchDescPhrase
public GameObjectRef IOSubEntity
public Transform IOSubEntitySpawnPos
public bool IsStatic
public EntityRef`1<IOEntity> ioEntity
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SetMode(RPCMessage msg)
public void Save(SaveInfo info)
public void SpawnChildEntity()
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public void PostMapEntitySpawn()
public void Load(LoadInfo info)
}
public MicrophoneStandIOEntity : IOEntity {
public int PowerCost
public TriggerBase InstrumentTrigger
public bool IsStatic
public int ConsumptionAmount()
public int DesiredPower(int inputIndex)
public int MaximalPowerOutput()
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
public int GetPassthroughAmount(int outputSlot)
public bool IsRootEntity()
public IOEntity ToEntity()
}
public Minicopter : PlayerHelicopter {
public float population
}
public MiniCopterAnimation : MonoBehaviour {
public void UpdateRotorSpeed(float newSpeed)
private void Update()
}
public MiningQuarry : BaseResourceExtractor {
public Animator beltAnimator
public Renderer beltScrollRenderer
public int scrollMatIndex
public float animatorSpeedChange
public float beltScrollSpeedMultiplier
public SoundPlayer[] onSounds
public float processRate
public float workToAdd
public float workPerFuel
public float pendingWork
public GameObjectRef bucketDropEffect
public GameObject bucketDropTransform
public ChildPrefab engineSwitchPrefab
public ChildPrefab hopperPrefab
public ChildPrefab fuelStoragePrefab
public QuarryType staticType
public bool isStatic
public ResourceDeposit _linkedDeposit
public bool IsEngineOn()
public void SetOn(bool isOn)
public void EngineSwitch(bool isOn)
public void ServerInit()
public bool CanAcceptItem(Item item, int targetSlot)
public void UpdateStaticDeposit()
public void PostServerLoad()
public void SpawnChildEntities()
public void ProcessResources()
public bool FuelCheck()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public MinMax : object {
public float x
public float y
public void .ctor(float x, float y)
public float Random()
public float Lerp(float t)
public float Lerp(float a, float b, float t)
}
public MinMaxAttribute : PropertyAttribute {
public float min
public float max
public void .ctor(float min, float max)
}
public MissionEntity : BaseMonoBehaviour {
public string identifier
public bool cleanupOnMissionSuccess
public bool cleanupOnMissionFailed
public void OnParentDestroying()
public void Setup(BasePlayer assignee, MissionInstance instance, string identifier, bool wantsSuccessCleanup, bool wantsFailedCleanup)
public void MissionStarted(BasePlayer assignee, MissionInstance instance)
public void MissionEnded(BasePlayer assignee, MissionInstance instance)
public BaseEntity GetEntity()
}
public MissionManifest : ScriptableObject {
public ScriptableObjectRef[] missionList
public WorldPositionGenerator[] positionGenerators
public MissionManifest instance
public MissionManifest Get()
public BaseMission GetFromShortName(string shortname)
public BaseMission GetFromID(UInt32 id)
}
public MissionMapMarker : MonoBehaviour {
public Image Icon
public Tooltip TooltipComponent
public void Populate(MissionInstance mission)
}
public MissionObjective : ScriptableObject {
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance)
public void ObjectiveFailed(BasePlayer playerFor, int index, MissionInstance instance)
public bool IsStarted(int index, MissionInstance instance)
public bool CanProgress(int index, MissionInstance instance)
public bool ShouldObjectiveStart(int index, MissionInstance instance)
public bool IsCompleted(int index, MissionInstance instance)
public bool ShouldThink(int index, MissionInstance instance)
public void ResetObjective(int index, MissionInstance instance, BasePlayer playerFor)
public void CompleteObjective(int index, MissionInstance instance, BasePlayer playerFor)
public void FailObjective(int index, MissionInstance instance, BasePlayer playerFor)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
protected bool TryFindNearby(Vector3 origin, Func`2<T, bool> filter, T& entity, float radius)
public void PostServerLoad(BasePlayer player, ObjectiveStatus status)
}
public MissionObjective_AcquireItem : MissionObjective {
public ItemDefinition targetItem
public int targetItemAmount
public bool allowStackEvents
public bool showResourcePings
public bool acceptExistingItems
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
}
public MissionObjective_Consume : MissionObjective {
public ItemDefinition TargetItem
public int RequiredAmount
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_CookItem : MissionObjective {
public ItemDefinition targetItem
public int targetItemAmount
public BaseEntityRef[] pingEntitiesOnTutorialIsland
public PingType pingType
public bool checkExistingInventory
private bool HasPings
private bool get_HasPings()
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_Craft : MissionObjective {
public ItemDefinition[] targetItems
public int targetItemAmount
public bool checkExistingInventory
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
}
public MissionObjective_DeployItem : MissionObjective {
public BaseEntity[] PossibleOptions
public ItemDefinition[] PossibleItems
public int RequiredAmount
public bool PingTutorialTargets
private PingType PingType
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
private bool Matches(MissionEventPayload payload)
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
private void UpdatePings(BasePlayer playerFor)
}
public MissionObjective_EnterTrigger : MissionObjective {
public string positionName
public float distForCompletion
public bool use2D
public BaseMountable requiredMountable
public bool shouldPing
public PingType pingType
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_EquipClothing : MissionObjective {
public ItemDefinition[] RequiredItems
public bool CheckExistingClothingOnStart
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_FillTutorialToolCupboard : MissionObjective {
public int RequiredUpkeepHours
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
}
public MissionObjective_FreeCrate : MissionObjective {
public int targetAmount
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
}
public MissionObjective_Harvest : MissionObjective {
public ItemDefinition[] targetItems
public int targetItemAmount
public ItemDefinition[] pingResourceDispensers
public PingType pingType
public bool countExisting
public void PostServerLoad(BasePlayer player, ObjectiveStatus status)
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
private void InitialiseResourcePings(BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance)
}
public MissionObjective_HaveItem : MissionObjective {
public ItemDefinition targetItem
public int targetItemAmount
public bool canBeReset
public BaseEntityRef[] pingEntitiesOnTutorialIsland
public PingType pingType
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
}
public MissionObjective_Heal : MissionObjective {
public float RequiredHealthNormalised
public BaseEntityRef RequireHealSource
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_HurtEntityType : MissionObjective {
public BaseEntityRef[] targetEntities
public float targetDamage
public bool shouldUpdateMissionLocation
private bool isInitalized
private UInt32[] targetPrefabIDs
private Func`2<BaseCombatEntity, bool> searchFilter
private void EnsureInitialized()
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
private bool <Think>b__9_0(BaseCombatEntity e)
}
public MissionObjective_HurtMissionEntity : MissionObjective {
public string targetIdentifier
public float targetDamage
public bool shouldUpdateMissionLocation
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
}
public MissionObjective_IgniteOven : MissionObjective {
public BaseEntityRef TargetOven
public bool PingTarget
public PingType PingType
private Func`2<BaseCombatEntity, bool> searchFilter
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
private bool <MissionStarted>b__4_0(BaseCombatEntity e)
}
public MissionObjective_KillEntity : MissionObjective {
public BaseEntityRef[] targetEntities
public int numToKill
public bool shouldUpdateMissionLocation
public bool pingTargets
private bool isInitalized
private UInt32[] targetPrefabIDs
private Func`2<BaseCombatEntity, bool> searchFilter
private void EnsureInitialized()
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
private bool <Think>b__10_0(BaseCombatEntity e)
}
public MissionObjective_MetalDetectorFind : MissionObjective {
public int RequiredFinds
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_MountEntityType : MissionObjective {
public BaseEntityRef[] targetEntities
public int numToMount
public bool shouldUpdateMissionLocation
private bool isInitalized
private UInt32[] targetPrefabIDs
private Func`2<BaseEntity, bool> searchFilter
private void EnsureInitialized()
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
private bool <Think>b__9_0(BaseEntity e)
}
public MissionObjective_MountMissionEntity : MissionObjective {
public string targetIdentifier
public bool shouldUpdateMissionLocation
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
}
public MissionObjective_Move : MissionObjective {
public string positionName
public float distForCompletion
public bool use2D
public BaseMountable requiredMountable
public bool shouldPing
public PingType pingType
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void Think(int index, MissionInstance instance, BasePlayer assignee, float delta)
}
public MissionObjective_OpenTutorialStorageContainer : MissionObjective {
public ItemAmount[] Items
public BaseEntity TargetEntity
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance)
private void DeregisterPing(BasePlayer playerFor)
public void ObjectiveFailed(BasePlayer playerFor, int index, MissionInstance instance)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_PlayerInput : MissionObjective {
public BUTTON requiredButton
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance)
public void ObjectiveFailed(BasePlayer playerFor, int index, MissionInstance instance)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_Respawn : MissionObjective {
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_RetrieveItemsFromCorpse : MissionObjective {
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionObjective_SpeakWith : MissionObjective {
public ItemAmount[] requiredReturnItems
public bool destroyReturnItems
public bool showPing
public bool checkSpaceForRewards
public Phrase NoSpaceInInventoryPhrase
public void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
public void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance)
private void DeregisterPing(BasePlayer playerFor, MissionInstance instance)
public void ObjectiveFailed(BasePlayer playerFor, int index, MissionInstance instance)
}
public MissionObjective_UpgradeBuildingBlock : MissionObjective {
public bool ShouldPingBlocksLessThanTargetGrade
public PingType PingType
public Enum TargetGrade
public int RequiredCount
public void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer)
public void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount)
}
public MissionPoint : MonoBehaviour {
public bool dropToGround
public int COUNT
public int EVERYTHING
public int NOTHING
public int EASY_MONUMENT
public int MED_MONUMENT
public int HARD_MONUMENT
public int ITEM_HIDESPOT
public int UNDERWATER
public int TUTORIAL_BEAR
public int EASY_MONUMENT_IDX
public int MED_MONUMENT_IDX
public int HARD_MONUMENT_IDX
public int ITEM_HIDESPOT_IDX
public int FOREST_IDX
public int ROADSIDE_IDX
public int BEACH
public int UNDERWATER_IDX
public int TUTORIAL_BEAR_IDX
private Dictionary`2<int, int> type2index
public MissionPointEnum Flags
public List`1<MissionPoint> all
public int TypeToIndex(int id)
public int IndexToType(int idx)
public void Awake()
private void Start()
private void DropToGround()
public void OnDisable()
public Vector3 GetPosition()
public Quaternion GetRotation()
public bool GetMissionPoints(List`1& points, Vector3 near, float minDistance, float maxDistance, int flags, int exclusionFlags)
}
public MissionPointMapMarker : MonoBehaviour {
public RustText MissionName
public Image Icon
}
public MissionsHUD : SingletonComponent`1<MissionsHUD> {
public SoundDefinition listComplete
public SoundDefinition itemComplete
public SoundDefinition popup
public Canvas Canvas
public RustText titleText
public GameObject timerObject
public RustText timerText
}
public MissionsHUDToDo : BaseMonoBehaviour {
private Memoized`2<string, ValueTuple`2<float, float>> FormatProgres
public RustText text
public RectTransform checkIcon
public RectTransform checkBox
public Phrase optionalPrefix
public CanvasGroup group
public Color DefaultColor
public Color CompletedColor
public Color CompletedHighlightColor
public Color FailedColor
public Color FailedHighlightColor
public PingWidget PingWidget
}
public MissionUIPanel : MonoBehaviour {
public GameObject activeMissionParent
public RustText missionTitleText
public RustText missionDescText
public GameObject rewardsParent
public VirtualItemIcon[] rewardIcons
public GameObject bonusRewardsParent
public VirtualItemIcon[] bonusIcons
public Phrase noMissionText
public GameObject abandonButton
}
public MixerSnapshotManager : SingletonComponent`1<MixerSnapshotManager> {
public AudioMixerSnapshot defaultSnapshot
public AudioMixerSnapshot underwaterSnapshot
public AudioMixerSnapshot loadingSnapshot
public AudioMixerSnapshot woundedSnapshot
public AudioMixerSnapshot cctvSnapshot
public AudioMixerSnapshot fadeToBlackSnapshot
public SoundDefinition underwaterInSound
public SoundDefinition underwaterOutSound
public AudioMixerSnapshot recordingSnapshot
public SoundDefinition woundedLoop
private Sound woundedLoopSound
public SoundDefinition cctvModeLoopDef
private Sound cctvModeLoop
public SoundDefinition cctvModeStartDef
public SoundDefinition cctvModeStopDef
public float deafness
}
public MixingTable : StorageContainer {
public GameObject Particles
public RecipeList Recipes
public bool OnlyAcceptValidIngredients
private float <RemainingMixTime>k__BackingField
private float <TotalMixTime>k__BackingField
public float lastTickTimestamp
private List`1<Item> inventoryItems
private BasePlayer <MixStartingPlayer>k__BackingField
private float mixTickInterval
public Recipe currentRecipe
public int currentQuantity
public ItemDefinition currentProductionItem
public float RemainingMixTime
public float TotalMixTime
public BasePlayer MixStartingPlayer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float get_RemainingMixTime()
public void set_RemainingMixTime(float value)
public float get_TotalMixTime()
public void set_TotalMixTime(float value)
public BasePlayer get_MixStartingPlayer()
private void set_MixStartingPlayer(BasePlayer value)
public void ServerInit()
private bool CanAcceptItem(Item item, int targetSlot)
protected void OnInventoryDirty()
private void SVSwitch(RPCMessage msg)
public void StartMixing(BasePlayer player)
protected bool CanStartMixing(BasePlayer player)
public void StopMixing()
public void TickMix()
public void ProduceItem(Recipe recipe, int quantity)
private void ConsumeInventory(Recipe recipe, int quantity)
private void ReturnExcessItems(List`1<Item> orderedContainerItems, BasePlayer player)
protected void CreateRecipeItems(Recipe recipe, int quantity)
public void Save(SaveInfo info)
private int GetItemWaterAmount(Item item)
public void Load(LoadInfo info)
public List`1<Item> GetOrderedContainerItems(ItemContainer container, Boolean& itemsAreContiguous)
}
public MLRS : BaseMountable {
private GameObjectRef rocketStoragePrefab
private GameObjectRef dashboardStoragePrefab
private Transform hRotator
public float hRotSpeed
private Transform vRotator
public float vRotSpeed
public float vRotMax
private Transform hydraulics
public float minRange
public float targetAreaRadius
private GameObjectRef mlrsRocket
public Transform firingPoint
public RocketTube[] rocketTubes
private GameObject screensChild
private Transform leftHandGrip
private Transform leftJoystick
private Transform rightHandGrip
private Transform rightJoystick
private Transform controlKnobHeight
private Transform controlKnobAngle
private GameObjectRef uiDialogPrefab
private Light fireButtonLight
private GameObject brokenDownEffect
private ParticleSystem topScreenShutdown
private ParticleSystem bottomScreenShutdown
public float brokenDownMinutes
private Vector3 <UserTargetHitPos>k__BackingField
private Vector3 <TrueHitPos>k__BackingField
private float <CurGravityMultiplier>k__BackingField
private int <RocketAmmoCount>k__BackingField
private bool <IsRealigning>k__BackingField
public Flags FLAG_FIRING_ROCKETS
public Flags FLAG_HAS_AIMING_MODULE
private EntityRef rocketStorageInstance
private EntityRef dashboardStorageInstance
public float rocketBaseGravity
public float rocketSpeed
private float <RocketDamageRadius>k__BackingField
private bool isInitialLoad
public string MLRS_PLAYER_KILL_STAT
private float leftRightInput
private float upDownInput
public Vector3 lastSentTargetHitPos
public Vector3 lastSentTrueHitPos
public int nextRocketIndex
public EntityRef rocketOwnerRef
public TimeSince timeSinceBroken
public int radiusModIndex
private Single[] radiusMods
public Vector3 trueTargetHitPos
public Vector3 UserTargetHitPos
public Vector3 TrueHitPos
public bool HasAimingModule
public bool CanBeUsed
public bool CanFire
public float HRotation
public float VRotation
public float CurGravityMultiplier
public int RocketAmmoCount
public bool IsRealigning
public bool IsFiringRockets
public float RocketDamageRadius
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 get_UserTargetHitPos()
public void set_UserTargetHitPos(Vector3 value)
public Vector3 get_TrueHitPos()
public void set_TrueHitPos(Vector3 value)
public bool get_HasAimingModule()
public bool get_CanBeUsed()
public bool get_CanFire()
public float get_HRotation()
public void set_HRotation(float value)
public float get_VRotation()
public void set_VRotation(float value)
public float get_CurGravityMultiplier()
public void set_CurGravityMultiplier(float value)
public int get_RocketAmmoCount()
public void set_RocketAmmoCount(int value)
public bool get_IsRealigning()
public void set_IsRealigning(bool value)
public bool get_IsFiringRockets()
public float get_RocketDamageRadius()
private void set_RocketDamageRadius(float value)
public void InitShared()
public void Load(LoadInfo info)
public bool CanBeLooted(BasePlayer player)
public void SetUserTargetHitPos(Vector3 worldPos)
public StorageContainer GetRocketContainer()
public StorageContainer GetDashboardContainer()
public void HitPosToRotation(Vector3 hitPos, Single& hRot, Single& vRot, Single& g)
public float ProjectileDistToSpeed(float x, float y, float angle, float g, float fallbackV)
protected void OnChildAdded(BaseEntity child)
public void VehicleFixedUpdate()
public float GetSurfaceHeight(Vector3 pos)
public void SetRepaired()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void Save(SaveInfo info)
public bool AdminFixUp()
public void Fire(BasePlayer owner)
public void EndFiring()
public void FireNextRocket()
private void UpdateStorageState()
public bool TryGetAimingModule(Item& item)
public void RPC_SetTargetHitPos(RPCMessage msg)
public void RPC_Fire_Rockets(RPCMessage msg)
public void RPC_Open_Rockets(RPCMessage msg)
public void RPC_Open_Dashboard(RPCMessage msg)
}
public MLRSAmmoIcon : MonoBehaviour {
private GameObject fill
protected void Awake()
public void SetState(bool filled)
}
public MLRSAmmoUI : MonoBehaviour {
private RustText ammoText
private MLRSAmmoIcon[] ammoIcons
}
public MLRSAudio : MonoBehaviour {
private MLRS mlrs
private Transform pitchTransform
private Transform yawTransform
private float pitchDeltaSmoothRate
private float yawDeltaSmoothRate
private float pitchDeltaThreshold
private float yawDeltaThreshold
private float lastPitch
private float lastYaw
private float pitchDelta
private float yawDelta
public SoundDefinition turretMovementStartDef
public SoundDefinition turretMovementLoopDef
public SoundDefinition turretMovementStopDef
private Sound turretMovementLoop
}
public MLRSMainUI : MonoBehaviour {
private bool isFullscreen
private GameObject noAimingModuleModeGO
private GameObject activeModeGO
private MLRSAmmoUI noAimingModuleAmmoUI
private MLRSAmmoUI activeAmmoUI
private MLRSVelocityUI velocityUI
private RustText titleText
private RustText usernameText
private TokenisedPhrase readyStatus
private TokenisedPhrase realigningStatus
private TokenisedPhrase firingStatus
private RustText statusText
private MapView mapView
private ScrollRectEx mapScrollRect
private ScrollRectZoom mapScrollRectZoom
private RectTransform mapBaseRect
private RectTransform minRangeCircle
private RectTransform targetAimRect
private RectTransform trueAimRect
private UILineRenderer connectingLine
private GameObject noTargetCirclePrefab
private Transform noTargetCircleParent
private SoundDefinition changeTargetSoundDef
private SoundDefinition readyToFireSoundDef
}
public MLRSRocket : TimedExplosive {
private GameObjectRef mapMarkerPrefab
private GameObjectRef launchBlastFXPrefab
private GameObjectRef explosionGroundFXPrefab
private ServerProjectile serverProjectile
private EntityRef mapMarkerInstanceRef
public List`1<MLRSRocket> serverList
public SamTargetType SAMTargetType
public SamTargetType get_SAMTargetType()
public void ServerInit()
internal void DoServerDestroy()
public void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
private void CreateMapMarker()
public bool IsValidSAMTarget(bool staticRespawn)
public Vector3 GetLocalVelocityServer()
private void OnTriggerEnter(Collider other)
}
public MLRSServerProjectile : ServerProjectile {
public bool HasRangeLimit
protected int mask
public bool get_HasRangeLimit()
protected int get_mask()
protected bool IsAValidHit(BaseEntity hitEnt)
}
public MLRSUIDialog : UIDialog {
private MLRSMainUI mainUI
private TokenisedPhrase howToUsePhrase
private float titleChangeInterval
}
public MLRSVelocityUI : MonoBehaviour {
private RustText percentText
private HudElement percentBar
}
public MobileInventoryEntity : BaseEntity {
public SoundDefinition ringingLoop
public SoundDefinition silentLoop
public Flags Ringing
public Flags Flag_Silent
public void ToggleRinging(bool state)
public void SetSilentMode(bool wantsSilent)
}
public MobileMapMarker : MapMarker {
private GameObject createdMarker
}
public MobilePhone : HeldEntity {
public PhoneController Controller
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Save(SaveInfo info)
public void ServerInit()
public void PostServerLoad()
internal void DoServerDestroy()
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
public void ClearCurrentUser(RPCMessage msg)
public void SetCurrentUser(RPCMessage msg)
public void InitiateCall(RPCMessage msg)
public void AnswerPhone(RPCMessage msg)
private void ServerHangUp(RPCMessage msg)
public void DestroyShared()
public void UpdatePhoneName(RPCMessage msg)
public void Server_RequestPhoneDirectory(RPCMessage msg)
public void Server_AddSavedNumber(RPCMessage msg)
public void Server_RemoveSavedNumber(RPCMessage msg)
public void Server_RequestCurrentState(RPCMessage msg)
public void ServerSendVoicemail(RPCMessage msg)
public void ServerPlayVoicemail(RPCMessage msg)
public void ServerStopVoicemail(RPCMessage msg)
public void ServerDeleteVoicemail(RPCMessage msg)
public void ToggleRinging(bool state)
public void Load(LoadInfo info)
public void OnFlagsChanged(Flags old, Flags next)
}
public Model : MonoBehaviour {
public SphereCollider collision
public Transform rootBone
public Transform headBone
public Transform eyeBone
public Animator animator
public Skeleton skeleton
public Transform[] boneTransforms
public String[] boneNames
internal BoneDictionary boneDict
internal int skin
protected void OnEnable()
public void BuildBoneDictionary()
public int GetSkin()
private Transform FindBoneInternal(string name)
public Transform FindBone(string name)
public Transform FindBone(UInt32 hash)
public UInt32 FindBoneID(Transform transform)
public Transform[] GetBones()
public Transform FindClosestBone(Vector3 worldPos)
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public ModelConditionTest : PrefabAttribute {
public bool DoTest(BaseEntity ent)
protected Type GetIndexedType()
}
public ModelConditionTest_False : ModelConditionTest {
public ConditionalModel reference
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_FoundationSide : ModelConditionTest {
private string square_south
private string square_north
private string square_west
private string square_east
private string triangle_south
private string triangle_northwest
private string triangle_northeast
private string socket
protected void OnDrawGizmosSelected()
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_Inside : ModelConditionTest {
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_Outside : ModelConditionTest {
public bool DoTest(BaseEntity ent)
public bool CheckCondition(BaseEntity ent)
}
public ModelConditionTest_RampHigh : ModelConditionTest {
private string socket
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RampLow : ModelConditionTest {
private string socket
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofBottom : ModelConditionTest {
private string roof_square
private string roof_triangle
private string socket_bot_right
private string socket_bot_left
private string socket_top_right
private string socket_top_left
private String[] sockets_bot_right
private String[] sockets_bot_left
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofLeft : ModelConditionTest {
public AngleType angle
public ShapeType shape
private string roof_square
private string roof_triangle
private string socket_right
private string socket_left
private String[] sockets_left
private bool IsConvex
private bool IsConcave
private bool get_IsConvex()
private bool get_IsConcave()
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofRight : ModelConditionTest {
public AngleType angle
public ShapeType shape
private string roof_square
private string roof_triangle
private string socket_right
private string socket_left
private String[] sockets_right
private bool IsConvex
private bool IsConcave
private bool get_IsConvex()
private bool get_IsConcave()
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofTop : ModelConditionTest {
private string roof_square
private string roof_triangle
private string socket_bot_right
private string socket_bot_left
private string socket_top_right
private string socket_top_left
private String[] sockets_top_right
private String[] sockets_top_left
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofTriangle : ModelConditionTest {
private string socket
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_SpiralStairs : ModelConditionTest {
private string stairs_socket_female
private String[] stairs_sockets_female
private string floor_socket_female
private String[] floor_sockets_female
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_True : ModelConditionTest {
public ConditionalModel reference
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_Variant : ModelConditionTest {
public ulong VariantSeed
public ulong VariantIndex
public ulong VariantCount
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_Wall : ModelConditionTest {
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallCornerLeft : ModelConditionTest {
private string socket
private String[] sockets
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallCornerRight : ModelConditionTest {
private string socket
private String[] sockets
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallTriangleLeft : ModelConditionTest {
private string socket_1
private string socket_2
private string socket_3
private string socket_4
private string socket_5
private string socket_6
private string socket
public bool CheckCondition(BaseEntity ent)
private bool CheckSocketOccupied(BaseEntity ent, string socket)
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallTriangleRight : ModelConditionTest {
private string socket_1
private string socket_2
private string socket_3
private string socket_4
private string socket_5
private string socket_6
private string socket
public bool CheckCondition(BaseEntity ent)
private bool CheckSocketOccupied(BaseEntity ent, string socket)
public bool DoTest(BaseEntity ent)
}
public Modifier : object {
private ModifierType <Type>k__BackingField
private ModifierSource <Source>k__BackingField
private float <Value>k__BackingField
private float <Duration>k__BackingField
private float <TimeRemaining>k__BackingField
private bool <Expired>k__BackingField
public ModifierType Type
public ModifierSource Source
public float Value
public float Duration
public float TimeRemaining
public bool Expired
public ModifierType get_Type()
private void set_Type(ModifierType value)
public ModifierSource get_Source()
private void set_Source(ModifierSource value)
public float get_Value()
private void set_Value(float value)
public float get_Duration()
private void set_Duration(float value)
public float get_TimeRemaining()
private void set_TimeRemaining(float value)
public bool get_Expired()
private void set_Expired(bool value)
public void Init(ModifierType type, ModifierSource source, float value, float duration, float remaining)
public void Tick(BaseCombatEntity ownerEntity, float delta)
public Modifier Save()
public void Load(Modifier m)
}
public ModifierDefintion : object {
public ModifierType type
public ModifierSource source
public float value
public float duration
}
public ModularCar : BaseModularVehicle {
public ModularCarChassisVisuals chassisVisuals
public VisualCarWheel wheelFL
public VisualCarWheel wheelFR
public VisualCarWheel wheelRL
public VisualCarWheel wheelRR
public CarSettings carSettings
public float hurtTriggerMinSpeed
public TriggerHurtNotChild hurtTriggerFront
public TriggerHurtNotChild hurtTriggerRear
public ProtectionProperties immortalProtection
public ProtectionProperties mortalProtection
private BoxCollider mainChassisCollider
public SpawnSettings spawnSettings
public MeshRenderer[] damageShowingRenderers
public float population
public float outsidedecayminutes
public BUTTON RapidSteerButton
private ModularCarCodeLock <CarLock>k__BackingField
public EngineState<GroundVehicle> lastSetEngineState
public float cachedFuelFraction
public HashSet`1<ModularCar> allCarsList
public ListDictionary`2<BaseMountable, DriverSeatInputs> driverSeatInputs
public CarPhysics`1<ModularCar> carPhysics
public VehicleTerrainHandler serverTerrainHandler
private CarWheel[] wheels
public float lastEngineOnTime
private float DECAY_TICK_TIME
private float INSIDE_DECAY_MULTIPLIER
private float CORPSE_DECAY_MINUTES
public Vector3 prevPosition
public Quaternion prevRotation
private Bounds collisionCheckBounds
private Vector3 lastGoodPos
private Quaternion lastGoodRot
private bool lastPosWasBad
public float deathDamageCounter
private float DAMAGE_TO_GIB
public TimeSince timeSinceDeath
private float IMMUNE_TIME
public Vector3 groundedCOMMultiplier
public Vector3 airbourneCOMMultiplier
public Vector3 prevCOMMultiplier
public float DriveWheelVelocity
public float DriveWheelSlip
public float SteerAngle
public ItemDefinition AssociatedItemDef
public float MaxSteerAngle
public bool IsLockable
public ModularCarCodeLock CarLock
public bool AlwaysAllowBradleyTargeting
public Surface OnSurface
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float get_DriveWheelVelocity()
public float get_DriveWheelSlip()
public float get_SteerAngle()
public ItemDefinition get_AssociatedItemDef()
public float get_MaxSteerAngle()
public bool get_IsLockable()
public ModularCarCodeLock get_CarLock()
private void set_CarLock(ModularCarCodeLock value)
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void InitShared()
public float MaxHealth()
public float StartHealth()
public float TotalHealth()
public float TotalMaxHealth()
public float GetMaxForwardSpeed()
public void Load(LoadInfo info)
public void OnFlagsChanged(Flags old, Flags next)
public float GetThrottleInput()
public float GetBrakeInput()
public float GetMaxDriveForce()
public float GetFuelFraction()
public bool PlayerHasUnlockPermission(BasePlayer player)
public bool KeycodeEntryBlocked(BasePlayer player)
public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)
public bool CanBeLooted(BasePlayer player)
public bool CanPushNow(BasePlayer pusher)
public bool RefreshEngineState()
public float RollOffDriveForce(float driveForce)
public void RefreshChassisProtectionState()
public void ModuleEntityAdded(BaseVehicleModule addedModule)
public void ModuleEntityRemoved(BaseVehicleModule removedModule)
public bool get_AlwaysAllowBradleyTargeting()
public Surface get_OnSurface()
public void ServerInit()
public void DoServerDestroy()
public void PostServerLoad()
public float GetSteerInput()
public bool GetSteerModInput()
public void VehicleFixedUpdate()
protected bool DetermineIfStationary()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void Save(SaveInfo info)
public void Hurt(HitInfo info)
public void TickFuel(float fuelUsedPerSecond)
public bool MountEligable(BasePlayer player)
public bool IsComplete()
public void DoDecayDamage(float damage)
public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
public bool HasAnyEngines()
public bool HasAnyWorkingEngines()
public bool MeetsEngineRequirements()
public void OnEngineStartFailed()
public CarWheel[] GetWheels()
public float GetWheelsMidPos()
public bool AdminFixUp(int tier)
public void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info)
public void PropagateDamageToModules(HitInfo info, float minPropagationPercent, float maxPropagationPercent, BaseVehicleModule ignoreModule)
public void ModuleReachedZeroHealth()
public void OnKilled(HitInfo info)
public void RemoveLock()
public void RestoreVelocity(Vector3 vel)
public Vector3 GetCOMMultiplier()
public void UpdateClients()
public void DecayTick()
protected void DoCollisionDamage(BaseEntity hitEntity, float damage)
public void SpawnPreassignedModules()
private void HandleAdminBonus()
public void RPC_OpenFuel(RPCMessage msg)
public void RPC_OpenFuelWithKeycode(RPCMessage msg)
public void RPC_TryMountWithKeycode(RPCMessage msg)
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
}
public ModularCarCentralLockingSwitch : VehicleModuleButtonComponent {
public Transform centralLockingSwitch
public Vector3 switchOffPos
public Vector3 switchOnPos
public void ServerUse(BasePlayer player, BaseVehicleModule parentModule)
}
public ModularCarChassisVisuals : VehicleChassisVisuals`1<ModularCar> {
public Transform frontAxle
public Transform rearAxle
public Steering steering
public LookAtTarget transmission
}
public ModularCarCodeLock : object {
private bool isServer
public ModularCar owner
public Flags FLAG_CENTRAL_LOCKING
public Flags FLAG_CODE_ENTRY_BLOCKED
public float LOCK_DESTROY_HEALTH
private List`1<ulong> whitelistPlayers
private string <Code>k__BackingField
private int wrongCodes
private float lastWrongTime
public bool HasALock
public bool CentralLockingIsOn
public IList`1<ulong> WhitelistPlayers
public string Code
public bool get_HasALock()
public bool get_CentralLockingIsOn()
public IList`1<ulong> get_WhitelistPlayers()
public void .ctor(ModularCar owner, bool isServer)
public bool PlayerCanDestroyLock(BaseVehicleModule viaModule)
public bool CodeEntryBlocked(BasePlayer player)
public void Load(LoadInfo info)
public bool HasLockPermission(BasePlayer player)
public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
public string get_Code()
private void set_Code(string value)
public void PostServerLoad()
public bool CanHaveALock()
public bool TryAddALock(string code, ulong userID)
public bool IsValidLockCode(string code)
public bool TrySetNewCode(string newCode, ulong userID)
public void RemoveLock()
public bool TryOpenWithCode(BasePlayer player, string codeEntered)
private void ClearCodeEntryBlocked()
public void CheckEnableCentralLocking()
public void ToggleCentralLocking()
public void Save(SaveInfo info)
public bool TryAddPlayer(ulong userID)
public bool TryRemovePlayer(ulong userID)
}
public ModularCarCodeLockVisuals : MonoBehaviour {
private GameObject lockedVisuals
private GameObject unlockedVisuals
private GameObject blockedVisuals
private GameObjectRef codelockEffectDenied
private GameObjectRef codelockEffectShock
private float xOffset
private ParticleSystemContainer keycodeDestroyableFX
}
public ModularCarGarage : ContainerIOEntity {
public Transform vehicleLift
public Animation vehicleLiftAnim
private string animName
public VehicleLiftOccupantTrigger occupantTrigger
public float liftMoveTime
public EmissionToggle poweredLight
public EmissionToggle inUseLight
public Transform vehicleLiftPos
public float recycleEfficiency
public Transform recycleDropPos
public bool needsElectricity
private SoundDefinition liftStartSoundDef
private SoundDefinition liftStopSoundDef
private SoundDefinition liftStopDownSoundDef
private SoundDefinition liftLoopSoundDef
private GameObjectRef addRemoveLockEffect
private GameObjectRef changeLockCodeEffect
private GameObjectRef repairEffect
private TriggerBase playerTrigger
public ChassisBuildOption[] chassisBuildOptions
public ItemAmount lockResourceCost
private bool <PlatformIsOccupied>k__BackingField
private bool <HasEditableOccupant>k__BackingField
private bool <HasDriveableOccupant>k__BackingField
private OccupantLock <OccupantLockState>k__BackingField
public VehicleLiftState vehicleLiftState
private Sound liftLoopSound
public Vector3 downPos
public Flags Flag_DestroyingChassis
public float TimeToDestroyChassis
public Flags Flag_EnteringKeycode
public Flags Flag_PlayerObstructing
public ModularCar lockedOccupant
public HashSet`1<BasePlayer> lootingPlayers
public MagnetSnap magnetSnap
public bool PlatformIsOccupied
public bool HasEditableOccupant
public bool HasDriveableOccupant
public OccupantLock OccupantLockState
public bool LiftIsUp
public bool LiftIsMoving
public bool LiftIsDown
public bool IsDestroyingChassis
private bool IsEnteringKeycode
public bool PlayerObstructingLift
public ModularCar carOccupant
public bool HasOccupant
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_PlatformIsOccupied()
public void set_PlatformIsOccupied(bool value)
public bool get_HasEditableOccupant()
public void set_HasEditableOccupant(bool value)
public bool get_HasDriveableOccupant()
public void set_HasDriveableOccupant(bool value)
public OccupantLock get_OccupantLockState()
public void set_OccupantLockState(OccupantLock value)
public bool get_LiftIsUp()
public bool get_LiftIsMoving()
public bool get_LiftIsDown()
public bool get_IsDestroyingChassis()
private bool get_IsEnteringKeycode()
public bool get_PlayerObstructingLift()
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void OnFlagsChanged(Flags old, Flags next)
public bool CanBeLooted(BasePlayer player)
public int ConsumptionAmount()
public void SetOccupantState(bool hasOccupant, bool editableOccupant, bool driveableOccupant, OccupantLock occupantLockState, bool forced)
public void RefreshLiftState(bool forced)
public void MoveLift(VehicleLiftState desiredLiftState, float startDelay, bool forced)
public void MoveLiftUp()
public void MoveLiftDown()
public ModularCar get_carOccupant()
public bool get_HasOccupant()
public void FixedUpdate()
internal void DoServerDestroy()
public void ServerInit()
public void Save(SaveInfo info)
public bool CanPickup(BasePlayer player)
public ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public void IOStateChanged(int inputAmount, int inputSlot)
public bool TryGetModuleForItem(Item item, BaseVehicleModule& result)
public void RefreshOnOffState()
public void UpdateCarOccupant()
public void UpdateOccupantMode()
public void WakeNearbyRigidbodies()
public void EditableOccupantEntered()
public void EditableOccupantLeft()
public void RefreshLoot()
public void GrabOccupant(ModularCar occupant)
public void ReleaseOccupant()
public void StopChassisDestroy()
public void RPC_RepairItem(RPCMessage msg)
public void RPC_OpenEditing(RPCMessage msg)
public void RPC_DiedWithKeypadOpen(RPCMessage msg)
public void RPC_SelectedLootItem(RPCMessage msg)
public void RPC_DeselectedLootItem(RPCMessage msg)
public void RPC_StartKeycodeEntry(RPCMessage msg)
public void RPC_RequestAddLock(RPCMessage msg)
public void RPC_RequestRemoveLock(RPCMessage msg)
public void RPC_RequestNewCode(RPCMessage msg)
public void RPC_StartDestroyingChassis(RPCMessage msg)
public void RPC_StopDestroyingChassis(RPCMessage msg)
public void FinishDestroyingChassis()
}
public ModularCarOven : BaseOven {
private BaseVehicleModule moduleParent
private BaseVehicleModule ModuleParent
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private BaseVehicleModule get_ModuleParent()
public void ResetState()
protected void SVSwitch(RPCMessage msg)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
protected void OnCooked()
}
public ModularCarPresetConfig : ScriptableObject {
public ItemModVehicleModule[] socketItemDefs
}
public ModularCarSeat : MouseSteerableSeat {
public Vector3 leftFootIKPos
public Vector3 rightFootIKPos
private Vector3 leftHandIKPos
private Vector3 rightHandIKPos
public float providesComfort
public VehicleModuleSeating associatedSeatingModule
public bool CanSwapToThis(BasePlayer player)
public float GetComfort()
}
public ModularVehicleShopFront : ShopFront {
public float maxUseDistance
public bool CanBeLooted(BasePlayer player)
public bool WithinUseDistance(BasePlayer player)
}
public Monument : TerrainPlacement {
public float Radius
public float Fade
public bool AutoCliffSplat
public bool AutoCliffTopology
protected void OnDrawGizmosSelected()
protected void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
}
public MonumentBenchmarkScene : BenchmarkScene {
public String[] monumentPrefabs
public Transform[] vantagePoints
}
public MonumentInfo : LandmarkInfo {
public MonumentType Type
public MonumentTier Tier
public int MinWorldSize
public Bounds Bounds
public bool HasNavmesh
public bool IsSafeZone
public bool WantsDungeonLink
public bool HasDungeonLink
public DungeonGridInfo DungeonEntrance
private OBB obbBounds
protected void Awake()
private void Start()
public bool CheckPlacement(Vector3 pos, Quaternion rot, Vector3 scale)
public float Distance(Vector3 position)
public float SqrDistance(Vector3 position)
public float Distance(OBB obb)
public float SqrDistance(OBB obb)
public bool IsInBounds(Vector3 position)
public Vector3 ClosestPointOnBounds(Vector3 position)
public Point GetPathFinderPoint(int res)
public int GetPathFinderRadius(int res)
protected void OnDrawGizmosSelected()
public MonumentNavMesh GetMonumentNavMesh()
public int TierToMask(MonumentTier tier)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
private DungeonGridInfo FindDungeonEntrance()
private bool DetermineHasDungeonLink()
private bool DetermineWantsDungeonLink()
}
public MonumentMarker : MonoBehaviour {
public Text text
public Image imageBackground
public Image image
public Color dayColor
public Color nightColor
public void Setup(LandmarkInfo info)
public void SetNightMode(bool nightMode)
}
public MonumentNavMesh : FacepunchBehaviour {
public int NavMeshAgentTypeIndex
public string DefaultAreaName
public int CellCount
public int CellSize
public int Height
public float NavmeshResolutionModifier
public bool overrideAutoBounds
public Bounds Bounds
public NavMeshData NavMeshData
public NavMeshDataInstance NavMeshDataInstance
public LayerMask LayerMask
public NavMeshCollectGeometry NavMeshCollectGeometry
public bool forceCollectTerrain
public bool shouldNotifyAIZones
public Transform CustomNavMeshRoot
public bool IgnoreTerrain
public bool use_baked_terrain_mesh
private List`1<NavMeshBuildSource> sources
private AsyncOperation BuildingOperation
private bool HasBuildOperationStarted
private Stopwatch BuildTimer
private int defaultArea
private int agentTypeId
public bool IsBuilding
public bool get_IsBuilding()
private void OnEnable()
private void OnDisable()
public void UpdateNavMeshAsync()
public IEnumerator UpdateNavMeshAndWait()
public void NotifyInformationZonesOfCompletion()
private void AppendModifierVolumes(List`1<NavMeshBuildSource> sources)
public void FinishBuildingNavmesh()
}
public MonumentNode : MonoBehaviour {
public string ResourceFolder
protected void Awake()
public void Process(UInt32& seed)
}
public MonumentSign : LODComponent {
public float viewDistance
public GameObject uiRoot
public RustText signText
}
public MonumentTier : Enum {
public int value__
public MonumentTier Tier0
public MonumentTier Tier1
public MonumentTier Tier2
}
public MonumentType : Enum {
public int value__
public MonumentType Cave
public MonumentType Airport
public MonumentType Building
public MonumentType Town
public MonumentType Radtown
public MonumentType Lighthouse
public MonumentType WaterWell
public MonumentType Roadside
public MonumentType Mountain
public MonumentType Lake
}
public MortarFirework : RepeatingFirework {
public GameObjectRef[] shellTypes
public Transform emissionPoint
}
public MotorRowboat : BaseBoat {
public BlendedSoundLoops engineLoops
public BlendedSoundLoops waterLoops
public SoundDefinition engineStartSoundDef
public SoundDefinition engineStopSoundDef
public SoundDefinition movementSplashAccentSoundDef
public SoundDefinition engineSteerSoundDef
public GameObjectRef pushLandEffect
public GameObjectRef pushWaterEffect
public float waterSpeedDivisor
public float turnPitchModScale
public float tiltPitchModScale
public float splashAccentFrequencyMin
public float splashAccentFrequencyMax
protected Flags Flag_ThrottleOn
protected Flags Flag_TurnLeft
protected Flags Flag_TurnRight
protected Flags Flag_HasFuel
protected Flags Flag_RecentlyPushed
protected Flags Flag_Submerged
protected Flags Flag_Dying
public float submergeFractionMinimum
public float deathSinkRate
public GameObjectRef fuelStoragePrefab
public float fuelPerSec
public GameObjectRef storageUnitPrefab
public EntityRef`1<StorageContainer> storageUnitInstance
public Transform boatRear
public ParticleSystemContainer wakeEffect
public ParticleSystemContainer engineEffectIdle
public ParticleSystemContainer engineEffectThrottle
public ParticleSystemContainer engineEffectThrottleReverse
public Transform boatFront
public ParticleSystemContainer forwardTravelEffect
public float forwardTravelEffectMinSpeed
public Projector causticsProjector
public Transform causticsDepthTest
public Transform engineLeftHandPosition
public Transform engineRotate
public float engineRotateRangeMultiplier
public Transform propellerRotate
public float population
public float outsidedecayminutes
public float deepwaterdecayminutes
public float decaystartdelayminutes
public EntityFuelSystem fuelSystem
public Transform[] stationaryDismounts
public TimeSince timeSinceLastUsedFuel
public float angularDragBase
public float engineOffAngularDragMultiplier
public float angularDragVelocity
public float landDrag
public float waterDrag
public float offAxisDrag
public float offAxisDot
protected float DECAY_TICK_TIME
private TimeSince startedFlip
public float lastHadDriverTime
public float maxVelForStationaryDismount
public bool IsDying
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_IsDying()
public void InitShared()
public void ServerInit()
protected void OnChildAdded(BaseEntity child)
internal void DoServerDestroy()
public IFuelSystem GetFuelSystem()
public int StartingFuelUnits()
public void BoatDecay()
public void DoPushAction(BasePlayer player)
private void FlipMonitor()
public void RPC_OpenFuel(RPCMessage msg)
public void RPC_EngineToggle(RPCMessage msg)
public void EngineToggle(bool wantsOn)
public void PostServerLoad()
public void CheckInvalidBoat()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public bool EngineOn()
public float TimeSinceDriver()
public void DriverInput(InputState inputState, BasePlayer player)
public void VehicleFixedUpdate()
private void SetFlags()
protected bool DetermineIfStationary()
public void SeatClippedWorld(BaseMountable mountable)
public void UpdateDrag()
public void OnKilled(HitInfo info)
protected void EnterCorpseState()
public void ActualDeath()
public bool MountEligable(BasePlayer player)
public bool HasValidDismountPosition(BasePlayer player)
public bool GetDismountPosition(BasePlayer player, Vector3& res)
public void DisableTransferProtection()
public void Save(SaveInfo info)
public bool CanPushNow(BasePlayer pusher)
private bool ShowPushMenu(BasePlayer player)
public void Load(LoadInfo info)
}
public MountableParentCombatEntity : BaseCombatEntity {
private BaseMountable mountable
private BaseMountable Mountable
private BaseMountable get_Mountable()
}
public Mountain : TerrainPlacement {
public float Fade
public bool AutoCliffSplat
public bool AutoCliffTopology
protected void OnDrawGizmosSelected()
protected void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
}
public MouseSteerableSeat : BaseVehicleSeat {
private bool supportsMouseSteer
public BUTTON MouseSteerButton
}
public MoveForward : MonoBehaviour {
public float Speed
protected void Update()
}
public MovementSounds : MonoBehaviour {
public SoundDefinition waterMovementDef
public float waterMovementFadeInSpeed
public float waterMovementFadeOutSpeed
public SoundDefinition enterWaterSmall
public SoundDefinition enterWaterMedium
public SoundDefinition enterWaterLarge
private Sound waterMovement
private Modulator waterGainMod
public bool inWater
public float waterLevel
public bool mute
}
public MovementSoundTrigger : TriggerBase {
public SoundDefinition softSound
public SoundDefinition medSound
public SoundDefinition hardSound
public Collider collider
public void PreClientComponentCull(IPrefabProcessor p)
}
public MoveMission : BaseMission {
public float minDistForMovePoint
public float maxDistForMovePoint
private float minDistFromLocation
public void MissionStart(MissionInstance instance, BasePlayer assignee)
public void MissionEnded(MissionInstance instance, BasePlayer assignee)
public Sprite GetIcon(MissionInstance instance)
public void Think(MissionInstance instance, BasePlayer assignee, float delta)
}
public MoveObjectOverTime : MonoBehaviour {
public Transform Mover
public Vector3 OffsetAmount
public float Speed
}
public MoveOverTime : MonoBehaviour {
public float speed
public Vector3 position
public Vector3 rotation
public Vector3 scale
private void Update()
}
public MurmurHash : object {
private UInt32 seed
public int Signed(Stream stream)
public UInt32 Unsigned(Stream stream)
private UInt32 rot(UInt32 x, byte r)
private UInt32 mix(UInt32 h)
}
public MurmurHashEx : object {
public int MurmurHashSigned(string str)
public UInt32 MurmurHashUnsigned(string str)
private MemoryStream StringToStream(string str)
}
public MusicChangeIntensity : MonoBehaviour {
public float raiseTo
public List`1<DistanceIntensity> distanceIntensities
public float tickInterval
}
public MusicClip : ScriptableObject {
public AudioClip audioClip
public int lengthInBars
public int lengthInBarsWithTail
public List`1<float> fadeInPoints
public float GetNextFadeInPoint(float currentClipTimeBars)
}
public MusicClipLoader : object {
public List`1<LoadedAudioClip> loadedClips
public Dictionary`2<AudioClip, LoadedAudioClip> loadedClipDict
public List`1<AudioClip> clipsToLoad
public List`1<AudioClip> clipsToUnload
public void Update()
public void Refresh()
private LoadedAudioClip FindLoadedClip(AudioClip clip)
}
public MusicManager : SingletonComponent`1<MusicManager> {
public AudioMixerGroup mixerGroup
public List`1<MusicTheme> themes
public MusicTheme currentTheme
public List`1<AudioSource> sources
public double nextMusic
public double nextMusicFromIntensityRaise
public float intensity
public Dictionary`2<PositionedClip, ClipPlaybackData> clipPlaybackData
public int holdIntensityUntilBar
public bool musicPlaying
public bool loadingFirstClips
public MusicTheme nextTheme
public double lastClipUpdate
public float clipUpdateInterval
public double themeStartTime
public int lastActiveClipRefresh
public int activeClipRefreshInterval
public bool forceThemeChange
public float randomIntensityJumpChance
public int clipScheduleBarsEarly
public List`1<PositionedClip> activeClips
public List`1<PositionedClip> activeMusicClips
public List`1<PositionedClip> activeControlClips
public List`1<MusicZone> currentMusicZones
public int currentBar
public int barOffset
public double currentThemeTime
public int themeBar
public double get_currentThemeTime()
public int get_themeBar()
public void RaiseIntensityTo(float amount, int holdLengthBars)
public void StopMusic()
}
public MusicTheme : ScriptableObject {
public float tempo
public int intensityHoldBars
public int lengthInBars
public bool canPlayInMenus
public ValueRange rain
public ValueRange wind
public ValueRange snow
public Enum biomes
public Enum topologies
public AnimationCurve time
public List`1<PositionedClip> clips
public List`1<Layer> layers
private Dictionary`2<int, List`1<PositionedClip>> activeClips
private List`1<AudioClip> firstAudioClips
private Dictionary`2<AudioClip, bool> audioClipDict
public int layerCount
public int samplesPerBar
public int get_layerCount()
public int get_samplesPerBar()
private void OnValidate()
public List`1<PositionedClip> GetActiveClipsForBar(int bar)
private int ActiveClipCollectionID(int bar)
public Layer LayerById(int id)
public void AddLayer()
private void UpdateLengthInBars()
public bool CanPlayInEnvironment(int currentBiome, int currentTopology, float currentRain, float currentSnow, float currentWind)
public bool FirstClipsLoaded()
public bool ContainsAudioClip(AudioClip clip)
}
public MusicUtil : object {
public float OneSixteenth
public double BeatsToSeconds(float tempo, float beats)
public double BarsToSeconds(float tempo, float bars)
public int SecondsToSamples(double seconds)
public int SecondsToSamples(double seconds, int sampleRate)
public int SecondsToSamples(float seconds)
public int SecondsToSamples(float seconds, int sampleRate)
public int BarsToSamples(float tempo, float bars, int sampleRate)
public int BarsToSamples(float tempo, float bars)
public int BeatsToSamples(float tempo, float beats)
public float SecondsToBeats(float tempo, double seconds)
public float SecondsToBars(float tempo, double seconds)
public float Quantize(float position, float gridSize)
public float FlooredQuantize(float position, float gridSize)
}
public MusicZone : MonoBehaviour {
public List`1<MusicTheme> themes
public float priority
public bool suppressAutomaticMusic
}
public Muzzleflash_AlphaRandom : MonoBehaviour {
public ParticleSystem[] muzzleflashParticles
private Gradient grad
private GradientColorKey[] gck
private GradientAlphaKey[] gak
private void Start()
private void OnEnable()
}
public MuzzleFlash_Flamelet : MonoBehaviour {
public ParticleSystem flameletParticle
private void OnEnable()
}
public NameHelper : object {
public string Get(ulong userId, string name, bool isClient, bool forceFriendly)
public string Get(IPlayerInfo playerInfo, bool isClient)
}
public nametags : ConsoleSystem {
public bool enabled
}
public NativeNoise : object {
public float Simplex1D(float x)
public float Simplex1D(float x, Single& dx)
public float Simplex2D(float x, float y)
public float Simplex2D(float x, float y, Single& dx, Single& dy)
public float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale)
}
public NaturalBloomAndDirtyLens : MonoBehaviour {
public Shader shader
public Texture2D lensDirtTexture
public float range
public float cutoff
public float bloomIntensity
public float lensDirtIntensity
public float spread
public int iterations
public int mips
public Single[] mipWeights
public bool highPrecision
public bool downscaleSource
public bool debug
public bool temporalFilter
public float temporalFilterWeight
}
public NavMeshTools : object {
public IEnumerator CollectSourcesAsync(Bounds bounds, int mask, NavMeshCollectGeometry geometry, int area, bool useBakedTerrainMesh, int cellSize, List`1<NavMeshBuildSource> sources, Action`1<List`1<NavMeshBuildSource>> append, Action callback, Transform customNavMeshDataRoot)
public IEnumerator CollectSourcesAsync(Transform root, int mask, NavMeshCollectGeometry geometry, int area, List`1<NavMeshBuildSource> sources, Action`1<List`1<NavMeshBuildSource>> append, Action callback)
}
public NeedsCursor : MonoBehaviour {
private void Update()
}
public NeedsMouseWheel : ListComponent`1<NeedsMouseWheel> {
public bool AnyActive()
}
public NeighbourSocket : Socket_Base {
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
}
public NeonMeshPaintableSource : MeshPaintableSource {
public NeonSign neonSign
public float editorEmissionScale
public AnimationCurve lightingCurve
public Color topLeft
public Color topRight
public Color bottomLeft
public Color bottomRight
public void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride, bool forEditing, bool isSelected)
public Color32[] UpdateFrom(Texture2D input)
private Color <UpdateFrom>g__GetColorForRegion|8_0(int x, int y, int regionWidth, int regionHeight, <>c__DisplayClass8_0& )
}
public NeonSign : Signage {
private float FastSpeed
private float MediumSpeed
private float SlowSpeed
private float MinSpeed
private float MaxSpeed
public Light topLeft
public Light topRight
public Light bottomLeft
public Light bottomRight
public float lightIntensity
public int powerConsumption
public Material activeMaterial
public Material inactiveMaterial
public float animationSpeed
public int currentFrame
public List`1<Lights> frameLighting
public bool isAnimating
public Action animationLoopAction
public AmbienceEmitter ambientSoundEmitter
public SoundDefinition switchSoundDef
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int ConsumptionAmount()
public void Load(LoadInfo info)
public void ServerInit()
public void ResetState()
public void UpdateHasPower(int inputAmount, int inputSlot)
private void SwitchToNextFrame()
public void Save(SaveInfo info)
public void SetAnimationSpeed(RPCMessage msg)
public void UpdateNeonColors(RPCMessage msg)
public void EnsureInitialized()
private Color ClampColor(Color color)
}
public Network.Channel.Client : object {
public byte Default
public byte Tick
}
public Network.Channel.Server : object {
public byte Default
public byte Positions
}
public NetworkCryptography : object {
private Byte[] buffer
public ArraySegment`1<byte> EncryptCopy(Connection connection, ArraySegment`1<byte> data)
public ArraySegment`1<byte> DecryptCopy(Connection connection, ArraySegment`1<byte> data)
public void Encrypt(Connection connection, ArraySegment`1& data)
public void Decrypt(Connection connection, ArraySegment`1& data)
protected void EncryptionHandler(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst)
protected void DecryptionHandler(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst)
}
public NetworkCryptographyServer : NetworkCryptography {
protected void EncryptionHandler(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst)
protected void DecryptionHandler(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst)
}
public NetworkedProperty`1 : object {
private T val
private BaseEntity entity
public T Value
public T get_Value()
public void set_Value(T value)
public void .ctor(BaseEntity entity)
public T op_Implicit(NetworkedProperty`1<T> value)
}
public NetworkInfoGeneralText : MonoBehaviour {
public TextMeshProUGUI text
private void Update()
private void UpdateText()
private string ChannelStat(int window, int left)
}
public NetworkSleep : MonoBehaviour {
public int totalBehavioursDisabled
public int totalCollidersDisabled
public Behaviour[] behaviours
public Collider[] colliders
internal int BehavioursDisabled
internal int CollidersDisabled
}
public NetworkVisibilityGrid : MonoBehaviour {
public int overworldLayer
public int cavesLayer
public int tunnelsLayer
public int tutorialsLayer
public int dynamicDungeonsFirstLayer
public int startID
public int gridSize
public int cellCount
public int visibilityRadiusFar
public int visibilityRadiusNear
public float switchTolerance
public float cavesThreshold
public float tunnelsThreshold
public float dynamicDungeonsThreshold
public float dynamicDungeonsInterval
private float halfGridSize
private float cellSize
private float halfCellSize
private int numIDsPerLayer
private void Awake()
private void OnEnable()
private void OnDisable()
private void OnDrawGizmosSelected()
private int PositionToGrid(float value)
private float GridToPosition(int value)
private int PositionToLayer(float x, float y, float z)
private UInt32 CoordToID(int x, int y, int layer)
private UInt32 GetID(Vector3 vPos)
private ValueTuple`3<int, int, int> DeconstructGroupId(int groupId)
private Bounds GetBounds(UInt32 uid)
public void OnGroupAdded(Group group)
public bool IsInside(Group group, Vector3 vPos)
public Group GetGroup(Vector3 vPos)
public void GetVisibleFromFar(Group group, List`1<Group> groups)
public void GetVisibleFromNear(Group group, List`1<Group> groups)
private void GetVisibleFrom(Group group, List`1<Group> groups, int radius)
private void <GetVisibleFrom>g__AddLayers|35_0(int groupX, int groupY, int groupLayer, <>c__DisplayClass35_0& )
private void <GetVisibleFrom>g__Add|35_1(int groupX, int groupY, int groupLayer, <>c__DisplayClass35_0& )
}
public NetworkWriteEx : object {
public void WriteObject(NetWrite write, T obj)
}
public NewsParagraph : MonoBehaviour {
public RustText Text
public List`1<string> Links
public void OnPointerClick(PointerEventData eventData)
}
public NewsSource : MonoBehaviour {
private Regex BbcodeParse
public RustText title
public RustText date
public RustText authorName
public HttpImage coverImage
public RectTransform container
public Button button
public RustText paragraphTemplate
public HttpImage imageTemplate
public HttpImage youtubeTemplate
private String[] BulletSeparators
public void Awake()
public void OnEnable()
public void SetStory(Story story)
private void ParseBbcode(ParagraphBuilder& currentParagraph, string bbcode, String& firstImage, int depth)
private String[] GetBulletPoints(string listContent)
private void AppendParagraph(ParagraphBuilder& currentParagraph)
private void AppendImage(ParagraphBuilder& currentParagraph, string url)
private void AppendYouTube(ParagraphBuilder& currentParagraph, string videoId)
}
public NewYearGong : BaseCombatEntity {
public SoundDefinition gongSound
public float minTimeBetweenSounds
public GameObject soundRoot
public Transform gongCentre
public float gongRadius
public AnimationCurve pitchCurve
public Animator gongAnimator
private float lastSound
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Hurt(HitInfo info)
}
public NexusClanBackend : object {
private Dictionary`2<long, NexusClanWrapper> _clanWrappers
private IClanChangeSink _changeSink
private NexusClanChatCollector _chatCollector
private NexusClanEventHandler _eventHandler
private NexusZoneClient _client
public ValueTask Initialize(IClanChangeSink changeSink)
public void Dispose()
public ValueTask`1<ClanValueResult`1<IClan>> Get(long clanId)
public bool TryGet(long clanId, IClan& clan)
public ValueTask`1<ClanValueResult`1<IClan>> GetByMember(ulong steamId)
public ValueTask`1<ClanValueResult`1<IClan>> Create(ulong leaderSteamId, string name)
public ValueTask`1<ClanValueResult`1<List`1<ClanInvitation>>> ListInvitations(ulong steamId)
public ValueTask`1<ClanValueResult`1<List`1<ClanLeaderboardEntry>>> GetLeaderboard(int limit)
public void HandleClanChatBatch(ClanChatBatchRequest request)
private IEnumerator BroadcastClanChatBatches()
public void UpdateWrapper(long clanId)
public void RemoveWrapper(long clanId)
private NexusClanWrapper Wrap(NexusClan clan)
internal void <BroadcastClanChatBatches>g__SendClanChatBatch|15_0(List`1<Message> messages)
}
public NexusClanChatCollector : object {
private IClanChangeSink _external
private List`1<Message> _messagesBuffer
public void .ctor(IClanChangeSink external)
public void TakeMessages(List`1<Message> messages)
public void OnClanChatMessage(long clanId, ClanChatEntry entry)
}
public NexusClanEventHandler : object {
private NexusClanBackend _backend
private IClanChangeSink _changeSink
public void .ctor(NexusClanBackend backend, IClanChangeSink changeSink)
public void OnDisbanded(ClanDisbandedEvent& args)
public void OnInvitation(ClanInvitedEvent& args)
public void OnJoined(ClanJoinedEvent& args)
public void OnKicked(ClanKickedEvent& args)
public void OnChanged(ClanChangedEvent& args)
public void OnUnload(Int64& clanId)
private void Facepunch.Nexus.INexusClanEventListener.OnDisbanded(ClanDisbandedEvent& modreq(System.Runtime.InteropServices.InAttribute) args)
private void Facepunch.Nexus.INexusClanEventListener.OnInvitation(ClanInvitedEvent& modreq(System.Runtime.InteropServices.InAttribute) args)
private void Facepunch.Nexus.INexusClanEventListener.OnJoined(ClanJoinedEvent& modreq(System.Runtime.InteropServices.InAttribute) args)
private void Facepunch.Nexus.INexusClanEventListener.OnKicked(ClanKickedEvent& modreq(System.Runtime.InteropServices.InAttribute) args)
private void Facepunch.Nexus.INexusClanEventListener.OnChanged(ClanChangedEvent& modreq(System.Runtime.InteropServices.InAttribute) args)
private void Facepunch.Nexus.INexusClanEventListener.OnUnload(Int64& modreq(System.Runtime.InteropServices.InAttribute) clanId)
}
public NexusClanUtil : object {
public string MotdVariable
public string MotdAuthorVariable
public string LogoVariable
public string ColorVariable
public string CanSetLogoVariable
public string CanSetMotdVariable
public string CanSetPlayerNotesVariable
public string PlayerNoteVariable
public List`1<VariableUpdate> DefaultLeaderVariables
private Memoized`2<string, ulong> SteamIdToPlayerId
public string GetPlayerId(ulong steamId)
public string GetPlayerId(Nullable`1<ulong> steamId)
public ulong GetSteamId(string playerId)
public Nullable`1<ulong> TryGetSteamId(string playerId)
public void GetMotd(NexusClan clan, String& motd, Int64& motdTimestamp, UInt64& motdAuthor)
public void GetBanner(NexusClan clan, Byte[]& logo, Color32& color)
public ClanRole ToClanRole(NexusClanRole role)
public ClanMember ToClanMember(NexusClanMember member)
public ClanInvite ToClanInvite(ClanInvite invite)
public ClanResult ToClanResult(NexusClanResultCode result)
public ClanRoleParameters ToRoleParameters(ClanRole role)
public VariableUpdate FlagVariable(string key, bool value)
private bool ParseFlag(Variable variable, bool defaultValue)
}
public NexusClanWrapper : object {
private int MaxChatScrollback
private string <Motd>k__BackingField
private long <MotdTimestamp>k__BackingField
private ulong <MotdAuthor>k__BackingField
private Byte[] <Logo>k__BackingField
private Color32 <Color>k__BackingField
private int <MaxMemberCount>k__BackingField
public NexusClan Internal
private NexusClanChatCollector _chatCollector
private List`1<ClanRole> _roles
private List`1<ClanMember> _members
private List`1<ClanInvite> _invites
private List`1<ClanChatEntry> _chatHistory
private RealTimeSince _sinceLastRefresh
public long ClanId
public string Name
public long Created
public ulong Creator
public string Motd
public long MotdTimestamp
public ulong MotdAuthor
public Byte[] Logo
public Color32 Color
public long Score
public IReadOnlyList`1<ClanRole> Roles
public IReadOnlyList`1<ClanMember> Members
public int MaxMemberCount
public IReadOnlyList`1<ClanInvite> Invites
public long get_ClanId()
public string get_Name()
public long get_Created()
public ulong get_Creator()
public string get_Motd()
private void set_Motd(string value)
public long get_MotdTimestamp()
private void set_MotdTimestamp(long value)
public ulong get_MotdAuthor()
private void set_MotdAuthor(ulong value)
public Byte[] get_Logo()
private void set_Logo(Byte[] value)
public Color32 get_Color()
private void set_Color(Color32 value)
public long get_Score()
public IReadOnlyList`1<ClanRole> get_Roles()
public IReadOnlyList`1<ClanMember> get_Members()
public int get_MaxMemberCount()
private void set_MaxMemberCount(int value)
public IReadOnlyList`1<ClanInvite> get_Invites()
public void .ctor(NexusClan clan, NexusClanChatCollector chatCollector)
public void UpdateValuesInternal()
public ValueTask RefreshIfStale()
public ValueTask`1<ClanValueResult`1<ClanLogs>> GetLogs(int limit, ulong bySteamId)
public ValueTask`1<ClanResult> UpdateLastSeen(ulong steamId)
public ValueTask`1<ClanResult> SetMotd(string newMotd, ulong bySteamId)
public ValueTask`1<ClanResult> SetLogo(Byte[] newLogo, ulong bySteamId)
public ValueTask`1<ClanResult> SetColor(Color32 newColor, ulong bySteamId)
public ValueTask`1<ClanResult> Invite(ulong steamId, ulong bySteamId)
public ValueTask`1<ClanResult> CancelInvite(ulong steamId, ulong bySteamId)
public ValueTask`1<ClanResult> AcceptInvite(ulong steamId)
public ValueTask`1<ClanResult> Kick(ulong steamId, ulong bySteamId)
public ValueTask`1<ClanResult> SetPlayerRole(ulong steamId, int newRoleId, ulong bySteamId)
public ValueTask`1<ClanResult> SetPlayerNotes(ulong steamId, string notes, ulong bySteamId)
public ValueTask`1<ClanResult> CreateRole(ClanRole role, ulong bySteamId)
public ValueTask`1<ClanResult> UpdateRole(ClanRole role, ulong bySteamId)
public ValueTask`1<ClanResult> SwapRoleRanks(int roleIdA, int roleIdB, ulong bySteamId)
public ValueTask`1<ClanResult> DeleteRole(int roleId, ulong bySteamId)
public ValueTask`1<ClanResult> Disband(ulong bySteamId)
public ValueTask`1<ClanValueResult`1<ClanScoreEvents>> GetScoreEvents(int limit, ulong bySteamId)
public ValueTask`1<ClanResult> AddScoreEvent(ClanScoreEvent scoreEvent)
public ValueTask`1<ClanValueResult`1<ClanChatScrollback>> GetChatScrollback()
public ValueTask`1<ClanResult> SendChatMessage(string name, string message, ulong bySteamId)
public void AddScrollback(ClanChatEntry& entry)
private bool CheckRole(ulong steamId, Func`2<ClanRole, bool> roleTest)
}
public NexusCleanupOnShutdown : MonoBehaviour {
public void OnDestroy()
}
public NexusDB : Database {
private int <JournalCount>k__BackingField
private Nullable`1<DateTimeOffset> <OldestJournal>k__BackingField
private int <TransferredCount>k__BackingField
public int JournalCount
public Nullable`1<DateTimeOffset> OldestJournal
public int TransferredCount
public int get_JournalCount()
private void set_JournalCount(int value)
public Nullable`1<DateTimeOffset> get_OldestJournal()
private void set_OldestJournal(Nullable`1<DateTimeOffset> value)
public int get_TransferredCount()
private void set_TransferredCount(int value)
public void Initialize()
public bool Seen(Guid id)
public bool SeenJournaled(Guid id, Byte[] data)
public List`1<ValueTuple`3<Guid, long, Byte[]>> ReadJournal()
private ValueTuple`3<Guid, long, Byte[]> ReadJournalRow(IntPtr stmHandle)
public void ClearJournal()
public void MarkTransferred(HashSet`1<NetworkableId> entityIds)
public List`1<NetworkableId> ReadTransferred()
public void ClearTransferred()
}
public NexusDock : SingletonComponent`1<NexusDock> {
public Transform FerryWaypoint
public Transform[] QueuePoints
public Transform Arrival
public Transform Docking
public Transform Docked
public Transform CastingOff
public Transform Departure
public float WaitTime
public BoxCollider EjectionZone
public float TraceHeight
public LayerMask TraceLayerMask
public NexusFerry[] QueuedFerries
public NexusFerry CurrentFerry
public Transform GetEntryPoint(NexusFerry ferry, Boolean& entered)
public bool Depart(NexusFerry ferry)
public bool TryFindEjectionPosition(Vector3& position, float radius)
public void CleanupQueuedFerries()
}
public NexusDockTerminal : BaseEntity {
public Phrase ScheduleSoonPhrase
public Phrase ScheduleMinutesPhrase
public Phrase ScheduleUnknownPhrase
public float TravelTime
public RustText[] ScheduleLabels
private List`1<ScheduleEntry> _scheduleEntries
private HashSet`1<string> SeenFerries
public void InitShared()
public void AdminKill()
private void UpdateFerrySchedule()
private void CalculateFerryEstimates(List`1<ValueTuple`2<string, Nullable`1<float>>> estimates)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
internal void <CalculateFerryEstimates>g__NextIdx|10_1(<>c__DisplayClass10_0& )
}
public NexusEx : Nexus {
public Char[] SplitComma
private string <Key>k__BackingField
private HashSet`1<string> <TagsSet>k__BackingField
public string Key
public HashSet`1<string> TagsSet
public string get_Key()
public HashSet`1<string> get_TagsSet()
public void .ctor(string endpoint, Nexus nexus)
}
public NexusExtensions : object {
public Vector2 Position(ZoneDetails zone)
public Vector2 Position(NexusZoneDetails zone)
}
public NexusFerry : BaseEntity {
public Phrase RetiringPhrase
public float TravelVelocity
public float ApproachVelocity
public float StoppingVelocity
public float AccelerationSpeed
public float TurnSpeed
public float VelocityPreservationOnTurn
public float TargetDistanceThreshold
public GameObjectRef hornEffect
public Transform hornEffectTransform
public float departureHornLeadTime
public SphereCollider SphereCaster
public int CastSweepDegrees
public float CastSweepNoise
public LayerMask CastLayers
public float CastInterval
public float CastHitProtection
public int PathLookahead
public int PathLookaheadThreshold
public RustText[] NextZoneLabels
private long _timestamp
private string _ownerZone
private List`1<string> _schedule
private int _scheduleIndex
private State _state
private bool _isRetiring
private int _nextScheduleIndex
private bool _departureHornPlayed
public ListHashSet`1<NexusFerry> All
private List`1<NetworkableId> _transferredIds
private NexusDock _targetDock
private bool _isTransferring
private TimeSince _sinceStartedWaiting
private TimeSince _sinceLastTransferAttempt
private RealTimeSince _sinceLastNextIndexUpdate
private TimeSince _sincePathCalculation
private Nullable`1<Vector3> _pathTargetPosition
private Nullable`1<Quaternion> _pathTargetRotation
private Vector3 _velocity
public string OwnerZone
public bool IsRetiring
public string NextZone
protected bool PositionTickFixedTime
public string get_OwnerZone()
public bool get_IsRetiring()
public string get_NextZone()
public void Initialize(string ownerZone, List`1<string> schedule)
private void EnsureInitialized()
public void ServerInit()
public void DestroyShared()
public void FixedUpdate()
public FerryStatus GetStatus()
public void Retire()
public void UpdateSchedule(List`1<string> schedule)
public float GetNetworkTime()
protected bool get_PositionTickFixedTime()
private void SwitchToNextState()
private State GetNextState(State currentState)
private State GetPreviousState(State currentState)
private void TransferToNextZone()
private Nullable`1<int> TryGetNextScheduleIndex()
private void EjectInactiveEntities(bool forceAll)
private void EjectEntity(BaseEntity entity)
private bool IsEntityActive(BaseEntity entity)
private bool IsPlayerReady(BasePlayer player)
private void PlayDepartureHornEffect()
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public NexusFerry Get(NetworkableId entityId, long timestamp)
private bool MoveTowardsTarget()
private bool MoveTowardsPositionAvoidObstacles(Vector3 targetPosition)
private bool MoveTowardsTargetTransform()
private Transform GetTargetTransform(State state)
private bool MoveTowardsPosition(Vector3 targetPosition, Quaternion targetRotation)
private bool SphereCast(Vector3 direction, float distance, Single& travelDistance, Vector3& endPosition)
private Vector3 GetIslandTransferPosition()
private bool TryFindWaypointsTowards(Vector3 targetPosition, List`1<Vector3> waypoints)
private Vector3 <MoveTowardsPositionAvoidObstacles>g__ChooseWaypoint|72_0(Vector3 target)
}
public NexusFerrySounds : MonoBehaviour {
private NexusFerry ferry
private float roughHalfWidth
private float roughHalfLength
private float soundCullDistanceSq
private SoundDefinition engineLoopDef
private Sound engineLoop
private Modulator engineGainMod
private Modulator enginePitchMod
private SoundDefinition engineStartDef
private SoundDefinition engineStopDef
private AnimationCurve engineGainCurve
private AnimationCurve enginePitchCurve
private float engineGainChangeRate
private float enginePitchChangeRate
private Transform engineTransform
private SoundDefinition waterIdleDef
private SoundDefinition waterSideMovementSlowDef
private SoundDefinition waterSideMovementFastDef
private AnimationCurve waterMovementGainCurve
private float waterMovementGainChangeRate
private AnimationCurve waterDistanceGainCurve
private Sound leftWaterSound
private Modulator leftWaterGainMod
private Sound rightWaterSound
private Modulator rightWaterGainMod
private Vector3 sideSoundLineStern
private Vector3 sideSoundLineBow
private SoundDefinition dockArrivalSoundDef
private SoundDefinition dockDepartureSoundDef
private Transform dockSoundTransform
private Sound ambientIdleSound
private SoundDefinition ambientActiveLoopDef
private Sound ambientActiveSound
private Line leftSoundLine
private Line rightSoundLine
public bool engineOn
}
public NexusIsland : BaseEntity {
public Flags ServerFullFlag
public Transform BillboardRoot
public Transform Billboard
public BoxCollider TransferZone
public BoxCollider SpawnZone
public float TraceHeight
public LayerMask TraceLayerMask
public Transform FerryWaypoint
public GameObjectRef MapMarkerPrefab
public Transform MapMarkerLocation
public string ZoneKey
public List`1<NexusIsland> All
public void InitShared()
public void DestroyShared()
public bool CanTransfer(BaseEntity entity)
public ValueTuple`2<string, string> GetTransferDestination()
public bool TryFindPosition(Vector3& position, float radius)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ServerInit()
internal bool <TryFindPosition>g__IsValidPosition|16_0(Vector3 center, float extent)
}
public NexusRpcResult : object {
public Dictionary`2<string, Response> Responses
public void Dispose()
public void EnterPool()
public void LeavePool()
}
public NexusServer : object {
private bool _isRefreshingCompanion
private RealTimeSince _lastCompanionRefresh
private Memoized`2<string, ulong> SteamIdToString
private MemoryStream WriterStream
private ByteArrayStream ReaderStream
private NexusDB _database
private NexusZoneClient <ZoneClient>k__BackingField
private bool <Started>k__BackingField
private bool <FailedToStart>k__BackingField
private Dictionary`2<string, List`1<ValueTuple`2<string, FerryStatus>>> FerryEntries
private bool _updatingFerries
private int _cyclesWithoutFerry
private float _zoneContactRadius
private Dictionary`2<string, NexusIsland> _existingIslands
private int MapRenderVersion
private HashSet`1<ulong> PlayerManifest
private Dictionary`2<string, ZonePlayerManifest> ZonePlayerManifests
private RealTimeSince _lastPlayerManifestBroadcast
private bool _playerManifestDirty
private RealTimeSince _lastPlayerManifestRebuild
private Dictionary`2<Uuid, PendingCall> PendingCalls
private RealTimeSince _sinceLastRpcTimeoutCheck
private Dictionary`2<string, ServerStatus> ZoneStatuses
private bool _isRefreshingZoneStatus
private RealTimeSince _lastZoneStatusRefresh
private Nullable`1<DateTimeOffset> _lastUnsavedTransfer
private string CopyFromKey
public NexusZoneClient ZoneClient
public bool Started
public bool FailedToStart
public Nullable`1<int> NexusId
public string ZoneKey
public Nullable`1<long> LastReset
public List`1<NexusZoneDetails> Zones
public bool NeedsJournalFlush
private int RpcResponseTtl
public bool NeedTransferFlush
private void RefreshCompanionVariables()
public NexusZoneClient get_ZoneClient()
private void set_ZoneClient(NexusZoneClient value)
public bool get_Started()
private void set_Started(bool value)
public bool get_FailedToStart()
private void set_FailedToStart(bool value)
public Nullable`1<int> get_NexusId()
public string get_ZoneKey()
public Nullable`1<long> get_LastReset()
public List`1<NexusZoneDetails> get_Zones()
public IEnumerator Initialize()
public void Shutdown()
public void Update()
public NexusZoneDetails FindZone(string zoneKey)
public Task`1<NexusLoginResult> Login(ulong steamId)
public void Logout(ulong steamId)
public bool TryGetPlayer(ulong steamId, NexusPlayer& player)
public Task AssignInitialZone(ulong steamId, string zoneKey)
private ZoneController BuildZoneController(string name)
public void PostGameSaved()
public void UpdateFerries()
private Task UpdateFerriesImpl()
public bool TryGetFerryStatus(string ownerZone, String& currentZone, FerryStatus& status)
private Task RetireFerry(string zone, NetworkableId entityId, long timestamp)
private Task UpdateFerrySchedule(string zone, NetworkableId entityId, long timestamp, List`1<string> schedule)
private bool TryParseFerrySchedule(string zone, string scheduleString, List`1& entries)
private void UpdateFerryStatuses(NexusRpcResult statusResponse)
public void UpdateIslands()
public bool TryGetIsland(string zoneKey, NexusIsland& island)
public bool TryGetIslandPosition(string zoneKey, Vector3& position)
private ValueTuple`2<Vector3, Quaternion> CalculateIslandTransform(NexusZoneDetails otherZone)
public Bounds GetWorldBounds()
private bool IsCloseTo(NexusZoneDetails otherZone)
public bool get_NeedsJournalFlush()
private void ReadIncomingMessages()
public void RestoreUnsavedState()
private void ReplayJournaledMessages()
private void DeleteTransferredEntities()
private bool RequiresJournaling(Packet packet)
public void UploadMapImage(bool force)
private void HandleMessage(Uuid id, Packet packet)
private Packet ReadPacket(Byte[] data)
private Task SendRequestImpl(Uuid id, Request request, string toZoneKey, Nullable`1<int> ttl)
private void SendResponseImpl(Response response, string toZoneKey, Nullable`1<int> ttl)
private Task SendPacket(Uuid id, Packet packet, string toZoneKey, Nullable`1<int> ttl)
public bool IsOnline(ulong userId)
public void AddZonePlayerManifest(string zoneKey, List`1<ulong> userIds)
private void UpdatePlayerManifest()
private void BroadcastPlayerManifest()
private void RebuildPlayerManifestIfDirty()
private void RemoveInvalidPlayerManifests()
private int get_RpcResponseTtl()
public Task`1<Response> ZoneRpc(string zone, Request request, float timeoutAfter)
public Task`1<NexusRpcResult> BroadcastRpc(Request request, float timeoutAfter)
private Task`1<NexusRpcResult> CallRpcImpl(string zone, Request request, float timeoutAfter, bool throwOnTimeout)
private void HandleRpcInvocation(NexusZoneDetails from, Uuid id, Request request)
private Response HandleRpcInvocationImpl(NexusZoneDetails from, Uuid id, Request request)
private void HandleRpcResponse(NexusZoneDetails from, Uuid id, Response response)
private void CheckForRpcTimeouts()
private void RefreshZoneStatus()
public bool TryGetZoneStatus(string zone, ServerStatus& status)
private void OnZoneStatusesRefreshed()
public bool get_NeedTransferFlush()
public Task TransferEntity(BaseEntity entity, string toZoneKey, string method, bool includeFerry)
public Task TransferEntityImpl(BaseEntity rootEntity, string toZoneKey, string method, string from, string to)
private void UnparentUnknown(BaseEntity entity, HashSet`1<NetworkableId> knownEntityIds)
public void BuildTransferRequest(BaseEntity rootEntity, string method, string from, string to, Request& request, List`1& networkables, List`1& players, List`1& playerIds)
private bool CanTransferEntity(BaseNetworkable networkable)
public BaseEntity FindRootEntity(BaseEntity startEntity, bool includeFerry)
private string GetWorldConfigString()
private JObject GetWorldConfigImpl(string zoneKey, List`1<string> stack)
private bool TryGetWorldConfigObject(string zoneKey, bool required, JObject& cfg, String& error)
private JObject MergeInto(JObject baseObject, JObject sourceObject)
internal void <RefreshCompanionVariables>g__RefreshCompanionVariablesImpl|2_0()
internal void <Initialize>g__RunConsoleConfig|27_2(Variable cfgVariable)
internal void <UpdateFerryStatuses>g__AddFerryStatus|46_0(string currentZone, FerryStatus status)
internal bool <HandleRpcInvocationImpl>g__Handle|90_10(Func`2<Request, TProto> protoSelector, INexusRequestHandler& requestHandler, <>c__DisplayClass90_0& )
internal void <RefreshZoneStatus>g__RefreshZoneStatusImpl|96_0()
internal bool <FindRootEntity>g__TryGetParent|107_0(BaseEntity entity, BaseEntity& parent)
}
public NexusServerLogger : object {
private NexusServerLogger <Instance>k__BackingField
public NexusServerLogger Instance
public NexusServerLogger get_Instance()
public void Log(NexusLogLevel level, string message, Exception exception)
}
public NexusTransferTrigger : BaseMonoBehaviour {
public MonoBehaviour Controller
private HashSet`1<BaseEntity> PendingEntities
private INexusTransferTriggerController _controller
protected void Start()
protected void OnTriggerEnter(Collider other)
}
public NexusUtil : object {
private Char[] ScheduleSeparators
public bool TryParseFerrySchedule(string zone, string scheduleString, String[]& entries)
public string ConnectionProtocol(NexusZoneDetails zone)
public bool IsStarterZone(ZoneDetails zone)
public bool IsStarterZone(NexusZoneDetails zone)
private bool IsStarterZone(VariableDictionary variables)
public bool TryGetString(VariableDictionary variables, string key, String& value)
}
public NexusVariables : object {
public string Blueprints
}
public NGSS_Directional : MonoBehaviour {
public float PCSS_GLOBAL_SOFTNESS
public float PCSS_FILTER_DIR_MIN
public float PCSS_FILTER_DIR_MAX
public float BANDING_NOISE_AMOUNT
public SAMPLER_COUNT SAMPLERS_COUNT
private void Update()
private void SetGlobalSettings(bool enabled)
}
public NightLightEffect : PostProcessEffectSettings {
public FloatParameter distance
public FloatParameter fadeFraction
public FloatParameter brightness
}
public NightLightEffectRenderer : PostProcessEffectRenderer`1<NightLightEffect> {
private int distanceProperty
private int fadeFractionProperty
private int brightnessProperty
private Shader nightlightShader
public void Init()
public void Render(PostProcessRenderContext context)
}
public NightLightOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
}
public Noise : object {
public float MIN
public float MAX
public float Simplex1D(float x)
public float Simplex2D(float x, float y)
public float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale)
}
public NoiseParameters : ValueType {
public int Octaves
public float Frequency
public float Amplitude
public float Offset
public void .ctor(int octaves, float frequency, float amplitude, float offset)
}
public NonDrawingGraphic : Graphic {
public void SetMaterialDirty()
public void SetVerticesDirty()
protected void OnPopulateMesh(VertexHelper vh)
}
public NoPlayersIOReset : FacepunchBehaviour {
private IOEntity[] entitiesToReset
private float radius
private float timeBetweenChecks
protected void OnEnable()
protected void OnDisable()
private void Check()
private void Reset()
}
public NoRespawnIcon : FacepunchBehaviour {
private CanvasGroup noRespawnWarning
private GameObject noRespawnWarningGO
}
public note : ConsoleSystem {
public void update(Arg arg)
}
public NoteBindingCollection : ScriptableObject {
public NoteData[] BaseBindings
public float MinimumNoteTime
public float MaximumNoteLength
public bool AllowAutoplay
public float AutoplayLoopDelay
public string NotePlayedStatName
public string KeyMidiMapShortname
public bool AllowSustain
public bool AllowFullKeyboardInput
public string InstrumentShortName
public InstrumentType NotePlayType
public int MaxConcurrentNotes
public bool LoopSounds
public float SoundFadeInTime
public float minimumSoundFadeOutTime
public KeySet PrimaryClickNote
public KeySet SecondaryClickNote
public bool RunInstrumentAnimationController
public bool PlayRepeatAnimations
public float AnimationDeadTime
public float AnimationResetDelay
public float RecentlyPlayedThreshold
public float CrossfadeNormalizedAnimationTarget
public float AnimationCrossfadeDuration
public float CrossfadePlayerSpeedMulti
public int DefaultOctave
public int ShiftedOctave
public bool UseClosestMidiNote
private float MidiNoteUpOctaveShift
private float MidiNoteDownOctaveShift
public bool FindNoteData(Notes note, int octave, NoteType type, NoteData& data, Int32& noteIndex)
public bool FindNoteDataIndex(Notes note, int octave, NoteType type, Int32& noteIndex)
public NoteData CreateMidiBinding(NoteData basedOn, int octave, int midiCode)
}
public NotePanel : MonoBehaviour {
public InputField input
private Item item
}
public NoticeArea : SingletonComponent`1<NoticeArea> {
public GameObjectRef itemPickupPrefab
public GameObjectRef itemPickupCondensedText
public GameObjectRef itemDroppedPrefab
public AnimationCurve pickupSizeCurve
public AnimationCurve pickupAlphaCurve
public AnimationCurve reuseAlphaCurve
public AnimationCurve reuseSizeCurve
private IVitalNotice[] notices
protected void Awake()
}
public NotifyLOD : LODComponent {
public float Distance
public float MinDistanceMultiplier
public GameObject TargetGameObject
}
public NPCAutoTurret : AutoTurret {
public Transform centerMuzzle
public Transform muzzleLeft
public Transform muzzleRight
private bool useLeftMuzzle
public float sleeperhostiledelay
public void ServerInit()
public bool HasAmmo()
public bool CheckPeekers()
public float TargetScanRate()
public bool InFiringArc(BaseCombatEntity potentialtarget)
public float GetMaxAngleForEngagement()
public bool HasFallbackWeapon()
public Transform GetCenterMuzzle()
public void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target)
public bool Ignore(BasePlayer player)
public bool IsEntityHostile(BaseCombatEntity ent)
}
public NPCBarricadeTriggerBox : MonoBehaviour {
private Barricade target
private int playerServerLayer
public void Setup(Barricade t)
private void OnTriggerEnter(Collider other)
}
public NPCDoorTriggerBox : MonoBehaviour {
private Door door
private int playerServerLayer
public void Setup(Door d)
private void OnTriggerEnter(Collider other)
}
public NPCDwelling : BaseEntity {
public NPCSpawner npcSpawner
public float NPCSpawnChance
public SpawnGroup[] spawnGroups
public AIMovePoint[] movePoints
public AICoverPoint[] coverPoints
public void ServerInit()
public void DestroyShared()
public bool ValidateAIPoint(Vector3 pos)
public void UpdateInformationZone(bool remove)
public void CheckDespawn()
public void CleanupSpawned()
public bool PlayersNearby()
public float TimeoutPlayerCheckRadius()
}
public NPCFootstepEffects : BaseFootstepEffect {
public string impactEffectDirectory
public Transform frontLeftFoot
public Transform frontRightFoot
public Transform backLeftFoot
public Transform backRightFoot
}
public NPCMissionProvider : NPCTalking {
public MissionManifest manifest
public GameObjectRef MarkerPrefab
public NetworkableId ProviderID()
public Vector3 ProviderPosition()
public BaseEntity Entity()
public void ServerInit()
private string GetProviderToken()
public void OnConversationEnded(BasePlayer player)
public void OnConversationStarted(BasePlayer speakingTo)
public bool ContainsSpeech(string speech)
public string IntroOverride(string overrideSpeech)
public string GetConversationStartSpeech(BasePlayer player)
public void OnConversationAction(BasePlayer player, string action)
}
public NPCNavigator : BaseNavigator {
public int DestroyOnFailedSampleCount
private BaseNpc <NPC>k__BackingField
private int sampleFailCount
public BaseNpc NPC
public BaseNpc get_NPC()
private void set_NPC(BaseNpc value)
public void Init(BaseCombatEntity entity, NavMeshAgent agent)
public void OnFailedToPlaceOnNavmesh()
public void OnPlacedOnNavmesh()
protected bool CanEnableNavMeshNavigation()
protected bool CanUpdateMovement()
protected void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
private void UpdateRotation(Vector3 moveToPosition, float delta)
public void ApplyFacingDirectionOverride()
public bool IsSwimming()
}
public NPCPlayer : BasePlayer {
public float MovementTickStartDelay
public AIInformationZone VirtualInfoZone
public Vector3 finalDestination
private float randomOffset
public Vector3 spawnPos
public PlayerInventoryProperties[] loadouts
public LayerMask movementMask
public bool LegacyNavigation
public NavMeshAgent NavAgent
public float damageScale
public float shortRange
public float attackLengthMaxShortRangeScale
private bool _isDormant
private string loadoutname
public float lastGunShotTime
public float triggerEndTime
public float nextTriggerTime
private float lastThinkTime
private float lastPositionUpdateTime
private float lastMovementTickTime
public Vector3 lastPos
private float lastThrowTime
public bool IsNpc
public bool IsDormant
protected float PositionTickRate
public bool IsOnNavMeshLink
public bool HasPath
public bool get_IsNpc()
public bool get_IsDormant()
public void set_IsDormant(bool value)
protected float get_PositionTickRate()
public bool IsLoadBalanced()
public void ServerInit()
public string GetLoadoutName()
public void EquipLoadout(PlayerInventoryProperties[] loads)
public void ApplyInheritedVelocity(Vector3 velocity)
public void RandomMove()
public void SetDestination(Vector3 newDestination)
public AttackEntity GetAttackEntity()
public BaseProjectile GetGun()
public float AmmoFractionRemaining()
public bool IsReloading()
public void AttemptReload()
public bool ShotTest(float targetDist)
public float GetAimConeScale()
public void CancelBurst(float delay)
public bool MeleeAttack()
public void TriggerDown()
public void EquipWeapon(bool skipDeployDelay)
public void EquipTest()
internal void ServerThink_Internal()
public void ServerThink(float delta)
public void Resume()
public bool IsNavRunning()
public bool get_IsOnNavMeshLink()
public bool get_HasPath()
public void TickAi(float delta)
public void TickMovement()
public float GetNetworkTime()
public void MovementUpdate(float delta)
private bool ValidateNextPosition(Vector3& moveToPosition)
private void UpdateSpeed(float delta)
protected void UpdatePositionAndRotation(Vector3 moveToPosition)
public Vector3 GetPosition()
public float DesiredMoveSpeed()
public bool EligibleForWounding(HitInfo info)
public Vector3 GetAimDirection()
public void SetAimDirection(Vector3 newAim)
public bool TryUseThrownWeapon(BaseEntity target, float attackRate)
public bool TryUseThrownWeapon(Item item, BaseEntity target, float attackRate)
public bool HasThrownItemCooldown()
protected bool UseThrownWeapon(Item item, BaseEntity target)
private IEnumerator DoThrow(ThrownWeapon thrownWeapon, BaseEntity target)
public Item FindThrownWeapon()
}
public NPCPlayerCorpse : PlayerCorpse {
private bool lootEnabled
public float GetRemovalTime()
public bool CanLoot()
public void SetLootableIn(float when)
public void EnableLooting()
protected bool CanLootContainer(ItemContainer c, int index)
protected void PreDropItems()
}
public NPCPlayerNavigator : BaseNavigator {
private NPCPlayer <NPCPlayerEntity>k__BackingField
public NPCPlayer NPCPlayerEntity
public NPCPlayer get_NPCPlayerEntity()
private void set_NPCPlayerEntity(NPCPlayer value)
public void Init(BaseCombatEntity entity, NavMeshAgent agent)
protected bool CanEnableNavMeshNavigation()
protected bool CanUpdateMovement()
protected void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
public void ApplyFacingDirectionOverride()
private Vector3 GetAimDirection(BasePlayer aimingPlayer, BaseEntity target)
private Vector3 TargetAimPositionOffset(BaseEntity target)
}
public NPCPlayerNavigatorTester : BaseMonoBehaviour {
public BasePathNode TargetNode
private BasePathNode currentNode
private void Update()
}
public NPCShopKeeper : NPCPlayer {
public EntityRef invisibleVendingMachineRef
public InvisibleVendingMachine machine
public float greetDir
public Vector3 initialFacingDir
public BasePlayer lastWavedAtPlayer
public InvisibleVendingMachine GetVendingMachine()
public void UpdateProtectionFromClothing()
public void Hurt(HitInfo info)
public void ServerInit()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void PostServerLoad()
public void DelayedSleepEnd()
public void GreetPlayer(BasePlayer player)
public void Greeting()
}
public NPCSpawner : SpawnGroup {
public int AdditionalLOSBlockingLayer
public MonumentNavMesh monumentNavMesh
public bool shouldFillOnSpawn
public AIInformationZone VirtualInfoZone
public AIMovePointPath Path
public BasePath AStarGraph
public bool UseStatModifiers
public float SenseRange
public bool CheckLOS
public float TargetLostRange
public float AttackRangeMultiplier
public float ListenRange
public float CanUseHealingItemsChance
public PlayerInventoryProperties[] Loadouts
public void SpawnInitial()
public bool WaitingForNavMesh()
public void LateSpawn()
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
private void ModifyHumanBrainStats(BaseAIBrain brain)
}
public NPCTalking : NPCShopKeeper {
public ConversationData[] conversations
public NPCConversationResultAction[] conversationResultActions
public float maxConversationDistance
public List`1<BasePlayer> conversingPlayers
public BasePlayer lastActionPlayer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetConversationIndex(string conversationName)
public string GetConversationStartSpeech(BasePlayer player)
public ConversationData GetConversation(string conversationName)
public ConversationData GetConversation(int index)
public ConversationData GetConversationFor(BasePlayer player)
public bool ProviderBusy()
public void ForceEndConversation(BasePlayer player)
public void ForceSpeechNode(BasePlayer player, int speechNodeIndex)
public void OnConversationEnded(BasePlayer player)
public void CleanupConversingPlayers()
public void Server_BeginTalking(RPCMessage msg)
protected bool CanTalkTo(BasePlayer bp)
public void Server_BeginTalking(BasePlayer ply)
public void OnConversationStarted(BasePlayer speakingTo)
public void UpdateFlags()
public void Server_EndTalking(RPCMessage msg)
public void ConversationAction(RPCMessage msg)
public bool ValidConversationPlayer(BasePlayer player)
public void Server_ResponsePressed(RPCMessage msg)
public BasePlayer GetActionPlayer()
public void OnConversationAction(BasePlayer player, string action)
}
public NPCVendingMachine : VendingMachine {
public NPCVendingOrder vendingOrders
public Phrase Phrase
public float RefillTime
public int StartingStock
public bool BypassDynamicPricing
private ListHashSet`1<NPCVendingMachine> allNpcVendingMachines
private Single[] refillTimes
public bool DynamicPricingEnabled
public int IntervalHours
public float MaximumPriceMultiplier
public float MinimumPriceMultiplier
public float StartingPriceMultiplier
public float PriceIncreaseAmount
public float PriceDecreaseAmount
private SalesData[] allSalesData
private DateTime lastHourUpdate
private bool preserveSalesData
private ItemDefinition _scrapItem
private DateTime CurrentDateTime
private TimeSpan PriceInterval
public ItemDefinition ScrapItem
private bool CanApplyDynamicPricing
public byte GetBPState(bool sellItemAsBP, bool currencyItemAsBP)
public void TakeCurrencyItem(Item takenCurrencyItem)
public void GiveSoldItem(Item soldItem, BasePlayer buyer)
public void PostServerLoad()
public void ServerInit()
internal void DoServerDestroy()
public void InstallFromVendingOrders()
private void SmartAddItemForSale(Entry ent)
public void InstallDefaultSellOrders()
public void Refill()
public void ClearSellOrders()
public void AddItemForSale(int itemID, int amountToSell, int currencyID, int currencyPerTransaction, byte bpState)
public void RefreshStock()
protected void RecordSaleAnalytics(Item itemSold, int orderId)
public string GetTranslationToken()
protected bool CanRotate()
public bool CanPlayerAdmin(BasePlayer player)
public void resetDynamicPricing()
public void printAllPriceChanges(Arg arg)
public void OnTimeModified()
private DateTime get_CurrentDateTime()
private TimeSpan get_PriceInterval()
public void RecordSale(int index, int count)
private void CheckSalesDataLength(bool reset)
public ItemDefinition get_ScrapItem()
protected float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder)
private bool get_CanApplyDynamicPricing()
private void DynamicPricingServerInit()
private void ResetDynamicPricing()
private void HourCheck()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public NPCVendingOrder : ScriptableObject {
public Entry[] orders
public List`1<Entry> GetRandomEntries(int count)
}
public NPCVendingOrderManifest : ScriptableObject {
public NPCVendingOrder[] orderList
public int GetIndex(NPCVendingOrder sample)
public NPCVendingOrder GetFromIndex(int index)
}
public NpcWalkAnimation : MonoBehaviour {
public Vector3 HipFudge
public BaseNpc Npc
public Animator Animator
public Transform HipBone
public Transform LookBone
public bool UpdateWalkSpeed
public bool UpdateFacingDirection
public bool UpdateGroundNormal
public Transform alignmentRoot
public bool LaggyAss
public bool LookAtTarget
public float MaxLaggyAssRotation
public float MaxWalkAnimSpeed
public bool UseDirectionBlending
public bool useTurnPosing
public float turnPoseScale
public float laggyAssLerpScale
public bool skeletonChainInverted
}
public NVGCamera : FacepunchBehaviour {
public NVGCamera instance
public PostProcessVolume postProcessVolume
public GameObject lights
}
public NVGEffect : PostEffectsBase {
public ColorCorrectionParams ColorCorrection1
public ColorCorrectionParams ColorCorrection2
public NoiseAndGrainParams NoiseAndGrain
private Texture2D rgbChannelTex1
private Texture2D rgbChannelTex2
private bool updateTexturesOnStartup
public Texture2D NoiseTexture
private float NOISE_TILE_AMOUNT
public Shader Shader
private Material material
private void Awake()
private void OnDestroy()
private void UpdateColorCorrectionTexture(ColorCorrectionParams param, Texture2D& tex)
public void UpdateTextures()
public bool CheckResources()
public bool IsActive()
public void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public OBBComponent : MonoBehaviour {
public Bounds Bounds
public OBB GetObb()
}
public ObjectEx : object {
public bool IsUnityNull(T obj)
}
public ObjectFlasher : BaseMonoBehaviour {
public GameObject enabledObj
public GameObject disabledObj
public float toggleLength
public float timeOffset
public float randomOffset
}
public ObjectRotation : MonoBehaviour {
public Camera cam
public bool ignoreNeedsKeyboard
public Transform panTransform
}
public ObjectSpam : MonoBehaviour {
public GameObject source
public int amount
public float radius
private void Start()
}
public ObjWriter : object {
public string MeshToString(Mesh mesh)
public void Write(Mesh mesh, string path)
}
public Occludee : MonoBehaviour {
public float minTimeVisible
public bool isStatic
public bool autoRegister
public bool stickyGizmos
public OccludeeState state
protected int occludeeId
protected Vector3 center
protected float radius
protected Renderer renderer
protected Collider collider
protected void Awake()
public void OnEnable()
public void OnDisable()
public void Register()
public void Unregister()
protected void OnVisibilityChanged(bool visible)
}
public OccludeeSphere : ValueType {
public int id
public OccludeeState state
public Sphere sphere
public bool IsRegistered
public bool get_IsRegistered()
public void Invalidate()
public void .ctor(int id)
public void .ctor(int id, Sphere sphere)
}
public OccludeeState : SmartListValue {
public int slot
public bool isStatic
public int layer
public OnVisibilityChanged onVisibilityChanged
public Cell cell
public SimpleList`1<State> states
public bool isVisible
public bool get_isVisible()
public OccludeeState Initialize(SimpleList`1<State> states, BufferSet set, int slot, Vector4 sphereBounds, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged)
public void Invalidate()
public void MakeVisible()
}
public OcclusionCulling : MonoBehaviour {
public ComputeShader computeShader
public bool usePixelShaderFallback
public bool useAsyncReadAPI
private Camera camera
private int ComputeThreadsPerGroup
private int InputBufferStride
private int ResultBufferStride
private int OccludeeMaxSlotsPerPool
private int OccludeePoolGranularity
private int StateBufferGranularity
private int GridBufferGranularity
private Queue`1<OccludeeState> statePool
private SimpleList`1<OccludeeState> staticOccludees
private SimpleList`1<State> staticStates
private SimpleList`1<int> staticVisibilityChanged
private SimpleList`1<OccludeeState> dynamicOccludees
private SimpleList`1<State> dynamicStates
private SimpleList`1<int> dynamicVisibilityChanged
private List`1<int> staticChanged
private Queue`1<int> staticRecycled
private List`1<int> dynamicChanged
private Queue`1<int> dynamicRecycled
private BufferSet staticSet
private BufferSet dynamicSet
private BufferSet gridSet
private Vector4[] frustumPlanes
private String[] frustumPropNames
private Single[] matrixToFloatTemp
private Material fallbackMat
private Material depthCopyMat
private Matrix4x4 viewMatrix
private Matrix4x4 projMatrix
private Matrix4x4 viewProjMatrix
private Matrix4x4 prevViewProjMatrix
private Matrix4x4 invViewProjMatrix
private bool useNativePath
private OcclusionCulling instance
public bool Passthrough
private GraphicsDeviceType[] supportedDeviceTypes
private bool _enabled
private bool _safeMode
private DebugFilter _debugShow
public DebugSettings debugSettings
private Material debugMipMat
private float debugDrawDuration
private Material downscaleMat
private Material blitCopyMat
private int hiZLevelCount
private int hiZWidth
private int hiZHeight
private RenderTexture depthTexture
private RenderTexture hiZTexture
private RenderTexture[] hiZLevels
private int GridCellsPerAxis
private int GridHalfCellsPerAxis
private int GridMinHalfCellsPerAxis
private int GridMaxHalfCellsPerAxis
private float GridCellSize
private float GridHalfCellSize
private float GridRcpCellSize
private int GridPoolCapacity
private int GridPoolGranularity
private HashedPool`1<Cell> grid
private Queue`1<Cell> gridChanged
public OcclusionCulling Instance
public bool Supported
public bool Enabled
public bool SafeMode
public DebugFilter DebugShow
public bool HiZReady
public OcclusionCulling get_Instance()
public bool get_Supported()
public bool get_Enabled()
public void set_Enabled(bool value)
public bool get_SafeMode()
public void set_SafeMode(bool value)
public DebugFilter get_DebugShow()
public void set_DebugShow(DebugFilter value)
private void GrowStatePool()
private OccludeeState Allocate()
private void Release(OccludeeState state)
private void Awake()
private void OnEnable()
private bool SupportsNativePath()
private void OnDisable()
public void MakeAllVisible()
private void Update()
public void RecursiveAddOccludees(Transform transform, float minTimeVisible, bool isStatic, bool stickyGizmos)
private int FindFreeSlot(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, Queue`1<int> recycled)
public OccludeeState GetStateById(int id)
public int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged)
private int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged, SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, Queue`1<int> recycled, List`1<int> changed, BufferSet set, SimpleList`1<int> visibilityChanged)
public void UnregisterOccludee(int id)
private void UnregisterOccludee(int slot, SimpleList`1<OccludeeState> occludees, Queue`1<int> recycled, List`1<int> changed)
public void UpdateDynamicOccludee(int id, Vector3 center, float radius)
private void UpdateBuffers(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, BufferSet set, List`1<int> changed, bool isStatic)
private void UpdateCameraMatrices(bool starting)
private void OnPreCull()
private void OnPostRender()
private Single[] MatrixToFloatArray(Matrix4x4 m)
private void PrepareAndDispatch()
private void IssueRead()
public void ResetTiming(SmartList bucket)
public void ResetTiming()
private void ProcessCallbacks(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, SimpleList`1<int> changed)
public void RetrieveAndApplyVisibility()
public bool DebugFilterIsDynamic(int filter)
public bool DebugFilterIsStatic(int filter)
public bool DebugFilterIsGrid(int filter)
private void DebugInitialize()
private void DebugShutdown()
private void DebugUpdate()
private void DebugDraw()
public void NormalizePlane(Vector4& plane)
public void ExtractFrustum(Matrix4x4 viewProjMatrix, Vector4[]& planes)
public bool get_HiZReady()
public void CheckResizeHiZMap()
private void InitializeHiZMap()
private void FinalizeHiZMap()
private void InitializeHiZMap(int width, int height)
private void DestroyHiZMap()
private RenderTexture CreateDepthTexture(string name, int width, int height, bool mips)
private RenderTexture CreateDepthTextureMip(string name, int width, int height, int mip)
public void GrabDepthTexture()
public void GenerateHiZMipChain()
private void DebugDrawGizmos()
private int floor(float x)
public Cell RegisterToGrid(OccludeeState occludee)
public void UpdateInGrid(OccludeeState occludee)
public void UnregisterFromGrid(OccludeeState occludee)
public void UpdateGridBuffers()
private bool FrustumCull(Vector4[] planes, Vector4 testSphere)
private int ProcessOccludees_Safe(SimpleList`1<State> states, SmartList bucket, Color32[] results, SimpleList`1<int> changed, Vector4[] frustumPlanes, float time, UInt32 frame)
private int ProcessOccludees_Fast(State[] states, Int32[] bucket, int bucketCount, Color32[] results, int resultCount, Int32[] changed, Int32& changedCount, Vector4[] frustumPlanes, float time, UInt32 frame)
private int ProcessOccludees_Native(State& states, Int32& bucket, int bucketCount, Color32& results, int resultCount, Int32& changed, Int32& changedCount, Vector4& frustumPlanes, float time, UInt32 frame)
private void ApplyVisibility_Safe(float time, UInt32 frame)
private void ApplyVisibility_Fast(float time, UInt32 frame)
private void ApplyVisibility_Native(float time, UInt32 frame)
private void ApplyVisibility_Passthrough(float time, UInt32 frame)
}
public OceanSettings : ScriptableObject {
public ComputeShader waveSpectrumCompute
public ComputeShader fftCompute
public ComputeShader waveMergeCompute
public ComputeShader waveInitialSpectrum
public Single[] octaveScales
public float lamda
public float windDirection
public float distanceAttenuationFactor
public float depthAttenuationFactor
public OceanSpectrumSettings[] spectrumSettings
public Single[] spectrumRanges
public OceanDisplacementShort3[0...,0...,0...] LoadSimData()
}
public OnePoleLowpassFilter : MonoBehaviour {
public float frequency
}
public OnParentDestroyingEx : object {
public void BroadcastOnParentDestroying(GameObject go)
public void SendOnParentDestroying(GameObject go)
}
public OnParentSpawningEx : object {
public void BroadcastOnParentSpawning(GameObject go)
public void SendOnParentSpawning(GameObject go)
}
public OnPositionMemorySetAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public OnPostNetworkUpdateEx : object {
public void BroadcastOnPostNetworkUpdate(GameObject go, BaseEntity entity)
public void SendOnPostNetworkUpdate(GameObject go, BaseEntity entity)
}
public OnSendNetworkUpdateEx : object {
public void BroadcastOnSendNetworkUpdate(GameObject go, BaseEntity entity)
public void SendOnSendNetworkUpdate(GameObject go, BaseEntity entity)
}
public OpenSteamURL : MonoBehaviour {
public bool openInSteam
}
public OpenURL : MonoBehaviour {
public bool OpenWebURL
}
public OreHopper : PercentFullStorageContainer {
private Transform oreOutputMesh
private float visualPercentFull
private Vector3 _oreScale
protected void OnPercentFullChanged(float newPercentFull)
private void SetVisualOreLevel(float percentFull)
public void VisualLerpToOreLevel()
private void OreVisualLerpUpdate()
public void ServerInit()
}
public OreHotSpot : BaseCombatEntity {
public float visualDistance
public GameObjectRef visualEffect
public GameObjectRef finishEffect
public GameObjectRef damageEffect
public OreResourceEntity owner
public void OreOwner(OreResourceEntity newOwner)
public void ServerInit()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public void FireFinishEffect()
}
public OreResourceEntity : StagedResourceEntity {
public GameObjectRef bonusPrefab
public GameObjectRef finishEffect
public GameObjectRef bonusFailEffect
public OreHotSpot _hotSpot
public SoundPlayer bonusSound
private int bonusesKilled
public int bonusesSpawned
public Vector3 lastNodeDir
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnAttacked(HitInfo info)
public void UpdateNetworkStage()
public void CleanupBonus()
public void DestroyShared()
public void OnKilled(HitInfo info)
public void ServerInit()
private void InitialSpawnBonusSpot()
public void FinishBonusAssigned()
public void DelayedBonusSpawn()
public void RespawnBonus()
public OreHotSpot SpawnBonusSpot(Vector3 lastDirection)
public Vector3 RandomCircle(float distance, bool allowInside)
public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset, bool allowInside, bool changeHeight)
public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight, float maxHeight, bool allowInside)
public Vector3 ClampToCylinder(Vector3 localPos, Vector3 cylinderAxis, float cylinderDistance, float minHeight, float maxHeight)
}
public ORSwitch : IOEntity {
private int input1Amount
private int input2Amount
public int ConsumptionAmount()
public bool WantsPower(int inputIndex)
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int slot)
}
public OutlineManager : MonoBehaviour {
public Material blurMat
public List`1<OutlineObject> objectsToRender
public float blurAmount
public Material glowSolidMaterial
public Material blendGlowMaterial
}
public OutlineObject : MonoBehaviour {
public Mesh[] meshes
public Transform[] meshTransforms
}
public OvenItemIcon : MonoBehaviour {
public ItemIcon ItemIcon
public RustText ItemLabel
public RustText MaterialLabel
public OvenSlotType SlotType
public Phrase EmptyPhrase
public List`1<OvenSlotConfig> SlotConfigs
public float DisabledAlphaScale
public CanvasGroup CanvasGroup
private Item _item
private void Start()
private void Update()
private void UpdateLabels()
private bool <Start>b__10_0(OvenSlotConfig x)
}
public OvenLineRow : MonoBehaviour {
public LootGrid Above
public LootGrid Below
public Transform Container
public Color Color
public Sprite TriangleSprite
public int LineWidth
public int ArrowWidth
public int ArrowHeight
public int Padding
private int _topCount
private int _bottomCount
private List`1<GameObject> images
private void Update()
private void CreateRow(bool above)
private Image CreateImage()
}
public OvenLootPanel : MonoBehaviour {
public GameObject controlsOn
public GameObject controlsOff
public Image TitleBackground
public RustText TitleText
public Color AlertBackgroundColor
public Color AlertTextColor
public Color OffBackgroundColor
public Color OffTextColor
public Color OnBackgroundColor
public Color OnTextColor
private Phrase OffPhrase
private Phrase OnPhrase
private Phrase NoFuelPhrase
public GameObject FuelRowPrefab
public GameObject MaterialRowPrefab
public GameObject ItemRowPrefab
public Sprite IconBackground_Wood
public Sprite IconBackGround_Input
public LootGrid LootGrid_Wood
public LootGrid LootGrid_Input
public LootGrid LootGrid_Output
public GameObject Contents
public GameObject[] ElectricDisableRoots
}
public OvenSlotType : Enum {
public int value__
public OvenSlotType Fuel
public OvenSlotType Charcoal
public OvenSlotType Material
public OvenSlotType Smelted
public OvenSlotType FoodInput
public OvenSlotType FoodOutput
}
public OvenStatus : Enum {
public int value__
public OvenStatus NoFuel
public OvenStatus Off
public OvenStatus On
}
public OverlayBlendMode : Enum {
public int value__
public OverlayBlendMode Additive
public OverlayBlendMode ScreenBlend
public OverlayBlendMode Multiply
public OverlayBlendMode Overlay
public OverlayBlendMode AlphaBlend
public OverlayBlendMode AdditiveNonLit
}
public OverlayMeshPaintableSource : MeshPaintableSource {
private Memoized`2<string, string> STPrefixed
public string baseTextureName
public Texture2D baseTexture
public void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride, bool forEditing, bool isSelected)
}
public OxygenOverlay : MonoBehaviour {
private PostProcessVolume postProcessVolume
private float smoothTime
private bool submarinesOnly
}
public Paddle : BaseMelee {
public float animPaddleCooldown
public GameObjectRef kayakSeat
public float animationLerpSpeed
}
public PaddlingPool : LiquidContainer {
public Flags FilledUp
public Transform poolWaterVolume
public GameObject poolWaterVisual
public float minimumWaterHeight
public float maximumWaterHeight
public WaterVolume waterVolume
public bool alignWaterUp
public GameObjectRef destroyedWithWaterEffect
public Transform destroyedWithWaterEffectPos
public Collider requireLookAt
private float lastFillAmount
public void OnItemAddedOrRemoved(Item item, bool added)
protected void OnInventoryDirty()
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public void Save(SaveInfo info)
private float GetNormalisedFillLevel()
private void UpdatePoolFillAmount(float normalisedAmount)
public int ConsumptionAmount()
public void DestroyShared()
}
public PagerEntity : BaseEntity {
public Flags Flag_Silent
private int frequency
public float beepRepeat
public GameObjectRef pagerEffect
public GameObjectRef silentEffect
private float nextChangeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetFrequency()
public void SwitchParent(BaseEntity ent)
public void ServerInit()
internal void DoServerDestroy()
public Vector3 GetPosition()
public float GetMaxRange()
public void RFSignalUpdate(bool on)
public void SetSilentMode(bool wantsSilent)
public void SetOff()
public void ChangeFrequency(int newFreq)
public void ServerSetFrequency(RPCMessage msg)
public void Save(SaveInfo info)
internal void OnParentRemoved()
public void OnParentDestroying()
public void Load(LoadInfo info)
}
public PaintableImageGrid : UIBehaviour {
public UIPaintableImage templateImage
public int cols
public int rows
}
public PaintableItem : MonoBehaviour {
public MeshPaintableSource PaintableSource
}
public PaintedItemStorageEntity : BaseEntity {
public UInt32 _currentImageCrc
private ulong lastEditedBy
public UInt32[] GetContentCRCs
public UGCType ContentType
public List`1<ulong> EditingHistory
public BaseNetworkable UgcEntity
public bool ShouldTransferAssociatedFiles
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
private void Server_UpdateImage(RPCMessage msg)
internal void DoServerDestroy()
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public UGCType get_ContentType()
public List`1<ulong> get_EditingHistory()
public BaseNetworkable get_UgcEntity()
public bool get_ShouldTransferAssociatedFiles()
private void DebugOnlyLog(string str)
}
public Painting.Brush : object {
public float spacing
public Vector2 brushSize
public Texture2D texture
public Color color
public bool erase
}
public PaperDollSegment : BaseMonoBehaviour {
public HitArea selectedAreas
public HitArea area
public Image overlayImg
}
public Parachute : BaseVehicle {
public Collider ParachuteCollider
public ItemDefinition PackedParachute
public GameObjectRef DetachedParachute
public Transform DetachedSpawnPoint
public float ConditionLossPerUse
public float HurtDeployTime
public float HurtAmount
public Animator ColliderAnimator
public Animator ColliderWorldAnimator
public float UprightLerpForce
public float ConstantForwardForce
public ForceMode ForwardForceMode
public float TurnForce
public ForceMode TurnForceMode
public float ForwardTiltAcceleration
public float BackInputForceMultiplier
public float DeployAnimationLength
public float TargetDrag
public float TargetAngularDrag
public AnimationCurve DragCurve
public AnimationCurve DragDamageCurve
public AnimationCurve MassDamageCurve
public AnimationCurve DamageHorizontalVelocityCurve
public float DamageTester
public float AnimationInputSmoothness
public Vector2 AnimationInputScale
public ParachuteWearable FirstPersonCanopy
public GameObjectRef ParachuteLandScreenBounce
private int AnimatorInputXParameter
private int AnimatorInputYParameter
private TimeSince mountTime
public Flags Flag_InputForward
public Flags Flag_InputBack
public Flags Flag_InputLeft
public Flags Flag_InputRight
public SoundDefinition deploySoundDef
public SoundDefinition releaseSoundDef
public SoundDefinition flightLoopSoundDef
public SoundDefinition steerSoundDef
public AnimationCurve flightLoopPitchCurve
public AnimationCurve flightLoopGainCurve
public bool BypassRepack
public bool LandingAnimations
private bool collisionDeath
private Vector3 collisionImpulse
private float startHeight
private float distanceTravelled
private Vector3 lastPosition
private Vector2 lerpedInput
private Vector3 collisionLocalPos
private Vector3 collisionWorldNormal
protected bool BypassClothingMountBlocks
public SamTargetType SAMTargetType
protected bool get_BypassClothingMountBlocks()
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public bool GetDismountPosition(BasePlayer player, Vector3& res)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void VehicleFixedUpdate()
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
private void ProcessDeath()
public void OnCollision(Collision collision, BaseEntity hitEntity)
private void DelayedDismount()
public float MaxVelocity()
public bool AllowPlayerInstigatedDismount(BasePlayer player)
public SamTargetType get_SAMTargetType()
public bool IsValidSAMTarget(bool staticRespawn)
private Vector2 ProcessInputVector(InputState inputState, BasePlayer player)
private Vector2 ProcessInputVectorFromFlags(BasePlayer player)
private Vector2 ProcessInputVector(bool leftDown, bool rightDown, bool forwardDown, bool backDown)
}
public ParachuteSeat : SledSeat {
protected bool BypassClothingMountBlocks
protected bool get_BypassClothingMountBlocks()
}
public ParachuteUnpacked : DecayEntity {
public Rigidbody targetRigidbody
public Transform centreOfMassRoot
public void ServerInit()
}
public ParachuteWearable : MonoBehaviour {
public Animator TargetAnimator
public Transform LeftHandTarget
public Transform RightHandTarget
}
public ParticleCollisionLOD : LODComponentParticleSystem {
public State[] States
}
public ParticleDisableOnParentDestroy : MonoBehaviour {
public float destroyAfterSeconds
public void OnParentDestroying()
}
public ParticleEmissionSound : FacepunchBehaviour {
public ParticleSystem particleSystem
public SoundDefinition soundDefinition
public float soundCooldown
}
public ParticleEmitFromParentObject : MonoBehaviour {
public string bonename
private Bounds bounds
private Transform bone
private BaseEntity entity
private float lastBoundsUpdate
}
public ParticleRandomLifetime : MonoBehaviour {
public ParticleSystem mySystem
public float minScale
public float maxScale
public void Awake()
}
public ParticleSpawn : SingletonComponent`1<ParticleSpawn> {
public GameObjectRef[] Prefabs
public int PatchCount
public int PatchSize
private Vector3 <Origin>k__BackingField
public Vector3 Origin
public Vector3 get_Origin()
private void set_Origin(Vector3 value)
}
public ParticleSystemContainer : MonoBehaviour {
public bool precached
public bool includeLights
private ParticleSystemGroup[] particleGroups
private Light[] lights
private LightEx[] lightExs
public void Play()
public void Pause()
public void Stop()
public void Clear()
private void SetLights(bool on)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public ParticleSystemCull : LODComponentParticleSystem {
public float Distance
}
public ParticleSystemEx : object {
public void SetPlayingState(ParticleSystem ps, bool play)
public void SetEmitterState(ParticleSystem ps, bool enable)
}
public ParticleSystemLOD : LODComponentParticleSystem {
public State[] States
}
public ParticleSystemPlayer : MonoBehaviour {
protected void OnEnable()
public void OnParentDestroying()
}
public PartyHatMaterialRandomiser : MonoBehaviour {
public Material[] MaterialOptions
public Renderer[] TargetRenderers
public void OnItemSetup(Item item)
}
public PathFinder : object {
private Int32[0...,0...] costmap
private Int32[0...,0...] visited
private Point[] neighbors
private bool diagonals
private bool directional
public Point PushPoint
public int PushRadius
public int PushDistance
public int PushMultiplier
public List`1<Point> PushPointsAdditional
public HashSet`1<Point> BlockedPointsAdditional
private Point[] mooreNeighbors
private Point[] neumannNeighbors
public void .ctor(Int32[0...,0...] costmap, bool diagonals, bool directional)
public int GetResolution(int index)
public Node FindPath(Point start, Point end, int depth)
private Node FindPathReversed(Point start, Point end, int depth)
public Node FindPathDirected(List`1<Point> startList, List`1<Point> endList, int depth)
public Node FindPathUndirected(List`1<Point> startList, List`1<Point> endList, int depth)
private Node FindPathReversed(List`1<Point> startList, List`1<Point> endList, int depth)
public Node FindClosestWalkable(Point start, int depth)
public bool IsWalkable(Point point)
public bool IsWalkableWithNeighbours(Point point)
public Node Reverse(Node start)
public Node FindEnd(Node start)
public int Cost(Point a)
public int Cost(Point a, Node prev)
public int Heuristic(Point a)
public int Heuristic(Point a, Point b)
public int Heuristic(Point a, List`1<Point> b)
public float Distance(Point a, Point b)
public Point GetPoint(Vector3 worldPos, int res)
}
public PathInterestNode : MonoBehaviour {
private float <NextVisitTime>k__BackingField
public Vector3 Position
public float NextVisitTime
public Vector3 get_Position()
public float get_NextVisitTime()
public void set_NextVisitTime(float value)
public void OnDrawGizmos()
}
public PathInterpolator : object {
public Vector3[] Points
public Vector3[] Tangents
private int <MinIndex>k__BackingField
private int <MaxIndex>k__BackingField
private float <Length>k__BackingField
private float <StepSize>k__BackingField
private bool <Circular>k__BackingField
protected bool initialized
public int MinIndex
public int MaxIndex
public float Length
public float StepSize
public bool Circular
public int DefaultMinIndex
public int DefaultMaxIndex
public float StartOffset
public float EndOffset
public int get_MinIndex()
public void set_MinIndex(int value)
public int get_MaxIndex()
public void set_MaxIndex(int value)
public float get_Length()
private void set_Length(float value)
public float get_StepSize()
private void set_StepSize(float value)
public bool get_Circular()
private void set_Circular(bool value)
public int get_DefaultMinIndex()
public int get_DefaultMaxIndex()
public float get_StartOffset()
public float get_EndOffset()
public void .ctor(Vector3[] points)
public void .ctor(Vector3[] points, Vector3[] tangents)
public void RecalculateTangents()
public void RecalculateLength()
public void Resample(float distance)
public void Smoothen(int iterations, Func`2<int, float> filter)
public void Smoothen(int iterations, Vector3 multipliers, Func`2<int, float> filter)
private void SmoothenIndex(int i, Vector3 multipliers, Func`2<int, float> filter)
public Vector3 GetStartPoint()
public Vector3 GetEndPoint()
public Vector3 GetStartTangent()
public Vector3 GetEndTangent()
public Vector3 GetPointByIndex(int i)
public Vector3 GetTangentByIndex(int i)
public Vector3 GetPoint(float distance)
public Vector3 GetTangent(float distance)
public Vector3 GetPointCubicHermite(float distance)
}
public PathList : object {
private Quaternion rot90
private Quaternion rot180
private Quaternion rot270
public string Name
public PathInterpolator Path
public bool Spline
public bool Start
public bool End
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
public int Topology
public int Splat
public int Hierarchy
public Node ProcgenStartNode
public Node ProcgenEndNode
public float StepSize
private Single[] placements
public void .ctor(string name, Vector3[] points)
private void SpawnObjectsNeighborAligned(UInt32& seed, Prefab[] prefabs, List`1<Vector3> positions, SpawnFilter filter)
private bool SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter)
private bool SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, List`1<Prefab> previousSpawns, Prefab& spawned, int pathLength, int index, SpawnFilter filter)
private bool CheckObjects(Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter)
private void SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
private bool CheckObjects(Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
public void SpawnSide(UInt32& seed, SideObject obj)
public void SpawnAlong(UInt32& seed, PathObject obj)
public void SpawnBridge(UInt32& seed, BridgeObject obj)
public void SpawnStart(UInt32& seed, BasicObject obj)
public void SpawnEnd(UInt32& seed, BasicObject obj)
public void TrimStart(BasicObject obj)
public void TrimEnd(BasicObject obj)
public void TrimTopology(int topology)
public void ResetTrims()
public void AdjustTerrainHeight(float intensity, float fade)
public void AdjustTerrainTexture()
public void AdjustTerrainTopology()
public void AdjustPlacementMap(float width)
public List`1<MeshObject> CreateMesh(Mesh[] meshes, float normalSmoothing, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain)
}
public PathSequence : PrefabAttribute {
protected Type GetIndexedType()
public void ApplySequenceReplacement(List`1<Prefab> sequence, Prefab& replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex)
}
public PathSequencePowerline : PathSequence {
public SequenceRule Rule
private int RegularPowerlineSpacing
public void ApplySequenceReplacement(List`1<Prefab> sequence, Prefab& replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex)
private Prefab GetPrefabOfType(Prefab[] options, SequenceRule ruleToFind)
private int GetIndexCountToRule(List`1<Prefab> sequence, SequenceRule rule)
}
public PathSpeedZone : MonoBehaviour {
public Bounds bounds
public OBB obbBounds
public float maxVelocityPerSec
public OBB WorldSpaceBounds()
public float GetMaxSpeed()
}
public PatrolHelicopter : BaseCombatEntity {
public GameObject rotorPivot
public GameObject mainRotor
public GameObject mainRotor_blades
public GameObject mainRotor_blur
public GameObject tailRotor
public GameObject tailRotor_blades
public GameObject tailRotor_blur
public GameObject rocket_tube_left
public GameObject rocket_tube_right
public GameObject left_gun_yaw
public GameObject left_gun_pitch
public GameObject left_gun_muzzle
public GameObject right_gun_yaw
public GameObject right_gun_pitch
public GameObject right_gun_muzzle
public GameObject spotlight_rotation
public GameObjectRef rocket_fire_effect
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public GameObjectRef explosionEffect
public GameObjectRef fireBall
public GameObjectRef crateToDrop
public int maxCratesToSpawn
public float bulletSpeed
public float bulletDamage
public GameObjectRef servergibs
public GameObjectRef debrisFieldMarker
public float flareDuration
public SoundDefinition rotorWashSoundDef
private Sound _rotorWashSound
public SoundDefinition flightEngineSoundDef
public SoundDefinition flightThwopsSoundDef
private Sound flightEngineSound
private Sound flightThwopsSound
public Modulator flightEngineGainMod
public Modulator flightThwopsGainMod
public float rotorGainModSmoothing
public float engineGainMin
public float engineGainMax
public float thwopGainMin
public float thwopGainMax
public float spotlightJitterAmount
public float spotlightJitterSpeed
public GameObject[] nightLights
public Vector3 spotlightTarget
public float engineSpeed
public float targetEngineSpeed
public float blur_rotationScale
public ParticleSystem[] _rotorWashParticles
public PatrolHelicopterAI myAI
public GameObjectRef mapMarkerEntityPrefab
public float lastNetworkUpdate
private float networkUpdateRate
private BaseEntity mapMarkerInstance
public weakspot[] weakspots
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float MaxVelocity()
public void InitShared()
public void Load(LoadInfo info)
public void RadarLock(SeekingServerProjectile incoming)
public void CancelRadar()
public void Save(SaveInfo info)
public void ServerInit()
public void DestroyShared()
public void CreateMapMarker()
public void OnPositionalNetworkUpdate()
public void CreateExplosionMarker(float durationMinutes)
public void OnKilled(HitInfo info)
public bool IsValidHomingTarget()
public void OnEntityMessage(BaseEntity from, string msg)
public void DoFlare()
public void ClearFlares()
public void Update()
public void InitalizeWeakspots()
public void OnAttacked(HitInfo info)
public void Hurt(HitInfo info)
}
public PatrolHelicopterAI : BaseMonoBehaviour {
public Vector3 interestZoneOrigin
public Vector3 destination
public bool hasInterestZone
public float moveSpeed
public float maxSpeed
public float courseAdjustLerpTime
public Quaternion targetRotation
public Vector3 windVec
public Vector3 targetWindVec
public float windForce
public float windFrequency
public float targetThrottleSpeed
public float throttleSpeed
public float maxRotationSpeed
public float rotationSpeed
public float terrainPushForce
public float obstaclePushForce
public HelicopterTurret leftGun
public HelicopterTurret rightGun
public PatrolHelicopterAI heliInstance
public PatrolHelicopter helicopterBase
public aiState _currentState
public float oceanDepthTargetCutoff
public AIHelicopterAnimation anim
private Vector3 _aimTarget
private bool movementLockingAiming
private bool hasAimTarget
private bool aimDoorSide
private Vector3 pushVec
private Vector3 _lastPos
private Vector3 _lastMoveDir
public bool isDead
public bool isRetiring
public float spawnTime
public float lastDamageTime
public float flee_damage_percentage
public bool use_danger_zones
public bool monument_crash
private bool shouldDebug
public List`1<targetinfo> _targetList
public List`1<DangerZone> dangerZones
public List`1<DangerZone> noGoZones
private int max_zones
private float no_go_zone_size
private float danger_zone_size
private DangerZone leastActiveZone
private float deathTimeout
private bool didImpact
private Collider[] collisions
private bool reachedSpinoutLocation
private float destination_min_dist
private float currentOrbitDistance
private float currentOrbitTime
private bool hasEnteredOrbit
private float orbitStartTime
public float maxOrbitDuration
private bool breakingOrbit
private float timeBetweenRocketsOrbit
private bool didGetToDesination
public List`1<MonumentInfo> _visitedMonuments
public float arrivalTime
public GameObjectRef rocketProjectile
public GameObjectRef rocketProjectile_Napalm
public bool leftTubeFiredLast
public float lastRocketTime
public float timeBetweenRockets
public int numRocketsLeft
public int maxRockets
public Vector3 strafe_target_position
public BasePlayer strafe_target
public bool puttingDistance
public float strafe_approach_range
public float strafe_firing_range
private float get_out_of_strafe_distance
private bool passNapalm
private Vector3 cached_strafe_pos
private TimeSince timeSinceRefreshed
private bool useNapalm
public float lastNapalmTime
public float lastStrafeTime
private float _lastThinkTime
public bool IsDead
public bool get_IsDead()
private void dumpstate()
public void Awake()
public void SetInitialDestination(Vector3 dest, float mapScaleDistance)
public void Retire()
public void SetIdealRotation(Quaternion newTargetRot, float rotationSpeedOverride)
public Quaternion GetYawRotationTo(Vector3 targetDest)
public void SetTargetDestination(Vector3 targetDest, float minDist, float minDistForFacingRotation)
public bool AtDestination()
public bool AtRotation()
private void NoGoZoneAdded(DangerZone zone)
public void MoveToDestination()
public void TerrainPushback()
public void UpdateRotation()
public void UpdateSpotlight()
public void Update()
public void FixedUpdate()
public void OtherDamaged(HitInfo info)
public void WeakspotDamaged(weakspot weak, HitInfo info)
public void TryStrafePlayer(HitInfo info, float timeSinceDamagedThreshold)
public void CriticalDamage()
public void DoMachineGuns()
public void FireGun(Vector3 targetPos, float aimCone, bool left)
public bool CanInterruptState()
public bool IsAlive()
public void DestroyMe()
public Vector3 GetLastMoveDir()
public Vector3 GetMoveDirection()
public float GetMoveSpeed()
public float GetMaxRotationSpeed()
public bool IsTargeting()
public void UpdateWind()
public void SetAimTarget(Vector3 aimTarg, bool isDoorSide)
public void ClearAimTarget()
public void UpdateTargetList()
private void UpdateTargetLineOfSightTime(targetinfo targ)
private void AddNewTargetsToList()
private Nullable`1<Vector3> FindTargetWithZones(bool withOffset)
private Vector3 FindDefaultTarget(bool withOffset)
private Vector3 GetTargetOffset()
public bool PlayerVisible(BasePlayer ply)
public void WasAttacked(HitInfo info)
public void UpdateDangerZones(Vector3 position, float damage, BasePlayer ply, weakspot weak)
public void MakeZone(Vector3 position, float damage, BaseEntity parent)
private void UpdateNoGoZones(DangerZone zone)
public void ClearStaleZones()
private void RemoveLeastSignificantZone()
public bool IsInNoGoZone(Vector3 position)
public bool IsInDangerZone(Vector3 position, DangerZone& dangerZone)
public void State_Death_Think(float timePassed)
public void State_Death_Enter()
public void State_Death_Leave()
private MonumentInfo GetCloseMonument(float maxDistance)
private void PhysicsDeathCheck()
private void KillOfNaturalCauses()
private void StartSpinout()
public void State_Flee_Think(float timePassed)
public void State_Flee_Enter(Vector3 newPos)
public void State_Flee_Leave()
public void State_Idle_Think(float timePassed)
public void State_Idle_Enter()
public void State_Idle_Leave()
public void State_Move_Think(float timePassed)
public void State_Move_Enter(Vector3 newPos)
public void State_Move_Leave()
private void TryMove(Vector3 newPos)
private void UpdateMove(float timePassed)
public void State_Orbit_Think(float timePassed)
public Vector3 GetOrbitPosition(float rate)
public void State_Orbit_Enter(float orbitDistance)
public void State_Orbit_Leave()
private void OrbitInit(float orbitDistance, float minDistForFacingRotation)
private void OrbitUpdate(float timePassed, float minDistForFacingRotation, bool canBreak)
private void StartBreakOrbit()
private void DebugOrbit()
public void State_OrbitStrafe_Enter()
public void State_OrbitStrafe_Think(float timePassed)
public void State_OrbitStrafe_Leave()
public Vector3 GetRandomPatrolDestination()
private Vector3 FindValidDestination(int maxAttempts)
public Vector3 GenerateRandomDestination(bool forceMonument)
public void State_Patrol_Think(float timePassed)
private void OrbitInterestZone()
public void State_Patrol_Enter()
public void State_Patrol_Leave()
private Vector3 GetRandomMapPosition()
public int ClipRocketsLeft()
public bool CanStrafe()
public bool CanUseNapalm()
public void State_Strafe_Enter(BasePlayer strafeTarget, bool shouldUseNapalm)
public void State_Strafe_Think(float timePassed)
private Vector3 GetPredictedPosition()
private bool CanSeeForStrafe(Vector3 targetPos)
public bool ValidRocketTarget(BasePlayer ply)
public void State_Strafe_Leave()
private void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm)
public void FireRocket(Vector3 targetPos)
private void RefreshTargetPosition()
public void InitializeAI()
public void OnCurrentStateExit()
public void ExitCurrentState()
public float GetTime()
public void AIThink()
public Vector3 GetRandomOffset(Vector3 origin, float minRange, float maxRange, float minHeight, float maxHeight)
public Vector3 GetAppropriatePosition(Vector3 origin, float minHeight, float maxHeight)
public float GetThrottleForDistance(float distToTarget)
}
public PatternFirework : MortarFirework {
public int CurrentVersion
public GameObjectRef FireworkDesignerDialog
public int MaxStars
public float ShellFuseLengthShort
public float ShellFuseLengthMed
public float ShellFuseLengthLong
public Design Design
public FuseLength ShellFuseLength
public UInt32[] GetContentCRCs
public UGCType ContentType
public List`1<ulong> EditingHistory
public BaseNetworkable UgcEntity
public void DestroyShared()
public void ServerInit()
private void StartOpenDesigner(RPCMessage rpc)
private void ServerSetFireworkDesign(RPCMessage rpc)
private void SetShellFuseLength(RPCMessage rpc)
private bool PlayerCanModify(BasePlayer player)
public void Save(SaveInfo info)
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public UGCType get_ContentType()
public List`1<ulong> get_EditingHistory()
public BaseNetworkable get_UgcEntity()
public void Load(LoadInfo info)
public float GetShellFuseLength()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public PatternFireworkShell : FireworkShell {
public GameObjectRef StarPrefab
public AnimationCurve StarCurve
public float Duration
public float Scale
public MinMax RandomSaturation
public MinMax RandomValue
}
public PatternFireworkStar : MonoBehaviour {
public GameObject Pixel
public GameObject Explosion
public ParticleSystem[] ParticleSystems
public void Initialize(Color color)
public void Explode()
}
public PegConfig : object {
public PegType Type
public Vector3 VerticalMountLocalRotation
public Vector3 VerticalMountLocalOffset
public void Init(PegType t, Vector3 localRot, Vector3 localOffset)
}
public PercentFullStorageContainer : StorageContainer {
private float prevPercentFull
public bool IsFull()
public bool IsEmpty()
protected void OnPercentFullChanged(float newPercentFull)
public float GetPercentFull()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
protected void OnInventoryDirty()
}
public Performance : SingletonComponent`1<Performance> {
public Tick current
public Tick report
public int FrameHistoryCount
private int HistoryLength
private long cycles
private Int32[] frameRateHistory
private Single[] frameTimeHistory
private Int32[] frameTimes
private int frames
private float time
private void Update()
public List`1<int> GetFrameTimes(int requestedStart, int maxCount, Int32& startIndex)
private void FPSTimer()
private float AverageFrameRate()
private float AverageFrameTime()
}
public PerformanceMetrics : object {
private PerformanceSamplePoint <LastFrame>k__BackingField
private PerformanceSamplePoint <PerformancePerSecond>k__BackingField
private PerformanceSamplePoint current
private Action OnBeforeRender
public PerformanceSamplePoint LastFrame
public PerformanceSamplePoint PerformancePerSecond
public PerformanceSamplePoint get_LastFrame()
private void set_LastFrame(PerformanceSamplePoint value)
public PerformanceSamplePoint get_PerformancePerSecond()
public void set_PerformancePerSecond(PerformanceSamplePoint value)
public void Setup()
private void AddCPUTimeStopwatch()
private void AddStopwatch(PerformanceSample sample, Action& pre, Action& post)
}
public PerformanceSample : Enum {
public int value__
public PerformanceSample Update
public PerformanceSample LateUpdate
public PerformanceSample PreCull
public PerformanceSample Render
public PerformanceSample FixedUpdate
public PerformanceSample NetworkMessage
public PerformanceSample TotalCPU
public PerformanceSample PhysicsUpdate
public PerformanceSample Last
}
public PerformanceSamplePoint : ValueType {
public int UpdateCount
public int FixedUpdateCount
public int RenderCount
public TimeSpan PreCull
public TimeSpan Update
public TimeSpan LateUpdate
public TimeSpan PhysicsUpdate
public TimeSpan Render
public TimeSpan FixedUpdate
public TimeSpan TotalCPU
public int CpuUpdateCount
public PerformanceSamplePoint Add(PerformanceSamplePoint other)
}
public PerformanceText : MonoBehaviour {
public TextMeshProUGUI text
}
public PerformedAttackAIEvent : BaseAIEvent {
protected float lastExecuteTime
private BaseCombatEntity combatEntity
public void Reset()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public PetBrain : BaseAIBrain {
public SoundDefinition CommandGivenVocalSFX
public bool DrownInDeepWater
public bool IdleWhenOwnerOfflineOrDead
public bool IdleWhenOwnerMounted
public float DrownTimer
public float ControlDistance
public int Count
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void AddStates()
public void InitializeAI()
public void OnDestroy()
public void Think(float delta)
private bool EvaluateLoadDefaultDesignTriggers()
public void OnAIDesignLoadedAtIndex(int index)
}
public PetCommandList : PrefabAttribute {
public List`1<PetCommandDesc> Commands
protected Type GetIndexedType()
public List`1<PetCommandDesc> GetCommandDescriptions()
}
public PetCommandType : Enum {
public int value__
public PetCommandType LoadDesign
public PetCommandType SetState
public PetCommandType Destroy
}
public PFXRepeatingFirework : RepeatingFirework {
public ParticleSystemContainer pfx
}
public PhoneController : EntityComponent`1<BaseEntity> {
public int PhoneNumber
public string PhoneName
public bool CanModifyPhoneName
public bool CanSaveNumbers
public bool RequirePower
public bool RequireParent
public float CallWaitingTime
public bool AppendGridToName
public bool IsMobile
public bool CanSaveVoicemail
public GameObjectRef PhoneDialog
public VoiceProcessor VProcessor
public PreloadedCassetteContent PreloadedContent
public SoundDefinition DialToneSfx
public SoundDefinition RingingSfx
public SoundDefinition ErrorSfx
public SoundDefinition CallIncomingWhileBusySfx
public SoundDefinition PickupHandsetSfx
public SoundDefinition PutDownHandsetSfx
public SoundDefinition FailedWrongNumber
public SoundDefinition FailedNoAnswer
public SoundDefinition FailedNetworkBusy
public SoundDefinition FailedEngaged
public SoundDefinition FailedRemoteHangUp
public SoundDefinition FailedSelfHangUp
public Light RingingLight
public float RingingLightFrequency
public AudioSource answeringMachineSound
public EntityRef currentPlayerRef
private int <lastDialedNumber>k__BackingField
public PhoneDirectory <savedNumbers>k__BackingField
public List`1<VoicemailEntry> savedVoicemail
public CallState <serverState>k__BackingField
public PhoneController activeCallTo
public int MaxVoicemailSlots
public BasePlayer currentPlayer
private bool isServer
public int lastDialedNumber
public PhoneDirectory savedNumbers
public BaseEntity ParentEntity
private Cassette cachedCassette
public CallState serverState
public UInt32 AnsweringMessageId
public int get_MaxVoicemailSlots()
public BasePlayer get_currentPlayer()
public void set_currentPlayer(BasePlayer value)
private bool get_isServer()
public int get_lastDialedNumber()
public void set_lastDialedNumber(int value)
public PhoneDirectory get_savedNumbers()
public void set_savedNumbers(PhoneDirectory value)
public BaseEntity get_ParentEntity()
private Cassette get_cachedCassette()
private bool IsPowered()
public bool IsSavedContactValid(string contactName, int contactNumber)
public void OnFlagsChanged(Flags old, Flags next)
public CallState get_serverState()
public void set_serverState(CallState value)
public UInt32 get_AnsweringMessageId()
public void ServerInit()
public void PostServerLoad()
public void DoServerDestroy()
public void ClearCurrentUser(RPCMessage msg)
public void ClearCurrentUser()
public void SetCurrentUser(RPCMessage msg)
private void UpdateServerPlayer(BasePlayer newPlayer)
public void InitiateCall(RPCMessage msg)
public void CallPhone(int number)
private bool CanReceiveCall()
public void AnswerPhone(RPCMessage msg)
public void ReceiveCallFrom(PhoneController t)
private void TimeOutDialing()
public void OnDialFailed(DialFailReason reason)
public void ServerPlayAnsweringMessage(PhoneController fromPhone)
private void TriggerTimeOut()
public void SetPhoneStateWithPlayer(CallState state)
private void SetPhoneState(CallState state)
public void BeginCall()
public void ServerHangUp(RPCMessage msg)
public void ServerHangUp()
private void SelfHangUp()
private void RemoteHangUp()
private void TimeOutCall()
public void OnReceivedVoiceFromUser(Byte[] data)
public void OnReceivedDataFromConnectedPhone(Byte[] data)
public void OnIncomingCallWhileBusy()
public void DestroyShared()
public void UpdatePhoneName(RPCMessage msg)
public void Server_RequestPhoneDirectory(RPCMessage msg)
public void Server_AddSavedNumber(RPCMessage msg)
public void Server_RemoveSavedNumber(RPCMessage msg)
public string GetDirectoryName()
public string PositionToGridCoord(Vector3 position)
public void WatchForDisconnects()
public void OnParentChanged(BaseEntity newParent)
private bool HasVoicemailSlot()
public void ServerSendVoicemail(RPCMessage msg)
public void SaveVoicemail(Byte[] data, string playerName)
public void ServerPlayVoicemail(RPCMessage msg)
public void ServerStopVoicemail(RPCMessage msg)
public void ServerDeleteVoicemail(RPCMessage msg)
public void DeleteAllVoicemail()
}
public PhoneDialler : UIDialog {
public GameObject DialingRoot
public GameObject CallInProcessRoot
public GameObject IncomingCallRoot
public RustText ThisPhoneNumber
public RustInput PhoneNameInput
public RustText textDisplay
public RustText CallTimeText
public RustButton DefaultDialViewButton
public RustText[] IncomingCallNumber
public GameObject NumberDialRoot
public GameObject PromptVoicemailRoot
public RustButton ContactsButton
public RustText FailText
public NeedsCursor CursorController
public NeedsKeyboard KeyboardController
public Phrase WrongNumberPhrase
public Phrase NetworkBusy
public Phrase Engaged
public GameObjectRef DirectoryEntryPrefab
public Transform DirectoryRoot
public GameObject NoDirectoryRoot
public RustButton DirectoryPageUp
public RustButton DirectoryPageDown
public Transform ContactsRoot
public RustInput ContactsNameInput
public RustInput ContactsNumberInput
public GameObject NoContactsRoot
public RustButton AddContactButton
public SoundDefinition DialToneSfx
public Button[] NumberButtons
public Phrase AnsweringMachine
public VoicemailDialog Voicemail
public GameObject VoicemailRoot
}
public PhoneDirectoryEntry : MonoBehaviour {
public RustText PhoneNumber
public RustText PhoneName
public GameObject DeleteIcon
public GameObject CensorIcon
}
public PhotoEntity : ImageStorageEntity {
private ulong <PhotographerSteamId>k__BackingField
private UInt32 <ImageCrc>k__BackingField
public ulong PhotographerSteamId
public UInt32 ImageCrc
protected UInt32 CrcToLoad
public bool ShouldTransferAssociatedFiles
public UInt32[] GetContentCRCs
public UGCType ContentType
public List`1<ulong> EditingHistory
public BaseNetworkable UgcEntity
public ulong get_PhotographerSteamId()
private void set_PhotographerSteamId(ulong value)
public UInt32 get_ImageCrc()
private void set_ImageCrc(UInt32 value)
protected UInt32 get_CrcToLoad()
public void Load(LoadInfo info)
public bool get_ShouldTransferAssociatedFiles()
public void Save(SaveInfo info)
public void SetImageData(ulong steamId, Byte[] data)
internal void DoServerDestroy()
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public UGCType get_ContentType()
public List`1<ulong> get_EditingHistory()
public BaseNetworkable get_UgcEntity()
}
public PhotoFilter : PostProcessEffectSettings {
public ColorParameter color
public FloatParameter density
}
public PhotoFilterRenderer : PostProcessEffectRenderer`1<PhotoFilter> {
private int rgbProperty
private int densityProperty
private Shader greyScaleShader
public void Init()
public void Render(PostProcessRenderContext context)
}
public PhotoFrame : StorageContainer {
private float TextureRequestDistance
private EntityRef _photoEntity
public UInt32 _overlayTextureCrc
private List`1<ulong> editHistory
public GameObjectRef SignEditorDialog
public OverlayMeshPaintableSource PaintableSource
public NetworkableId NetworkID
public Type FileType
public UGCType ContentType
public List`1<ulong> EditingHistory
public UInt32[] GetContentCRCs
public bool ShouldTransferAssociatedFiles
public BaseNetworkable UgcEntity
public Vector2i TextureSize
public int TextureCount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public UInt32[] GetTextureCRCs()
public NetworkableId get_NetworkID()
public Type get_FileType()
public UGCType get_ContentType()
public void Save(SaveInfo info)
public void OnItemAddedOrRemoved(Item item, bool added)
public void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public void SetTextureCRCs(UInt32[] crcs)
public List`1<ulong> get_EditingHistory()
private void LogEdit(BasePlayer byPlayer)
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public bool get_ShouldTransferAssociatedFiles()
public BaseNetworkable get_UgcEntity()
public bool CanPickup(BasePlayer player)
public Vector2i get_TextureSize()
public int get_TextureCount()
public bool CanUpdateSign(BasePlayer player)
public bool CanUnlockSign(BasePlayer player)
public bool CanLockSign(BasePlayer player)
public void UpdateSign(RPCMessage msg)
public void LockSign(RPCMessage msg)
public void UnLockSign(RPCMessage msg)
public void OnKilled(HitInfo info)
public bool ShouldNetworkOwnerInfo()
public string Categorize()
}
public PhotoPanel : MonoBehaviour {
public RawImage Image
public InputField Message
}
public PhysicsEffects : MonoBehaviour {
public BaseEntity entity
public SoundDefinition physImpactSoundDef
public float minTimeBetweenEffects
public float minDistBetweenEffects
public float hardnessScale
public float lowMedThreshold
public float medHardThreshold
public float enableDelay
public LayerMask ignoreLayers
public bool useCollisionPositionInsteadOfTransform
public float minimumRigidbodyImpactWeight
private float lastEffectPlayed
private float enabledAt
private float ignoreImpactThreshold
private Vector3 lastCollisionPos
public void OnEnable()
public void OnCollisionEnter(Collision collision)
}
public PickAFriend : UIDialog {
public InputField input
public RustText headerText
public bool AutoSelectInputField
public bool AllowMultiple
public Action`2<ulong, string> onSelected
public Phrase sleepingBagHeaderPhrase
public Phrase turretHeaderPhrase
public SteamFriendsList friendsList
public Func`2<ulong, bool> shouldShowPlayer
public void set_shouldShowPlayer(Func`2<ulong, bool> value)
}
public PIDController : object {
public float p
public float i
public float d
private float oldError
private float integralSum
public float Update(float dt, float current, float target)
}
public PieMenu : UIBehaviour {
public PieMenu Instance
public Image middleBox
public PieShape pieBackgroundBlur
public PieShape pieBackground
public PieShape pieSelection
public GameObject pieOptionPrefab
public GameObject optionsCanvas
public MenuOption[] options
public GameObject scaleTarget
public GameObject arrowLeft
public GameObject arrowRight
public float sliceGaps
public float outerSize
public float innerSize
public float iconSize
public float startRadius
public float radiusSize
public Image middleImage
public TextMeshProUGUI middleTitle
public TextMeshProUGUI middleDesc
public TextMeshProUGUI middleRequired
public Color colorIconActive
public Color colorIconHovered
public Color colorIconDisabled
public Color colorBackgroundDisabled
public SoundDefinition clipOpen
public SoundDefinition clipCancel
public SoundDefinition clipChanged
public SoundDefinition clipSelected
public MenuOption defaultOption
private bool <IsOpen>k__BackingField
public Material IconMaterial
public bool IsOpen
public bool get_IsOpen()
private void set_IsOpen(bool value)
}
public PieOption : MonoBehaviour {
public PieShape background
public Image imageIcon
public Image overlayIcon
public PingWidget tutorialHighlight
}
public PieShape : Graphic {
public float outerSize
public float innerSize
public float startRadius
public float endRadius
public float border
public bool debugDrawing
protected void OnPopulateMesh(VertexHelper vbo)
}
public Pinata : BaseCombatEntity {
public Transform DropPoint
public float DropPointRadius
public float TotalSwingTime
public float SwingForce
public Transform SwingTransform
public AnimationCurve SwingCurve
public VisualThreshold[] Thresholds
public LineRenderer Line
public Transform DestroyEffectSpawnPos
public float HangLength
public GameObjectRef FinalDestroyEffect
public void OnKilled(HitInfo info)
}
public PinataPayouts : PrefabAttribute {
public Payout[] AllPayouts
private int totalChance
public Payout GetPayout()
protected Type GetIndexedType()
}
public PingManager : ListComponent`1<PingManager> {
public GameObjectRef PingWidgetRef
public RectTransform PingParent
public RectTransform TeamPingParent
public CanvasGroup AlphaCanvas
}
public PingPongRotate : MonoBehaviour {
public Vector3 rotationSpeed
public Vector3 offset
public Vector3 rotationAmount
private void Update()
public Quaternion GetRotation(int index)
}
public PingWidget : MonoBehaviour {
public RectTransform MoveTransform
public RectTransform ScaleTransform
public Image InnerImage
public Image OuterImage
public GameObject TeamLeaderRoot
public GameObject CancelHoverRoot
public SoundDefinition PingDeploySoundHostile
public SoundDefinition PingDeploySoundGoTo
public SoundDefinition PingDeploySoundDollar
public SoundDefinition PingDeploySoundLoot
public SoundDefinition PingDeploySoundNode
public SoundDefinition PingDeploySoundGun
public CanvasGroup FadeCanvas
}
public PipeMesh : MonoBehaviour {
public float PipeRadius
public Material PipeMaterial
public float StraightLength
public int PipeSubdivisions
public int BendTesselation
public float RidgeHeight
public float UvScaleMultiplier
public float RidgeIncrements
public float RidgeLength
public Vector2 HorizontalUvRange
}
public PipeMeshTester : MonoBehaviour {
public List`1<Vector3> positions
public Vector3 startDir
public Vector3 endDir
public Transform startGuide
public Transform endGuide
}
public PlaceCliffs : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public int RetryMultiplier
public int CutoffSlope
public float MinScale
public float MaxScale
private int target_count
private int target_length
private float min_scale_delta
private int max_scale_attempts
private int min_rotation
private int max_rotation
private int rotation_delta
private float offset_c
private float offset_l
private float offset_r
private Vector3[] offsets
public void Process(UInt32 seed)
private CliffPlacement PlaceMale(Prefab[] prefabs, UInt32& seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
private CliffPlacement PlaceFemale(Prefab[] prefabs, UInt32& seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
private CliffPlacement Place(Prefab[] prefabs, UInt32& seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale, int parentAngle, int parentCount, int parentScore)
}
public PlaceDecorUniform : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public float ObjectDistance
public float ObjectDithering
public void Process(UInt32 seed)
}
public PlaceDecorValueNoise : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public NoiseParameters Cluster
public float ObjectDensity
public void Process(UInt32 seed)
}
public PlaceDecorWhiteNoise : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public float ObjectDensity
public void Process(UInt32 seed)
}
public PlacementTest : MonoBehaviour {
public MeshCollider myMeshCollider
public Transform testTransform
public Transform visualTest
public float hemisphere
public float clampTest
public float testDist
private float nextTest
public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset)
public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight, float maxHeight)
public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
private void Update()
public void OnDrawGizmos()
}
public PlaceMonument : ProceduralComponent {
public SpawnFilter Filter
public GameObjectRef Monument
private int Attempts
public void Process(UInt32 seed)
}
public PlaceMonuments : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public int TargetCount
public int MinDistanceSameType
public int MinDistanceDifferentType
public int MinWorldSize
public DistanceMode DistanceSameType
public DistanceMode DistanceDifferentType
public bool NexusOnly
public int GroupCandidates
public int IndividualCandidates
public int Attempts
private int MaxDepth
public void Process(UInt32 seed)
public DistanceInfo GetDistanceInfo(List`1<SpawnInfo> spawns, Prefab`1<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale, Vector3 dungeonPos)
}
public PlaceMonumentsOffshore : ProceduralComponent {
public string ResourceFolder
public int TargetCount
public int MinDistanceFromTerrain
public int MaxDistanceFromTerrain
public int DistanceBetweenMonuments
public int MinWorldSize
private int Candidates
private int Attempts
public void Process(UInt32 seed)
public bool CheckRadius(List`1<SpawnInfo> spawns, Vector3 pos, float radius)
}
public PlaceMonumentsRailside : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public int TargetCount
public int PositionOffset
public int TangentInterval
public int MinDistanceSameType
public int MinDistanceDifferentType
public int MinWorldSize
public DistanceMode DistanceSameType
public DistanceMode DistanceDifferentType
private int GroupCandidates
private int IndividualCandidates
private Quaternion rot90
public void Process(UInt32 seed)
private DistanceInfo GetDistanceInfo(List`1<SpawnInfo> spawns, Prefab`1<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale)
private float GetDistanceToAboveGroundRail(Vector3 pos)
}
public PlaceMonumentsRoadside : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public int TargetCount
public int MinDistanceSameType
public int MinDistanceDifferentType
public int MinWorldSize
public DistanceMode DistanceSameType
public DistanceMode DistanceDifferentType
public RoadMode RoadType
public int GroupCandidates
public int IndividualCandidates
public Quaternion rot90
public void Process(UInt32 seed)
private DistanceInfo GetDistanceInfo(List`1<SpawnInfo> spawns, Prefab`1<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale)
}
public PlacePowerlineObjects : ProceduralComponent {
public BasicObject[] Start
public BasicObject[] End
public SideObject[] Side
public PathObject[] Path
public void Process(UInt32 seed)
}
public PlaceRiverObjects : ProceduralComponent {
public BasicObject[] Start
public BasicObject[] End
public SideObject[] Side
public PathObject[] Path
public void Process(UInt32 seed)
}
public PlaceRoadObjects : ProceduralComponent {
public BasicObject[] Start
public BasicObject[] End
public SideObject[] Side
public PathObject[] Path
public void Process(UInt32 seed)
}
public PlanarReflectionCamera : MonoBehaviour {
public PlanarReflectionCamera instance
public float updateRate
public float nearClipPlane
public float farClipPlane
public Color fogColor
public float fogDensity
public Mesh waterPlaneMesh
public Material waterPlaneMaterial
}
public Planner : HeldEntity {
public BaseEntity[] buildableList
private Vector3 <serverStartDurationPlacementPosition>k__BackingField
private TimeSince <serverStartDurationPlacementTime>k__BackingField
public bool isTypeDeployable
public Vector3 serverStartDurationPlacementPosition
public TimeSince serverStartDurationPlacementTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ItemModDeployable GetModDeployable()
public Deployable GetDeployable()
public bool get_isTypeDeployable()
private void DoPlace(RPCMessage msg)
public Vector3 get_serverStartDurationPlacementPosition()
private void set_serverStartDurationPlacementPosition(Vector3 value)
public TimeSince get_serverStartDurationPlacementTime()
private void set_serverStartDurationPlacementTime(TimeSince value)
private void StartDurationPlace(RPCMessage msg)
public Socket_Base FindSocket(string name, UInt32 prefabIDToFind)
public void DoBuild(CreateBuilding msg)
public BaseEntity DoBuild(Target target, Construction component)
public GameObject DoPlacement(Target placement, Construction component)
public void PayForPlacement(BasePlayer player, Construction component)
public bool CanAffordToPlace(Construction component)
private void GetConstructionCost(ItemAmountList list, Construction component)
private bool ShouldParent(BaseEntity targetEntity, Deployable deployable)
private bool HandleCanBuild(Nullable`1<CanBuildResult> result, BasePlayer player)
}
public PlanterBox : StorageContainer {
public int soilSaturation
public int soilSaturationMax
public MeshRenderer soilRenderer
private float MinimumSaturationTriggerLevel
private float MaximumSaturationTriggerLevel
public TimeCachedValue`1<float> sunExposure
public TimeCachedValue`1<float> artificialLightExposure
public TimeCachedValue`1<float> plantTemperature
public TimeCachedValue`1<float> plantArtificalTemperature
private TimeSince lastSplashNetworkUpdate
private TimeSince lastRainCheck
public float soilSaturationFraction
public int availableIdealWaterCapacity
public int availableWaterCapacity
public int idealSaturation
public bool BelowMinimumSaturationTriggerLevel
public bool AboveMaximumSaturationTriggerLevel
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
public bool InventoryItemFilter(Item item, int targetSlot)
public bool CanPickup(BasePlayer player)
private bool ItemIsFertilizer(Item item)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float get_soilSaturationFraction()
public int get_availableIdealWaterCapacity()
public int get_availableWaterCapacity()
public int get_idealSaturation()
public bool get_BelowMinimumSaturationTriggerLevel()
public bool get_AboveMaximumSaturationTriggerLevel()
public void FertilizeGrowables()
public int GetFertilizerCount()
public bool ConsumeFertilizer()
public int ConsumeWater(int amount, GrowableEntity ignoreEntity)
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
private void RefreshGrowables(GrowableEntity ignoreEntity)
public void ForceLightUpdate()
public void ForceTemperatureUpdate()
public float GetSunExposure()
public float CalculateSunExposure()
public float GetArtificialLightExposure()
public float CalculateArtificialLightExposure()
public float GetPlantTemperature()
public float CalculatePlantTemperature()
private bool HasPlants()
public void CalculateRainFactor()
public float CalculateArtificialTemperature()
public void OnPlantInserted(GrowableEntity entity, BasePlayer byPlayer)
private void RPC_RequestSaturationUpdate(RPCMessage msg)
public bool SupportsChildDeployables()
}
public PlantProperties : ScriptableObject {
public Phrase Description
public GrowableGeneProperties Genes
public Stage[] stages
public AnimationCurve timeOfDayHappiness
public AnimationCurve temperatureHappiness
public AnimationCurve temperatureWaterRequirementMultiplier
public AnimationCurve fruitVisualScaleCurve
public int MaxSeasons
public float WaterIntake
public float OptimalLightQuality
public float OptimalWaterQuality
public float OptimalGroundQuality
public float OptimalTemperatureQuality
public Option pickOption
public Option pickAllOption
public Option eatOption
public ItemDefinition pickupItem
public Option cloneOption
public Option cloneAllOption
public Option removeDyingOption
public Option removeDyingAllOption
public ItemDefinition removeDyingItem
public GameObjectRef removeDyingEffect
public int pickupMultiplier
public GameObjectRef pickEffect
public int maxHarvests
public bool disappearAfterHarvest
public GameObjectRef CrossBreedEffect
public ItemDefinition SeedItem
public ItemDefinition CloneItem
public int BaseCloneCount
public int BaseMarketValue
}
public PlatformEntity : BaseEntity {
private float movementSpeed
private float rotationSpeed
private float radius
private Vector3 targetPosition
private Quaternion targetRotation
protected void FixedUpdate()
public float GetNetworkTime()
}
public PlayAudioEx : MonoBehaviour {
public float delay
private void Start()
private void OnEnable()
}
public PlayerBelt : object {
public int ClientAutoSelectSlot
public UInt32 ClientAutoSeletItemUID
public EncryptedValue`1<int> SelectedSlot
protected BasePlayer player
public int MaxBeltSlots
public int get_MaxBeltSlots()
public void .ctor(BasePlayer player)
public void DropActive(Vector3 position, Vector3 velocity)
public Item GetItemInSlot(int slot)
public Handcuffs GetRestraintItem()
}
public PlayerBlueprints : EntityComponent`1<BasePlayer> {
public SteamInventory steamInventory
public void Reset()
public void UnlockAll()
public bool IsUnlocked(ItemDefinition itemDef)
public void Unlock(ItemDefinition itemDef)
public bool HasUnlocked(ItemDefinition targetItem)
public bool CanCraft(int itemid, int skinItemId, ulong playerId)
public bool CheckSkinOwnership(int skinItemId, ulong playerId)
}
public PlayerBonePosData : ScriptableObject {
public SkeletonDefinition skeletonDef
public GameObjectRef playerModel
public String[] boneNames
public BonePosData crawling
public BonePosData ducking
public BonePosData incapacitated
public BonePosData onladder
public BonePosData sleeping
public BonePosData standing
public BonePosData swimming
public BonePosData[] mountedPoses
}
public PlayerCorpse : LootableCorpse {
public Buoyancy buoyancy
public Flags Flag_Buoyant
public UInt32 underwearSkin
public PlayerBonePosData bonePosData
private Ragdoll <CorpseRagdollScript>k__BackingField
private Vector3 prevLocalPos
private float SLEEP_CHECK_FREQUENCY
public Ragdoll CorpseRagdollScript
public bool CorpseIsRagdoll
protected float PositionTickRate
protected bool PositionTickFixedTime
public bool IsBuoyant()
public Ragdoll get_CorpseRagdollScript()
private void set_CorpseRagdollScript(Ragdoll value)
public bool get_CorpseIsRagdoll()
protected float get_PositionTickRate()
protected bool get_PositionTickFixedTime()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void ServerInit()
public void ServerInitCorpse(BaseEntity pr, Vector3 posOnDeah, Quaternion rotOnDeath, PlayerFlags playerFlagsOnDeath, ModelState modelState)
private BonePosData GetBonePositionData(PlayerFlags flagsOnDeath, ModelState modelState)
public void BuoyancyChanged(bool isSubmerged)
public void BecomeActive()
public void BecomeInactive()
protected void PushRagdoll(HitInfo info)
private void SleepCheck()
public bool BuoyancySleep(bool inWater)
public bool BuoyancyWake()
private void OnPhysicsNeighbourChanged()
public void Save(SaveInfo info)
public string Categorize()
}
public PlayerDetectedAIEvent : BaseAIEvent {
private float <Range>k__BackingField
public float Range
public float get_Range()
public void set_Range(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public PlayerDetectionTrigger : TriggerBase {
public BaseDetector myDetector
public GameObject InterestedInObject(GameObject obj)
public void OnObjects()
public void OnEmpty()
}
public PlayerEyes : EntityComponent`1<BasePlayer> {
public Vector3 EyeOffset
public Vector3 DuckOffset
public Vector3 CrawlOffset
public Vector3 ParachuteOffset
public Vector3 thirdPersonSleepingOffset
public LazyAimProperties defaultLazyAim
private EncryptedValue`1<Vector3> viewOffset
private Quaternion <bodyRotation>k__BackingField
public Vector3 worldMountedPosition
public Vector3 worldStandingPosition
public Vector3 worldCrouchedPosition
public Vector3 worldCrawlingPosition
public Vector3 position
private Vector3 BodyLeanOffset
public Vector3 center
public Vector3 offset
public Quaternion rotation
public Quaternion bodyRotation
public Quaternion parentRotation
public Vector3 get_worldMountedPosition()
public Vector3 get_worldStandingPosition()
public Vector3 get_worldCrouchedPosition()
public Vector3 get_worldCrawlingPosition()
public Vector3 get_position()
private Vector3 get_BodyLeanOffset()
public Vector3 get_center()
public Vector3 get_offset()
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public Quaternion get_bodyRotation()
public void set_bodyRotation(Quaternion value)
public Quaternion get_parentRotation()
public void NetworkUpdate(Quaternion rot)
public Vector3 MovementForward()
public Vector3 MovementRight()
public Ray BodyRay()
public Vector3 BodyForward()
public Vector3 BodyRight()
public Vector3 BodyUp()
public Ray HeadRay()
public Vector3 HeadForward()
public Vector3 HeadRight()
public Vector3 HeadUp()
public Quaternion GetLookRotation()
public Quaternion GetAimRotation()
}
public PlayerHelicopter : BaseHelicopter {
public Wheel[] wheels
public Transform waterSample
public PlayerHeliSounds playerHeliSounds
private Transform joystickPositionLeft
private Transform joystickPositionRight
private Transform passengerJoystickPositionRight
private Transform leftFootPosition
private Transform rightFootPosition
protected Animator animator
public float maxRotorSpeed
public float timeUntilMaxRotorSpeed
private Transform mainRotorBlurBone
private Renderer mainRotorBlurMesh
public float rotorBlurThreshold
private Transform mainRotorBladesBone
private Renderer[] mainRotorBladeMeshes
private Transform rearRotorBladesBone
private Renderer[] rearRotorBladeMeshes
private Transform rearRotorBlurBone
private Renderer rearRotorBlurMesh
public float motorForceConstant
public float brakeForceConstant
public float maxPitchAnim
private GameObject preventBuildingObject
public float maxRollAnim
public float maxYawAnim
public GameObjectRef fuelStoragePrefab
public float fuelPerSec
public float fuelGaugeMax
public float outsidedecayminutes
public float insidedecayminutes
public VehicleEngineController`1<PlayerHelicopter> engineController
public TimeSince timeSinceCachedFuelFraction
public float cachedFuelFraction
protected Flags WHEEL_GROUNDED_LR
protected Flags WHEEL_GROUNDED_RR
protected Flags WHEEL_GROUNDED_FRONT
protected Flags RADAR_WARNING_FLAG
protected Flags RADAR_LOCK_FLAG
protected Flags ENGINE_STARTING_FLAG
private float <cachedPitch>k__BackingField
private float <cachedYaw>k__BackingField
private float <cachedRoll>k__BackingField
public bool isPushing
private Single[] recentVelocities
private int recentVelIndex
public float lastEngineOnTime
public EngineState<PlayerHelicopter> CurEngineState
public bool IsStartingUp
public float cachedPitch
public float cachedYaw
public float cachedRoll
public SamTargetType SAMTargetType
protected bool ForceMovementHandling
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public EngineState<PlayerHelicopter> get_CurEngineState()
public bool get_IsStartingUp()
public void InitShared()
public float GetFuelFraction(bool force)
public bool CanPushNow(BasePlayer pusher)
public float InheritedVelocityScale()
public bool InheritedVelocityDirection()
public float get_cachedPitch()
public void set_cachedPitch(float value)
public float get_cachedYaw()
public void set_cachedYaw(float value)
public float get_cachedRoll()
public void set_cachedRoll(float value)
public void Load(LoadInfo info)
public void OnFlagsChanged(Flags old, Flags next)
public SamTargetType get_SAMTargetType()
protected void OnChildAdded(BaseEntity child)
public float GetServiceCeiling()
public IFuelSystem GetFuelSystem()
public int StartingFuelUnits()
public bool IsValidSAMTarget(bool staticRespawn)
public void PilotInput(InputState inputState, BasePlayer player)
public bool IsGrounded()
public void SetDefaultInputState()
public void ApplyForceAtWheels()
public void ApplyForceWithoutWheels()
public void ApplyWheelForce(WheelCollider wheel, float gasScale, float brakeScale, float turning)
public void MovementUpdate()
public void ServerInit()
public void DecayTick()
public bool IsEngineOn()
protected bool get_ForceMovementHandling()
protected void TryStartEngine(BasePlayer player)
public bool MeetsEngineRequirements()
public void OnEngineStartFailed()
public void VehicleFixedUpdate()
public void UpdateNetwork()
public void OnEntityMessage(BaseEntity from, string msg)
public void ClearRadarLock()
public void ClearRadarWarning()
public void UpdateCOM()
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public void DoPushAction(BasePlayer player)
public void DisablePushing()
public bool IsValidHomingTarget()
public void RPC_OpenFuel(RPCMessage msg)
public bool ShouldDisableTransferProtectionOnLoad(BasePlayer player)
public void DisableTransferProtection()
private void SwapDriverIfInactive()
protected void ApplyHandbrake()
private void SetWheelFrictionMultiplier(WheelCollider wheel, float multiplier)
private void IEngineControllerUser.Invoke(Action action, float time)
private void IEngineControllerUser.CancelInvoke(Action action)
private BasePlayer <SwapDriverIfInactive>g__FindActivePassenger|105_0()
internal bool <SwapDriverIfInactive>g__IsPlayerActive|105_1(BasePlayer player)
}
public PlayerHeliSounds : MonoBehaviour {
public PlayerHelicopter miniCopter
public GameObject soundAttachPoint
public List`1<FlightSoundLayer> flightSoundLayers
public SoundDefinition engineStartDef
public SoundDefinition engineLoopDef
public SoundDefinition engineStopDef
public SoundDefinition rotorLoopDef
public SoundDefinition radarWarningDef
public SoundDefinition radarLockDef
public SoundDefinition noAmmoDef
public SoundDefinition noFlaresDef
public SoundDefinition flaresReadyDef
public SoundDefinition flightControlMovementSoundDef
public GameObject flightControlSoundPosition
public float engineStartFadeOutTime
public float engineLoopFadeInTime
public float engineLoopFadeOutTime
public float engineStopFadeOutTime
public float rotorLoopFadeInTime
public float rotorLoopFadeOutTime
public float enginePitchInterpRate
public float rotorPitchInterpRate
public float rotorGainInterpRate
public float rotorStartStopPitchRateUp
public float rotorStartStopPitchRateDown
public float rotorStartStopGainRateUp
public float rotorStartStopGainRateDown
public AnimationCurve engineUpDotPitchCurve
public AnimationCurve rotorUpDotPitchCurve
public Animator animator
public SoundDefinition reloadStartSoundDef
public SoundDefinition reloadLoopSoundDef
public SoundDefinition reloadFinishSoundDef
}
public PlayerIdleAnimationRandomiser : StateMachineBehaviour {
public int MaxValue
public int Param_Random
private TimeSince lastRandomisation
}
public PlayerInput : EntityComponent`1<BasePlayer> {
public InputState state
public bool hadInputBuffer
protected void OnDisable()
}
public PlayerInventory : EntityComponent`1<BasePlayer> {
public ItemContainer containerMain
public ItemContainer containerBelt
public ItemContainer containerWear
public ItemCrafter crafting
public PlayerLoot loot
public Phrase BackpackGroundedError
private List`1<Item> returnItems
public bool forceBirthday
private float nextCheckTime
private bool wasBirthday
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected void Initialize(BasePlayer owner)
public void DoDestroy()
public void SetLockedByRestraint(bool flag)
public void ServerInit(BasePlayer owner)
private void OnMainInventoryItemAddedOrRemoved(Item item, bool bAdded)
public void OnItemAddedOrRemoved(Item item, bool bAdded)
private void OnBeltItemAddedOrRemoved(Item item, bool added)
public void UpdatedVisibleHolsteredItems()
public void AddBackpackContentsToList(List`1<Item> items)
public void OnContentsDirty()
public bool CanMoveItemsFrom(BaseEntity entity, Item item)
private void ItemCmd(RPCMessage msg)
public void MoveItem(RPCMessage msg)
public void OnClothingChanged(Item item, bool bAdded)
public void OnItemRemoved(Item item)
public bool CanStoreInInventory(Item item, int targetSlot)
public bool CanEquipItem(Item item, int targetSlot)
public bool CanWearItem(Item item, int targetSlot)
public bool CanWearItem(Item item, bool canAdjustClothing, int targetSlot)
public bool CanReplaceBackpack(Item itemToWear)
public void ServerUpdate(float delta)
public void UpdateContainer(float delta, Type type, ItemContainer container, bool bSendInventoryToEveryone, float temperature)
public void SendSnapshot()
public void SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone)
public void SendUpdatedInventoryInternal(Type type, ItemContainer container, NetworkInventoryMode mode)
private WearCheckResult WearItemCheck(Item item, bool canAdjustClothing, int targetSlot, bool dontMove)
public Item FindItemByUID(ItemId id)
public Item FindItemByItemID(string itemName)
public Item FindItemByItemID(int id)
public Item FindItemByItemName(string name)
public Item FindBySubEntityID(NetworkableId subEntityID)
public List`1<Item> FindItemsByItemID(int id)
public ItemContainer FindContainer(ItemContainerId id)
public ItemContainer GetContainer(Type id)
public Item GetAnyBackpack()
public bool HasBackpackItem()
public Item GetBackpackWithInventory()
public void DropBackpackOnDeath()
public Item GetEquippedPrisonerHoodItem()
public Item GetUsableHoodItem()
public bool GiveItem(Item item, ItemContainer container)
public bool GiveItem(Item item, ItemMoveModifier modifiers, ItemContainer container)
public ItemContainer GetIdealPickupContainer(Item item, bool tryWearClothing)
public void Strip()
public bool IsBirthday()
public bool IsChristmas()
public void GiveDefaultItems()
public bool CanEquipParachute()
public PlayerInventory Save(bool bForDisk)
public void Load(PlayerInventory msg)
public void TryDropBackpack()
public int Take(List`1<Item> collect, int itemid, int amount)
public bool HasEmptySlotInBeltOrMain()
public bool HasEmptySlots(int requiredSlots)
public int GetAmount(ItemDefinition definition)
public int GetAmount(int itemid)
public int GetOkConditionAmount(int itemid)
public Item[] AllItems()
public int AllItemsNoAlloc(List`1& items)
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public bool HasAmmo(AmmoTypes ammoType)
private void <GiveDefaultItems>g__GiveDefaultItemWithSkin|61_0(string convarSkinName, string itemShortName)
}
public PlayerInventoryProperties : BaseScriptableObject {
public string niceName
public int order
public List`1<ItemAmountSkinned> belt
public List`1<ItemAmountSkinned> main
public List`1<ItemAmountSkinned> wear
public PlayerInventoryProperties giveBase
private PlayerInventoryProperties[] allInventories
public void GiveToPlayer(BasePlayer player)
public PlayerInventoryProperties GetInventoryConfig(string name)
internal void <GiveToPlayer>g__CreateItem|7_0(ItemAmountSkinned toCreate, ItemContainer destination, <>c__DisplayClass7_0& )
}
public PlayerLoot : EntityComponent`1<BasePlayer> {
public BaseEntity entitySource
public Item itemSource
public List`1<ItemContainer> containers
public bool PositionChecks
private bool isInvokingSendUpdate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsLooting()
public void Clear()
public ItemContainer FindContainer(ItemContainerId id)
public Item FindItem(ItemId id)
public void Check()
public void MarkDirty()
public void SendImmediate()
private void SendUpdate()
public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks)
public void AddContainer(ItemContainer container)
public void RemoveContainer(ItemContainer container)
public bool RemoveContainerAt(int index)
public void StartLootingItem(Item item)
}
public PlayerMetabolism : BaseMetabolism`1<BasePlayer> {
public float HotThreshold
public float ColdThreshold
public float OxygenHurtThreshold
public float OxygenDepleteTime
public float OxygenRefillTime
public MetabolismAttribute temperature
public MetabolismAttribute poison
public MetabolismAttribute radiation_level
public MetabolismAttribute radiation_poison
public MetabolismAttribute wetness
public MetabolismAttribute dirtyness
public MetabolismAttribute oxygen
public MetabolismAttribute bleeding
public MetabolismAttribute comfort
public MetabolismAttribute pending_health
public bool isDirty
private float lastConsumeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Reset()
public void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
internal bool HasChanged()
protected void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
public bool SignificantBleeding()
public void ForceUpdateWorkbenchFlags()
private void UpdateWorkbenchFlags()
protected void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
private float DeltaHot()
private float DeltaCold()
private float DeltaWet()
public void UseHeart(float frate)
public void SendChangesToClient()
public void ApplyChange(Type type, float amount, float time)
public bool CanConsume()
public void MarkConsumption()
public PlayerMetabolism Save()
public void Load(PlayerMetabolism s)
public void SetAttribute(Type type, float amount)
public MetabolismAttribute FindAttribute(Type type)
}
public PlayerModel : ListComponent`1<PlayerModel> {
protected int speed
protected int acceleration
protected int rotationYaw
protected int forward
protected int right
protected int up
protected int ducked
protected int grounded
protected int crawling
protected int waterlevel
protected int attack
protected int attack_alt
protected int deploy
protected int turnOn
protected int turnOff
protected int reload
protected int throwWeapon
protected int holster
protected int aiming
protected int onLadder
protected int posing
protected int poseType
protected int relaxGunPose
protected int vehicle_aim_yaw
protected int vehicle_aim_speed
protected int usePoseTransition
protected int onPhone
protected int leftFootIK
protected int rightFootIK
protected int vehicleSteering
protected int sitReaction
protected int forwardReaction
protected int rightReaction
protected int ladderType
protected int hasParachute
protected int nonGroundedTime
protected int deployParachuteTrigger
public BoxCollider collision
public GameObject censorshipCube
public GameObject censorshipCubeBreasts
public GameObject jawBone
public GameObject neckBone
public GameObject headBone
public EyeController eyeController
public EyeBlink blinkController
public Transform[] SpineBones
public Transform leftFootBone
public Transform rightFootBone
public Transform leftHandPropBone
public Transform rightHandPropBone
public Vector3 rightHandTarget
public bool isPreview
public Vector3 leftHandTargetPosition
public Quaternion leftHandTargetRotation
public Vector3 rightHandTargetPosition
public Quaternion rightHandTargetRotation
public float steeringTargetDegrees
public Vector3 rightFootTargetPosition
public Quaternion rightFootTargetRotation
public Vector3 leftFootTargetPosition
public Quaternion leftFootTargetRotation
public RuntimeAnimatorController CinematicAnimationController
public Avatar DefaultAvatar
public Avatar CinematicAvatar
public RuntimeAnimatorController DefaultHoldType
public RuntimeAnimatorController SleepGesture
public RuntimeAnimatorController CrawlToIncapacitatedGesture
public RuntimeAnimatorController CrawlToIncapacitatedGestureHandcuff
public RuntimeAnimatorController StandToIncapacitatedGesture
public RuntimeAnimatorController CurrentGesture
public SkinSetCollection MaleSkin
public SkinSetCollection FemaleSkin
public SubsurfaceProfile subsurfaceProfile
public float voiceVolume
public float skinColor
public float skinNumber
public float meshNumber
public float hairNumber
public int skinType
public MovementSounds movementSounds
public bool showSash
public int tempPoseType
public UInt32 underwearSkin
private ulong <overrideSkinSeed>k__BackingField
private Quaternion <AimAngles>k__BackingField
private Quaternion <LookAngles>k__BackingField
public Transform[] Shoulders
public Transform[] AdditionalSpineBones
public ulong overrideSkinSeed
public bool IsFemale
public SkinSetCollection SkinSet
public Quaternion AimAngles
public Quaternion LookAngles
private Vector3 GetFlat(Vector3 dir)
public void RebuildAll()
public ulong get_overrideSkinSeed()
private void set_overrideSkinSeed(ulong value)
public bool get_IsFemale()
public SkinSetCollection get_SkinSet()
public Quaternion get_AimAngles()
public void set_AimAngles(Quaternion value)
public Quaternion get_LookAngles()
public void set_LookAngles(Quaternion value)
}
public PlayerModelCinematicList : PrefabAttribute {
public PlayerModelCinematicAnimation[] Animations
protected Type GetIndexedType()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public PlayerModelHair : MonoBehaviour {
public HairType type
private Dictionary`2<Renderer, RendererMaterials> materials
public Dictionary`2<Renderer, RendererMaterials> Materials
public Dictionary`2<Renderer, RendererMaterials> get_Materials()
private void CacheOriginalMaterials()
private void Setup(HairType type, HairSetCollection hair, int meshIndex, float typeNum, float dyeNum, MaterialPropertyBlock block)
public void Setup(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
public void GetRandomVariation(float hairNum, int typeIndex, int meshIndex, Single& typeNum, Single& dyeNum)
public float GetRandomHairType(float hairNum, int typeIndex)
}
public PlayerModelHairCap : MonoBehaviour {
public HairCapMask hairCapMask
public void SetupHairCap(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
}
public PlayerModelSkin : MonoBehaviour {
public SkinMaterialType MaterialType
public Renderer SkinRenderer
public void Setup(SkinSetCollection skin, float hairNum, float meshNum)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public PlayerModifiers : BaseModifiers`1<BasePlayer> {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerUpdate(BaseCombatEntity ownerEntity)
public PlayerModifiers Save()
public void Load(PlayerModifiers m)
public void SendChangesToClient()
}
public PlayerNameTag : MonoBehaviour {
public CanvasGroup canvasGroup
public Text text
public Gradient color
public float minDistance
public float maxDistance
public Vector3 positionOffset
public Transform parentBone
}
public PlayerStateManager : object {
private MruDictionary`2<ulong, PlayerState> _cache
private UserPersistance _persistence
public int CacheSize
public int CacheCount
public long CacheEvictions
public void .ctor(UserPersistance persistence)
public PlayerState Get(ulong playerId)
public void Save(ulong playerId)
private void SaveState(ulong playerId, PlayerState state)
private void FreeOldState(ulong playerId, PlayerState state)
public void Reset(ulong playerId)
private void OnPlayerStateLoaded(PlayerState state)
public int get_CacheSize()
public void set_CacheSize(int value)
public int get_CacheCount()
public long get_CacheEvictions()
}
public PlayerStatistics : object {
public SteamStatistics steam
public ServerStatistics server
public CombatLog combat
public BasePlayer forPlayer
private TimeSince lastSteamSave
public void .ctor(BasePlayer player)
public void Init()
public void Save(bool forceSteamSave)
public void Add(string name, int val, Stats stats)
}
public PlayerVoiceSpeaker : EntityComponent`1<BasePlayer> {
public VoiceProcessor voiceProcessor
}
public PlayerWalkMovement : BaseMovement {
public float WaterLevelHead
public float WaterLevelNeck
public PhysicMaterial zeroFrictionMaterial
public PhysicMaterial highFrictionMaterial
public float capsuleHeight
public float capsuleCenter
public float capsuleHeightDucked
public float capsuleCenterDucked
public float capsuleHeightCrawling
public float capsuleCenterCrawling
public float gravityTestRadius
public float gravityMultiplier
public float gravityMultiplierSwimming
public float maxAngleWalking
public float maxAngleClimbing
public float maxAngleSliding
public float maxStepHeight
}
public PlayingCardSprite : MonoBehaviour {
private Image image
private Animation anim
}
public PlayingCardsViewmodel : MonoBehaviour {
private Canvas cardUICanvas
private Image cardA
private Image cardB
private Sprite blankCard
}
public PointOfInterestMapMarker : MonoBehaviour {
public Image MapIcon
public Image MapIconOuter
public GameObject LeaderRoot
public GameObject EditPopup
public Tooltip Tooltip
public GameObject MarkerLabelRoot
public RustText MarkerLabel
public RustText NoMarkerLabel
public RustInput MarkerLabelModify
public MapMarkerIconSelector[] IconSelectors
public MapMarkerIconSelector[] ColourSelectors
public bool IsListWidget
public GameObject DeleteButton
}
public Polarbear : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public Poolable : MonoBehaviour {
public UInt32 prefabID
public Behaviour[] behaviours
public Rigidbody[] rigidbodies
public Collider[] colliders
public LODGroup[] lodgroups
public Renderer[] renderers
public ParticleSystem[] particles
public Boolean[] behaviourStates
public Boolean[] rigidbodyStates
public Boolean[] colliderStates
public Boolean[] lodgroupStates
public Boolean[] rendererStates
public int ClientCount
public int ServerCount
public int get_ClientCount()
public int get_ServerCount()
public void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void Initialize(UInt32 id)
public void EnterPool()
public void LeavePool()
public void SetBehaviourEnabled(bool state)
public void SetComponentEnabled(bool state)
}
public PoolableEx : object {
public bool SupportsPoolingInParent(GameObject gameObject)
public bool SupportsPooling(GameObject gameObject)
public void AwakeFromInstantiate(GameObject gameObject)
}
public PooledList`1 : object {
public List`1<T> data
public void Alloc()
public void Free()
public void Clear()
}
public PositionLerp : object {
private ListHashSet`1<PositionLerp> InstanceList
public bool DebugLog
public bool DebugDraw
public int TimeOffsetInterval
public float TimeOffset
public int TimeOffsetIntervalMin
public int TimeOffsetIntervalMax
private bool enabled
private Action idleDisable
private Interpolator`1<TransformSnapshot> interpolator
private IPosLerpTarget target
private TransformSnapshot snapshotPrototype
private float timeOffset0
private float timeOffset1
private float timeOffset2
private float timeOffset3
private int timeOffsetCount
private float lastClientTime
private float lastServerTime
private float extrapolatedTime
private float enabledTime
public bool Enabled
public float LerpTime
public bool get_Enabled()
public void set_Enabled(bool value)
public float get_LerpTime()
private void OnEnable()
private void OnDisable()
public void Initialize(IPosLerpTarget target)
public void Snapshot(Vector3 position, Quaternion rotation, float serverTime)
public void Snapshot(Vector3 position, Quaternion rotation)
public void SnapTo(Vector3 position, Quaternion rotation, float serverTime)
public void SnapTo(Vector3 position, Quaternion rotation)
public void SnapToEnd()
public void Wipe()
public void WipeAll()
protected void DoCycle()
public void TransformEntries(Matrix4x4 matrix)
public Quaternion GetEstimatedAngularVelocity()
public Vector3 GetEstimatedVelocity()
public void Dispose()
public void Clear()
public void Cycle()
}
public PostCullingJob : ValueType {
public NativeArray`1<int> CountPerMesh
public int RendererCount
public NativeArray`1<InstancedRendererJobData> Renderers
public JobInt PostCullMeshCount
public JobInt PostCullShadowCount
public void Execute()
}
public PostOpaqueDepth : MonoBehaviour {
public RenderTexture postOpaqueDepth
public RenderTexture PostOpaque
public RenderTexture get_PostOpaque()
}
public PostProcessVolumeLOD : MonoBehaviour {
public float distance
}
public PostUpdateHook : MonoBehaviour {
public Action OnUpdate
public Action OnLateUpdate
public Action OnFixedUpdate
public Action EndOfFrame
private void Update()
private void LateUpdate()
private void FixedUpdate()
private void Start()
private IEnumerator EndOfFrameRoutine()
}
public PowerBar : MonoBehaviour {
public PowerBar Instance
public Image powerInner
public float fullSize
public CanvasGroup group
}
public PowerCounter : IOEntity {
public int counterNumber
public int targetCounterNumber
public Canvas canvas
public CanvasGroup screenAlpha
public Text screenText
public Flags Flag_ShowPassthrough
public GameObjectRef counterConfigPanel
public Color passthroughColor
public Color counterColor
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool DisplayPassthrough()
public bool DisplayCounter()
public bool CanPlayerAdmin(BasePlayer player)
public int GetTarget()
public void ResetState()
public int ConsumptionAmount()
public void SERVER_SetTarget(RPCMessage msg)
public void ToggleDisplayMode(RPCMessage msg)
public int GetPassthroughAmount(int outputSlot)
public bool WantsPower(int inputIndex)
public void Save(SaveInfo info)
public void SetCounterNumber(int newNumber)
public void SendIONetworkUpdate()
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int inputSlot)
public void Load(LoadInfo info)
}
public PoweredLightsDeployer : HeldEntity {
public GameObjectRef poweredLightsPrefab
public EntityRef activeLights
public MaterialReplacement guide
public GameObject guideObject
public float maxPlaceDistance
public float lengthPerAmount
private int placementLayerMask
public AdvancedChristmasLights active
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool CheckValidPlacement(Vector3 position, float radius, int layerMask)
public bool CanPlayerUse(BasePlayer player)
public AdvancedChristmasLights get_active()
public void set_active(AdvancedChristmasLights value)
public void AddPoint(RPCMessage msg)
public void Finish(RPCMessage msg)
public void DoFinish()
public void OnHeldChanged()
public void Save(SaveInfo info)
}
public PoweredRemoteControlEntity : IOEntity {
public string rcIdentifier
public Transform viewEyes
public GameObjectRef IDPanelPrefab
public RemoteControllableControls rcControls
public bool isStatic
public bool appendEntityIDToIdentifier
private int <ViewerCount>k__BackingField
private Nullable`1<CameraViewerId> <ControllingViewerId>k__BackingField
public bool RequiresMouse
public float MaxRange
public RemoteControllableControls RequiredControls
public bool CanPing
protected bool EntityCanPing
public bool CanAcceptInput
public int ViewerCount
public Nullable`1<CameraViewerId> ControllingViewerId
public bool IsBeingControlled
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsStatic()
public bool get_RequiresMouse()
public float get_MaxRange()
public RemoteControllableControls get_RequiredControls()
public bool get_CanPing()
protected bool get_EntityCanPing()
public bool get_CanAcceptInput()
public int get_ViewerCount()
public void set_ViewerCount(int value)
public Nullable`1<CameraViewerId> get_ControllingViewerId()
public void set_ControllingViewerId(Nullable`1<CameraViewerId> value)
public bool get_IsBeingControlled()
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateRCAccess(bool isOnline)
public void Spawn()
public bool InitializeControl(CameraViewerId viewerID)
public void StopControl(CameraViewerId viewerID)
public void UserInput(InputState inputState, CameraViewerId viewerID)
public Transform GetEyes()
public float GetFovScale()
public bool CanControl(ulong playerID)
public BaseEntity GetEnt()
public void RCSetup()
public void RCShutdown()
public void Server_SetID(RPCMessage msg)
public bool CanUseNetworkCache(Connection connection)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void UpdateIdentifier(string newID, bool clientSend)
public string GetIdentifier()
public void InitShared()
public void DestroyShared()
public bool CanChangeID(BasePlayer player)
}
public PoweredWaterPurifier : WaterPurifier {
public float ConvertInterval
public int PowerDrain
public Material PoweredMaterial
public Material UnpoweredMaterial
public MeshRenderer TargetRenderer
public void ResetState()
public bool CanPickup(BasePlayer player)
protected void SpawnStorageEnt(bool load)
public void OnItemAddedOrRemoved(Item item, bool added)
private void ConvertWater()
public int ConsumptionAmount()
public void OnFlagsChanged(Flags old, Flags next)
}
public PowerlineNode : MonoBehaviour {
public GameObjectRef WirePrefab
public float MaxDistance
protected void Awake()
}
public PowerLineWire : MonoBehaviour {
public List`1<Transform> poles
public List`1<PowerLineWireConnectionDef> connections
public List`1<PowerLineWireSpan> spans
public void Copy(PowerLineWire from, PowerLineWireConnectionHelper helper)
public PowerLineWire Create(PowerLineWire wire, List`1<GameObject> objs, GameObjectRef wirePrefab, string name, PowerLineWire copyfrom, float wiresize, float str)
public void Init()
}
public PowerLineWireConnection : object {
public Vector3 inOffset
public Vector3 outOffset
public float radius
public Transform start
public Transform end
}
public PowerLineWireConnectionDef : object {
public Vector3 inOffset
public Vector3 outOffset
public float radius
public bool hidden
public void .ctor(PowerLineWireConnectionDef src)
}
public PowerLineWireConnectionHelper : MonoBehaviour {
public List`1<PowerLineWireConnectionDef> connections
public bool showgizmo
}
public PowerLineWireSpan : MonoBehaviour {
public GameObjectRef wirePrefab
public Transform start
public Transform end
public float WireLength
public List`1<PowerLineWireConnection> connections
public void Init(PowerLineWire wire)
}
public Prefab : object {
public UInt32 ID
public string Name
public string Folder
public GameObject Object
public GameManager Manager
public Library Attribute
public PrefabParameters Parameters
public Library DefaultAttribute
public GameManager DefaultManager
public void .ctor(string name, GameObject prefab, GameManager manager, Library attribute)
public GameObject op_Implicit(Prefab prefab)
public int CompareTo(Prefab that)
public bool ApplyTerrainAnchors(Vector3& pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter)
public bool ApplyTerrainAnchors(Vector3& pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public bool ApplyTerrainChecks(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public bool ApplyTerrainFilters(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public void ApplyTerrainModifiers(Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyTerrainPlacements(Vector3 pos, Quaternion rot, Vector3 scale)
public bool ApplyWaterChecks(Vector3 pos, Quaternion rot, Vector3 scale)
public bool ApplyBoundsChecks(Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer)
public void ApplyDecorComponents(Vector3& pos, Quaternion& rot, Vector3& scale)
public bool CheckEnvironmentVolumes(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
public bool CheckEnvironmentVolumesInsideTerrain(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type, float padding)
public bool CheckEnvironmentVolumesOutsideTerrain(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type, float padding)
public void ApplySequenceReplacement(List`1<Prefab> sequence, Prefab& replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex)
public GameObject Spawn(Transform transform, bool active)
public GameObject Spawn(Vector3 pos, Quaternion rot, bool active)
public GameObject Spawn(Vector3 pos, Quaternion rot, Vector3 scale, bool active)
public BaseEntity SpawnEntity(Vector3 pos, Quaternion rot, bool active)
public Prefab`1<T> Load(UInt32 id, GameManager manager, Library attribute)
public Prefab Load(UInt32 id, GameManager manager, Library attribute)
public Prefab[] Load(string folder, GameManager manager, Library attribute, bool useProbabilities, bool useWorldConfig)
public Prefab`1[] Load(string folder, GameManager manager, Library attribute, bool useProbabilities, bool useWorldConfig)
public Prefab`1[] Load(String[] names, GameManager manager, Library attribute)
public Prefab LoadRandom(string folder, UInt32& seed, GameManager manager, Library attribute, bool useProbabilities)
public Prefab`1<T> LoadRandom(string folder, UInt32& seed, GameManager manager, Library attribute, bool useProbabilities)
public Library get_DefaultAttribute()
public GameManager get_DefaultManager()
private String[] FindPrefabNames(string strPrefab, bool useProbabilities, bool useWorldConfig)
}
public Prefab`1 : Prefab {
public T Component
public void .ctor(string name, GameObject prefab, T component, GameManager manager, Library attribute)
public int CompareTo(Prefab`1<T> that)
}
public PrefabAttribute : MonoBehaviour {
public Vector3 worldPosition
public Quaternion worldRotation
public Vector3 worldForward
public Vector3 localPosition
public Vector3 localScale
public Quaternion localRotation
public string fullName
public string hierachyName
public UInt32 prefabID
public int instanceID
public Library prefabAttribute
public GameManager gameManager
public bool isServer
public Library server
public bool isClient
public bool get_isClient()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
public bool op_Equality(PrefabAttribute x, PrefabAttribute y)
public bool op_Inequality(PrefabAttribute x, PrefabAttribute y)
public bool Equals(object o)
public int GetHashCode()
public bool op_Implicit(PrefabAttribute exists)
internal bool ComparePrefabAttribute(PrefabAttribute x, PrefabAttribute y)
public string ToString()
}
public PrefabInformation : PrefabAttribute {
public ItemDefinition associatedItemDefinition
public Phrase title
public Phrase description
public Sprite sprite
public bool shownOnDeathScreen
protected Type GetIndexedType()
}
public PrefabInstantiate : MonoBehaviour {
public GameObjectRef Prefab
}
public PrefabParameters : MonoBehaviour {
public PrefabPriority Priority
public int Count
}
public PrefabPool : object {
public Stack`1<Poolable> stack
private string <PrefabName>k__BackingField
private int <Missed>k__BackingField
private int <Pushed>k__BackingField
private int <Popped>k__BackingField
private int <TargetCapacity>k__BackingField
public string PrefabName
public int Missed
public int Pushed
public int Popped
public int Count
public int TargetCapacity
public string get_PrefabName()
private void set_PrefabName(string value)
public int get_Missed()
private void set_Missed(int value)
public int get_Pushed()
private void set_Pushed(int value)
public int get_Popped()
private void set_Popped(int value)
public void .ctor(UInt32 prefabId, int targetCapacity)
public int get_Count()
public int get_TargetCapacity()
private void set_TargetCapacity(int value)
public void Push(Poolable info)
public void Push(GameObject instance)
public GameObject Pop(Vector3 pos, Quaternion rot)
public void Clear()
}
public PrefabPoolCollection : object {
public Dictionary`2<UInt32, PrefabPool> storage
private bool isClient
public void .ctor(bool client)
public void Push(GameObject instance)
public GameObject Pop(UInt32 id, Vector3 pos, Quaternion rot)
public void Clear(string filter)
}
public PrefabPoolWarmup : object {
public void Run(string filter, int countOverride)
public IEnumerator Run(float deltaTime, Action`1<string> statusFunction, string format)
public String[] GetAssetList()
private void PrefabWarmup(string path, int countOverride)
}
public PrefabPreProcess : object {
public Type[] clientsideOnlyTypes
public Type[] serversideOnlyTypes
public bool isClientside
public bool isServerside
public bool isBundling
public Dictionary`2<string, GameObject> prefabList
public List`1<Component> destroyList
public List`1<GameObject> cleanupList
public void .ctor(bool clientside, bool serverside, bool bundling)
public GameObject Find(string strPrefab)
public bool NeedsProcessing(GameObject go)
public void ProcessObject(string name, GameObject go, bool resetLocalTransform)
public void Process(string name, GameObject go)
public void Invalidate(string name)
public GameObject GetHierarchyGroup()
public void AddPrefab(string name, GameObject go)
private void DestroyComponents(Type t, GameObject go, bool client, bool server)
private bool ShouldExclude(Transform transform)
private bool HasComponents(Transform transform)
private bool HasComponents(Transform transform, Type t)
public List`1<T> FindComponents(Transform transform)
public void FindComponents(Transform transform, List`1<T> list)
public List`1<Component> FindComponents(Transform transform, Type t)
public void FindComponents(Transform transform, List`1<Component> list, Type t)
public void RemoveComponent(Component c)
public void RemoveComponents(GameObject gameObj)
public void NominateForDeletion(GameObject gameObj)
public void RunCleanupQueue()
public void DoCleanup(GameObject go)
}
public PrefabPriority : Enum {
public int value__
public PrefabPriority Lowest
public PrefabPriority Low
public PrefabPriority Default
public PrefabPriority High
public PrefabPriority Highest
}
public PreloadedCassetteContent : ScriptableObject {
public SoundDefinition[] ShortTapeContent
public SoundDefinition[] MediumTapeContent
public SoundDefinition[] LongTapeContent
public SoundDefinition GetSoundContent(int index, PreloadType type)
private SoundDefinition GetDefinition(int index, SoundDefinition[] array)
public UInt32 GetSoundContentId(SoundDefinition def)
public SoundDefinition GetSoundContent(UInt32 id)
}
public PressButton : IOEntity {
public float pressDuration
public float pressPowerTime
public int pressPowerAmount
public Flags Flag_EmittingPower
public bool smallBurst
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int ConsumptionAmount()
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void UnpowerTime()
public void PostServerLoad()
public void RPC_Press(RPCMessage msg)
public void Press()
public void Unpress()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public PressurePad : BaseDetector {
public float pressPowerTime
public int pressPowerAmount
public Flags Flag_EmittingPower
public int ConsumptionAmount()
public bool IsRootEntity()
public bool ShouldTrigger()
public void OnDetectorTriggered()
public void OnDetectorReleased()
public void UnpowerTime()
public int GetPassthroughAmount(int outputSlot)
}
public PreUpdateHook : MonoBehaviour {
public Action OnUpdate
public Action OnLateUpdate
public Action OnFixedUpdate
public Action PostPhysicsUpdate
public Action StartOfFrame
private int lastStartOfFrame
private void Start()
private void Update()
private void LateUpdate()
private void FixedUpdate()
private void TryRunStartOfFrame()
private IEnumerator AfterPhysicsUpdate()
}
public PreventBuildingMonumentTag : MonoBehaviour {
public MonumentInfo AttachedMonument
}
public ProceduralComponent : MonoBehaviour {
public Realm Mode
public string Description
public bool RunOnCache
public bool get_RunOnCache()
public bool ShouldRun()
public void Process(UInt32 seed)
}
public ProceduralDungeonCell : BaseMonoBehaviour {
public bool north
public bool east
public bool south
public bool west
public bool entrance
public bool hasSpawn
public Transform exitPointHack
public SpawnGroup[] spawnGroups
public RendererLOD[] mapRendererLods
public void Awake()
}
public ProceduralDynamicDungeon : BaseEntity {
public int gridResolution
public float gridSpacing
public Boolean[] grid
public List`1<GameObjectRef> cellPrefabReferences
public List`1<ProceduralDungeonCell> spawnedCells
public EnvironmentVolume envVolume
public MonumentNavMesh monumentNavMesh
public GameObjectRef exitPortalPrefab
private EntityRef`1<BasePortal> exitPortal
public TriggerRadiation exitRadiation
public UInt32 seed
public UInt32 baseseed
public Vector3 mapOffset
public List`1<ProceduralDynamicDungeon> dungeons
public ProceduralDungeonCell entranceHack
public void InitShared()
public void OnFlagsChanged(Flags old, Flags next)
public BaseEntity GetExitPortal(bool serverSide)
public void DestroyShared()
public bool ContainsAnyPlayers()
public void KillPlayers()
internal void DoServerDestroy()
public void ServerInit()
public void DoGeneration()
private void CreateAIZ()
public void PostServerLoad()
public IEnumerator UpdateNavMesh()
public void Save(SaveInfo info)
public BasePortal GetExitPortal()
public void InitSpawnGroups()
public void CleanupSpawnGroups()
public void Load(LoadInfo info)
public void GenerateGrid()
public ProceduralDungeonCell CellInstantiate(string path)
public void RetireCell(GameObject cell)
public void RetireAllCells()
public bool CanSeeEntrance(int x, int y, List`1& checkedCells)
public bool HasPathToEntrance(int x, int y)
public bool CanFindEntrance(int x, int y)
public bool IsEntrance(int x, int y)
public int GetEntranceIndex()
public void SetEntrance(int x, int y)
public void SetGridState(int x, int y, bool state)
public bool GetGridState(int x, int y)
public int GetGridX(int index)
public int GetGridY(int index)
public int GetGridIndex(int x, int y)
}
public ProceduralLift : BaseEntity {
public float movementSpeed
public float resetDelay
public ProceduralLiftCabin cabin
public ProceduralLiftStop[] stops
public GameObjectRef triggerPrefab
public string triggerBone
private int floorIndex
public SoundDefinition startSoundDef
public SoundDefinition stopSoundDef
public SoundDefinition movementLoopSoundDef
private Sound movementLoopSound
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Spawn()
private void RPC_UseLift(RPCMessage rpc)
public void ServerInit()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
private void ResetLift()
private void MoveToFloor(int floor)
private void SnapToFloor(int floor)
private void OnFinishedMoving()
protected void Update()
public void StartMovementSounds()
public void StopMovementSounds()
}
public ProceduralObject : MonoBehaviour {
protected void Awake()
public void Process()
}
public ProcessedTexture : object {
protected RenderTexture result
protected Material material
public void Dispose()
protected RenderTexture CreateRenderTexture(string name, int width, int height, bool linear)
protected void DestroyRenderTexture(RenderTexture& rt)
protected RenderTexture CreateTemporary()
protected void ReleaseTemporary(RenderTexture rt)
protected Material CreateMaterial(string shader)
protected Material CreateMaterial(Shader shader)
protected void DestroyMaterial(Material& mat)
public Texture op_Implicit(ProcessedTexture t)
}
public ProcessMonumentNodes : ProceduralComponent {
public void Process(UInt32 seed)
}
public ProcessProceduralObjects : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public Profile : object {
public Stopwatch watch
public string category
public string name
public float warnTime
public void .ctor(string cat, string nam, float WarnTime)
public void Start()
public void Stop()
}
public ProgressBar : UIBehaviour {
public ProgressBar Instance
private Action`1<BasePlayer> action
public float timeFinished
private float timeCounter
public GameObject scaleTarget
public Image progressField
public Image iconField
public Text leftField
public Text rightField
public SoundDefinition clipOpen
public SoundDefinition clipCancel
private bool isOpen
public bool InstanceIsOpen
public bool get_InstanceIsOpen()
}
public ProgressDoor : IOEntity {
public float storedEnergy
public float energyForOpen
public float secondsToClose
public float openProgress
public void ResetIOState()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public void NoEnergy()
public void AddEnergy(float amount)
public void UpdateProgress()
}
public Projectile : BaseMonoBehaviour {
public float moveDeltaTime
public float lifeTime
public Vector3 initialVelocity
public float drag
public float gravityModifier
public float thickness
public float initialDistance
public bool remainInWorld
public float stickProbability
public float breakProbability
public float conditionLoss
public float ricochetChance
public float penetrationPower
public float waterIntegrityLoss
public DamageProperties damageProperties
public MinMax damageDistances
public MinMax damageMultipliers
public List`1<DamageTypeEntry> damageTypes
public ScaleRenderer rendererToScale
public ScaleRenderer firstPersonRenderer
public bool createDecals
public bool doDefaultHitEffects
public SoundDefinition flybySound
public float flybySoundDistance
public SoundDefinition closeFlybySound
public float closeFlybyDistance
public float tumbleSpeed
public Vector3 tumbleAxis
public Vector3 swimScale
public Vector3 swimSpeed
public BasePlayer owner
public AttackEntity sourceWeaponPrefab
public Projectile sourceProjectilePrefab
public ItemModProjectile mod
public int projectileID
public int seed
public bool clientsideEffect
public bool clientsideAttack
public float integrity
public float maxDistance
public Modifier modifier
public bool invisible
public bool noheadshots
public float currentThickness
private UInt32 _fleshMaterialID
private UInt32 _waterMaterialID
private UInt32 cachedWaterString
public void CalculateDamage(HitInfo info, Modifier mod, float scale)
public UInt32 FleshMaterialID()
public UInt32 WaterMaterialID()
public bool IsWaterMaterial(string hitMaterial)
public bool ShouldStopProjectile(RaycastHit hit)
}
public ProjectileTestSpawner : MonoBehaviour {
public Projectile TargetProjectile
public float RepeatTime
public float VelocityScale
}
public ProjectileWeaponInformationPanel : ItemInformationPanel {
public ItemStatValue damageDisplay
public ItemStatValue recoilDisplay
public ItemStatValue rofDisplay
public ItemStatValue accuracyDisplay
public ItemStatValue rangeDisplay
public ItemStatValue minigunMoveDisplay
public ItemIcon[] attachmentIcons
}
public ProjectileWeaponMod : BaseEntity {
public GameObjectRef defaultSilencerEffect
public bool isSilencer
public Modifier repeatDelay
public Modifier projectileVelocity
public Modifier projectileDamage
public Modifier projectileDistance
public Modifier aimsway
public Modifier aimswaySpeed
public Modifier recoil
public Modifier sightAimCone
public Modifier hipAimCone
public bool isLight
public bool isMuzzleBrake
public bool isMuzzleBoost
public bool isScope
public float zoomAmountDisplayOnly
public Modifier magazineCapacity
public bool needsOnForEffects
public int burstCount
public float timeBetweenBursts
public void ServerInit()
public void PostServerLoad()
public float Mult(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Sum(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Average(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Max(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Min(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public IEnumerable`1<float> GetMods(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value)
public bool HasBrokenWeaponMod(BaseEntity parentEnt)
}
public PropSway : MonoBehaviour {
public Transform pivotRotator
public float swaySpeed
public float swayDistance
public float lerpSpeed
}
public ProtectionProperties : ScriptableObject {
public string comments
public float density
public Single[] amounts
public void OnValidate()
public void Clear()
public void Add(float amount)
public void Add(DamageType index, float amount)
public void Add(ProtectionProperties other, float scale)
public void Add(List`1<Item> items, HitArea area)
public void Multiply(float multiplier)
public void Multiply(DamageType index, float multiplier)
public void Scale(DamageTypeList damageList, float ProtectionAmount)
public float Get(DamageType damageType)
}
public ProtectionValue : MonoBehaviour {
public CanvasGroup group
public TextMeshProUGUI text
public DamageType damageType
public bool selectedItem
public bool displayBaseProtection
}
public PuzzleReset : FacepunchBehaviour {
public SpawnGroup[] respawnGroups
public IOEntity[] resetEnts
public GameObject[] resetObjects
public bool playersBlockReset
public bool CheckSleepingAIZForPlayers
public float playerDetectionRadius
public float playerHeightDetectionMinMax
public Transform playerDetectionOrigin
public float timeBetweenResets
public bool scaleWithServerPopulation
public Vector3[] resetPositions
public bool broadcastResetMessage
public Phrase resetPhrase
private AIInformationZone zone
private float resetTimeElapsed
private float resetTickTime
public float GetResetSpacing()
public void Start()
public void ResetTimer()
public bool PassesResetCheck()
private bool AIZSleeping()
private bool PlayersWithinDistance()
public bool AnyPlayersWithinDistance(Transform origin, float radius)
public void ResetTick()
public void CleanupSleepers()
public void DoReset()
public void ResetIOEntRecursive(IOEntity target, int resetIndex)
}
public PVPMissionManager : MonoBehaviour {
private void Start()
private void Update()
}
public QueryVis : BaseMonoBehaviour {
public Collider checkCollider
private Query query
public RadiusSpace coverageRadiusSpace
public float coverageRadius
}
public QuickCraft : SingletonComponent`1<QuickCraft> {
public GameObjectRef craftButton
public GameObject empty
public Sprite FavouriteOnSprite
public Sprite FavouriteOffSprite
public Color FavouriteOnColor
public Color FavouriteOffColor
}
public QuickCraftButton : MonoBehaviour {
public Image icon
public Image favourite
public Tooltip tooltip
public Text CraftCount
public Image FavouriteIcon
}
public RaceWaypointVisual : MonoBehaviour {
public GameObject RegularCheckpoint
public GameObject FinishCheckpoint
}
public RadialSpawnPoint : BaseSpawnPoint {
public float radius
public void GetLocation(Vector3& pos, Quaternion& rot)
public bool HasPlayersIntersecting()
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
}
public RadiationOverlay : MonoBehaviour {
public SoundDefinition[] geigerSounds
public PostProcessVolume postProcessVolume
}
public RadiationSphere : BaseEntity {
public AnimationCurve RadiationCurve
public float InvokeDelay
public List`1<IOEntity> RadiationLights
private float timeStarted
private TriggerRadiation[] radiationTriggers
private List`1<RadiationSphere> <All>k__BackingField
public List`1<RadiationSphere> All
public List`1<RadiationSphere> get_All()
private void set_All(List`1<RadiationSphere> value)
public void ServerInit()
internal void DoServerDestroy()
public void RestartRadiation()
public void StopRadation()
public void UpdateRadiation()
private void SetLights(bool state)
public void OnEntityMessage(BaseEntity from, string msg)
public void OnPuzzleReset()
}
public RadioDialog : UIDialog {
public RustInput IpInput
public GameObjectRef FavouritePrefab
public Transform FavouritesContainer
public GameObject HasCassetteRoot
public RadioDialog Instance
}
public RadioPlaylist : ScriptableObject {
public string Url
public AudioClip[] Playlist
public float PlaylistLength
}
public RadixSorter : object {
private UInt32[] histogram
private UInt32[] offset
public void SortU8(UInt32[] values, UInt32[] remap, UInt32 num)
public void SortU24(UInt32[] values, UInt32[] remap, UInt32[] remapTemp, UInt32 num)
}
public Ragdoll : EntityComponent`1<BaseEntity> {
public bool simOnServer
public float lerpToServerSimTime
public Transform eyeTransform
public Rigidbody primaryBody
public SpringJoint corpseJoint
private PhysicMaterial physicMaterial
private Skeleton skeleton
private Model model
public List`1<Rigidbody> rigidbodies
private List`1<Transform> rbTransforms
private List`1<Joint> joints
private List`1<CharacterJoint> characterJoints
private List`1<ConfigurableJoint> configurableJoints
private List`1<Collider> colliders
private Int32[] boneIndex
private Vector3[] genericBonePos
private Quaternion[] genericBoneRot
private GameObject GibEffect
protected bool isSetUp
private float MAX_JOINT_DIST
private bool wasSyncingJoints
protected bool IsClient
protected bool isServer
public bool IsSleeping
public bool IsKinematic
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected bool get_IsClient()
protected bool get_isServer()
private void SetUpPhysics(bool isServer)
public void ParentChanging(BaseCorpse corpse, Transform newParent)
private void SetInterpolationMode(Transform parent, bool isServer)
private bool AnyParentMoves(Transform parent)
private void SetCollisionMode(Rigidbody rigidBody, bool isServer)
public void MoveRigidbodiesToRoot()
public void LoadComponent(LoadInfo info)
public void GetCurrentBoneState(GameObject[] bones, Vector3[]& bonePos, Quaternion[]& boneRot)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
private void RemoveRootBoneOffset()
public bool get_IsSleeping()
public bool get_IsKinematic()
public void ServerInit()
public void SaveComponent(SaveInfo info)
public bool IsFullySleeping()
private void SyncJointsToClients()
private bool ShouldSyncJoints()
private void SetRagdollMessageVals(Ragdoll ragdollMsg)
public void BecomeActive()
public void BecomeInactive()
}
public RagdollEditor : SingletonComponent`1<RagdollEditor> {
private Vector3 view
private Rigidbody grabbedRigid
private Vector3 grabPos
private Vector3 grabOffset
private void OnGUI()
protected void Awake()
private void Update()
private void FixedUpdate()
private void StartGrab()
private void UpdateGrab()
private void StopGrab()
}
public RainEffect : WeatherEffect {
public int FadeStartDistance
public int FadeEndDistance
public int FadeFalloff
public bool Stormy
}
public RainSurfaceAmbience : SingletonComponent`1<RainSurfaceAmbience> {
public List`1<SurfaceSound> surfaces
public GameObjectRef emitterPrefab
public Dictionary`2<ParticlePatch, AmbienceEmitter> spawnedEmitters
}
public RandomDestroy : MonoBehaviour {
public UInt32 Seed
public float Probability
protected void Start()
}
public RandomDynamicObject : MonoBehaviour {
public UInt32 Seed
public float Distance
public float Probability
public GameObject[] Candidates
}
public RandomDynamicPrefab : MonoBehaviour {
public UInt32 Seed
public float Distance
public float Probability
public string ResourceFolder
}
public RandomItemDispenser : PrefabAttribute {
public RandomItemChance[] Chances
public bool OnlyAwardOne
protected Type GetIndexedType()
public void DistributeItems(BasePlayer forPlayer, Vector3 distributorPosition)
private bool TryAward(RandomItemChance itemChance, BasePlayer forPlayer, Vector3 distributorPosition)
}
public RandomObjectEnableOnEnable : MonoBehaviour {
public GameObject[] objects
public void OnEnable()
}
public RandomParameterNumber : StateMachineBehaviour {
public string parameterName
public int min
public int max
public bool preventRepetition
public bool isFloat
private int last
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public RandomParameterNumberFloat : StateMachineBehaviour {
public string parameterName
public int min
public int max
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public RandomRendererEnable : MonoBehaviour {
public Renderer[] randoms
private int <EnabledIndex>k__BackingField
public int EnabledIndex
public int get_EnabledIndex()
private void set_EnabledIndex(int value)
public void OnEnable()
}
public RandomStaticObject : MonoBehaviour {
public UInt32 Seed
public float Probability
public GameObject[] Candidates
protected void Start()
}
public RandomStaticPrefab : MonoBehaviour {
public UInt32 Seed
public float Probability
public string ResourceFolder
protected void Start()
}
public RANDSwitch : ElectricalBlocker {
private bool rand
public int GetPassthroughAmount(int outputSlot)
public bool WantsPower(int inputIndex)
public void UpdateBlocked()
public bool RandomRoll()
public void UpdateFromInput(int inputAmount, int inputSlot)
}
public RawWriter : object {
public void Write(IEnumerable`1<byte> data, string path)
public void Write(IEnumerable`1<int> data, string path)
public void Write(IEnumerable`1<short> data, string path)
public void Write(IEnumerable`1<float> data, string path)
}
public RaycastHitEx : object {
public Transform GetTransform(RaycastHit hit)
public Rigidbody GetRigidbody(RaycastHit hit)
public Collider GetCollider(RaycastHit hit)
public BaseEntity GetEntity(RaycastHit hit)
public bool IsOnLayer(RaycastHit hit, Layer rustLayer)
public bool IsOnLayer(RaycastHit hit, int layer)
public bool IsWaterHit(RaycastHit hit)
public WaterBody GetWaterBody(RaycastHit hit)
}
public RCBookmarkEntry : MonoBehaviour {
private string <identifier>k__BackingField
private ComputerMenu owner
public RectTransform connectButton
public RectTransform disconnectButton
public RawImage onlineIndicator
public RawImage offlineIndicator
public GameObject selectedindicator
public Image backgroundImage
public Color selectedColor
public Color activeColor
public Color inactiveColor
public Text nameLabel
private bool <isSelected>k__BackingField
private bool <isControlling>k__BackingField
public EventTrigger eventTrigger
public string identifier
public bool isSelected
public bool isControlling
public string get_identifier()
private void set_identifier(string value)
public bool get_isSelected()
private void set_isSelected(bool value)
public bool get_isControlling()
private void set_isControlling(bool value)
}
public RCMenu : ComputerMenu {
public Image backgroundOpaque
public InputField newBookmarkEntryField
public NeedsCursor needsCursor
public float hiddenOffset
public RectTransform devicesPanel
private Vector3 initialDevicesPosition
public bool isControllingCamera
public CanvasGroup overExposure
public CanvasGroup interference
public float interferenceFadeDuration
public float rangeInterferenceScale
public Text timeText
public Text watchedDurationText
public Text deviceNameText
public Text noSignalText
public Text healthText
public GameObject healthBarParent
public RectTransform healthBarBackground
public RectTransform healthBarFill
public SoundDefinition bookmarkPressedSoundDef
public GameObject[] hideIfStatic
public GameObject readOnlyIndicator
public GameObject aimCrosshair
public GameObject generalCrosshair
public float fogOverrideDensity
public float autoTurretFogDistance
public float autoTurretDotBaseScale
public float autoTurretDotGrowScale
public PingManager PingManager
public ScrollRectSettable scrollRect
}
public ReactiveTarget : IOEntity {
public Animator myAnimator
public GameObjectRef bullseyeEffect
public GameObjectRef knockdownEffect
public float activationPowerTime
public int activationPowerAmount
private float lastToggleTime
public Flags Flag_KnockedDown
public float knockdownHealth
private int inputAmountReset
private int inputAmountLower
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnHitShared(HitInfo info)
public bool IsKnockedDown()
public bool IsLowered()
public void OnAttacked(HitInfo info)
public bool CanToggle()
public bool CanLower()
public bool CanReset()
public void QueueReset()
public void ResetTarget()
private void LowerTarget()
private void SendPowerBurst()
public int ConsumptionAmount()
public bool IsRootEntity()
public void UpdateFromInput(int inputAmount, int inputSlot)
public int GetPassthroughAmount(int outputSlot)
public void RPC_Reset(RPCMessage msg)
public void RPC_Lower(RPCMessage msg)
}
public RealmedCollider : BasePrefab {
public Collider ServerCollider
public Collider ClientCollider
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public RealmedNavMeshObstacle : BasePrefab {
public NavMeshObstacle Obstacle
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public RealmedRemove : MonoBehaviour {
public GameObject[] removedFromClient
public Component[] removedComponentFromClient
public GameObject[] removedFromServer
public Component[] removedComponentFromServer
public Component[] doNotRemoveFromServer
public Component[] doNotRemoveFromClient
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool ShouldDelete(Component comp, bool client, bool server)
}
public RealTimeSinceEx : ValueType {
private double time
public double op_Implicit(RealTimeSinceEx ts)
public RealTimeSinceEx op_Implicit(double ts)
public string ToString()
}
public Recipe : ScriptableObject {
public ItemDefinition ProducedItem
public int ProducedItemCount
public bool CanQueueMultiple
public GameObjectRef SpawnedItem
public string SpawnedItemName
public string SpawnedItemDescription
public Sprite SpawnedItemIcon
public bool RequiresBlueprint
public RecipeIngredient[] Ingredients
public float MixingDuration
public string DisplayName
public string DisplayDescription
public Sprite DisplayIcon
public string get_DisplayName()
public string get_DisplayDescription()
public Sprite get_DisplayIcon()
public bool ContainsItem(Item item)
}
public RecipeDictionary : object {
private Dictionary`2<UInt32, Dictionary`2<int, List`1<Recipe>>> recipeListsDict
public void CacheRecipes(RecipeList recipeList)
public Recipe GetMatchingRecipeAndQuantity(RecipeList recipeList, List`1<Item> orderedIngredients, Int32& quantity)
private List`1<Recipe> GetRecipesByFirstIngredient(RecipeList recipeList, Item firstIngredient)
public bool ValidIngredientForARecipe(Item ingredient, RecipeList recipeList)
}
public RecipeList : BaseScriptableObject {
public Recipe[] Recipes
}
public ReclaimBackpack : StorageContainer {
public int reclaimID
public ulong playerSteamID
public bool onlyOwnerLoot
public Collider myCollider
public GameObject art
private bool isBeingLooted
public void InitForPlayer(ulong playerID, int newID)
public void ServerInit()
public void RemoveMe()
public void CheckEmpty()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void PlayerStoppedLooting(BasePlayer player)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ReclaimManager : BaseEntity {
private int defaultReclaims
private int reclaimSlotCount
private int lastReclaimID
public float reclaim_expire_minutes
private ReclaimManager _instance
private List`1<PlayerReclaimEntry> entries
private float lastTickTime
public ReclaimManager instance
public ReclaimManager get_instance()
public int AddPlayerReclaim(ulong victimID, List`1<Item> itemList, ulong killerID, string killerString, int reclaimIDToUse)
public void DoCleanup()
public void TickEntries()
public bool HasReclaims(ulong playerID)
public PlayerReclaimEntry GetReclaimForPlayer(ulong playerID, int reclaimID)
public bool GetReclaimsForPlayer(ulong playerID, List`1& list)
public PlayerReclaimEntry NewEntry()
public void RemoveEntry(PlayerReclaimEntry entry)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ServerInit()
internal void DoServerDestroy()
}
public ReclaimTerminal : StorageContainer {
public int itemCount
public Phrase DespawnToast
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void RPC_ReloadLoot(RPCMessage msg)
public void LoadReclaimLoot(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public RecoilProperties : ScriptableObject {
public float recoilYawMin
public float recoilYawMax
public float recoilPitchMin
public float recoilPitchMax
public float timeToTakeMin
public float timeToTakeMax
public float ADSScale
public float movementPenalty
public float clampPitch
public AnimationCurve pitchCurve
public AnimationCurve yawCurve
public bool useCurves
public bool curvesAsScalar
public int shotsUntilMax
public float maxRecoilRadius
public bool overrideAimconeWithCurve
public float aimconeCurveScale
public AnimationCurve aimconeCurve
public AnimationCurve aimconeProbabilityCurve
public float ammoAimconeScaleMultiProjectile
public float ammoAimconeScaleSingleProjectile
public RecoilProperties newRecoilOverride
public RecoilProperties GetRecoil()
}
public RecorderTool : ThrownWeapon {
public bool debugRecording
public AudioSource RecorderAudioSource
public SoundDefinition RecordStartSfx
public SoundDefinition RewindSfx
public SoundDefinition RecordFinishedSfx
public SoundDefinition PlayTapeSfx
public SoundDefinition StopTapeSfx
public float ThrowScale
private Cassette <cachedCassette>k__BackingField
public Cassette cachedCassette
public Sprite LoadedCassetteIcon
public BaseEntity ToBaseEntity
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Cassette get_cachedCassette()
public void set_cachedCassette(Cassette value)
public Sprite get_LoadedCassetteIcon()
private bool HasCassette()
public BaseEntity get_ToBaseEntity()
public void Server_TogglePlaying(RPCMessage msg)
public void OnCassetteInserted(Cassette c)
public void OnCassetteRemoved(Cassette c)
protected void SetUpThrownWeapon(BaseEntity ent)
public void OnHeldChanged()
}
public RecordingSaved : SingletonComponent`1<RecordingSaved> {
public RustText Label
}
public RectChangeEvent : UIBehaviour {
public UnityEvent action
protected void OnRectTransformDimensionsChange()
}
public Recycler : StorageContainer {
public Animator Animator
public float recycleEfficiency
public float safezoneRecycleEfficiency
public float radtownRecycleEfficiency
public SoundDefinition grindingLoopDef
public SoundDefinition grindingLoopDef_Slow
public GameObjectRef startSound
public GameObjectRef stopSound
private float scrapRemainder
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
private bool CanBeRecycled(Item item)
public void ServerInit()
public bool RecyclerItemFilter(Item item, int targetSlot)
private void SVSwitch(RPCMessage msg)
public bool MoveItemToOutput(Item newItem)
public bool HasRecyclable()
public void RecycleThink()
public float GetRecycleThinkDuration()
public void StartRecycling()
public void StopRecycling()
public void UpdateInSafeZone()
public bool IsSafezoneRecycler()
public void PlayAnim()
public void StopAnim()
private void ToggleAnim(bool toggle)
}
public ReflectionPlane : DecayEntity {
private int _ColorTexID
private int _DepthTexID
private int _ReflectionLerpID
public LayerMask layerMask
public float nearClip
public float farClip
public Material reflectionMaterial
public Renderer reflectionRenderer
public float maxDistance
public float fadeTime
}
public ReflectionProbeEx : MonoBehaviour {
public ReflectionProbeRefreshMode refreshMode
public bool timeSlicing
public int resolution
public bool hdr
public float shadowDistance
public ReflectionProbeClearFlags clearFlags
public Color background
public float nearClip
public float farClip
public Transform attachToTarget
public Light directionalLight
public float textureMipBias
public bool highPrecision
public bool enableShadows
public ConvolutionQuality convolutionQuality
public List`1<RenderListEntry> staticRenderList
public Cubemap reflectionCubemap
public float reflectionIntensity
private Mesh blitMesh
private Mesh skyboxMesh
private Single[] octaVerts
private CubemapFaceMatrices[] cubemapFaceMatrices
private CubemapFaceMatrices[] cubemapFaceMatricesD3D11
private CubemapFaceMatrices[] shadowCubemapFaceMatrices
private CubemapFaceMatrices[] platformCubemapFaceMatrices
private Int32[] tab32
private void CreateMeshes()
private void DestroyMeshes()
private Mesh CreateBlitMesh()
private CubemapSkyboxVertex SubDivVert(CubemapSkyboxVertex v1, CubemapSkyboxVertex v2)
private void Subdivide(List`1<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
private void SubdivideYOnly(List`1<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
private Mesh CreateSkyboxMesh()
private bool InitializeCubemapFaceMatrices()
private int FastLog2(int value)
private UInt32 ReverseBits(UInt32 bits)
private void SafeCreateMaterial(Material& mat, Shader shader)
private void SafeCreateMaterial(Material& mat, string shaderName)
private void SafeCreateCubeRT(RenderTexture& rt, string name, int size, int depth, bool mips, TextureDimension dim, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite)
private void SafeCreateCB(CommandBuffer& cb, string name)
private void SafeDestroy(T& obj)
private void SafeDispose(T& obj)
}
public RelationshipManager : BaseEntity {
public bool contacts
public Type MugshotFileFormat
private int MugshotResolution
private int MugshotMaxFileSize
private float MugshotMaxDistance
public Dictionary`2<ulong, PlayerRelationships> relationships
private int lastReputationUpdateIndex
private int seenReputationSeconds
private int startingReputation
public int forgetafterminutes
public int maxplayerrelationships
public float seendistance
public float mugshotUpdateInterval
private List`1<BasePlayer> _dirtyRelationshipPlayers
public int maxTeamSize_Internal
private RelationshipManager <ServerInstance>k__BackingField
public Dictionary`2<ulong, BasePlayer> cachedPlayers
public Dictionary`2<ulong, PlayerTeam> playerToTeam
public Dictionary`2<ulong, PlayerTeam> teams
public ulong lastTeamIndex
public int maxTeamSize
public RelationshipManager ServerInstance
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void BagQuotaRequest_SERVER()
public void ServerInit()
public void UpdateReputations()
public void UpdateContactsTick()
public int GetReputationFor(ulong playerID)
public void wipecontacts(Arg arg)
public void wipe_all_contacts(Arg arg)
public float GetAcquaintanceMaxDist()
public void UpdateAcquaintancesFor(BasePlayer player, float deltaSeconds)
public void SetSeen(BasePlayer player, BasePlayer otherPlayer)
public bool CleanupOldContacts(PlayerRelationships ownerRelationships, ulong playerID, RelationshipType relationshipType)
public void ForceRelationshipByID(BasePlayer player, ulong otherPlayerID, RelationshipType newType, int weight, bool sendImmediate)
public void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight, bool sendImmediate)
public PlayerRelationships GetRelationshipSaveByID(ulong playerID)
public void MarkRelationshipsDirtyFor(ulong playerID)
public void ForceSendRelationships(BasePlayer player)
public void MarkRelationshipsDirtyFor(BasePlayer player)
public void SendRelationshipsFor(BasePlayer player)
public void SendRelationships()
public int GetNumberRelationships(ulong player)
public bool HasRelations(ulong player, ulong otherPlayer)
public PlayerRelationships GetRelationships(ulong player)
public void SERVER_SendFreshContacts(RPCMessage msg)
public void SERVER_ChangeRelationship(RPCMessage msg)
public void SERVER_UpdatePlayerNote(RPCMessage msg)
public void SERVER_ReceiveMugshot(RPCMessage msg)
private void DeleteMugshot(ulong steamId, ulong targetSteamId, UInt32 crc)
public UInt32 GetSteamIdHash(ulong requesterSteamId, ulong targetSteamId)
public void set_maxTeamSize(int value)
public int get_maxTeamSize()
public int GetMaxTeamSize()
public RelationshipManager get_ServerInstance()
private void set_ServerInstance(RelationshipManager value)
public void OnEnable()
public void OnDestroy()
public void Save(SaveInfo info)
public void DisbandTeam(PlayerTeam teamToDisband)
public BasePlayer FindByID(ulong userID)
public PlayerTeam FindTeam(ulong TeamID)
public PlayerTeam FindPlayersTeam(ulong userID)
public PlayerTeam CreateTeam()
private PlayerTeam CreateTeam(ulong customId)
public void trycreateteam(Arg arg)
public void promote(Arg arg)
public void promote_id(Arg arg)
public void leaveteam(Arg arg)
public void acceptinvite(Arg arg)
public void rejectinvite(Arg arg)
public BasePlayer GetLookingAtPlayer(BasePlayer source)
public void sleeptoggle(Arg arg)
public void kickmember(Arg arg)
public void sendinvite(Arg arg)
public void fakeinvite(Arg arg)
public void addtoteam(Arg arg)
public string createAndAddToTeam(Arg arg)
public bool TeamsEnabled()
public void Load(LoadInfo info)
}
public ReliableEventSender : StateMachineBehaviour {
public string StateEnter
public string MidStateEvent
public float TargetEventTime
}
public ReloadingAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public RemoteControlEntity : BaseCombatEntity {
public List`1<IRemoteControllable> allControllables
public string rcIdentifier
public Transform viewEyes
public GameObjectRef IDPanelPrefab
public RemoteControllableControls rcControls
private int <ViewerCount>k__BackingField
private Nullable`1<CameraViewerId> <ControllingViewerId>k__BackingField
public bool CanPing
public bool CanAcceptInput
public int ViewerCount
public Nullable`1<CameraViewerId> ControllingViewerId
public bool IsBeingControlled
public bool RequiresMouse
public float MaxRange
public RemoteControllableControls RequiredControls
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_CanPing()
public Transform GetEyes()
public float GetFovScale()
public BaseEntity GetEnt()
public string GetIdentifier()
public bool get_CanAcceptInput()
public int get_ViewerCount()
public void set_ViewerCount(int value)
public Nullable`1<CameraViewerId> get_ControllingViewerId()
public void set_ControllingViewerId(Nullable`1<CameraViewerId> value)
public bool get_IsBeingControlled()
public bool InitializeControl(CameraViewerId viewerID)
public void StopControl(CameraViewerId viewerID)
public void UserInput(InputState inputState, CameraViewerId viewerID)
public void UpdateIdentifier(string newID, bool clientSend)
public void RCSetup()
public void RCShutdown()
public void InitShared()
public void DestroyShared()
public bool CanControl(ulong playerID)
public bool get_RequiresMouse()
public float get_MaxRange()
public RemoteControllableControls get_RequiredControls()
public void Server_SetID(RPCMessage msg)
public bool CanUseNetworkCache(Connection connection)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool CanChangeID(BasePlayer player)
public bool IDInUse(string id)
public IRemoteControllable FindByID(string id)
public bool InstallControllable(IRemoteControllable newControllable)
public bool RemoveControllable(IRemoteControllable newControllable)
}
public RemoteControllableControls : Enum {
public int value__
public RemoteControllableControls None
public RemoteControllableControls Movement
public RemoteControllableControls Mouse
public RemoteControllableControls SprintAndDuck
public RemoteControllableControls Fire
public RemoteControllableControls Reload
public RemoteControllableControls Crosshair
}
public RemoveChildObjectsAlongPath : MonoBehaviour {
public Transform Node1
public Transform Node2
public float Distance
}
public RenameSleepingBag : UIDialog {
public InputField input
public SleepingBag bag
}
public RendererEx : object {
private Memoized`2<Material[], int> ArrayCache
public void SetSharedMaterials(Renderer renderer, List`1<Material> materials)
}
public RendererGrid : SingletonComponent`1<RendererGrid> {
public bool Paused
public GameObjectRef BatchPrefab
public float CellSize
public float MaxMilliseconds
public float MinTimeBetweenRefreshes
}
public RendererInfo : ComponentInfo`1<Renderer> {
public ShadowCastingMode shadows
public Material material
public Mesh mesh
public MeshFilter meshFilter
public void Reset()
public void Setup()
}
public RendererLOD : LODComponent {
public float minDistanceMultiplier
public State[] States
public Mesh GetFinalLodMesh(Matrix4x4& localToWorldMatrix)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public RenderType : Enum {
public int value__
public RenderType OPAQUE_DEFERRED
public RenderType OPAQUE_FORWARDBASE
public RenderType TRANSPARENT_FORWARDBASE
public RenderType TRANSPARENT
public RenderType UNDEFINED
}
public RepairBench : StorageContainer {
public float maxConditionLostOnRepair
public GameObjectRef skinchangeEffect
public float REPAIR_COST_FRACTION
private float nextSkinChangeAudioTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float GetRepairFraction(Item itemToRepair)
public float RepairCostFraction(Item itemToRepair)
public void GetRepairCostList(ItemBlueprint bp, List`1<ItemAmount> allIngredients)
public void StripComponentRepairCost(List`1<ItemAmount> allIngredients, float repairCostMultiplier)
public void debugprint(string toPrint)
public void ChangeSkin(RPCMessage msg)
private void ApplySkinToItem(Item item, ulong Skin)
public void RepairItem(RPCMessage msg)
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)
}
public RepairBenchPanel : LootPanel {
public Text infoText
public GameObject repairButton
public GameObject skinLinkButton
public Color gotColor
public Color notGotColor
public Color skinColour
public Phrase phraseEmpty
public Phrase phraseNotRepairable
public Phrase phraseRepairNotNeeded
public Phrase phraseNoBlueprint
public GameObject skinsPanel
public GameObject changeSkinDialog
public IconSkinPicker picker
public GameObject attachmentSkinBlocker
}
public RepairCostIndicator : SingletonComponent`1<RepairCostIndicator> {
public RepairCostIndicatorRow[] Rows
public CanvasGroup Fader
}
public RepairCostIndicatorRow : MonoBehaviour {
public RustText ItemName
public Image ItemSprite
public RustText Amount
public RectTransform FillRect
public Image BackgroundImage
public Color OkColour
public Color MissingColour
}
public RepeatingFirework : BaseFirework {
public float timeBetweenRepeats
public int maxRepeats
public SoundPlayer launchSound
private int numFired
public void Begin()
public void SendFire()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public ResearchTable : StorageContainer {
public float researchFinishedTime
public float researchCostFraction
public float researchDuration
public int requiredPaper
public GameObjectRef researchStartEffect
public GameObjectRef researchFailEffect
public GameObjectRef researchSuccessEffect
public ItemDefinition researchResource
public BasePlayer user
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public bool IsResearching()
public int RarityMultiplier(Rarity rarity)
public int GetBlueprintStacksize(Item sourceItem)
public int ScrapForResearch(Item item)
public int ScrapForResearch(ItemDefinition info)
public bool IsItemResearchable(Item item)
public void ServerInit()
public bool ItemFilter(Item item, int targetSlot)
public Item GetTargetItem()
public Item GetScrapItem()
public void PostServerLoad()
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public void DoResearch(RPCMessage msg)
public void ResearchAttemptFinished()
public void CancelResearch()
public void EndResearch()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ResearchTablePanel : LootPanel {
public Button researchButton
public Text timerText
public GameObject itemDescNoItem
public GameObject itemDescTooBroken
public GameObject itemDescNotResearchable
public GameObject itemDescTooMany
public GameObject itemTakeBlueprint
public GameObject itemDescAlreadyResearched
public GameObject itemDescDefaultBlueprint
public Text successChanceText
public ItemIcon scrapIcon
public bool wasResearching
public GameObject[] workbenchReqs
}
public ReservedAIPointSlots : Enum {
public int value__
public ReservedAIPointSlots CoverPoint
}
public ReservedEntitySlots : Enum {
public int value__
public ReservedEntitySlots Self
public ReservedEntitySlots OwningPlayer
public ReservedEntitySlots GroupLeader
public ReservedEntitySlots SpecialEntity
}
public ReservedPositionSlots : Enum {
public int value__
public ReservedPositionSlots HomePoint
public ReservedPositionSlots GroupRoamPoint
public ReservedPositionSlots RaycastTargetPoint
public ReservedPositionSlots Vector3
}
public ResetPlacementMap : ProceduralComponent {
public void Process(UInt32 seed)
}
public ReskinEffect : MonoBehaviour {
public ParticleSystem TargetSystem
}
public ResolutionType : Enum {
public int value__
public ResolutionType Low
public ResolutionType Normal
public ResolutionType High
}
public ResourceContainer : EntityComponent`1<BaseEntity> {
public bool lootable
public ItemContainer container
public float lastAccessTime
public int accessedSecondsAgo
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int get_accessedSecondsAgo()
private void StartLootingContainer(RPCMessage msg)
}
public ResourceDepositManager : BaseEntity {
public ResourceDepositManager _manager
private int resolution
public Dictionary`2<Vector2i, ResourceDeposit> _deposits
public Vector2i GetIndexFrom(Vector3 pos)
public ResourceDepositManager Get()
public ResourceDeposit CreateFromPosition(Vector3 pos)
public ResourceDeposit GetFromPosition(Vector3 pos)
public ResourceDeposit GetOrCreate(Vector3 pos)
}
public ResourceDispenser : EntityComponent`1<BaseEntity> {
public GatherType gatherType
public List`1<ItemAmount> containedItems
public float maxDestroyFractionForFinishBonus
public List`1<ItemAmount> finishBonus
public bool forceFullFinishBonus
public float fractionRemaining
private float categoriesRemaining
private float startingItemCounts
private Dictionary`2<GatherType, HashSet`1<int>> cachedResourceItemTypes
public void Start()
public void Initialize()
private void CacheResourceTypeItems()
public void DoGather(HitInfo info, BaseCorpse corpse)
public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
public void OnAttacked(HitInfo info)
private void GiveResources(BasePlayer entity, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
public void DestroyFraction(float fraction)
private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
private int CalculateGatherBonus(BaseEntity entity, ItemAmount item, float amountToGive)
private bool IsProducedItemOfGatherType(ItemAmount item)
public bool OverrideOwnership(Item item, AttackEntity weapon)
private void UpdateVars()
public void UpdateRemainingCategories()
public void CountAllItems()
private void UpdateFraction()
public bool HasItemToDispense(ItemDefinition def)
}
public ResourceEntity : BaseEntity {
public float startHealth
public ProtectionProperties baseProtection
public float health
public ResourceDispenser resourceDispenser
protected bool isKilled
public void Load(LoadInfo info)
public void InitShared()
public void ServerInit()
public void Save(SaveInfo info)
public float MaxHealth()
public float Health()
protected void OnHealthChanged()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public float BoundsPadding()
}
public ResourceRef`1 : object {
public string guid
protected T _cachedObject
public bool isValid
public string resourcePath
public UInt32 resourceID
public bool get_isValid()
public T Get()
public string get_resourcePath()
public UInt32 get_resourceID()
}
public RevealTransitionBase : BaseMonoBehaviour {
public Reveal[] Reveals
}
public ReverbSettings : ScriptableObject {
public int room
public int roomHF
public int roomLF
public float decayTime
public float decayHFRatio
public int reflections
public float reflectionsDelay
public int reverb
public float reverbDelay
public float HFReference
public float LFReference
public float diffusion
public float density
}
public ReverbZoneTrigger : TriggerBase {
public Collider trigger
public AudioReverbZone reverbZone
public float lodDistance
public bool inRange
public ReverbSettings reverbSettings
public void PreClientComponentCull(IPrefabProcessor p)
public bool IsSyncedToParent()
}
public RFBroadcaster : IOEntity {
public int frequency
public GameObjectRef frequencyPanelPrefab
public Flags Flag_Broadcasting
public bool playerUsable
private float nextChangeTime
private float nextStopTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetFrequency()
public bool WantsPower(int inputIndex)
public Vector3 GetPosition()
public float GetMaxRange()
public void RFSignalUpdate(bool on)
public void ServerSetFrequency(RPCMessage msg)
public bool CanUseNetworkCache(Connection connection)
public void Save(SaveInfo info)
public void IOStateChanged(int inputAmount, int inputSlot)
public void StopBroadcasting()
internal void DoServerDestroy()
public void Load(LoadInfo info)
private bool CanChangeFrequency(BasePlayer player)
}
public RFManager : object {
public Dictionary`2<int, List`1<IRFObject>> _listeners
public Dictionary`2<int, List`1<IRFObject>> _broadcasters
public int minFreq
public int maxFreq
private int reserveRangeMin
private int reserveRangeMax
public string reserveString
public int ClampFrequency(int freq)
public List`1<IRFObject> GetListenList(int frequency)
public List`1<IRFObject> GetBroadcasterList(int frequency)
public void AddListener(int frequency, IRFObject obj)
public void RemoveListener(int frequency, IRFObject obj)
public void AddBroadcaster(int frequency, IRFObject obj)
public void RemoveBroadcaster(int frequency, IRFObject obj)
public bool IsReserved(int frequency)
public void ReserveErrorPrint(BasePlayer player)
public void ChangeFrequency(int oldFrequency, int newFrequency, IRFObject obj, bool isListener, bool isOn)
public void MarkFrequencyDirty(int frequency)
}
public RFReceiver : IOEntity {
public int frequency
public GameObjectRef frequencyPanelPrefab
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetFrequency()
public bool WantsPower(int inputIndex)
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public Vector3 GetPosition()
public float GetMaxRange()
public void Init()
internal void DoServerDestroy()
public void RFSignalUpdate(bool on)
public void ServerSetFrequency(RPCMessage msg)
public bool CanUseNetworkCache(Connection connection)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
private bool CanChangeFrequency(BasePlayer player)
}
public RFTimedExplosive : TimedExplosive {
public SoundPlayer beepLoop
private ulong creatorPlayerID
public ItemDefinition pickupDefinition
public float minutesUntilDecayed
private int RFFrequency
private float decayTickDuration
private float minutesDecayed
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 GetPosition()
public float GetMaxRange()
public void RFSignalUpdate(bool on)
public void SetFrequency(int newFreq)
public int GetFrequency()
public void SetFuse(float fuseLength)
public void ArmRF()
public void DisarmRF()
public void Save(SaveInfo info)
public void ServerInit()
public void DecayCheck()
public void PostServerLoad()
internal void DoServerDestroy()
public void ChangeFrequency(int newFreq)
public void SetCreatorEntity(BaseEntity newCreatorEntity)
public void Pickup(RPCMessage msg)
public bool IsArmed()
public void Load(LoadInfo info)
public bool CanPickup(BasePlayer player)
}
public RgbColor : Enum {
public int value__
public RgbColor Default
public RgbColor BuildingPrivilege
public RgbColor Cold
public RgbColor Hot
public RgbColor Hurt
public RgbColor Healed
public RgbColor Irradiated
public RgbColor Comforted
}
public RgbEffects : SingletonComponent`1<RgbEffects> {
public bool Enabled
public Vector3 ColorCorrection_SteelSeries
public Vector3 ColorCorrection_Razer
public float Brightness
public Color defaultColor
public Color buildingPrivilegeColor
public Color coldColor
public Color hotColor
public Color hurtColor
public Color healedColor
public Color irradiatedColor
public Color comfortedColor
public void ConVar_Static(Arg args)
public void ConVar_Pulse(Arg args)
}
public RHIB : MotorRowboat {
public Transform steeringWheelLeftHandTarget
public Transform steeringWheelRightHandTarget
public float rhibpopulation
private float targetGasPedal
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Server_Release(RPCMessage msg)
public void VehicleFixedUpdate()
public bool EngineOn()
public void DriverInput(InputState inputState, BasePlayer player)
public void AddFuel(int amount)
}
public RHIBAIController : FacepunchBehaviour {
public List`1<Vector3> nodes
public void SetupPatrolPath()
public float GetWaterDepth(Vector3 pos)
public void OnDrawGizmosSelected()
}
public RidableHorse : BaseRidableAnimal {
public Phrase SwapToSingleTitle
public Phrase SwapToSingleDescription
public Sprite SwapToSingleIcon
public Phrase SwapToDoubleTitle
public Phrase SwapToDoubleDescription
public Sprite SwapToDoubleIcon
public ItemDefinition WildSaddleItem
public float Population
public string distanceStatName
public HorseBreed[] breeds
public SkinnedMeshRenderer[] bodyRenderers
public SkinnedMeshRenderer[] hairRenderers
public int currentBreed
public ProtectionProperties riderProtection
public ProtectionProperties baseHorseProtection
public Flags Flag_HideHair
public Flags Flag_WoodArmor
public Flags Flag_RoadsignArmor
public Flags Flag_HasSingleSaddle
public Flags Flag_HasDoubleSaddle
public float equipmentSpeedMod
private int prevBreed
private int prevSlots
private float distanceRecordingSpacing
public HitchTrough currentHitch
public float totalDistance
public float kmDistance
public float tempDistanceTravelled
public float RealisticMass
protected float PositionTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetStorageSlotCount()
public float get_RealisticMass()
public void ApplyBreed(int index)
protected void ApplyBreedInternal(HorseBreed breed)
public HorseBreed GetBreed()
public float GetTrotSpeed()
public float GetRunSpeed()
public void OnInventoryFirstCreated(ItemContainer container)
private void SpawnWildSaddle()
public void SetForSale()
public bool IsStandCollisionClear()
public bool IsPlayerSeatSwapValid(BasePlayer player, int fromIndex, int toIndex, bool ignoreRestraint)
public int NumSwappableSeats()
public void AttemptMount(BasePlayer player, bool doMountChecks)
public void SetupCorpse(BaseCorpse corpse)
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public void OnKilled(HitInfo hitInfo)
public void SetBreed(int index)
public void LeadingChanged()
public void ServerInit()
protected float get_PositionTickRate()
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public bool IsHitched()
public void SetHitch(HitchTrough Hitch)
public float ReplenishRatio()
public void EatNearbyFood()
public void TryLeaveHitch()
public void TryHitch()
public void RecordDistance()
public void MarkDistanceTravelled(float amount)
public void Save(SaveInfo info)
public void OnClaimedWithToken(Item tokenItem)
public void OnItemAddedOrRemoved(Item item, bool added)
public void OnInventoryDirty()
public bool CanAnimalAcceptItem(Item item, int targetSlot)
public void EquipmentUpdate()
private void SetSeatCount(int count)
public void DoNetworkUpdate()
public int GetSaddleItemSeatCount(Item item)
public bool HasSaddle()
public bool HasSingleSaddle()
public bool HasDoubleSaddle()
private bool ItemIsSaddle(Item item)
public void Load(LoadInfo info)
public bool HasValidSaddle()
public bool HasSeatAvailable()
public int GetSeatCapacity()
protected bool CanPushNow(BasePlayer pusher)
public void RPC_ReqSwapSaddleType(RPCMessage msg)
public int MaxMounted()
public void setHorseBreed(Arg arg)
}
public RightClickReceiver : MonoBehaviour {
public UnityEvent ClickReceiver
public void OnPointerClick(PointerEventData eventData)
}
public RigidbodyInfo : PrefabAttribute {
public float mass
public float drag
public float angularDrag
protected Type GetIndexedType()
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public RigidbodyLOD : LODComponent {
public float Distance
}
public RiverInfo : MonoBehaviour {
protected void Awake()
}
public RoadBradleys : TriggeredEvent {
private List`1<BradleyAPC> spawnedAPCs
public int StaticBradleyCount
public int GetNumBradleys()
public int GetDesiredNumber()
private void CleanList()
public void RunEvent()
public void Kill()
}
public RoadFlare : TimedExplosive {
public void ServerInit()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public bool IsValidHomingTarget()
internal void DoServerDestroy()
}
public RockingChair : BaseChair {
public float Acceleration
public float MaxRockingAngle
public float MaxRockVelocity
public bool ApplyVelocityBetweenSwings
public float AppliedVelocity
public float WeaponFireImpact
public SoundDefinition creakForwardSoundDef
public SoundDefinition creakBackwardSoundDef
public float creakForwardAngle
public float creakBackwardAngle
public float creakVelocityThreshold
public AnimationCurve creakGainCurve
private float initLocalY
private Vector3 initLocalRot
private float velocity
private float oppositePotentialVelocity
private TimeSince timeSinceInput
private float sineTime
private float timeUntilStartSine
private float t
private float angle
private Quaternion max
private Quaternion min
public void ServerInit()
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
private void SaveBaseLocalPos()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void OnWeaponFired(BaseProjectile weapon)
public void OnPlayerDismounted(BasePlayer player)
private void PreventClipping(bool hasInput)
private void CalculateVelocity(Vector2 currentInput)
private void ApplyVelocity(float delta, bool hasInput)
private void ResetChair()
private Vector2 GetInputVector(InputState inputState)
private Vector2 ProcessInputVector(bool leftDown, bool rightDown, bool forwardDown, bool backDown)
private float EaseOutCubic(float value)
private float EaseOutCubicOvershoot(float value, float overshoot)
}
public RotateCameraAroundObject : MonoBehaviour {
public GameObject m_goObjectToRotateAround
public float m_flRotateSpeed
private void FixedUpdate()
}
public RotateObject : MonoBehaviour {
public float rotateSpeed_X
public float rotateSpeed_Y
public float rotateSpeed_Z
public bool localSpace
protected void Update()
}
public RotateToCamera : MonoBehaviour {
public float maxDistance
}
public rottest : MonoBehaviour {
public Transform turretBase
public Vector3 aimDir
private void Start()
private void Update()
public void UpdateAiming()
}
public RottingFlies : MonoBehaviour {
public GameObjectRef effect
public SoundDefinition soundDef
public Transform rootBone
}
public RpcTarget : ValueType {
public string Function
public SendInfo Connections
public bool ToNetworkGroup
public bool UsingPooledConnections
public RpcTarget NetworkGroup(string funcName)
public RpcTarget NetworkGroup(string funcName, BaseNetworkable entity)
public RpcTarget NetworkGroup(string funcName, BaseNetworkable entity, SendMethod method, Priority priority)
public RpcTarget Player(string funcName, BasePlayer target)
public RpcTarget Player(string funcName, Connection connection)
public RpcTarget Players(string funcName, List`1<Connection> connections)
public RpcTarget SendInfo(string funcName, SendInfo sendInfo)
public RpcTarget PlayerAndSpectators(string funcName, BasePlayer player)
}
public RunConsoleCommand : MonoBehaviour {
public void ClientRun(string command)
}
public RuntimeInterestNode : object {
private Vector3 <Position>k__BackingField
private float <NextVisitTime>k__BackingField
public Vector3 Position
public float NextVisitTime
public Vector3 get_Position()
public void set_Position(Vector3 value)
public float get_NextVisitTime()
public void set_NextVisitTime(float value)
public void .ctor(Vector3 position)
}
public RuntimePath : object {
private IAIPathNode[] <Nodes>k__BackingField
private List`1<IAIPathSpeedZone> speedZones
private List`1<IAIPathInterestNode> interestNodes
public IAIPathNode[] Nodes
public IEnumerable`1<IAIPathSpeedZone> SpeedZones
public IEnumerable`1<IAIPathInterestNode> InterestNodes
public IAIPathNode[] get_Nodes()
public void set_Nodes(IAIPathNode[] value)
public IEnumerable`1<IAIPathSpeedZone> get_SpeedZones()
public IEnumerable`1<IAIPathInterestNode> get_InterestNodes()
public IAIPathNode GetClosestToPoint(Vector3 point)
public void GetNodesNear(Vector3 point, List`1& nearNodes, float dist)
public IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist)
public void AddInterestNode(IAIPathInterestNode interestNode)
public void AddSpeedZone(IAIPathSpeedZone speedZone)
}
public RuntimePathNode : object {
private Vector3 <Position>k__BackingField
private bool <Straightaway>k__BackingField
private HashSet`1<IAIPathNode> linked
public Vector3 Position
public bool Straightaway
public IEnumerable`1<IAIPathNode> Linked
public Vector3 get_Position()
public void set_Position(Vector3 value)
public bool get_Straightaway()
public void set_Straightaway(bool value)
public IEnumerable`1<IAIPathNode> get_Linked()
public void .ctor(Vector3 position)
public bool IsValid()
public void AddLink(IAIPathNode link)
}
public runtimeScript : MonoBehaviour {
public ERRoadNetwork roadNetwork
public ERRoad road
public GameObject go
public int currentElement
public float distance
public float speed
private void Start()
private void Update()
private void OnDestroy()
}
public RuntimeSpeedZone : object {
public OBB worldOBBBounds
public float maxVelocityPerSec
public float GetMaxSpeed()
public OBB WorldSpaceBounds()
}
public Rust.Ai.AiLocationManager : FacepunchBehaviour {
public List`1<AiLocationManager> Managers
public AiLocationSpawner MainSpawner
public SquadSpawnerLocation LocationWhenMainSpawnerIsNull
public Transform CoverPointGroup
public Transform PatrolPointGroup
public CoverPointVolume DynamicCoverPointVolume
public bool SnapCoverPointsToGround
private List`1<PathInterestNode> patrolPoints
public SquadSpawnerLocation LocationType
public SquadSpawnerLocation get_LocationType()
private void Awake()
private void OnDestroy()
public PathInterestNode GetFirstPatrolPointInRange(Vector3 from, float minRange, float maxRange)
public PathInterestNode GetRandomPatrolPointInRange(Vector3 from, float minRange, float maxRange, PathInterestNode currentPatrolPoint)
}
public Rust.Ai.AiLocationSpawner : SpawnGroup {
public SquadSpawnerLocation Location
public AiLocationManager Manager
public JunkPile Junkpile
public bool IsMainSpawner
public float chance
private int defaultMaxPopulation
private int defaultNumToSpawnPerTickMax
private int defaultNumToSpawnPerTickMin
public void SpawnInitial()
protected void Spawn(int numToSpawn)
protected BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, Vector3& pos, Quaternion& rot)
}
public Rust.Ai.AiManagedAgent : FacepunchBehaviour {
public int AgentTypeIndex
public Vector2i NavmeshGridCoord
private bool isRegistered
private void OnEnable()
private void DelayedRegistration()
private void OnDisable()
}
public Rust.Ai.AiManager : SingletonComponent`1<AiManager> {
public bool UseCover
public float CoverPointVolumeCellSize
public float CoverPointVolumeCellHeight
public float CoverPointRayLength
public CoverPointVolume cpvPrefab
public LayerMask DynamicCoverPointVolumeLayerMask
private WorldSpaceGrid`1<CoverPointVolume> coverPointVolumeGrid
public bool nav_wait
public bool nav_disable
public bool setdestination_navmesh_failsafe
public bool ai_dormant
public float ai_to_player_distance_wakeup_range
public int nav_obstacles_carve_state
public int ai_dormant_max_wakeup_per_tick
public float ai_htn_player_tick_budget
public float ai_htn_player_junkpile_tick_budget
public float ai_htn_animal_tick_budget
public bool ai_htn_use_agency_tick
private BasePlayer[] playerVicinityQuery
private Func`2<BasePlayer, bool> filter
public int pathfindingIterationsPerFrame
public bool repeat
internal void OnEnableAgency()
internal void OnDisableAgency()
internal void UpdateAgency()
internal void OnEnableCover()
internal void OnDisableCover()
public CoverPointVolume CreateNewCoverVolume(Vector3 point, Transform coverPointGroup)
public CoverPointVolume GetCoverVolumeContaining(Vector3 point)
public void set_pathfindingIterationsPerFrame(int value)
public int get_pathfindingIterationsPerFrame()
public bool get_repeat()
public void Initialize()
private void OnDisable()
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
private bool InterestedInPlayersOnly(BaseEntity entity)
}
public Rust.AI.AStarNode : object {
public AStarNode Parent
public float G
public float H
public IAIPathNode Node
public float F
public float get_F()
public void .ctor(float g, float h, AStarNode parent, IAIPathNode node)
public void Update(float g, float h, AStarNode parent, IAIPathNode node)
public bool Satisfies(IAIPathNode node)
public bool op_LessThan(AStarNode lhs, AStarNode rhs)
public bool op_GreaterThan(AStarNode lhs, AStarNode rhs)
}
public Rust.AI.AStarNodeList : List`1<AStarNode> {
private AStarNodeComparer comparer
public bool Contains(IAIPathNode n)
public AStarNode GetAStarNodeOf(IAIPathNode n)
public void AStarNodeSort()
}
public Rust.AI.AStarPath : object {
private float Heuristic(IAIPathNode from, IAIPathNode to)
public bool FindPath(IAIPathNode start, IAIPathNode goal, Stack`1& path, Single& pathCost)
}
public Rust.Ai.CoverPoint : object {
private CoverPointVolume <Volume>k__BackingField
public CoverType NormalCoverType
public bool IsDynamic
public Transform SourceTransform
private Vector3 _staticPosition
private Vector3 _staticNormal
private BaseEntity <ReservedFor>k__BackingField
private bool <IsCompromised>k__BackingField
private float <Score>k__BackingField
public CoverPointVolume Volume
public Vector3 Position
public Vector3 Normal
public BaseEntity ReservedFor
public bool IsReserved
public bool IsCompromised
public float Score
public CoverPointVolume get_Volume()
private void set_Volume(CoverPointVolume value)
public Vector3 get_Position()
public void set_Position(Vector3 value)
public Vector3 get_Normal()
public void set_Normal(Vector3 value)
public BaseEntity get_ReservedFor()
public void set_ReservedFor(BaseEntity value)
public bool get_IsReserved()
public bool get_IsCompromised()
public void set_IsCompromised(bool value)
public float get_Score()
public void set_Score(float value)
public bool IsValidFor(BaseEntity entity)
public void .ctor(CoverPointVolume volume, float score)
public void CoverIsCompromised(float cooldown)
private IEnumerator StartCooldown(float cooldown)
public bool ProvidesCoverFromPoint(Vector3 point, float arcThreshold)
}
public Rust.Ai.CoverPointVolume : MonoBehaviour {
public float DefaultCoverPointScore
public float CoverPointRayLength
public LayerMask CoverLayerMask
public Transform BlockerGroup
public Transform ManualCoverPointGroup
public float cover_point_sample_step_size
public float cover_point_sample_step_height
public List`1<CoverPoint> CoverPoints
private List`1<CoverPointBlockerVolume> _coverPointBlockers
private float _dynNavMeshBuildCompletionTime
private int _genAttempts
private Bounds bounds
public bool repeat
public bool get_repeat()
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
private void ClearCoverPoints()
public Bounds GetBounds()
public void PreGenerateCoverPoints()
public void ConvertToManualCoverPoints()
public void GenerateCoverPoints(Transform coverPointGroup)
private CoverPoint CalculateCoverPoint(NavMeshHit info)
internal CoverType ProvidesCoverInDir(Ray ray, float maxDistance, RaycastHit& rayHit)
public bool Contains(Vector3 point)
}
public Rust.Ai.HTN.ScientistJunkpile.ScientistJunkpileSpawner : MonoBehaviour {
public GameObjectRef ScientistPrefab
public List`1<BaseCombatEntity> Spawned
public BaseSpawnPoint[] SpawnPoints
public int MaxPopulation
public bool InitialSpawn
public float MinRespawnTimeMinutes
public float MaxRespawnTimeMinutes
public float MovementRadius
public bool ReducedLongRangeAccuracy
public JunkpileType SpawnType
public float SpawnBaseChance
private float nextRespawnTime
private bool pendingRespawn
public int currentPopulation
public int get_currentPopulation()
private void Awake()
protected void OnDestroy()
public void Fill()
public void Clear()
public void SpawnInitial()
public void SpawnRepeating()
public void CheckIfRespawnNeeded()
private bool IsAllSpawnedDead()
public void ScheduleRespawn()
public void DoRespawn()
public void SpawnScientist()
private BaseSpawnPoint GetSpawnPoint(Vector3& pos, Quaternion& rot)
}
public Rust.Ai.ManualCoverPoint : FacepunchBehaviour {
public bool IsDynamic
public float Score
public CoverPointVolume Volume
public Vector3 Normal
public CoverType NormalCoverType
public Vector3 Position
public float DirectionMagnitude
public Vector3 get_Position()
public float get_DirectionMagnitude()
private void Awake()
public CoverPoint ToCoverPoint(CoverPointVolume volume)
}
public Rust.Ai.Memory : object {
public List`1<BaseEntity> Visible
public List`1<SeenInfo> All
public List`1<ExtendedInfo> AllExtended
public SeenInfo Update(BaseEntity entity, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, ExtendedInfo& extendedInfo)
public SeenInfo Update(BaseEntity entity, Vector3 position, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, ExtendedInfo& extendedInfo)
public SeenInfo Update(BaseEntity ent, float danger)
public SeenInfo Update(BaseEntity ent, Vector3 position, float danger)
public void AddDanger(Vector3 position, float amount)
public SeenInfo GetInfo(BaseEntity entity)
public SeenInfo GetInfo(Vector3 position)
public ExtendedInfo GetExtendedInfo(BaseEntity entity)
internal void Forget(float maxSecondsOld)
}
public Rust.Ai.NavmeshPrefabInstantiator : MonoBehaviour {
public GameObjectRef NavmeshPrefab
private void Start()
}
public Rust.Ai.ScientistSpawner : SpawnGroup {
public bool Mobile
public bool NeverMove
public bool SpawnHostile
public bool OnlyAggroMarkedTargets
public bool IsPeacekeeper
public bool IsBandit
public bool IsMilitaryTunnelLab
public WaypointSet Waypoints
public Transform[] LookAtInterestPointsStationary
public Vector2 RadioEffectRepeatRange
public Model Model
private AiLocationManager _mgr
private float _nextForcedRespawn
private bool _lastSpawnCallHadAliveMembers
private bool _lastSpawnCallHadMaxAliveMembers
protected void Spawn(int numToSpawn)
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
protected void OnDrawGizmos()
}
public Rust.AI.SimpleAIMemory : object {
public HashSet`1<BasePlayer> PlayerIgnoreList
public List`1<SeenInfo> All
public List`1<BaseEntity> Players
public HashSet`1<BaseEntity> LOS
public List`1<BaseEntity> Targets
public List`1<BaseEntity> Threats
public List`1<BaseEntity> Friendlies
public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)
public void SetLOS(BaseEntity ent, bool flag)
public bool IsLOS(BaseEntity ent)
public bool IsPlayerKnown(BasePlayer player)
public void Forget(float secondsOld)
public void AddIgnorePlayer(BasePlayer player)
public void RemoveIgnorePlayer(BasePlayer player)
public void ClearIgnoredPlayers()
public string GetIgnoredPlayers()
}
public Rust.Ai.WaypointSet : MonoBehaviour {
private List`1<Waypoint> _points
private NavModes navMode
public List`1<Waypoint> Points
public NavModes NavMode
public List`1<Waypoint> get_Points()
public void set_Points(List`1<Waypoint> value)
public NavModes get_NavMode()
private void OnDrawGizmos()
}
public Rust.DamageType : Enum {
public int value__
public DamageType Generic
public DamageType Hunger
public DamageType Thirst
public DamageType Cold
public DamageType Drowned
public DamageType Heat
public DamageType Bleeding
public DamageType Poison
public DamageType Suicide
public DamageType Bullet
public DamageType Slash
public DamageType Blunt
public DamageType Fall
public DamageType Radiation
public DamageType Bite
public DamageType Stab
public DamageType Explosion
public DamageType RadiationExposure
public DamageType ColdExposure
public DamageType Decay
public DamageType ElectricShock
public DamageType Arrow
public DamageType AntiVehicle
public DamageType Collision
public DamageType Fun_Water
public DamageType LAST
}
public Rust.DamageTypeEntry : object {
public DamageType type
public float amount
}
public Rust.DamageTypeEx : object {
public bool IsMeleeType(DamageType damageType)
public bool IsBleedCausing(DamageType damageType)
public bool IsConsideredAnAttack(DamageType damageType)
public bool InterruptsRestraintMinigame(DamageType damageType)
}
public Rust.DamageTypeList : object {
public Single[] types
public void Set(DamageType index, float amount)
public float Get(DamageType index)
public void Add(DamageType index, float amount)
public void Scale(DamageType index, float amount)
public bool Has(DamageType index)
public float Total()
public void Clear()
public void Add(List`1<DamageTypeEntry> entries)
public void ScaleAll(float amount)
public DamageType GetMajorityDamageType()
public bool IsMeleeType()
public bool IsBleedCausing()
public bool IsConsideredAnAttack()
}
public Rust.Defines : object {
public UInt32 appID
public string resourceFolder
}
internal Rust.GameInfo : object {
internal bool IsOfficialServer
internal bool HasAchievements
internal bool get_IsOfficialServer()
internal bool get_HasAchievements()
}
public Rust.GC : MonoBehaviour {
public int gcLowerBounds
public int gcDefaultValue
public int gcEditorDefaultValue
public bool Enabled
public bool get_Enabled()
public void Collect()
public int GetSafeGCValue(int val)
public long GetTotalMemory()
public int CollectionCount()
}
public Rust.Generic : object {
private Scene _batchingScene
public Scene BatchingScene
public Scene get_BatchingScene()
}
public Rust.Instruments.Notes : Enum {
public int value__
public Notes A
public Notes B
public Notes C
public Notes D
public Notes E
public Notes F
public Notes G
}
public Rust.Interpolation.FloatSnapshot : ValueType {
private float <Time>k__BackingField
public float value
public float Time
public float get_Time()
public void set_Time(float value)
public void .ctor(float time, float value)
public void MatchValuesTo(FloatSnapshot entry)
public void Lerp(FloatSnapshot prev, FloatSnapshot next, float delta)
public FloatSnapshot GetNew()
}
public Rust.Interpolation.GenericLerp`1 : object {
private Interpolator`1<T> interpolator
private IGenericLerpTarget`1<T> target
private T snapshotPrototype
private float timeOffset
private float timeOffset0
private float timeOffset1
private float timeOffset2
private float timeOffset3
private int timeOffsetCount
private int TimeOffsetInterval
private float LerpTime
private int get_TimeOffsetInterval()
private float get_LerpTime()
public void .ctor(IGenericLerpTarget`1<T> target, int listCount)
public void Tick()
public void Snapshot(T snapshot)
public void SnapTo(T snapshot)
public void SnapToNow(T snapshot)
public void SnapToEnd()
public void Dispose()
private void Wipe()
}
public Rust.Interpolation.IGenericLerpTarget`1 {
public float GetInterpolationDelay()
public float GetInterpolationSmoothing()
public void SetFrom(T snapshot)
public T GetCurrentState()
public void DebugInterpolationState(Segment<T> segment, List`1<T> entries)
}
public Rust.Interpolation.Interpolator`1 : object {
public List`1<T> list
public T last
public void .ctor(int listCount)
public void Add(T tick)
public void Cull(float beforeTime)
public void Clear()
public Segment<T> Query(float time, float interpolation, float extrapolation, float smoothing, T& t)
}
public Rust.Interpolation.ISnapshot`1 {
public float Time
public float get_Time()
public void set_Time(float value)
public void MatchValuesTo(T entry)
public void Lerp(T prev, T next, float delta)
public T GetNew()
}
public Rust.Interpolation.TransformSnapshot : ValueType {
private float <Time>k__BackingField
public Vector3 pos
public Quaternion rot
public float Time
public float get_Time()
public void set_Time(float value)
public void .ctor(float time, Vector3 pos, Quaternion rot)
public void MatchValuesTo(TransformSnapshot entry)
public void Lerp(TransformSnapshot prev, TransformSnapshot next, float delta)
public TransformSnapshot GetNew()
}
public Rust.Modular.ConditionalObject : object {
public GameObject gameObject
public GameObject ownerGameObject
public ConditionalSocketSettings[] socketSettings
public bool restrictOnHealth
public float healthRestrictionMin
public float healthRestrictionMax
public bool restrictOnAdjacent
public AdjacentCondition adjacentRestriction
public AdjacentMatchType adjacentMatch
public bool restrictOnLockable
public bool lockableRestriction
private Nullable`1<bool> <IsActive>k__BackingField
public Nullable`1<bool> IsActive
public Nullable`1<bool> get_IsActive()
private void set_IsActive(Nullable`1<bool> value)
public void .ctor(GameObject conditionalGO, GameObject ownerGO, int socketsTaken)
public void SetActive(bool active)
public void RefreshActive()
}
public Rust.Modular.ConditionalSocketSettings : object {
public bool restrictOnLocation
public LocationCondition locationRestriction
public bool restrictOnWheel
public SocketWheelType wheelRestriction
public bool HasSocketRestrictions
public bool get_HasSocketRestrictions()
}
public Rust.Modular.EnableDisableEvent : MonoBehaviour {
private UnityEvent enableEvent
private UnityEvent disableEvent
protected void OnEnable()
protected void OnDisable()
}
public Rust.Modular.EngineItemTypeEx : object {
public bool BoostsAcceleration(EngineItemTypes engineItemType)
public bool BoostsTopSpeed(EngineItemTypes engineItemType)
public bool BoostsFuelEconomy(EngineItemTypes engineItemType)
}
public Rust.Modular.EngineStorage : StorageContainer {
public Sprite engineIcon
public float internalDamageMultiplier
public EngineItemTypes[] slotTypes
public VehicleModuleEngineItems allEngineItems
public int accelerationBoostSlots
public int topSpeedBoostSlots
public int fuelEconomyBoostSlots
private bool <isUsable>k__BackingField
private float <accelerationBoostPercent>k__BackingField
private float <topSpeedBoostPercent>k__BackingField
private float <fuelEconomyBoostPercent>k__BackingField
public bool isUsable
public float accelerationBoostPercent
public float topSpeedBoostPercent
public float fuelEconomyBoostPercent
public bool get_isUsable()
public void set_isUsable(bool value)
public float get_accelerationBoostPercent()
public void set_accelerationBoostPercent(float value)
public float get_topSpeedBoostPercent()
public void set_topSpeedBoostPercent(float value)
public float get_fuelEconomyBoostPercent()
public void set_fuelEconomyBoostPercent(float value)
public VehicleModuleEngine GetEngineModule()
public float GetAveragedLoadoutPercent()
public void Load(LoadInfo info)
public bool CanBeLooted(BasePlayer player)
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public int GetValidSlot(Item item)
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool ItemFilter(Item item, int targetSlot)
public void RefreshLoadoutData()
public void Save(SaveInfo info)
public void OnModuleDamaged(float damageTaken)
public void AdminAddParts(int tier)
public float GetContainerItemsValueFor(Func`2<EngineItemTypes, bool> boostConditional)
public float GetTierValue(int tier)
}
public Rust.Modular.ItemModEngineItem : ItemMod {
public EngineItemTypes engineItemType
public int tier
}
public Rust.Modular.ItemModVehicleChassis : ItemMod {
public GameObjectRef entityPrefab
public int socketsTaken
public int SocketsTaken
public int get_SocketsTaken()
}
public Rust.Modular.ItemModVehicleModule : ItemMod {
public GameObjectRef entityPrefab
public int socketsTaken
public int SocketsTaken
public int get_SocketsTaken()
public BaseVehicleModule CreateModuleEntity(BaseEntity parent, Vector3 position, Quaternion rotation)
}
public Rust.Modular.ModularCarAudio : GroundVehicleAudio {
public bool showDebug
private SoundDefinition skidSoundLoop
private SoundDefinition skidSoundDirtLoop
private SoundDefinition skidSoundSnowLoop
private float skidMinSlip
private float skidMaxSlip
private SoundDefinition movementStartOneshot
private SoundDefinition movementStopOneshot
private float movementStartStopMinTimeBetweenSounds
private SoundDefinition movementRattleLoop
private float movementRattleMaxSpeed
private float movementRattleMaxAngSpeed
private float movementRattleIdleGain
private SoundDefinition suspensionLurchSound
private float suspensionLurchMinExtensionDelta
private float suspensionLurchMinTimeBetweenSounds
private SoundDefinition tyreRollingSoundDef
private SoundDefinition tyreRollingWaterSoundDef
private SoundDefinition tyreRollingGrassSoundDef
private SoundDefinition tyreRollingSnowSoundDef
private AnimationCurve tyreRollGainCurve
}
public Rust.Modular.ModularVehicleInventory : object {
private ItemContainer <ModuleContainer>k__BackingField
private ItemContainer <ChassisContainer>k__BackingField
private BaseModularVehicle vehicle
public ItemContainer ModuleContainer
public ItemContainer ChassisContainer
public ItemContainerId UID
private int TotalSockets
public ItemContainer get_ModuleContainer()
public ItemContainer get_ChassisContainer()
public ItemContainerId get_UID()
private int get_TotalSockets()
public void .ctor(BaseModularVehicle vehicle, ItemDefinition chassisItemDef, bool giveUID)
public void Dispose()
public void GiveUIDs()
public bool SocketIsFree(int socketIndex, Item moduleItem)
public bool SocketIsTaken(int socketIndex)
public bool TryAddModuleItem(Item moduleItem, int socketIndex)
public bool RemoveAndDestroy(Item itemToRemove)
public int TryGetFreeSocket(int socketsTaken)
public int TryGetFreeSocket(Item moduleItem, int socketsTaken)
public bool SocketsAreFree(int firstIndex, int socketsTaken, Item moduleItem)
public bool TrySyncModuleInventory(BaseVehicleModule moduleEntity, int firstSocketIndex)
private bool SocketIsUsed(Item item, int slotIndex)
private ItemContainer CreateModuleInventory(BaseModularVehicle vehicle, bool giveUID)
private ItemContainer CreateChassisInventory(BaseModularVehicle vehicle, bool giveUID)
private void OnSocketInventoryAddRemove(Item moduleItem, bool added)
private void ModuleItemAdded(Item moduleItem, int socketIndex)
private void ModuleItemRemoved(Item moduleItem)
private void OnModuleItemChanged(Item moduleItem)
private bool ItemFilter(Item item, int targetSlot)
}
public Rust.Modular.ModularVehicleSocket : object {
private Transform socketTransform
private SocketWheelType wheelType
private SocketLocationType locationType
public Vector3 WorldPosition
public Quaternion WorldRotation
public SocketWheelType WheelType
public SocketLocationType LocationType
public Vector3 get_WorldPosition()
public Quaternion get_WorldRotation()
public SocketWheelType get_WheelType()
public SocketLocationType get_LocationType()
public bool ShouldBeActive(ConditionalSocketSettings modelSettings)
}
public Rust.Modular.VehicleModuleEngineItems : ScriptableObject {
private ItemModEngineItem[] engineItems
public bool TryGetItem(int tier, EngineItemTypes type, ItemModEngineItem& output)
}
public Rust.Modular.VehicleModuleSlidingComponent : object {
public string interactionColliderName
public Flags flag_SliderOpen
public float moveTime
public SlidingPart[] slidingParts
public SoundDefinition openSoundDef
public SoundDefinition closeSoundDef
private float positionPercent
public bool WantsOpenPos(BaseEntity parentEntity)
public void Use(BaseVehicleModule parentModule)
public void ServerUpdateTick(BaseVehicleModule parentModule)
private void CheckPosition(BaseEntity parentEntity, float dt)
}
public Rust.Nexus.Handlers.BaseNexusRequestHandler`1 : object {
private NexusZoneDetails <FromZone>k__BackingField
private Uuid <RequestId>k__BackingField
private T <Request>k__BackingField
private Response <Response>k__BackingField
private bool _fireAndForget
protected NexusZoneDetails FromZone
protected Uuid RequestId
protected T Request
public Response Response
protected NexusZoneDetails get_FromZone()
private void set_FromZone(NexusZoneDetails value)
protected Uuid get_RequestId()
private void set_RequestId(Uuid value)
protected T get_Request()
private void set_Request(T value)
public Response get_Response()
private void set_Response(Response value)
public void Initialize(NexusZoneDetails fromZone, Uuid id, bool fireAndForget, T request)
public void EnterPool()
public void LeavePool()
public void Execute()
protected void Handle()
protected void Reset()
protected void SendSuccess()
protected void SendSuccess(Response response)
protected void SendResult(bool success)
protected void SendResult(bool success, Response response)
protected void SendError(string message)
protected Response NewResponse()
}
public Rust.Nexus.Handlers.ClanChatBatchHandler : BaseNexusRequestHandler`1<ClanChatBatchRequest> {
protected void Handle()
}
public Rust.Nexus.Handlers.DestroyBagHandler : BaseNexusRequestHandler`1<SleepingBagDestroyRequest> {
protected void Handle()
}
public Rust.Nexus.Handlers.FerryRetireHandler : BaseNexusRequestHandler`1<FerryRetireRequest> {
protected void Handle()
}
public Rust.Nexus.Handlers.FerryStatusHandler : BaseNexusRequestHandler`1<FerryStatusRequest> {
protected void Handle()
}
public Rust.Nexus.Handlers.FerryUpdateScheduleHandler : BaseNexusRequestHandler`1<FerryUpdateScheduleRequest> {
protected void Handle()
}
public Rust.Nexus.Handlers.INexusRequestHandler {
public Response Response
public Response get_Response()
public void Execute()
}
public Rust.Nexus.Handlers.PingHandler : BaseNexusRequestHandler`1<PingRequest> {
protected void Handle()
}
public Rust.Nexus.Handlers.PlayerManifestHandler : BaseNexusRequestHandler`1<PlayerManifestRequest> {
protected void Handle()
}
public Rust.Nexus.Handlers.RespawnAtBagHandler : BaseNexusRequestHandler`1<SleepingBagRespawnRequest> {
protected void Handle()
}
public Rust.Nexus.Handlers.SpawnOptionsHandler : BaseNexusRequestHandler`1<SpawnOptionsRequest> {
protected void Handle()
}
public Rust.Nexus.Handlers.TransferHandler : BaseNexusRequestHandler`1<TransferRequest> {
private Dictionary`2<ulong, ulong> UidMapping
private Dictionary`2<NetworkableId, Entity> UidToEntity
private Dictionary`2<BaseEntity, Entity> EntityToSpawn
private Dictionary`2<ulong, BasePlayer> SpawnedPlayers
private List`1<string> PlayerIds
private List`1<NetworkableId> EntitiesToProtect
private Dictionary`2<ulong, PlayerTeam> TeamMapping
protected void Handle()
private void CompleteTransfers()
private void RepositionEntitiesFromTransfer()
private void SpawnEntities(Dictionary`2<ulong, BasePlayer> players)
internal void <Handle>g__UpdateWithNewUid|7_0(UidType type, UInt64& prevUid)
}
public Rust.Numlock : object {
private byte VK_NUMLOCK
private UInt32 KEYEVENTF_EXTENDEDKEY
private int KEYEVENTF_KEYUP
private int KEYEVENTF_KEYDOWN
public bool IsOn
private short GetKeyState(int keyCode)
private void keybd_event(byte bVk, byte bScan, UInt32 dwFlags, int dwExtraInfo)
public bool get_IsOn()
public void TurnOn()
}
public Rust.Server : object {
public float UseDistance
private Scene _entityScene
public Scene EntityScene
public Scene get_EntityScene()
}
public Rust.UI.MainMenu.Hero : SingletonComponent`1<Hero> {
public CanvasGroup CanvasGroup
public Video VideoPlayer
public RustText TitleText
public RustText ButtonText
public HttpImage TitleImage
public RustButton ItemStoreButton
public RustButton LimitedTabButton
public RustButton GeneralTabButton
}
public Rust.UI.MuteListController : UIDialog {
public RectTransform ListParent
public GameObjectRef UserWidget
public SteamFriendsList SearchList
}
public Rust.UI.ReportBug : UIDialog {
public GameObject GetInformation
public GameObject Finished
public RustInput Subject
public RustInput Message
public RustButton ReportButton
public RustButtonGroup Category
public RustIcon ProgressIcon
public RustText ProgressText
public RawImage ScreenshotImage
public GameObject ScreenshotRoot
public UIBackgroundBlur BlurController
public RustButton SubmitButton
public GameObject SubmitErrorRoot
public RustText CooldownText
public RustText ContentMissingText
}
public Rust.UI.ReportPlayer : UIDialog {
public GameObject FindPlayer
public GameObject GetInformation
public GameObject Finished
public GameObject RecentlyReported
public Dropdown ReasonDropdown
public RustInput Subject
public RustInput Message
public RustButton ReportButton
public SteamUserButton SteamUserButton
public RustIcon ProgressIcon
public RustText ProgressText
public Option[] ReportReasons
}
public Rust.UI.ServerAdmin.ServerAdminConvarInfo : MonoBehaviour {
public RustText InfoName
public RustText InfoValue
public RustInput VariableInput
public Tooltip TooltipComponent
}
public Rust.UI.ServerAdmin.ServerAdminPlayerEntry : MonoBehaviour {
public RustText PlayerName
public RustText Ping
public RustButton Button
}
public Rust.UI.ServerAdmin.ServerAdminPlayerId : MonoBehaviour {
public RustText PlayerName
public RustText PlayerId
}
public Rust.UI.ServerAdmin.ServerAdminPlayerInfo : MonoBehaviour {
public RustText PlayerName
public RustText SteamID
public RustText OwnerSteamID
public RustText Ping
public RustText Address
public RustText ConnectedTime
public RustText ViolationLevel
public RustText Health
public RustInput KickReasonInput
public RustInput BanReasonInput
}
public Rust.UI.ServerAdmin.ServerAdminServerInfo : MonoBehaviour {
public RustText InfoName
public RustText InfoValue
}
public Rust.UI.ServerAdmin.ServerAdminUGCEntryAudio : ServerAdminUGCEntry {
public AudioSource AudioSpeaker
public RustText DurationText
public RustSlider ProgressSlider
public RustIcon PlayIcon
}
public Rust.UI.ServerAdmin.ServerAdminUGCEntryImage : ServerAdminUGCEntry {
public RawImage Image
public RectTransform Backing
public GameObject MultiImageRoot
public RustText ImageIndex
public Vector2 OriginalImageSize
}
public Rust.UI.ServerAdmin.ServerAdminUGCEntryPattern : ServerAdminUGCEntry {
public GameObjectRef StarPrefab
public RectTransform StarRoot
}
public Rust.UI.ServerAdmin.ServerAdminUGCEntryStub : MonoBehaviour {
public ServerAdminUGCEntryAudio AudioWidget
public ServerAdminUGCEntryImage ImageWidget
public ServerAdminUGCEntryPattern PatternWidget
public RustText PrefabName
public RustButton HistoryButton
public ServerAdminPlayerId[] HistoryIds
}
public Rust.UI.ServerAdmin.ServerAdminUI : SingletonComponent`1<ServerAdminUI> {
public GameObjectRef PlayerEntry
public RectTransform PlayerInfoParent
public RustText PlayerCount
public RustInput PlayerNameFilter
public GameObjectRef ServerInfoEntry
public RectTransform ServerInfoParent
public GameObjectRef ConvarInfoEntry
public GameObjectRef ConvarInfoLongEntry
public RectTransform ConvarInfoParent
public ServerAdminPlayerInfo PlayerInfo
public RustInput UgcNameFilter
public GameObjectRef ImageEntry
public GameObjectRef PatternEntry
public GameObjectRef SoundEntry
public VirtualScroll UgcVirtualScroll
public GameObject ExpandedUgcRoot
public RawImage ExpandedImage
public RectTransform ExpandedImageBacking
}
public Rust.UI.SteamInventoryCrafting : MonoBehaviour {
public GameObject Container
public ToggleGroup ToggleGroup
public Button ConvertToItem
public Button DeleteButton
public TextMeshProUGUI WoodAmount
public TextMeshProUGUI ClothAmount
public TextMeshProUGUI MetalAmount
public TextMeshProUGUI InfoText
private IPlayerItemDefinition <ResultItem>k__BackingField
private Coroutine <MarketCoroutine>k__BackingField
public SteamInventoryCrateOpen CraftModal
public GameObject CraftingContainer
public GameObject CraftingButton
public SteamInventoryNewItem NewItemModal
public IPlayerItemDefinition ResultItem
public Coroutine MarketCoroutine
public IPlayerItemDefinition get_ResultItem()
private void set_ResultItem(IPlayerItemDefinition value)
public Coroutine get_MarketCoroutine()
private void set_MarketCoroutine(Coroutine value)
}
public Rust.UI.SteamInventoryCrateOpen : MonoBehaviour {
public TextMeshProUGUI Name
public TextMeshProUGUI Requirements
public TextMeshProUGUI Label
public HttpImage IconImage
public GameObject ErrorPanel
public TextMeshProUGUI ErrorText
public GameObject CraftButton
public GameObject ProgressPanel
public SteamInventoryNewItem NewItemModal
}
public Rust.UI.SteamInventoryItem : MonoBehaviour {
public IPlayerItem Item
public HttpImage Image
public bool Setup(IPlayerItem item)
}
public Rust.UI.SteamInventoryManager : SingletonComponent`1<SteamInventoryManager> {
public GameObject inventoryItemPrefab
public GameObject inventoryCanvas
public GameObject missingItems
public SteamInventoryCrafting CraftControl
public List`1<GameObject> items
public GameObject LoadingOverlay
}
public Rust.UI.SteamInventoryNewItem : MonoBehaviour {
public Task Open(IPlayerItem item)
}
internal Rust.UI.Utility.ForceWeather : MonoBehaviour {
private Toggle component
public bool Rain
public bool Fog
public bool Wind
public bool Clouds
public void OnEnable()
public void Update()
}
public Rust.Water5.OceanDisplacementShort3 : ValueType {
private float precision
private float float2short
private float short2float
public short x
public short y
public short z
public Vector3 op_Implicit(OceanDisplacementShort3 v)
public OceanDisplacementShort3 op_Implicit(Vector3 v)
public OceanDisplacementShort3 op_Implicit(float3 v)
}
public Rust.Water5.OceanSimulation : object {
public int octaveCount
public int simulationSize
public int physicsSimulationSize
public int physicsFrameRate
public int physicsLooptime
public int physicsFrameCount
public float phsyicsDeltaTime
public float oneOverPhysicsSimulationSize
public int physicsFrameSize
public int physicsSpectrumOffset
private OceanSettings oceanSettings
private Single[] spectrumRanges
private float distanceAttenuationFactor
private float depthAttenuationFactor
private float oneOverOctave0Scale
private Single[] beaufortValues
private int spectrum0
private int spectrum1
private float spectrumBlend
private int frame0
private int frame1
private float frameBlend
private float currentTime
private float prevUpdateComputeTime
private float deltaTime
public OceanDisplacementShort3[0...,0...,0...] simData
public int Spectrum0
public int Spectrum1
public float SpectrumBlend
public int Frame0
public int Frame1
public float FrameBlend
public int get_Spectrum0()
public int get_Spectrum1()
public float get_SpectrumBlend()
public int get_Frame0()
public int get_Frame1()
public float get_FrameBlend()
public void .ctor(OceanSettings oceanSettings)
public void Update(float time, float dt, float beaufort)
private void FindSpectra(float beaufort, Int32& spectrum0, Int32& spectrum1, Single& spectrumT)
public void FindFrames(float time, Int32& frame0, Int32& frame1, Single& frameBlend)
public bool Trace(Ray ray, float maxDist, Vector3& result)
public float MinLevel()
public float MaxLevel()
public float GetHeight(Vector3[0...,0...,0...] simData, Vector3 position, float time, float beaufort, float distAttenFactor, float depthAttenFactor)
public Vector3 GetDisplacement(Vector3[0...,0...,0...] simData, Vector3 position, float time, float beaufort)
public Vector3 GetDisplacement(Vector3[0...,0...,0...] simData, Vector3 position, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
public Vector3 GetDisplacement(Vector3[0...,0...,0...] simData, float normX, float normZ, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
public Vector3 GetDisplacement(Vector3[0...,0...,0...] simData, int x, int y, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
public void Dispose()
public float GetHeightRaw(Vector3 position)
public Vector3 GetDisplacement(Vector3 position)
public Vector3 GetDisplacement(float normX, float normZ)
public Vector3 GetDisplacement(int x, int z)
public float GetHeight(Vector3 position)
public float GetHeightAttenuation(Vector3 position)
}
public Rust.Water5.OceanSpectrumSettings : ScriptableObject {
public OceanSettings oceanSettings
public float g
public float beaufort
public float depth
public SpectrumSettings local
public SpectrumSettings swell
public Color color
public Color specColor
public float smoothness
public Color waterColor
public Color waterExtinction
public float scatteringCoefficient
public Color subSurfaceColor
public float subSurfaceFalloff
public float subSurfaceBase
public float subSurfaceSun
public float subSurfaceAmount
public float foamAmount
public float foamScale
public Color foamColor
public Color baseFoamColor
public void UpdateSpectrum()
}
public Rust.Water5.SpectrumParameters : ValueType {
public float scale
public float angle
public float spreadBlend
public float swell
public float alpha
public float peakOmega
public float gamma
public float shortWavesFade
}
public Rust.Water5.SpectrumSettings : ValueType {
public float scale
public float windSpeed
public float fetch
public float spreadBlend
public float swell
public float peakEnhancement
public float shortWavesFade
}
public RustCamera`1 : SingletonComponent`1<T> {
private AmplifyOcclusionEffect ssao
private SEScreenSpaceShadows contactShadows
private VisualizeTexelDensity visualizeTexelDensity
private EnvironmentVolumePropertiesCollection environmentVolumeProperties
private PostProcessLayer post
private PostProcessVolume baseEffectVolume
}
public RustEmojiConfig : ScriptableObject {
public bool Hide
public EmojiSource Source
}
public RustEmojiLibrary : BaseScriptableObject {
public NetworkableId EmojiStorageNetworkId
public RustEmojiConfig[] Configs
public RenderTextureDescriptor RenderTextureDesc
public int InitialPoolSize
private List`1<EmojiSource> all
private List`1<EmojiSource> conditionalAccessOnly
public GameObjectRef VideoPlayerRef
private RustEmojiLibrary _instance
private bool hasPrewarmed
private long MAX_FILE_SIZE_BYTES
public int MAX_TEX_SIZE_PIXELS
public Dictionary`2<string, ServerEmojiConfig> allServerEmoji
private bool hasLoaded
public List`1<string> cachedServerList
public RustEmojiLibrary Instance
public RustEmojiLibrary get_Instance()
private void Prewarm()
public bool TryGetEmoji(string key, EmojiSource& er, Int32& skinVariantIndex, Int32& allIndex, bool serverSide)
public void FindAllServerEmoji()
public void ResetServerEmoji()
private bool CheckByteArray(long arrayLength)
public bool CheckByteArray(int arrayLength)
}
public RustigeEgg : BaseCombatEntity {
public Flags Flag_Spin
public Transform eggRotationTransform
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsSpinning()
public void RPC_Spin(RPCMessage msg)
public void RPC_Open(RPCMessage msg)
public void CloseEgg()
}
public RustPlatformHooks : object {
public RustPlatformHooks Instance
public UInt32 SteamAppId
public Nullable`1<ServerParameters> ServerParameters
public UInt32 get_SteamAppId()
public void Abort()
public void OnItemDefinitionsChanged()
public Nullable`1<ServerParameters> get_ServerParameters()
public void AuthSessionValidated(ulong userId, ulong ownerUserId, AuthResponse response, string rawResponse)
}
public SamSite : ContainerIOEntity {
public Animator pitchAnimator
public GameObject yaw
public GameObject pitch
public GameObject gear
public Transform eyePoint
public float gearEpislonDegrees
public float turnSpeed
public float clientLerpSpeed
public Vector3 currentAimDir
public Vector3 targetAimDir
public float vehicleScanRadius
public float missileScanRadius
public GameObjectRef projectileTest
public GameObjectRef muzzleFlashTest
public bool staticRespawn
public ItemDefinition ammoType
public Transform[] tubes
public float staticrepairseconds
public SoundDefinition yawMovementLoopDef
public float yawGainLerp
public float yawGainMovementSpeedMult
public SoundDefinition pitchMovementLoopDef
public float pitchGainLerp
public float pitchGainMovementSpeedMult
public int lowAmmoThreshold
public Flags Flag_TargetMode
public Flags Flag_ManuallySetMode
public SamTargetType targetTypeUnknown
public SamTargetType targetTypeVehicle
public SamTargetType targetTypeMissile
public ISamSiteTarget currentTarget
public SamTargetType mostRecentTargetType
public Item ammoItem
public float lockOnTime
public float lastTargetVisibleTime
public int lastAmmoCount
public int currentTubeIndex
public int firedCount
public float nextBurstTime
private int input1Amount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPowered()
public int ConsumptionAmount()
public bool IsInDefenderMode()
public void Load(LoadInfo info)
public void SetTarget(ISamSiteTarget target)
public void MarkIODirty()
public void ClearTarget()
public void ServerInit()
public void OnItemAddedRemoved(Item arg1, bool arg2)
public void Save(SaveInfo info)
public void PostServerLoad()
public void SelfHeal()
public void Die(HitInfo info)
public void FixedUpdate()
public Vector3 GetAimDir()
public bool HasValidTarget()
public bool CanPickup(BasePlayer player)
private void AddTargetSet(List`1<ISamSiteTarget> allTargets, float scanRadius)
private void AddMLRSRockets(List`1<ISamSiteTarget> allTargets, float scanRadius)
public void TargetScan()
public bool HasAmmo()
public void Reload()
public void EnsureReloaded()
public bool IsReloading()
public void WeaponTick()
public void FireProjectile(Vector3 origin, Vector3 direction, float speedMultiplier)
public int GetPassthroughAmount(int outputSlot)
private void ToggleDefenderMode(RPCMessage msg)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int inputSlot)
}
public Sandstorm : MonoBehaviour {
public ParticleSystem m_psSandStorm
public float m_flSpeed
public float m_flSwirl
public float m_flEmissionRate
private void Start()
private void Update()
}
public SantaSleigh : BaseEntity {
public GameObjectRef prefabDrop
public SpawnFilter filter
public Transform dropOrigin
public float altitudeAboveTerrain
public float desiredAltitude
public Light bigLight
public SoundPlayer hohoho
public float hohohospacing
public float hohoho_additional_spacing
public Vector3 swimScale
public Vector3 swimSpeed
public float appliedSwimScale
public float appliedSwimRotation
private Vector3 startPos
private Vector3 endPos
private float secondsToTake
private float secondsTaken
private bool dropped
public Vector3 dropPosition
private float swimRandom
private string path
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float GetNetworkTime()
public void InitDropPosition(Vector3 newDropPosition)
public void ServerInit()
public void SendHoHoHo()
public Vector3 RandomDropPosition()
public void UpdateDropPosition(Vector3 newDropPosition)
private void FixedUpdate()
public void drop(Arg arg)
}
public SaveRestore : SingletonComponent`1<SaveRestore> {
public bool IsSaving
public DateTime SaveCreatedTime
private RealTimeSince TimeSinceLastSave
private MemoryStream SaveBuffer
private string <WipeId>k__BackingField
public string WipeId
public string get_WipeId()
private void set_WipeId(string value)
public IEnumerator Save(string strFilename, bool AndWait)
private void ShiftSaveBackups(string fileName)
private void Start()
private IEnumerator SaveRegularly()
private IEnumerator DoAutomatedSave(bool AndWait)
public bool Save(bool AndWait)
public List`1<BaseEntity> FindMapEntities()
public void ClearMapEntities(List`1<BaseEntity> entities)
public void SpawnMapEntities(List`1<BaseEntity> entities)
public bool Load(string strFilename, bool allowOutOfDateSaves)
public void GetSaveCache()
public void InitializeEntityLinks()
public void InitializeEntitySupports()
public void InitializeEntityConditionals()
public void InitializeWipeId()
internal string <ShiftSaveBackups>g__GetBackupName|9_0(int i, <>c__DisplayClass9_0& )
}
public ScaleByIntensity : MonoBehaviour {
public Vector3 initialScale
public Light intensitySource
public float maxIntensity
private void Start()
private void Update()
}
public ScaleBySpeed : MonoBehaviour {
public float minScale
public float maxScale
public float minSpeed
public float maxSpeed
public MonoBehaviour component
public bool toggleComponent
public bool onlyWhenSubmerged
public float submergedThickness
private Vector3 prevPosition
}
public ScaleParticleSystem : ScaleRenderer {
public ParticleSystem pSystem
public bool scaleGravity
private float startSize
private float startLifeTime
private float startSpeed
private float startGravity
public void GatherInitialValues()
public void SetScale_Internal(float scale)
}
public ScaleRenderer : MonoBehaviour {
public bool useRandomScale
public float scaleMin
public float scaleMax
private float lastScale
protected bool hasInitialValues
public Renderer myRenderer
private bool ScaleDifferent(float newScale)
public void Start()
public void SetScale(float scale)
public void SetScale_Internal(float scale)
public void SetRendererEnabled(bool isEnabled)
public void GatherInitialValues()
}
public ScaleTrailRenderer : ScaleRenderer {
private TrailRenderer trailRenderer
private float startWidth
private float endWidth
private float duration
private float startMultiplier
public void GatherInitialValues()
public void SetScale_Internal(float scale)
}
public ScaleTransform : ScaleRenderer {
private Vector3 initialScale
public void SetScale_Internal(float scale)
public void GatherInitialValues()
}
public ScarecrowBrain : BaseAIBrain {
public void AddStates()
public void InitializeAI()
public void OnDestroy()
}
public ScarecrowNPC : NPCPlayer {
private ScarecrowBrain <Brain>k__BackingField
public float BaseAttackRate
public LootSpawnSlot[] LootSpawnSlots
public LootSpawnSlot[] bonusLootSlots
public float NextBeanCanAllowedTime
public bool BlockClothingOnCorpse
public bool RoamAroundHomePoint
public GameObjectRef soulReleaseEffect
public bool wasSoulReleased
public ScarecrowBrain Brain
public FamilyEnum Family
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public ScarecrowBrain get_Brain()
public void set_Brain(ScarecrowBrain value)
public FamilyEnum get_Family()
public void ServerInit()
internal void DoServerDestroy()
public void TryThink()
public void ServerThink(float delta)
public string Categorize()
public void EquipWeapon(bool skipDeployDelay)
public float EngagementRange()
public bool IsThreat(BaseEntity entity)
public bool IsTarget(BaseEntity entity)
public bool IsFriendly(BaseEntity entity)
public bool CanAttack(BaseEntity entity)
public bool IsTargetInRange(BaseEntity entity, Single& dist)
public bool CanSeeTarget(BaseEntity entity)
public bool NeedsToReload()
public bool Reload()
public float CooldownDuration()
public bool IsOnCooldown()
public bool StartAttacking(BaseEntity target)
private void Attack(BaseCombatEntity target)
public void StopAttacking()
public float GetAmmoFraction()
public BaseEntity GetBestTarget()
public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
public bool ShouldDropActiveItem()
public BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List`1<TriggerBase> triggersOnDeath)
public void Hurt(HitInfo info)
public void AttackerInfo(DeathInfo info)
}
public SceneToPrefab : MonoBehaviour {
public bool flattenHierarchy
public GameObject outputPrefab
public bool skipAllHlod
}
public SceneToPrefabTag : MonoBehaviour {
public TagType Type
public int SpecificLOD
}
public ScientistBrain : BaseAIBrain {
public int Count
public void AddStates()
public void InitializeAI()
public void OnDestroy()
public HumanNPC GetEntity()
protected void OnStateChanged()
}
public ScientistNPC : HumanNPC {
public GameObjectRef[] RadioChatterEffects
public GameObjectRef[] DeathEffects
public string deathStatName
public Vector2 IdleChatterRepeatRange
public RadioChatterType radioChatterType
public float lastAlertedTime
public void SetChatterType(RadioChatterType newType)
public void ServerInit()
public void IdleCheck()
public void QueueRadioChatter()
public bool ShotTest(float targetDist)
public void Alert()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public void PlayRadioChatter()
public void EquipWeapon(bool skipDeployDelay)
public bool IsMounted()
protected string OverrideCorpseName()
}
public Scoreboard : MonoBehaviour {
public Scoreboard instance
public RustText scoreboardTitle
public RectTransform scoreboardRootContents
public RustText scoreLimitText
public GameObject teamPrefab
public GameObject columnPrefab
public GameObject dividerPrefab
public Color localPlayerColor
public Color otherPlayerColor
public TeamColumn[] teamColumns
public GameObject[] TeamPanels
}
public ScrapTransportHelicopter : PlayerHelicopter {
private Transform searchlightEye
private BoxCollider parentTriggerCollider
private ParticleSystemContainer tailDamageLight
private ParticleSystemContainer tailDamageHeavy
private ParticleSystemContainer mainEngineDamageLight
private ParticleSystemContainer mainEngineDamageHeavy
private ParticleSystemContainer cockpitSparks
private Transform tailDamageLightEffects
private Transform mainEngineDamageLightEffects
private SoundDefinition damagedFireSoundDef
private SoundDefinition damagedFireTailSoundDef
private SoundDefinition damagedSparksSoundDef
private float pilotRotorScale
private float compassOffset
public float population
public string PASSENGER_ACHIEVEMENT
public int PASSENGER_ACHIEVEMENT_REQ_COUNT
public void ServerInit()
public void OnHealthChanged(float oldvalue, float newvalue)
public void DelayedNetworking()
public void OnFlagsChanged(Flags old, Flags next)
public float GetDamageMultiplier(BaseEntity ent)
public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
protected bool CanPushNow(BasePlayer pusher)
}
public ScrapTransportHelicopterWheelEffects : MonoBehaviour {
public WheelCollider wheelCollider
public GameObjectRef impactEffect
public float minTimeBetweenEffects
public float minDistBetweenEffects
private bool wasGrounded
private float lastEffectPlayed
private Vector3 lastCollisionPos
public void Update()
private void DoImpactEffect()
}
public ScreenBounce : BaseScreenShake {
public AnimationCurve bounceScale
public AnimationCurve bounceSpeed
public AnimationCurve bounceViewmodel
private float bounceTime
private Vector3 bounceVelocity
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public ScreenBounceFade : BaseScreenShake {
public AnimationCurve bounceScale
public AnimationCurve bounceSpeed
public AnimationCurve bounceViewmodel
public AnimationCurve distanceFalloff
public AnimationCurve timeFalloff
private float bounceTime
private Vector3 bounceVelocity
public float maxDistance
public float scale
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public ScreenFov : BaseScreenShake {
public AnimationCurve FovAdjustment
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public ScreenOverlay : PostProcessEffectSettings {
public OverlayBlendModeParameter blendMode
public FloatParameter intensity
public TextureParameter texture
public TextureParameter normals
}
public ScreenOverlayRenderer : PostProcessEffectRenderer`1<ScreenOverlay> {
private Shader overlayShader
public void Init()
public void Render(PostProcessRenderContext context)
}
public ScreenRotate : BaseScreenShake {
public AnimationCurve Pitch
public AnimationCurve Yaw
public AnimationCurve Roll
public AnimationCurve ViewmodelEffect
public float scale
public bool useViewModelEffect
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public Screenshot : SingletonComponent`1<Screenshot> {
public string screenshotPath
public int sizeMultiplier
}
public ScreenshotCamera : RustCamera`1<ScreenshotCamera> {
public List`1<ScreenshotCamera> activeScreenshotCameras
}
public ScreenSpaceRefractionParams : ValueType {
public float screenWeightDistance
public ScreenSpaceRefractionParams Default
}
public ScrollRectZoom : MonoBehaviour {
public ScrollRectEx scrollRect
public float zoom
public float max
public float min
public bool mouseWheelZoom
public float scrollAmount
public RectTransform rectTransform
public RectTransform get_rectTransform()
private void OnEnable()
public void OnScroll(PointerEventData data)
public void SetZoom(float z, bool expZoom)
}
public SearchFilterInput : MonoBehaviour {
public GameObject OpenRoot
public GameObject ClosedRoot
public RustInput InputField
}
public SearchLight : IOEntity {
public GameObject pitchObject
public GameObject yawObject
public GameObject eyePoint
public SoundPlayer turnLoop
public bool needsBuildingPrivilegeToUse
public Vector3 aimDir
public BasePlayer mountedPlayer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public int ConsumptionAmount()
public bool IsMounted()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void PlayerEnter(BasePlayer player)
public void PlayerExit()
public void MountedUpdate()
public void SetTargetAimpoint(Vector3 worldPos)
public int GetCurrentEnergy()
public void RPC_UseLight(RPCMessage msg)
public void OnKilled(HitInfo info)
public void Update()
}
public SeasonalTimedExplosive : TimedExplosive {
public RandomRendererEnable randomRenderer
}
public sedanAnimation : MonoBehaviour {
public Transform[] frontAxles
public Transform FL_shock
public Transform FL_wheel
public Transform FR_shock
public Transform FR_wheel
public Transform RL_shock
public Transform RL_wheel
public Transform RR_shock
public Transform RR_wheel
public WheelCollider FL_wheelCollider
public WheelCollider FR_wheelCollider
public WheelCollider RL_wheelCollider
public WheelCollider RR_wheelCollider
public Transform steeringWheel
public float motorForceConstant
public float brakeForceConstant
public float brakePedal
public float gasPedal
public float steering
private Rigidbody myRigidbody
public float GasLerpTime
public float SteeringLerpTime
private float wheelSpinConstant
private float shockRestingPosY
private float shockDistance
private float traceDistanceNeutralPoint
private void Start()
private void Update()
private void InputPlayer()
private void DoSteering()
private void ApplyForceAtWheels()
private void UpdateTireAnimation()
private float GetShockHeightDelta(WheelCollider wheel)
}
public SedanWheelSmoke : MonoBehaviour {
public ParticleSystem[] tireSmoke
public ParticleSystem[] tireWaterSplash
public ParticleSystem[] tireWaterSplash_Extra
public Boolean[] wheelTouching
}
public SeedInformationPanel : ItemInformationPanel {
public ItemTextValue maxHarvestsDisplay
public UIGenesDisplay GeneticsDisplay
public Text TextUnknownGenetics
public GameObject GeneticsGameObject
public ItemStatValue WaterResilience
public ItemStatValue GroundResilience
public ItemStatValue LightResilience
public ItemStatValue TemperatureResilience
}
public SeedPosInfo : MonoBehaviour {
public CanvasGroup Canvas
public Text WorldPos
public Text LevelName
public Text WorldSize
public Text Seed
}
public SeekerTarget : object {
public SeekerStrength strength
public ISeekerTargetOwner owner
private Dictionary`2<ISeekerTargetOwner, SeekerTarget> seekerTargets
public bool IsValidTarget()
public bool TryGetPosition(Vector3& result)
public void SendOwnerMessage(BaseEntity from, string message)
public SeekerTarget GetBestForPoint(Vector3 from, Vector3 forward, float maxCone, float maxDist, SeekerStrength minStrength)
public void SetSeekerTarget(ISeekerTargetOwner toAdd, SeekerStrength strength)
}
public SeekerTest : BaseEntity {
public GameObjectRef roadFlare
public bool useRoadFlares
public int numFlares
public int maxFlares
public float flareRegenTime
public float timeBetweenFlares
public Transform flareSpawnPoint
public float flareDuration
private float nextFlareRegenTime
public void ServerInit()
public void Update()
public void DoFlare()
public void ClearFlares()
public void OnEntityMessage(BaseEntity from, string msg)
public void ClearWarning()
public void DestroyShared()
public bool IsValidHomingTarget()
}
public SeekingServerProjectile : ServerProjectile {
public float courseAdjustRate
public float maxTrackDistance
public float minLockDot
public float flareLockDot
public bool autoSeek
public float swimAfter
public float launchingDuration
public float armingDuration
public float velocityRampUpTime
public Vector3 armingFinalDir
public AnimationCurve airmingDirCurve
public AnimationCurve armingVelocityCurve
public float armingVelocity
public AnimationCurve velocityCurve
public float orphanedVectorChangeRate
public SeekerTarget lockedTarget
private float nextTargetUpdateTime
private Vector3 seekingDestination
private float launchTime
private Vector3 initialDir
private bool orphanedProjectile
private Vector3 orphanedTargetVector
private Vector3 orphanedRotationAxis
public float totalArmingPhaseDuration
public float get_totalArmingPhaseDuration()
public void NotifyOrphaned()
public void UpdateTarget()
public Vector3 GetSeekingDestination()
public bool DoMovement()
public float TimeSinceArmed()
public float TimeSinceLaunch()
public void EnableBoosters()
public void DisableBoosters()
public void InitializeVelocity(Vector3 overrideVel)
private void PickNewRotationAxis()
}
public SegmentMaskPositioning : MonoBehaviour {
public PlayerModel source
public GameObject headMask
public GameObject chestMask
public GameObject legsMask
public float xOffset
}
public SeismicSensor : IOEntity {
public int MinRange
public int MaxRange
public int range
public GameObjectRef sensorPanelPrefab
private int vibrationLevel
private int holdTime
private BaseEntity[] resultBuffer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SetVibrationLevel(int value)
private void SetOff()
public void SetRange(int value)
public void RPC_SetRange(RPCMessage msg)
public int GetPassthroughAmount(int outputSlot)
public void ResetIOState()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void Notify(Vector3 position, int value)
private bool FilterOutSensors(BaseEntity entity)
}
public SelectedBlueprint : SingletonComponent`1<SelectedBlueprint> {
public ItemBlueprint blueprint
public InputField craftAmountText
public GameObject ingredientGrid
public IconSkinPicker skinPicker
public Image iconImage
public RustText titleText
public RustText descriptionText
public CanvasGroup CraftArea
public Button CraftButton
public RustText CraftingTime
public RustText CraftingAmount
public GameObject TutorialCraftButtonHighlight
public Sprite FavouriteOnSprite
public Sprite FavouriteOffSprite
public Image FavouriteButtonStatusMarker
public GameObject[] workbenchReqs
private ItemInformationPanel[] informationPanels
public bool isOpen
public bool get_isOpen()
}
public SelectedContact : SingletonComponent`1<SelectedContact> {
public RustText nameText
public RustText seenText
public RawImage mugshotImage
public Texture2D unknownMugshot
public InputField noteInput
public GameObject[] relationshipTypeTags
public Phrase lastSeenPrefix
public Phrase nowPhrase
public Phrase agoSuffix
public RustButton FriendlyButton
public RustButton SeenButton
public RustButton EnemyButton
public RustButton chatMute
}
public SelectedItem : SingletonComponent`1<SelectedItem> {
public Phrase DropTitle
public Phrase DropDesc
public Image icon
public Image iconSplitter
public RustText title
public RustText description
public GameObject splitPanel
public GameObject itemProtection
public GameObject menuOption
public GameObject optionsParent
public GameObject innerPanelContainer
}
public SelfCheck : object {
public bool Run()
private bool Failed(string Message)
private bool TestRustNative()
private bool RustNative_VersionCheck(int version)
}
public SellOrderEntry : MonoBehaviour {
public VirtualItemIcon MerchandiseIcon
public VirtualItemIcon CurrencyIcon
private ItemDefinition merchandiseInfo
private ItemDefinition currencyInfo
public GameObject buyButton
public GameObject cantaffordNotification
public GameObject outOfStockNotification
private IVendingMachineInterface vendingPanel
public UIIntegerEntry intEntry
public VendingPriceMultiplierWidget priceMultiplier
}
public SendMessageToEntityOnAnimationFinish : StateMachineBehaviour {
public string messageToSendToEntity
public float repeatRate
private float lastMessageSent
public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public SeparableSSS : object {
private Vector3 Gaussian(float variance, float r, Color falloffColor)
private Vector3 Profile(float r, Color falloffColor)
public void CalculateKernel(Color[] target, int targetStart, int targetSize, Color subsurfaceColor, Color falloffColor)
}
public ServerBrowser : MonoBehaviour {
public string orderBy
public RustButton cacheBrowserToggle
public RustButton filterTutorialButton
}
public ServerBrowserCategory : MonoBehaviour {
public LocalizeText serverCountText
}
public ServerBrowserEx : object {
public string GetPingString(ServerInfo server)
}
public ServerBrowserInfo : SingletonComponent`1<ServerBrowserInfo> {
public bool isMain
public Text serverName
public Text serverMeta
public Text serverText
public Button viewWebpage
public Button refresh
public Nullable`1<ServerInfo> currentServer
public HttpImage headerImage
public HttpImage logoImage
}
public ServerBrowserInfoNexus : SingletonComponent`1<ServerBrowserInfoNexus> {
public GameObject loadingIndicator
public GameObject errorIndicator
public GameObject errorGenericText
public GameObject errorSteamAuthNullText
public RustText serverName
public RustText serverDesc
public RustText playerCount
public RustText zoneCount
public RustText lastWiped
public HttpImage coverImage
public HttpImage logoImage
public UINexusMapWidget mapWidget
public FlexTransition zoneListReveal
public RectTransform zoneListParent
public GameObjectRef zoneListItem
public RustButton joinServer
public RustButton viewWebpage
}
public ServerBrowserInfoNexusZone : MonoBehaviour {
public RustButton button
public GameObject checkbox
public GameObject checkboxIndicator
public RectTransform currentServerIndicator
public RustText zoneName
public RustText ping
public RustText playerCount
}
public ServerBrowserItem : MonoBehaviour {
public TextMeshProUGUI serverName
public RustFlexText mapName
public TextMeshProUGUI playerCount
public TextMeshProUGUI ping
public TextMeshProUGUI pendingPing
public Toggle favourited
public ServerBrowserTagList serverTagList
}
public ServerBrowserItemNexus : MonoBehaviour {
public TextMeshProUGUI serverName
public RustFlexText mapName
public TextMeshProUGUI playerCount
public Toggle favourited
public ServerBrowserTagList serverTagList
public TextMeshProUGUI changeset
}
public ServerBrowserList : ServerBrowserListBase {
public bool startActive
public Transform listTransform
public int refreshOrder
public bool UseOfficialServers
public VirtualScroll VirtualScroll
public Rules[] rules
public bool hideOfficialServers
public bool excludeEmptyServersUsingQuery
public bool alwaysIncludeEmptyServers
public bool clampPlayerCountsToTrustedValues
private String[] pingStrings
public QueryType queryType
public string VersionTag
public ServerKeyvalues[] keyValues
public int GetItemCount()
public void OnVisualUpdate(int i, GameObject obj)
public void SetItemData(int i, GameObject obj)
}
public ServerBrowserListBase : BaseMonoBehaviour {
public ServerBrowserCategory categoryButton
public string sortOrder
}
public ServerBrowserListNexus : ServerBrowserListBase {
public VirtualScroll VirtualScroll
}
public ServerBrowserTag : MonoBehaviour {
public string serverTag
private string _tag
public RustButton button
public string CompactTag
public bool IsActive
public string get_CompactTag()
public bool get_IsActive()
public bool ContainsTag(HashSet`1<string> tags)
}
public ServerBrowserTagFilters : MonoBehaviour {
public UnityEvent TagFiltersChanged
private ServerBrowserTagGroup[] _groups
private List`1<bool> _previousState
public void Start()
public void DeselectAll()
public void GetTags(List`1& searchTagGroups, HashSet`1& excludeTags)
private void <Start>b__3_0()
}
public ServerBrowserTagGroup : MonoBehaviour {
public bool isExclusive
public ServerBrowserTag[] tags
private void Initialize()
public void Awake()
public bool AnyActive()
public void Refresh(HashSet`1<string> serverTags, Int32& tagsEnabled, int maxTags)
}
public ServerBrowserTagList : MonoBehaviour {
public int maxTagsToShow
private ServerBrowserTagGroup[] _groups
private void Initialize()
public void Awake()
public bool Refresh(HashSet`1<string> serverTags)
}
public ServerBuildingManager : BuildingManager {
private int decayTickBuildingIndex
private int decayTickEntityIndex
private int decayTickWorldIndex
private int navmeshCarveTickBuildingIndex
private UInt32 maxBuildingID
public void CheckSplit(DecayEntity ent)
private bool ShouldSplit(Building building)
private void Split(Building building)
public void CheckMerge(DecayEntity ent)
private void Merge(Building building1, Building building2)
public void Cycle()
public void UpdateNavMeshCarver(Building building, Int32& ticks, int i)
public UInt32 NewBuildingID()
public void LoadBuildingID(UInt32 id)
protected Building CreateBuilding(UInt32 id)
protected void DisposeBuilding(Building& building)
}
public ServerConsole : SingletonComponent`1<ServerConsole> {
private ConsoleWindow console
private ConsoleInput input
private float nextUpdate
private bool consoleEnabled
private DateTime currentGameTime
private int currentPlayerCount
private int maxPlayerCount
private int currentEntityCount
private int currentSleeperCount
private bool get_consoleEnabled()
public void OnEnable()
private void OnDisable()
private void OnInputText(string obj)
public void PrintColoured(Object[] objects)
private void HandleLog(string message, string stackTrace, LogType type)
private void Update()
private void UpdateStatus()
private DateTime get_currentGameTime()
private int get_currentPlayerCount()
private int get_maxPlayerCount()
private int get_currentEntityCount()
private int get_currentSleeperCount()
}
public ServerGib : BaseCombatEntity {
public GameObject _gibSource
public string _gibName
public PhysicMaterial physicsMaterial
public bool useContinuousCollision
private MeshCollider meshCollider
private Rigidbody rigidBody
public float BoundsPadding()
public List`1<ServerGib> CreateGibs(string entityToCreatePath, GameObject creator, GameObject gibSource, Vector3 inheritVelocity, float spreadVelocity)
public void Save(SaveInfo info)
public MeshCollider GetCollider()
public void ServerInit()
public void RemoveMe()
public void PhysicsInit(Mesh physicsMesh)
}
public ServerHistory : MonoBehaviour {
public ServerHistoryItem prefab
public GameObject panelList
internal IServerQuery Request
}
public ServerHistoryItem : MonoBehaviour {
private ServerInfo serverInfo
public Text serverName
public Text players
public Text lastJoinDate
public UInt32 order
}
public ServerMgr : SingletonComponent`1<ServerMgr> {
public string BYPASS_PROCEDURAL_SPAWN_PREF
private ConnectionAuth auth
private bool <runFrameUpdate>k__BackingField
public UserPersistance persistance
public PlayerStateManager playerStateManager
private QueueType aiTick
private Stopwatch methodTimer
private Stopwatch updateTimer
private List`1<ulong> bannedPlayerNotices
private string _AssemblyHash
public IEnumerator restartCoroutine
public ConnectionQueue connectionQueue
public TimeAverageValueLookup`1<Type> packetHistory
public TimeAverageValueLookup`1<UInt32> rpcHistory
private Stopwatch timer
public bool runFrameUpdate
public int AvailableSlots
private string AssemblyHash
public bool Restarting
public bool get_runFrameUpdate()
private void set_runFrameUpdate(bool value)
public bool Initialize(bool loadSave, string saveFile, bool allowOutOfDateSaves, bool skipInitialSpawn)
public void OpenConnection()
private void CloseConnection()
private void OnDisable()
private void OnApplicationQuit()
private void CreateImportantEntities()
public void CreateImportantEntity(string prefabName)
private void StartSteamServer()
private void UpdateItemDefinitions()
internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)
public int get_AvailableSlots()
private void Update()
private void LateUpdate()
private void FixedUpdate()
private void DoTick()
private void DoHeartbeat()
private string get_AssemblyHash()
private BaseGameMode Gamemode()
public string GamemodeName()
public string GamemodeTitle()
private void UpdateServerInformation()
public void OnDisconnected(string strReason, Connection connection)
public void OnEnterVisibility(Connection connection, Group group)
public void OnLeaveVisibility(Connection connection, Group group)
public SpawnPoint FindSpawnPoint(BasePlayer forPlayer)
public void JoinGame(Connection connection)
public bool get_Restarting()
internal void Shutdown()
private IEnumerator ServerRestartWarning(string info, int iSeconds)
public void RestartServer(string strNotice, int iSeconds)
public void SendReplicatedVars(string filter)
public void SendReplicatedVars(Connection connection)
private void OnReplicatedVarChanged(string fullName, string value)
private void Log(Exception e)
public void OnNetworkMessage(Message packet)
public void ProcessUnhandledPacket(Message packet)
public void ReadDisconnectReason(Message packet)
private BasePlayer SpawnPlayerSleeping(Connection connection)
public BasePlayer SpawnNewPlayer(Connection connection)
private void ClientReady(Message packet)
private void OnRPCMessage(Message packet)
private void OnPlayerTick(Message packet)
private void OnPlayerVoice(Message packet)
private void OnGiveUserInformation(Message packet)
}
public ServerPerformance : BaseMonoBehaviour {
public ulong deaths
public ulong spawns
public ulong position_changes
private string fileName
private int lastFrame
private void Start()
private void WriteLine()
public void DoReport()
public string WorkoutPrefabName(GameObject obj)
public void ComponentReport(string filename, string Title, Object[] objects)
}
public ServerPlayers : object {
private HashSet`1<ulong> OnlineUserIdSet
private int _currentFrame
public bool IsOnline(ulong userId)
public void GetAll(List`1<ulong> userIds)
private void RebuildIfNecessary()
}
public ServerProjectile : EntityComponent`1<BaseEntity> {
public Vector3 initialVelocity
public float drag
public float gravityModifier
public float speed
public float scanRange
public Vector3 swimScale
public Vector3 swimSpeed
public float radius
public bool IgnoreAI
public bool impacted
public float swimRandom
private Vector3 <CurrentVelocity>k__BackingField
public bool HasRangeLimit
protected int mask
public Vector3 CurrentVelocity
public bool get_HasRangeLimit()
public float GetMaxRange(float maxFuseTime)
protected int get_mask()
public Vector3 get_CurrentVelocity()
public void set_CurrentVelocity(Vector3 value)
protected void FixedUpdate()
public bool ShouldSwim()
public bool DoMovement()
protected bool IsAValidHit(BaseEntity hitEnt)
protected bool IsAnIgnoredAI(BaseEntity hitEnt)
public void InitializeVelocity(Vector3 overrideVel)
}
public ServerStatistics : object {
private BasePlayer player
private Storage storage
private Dictionary`2<ulong, Storage> players
public void .ctor(BasePlayer player)
public void Init()
public void Save()
public void Add(string name, int val)
public Storage Get(ulong id)
}
public ServerStatus : ValueType {
public bool IsOnline
public RealTimeSince LastSeen
public int Players
public int MaxPlayers
public int QueuedPlayers
public bool IsFull
public bool get_IsFull()
}
public ServerUsers : object {
public Dictionary`2<ulong, User> users
public void Remove(ulong uid)
public void Set(ulong uid, UserGroup group, string username, string notes, long expiry)
public User Get(ulong uid)
public bool Is(ulong uid, UserGroup group)
public IEnumerable`1<User> GetAll(UserGroup group)
public void Clear()
public void Load()
public void Save()
public string BanListString(bool bHeader)
public string BanListStringEx()
}
public SEScreenSpaceShadows : SingletonComponent`1<SEScreenSpaceShadows> {
private CommandBuffer blendShadowsCommandBuffer
private CommandBuffer renderShadowsCommandBuffer
private Camera attachedCamera
public Light sun
public float blendStrength
public float accumulation
public float lengthFade
public float range
public float zThickness
public int samples
public float nearSampleQuality
public float traceBias
public bool stochasticSampling
public bool leverageTemporalAA
public bool bilateralBlur
public int blurPasses
public float blurDepthTolerance
}
public SetMemorySlider : MonoBehaviour {
private void Awake()
}
public SetParameterAnimatorBehaviour : StateMachineBehaviour {
public string ParameterName
public ParamType ParameterType
public float FloatValue
public bool BoolValue
public int IntValue
public Timing SetParameterTiming
public float ThresholdTiming
private float lastNormalisedTime
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller)
public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
private void SetParameter(Animator animator)
}
public SetParameterCurveAnimatorBehaviour : StateMachineBehaviour {
public string FloatParameterName
public AnimationCurve ParameterCurve
public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public SetupAppNotification : UIDialog {
public RustInput titleInput
public RustInput bodyInput
}
public Shaker : MonoBehaviour {
public float Frequency
public Vector3 PositionMagnitude
public Vector3 RotationMagnitude
public float GlobalMultiplier
}
public SharpenAndVignette : PostProcessEffectSettings {
public BoolParameter applySharpen
public FloatParameter strength
public FloatParameter clamp
public BoolParameter applyVignette
public FloatParameter sharpness
public FloatParameter darkness
}
public SharpenAndVignetteOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
}
public SharpenAndVignetteRenderer : PostProcessEffectRenderer`1<SharpenAndVignette> {
private Shader sharpenAndVigenetteShader
public void Init()
public void Render(PostProcessRenderContext context)
}
public ShopFront : StorageContainer {
public float maxUseAngle
public BasePlayer vendorPlayer
public BasePlayer customerPlayer
public GameObjectRef transactionCompleteEffect
public ItemContainer customerInventory
private bool swappingItems
private float AngleDotProduct
public ItemContainer vendorInventory
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private float get_AngleDotProduct()
public ItemContainer get_vendorInventory()
public bool TradeLocked()
public bool IsTradingPlayer(BasePlayer player)
public bool IsPlayerCustomer(BasePlayer player)
public bool IsPlayerVendor(BasePlayer player)
public bool PlayerInVendorPos(BasePlayer player)
public bool PlayerInCustomerPos(BasePlayer player)
public bool LootEligable(BasePlayer player)
public void ResetTrade()
public void CompleteTrade()
public void AcceptClicked(RPCMessage msg)
public void CancelClicked(RPCMessage msg)
public void PreServerLoad()
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
private bool CanAcceptVendorItem(Item item, int targetSlot)
private bool CanAcceptCustomerItem(Item item, int targetSlot)
public bool CanMoveFrom(BasePlayer player, Item item)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public void ReturnPlayerItems(BasePlayer player)
public void PlayerStoppedLooting(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void UpdatePlayers()
}
public ShopFrontLootPanel : LootPanel {
public Text playerLabelA
public Text playerLabelB
public GameObject confirmButton
public GameObject confirmHelp
public GameObject denyButton
public GameObject denyHelp
public GameObject waitingText
public GameObject exchangeInProgressImage
public Phrase acceptedPhrase
public Phrase noOnePhrase
}
public ShoutcastStreamer : MonoBehaviour {
public string Host
public AudioSource Source
public RadioPlaylist[] BuiltinRadios
}
public ShowIfConvarEnabled : MonoBehaviour {
public string Convar
}
public SidecarBikeChassisVisuals : BikeChassisVisuals {
private SidecarSuspensionSettings sidecarSuspension
}
public Signage : IOEntity {
public ItemDefinition RequiredHeldEntity
private List`1<ulong> editHistory
private float TextureRequestTimeout
public GameObjectRef changeTextDialog
public MeshPaintableSource[] paintableSources
public UInt32[] textureIDs
public NetworkableId NetworkID
public Type FileType
public UGCType ContentType
public List`1<ulong> EditingHistory
public BaseNetworkable UgcEntity
public UInt32[] GetContentCRCs
public bool ShouldTransferAssociatedFiles
public Vector2i TextureSize
public int TextureCount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanUpdateSign(BasePlayer player)
public bool CanUnlockSign(BasePlayer player)
public bool CanLockSign(BasePlayer player)
public void Load(LoadInfo info)
private bool HeldEntityCheck(BasePlayer player)
public UInt32[] GetTextureCRCs()
public NetworkableId get_NetworkID()
public Type get_FileType()
public UGCType get_ContentType()
public void LockSign(RPCMessage msg)
public void UnLockSign(RPCMessage msg)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public bool ShouldNetworkOwnerInfo()
public void SetTextureCRCs(UInt32[] crcs)
public List`1<ulong> get_EditingHistory()
public BaseNetworkable get_UgcEntity()
public void LogEdit(BasePlayer byPlayer)
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public string Admin_Who()
public bool get_ShouldTransferAssociatedFiles()
public int ConsumptionAmount()
public string Categorize()
public Vector2i get_TextureSize()
public int get_TextureCount()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void UpdateSign(RPCMessage msg)
public void EnsureInitialized()
private void SignDebugLog(string str)
}
public SignContent : ImageStorageEntity {
private UInt32[] textureIDs
private List`1<ulong> editHistory
protected UInt32 CrcToLoad
protected Type StorageType
public UGCType ContentType
public UInt32[] GetContentCRCs
public Type FileType
public List`1<ulong> EditingHistory
public BaseNetworkable UgcEntity
protected UInt32 get_CrcToLoad()
protected Type get_StorageType()
public UGCType get_ContentType()
public void CopyInfoFromSign(ISignage s, IUGCBrowserEntity b)
public void CopyInfoToSign(ISignage s, IUGCBrowserEntity b)
public void Save(SaveInfo info)
internal void DoServerDestroy()
public void Load(LoadInfo info)
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public Type get_FileType()
public List`1<ulong> get_EditingHistory()
public BaseNetworkable get_UgcEntity()
}
public SignPanel : MonoBehaviour {
public RawImage Image
public RectTransform ImageContainer
public RustText DisabledSignsMessage
}
public SimpleLight : IOEntity {
public void ResetIOState()
public void IOStateChanged(int inputAmount, int inputSlot)
}
public SimpleList`1 : object {
private int defaultCapacity
private T[] emptyArray
public T[] array
public int count
public T[] Array
public int Count
public int Capacity
public T Item
public T[] get_Array()
public int get_Count()
public int get_Capacity()
public void set_Capacity(int value)
public T get_Item(int index)
public void set_Item(int index, T value)
public void .ctor(int capacity)
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array)
public void EnsureCapacity(int min)
}
public SimplePrivilege : BaseEntity {
public List`1<PlayerNameID> authorizedPlayers
public Flags Flag_MaxAuths
public void ResetState()
public bool IsAuthed(BasePlayer player)
public bool IsAuthed(ulong userID)
public bool AnyAuthed()
public void Save(SaveInfo info)
public void PostSave(SaveInfo info)
public void Load(LoadInfo info)
public bool AtMaxAuthCapacity()
public void UpdateMaxAuthCapacity()
}
public SimpleShark : BaseCombatEntity {
public Vector3 destination
public float minSpeed
public float maxSpeed
public float idealDepth
public float minTurnSpeed
public float maxTurnSpeed
public float attackCooldown
public float aggroRange
public float obstacleDetectionRadius
public Animator animator
public GameObjectRef bloodCloud
public GameObjectRef corpsePrefab
private string SPEARGUN_KILL_STAT
public float forceSurfaceAmount
public bool disable
private Vector3 spawnPos
private float stoppingDistance
private float currentSpeed
private float lastStartleTime
private float startleDuration
private SimpleState[] states
private SimpleState _currentState
private bool sleeping
private List`1<Vector3> patrolPath
private BasePlayer target
private float lastSeenTargetTime
private float nextTargetSearchTime
private BasePlayer[] playerQueryResults
private float minFloorDist
private float minSurfaceDist
private float lastTimeAttacked
public float nextAttackTime
private Vector3 cachedObstacleNormal
private float cachedObstacleDistance
private float obstacleAvoidanceScale
private float obstacleDetectionRange
private float timeSinceLastObstacleCheck
public bool IsNpc
public bool get_IsNpc()
private void GenerateIdlePoints(Vector3 center, float radius, float heightOffset, float staggerOffset)
private void GenerateIdlePoints_Shrinkwrap(Vector3 center, float radius, float heightOffset, float staggerOffset)
public void ServerInit()
public void CheckSleepState()
public void Init()
private void Think(float delta)
public Vector3 WaterClamp(Vector3 point)
public bool ValidTarget(BasePlayer newTarget)
public void ClearTarget()
public void OnKilled(HitInfo hitInfo)
public void UpdateTarget(float delta)
public float TimeSinceAttacked()
public void OnAttacked(HitInfo info)
public bool HasTarget()
public BasePlayer GetTarget()
public string Categorize()
public bool CanAttack()
public void DoAttack()
public void Startle()
public bool IsStartled()
private float GetDesiredSpeed()
public float GetTurnSpeed()
private float GetCurrentSpeed()
private void UpdateObstacleAvoidance(float delta)
private void UpdateDirection(float delta)
private void UpdatePosition(float delta)
private void UpdateSpeed(float delta)
public void Update()
}
public SingleSpawn : SpawnGroup {
public bool WantsInitialSpawn()
public void FillDelay(float delay)
}
public SingleVendor : FacepunchBehaviour {
public RustText VendorName
public TmProEmojiRedirector emojiRedirector
public Transform ListingsParent
public Transform AccordionRow
public Transform AccordionChevron
public Image[] AccordionImages
public GameObjectRef VendorListingPrefab
public GameObject NoListings
public FlexTransition VendorListingsTransition
public Image OwnerImage
public RustText OwnerName
public SellOrderContainer SellOrdersContainer
private List`1<VendorListing> listings
public int COUNT_FOR_ACCORDION
public int CompareTo(SingleVendor other)
}
public SirenLight : IOEntity {
public EmissionToggle toggler
public GameObject lightObj
public float speed
public void ResetState()
}
public SkeletonProperties : ScriptableObject {
public GameObject boneReference
public BoneProperty[] bones
private Dictionary`2<UInt32, BoneProperty> quickLookup
public void OnValidate()
private void BuildDictionary()
public BoneProperty FindBone(UInt32 id)
}
public SkinnedMultiMesh : MonoBehaviour {
public bool shadowOnly
internal bool IsVisible
public bool eyesView
public Skeleton skeleton
public SkeletonSkinLod skeletonSkinLod
public List`1<Part> parts
public List`1<Part> createdParts
public long lastBuildHash
public MaterialPropertyBlock sharedPropertyBlock
public MaterialPropertyBlock hairPropertyBlock
public float skinNumber
public float meshNumber
public float hairNumber
public int skinType
public SkinSetCollection SkinCollection
private List`1<Renderer> <Renderers>k__BackingField
public List`1<Renderer> Renderers
public List`1<Renderer> get_Renderers()
}
public SkinReplacement : object {
public SkinType skinReplacementType
public GameObjectRef targetReplacement
}
public SkinSet : ScriptableObject {
public string Label
public Gradient SkinColour
public HairSetCollection HairCollection
public GameObjectRef Head
public GameObjectRef Torso
public GameObjectRef Legs
public GameObjectRef Feet
public GameObjectRef Hands
public GameObjectRef CensoredTorso
public GameObjectRef CensoredLegs
public Material HeadMaterial
public Material BodyMaterial
public Material EyeMaterial
internal Color GetSkinColor(float skinNumber)
}
public SkinSetCollection : ScriptableObject {
public SkinSet[] Skins
public int GetIndex(float MeshNumber)
public SkinSet Get(float MeshNumber)
}
public SkinViewer : FacepunchBehaviour {
private Camera cam
private Transform positionParent
private Transform modelParent
private GameObject[] lights
private SkinSetCollection skin
private float rotateResetSpeed
private float dragSpeed
private bool autoSpin
private float timeoutSeconds
private Skeleton skinViewerSkeleton
}
public SkinViewerTesting : FacepunchBehaviour {
private GameObjectRef skinViewerPrefab
private SkinViewItem[] panels
}
public SksViewmodel : MonoBehaviour {
public GameObject ShellRoot
public Animator TargetAnimator
}
public SkullTrophy : StorageContainer {
public RustText NameText
public TextProOnACircle CircleModifier
public int AngleModifierMinCharCount
public int AngleModifierMaxCharCount
public int AngleModifierMinArcAngle
public int AngleModifierMaxArcAngle
public float SunsetTime
public float SunriseTime
public RendererLOD SkullRenderer
public Material[] DaySkull
public Material[] NightSkull
public Material[] NoSkull
public Flags HasSkull
public void OnItemAddedOrRemoved(Item item, bool added)
public void Save(SaveInfo info)
}
public SkyLantern : StorageContainer {
public float gravityScale
public float travelSpeed
public float collisionRadius
public float rotationSpeed
public float randOffset
public float lifeTime
public float hoverHeight
public Transform collisionCheckPoint
private float idealAltitude
private Vector3 travelVec
private float takeOffY
public float GetNetworkTime()
public void ServerInit()
public void Ignite(Vector3 fromPos)
public void OnAttacked(HitInfo info)
public void SelfDestroy()
public bool CanIgnite()
public void UpdateIdealAltitude()
public void StartSinking()
public void FixedUpdate()
}
public Sled : BaseVehicle {
public Flags BrakeOn
public Flags OnSnow
public Flags IsGrounded
public Flags OnSand
public PhysicMaterial BrakeMaterial
public PhysicMaterial SnowMaterial
public PhysicMaterial NonSnowMaterial
public Transform CentreOfMassTransform
public Collider[] PhysicsMaterialTargets
public float InitialForceCutoff
public float InitialForceIncreaseRate
public float TurnForce
public float DirectionMatchForce
public float VerticalAdjustmentForce
public float VerticalAdjustmentAngleThreshold
public float NudgeCooldown
public float NudgeForce
public float MaxNudgeVelocity
public float DecayFrequency
public float DecayAmount
public ParticleSystemContainer TrailEffects
public SoundDefinition enterSnowSoundDef
public SoundDefinition snowSlideLoopSoundDef
public SoundDefinition dirtSlideLoopSoundDef
public AnimationCurve movementLoopGainCurve
public AnimationCurve movementLoopPitchCurve
public VehicleTerrainHandler terrainHandler
public PhysicMaterial cachedMaterial
public float initialForceScale
public TimeSince leftIce
public TimeSince lastNudge
public bool BlocksDoors
public void ServerInit()
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public void VehicleFixedUpdate()
public void UpdatePhysicsMaterial()
public void UpdateGroundedFlag()
public PhysicMaterial GetPhysicMaterial()
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public void ApplyInitialForce()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void DecayOverTime()
public bool CanPickup(BasePlayer player)
public void OnObjects(TriggerNotify trigger)
public void OnEmpty()
public bool get_BlocksDoors()
}
public SledSeat : BaseVehicleSeat {
public Transform LeftHand
public Transform RightHand
public Transform LeftFoot
public Transform RightFoot
public float MountedAnimationSpeed
}
public SleepingBag : DecayEntity {
public ulong deployerUserID
public GameObject renameDialog
public GameObject assignDialog
public float secondsBetweenReuses
public string niceName
public Vector3 spawnOffset
public RespawnType RespawnType
public bool isStatic
public bool canBePublic
public Flags IsPublicFlag
public Phrase bagLimitPhrase
public Phrase bagLimitReachedPhrase
public Phrase assignOtherBagPhrase
public Phrase assignedBagPhrase
public Phrase cannotAssignBedPhrase
public Phrase cannotMakeBedPhrase
public Phrase bedAssigningBlocked
public Phrase tutorialPhrase
public float unlockTime
public List`1<SleepingBag> sleepingBags
private bool notifyPlayerOnServerInit
private Dictionary`2<ulong, List`1<SleepingBag>> bagsPerPlayer
public float unlockSeconds
public bool IsTutorialBag
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPublic()
public float get_unlockSeconds()
public float GetUnlockSeconds(ulong playerID)
public bool ValidForPlayer(ulong playerID, bool ignoreTimers)
public Nullable`1<CanAssignBedResult> CanAssignBed(BasePlayer player, SleepingBag newBag, ulong targetPlayer, int countOffset, int maxOffset, SleepingBag ignore)
public Nullable`1<CanBuildResult> CanBuildBed(BasePlayer player, Construction construction)
public SleepingBag[] FindForPlayer(ulong playerID, bool ignoreTimers)
public void FindForPlayer(ulong playerID, bool ignoreTimers, List`1<SleepingBag> result)
public bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)
public void AddBagForPlayer(SleepingBag bag, ulong user, bool networkUpdate)
public void RemoveBagForPlayer(SleepingBag bag, ulong user)
public void OnBagChangedOwnership(SleepingBag bag, ulong oldUser)
public void ClearTutorialBagsForPlayer(ulong userId)
public int GetSleepingBagCount(ulong userId)
public bool TrySpawnPlayer(BasePlayer player, NetworkableId sleepingBag, String& errorMessage)
public bool get_IsTutorialBag()
public void SetUnlockTime(float newTime)
public bool DestroyBag(ulong userID, NetworkableId sleepingBag)
public void ResetTimersForPlayer(BasePlayer player)
public void GetSpawnPos(Vector3& pos, Quaternion& rot)
public void SetPublic(bool isPublic)
public void SetDeployedBy(BasePlayer player)
public void OnPlayerDeath(BasePlayer player)
public void SetBagTimer(SleepingBag bag, Vector3 position, SleepingBagResetReason reason, BasePlayer forPlayer)
public void ServerInit()
public void OnPlaced(BasePlayer player)
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
private void DelayedPlayerNotify()
public void PostServerLoad()
private void NotifyPlayer(ulong id)
public void DoServerDestroy()
public void Save(SaveInfo info)
public bool CanUseNetworkCache(Connection connection)
public void Rename(RPCMessage msg)
public void AssignToFriend(RPCMessage msg)
public void RPC_MakePublic(RPCMessage msg)
public void RPC_MakeBed(RPCMessage msg)
protected void PostPlayerSpawn(BasePlayer p)
public RespawnState GetRespawnState(ulong userID)
public bool IsMobile()
public string Admin_Who()
public void Load(LoadInfo info)
public bool CanPickup(BasePlayer player)
private bool <DoServerDestroy>b__59_0(SleepingBag x)
}
public SleepingBagButton : MonoBehaviour {
public GameObject TimeLockRoot
public GameObject LockRoot
public GameObject UnavailableRoot
public Tooltip unavailableTooltip
public Phrase occupied
public Phrase underwater
public Phrase noRespawnZone
public Button ClickButton
public TextMeshProUGUI BagName
public TextMeshProUGUI ZoneName
public TextMeshProUGUI LockTime
public Image Icon
public Sprite SleepingBagSprite
public Sprite BedSprite
public Sprite BeachTowelSprite
public Sprite CamperSprite
public Image CircleRim
public Image CircleFill
public Image Background
public RustButton DeleteButton
public Image ConfirmSlider
public Phrase toastHoldToUnclaimBag
}
public SleepingBagCamper : SleepingBag {
public EntityRef`1<BaseVehicleSeat> AssociatedSeat
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
protected void PostPlayerSpawn(BasePlayer p)
public void SetSeat(BaseVehicleSeat seat, bool sendNetworkUpdate)
public void Save(SaveInfo info)
public RespawnState GetRespawnState(ulong userID)
public void ServerClearBed(RPCMessage msg)
}
public SleepingBagClusterMapMarker : MonoBehaviour {
public TextMeshProUGUI CountText
public List`1<SleepingBagButton> SleepingBagButtons
public GameObject OpenRoot
public Tooltip SummaryTooltip
public Image RimImage
}
public SleepingBagMapMarker : MonoBehaviour {
public Image MapIcon
public Image SleepingBagIcon
public Sprite SleepingBagSprite
public Sprite BedSprite
public Sprite BeachTowelSprite
public Sprite CamperSprite
public Tooltip MarkerTooltip
public GameObject LockRoot
public TextMeshProUGUI LockTime
public GameObject OccupiedRoot
public Image CircleRim
public Image CircleFill
public RustButton DeleteButton
public Image ConfirmSlider
}
public SlicedGranularAudioClip : MonoBehaviour {
public AudioSource source
public AudioClip sourceClip
public AudioClip granularClip
public int sampleRate
public float grainAttack
public float grainSustain
public float grainRelease
public float grainFrequency
public int grainAttackSamples
public int grainSustainSamples
public int grainReleaseSamples
public int grainFrequencySamples
public int samplesUntilNextGrain
public List`1<Grain> grains
public List`1<int> startPositions
public int lastStartPositionIdx
public bool playOnAwake
}
public SliderCookie : MonoBehaviour {
public void OnEnable()
public void OnDisable()
private void OnSliderChanged(float v)
}
public SlidingProgressDoor : ProgressDoor {
public Vector3 openPosition
public Vector3 closedPosition
public GameObject doorObject
public TriggerVehiclePush vehiclePhysBox
private float lastEnergyTime
private float lastServerUpdateTime
public void Spawn()
public void NoEnergy()
public void AddEnergy(float amount)
public void ServerUpdate()
public void UpdateProgress()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
}
public SlotMachine : BaseMountable {
public int ForcePayoutIndex
public Transform Reel1
public Transform Reel2
public Transform Reel3
public Transform Arm
public AnimationCurve Curve
public int Reel1Spins
public int Reel2Spins
public int Reel3Spins
public int MaxReelSpins
public float SpinDuration
private int SpinResult1
private int SpinResult2
private int SpinResult3
private int SpinResultPrevious1
private int SpinResultPrevious2
private int SpinResultPrevious3
private float SpinTime
public GameObjectRef StoragePrefab
public EntityRef StorageInstance
public SoundDefinition SpinSound
public SlotMachinePayoutDisplay PayoutDisplay
public SlotMachinePayoutSettings PayoutSettings
public Transform HandIkTarget
private Flags HasScrapForSpin
private Flags IsSpinningFlag
public Material PayoutIconMaterial
public bool UseTimeOfDayAdjustedSprite
public MeshRenderer[] PulseRenderers
public float PulseSpeed
public Color PulseFrom
public Color PulseTo
private int <CurrentMultiplier>k__BackingField
private BasePlayer CurrentSpinPlayer
private bool IsSpinning
public int CurrentMultiplier
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool get_IsSpinning()
public int get_CurrentMultiplier()
private void set_CurrentMultiplier(int value)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float GetComfort()
public void Spawn()
internal void DoServerDestroy()
private int GetBettingAmount()
private void RPC_Spin(RPCMessage rpc)
private void RPC_Deposit(RPCMessage rpc)
private void CheckPayout()
private void DelayedSpinningReset()
private void CalculateSpinResults()
private int RandomSpinResult()
public void OnPlayerDismounted(BasePlayer player)
private void Server_RequestMultiplierChange(RPCMessage msg)
public void OnBettingScrapUpdated(int amount)
private bool CalculatePayout(PayoutInfo& info, Int32& bonus)
}
public SlotMachineLootPanel : LootPanel {
public Text spinsRemainingText
public Text multiplierText
public LocalizeText ScrapCostText
}
public SlotMachinePayoutDisplay : MonoBehaviour {
public GameObjectRef PayoutWidget
public RectTransform WidgetRoot
public Sprite[] FaceSprites
}
public SlotMachinePayoutSettings : ScriptableObject {
public ItemAmount SpinCost
public PayoutInfo[] Payouts
public Int32[] VirtualFaces
public IndividualPayouts[] FacePayouts
public int TotalStops
public GameObjectRef DefaultWinEffect
}
public SlotMachinePayoutWidget : MonoBehaviour {
public RustText PayoutAmount
public GameObject AnyText
public Image[] Faces
}
public SlotMachineStorage : StorageContainer {
public int Amount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPlayerValid(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
protected void OnInventoryDirty()
public void UpdateAmount(int amount)
public bool CanBeLooted(BasePlayer player)
}
public Smaa.DebugPass : Enum {
public int value__
public DebugPass Off
public DebugPass Edges
public DebugPass Weights
}
public Smaa.EdgeDetectionMethod : Enum {
public int value__
public EdgeDetectionMethod Luma
public EdgeDetectionMethod Color
public EdgeDetectionMethod Depth
}
public Smaa.MinAttribute : PropertyAttribute {
public float min
public void .ctor(float min)
}
public Smaa.PredicationPreset : object {
public float Threshold
public float Scale
public float Strength
}
public Smaa.Preset : object {
public bool DiagDetection
public bool CornerDetection
public float Threshold
public float DepthThreshold
public int MaxSearchSteps
public int MaxSearchStepsDiag
public int CornerRounding
public float LocalContrastAdaptationFactor
}
public Smaa.QualityPreset : Enum {
public int value__
public QualityPreset Low
public QualityPreset Medium
public QualityPreset High
public QualityPreset Ultra
public QualityPreset Custom
}
public Smaa.SMAA : MonoBehaviour {
public DebugPass DebugPass
public QualityPreset Quality
public EdgeDetectionMethod DetectionMethod
public bool UsePredication
public Preset CustomPreset
public PredicationPreset CustomPredicationPreset
public Shader Shader
public Texture2D AreaTex
public Texture2D SearchTex
protected Camera m_Camera
protected Preset m_LowPreset
protected Preset m_MediumPreset
protected Preset m_HighPreset
protected Preset m_UltraPreset
protected Material m_Material
public Material Material
public Material get_Material()
}
public SmartAlarm : AppIOEntity {
public Flags Flag_HasCustomMessage
public Phrase DefaultNotificationTitle
public Phrase DefaultNotificationBody
public GameObjectRef SetupNotificationDialog
public Animator Animator
private bool <Value>k__BackingField
public NotificationList _subscriptions
public string _notificationTitle
public string _notificationBody
public float _lastSentTime
public AppEntityType Type
public bool Value
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public AppEntityType get_Type()
public bool get_Value()
public void set_Value(bool value)
public bool AddSubscription(ulong steamId)
public bool RemoveSubscription(ulong steamId)
public bool HasSubscription(ulong steamId)
public void InitShared()
public void IOStateChanged(int inputAmount, int inputSlot)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
protected void OnPairedWithPlayer(BasePlayer player)
private void StartSetupNotification(RPCMessage rpc)
private void SetNotificationTextImpl(RPCMessage rpc)
}
public SmartSwitch : AppIOEntity {
public Animator ReceiverAnimator
public AppEntityType Type
public bool Value
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool WantsPower(int inputIndex)
public int ConsumptionAmount()
public AppEntityType get_Type()
public void ServerInit()
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void SetSwitch(bool wantsOn)
public void ToggleSwitch(RPCMessage msg)
public bool get_Value()
public void set_Value(bool value)
public void Unbusy()
private bool PlayerCanToggle(BasePlayer player)
}
public SmokeGrenade : TimedExplosive {
public float smokeDuration
public GameObjectRef smokeEffectPrefab
public GameObjectRef igniteSound
public SoundPlayer soundLoop
private GameObject smokeEffectInstance
public List`1<SmokeGrenade> activeGrenades
public float fieldMin
public float fieldMax
protected bool killing
public void ServerInit()
public void Explode()
public void CheckForWater()
public void FinishUp()
public void DestroyShared()
}
public SnowballGun : BaseProjectile {
public ItemDefinition OverrideProjectile
private ItemDefinition _snowballInventoryItem
private ItemDefinition _snowballAmmoItem
public ItemDefinition SnowballInventoryItem
public ItemDefinition SnowballAmmoItem
protected ItemDefinition PrimaryMagazineAmmo
protected bool CanRefundAmmo
public ItemDefinition get_SnowballInventoryItem()
public ItemDefinition get_SnowballAmmoItem()
public bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount)
protected ItemDefinition get_PrimaryMagazineAmmo()
protected bool get_CanRefundAmmo()
}
public SnowballGunProjectile : Projectile {
public float OverrideEffectScale
public GameObjectRef SnowballImpactEffect
}
public SnowEffect : WeatherEffect {
public int FadeStartDistance
public int FadeEndDistance
public int FadeFalloff
public bool Stormy
}
public SnowMachine : FogMachine {
public AdaptMeshToTerrain snowMesh
public TriggerTemperature tempTrigger
public bool MotionModeEnabled()
public void EnableFogField()
public void FinishFogging()
}
public Snowmobile : GroundVehicle {
private Transform centreOfMassTransform
private GameObjectRef itemStoragePrefab
private VisualCarWheel wheelSkiFL
private VisualCarWheel wheelSkiFR
private VisualCarWheel wheelTreadFL
private VisualCarWheel wheelTreadFR
private VisualCarWheel wheelTreadRL
private VisualCarWheel wheelTreadRR
public CarSettings carSettings
public int engineKW
public float idleFuelPerSec
public float maxFuelPerSec
public float airControlStability
public float airControlPower
public float badTerrainDrag
public ProtectionProperties riderProtection
public float hurtTriggerMinSpeed
public TriggerHurtNotChild hurtTriggerFront
public TriggerHurtNotChild hurtTriggerRear
public float minGroundFXSpeed
private SnowmobileChassisVisuals chassisVisuals
private VehicleLight[] lights
private Transform steeringLeftIK
private Transform steeringRightIK
private Transform leftFootIK
private Transform rightFootIK
private Transform starterKey
private Vector3 engineOffKeyRot
private Vector3 engineOnKeyRot
public float outsideDecayMinutes
public bool allowPassengerOnly
public bool allTerrain
private float _throttle
private float _brake
private float _mass
public Flags Flag_Slowmode
private EntityRef`1<StorageContainer> itemStorageInstance
private float cachedFuelFraction
private float FORCE_MULTIPLIER
private float _steer
public CarPhysics`1<Snowmobile> carPhysics
public VehicleTerrainHandler serverTerrainHandler
private CarWheel[] wheels
public TimeSince timeSinceLastUsed
private float DECAY_TICK_TIME
public float prevTerrainModDrag
public TimeSince timeSinceTerrainModCheck
public float ThrottleInput
public float BrakeInput
public bool IsBraking
public float SteerAngle
public float DriveWheelVelocity
public float DriveWheelSlip
public float MaxSteerAngle
public bool InSlowMode
private float Mass
public float SteerInput
public Surface OnSurface
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float get_ThrottleInput()
protected void set_ThrottleInput(float value)
public float get_BrakeInput()
protected void set_BrakeInput(float value)
public bool get_IsBraking()
public float get_SteerAngle()
public float get_DriveWheelVelocity()
public float get_DriveWheelSlip()
public float get_MaxSteerAngle()
public bool get_InSlowMode()
private void set_InSlowMode(bool value)
private float get_Mass()
public void Load(LoadInfo info)
public float GetMaxDriveForce()
public float GetMaxForwardSpeed()
public float GetThrottleInput()
public float GetBrakeInput()
public bool GetSteerModInput()
public float GetPerformanceFraction()
public float GetFuelFraction()
public bool CanBeLooted(BasePlayer player)
public void OnFlagsChanged(Flags old, Flags next)
public float get_SteerInput()
protected void set_SteerInput(float value)
public Surface get_OnSurface()
public float GetSteerInput()
public void ServerInit()
public void VehicleFixedUpdate()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
public float GetModifiedDrag()
public float MaxVelocity()
public CarWheel[] GetWheels()
public float GetWheelsMidPos()
public void Save(SaveInfo info)
public int StartingFuelUnits()
protected void OnChildAdded(BaseEntity child)
internal void DoServerDestroy()
public bool MeetsEngineRequirements()
public void AttemptMount(BasePlayer player, bool doMountChecks)
public void SnowmobileDecay()
public StorageContainer GetItemContainer()
private void UpdateClients()
public void OnEngineStartFailed()
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public void RPC_OpenFuel(RPCMessage msg)
public void RPC_OpenItemStorage(RPCMessage msg)
}
public SnowmobileAudio : GroundVehicleAudio {
private EngineAudioSet engineAudioSet
private AnimationCurve skiGainCurve
private SoundDefinition skiSlideSoundDef
private SoundDefinition skiSlideSnowSoundDef
private SoundDefinition skiSlideSandSoundDef
private SoundDefinition skiSlideGrassSoundDef
private SoundDefinition skiSlideWaterSoundDef
private AnimationCurve movementGainCurve
private SoundDefinition movementLoopDef
private SoundDefinition suspensionLurchSoundDef
private float suspensionLurchMinExtensionDelta
private float suspensionLurchMinTimeBetweenSounds
}
public SnowmobileChassisVisuals : VehicleChassisVisuals`1<Snowmobile> {
private Animator animator
private SnowmobileAudio audioScript
private TreadRenderer[] treadRenderers
private float treadSpeedMultiplier
private bool flipRightSkiExtension
private Transform leftSki
private Transform leftSkiPistonIn
private Transform leftSkiPistonOut
private Transform rightSki
private Transform rightSkiPistonIn
private Transform rightSkiPistonOut
private float skiVisualAdjust
private float treadVisualAdjust
private float skiVisualMaxExtension
private float treadVisualMaxExtension
private float wheelSizeVisualMultiplier
}
public SoccerBall : BaseCombatEntity {
private Rigidbody rigidBody
private float additionalForceMultiplier
private float upForceMultiplier
private DamageRenderer damageRenderer
private float explosionForceMultiplier
private float otherForceMultiplier
protected void OnCollisionEnter(Collision collision)
public void Hurt(HitInfo info)
}
public Socket_Base : PrefabAttribute {
public bool male
public bool maleDummy
public bool female
public bool femaleDummy
public bool femaleNoStability
public bool monogamous
public Vector3 position
public Quaternion rotation
private Type cachedType
public Vector3 selectSize
public Vector3 selectCenter
public string socketName
public SocketMod[] socketMods
public OccupiedSocketCheck[] checkOccupiedSockets
public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
public OBB GetSelectBounds(Vector3 position, Quaternion rotation)
protected Type GetIndexedType()
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool TestTarget(Target target)
public bool IsCompatible(Socket_Base socket)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
public Placement DoPlacement(Target target)
public bool CheckSocketMods(Placement placement)
}
public Socket_Free : Socket_Base {
public Vector3 idealPlacementNormal
public bool useTargetNormal
public bool blendAimAngle
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public Placement DoPlacement(Target target)
}
public Socket_Specific : Socket_Base {
public bool useFemaleRotation
public string targetSocketName
public bool blockPlacementOnChildEntities
private void OnDrawGizmos()
public bool TestTarget(Target target)
public Placement DoPlacement(Target target)
}
public Socket_Specific_Female : Socket_Base {
public int rotationDegrees
public int rotationOffset
public String[] allowedMaleSockets
public bool parentToBone
public string boneName
private void OnDrawGizmos()
private void OnDrawGizmosSelected()
public bool CanAccept(Socket_Specific socket)
public Placement DoPlacement(Target target)
}
public Socket_Terrain : Socket_Base {
public float placementHeight
public bool alignToNormal
private void OnDrawGizmos()
public bool TestTarget(Target target)
public Placement DoPlacement(Target target)
}
public SocketHandle : PrefabAttribute {
protected Type GetIndexedType()
internal void AdjustTarget(Target& target, float maxplaceDistance)
}
public SocketMod : PrefabAttribute {
public Socket_Base baseSocket
public Phrase FailedPhrase
public bool DoCheck(Placement place)
public void ModifyPlacement(Placement place)
protected Type GetIndexedType()
}
public SocketMod_AngleCheck : SocketMod {
public bool wantsAngle
public Vector3 worldNormal
public float withinDegrees
public Phrase ErrorPhrase
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_AreaCheck : SocketMod {
public Bounds bounds
public LayerMask layerMask
public bool wantsInside
private void OnDrawGizmosSelected()
public bool IsInArea(Vector3 position, Quaternion rotation, Bounds bounds, LayerMask layerMask, BaseEntity entity)
public bool DoCheck(Vector3 position, Quaternion rotation, BaseEntity entity)
public bool DoCheck(Placement place)
}
public SocketMod_Attraction : SocketMod {
public float outerRadius
public float innerRadius
public string groupName
public bool lockRotation
public bool ignoreRotationForRadiusCheck
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
public void ModifyPlacement(Placement place)
}
public SocketMod_BuildingBlock : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_EntityCheck : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public BaseEntity[] entityTypes
public bool wantsCollide
public Phrase ErrorPhrase
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_EntityType : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public BaseEntity searchType
public bool wantsCollide
public Phrase ErrorPhrase
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_EnvironmentVolume : SocketMod {
public EnvironmentType environmentNone
public bool DoCheck(Placement place)
private string GetErrorMessage(EnvironmentType blockedTypes)
}
public SocketMod_HotSpot : SocketMod {
public float spotSize
private void OnDrawGizmos()
public void ModifyPlacement(Placement place)
}
public SocketMod_InWater : SocketMod {
public bool wantsInWater
public Phrase WantsWaterPhrase
public Phrase NoWaterPhrase
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_PhysicMaterial : SocketMod {
public PhysicMaterial[] ValidMaterials
private PhysicMaterial foundMaterial
public bool DoCheck(Placement place)
}
public SocketMod_PlantCheck : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_RoadCheck : SocketMod {
public float sphereRadius
public bool wantsCollide
public LayerMask layerMask
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_SphereCheck : SocketMod {
public float sphereRadius
public LayerMask layerMask
public bool wantsCollide
public bool requireMonument
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_TerrainCheck : SocketMod {
public bool wantsInTerrain
public bool preventWorldLayerInMonuments
private void OnDrawGizmos()
public bool IsInTerrain(Vector3 vPoint, bool worldLayerInMonuments)
public bool DoCheck(Placement place)
}
public SocketMod_WaterDepth : SocketMod {
public float MinimumWaterDepth
public float MaximumWaterDepth
public bool AllowWaterVolumes
public Phrase TooDeepPhrase
public Phrase TooShallowPhrase
public bool DoCheck(Placement place)
}
public SolarPanel : IOEntity {
public Transform sunSampler
private int tickrateSeconds
public int maximalPowerOutput
public float dot_minimum
public float dot_maximum
public bool IsRootEntity()
public int MaximalPowerOutput()
public int ConsumptionAmount()
public void ServerInit()
public void SunUpdate()
public int GetPassthroughAmount(int outputSlot)
}
public Sonar.SonarObject : MonoBehaviour {
private SType sonarType
}
public Sonar.SonarSystem : FacepunchBehaviour {
private float range
private float maxDepth
private ParticleSystem sonarPS
private ParticleSystem blipPS
private SonarObject us
private Color greenBlip
private Color redBlip
private Color whiteBlip
private SoundDefinition sonarBlipSound
private GameObject sonarSoundParent
}
public Sound : MonoBehaviour {
public float volumeExponent
public SoundDefinition definition
public SoundModifier[] modifiers
public SoundSource soundSource
public AudioSource[] audioSources
private SoundFade _fade
private SoundModulation _modulation
private SoundOcclusion _occlusion
public SoundFade fade
public SoundModulation modulation
public SoundOcclusion occlusion
public SoundFade get_fade()
public SoundModulation get_modulation()
public SoundOcclusion get_occlusion()
}
public SoundClass : ScriptableObject {
public AudioMixerGroup output
public AudioMixerGroup firstPersonOutput
public bool enableOcclusion
public bool playIfOccluded
public float occlusionGain
public AudioMixerGroup occludedOutput
public int globalVoiceMaxCount
public int priority
public List`1<SoundDefinition> definitions
}
public SoundClassTest : MonoBehaviour {
public SoundClass soundClass
public float soundInterval
}
public SoundDefinition : ScriptableObject {
public GameObjectRef template
public List`1<WeightedAudioClip> weightedAudioClips
public List`1<DistanceAudioClipList> distanceAudioClips
public SoundClass soundClass
public bool defaultToFirstPerson
public bool loop
public bool randomizeStartPosition
public bool useHighQualityFades
public float volume
public float volumeVariation
public float pitch
public float pitchVariation
public bool dontVoiceLimit
public int globalVoiceMaxCount
public int localVoiceMaxCount
public float localVoiceRange
public float voiceLimitFadeOutTime
public float localVoiceDebounceTime
public bool forceOccludedPlayback
public bool enableDoppler
public float dopplerAmount
public float dopplerScale
public float dopplerAdjustmentRate
public AnimationCurve falloffCurve
public bool useCustomFalloffCurve
public AnimationCurve spatialBlendCurve
public bool useCustomSpatialBlendCurve
public AnimationCurve spreadCurve
public bool useCustomSpreadCurve
public float maxDistance
public float get_maxDistance()
public float GetLength()
public Sound Play()
public Sound Play(GameObject forGameObject)
}
public SoundFade : MonoBehaviour {
public SoundFadeHQAudioFilter hqFadeFilter
public float currentGain
public float startingGain
public float finalGain
public int sampleRate
public bool highQualityFadeCompleted
public float length
public Direction currentDirection
}
public SoundFollowCollider : MonoBehaviour {
public SoundDefinition soundDefinition
public Sound sound
public Bounds soundFollowBounds
public bool startImmediately
}
public SoundLightDialog : UIDialog {
public RustOption ColourOption
public RustOption VolumeOption
public RustOption SpeedOption
public RustOption PatternOption
public RustOption GradientOption
}
public SoundManager : SingletonComponent`1<SoundManager> {
public SoundClass defaultSoundClass
}
public SoundModifier : MonoBehaviour {
public Sound sound
}
public SoundModulation : MonoBehaviour {
private int parameterCount
}
public SoundOcclusion : MonoBehaviour {
public LayerMask occlusionLayerMask
}
public SoundPlayer : BaseMonoBehaviour {
public SoundDefinition soundDefinition
public bool playImmediately
public float minStartDelay
public float maxStartDelay
public bool debugRepeat
public bool pending
public Vector3 soundOffset
}
public SoundPlayerCull : MonoBehaviour {
public SoundPlayer soundPlayer
public float cullDistance
}
public SoundPlayerCullLODComponent : LODComponent {
public float Distance
public SoundPlayer TargetSoundPlayer
private void OnValidate()
}
public SoundRepeater : MonoBehaviour {
public float interval
public SoundPlayer player
}
public SoundSource : MonoBehaviour {
public bool handleOcclusionChecks
public LayerMask occlusionLayerMask
public List`1<OcclusionPoint> occlusionPoints
public bool isOccluded
public float occlusionAmount
public float lodDistance
public bool inRange
public void PreClientComponentCull(IPrefabProcessor p)
public bool IsSyncedToParent()
}
public SoundVoiceLimiter : MonoBehaviour {
public int maxSimultaneousSounds
}
public SpaceCheckingSpawnPoint : GenericSpawnPoint {
public bool useCustomBoundsCheckMask
public LayerMask customBoundsCheckMask
public float customBoundsCheckScale
public bool IsAvailableTo(GameObject prefab)
}
public Spawnable : MonoBehaviour {
public SpawnPopulationBase Population
private bool ForceSpawnOnly
private string ForceSpawnInfoMessage
internal UInt32 PrefabID
internal bool SpawnIndividual
internal Vector3 SpawnPosition
internal Quaternion SpawnRotation
protected void OnEnable()
protected void OnDisable()
private void Add()
private void Remove()
internal void Save(SaveInfo info)
internal void Load(LoadInfo info)
protected void OnValidate()
}
public SpawnableBoundsBlocker : MonoBehaviour {
public BlockType BlockType
public BoxCollider BoxCollider
public void ClearTrees()
}
public SpawnDistribution : object {
internal SpawnHandler Handler
public float Density
public int Count
private WorldSpaceGrid`1<int> grid
private Dictionary`2<UInt32, int> dict
private ByteQuadtree quadtree
private Vector3 origin
private Vector3 area
public void .ctor(SpawnHandler handler, Byte[] baseValues, Vector3 origin, Vector3 area)
public bool Sample(Vector3& spawnPos, Quaternion& spawnRot, bool alignToNormal, float dithering)
public bool Sample(Vector3& spawnPos, Quaternion& spawnRot, Element node, bool alignToNormal, float dithering)
public Element SampleNode()
public void AddInstance(Spawnable spawnable)
public void RemoveInstance(Spawnable spawnable)
private void UpdateCount(Spawnable spawnable, int delta)
public int GetCount(UInt32 prefabID)
public int GetCount(Vector3 position)
public float GetGridCellArea()
}
public SpawnFilter : object {
public Enum SplatType
public Enum BiomeType
public Enum TopologyAny
public Enum TopologyAll
public Enum TopologyNot
public bool Test(Vector3 worldPos)
public bool Test(float normX, float normZ)
public float GetFactor(Vector3 worldPos, bool checkPlacementMap)
public float GetFactor(float normX, float normZ, bool checkPlacementMap)
}
public SpawnGroup : BaseMonoBehaviour {
public MonumentTier Tier
public List`1<SpawnEntry> prefabs
public int maxPopulation
public int numToSpawnPerTickMin
public int numToSpawnPerTickMax
public float respawnDelayMin
public float respawnDelayMax
public bool wantsInitialSpawn
public bool temporary
public bool forceInitialSpawn
public bool preventDuplicates
public bool isSpawnerActive
public BoxCollider setFreeIfMovedBeyond
public string category
public MonumentInfo Monument
public bool fillOnSpawn
public BaseSpawnPoint[] spawnPoints
public List`1<SpawnPointInstance> spawnInstances
public LocalClock spawnClock
public int currentPopulation
public int get_currentPopulation()
public bool WantsInitialSpawn()
public bool WantsTimedSpawn()
public float GetSpawnDelta()
public float GetSpawnVariance()
protected void Awake()
protected void OnDestroy()
public void Fill()
public void Clear()
public bool HasSpawned(UInt32 prefabID)
public void SpawnInitial()
public void SpawnRepeating()
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
public void DelayedSpawn()
public void Spawn()
protected void Spawn(int numToSpawn)
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
protected GameObjectRef GetPrefab()
protected BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, Vector3& pos, Quaternion& rot)
private MonumentInfo FindMonument()
protected void OnDrawGizmos()
private int <GetPrefab>b__39_0(SpawnEntry x)
}
public SpawnHandler : SingletonComponent`1<SpawnHandler> {
public float TickInterval
public int MinSpawnsPerTick
public int MaxSpawnsPerTick
public LayerMask PlacementMask
public LayerMask PlacementCheckMask
public float PlacementCheckHeight
public LayerMask RadiusCheckMask
public float RadiusCheckDistance
public LayerMask BoundsCheckMask
public SpawnFilter CharacterSpawn
public float CharacterSpawnCutoff
public SpawnPopulationBase[] SpawnPopulations
public SpawnDistribution[] SpawnDistributions
public SpawnDistribution CharDistribution
public ListHashSet`1<ISpawnGroup> SpawnGroups
internal List`1<SpawnIndividual> SpawnIndividuals
public SpawnPopulationBase[] ConvarSpawnPopulations
public Dictionary`2<SpawnPopulationBase, SpawnDistribution> population2distribution
private bool spawnTick
public SpawnPopulationBase[] AllSpawnPopulations
protected void OnEnable()
public SpawnPoint GetSpawnPoint()
private bool GetSpawnPointStandard(SpawnPoint spawnPoint)
public void UpdateDistributions()
public void FillPopulations()
public void FillGroups()
public void FillIndividuals()
public void InitialSpawn()
public void StartSpawnTick()
private IEnumerator SpawnTick()
private IEnumerator SpawnGroupTick()
private IEnumerator SpawnIndividualTick()
public void SpawnInitial(SpawnPopulationBase population, SpawnDistribution distribution)
public void SpawnRepeating(SpawnPopulationBase population, SpawnDistribution distribution)
public GameObject Spawn(SpawnPopulationBase population, Prefab`1<Spawnable> prefab, Vector3 pos, Quaternion rot)
private GameObject Spawn(Prefab`1<Spawnable> prefab, Vector3 pos, Quaternion rot)
public bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale)
public bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask mask)
public void EnforceLimits(bool forceAll)
public void EnforceLimits(SpawnPopulationBase population, SpawnDistribution distribution)
public Spawnable[] FindAll(SpawnPopulationBase population)
public void AddRespawn(SpawnIndividual individual)
public void AddInstance(Spawnable spawnable)
public void RemoveInstance(Spawnable spawnable)
public float PlayerFraction()
public float PlayerLerp(float min, float max)
public float PlayerExcess()
public float PlayerScale(float scalar)
public void DumpReport(string filename)
public string GetReport(bool detailed)
}
public SpawnIndividual : ValueType {
public UInt32 PrefabID
public Vector3 Position
public Quaternion Rotation
public void .ctor(UInt32 prefabID, Vector3 position, Quaternion rotation)
}
public SpawnPointInstance : MonoBehaviour {
public ISpawnPointUser parentSpawnPointUser
public BaseSpawnPoint parentSpawnPoint
public void Notify()
public void Retire()
protected void OnDestroy()
}
public SpawnPointSpawnPopulation : SpawnPopulationBase {
private SpawnPointType spawnPointType
private SpawnFilter Filter
public void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
public Byte[] GetBaseMapValues(int populationRes)
public SpawnFilter GetSpawnFilter()
public int GetTargetCount(SpawnDistribution distribution)
private bool TryGetSpawnPoints(List`1& result)
}
public SpawnPopulationBase : BaseScriptableObject {
public string ResourceFolder
public GameObjectRef[] ResourceList
public bool EnforcePopulationLimits
public float SpawnRate
public bool ScaleWithServerPopulation
public Prefab`1[] Prefabs
public Int32[] numToSpawn
protected bool haveInitialized
public bool Initialize()
public float GetCurrentSpawnRate()
public void Fill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
public void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
public Byte[] GetBaseMapValues(int populationRes)
public int GetTargetCount(SpawnDistribution distribution)
public SpawnFilter GetSpawnFilter()
public void GetReportString(StringBuilder sb, bool detailed)
}
public Speargun : CrossbowWeapon {
public GameObject worldAmmoModel
public bool ForceSendMagazine(SaveInfo saveInfo)
protected bool VerifyClientAttack(BasePlayer player)
public bool CanBeUsedInWater()
}
public SphereEntity : BaseEntity {
public float currentRadius
public float lerpRadius
public float lerpSpeed
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void LerpRadiusTo(float radius, float speed)
public void UpdateScale()
public void Update()
}
public SpiderWeb : BaseCombatEntity {
public bool Fresh()
public void ServerInit()
}
public SpinnerWheel : Signage {
public Transform wheel
public float velocity
public Quaternion targetRotation
public SoundDefinition spinLoopSoundDef
public SoundDefinition spinStartSoundDef
public SoundDefinition spinAccentSoundDef
public SoundDefinition spinStopSoundDef
public float minTimeBetweenSpinAccentSounds
public float spinAccentAngleDelta
private Sound spinSound
private Modulator spinSoundGain
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool AllowPlayerSpins()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float GetMaxSpinSpeed()
public void Update_Server()
public void Update_Client()
public void Update()
private void RPC_Spin(RPCMessage rpc)
private void RPC_AnyoneSpin(RPCMessage rpc)
public bool AnyoneSpin()
}
public SpinUpWeapon : BaseProjectile {
public float timeBetweenSpinToggle
public float spinUpTime
public GameObjectRef bulletEffect
public float projectileThicknessOverride
public bool showSpinProgress
public float spinningMoveSpeedScale
public float conditionLossPerSecondSpinning
public ItemModWearable BackpackWearable
public Flags FullySpunFlag
public Flags SpinningFlag
public Flags ShootingFlag
private float lastSpinToggleTime
public ItemModWearable WearableWhileEquipped
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ItemModWearable get_WearableWhileEquipped()
public float GetOverrideProjectileThickness(Projectile projectile)
public bool IsSpinning()
public bool IsFullySpun()
public void ServerUse()
public void ServerReload()
public void ServerUse(float damageModifier, Transform originOverride, bool useBulletThickness)
public void ServerUseBase(float damageModifier, Transform originOverride)
public void SetGenericVisible(bool visible)
public void OnHeldChanged()
public void UpdateConditionLoss()
protected void OnReceivedSignalServer(Signal signal, string arg)
public void StopMainTrigger()
public void DidAttackServerside()
private void Server_SetSpinButton(RPCMessage msg)
public void SetFullySpun()
}
public SpinUpWeaponSounds : MonoBehaviour {
public SoundDefinition spinStartDef
public SoundDefinition spinReleaseDef
public SoundDefinition spinStopDef
public SoundDefinition spinLoopUnpitchedDef
public SoundDefinition spinLoopPitchedDef
public AnimationCurve spinUnpitchedGainCurve
public AnimationCurve spinPitchedGainCurve
public AnimationCurve spinPitchCurve
public AnimationCurve spinPitchedGainCurveDown
public AnimationCurve spinPitchCurveDown
public List`1<GunshotLayer> gunshotLayers
}
public Splitter : IOEntity {
public bool BlockFluidDraining
public int ConsumptionAmount()
public bool get_BlockFluidDraining()
public int GetPassthroughAmount(int outputSlot)
public bool IsRootEntity()
public void OnCircuitChanged(bool forceUpdate)
}
public SpookySpeaker : IOEntity {
public SoundPlayer soundPlayer
public float soundSpacing
public float soundSpacingRand
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void PostServerLoad()
public void UpdateHasPower(int inputAmount, int inputSlot)
public int ConsumptionAmount()
private void SetTargetState(bool state)
public void SetWantsOn(RPCMessage msg)
public void UpdateInvokes()
public void SendPlaySound()
public void DelayedOff()
}
public SprayCan : HeldEntity {
public float MaxFreeSprayDistanceFromStart
public float MaxFreeSprayStartingDistance
private SprayCanSpray_Freehand paintingLine
public Flags IsFreeSpraying
public SoundDefinition SpraySound
public GameObjectRef SkinSelectPanel
public float SprayCooldown
public float ConditionLossPerSpray
public float ConditionLossPerReskin
public GameObjectRef LinePrefab
public Color[] SprayColours
public Single[] SprayWidths
public ParticleSystem worldSpaceSprayFx
public GameObjectRef ReskinEffect
public ItemDefinition SprayDecalItem
public GameObjectRef SprayDecalEntityRef
public SteamInventoryItem FreeSprayUnlockItem
public MinMaxGradient DecalSprayGradient
public SoundDefinition SprayLoopDef
public Phrase FreeSprayNamePhrase
public Phrase FreeSprayDescPhrase
public Phrase BuildingSkinDefaultPhrase
public Phrase BuildingSkinDefaultDescPhrase
public Phrase BuildingSkinColourPhrase
public Phrase BuildingSkinColourDescPhrase
public ConstructionSkin_ColourLookup ShippingContainerColourLookup
public string ENEMY_BASE_STAT
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void BeginFreehandSpray(RPCMessage msg)
public void ClearPaintingLine(bool allowNewSprayImmediately)
public bool CanSprayFreehand(BasePlayer player)
private bool IsSprayBlockedByTrigger(Vector3 pos)
private void ChangeItemSkin(RPCMessage msg)
private bool GetEntityPrefabPath(ItemDefinition def, String& resourcePath)
private void CreateSpray(RPCMessage msg)
private void CheckAchievementPosition(Vector3 pos)
private void LoseCondition(float amount)
public void ClearBusy()
public void OnHeldChanged()
private void Server_SetBlockColourId(RPCMessage msg)
private bool CanEntityBeRespawned(BaseEntity targetEntity, SprayFailReason& reason)
public bool GetItemDefinitionForEntity(BaseEntity be, ItemDefinition& def, bool useRedirect)
internal void <ChangeItemSkin>g__SaveEntityStorage|34_0(BaseEntity baseEntity, Dictionary`2<ContainerSet, List`1<Item>> dictionary, int index)
internal void <ChangeItemSkin>g__RestoreEntityStorage|34_1(BaseEntity baseEntity, int index, Dictionary`2<ContainerSet, List`1<Item>> copy)
}
public SprayCanSkinSelect : UIDialog {
public IconSkinPicker skinPicker
}
public SprayCanSpray : DecayEntity {
private DateTime sprayTimestamp
public ulong sprayedByPlayer
public ListHashSet`1<SprayCanSpray> AllSprays
public int splashThreshold
public bool BypassInsideDecayMultiplier
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public void ApplyOutOfAuthConditionPenalty()
public void ServerInit()
internal void DoServerDestroy()
public void RainCheck()
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
private void Server_RequestWaterClear(RPCMessage msg)
public bool get_BypassInsideDecayMultiplier()
public bool Menu_WaterClear_ShowIf(BasePlayer player)
}
public SprayCanSpray_Decal : SprayCanSpray {
public DeferredDecal DecalComponent
public GameObject IconPreviewRoot
public Material DefaultMaterial
}
public SprayCanSpray_Freehand : SprayCanSpray {
public AlignedLineDrawer LineDrawer
public List`1<LinePoint> LinePoints
public Color colour
public float width
public EntityRef`1<BasePlayer> editingPlayer
public GroundWatch groundWatch
public MeshCollider meshCollider
public int MaxLinePointLength
public float SimplifyTolerance
private bool AcceptingChanges
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool get_AcceptingChanges()
public bool ShouldNetworkOwnerInfo()
public void PostServerLoad()
public void Save(SaveInfo info)
public void SetColour(Color newColour)
public void SetWidth(float lineWidth)
private void Server_AddPointMidSpray(RPCMessage msg)
public void EnableChanges(BasePlayer byPlayer)
public void TimeoutEditing()
private void Server_FinishEditing(RPCMessage msg)
public void AddInitialPoint(Vector3 atNormal)
private void UpdateGroundWatch()
public void Load(LoadInfo info)
public void CopyPoints(List`1<LinePoint> from, List`1<LinePoint> to)
public void CopyPoints(List`1<LinePoint> from, List`1<Vector3> to)
public void CopyPoints(List`1<LinePoint> from, List`1<LinePoint> to)
public void CopyPoints(List`1<LinePoint> from, List`1<LinePoint> to)
public void ResetState()
}
public SprayCanViewmodel : MonoBehaviour {
public ParticleSystem Particles
public SoundDefinition sprayLoopDef
}
public SprayDecay : Decay {
public bool ShouldDecay(BaseEntity entity)
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
}
public Sprinkler : IOEntity {
public float SplashFrequency
public Transform Eyes
public int WaterPerSplash
public float DecayPerSplash
public ItemDefinition currentFuelType
private IOEntity currentFuelSource
private HashSet`1<ISplashable> cachedSplashables
private TimeSince updateSplashableCache
private bool forceUpdateSplashables
public bool BlockFluidDraining
public bool get_BlockFluidDraining()
public int ConsumptionAmount()
public int DesiredPower(int inputIndex)
public void UpdateHasPower(int inputAmount, int inputSlot)
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
private void DoSplash()
public void SetSprinklerState(bool wantsOn)
public void TurnOn()
public void TurnOff()
public void SetFuelType(ItemDefinition def, IOEntity source)
public void Load(LoadInfo info)
}
public SpriteArcadeEntity : ArcadeEntity {
public SpriteRenderer spriteRenderer
}
public SquareBorder : MonoBehaviour {
public float Size
public Color Color
public RectTransform Top
public RectTransform Bottom
public RectTransform Left
public RectTransform Right
public Image TopImage
public Image BottomImage
public Image LeftImage
public Image RightImage
private float _lastSize
private Color _lastColor
private void Update()
}
public sRGB : object {
public Byte[] to_linear
public Byte[] to_srgb
public float linear_to_srgb(float linear)
public float srgb_to_linear(float srgb)
}
public StabilityEntity : DecayEntity {
public Phrase CancelTitle
public Phrase CancelDesc
public bool grounded
public float cachedStability
public int cachedDistanceFromGround
private List`1<Support> supports
private int stabilityStrikes
private bool dirty
public Phrase DemolishTitle
public Phrase DemolishDesc
public int demolish_seconds
public Flags DemolishFlag
public bool canBeDemolished
public StabilityCheckWorkQueue stabilityCheckQueue
public UpdateSurroundingsQueue updateSurroundingsQueue
public bool CanBeDemolished
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public void InitializeSupports()
public int DistanceFromGround(StabilityEntity ignoreEntity)
public float SupportValue(StabilityEntity ignoreEntity)
public int CachedDistanceFromGround(StabilityEntity ignoreEntity)
public float CachedSupportValue(StabilityEntity ignoreEntity)
public void StabilityCheck()
public void UpdateStability()
public void UpdateSurroundingEntities()
public void UpdateConnectedEntities()
protected void OnPhysicsNeighbourChanged()
protected void DebugNudge()
public void ServerInit()
internal void DoServerDestroy()
public bool get_CanBeDemolished()
public bool CanDemolish(BasePlayer player)
public bool IsDemolishable()
public bool HasDemolishPrivilege(BasePlayer player)
public void DoDemolish(RPCMessage msg)
public void DoImmediateDemolish(RPCMessage msg)
public void StopBeingDemolishable()
public void StartBeingDemolishable()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public StabilitySocket : Socket_Base {
public float support
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
}
public Stag : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public StagedResourceEntity : ResourceEntity {
public List`1<ResourceStage> stages
public int stage
public GameObjectRef changeStageEffect
public GameObject gibSourceTest
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
protected void OnHealthChanged()
public void UpdateNetworkStage()
private int FindBestStage()
public T GetStageComponent()
private void UpdateStage()
}
public StampClanLogo : MonoBehaviour {
public GameObject UiElement
public RawImage LogoPreview
public MeshPaintController Controller
}
public StashContainer : StorageContainer {
public Transform visuals
public float burriedOffset
public float raisedOffset
public GameObjectRef buryEffect
public float uncoverRange
public float uncoverTime
public float PlayerDetectionTickRate
private float lastToggleTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool PlayerInRange(BasePlayer ply)
public void InitShared()
public void DoOccludedCheck()
public void OnPhysicsNeighbourChanged()
private void RemoveFromNetworkRange()
private void ReturnToNetworkRange()
public void SetHidden(bool isHidden)
public void DisableNetworking()
public void Decay()
public void ServerInit()
public void PostServerLoad()
public void ToggleHidden()
public void RPC_HideStash(RPCMessage rpc)
public void OnFlagsChanged(Flags old, Flags next)
public bool IsHidden()
}
public StateErrorAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public StateFinishedAIEvent : BaseAIEvent {
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public StateLayerController : StateMachineBehaviour {
public int TargetLayer
}
public StateStatus : Enum {
public int value__
public StateStatus Running
public StateStatus Finished
public StateStatus Error
}
public StateTimer : ValueType {
public float ReleaseTime
public Action OnFinished
public bool IsActive
public void Activate(float seconds, Action onFinished)
public bool get_IsActive()
}
public StaticInstrument : BaseMountable {
public AnimatorOverrideController AnimatorOverride
public bool ShowDeployAnimation
public InstrumentKeyController KeyController
public bool ShouldSuppressHandsAnimationLayer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void Server_PlayNote(RPCMessage msg)
private void Server_StopNote(RPCMessage msg)
public bool IsInstrument()
}
public StaticMapMarker : MapMarker {
private GameObject createdMarker
}
public StaticRespawnArea : SleepingBag {
public Transform[] spawnAreas
public bool allowHostileSpawns
public bool ValidForPlayer(ulong playerID, bool ignoreTimers)
public void GetSpawnPos(Vector3& pos, Quaternion& rot)
public void SetUnlockTime(float newTime)
public float GetUnlockSeconds(ulong playerID)
}
public Stats : Enum {
public int value__
public Stats Steam
public Stats Server
public Stats Life
public Stats All
}
public StatusLightRenderer : MonoBehaviour {
public Material offMaterial
public Material onMaterial
private MaterialPropertyBlock propertyBlock
private Renderer targetRenderer
private Color lightColor
private Light targetLight
private int colorID
private int emissionID
protected void Awake()
public void SetOff()
public void SetOn()
public void SetRed()
public void SetGreen()
private Color GetColor(byte r, byte g, byte b, byte a)
private Color GetColor(byte r, byte g, byte b, byte a, float intensity)
}
public SteamDLCItem : ScriptableObject {
public Phrase dlcName
public int dlcAppID
public bool bypassLicenseCheck
public bool HasLicense(ulong steamid)
public bool CanUse(BasePlayer player)
}
public SteamFriendsList : MonoBehaviour {
public RectTransform targetPanel
public SteamUserButton userButton
public bool IncludeFriendsList
public bool IncludeRecentlySeen
public bool IncludeLastAttacker
public bool IncludeRecentlyPlayedWith
public bool ShowTeamFirst
public bool HideSteamIdsInStreamerMode
public bool IncludeContacts
public bool RefreshOnEnable
public onFriendSelectedEvent onFriendSelected
public Func`2<ulong, bool> shouldShowPlayer
}
public SteamInventory : EntityComponent`1<BasePlayer> {
private IPlayerItem[] Items
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasItem(int itemid)
private Task UpdateSteamInventory(RPCMessage msg)
}
public SteamInventoryCategory : ScriptableObject {
public bool canBeSoldToOtherUsers
public bool canBeTradedWithOtherUsers
public bool isCommodity
public Price price
public DropChance dropChance
public bool CanBeInCrates
}
public SteamInventoryItem : ScriptableObject {
public int id
public Sprite icon
public Phrase displayName
public Phrase displayDescription
public Category category
public SubCategory subcategory
public SteamInventoryCategory steamCategory
public bool isLimitedTimeOffer
public bool PreventBreakingDown
public bool IsTwitchDrop
public string itemname
public ulong workshopID
public SteamDLCItem DlcItem
public bool forceCraftableItemDesc
public ItemDefinition itemDefinition
public ItemDefinition get_itemDefinition()
public bool HasUnlocked(ulong playerId)
}
public SteamNewsSource : object {
public Story[] Stories
public IEnumerator GetStories()
}
public SteamStatistics : object {
private BasePlayer player
public Dictionary`2<string, int> intStats
private Task refresh
public void .ctor(BasePlayer p)
public void Init()
public void Save()
public void Add(string name, int var)
public int Get(string name)
}
public SteamUserButton : MonoBehaviour {
public RustText steamName
public RustText steamInfo
public RawImage avatar
public Color colorTeamOnline
public Color colorTeamOffline
public Color colorFriendOnline
public Color colorFriendOffline
public Color colorOnline
public Color colorOffline
private ulong <SteamId>k__BackingField
private string <Username>k__BackingField
public ulong SteamId
public string Username
public ulong get_SteamId()
private void set_SteamId(ulong value)
public string get_Username()
private void set_Username(string value)
}
public Stocking : LootContainer {
public ListHashSet`1<Stocking> stockings
public void ServerInit()
internal void DoServerDestroy()
public bool IsEmpty()
public void SpawnLoot()
public void PlayerStoppedLooting(BasePlayer player)
}
public StorageContainer : DecayEntity {
public Phrase LockedMessage
public Phrase InUseMessage
public int inventorySlots
public bool dropsLoot
public float dropLootDestroyPercent
public bool dropFloats
public bool isLootable
public bool isLockable
public bool isMonitorable
public string panelName
public Phrase panelTitle
public ContentsType allowedContents
public ItemDefinition allowedItem
public ItemDefinition allowedItem2
public ItemDefinition[] blockedItems
public int maxStackSize
public bool needsBuildingPrivilegeToUse
public bool mustBeMountedToUse
public SoundDefinition openSound
public SoundDefinition closeSound
public Vector3 dropPosition
public Vector3 dropVelocity
public ItemCategory onlyAcceptCategory
public bool onlyOneUser
private ItemContainer <inventory>k__BackingField
private ulong <LastLootedBy>k__BackingField
public Phrase LootPanelTitle
public ItemContainer inventory
public Transform Transform
public bool DropsLoot
public bool DropFloats
public float DestroyLootPercent
public ulong LastLootedBy
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Phrase get_LootPanelTitle()
public void ResetState()
public void OnDrawGizmos()
public ItemContainer get_inventory()
public void set_inventory(ItemContainer value)
public Transform get_Transform()
public bool get_DropsLoot()
public bool get_DropFloats()
public float get_DestroyLootPercent()
public ulong get_LastLootedBy()
public void set_LastLootedBy(ulong value)
public bool MoveAllInventoryItems(ItemContainer from)
public bool MoveAllInventoryItems(ItemContainer source, ItemContainer dest)
public void ReceiveInventoryFromItem(Item item)
public bool CanPickup(BasePlayer player)
public void OnPickedUp(Item createdItem, BasePlayer player)
public void ServerInit()
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool ItemFilter(Item item, int targetSlot)
public void CreateInventory(bool giveUID)
public void PreServerLoad()
protected void OnInventoryDirty()
public void PostServerLoad()
internal void DoServerDestroy()
private void RPC_OpenLoot(RPCMessage rpc)
public string GetPanelName()
public bool CanMoveFrom(BasePlayer player, Item item)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public bool CanBeLooted(BasePlayer player)
public void AddContainers(PlayerLoot loot)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public void DropItems(BaseEntity initiator)
public void DropItems(IItemContainerEntity containerEntity, BaseEntity initiator)
public void DropBonusItems(BaseEntity initiator, ItemContainer container)
public Vector3 GetDropPosition()
public Vector3 GetDropVelocity()
public bool ShouldDropItemsIndividually()
public void Load(LoadInfo info)
public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
public ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
public bool HasSlot(Slot slot)
public bool OccupiedCheck(BasePlayer player)
protected bool HasAttachedStorageAdaptor()
}
public StorageMonitor : AppIOEntity {
public Action`2<Item, bool> _onItemAddedRemoved
private Action`2<Item, int> _onItemAddedToStack
private Action`2<Item, int> _onItemRemovedFromStack
private Action _resetSwitchHandler
private double _lastPowerOnUpdate
public AppEntityType Type
public bool Value
public AppEntityType get_Type()
public bool get_Value()
public void set_Value(bool value)
internal void FillEntityPayload(AppEntityPayload payload)
public void Init()
public void DestroyShared()
private StorageContainer GetStorageContainer()
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
private void OnItemAddedRemoved(Item item, bool added)
private void OnItemAddedToStack(Item item, int amount)
private void OnItemRemovedFromStack(Item item, int amount)
public void OnContainerChanged()
private void ResetSwitch()
}
public StreamEx : object {
private Byte[] StaticBuffer
public void WriteToOtherStream(Stream self, Stream target)
}
public StringFirecracker : TimedExplosive {
public Rigidbody serverRigidBody
public Rigidbody clientMiddleBody
public Rigidbody[] clientParts
public SpringJoint serverClientJoint
public Transform clientFirecrackerTransform
public void InitShared()
public void CreatePinJoint()
}
public StringFormatCache : object {
private Dictionary`2<Key1, string> dict1
private Dictionary`2<Key2, string> dict2
private Dictionary`2<Key3, string> dict3
private Dictionary`2<Key4, string> dict4
public string Get(string format, string value1)
public string Get(string format, string value1, string value2)
public string Get(string format, string value1, string value2, string value3)
public string Get(string format, string value1, string value2, string value3, string value4)
}
public StringPool : object {
public Dictionary`2<UInt32, string> toString
public Dictionary`2<string, UInt32> toNumber
private bool initialized
public UInt32 closest
private void Init()
public string Get(UInt32 i)
public UInt32 Get(string str)
public UInt32 Add(string str)
}
public StripEmptyChildren : PrefabAttribute {
protected Type GetIndexedType()
}
public StripRig : MonoBehaviour {
public Transform root
public bool fromClient
public bool fromServer
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void Strip(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer)
}
public StrobeLight : IOEntity {
public float frequency
public MeshRenderer lightMesh
public Light strobeLight
private float speedSlow
private float speedMed
private float speedFast
public float burnRate
public float lifeTimeSeconds
public Flags Flag_Slow
public Flags Flag_Med
public Flags Flag_Fast
private int currentSpeed
public float GetFrequency()
public void SetStrobe(RPCMessage msg)
private void SetStrobe(bool wantsOn)
public void SetStrobeSpeed(RPCMessage msg)
public void UpdateSpeedFlags()
public void ServerEnableStrobing(bool wantsOn)
public void SelfDamage()
public void UpdateHasPower(int inputAmount, int inputSlot)
public int ConsumptionAmount()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public SubmarineAudio : MonoBehaviour {
private SoundDefinition engineStartSound
private SoundDefinition engineStopSound
private SoundDefinition engineStartFailSound
private SoundDefinition engineLoopSound
private AnimationCurve engineLoopPitchCurve
private SoundDefinition underwaterLoopDef
private SoundDefinition underwaterMovementLoopDef
private BlendedSoundLoops surfaceWaterLoops
private float surfaceWaterSoundsMaxSpeed
private SoundDefinition waterEmergeSoundDef
private SoundDefinition waterSubmergeSoundDef
private SoundDefinition activeLoopDef
private SoundDefinition footPedalSoundDef
private Transform footPedalSoundPos
private SoundDefinition steeringWheelSoundDef
private Transform steeringWheelSoundPos
private SoundDefinition heavyDamageSparksDef
private Transform heavyDamageSparksPos
private SoundDefinition flagRaise
private SoundDefinition flagLower
private GameObject dashboardAudioPoint
private SoundDefinition climbOrDiveLoopSound
private SoundDefinition torpedoFailedSound
}
public SubmarineDuo : BaseSubmarine {
private Transform steeringWheel
private Transform steeringWheelLeftGrip
private Transform steeringWheelRightGrip
private Transform leftPedal
private Transform rightPedal
private Transform driverLeftFoot
private Transform driverRightFoot
private Transform mphNeedle
private Transform fuelNeedle
private Transform waterDepthNeedle
private Transform ammoFlag
private SonarSystem sonar
private Transform torpedoTubeHatch
}
public SubmarineOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
}
public SubsurfaceProfile : ScriptableObject {
private SubsurfaceProfileTexture profileTexture
public SubsurfaceProfileData Data
private int id
public Texture2D Texture
public Vector4[] TransmissionTints
public int Id
public Texture2D get_Texture()
public Vector4[] get_TransmissionTints()
public int get_Id()
public void set_Id(int value)
private void OnEnable()
}
public SubsurfaceProfileData : ValueType {
public float ScatterRadius
public Color SubsurfaceColor
public Color FalloffColor
public Color TransmissionTint
public SubsurfaceProfileData Default
public SubsurfaceProfileData Invalid
public SubsurfaceProfileData get_Default()
public SubsurfaceProfileData get_Invalid()
}
public SubsurfaceProfileTexture : object {
public int SUBSURFACE_PROFILE_COUNT
public int MAX_SUBSURFACE_PROFILES
public int SUBSURFACE_RADIUS_SCALE
public int SUBSURFACE_KERNEL_SIZE
private HashSet`1<SubsurfaceProfile> entries
private Texture2D texture
private Vector4[] transmissionTints
private int KernelSize0
private int KernelSize1
private int KernelSize2
private int KernelTotalSize
private int Width
public Texture2D Texture
public Vector4[] TransmissionTints
public Texture2D get_Texture()
public Vector4[] get_TransmissionTints()
public void AddProfile(SubsurfaceProfile profile)
public Color Clamp(Color color, float min, float max)
private void WriteKernel(Color[]& pixels, Color[]& kernel, int id, int y, SubsurfaceProfileData& data)
private void CreateResources()
public void ReleaseResources()
}
public SubsurfaceScatteringParams : ValueType {
public bool enabled
public bool halfResolution
public float radiusScale
public SubsurfaceScatteringParams Default
}
public SunSettings : MonoBehaviour {
private Light light
private void OnEnable()
private void Update()
}
public SupplyDrop : LootContainer {
public Flags FlagNightLight
private Flags ShowParachute
public GameObject ParachuteRoot
public void ServerInit()
public void RemoveParachute()
public void MakeLootable()
private void OnCollisionEnter(Collision collision)
public void CheckNightLight()
public void OnFlagsChanged(Flags old, Flags next)
}
public SupplySignal : TimedExplosive {
public GameObjectRef smokeEffectPrefab
public GameObjectRef EntityToCreate
public GameObject smokeEffect
public void Explode()
public void FinishUp()
}
public SurveyCharge : TimedExplosive {
public GameObjectRef craterPrefab
public GameObjectRef craterPrefab_Oil
public void Explode()
}
public SurveyCrater : BaseCombatEntity {
private ResourceDispenser resourceDispenser
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void OnAttacked(HitInfo info)
public void RemoveMe()
public void AnalysisComplete(RPCMessage msg)
public float BoundsPadding()
}
public SurvivalFishTrap : WildlifeTrap {
private WaterBody cachedWaterBody
private bool bypassItemFilter
public void ServerInit()
public bool HasBait()
public void TrapThink()
public bool ItemFilter(Item item, int targetSlot)
protected bool CanAcceptItem(Item item, int slot)
}
public SwapArrows : MonoBehaviour {
public GameObject[] arrowModels
private string curAmmoType
private bool wasHidden
public void SelectArrowType(int iType)
public void HideAllArrowHeads()
public void UpdateAmmoType(ItemDefinition ammoType, bool hidden)
private void Cleanup()
public void OnDisable()
public void OnEnable()
}
public SwapKeycard : MonoBehaviour {
public GameObject[] accessLevels
public void UpdateAccessLevel(int level)
public void SetRootActive(int index)
}
public SwapRPG : MonoBehaviour {
public GameObject[] rpgModels
private string curAmmoType
public void SelectRPGType(int iType)
public void UpdateAmmoType(ItemDefinition ammoType)
private void Start()
}
public SwitchLODMaterials : MonoBehaviour {
public Material[] materialSet1
public Material[] materialSet2
}
public SynchronizedClock : object {
public List`1<TimedEvent> events
private float CurrentTime
private float get_CurrentTime()
public void Add(float delta, float variance, Action`1<UInt32> action)
public void Tick()
}
public SystemInfoEx : object {
private Boolean[] supportedRenderTextureFormats
public int systemMemoryUsed
private ulong System_GetMemoryUsage()
public int get_systemMemoryUsed()
public bool SupportsRenderTextureFormat(RenderTextureFormat format)
}
public SystemInfoGeneralText : MonoBehaviour {
public TextMeshProUGUI text
public string currentInfo
public string get_currentInfo()
protected void Update()
private long MB(long bytes)
private long MB(ulong bytes)
private int KM2(float meters)
}
public TabToggle : MonoBehaviour {
public Transform TabHolder
public Transform ContentHolder
public bool FadeIn
public bool FadeOut
public void Awake()
public void SwitchTo(Button sourceTab)
private void Hide(GameObject go)
private void Show(GameObject go)
}
public TagComponent : MonoBehaviour {
public GameObjectTag Tag
public bool HasTag(GameObjectTag tag)
public void AddTag(GameObjectTag tag)
public void RemoveTag(GameObjectTag tag)
public void SetTag(GameObjectTag tag, bool state)
}
public TagComponentEx : object {
private Dictionary`2<GameObjectTag, string> strings
public bool HasCustomTag(GameObject gameObject, GameObjectTag tag)
public bool SetCustomTag(GameObject gameObject, GameObjectTag tag, bool apply)
}
public TakeCollisionDamage : FacepunchBehaviour {
private BaseCombatEntity entity
private float minDamage
private float maxDamage
private float forceForAnyDamage
private float forceForMaxDamage
private float velocityRestorePercent
private float pendingDamage
private bool IsServer
private bool IsClient
private bool get_IsServer()
private bool get_IsClient()
protected void OnCollisionEnter(Collision collision)
protected void OnDestroy()
private void DoDamage()
}
public TargetDetectedAIEvent : BaseAIEvent {
private float <Range>k__BackingField
public float Range
public float get_Range()
public void set_Range(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public TargetLostAIEvent : BaseAIEvent {
private float <Range>k__BackingField
public float Range
public float get_Range()
public void set_Range(float value)
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public TargetTrigger : TriggerBase {
public Transform losEyes
public GameObject InterestedInObject(GameObject obj)
}
public TeamMemberElement : MonoBehaviour {
public RustText nameText
public RawImage icon
public Color onlineColor
public Color offlineColor
public Color deadColor
public Color woundedColor
public RawImage memberIcon
public RawImage leaderIcon
public RawImage deadIcon
public RawImage woundedIcon
public int teamIndex
public CanvasGroup EditButton
}
public TeamMemberMapMarker : MonoBehaviour {
public RectTransform rectTransform
public Text nameTagText
public Tooltip toolTip
public Image innerImage
}
public TeamUI : MonoBehaviour {
public Phrase invitePhrase
public RectTransform MemberPanel
public GameObject memberEntryPrefab
public TeamMemberElement[] elements
public GameObject NoTeamPanel
public GameObject TeamPanel
public GameObject LeaveTeamButton
public GameObject InviteAcceptPanel
public TextMeshProUGUI inviteText
public bool dirty
public ulong pendingTeamID
public string pendingTeamLeaderName
public GameObject teamMemberDetailsPanel
public RustText selectedTeamMemberNameText
}
public TechTreeData : ScriptableObject {
public string shortname
public int nextID
public int techTreeLevel
public SoundDefinition openSound
public SoundDefinition closeSound
private Dictionary`2<int, NodeInstance> _idToNode
private NodeInstance _entryNode
public List`1<NodeInstance> nodes
public NodeInstance GetByID(int id)
public NodeInstance GetEntryNode()
public void ClearInputs(NodeInstance node)
public void SetupInputs(NodeInstance node)
public bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)
public bool CheckChainRecursive(BasePlayer player, NodeInstance start, NodeInstance target)
public bool PlayerCanUnlock(BasePlayer player, NodeInstance node)
public bool HasPlayerUnlocked(BasePlayer player, NodeInstance node)
public void GetNodesRequiredToUnlock(BasePlayer player, NodeInstance node, List`1<NodeInstance> foundNodes)
}
public TechTreeDialog : UIDialog {
private string techTreeLevelPrefKey
private TechTreeData[] dataOptions
public float graphScale
public RustButton[] tierButtons
public GameObjectRef entryPrefab
public GameObjectRef groupPrefab
public GameObjectRef linePrefab
public RectTransform contents
public RectTransform contentParent
public TechTreeSelectedNodeUI selectedNodeUI
public float nodeSize
public float gridSize
public GameObjectRef unlockEffect
public RustText scrapCount
private Vector2 startPos
public ScrollRectZoom zoom
public TechTreeData data
private int selectedDataIndex
public TechTreeData get_data()
private int get_selectedDataIndex()
private void set_selectedDataIndex(int value)
}
public TechTreeEntry : TechTreeWidget {
public RawImage icon
public GameObject ableToUnlockBackground
public GameObject unlockedBackground
public GameObject lockedBackground
public GameObject lockOverlay
public GameObject selectedBackground
public Image radialUnlock
public float holdTime
}
public TechTreeLine : TechTreeWidget {
public RawImage center
public RawImage topLeft
public RawImage topRight
public RawImage bottomLeft
public RawImage bottomRight
public RawImage centerDotted
public RawImage topLeftDotted
public RawImage topRightDotted
public RawImage bottomLeftDotted
public RawImage bottomRightDotted
public int from
public int to
}
public TechTreeSelectedNodeUI : MonoBehaviour {
public RustText selectedTitle
public RawImage selectedIcon
public RustText selectedDescription
public RustText costText
public RustText craftingCostText
public GameObject costObject
public GameObject cantAffordObject
public GameObject unlockedObject
public GameObject unlockButton
public GameObject noPathObject
public TechTreeDialog dialog
public Color ColorAfford
public Color ColorCantAfford
public GameObject totalRequiredRoot
public RustText totalRequiredText
public ItemInformationPanel[] informationPanels
public GameObject workbenchTaxRoot
public RustText workbenchTaxText
public Tooltip workbenchTaxTooltip
}
public TechTreeWidget : BaseMonoBehaviour {
public int id
public RectTransform rectTransform
public RectTransform get_rectTransform()
}
public Telephone : ContainerIOEntity {
public int MaxPhoneNameLength
public int MaxSavedNumbers
public Transform PhoneHotspot
public Transform AnsweringMachineHotspot
public Transform[] HandsetRoots
public ItemDefinition[] ValidCassettes
public Transform ParentedHandsetTransform
public LineRenderer CableLineRenderer
public Transform CableStartPoint
public Transform CableEndPoint
public float LineDroopAmount
private Cassette <cachedCassette>k__BackingField
public PhoneController Controller
public Cassette cachedCassette
public BaseEntity ToBaseEntity
public UInt32 AnsweringMessageId
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Cassette get_cachedCassette()
private void set_cachedCassette(Cassette value)
public void Load(LoadInfo info)
public bool CanPickup(BasePlayer player)
public BaseEntity get_ToBaseEntity()
public void OnFlagsChanged(Flags old, Flags next)
public UInt32 get_AnsweringMessageId()
public void Save(SaveInfo info)
public void ServerInit()
public void PostServerLoad()
internal void DoServerDestroy()
public void ClearCurrentUser(RPCMessage msg)
public void SetCurrentUser(RPCMessage msg)
public void InitiateCall(RPCMessage msg)
public void AnswerPhone(RPCMessage msg)
private void ServerHangUp(RPCMessage msg)
public void OnCassetteInserted(Cassette c)
public void OnCassetteRemoved(Cassette c)
private bool CanAcceptItem(Item item, int targetSlot)
public void DestroyShared()
public void UpdatePhoneName(RPCMessage msg)
public void Server_RequestPhoneDirectory(RPCMessage msg)
public void Server_AddSavedNumber(RPCMessage msg)
public void Server_RemoveSavedNumber(RPCMessage msg)
public void ServerSendVoicemail(RPCMessage msg)
public void ServerPlayVoicemail(RPCMessage msg)
public void ServerStopVoicemail(RPCMessage msg)
public void ServerDeleteVoicemail(RPCMessage msg)
public int GetPassthroughAmount(int outputSlot)
}
public TelephoneManager : object {
public int MaxPhoneNumber
public int MinPhoneNumber
public int MaxConcurrentCalls
public int MaxCallLength
public Dictionary`2<int, PhoneController> allTelephones
public int maxAssignedPhoneNumber
public int GetUnusedTelephoneNumber()
public void RegisterTelephone(PhoneController t, bool checkPhoneNumber)
public void DeregisterTelephone(PhoneController t)
public PhoneController GetTelephone(int number)
public PhoneController GetRandomTelephone(int ignoreNumber)
public int GetCurrentActiveCalls()
public void GetPhoneDirectory(int ignoreNumber, int page, int perPage, PhoneDirectory directory)
public void PrintAllPhones(Arg arg)
}
public TennisArcadeGame : BaseArcadeGame {
public ArcadeEntity paddle1
public ArcadeEntity paddle2
public ArcadeEntity ball
public Transform paddle1Origin
public Transform paddle2Origin
public Transform paddle1Goal
public Transform paddle2Goal
public Transform ballSpawn
public float maxScore
public ArcadeEntity[] paddle1ScoreNodes
public ArcadeEntity[] paddle2ScoreNodes
public int paddle1Score
public int paddle2Score
public float sensitivity
public ArcadeEntity logo
public bool OnMainMenu
public bool GameActive
}
public TennisBall : SpriteArcadeEntity {
public float speed
public float maxSpeed
}
public TerrainAlphaMap : TerrainMap`1<byte> {
public Texture2D AlphaTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetAlpha(Vector3 worldPos)
public float GetAlpha(float normX, float normZ)
public float GetAlpha(int x, int z)
public void SetAlpha(Vector3 worldPos, float a)
public void SetAlpha(float normX, float normZ, float a)
public void SetAlpha(int x, int z, float a)
public void SetAlpha(int x, int z, float a, float opacity)
public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade)
public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade)
}
public TerrainAnchor : PrefabAttribute {
public float Extents
public float Offset
public float Radius
public void Apply(Single& height, Single& min, Single& max, Vector3 pos, Vector3 scale)
protected Type GetIndexedType()
}
public TerrainAnchorEx : object {
public bool ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors, Vector3& pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public bool ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors, Vector3& pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter)
public void ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors)
}
public TerrainAnchorGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementPadding
public float PlacementFade
public float PlacementDistance
public float AnchorExtentsMin
public float AnchorExtentsMax
public float AnchorOffsetMin
public float AnchorOffsetMax
}
public TerrainAnchorMode : Enum {
public int value__
public TerrainAnchorMode MinimizeError
public TerrainAnchorMode MinimizeMovement
}
public TerrainAtlasSet : ScriptableObject {
public int SplatCount
public int SplatSize
public int MaxSplatSize
public int SplatPadding
public int AtlasSize
public int RegionSize
public int SplatsPerLine
public int SourceTypeCount
public int AtlasMipCount
public String[] sourceTypeNames
public String[] sourceTypeNamesExt
public String[] sourceTypePostfix
public String[] splatNames
public Boolean[] albedoHighpass
public String[] albedoPaths
public Color[] defaultValues
public SourceMapSet[] sourceMaps
public bool highQualityCompression
public bool generateTextureAtlases
public bool generateTextureArrays
public string splatSearchPrefix
public string splatSearchFolder
public string albedoAtlasSavePath
public string normalAtlasSavePath
public string albedoArraySavePath
public string normalArraySavePath
public void CheckReset()
}
public TerrainBenchmarkScene : BenchmarkScene {
public Terrain terrain
private TerrainMeta terrainMeta
public Transform viewpointA
public Transform viewpointB
}
public TerrainBiomeMap : TerrainMap`1<byte> {
public Texture2D BiomeTexture
internal int num
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetBiomeMax(Vector3 worldPos, int mask)
public float GetBiomeMax(float normX, float normZ, int mask)
public float GetBiomeMax(int x, int z, int mask)
public int GetBiomeMaxIndex(Vector3 worldPos, int mask)
public int GetBiomeMaxIndex(float normX, float normZ, int mask)
public int GetBiomeMaxIndex(int x, int z, int mask)
public int GetBiomeMaxType(Vector3 worldPos, int mask)
public int GetBiomeMaxType(float normX, float normZ, int mask)
public int GetBiomeMaxType(int x, int z, int mask)
public float GetBiome(Vector3 worldPos, int mask)
public float GetBiome(float normX, float normZ, int mask)
public float GetBiome(int x, int z, int mask)
public void SetBiome(Vector3 worldPos, int id)
public void SetBiome(float normX, float normZ, int id)
public void SetBiome(int x, int z, int id)
public void SetBiome(Vector3 worldPos, int id, float v)
public void SetBiome(float normX, float normZ, int id, float v)
public void SetBiome(int x, int z, int id, float v)
public void SetBiomeRaw(int x, int z, Vector4 v, float opacity)
private void SetBiome(int x, int z, int id, float old_val, float new_val)
}
public TerrainBlendMap : TerrainMap`1<byte> {
public Texture2D BlendTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetAlpha(Vector3 worldPos)
public float GetAlpha(float normX, float normZ)
public float GetAlpha(int x, int z)
public void SetAlpha(Vector3 worldPos, float a)
public void SetAlpha(float normX, float normZ, float a)
public void SetAlpha(int x, int z, float a)
public void SetAlpha(int x, int z, float a, float opacity)
public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade)
public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade)
}
public TerrainCarve : TerrainModifier {
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainCheck : PrefabAttribute {
public bool Rotate
public float Extents
public bool Check(Vector3 pos)
protected Type GetIndexedType()
}
public TerrainCheckEx : object {
public bool ApplyTerrainChecks(Transform transform, TerrainCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
}
public TerrainCheckGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementPadding
public float PlacementFade
public float PlacementDistance
public float CheckExtentsMin
public float CheckExtentsMax
public bool CheckRotate
}
public TerrainCheckGeneratorVolumes : MonoBehaviour {
public float PlacementRadius
protected void OnDrawGizmosSelected()
}
public TerrainCollision : TerrainExtension {
private ListDictionary`2<Collider, List`1<Collider>> ignoredColliders
private TerrainCollider terrainCollider
public void Setup()
public void Clear()
public void Reset(Collider collider)
public bool GetIgnore(Vector3 pos, float radius)
public bool GetIgnore(RaycastHit hit)
public bool GetIgnore(Collider collider)
public void SetIgnore(Collider collider, Collider trigger, bool ignore)
protected void LateUpdate()
}
public TerrainCollisionProxy : MonoBehaviour {
public WheelCollider[] colliders
}
public TerrainCollisionTrigger : EnvironmentVolumeTrigger {
protected void OnTriggerEnter(Collider other)
protected void OnTriggerExit(Collider other)
private void UpdateCollider(Collider other, bool state)
}
public TerrainColors : TerrainExtension {
private TerrainSplatMap splatMap
private TerrainBiomeMap biomeMap
public void Setup()
public Color GetColor(Vector3 worldPos, int mask)
public Color GetColor(float normX, float normZ, int mask)
}
public TerrainConfig : ScriptableObject {
public bool CastShadows
public LayerMask GroundMask
public LayerMask WaterMask
public PhysicMaterial GenericMaterial
public PhysicMaterial WaterMaterial
public Material Material
public Material MarginMaterial
public Texture[] AlbedoArrays
public Texture[] NormalArrays
public float HeightMapErrorMin
public float HeightMapErrorMax
public float BaseMapDistanceMin
public float BaseMapDistanceMax
public float ShaderLodMin
public float ShaderLodMax
public SplatType[] Splats
private string snowMatName
private string grassMatName
private string sandMatName
private List`1<string> dirtMatNames
private List`1<string> stoneyMatNames
public Texture AlbedoArray
public Texture NormalArray
public Texture get_AlbedoArray()
public Texture get_NormalArray()
public PhysicMaterial[] GetPhysicMaterials()
public Color[] GetAridColors()
public void GetAridOverlayConstants(Color[]& color, Vector4[]& param)
public Color[] GetTemperateColors()
public void GetTemperateOverlayConstants(Color[]& color, Vector4[]& param)
public Color[] GetTundraColors()
public void GetTundraOverlayConstants(Color[]& color, Vector4[]& param)
public Color[] GetArcticColors()
public void GetArcticOverlayConstants(Color[]& color, Vector4[]& param)
public Single[] GetSplatTiling()
public float GetMaxSplatTiling()
public float GetMinSplatTiling()
public Vector3[] GetPackedUVMIX()
public GroundType GetCurrentGroundType(bool isGrounded, RaycastHit hit)
}
public TerrainDistanceMap : TerrainMap`1<byte> {
public Texture2D DistanceTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public Vector2i GetDistance(Vector3 worldPos)
public Vector2i GetDistance(float normX, float normZ)
public Vector2i GetDistance(int x, int z)
public void SetDistance(int x, int z, Vector2i v)
}
public TerrainExtension : MonoBehaviour {
public bool isInitialized
internal Terrain terrain
internal TerrainConfig config
public void Init(Terrain terrain, TerrainConfig config)
public void Setup()
public void PostSetup()
public void LogSize(object obj, ulong size)
}
public TerrainFilter : PrefabAttribute {
public SpawnFilter Filter
public bool CheckPlacementMap
public bool CheckTerrainBounds
protected void OnDrawGizmosSelected()
public bool Check(Vector3 pos)
protected Type GetIndexedType()
}
public TerrainFilterEx : object {
public bool ApplyTerrainFilters(Transform transform, TerrainFilter[] filters, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter globalFilter)
}
public TerrainFilterGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementDistance
public SpawnFilter Filter
public bool CheckPlacementMap
}
public TerrainGenerator : SingletonComponent`1<TerrainGenerator> {
public TerrainConfig config
private float HeightMapRes
private float SplatMapRes
private float BaseMapRes
public int GetHeightMapRes()
public int GetSplatMapRes()
public int GetBaseMapRes()
public GameObject CreateTerrain()
public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)
}
public TerrainHeightAdd : TerrainModifier {
public float Delta
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainHeightMap : TerrainMap`1<short> {
public Texture2D HeightTexture
public Texture2D NormalTexture
private float normY
public void Setup()
public void ApplyToTerrain()
public void GenerateTextures(bool heightTexture, bool normalTexture)
public void ApplyTextures()
public float GetHeight(Vector3 worldPos)
public float GetHeight(float normX, float normZ)
public float GetHeightFast(Vector2 uv)
public float GetHeight(int x, int z)
public float GetHeight01(Vector3 worldPos)
public float GetHeight01(float normX, float normZ)
public float GetTriangulatedHeight01(float normX, float normZ)
public float GetHeight01(int x, int z)
private float GetSrcHeight01(int x, int z)
private float GetDstHeight01(int x, int z)
public Vector3 GetNormal(Vector3 worldPos)
public Vector3 GetNormal(float normX, float normZ)
public Vector3 GetNormal(int x, int z)
private Vector3 GetNormalSobel(int x, int z)
public float GetSlope(Vector3 worldPos)
public float GetSlope(float normX, float normZ)
public float GetSlope(int x, int z)
public float GetSlope01(Vector3 worldPos)
public float GetSlope01(float normX, float normZ)
public float GetSlope01(int x, int z)
public void SetHeight(Vector3 worldPos, float height)
public void SetHeight(float normX, float normZ, float height)
public void SetHeight(int x, int z, float height)
public void SetHeight(Vector3 worldPos, float height, float opacity)
public void SetHeight(float normX, float normZ, float height, float opacity)
public void SetHeight(int x, int z, float height, float opacity)
public void AddHeight(Vector3 worldPos, float delta)
public void AddHeight(float normX, float normZ, float delta)
public void AddHeight(int x, int z, float delta)
public void LowerHeight(Vector3 worldPos, float height, float opacity)
public void LowerHeight(float normX, float normZ, float height, float opacity)
public void LowerHeight(int x, int z, float height, float opacity)
public void RaiseHeight(Vector3 worldPos, float height, float opacity)
public void RaiseHeight(float normX, float normZ, float height, float opacity)
public void RaiseHeight(int x, int z, float height, float opacity)
public void SetHeight(Vector3 worldPos, float opacity, float radius, float fade)
public void SetHeight(float normX, float normZ, float height, float opacity, float radius, float fade)
public void LowerHeight(Vector3 worldPos, float opacity, float radius, float fade)
public void LowerHeight(float normX, float normZ, float height, float opacity, float radius, float fade)
public void RaiseHeight(Vector3 worldPos, float opacity, float radius, float fade)
public void RaiseHeight(float normX, float normZ, float height, float opacity, float radius, float fade)
public void AddHeight(Vector3 worldPos, float delta, float radius, float fade)
public void AddHeight(float normX, float normZ, float delta, float radius, float fade)
}
public TerrainHeightSet : TerrainModifier {
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainMap : TerrainExtension {
internal int res
public void ApplyFilter(float normX, float normZ, float radius, float fade, Action`3<int, int, float> action)
public void ForEach(Vector3 worldPos, float radius, Action`2<int, int> action)
public void ForEach(float normX, float normZ, float normRadius, Action`2<int, int> action)
public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Action`2<int, int> action)
public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action)
public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Action`2<int, int> action)
public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action)
private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action, Vector2i min, Vector2i max)
public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action`2<int, int> action)
public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action)
public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action`2<int, int> action)
public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action)
private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action, Vector2i min, Vector2i max)
public void ForEach(int x_min, int x_max, int z_min, int z_max, Action`2<int, int> action)
public void ForEach(Action`2<int, int> action)
public int Index(float normalized)
public float Coordinate(int index)
}
public TerrainMap`1 : TerrainMap {
internal T[] src
internal T[] dst
public void Push()
public void Pop()
public IEnumerable`1<T> ToEnumerable()
public int BytesPerElement()
public long GetMemoryUsage()
public Byte[] ToByteArray()
public void FromByteArray(Byte[] dat)
}
public TerrainMargin : object {
private MaterialPropertyBlock materialPropertyBlock
public void Create()
private void Create(Vector3 position, Vector3 size, Material material)
}
public TerrainMeta : MonoBehaviour {
public Terrain terrain
public TerrainConfig config
public PaintMode paint
public PaintMode currentPaintMode
private TerrainConfig <Config>k__BackingField
private Terrain <Terrain>k__BackingField
private Transform <Transform>k__BackingField
private Vector3 <Position>k__BackingField
private Vector3 <Size>k__BackingField
private Vector3 <OneOverSize>k__BackingField
private Vector3 <HighestPoint>k__BackingField
private Vector3 <LowestPoint>k__BackingField
private float <LootAxisAngle>k__BackingField
private float <BiomeAxisAngle>k__BackingField
private TerrainData <Data>k__BackingField
private TerrainCollider <Collider>k__BackingField
private TerrainCollision <Collision>k__BackingField
private TerrainPhysics <Physics>k__BackingField
private TerrainColors <Colors>k__BackingField
private TerrainQuality <Quality>k__BackingField
private TerrainPath <Path>k__BackingField
private TerrainBiomeMap <BiomeMap>k__BackingField
private TerrainAlphaMap <AlphaMap>k__BackingField
private TerrainBlendMap <BlendMap>k__BackingField
private TerrainHeightMap <HeightMap>k__BackingField
private TerrainSplatMap <SplatMap>k__BackingField
private TerrainTopologyMap <TopologyMap>k__BackingField
private TerrainWaterMap <WaterMap>k__BackingField
private TerrainDistanceMap <DistanceMap>k__BackingField
private TerrainPlacementMap <PlacementMap>k__BackingField
private TerrainTexturing <Texturing>k__BackingField
public TerrainConfig Config
public Terrain Terrain
public Transform Transform
public Vector3 Position
public Vector3 Size
public Vector3 Center
public Vector3 OneOverSize
public Vector3 HighestPoint
public Vector3 LowestPoint
public float LootAxisAngle
public float BiomeAxisAngle
public TerrainData Data
public TerrainCollider Collider
public TerrainCollision Collision
public TerrainPhysics Physics
public TerrainColors Colors
public TerrainQuality Quality
public TerrainPath Path
public TerrainBiomeMap BiomeMap
public TerrainAlphaMap AlphaMap
public TerrainBlendMap BlendMap
public TerrainHeightMap HeightMap
public TerrainSplatMap SplatMap
public TerrainTopologyMap TopologyMap
public TerrainWaterMap WaterMap
public TerrainDistanceMap DistanceMap
public TerrainPlacementMap PlacementMap
public TerrainTexturing Texturing
public TerrainConfig get_Config()
private void set_Config(TerrainConfig value)
public Terrain get_Terrain()
private void set_Terrain(Terrain value)
public Transform get_Transform()
private void set_Transform(Transform value)
public Vector3 get_Position()
private void set_Position(Vector3 value)
public Vector3 get_Size()
private void set_Size(Vector3 value)
public Vector3 get_Center()
public Vector3 get_OneOverSize()
private void set_OneOverSize(Vector3 value)
public Vector3 get_HighestPoint()
public void set_HighestPoint(Vector3 value)
public Vector3 get_LowestPoint()
public void set_LowestPoint(Vector3 value)
public float get_LootAxisAngle()
private void set_LootAxisAngle(float value)
public float get_BiomeAxisAngle()
private void set_BiomeAxisAngle(float value)
public TerrainData get_Data()
private void set_Data(TerrainData value)
public TerrainCollider get_Collider()
private void set_Collider(TerrainCollider value)
public TerrainCollision get_Collision()
private void set_Collision(TerrainCollision value)
public TerrainPhysics get_Physics()
private void set_Physics(TerrainPhysics value)
public TerrainColors get_Colors()
private void set_Colors(TerrainColors value)
public TerrainQuality get_Quality()
private void set_Quality(TerrainQuality value)
public TerrainPath get_Path()
private void set_Path(TerrainPath value)
public TerrainBiomeMap get_BiomeMap()
private void set_BiomeMap(TerrainBiomeMap value)
public TerrainAlphaMap get_AlphaMap()
private void set_AlphaMap(TerrainAlphaMap value)
public TerrainBlendMap get_BlendMap()
private void set_BlendMap(TerrainBlendMap value)
public TerrainHeightMap get_HeightMap()
private void set_HeightMap(TerrainHeightMap value)
public TerrainSplatMap get_SplatMap()
private void set_SplatMap(TerrainSplatMap value)
public TerrainTopologyMap get_TopologyMap()
private void set_TopologyMap(TerrainTopologyMap value)
public TerrainWaterMap get_WaterMap()
private void set_WaterMap(TerrainWaterMap value)
public TerrainDistanceMap get_DistanceMap()
private void set_DistanceMap(TerrainDistanceMap value)
public TerrainPlacementMap get_PlacementMap()
private void set_PlacementMap(TerrainPlacementMap value)
public TerrainTexturing get_Texturing()
private void set_Texturing(TerrainTexturing value)
public bool OutOfBounds(Vector3 worldPos)
public bool OutOfMargin(Vector3 worldPos)
public bool OutOfMarginPlusTutorialBounds(Vector3 worldPos)
public float InnerDistToEdge2D(Vector3 worldPos)
public bool IsPointWithinTutorialBounds(Vector3 worldPos)
public bool RandomWaterPointInAnnulus(Vector3 centre, float minRadius, float maxRadius, Vector3& randomPoint)
public Vector3 RandomPointOffshore()
public Vector3 Normalize(Vector3 worldPos)
public float NormalizeX(float x)
public float NormalizeY(float y)
public float NormalizeZ(float z)
public Vector3 Denormalize(Vector3 normPos)
public float DenormalizeX(float normX)
public float DenormalizeY(float normY)
public float DenormalizeZ(float normZ)
protected void Awake()
public void Init(Terrain terrainOverride, TerrainConfig configOverride)
public void InitNoTerrain(bool createPath)
public void SetupComponents()
public void PostSetupComponents()
public void BindShaderProperties()
}
public TerrainModifier : PrefabAttribute {
public float Opacity
public float Radius
public float Fade
public void Apply(Vector3 pos, float scale)
protected void Apply(Vector3 position, float opacity, float radius, float fade)
protected Type GetIndexedType()
}
public TerrainModifierEx : object {
public void ApplyTerrainModifiers(Transform transform, TerrainModifier[] modifiers, Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyTerrainModifiers(Transform transform, TerrainModifier[] modifiers)
}
public TerrainPath : TerrainExtension {
public List`1<PathList> Roads
internal List`1<PathList> MainRoads
internal List`1<PathList> SideRoads
internal List`1<PathList> TrailRoads
public List`1<PathList> Rails
public List`1<PathList> Rivers
public List`1<PathList> Powerlines
public List`1<LandmarkInfo> Landmarks
public List`1<MonumentInfo> Monuments
public List`1<RiverInfo> RiverObjs
public List`1<LakeInfo> LakeObjs
public GameObject DungeonGridRoot
public List`1<DungeonGridInfo> DungeonGridEntrances
public List`1<DungeonGridCell> DungeonGridCells
public GameObject DungeonBaseRoot
public List`1<DungeonBaseInfo> DungeonBaseEntrances
public List`1<DungeonBaseLink> DungeonBaseLinks
public List`1<Vector3> OceanPatrolClose
public List`1<Vector3> OceanPatrolFar
public Dictionary`2<string, List`1<PowerlineNode>> wires
public void PostSetup()
public void Clear()
public T FindClosest(List`1<T> list, Vector3 pos)
public Int32[0...,0...] CreatePowerlineCostmap(UInt32& seed)
public Int32[0...,0...] CreateRoadCostmap(UInt32& seed)
public Int32[0...,0...] CreateRailCostmap(UInt32& seed)
public Int32[0...,0...] CreateBoatCostmap(float depth)
public void AddWire(PowerlineNode node)
public void CreateWires()
private void CreateWire(string name, List`1<GameObject> objects, GameObjectRef wirePrefab)
public MonumentInfo FindMonumentWithBoundsOverlap(Vector3 position)
public void AddRoad(List`1<PathList> newRoadList, bool addToMaster)
public void AddRoad(PathList newRoad, bool addToMaster)
}
public TerrainPathChildObjects : MonoBehaviour {
public bool Spline
public float Width
public float Offset
public float Fade
public Enum Splat
public Enum Topology
public InfrastructureType Type
protected void Awake()
protected void OnDrawGizmos()
}
public TerrainPathConnect : MonoBehaviour {
public InfrastructureType Type
public Point GetPathFinderPoint(int res)
}
public TerrainPhysics : TerrainExtension {
private TerrainSplatMap splat
private PhysicMaterial[] materials
public void Setup()
public PhysicMaterial GetMaterial(Vector3 worldPos)
}
public TerrainPlacement : PrefabAttribute {
public Vector3 size
public Vector3 extents
public Vector3 offset
public bool HeightMap
public bool AlphaMap
public bool WaterMap
public Enum SplatMask
public Enum BiomeMask
public Enum TopologyMask
public Texture2DRef heightmap
public Texture2DRef splatmap0
public Texture2DRef splatmap1
public Texture2DRef alphamap
public Texture2DRef biomemap
public Texture2DRef topologymap
public Texture2DRef watermap
public Texture2DRef blendmap
public void Apply(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected bool ShouldHeight()
protected bool ShouldSplat(int id)
protected bool ShouldAlpha()
protected bool ShouldBiome(int id)
protected bool ShouldTopology(int id)
protected bool ShouldWater()
protected void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected Type GetIndexedType()
}
public TerrainPlacementBlocked : TerrainModifier {
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainPlacementEx : object {
public void ApplyTerrainPlacements(Transform transform, TerrainPlacement[] placements, Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyTerrainPlacements(Transform transform, TerrainPlacement[] placements)
}
public TerrainPlacementMap : TerrainMap`1<bool> {
private bool isEnabled
public void Setup()
public void PostSetup()
public void Enable()
public void Disable()
public void Reset()
public bool GetBlocked(Vector3 worldPos)
public bool GetBlocked(float normX, float normZ)
public bool GetBlocked(int x, int z)
public void SetBlocked(Vector3 worldPos)
public void SetBlocked(float normX, float normZ)
public void SetBlocked(int x, int z)
public bool GetBlocked(Vector3 worldPos, float radius)
public bool GetBlocked(float normX, float normZ, float radius)
public void SetBlocked(Vector3 worldPos, float radius, float fade)
public void SetBlocked(float normX, float normZ, float radius, float fade)
private void <SetBlocked>b__15_0(int x, int z, float lerp)
}
public TerrainSplatMap : TerrainMap`1<byte> {
public Texture2D SplatTexture0
public Texture2D SplatTexture1
internal int num
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetSplatMax(Vector3 worldPos, int mask)
public float GetSplatMax(float normX, float normZ, int mask)
public float GetSplatMax(int x, int z, int mask)
public int GetSplatMaxIndex(Vector3 worldPos, int mask)
public int GetSplatMaxIndex(float normX, float normZ, int mask)
public int GetSplatMaxIndex(int x, int z, int mask)
public int GetSplatMaxType(Vector3 worldPos, int mask)
public int GetSplatMaxType(float normX, float normZ, int mask)
public int GetSplatMaxType(int x, int z, int mask)
public float GetSplat(Vector3 worldPos, int mask)
public float GetSplat(float normX, float normZ, int mask)
public float GetSplat(int x, int z, int mask)
public void SetSplat(Vector3 worldPos, int id)
public void SetSplat(float normX, float normZ, int id)
public void SetSplat(int x, int z, int id)
public void SetSplat(Vector3 worldPos, int id, float v)
public void SetSplat(float normX, float normZ, int id, float v)
public void SetSplat(int x, int z, int id, float v)
public void SetSplatRaw(int x, int z, Vector4 v1, Vector4 v2, float opacity)
public void SetSplat(Vector3 worldPos, int id, float opacity, float radius, float fade)
public void SetSplat(float normX, float normZ, int id, float opacity, float radius, float fade)
public void AddSplat(Vector3 worldPos, int id, float delta, float radius, float fade)
public void AddSplat(float normX, float normZ, int id, float delta, float radius, float fade)
private void SetSplat(int x, int z, int id, float old_val, float new_val)
}
public TerrainSplatSet : TerrainModifier {
public Enum SplatType
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainTexturing : TerrainExtension {
public bool debugFoliageDisplacement
private bool initialized
private TerrainTexturing instance
private int ShoreVectorDownscale
private int ShoreVectorBlurPasses
private float terrainSize
private int shoreMapSize
private float shoreDistanceScale
private Single[] shoreDistances
private Vector3[] shoreVectors
public TerrainTexturing Instance
public int ShoreMapSize
public Vector3[] ShoreMap
private void ReleaseBasePyramid()
private void UpdateBasePyramid()
private void InitializeCoarseHeightSlope()
private void ReleaseCoarseHeightSlope()
private void UpdateCoarseHeightSlope()
public TerrainTexturing get_Instance()
private void CheckInstance()
private void Awake()
public void Setup()
public void PostSetup()
private void Shutdown()
private void OnEnable()
private void OnDisable()
private void Update()
public int get_ShoreMapSize()
public Vector3[] get_ShoreMap()
private void InitializeShoreVector()
private void GenerateShoreVector()
private void ReleaseShoreVector()
private void GenerateShoreVector(Single[]& distances, Vector3[]& vectors)
public float GetCoarseDistanceToShore(Vector3 pos)
public float GetCoarseDistanceToShore(Vector2 uv)
public Vector3 GetCoarseVectorToShore(Vector3 pos)
public Vector3 GetCoarseVectorToShore(Vector2 uv)
}
public TerrainTopologyAdd : TerrainModifier {
public Enum TopologyType
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainTopologyMap : TerrainMap`1<int> {
public Texture2D TopologyTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public bool GetTopology(Vector3 worldPos, int mask)
public bool GetTopology(float normX, float normZ, int mask)
public bool GetTopology(int x, int z, int mask)
public int GetTopology(Vector3 worldPos)
public int GetTopology(float normX, float normZ)
public int GetTopologyFast(Vector2 uv)
public int GetTopology(int x, int z)
public void SetTopology(Vector3 worldPos, int mask)
public void SetTopology(float normX, float normZ, int mask)
public void SetTopology(int x, int z, int mask)
public void AddTopology(Vector3 worldPos, int mask)
public void AddTopology(float normX, float normZ, int mask)
public void AddTopology(int x, int z, int mask)
public void RemoveTopology(Vector3 worldPos, int mask)
public void RemoveTopology(float normX, float normZ, int mask)
public void RemoveTopology(int x, int z, int mask)
public int GetTopology(Vector3 worldPos, float radius)
public int GetTopology(float normX, float normZ, float radius)
public void SetTopology(Vector3 worldPos, int mask, float radius, float fade)
public void SetTopology(float normX, float normZ, int mask, float radius, float fade)
public void AddTopology(Vector3 worldPos, int mask, float radius, float fade)
public void AddTopology(float normX, float normZ, int mask, float radius, float fade)
}
public TerrainTopologySet : TerrainModifier {
public Enum TopologyType
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainWaterMap : TerrainMap`1<short> {
public Texture2D WaterTexture
private float normY
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetHeight(Vector3 worldPos)
public float GetHeight(float normX, float normZ)
public float GetHeightFast(Vector2 uv)
public float GetHeight(int x, int z)
public float GetHeight01(Vector3 worldPos)
public float GetHeight01(float normX, float normZ)
public float GetHeight01(int x, int z)
public Vector3 GetNormal(Vector3 worldPos)
public Vector3 GetNormal(float normX, float normZ)
public Vector3 GetNormalFast(Vector2 uv)
public Vector3 GetNormal(int x, int z)
public float GetSlope(Vector3 worldPos)
public float GetSlope(float normX, float normZ)
public float GetSlope(int x, int z)
public float GetSlope01(Vector3 worldPos)
public float GetSlope01(float normX, float normZ)
public float GetSlope01(int x, int z)
public float GetDepth(Vector3 worldPos)
public float GetDepth(float normX, float normZ)
public void SetHeight(Vector3 worldPos, float height)
public void SetHeight(float normX, float normZ, float height)
public void SetHeight(int x, int z, float height)
}
public TeslaCoil : IOEntity {
public TargetTrigger targetTrigger
public TriggerMovement movementTrigger
public float powerToDamageRatio
public float dischargeTickRate
public float maxDischargeSelfDamageSeconds
public float maxDamageOutput
public Transform damageEyes
public Flags Flag_WeakShorting
public Flags Flag_StrongShorting
public int powerForHeavyShorting
private float lastDischargeTime
public int ConsumptionAmount()
public int DesiredPower(int inputIndex)
public bool CanDischarge()
public void UpdateFromInput(int inputAmount, int inputSlot)
public void Discharge()
public void OnRepair()
}
public TexasHoldEmUI : MonoBehaviour {
private Image[] holeCardImages
private Image[] holeCardBackings
private Image[] communityCardImages
private Image[] communityCardBackings
private RustText potText
private CardGamePlayerWidget[] playerWidgets
private Phrase phraseWinningHand
private Phrase foldPhrase
private Phrase raisePhrase
private Phrase checkPhrase
private Phrase callPhrase
private Phrase phraseRoyalFlush
private Phrase phraseStraightFlush
private Phrase phraseFourOfAKind
private Phrase phraseFullHouse
private Phrase phraseFlush
private Phrase phraseStraight
private Phrase phraseThreeOfAKind
private Phrase phraseTwoPair
private Phrase phrasePair
private Phrase phraseHighCard
private Phrase phraseRaiseAmount
private Sprite dealerChip
private Sprite smallBlindChip
private Sprite bigBlindChip
private Sprite noIcon
}
public TextArcadeEntity : ArcadeEntity {
public TextMeshProUGUI text
}
public TextEntryCookie : MonoBehaviour {
public InputField control
public InputField get_control()
private void OnEnable()
private void OnDisable()
}
internal TextureCacheState : Enum {
public int value__
public TextureCacheState Initializing
public TextureCacheState Uncached
public TextureCacheState CachedRaw
public TextureCacheState CachedCompressed
}
public TextureColorPicker : MonoBehaviour {
public Texture2D texture
public onColorSelectedEvent onColorSelected
public void OnPointerDown(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
}
public TextureData : ValueType {
public int width
public int height
public Color32[] colors
public void .ctor(Texture2D tex)
public Color32 GetColor(int x, int y)
public int GetShort(int x, int y)
public int GetInt(int x, int y)
public float GetFloat(int x, int y)
public float GetHalf(int x, int y)
public Vector4 GetVector(int x, int y)
public Vector3 GetNormal(int x, int y)
public Color32 GetInterpolatedColor(float x, float y)
public int GetInterpolatedInt(float x, float y)
public int GetInterpolatedShort(float x, float y)
public float GetInterpolatedFloat(float x, float y)
public float GetInterpolatedHalf(float x, float y)
public Vector4 GetInterpolatedVector(float x, float y)
public Vector3 GetInterpolatedNormal(float x, float y)
}
public ThreatDetectedAIEvent : BaseAIEvent {
private float <Range>k__BackingField
public float Range
public float get_Range()
public void set_Range(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public ThrownWeapon : AttackEntity {
public GameObjectRef prefabToThrow
public float maxThrowVelocity
public float tumbleVelocity
public Vector3 overrideAngle
public bool canStick
public bool canThrowUnderwater
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
public void ServerThrow(Vector3 targetPosition)
private float GetThrowVelocity(Vector3 throwPos, Vector3 targetPos, Vector3 aimDir)
private void DoThrow(RPCMessage msg)
private void DoDrop(RPCMessage msg)
protected void SetUpThrownWeapon(BaseEntity ent)
}
public TickHistory : object {
private Deque`1<Vector3> points
public int Count
public int get_Count()
public void Reset()
public void Reset(Vector3 point)
public float Distance(BasePlayer player, Vector3 point)
public void AddPoint(Vector3 point, int limit)
public void TransformEntries(Matrix4x4 matrix)
}
public TickInterpolator : object {
private List`1<Segment> points
private int index
public float Length
public Vector3 CurrentPoint
public Vector3 StartPoint
public Vector3 EndPoint
public int Count
public int get_Count()
public void Reset()
public void Reset(Vector3 point)
public void AddPoint(Vector3 point)
public bool MoveNext(float distance)
public bool HasNext()
public void TransformEntries(Matrix4x4 matrix)
}
public TimeBasedSoundSpread : SoundModifier {
public AnimationCurve spreadCurve
public AnimationCurve wanderIntensityCurve
}
public TimeCachedValue`1 : object {
public float refreshCooldown
public float refreshRandomRange
public Func`1<T> updateValue
private T cachedValue
private TimeSince cooldown
private bool hasRun
private bool forceNextRun
public T Get(bool force)
public void ForceNextRun()
}
public TimedExplosive : BaseEntity {
public float timerAmountMin
public float timerAmountMax
public float minExplosionRadius
public float explosionRadius
public bool explodeOnContact
public bool canStick
public bool onlyDamageParent
public bool IgnoreAI
public bool BlindAI
public float aiBlindDuration
public float aiBlindRange
public GameObjectRef explosionEffect
public GameObjectRef underwaterExplosionEffect
public float underwaterExplosionDepth
public GameObjectRef watersurfaceExplosionEffect
public MinMax watersurfaceExplosionDepth
public GameObjectRef stickEffect
public GameObjectRef bounceEffect
public bool explosionUsesForward
public bool waterCausesExplosion
public int vibrationLevel
public List`1<DamageTypeEntry> damageTypes
private float lastBounceTime
private bool hadRB
private float rbMass
private float rbDrag
private float rbAngularDrag
private CollisionDetectionMode rbCollisionMode
private int parentOnlySplashDamage
private int fullSplashDamage
private BaseEntity[] queryResults
private Vector3 lastPosition
protected bool PositionTickFixedTime
protected bool AlwaysRunWaterCheck
protected bool get_PositionTickFixedTime()
public void SetDamageScale(float scale)
public float GetNetworkTime()
public void ServerInit()
protected bool get_AlwaysRunWaterCheck()
public void WaterCheck()
public void SetFuse(float fuseLength)
public float GetRandomTimerTime()
public void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
public void ForceExplode()
public void Explode()
public void Explode(Vector3 explosionFxPos)
private Vector3 ExplosionCenter()
private void BlindAnyAI()
public void FixedUpdate()
private void CheckClippingThroughWalls()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public bool CanStickTo(BaseEntity entity)
private void DoBounceEffect()
private void DoCollisionStick(Collision collision, BaseEntity ent)
public void SetMotionEnabled(bool wantsMotion)
public bool IsStuck(bool bypassColliderCheck)
public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent, Collider collider)
private void UnStick()
internal void OnParentRemoved()
public void Save(SaveInfo info)
public void PostServerLoad()
public void Load(LoadInfo info)
public void SetCollisionEnabled(bool wantsCollision)
}
public TimedRemoval : MonoBehaviour {
public Object objectToDestroy
public float removeDelay
private void OnEnable()
}
public TimedUnlootableCrate : LootContainer {
public bool unlootableOnSpawn
public float unlootableDuration
public void ServerInit()
public void SetUnlootableFor(float duration)
public void MakeLootable()
}
public TimelineConvarController : PlayableAsset {
public string convarName
public TimelineConvarPlayable template
public ClipCaps clipCaps
public Playable CreatePlayable(PlayableGraph graph, GameObject owner)
public ClipCaps get_clipCaps()
}
public TimelineConvarPlayable : PlayableBehaviour {
public string convar
public float ConvarValue
public void ProcessFrame(Playable playable, FrameData info, object playerData)
}
public TimerAIEvent : BaseAIEvent {
private float <DurationMin>k__BackingField
private float <DurationMax>k__BackingField
protected float currentDuration
protected float elapsedDuration
public float DurationMin
public float DurationMax
public float get_DurationMin()
public void set_DurationMin(float value)
public float get_DurationMax()
public void set_DurationMax(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Reset()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public TimerSwitch : IOEntity {
public float timerLength
public Transform timerDrum
private float timePassed
private float input1Amount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int ConsumptionAmount()
public void ResetIOState()
public bool WantsPassthroughPower()
public int GetPassthroughAmount(int outputSlot)
public bool WantsPower(int inputIndex)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int inputSlot)
public void SVSwitch(RPCMessage msg)
public void SwitchPressed()
public void AdvanceTime()
public void EndTimer()
public float GetPassedTime()
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public TimeSinceThreatAIEvent : BaseAIEvent {
private float <Value>k__BackingField
public float Value
public float get_Value()
private void set_Value(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public TimeSlider : MonoBehaviour {
private Slider slider
private void Start()
private void Update()
public void OnValue(float f)
}
public TimeSpanEx : object {
public string ToShortString(TimeSpan timeSpan)
public string ToShortStringNoHours(TimeSpan timeSpan)
}
public Timing : ValueType {
private Stopwatch sw
private string name
public Timing Start(string name)
public void End()
public void .ctor(string name)
}
public TinyJSON.DecodeAlias : Attribute {
private String[] <Names>k__BackingField
public String[] Names
public String[] get_Names()
private void set_Names(String[] value)
public void .ctor(String[] names)
public bool Contains(string name)
}
public TinyJSON.DecodeException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public TinyJSON.Decoder : object {
private string whiteSpace
private string wordBreak
private StringReader json
private char PeekChar
private char NextChar
private string NextWord
private Token NextToken
private void .ctor(string jsonString)
public Variant Decode(string jsonString)
public void Dispose()
private ProxyObject DecodeObject()
private ProxyArray DecodeArray()
private Variant DecodeValue()
private Variant DecodeByToken(Token token)
private Variant DecodeString()
private Variant DecodeNumber()
private void ConsumeWhiteSpace()
private char get_PeekChar()
private char get_NextChar()
private string get_NextWord()
private Token get_NextToken()
}
public TinyJSON.EncodeOptions : Enum {
public int value__
public EncodeOptions None
public EncodeOptions PrettyPrint
public EncodeOptions NoTypeHints
public EncodeOptions IncludePublicProperties
public EncodeOptions EnforceHierarchyOrder
public EncodeOptions EnforceHeirarchyOrder
}
public TinyJSON.Encoder : object {
private Type includeAttrType
private Type excludeAttrType
private Type typeHintAttrType
private StringBuilder builder
private EncodeOptions options
private int indent
private bool PrettyPrintEnabled
private bool TypeHintsEnabled
private bool IncludePublicPropertiesEnabled
private bool EnforceHierarchyOrderEnabled
private void .ctor(EncodeOptions options)
public string Encode(object obj)
public string Encode(object obj, EncodeOptions options)
private bool get_PrettyPrintEnabled()
private bool get_TypeHintsEnabled()
private bool get_IncludePublicPropertiesEnabled()
private bool get_EnforceHierarchyOrderEnabled()
private void EncodeValue(object value, bool forceTypeHint)
private IEnumerable`1<FieldInfo> GetFieldsForType(Type type)
private IEnumerable`1<PropertyInfo> GetPropertiesForType(Type type)
private void EncodeObject(object value, bool forceTypeHint)
private void EncodeProxyArray(ProxyArray value)
private void EncodeProxyObject(ProxyObject value)
private void EncodeDictionary(IDictionary value, bool forceTypeHint)
private void EncodeList(IList value, bool forceTypeHint)
private void EncodeArray(Array value, bool forceTypeHint)
private void EncodeArrayRank(Array value, int rank, Int32[] indices, bool forceTypeHint)
private void EncodeString(string value)
private void AppendIndent()
private void AppendOpenBrace()
private void AppendCloseBrace()
private void AppendOpenBracket()
private void AppendCloseBracket()
private void AppendComma(bool firstItem)
private void AppendColon()
}
public TinyJSON.Extensions : object {
public bool AnyOfType(IEnumerable`1<TSource> source, Type expectedType)
}
public TinyJSON.JSON : object {
private Type includeAttrType
private Type excludeAttrType
private Type decodeAliasAttrType
private Dictionary`2<string, Type> typeCache
private BindingFlags instanceBindingFlags
private BindingFlags staticBindingFlags
private MethodInfo decodeTypeMethod
private MethodInfo decodeListMethod
private MethodInfo decodeDictionaryMethod
private MethodInfo decodeArrayMethod
private MethodInfo decodeMultiRankArrayMethod
public Variant Load(string json)
public string Dump(object data)
public string Dump(object data, EncodeOptions options)
public void MakeInto(Variant data, T& item)
private Type FindType(string fullName)
private T DecodeType(Variant data)
private List`1<T> DecodeList(Variant data)
private Dictionary`2<TKey, TValue> DecodeDictionary(Variant data)
private T[] DecodeArray(Variant data)
private void DecodeMultiRankArray(ProxyArray arrayData, Array array, int arrayRank, Int32[] indices)
public void SupportTypeForAOT()
private void SupportValueTypesForAOT()
}
public TinyJSON.ProxyArray : Variant {
private List`1<Variant> list
public Variant Item
public int Count
private IEnumerator`1<Variant> System.Collections.Generic.IEnumerable<TinyJSON.Variant>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(Variant item)
public Variant get_Item(int index)
public void set_Item(int index, Variant value)
public int get_Count()
internal bool CanBeMultiRankArray(Int32[] rankLengths)
private bool CanBeMultiRankArray(int rank, Int32[] rankLengths)
}
public TinyJSON.ProxyBoolean : Variant {
private bool value
public void .ctor(bool value)
public bool ToBoolean(IFormatProvider provider)
public string ToString(IFormatProvider provider)
}
public TinyJSON.ProxyNumber : Variant {
private Char[] floatingPointCharacters
private IConvertible value
public void .ctor(IConvertible value)
private IConvertible Parse(string value)
public bool ToBoolean(IFormatProvider provider)
public byte ToByte(IFormatProvider provider)
public char ToChar(IFormatProvider provider)
public decimal ToDecimal(IFormatProvider provider)
public double ToDouble(IFormatProvider provider)
public short ToInt16(IFormatProvider provider)
public int ToInt32(IFormatProvider provider)
public long ToInt64(IFormatProvider provider)
public sbyte ToSByte(IFormatProvider provider)
public float ToSingle(IFormatProvider provider)
public string ToString(IFormatProvider provider)
public ushort ToUInt16(IFormatProvider provider)
public UInt32 ToUInt32(IFormatProvider provider)
public ulong ToUInt64(IFormatProvider provider)
}
public TinyJSON.ProxyObject : Variant {
public string TypeHintKey
private Dictionary`2<string, Variant> dict
public string TypeHint
public Variant Item
public int Count
public KeyCollection<string, Variant> Keys
public ValueCollection<string, Variant> Values
private IEnumerator`1<KeyValuePair`2<string, Variant>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,TinyJSON.Variant>>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(string key, Variant item)
public bool TryGetValue(string key, Variant& item)
public string get_TypeHint()
public Variant get_Item(string key)
public void set_Item(string key, Variant value)
public int get_Count()
public KeyCollection<string, Variant> get_Keys()
public ValueCollection<string, Variant> get_Values()
}
public TinyJSON.ProxyString : Variant {
private string value
public void .ctor(string value)
public string ToString(IFormatProvider provider)
}
public TinyJSON.Variant : object {
protected IFormatProvider FormatProvider
public Variant Item
public Variant Item
public void Make(T& item)
public T Make()
public string ToJSON()
public TypeCode GetTypeCode()
public object ToType(Type conversionType, IFormatProvider provider)
public DateTime ToDateTime(IFormatProvider provider)
public bool ToBoolean(IFormatProvider provider)
public byte ToByte(IFormatProvider provider)
public char ToChar(IFormatProvider provider)
public decimal ToDecimal(IFormatProvider provider)
public double ToDouble(IFormatProvider provider)
public short ToInt16(IFormatProvider provider)
public int ToInt32(IFormatProvider provider)
public long ToInt64(IFormatProvider provider)
public sbyte ToSByte(IFormatProvider provider)
public float ToSingle(IFormatProvider provider)
public string ToString(IFormatProvider provider)
public ushort ToUInt16(IFormatProvider provider)
public UInt32 ToUInt32(IFormatProvider provider)
public ulong ToUInt64(IFormatProvider provider)
public string ToString()
public Variant get_Item(string key)
public void set_Item(string key, Variant value)
public Variant get_Item(int index)
public void set_Item(int index, Variant value)
public bool op_Implicit(Variant variant)
public float op_Implicit(Variant variant)
public double op_Implicit(Variant variant)
public ushort op_Implicit(Variant variant)
public short op_Implicit(Variant variant)
public UInt32 op_Implicit(Variant variant)
public int op_Implicit(Variant variant)
public ulong op_Implicit(Variant variant)
public long op_Implicit(Variant variant)
public decimal op_Implicit(Variant variant)
public string op_Implicit(Variant variant)
public Guid op_Implicit(Variant variant)
}
public TirednessAboveAIEvent : BaseAIEvent {
private float <Value>k__BackingField
public float Value
public float get_Value()
private void set_Value(float value)
public void Init(AIEventData data, BaseEntity owner)
public AIEventData ToProto()
public void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus)
}
public TmProEmojiInputField : TMP_InputField {
public TmProEmojiRedirector Redirector
public EmojiAutocomplete Autocomplete
}
public TmProEmojiRedirector : MonoBehaviour {
public GameObjectRef SpritePrefab
public float EmojiScale
public bool NonDestructiveChange
public bool CanTextHaveLegitimateRichText
public void FindEmojiSubstitutions(string text, RustEmojiLibrary library, List`1<ValueTuple`2<EmojiSub, int>> foundSubs, bool richText, bool isServer, int messageLength)
}
public ToggleCookie : MonoBehaviour {
public void OnEnable()
public void OnDisable()
private void OnPressed()
private void OnReleased()
private void OnChanged(bool v)
}
public ToggleGroupCookie : MonoBehaviour {
public ToggleGroup group
public ToggleGroup get_group()
private void OnEnable()
private void OnDisable()
private void SetupListeners()
private void OnToggleChanged(bool b)
private Transform FindChild(Transform parent, string name)
}
public ToggleHUDLayer : MonoBehaviour {
public Toggle toggleControl
public TextMeshProUGUI textControl
public string hudComponentName
protected void OnEnable()
public void OnToggleChanged()
}
public ToggleLayer : MonoBehaviour {
public Toggle toggleControl
public TextMeshProUGUI textControl
public LayerSelect layer
protected void OnEnable()
public void OnToggleChanged()
protected void OnValidate()
}
public ToggleTerrainRenderer : MonoBehaviour {
public Toggle toggleControl
public Text textControl
protected void OnEnable()
public void OnToggleChanged()
protected void OnValidate()
}
public ToggleTerrainTrees : MonoBehaviour {
public Toggle toggleControl
public Text textControl
protected void OnEnable()
public void OnToggleChanged()
protected void OnValidate()
}
public TokenisedPhrase : Phrase {
public Phrase LeftMouse
public Phrase RightMouse
public Phrase MiddleMouse
public string translated
public string get_translated()
public string ReplaceTokens(string str)
public void .ctor(string t, string eng)
public string TranslateMouseButton(string mouseButton)
private string GetButtonWithBind(string s)
}
public TonemappingOverlay : ImageEffectLayer {
public TonemappingColorGrading tonemapping
}
public Toolgun : Hammer {
public GameObjectRef attackEffect
public GameObjectRef beamEffect
public GameObjectRef beamImpactEffect
public GameObjectRef errorEffect
public GameObjectRef beamEffectClassic
public GameObjectRef beamImpactEffectClassic
public Transform muzzlePoint
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void DoAttackShared(HitInfo info)
}
public ToolgunBeam : MonoBehaviour {
public LineRenderer electricalBeam
public float scrollSpeed
private Color fadeColor
public float fadeSpeed
public void Update()
}
public ToolgunScreen : MonoBehaviour {
public Text blockInfoText
public Text noBlockText
public void SetScreenText(string newText)
}
public ToolsHUDUI : MonoBehaviour {
private GameObject prefab
private Transform parent
private bool initialised
protected void OnEnable()
private void Init()
private void AddToggleObj(string trName, string labelText)
public void SelectAll()
public void SelectNone()
}
public Tooltip : BaseMonoBehaviour {
public TooltipContainer Current
public string Text
public GameObject TooltipObject
public string token
public string english
public string get_english()
}
public TooltipContainer : MonoBehaviour {
public Transform ScaleRoot
public RustText TooltipText
public RectTransform OverrideLayoutRoot
}
public TooltipContainer_Emoji : TooltipContainer {
public TmProEmojiRedirector EmojiRedirector
}
public TopBunnies : MonoBehaviour {
public BunnyEntry[] topBunnyEntries
public Text timerText
public CanvasGroup group
public Color endingColor
}
public TorchDeployableLightSource : StorageContainer {
public ItemDefinition[] AllowedTorches
public Transform TorchRoot
public Flags HasTorch
public Flags UseBuiltInFx
public ItemDefinition[] BuiltInFxItems
private EntityRef`1<TorchWeapon> spawnedTorch
private ItemDefinition spawnedTorchDef
private Item CurrentTorch
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool ItemFilter(Item item, int targetSlot)
private bool ShouldUseBuiltInFx(ItemDefinition def)
private void UpdateTorch()
private void TickTorchDurability()
public void PostServerLoad()
public void OnItemAddedOrRemoved(Item item, bool added)
private Item get_CurrentTorch()
private void RequestTurnOnOff(RPCMessage msg)
private void TryToggle(bool wantsOn)
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public void Ignite(Vector3 fromPos)
public bool CanIgnite()
}
public TorchWeapon : BaseMelee {
public float FuelTickAmount
public AnimatorOverrideController LitHoldAnimationOverride
public bool ExtinguishUnderwater
public bool UseTurnOnOffAnimations
public GameObjectRef litStrikeFX
public Flags IsInHolder
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void GetAttackStats(HitInfo info)
public float GetConditionLoss()
public void SetIsOn(bool isOn)
private void Ignite(RPCMessage msg)
private void Extinguish(RPCMessage msg)
public void UseFuel()
public void OnHeldChanged()
public string GetStrikeEffectPath(string materialName)
}
public TorpedoServerProjectile : ServerProjectile {
private float minWaterDepth
private float shallowWaterInaccuracy
private float deepWaterInaccuracy
private float shallowWaterCutoff
public bool HasRangeLimit
protected int mask
public bool get_HasRangeLimit()
protected int get_mask()
public bool DoMovement()
public void InitializeVelocity(Vector3 overrideVel)
}
public TrainBarricade : BaseCombatEntity {
private float trainDamagePerMPS
private float minVelToDestroy
private float velReduction
private GameObjectRef barricadeDamageEffect
private float <FrontWheelSplineDist>k__BackingField
private TrainCar hitTrain
private TriggerTrainCollisions hitTrainTrigger
private TrainTrackSpline track
public Vector3 Position
public float FrontWheelSplineDist
public TrainCarType CarType
public Vector3 get_Position()
public float get_FrontWheelSplineDist()
private void set_FrontWheelSplineDist(float value)
public TrainCarType get_CarType()
public bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger)
public void ServerInit()
internal void DoServerDestroy()
private void SetHitTrain(TrainCar train, TriggerTrainCollisions trainTrigger)
private void ClearHitTrain()
private void DestroyThisBarrier()
private void PushForceTick()
}
public TrainCar : BaseVehicle {
public float corpseSeconds
public TriggerTrainCollisions frontCollisionTrigger
public TriggerTrainCollisions rearCollisionTrigger
public float collisionDamageDivide
public float derailCollisionForce
public TriggerHurtNotChild hurtTriggerFront
public TriggerHurtNotChild hurtTriggerRear
private GameObject[] hurtOrRepelTriggersInternal
public float hurtTriggerMinSpeed
public Transform centreOfMassTransform
public Transform frontBogiePivot
public bool frontBogieCanRotate
public Transform rearBogiePivot
public bool rearBogieCanRotate
private Transform[] wheelVisuals
public float wheelRadius
public GameObjectRef fxDestroyed
public TriggerParent platformParentTrigger
public GameObjectRef collisionEffect
public Transform frontCoupling
public Transform frontCouplingPivot
public Transform rearCoupling
public Transform rearCouplingPivot
public SoundDefinition coupleSound
private SoundDefinition uncoupleSound
private TrainCarAudio trainCarAudio
public ParticleSystem frontCouplingChangedFx
public ParticleSystem rearCouplingChangedFx
public ParticleSystem newCouplingFX
private float decayTimeMultiplier
public Vector3 frontBogieLocalOffset
public Vector3 rearBogieLocalOffset
public float population
public int wagons_per_engine
public float decayminutes
public float DistFrontWheelToFrontCoupling
public float DistFrontWheelToBackCoupling
public TrainCouplingController coupling
public TrackSelection localTrackSelection
public Flags Flag_LinedUpToUnload
private float <FrontWheelSplineDist>k__BackingField
protected bool trainDebug
public CompleteTrain completeTrain
private bool frontAtEndOfLine
private bool rearAtEndOfLine
public float frontBogieYRot
public float rearBogieYRot
public Vector3 spawnOrigin
public float TRAINCAR_MAX_SPEED
public TrainTrackSpline _frontTrackSection
private TrainTrackSpline <RearTrackSection>k__BackingField
public float distFrontToBackWheel
public float initialSpawnTime
public float decayingFor
public float decayTickSpacing
public float lastDecayTick
public TriggerTrainCollisions FrontCollisionTrigger
public TriggerTrainCollisions RearCollisionTrigger
public TrainCarType CarType
public bool LinedUpToUnload
public Vector3 Position
public float FrontWheelSplineDist
public bool FrontAtEndOfLine
public bool RearAtEndOfLine
public bool networkUpdateOnCompleteTrainChange
public TrainTrackSpline FrontTrackSection
public TrainTrackSpline RearTrackSection
public bool IsAtAStation
public bool IsOnAboveGroundSpawnRail
public bool RecentlySpawned
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public TriggerTrainCollisions get_FrontCollisionTrigger()
public TriggerTrainCollisions get_RearCollisionTrigger()
public TrainCarType get_CarType()
public bool get_LinedUpToUnload()
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void InitShared()
public void Load(LoadInfo info)
public void OnFlagsChanged(Flags old, Flags next)
public bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger)
public float InheritedVelocityScale()
public void SetTrackSelection(TrackSelection trackSelection)
public bool PlayerIsOnPlatform(BasePlayer player)
public Vector3 get_Position()
public float get_FrontWheelSplineDist()
public void set_FrontWheelSplineDist(float value)
public bool get_FrontAtEndOfLine()
public bool get_RearAtEndOfLine()
public bool get_networkUpdateOnCompleteTrainChange()
public TrainTrackSpline get_FrontTrackSection()
public void set_FrontTrackSection(TrainTrackSpline value)
public TrainTrackSpline get_RearTrackSection()
public void set_RearTrackSection(TrainTrackSpline value)
public bool get_IsAtAStation()
public bool get_IsOnAboveGroundSpawnRail()
public bool get_RecentlySpawned()
public void ServerInit()
public void PostServerLoad()
public void Spawn()
public void Save(SaveInfo info)
public void ServerFlagsChanged(Flags old, Flags next)
public void UpdateCompleteTrain()
public void SetNewCompleteTrain(CompleteTrain ct)
public void Hurt(HitInfo info)
public void OnKilled(HitInfo info)
public Vector3 GetExplosionPos()
public void ActualDeath()
public void DoRepair(BasePlayer player)
public float GetDamageMultiplier(BaseEntity ent)
public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
public void DoServerDestroy()
public void RemoveFromCompleteTrain()
public bool MountEligable(BasePlayer player)
public float MaxVelocity()
public float GetTrackSpeed()
public bool IsCoupledBackwards()
public float GetPrevTrackSpeed()
public Vector3 GetLocalVelocityServer()
public bool AnyPlayersOnTrainCar()
public void VehicleFixedUpdate()
public void PostVehicleFixedUpdate()
public Vector3 GetCentreOfTrainPos()
public Vector3 GetFrontOfTrainPos()
public Vector3 GetRearOfTrainPos()
public void FrontTrainCarTick(TrackSelection trackSelection, float dt)
public void OtherTrainCarTick(TrainTrackSpline theirTrackSpline, float prevSplineDist, float distanceOffset)
public bool TryGetNextTrainCar(Vector3 forwardDir, TrainCar& result)
public bool TryGetPrevTrainCar(Vector3 forwardDir, TrainCar& result)
public bool TryGetTrainCar(bool next, Vector3 forwardDir, TrainCar& result)
public void MoveFrontWheelsAlongTrackSpline(TrainTrackSpline trackSpline, float prevSplineDist, float distToMove, TrainTrackSpline preferredAltTrack, TrackSelection trackSelection)
public Vector3 GetFrontWheelPos()
public Vector3 GetRearWheelPos()
public void SetTheRestFromFrontWheelData(TrainTrackSpline& frontTS, Vector3 targetFrontWheelPos, Vector3 targetFrontWheelTangent, TrackSelection trackSelection, TrainTrackSpline additionalAlt, bool instantMove)
public float GetForces()
protected float GetThrottleForce()
public bool HasThrottleInput()
public float ApplyCollisionDamage(float forceMagnitude)
public bool SpaceIsClear()
public bool ColliderIsPartOfTrain(Collider collider)
public void UpdateClients()
public void DecayTick()
public float GetDecayMinutes(bool hasPassengers)
public bool CanDieFromDecayNow()
public bool AnyPlayersNearby(float maxDist)
public void RPC_WantsUncouple(RPCMessage msg)
}
public TrainCarAudio : MonoBehaviour {
private TrainCar trainCar
private SoundDefinition movementStartDef
private SoundDefinition movementStopDef
private SoundDefinition movementLoopDef
private AnimationCurve movementLoopGainCurve
private float movementChangeOneshotDebounce
private Sound movementLoop
private Modulator movementLoopGain
private SoundDefinition turnLoopDef
private Sound turnLoop
private SoundDefinition trackClatterLoopDef
private AnimationCurve trackClatterGainCurve
private AnimationCurve trackClatterPitchCurve
private Sound trackClatterLoop
private Modulator trackClatterGain
private Modulator trackClatterPitch
}
public TrainCarFuelHatches : MonoBehaviour {
private TrainCar owner
private float animSpeed
private Transform hatch1Col
private Transform hatch1Vis
private Transform hatch2Col
private Transform hatch2Vis
private Transform hatch3Col
private Transform hatch3Vis
private float closedXAngle
private float openXAngle
private SoundDefinition hatchOpenSoundDef
private SoundDefinition hatchCloseSoundDef
private Vector3 _angles
private float _hatchLerp
private bool opening
private bool openingQueued
private bool isMoving
public void LinedUpStateChanged(bool linedUp)
private void MoveTick()
private void EndMove()
private void SetAngleOnAll(float lerpT, bool closing)
private void SetAngle(Transform transform, float angle)
}
public TrainCarUnloadable : TrainCar {
private GameObjectRef storagePrefab
private BoxCollider[] unloadingAreas
private TrainCarFuelHatches fuelHatches
private Transform orePlaneVisuals
private Transform orePlaneColliderDetailed
private Transform orePlaneColliderWorld
public float vacuumStretchPercent
private ParticleSystemContainer unloadingFXContainer
private ParticleSystem unloadingFX
public WagonType wagonType
private int lootTypeIndex
private List`1<EntityRef`1<LootContainer>> lootContainers
private Vector3 _oreScale
private float animPercent
private float prevAnimTime
public float decayminutesafterunload
private EntityRef`1<StorageContainer> storageInstance
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnFlagsChanged(Flags old, Flags next)
protected void OnChildAdded(BaseEntity child)
public void Load(LoadInfo info)
public bool IsEmpty()
public bool TryGetLootType(LootOption& lootOption)
public bool CanBeLooted(BasePlayer player)
public int GetFilledLootAmount()
public void SetVisualOreLevel(float percent)
private void AnimateUnload(float startPercent)
private void UnloadAnimTick()
private void EndUnloadAnim()
public float GetOrePercent()
public void Save(SaveInfo info)
internal void DoServerDestroy()
public bool IsLinedUpToUnload(BoxCollider unloaderBounds)
public void FillWithLoot(StorageContainer sc)
public void EmptyOutLoot(StorageContainer sc)
public void BeginUnloadAnimation()
public void EndEmptyProcess()
public StorageContainer GetStorageContainer()
protected float GetDecayMinutes(bool hasPassengers)
protected bool CanDieFromDecayNow()
public bool AdminFixUp(int tier)
public float MinDistToUnloadingArea(Vector3 point)
public void RPC_Open(RPCMessage msg)
}
public TrainCarUnloadableLoot : TrainCarUnloadable {
private LootCrateSet[] lootLayouts
private Transform[] lootPositions
public void Spawn()
}
public TrainCoupling : object {
public TrainCar owner
public bool isFrontCoupling
public TrainCouplingController controller
public Transform couplingPoint
public Transform couplingPivot
public Flags flag
public bool isValid
private TrainCoupling <CoupledTo>k__BackingField
public TimeSince timeSinceCouplingBlock
public bool IsCoupled
public bool IsUncoupled
public TrainCoupling CoupledTo
public bool get_IsCoupled()
public bool get_IsUncoupled()
public void .ctor(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller)
public void .ctor(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller, Transform couplingPoint, Transform couplingPivot, Flags flag)
public TrainCoupling get_CoupledTo()
private void set_CoupledTo(TrainCoupling value)
public bool IsCoupledTo(TrainCar them)
public bool IsCoupledTo(TrainCoupling them)
public bool TryCouple(TrainCoupling theirCoupling, bool reflect)
public void Uncouple(bool reflect)
public TrainCoupling GetOppositeCoupling()
public bool TryGetCoupledToID(NetworkableId& id)
}
public TrainCouplingController : object {
private float <PreChangeTrackSpeed>k__BackingField
private bool <PreChangeCoupledBackwards>k__BackingField
public Flags Flag_CouplingFront
public Flags Flag_CouplingRear
public TrainCoupling frontCoupling
public TrainCoupling rearCoupling
private TrainCar owner
public float max_couple_speed
public bool IsCoupled
public bool IsFrontCoupled
public bool IsRearCoupled
public float PreChangeTrackSpeed
public bool PreChangeCoupledBackwards
public bool get_IsCoupled()
public bool get_IsFrontCoupled()
public bool get_IsRearCoupled()
public float get_PreChangeTrackSpeed()
private void set_PreChangeTrackSpeed(float value)
public bool get_PreChangeCoupledBackwards()
private void set_PreChangeCoupledBackwards(bool value)
public void .ctor(TrainCar owner)
public bool IsCoupledTo(TrainCar them)
public bool TryCouple(TrainCar them, Location ourLocation)
public void Uncouple(bool front)
public void GetAll(List`1& result)
public void OnPreCouplingChange()
}
public TrainEngine : TrainCar {
public Transform leftHandLever
public Transform rightHandLever
public Transform leftHandGrip
public Transform rightHandGrip
private LeverStyle leverStyle
public Canvas monitorCanvas
public RustText monitorText
private LocomotiveExtraVisuals gauges
public float engineForce
public float maxSpeed
public float engineStartupTime
public GameObjectRef fuelStoragePrefab
public float idleFuelPerSec
public float maxFuelPerSec
public ProtectionProperties driverProtection
public bool lootablesAreOnPlatform
private bool mustMountFromPlatform
private VehicleLight[] onLights
public VehicleLight[] headlights
private VehicleLight[] notMovingLights
private VehicleLight[] movingForwardLights
private VehicleLight[] movingBackwardLights
public ParticleSystemContainer fxEngineOn
public ParticleSystemContainer fxLightDamage
public ParticleSystemContainer fxMediumDamage
public ParticleSystemContainer fxHeavyDamage
public ParticleSystemContainer fxEngineTrouble
public BoxCollider engineWorldCol
public float engineDamageToSlow
public float engineDamageTimeframe
public float engineSlowedTime
public float engineSlowedMaxVel
private ParticleSystemContainer[] sparks
private Light[] sparkLights
private TrainEngineAudio trainAudio
public Flags Flag_HazardAhead
public Flags Flag_Horn
public Flags Flag_AltColor
public Flags Flag_EngineSlowed
public VehicleEngineController`1<TrainEngine> engineController
private EngineSpeeds <CurThrottleSetting>k__BackingField
public float HAZARD_CHECK_EVERY
public float HAZARD_DIST_MAX
public float HAZARD_DIST_MIN
public float HAZARD_SPEED_MIN
public float buttonHoldTime
public EngineSpeeds MaxThrottle
public EngineSpeeds MinThrottle
public EngineDamageOverTime engineDamage
public Vector3 engineLocalOffset
public int lastSentLinedUpToUnload
public bool LightsAreOn
public bool CloseToHazard
public bool EngineIsSlowed
public EngineSpeeds CurThrottleSetting
public TrainCarType CarType
public bool networkUpdateOnCompleteTrainChange
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_LightsAreOn()
public bool get_CloseToHazard()
public bool get_EngineIsSlowed()
public EngineSpeeds get_CurThrottleSetting()
public void set_CurThrottleSetting(EngineSpeeds value)
public TrainCarType get_CarType()
public void InitShared()
public void Load(LoadInfo info)
public bool CanBeLooted(BasePlayer player)
public float GetEnginePowerMultiplier(float minPercent)
public float GetThrottleFraction()
public bool IsNearDesiredSpeed(float leeway)
public void SetTrackSelection(TrackSelection trackSelection)
public void SetThrottle(EngineSpeeds throttle)
public int GetFuelAmount()
public bool CanMount(BasePlayer player)
public bool get_networkUpdateOnCompleteTrainChange()
public void ServerInit()
public void OnChildAdded(BaseEntity child)
public void VehicleFixedUpdate()
public void Save(SaveInfo info)
public IFuelSystem GetFuelSystem()
public void LightToggle(BasePlayer player)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public bool MeetsEngineRequirements()
public void OnEngineStartFailed()
public void AttemptMount(BasePlayer player, bool doMountChecks)
protected float GetThrottleForce()
public bool HasThrottleInput()
public void Hurt(HitInfo info)
public void StopEngine()
public Vector3 GetExplosionPos()
public void IncreaseThrottle()
public void DecreaseThrottle()
public void SetZeroThrottle()
public void ServerFlagsChanged(Flags old, Flags next)
public void CheckForHazards()
public void OnEngineTookHeavyDamage()
public void ResetEngineToNormal()
public float GetCurTopSpeed()
public float GetCurEngineForce()
public void RPC_OpenFuel(RPCMessage msg)
private void IEngineControllerUser.Invoke(Action action, float time)
private void IEngineControllerUser.CancelInvoke(Action action)
private bool <PlayerServerInput>g__ProcessThrottleInput|83_0(BUTTON button, Action action, <>c__DisplayClass83_0& )
}
public TrainEngineAudio : TrainCarAudio {
private TrainEngine trainEngine
private Transform cockpitSoundPosition
private Transform hornSoundPosition
private SoundDefinition engineStartSound
private SoundDefinition engineStopSound
private SoundDefinition engineActiveLoopDef
private AnimationCurve engineActiveLoopPitchCurve
private float engineActiveLoopChangeSpeed
private Sound engineActiveLoop
private Modulator engineActiveLoopPitch
private BlendedLoopEngineSound engineLoops
private EngineReflection[] engineReflections
private LayerMask reflectionLayerMask
private float reflectionMaxDistance
private float reflectionGainChangeSpeed
private float reflectionPositionChangeSpeed
private float reflectionRayOffset
private SoundDefinition hornLoop
private SoundDefinition hornStart
private SoundDefinition lightsToggleSound
private SoundDefinition proximityAlertDef
private Sound proximityAlertSound
private SoundDefinition damagedLoopDef
private Sound damagedLoop
private SoundDefinition changeThrottleDef
private SoundDefinition changeCouplingDef
private SoundDefinition unloadableStartDef
private SoundDefinition unloadableEndDef
private GameObject bellObject
private SoundDefinition bellRingDef
private SoundPlayer brakeSound
}
public TrainSignal : BaseEntity {
private bool testFX
private VehicleLight redLight
private VehicleLight yellowLight
private VehicleLight greenLight
private Flags Flag_Red
private Flags Flag_Yellow
private Flags Flag_Green
private LightState lightState
public TrainSignal nextSignal
private TrainTrackSpline ourSpline
private float ourSplineDist
private List`1<SplineSection> ourSplines
private LightState prevTargetLightState
public float SplineDist
public bool HasNextSignal
public void OnFlagsChanged(Flags old, Flags next)
private void SetLightState(LightState newState)
public float get_SplineDist()
public bool get_HasNextSignal()
public void ServerInit()
private void SetUpSignal()
internal void DoServerDestroy()
public void RefreshLightState()
private bool HasOccupant()
public bool IsForward()
private void TestLights()
private MoveResult ProcessSplineSection(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength)
}
public TrainTrackSpline : WorldSpline {
public bool isStation
public bool aboveGroundSpawn
public int hierarchy
public List`1<TrainTrackSpline> SidingSplines
public List`1<ConnectedTrackInfo> nextTracks
public int straightestNextIndex
public List`1<ConnectedTrackInfo> prevTracks
public int straightestPrevIndex
public HashSet`1<ITrainTrackUser> trackUsers
public HashSet`1<TrainSignal> signals
public bool HasNextTrack
public bool HasPrevTrack
public bool get_HasNextTrack()
public bool get_HasPrevTrack()
public void SetAll(Vector3[] points, Vector3[] tangents, TrainTrackSpline sourceSpline)
public MoveResult MoveAlongSpline(float prevSplineDist, Vector3 askerForward, float distMoved, TrackRequest tReq, SplineAction onSpline)
private MoveResult MoveAlongSpline(MoveRequest request, bool facingForward, float prevDistMoved)
private MoveResult MoveToNextSpline(MoveResult result, MoveRequest request, bool facingForward, float splineLength)
private MoveResult MoveToPrevSpline(MoveResult result, MoveRequest request, bool facingForward)
public float GetDistance(Vector3 position, float maxError, Single& minSplineDist)
public float GetLength()
public Vector3 GetPosition(float distance)
public Vector3 GetPositionAndTangent(float distance, Vector3 askerForward, Vector3& tangent)
public void AddTrackConnection(TrainTrackSpline track, TrackPosition p, TrackOrientation o)
public void RegisterTrackUser(ITrainTrackUser user)
public void DeregisterTrackUser(ITrainTrackUser user)
public void RegisterSignal(TrainSignal signal)
public void DeregisterSignal(TrainSignal signal)
public bool IsForward(Vector3 askerForward, float askerSplineDist)
public bool HasValidHazardWithin(TrainCar asker, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, float trackSpeed, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
public bool HasValidHazardWithin(ITrainTrackUser asker, Vector3 askerForward, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, bool movingForward, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
public bool HasAnyUsers()
public bool HasAnyUsersOfType(TrainCarType carType)
public bool HasConnectedTrack(TrainTrackSpline tts)
public bool HasConnectedNextTrack(TrainTrackSpline tts)
public bool HasConnectedPrevTrack(TrainTrackSpline tts)
public Vector3 GetInitialVector(TrainTrackSpline track, TrackPosition p, TrackOrientation o)
protected void OnDrawGizmosSelected()
public ConnectedTrackInfo GetTrackSelection(List`1<ConnectedTrackInfo> trackOptions, int straightestIndex, bool nextTrack, bool trainForward, TrackRequest request)
public bool TryFindTrackNear(Vector3 pos, float maxDist, TrainTrackSpline& splineResult, Single& distResult)
}
public TrainWagonLootData : ScriptableObject {
private LootOption[] oreOptions
private LootOption lootWagonContent
private LootOption fuelWagonContent
private TrainWagonLootData _instance
private int LOOT_WAGON_INDEX
private int FUEL_WAGON_INDEX
public TrainWagonLootData instance
public TrainWagonLootData get_instance()
public LootOption GetLootOption(WagonType wagonType, Int32& index)
public bool TryGetLootFromIndex(int index, LootOption& lootOption)
public bool TryGetIndexFromLoot(LootOption lootOption, Int32& index)
public float GetOrePercent(int lootTypeIndex, StorageContainer sc)
public float GetOrePercent(LootOption lootOption, StorageContainer sc)
}
public TransformLineRenderer : MonoBehaviour {
public Transform[] TransformSequence
public LineRenderer TargetRenderer
}
public TransformUtil : object {
public bool GetGroundInfo(Vector3 startPos, RaycastHit& hit, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, RaycastHit& hit, float range, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, RaycastHit& hitOut, float range, LayerMask mask, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, float range, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, float range, LayerMask mask, Transform ignoreTransform)
public bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal)
public bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal, float range)
public bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal, float range, LayerMask mask)
public Transform[] GetRootObjects()
}
public TrappableWildlife : ScriptableObject {
public GameObjectRef worldObject
public ItemDefinition inventoryObject
public int minToCatch
public int maxToCatch
public List`1<BaitType> baitTypes
public int caloriesForInterest
public float successRate
public float xpScale
}
public TravellingVendor : BaseEntity {
public TravellingVendorVisuals visuals
public TravellingVendorSounds sounds
private VisualCarWheel wheelFL
private VisualCarWheel wheelFR
private VisualCarWheel wheelRL
private VisualCarWheel wheelRR
public float client_steering_left
public float client_steering_right
public Vector3 client_velocity
private WheelIsGroundedFlags client_wheel_flags
public TimeSince timeSinceLastUpdate
private Collider[] spawncheckColliders
private string prefabPath
public bool DoAI
public float ObstacleCheckTime
public float MarkerUpdateTime
public float TimeBetweenPullovers
public float motorForceConstant
public float brakeForceConstant
public float acceleration
public float maxSpeed
public float wheelbase
public float rearTrack
public float steeringSmoothing
public float downforceCoefficient
public float maxSteerAngle
public GameObjectRef vendingMachineRef
public GameObjectRef vendingMachineFrontRef
public float maxPulloverAngleDifference
public int obstacleMask
public GameObjectRef mapMarkerEntityPrefab
public GameObjectRef preventBuildingPrefab
public GameObjectRef backfireEffect
public Transform backfirePosition
private BaseEntity preventBuildingInstance
private NPCVendingMachine vendingMachine
private RaycastHit hit
private TriggerVehiclePush pusher
private TriggerPlayerForce forcer
public bool should_spawn
public bool attempt_pullovers
public float alive_time_seconds
public bool should_destroy_buildings
private float smoothedSteering
private float brakes
private float throttle
private float targetThrottle
private bool handbrake
private float steeringAngle
private float currentMaxSpeed
private Rigidbody myRigidbody
private List`1<RaycastHit> obstacleHits
private List`1<RaycastHit> pulloverHits
private Vector3 destination
private bool instantLeave
private float waitTimeAccumulator
private float aliveTimer
private TimeSince timeSinceBackfire
private bool pullingOver
private Vector3 pulloverPosition
private float pullOverTimer
private Vector3 pulloverTangent
private bool overrideSteering
private TravellingVendorState internalState
private WheelIsGroundedFlags wheelFlags
private MapMarker mapMarkerInstance
private bool globaIndicatorLeft
public List`1<Vector3> currentPath
public int currentPathIndex
private float atDestinationDistance
private Dictionary`2<BasePlayer, float> ignoreList
private Dictionary`2<BasePlayer, VendorTargetInfo> possiblePatrons
private Dictionary`2<BasePlayer, float> blockerPlayers
private List`1<BasePlayer> ignoreDebugList
private List`1<BasePlayer> possiblePatronsDebugList
private List`1<BasePlayer> blockerDebugList
private int searchRange
private float memoryDuration
private float allowedVendorBlockTime
public Vector3 Velocity
public float DriveWheelVelocity
public float SteerAngle
public float MaxSteerAngle
protected bool PositionTickFixedTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 get_Velocity()
public float get_DriveWheelVelocity()
public float get_SteerAngle()
public float get_MaxSteerAngle()
public float GetThrottleInput()
public string svspawntravellingvendor(Arg args)
public string svspawntravellingvendorevent(Arg args)
public TravellingVendor SpawnTravellingVendor(Vector3 position)
private ValueTuple`2<Vector3, int> FindFarthestPointFromPlayers(Vector3[] points, List`1<BasePlayer> players)
public TravellingVendor SpawnTravellingVendorForEvent()
private bool CheckSpawnPosition(Vector3 testPosition)
protected void OnChildAdded(BaseEntity child)
public void SV_OpenMenu(RPCMessage msg)
public float GetNetworkTime()
protected bool get_PositionTickFixedTime()
public bool IsDebugging()
public void OnAttacked(HitInfo info)
public void CreateMapMarker()
public void CreatePreventBuilding()
public void Save(SaveInfo info)
public void ServerInit()
internal void DoServerDestroy()
private void FixedUpdate()
private void ProcessHandbrake()
private void SetGlobalIndicator()
private void TurnOffIndicators()
private void UpdateMarker()
private void NightCheck()
private void ProcessLifetime()
private void ProcessState()
private void HandlePullover()
private void SetPulloverWaiting()
private bool FindPullingOverSpot()
private Vector3 GetAdjustedPulloverPoint(bool onLeft)
private bool TryFindClearPulloverPoint(bool onLeft, Vector3& testedPosition)
private Vector3 GetPulloverPointFromSide(Vector3 side, bool inFront)
private bool IsPositionClear(Vector3 position, float radiusCheck)
private bool IsDirectionClear(Vector3 direction, Vector3 point)
private Vector3 GetTerrainNormal(Vector3 testPos)
private void SetWaiting()
private void SetTravelling()
private void AdvancePath()
private int GetPathIndexAhead(int ahead)
private void ResetPullover()
private float GetWaitAccumulator()
public void ScaleSidewaysFriction(float scale)
private void ApplyDownforce()
private void UpdateWheelFlags()
private void BuildingCheck()
private bool CheckForObstacle()
private void UpdateObstacles()
private void UpdateObstacleList(List`1<RaycastHit> hits, Vector3 forward, float checkRadius)
private void DoSteering()
private void ApplyForceAtWheels()
private void ApplyBrakesAtWheels()
private float CalculateSteeringAngle(float radius)
public void InstallPath(RuntimePath path, int initialDestination)
private bool HasPath()
private void ClearPath()
private bool IndexValid(int index)
private Vector3 GetCurrentPathDestination()
private bool PathComplete()
public void SetDestination(Vector3 dest, float destinationDistance)
public bool AtDestination()
private void FetchTargets()
private void FetchCycle(List`1<BaseEntity> foundEntities)
private bool IsInvalidPlayer(BasePlayer player)
private void IgnorePlayer(BasePlayer player)
private bool IsValidPatrons()
}
public TravellingVendorEvent : TriggeredEvent {
public Phrase spawnPhrase
public TravellingVendor currentVendor
public float dontSpawnHoursBeforeWipe
public void RunEvent()
private bool HoursCheck()
}
public TravellingVendorSounds : MonoBehaviour {
private EngineAudioSet EngineAudioSet
private BlendedLoopEngineSound blendedEngineLoops
private float engineRPMThrottleWeight
private float engineRPMThrottleSpeedWeight
private float engineRPMSpeedWeight
private float wheelRatioMultiplier
private SoundDefinition missGearSoundDef
private float gearMissCooldown
private SoundDefinition suspensionDef
private float suspensionMinTimeBetweenSounds
private float suspensionUpAngleDeltaThreshold
private AnimationCurve suspensionDeltaSpeedGain
private AnimationCurve suspensionUpAngleDeltaGain
private SoundDefinition tireDirtSoundDef
private SoundDefinition tireGrassSoundDef
private SoundDefinition tireSnowSoundDef
private SoundDefinition tireWaterSoundDef
private AnimationCurve tireGainCurve
private SoundDefinition movementLoopDef
private AnimationCurve movementLoopGainCurve
private SoundDefinition brakeLoopDef
private SoundDefinition brakeHissDef
private float brakeHissCooldown
private SoundDefinition angryHornSoundDef
private SoundDefinition musicLoopSoundDef
}
public TreadAnimator : MonoBehaviour {
public Animator mainBodyAnimator
public Transform[] wheelBones
public Vector3[] vecShocksOffsetPosition
public Vector3[] wheelBoneOrigin
public float wheelBoneDistMax
public Material leftTread
public Material rightTread
public TreadEffects treadEffects
public float traceThickness
public float heightFudge
public bool useWheelYOrigin
public Vector2 treadTextureDirection
public bool isMetallic
public float angularTreadConstant
public float treadConstant
public float wheelSpinConstant
public float traceLineMin
public float traceLineMax
public float maxShockDist
}
public TreadEffects : MonoBehaviour {
public ParticleSystem[] rearTreadDirt
public ParticleSystem[] rearTreadSmoke
public ParticleSystem[] middleTreadSmoke
}
public TreeEntity : ResourceEntity {
public bool fallOnKilled
public float fallDuration
public GameObjectRef fallStartSound
public GameObjectRef fallImpactSound
public GameObjectRef fallImpactParticles
public SoundDefinition fallLeavesLoopDef
public Boolean[] usedHeights
public bool impactSoundPlayed
private float treeDistanceUponFalling
public GameObjectRef prefab
public bool hasBonusGame
public GameObjectRef bonusHitEffect
public GameObjectRef bonusHitSound
public Collider serverCollider
public Collider clientCollider
public SoundDefinition smallCrackSoundDef
public SoundDefinition medCrackSoundDef
private float lastAttackDamage
public BaseEntity xMarker
private int currentBonusLevel
private float lastDirection
private float lastHitTime
private int lastHitMarkerIndex
private float nextBirdTime
private UInt32 birdCycleIndex
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public float BoundsPadding()
public void OnAttacked(HitInfo info)
public void ServerInit()
public void ServerInitPostNetworkGroupAssign()
internal void DoServerDestroy()
public bool DidHitMarker(HitInfo info)
public void StartBonusGame()
public void StopBonusGame()
public bool BonusActive()
private void DoBirds()
public void CleanupMarker()
public void OnKilled(HitInfo info)
public void DelayedKill()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public TreeLOD : LODComponent {
public State[] States
}
public TreeManager : BaseEntity {
public ListHashSet`1<BaseEntity> entities
public TreeManager server
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 ProtoHalf3ToVec3(Half3 half3)
public Half3 Vec3ToProtoHalf3(Vector3 vec3)
public int GetTreeCount()
public void ServerInit()
public void OnTreeDestroyed(BaseEntity billboardEntity)
public void OnTreeSpawned(BaseEntity billboardEntity)
private void ExtractTreeNetworkData(BaseEntity billboardEntity, Tree tree)
public void SendSnapshot(BasePlayer player)
private void SERVER_RequestTrees(RPCMessage msg)
}
public TreeMarker : BaseEntity {
public GameObjectRef hitEffect
public SoundDefinition hitEffectSound
public GameObjectRef spawnEffect
private Vector3 initialPosition
public bool SpherecastOnInit
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public TreeMarkerData : PrefabAttribute {
public GenerationArc[] GenerationArcs
public MarkerLocation[] Markers
public Vector3 GenerationStartPoint
public float GenerationRadius
public float MaxY
public float MinY
public bool ProcessAngleChecks
protected Type GetIndexedType()
public Vector3 GetNearbyPoint(Vector3 point, Int32& ignoreIndex, Vector3& normal)
}
public TriangleIdentifier : MonoBehaviour {
public int TriangleID
public int SubmeshID
public float LineLength
private void OnDrawGizmosSelected()
}
public TriggerAchievement : TriggerBase {
public string statToIncrease
public string achievementOnEnter
public string requiredVehicleName
public bool serverSide
public bool allowDuringTutorial
private List`1<ulong> triggeredPlayers
public void OnPuzzleReset()
public void Reset()
public GameObject InterestedInObject(GameObject obj)
public void OnEntityEnter(BaseEntity ent)
}
public TriggerAnalytic : TriggerBase {
public string AnalyticMessage
public float Timeout
private List`1<RecentPlayerEntrance> recentEntrances
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
private void CheckTimeouts()
private bool IsPlayerValid(BasePlayer p)
}
public TriggerBanditZone : TriggerBase {
public float GetBanditZoneLevel(Vector3 pos)
}
public TriggerBase : BaseMonoBehaviour {
public LayerMask interestLayers
public HashSet`1<GameObject> contents
public HashSet`1<BaseEntity> entityContents
public Action`1<BaseNetworkable> OnEntityEnterTrigger
public Action`1<BaseNetworkable> OnEntityLeaveTrigger
public bool HasAnyContents
public bool HasAnyEntityContents
public bool get_HasAnyContents()
public bool get_HasAnyEntityContents()
public GameObject InterestedInObject(GameObject obj)
protected void OnDisable()
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
public void OnObjectAdded(GameObject obj, Collider col)
public void OnObjectRemoved(GameObject obj)
public void RemoveInvalidEntities()
public bool CheckEntity(BaseEntity ent)
public void OnObjects()
public void OnEmpty()
public void RemoveObject(GameObject obj)
public void RemoveEntity(BaseEntity ent)
public void OnTriggerEnter(Collider collider)
internal bool SkipOnTriggerExit(Collider collider)
public void OnTriggerExit(Collider collider)
public void OnTriggerExitImpl(GameObject targetObj)
}
public TriggerClanModify : TriggerBase {
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerComfort : TriggerBase {
public float triggerSize
public float baseComfort
public float minComfortRange
private float perPlayerComfortBonus
private float bonusComfort
private List`1<BasePlayer> _players
private void OnValidate()
public GameObject InterestedInObject(GameObject obj)
public float CalculateComfort(Vector3 position, BasePlayer forPlayer)
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
}
public TriggerDanceAchievement : TriggerBase {
public int RequiredPlayerCount
public string AchievementName
private List`1<NetworkableId> triggeredPlayers
public void OnPuzzleReset()
public void Reset()
internal GameObject InterestedInObject(GameObject obj)
public void NotifyDanceStarted()
}
public TriggeredEvent : MonoBehaviour {
public void RunEvent()
public void Kill()
}
public TriggeredEventPrefab : TriggeredEvent {
public GameObjectRef targetPrefab
public bool shouldBroadcastSpawn
public Phrase spawnPhrase
public BaseEntity spawnedEntity
public void RunEvent()
public void Kill()
}
public TriggerEnsnare : TriggerBase {
public bool blockHands
public GameObject InterestedInObject(GameObject obj)
}
public TriggerForce : TriggerBase {
public float GravityMultiplier
public float VelocityLerp
public float AngularDrag
public Vector3 velocity
public GameObject InterestedInObject(GameObject obj)
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
protected void FixedUpdate()
}
public TriggerHurt : TriggerBase {
public float DamagePerSecond
public float DamageTickRate
public DamageType damageType
public GameObject InterestedInObject(GameObject obj)
public void OnObjects()
public void OnEmpty()
private void OnTick()
protected bool CanHurt(BaseCombatEntity ent)
}
public TriggerHurtEx : TriggerBase {
public float repeatRate
public List`1<DamageTypeEntry> damageOnEnter
public GameObjectRef effectOnEnter
public HurtType hurtTypeOnEnter
public List`1<DamageTypeEntry> damageOnTimer
public GameObjectRef effectOnTimer
public HurtType hurtTypeOnTimer
public List`1<DamageTypeEntry> damageOnMove
public GameObjectRef effectOnMove
public HurtType hurtTypeOnMove
public List`1<DamageTypeEntry> damageOnLeave
public GameObjectRef effectOnLeave
public HurtType hurtTypeOnLeave
public bool damageEnabled
internal Dictionary`2<BaseEntity, EntityTriggerInfo> entityInfo
internal List`1<BaseEntity> entityAddList
internal List`1<BaseEntity> entityLeaveList
public GameObject InterestedInObject(GameObject obj)
internal void DoDamage(BaseEntity ent, HurtType type, List`1<DamageTypeEntry> damage, GameObjectRef effect, float multiply)
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
public void OnObjects()
public void OnEmpty()
private void OnTick()
private void ProcessQueues()
}
public TriggerHurtNotChild : TriggerBase {
public float DamagePerSecond
public float DamageTickRate
public float DamageDelay
public DamageType damageType
public bool ignoreNPC
public float npcMultiplier
public float resourceMultiplier
public bool triggerHitImpacts
public bool RequireUpAxis
public BaseEntity SourceEntity
public bool UseSourceEntityDamageMultiplier
public bool ignoreAllVehicleMounted
public float activationDelay
private Dictionary`2<BaseEntity, float> entryTimes
private TimeSince timeSinceAcivation
private IHurtTriggerUser hurtTiggerUser
public GameObject InterestedInObject(GameObject obj)
public void OnObjects()
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
public void OnEmpty()
protected void OnEnable()
public void OnDisable()
private bool IsInterested(BaseEntity ent)
private void OnTick()
}
public TriggerLadder : TriggerBase {
public LadderType Type
public GameObject InterestedInObject(GameObject obj)
}
public TriggerMagnet : TriggerBase {
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerMission : TriggerBase {
private BasePlayer cachedPlayer
internal void OnEntityEnter(BaseEntity ent)
private void DelayedEntityCallback()
}
public TriggerMount : TriggerBase {
private float MOUNT_DELAY
private float MAX_MOVE
private Dictionary`2<BaseEntity, EntryInfo> entryInfo
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
private void CheckForMount()
}
public TriggerMovement : TriggerBase {
public Transform losEyes
public MovementModify movementModify
}
public TriggerNoRespawnZone : TriggerBase {
public List`1<TriggerNoRespawnZone> allNRZones
public float maxDepth
public float maxAltitude
private SphereCollider sphereCollider
private float radiusSqr
protected void Awake()
protected void OnEnable()
protected void OnDisable()
internal GameObject InterestedInObject(GameObject obj)
public bool InAnyNoRespawnZone(Vector3 theirPos)
public bool InNoRespawnZone(Vector3 theirPos, bool checkRadius)
}
public TriggerNoSpray : TriggerBase {
public BoxCollider TriggerCollider
private OBB cachedBounds
private Transform cachedTransform
private void OnEnable()
internal GameObject InterestedInObject(GameObject obj)
public bool IsPositionValid(Vector3 worldPosition)
}
public TriggerNotify : TriggerBase {
public GameObject notifyTarget
private INotifyTrigger toNotify
public bool runClientside
public bool runServerside
public bool HasContents
public bool get_HasContents()
internal void OnObjects()
internal void OnEmpty()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public TriggerNotifyEntity : TriggerBase {
public GameObject notifyTarget
private INotifyEntityTrigger toNotify
public bool runClientside
public bool runServerside
public bool HasContents
public bool get_HasContents()
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public TriggerParent : TriggerBase {
public bool doClippingCheck
public BaseMountable associatedMountable
public bool parentMountedPlayers
public bool parentSleepers
public bool ParentNPCPlayers
public bool overrideOtherTriggers
public bool checkForObjUnderFeet
public int CLIP_CHECK_MASK
protected Collider triggerCollider
protected float triggerHeight
private BasePlayer killPlayerTemp
public GameObject InterestedInObject(GameObject obj)
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
public bool ShouldParent(BaseEntity ent, bool bypassOtherTriggerCheck)
public void ForceParentEarly(BaseEntity ent)
private void CheckAllParenting()
protected void Parent(BaseEntity ent)
protected void Unparent(BaseEntity ent)
private void KillPlayerDelayed()
private void OnTick()
protected bool IsClipping(BaseEntity ent)
private bool HasObjUnderFeet(BaseEntity ent)
}
public TriggerParentElevator : TriggerParentEnclosed {
public bool AllowHorsesToBypassClippingChecks
protected bool IsClipping(BaseEntity ent)
}
public TriggerParentEnclosed : TriggerParent {
public float Padding
public TriggerMode intersectionMode
public bool CheckBoundsOnUnparent
public BoxCollider boxCollider
protected void OnEnable()
public bool ShouldParent(BaseEntity ent, bool bypassOtherTriggerCheck)
internal bool SkipOnTriggerExit(Collider collider)
public bool IsInside(BaseEntity ent, float padding)
}
public TriggerParentExclusion : TriggerBase {
public GameObject InterestedInObject(GameObject obj)
}
public TriggerPlayerForce : TriggerBase {
public BoxCollider triggerCollider
public float pushVelocity
public bool requireUpAxis
private float HACK_DISABLE_TIME
internal GameObject InterestedInObject(GameObject obj)
internal void OnObjects()
internal void OnEmpty()
protected void OnDisable()
internal void OnEntityLeave(BaseEntity ent)
private void HackDisableTick()
protected void FixedUpdate()
private Vector3 GetPushVelocity(GameObject obj)
private bool IsInterested(BaseEntity entity)
}
public TriggerPlayerTimer : TriggerBase {
public BaseEntity TargetEntity
public float DamageAmount
public float TimeToDamage
internal GameObject InterestedInObject(GameObject obj)
internal void OnObjects()
internal void OnEmpty()
private void DamageTarget()
}
public TriggerRadiation : TriggerBase {
public RadiationTier radiationTier
public bool BypassArmor
public float RadiationAmountOverride
public float falloff
private SphereCollider sphereCollider
private float GetRadiationSize()
private float GetRadiationAmount()
public float GetRadiation(Vector3 position, float radProtection)
public GameObject InterestedInObject(GameObject obj)
public void OnDrawGizmosSelected()
}
public TriggerRagdollRelocate : TriggerBase {
public Transform targetLocation
internal void OnObjectAdded(GameObject obj, Collider col)
private void RepositionTransform(Transform t)
}
public TriggerResetter : StateMachineBehaviour {
public string triggerName
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public TriggerSafeZone : TriggerBase {
public List`1<TriggerSafeZone> allSafeZones
public float maxDepth
public float maxAltitude
private Collider <triggerCollider>k__BackingField
public Collider triggerCollider
public Collider get_triggerCollider()
private void set_triggerCollider(Collider value)
protected void Awake()
protected void OnEnable()
protected void OnDisable()
internal GameObject InterestedInObject(GameObject obj)
public bool PassesHeightChecks(Vector3 entPos)
public float GetSafeLevel(Vector3 pos)
}
public TriggerSnowmobileAchievement : TriggerBase {
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerStashPlayer : TriggerBase {
public StashContainer Stash
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
}
public TriggerSubmarineMoonpool : TriggerBase {
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
}
public TriggerTemperature : TriggerBase {
public float Temperature
public float triggerSize
public float minSize
public bool sunlightBlocker
public float sunlightBlockAmount
public float blockMinHour
public float blockMaxHour
private void OnValidate()
public float WorkoutTemperature(Vector3 position, float oldTemperature)
public GameObject InterestedInObject(GameObject obj)
}
public TriggerTrainCollisions : TriggerBase {
public Collider triggerCollider
public Location location
public TrainCar owner
public HashSet`1<GameObject> staticContents
public HashSet`1<TrainCar> trainContents
public HashSet`1<Rigidbody> otherRigidbodyContents
public HashSet`1<Collider> colliderContents
private float TICK_RATE
public bool HasAnyStaticContents
public bool HasAnyTrainContents
public bool HasAnyOtherRigidbodyContents
public bool HasAnyNonStaticContents
public bool get_HasAnyStaticContents()
public bool get_HasAnyTrainContents()
public bool get_HasAnyOtherRigidbodyContents()
public bool get_HasAnyNonStaticContents()
internal void OnObjectAdded(GameObject obj, Collider col)
internal void OnObjectRemoved(GameObject obj)
private void TrainContentsTick()
private bool <OnObjectRemoved>g__HasAnotherColliderFor|18_0(T component)
}
public TriggerTutorialPrompt : TriggerBase {
public TutorialFullScreenHelpInfo ToDisplay
public BaseMission RequiredMission
public int RequiredMissionStageActive
public bool OnlyShowOnce
public CustomCloseAction CloseAction
public bool DebugConditions
public bool DeathDisplay
}
public TriggerVehicleDrag : TriggerBase {
public Transform losEyes
public float vehicleDrag
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerVehiclePush : TriggerBase {
public BaseEntity thisEntity
public float maxPushVelocity
public float minRadius
public float maxRadius
public bool snapToAxis
public Vector3 axisToSnapTo
public bool allowParentRigidbody
public bool useRigidbodyPosition
public bool useCentreOfMass
public int ContentsCount
public GameObject InterestedInObject(GameObject obj)
public int get_ContentsCount()
public void FixedUpdate()
public void OnDrawGizmosSelected()
}
public TriggerWakeAIZ : TriggerBase {
public float SleepDelaySeconds
public List`1<AIInformationZone> zones
private AIInformationZone aiz
public void Init(AIInformationZone zone)
private void Awake()
private void SetZonesSleeping(bool flag)
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
private void DelayedSleepAI()
private void SleepAI()
}
public TriggerWetness : TriggerBase {
public float Wetness
public SphereCollider TargetCollider
public Transform OriginTransform
public bool ApplyLocalHeightCheck
public float MinLocalHeight
public float WorkoutWetness(Vector3 position)
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerWorkbench : TriggerBase {
public Workbench parentBench
public GameObject InterestedInObject(GameObject obj)
public float WorkbenchLevel()
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
}
public trisPerSubmesh : object {
public Int32[] triangles
}
public Tugboat : MotorRowboat {
private Canvas monitorCanvas
private RustText fuelText
private RustText speedText
private ParticleSystemContainer exhaustEffect
private SoundDefinition lightsToggleSound
private Transform steeringWheelLeftHandTarget
private Transform steeringWheelRightHandTarget
private SonarSystem sonar
private TugboatSounds tugboatSounds
private CanvasGroup canvasGroup
private EmissionToggle emissionToggle
private AnimationCurve emissionCurve
private ParticleSystemContainer fxLightDamage
private ParticleSystemContainer fxMediumDamage
private ParticleSystemContainer fxHeavyDamage
private GameObject heavyDamageLights
private TriggerParent parentTrigger
public float tugcorpseseconds
public float tugdecayminutes
public float tugdecaystartdelayminutes
public bool LightsAreOn
protected bool AllowKinematicDrift
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_LightsAreOn()
public void Load(LoadInfo info)
public float MaxVelocity()
protected bool get_AllowKinematicDrift()
public void VehicleFixedUpdate()
public void Save(SaveInfo info)
public void BoatDecay()
public int StartingFuelUnits()
public void LightToggle(BasePlayer player)
protected void EnterCorpseState()
public bool AnyPlayersOnBoat()
public bool BuoyancySleep(bool inWater)
public bool BuoyancyWake()
public bool SupportsChildDeployables()
public bool ForceDeployableSetParent()
protected bool CanPushNow(BasePlayer pusher)
}
public TugboatInteriorSoundTrigger : MonoBehaviour {
public TugboatSounds tugboatSounds
public bool bridge
}
public TugboatSounds : MonoBehaviour {
private Tugboat tugboat
private float roughHalfWidth
private float roughHalfLength
private float soundCullDistanceSq
private SoundDefinition engineLoopDef
private Sound engineLoop
private Modulator engineGainMod
private Modulator enginePitchMod
private SoundDefinition engineStartDef
private SoundDefinition engineStartBridgeDef
private SoundDefinition engineStopDef
private SoundDefinition engineStopBridgeDef
private float engineGainChangeRate
private float enginePitchChangeRate
private Transform engineTransform
private Transform bridgeControlsTransform
private SoundDefinition waterIdleDef
private SoundDefinition waterSideMovementSlowDef
private SoundDefinition waterSideMovementFastDef
private SoundDefinition waterSternMovementDef
private SoundDefinition waterInteriorIdleDef
private SoundDefinition waterInteriorDef
private AnimationCurve waterMovementGainCurve
private float waterMovementGainChangeRate
private AnimationCurve waterDistanceGainCurve
private Sound leftWaterSound
private Modulator leftWaterGainMod
private Sound rightWaterSound
private Modulator rightWaterGainMod
private Sound sternWaterSound
private Modulator sternWaterGainMod
private Transform wakeTransform
private Vector3 sideSoundLineStern
private Vector3 sideSoundLineBow
private Sound ambientIdleSound
private SoundDefinition ambientActiveLoopDef
private Sound ambientActiveSound
private SoundDefinition hullGroanDef
private float hullGroanCooldown
private float lastHullGroan
private SoundDefinition chainRattleDef
private float chainRattleCooldown
private Transform[] chainRattleLocations
private float chainRattleAngleDeltaThreshold
private float lastChainRattle
private Line leftSoundLine
private Line rightSoundLine
public bool engineOn
public bool throttleOn
public bool inWater
}
public TunnelDweller : HumanNPC {
private string DWELLER_KILL_STAT
protected string OverrideCorpseName()
protected void OnKilledByPlayer(BasePlayer p)
}
public TutorialBuildTarget : MonoBehaviour {
public BaseEntityRef TargetPrefab
public ItemDefinition TargetItemDef
public GameObject VisualObject
public Vector3 PhysCheckOffset
public bool Snap
public float MaxDistance
public BaseMission RequiredMission
public int RequiredMissionStage
public float MaxValidAngle
public bool IsValid(Construction toConstruct, Target target, Placement placement)
public bool IsValid(BasePlayer player, Deployable deployable, Vector3 worldPosition, Quaternion worldRotation)
public void UpdateActive(BasePlayer p)
private bool HasTargetBeenBuilt()
}
public TutorialContainer : StorageContainer {
private bool acceptingItems
public void LoadStorage(ItemAmount[] toLoad)
public void ServerInit()
private bool CanAcceptItem(Item item, int targetSlot)
}
public TutorialFullScreenHelpInfo : ScriptableObject {
public Phrase MovementPhrase
public Phrase CraftingPhrase
public Phrase CombatPhrase
public Phrase BuildingPhrase
public Dictionary`2<MenuCategory, Phrase> CategoryPhraseLookup
public MenuCategory Category
public int Priority
public TokenisedPhrase TextToDisplay
public Sprite StaticImage
public VideoClip VideoClip
}
public TutorialHelpPopup : ListComponent`1<TutorialHelpPopup> {
public RustText HelpText
public Image HelpImage
public VideoPlayer HelpVideo
public RawImage HelpVideoTexture
public CanvasGroup Group
public Canvas Canvas
}
public TutorialIsland : BaseEntity {
public EntityRef`1<BasePlayer> ForPlayer
public Transform InitialSpawnPoint
public Transform MidMissionSpawnPoint
public int SpawnLocationIndex
public TutorialNPC StartTutorialNPC
public TutorialContainer TutorialContainer
public MonumentNavMesh MonumentNavMesh
public FoliageGridBaked FoliageGrid
public MeshTerrainRoot MeshTerrain
public Transform KayakPoint
public BaseMission FinalMission
public float TimeOfDay
public ItemDefinition rockDefinition
public WeatherPreset Weather
public BaseMission TestMission
private TutorialBuildTarget[] buildTargets
public Phrase NoTutorialIslandsAvailablePhrase
public Phrase TutorialIslandStartCooldown
public ListHashSet`1<IslandBounds> BoundsListServer
public float TutorialBoundsSize
public bool SpawnTutorialIslandForNewPlayer
private ListHashSet`1<TutorialIsland> ActiveIslandsServer
public bool EnforceTrespassChecks
public Vector3 OverrideTutorialLocation
private string TutorialIslandAssetPath
private float _tutorialWorldStart
public Bounds WorldBoundsMinusTutorialIslands
private List`1<Vector3> islandSpawnLocations
private List`1<int> freeIslandLocations
private float tutorialDuration
private float disconnectedDuration
private bool readyToStartConversation
private float tickRate
private Vector3 kayakAnchorPoint
private Kayak kayakToAnchor
private TimeSince rockCheck
public float TutorialWorldStart
public float TutorialWorldNetworkThreshold
public int MaxTutorialIslandCount
public TimeSpan TutorialDuration
public float DisconnectTimeOutDuration
public bool HasAvailableTutorialIsland
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ListHashSet`1<TutorialIsland> GetTutorialList(bool isServer)
public UInt32 GetTutorialGroupId(int index)
public bool IsTutorialNetworkGroup(UInt32 grp)
public float get_TutorialWorldStart()
public float get_TutorialWorldNetworkThreshold()
public int get_MaxTutorialIslandCount()
public TimeSpan get_TutorialDuration()
public float get_DisconnectTimeOutDuration()
public void GenerateIslandSpawnPoints(bool loadingSave)
public Group GetTutorialGroup(int index)
public int AvailableIslandCount()
public bool ShouldPlayerResumeTutorial(BasePlayer player)
public bool ShouldPlayerBeAskedToStartTutorial(BasePlayer player)
public TutorialIsland RestoreOrCreateIslandForPlayer(BasePlayer player, bool triggerAnalytics)
public bool get_HasAvailableTutorialIsland()
private TutorialIsland CreateIslandForPlayer(BasePlayer player)
private Group SetupGroup(int spawnLocationIndex, Vector3 worldPos, Quaternion worldRot)
private int GetUnusedTutorialIslandLocationRotation(Vector3& worldPos, Quaternion& worldRot)
public void AddIslandFromSave(TutorialIsland island)
public void GenerateNavMesh()
public IEnumerator UpdateNavMesh()
private void StartInitialConversation()
public void ServerInit()
private void InitSpawnGroups()
public void OnPlayerBuiltConstruction(BasePlayer player)
public void Save(SaveInfo info)
public void GetBuildTargets(List`1<TutorialBuildTarget> targetList, UInt32 targetPrefab)
public Vector3 GetWorldPosOfBuildTarget(int index)
public void StartEndingCinematic(BasePlayer player)
private void AnchorKayak()
public void OnPlayerCompletedTutorial(BasePlayer player, bool isQuit, bool triggerAnalytics)
private void KillPlayerAtEndOfTutorial()
private void DelayedCompleteTutorial()
public void Return()
private void ReturnIsland(TutorialIsland island)
public void Tick()
private void TickPlayerConnectionStatus()
public bool IsPingValid(MapNote note)
public TutorialIsland GetClosestTutorialIsland(Vector3 position, float maxRange)
public void OnPlayerStartedMission(BasePlayer player)
public void Load(LoadInfo info)
public bool CheckPlacement(Construction toConstruct, Target target, Placement placement)
public bool CheckPlacement(BasePlayer forPlayer, Deployable deployable, Vector3 worldPosition, Quaternion worldRotation)
public void InitShared()
public void DestroyShared()
private void AddIslandBounds(OBB worldBounds, UInt32 netId, bool isServer)
private void RemoveIslandBounds(UInt32 netId, bool isServer)
public bool SupportsChildDeployables()
public bool ForceDeployableSetParent()
}
public TutorialIslandSpawner : object {
public List`1<Vector3> GetEdgeSpawnPoints(Vector3 start, Vector3 bounds, Vector3 cellSize, int loopCount, Bounds& worldBoundsMinusTutorialIslands)
public List`1<Vector3> GetEdgeSpawnPoints(Vector3 start, Vector3 bounds, Vector3 cellSize, int curLoop)
}
public TutorialMissionHelpSet : ScriptableObject {
public TutorialFullScreenHelpInfo[] Infos
}
public TutorialNPC : NPCMissionProvider {
public ConversationData StartConversation
public ConversationData MissionInProgressConversation
public ConversationData ForageCompleteConversation
public ConversationData FirstBuildCompleteConversation
public ConversationData SecondBuildCompleteConversation
public ConversationData PrepareForCombatConversation
public ConversationData BuildKayakConversation
public ConversationData SetSailConversation
public ConversationData PostBearAttackConversation
public BaseMission PostBearAttackMission
public GameObjectRef BearRoarSfx
public Transform BearRoarSpawnPos
public float TalkingHeadIkWeight
public RuntimeAnimatorController CustomAnimator
private int IsTalking
private UInt32 FORAGE_MISSION
private UInt32 BUILD1_MISSION
private UInt32 BUILD2_MISSION
private UInt32 COOK_MISSION
private UInt32 KILL_BEAR_MISSION
private UInt32 CRAFT_KAYAK_MISSION
public UInt32 BEAR_ATTACK_RESPAWN_MISSION
private BasePlayer playerToKill
protected bool CanTalkTo(BasePlayer bp)
public ConversationData GetConversationFor(BasePlayer player)
public void OnConversationAction(BasePlayer player, string action)
private void WaitAndKill()
public void PostServerLoad()
public void GreetPlayer(BasePlayer player)
public void Greeting()
public void OnConversationStarted(BasePlayer speakingTo)
public void OnConversationEnded(BasePlayer player)
}
public TutorialOptionsPrompt : MonoBehaviour {
public CanvasGroup Group
public GameObject NotConnectedToValidServerRoot
public GameObject ServerValidRoot
public GameObject TutorialInProcessRoot
}
public TweakUI : SingletonComponent`1<TweakUI> {
public bool isOpen
private void Update()
protected bool CanToggle()
public void SetVisible(bool b)
}
public TweakUIBase : MonoBehaviour {
public string convarName
public bool ApplyImmediatelyOnChange
internal Command conVar
private void Awake()
protected void Init()
public void OnApplyClicked()
public void UnapplyChanges()
protected void OnConVarChanged(Command obj)
public void ResetToConvar()
protected void SetConvarValue()
private void OnDestroy()
}
public TweakUIDropdown : TweakUIBase {
public RustText Current
public Image BackgroundImage
public RustButton Opener
public RectTransform Dropdown
public RectTransform DropdownContainer
public GameObject DropdownItemPrefab
public NameValue[] nameValues
public bool assignImageColor
public UnityEvent onValueChanged
public int currentValue
protected void Init()
protected void OnEnable()
public void UpdateDropdownOptions()
public void OnValueChanged()
public void OnDropdownOpen()
public void ChangeValue(int index)
protected void SetConvarValue()
public void ResetToConvar()
private void ShowValue(string value)
}
public TweakUIMultiSelect : TweakUIBase {
public ToggleGroup toggleGroup
protected void Init()
protected void OnEnable()
public void OnChanged()
private void UpdateToggleGroup()
private void UpdateConVar()
}
public TweakUISlider : TweakUIBase {
public Slider sliderControl
public TextMeshProUGUI textControl
public string lastConVarChanged
public TimeSince timeSinceLastConVarChange
protected void Init()
protected void OnEnable()
public void OnChanged()
protected void SetConvarValue()
public void ResetToConvar()
private void RefreshSliderDisplay(float value)
}
public TweakUIToggle : TweakUIBase {
public Toggle toggleControl
public bool inverse
public string lastConVarChanged
public TimeSince timeSinceLastConVarChange
protected void Init()
protected void OnEnable()
public void OnToggleChanged()
protected void SetConvarValue()
public void ResetToConvar()
}
public TwitchBus : CH47Helicopter {
public LineRenderer[] LineRenderers
public Transform[] LineRendererBusPoints
public Transform[] HelicopterPoints
}
public TwitchTrophy : BaseCombatEntity {
public GameObjectRef DialogPrefab
}
public TypeThroughButton : Button {
public InputField typingTarget
private Event _processingEvent
public void OnUpdateSelected(BaseEventData eventData)
private IEnumerator DelayedActivateTextField(Event e)
}
public UGCType : Enum {
public int value__
public UGCType ImageJpg
public UGCType ImagePng
public UGCType AudioOgg
public UGCType PatternBoomer
}
public UI_LocalVoice : PriorityListComponent`1<UI_LocalVoice> {
public CanvasGroup voiceCanvas
public CanvasGroup levelImage
}
public UIAIDesignerScreen : SingletonComponent`1<UIAIDesignerScreen> {
public GameObject SaveEntityButton
public GameObject SaveServerButton
public GameObject SaveDefaultButton
public RustInput InputAIDescription
public RustText TextDefaultStateContainer
public Transform PrefabAddNewStateButton
public Transform StateContainer
public Transform PrefabState
public EnumListUI PopupList
public EnumListUI EnumList
public NeedsCursor needsCursor
protected CanvasGroup canvasGroup
public GameObject RootPanel
}
public UIAutoPanelCloser : MonoBehaviour {
public UIDialog Dialog
}
public UIBackgroundBlur : ListComponent`1<UIBackgroundBlur> {
public float amount
public float currentMax
public float get_currentMax()
}
public UIBelt : SingletonComponent`1<UIBelt> {
public List`1<ItemIcon> ItemIcons
protected void Awake()
public ItemIcon GetItemIconAtSlot(int slot)
}
public UIBlackoutOverlay : MonoBehaviour {
public CanvasGroup group
public Dictionary`2<blackoutType, UIBlackoutOverlay> instances
public blackoutType overlayType
public bool overrideCanvasScaling
public float referenceScale
}
public UIBlueprints : ListComponent`1<UIBlueprints> {
public GameObjectRef buttonPrefab
public ScrollRect scrollRect
public CanvasGroup ScrollRectCanvasGroup
public InputField searchField
public GameObject searchFieldPlaceholder
public GameObject listAvailable
public GameObject listLocked
public GameObject Categories
public VerticalLayoutGroup CategoryVerticalLayoutGroup
public BlueprintCategoryButton FavouriteCategoryButton
}
public UIBuffs : SingletonComponent`1<UIBuffs> {
public bool Enabled
public Transform PrefabBuffIcon
public void Refresh(PlayerModifiers modifiers)
private void RemoveAll()
}
public UIBuffsIcon : SingletonComponent`1<UIBuffsIcon> {
public TextMeshProUGUI Text
public Tooltip ToolTip
public CanvasGroup Group
}
public UICameraOverlay : SingletonComponent`1<UICameraOverlay> {
public Phrase FocusOffText
public Phrase FocusAutoText
public Phrase FocusManualText
public CanvasGroup CanvasGroup
public RustText FocusModeLabel
public void Show()
public void Hide()
public void SetFocusMode(CameraFocusMode mode)
}
public UIChat : PriorityListComponent`1<UIChat> {
public GameObject inputArea
public GameObject chatArea
public TMP_InputField inputField
public TextMeshProUGUI channelLabel
public ScrollRect scrollRect
public CanvasGroup canvasGroup
public bool allowOpeningWhileCursorVisible
public GameObjectRef chatItemPlayer
public GameObject userPopup
public EmojiGallery emojiGallery
public bool isOpen
}
public UIChatPopup : MonoBehaviour {
public TextMeshProUGUI TextToggleMute
public TextMeshProUGUI TextToggleGlobalMute
public Button MuteButton
public Button ReportButton
public GameObject InviteToTeamButton
}
public UIClanConfirmation : BaseMonoBehaviour {
public RustText Text
public RustText TryAgainText
}
public UIClanCreator : BaseMonoBehaviour {
public Phrase CreateNameBlank
public Phrase CreateNameInvalid
public Phrase CreateAlreadyInClan
public Phrase CreateDuplicateName
public Phrase CreateFailure
public UIClans UiClans
public RustInput ClanName
}
public UIClanInvitation : BaseMonoBehaviour {
public Phrase AcceptInvitationFailure
public Phrase AcceptInvitationFull
public Phrase DeclineInvitationFailure
public RustText ClanName
public RustText ClanMembers
public Image ClanBanner
public RawImage RecruiterAvatar
public RustText RecruiterName
public GameObject ActionsContainer
}
public UIClanInvitations : BaseMonoBehaviour {
public UIClans UiClans
public RectTransform InvitationList
public GameObjectRef InvitationPrefab
}
public UIClanInvite : BaseMonoBehaviour {
public Phrase CancelInviteFailure
public RawImage Avatar
public RustText Name
public RustText Recruiter
public RustText Created
public RustButton CancelButton
}
public UIClanInvites : BaseMonoBehaviour {
public UIClans UiClans
public RectTransform InviteList
public GameObjectRef InvitePrefab
}
public UIClanLeaderboard : BaseMonoBehaviour {
public UIClans UiClans
public GameObject LoadingIndicator
public GameObject Content
public RectTransform EntryList
public GameObjectRef EntryPrefab
}
public UIClanLeaderboardEntry : MonoBehaviour {
public RustText ClanName
public RustText Score
}
public UIClanLog : BaseMonoBehaviour {
public Phrase RefreshFailure
public UIClans UiClans
public RectTransform EntryList
public GameObjectRef EntryPrefab
}
public UIClanLogEntry : BaseMonoBehaviour {
public Phrase FoundedEvent
public Phrase SetMotdEvent
public Phrase SetLogoEvent
public Phrase SetColorEvent
public Phrase InviteEvent
public Phrase LeaveEvent
public Phrase KickEvent
public Phrase AcceptInviteEvent
public Phrase DeclineInviteEvent
public Phrase CancelInviteEvent
public Phrase CreateRoleEvent
public Phrase UpdateRoleEvent
public Phrase UpdateRoleRenamedEvent
public Phrase SwapRolesEvent
public Phrase DeleteRoleEvent
public Phrase ChangeRoleEvent
public Phrase SetNotesEvent
public RustText Event
public RustText Time
}
public UIClanMember : BaseMonoBehaviour {
public Phrase OnlinePhrase
public Image Highlight
public Color HighlightColor
public Color SelectedColor
public RawImage Avatar
public RustText Name
public RustText Rank
public RustText LastSeen
}
public UIClanMemberDetails : UIClanMember {
public Phrase KickConfirmation
public Phrase SaveNotesFailure
public Phrase ChangeRankCannotDemoteLeader
public Phrase ChangeRankFailure
public Phrase KickFailure
public UIClans UiClans
public RustInput NoteEditor
public RustButton SaveNoteButton
public GameObject ChangeRankSection
public Dropdown ChangeRankDropdown
public GameObject KickSection
public RustButton KickButton
}
public UIClanMembers : BaseMonoBehaviour {
public UIClans UiClans
public RectTransform MemberList
public GameObjectRef MemberPrefab
public UIClanMemberDetails MemberDetails
}
public UIClanOverview : BaseMonoBehaviour {
public Phrase SetMotdFailure
public UIClans UiClans
public RawImage MotdAuthorAvatar
public RustText MotdAuthorName
public RustText MotdTime
public RustInput MotdInput
public RustButton MotdSaveButton
public RustButton MotdCancelButton
}
public UIClanRank : BaseMonoBehaviour {
public Phrase MoveUpFailure
public Phrase MoveDownFailure
public Phrase DeleteRankFailure
public Phrase DeleteRankNotEmpty
private Memoized`2<string, int> IndexToString
public Image Highlight
public RustText IndexLabel
public RustText Name
public RustButton MoveUpButton
public RustButton MoveDownButton
public RustButton DeleteButton
}
public UIClanRankCreator : BaseMonoBehaviour {
public Phrase CreateRankFailure
public Phrase CreateRankDuplicate
public Phrase CreateRankNameInvalid
public UIClans UiClans
public RustInput RankName
public RustButton Submit
}
public UIClanRankEditor : BaseMonoBehaviour {
public Phrase SaveRankFailure
public Phrase SaveRankDuplicate
public UIClans UiClans
public RustInput NameEditor
public RustButton SetMotd
public RustButton SetLogo
public RustButton Invite
public RustButton Kick
public RustButton Promote
public RustButton Demote
public RustButton SetPlayerNotes
public RustButton AccessLogs
public RustButton AccessScoreEvents
public RustButton CancelButton
public RustButton SubmitButton
}
public UIClanRanks : BaseMonoBehaviour {
public UIClans UiClans
public RectTransform RankContainer
public GameObjectRef RankPrefab
public UIClanRankCreator RankCreator
public RectTransform RankListing
public UIClanRankEditor RankEditor
}
public UIClans : SingletonComponent`1<UIClans> {
public Phrase LeaveConfirmation
public Phrase GetInvitationsFailure
public Phrase GetClanFailure
public Phrase LeaveFailure
public Phrase LeaveNoOtherLeader
public CanvasGroup CanvasGroup
public UIEscapeCapture EscapeCapture
public NeedsCursor NeedsCursor
public NeedsKeyboard NeedsKeyboard
public GameObject ClanTableRequired
public GameObject EmptyState
public GameObject CreateState
public GameObject InvitesState
public GameObject MainState
public RustText ClanName
public Image ClanBanner
public RawImage ClanLogo
public RustText ClanMembers
public RustText ClanScore
public RustButton LeaveButton
public Texture2D DefaultLogo
public RustButton OverviewButton
public RustButton ScoreEventsButton
public RustButton LogsButton
public RustButton SettingsButton
public RustButton CreatePrompt
public CanvasGroup LoadingIndicator
public UIClanLeaderboard Leaderboard
public UIClanConfirmation Confirmation
public UIClanConfirmation Error
public UIClanInvitations Invitations
public UIClanOverview Overview
public UIClanMembers Members
public UIClanInvites Invites
public UIClanRanks Ranks
public UIClanScoreEvents ScoreEvents
public UIClanLog Logs
public UIClanSettings Settings
}
public UIClanScoreEvents : BaseMonoBehaviour {
public Phrase RefreshFailure
public UIClans UiClans
public RectTransform EntryList
public GameObjectRef EntryPrefab
}
public UIClanScoreEventsEntry : BaseMonoBehaviour {
public Phrase ClanPlayerKilledEvent
public Phrase ClanPlayerDiedEvent
public Phrase KilledUnarmedEvent
public Phrase DestroyedToolCupboardEvent
public Phrase HackedCrateEvent
public Phrase OpenedHackedCrateEvent
public Phrase DestroyedBradleyEvent
public Phrase RanExcavatorEvent
public Phrase ReachedCargoShipEvent
public Phrase LootedEliteCrateEvent
public Phrase UnknownEvent
public RustText Event
public RustText Score
public RustText Multiplier
public RustText Time
}
public UIClanSettings : BaseMonoBehaviour {
public Phrase SetLogoFailure
public Phrase SetColorFailure
public UIClans UiClans
public RustButton EditLogoButton
public GameObjectRef ChangeSignDialog
public MeshPaintableSource[] PaintableSources
public RectTransform ColorsContainer
}
public UIColorPickerButton : MonoBehaviour {
public Image Image
public Color Color
}
public UICompass : MonoBehaviour {
public RawImage compassStrip
public CanvasGroup compassGroup
public List`1<CompassMapMarker> CompassMarkers
public List`1<CompassMapMarker> TeamCompassMarkers
public List`1<CompassMissionMarker> MissionMarkers
public CompassMapMarker DeathMarker
public Phrase IslandInfoPhrase
public RectTransform IslandInfoContainer
public RustText IslandInfoText
public float IslandInfoDistanceThreshold
public float IslandLookThreshold
public RectTransform IslandInfoFullContainer
public List`1<CompassMapMarker> LocalPings
public List`1<CompassMapMarker> TeamPings
public Image LeftPingPulse
public Image RightPingPulse
}
public UIConfirmationPopup : MonoBehaviour {
private Transform buttonsParent
private RustText messageText
private RustButton buttonTemplate
public RustButton[] buttons
}
public UIContacts : SingletonComponent`1<UIContacts> {
public bool isOpen
public float LastOpened
public ContactsPanel contactsPanel
}
public UIConversationScreen : SingletonComponent`1<UIConversationScreen> {
public NeedsCursor needsCursor
public RectTransform conversationPanel
public RustText conversationSpeechBody
public RustText conversationProviderName
public Image conversationProviderImage
public RustButton[] responseButtons
public RectTransform letterBoxTop
public RectTransform letterBoxBottom
public GameObject cancelButton
protected CanvasGroup canvasGroup
public UIMissionInfoConversation missionInfo
public UIEscapeCapture escapeCapture
}
public UICrafting : SingletonComponent`1<UICrafting> {
public GameObject skinViewerPrefab
public bool isOpen
public float LastOpened
}
public UIDeathScreen : SingletonComponent`1<UIDeathScreen> {
public LifeInfographic previousLifeInfographic
public Animator screenAnimator
public bool fadeIn
public Button ReportCheatButton
public MapView View
public List`1<SleepingBagButton> sleepingBagButtons
public GameObject loadingIndicator
public RespawnColourScheme[] RespawnColourSchemes
public GameObject RespawnScrollGradient
public ScrollRect RespawnScrollRect
public ExpandedLifeStats ExpandedStats
public GameObject OpenStatsButton
public CanvasGroup StreamerModeContainer
public GameObject SafeZoneInfo
}
public UIDialog : ListComponent`1<UIDialog> {
public SoundDefinition openSoundDef
public SoundDefinition closeSoundDef
}
public UIEscapeCapture : ListComponent`1<UIEscapeCapture> {
public UnityEvent onEscape
public bool EscapePressed()
}
public UIFadeOut : MonoBehaviour {
public float secondsToFadeOut
public bool destroyOnFaded
public CanvasGroup targetGroup
public float fadeDelay
}
public UIFireworkDesigner : UIDialog {
public RustInput Title
public RustText StarsPlaced
public RectTransform Canvas
public RectTransform InnerCanvas
public GameObject StarPrefab
}
public UIFireworkDesignItem : MonoBehaviour {
public Phrase EmptyPhrase
public Phrase UntitledPhrase
public RustText Title
public RustButton LoadButton
public RustButton SaveButton
public RustButton EraseButton
public UIFireworkDesigner Designer
public int Index
}
public UIFireworkStar : EventTrigger {
public Image Image
public RustText Text
}
public UIFishing : SingletonComponent`1<UIFishing> {
public Slider TensionLine
public Image FillImage
public Gradient FillGradient
private void Start()
}
public UIFogOverlay : MonoBehaviour {
public UIFogOverlay Instance
public CanvasGroup group
public Color baseColor
public Image overlayImage
}
public UIGene : MonoBehaviour {
public GameObject Child
public Color PositiveColour
public Color NegativeColour
public Color PositiveTextColour
public Color NegativeTextColour
public Image ImageBG
public Text TextGene
public void Init(GrowableGene gene)
public void InitPrevious(GrowableGene gene)
public void Hide()
public void Show()
}
public UIGenesDisplay : MonoBehaviour {
public UIGene[] GeneUI
public Text[] TextLinks
public Text[] TextDiagLinks
public void Init(GrowableGenes genes)
public void InitDualRow(GrowableGenes genes, bool firstRow)
private void InitFirstRow(GrowableGenes genes)
private void InitSecondRow(GrowableGenes genes)
private void ShowDiagLink(int index, float rotation, GrowableGene nextGene)
}
public UIHUD : SingletonComponent`1<UIHUD> {
public UIChat chatPanel
public HudElement Hunger
public HudElement Thirst
public HudElement Health
public HudElement PendingHealth
public HudElement VehicleHealth
public HudElement AnimalStamina
public HudElement AnimalStaminaMax
public RectTransform vitalsRect
public Canvas healthCanvas
public UICompass CompassWidget
public GameObject KeyboardCaptureMode
}
public UIIntegerEntry : MonoBehaviour {
public InputField textEntry
private Action textChanged
public void add_textChanged(Action value)
public void remove_textChanged(Action value)
public void OnAmountTextChanged()
public void SetAmount(int amount)
public int GetIntAmount()
public void PlusMinus(int delta)
}
public UIInventory : SingletonComponent`1<UIInventory> {
public TextMeshProUGUI PlayerName
public bool isOpen
public float LastOpened
public VerticalLayoutGroup rightContents
public GameObject QuickCraft
public Transform InventoryIconContainer
public ChangelogPanel ChangelogPanel
public ContactsPanel contactsPanel
public GameObject backpackSlot
public UnderwearSkinPicker underwearSkinPicker
}
public UIInvertedMaskImage : Image {
private Material cachedMaterial
public Material materialForRendering
public Material get_materialForRendering()
}
public UIMapGenericRadius : MonoBehaviour {
public Image radialImage
public Image outlineImage
public float radius
public CanvasGroup fade
public RectTransform rect
}
public UIMapMissionProvider : MonoBehaviour {
public Tooltip TargetTooltip
public RustText CountText
}
public UIMapVendingMachineMarker : MonoBehaviour {
public Color inStock
public Color outOfStock
public Image colorBackground
public string displayName
public Tooltip toolTip
public RustButton button
}
public UIMapVendingMachineMarkerCluster : MonoBehaviour {
public GameObject OpenRoot
public TextMeshProUGUI CountText
public GameObjectRef MarkerPrefab
public Transform MarkerParent
}
public UIMarketSearch : MonoBehaviour {
public GameObjectRef StoreEntryRef
public RectTransform StoreRoot
public UIMarketTerminal Terminal
}
public UIMarketSearchOrderEntry : MonoBehaviour {
public RustText ItemName
public GameObject OutOfStockRoot
public GameObject BpRoot
}
public UIMarketSearchStore : MonoBehaviour {
public RustText StoreName
public List`1<UIMarketSearchOrderEntry> Entries
}
public UIMarketTerminal : UIDialog {
public Phrase PendingDeliveryPluralPhrase
public Phrase PendingDeliverySingularPhrase
public Canvas canvas
public MapView mapView
public RectTransform shopDetailsPanel
public float shopDetailsMargin
public float easeDuration
public LeanTweenType easeType
public TmProEmojiRedirector shopName
public GameObject shopOrderingPanel
public RectTransform sellOrderContainer
public GameObjectRef sellOrderPrefab
public VirtualItemIcon deliveryFeeIcon
public GameObject deliveryFeeCantAffordIndicator
public GameObject inventoryFullIndicator
public GameObject notEligiblePanel
public GameObject pendingDeliveryPanel
public RustText pendingDeliveryLabel
public RectTransform itemNoticesContainer
public GameObjectRef itemRemovedPrefab
public GameObjectRef itemPendingPrefab
public GameObjectRef itemAddedPrefab
public CanvasGroup gettingStartedTip
public SoundDefinition buyItemSoundDef
public SoundDefinition buttonPressSoundDef
}
public UIMissionInfoConversation : MonoBehaviour {
public RustText MissionName
public RustText[] MissionObjectives
public GameObject TimerRoot
public RustText TimerText
public VirtualItemIcon[] RewardIcons
}
public UIMixingTableItem : MonoBehaviour {
public Image ItemIcon
public Tooltip ItemTooltip
public RustText TextItemNameAndQuantity
public UIMixingTableItemIngredient[] Ingredients
public void Init(Recipe recipe)
}
public UIMixingTableItemIngredient : MonoBehaviour {
public Image ItemIcon
public Text ItemCount
public Tooltip ToolTip
public void Init(RecipeIngredient ingredient)
public void InitBlank()
}
public UINexusMapBase : BaseMonoBehaviour {
private Memoized`2<string, int> IntMemoized
public RawImage BackgroundImage
public RawImage BackgroundFillImage
public RectTransform LoadingView
public RectTransform MissingView
public ScrollRectEx MapScrollRect
public ScrollRectZoom MapScrollZoom
public RectTransform CameraPositon
public CanvasGroup ZoneNameCanvasGroup
public RectTransform ZoneNameContainer
public GameObjectRef ZoneNameMarkerPrefab
public CanvasGroup ZoneDetails
public RustText ZoneName
public RustText OnlineCount
public RustText MaxCount
public GameObjectRef ZoneNameLabelPrefab
public GameObject InboundFerriesSection
public RectTransform InboundFerriesList
public GameObject OutboundFerriesSection
public RectTransform OutboundFerriesList
public GameObject ConnectionsSection
public RectTransform ConnectionsList
public bool ShowLocalPlayer
public float OutOfBoundsScaleFactor
public float ZoneNameAlphaPower
public UnityEvent OnMapLoaded
public UnityEvent OnClicked
public void OnPointerDown(PointerEventData eventData)
}
public UINexusMapWidget : UINexusMapBase {
public RustButton FocusButton
public FlexTransition RevealTransition
}
public UIPaintableImage : MonoBehaviour {
public RawImage image
public int texSize
public Color clearColor
public FilterMode filterMode
public bool mipmaps
public RectTransform rectTransform
public RectTransform get_rectTransform()
}
public UIPaintBox : MonoBehaviour {
public OnBrushChanged onBrushChanged
public Brush brush
public void UpdateBrushSize(int size)
public void UpdateBrushTexture(Texture2D tex)
public void UpdateBrushColor(Color col)
public void UpdateBrushAlpha(float a)
public void UpdateBrushEraser(bool b)
private void OnChanged()
}
public UIParticle : BaseMonoBehaviour {
public Vector2 LifeTime
public Vector2 Gravity
public Vector2 InitialX
public Vector2 InitialY
public Vector2 InitialScale
public Vector2 InitialDelay
public Vector2 ScaleVelocity
public Gradient InitialColor
private float lifetime
private float gravity
private Vector2 velocity
private float scaleVelocity
public void Add(UIParticle particleSource, RectTransform spawnPosition, RectTransform particleCanvas)
private void Start()
private void Update()
private void Die()
}
public UIPixelDownscale : MonoBehaviour {
public CanvasScaler CanvasScaler
private void Awake()
private void Update()
}
public uiPlayerPreview : SingletonComponent`1<uiPlayerPreview> {
public Camera previewCamera
public PlayerModel playermodel
public GameObject wantedSnapshotEffectPosterRoot
public GameObject wantedSnapshotEffectPolaroidRoot
public SegmentMaskPositioning segmentMask
}
public UIPlayerPreviewControls : SingletonComponent`1<UIPlayerPreviewControls> {
public float RotationSpeed
public float RotationLerpSpeed
public float RotationStopLerpSpeed
}
public UIPrefab : MonoBehaviour {
public GameObject prefabSource
internal GameObject createdGameObject
private void Awake()
public void SetVisible(bool visible)
}
public UIRecordingInfo : SingletonComponent`1<UIRecordingInfo> {
public RustText CountdownText
public Slider TapeProgressSlider
public GameObject CountdownRoot
public GameObject RecordingRoot
public Transform Spinner
public float SpinSpeed
public Image CassetteImage
private void Start()
}
public UIRestrained : SingletonComponent`1<UIRestrained> {
public Image Fill
private void Start()
public void SetActive(bool state)
public void SetProgress(Item handcuffItem)
public void SetProgress(float progress)
}
public UIRoot : MonoBehaviour {
private GraphicRaycaster[] graphicRaycasters
public Canvas overlayCanvas
private void ToggleRaycasters(bool state)
protected void Awake()
protected void Start()
protected void Update()
protected void Refresh()
}
public UIRootPixel : UIRoot {
protected void Refresh()
}
public UIRootScaled : UIRoot {
private UIRootScaled Instance
public bool OverrideReference
public Vector2 TargetReference
public CanvasScaler scaler
public Canvas DragOverlayCanvas
public Canvas get_DragOverlayCanvas()
protected void Awake()
protected void Refresh()
}
public UIScale : MonoBehaviour {
public CanvasScaler scaler
}
public UIScalerOverride : MonoBehaviour {
public AnimationCurve scaleCurve
}
public UIScopeOverlay : MonoBehaviour {
public CanvasGroup group
public UIScopeOverlay instance
public Image scopeImage
}
public UISleepingScreen : SingletonComponent`1<UISleepingScreen> {
protected CanvasGroup canvasGroup
private bool visible
protected void Awake()
public void SetVisible(bool b)
}
public UISound : object {
private AudioSource source
private AudioSource GetAudioSource()
public void Play(AudioClip clip, float volume)
}
public UITwitchTrophy : UIDialog {
public HttpImage EventImage
public RustText EventName
public RustText WinningTeamName
public RectTransform TeamMembersRoot
public GameObject TeamMemberNamePrefab
public GameObject MissingDataOverlay
}
public UIUnderlay : SingletonComponent`1<UIUnderlay> {
public GameObjectRef damageDirectional
public GameObjectRef waterDirectional
}
public UIVideoPlayer : UIDialog {
public AspectRatioFitter aspectRatioFitter
public GameObject closeButton
public VideoPlayer videoPlayer
public RawImage videoCanvas
public RectTransform videoProgressBar
public GameObject loadingIndicator
public float audioDuckingAmount
public float timeoutAfter
}
public UIVoiceIcon : MonoBehaviour {
public Text nameText
public RawImage avatar
}
public UIWounded : MonoBehaviour {
public CanvasGroup group
public Image chanceFill
public RustText chanceText
public Image timeRemainingFill
public RustText timeRemainingText
}
public UndergroundLODSwitcher : MonoBehaviour {
public LODComponent TargetComponent
}
public UnderwaterDweller : HumanNPC {
protected string OverrideCorpseName()
}
public UnderWaterEffectRenderer : PostProcessEffectRenderer`1<UnderwaterPostEffect> {
public void Render(PostProcessRenderContext context)
}
public UnderwaterPathFinder : BasePathFinder {
private BaseEntity npc
public void Init(BaseEntity npc)
public Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange)
public bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, Vector3& result)
}
public UnderwaterPostEffect : PostProcessEffectSettings {
public BoolParameter wiggle
public FloatParameter speed
public FloatParameter scale
public ColorParameter waterLineColor
public FixedIntParameter waterLineBlurIterations
public FloatParameter waterLineBlurSize
public FixedIntParameter downsample
public FixedIntParameter blurIterations
public FloatParameter blurSize
public FloatParameter fadeToBlurDistance
}
public Underwear : ScriptableObject {
public string shortname
public Phrase displayName
public Sprite icon
public Sprite iconFemale
public SkinReplacement[] replacementsMale
public SkinReplacement[] replacementsFemale
public SteamInventoryItem steamItem
public SteamDLCItem steamDLC
public bool adminOnly
public UInt32 GetID()
public bool HasMaleParts()
public bool HasFemaleParts()
public bool ValidForPlayer(BasePlayer player)
public bool IsFemale(BasePlayer player)
public bool Validate(Underwear underwear, BasePlayer player)
}
public UnderwearIcon : MonoBehaviour {
public Image icon
}
public UnderwearManifest : ScriptableObject {
public UnderwearManifest instance
public List`1<Underwear> underwears
public UnderwearManifest Get()
public void PrintManifest()
public Underwear GetUnderwear(UInt32 id)
}
public UnderwearSkinPicker : MonoBehaviour {
public GameObjectRef pickerIcon
public GameObject container
public Action skinChangedEvent
public Sprite defaultNudeIcon
public Sprite defaultIconMale
public Sprite defaultIconFemale
}
public Unity.Collections.NativeArrayEx : object {
public void Add(NativeArray`1& array, T item, Int32& size)
public void RemoveUnordered(NativeArray`1& array, int index, Int32& count)
public void Expand(NativeArray`1& array, int newCapacity)
public void SafeDispose(NativeArray`1& array)
}
public UnityEngine.AniamtorEx : object {
public void SetFloatFixed(Animator animator, int id, float value, float dampTime, float deltaTime)
public void SetBoolChecked(Animator animator, int id, bool value)
}
public UnityEngine.ArgEx : object {
public BasePlayer Player(Arg arg)
public BasePlayer GetPlayer(Arg arg, int iArgNum)
public BasePlayer GetSleeper(Arg arg, int iArgNum)
public BasePlayer GetPlayerOrSleeper(Arg arg, int iArgNum)
public BasePlayer GetPlayerOrSleeperOrBot(Arg arg, int iArgNum)
public NetworkableId GetEntityID(Arg arg, int iArg, NetworkableId def)
public ItemId GetItemID(Arg arg, int iArg, ItemId def)
}
public UnityEngine.ColliderEx : object {
public PhysicMaterial GetMaterialAt(Collider obj, Vector3 pos)
public float EstimateVolume(Collider collider)
public bool IsOnLayer(Collider col, Layer rustLayer)
public bool IsOnLayer(Collider col, int layer)
public float GetRadius(Collider col, Vector3 transformScale)
public MonumentInfo GetMonument(Collider collider, bool ignoreEntity)
}
public UnityEngine.CollisionEx : object {
public BaseEntity GetEntity(Collision col)
}
public UnityEngine.ComponentEx : object {
public T Instantiate(T component)
public bool HasComponent(Component component)
public Nullable`1<bool> IsEnabled(Component component)
}
public UnityEngine.CoroutineEx : object {
public WaitForEndOfFrame waitForEndOfFrame
public WaitForFixedUpdate waitForFixedUpdate
private Dictionary`2<float, WaitForSeconds> waitForSecondsBuffer
public WaitForSeconds waitForSeconds(float seconds)
public WaitForSecondsRealtimeEx waitForSecondsRealtime(float seconds)
public IEnumerator Combine(IEnumerator[] coroutines)
}
public UnityEngine.GameObjectEx : object {
public BaseEntity ToBaseEntity(GameObject go)
public BaseEntity ToBaseEntity(Collider collider)
public BaseEntity ToBaseEntity(Transform transform)
public bool IsOnLayer(GameObject go, Layer rustLayer)
public bool IsOnLayer(GameObject go, int layer)
private IEntity GetEntityFromRegistry(Transform transform)
private IEntity GetEntityFromComponent(Transform transform)
public void SetHierarchyGroup(GameObject obj, string strRoot, bool groupActive, bool persistant)
public bool HasComponent(GameObject obj)
public void SetChildComponentsEnabled(GameObject gameObject, bool enabled)
public GameObject FindInChildren(GameObject parent, string name)
}
public UnityEngine.MonumentColliderTag : MonoBehaviour {
public MonumentInfo Monument
}
public UnityEngine.NetworkPacketEx : object {
public BasePlayer Player(Message v)
}
public UnityEngine.QuaternionEx : object {
public Quaternion AlignToNormal(Quaternion rot, Vector3 normal)
public Quaternion LookRotationWithOffset(Vector3 offset, Vector3 forward, Vector3 up)
public Quaternion LookRotationForcedUp(Vector3 forward, Vector3 up)
public Quaternion LookRotationGradient(Vector3 normal, Vector3 up)
public Quaternion LookRotationNormal(Vector3 normal, Vector3 up)
public Quaternion EnsureValid(Quaternion rot, float epsilon)
}
public UnityEngine.RayEx : object {
public Vector3 ClosestPoint(Ray ray, Vector3 pos)
public float Distance(Ray ray, Vector3 pos)
public float SqrDistance(Ray ray, Vector3 pos)
public bool IsNaNOrInfinity(Ray r)
}
public UnityEngine.Rendering.PostProcessing.AmbientOcclusion : PostProcessEffectSettings {
public AmbientOcclusionModeParameter mode
public FloatParameter intensity
public ColorParameter color
public BoolParameter ambientOnly
public FloatParameter noiseFilterTolerance
public FloatParameter blurTolerance
public FloatParameter upsampleTolerance
public FloatParameter thicknessModifier
public FloatParameter directLightingStrength
public FloatParameter radius
public AmbientOcclusionQualityParameter quality
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.AmbientOcclusionMode : Enum {
public int value__
public AmbientOcclusionMode ScalableAmbientObscurance
public AmbientOcclusionMode MultiScaleVolumetricObscurance
}
public UnityEngine.Rendering.PostProcessing.AmbientOcclusionQuality : Enum {
public int value__
public AmbientOcclusionQuality Lowest
public AmbientOcclusionQuality Low
public AmbientOcclusionQuality Medium
public AmbientOcclusionQuality High
public AmbientOcclusionQuality Ultra
}
internal UnityEngine.Rendering.PostProcessing.AmbientOcclusionRenderer : PostProcessEffectRenderer`1<AmbientOcclusion> {
private IAmbientOcclusionMethod[] m_Methods
public void Init()
public bool IsAmbientOnly(PostProcessRenderContext context)
public IAmbientOcclusionMethod Get()
public DepthTextureMode GetCameraFlags()
public void Release()
public ScalableAO GetScalableAO()
public MultiScaleVO GetMultiScaleVO()
public void Render(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.AutoExposure : PostProcessEffectSettings {
public Vector2Parameter filtering
public FloatParameter minLuminance
public FloatParameter maxLuminance
public FloatParameter keyValue
public EyeAdaptationParameter eyeAdaptation
public FloatParameter speedUp
public FloatParameter speedDown
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.AutoExposureRenderer : PostProcessEffectRenderer`1<AutoExposure> {
private int k_NumEyes
private int k_NumAutoExposureTextures
private RenderTexture[][] m_AutoExposurePool
private Int32[] m_AutoExposurePingPong
private RenderTexture m_CurrentAutoExposure
private void CheckTexture(int eye, int id)
public void Render(PostProcessRenderContext context)
public void Release()
}
public UnityEngine.Rendering.PostProcessing.Bloom : PostProcessEffectSettings {
public FloatParameter intensity
public FloatParameter threshold
public FloatParameter softKnee
public FloatParameter clamp
public FloatParameter diffusion
public FloatParameter anamorphicRatio
public ColorParameter color
public BoolParameter fastMode
public TextureParameter dirtTexture
public FloatParameter dirtIntensity
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.BloomRenderer : PostProcessEffectRenderer`1<Bloom> {
private Level[] m_Pyramid
private int k_MaxPyramidSize
public void Init()
public void Render(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.ChromaticAberration : PostProcessEffectSettings {
public TextureParameter spectralLut
public FloatParameter intensity
public BoolParameter fastMode
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.ChromaticAberrationRenderer : PostProcessEffectRenderer`1<ChromaticAberration> {
private Texture2D m_InternalSpectralLut
public void Render(PostProcessRenderContext context)
public void Release()
}
public UnityEngine.Rendering.PostProcessing.ColorBlindnessType : Enum {
public int value__
public ColorBlindnessType Deuteranopia
public ColorBlindnessType Protanopia
public ColorBlindnessType Tritanopia
}
public UnityEngine.Rendering.PostProcessing.ColorGrading : PostProcessEffectSettings {
public GradingModeParameter gradingMode
public TextureParameter externalLut
public TonemapperParameter tonemapper
public FloatParameter toneCurveToeStrength
public FloatParameter toneCurveToeLength
public FloatParameter toneCurveShoulderStrength
public FloatParameter toneCurveShoulderLength
public FloatParameter toneCurveShoulderAngle
public FloatParameter toneCurveGamma
public TextureParameter ldrLut
public FloatParameter ldrLutContribution
public FloatParameter temperature
public FloatParameter tint
public ColorParameter colorFilter
public FloatParameter hueShift
public FloatParameter saturation
public FloatParameter brightness
public FloatParameter postExposure
public FloatParameter contrast
public MaskingModeParameter maskMode
public FloatParameter maskIntensity
public FloatParameter mixerRedOutRedIn
public FloatParameter mixerRedOutGreenIn
public FloatParameter mixerRedOutBlueIn
public FloatParameter mixerGreenOutRedIn
public FloatParameter mixerGreenOutGreenIn
public FloatParameter mixerGreenOutBlueIn
public FloatParameter mixerBlueOutRedIn
public FloatParameter mixerBlueOutGreenIn
public FloatParameter mixerBlueOutBlueIn
public Vector4Parameter lift
public Vector4Parameter gamma
public Vector4Parameter gain
public SplineParameter masterCurve
public SplineParameter redCurve
public SplineParameter greenCurve
public SplineParameter blueCurve
public SplineParameter hueVsHueCurve
public SplineParameter hueVsSatCurve
public SplineParameter satVsSatCurve
public SplineParameter lumVsSatCurve
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.ColorGradingRenderer : PostProcessEffectRenderer`1<ColorGrading> {
private Texture2D m_GradingCurves
private Color[] m_Pixels
private RenderTexture m_InternalLdrLut
private RenderTexture m_InternalLogLut
private int k_Lut2DSize
private int k_Lut3DSize
private HableCurve m_HableCurve
public void Render(PostProcessRenderContext context)
private void RenderExternalPipeline3D(PostProcessRenderContext context)
private void RenderHDRPipeline3D(PostProcessRenderContext context)
private void RenderHDRPipeline2D(PostProcessRenderContext context)
private void RenderLDRPipeline2D(PostProcessRenderContext context)
private void CheckInternalLogLut()
private void CheckInternalStripLut()
private Texture2D GetCurveTexture(bool hdr)
private bool IsRenderTextureFormatSupportedForLinearFiltering(RenderTextureFormat format)
private RenderTextureFormat GetLutFormat()
private TextureFormat GetCurveFormat()
public void Release()
}
public UnityEngine.Rendering.PostProcessing.ColorParameter : ParameterOverride`1<Color> {
public void Interp(Color from, Color to, float t)
public Vector4 op_Implicit(ColorParameter prop)
}
public UnityEngine.Rendering.PostProcessing.ColorUtilities : object {
private float logC_cut
private float logC_a
private float logC_b
private float logC_c
private float logC_d
private float logC_e
private float logC_f
public float StandardIlluminantY(float x)
public Vector3 CIExyToLMS(float x, float y)
public Vector3 ComputeColorBalance(float temperature, float tint)
public Vector3 ColorToLift(Vector4 color)
public Vector3 ColorToInverseGamma(Vector4 color)
public Vector3 ColorToGain(Vector4 color)
public float LogCToLinear(float x)
public float LinearToLogC(float x)
public UInt32 ToHex(Color c)
public Color ToRGBA(UInt32 hex)
}
public UnityEngine.Rendering.PostProcessing.DebugOverlay : Enum {
public int value__
public DebugOverlay None
public DebugOverlay Depth
public DebugOverlay Normals
public DebugOverlay MotionVectors
public DebugOverlay NANTracker
public DebugOverlay ColorBlindnessSimulation
public DebugOverlay _
public DebugOverlay AmbientOcclusion
public DebugOverlay BloomBuffer
public DebugOverlay BloomThreshold
public DebugOverlay DepthOfField
}
public UnityEngine.Rendering.PostProcessing.DepthOfField : PostProcessEffectSettings {
public FloatParameter focusDistance
public FloatParameter aperture
public FloatParameter focalLength
public KernelSizeParameter kernelSize
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.DepthOfFieldRenderer : PostProcessEffectRenderer`1<DepthOfField> {
private int k_NumEyes
private int k_NumCoCHistoryTextures
private RenderTexture[][] m_CoCHistoryTextures
private Int32[] m_HistoryPingPong
private float k_FilmHeight
public DepthTextureMode GetCameraFlags()
private RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary)
private float CalculateMaxCoCRadius(int screenHeight)
private RenderTexture CheckHistory(int eye, int id, PostProcessRenderContext context, RenderTextureFormat format)
public void Render(PostProcessRenderContext context)
public void Release()
}
public UnityEngine.Rendering.PostProcessing.DisplayNameAttribute : Attribute {
public string displayName
public void .ctor(string displayName)
}
internal UnityEngine.Rendering.PostProcessing.Dithering : object {
private int m_NoiseTextureIndex
internal void Render(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.EyeAdaptation : Enum {
public int value__
public EyeAdaptation Progressive
public EyeAdaptation Fixed
}
public UnityEngine.Rendering.PostProcessing.FastApproximateAntialiasing : object {
public bool fastMode
public bool keepAlpha
}
public UnityEngine.Rendering.PostProcessing.FloatParameter : ParameterOverride`1<float> {
public void Interp(float from, float to, float t)
}
public UnityEngine.Rendering.PostProcessing.Fog : object {
public bool enabled
public bool excludeSkybox
internal DepthTextureMode GetCameraFlags()
internal bool IsEnabledAndSupported(PostProcessRenderContext context)
internal void Render(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.GradingMode : Enum {
public int value__
public GradingMode LowDefinitionRange
public GradingMode HighDefinitionRange
public GradingMode External
}
public UnityEngine.Rendering.PostProcessing.Grain : PostProcessEffectSettings {
public BoolParameter colored
public FloatParameter intensity
public FloatParameter size
public FloatParameter lumContrib
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.GrainRenderer : PostProcessEffectRenderer`1<Grain> {
private RenderTexture m_GrainLookupRT
private int k_SampleCount
private int m_SampleIndex
public void Render(PostProcessRenderContext context)
private RenderTextureFormat GetLookupFormat()
public void Release()
}
public UnityEngine.Rendering.PostProcessing.HableCurve : object {
private float <whitePoint>k__BackingField
private float <inverseWhitePoint>k__BackingField
private float <x0>k__BackingField
private float <x1>k__BackingField
private Segment[] m_Segments
public Uniforms uniforms
public float whitePoint
public float inverseWhitePoint
internal float x0
internal float x1
public float get_whitePoint()
private void set_whitePoint(float value)
public float get_inverseWhitePoint()
private void set_inverseWhitePoint(float value)
internal float get_x0()
private void set_x0(float value)
internal float get_x1()
private void set_x1(float value)
public float Eval(float x)
public void Init(float toeStrength, float toeLength, float shoulderStrength, float shoulderLength, float shoulderAngle, float gamma)
private void InitSegments(DirectParams srcParams)
private void SolveAB(Single& lnA, Single& B, float x0, float y0, float m)
private void AsSlopeIntercept(Single& m, Single& b, float x0, float x1, float y0, float y1)
private float EvalDerivativeLinearGamma(float m, float b, float g, float x)
}
public UnityEngine.Rendering.PostProcessing.HaltonSeq : object {
public float Get(int index, int radix)
}
public UnityEngine.Rendering.PostProcessing.HistogramMonitor : Monitor {
public int width
public int height
public Channel channel
private ComputeBuffer m_Data
private int k_NumBins
private int k_ThreadGroupSizeX
private int k_ThreadGroupSizeY
internal void OnDisable()
internal bool NeedsHalfRes()
internal bool ShaderResourcesAvailable(PostProcessRenderContext context)
internal void Render(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.IAmbientOcclusionMethod {
public DepthTextureMode GetCameraFlags()
public void RenderAfterOpaque(PostProcessRenderContext context)
public void RenderAmbientOnly(PostProcessRenderContext context)
public void CompositeAmbientOnly(PostProcessRenderContext context)
public void Release()
}
public UnityEngine.Rendering.PostProcessing.IntParameter : ParameterOverride`1<int> {
public void Interp(int from, int to, float t)
}
public UnityEngine.Rendering.PostProcessing.KernelSize : Enum {
public int value__
public KernelSize Small
public KernelSize Medium
public KernelSize Large
public KernelSize VeryLarge
}
public UnityEngine.Rendering.PostProcessing.LensDistortion : PostProcessEffectSettings {
public FloatParameter intensity
public FloatParameter intensityX
public FloatParameter intensityY
public FloatParameter centerX
public FloatParameter centerY
public FloatParameter scale
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.LensDistortionRenderer : PostProcessEffectRenderer`1<LensDistortion> {
public void Render(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.LightMeterMonitor : Monitor {
public int width
public int height
public bool showCurves
internal bool ShaderResourcesAvailable(PostProcessRenderContext context)
internal void Render(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.LogHistogram : object {
public int rangeMin
public int rangeMax
private int k_Bins
private ComputeBuffer <data>k__BackingField
public ComputeBuffer data
public ComputeBuffer get_data()
private void set_data(ComputeBuffer value)
public void Generate(PostProcessRenderContext context)
public Vector4 GetHistogramScaleOffsetRes(PostProcessRenderContext context)
public void Release()
}
public UnityEngine.Rendering.PostProcessing.MaskingMode : Enum {
public int value__
public MaskingMode None
public MaskingMode SourceAlpha
public MaskingMode SourceOneMinusAlpha
}
public UnityEngine.Rendering.PostProcessing.MaxAttribute : Attribute {
public float max
public void .ctor(float max)
}
internal UnityEngine.Rendering.PostProcessing.MeshUtilities : object {
private Dictionary`2<PrimitiveType, Mesh> s_Primitives
private Dictionary`2<Type, PrimitiveType> s_ColliderPrimitives
internal Mesh GetColliderMesh(Collider collider)
internal Mesh GetPrimitive(PrimitiveType primitiveType)
private Mesh GetBuiltinMesh(PrimitiveType primitiveType)
}
public UnityEngine.Rendering.PostProcessing.MinAttribute : Attribute {
public float min
public void .ctor(float min)
}
public UnityEngine.Rendering.PostProcessing.MinMaxAttribute : Attribute {
public float min
public float max
public void .ctor(float min, float max)
}
public UnityEngine.Rendering.PostProcessing.Monitor : object {
private RenderTexture <output>k__BackingField
internal bool requested
public RenderTexture output
public RenderTexture get_output()
protected void set_output(RenderTexture value)
public bool IsRequestedAndSupported(PostProcessRenderContext context)
internal bool ShaderResourcesAvailable(PostProcessRenderContext context)
internal bool NeedsHalfRes()
protected void CheckOutput(int width, int height)
internal void OnEnable()
internal void OnDisable()
internal void Render(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.MonitorType : Enum {
public int value__
public MonitorType LightMeter
public MonitorType Histogram
public MonitorType Waveform
public MonitorType Vectorscope
}
public UnityEngine.Rendering.PostProcessing.MotionBlur : PostProcessEffectSettings {
public FloatParameter shutterAngle
public IntParameter sampleCount
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.MotionBlurRenderer : PostProcessEffectRenderer`1<MotionBlur> {
public DepthTextureMode GetCameraFlags()
public void Render(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.MultiScaleVO : object {
private Single[] m_SampleThickness
private Single[] m_InvThicknessTable
private Single[] m_SampleWeightTable
private Int32[] m_Widths
private Int32[] m_Heights
private AmbientOcclusion m_Settings
private PropertySheet m_PropertySheet
private PostProcessResources m_Resources
private RenderTexture m_AmbientOnlyAO
private RenderTargetIdentifier[] m_MRT
public void .ctor(AmbientOcclusion settings)
public DepthTextureMode GetCameraFlags()
public void SetResources(PostProcessResources resources)
private void Alloc(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav)
private void AllocArray(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav)
private void Release(CommandBuffer cmd, int id)
private Vector4 CalculateZBufferParams(Camera camera)
private float CalculateTanHalfFovHeight(Camera camera)
private Vector2 GetSize(MipLevel mip)
private Vector3 GetSizeArray(MipLevel mip)
public void GenerateAOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, Nullable`1<RenderTargetIdentifier> depthMap, bool invert, bool isMSAA)
private void PushAllocCommands(CommandBuffer cmd, bool isMSAA)
private void PushDownsampleCommands(CommandBuffer cmd, Camera camera, Nullable`1<RenderTargetIdentifier> depthMap, bool isMSAA)
private void PushRenderCommands(CommandBuffer cmd, int source, int destination, Vector3 sourceSize, float tanHalfFovH, bool isMSAA)
private void PushUpsampleCommands(CommandBuffer cmd, int lowResDepth, int interleavedAO, int highResDepth, Nullable`1<int> highResAO, RenderTargetIdentifier dest, Vector3 lowResDepthSize, Vector2 highResDepthSize, bool isMSAA, bool invert)
private void PushReleaseCommands(CommandBuffer cmd)
private void PreparePropertySheet(PostProcessRenderContext context)
private void CheckAOTexture(PostProcessRenderContext context)
private void PushDebug(PostProcessRenderContext context)
public void RenderAfterOpaque(PostProcessRenderContext context)
public void RenderAmbientOnly(PostProcessRenderContext context)
public void CompositeAmbientOnly(PostProcessRenderContext context)
public void Release()
}
public UnityEngine.Rendering.PostProcessing.ParameterOverride : object {
public bool overrideState
internal void Interp(ParameterOverride from, ParameterOverride to, float t)
public int GetHash()
public T GetValue()
protected internal void OnEnable()
protected internal void OnDisable()
internal void SetValue(ParameterOverride parameter)
}
public UnityEngine.Rendering.PostProcessing.ParameterOverride`1 : ParameterOverride {
public T value
public void .ctor(T value)
public void .ctor(T value, bool overrideState)
internal void Interp(ParameterOverride from, ParameterOverride to, float t)
public void Interp(T from, T to, float t)
public void Override(T x)
internal void SetValue(ParameterOverride parameter)
public int GetHash()
public T op_Implicit(ParameterOverride`1<T> prop)
}
public UnityEngine.Rendering.PostProcessing.PostProcessAttribute : Attribute {
public Type renderer
public PostProcessEvent eventType
public string menuItem
public bool allowInSceneView
internal bool builtinEffect
public void .ctor(Type renderer, PostProcessEvent eventType, string menuItem, bool allowInSceneView)
internal void .ctor(Type renderer, string menuItem, bool allowInSceneView)
}
public UnityEngine.Rendering.PostProcessing.PostProcessBundle : object {
private PostProcessAttribute <attribute>k__BackingField
private PostProcessEffectSettings <settings>k__BackingField
private PostProcessEffectRenderer m_Renderer
public PostProcessAttribute attribute
public PostProcessEffectSettings settings
internal PostProcessEffectRenderer renderer
public PostProcessAttribute get_attribute()
private void set_attribute(PostProcessAttribute value)
public PostProcessEffectSettings get_settings()
private void set_settings(PostProcessEffectSettings value)
internal PostProcessEffectRenderer get_renderer()
internal void .ctor(PostProcessEffectSettings settings)
internal void Release()
internal void ResetHistory()
internal T CastSettings()
internal T CastRenderer()
}
public UnityEngine.Rendering.PostProcessing.PostProcessDebug : MonoBehaviour {
public PostProcessLayer postProcessLayer
private PostProcessLayer m_PreviousPostProcessLayer
public bool lightMeter
public bool histogram
public bool waveform
public bool vectorscope
public DebugOverlay debugOverlay
private Camera m_CurrentCamera
private CommandBuffer m_CmdAfterEverything
private void OnEnable()
private void OnDisable()
private void Update()
private void Reset()
private void UpdateStates()
private void OnPostRender()
private void OnGUI()
private void DrawMonitor(Rect& rect, Monitor monitor, bool enabled)
}
public UnityEngine.Rendering.PostProcessing.PostProcessDebugLayer : object {
public LightMeterMonitor lightMeter
public HistogramMonitor histogram
public WaveformMonitor waveform
public VectorscopeMonitor vectorscope
private Dictionary`2<MonitorType, Monitor> m_Monitors
private int frameWidth
private int frameHeight
private RenderTexture <debugOverlayTarget>k__BackingField
private bool <debugOverlayActive>k__BackingField
private DebugOverlay <debugOverlay>k__BackingField
public OverlaySettings overlaySettings
public RenderTexture debugOverlayTarget
public bool debugOverlayActive
public DebugOverlay debugOverlay
public RenderTexture get_debugOverlayTarget()
private void set_debugOverlayTarget(RenderTexture value)
public bool get_debugOverlayActive()
private void set_debugOverlayActive(bool value)
public DebugOverlay get_debugOverlay()
private void set_debugOverlay(DebugOverlay value)
internal void OnEnable()
internal void OnDisable()
private void DestroyDebugOverlayTarget()
public void RequestMonitorPass(MonitorType monitor)
public void RequestDebugOverlay(DebugOverlay mode)
internal void SetFrameSize(int width, int height)
public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass)
internal DepthTextureMode GetCameraFlags()
internal void RenderMonitors(PostProcessRenderContext context)
internal void RenderSpecialOverlays(PostProcessRenderContext context)
internal void EndFrame()
}
public UnityEngine.Rendering.PostProcessing.PostProcessEffectRenderer : object {
protected bool m_ResetHistory
public void Init()
public DepthTextureMode GetCameraFlags()
public void ResetHistory()
public void Release()
public void Render(PostProcessRenderContext context)
internal void SetSettings(PostProcessEffectSettings settings)
}
public UnityEngine.Rendering.PostProcessing.PostProcessEffectRenderer`1 : PostProcessEffectRenderer {
private T <settings>k__BackingField
public T settings
public T get_settings()
internal void set_settings(T value)
internal void SetSettings(PostProcessEffectSettings settings)
}
public UnityEngine.Rendering.PostProcessing.PostProcessEffectSettings : ScriptableObject {
public bool active
public BoolParameter enabled
internal ReadOnlyCollection`1<ParameterOverride> parameters
private void OnEnable()
private void OnDisable()
public void SetAllOverridesTo(bool state, bool excludeEnabled)
public bool IsEnabledAndSupported(PostProcessRenderContext context)
public int GetHash()
private ParameterOverride <OnEnable>b__3_2(FieldInfo t)
}
public UnityEngine.Rendering.PostProcessing.PostProcessEvent : Enum {
public int value__
public PostProcessEvent BeforeTransparent
public PostProcessEvent BeforeStack
public PostProcessEvent AfterStack
}
internal UnityEngine.Rendering.PostProcessing.PostProcessEventComparer : ValueType {
public bool Equals(PostProcessEvent x, PostProcessEvent y)
public int GetHashCode(PostProcessEvent obj)
}
public UnityEngine.Rendering.PostProcessing.PostProcessLayer : MonoBehaviour {
public Transform volumeTrigger
public LayerMask volumeLayer
public bool stopNaNPropagation
public bool finalBlitToCameraTarget
public Antialiasing antialiasingMode
public TemporalAntialiasing temporalAntialiasing
public SubpixelMorphologicalAntialiasing subpixelMorphologicalAntialiasing
public FastApproximateAntialiasing fastApproximateAntialiasing
public Fog fog
private Dithering dithering
public PostProcessDebugLayer debugLayer
public RenderTextureFormat intermediateFormat
private RenderTextureFormat prevIntermediateFormat
private bool supportsIntermediateFormat
private PostProcessResources m_Resources
private bool m_ShowToolkit
private bool m_ShowCustomSorter
public bool breakBeforeColorGrading
private List`1<SerializedBundleRef> m_BeforeTransparentBundles
private List`1<SerializedBundleRef> m_BeforeStackBundles
private List`1<SerializedBundleRef> m_AfterStackBundles
private Dictionary`2<PostProcessEvent, List`1<SerializedBundleRef>> <sortedBundles>k__BackingField
private bool <haveBundlesBeenInited>k__BackingField
private Dictionary`2<Type, PostProcessBundle> m_Bundles
private PropertySheetFactory m_PropertySheetFactory
private CommandBuffer m_LegacyCmdBufferBeforeReflections
private CommandBuffer m_LegacyCmdBufferBeforeLighting
private CommandBuffer m_LegacyCmdBufferOpaque
private CommandBuffer m_LegacyCmdBuffer
private Camera m_Camera
private PostProcessRenderContext m_CurrentContext
private LogHistogram m_LogHistogram
private bool m_SettingsUpdateNeeded
private bool m_IsRenderingInSceneView
private TargetPool m_TargetPool
private bool m_NaNKilled
private List`1<PostProcessEffectRenderer> m_ActiveEffects
private List`1<RenderTargetIdentifier> m_Targets
public Dictionary`2<PostProcessEvent, List`1<SerializedBundleRef>> sortedBundles
public bool haveBundlesBeenInited
public Dictionary`2<PostProcessEvent, List`1<SerializedBundleRef>> get_sortedBundles()
private void set_sortedBundles(Dictionary`2<PostProcessEvent, List`1<SerializedBundleRef>> value)
public bool get_haveBundlesBeenInited()
private void set_haveBundlesBeenInited(bool value)
private void OnEnable()
private void InitLegacy()
private void OnRenderImage(RenderTexture src, RenderTexture dst)
public void Init(PostProcessResources resources)
public void InitBundles()
private void UpdateBundleSortList(List`1<SerializedBundleRef> sortedList, PostProcessEvent evt)
private void OnDisable()
private void Reset()
private void OnPreCull()
private void OnPreRender()
private RenderTextureFormat GetIntermediateFormat()
private bool RequiresInitialBlit(Camera camera, PostProcessRenderContext context)
private void UpdateSrcDstForOpaqueOnly(Int32& src, Int32& dst, PostProcessRenderContext context, RenderTargetIdentifier cameraTarget, int opaqueOnlyEffectsRemaining)
private void BuildCommandBuffers()
private void BuildPostEffectsOld(RenderTextureFormat sourceFormat, PostProcessRenderContext context, RenderTargetIdentifier cameraTarget)
private void OnPostRender()
public PostProcessBundle GetBundle()
public PostProcessBundle GetBundle(Type settingsType)
public T GetSettings()
public void BakeMSVOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, Nullable`1<RenderTargetIdentifier> depthMap, bool invert, bool isMSAA)
internal void OverrideSettings(List`1<PostProcessEffectSettings> baseSettings, float interpFactor)
private void SetLegacyCameraFlags(PostProcessRenderContext context)
public void ResetHistory()
public bool HasOpaqueOnlyEffects(PostProcessRenderContext context)
public bool HasActiveEffects(PostProcessEvent evt, PostProcessRenderContext context)
private void SetupContext(PostProcessRenderContext context)
public void UpdateVolumeSystem(Camera cam, CommandBuffer cmd)
public void RenderOpaqueOnly(PostProcessRenderContext context)
public void Render(PostProcessRenderContext context)
private int RenderInjectionPoint(PostProcessEvent evt, PostProcessRenderContext context, string marker, int releaseTargetAfterUse)
private void RenderList(List`1<SerializedBundleRef> list, PostProcessRenderContext context, string marker)
private void ApplyFlip(PostProcessRenderContext context, MaterialPropertyBlock properties)
private void ApplyDefaultFlip(MaterialPropertyBlock properties)
private int RenderBuiltins(PostProcessRenderContext context, bool isFinalPass, int releaseTargetAfterUse, int eye)
private void RenderFinalPass(PostProcessRenderContext context, int releaseTargetAfterUse, int eye)
private int RenderEffect(PostProcessRenderContext context, bool useTempTarget)
private bool ShouldGenerateLogHistogram(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.PostProcessManager : object {
private PostProcessManager s_Instance
private int k_MaxLayerCount
private Dictionary`2<int, List`1<PostProcessVolume>> m_SortedVolumes
private List`1<PostProcessVolume> m_Volumes
private Dictionary`2<int, bool> m_SortNeeded
private List`1<PostProcessEffectSettings> m_BaseSettings
public Dictionary`2<Type, PostProcessAttribute> settingsTypes
public PostProcessManager instance
public PostProcessManager get_instance()
private void CleanBaseTypes()
private void ReloadBaseTypes()
public void GetActiveVolumes(PostProcessLayer layer, List`1<PostProcessVolume> results, bool skipDisabled, bool skipZeroWeight)
public PostProcessVolume GetHighestPriorityVolume(PostProcessLayer layer)
public PostProcessVolume GetHighestPriorityVolume(LayerMask mask)
public PostProcessVolume QuickVolume(int layer, float priority, PostProcessEffectSettings[] settings)
internal void SetLayerDirty(int layer)
internal void UpdateVolumeLayer(PostProcessVolume volume, int prevLayer, int newLayer)
private void Register(PostProcessVolume volume, int layer)
internal void Register(PostProcessVolume volume)
private void Unregister(PostProcessVolume volume, int layer)
internal void Unregister(PostProcessVolume volume)
private void ReplaceData(PostProcessLayer postProcessLayer)
internal void UpdateSettings(PostProcessLayer postProcessLayer, Camera camera)
private List`1<PostProcessVolume> GrabVolumes(LayerMask mask)
private void SortByPriority(List`1<PostProcessVolume> volumes)
private bool IsVolumeRenderedByCamera(PostProcessVolume volume, Camera camera)
}
public UnityEngine.Rendering.PostProcessing.PostProcessProfile : ScriptableObject {
public List`1<PostProcessEffectSettings> settings
public bool isDirty
private void OnEnable()
public T AddSettings()
public PostProcessEffectSettings AddSettings(Type type)
public PostProcessEffectSettings AddSettings(PostProcessEffectSettings effect)
public void RemoveSettings()
public void RemoveSettings(Type type)
public bool HasSettings()
public bool HasSettings(Type type)
public T GetSetting()
public bool TryGetSettings(T& outSetting)
}
public UnityEngine.Rendering.PostProcessing.PostProcessRenderContext : object {
public bool dlssEnabled
private Camera m_Camera
private CommandBuffer <command>k__BackingField
private RenderTargetIdentifier <source>k__BackingField
private RenderTargetIdentifier <destination>k__BackingField
private RenderTextureFormat <sourceFormat>k__BackingField
private bool <flip>k__BackingField
private PostProcessResources <resources>k__BackingField
private PropertySheetFactory <propertySheets>k__BackingField
private Dictionary`2<string, object> <userData>k__BackingField
private PostProcessDebugLayer <debugLayer>k__BackingField
private int <width>k__BackingField
private int <height>k__BackingField
private bool <stereoActive>k__BackingField
private int <xrActiveEye>k__BackingField
private int <numberOfEyes>k__BackingField
private StereoRenderingMode <stereoRenderingMode>k__BackingField
private int <screenWidth>k__BackingField
private int <screenHeight>k__BackingField
private bool <isSceneView>k__BackingField
private Antialiasing <antialiasing>k__BackingField
private TemporalAntialiasing <temporalAntialiasing>k__BackingField
internal PropertySheet uberSheet
internal Texture autoExposureTexture
internal LogHistogram logHistogram
internal Texture logLut
internal AutoExposure autoExposure
internal int bloomBufferNameID
internal bool physicalCamera
private RenderTextureDescriptor m_sourceDescriptor
public Camera camera
public CommandBuffer command
public RenderTargetIdentifier source
public RenderTargetIdentifier destination
public RenderTextureFormat sourceFormat
public bool flip
public PostProcessResources resources
public PropertySheetFactory propertySheets
public Dictionary`2<string, object> userData
public PostProcessDebugLayer debugLayer
public int width
public int height
public bool stereoActive
public int xrActiveEye
public int numberOfEyes
public StereoRenderingMode stereoRenderingMode
public int screenWidth
public int screenHeight
public bool isSceneView
public Antialiasing antialiasing
public TemporalAntialiasing temporalAntialiasing
public void Resize(int width, int height, bool dlssEnabled)
public Camera get_camera()
public void set_camera(Camera value)
public CommandBuffer get_command()
public void set_command(CommandBuffer value)
public RenderTargetIdentifier get_source()
public void set_source(RenderTargetIdentifier value)
public RenderTargetIdentifier get_destination()
public void set_destination(RenderTargetIdentifier value)
public RenderTextureFormat get_sourceFormat()
public void set_sourceFormat(RenderTextureFormat value)
public bool get_flip()
public void set_flip(bool value)
public PostProcessResources get_resources()
internal void set_resources(PostProcessResources value)
public PropertySheetFactory get_propertySheets()
internal void set_propertySheets(PropertySheetFactory value)
public Dictionary`2<string, object> get_userData()
private void set_userData(Dictionary`2<string, object> value)
public PostProcessDebugLayer get_debugLayer()
internal void set_debugLayer(PostProcessDebugLayer value)
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public bool get_stereoActive()
private void set_stereoActive(bool value)
public int get_xrActiveEye()
private void set_xrActiveEye(int value)
public int get_numberOfEyes()
private void set_numberOfEyes(int value)
public StereoRenderingMode get_stereoRenderingMode()
private void set_stereoRenderingMode(StereoRenderingMode value)
public int get_screenWidth()
public void set_screenWidth(int value)
public int get_screenHeight()
public void set_screenHeight(int value)
public bool get_isSceneView()
internal void set_isSceneView(bool value)
public Antialiasing get_antialiasing()
internal void set_antialiasing(Antialiasing value)
public TemporalAntialiasing get_temporalAntialiasing()
internal void set_temporalAntialiasing(TemporalAntialiasing value)
public void Reset()
public bool IsTemporalAntialiasingActive()
public bool IsDebugOverlayEnabled(DebugOverlay overlay)
public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass)
private RenderTextureDescriptor GetDescriptor(int depthBufferBits, RenderTextureFormat colorFormat, RenderTextureReadWrite readWrite)
public void GetScreenSpaceTemporaryRT(CommandBuffer cmd, int nameID, int depthBufferBits, RenderTextureFormat colorFormat, RenderTextureReadWrite readWrite, FilterMode filter, int widthOverride, int heightOverride)
public RenderTexture GetScreenSpaceTemporaryRT(int depthBufferBits, RenderTextureFormat colorFormat, RenderTextureReadWrite readWrite, int widthOverride, int heightOverride)
}
public UnityEngine.Rendering.PostProcessing.PostProcessResources : ScriptableObject {
public Texture2D[] blueNoise64
public Texture2D[] blueNoise256
public SMAALuts smaaLuts
public Shaders shaders
public ComputeShaders computeShaders
}
public UnityEngine.Rendering.PostProcessing.PostProcessVolume : MonoBehaviour {
public PostProcessProfile sharedProfile
public bool isGlobal
public Bounds bounds
public float blendDistance
public float weight
public float priority
private int m_PreviousLayer
private float m_PreviousPriority
private PostProcessProfile m_InternalProfile
public PostProcessProfile profile
internal PostProcessProfile profileRef
public PostProcessProfile get_profile()
public void set_profile(PostProcessProfile value)
internal PostProcessProfile get_profileRef()
public bool HasInstantiatedProfile()
private void OnEnable()
private void OnDisable()
private void Update()
private void OnDrawGizmos()
}
public UnityEngine.Rendering.PostProcessing.PropertySheet : object {
private MaterialPropertyBlock <properties>k__BackingField
private Material <material>k__BackingField
public MaterialPropertyBlock properties
internal Material material
public MaterialPropertyBlock get_properties()
private void set_properties(MaterialPropertyBlock value)
internal Material get_material()
private void set_material(Material value)
internal void .ctor(Material material)
public void ClearKeywords()
public void EnableKeyword(string keyword)
public void DisableKeyword(string keyword)
internal void Release()
}
public UnityEngine.Rendering.PostProcessing.PropertySheetFactory : object {
private Dictionary`2<Shader, PropertySheet> m_Sheets
public PropertySheet Get(string shaderName)
public PropertySheet Get(Shader shader)
public void Release()
}
public UnityEngine.Rendering.PostProcessing.RuntimeUtilities : object {
private Texture2D m_WhiteTexture
private Texture3D m_WhiteTexture3D
private Texture2D m_BlackTexture
private Texture3D m_BlackTexture3D
private Texture2D m_TransparentTexture
private Texture3D m_TransparentTexture3D
private Dictionary`2<int, Texture2D> m_LutStrips
internal PostProcessResources s_Resources
private Mesh s_FullscreenTriangle
private Material s_CopyStdMaterial
private Material s_CopyStdFromDoubleWideMaterial
private Material s_CopyMaterial
private Material s_CopyFromTexArrayMaterial
private PropertySheet s_CopySheet
private PropertySheet s_CopyFromTexArraySheet
private IEnumerable`1<Type> m_AssemblyTypes
public Texture2D whiteTexture
public Texture3D whiteTexture3D
public Texture2D blackTexture
public Texture3D blackTexture3D
public Texture2D transparentTexture
public Texture3D transparentTexture3D
public Mesh fullscreenTriangle
public Material copyStdMaterial
public Material copyStdFromDoubleWideMaterial
public Material copyMaterial
public Material copyFromTexArrayMaterial
public PropertySheet copySheet
public PropertySheet copyFromTexArraySheet
public bool scriptableRenderPipelineActive
public bool supportsDeferredShading
public bool supportsDepthNormals
public bool isSinglePassStereoEnabled
public bool isVREnabled
public bool isAndroidOpenGL
public RenderTextureFormat defaultHDRRenderTextureFormat
public bool isLinearColorSpace
public Texture2D get_whiteTexture()
public Texture3D get_whiteTexture3D()
public Texture2D get_blackTexture()
public Texture3D get_blackTexture3D()
public Texture2D get_transparentTexture()
public Texture3D get_transparentTexture3D()
public Texture2D GetLutStrip(int size)
public Mesh get_fullscreenTriangle()
public Material get_copyStdMaterial()
public Material get_copyStdFromDoubleWideMaterial()
public Material get_copyMaterial()
public Material get_copyFromTexArrayMaterial()
public PropertySheet get_copySheet()
public PropertySheet get_copyFromTexArraySheet()
public void SetRenderTargetWithLoadStoreAction(CommandBuffer cmd, RenderTargetIdentifier rt, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction)
public void SetRenderTargetWithLoadStoreAction(CommandBuffer cmd, RenderTargetIdentifier color, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depth, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction)
public void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, bool clear, Nullable`1<Rect> viewport)
public void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, RenderBufferLoadAction loadAction, Nullable`1<Rect> viewport)
public void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear, Nullable`1<Rect> viewport)
public void BlitFullscreenTriangleFromDoubleWide(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material, int pass, int eye)
public void BlitFullscreenTriangleToDoubleWide(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, int eye)
public void BlitFullscreenTriangleFromTexArray(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear, int depthSlice)
public void BlitFullscreenTriangleToTexArray(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear, int depthSlice)
public void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear, Nullable`1<Rect> viewport)
public void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier[] destinations, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear, Nullable`1<Rect> viewport)
public void BuiltinBlit(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination)
public void BuiltinBlit(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material mat, int pass)
public void CopyTexture(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination)
public bool get_scriptableRenderPipelineActive()
public bool get_supportsDeferredShading()
public bool get_supportsDepthNormals()
public bool get_isSinglePassStereoEnabled()
public bool get_isVREnabled()
public bool get_isAndroidOpenGL()
public RenderTextureFormat get_defaultHDRRenderTextureFormat()
public bool isFloatingPointFormat(RenderTextureFormat format)
public void Destroy(Object obj)
public bool get_isLinearColorSpace()
public bool IsResolvedDepthAvailable(Camera camera)
public void DestroyProfile(PostProcessProfile profile, bool destroyEffects)
public void DestroyVolume(PostProcessVolume volume, bool destroyProfile, bool destroyGameObject)
public bool IsPostProcessingActive(PostProcessLayer layer)
public bool IsTemporalAntialiasingActive(PostProcessLayer layer)
public IEnumerable`1<T> GetAllSceneObjects()
public void CreateIfNull(T& obj)
public float Exp2(float x)
public Matrix4x4 GetJitteredPerspectiveProjectionMatrix(Camera camera, Vector2 offset)
public Matrix4x4 GetJitteredOrthographicProjectionMatrix(Camera camera, Vector2 offset)
public Matrix4x4 GenerateJitteredProjectionMatrixFromOriginal(PostProcessRenderContext context, Matrix4x4 origProj, Vector2 jitter)
public IEnumerable`1<Type> GetAllAssemblyTypes()
public T GetAttribute(Type type)
public Attribute[] GetMemberAttributes(Expression`1<Func`2<TType, TValue>> expr)
public string GetFieldPath(Expression`1<Func`2<TType, TValue>> expr)
}
internal UnityEngine.Rendering.PostProcessing.ScalableAO : object {
private RenderTexture m_Result
private PropertySheet m_PropertySheet
private AmbientOcclusion m_Settings
private RenderTargetIdentifier[] m_MRT
private Int32[] m_SampleCount
public void .ctor(AmbientOcclusion settings)
public DepthTextureMode GetCameraFlags()
private void DoLazyInitialization(PostProcessRenderContext context)
private void Render(PostProcessRenderContext context, CommandBuffer cmd, int occlusionSource)
public void RenderAfterOpaque(PostProcessRenderContext context)
public void RenderAmbientOnly(PostProcessRenderContext context)
public void CompositeAmbientOnly(PostProcessRenderContext context)
public void Release()
}
public UnityEngine.Rendering.PostProcessing.ScreenSpaceReflectionPreset : Enum {
public int value__
public ScreenSpaceReflectionPreset Lower
public ScreenSpaceReflectionPreset Low
public ScreenSpaceReflectionPreset Medium
public ScreenSpaceReflectionPreset High
public ScreenSpaceReflectionPreset Higher
public ScreenSpaceReflectionPreset Ultra
public ScreenSpaceReflectionPreset Overkill
public ScreenSpaceReflectionPreset Custom
}
public UnityEngine.Rendering.PostProcessing.ScreenSpaceReflectionResolution : Enum {
public int value__
public ScreenSpaceReflectionResolution Downsampled
public ScreenSpaceReflectionResolution FullSize
public ScreenSpaceReflectionResolution Supersampled
}
public UnityEngine.Rendering.PostProcessing.ScreenSpaceReflections : PostProcessEffectSettings {
public ScreenSpaceReflectionPresetParameter preset
public IntParameter maximumIterationCount
public ScreenSpaceReflectionResolutionParameter resolution
public FloatParameter thickness
public FloatParameter maximumMarchDistance
public FloatParameter distanceFade
public FloatParameter vignette
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.ScreenSpaceReflectionsRenderer : PostProcessEffectRenderer`1<ScreenSpaceReflections> {
private RenderTexture m_Resolve
private RenderTexture m_History
private Int32[] m_MipIDs
private QualityPreset[] m_Presets
public DepthTextureMode GetCameraFlags()
internal void CheckRT(RenderTexture& rt, int width, int height, FilterMode filterMode, bool useMipMap)
public void Render(PostProcessRenderContext context)
public void Release()
}
internal UnityEngine.Rendering.PostProcessing.ShaderIDs : object {
internal int MainTex
internal int Jitter
internal int Sharpness
internal int FinalBlendParameters
internal int HistoryTex
internal int SMAA_Flip
internal int SMAA_Flop
internal int AOParams
internal int AOColor
internal int OcclusionTexture1
internal int OcclusionTexture2
internal int SAOcclusionTexture
internal int MSVOcclusionTexture
internal int DepthCopy
internal int LinearDepth
internal int LowDepth1
internal int LowDepth2
internal int LowDepth3
internal int LowDepth4
internal int TiledDepth1
internal int TiledDepth2
internal int TiledDepth3
internal int TiledDepth4
internal int Occlusion1
internal int Occlusion2
internal int Occlusion3
internal int Occlusion4
internal int Combined1
internal int Combined2
internal int Combined3
internal int SSRResolveTemp
internal int Noise
internal int Test
internal int Resolve
internal int History
internal int ViewMatrix
internal int InverseViewMatrix
internal int InverseProjectionMatrix
internal int ScreenSpaceProjectionMatrix
internal int Params2
internal int FogColor
internal int FogParams
internal int VelocityScale
internal int MaxBlurRadius
internal int RcpMaxBlurRadius
internal int VelocityTex
internal int Tile2RT
internal int Tile4RT
internal int Tile8RT
internal int TileMaxOffs
internal int TileMaxLoop
internal int TileVRT
internal int NeighborMaxTex
internal int LoopCount
internal int DepthOfFieldTemp
internal int DepthOfFieldTex
internal int Distance
internal int LensCoeff
internal int MaxCoC
internal int RcpMaxCoC
internal int RcpAspect
internal int CoCTex
internal int TaaParams
internal int AutoExposureTex
internal int HistogramBuffer
internal int Params
internal int ScaleOffsetRes
internal int BloomTex
internal int SampleScale
internal int Threshold
internal int ColorIntensity
internal int Bloom_DirtTex
internal int Bloom_Settings
internal int Bloom_Color
internal int Bloom_DirtTileOffset
internal int ChromaticAberration_Amount
internal int ChromaticAberration_SpectralLut
internal int Distortion_CenterScale
internal int Distortion_Amount
internal int Lut2D
internal int Lut3D
internal int Lut3D_Params
internal int Lut2D_Params
internal int UserLut2D_Params
internal int PostExposure
internal int ColorBalance
internal int ColorFilter
internal int HueSatCon
internal int Brightness
internal int ChannelMixerRed
internal int ChannelMixerGreen
internal int ChannelMixerBlue
internal int Lift
internal int InvGamma
internal int Gain
internal int Curves
internal int CustomToneCurve
internal int ToeSegmentA
internal int ToeSegmentB
internal int MidSegmentA
internal int MidSegmentB
internal int ShoSegmentA
internal int ShoSegmentB
internal int MaskMode
internal int MaskIntensity
internal int Vignette_Color
internal int Vignette_Center
internal int Vignette_Settings
internal int Vignette_Mask
internal int Vignette_Opacity
internal int Vignette_Mode
internal int Grain_Params1
internal int Grain_Params2
internal int GrainTex
internal int Phase
internal int GrainNoiseParameters
internal int LumaInAlpha
internal int DitheringTex
internal int Dithering_Coords
internal int From
internal int To
internal int Interp
internal int TargetColor
internal int HalfResFinalCopy
internal int WaveformSource
internal int WaveformBuffer
internal int VectorscopeBuffer
internal int RenderViewportScaleFactor
internal int UVTransform
internal int DepthSlice
internal int UVScaleOffset
internal int PosScaleOffset
}
public UnityEngine.Rendering.PostProcessing.Spline : object {
public int k_Precision
public float k_Step
public AnimationCurve curve
private bool m_Loop
private float m_ZeroValue
private float m_Range
private AnimationCurve m_InternalLoopingCurve
private int frameCount
public Single[] cachedData
public void .ctor(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds)
public void Cache(int frame)
public float Evaluate(float t, int length)
public float Evaluate(float t)
public int GetHashCode()
}
public UnityEngine.Rendering.PostProcessing.SplineParameter : ParameterOverride`1<Spline> {
protected internal void OnEnable()
internal void SetValue(ParameterOverride parameter)
public void Interp(Spline from, Spline to, float t)
}
public UnityEngine.Rendering.PostProcessing.SubpixelMorphologicalAntialiasing : object {
public Quality quality
public bool IsSupported()
internal void Render(PostProcessRenderContext context)
}
internal UnityEngine.Rendering.PostProcessing.TargetPool : object {
private List`1<int> m_Pool
private int m_Current
internal int Get()
private int Get(int i)
internal void Reset()
}
public UnityEngine.Rendering.PostProcessing.TemporalAntialiasing : object {
public float jitterSpread
public float sharpness
public float stationaryBlending
public float motionBlending
public Func`3<Camera, Vector2, Matrix4x4> jitteredMatrixFunc
private Vector2 <jitter>k__BackingField
private Vector2 <jitterRaw>k__BackingField
private RenderTargetIdentifier[] m_Mrt
private bool m_ResetHistory
private int <sampleIndex>k__BackingField
private int <sampleCount>k__BackingField
private int k_NumEyes
private int k_NumHistoryTextures
private RenderTexture[][] m_HistoryTextures
private Int32[] m_HistoryPingPong
public Vector2 jitter
public Vector2 jitterRaw
public int sampleIndex
public int sampleCount
public Vector2 get_jitter()
private void set_jitter(Vector2 value)
public Vector2 get_jitterRaw()
private void set_jitterRaw(Vector2 value)
public int get_sampleIndex()
private void set_sampleIndex(int value)
public int get_sampleCount()
public void set_sampleCount(int value)
public bool IsSupported()
internal DepthTextureMode GetCameraFlags()
internal void ResetHistory()
private Vector2 GenerateRandomOffset()
public Matrix4x4 GetJitteredProjectionMatrix(Camera camera)
public void ConfigureJitteredProjectionMatrix(PostProcessRenderContext context)
public void ConfigureStereoJitteredProjectionMatrices(PostProcessRenderContext context)
private void GenerateHistoryName(RenderTexture rt, int id, PostProcessRenderContext context)
private RenderTexture CheckHistory(int id, PostProcessRenderContext context)
internal void Render(PostProcessRenderContext context)
internal void Release()
}
public UnityEngine.Rendering.PostProcessing.TextureFormatUtilities : object {
private Dictionary`2<int, RenderTextureFormat> s_FormatAliasMap
private Dictionary`2<int, bool> s_SupportedRenderTextureFormats
private Dictionary`2<int, bool> s_SupportedTextureFormats
private bool IsObsolete(object value)
public RenderTextureFormat GetUncompressedRenderTextureFormat(Texture texture)
internal bool IsSupported(RenderTextureFormat format)
internal bool IsSupported(TextureFormat format)
}
internal UnityEngine.Rendering.PostProcessing.TextureLerper : object {
private TextureLerper m_Instance
private CommandBuffer m_Command
private PropertySheetFactory m_PropertySheets
private PostProcessResources m_Resources
private List`1<RenderTexture> m_Recycled
private List`1<RenderTexture> m_Actives
internal TextureLerper instance
internal TextureLerper get_instance()
internal void BeginFrame(PostProcessRenderContext context)
internal void EndFrame()
private RenderTexture Get(RenderTextureFormat format, int w, int h, int d, bool enableRandomWrite, bool force3D)
internal Texture Lerp(Texture from, Texture to, float t)
internal Texture Lerp(Texture from, Color to, float t)
internal void Clear()
}
public UnityEngine.Rendering.PostProcessing.TextureParameter : ParameterOverride`1<Texture> {
public TextureParameterDefault defaultState
public void Interp(Texture from, Texture to, float t)
}
public UnityEngine.Rendering.PostProcessing.TextureParameterDefault : Enum {
public int value__
public TextureParameterDefault None
public TextureParameterDefault Black
public TextureParameterDefault White
public TextureParameterDefault Transparent
public TextureParameterDefault Lut2D
}
public UnityEngine.Rendering.PostProcessing.Tonemapper : Enum {
public int value__
public Tonemapper None
public Tonemapper Neutral
public Tonemapper ACES
public Tonemapper Custom
}
public UnityEngine.Rendering.PostProcessing.TrackballAttribute : Attribute {
public Mode mode
public void .ctor(Mode mode)
}
public UnityEngine.Rendering.PostProcessing.Vector2Parameter : ParameterOverride`1<Vector2> {
public void Interp(Vector2 from, Vector2 to, float t)
public Vector3 op_Implicit(Vector2Parameter prop)
public Vector4 op_Implicit(Vector2Parameter prop)
}
public UnityEngine.Rendering.PostProcessing.Vector3Parameter : ParameterOverride`1<Vector3> {
public void Interp(Vector3 from, Vector3 to, float t)
public Vector2 op_Implicit(Vector3Parameter prop)
public Vector4 op_Implicit(Vector3Parameter prop)
}
public UnityEngine.Rendering.PostProcessing.Vector4Parameter : ParameterOverride`1<Vector4> {
public void Interp(Vector4 from, Vector4 to, float t)
public Vector2 op_Implicit(Vector4Parameter prop)
public Vector3 op_Implicit(Vector4Parameter prop)
}
public UnityEngine.Rendering.PostProcessing.VectorscopeMonitor : Monitor {
public int size
public float exposure
private ComputeBuffer m_Data
private int k_ThreadGroupSizeX
private int k_ThreadGroupSizeY
internal void OnDisable()
internal bool NeedsHalfRes()
internal bool ShaderResourcesAvailable(PostProcessRenderContext context)
internal void Render(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.Vignette : PostProcessEffectSettings {
public VignetteModeParameter mode
public ColorParameter color
public Vector2Parameter center
public FloatParameter intensity
public FloatParameter smoothness
public FloatParameter roundness
public BoolParameter rounded
public TextureParameter mask
public FloatParameter opacity
public bool IsEnabledAndSupported(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.VignetteMode : Enum {
public int value__
public VignetteMode Classic
public VignetteMode Masked
}
internal UnityEngine.Rendering.PostProcessing.VignetteRenderer : PostProcessEffectRenderer`1<Vignette> {
public void Render(PostProcessRenderContext context)
}
public UnityEngine.Rendering.PostProcessing.WaveformMonitor : Monitor {
public float exposure
public int height
private ComputeBuffer m_Data
private int k_ThreadGroupSize
private int k_ThreadGroupSizeX
private int k_ThreadGroupSizeY
internal void OnDisable()
internal bool NeedsHalfRes()
internal bool ShaderResourcesAvailable(PostProcessRenderContext context)
internal void Render(PostProcessRenderContext context)
}
public UnityEngine.SkinnedMeshRendererEx : object {
public Transform FindRig(SkinnedMeshRenderer renderer)
}
public UnityEngine.TransformEx : object {
public string GetRecursiveName(Transform transform, string strEndName)
public void RemoveComponent(Transform transform)
public void RetireAllChildren(Transform transform, GameManager gameManager)
public List`1<Transform> GetChildren(Transform transform)
public void OrderChildren(Transform tx, Func`2<Transform, object> selector)
public List`1<Transform> GetAllChildren(Transform transform)
public void AddAllChildren(Transform transform, List`1<Transform> list)
public Transform[] GetChildrenWithTag(Transform transform, string strTag)
public Matrix4x4 LocalToPrefabRoot(Transform transform)
public void Identity(GameObject go)
public GameObject CreateChild(GameObject go)
public GameObject InstantiateChild(GameObject go, GameObject prefab)
public void SetLayerRecursive(GameObject go, int Layer)
public bool DropToGround(Transform transform, bool alignToNormal, float fRange)
public bool GetGroundInfo(Transform transform, Vector3& pos, Vector3& normal, float range)
public bool GetGroundInfoTerrainOnly(Transform transform, Vector3& pos, Vector3& normal, float range)
public Bounds WorkoutRenderBounds(Transform tx)
public List`1<T> GetSiblings(Transform transform, bool includeSelf)
public void DestroyChildren(Transform transform)
public void SetChildrenActive(Transform transform, bool b)
public Transform ActiveChild(Transform transform, string name, bool bDisableOthers)
public T GetComponentInChildrenIncludeDisabled(Transform transform)
public bool HasComponentInChildrenIncludeDisabled(Transform transform)
public void SetHierarchyGroup(Transform transform, string strRoot, bool groupActive, bool persistant)
public Bounds GetBounds(Transform transform, bool includeRenderers, bool includeColliders, bool includeInactive)
}
public UnityEngine.UI.Extensions.BezierPath : object {
public int SegmentsPerCurve
public float MINIMUM_SQR_DISTANCE
public float DIVISION_THRESHOLD
private List`1<Vector2> controlPoints
private int curveCount
public void SetControlPoints(List`1<Vector2> newControlPoints)
public void SetControlPoints(Vector2[] newControlPoints)
public List`1<Vector2> GetControlPoints()
public void Interpolate(List`1<Vector2> segmentPoints, float scale)
public void SamplePoints(List`1<Vector2> sourcePoints, float minSqrDistance, float maxSqrDistance, float scale)
public Vector2 CalculateBezierPoint(int curveIndex, float t)
public List`1<Vector2> GetDrawingPoints0()
public List`1<Vector2> GetDrawingPoints1()
public List`1<Vector2> GetDrawingPoints2()
private List`1<Vector2> FindDrawingPoints(int curveIndex)
private int FindDrawingPoints(int curveIndex, float t0, float t1, List`1<Vector2> pointList, int insertionIndex)
private Vector2 CalculateBezierPoint(float t, Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3)
}
public UnityEngine.UI.Extensions.CableCurve : object {
private Vector2 m_start
private Vector2 m_end
private float m_slack
private int m_steps
private bool m_regen
private Vector2[] emptyCurve
private Vector2[] points
public bool regenPoints
public Vector2 start
public Vector2 end
public float slack
public int steps
public Vector2 midPoint
public bool get_regenPoints()
public void set_regenPoints(bool value)
public Vector2 get_start()
public void set_start(Vector2 value)
public Vector2 get_end()
public void set_end(Vector2 value)
public float get_slack()
public void set_slack(float value)
public int get_steps()
public void set_steps(int value)
public Vector2 get_midPoint()
public void .ctor(Vector2[] inputPoints)
public void .ctor(List`1<Vector2> inputPoints)
public void .ctor(CableCurve v)
public Vector2[] Points()
}
public UnityEngine.UI.Extensions.DiamondGraph : UIPrimitiveBase {
private float m_a
private float m_b
private float m_c
private float m_d
public float A
public float B
public float C
public float D
public float get_A()
public void set_A(float value)
public float get_B()
public void set_B(float value)
public float get_C()
public void set_C(float value)
public float get_D()
public void set_D(float value)
protected void OnPopulateMesh(VertexHelper vh)
}
public UnityEngine.UI.Extensions.ResolutionMode : Enum {
public int value__
public ResolutionMode None
public ResolutionMode PerSegment
public ResolutionMode PerLine
}
internal UnityEngine.UI.Extensions.SetPropertyUtility : object {
public bool SetColor(Color& currentValue, Color newValue)
public bool SetEquatableStruct(T& currentValue, T newValue)
public bool SetStruct(T& currentValue, T newValue)
public bool SetClass(T& currentValue, T newValue)
}
public UnityEngine.UI.Extensions.UICircle : UIPrimitiveBase {
public bool ArcInvert
public float Arc
public int ArcSteps
public int ArcRotation
public float Progress
private float _progress
public Color ProgressColor
public bool Fill
public float Thickness
public int Padding
private List`1<int> indices
private List`1<UIVertex> vertices
private Vector2 uvCenter
protected void OnPopulateMesh(VertexHelper vh)
public void SetProgress(float progress)
public void SetArcSteps(int steps)
public void SetInvertArc(bool invert)
public void SetArcRotation(int rotation)
public void SetFill(bool fill)
public void SetBaseColor(Color color)
public void UpdateBaseAlpha(float value)
public void SetProgressColor(Color color)
public void UpdateProgressAlpha(float value)
public void SetPadding(int padding)
public void SetThickness(int thickness)
}
public UnityEngine.UI.Extensions.UICircleSimple : UIPrimitiveBase {
public int ArcSteps
public bool Fill
public float Thickness
public bool ThicknessIsOutside
private List`1<int> indices
private List`1<UIVertex> vertices
private Vector2 uvCenter
protected void OnPopulateMesh(VertexHelper vh)
public void SetArcSteps(int steps)
public void SetFill(bool fill)
public void SetBaseColor(Color color)
public void UpdateBaseAlpha(float value)
public void SetThickness(int thickness)
}
public UnityEngine.UI.Extensions.UICornerCut : UIPrimitiveBase {
public Vector2 cornerSize
private bool m_cutUL
private bool m_cutUR
private bool m_cutLL
private bool m_cutLR
private bool m_makeColumns
private bool m_useColorUp
private Color32 m_colorUp
private bool m_useColorDown
private Color32 m_colorDown
public bool CutUL
public bool CutUR
public bool CutLL
public bool CutLR
public bool MakeColumns
public bool UseColorUp
public Color32 ColorUp
public bool UseColorDown
public Color32 ColorDown
public bool get_CutUL()
public void set_CutUL(bool value)
public bool get_CutUR()
public void set_CutUR(bool value)
public bool get_CutLL()
public void set_CutLL(bool value)
public bool get_CutLR()
public void set_CutLR(bool value)
public bool get_MakeColumns()
public void set_MakeColumns(bool value)
public bool get_UseColorUp()
public void set_UseColorUp(bool value)
public Color32 get_ColorUp()
public void set_ColorUp(Color32 value)
public bool get_UseColorDown()
public void set_UseColorDown(bool value)
public Color32 get_ColorDown()
public void set_ColorDown(Color32 value)
protected void OnPopulateMesh(VertexHelper vh)
private void AddSquare(Rect rect, Rect rectUV, Color32 color32, VertexHelper vh)
private void AddSquare(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Rect rectUV, Color32 color32, VertexHelper vh)
private int AddVert(float x, float y, Rect area, Color32 color32, VertexHelper vh)
}
public UnityEngine.UI.Extensions.UIGoldenRatioRenderer : UILineRenderer {
private List`1<Vector2> _points
private List`1<Rect> _rects
private int canvasWidth
private int canvasHeight
public float lineThickness2
private void DrawSpiral(VertexHelper vh)
private void DrawPhiRectangles(VertexHelper vh, List`1<Vector2> points, float x, float y, float width, float height, Orientations orientation)
protected void OnPopulateMesh(VertexHelper vh)
private void DrawRect(VertexHelper vh, Rect rect)
}
public UnityEngine.UI.Extensions.UIGridRenderer : UILineRenderer {
private int m_GridColumns
private int m_GridRows
public int GridColumns
public int GridRows
public int get_GridColumns()
public void set_GridColumns(int value)
public int get_GridRows()
public void set_GridRows(int value)
protected void OnPopulateMesh(VertexHelper vh)
}
public UnityEngine.UI.Extensions.UILineRenderer : UIPrimitiveBase {
private float MIN_MITER_JOIN
private float MIN_BEVEL_NICE_JOIN
private Vector2 UV_TOP_LEFT
private Vector2 UV_BOTTOM_LEFT
private Vector2 UV_TOP_CENTER_LEFT
private Vector2 UV_TOP_CENTER_RIGHT
private Vector2 UV_BOTTOM_CENTER_LEFT
private Vector2 UV_BOTTOM_CENTER_RIGHT
private Vector2 UV_TOP_RIGHT
private Vector2 UV_BOTTOM_RIGHT
private Vector2[] startUvs
private Vector2[] middleUvs
private Vector2[] endUvs
private Vector2[] fullUvs
internal Vector2[] m_points
internal List`1<Vector2[]> m_segments
internal float lineThickness
internal bool relativeSize
internal bool lineList
internal bool lineCaps
internal int bezierSegmentsPerCurve
public JoinType LineJoins
public BezierType BezierMode
public bool drivenExternally
public float LineThickness
public bool RelativeSize
public bool LineList
public bool LineCaps
public int BezierSegmentsPerCurve
public Vector2[] Points
public List`1<Vector2[]> Segments
public float get_LineThickness()
public void set_LineThickness(float value)
public bool get_RelativeSize()
public void set_RelativeSize(bool value)
public bool get_LineList()
public void set_LineList(bool value)
public bool get_LineCaps()
public void set_LineCaps(bool value)
public int get_BezierSegmentsPerCurve()
public void set_BezierSegmentsPerCurve(int value)
public Vector2[] get_Points()
public void set_Points(Vector2[] value)
public List`1<Vector2[]> get_Segments()
public void set_Segments(List`1<Vector2[]> value)
private void PopulateMesh(VertexHelper vh, Vector2[] pointsToDraw)
protected void OnPopulateMesh(VertexHelper vh)
private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type)
private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type, UIVertex[] previousVert)
protected void GeneratedUVs()
protected void ResolutionToNativeSize(float distance)
private int GetSegmentPointCount()
public Vector2 GetPosition(int index, int segmentIndex)
public Vector2 GetPositionBySegment(int index, int segment)
public Vector2 GetClosestPoint(Vector2 p1, Vector2 p2, Vector2 p3)
}
public UnityEngine.UI.Extensions.UILineRendererList : UIPrimitiveBase {
private float MIN_MITER_JOIN
private float MIN_BEVEL_NICE_JOIN
private Vector2 UV_TOP_LEFT
private Vector2 UV_BOTTOM_LEFT
private Vector2 UV_TOP_CENTER_LEFT
private Vector2 UV_TOP_CENTER_RIGHT
private Vector2 UV_BOTTOM_CENTER_LEFT
private Vector2 UV_BOTTOM_CENTER_RIGHT
private Vector2 UV_TOP_RIGHT
private Vector2 UV_BOTTOM_RIGHT
private Vector2[] startUvs
private Vector2[] middleUvs
private Vector2[] endUvs
private Vector2[] fullUvs
internal List`1<Vector2> m_points
internal float lineThickness
internal bool relativeSize
internal bool lineList
internal bool lineCaps
internal int bezierSegmentsPerCurve
public JoinType LineJoins
public BezierType BezierMode
public bool drivenExternally
public float LineThickness
public bool RelativeSize
public bool LineList
public bool LineCaps
public int BezierSegmentsPerCurve
public List`1<Vector2> Points
public float get_LineThickness()
public void set_LineThickness(float value)
public bool get_RelativeSize()
public void set_RelativeSize(bool value)
public bool get_LineList()
public void set_LineList(bool value)
public bool get_LineCaps()
public void set_LineCaps(bool value)
public int get_BezierSegmentsPerCurve()
public void set_BezierSegmentsPerCurve(int value)
public List`1<Vector2> get_Points()
public void set_Points(List`1<Vector2> value)
public void AddPoint(Vector2 pointToAdd)
public void RemovePoint(Vector2 pointToRemove)
public void ClearPoints()
private void PopulateMesh(VertexHelper vh, List`1<Vector2> pointsToDraw)
protected void OnPopulateMesh(VertexHelper vh)
private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type)
private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type)
protected void GeneratedUVs()
protected void ResolutionToNativeSize(float distance)
}
public UnityEngine.UI.Extensions.UILineTextureRenderer : UIPrimitiveBase {
private Rect m_UVRect
private Vector2[] m_points
public float LineThickness
public bool UseMargins
public Vector2 Margin
public bool relativeSize
public Rect uvRect
public Vector2[] Points
public Rect get_uvRect()
public void set_uvRect(Rect value)
public Vector2[] get_Points()
public void set_Points(Vector2[] value)
protected void OnPopulateMesh(VertexHelper vh)
public Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Vector3 angles)
}
public UnityEngine.UI.Extensions.UIPolygon : UIPrimitiveBase {
public bool fill
public float thickness
public int sides
public float rotation
public Single[] VerticesDistances
private float size
public void DrawPolygon(int _sides)
public void DrawPolygon(int _sides, Single[] _VerticesDistances)
public void DrawPolygon(int _sides, Single[] _VerticesDistances, float _rotation)
private void Update()
protected void OnPopulateMesh(VertexHelper vh)
}
public UnityEngine.UI.Extensions.UIPrimitiveBase : MaskableGraphic {
protected Material s_ETC1DefaultUI
private List`1<Vector2> outputList
private Sprite m_Sprite
private Sprite m_OverrideSprite
internal float m_EventAlphaThreshold
private ResolutionMode m_improveResolution
protected float m_Resolution
private bool m_useNativeSize
public Sprite sprite
public Sprite overrideSprite
protected Sprite activeSprite
public float eventAlphaThreshold
public ResolutionMode ImproveResolution
public float Resoloution
public bool UseNativeSize
public Material defaultETC1GraphicMaterial
public Texture mainTexture
public bool hasBorder
public float pixelsPerUnit
public Material material
public float minWidth
public float preferredWidth
public float flexibleWidth
public float minHeight
public float preferredHeight
public float flexibleHeight
public int layoutPriority
public Sprite get_sprite()
public void set_sprite(Sprite value)
public Sprite get_overrideSprite()
public void set_overrideSprite(Sprite value)
protected Sprite get_activeSprite()
public float get_eventAlphaThreshold()
public void set_eventAlphaThreshold(float value)
public ResolutionMode get_ImproveResolution()
public void set_ImproveResolution(ResolutionMode value)
public float get_Resoloution()
public void set_Resoloution(float value)
public bool get_UseNativeSize()
public void set_UseNativeSize(bool value)
public Material get_defaultETC1GraphicMaterial()
public Texture get_mainTexture()
public bool get_hasBorder()
public float get_pixelsPerUnit()
public Material get_material()
public void set_material(Material value)
protected UIVertex[] SetVbo(Vector2[] vertices, Vector2[] uvs)
protected Vector2[] IncreaseResolution(Vector2[] input)
protected List`1<Vector2> IncreaseResolution(List`1<Vector2> input)
protected void GeneratedUVs()
protected void ResolutionToNativeSize(float distance)
public void CalculateLayoutInputHorizontal()
public void CalculateLayoutInputVertical()
public float get_minWidth()
public float get_preferredWidth()
public float get_flexibleWidth()
public float get_minHeight()
public float get_preferredHeight()
public float get_flexibleHeight()
public int get_layoutPriority()
public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
private Vector2 MapCoordinate(Vector2 local, Rect rect)
private Vector4 GetAdjustedBorders(Vector4 border, Rect rect)
protected void OnEnable()
}
public UnityEngine.UI.Extensions.UIRing : UIPrimitiveBase {
public float innerRadius
public float outerRadius
public int ArcSteps
private List`1<int> indices
private List`1<UIVertex> vertices
protected void OnPopulateMesh(VertexHelper vh)
public void SetArcSteps(int steps)
public void SetBaseColor(Color color)
public void UpdateBaseAlpha(float value)
}
public UnityEngine.UI.ScrollRectEx : UIBehaviour {
public InputButton scrollButton
public InputButton altScrollButton
private RectTransform m_Content
private bool m_Horizontal
private bool m_Vertical
private MovementType m_MovementType
private float m_Elasticity
private bool m_Inertia
private float m_DecelerationRate
private float m_ScrollSensitivity
private RectTransform m_Viewport
private Scrollbar m_HorizontalScrollbar
private Scrollbar m_VerticalScrollbar
private ScrollbarVisibility m_HorizontalScrollbarVisibility
private ScrollbarVisibility m_VerticalScrollbarVisibility
private float m_HorizontalScrollbarSpacing
private float m_VerticalScrollbarSpacing
private ScrollRectEvent m_OnValueChanged
private Vector2 m_PointerStartLocalCursor
private Vector2 m_ContentStartPosition
private RectTransform m_ViewRect
private Bounds m_ContentBounds
private Bounds m_ViewBounds
private Vector2 m_Velocity
private bool m_Dragging
private Vector2 m_PrevPosition
private Bounds m_PrevContentBounds
private Bounds m_PrevViewBounds
private bool m_HasRebuiltLayout
private bool m_HSliderExpand
private bool m_VSliderExpand
private float m_HSliderHeight
private float m_VSliderWidth
private RectTransform m_Rect
private RectTransform m_HorizontalScrollbarRect
private RectTransform m_VerticalScrollbarRect
private DrivenRectTransformTracker m_Tracker
private Vector3[] m_Corners
public RectTransform content
public bool horizontal
public bool vertical
public MovementType movementType
public float elasticity
public bool inertia
public float decelerationRate
public float scrollSensitivity
public RectTransform viewport
public Scrollbar horizontalScrollbar
public Scrollbar verticalScrollbar
public ScrollbarVisibility horizontalScrollbarVisibility
public ScrollbarVisibility verticalScrollbarVisibility
public float horizontalScrollbarSpacing
public float verticalScrollbarSpacing
public ScrollRectEvent onValueChanged
protected RectTransform viewRect
public Vector2 velocity
private RectTransform rectTransform
public Vector2 normalizedPosition
public float horizontalNormalizedPosition
public float verticalNormalizedPosition
private bool hScrollingNeeded
private bool vScrollingNeeded
public Rect normalizedViewRect
public RectTransform get_content()
public void set_content(RectTransform value)
public bool get_horizontal()
public void set_horizontal(bool value)
public bool get_vertical()
public void set_vertical(bool value)
public MovementType get_movementType()
public void set_movementType(MovementType value)
public float get_elasticity()
public void set_elasticity(float value)
public bool get_inertia()
public void set_inertia(bool value)
public float get_decelerationRate()
public void set_decelerationRate(float value)
public float get_scrollSensitivity()
public void set_scrollSensitivity(float value)
public RectTransform get_viewport()
public void set_viewport(RectTransform value)
public Scrollbar get_horizontalScrollbar()
public void set_horizontalScrollbar(Scrollbar value)
public Scrollbar get_verticalScrollbar()
public void set_verticalScrollbar(Scrollbar value)
public ScrollbarVisibility get_horizontalScrollbarVisibility()
public void set_horizontalScrollbarVisibility(ScrollbarVisibility value)
public ScrollbarVisibility get_verticalScrollbarVisibility()
public void set_verticalScrollbarVisibility(ScrollbarVisibility value)
public float get_horizontalScrollbarSpacing()
public void set_horizontalScrollbarSpacing(float value)
public float get_verticalScrollbarSpacing()
public void set_verticalScrollbarSpacing(float value)
public ScrollRectEvent get_onValueChanged()
public void set_onValueChanged(ScrollRectEvent value)
protected RectTransform get_viewRect()
public Vector2 get_velocity()
public void set_velocity(Vector2 value)
private RectTransform get_rectTransform()
public void Rebuild(CanvasUpdate executing)
private void UpdateCachedData()
protected void OnEnable()
protected void OnDisable()
public bool IsActive()
private void EnsureLayoutHasRebuilt()
public void StopMovement()
public void OnScroll(PointerEventData data)
public void OnInitializePotentialDrag(PointerEventData eventData)
public void OnBeginDrag(PointerEventData eventData)
public void OnEndDrag(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
protected void SetContentAnchoredPosition(Vector2 position)
protected void LateUpdate()
private void UpdatePrevData()
private void UpdateScrollbars(Vector2 offset)
public Vector2 get_normalizedPosition()
public void set_normalizedPosition(Vector2 value)
public float get_horizontalNormalizedPosition()
public void set_horizontalNormalizedPosition(float value)
public float get_verticalNormalizedPosition()
public void set_verticalNormalizedPosition(float value)
private void SetHorizontalNormalizedPosition(float value)
private void SetVerticalNormalizedPosition(float value)
private void SetNormalizedPosition(float value, int axis)
private float RubberDelta(float overStretching, float viewSize)
protected void OnRectTransformDimensionsChange()
private bool get_hScrollingNeeded()
private bool get_vScrollingNeeded()
public void SetLayoutHorizontal()
public void SetLayoutVertical()
private void UpdateScrollbarVisibility()
private void UpdateScrollbarLayout()
private void UpdateBounds()
private Bounds GetBounds()
private Vector2 CalculateOffset(Vector2 delta)
protected void SetDirty()
protected void SetDirtyCaching()
public void CenterOnPosition(Vector2 pos)
public Rect get_normalizedViewRect()
public void LayoutComplete()
public void GraphicUpdateComplete()
private Transform UnityEngine.UI.ICanvasElement.get_transform()
}
public UnityEngine.UI.ScrollRectSettable : ScrollRect {
public void SetHorizNormalizedPosition(float value)
public void SetVertNormalizedPosition(float value)
}
public UnityEngine.UIEx : object {
public Vector2 Unpivot(RectTransform rect, Vector2 localPos)
public void CenterOnPosition(ScrollRect scrollrect, Vector2 pos)
public void RebuildHackUnity2019(Image image)
}
public UnityHookHandler : SingletonComponent`1<UnityHookHandler> {
public void EnsureCreated()
private void CreateInstance()
}
internal UnitySourceGeneratedAssemblyMonoScriptTypes_v1 : object {
private MonoScriptData Get()
}
public UnityStandardAssets.CinematicEffects.ImageEffectHelper : object {
public bool supportsDX11
public bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
public Material CheckShaderAndCreateMaterial(Shader s)
public bool get_supportsDX11()
}
public UnityStandardAssets.CinematicEffects.MinAttribute : PropertyAttribute {
public float min
public void .ctor(float min)
}
public UnityStandardAssets.CinematicEffects.RenderTextureUtility : object {
private List`1<RenderTexture> m_TemporaryRTs
public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer, RenderTextureFormat format, FilterMode filterMode)
public void ReleaseTemporaryRenderTexture(RenderTexture rt)
public void ReleaseAllTemporaryRenderTextures()
}
public UnityStandardAssets.CinematicEffects.TonemappingColorGrading : MonoBehaviour {
private EyeAdaptationSettings m_EyeAdaptation
private TonemappingSettings m_Tonemapping
private ColorGradingSettings m_ColorGrading
private LUTSettings m_Lut
private Shader m_Shader
}
public UnityStandardAssets.ImageEffects.ScopeEffect : PostEffectsBase {
public Material overlayMaterial
public bool CheckResources()
public bool IsActive()
public void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public UnparentOnDestroy : MonoBehaviour {
public float destroyAfterSeconds
public void OnParentDestroying()
protected void OnValidate()
}
public UnreadMessages : SingletonComponent`1<UnreadMessages> {
public StyleAsset AllRead
public StyleAsset Unread
public RustButton Button
public GameObject UnreadTextObject
public RustText UnreadText
public GameObject MessageList
public GameObject MessageListContainer
public GameObject MessageListEmpty
}
public Upkeep : PrefabAttribute {
public float upkeepMultiplier
protected Type GetIndexedType()
}
public UserPersistance : object {
public Database blueprints
public Database deaths
public Database identities
public Database tokens
public Database playerState
public Dictionary`2<ulong, string> nameCache
private Dictionary`2<ulong, string> wipeIdCache
public MruDictionary`2<ulong, ValueTuple`2<int, bool>> tokenCache
public void .ctor(string strFolder)
public void Dispose()
public PersistantPlayer GetPlayerInfo(ulong playerID)
private PersistantPlayer FetchFromDatabase(ulong playerID)
public void SetPlayerInfo(ulong playerID, PersistantPlayer info)
public void AddLifeStory(ulong playerID, PlayerLifeStory lifeStory)
public PlayerLifeStory GetLastLifeStory(ulong playerID)
public string GetPlayerName(ulong playerID)
public void SetPlayerName(ulong playerID, string name)
public int GetOrGenerateAppToken(ulong playerID, Boolean& locked)
public void RegenerateAppToken(ulong playerID)
private int GenerateAppToken()
public bool SetAppTokenLocked(ulong playerID, bool locked)
public Byte[] GetPlayerState(ulong playerID)
public void SetPlayerState(ulong playerID, Byte[] state)
public string GetUserWipeId(ulong playerID)
public void ResetPlayerState(ulong playerID)
}
internal UVTextureAnimator : MonoBehaviour {
public int Rows
public int Columns
public float Fps
public int OffsetMat
public bool IsLoop
public float StartDelay
private bool isInizialised
private int index
private int count
private int allCount
private float deltaFps
private bool isVisible
private bool isCorutineStarted
private Renderer currentRenderer
private Material instanceMaterial
private void Start()
private void InitDefaultVariables()
private void Play()
private void PlayDelay()
private void OnEnable()
private void OnDisable()
private IEnumerator UpdateCorutine()
private void UpdateCorutineFrame()
private void OnDestroy()
}
public v_chainsaw : MonoBehaviour {
public bool bAttacking
public bool bHitMetal
public bool bHitWood
public bool bHitFlesh
public bool bEngineOn
public ParticleSystem[] hitMetalFX
public ParticleSystem[] hitWoodFX
public ParticleSystem[] hitFleshFX
public SoundDefinition hitMetalSoundDef
public SoundDefinition hitWoodSoundDef
public SoundDefinition hitFleshSoundDef
public Sound hitSound
public GameObject hitSoundTarget
public float hitSoundFadeTime
public ParticleSystem smokeEffect
public Animator chainsawAnimator
public Renderer chainRenderer
public Material chainlink
private MaterialPropertyBlock block
private Vector2 saveST
private float chainSpeed
private float chainAmount
public float temp1
public float temp2
public void OnEnable()
private void Awake()
private void Start()
private void ScrollChainTexture()
private void Update()
private void DoHitSound(SoundDefinition soundDef)
}
public VacuumBreather.PidController : object {
private float MaxOutput
private float _integralMax
private float _integral
private float _kp
private float _ki
private float _kd
public float Kp
public float Ki
public float Kd
public void .ctor(float kp, float ki, float kd)
public float get_Kp()
public void set_Kp(float value)
public float get_Ki()
public void set_Ki(float value)
public float get_Kd()
public void set_Kd(float value)
public float ComputeOutput(float error, float delta, float deltaTime)
}
public VacuumBreather.PidQuaternionController : object {
private PidController[] _internalController
public float Kp
public float Ki
public float Kd
public void .ctor(float kp, float ki, float kd)
public float get_Kp()
public void set_Kp(float value)
public float get_Ki()
public void set_Ki(float value)
public float get_Kd()
public void set_Kd(float value)
public Quaternion MultiplyAsVector(Matrix4x4 matrix, Quaternion quaternion)
public Quaternion ToEulerAngleQuaternion(Vector3 eulerAngles)
public Vector3 ComputeRequiredAngularAcceleration(Quaternion currentOrientation, Quaternion desiredOrientation, Vector3 currentAngularVelocity, float deltaTime)
private Quaternion ComputeOutput(Quaternion error, Quaternion delta, float deltaTime)
}
public VacuumBreather.QuaternionExtensions : object {
public Quaternion Multiply(Quaternion quaternion, float scalar)
public Quaternion RequiredRotation(Quaternion from, Quaternion to)
public Quaternion Subtract(Quaternion lhs, Quaternion rhs)
}
public ValidBounds : SingletonComponent`1<ValidBounds> {
public Bounds worldBounds
public bool Test(BaseEntity entity, Vector3 vPos)
public float TestDist(BaseEntity entity, Vector3 vPos)
public bool TestInnerBounds(Vector3 vPos)
public bool TestOuterBounds(Vector3 vPos)
internal bool IsInsideInnerBounds(Vector3 vPos)
internal bool IsInsideOuterBounds(Vector3 vPos)
public float GetMaximumPointTutorial()
public float GetMaximumPoint()
internal float DistToWorldEdge2D(Vector3 vPos)
}
public VehicleEditingItemIcon : MonoBehaviour {
private Image foregroundImage
private Image linkImage
}
public VehicleEditingPanel : LootPanel {
private float disabledAlpha
private CanvasGroup editGroup
private GameObject moduleInternalItemsGroup
private GameObject moduleInternalLiquidsGroup
private GameObject destroyChassisGroup
private Button itemTakeButton
private Button liquidTakeButton
private GameObject liquidHelp
private GameObject liquidButton
private Color gotColor
private Color notGotColor
private Text generalInfoText
private Text generalWarningText
private Image generalWarningImage
private Text repairInfoText
private Button repairButton
private Text destroyChassisButtonText
private Text destroyChassisCountdown
private Phrase phraseEditingInfo
private Phrase phraseNoOccupant
private Phrase phraseBadOccupant
private Phrase phrasePlayerObstructing
private Phrase phraseNotDriveable
private Phrase phraseNotRepairable
private Phrase phraseRepairNotNeeded
private Phrase phraseRepairSelectInfo
private Phrase phraseRepairEnactInfo
private Phrase phraseHasLock
private Phrase phraseHasNoLock
private Phrase phraseAddLock
private Phrase phraseAddLockButton
private Phrase phraseChangeLockCodeButton
private Text carLockInfoText
private RustText carLockButtonText
private Button actionLockButton
private Button removeLockButton
private GameObjectRef keyEnterDialog
private Phrase phraseEmptyStorage
private CreateChassisEntry[] chassisOptions
}
public VehicleEngineController`1 : object {
private IFuelSystem <FuelSystem>k__BackingField
public TOwner owner
private bool isServer
public float engineStartupTime
public Transform waterloggedPoint
public Flags engineStartingFlag
public EngineState<TOwner> CurEngineState
public bool IsOn
public bool IsOff
public bool IsStarting
public bool IsStartingOrOn
public IFuelSystem FuelSystem
public EngineState<TOwner> get_CurEngineState()
public bool get_IsOn()
public bool get_IsOff()
public bool get_IsStarting()
public bool get_IsStartingOrOn()
public IFuelSystem get_FuelSystem()
private void set_FuelSystem(IFuelSystem value)
public void .ctor(TOwner owner, IFuelSystem fuelSystem, bool isServer, float engineStartupTime, Transform waterloggedPoint, Flags engineStartingFlag)
public EngineState<TOwner> EngineStateFrom(Flags flags)
public void TryStartEngine(BasePlayer player)
public void FinishStartingEngine()
public void StopEngine()
public void CheckEngineState()
public bool CanRunEngine()
public bool IsWaterlogged()
public int TickFuel(float fuelPerSecond)
public void CancelEngineStart()
}
public VehicleLiftOccupantTrigger : TriggerBase {
private ModularCar <carOccupant>k__BackingField
public ModularCar carOccupant
public ModularCar get_carOccupant()
private void set_carOccupant(ModularCar value)
protected void OnDisable()
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
}
public VehicleLight : MonoBehaviour {
public bool IsBrake
public GameObject toggleObject
public LightRenderer[] renderers
public Color lightOnColour
public Color brakesOnColour
public bool applyToTransmittance
public bool useLightOnColourForBrake
}
public VehicleModuleButtonComponent : MonoBehaviour {
public string interactionColliderName
public SoundDefinition pressSoundDef
public void ServerUse(BasePlayer player, BaseVehicleModule parentModule)
}
public VehicleModuleCamper : VehicleModuleSeating {
public GameObjectRef SleepingBagEntity
public Transform[] SleepingBagPoints
public GameObjectRef LockerEntity
public Transform LockerPoint
public GameObjectRef BbqEntity
public Transform BbqPoint
public GameObjectRef StorageEntity
public Transform StoragePoint
public EntityRef`1<BaseOven> activeBbq
public EntityRef`1<Locker> activeLocker
public EntityRef`1<StorageContainer> activeStorage
private bool wasLoaded
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
protected Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos)
public void PostServerLoad()
public void Spawn()
private void OnItemAddedRemoved(Item item, bool add)
protected bool CanBeMovedNowOnVehicle()
protected void PostConditionalRefresh()
private CamperSeatConfig GetSeatConfig()
public void Save(SaveInfo info)
public void RPC_OpenLocker(RPCMessage msg)
public void RPC_OpenStorage(RPCMessage msg)
internal void DoServerDestroy()
public IItemContainerEntity GetContainer()
public string Admin_Who()
public bool CanBeLooted(BasePlayer player)
public bool IsOnThisModule(BasePlayer player)
public void Load(LoadInfo info)
}
public VehicleModuleEngine : VehicleModuleStorage {
public Engine engine
private bool <IsUsable>k__BackingField
private float <PerformanceFractionAcceleration>k__BackingField
private float <PerformanceFractionTopSpeed>k__BackingField
private float <PerformanceFractionFuelEconomy>k__BackingField
private float <OverallPerformanceFraction>k__BackingField
private float FORCE_MULTIPLIER
private float HEALTH_PERFORMANCE_FRACTION
private float LOW_PERFORMANCE_THRESHOLD
private Sound badPerformanceLoop
private Modulator badPerformancePitchModulator
private float prevSmokePercent
private float MIN_FORCE_BIAS
private float MAX_FORCE_BIAS
public bool HasAnEngine
public bool IsUsable
public float PerformanceFractionAcceleration
public float PerformanceFractionTopSpeed
public float PerformanceFractionFuelEconomy
public float OverallPerformanceFraction
public bool AtLowPerformance
public bool AtPeakPerformance
public int KW
public EngineAudioSet AudioSet
private bool EngineIsOn
public bool get_HasAnEngine()
public bool get_IsUsable()
public void set_IsUsable(bool value)
public float get_PerformanceFractionAcceleration()
public void set_PerformanceFractionAcceleration(float value)
public float get_PerformanceFractionTopSpeed()
public void set_PerformanceFractionTopSpeed(float value)
public float get_PerformanceFractionFuelEconomy()
public void set_PerformanceFractionFuelEconomy(float value)
public float get_OverallPerformanceFraction()
public void set_OverallPerformanceFraction(float value)
public bool get_AtLowPerformance()
public bool get_AtPeakPerformance()
public int get_KW()
public EngineAudioSet get_AudioSet()
private bool get_EngineIsOn()
public void InitShared()
public void OnEngineStateChanged(EngineState<GroundVehicle> oldState, EngineState<GroundVehicle> newState)
public float GetMaxDriveForce()
public void RefreshPerformanceStats(EngineStorage engineStorage)
public float GetPerformanceFraction(float statBoostPercent)
public void Load(LoadInfo info)
public bool CanBeLooted(BasePlayer player)
public void VehicleFixedUpdate()
public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
public void Hurt(HitInfo info)
public void OnHealthChanged(float oldValue, float newValue)
public bool AdminFixUp(int tier)
}
public VehicleModuleInformationPanel : ItemInformationPanel {
public ItemStatValue socketsDisplay
public ItemStatValue hpDisplay
}
public VehicleModuleSeating : BaseVehicleModule {
private ProtectionProperties passengerProtection
private ModularCarCodeLockVisuals codeLockVisuals
private Seating seating
private Vector3 steerAngle
private Vector3 accelAngle
private Vector3 brakeAngle
private Vector3 speedometerAngle
private Vector3 fuelAngle
private SoundDefinition hornLoop
private SoundDefinition hornStart
private Flags FLAG_HORN
private float steerPercent
private float throttlePercent
private float brakePercent
private Nullable`1<bool> checkEngineLightOn
private Nullable`1<bool> fuelLightOn
private ModularCar <Car>k__BackingField
protected IVehicleLockUser VehicleLockUser
private MaterialPropertyBlock dashboardLightPB
private int emissionColorID
private BasePlayer hornPlayer
public bool HasSeating
public ModularCar Car
protected bool IsOnACar
protected bool IsOnAVehicleLockUser
public bool DoorsAreLockable
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_HasSeating()
public ModularCar get_Car()
private void set_Car(ModularCar value)
protected bool get_IsOnACar()
protected bool get_IsOnAVehicleLockUser()
public bool get_DoorsAreLockable()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool IsOnThisModule(BasePlayer player)
public bool HasADriverSeat()
public void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
public void ModuleRemoved()
public bool PlayerCanDestroyLock(BasePlayer player)
protected BaseVehicleSeat GetSeatAtIndex(int index)
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void OnPlayerDismountedVehicle(BasePlayer player)
public void RPC_DestroyLock(RPCMessage msg)
protected Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos)
public void OnEngineStateChanged(EngineState<GroundVehicle> oldState, EngineState<GroundVehicle> newState)
}
public VehicleModuleStorage : VehicleModuleSeating {
private Storage storage
private EntityRef storageUnitInstance
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public IItemContainerEntity GetContainer()
public void Load(LoadInfo info)
public void Spawn()
public void PostServerLoad()
private void OnItemAddedRemoved(Item item, bool add)
internal void DoServerDestroy()
public void Save(SaveInfo info)
public void CreateStorageEntity()
public void DestroyStorageEntity()
public void RPC_Open(RPCMessage msg)
private bool TryOpen(BasePlayer player)
protected bool CanBeMovedNowOnVehicle()
public void RPC_TryOpenWithKeycode(RPCMessage msg)
}
public VehicleModuleTaxi : VehicleModuleStorage {
private SoundDefinition kickButtonSound
private SphereCollider kickButtonCollider
private float maxKickVelocity
private Vector3 KickButtonPos
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private Vector3 get_KickButtonPos()
private bool CanKickPassengers(BasePlayer player)
public void RPC_KickPassengers(RPCMessage msg)
private void KickPassengers()
}
public VehiclePrivilege : SimplePrivilege {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsDriver(BasePlayer player)
private void AddSelfAuthorize(RPCMessage rpc)
public void AddPlayer(BasePlayer player)
private void RemoveSelfAuthorize(RPCMessage rpc)
private void ClearList(RPCMessage rpc)
}
public VehicleSpawner : BaseEntity {
public float spawnNudgeRadius
public float cleanupRadius
public float occupyRadius
public SpawnPair[] objectsToSpawn
public Transform spawnOffset
public float safeRadius
protected bool LogAnalytics
public int GetOccupyLayer()
public IVehicleSpawnUser GetVehicleOccupying()
public bool IsPadOccupied()
public void OnEntityMessage(BaseEntity from, string msg)
public IVehicleSpawnUser SpawnVehicle(string prefabToSpawn, BasePlayer newOwner)
protected bool get_LogAnalytics()
public void CleanupArea(float radius)
public void NudgePlayersInRadius(float radius)
}
public VehicleSpawnPoint : SpaceCheckingSpawnPoint {
public void ObjectSpawned(SpawnPointInstance instance)
public void AddStartingFuel(IVehicleSpawnUser vehicle)
}
public VehicleTerrainHandler : object {
public string CurGroundPhysicsMatName
public Surface OnSurface
public bool IsGrounded
public float RayLength
private String[] TerrainRoad
private float SECONDS_BETWEEN_TERRAIN_SAMPLE
private TimeSince timeSinceTerrainCheck
private BaseVehicle vehicle
public bool IsOnSnowOrIce
public bool get_IsOnSnowOrIce()
public void .ctor(BaseVehicle vehicle)
public void FixedUpdate()
private void DoTerrainCheck()
private bool GetOnRoad(string physicMat)
}
public VehicleVendor : NPCTalking {
public EntityRef spawnerRef
public VehicleSpawner vehicleSpawner
public string GetConversationStartSpeech(BasePlayer player)
public VehicleSpawner GetVehicleSpawner()
public void UpdateFlags()
public void ServerInit()
public void Save(SaveInfo info)
public ConversationData GetConversationFor(BasePlayer player)
public void Load(LoadInfo info)
}
public VendingMachine : StorageContainer {
public Phrase WaitForVendingMessage
public GameObjectRef adminMenuPrefab
public string customerPanel
public SellOrderContainer sellOrders
public SoundPlayer buySound
public string shopName
public int maxCurrencyVolume
public GameObjectRef mapMarkerPrefab
public bool IsLocalized
private Action fullUpdateCached
protected BasePlayer vend_Player
private int vend_sellOrderID
private int vend_numberOfTransactions
public bool transactionActive
private VendingMachineMapMarker myMarker
private bool industrialItemIncoming
public ItemDefinition blueprintBaseDef
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public int GetTotalPriceForOrder(SellOrder order)
public int GetTotalPriceForOrder(int currencyAmountPerItem, float multiplier)
public ItemDefinition get_blueprintBaseDef()
public void Save(SaveInfo info)
public void ServerInit()
public void DestroyShared()
public void OnItemAddedOrRemoved(Item item, bool added)
public void FullUpdate()
protected void OnInventoryDirty()
public void RefreshSellOrderStockLevel(ItemDefinition itemDef)
protected float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder)
public bool OutOfStock()
public void PostServerLoad()
public void UpdateEmptyFlag()
public void PlayerStoppedLooting(BasePlayer player)
public void InstallDefaultSellOrders()
public bool HasVendingSounds()
public float GetBuyDuration()
public void SetPendingOrder(BasePlayer buyer, int sellOrderId, int numberOfTransactions)
public void ClearPendingOrder()
public void BuyItem(RPCMessage rpc)
public void CompletePendingOrder()
public void TransactionStart(RPCMessage rpc)
private void GetItemsToSell(SellOrder sellOrder, List`1<Item> items)
public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer, Action`2<BasePlayer, Item> onCurrencyRemoved, Action`2<BasePlayer, Item> onItemPurchased, MarketTerminal droneMarketTerminal)
protected void RecordSaleAnalytics(Item itemSold, int orderId)
public void TakeCurrencyItem(Item takenCurrencyItem)
public void GiveSoldItem(Item soldItem, BasePlayer buyer)
public void SendSellOrders(BasePlayer player)
public void RPC_Broadcast(RPCMessage msg)
public void RPC_UpdateShopName(RPCMessage msg)
public void UpdateMapMarkerPosition()
public void SetupPositionUpdate()
public void UpdateMapMarker(bool updatePosition)
public void OpenShop(BasePlayer ply)
public void RPC_OpenShopNoLOS(RPCMessage msg)
public void RPC_OpenShop(RPCMessage msg)
public void RPC_OpenAdmin(RPCMessage msg)
public void OnIndustrialItemTransferBegins()
public void OnIndustrialItemTransferEnds()
public bool CanAcceptItem(Item item, int targetSlot)
public bool CanMoveFrom(BasePlayer player, Item item)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public void RPC_DeleteSellOrder(RPCMessage msg)
public void RPC_RotateVM(RPCMessage msg)
public void RPC_AddSellOrder(RPCMessage msg)
public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
public void RefreshAndSendNetworkUpdate()
public void UpdateOrCreateSalesSheet()
protected bool CanRotate()
public bool IsBroadcasting()
public bool IsInventoryEmpty()
public bool IsVending()
public bool PlayerBehind(BasePlayer player)
public bool PlayerInfront(BasePlayer player)
public bool CanPlayerAdmin(BasePlayer player)
public bool SupportsChildDeployables()
public string GetTranslationToken()
}
public VendingMachineFront : BaseEntity {
public VendingMachine vendingMachine
}
public VendingMachineMapMarker : MapMarker {
public string markerShopName
public VendingMachine server_vendingMachine
public VendingMachine client_vendingMachine
public NetworkableId client_vendingMachineNetworkID
public GameObjectRef clusterMarkerObj
private UIMapVendingMachineMarker myUIMarker
private RectTransform markerTransform
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SetVendingMachine(VendingMachine vm, string shopName)
public void SetupPositionUpdate()
public void TryUpdatePosition()
public void Save(SaveInfo info)
public AppMarker GetAppMarkerData()
}
public VendingMachineScreen : MonoBehaviour {
public RawImage largeIcon
public RawImage blueprintIcon
public Text mainText
public Text lowerText
public Text centerText
public RawImage smallIcon
public VendingMachine vendingMachine
public Sprite outOfStockSprite
public Renderer fadeoutMesh
public CanvasGroup screenCanvas
public Renderer light1
public Renderer light2
public bool isUpdatedWithNotifySystem
}
public VendingPanelAdmin : UIDialog {
public GameObject sellOrderAdminContainer
public GameObject sellOrderAdminPrefab
public TMP_InputField storeNameInputField
public EmojiGallery emojiGallery
}
public VendingPriceMultiplierWidget : MonoBehaviour {
public GameObject SurchargeRoot
public RustText SurchargeText
public GameObject DiscountRoot
public RustText DiscountText
public Tooltip SurchargeTooltip
public Tooltip DiscountTooltip
public GameObject RegularTooltip
public GameObject AlwaysOnTopTooltip
}
public VendorList : MonoBehaviour {
public GameObject singleHeader
public GameObject multiHeader
public Transform ListParent
public GameObjectRef SingleVendorPrefab
public ScrollRect scrollRect
}
public VendorListing : FacepunchBehaviour {
public Image panelBacking
public RustText AvailableText
public RustText CostText
public RustText AvailableAmount
public RustText CostAmount
public RustText InStockAmount
public RustText InStockText
public VendingPriceMultiplierWidget PriceMultiplier
public Image AvaliableIcon
public Image CostIcon
public Image AvaliableBPIcon
public Image CostBPIcon
public Image AvaliableBPBacking
public Image CostBPBacking
public Tooltip avaliableIconTooltip
public Tooltip costIconTooltip
public CanvasGroup availableConditionGroup
public Image availableCondition
public Image availableMaxCondition
public GameObject brokenIcon
public GameObject slots
public Image[] slotImages
private FlexTransition transition
public Phrase inStockPhrase
public Phrase outOfStockPhrase
public Phrase attachmentsPhrase
}
public VertexColorAnimator : MonoBehaviour {
public List`1<MeshHolder> animationMeshes
public List`1<float> animationKeyframes
public float timeScale
public int mode
private float elapsedTime
public void initLists()
public void addMesh(Mesh mesh, float atPosition)
private void Start()
public void replaceKeyframe(int frameIndex, Mesh mesh)
public void deleteKeyframe(int frameIndex)
public void scrobble(float scrobblePos)
private void Update()
}
public VertexColorStream : MonoBehaviour {
public Mesh originalMesh
public Mesh paintedMesh
public MeshHolder meshHold
public Vector3[] _vertices
public Vector3[] _normals
public Int32[] _triangles
public Int32[][] _Subtriangles
public Matrix4x4[] _bindPoses
public BoneWeight[] _boneWeights
public Bounds _bounds
public int _subMeshCount
public Vector4[] _tangents
public Vector2[] _uv
public Vector2[] _uv2
public Vector2[] _uv3
public Color[] _colors
public Vector2[] _uv4
private void OnDidApplyAnimationProperties()
public void init(Mesh origMesh, bool destroyOld)
public void setWholeMesh(Mesh tmpMesh)
public Vector3[] setVertices(Vector3[] _deformedVertices)
public Vector3[] getVertices()
public Vector3[] getNormals()
public Int32[] getTriangles()
public void setTangents(Vector4[] _meshTangents)
public Vector4[] getTangents()
public void setColors(Color[] _vertexColors)
public Color[] getColors()
public Vector2[] getUVs()
public void setUV4s(Vector2[] _uv4s)
public Vector2[] getUV4s()
public void unlink()
public void rebuild()
private void Start()
}
public ViewModel : MonoBehaviour {
public GameObjectRef viewModelPrefab
}
public ViewmodelAspectOffset : MonoBehaviour {
public Vector3 OffsetAmount
public float aspectCutoff
}
public ViewmodelAttachment : EntityComponent`1<BaseEntity> {
public GameObjectRef modelObject
public string targetBone
public bool hideViewModelIronSights
}
public ViewmodelBob : MonoBehaviour {
public float bobSpeedWalk
public float bobSpeedRun
public float bobAmountWalk
public float bobAmountRun
public float leftOffsetRun
}
public ViewmodelCameraAnimation : MonoBehaviour {
public Transform CameraModifyBone
public bool ShouldSuppressLeftHandScreenShake
public float FadeInTime
public Vector3 PositionOffset
public Vector3 RotationOffset
}
public ViewmodelClothing : MonoBehaviour {
public SkeletonSkin[] SkeletonSkins
public bool DisableHandsEntirely
}
public ViewModelDrawEvent : ValueType {
public ViewModelRenderer viewModelRenderer
public Renderer renderer
public bool skipDepthPrePass
public Material material
public int subMesh
public int pass
public bool Equals(ViewModelDrawEvent other)
public bool Equals(object obj)
public int GetHashCode()
}
public ViewmodelIgniteToggle : MonoBehaviour {
public void Start()
}
public ViewmodelLower : MonoBehaviour {
public bool lowerOnSprint
public bool lowerWhenCantAttack
public bool forceLower
public float lowerScale
public void SetShouldLower(bool shouldLower)
}
public ViewmodelMountedAnchor : MonoBehaviour {
public ViewmodelIk IkController
}
public ViewmodelPunch : MonoBehaviour {
public AnimationCurve punchScale
public Vector3 punchDirection
public float punchDuration
public float punchMagnitude
}
public ViewModelRenderer : MonoBehaviour {
public List`1<Texture2D> cachedTextureRefs
public List`1<ViewModelDrawEvent> opaqueEvents
public List`1<ViewModelDrawEvent> transparentEvents
public Matrix4x4 prevModelMatrix
private Renderer viewModelRenderer
}
public ViewmodelScope : MonoBehaviour {
public float smoothSpeed
public Material scopeMaterialOverride
}
public ViewmodelSway : MonoBehaviour {
public float positionalSwaySpeed
public float positionalSwayAmount
public float rotationSwaySpeed
public float rotationSwayAmount
public float rotateAmountTest
}
public ViewShake : object {
private Vector3 <PositionOffset>k__BackingField
private Vector3 <AnglesOffset>k__BackingField
protected List`1<ShakeParameters> Entries
public Vector3 PositionOffset
public Vector3 AnglesOffset
public Vector3 get_PositionOffset()
protected void set_PositionOffset(Vector3 value)
public Vector3 get_AnglesOffset()
protected void set_AnglesOffset(Vector3 value)
public void AddShake(float amplitude, float frequency, float duration)
public void Update()
public void Stop()
}
public VirtualEntityScheduler : object {
private VirtualEntityScheduler <Instance>k__BackingField
public VirtualEntityScheduler Instance
public VirtualEntityScheduler get_Instance()
private void set_Instance(VirtualEntityScheduler value)
}
public VirtualItemIcon : MonoBehaviour {
public ItemDefinition itemDef
public int itemAmount
public bool asBlueprint
public Image iconImage
public Image bpUnderlay
public Text amountText
public Text hoverText
public CanvasGroup iconContents
public Tooltip ToolTip
public CanvasGroup conditionObject
public Image conditionFill
public Image maxConditionFill
public Image cornerIcon
public GameObject slots
public Image[] slotImages
public Phrase attachmentsPhrase
}
public Vis : object {
private int colCount
public Collider[] colBuffer
private HashSet`1<object> hashSet
private void Buffer(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool AnyColliders(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Colliders(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Components(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Entities(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void EntityComponents(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void Buffer(OBB bounds, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Colliders(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Components(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Entities(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void EntityComponents(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void Buffer(Vector3 startPosition, Vector3 endPosition, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Colliders(Vector3 startPosition, Vector3 endPosition, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Components(Vector3 startPosition, Vector3 endPosition, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Entities(Vector3 startPosition, Vector3 endPosition, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void EntityComponents(Vector3 startPosition, Vector3 endPosition, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
}
public VisualCarWheel : CarWheel {
public Transform visualWheel
public Transform visualWheelSteering
public bool visualPowerWheel
public ParticleSystem snowFX
public ParticleSystem sandFX
public ParticleSystem dirtFX
public ParticleSystem asphaltFX
public ParticleSystem waterFX
public ParticleSystem snowSpinFX
public ParticleSystem sandSpinFX
public ParticleSystem dirtSpinFX
public ParticleSystem asphaltSpinFX
}
public VisualiseTrigger : MonoBehaviour {
private Color colour
}
public VisualizeTexelDensity : MonoBehaviour {
public Shader shader
public string shaderTag
public int texelsPerMeter
public float overlayOpacity
public bool showHUD
private Camera mainCamera
private bool initialized
private int screenWidth
private int screenHeight
private Camera texelDensityCamera
private RenderTexture texelDensityRT
private Texture texelDensityGradTex
private Material texelDensityOverlayMat
private VisualizeTexelDensity instance
public VisualizeTexelDensity Instance
public VisualizeTexelDensity get_Instance()
private void Awake()
private void OnEnable()
private void OnDisable()
private void LoadResources()
private void SafeDestroyViewTexelDensity()
private void SafeDestroyViewTexelDensityRT()
private void UpdateViewTexelDensity(bool screenResized)
private bool CheckScreenResized(int width, int height)
private void OnPreCull()
private void OnRenderImage(RenderTexture source, RenderTexture destination)
private void DrawGUIText(float x, float y, Vector2 size, string text, GUIStyle fontStyle)
private void OnGUI()
}
public VisualStorageContainer : LootContainer {
public VisualStorageContainerNode[] displayNodes
public DisplayModel[] displayModels
public Transform nodeParent
public GameObject defaultDisplayModel
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
public void PopulateLoot()
public void ClearRigidBodies()
public void SetItemsVisible(bool vis)
public void ItemUpdateComplete()
public void UpdateVisibleItems(ItemContainer msg)
}
public VisualStorageContainerNode : MonoBehaviour {
private void Start()
private void Update()
}
public VitalInfo : MonoBehaviour {
public HudElement Element
public Image InfoImage
public Vital VitalType
public TextMeshProUGUI text
}
public VitalLevel : ValueType {
public float Level
private float lastUsedTime
public float TimeSinceUsed
internal void Add(float f)
public float get_TimeSinceUsed()
internal void Use(float f)
}
public VitalNote : MonoBehaviour {
public Vital VitalType
public FloatConditions showIf
public TextMeshProUGUI valueText
}
public VitalNoteOxygen : MonoBehaviour {
private float refreshTime
private TextMeshProUGUI valueText
private Animator animator
private Image airIcon
private RectTransform airIconTr
private Image backgroundImage
private Color baseColour
private Color badColour
private Image iconImage
private Color iconBaseColour
private Color iconBadColour
protected bool show
}
public VitalRadial : MonoBehaviour {
private void Awake()
}
public VLB.AttenuationEquation : Enum {
public int value__
public AttenuationEquation Linear
public AttenuationEquation Quadratic
public AttenuationEquation Blend
}
public VLB.BeamGeometry : MonoBehaviour {
private VolumetricLightBeam m_Master
private Matrix4x4 m_ColorGradientMatrix
private MeshType m_CurrentMeshType
private MeshRenderer <meshRenderer>k__BackingField
private MeshFilter <meshFilter>k__BackingField
private Material <material>k__BackingField
private Mesh <coneMesh>k__BackingField
public MeshRenderer meshRenderer
public MeshFilter meshFilter
public Material material
public Mesh coneMesh
public bool visible
public int sortingLayerID
public int sortingOrder
public MeshRenderer get_meshRenderer()
private void set_meshRenderer(MeshRenderer value)
public MeshFilter get_meshFilter()
private void set_meshFilter(MeshFilter value)
public Material get_material()
private void set_material(Material value)
public Mesh get_coneMesh()
private void set_coneMesh(Mesh value)
public bool get_visible()
public void set_visible(bool value)
public int get_sortingLayerID()
public void set_sortingLayerID(int value)
public int get_sortingOrder()
public void set_sortingOrder(int value)
private void Start()
private void OnDestroy()
private bool IsUsingCustomRenderPipeline()
private void OnEnable()
private void OnDisable()
public void Initialize(VolumetricLightBeam master, Shader shader)
public void RegenerateMesh()
private void ComputeLocalMatrix()
public void UpdateMaterialAndBounds()
public void SetClippingPlane(Plane planeWS)
public void SetClippingPlaneOff()
private void OnBeginCameraRendering(ScriptableRenderContext context, Camera cam)
private void OnWillRenderObject()
private void UpdateCameraRelatedProperties(Camera cam)
}
public VLB.BlendingMode : Enum {
public int value__
public BlendingMode Additive
public BlendingMode SoftAdditive
public BlendingMode TraditionalTransparency
}
public VLB.ColorMode : Enum {
public int value__
public ColorMode Flat
public ColorMode Gradient
}
public VLB.Config : ScriptableObject {
public int geometryLayerID
public string geometryTag
public int geometryRenderQueue
public bool forceSinglePass
private Shader beamShader1Pass
private Shader beamShader2Pass
public int sharedMeshSides
public int sharedMeshSegments
public float globalNoiseScale
public Vector3 globalNoiseVelocity
public TextAsset noise3DData
public int noise3DSize
public ParticleSystem dustParticlesPrefab
private Config m_Instance
public Shader beamShader
public Vector4 globalNoiseParam
public Config Instance
public Shader get_beamShader()
public Vector4 get_globalNoiseParam()
public void Reset()
public ParticleSystem NewVolumetricDustParticles()
public Config get_Instance()
}
public VLB.Consts : object {
private string HelpUrlBase
public string HelpUrlBeam
public string HelpUrlDustParticles
public string HelpUrlDynamicOcclusion
public string HelpUrlTriggerZone
public string HelpUrlConfig
public bool ProceduralObjectsVisibleInEditor
public Color FlatColor
public ColorMode ColorModeDefault
public float Alpha
public float SpotAngleDefault
public float SpotAngleMin
public float SpotAngleMax
public float ConeRadiusStart
public MeshType GeomMeshType
public int GeomSidesDefault
public int GeomSidesMin
public int GeomSidesMax
public int GeomSegmentsDefault
public int GeomSegmentsMin
public int GeomSegmentsMax
public bool GeomCap
public AttenuationEquation AttenuationEquationDefault
public float AttenuationCustomBlending
public float FadeStart
public float FadeEnd
public float FadeMinThreshold
public float DepthBlendDistance
public float CameraClippingDistance
public float FresnelPowMaxValue
public float FresnelPow
public float GlareFrontal
public float GlareBehind
public float NoiseIntensityMin
public float NoiseIntensityMax
public float NoiseIntensityDefault
public float NoiseScaleMin
public float NoiseScaleMax
public float NoiseScaleDefault
public Vector3 NoiseVelocityDefault
public BlendingMode BlendingModeDefault
public BlendMode[] BlendingMode_SrcFactor
public BlendMode[] BlendingMode_DstFactor
public Boolean[] BlendingMode_AlphaAsBlack
public float DynOcclusionMinSurfaceRatioDefault
public float DynOcclusionMinSurfaceRatioMin
public float DynOcclusionMinSurfaceRatioMax
public float DynOcclusionMaxSurfaceDotDefault
public float DynOcclusionMaxSurfaceAngleMin
public float DynOcclusionMaxSurfaceAngleMax
public int ConfigGeometryLayerIDDefault
public string ConfigGeometryTagDefault
public RenderQueue ConfigGeometryRenderQueueDefault
public bool ConfigGeometryForceSinglePassDefault
public int ConfigNoise3DSizeDefault
public int ConfigSharedMeshSides
public int ConfigSharedMeshSegments
public HideFlags ProceduralObjectsHideFlags
public HideFlags get_ProceduralObjectsHideFlags()
}
public VLB.DynamicOcclusion : MonoBehaviour {
public LayerMask layerMask
public float minOccluderArea
public int waitFrameCount
public float minSurfaceRatio
public float maxSurfaceDot
public PlaneAlignment planeAlignment
public float planeOffset
private VolumetricLightBeam m_Master
private int m_FrameCountToWait
private float m_RangeMultiplier
private UInt32 m_PrevNonSubHitDirectionId
private void OnValidate()
private void OnEnable()
private void OnDisable()
private void Start()
private void LateUpdate()
private Vector3 GetRandomVectorAround(Vector3 direction, float angleDiff)
private RaycastHit GetBestHit(Vector3 rayPos, Vector3 rayDir)
private Vector3 GetDirection(UInt32 dirInt)
private bool IsHitValid(RaycastHit hit)
private void ProcessRaycasts()
private void SetHit(RaycastHit hit)
private void SetHitNull()
private void SetClippingPlane(Plane planeWS)
private void SetClippingPlaneOff()
}
public VLB.GlobalMesh : object {
private Mesh ms_Mesh
public Mesh mesh
public Mesh get_mesh()
}
public VLB.MeshGenerator : object {
private float kMinTruncatedRadius
private bool duplicateBackFaces
private bool get_duplicateBackFaces()
public Mesh GenerateConeZ_RadiusAndAngle(float lengthZ, float radiusStart, float coneAngle, int numSides, int numSegments, bool cap)
public Mesh GenerateConeZ_Angle(float lengthZ, float coneAngle, int numSides, int numSegments, bool cap)
public Mesh GenerateConeZ_Radius(float lengthZ, float radiusStart, float radiusEnd, int numSides, int numSegments, bool cap)
public int GetVertexCount(int numSides, int numSegments, bool geomCap)
public int GetIndicesCount(int numSides, int numSegments, bool geomCap)
public int GetSharedMeshVertexCount()
public int GetSharedMeshIndicesCount()
}
public VLB.MeshType : Enum {
public int value__
public MeshType Shared
public MeshType Custom
}
public VLB.Noise3D : object {
private bool ms_IsSupportedChecked
private bool ms_IsSupported
private Texture3D ms_NoiseTexture
private HideFlags kHideFlags
private int kMinShaderLevel
public bool isSupported
public bool isProperlyLoaded
public string isNotSupportedString
public bool get_isSupported()
public bool get_isProperlyLoaded()
public string get_isNotSupportedString()
private void OnStartUp()
public void LoadIfNeeded()
private Texture3D LoadTexture3D(TextAsset textData, int size)
}
public VLB.PlaneAlignment : Enum {
public int value__
public PlaneAlignment Surface
public PlaneAlignment Beam
}
public VLB.RenderQueue : Enum {
public int value__
public RenderQueue Custom
public RenderQueue Background
public RenderQueue Geometry
public RenderQueue AlphaTest
public RenderQueue GeometryLast
public RenderQueue Transparent
public RenderQueue Overlay
}
public VLB.TriggerZone : MonoBehaviour {
public bool setIsTrigger
public float rangeMultiplier
private int kMeshColliderNumSides
private Mesh m_Mesh
private void Update()
}
public VLB.Utils : object {
private FloatPackingPrecision ms_FloatPackingPrecision
private int kFloatPackingHighMinShaderLevel
public string GetPath(Transform current)
public T NewWithComponent(string name)
public T GetOrAddComponent(GameObject self)
public T GetOrAddComponent(MonoBehaviour self)
public bool HasFlag(Enum mask, Enum flags)
public Vector2 xy(Vector3 aVector)
public Vector2 xz(Vector3 aVector)
public Vector2 yz(Vector3 aVector)
public Vector2 yx(Vector3 aVector)
public Vector2 zx(Vector3 aVector)
public Vector2 zy(Vector3 aVector)
public float GetVolumeCubic(Bounds self)
public float GetMaxArea2D(Bounds self)
public Color Opaque(Color self)
public void GizmosDrawPlane(Vector3 normal, Vector3 position, Color color, float size)
public Plane TranslateCustom(Plane plane, Vector3 translation)
public bool IsValid(Plane plane)
public Matrix4x4 SampleInMatrix(Gradient self, int floatPackingPrecision)
public Color[] SampleInArray(Gradient self, int samplesCount)
private Vector4 Vector4_Floor(Vector4 vec)
public float4 ToFloat4(Color color)
public float PackToFloat(Color color, int floatPackingPrecision)
public FloatPackingPrecision GetFloatPackingPrecision()
public void MarkCurrentSceneDirty()
}
public VLB.Version : object {
public int Current
}
public VLB.VolumetricDustParticles : MonoBehaviour {
public float alpha
public float size
public Direction direction
public float speed
public float density
public float spawnMaxDistance
public bool cullingEnabled
public float cullingMaxDistance
private bool <isCulled>k__BackingField
public bool isFeatureSupported
private ParticleSystem m_Particles
private ParticleSystemRenderer m_Renderer
private bool ms_NoMainCameraLogged
private Camera ms_MainCamera
private VolumetricLightBeam m_Master
public bool isCulled
public bool particlesAreInstantiated
public int particlesCurrentCount
public int particlesMaxCount
public Camera mainCamera
public bool get_isCulled()
private void set_isCulled(bool value)
public bool get_particlesAreInstantiated()
public int get_particlesCurrentCount()
public int get_particlesMaxCount()
public Camera get_mainCamera()
private void Start()
private void InstantiateParticleSystem()
private void OnEnable()
private void SetActiveAndPlay()
private void OnDisable()
private void OnDestroy()
private void Update()
private void SetParticleProperties()
private void UpdateCulling()
}
public VLB.VolumetricLightBeam : MonoBehaviour {
public bool colorFromLight
public ColorMode colorMode
public Color color
public Gradient colorGradient
public float alphaInside
public float alphaOutside
public BlendingMode blendingMode
public bool spotAngleFromLight
public float spotAngle
public float coneRadiusStart
public MeshType geomMeshType
public int geomCustomSides
public int geomCustomSegments
public bool geomCap
public bool fadeEndFromLight
public AttenuationEquation attenuationEquation
public float attenuationCustomBlending
public float fadeStart
public float fadeEnd
public float depthBlendDistance
public float cameraClippingDistance
public float glareFrontal
public float glareBehind
public float boostDistanceInside
public float fresnelPowInside
public float fresnelPow
public bool noiseEnabled
public float noiseIntensity
public bool noiseScaleUseGlobal
public float noiseScaleLocal
public bool noiseVelocityUseGlobal
public Vector3 noiseVelocityLocal
private Plane m_PlaneWS
private int pluginVersion
private bool _TrackChangesDuringPlaytime
private int _SortingLayerID
private int _SortingOrder
private BeamGeometry m_BeamGeom
private Coroutine m_CoPlaytimeUpdate
private Light _CachedLight
public float coneAngle
public float coneRadiusEnd
public float coneVolume
public float coneApexOffsetZ
public int geomSides
public int geomSegments
public float attenuationLerpLinearQuad
public int sortingLayerID
public string sortingLayerName
public int sortingOrder
public bool trackChangesDuringPlaytime
public bool isCurrentlyTrackingChanges
public bool hasGeometry
public Bounds bounds
public int blendingModeAsInt
public MeshRenderer Renderer
public string meshStats
public int meshVerticesCount
public int meshTrianglesCount
private Light lightSpotAttached
public float get_coneAngle()
public float get_coneRadiusEnd()
public float get_coneVolume()
public float get_coneApexOffsetZ()
public int get_geomSides()
public void set_geomSides(int value)
public int get_geomSegments()
public void set_geomSegments(int value)
public float get_attenuationLerpLinearQuad()
public int get_sortingLayerID()
public void set_sortingLayerID(int value)
public string get_sortingLayerName()
public void set_sortingLayerName(string value)
public int get_sortingOrder()
public void set_sortingOrder(int value)
public bool get_trackChangesDuringPlaytime()
public void set_trackChangesDuringPlaytime(bool value)
public bool get_isCurrentlyTrackingChanges()
public bool get_hasGeometry()
public Bounds get_bounds()
public void SetClippingPlane(Plane planeWS)
public void SetClippingPlaneOff()
public bool IsColliderHiddenByDynamicOccluder(Collider collider)
public int get_blendingModeAsInt()
public MeshRenderer get_Renderer()
public string get_meshStats()
public int get_meshVerticesCount()
public int get_meshTrianglesCount()
private Light get_lightSpotAttached()
public float GetInsideBeamFactor(Vector3 posWS)
public float GetInsideBeamFactorFromObjectSpacePos(Vector3 posOS)
public void Generate()
public void GenerateGeometry()
public void UpdateAfterManualPropertyChange()
private void Start()
private void OnEnable()
private void OnDisable()
private void StartPlaytimeUpdateIfNeeded()
private IEnumerator CoPlaytimeUpdate()
private void OnDestroy()
private void DestroyBeam()
private void AssignPropertiesFromSpotLight(Light lightSpot)
private void ClampProperties()
private void ValidateProperties()
private void HandleBackwardCompatibility(int serializedVersion, int newVersion)
}
public VoicemailDialog : MonoBehaviour {
public GameObject RecordingRoot
public RustSlider RecordingProgress
public GameObject BrowsingRoot
public PhoneDialler ParentDialler
public GameObjectRef VoicemailEntry
public Transform VoicemailEntriesRoot
public GameObject NoVoicemailRoot
public GameObject NoCassetteRoot
}
public VoicemailEntry : MonoBehaviour {
public GameObject PlayingRoot
public RustText DisplayName
public RustIcon PlayIcon
public RustSlider ProgressSlider
}
public VoiceProcessor : EntityComponentBase {
public AudioSource mouthSpeaker
public PlayerVoiceSpeaker playerSpeaker
public float volumeMultiplier
}
public VTP : MonoBehaviour {
public Color getSingleVertexColorAtHit(Transform transform, RaycastHit hit)
public Color getFaceVerticesColorAtHit(Transform transform, RaycastHit hit)
public void paintSingleVertexOnHit(Transform transform, RaycastHit hit, Color color, float strength)
public void paintFaceVerticesOnHit(Transform transform, RaycastHit hit, Color color, float strength)
public void deformSingleVertexOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
public void deformFaceVerticesOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
private void recalculateMeshForFlow(Transform transform, Vector3[] currentVertices, Vector3[] currentNormals, Vector4[] currentTangents)
private Vector4[] calculateMeshTangents(Int32[] triangles, Vector3[] vertices, Vector2[] uv, Vector3[] normals)
public Color VertexColorLerp(Color colorA, Color colorB, float value)
}
public WantedPoster : DecayEntity {
public UInt32 imageCrc
public ulong playerId
public string playerName
public MeshRenderer PhotoImage
public RustText WantedName
public GameObjectRef AssignDialog
public Flags HasTarget
public EffectMode EffectMode
private List`1<ulong> <EditingHistory>k__BackingField
public UInt32[] GetContentCRCs
public UGCType ContentType
public List`1<ulong> EditingHistory
public BaseNetworkable UgcEntity
public Vector2i TextureSize
public int TextureCount
public NetworkableId NetworkID
public Type FileType
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void UpdatePoster(RPCMessage msg)
private void ClearPlayer(RPCMessage msg)
public void SetTextureCRCs(UInt32[] crcs)
public UInt32[] get_GetContentCRCs()
public void ClearContent()
public UGCType get_ContentType()
public List`1<ulong> get_EditingHistory()
public BaseNetworkable get_UgcEntity()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool CanUpdateSign(BasePlayer player)
public Vector2i get_TextureSize()
public int get_TextureCount()
public UInt32[] GetTextureCRCs()
public NetworkableId get_NetworkID()
public Type get_FileType()
}
public WaterBall : BaseEntity {
public ItemDefinition liquidType
public int waterAmount
public GameObjectRef waterExplosion
public Collider waterCollider
public Rigidbody myRigidBody
public void ServerInit()
public void Extinguish()
public void FixedUpdate()
public bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount)
private void OnCollisionEnter(Collision collision)
}
public WaterBaseNavGenTest : MonoBehaviour {
private IEnumerator co
public void NavGen()
}
public WaterBody : MonoBehaviour {
public WaterBodyType Type
public Renderer Renderer
public Collider[] Triggers
public bool IsOcean
private Transform <Transform>k__BackingField
public FishingTag FishingType
public Transform Transform
private void set_Transform(Transform value)
public Transform get_Transform()
private void Awake()
private void OnEnable()
private void OnDisable()
public void OnOceanLevelChanged(float newLevel)
}
public WaterBodyType : Enum {
public int value__
public WaterBodyType Ocean
public WaterBodyType River
public WaterBodyType Lake
public WaterBodyType Pool
public WaterBodyType Moonpool
}
public WaterCatcher : LiquidContainer {
public ItemDefinition itemToCreate
public WaterCatcherCollectRate collectionRates
public float maxItemToCreate
public Vector3 rainTestPosition
public float rainTestSize
public float collectInterval
public void ServerInit()
public void CollectWater()
public bool IsFull()
public bool TestIsOutside()
public void AddResource(int iAmount)
private IOEntity CheckPushLiquid(IOEntity connected, int amount, IOEntity fromSource, int depth)
}
public WaterCatcherCollectRate : ScriptableObject {
public float baseRate
public float rainRate
public float snowRate
public float fogRate
}
public WaterCheck : PrefabAttribute {
public bool Rotate
protected void OnDrawGizmosSelected()
public bool Check(Vector3 pos)
protected Type GetIndexedType()
}
public WaterCheckEx : object {
public bool ApplyWaterChecks(Transform transform, WaterCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale)
}
public WaterCheckGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementDistance
public bool CheckRotate
}
public WaterCollision : MonoBehaviour {
private ListDictionary`2<Collider, List`1<Collider>> ignoredColliders
private HashSet`1<Collider> waterColliders
private void Awake()
public void Clear()
public void Reset(Collider collider)
public bool GetIgnore(Vector3 pos, float radius)
public bool GetIgnore(Bounds bounds)
public bool GetIgnore(Vector3 start, Vector3 end, float radius)
public bool GetIgnore(RaycastHit hit)
public bool GetIgnore(Collider collider)
public void SetIgnore(Collider collider, Collider trigger, bool ignore)
protected void LateUpdate()
}
public WaterCullingVolume : MonoBehaviour {
public bool isDynamic
}
public WaterDepthTester : MonoBehaviour {
private void Update()
}
public WaterInflatable : BaseMountable {
public Transform centerOfMass
public float forwardPushForce
public float rearPushForce
public float rotationForce
public float maxSpeed
public float maxPaddleFrequency
public SoundDefinition paddleSfx
public SoundDefinition smallPlayerMovementSound
public SoundDefinition largePlayerMovementSound
public BlendedSoundLoops waterLoops
public float waterSoundSpeedDivisor
public float additiveDownhillVelocity
public GameObjectRef handSplashForwardEffect
public GameObjectRef handSplashBackEffect
public GameObjectRef footSplashEffect
public float animationLerpSpeed
public Transform smoothedEyePosition
public float smoothedEyeSpeed
public Buoyancy buoyancy
public bool driftTowardsIsland
public GameObjectRef mountEffect
public float handSplashOffset
public float velocitySplashMultiplier
public Vector3 modifyEyeOffset
public float inheritVelocityMultiplier
private TimeSince lastPaddle
public ParticleSystem[] movingParticleSystems
public float movingParticlesThreshold
public Transform headSpaceCheckPosition
public float headSpaceCheckRadius
private TimeSince landFacingCheck
private bool isFacingLand
private float landPushAcceleration
private TimeSince inPoolCheck
private bool isInPool
private Vector3 lastPos
private Vector3 lastClipCheckPosition
private bool forceClippingCheck
private bool prevSleeping
public bool IsSummerDlcVehicle
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
public void VehicleFixedUpdate()
public void OnPlayerMounted()
public void PlayerServerInput(InputState inputState, BasePlayer player)
private void PaddleTurn(PaddleDirection direction)
public float WaterFactorForPlayer(BasePlayer player)
public void OnCollision(Collision collision, BaseEntity hitEntity)
private bool IsOutOfWaterServer()
public void OnPoolDestroyed()
public void WakeUp()
public bool get_IsSummerDlcVehicle()
public void OnObjects(TriggerNotify trigger)
public void OnEmpty()
}
public WaterInteraction : MonoBehaviour {
private Texture2D texture
public float Displacement
public float Disturbance
}
public WaterLevel : object {
public float Factor(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity)
public float Factor(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity)
public bool Test(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity)
public float GetWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity)
public float GetOverallWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity, bool noEarlyExit)
public WaterInfo GetBuoyancyWaterInfo(Vector3 pos, Vector2 posUV, float terrainHeight, float waterHeight, bool doDeepwaterChecks, BaseEntity forEntity)
public WaterInfo GetWaterInfo(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity, bool noEarlyExit)
public WaterInfo GetWaterInfo(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity)
public WaterInfo GetWaterInfo(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity)
public WaterInfo GetWaterInfo(Camera cam, bool waves, bool volumes, BaseEntity forEntity, bool noEarlyExit)
private float GetWaterLevel(Vector3 pos)
private WaterInfo GetWaterInfoFromVolumes(Bounds bounds, BaseEntity forEntity)
private WaterInfo GetWaterInfoFromVolumes(Vector3 pos, BaseEntity forEntity)
private WaterInfo GetWaterInfoFromVolumes(Vector3 start, Vector3 end, float radius, BaseEntity forEntity)
}
public WaterOverlay : MonoBehaviour {
public PostProcessVolume postProcessVolume
public PostProcessVolume blurPostProcessVolume
public EffectParams defaultParams
public EffectParams adminParams
public EffectParams gogglesParams
public EffectParams submarineParams
public EffectParams underwaterLabParams
public EffectParams cinematicParams
public Material[] UnderwaterFogMaterials
}
public WaterPump : LiquidContainer {
public Transform WaterResourceLocation
public float PumpInterval
public int AmountPerPump
public int PowerConsumption
public bool IsGravitySource
public int ConsumptionAmount()
public void CreateWater()
public void OnFlagsChanged(Flags old, Flags next)
public int GetPassthroughAmount(int outputSlot)
public bool IsFull()
public bool get_IsGravitySource()
}
public WaterPurifier : LiquidContainer {
public GameObjectRef storagePrefab
public Transform storagePrefabAnchor
public ItemDefinition freshWater
public int waterToProcessPerMinute
public int freshWaterRatio
public bool stopWhenOutputFull
public LiquidContainer waterStorage
public float dirtyWaterProcssed
public float pendingFreshWater
public void ServerInit()
public void PostServerLoad()
internal void DoServerDestroy()
protected void SpawnStorageEnt(bool load)
internal void OnParentRemoved()
public void OnKilled(HitInfo info)
public void ParentTemperatureUpdate(float temp)
public void CheckCoolDown()
public bool HasDirtyWater()
public void Cook(float timeCooked)
protected void ConvertWater(float timeCooked)
public void Load(LoadInfo info)
public bool CanPickup(BasePlayer player)
public bool IsBoiling()
}
public WaterQuality : Enum {
public int value__
public WaterQuality Low
public WaterQuality Medium
public WaterQuality High
}
public WaterResource : object {
public ItemDefinition GetAtPoint(Vector3 pos)
public bool IsFreshWater(Vector3 pos)
public ItemDefinition Merge(ItemDefinition first, ItemDefinition second)
}
public WaterSystem : MonoBehaviour {
private float oceanLevel
private WaterSystem <Instance>k__BackingField
private WaterCollision <Collision>k__BackingField
private WaterBody <Ocean>k__BackingField
private ListHashSet`1<WaterCamera> <WaterCameras>k__BackingField
private HashSet`1<WaterBody> <WaterBodies>k__BackingField
private HashSet`1<WaterDepthMask> <DepthMasks>k__BackingField
private float <WaveTime>k__BackingField
public OceanSettings oceanSettings
public OceanSimulation oceanSimulation
public WaterQuality Quality
public Material oceanMaterial
public RenderingSettings Rendering
public int patchSize
public int patchCount
public float patchScale
private bool <IsInitialized>k__BackingField
public WaterSystem Instance
public WaterCollision Collision
public WaterBody Ocean
public Material OceanMaterial
public ListHashSet`1<WaterCamera> WaterCameras
public HashSet`1<WaterBody> WaterBodies
public HashSet`1<WaterDepthMask> DepthMasks
public float WaveTime
public float OceanLevel
public bool IsInitialized
public int Layer
public int Reflections
public float WindowDirection
public Single[] OctaveScales
public WaterSystem get_Instance()
private void set_Instance(WaterSystem value)
public WaterCollision get_Collision()
private void set_Collision(WaterCollision value)
public WaterBody get_Ocean()
private void set_Ocean(WaterBody value)
public Material get_OceanMaterial()
public ListHashSet`1<WaterCamera> get_WaterCameras()
public HashSet`1<WaterBody> get_WaterBodies()
public HashSet`1<WaterDepthMask> get_DepthMasks()
public float get_WaveTime()
private void set_WaveTime(float value)
public float get_OceanLevel()
public void set_OceanLevel(float value)
public bool get_IsInitialized()
private void set_IsInitialized(bool value)
public int get_Layer()
public int get_Reflections()
public float get_WindowDirection()
public Single[] get_OctaveScales()
private void CheckInstance()
private void Awake()
private void OnEnable()
private void OnDisable()
private void Update()
public bool Trace(Ray ray, Vector3& position, float maxDist)
public bool Trace(Ray ray, Vector3& position, Vector3& normal, float maxDist)
public void GetHeightArray_Managed(Vector2[] pos, Vector2[] posUV, Vector3[] shore, Single[] terrainHeight, Single[] waterHeight)
public void GetHeightArray(Vector2[] pos, Vector2[] posUV, Vector3[] shore, Single[] terrainHeight, Single[] waterHeight)
public float GetHeight(Vector3 pos)
public Vector3 GetNormal(Vector3 pos)
public float MinLevel()
public float MaxLevel()
public void RegisterBody(WaterBody body)
public void UnregisterBody(WaterBody body)
private void UpdateOceanLevel()
private void UpdateOceanSimulation()
public void Refresh()
private void EditorInitialize()
private void EditorShutdown()
}
public WaterVisibilityTrigger : EnvironmentVolumeTrigger {
public bool togglePhysics
public bool toggleVisuals
private long enteredTick
private long ticks
private SortedList`2<long, WaterVisibilityTrigger> tracker
public void Reset()
protected void OnDestroy()
private void ToggleVisibility()
private void ResetVisibility()
private void ToggleCollision(Collider other)
private void ResetCollision(Collider other)
protected void OnTriggerEnter(Collider other)
protected void OnTriggerExit(Collider other)
}
public WaterVolume : TriggerBase {
public Bounds WaterBounds
private OBB cachedBounds
private Transform cachedTransform
public Transform[] cutOffPlanes
public bool waterEnabled
private void OnEnable()
public bool Test(Vector3 pos, WaterInfo& info)
public bool Test(Bounds bounds, WaterInfo& info)
public bool Test(Vector3 start, Vector3 end, float radius, WaterInfo& info)
private bool CheckCutOffPlanes(Vector3 pos)
private void UpdateCachedTransform()
internal GameObject InterestedInObject(GameObject obj)
}
public WaterWell : LiquidContainer {
public Animator animator
private Flags Pumping
private Flags WaterFlow
public float caloriesPerPump
public float pressurePerPump
public float pressureForProduction
public float currentPressure
public int waterPerPump
public GameObject waterLevelObj
public float waterLevelObjFullOffset
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void RPC_Pump(RPCMessage msg)
public void StopPump()
public void OnItemAddedOrRemoved(Item item, bool added)
public void Produce()
public void ScheduleTapOff()
private void TapOff()
public void ReducePressure()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float GetWaterAmount()
}
public WaypointRace : BaseEntity {
public float WaypointRadius
public RaceWaypointVisual TargetWaypointVisual
public RaceWaypointVisual NextWaypointVisual
private List`1<Vector3> racePoints
private EntityRef`1<BaseVehicle> racingVehicle
private int currentWaypoint
public Phrase stageNotifyPhrase
public Phrase raceCompletePhrase
private PendingRaceResults raceResults
private TimeSince startTime
public float raceTimeout
public void startRace(Arg arg)
private void Setup(List`1<Transform> waypoints, BaseVehicle participant, PendingRaceResults results)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
private void Update()
}
public WaypointRaceTarget : MonoBehaviour {
private Dictionary`2<string, Transform> allPoints
private void Start()
public void GetWaypoints(string filter, List`1<Transform> found, int max)
}
public WeakpointProperties : PrefabAttribute {
public bool BlockWhenRoofAttached
protected Type GetIndexedType()
}
public WeaponRack : StorageContainer {
public Phrase textLoadAmmos
public RackType Type
public float GridCellSize
public bool SetGridCellSizeFromCollision
public int Capacity
public bool UseColliders
public int GridCellCountX
public int GridCellCountY
public BoxCollider Collision
public Transform Anchor
public Transform SmallPegPrefab
public Transform LargePegPrefab
public GameObjectRef LightPrefab
public Transform[] LightPoints
private WeaponRackSlot[] gridSlots
private WeaponRackSlot[] gridCellSlotReferences
public int ForceItemRotation
public bool CreatePegs
public SpecialRackType CustomRackType
public Transform CustomCenter
private HashSet`1<int> usedSlots
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void InitShared()
private void ClearGridCellContentsRefs()
private void SetupSlot(WeaponRackSlot slot)
private void ClearSlot(WeaponRackSlot slot)
private void SetGridCellContents(WeaponRackSlot slot, bool clear)
public void Load(LoadInfo info)
public WeaponRackSlot GetWeaponAtIndex(int gridIndex)
public Vector2Int GetXYForIndex(int index)
private Vector2Int GetWeaponSize(WorldModelRackMountConfig config, int rotation)
private Vector2Int GetWeaponStart(Vector2Int targetXY, Vector2Int size, bool clamp)
public bool CanAcceptWeaponType(WorldModelRackMountConfig weaponConfig)
public int GetBestPlacementCellIndex(Vector2Int targetXY, WorldModelRackMountConfig config, int rotation, WeaponRackSlot ignoreSlot)
public int GetGridIndexAtPosition(Vector3 pos)
private bool GridCellsFree(WorldModelRackMountConfig config, int gridIndex, int rotation, WeaponRackSlot ignoreGridSlot)
private int GetGridCellIndex(int x, int y)
private bool GridCellFree(int index, WeaponRackSlot ignoreSlot)
private bool ItemIsRackMountable(Item item)
public void ServerInit()
private void SpawnLightSubEntities()
private bool InventoryItemFilter(Item item, int targetSlot)
public void Save(SaveInfo info)
private void ReqSwapWeapon(RPCMessage msg)
private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
private void ReqTakeWeapon(RPCMessage msg)
private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex, bool tryHold, bool sendUpdate)
private void ReqTakeAll(RPCMessage msg)
private void GivePlayerAllWeapons(BasePlayer player, int mountSlotIndex)
private void ReqUnloadWeapon(RPCMessage msg)
private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
private void ReqMountWeapon(RPCMessage msg)
private void MountWeapon(BasePlayer player, int gridCellIndex, int rotation)
private void SetSlotItem(WeaponRackSlot slot, Item item, int gridCellIndex, int rotation)
private void SetSlotAmmoDetails(WeaponRackSlot slot, Item item)
private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate)
private void PlayMountSound(int itemID)
private void LoadWeaponAmmo(RPCMessage msg)
}
public WeaponRackBatchAutoSet : MonoBehaviour {
public Transform Anchor
public Object MountConfigScript
}
public WeaponRackSlot : object {
private bool <Used>k__BackingField
private ItemDefinition <ItemDef>k__BackingField
private int <ClientItemID>k__BackingField
private ulong <ClientItemSkinID>k__BackingField
private ItemDefinition <AmmoItemDef>k__BackingField
private int <AmmoItemID>k__BackingField
private int <AmmoCount>k__BackingField
private int <AmmoMax>k__BackingField
private float <Condition>k__BackingField
private int <InventoryIndex>k__BackingField
private int <GridSlotIndex>k__BackingField
private int <Rotation>k__BackingField
private float <ReloadTime>k__BackingField
public AmmoTypes AmmoTypes
public bool Used
public ItemDefinition ItemDef
public int ClientItemID
public ulong ClientItemSkinID
public ItemDefinition AmmoItemDef
public int AmmoItemID
public int AmmoCount
public int AmmoMax
public float Condition
public int InventoryIndex
public int GridSlotIndex
public int Rotation
public float ReloadTime
public bool get_Used()
private void set_Used(bool value)
public ItemDefinition get_ItemDef()
private void set_ItemDef(ItemDefinition value)
public int get_ClientItemID()
private void set_ClientItemID(int value)
public ulong get_ClientItemSkinID()
private void set_ClientItemSkinID(ulong value)
public ItemDefinition get_AmmoItemDef()
private void set_AmmoItemDef(ItemDefinition value)
public int get_AmmoItemID()
private void set_AmmoItemID(int value)
public int get_AmmoCount()
private void set_AmmoCount(int value)
public int get_AmmoMax()
private void set_AmmoMax(int value)
public float get_Condition()
private void set_Condition(float value)
public int get_InventoryIndex()
private void set_InventoryIndex(int value)
public int get_GridSlotIndex()
private void set_GridSlotIndex(int value)
public int get_Rotation()
private void set_Rotation(int value)
public float get_ReloadTime()
private void set_ReloadTime(float value)
public void SetUsed(bool flag)
public WeaponRackItem SaveToProto(Item item, WeaponRackItem proto)
public void InitFromProto(WeaponRackItem item)
public void SetItem(Item item, ItemDefinition updatedItemDef, int gridCellIndex, int rotation)
public void SetAmmoDetails(Item item)
private void ClearAmmoDetails()
public bool CanBeReloadedAtWeaponRack()
}
public Wearable : MonoBehaviour {
public RemoveSkin removeSkin
public RemoveSkin removeSkinFirstPerson
public RemoveHair removeHair
public DeformHair deformHair
public OccupationSlots occupationUnder
public OccupationSlots occupationOver
public bool IsBackpack
public bool HideInPlayerPreview
public bool showCensorshipCube
public bool showCensorshipCubeBreasts
public bool forceHideCensorshipBreasts
public string followBone
public bool disableRigStripping
public bool overrideDownLimit
public float downLimit
public float handcuffsSize
public PlayerModelHair playerModelHair
public PlayerModelHairCap playerModelHairCap
public WearableReplacementByRace wearableReplacementByRace
public WearableShadowLod wearableShadowLod
public List`1<Renderer> renderers
public List`1<PlayerModelSkin> playerModelSkins
public List`1<BoneRetarget> boneRetargets
public List`1<SkinnedMeshRenderer> skinnedRenderers
public List`1<SkeletonSkin> skeletonSkins
public List`1<ComponentInfo> componentInfos
public List`1<WearableNotify> notifies
public bool HideInEyesView
public bool HideInFirstPerson
public float ExtraLeanBack
public bool PreserveBones
public bool LegFade
public Renderer[] RenderersLod0
public Renderer[] RenderersLod1
public Renderer[] RenderersLod2
public Renderer[] RenderersLod3
public Renderer[] RenderersLod4
public Renderer[] SkipInFirstPersonLegs
private LOD[] emptyLOD
public PartRandomizer[] randomParts
public void OnItemSetup(Item item)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void CacheComponents()
public void StripRig(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer)
public void SetupRendererCache(IPrefabProcessor preProcess)
}
public WearableEyeViewAdjustment_Submesh : WearableEyeViewAdjustment {
public int TargetSubmesh
public Material HideMaterial
public Material DefaultMaterial
}
public WearableHairCap : MonoBehaviour {
public HairType Type
public Color BaseColor
public Texture Mask
private MaterialPropertyBlock block
private int _HairBaseColorUV1
private int _HairBaseColorUV2
private int _HairPackedMapUV1
private int _HairPackedMapUV2
public void ApplyHairCap(MaterialPropertyBlock block)
}
public WearableHolsterOffset : MonoBehaviour {
public offsetInfo[] Offsets
}
public WearableNotifyHasBackpack : WearableNotify {
public GameObject[] ObjectsToHide
}
public WearableNotifyLifestate : WearableNotify {
public LifeState TargetState
public UnityEvent OnTargetState
public UnityEvent OnTargetStateFailed
}
public WearableNotifyTrophyMounted : WearableNotify {
public UnityEvent OnMounted
public Renderer[] EmissionToggles
}
public WearableReplacementByRace : MonoBehaviour {
public GameObjectRef[] replacements
public GameObjectRef GetReplacement(int meshIndex)
}
public WearableShadowLod : MonoBehaviour {
public Renderer[] DisableShadows
}
public WeatherEffect : BaseMonoBehaviour {
public ParticleSystem[] emitOnStart
public ParticleSystem[] emitOnStop
public ParticleSystem[] emitOnLoop
}
public WeatherEffectSting : BaseMonoBehaviour {
public float frequency
public float variance
public GameObjectRef[] effects
}
public WeatherPreset : ScriptableObject {
public WeatherPresetType Type
public float Wind
public float Rain
public float Thunder
public float Rainbow
public TOD_AtmosphereParameters Atmosphere
public TOD_CloudParameters Clouds
public float OceanScale
public void Apply(TOD_Sky sky)
public void Copy(TOD_Sky sky)
public void Reset()
public void Set(WeatherPreset other)
public string ToString()
public void Fade(WeatherPreset a, WeatherPreset b, float t)
public void Override(WeatherPreset other)
public void Max(WeatherPreset other)
public void Min(WeatherPreset other)
private void Fade(Single& x, float a, float b, float t)
private void Override(Single& x, float other)
private void Max(Single& x, float other)
private void Min(Single& x, float other)
}
public WeatherPresetType : Enum {
public int value__
public WeatherPresetType Clear
public WeatherPresetType Overcast
public WeatherPresetType Storm
public WeatherPresetType Dust
public WeatherPresetType Fog
public WeatherPresetType Rain
public WeatherPresetType Cinematic
}
public WeightedAnimationRandomiser : StateMachineBehaviour {
public int LoopRangeMin
public int LoopRangeMax
public float NormalizedTransitionDuration
public IdleChance[] IdleTransitions
public bool AllowRepeats
}
public WeightedAudioClip : object {
public AudioClip audioClip
public int weight
}
public WheelSwitch : IOEntity {
public Transform wheelObj
public float rotateSpeed
public Flags BeingRotated
public Flags RotatingLeft
public Flags RotatingRight
public float rotateProgress
public Animator animator
public float kineticEnergyPerSec
private BasePlayer rotatorPlayer
private float progressTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public void BeginRotate(RPCMessage msg)
public void CancelPlayerRotation()
public void RotateProgress()
public void SetRotateProgress(float newValue)
public void StoppedRotatingCheck()
public void CancelRotate(RPCMessage msg)
public void Powered()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public bool IsBeingRotated()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
}
public WhitelistLootContainer : LootContainer {
public Phrase CantLootToast
public List`1<ulong> whitelist
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void MissionSetupPlayer(BasePlayer player)
public void AddToWhitelist(ulong userid)
public void RemoveFromWhitelist(ulong userid)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
}
public Wiggle : PostProcessEffectSettings {
public FloatParameter speed
public FloatParameter scale
}
public WiggleRenderer : PostProcessEffectRenderer`1<Wiggle> {
private int timerProperty
private int scaleProperty
private Shader wiggleShader
private float timer
public void Init()
public void Render(PostProcessRenderContext context)
}
public WildlifeTrap : StorageContainer {
public float tickRate
public GameObjectRef trappedEffect
public float trappedEffectRepeatRate
public float trapSuccessRate
public List`1<ItemDefinition> ignoreBait
public List`1<WildlifeWeight> targetWildlife
public void ResetState()
public void SetTrapActive(bool trapOn)
private int CalculateBaitCalories(Item bait)
public int GetBaitCalories()
public void DestroyRandomFoodItem()
public void UseBaitCalories(int numToUse)
public int GetItemCalories(Item item)
public void TrapThink()
public void TrapWildlife(TrappableWildlife trapped)
protected void OnTrappedWildlife(bool setFlag)
public void ClearTrap()
public bool HasBait()
public void PlayerStoppedLooting(BasePlayer player)
public bool OnStartBeingLooted(BasePlayer baseEntity)
public TrappableWildlife GetRandomWildlife()
public void ServerInit()
protected bool CanAcceptItem(Item item, int slot)
public bool HasCatch()
public bool IsTrapActive()
}
public Windows.ConsoleInput : object {
private Action`1<string> OnInputText
public string inputString
public String[] statusText
internal float nextUpdate
public bool valid
public int lineWidth
public void add_OnInputText(Action`1<string> value)
public void remove_OnInputText(Action`1<string> value)
public bool get_valid()
public int get_lineWidth()
public void ClearLine(int numLines)
public void RedrawInputLine()
internal void OnBackspace()
internal void OnEscape()
internal void OnEnter()
public void Update()
}
public Windows.ConsoleWindow : object {
private TextWriter oldOutput
private int STD_INPUT_HANDLE
private int STD_OUTPUT_HANDLE
public void Initialize()
public void Shutdown()
public void SetTitle(string strName)
private bool AttachConsole(UInt32 dwProcessId)
private bool AllocConsole()
private bool FreeConsole()
private IntPtr GetStdHandle(int nStdHandle)
private bool SetConsoleTitleA(string lpConsoleTitle)
}
public WindowsAffinityShim : object {
public bool SetProcessAffinityMask(IntPtr process, IntPtr mask)
public bool SetPriorityClass(IntPtr process, UInt32 mask)
}
public WindZoneExManager : MonoBehaviour {
public float maxAccumMain
public float maxAccumTurbulence
public float globalMainScale
public float globalTurbulenceScale
public Transform testPosition
}
public WipeTimer : BaseEntity {
public int wipeDayOfWeek
public float wipeHourOfDay
public string wipeTimezone
public long wipeUnixTimestampOverride
public string wipeCronOverride
public bool useWipeDayOverride
public DayOfWeek wipeDayOfWeekOverride
public WipeFrequency wipeFrequency
public int daysToAddTest
public float hoursToAddTest
public WipeTimer serverinstance
public WipeTimer clientinstance
private string oldTags
private string cronExprCacheKey
private CronExpression cronExprCache
private Nullable`1<ValueTuple`3<WipeFrequency, int, float>> cronCacheKey
private string cronCache
private string timezoneCacheKey
private TimeZoneInfo timezoneCache
public void InitShared()
public void DestroyShared()
public void ServerInit()
public void RecalculateWipeFrequency()
public void TryAndUpdate()
public void Save(SaveInfo info)
public TimeSpan GetTimeSpanUntilWipe()
public long GetTicksUntilWipe()
public void PrintWipe(Arg arg)
public void PrintTimeZones(Arg arg)
public DateTimeOffset GetWipeTime(DateTimeOffset nowTime)
private bool HoursUntilWipe(float hours)
private CronExpression GetCronExpression(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
private string GetCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
private string BuildCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
private TimeZoneInfo GetTimeZone()
}
public WipeTimerScreen : MonoBehaviour {
public Text timerText
}
public WireColorSettings : BaseScriptableObject {
private List`1<WireColorSettings> settings
public IOType ioType
public WireColor[] WireColors
public WireColorSettings Get(IOType type)
public GameObjectRef GetPrefabRef(WireColour wireColor)
}
public WireTool : HeldEntity {
private int maxLineNodes
private float industrialWallOffset
public IOType wireType
public WireColour DefaultColor
public float radialMenuHoldTime
public float disconnectDelay
public float clearDelay
private bool justCleared
public GameObjectRef plugEffect
public SoundDefinition clearStartSoundDef
public SoundDefinition clearSoundDef
public PendingPlug pendingPlug
private float IndustrialThickness
private bool CanChangeColours
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool get_CanChangeColours()
public float GetMaxWireLength(BasePlayer forPlayer)
public void RPC_MakeConnection(RPCMessage rpc)
public void RPC_RequestClear(RPCMessage msg)
public void RPC_RequestChangeColor(RPCMessage msg)
public bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)
public WireColour IntToColour(int i)
public bool ValidateLine(List`1<Vector3> lineList, IOEntity inputEntity, IOEntity outputEntity, BasePlayer byPlayer, int outputIndex)
public bool VerifyLineOfSight(List`1<Vector3> positions, Matrix4x4 localToWorldSpace)
public bool VerifyLineOfSight(Vector3 worldSpaceA, Vector3 worldSpaceB)
public bool HasPendingPlug()
public bool PendingPlugIsInput()
public bool PendingPlugIsType(IOType type)
public bool PendingPlugIsOutput()
public bool PendingPlugIsRoot()
private void ResetPendingPlug()
public bool CanPlayerUseWires(BasePlayer player)
private bool CanModifyEntity(BasePlayer player, IOEntity ent)
}
public Wolf : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public WordFilter : object {
public string Filter(string str)
}
public Workbench : StorageContainer {
public int blueprintSlot
public int experimentSlot
public bool Static
public int Workbenchlevel
public LootSpawn experimentalItems
public GameObjectRef experimentStartEffect
public GameObjectRef experimentSuccessEffect
public ItemDefinition experimentResource
public TechTreeData[] techTrees
public ItemDefinition blueprintBaseDef
private ItemDefinition pendingBlueprint
private bool creatingBlueprint
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public TechTreeData GetTechTreeForLevel(int level)
public int GetScrapForExperiment()
public bool IsWorking()
public bool CanPickup(BasePlayer player)
public void RPC_TechTreeUnlock(RPCMessage msg)
public ItemDefinition GetBlueprintTemplate()
public void RPC_BeginExperiment(RPCMessage msg)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public int GetAvailableExperimentResources()
public Item GetExperimentResourceItem()
public void ExperimentComplete()
public void PostServerLoad()
public void ServerInit()
public bool ItemFilter(Item item, int targetSlot)
public int ScrapForResearch(ItemDefinition info, int workbenchLevel, Int32& tax)
public bool SupportsChildDeployables()
}
public WorkbenchPanel : LootPanel {
public GameObject tier1Button
public GameObject tier2Button
public GameObject tier3Button
public Text timerText
public Text costText
public GameObject expermentCostParent
public GameObject controlsParent
public GameObject allUnlockedNotification
public GameObject informationParent
public GameObject cycleIcon
public TechTreeDialog techTreeDialog
}
public WorkshopIconRender : MonoBehaviour {
public int MinimumId
public int MaximumId
}
public WorkshopMainMenu : SingletonComponent`1<WorkshopMainMenu> {
public Phrase loading_workshop
public Phrase loading_workshop_setup
public Phrase loading_workshop_skinnables
public Phrase loading_workshop_item
}
public World : object {
private UInt32 <Seed>k__BackingField
private UInt32 <Salt>k__BackingField
private UInt32 _size
private string <Checksum>k__BackingField
private string <Url>k__BackingField
private bool <Procedural>k__BackingField
private bool <Cached>k__BackingField
private bool <Networked>k__BackingField
private bool <Receiving>k__BackingField
private bool <Transfer>k__BackingField
private bool <LoadedFromSave>k__BackingField
private int <SpawnIndex>k__BackingField
private WorldSerialization <Serialization>k__BackingField
private WorldConfig <Config>k__BackingField
private Stopwatch spawnTimer
private List`1<SpawnTiming> spawnTimings
public UInt32 Seed
public UInt32 Salt
public UInt32 Size
public string Checksum
public string Url
public bool Procedural
public bool Cached
public bool Networked
public bool Receiving
public bool Transfer
public bool Nexus
public bool LoadedFromSave
public int SpawnIndex
public WorldSerialization Serialization
public WorldConfig Config
public string Name
public string MapFileName
public string MapFolderName
public string SaveFileName
public string SaveFolderName
public UInt32 get_Seed()
public void set_Seed(UInt32 value)
public UInt32 get_Salt()
public void set_Salt(UInt32 value)
public UInt32 get_Size()
public void set_Size(UInt32 value)
public string get_Checksum()
public void set_Checksum(string value)
public string get_Url()
public void set_Url(string value)
public bool get_Procedural()
public void set_Procedural(bool value)
public bool get_Cached()
public void set_Cached(bool value)
public bool get_Networked()
public void set_Networked(bool value)
public bool get_Receiving()
public void set_Receiving(bool value)
public bool get_Transfer()
public void set_Transfer(bool value)
public bool get_Nexus()
public bool get_LoadedFromSave()
public void set_LoadedFromSave(bool value)
public int get_SpawnIndex()
public void set_SpawnIndex(int value)
public WorldSerialization get_Serialization()
public void set_Serialization(WorldSerialization value)
public WorldConfig get_Config()
public void set_Config(WorldConfig value)
public string get_Name()
public string GetServerBrowserMapName()
public bool CanLoadFromUrl()
public bool CanLoadFromDisk()
public void CleanupOldFiles()
public string get_MapFileName()
public string get_MapFolderName()
public string get_SaveFileName()
public string get_SaveFolderName()
public void InitSeed(int seed)
public void InitSeed(UInt32 seed)
private string SeedIdentifier()
public void InitSalt(int salt)
public void InitSalt(UInt32 salt)
private string SaltIdentifier()
public void InitSize(int size)
public void InitSize(UInt32 size)
public Byte[] GetMap(string name)
public int GetCachedHeightMapResolution()
public int GetCachedSplatMapResolution()
public void AddMap(string name, Byte[] data)
public void AddPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
public PathData PathListToPathData(PathList src)
public PathList PathDataToPathList(PathData src)
public Vector3[] VectorListToArray(List`1<VectorData> src)
public List`1<VectorData> VectorArrayToList(Vector3[] src)
public IEnumerable`1<PathList> GetPaths(string name)
public void AddPaths(IEnumerable`1<PathList> paths)
public void AddPath(PathList path)
public IEnumerator SpawnAsync(float deltaTime, Action`1<string> statusFunction)
public IEnumerator Spawn(float deltaTime, Action`1<string> statusFunction)
public void Spawn()
public void Spawn(string category, string folder)
public void Spawn(string category, String[] folders)
private void Spawn(PrefabData prefab)
private void Spawn(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
private void Status(Action`1<string> statusFunction, string status, object obj1)
private void Status(Action`1<string> statusFunction, string status, object obj1, object obj2)
private void Status(Action`1<string> statusFunction, string status, object obj1, object obj2, object obj3)
private void Status(Action`1<string> statusFunction, string status, Object[] objs)
public IEnumerable`1<SpawnTiming> GetSpawnTimings()
public void ResetTiming()
}
public WorldConfig : object {
public string JsonString
public float PercentageTier0
public float PercentageTier1
public float PercentageTier2
public float PercentageBiomeArid
public float PercentageBiomeTemperate
public float PercentageBiomeTundra
public float PercentageBiomeArctic
public bool MainRoads
public bool SideRoads
public bool Trails
public bool Rivers
public bool Powerlines
public bool AboveGroundRails
public bool BelowGroundRails
public bool UnderwaterLabs
public List`1<string> PrefabBlacklist
public List`1<string> PrefabWhitelist
public bool IsPrefabAllowed(string name)
public void LoadFromJsonFile(string fileName)
public void LoadFromJsonString(string data)
public void LoadFromWorldConfig(WorldConfig data)
}
public WorldGrid : SingletonComponent`1<WorldGrid> {
public bool Paused
public float CellSize
public float MaxMilliseconds
public float MaxRefreshDistance
public float MinTimeBetweenRefreshes
}
public WorldItem : BaseEntity {
public Phrase OpenLootTitle
public Phrase PickUpTitle
public Phrase HoldToPickupPhrase
public bool allowPickup
public Item item
private bool _isInvokingSendItemUpdate
protected float eatSeconds
protected float caloriesPerSecond
public TraitFlag Traits
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Item GetItem()
public void InitializeItem(Item in_item)
public void RemoveItem()
public void DestroyItem()
protected void OnItemDirty(Item in_item)
public void Load(LoadInfo info)
public TraitFlag get_Traits()
public string ToString()
public bool CanMoveFrom(BasePlayer player, Item item)
public void ServerInit()
private void DoItemNetworking()
private void SendItemUpdate()
public void Pickup(RPCMessage msg)
public void Save(SaveInfo info)
internal void DoServerDestroy()
public void SwitchParent(BaseEntity ent)
public void Eat(BaseNpc baseNpc, float timeSpent)
private bool CanOpenInSafeZone(BasePlayer looter)
private void RPC_OpenLoot(RPCMessage rpc)
}
public WorldModel : MonoBehaviour {
public float mass
}
public WorldModelOutline : OutlineObject {
public bool AlwaysRender
}
public WorldModelRackMountConfig : MonoBehaviour {
public List`1<RackType> ExcludedRackTypes
public Vector3 CenterOffsfet
public Vector3 LeftOffset
public Vector3 VerticalMountLocalRotation
public Vector3 VerticalMountLocalOffset
public int XSize
public int YSize
public int ZSize
public List`1<PegConfig> Pegs
public List`1<PegConfig> VerticalPegs
public bool OverrideScale
public Vector3 Scale
public bool UseManualRenderBounds
public Bounds ManualRenderBounds
public bool CanReloadOnWeaponRack
public List`1<CustomPosition> CustomPositions
public WorldModelRackMountConfig GetForItemDef(ItemDefinition itemDef)
public void ApplyTransformDefaults(Transform displayItem)
public CustomPosition FindCustomRackPosition(SpecialRackType rackType)
}
public WorldModelRandomiser : MonoBehaviour {
public PartRandomizer[] randomParts
}
public WorldNetworking : object {
private int prefabsPerPacket
private int pathsPerPacket
public void OnMessageReceived(Message message)
private void SendWorldData(Connection connection)
private void SendWorldData(Connection connection, WorldMessage& data)
}
public WorldPositionGenerator : ScriptableObject {
public SpawnFilter Filter
public float FilterCutoff
public bool aboveWater
public float MaxSlopeRadius
public float MaxSlopeDegrees
public float CheckSphereRadius
public LayerMask CheckSphereMask
private Vector3 _origin
private Vector3 _area
private ByteQuadtree _quadtree
public bool TrySample(Vector3 origin, float minDist, float maxDist, Vector3& position, List`1<Vector3> blocked)
public void PrecalculatePositions()
private void <TrySample>g__EvaluateCandidate|10_0(Element child, <>c__DisplayClass10_0& )
private Rect <TrySample>g__GetElementRect|10_1(Element element, <>c__DisplayClass10_0& )
}
public WorldSetup : SingletonComponent`1<WorldSetup> {
public bool AutomaticallySetup
public bool BypassProceduralSpawn
public bool ForceGenerateOceanPatrols
public GameObject terrain
public GameObject decorPrefab
public GameObject grassPrefab
public GameObject spawnPrefab
private TerrainMeta terrainMeta
public UInt32 EditorSeed
public UInt32 EditorSalt
public UInt32 EditorSize
public string EditorUrl
public string EditorConfigFile
public string EditorConfigString
public List`1<ProceduralObject> ProceduralObjects
internal List`1<MonumentNode> MonumentNodes
public void OnValidate()
protected void Awake()
public void CreateObject(GameObject prefab)
public IEnumerator InitCoroutine()
private void CancelSetup(string msg)
}
public WorldSpline : MonoBehaviour {
public int dataIndex
public Vector3[] points
public Vector3[] tangents
public float lutInterval
private bool showGizmos
private List`1<Vector3> visualSplineList
private WorldSplineData privateData
public WorldSplineData GetData()
public void SetAll(Vector3[] points, Vector3[] tangents, float lutInterval)
public void CheckValidity()
protected void OnDrawGizmosSelected()
protected void DrawSplineGizmo(WorldSpline ws, Color splineColour)
private Vector3[] GetVisualSpline(WorldSpline ws, WorldSplineData data, float distBetweenPoints)
public Vector3 GetStartPointWorld()
public Vector3 GetEndPointWorld()
public Vector3 GetStartTangentWorld()
public Vector3 GetEndTangentWorld()
public Vector3 GetTangentCubicHermiteWorld(float distance)
public Vector3 GetTangentCubicHermiteWorld(float distance, WorldSplineData data)
public Vector3 GetPointCubicHermiteWorld(float distance)
public Vector3 GetPointCubicHermiteWorld(float distance, WorldSplineData data)
public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, Vector3& tangent)
public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, WorldSplineData data, Vector3& tangent)
public Vector3[] GetPointsWorld()
public Vector3[] GetTangentsWorld()
private Vector3[] PointsToWorld(Vector3[] points, Transform tr)
private Vector3[] TangentsToWorld(Vector3[] tangents, Transform tr)
}
public WorldSplineData : object {
public Vector3[] inputPoints
public Vector3[] inputTangents
public float inputLUTInterval
public List`1<LUTEntry> LUTValues
public float Length
private int maxPointsIndex
public void .ctor(WorldSpline worldSpline)
public bool IsSameAs(WorldSpline worldSpline)
public bool IsDifferentTo(WorldSpline worldSpline)
public Vector3 GetStartPoint()
public Vector3 GetEndPoint()
public Vector3 GetStartTangent()
public Vector3 GetEndTangent()
public Vector3 GetPointCubicHermite(float distance)
public Vector3 GetTangentCubicHermite(float distance)
public Vector3 GetPointAndTangentCubicHermite(float distance, Vector3& tangent)
public void SetDefaultTangents(WorldSpline worldSpline)
public bool DetectSplineProblems(WorldSpline worldSpline)
private void CreateLookupTable(WorldSpline worldSpline)
private void AddEntry(float distance, Vector3 pos)
}
public WorldSplineSharedData : ScriptableObject {
private List`1<WorldSplineData> dataList
public WorldSplineSharedData _instance
private String[] worldSplineFolders
public WorldSplineSharedData instance
public WorldSplineSharedData get_instance()
public bool TryGetDataFor(WorldSpline worldSpline, WorldSplineData& data)
}
public XmasDungeon : HalloweenDungeon {
public Flags HasPlayerOutside
public Flags HasPlayerInside
public float xmaspopulation
public float xmaslifetime
public float playerdetectrange
public float GetLifetime()
public void ServerInit()
public void PlayerChecks()
}
public XMasRefill : BaseEntity {
public GameObjectRef[] giftPrefabs
public List`1<BasePlayer> goodKids
public List`1<Stocking> stockings
public AudioSource bells
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float GiftRadius()
public int GiftsPerPlayer()
public int GiftSpawnAttempts()
public void ServerInit()
public void SendBells()
public void RemoveMe()
public void DistributeLoot()
protected bool DropToGround(Vector3& pos)
public bool DistributeGiftsForPlayer(BasePlayer player)
}
public XORSwitch : IOEntity {
private int input1Amount
private int input2Amount
private bool firstRun
public int ConsumptionAmount()
public bool WantsPower(int inputIndex)
public void ResetState()
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int slot)
private void UpdateFlags()
}
public ZiplineArrivalPoint : BaseEntity {
public LineRenderer Line
private Vector3[] linePositions
public void Save(SaveInfo info)
public void SetPositions(List`1<Vector3> points)
public void Load(LoadInfo info)
public void ResetState()
}
public ZiplineAudio : MonoBehaviour {
public ZiplineMountable zipline
public SoundDefinition movementLoopDef
public SoundDefinition frictionLoopDef
public SoundDefinition sparksLoopDef
public AnimationCurve movementGainCurve
public AnimationCurve movementPitchCurve
public AnimationCurve frictionGainCurve
public AnimationCurve sparksGainCurve
}
public ZiplineLaunchPoint : BaseEntity {
public Transform LineDeparturePoint
public LineRenderer ZiplineRenderer
public Collider MountCollider
public BoxCollider[] BuildingBlocks
public BoxCollider[] PointBuildingBlocks
public SpawnableBoundsBlocker[] SpawnableBoundsBlockers
public GameObjectRef MountableRef
public float LineSlackAmount
public bool RegenLine
public List`1<Vector3> ziplineTargets
private List`1<Vector3> linePoints
public GameObjectRef ArrivalPointRef
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public void PostMapEntitySpawn()
public void FindZiplineTarget(List`1& foundPositions)
public bool CheckLineOfSight(Vector3 from, Vector3 to)
public void MountPlayer(RPCMessage msg)
public void ClearBusy()
public void Save(SaveInfo info)
public void report(Arg arg)
public void Load(LoadInfo info)
private void CalculateZiplinePoints(List`1<Vector3> targets, List`1& points)
public Vector3 CalculateLineMidPoint(Vector3 start, Vector3 endPoint)
public void UpdateBuildingBlocks()
public bool IsPlayerFacingValidDirection(BasePlayer ply)
public float GetLineLength()
private void <UpdateBuildingBlocks>g__SetUpBuildingBlock|24_0(BoxCollider longCollider, BoxCollider pointCollider, SpawnableBoundsBlocker spawnBlocker, int startIndex, int endIndex)
}
public ZiplineMountable : BaseMountable {
public float MoveSpeed
public float ForwardAdditive
public CapsuleCollider ZipCollider
public Transform ZiplineGrabRoot
public Transform LeftHandIkPoint
public Transform RightHandIkPoint
public float SpeedUpTime
public bool EditorHoldInPlace
private List`1<Vector3> linePoints
public Flags PushForward
public AnimationCurve MountPositionCurve
public AnimationCurve MountRotationCurve
public float MountEaseInTime
public Flags ShowHandle
public float additiveValue
public float currentTravelDistance
public TimeSince mountTime
private bool hasEnded
public List`1<Collider> ignoreColliders
private Vector3 lastSafePosition
public Vector3 startPosition
public Vector3 endPosition
public Quaternion startRotation
public Quaternion endRotation
public float elapsedMoveTime
public bool isAnimatingIn
public Vector3 ProcessBezierMovement(float distanceToTravel)
public Vector3 GetLineEndPoint(bool applyDismountOffset)
public Vector3 GetNextLinePoint(Transform forTransform)
public void ResetState()
public float MaxVelocity()
public void SetDestination(List`1<Vector3> targetLinePoints, Vector3 lineStartPos, Quaternion lineStartRot)
private void Update()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void EndZipline()
public void OnPlayerDismounted(BasePlayer player)
public bool ValidDismountPosition(BasePlayer player, Vector3 disPos)
public void Save(SaveInfo info)
public void MovePlayerToPosition()
public void OnFlagsChanged(Flags old, Flags next)
}
public ZiplineTarget : MonoBehaviour {
public Transform Target
public bool IsChainPoint
public float MonumentConnectionDotMin
public float MonumentConnectionDotMax
public bool IsValidPosition(Vector3 position)
public bool IsValidChainPoint(Vector3 from, Vector3 to)
}
public Zombie : BaseAnimalNPC {
public float Population
public TraitFlag Traits
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
protected void TickSleep()
public string Categorize()
}
public ZoneController : object {
private ZoneController <Instance>k__BackingField
protected NexusZoneClient ZoneClient
public ZoneController Instance
public ZoneController get_Instance()
public void set_Instance(ZoneController value)
protected void .ctor(NexusZoneClient zoneClient)
public string ChooseSpawnZone(ulong steamId, bool isAlreadyAssignedToThisZone)
public ValueTuple`3<Vector3, Quaternion, bool> ChooseTransferDestination(string sourceZone, string method, string from, string to, Vector3 position, Quaternion rotation)
protected ValueTuple`3<Vector3, Quaternion, bool> ChooseConsoleTransferDestination(string sourceZone)
protected ValueTuple`3<Vector3, Quaternion, bool> ChooseFerryTransferDestination(string sourceZone)
protected ValueTuple`3<Vector3, Quaternion, bool> ChooseOceanTransferDestination(string sourceZone)
protected ValueTuple`3<Vector3, Quaternion, bool> ChooseTransferFallbackDestination(string sourceZone)
public bool CanRespawnAcrossZones(BasePlayer player)
}
public ZoomImage : MonoBehaviour {
private float _minimumScale
private float _initialScale
private float _maximumScale
private float _scaleIncrement
private Vector3 _scale
private RectTransform _thisTransform
private void Awake()
public void OnScroll(PointerEventData eventData)
}
