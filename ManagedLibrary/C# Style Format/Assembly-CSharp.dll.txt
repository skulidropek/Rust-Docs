public AboutYou : BaseMonoBehaviour {
public Text username
public RawImage avatar
public Text subtitle
}
public Achievements : SingletonComponent`1<Achievements> {
public SoundDefinition listComplete
public SoundDefinition itemComplete
public SoundDefinition popup
public Canvas Canvas
public Text titleText
}
public AchievementTodo : BaseMonoBehaviour {
public Text text
public RectTransform checkIcon
public RectTransform checkBox
public Color AliveColor
public Color DeadColor
public Color HighlightColor
}
public ActionPriority : Enum {
public int value__
public ActionPriority Highest
public ActionPriority High
public ActionPriority Medium
public ActionPriority Low
public ActionPriority Lowest
}
public AdaptMeshToTerrain : MonoBehaviour {
public LayerMask LayerMask
public float RayHeight
public float RayMaxDistance
public float MinDisplacement
public float MaxDisplacement
public int PlaneResolution
}
public AddSellOrderManager : MonoBehaviour {
public VirtualItemIcon sellItemIcon
public VirtualItemIcon currencyItemIcon
public GameObject itemSearchParent
public ItemSearchEntry itemSearchEntryPrefab
public InputField sellItemInput
public InputField sellItemAmount
public InputField currencyItemInput
public InputField currencyItemAmount
public VendingPanelAdmin adminPanel
}
public AddToAlphaMap : ProceduralObject {
public Bounds bounds
public void Process()
}
public AddToHeightMap : ProceduralObject {
public bool DestroyGameObject
public void Process()
}
public AddToWaterMap : ProceduralObject {
public void Process()
}
public AdminExistingSellOrder : MonoBehaviour {
public VirtualItemIcon MerchandiseIcon
public VirtualItemIcon CurrencyIcon
private VendingPanelAdmin adminPanel
private int index
}
public AdvancedChristmasLights : IOEntity {
public GameObjectRef bulbPrefab
public LineRenderer lineRenderer
public List`1<pointEntry> points
public List`1<BaseBulb> bulbs
public float bulbSpacing
public float wireThickness
public Transform wireEmission
public AnimationType animationStyle
public RendererLOD _lod
public float lengthToPowerRatio
private bool finalized
private int lengthUsed
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ClearPoints()
public void FinishEditing()
public bool IsFinalized()
public void AddPoint(Vector3 newPoint, Vector3 newNormal)
public int ConsumptionAmount()
protected int GetPickupCount()
public void AddLengthUsed(int addLength)
public void ServerInit()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool IsStyle(AnimationType testType)
public bool CanPlayerManipulate(BasePlayer player)
public void SetAnimationStyle(RPCMessage msg)
}
public AICoverPoint : BaseMonoBehaviour {
public float coverDot
private BaseEntity currentUser
private bool disabled
public bool InUse()
public void SetDisabled(bool wants)
public bool IsDisabled()
public bool IsUsedBy(BaseEntity user)
public void SetUsedBy(BaseEntity user, float duration)
public void ClearUsed()
public void ClearIfUsedBy(BaseEntity user)
public void OnDrawGizmos()
}
public AIHelicopterAnimation : MonoBehaviour {
public PatrolHelicopterAI _ai
public float swayAmount
public float lastStrafeScalar
public float lastForwardBackScalar
public float degreeMax
public Vector3 lastPosition
public float oldMoveSpeed
public float smoothRateOfChange
public float flareAmount
public void Awake()
public Vector3 GetMoveDirection()
public float GetMoveSpeed()
public void Update()
}
public AIInformationZone : BaseMonoBehaviour {
public List`1<AIInformationZone> zones
public List`1<AICoverPoint> coverPoints
public List`1<AIMovePoint> movePoints
public List`1<NavMeshLink> navMeshLinks
public Bounds bounds
private OBB areaBox
private bool isDirty
private int processIndex
private int halfPaths
private int pathSuccesses
private int pathFails
private bool lastFrameAnyDirty
private float rebuildStartTime
public float buildTimeTest
private float lastNavmeshBuildTime
public void OnValidate()
public void AddCoverPoint(AICoverPoint point)
public void RemoveCoverPoint(AICoverPoint point)
public void AddMovePoint(AIMovePoint point)
public void RemoveMovePoint(AIMovePoint point)
public void MarkDirty(bool completeRefresh)
private bool PassesBudget(float startTime, float budgetSeconds)
public bool ProcessDistancesAttempt()
public void BudgetedTick()
private float PathDistance(int count, Vector3[]& path, float maxDistance)
public void NavmeshBuildingComplete()
public void Start()
public Vector3 ClosestPointTo(Vector3 target)
public void OnDrawGizmos()
public void AddInitialPoints()
public AIInformationZone GetForPoint(Vector3 point, BaseEntity from)
public AIMovePoint GetBestMovePointNear(Vector3 targetPosition, Vector3 fromPosition, float minRange, float maxRange, bool checkLOS, BaseEntity forObject, bool returnClosest)
public Vector3 GetBestPositionNear(Vector3 targetPosition, Vector3 fromPosition, float minRange, float maxRange, bool checkLOS)
public AIMovePoint GetClosestRaw(Vector3 pos, bool onlyIncludeWithCover)
public AICoverPoint GetBestCoverPoint(Vector3 currentPosition, Vector3 hideFromPosition, float minRange, float maxRange, BaseEntity forObject)
public NavMeshLink GetClosestNavMeshLink(Vector3 pos)
}
public AiManagerLoadBalancer : LoadBalancer {
public ILoadBalancer aiManagerLoadBalancer
}
public AimConeUtil : object {
public Vector3 GetModifiedAimConeDirection(float aimCone, Vector3 inputVec, bool anywhereInside)
public Quaternion GetAimConeQuat(float aimCone)
}
public AIMovePoint : MonoBehaviour {
public ListDictionary`2<AIMovePoint, float> distances
public ListDictionary`2<AICoverPoint, float> distancesToCover
public float radius
public float nextAvailableRoamTime
public float nextAvailableEngagementTime
public BaseEntity lastUser
public void OnDrawGizmos()
public bool CanBeUsedBy(BaseEntity user)
public bool IsUsed()
public void MarkUsedForRoam(float dur, BaseEntity user)
public void MarkUsedForEngagement(float dur, BaseEntity user)
public bool IsUsedForRoaming()
public bool IsUsedForEngagement()
}
public AIThinkManager : BaseMonoBehaviour {
public ListHashSet`1<IThinker> _processQueue
public ListHashSet`1<IThinker> _removalQueue
public float framebudgetms
private int lastIndex
public void ProcessQueue()
public void Add(IThinker toAdd)
public void Remove(IThinker toRemove)
}
public AITraversalArea : TriggerBase {
public Transform entryPoint1
public Transform entryPoint2
public AITraversalWaitPoint[] waitPoints
public Bounds movementArea
public Transform activeEntryPoint
public float nextFreeTime
public void OnValidate()
public GameObject InterestedInObject(GameObject obj)
public bool CanTraverse(BaseEntity ent)
public Transform GetClosestEntry(Vector3 position)
public Transform GetFarthestEntry(Vector3 position)
public void SetBusyFor(float dur)
public bool CanUse(Vector3 dirFrom)
public void OnEntityEnter(BaseEntity ent)
public AITraversalWaitPoint GetEntryPointNear(Vector3 pos)
public bool EntityFilter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
public void OnDrawGizmos()
}
public AITraversalWaitPoint : MonoBehaviour {
public float nextFreeTime
public bool Occupied()
public void Occupy(float dur)
}
public AlternateAttack : StateMachineBehaviour {
public bool random
public bool dontIncrement
public String[] targetTransitions
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public AmbienceDefinition : ScriptableObject {
public List`1<SoundDefinition> sounds
public ValueRange stingFrequency
public Enum biomes
public Enum topologies
public EnvironmentType environmentType
public bool useEnvironmentType
public AnimationCurve time
public ValueRange rain
public ValueRange wind
public ValueRange snow
}
public AmbienceDefinitionList : ScriptableObject {
public List`1<AmbienceDefinition> defs
}
public AmbienceEmitter : MonoBehaviour {
public AmbienceDefinitionList baseAmbience
public AmbienceDefinitionList stings
public bool isStatic
public bool followCamera
public bool isBaseEmitter
public bool active
public float cameraDistanceSq
public BoundingSphere boundingSphere
public float crossfadeTime
private Enum <currentTopology>k__BackingField
private Enum <currentBiome>k__BackingField
public Dictionary`2<AmbienceDefinition, float> nextStingTime
public float deactivateTime
public Enum currentTopology
public Enum currentBiome
public Enum get_currentTopology()
private void set_currentTopology(Enum value)
public Enum get_currentBiome()
private void set_currentBiome(Enum value)
public int CompareTo(AmbienceEmitter other)
}
public AmbienceLocalStings : MonoBehaviour {
public float maxDistance
public float stingRadius
public float stingFrequency
public float stingFrequencyVariance
public SoundDefinition[] stingSounds
}
public AmbienceManager : SingletonComponent`1<AmbienceManager> {
public List`1<EmitterTypeLimit> localEmitterLimits
public EmitterTypeLimit catchallEmitterLimit
public int maxActiveLocalEmitters
public int activeLocalEmitters
public List`1<AmbienceEmitter> cameraEmitters
public List`1<AmbienceEmitter> emittersInRange
public List`1<AmbienceEmitter> activeEmitters
public float localEmitterRange
public List`1<AmbienceZone> currentAmbienceZones
}
public AmbienceSpawnEmitters : MonoBehaviour {
public int baseEmitterCount
public int baseEmitterDistance
public GameObjectRef emitterPrefab
}
public AmbienceZone : MonoBehaviour {
public AmbienceDefinitionList baseAmbience
public AmbienceDefinitionList stings
public float priority
public bool overrideCrossfadeTime
public float crossfadeTime
}
public AmbientLightLOD : FacepunchBehaviour {
public bool isDynamic
public float enabledRadius
public bool toggleFade
public float toggleFadeDuration
protected void OnValidate()
}
public AmmoInformationPanel : ItemInformationPanel {
public ItemStatValue damageDisplay
public ItemStatValue velocityDisplay
public ItemStatValue spreadDisplay
public ItemTextValue pelletsDisplay
public ItemStatValue falloffRangeDisplay
public ItemTextValue thicknessDisplay
}
public AmplifyOcclusion.VersionInfo : object {
public byte Major
public byte Minor
public byte Release
private string StageSuffix
private int m_major
private int m_minor
private int m_release
public int Number
public string StaticToString()
public string ToString()
public int get_Number()
private void .ctor(byte major, byte minor, byte release)
public VersionInfo Current()
public bool Matches(VersionInfo version)
}
public AmplifyOcclusionBase : MonoBehaviour {
public ApplicationMethod ApplyMethod
public SampleCountLevel SampleCount
public PerPixelNormalSource PerPixelNormals
public float Intensity
public Color Tint
public float Radius
public int PixelRadiusLimit
public float RadiusIntensity
public float PowerExponent
public float Bias
public float Thickness
public bool Downsample
public bool FadeEnabled
public float FadeStart
public float FadeLength
public float FadeToIntensity
public Color FadeToTint
public float FadeToRadius
public float FadeToPowerExponent
public float FadeToThickness
public bool BlurEnabled
public int BlurRadius
public int BlurPasses
public float BlurSharpness
public bool FilterEnabled
public float FilterBlending
public float FilterResponse
public bool TemporalDirections
public bool TemporalOffsets
public bool TemporalDilation
public bool UseMotionVectors
}
public ANDSwitch : IOEntity {
private int input1Amount
private int input2Amount
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int slot)
}
public AnimalAnimation : MonoBehaviour {
public BaseEntity Entity
public BaseNpc Target
public Animator Animator
public MaterialEffect FootstepEffects
public Transform[] Feet
public SoundDefinition saddleMovementSoundDef
public SoundDefinition saddleMovementSoundDefWood
public SoundDefinition saddleMovementSoundDefRoadsign
public AnimationCurve saddleMovementGainCurve
public string BaseFolder
public Flags Flag_WoodArmor
public Flags Flag_RoadsignArmor
}
public AnimalFootIK : MonoBehaviour {
public Transform[] Feet
public Animator animator
public float maxWeightDistance
public float minWeightDistance
public float actualFootOffset
public bool GroundSample(Vector3 origin, RaycastHit& hit)
public void Start()
public AvatarIKGoal GoalFromIndex(int index)
private void OnAnimatorIK(int layerIndex)
}
public AnimalMultiSkin : object {
public Material[] multiSkin
}
public AnimalRagdoll : Ragdoll {
public SkinnedMeshRenderer[] bodyRenderers
public SkinnedMeshRenderer[] hairRenderers
}
public AnimalSensesLoadBalancer : LoadBalancer {
public ILoadBalancer animalSensesLoadBalancer
}
public AnimalSkin : MonoBehaviour {
public SkinnedMeshRenderer[] animalMesh
public AnimalMultiSkin[] animalSkins
private Model model
public bool dontRandomizeOnStart
private void Start()
public void ChangeSkin(int iSkin)
}
public AnimatedBuildingBlock : StabilityEntity {
private bool animatorNeedsInitializing
private bool animatorIsOpen
private bool isAnimating
public void ServerInit()
public void PostServerLoad()
public void OnFlagsChanged(Flags old, Flags next)
protected void UpdateAnimationParameters(bool init)
protected void OnAnimatorFinished()
private void PutAnimatorToSleep()
protected void OnAnimatorDisabled()
public bool SupportsChildDeployables()
}
public AnimationEventForward : MonoBehaviour {
public GameObject targetObject
public void Event(string type)
}
public AnimationEvents : BaseMonoBehaviour {
public Transform rootObject
public HeldEntity targetEntity
public string effectFolder
public string localFolder
public bool IsBusy
protected void OnEnable()
}
public AnimationFlagHandler : MonoBehaviour {
public Animator animator
public void SetBoolTrue(string name)
public void SetBoolFalse(string name)
}
public AnimatorLOD : LODComponent {
public float Distance
}
public AntiHack : object {
private int movement_mask
private int grounded_mask
private int vehicle_mask
private int player_mask
private Collider[] buffer
private Dictionary`2<ulong, int> kicks
private Dictionary`2<ulong, int> bans
public void ResetTimer(BasePlayer ply)
public bool ShouldIgnore(BasePlayer ply)
public bool ValidateMove(BasePlayer ply, TickInterpolator ticks, float deltaTime)
public bool IsInsideTerrain(BasePlayer ply)
public bool TestInsideTerrain(Vector3 pos)
public bool IsNoClipping(BasePlayer ply, TickInterpolator ticks, float deltaTime)
public bool TestNoClipping(BasePlayer ply, Vector3 oldPos, Vector3 newPos, bool sphereCast, float deltaTime)
public bool IsSpeeding(BasePlayer ply, TickInterpolator ticks, float deltaTime)
public bool IsFlying(BasePlayer ply, TickInterpolator ticks, float deltaTime)
public bool TestFlying(BasePlayer ply, Vector3 oldPos, Vector3 newPos, bool verifyGrounded)
public void NoteAdminHack(BasePlayer ply)
public void FadeViolations(BasePlayer ply, float deltaTime)
public void EnforceViolations(BasePlayer ply)
public void Log(BasePlayer ply, AntiHackType type, string message)
private void LogToConsole(BasePlayer ply, AntiHackType type, string message)
private void LogToEAC(BasePlayer ply, AntiHackType type, string message)
public void AddViolation(BasePlayer ply, AntiHackType type, float amount)
public void Kick(BasePlayer ply, string reason)
public void Ban(BasePlayer ply, string reason)
private void AddRecord(BasePlayer ply, Dictionary`2<ulong, int> records)
public int GetKickRecord(BasePlayer ply)
public int GetBanRecord(BasePlayer ply)
private int GetRecord(BasePlayer ply, Dictionary`2<ulong, int> records)
}
public AntiHackType : Enum {
public int value__
public AntiHackType None
public AntiHackType NoClip
public AntiHackType SpeedHack
public AntiHackType FlyHack
public AntiHackType ProjectileHack
public AntiHackType MeleeHack
public AntiHackType EyeHack
public AntiHackType AttackHack
public AntiHackType ReloadHack
public AntiHackType CooldownHack
public AntiHackType InsideTerrain
}
public Apex.AI.AINameMap : object {
public Guid AnimalAction
public Guid AnimalMovement
public Guid AnimalThink
public Guid HTNAllShoot
public Guid HTNDomainAnimalBear
public Guid HTNDomainMurderer
public Guid HTNDomainNPCTurret
public Guid HTNDomainScientistAStar
public Guid HTNDomainScientistAStarTestCargoShip
public Guid HTNDomainScientistJunkpile
public Guid HTNDomainScientistMilitaryTunnel
public Guid HTNOneAttackFromCover
public Guid HTNOneIdle
public Guid HTNOneKillPrimaryThreat
public Guid HTNOneReloadOrSwitchWeapon
public Guid HTNRootScientist
public Guid MurdererAction
public Guid MurdererMove
public Guid MurdererThink
public Guid NpcAnimalGeneric
public Guid NpcHumanBanditGuard
public Guid NpcHumanScientist
public Guid NpcHumanScientistCH47
public Guid NpcHumanScientistJunkpile
public Guid NpcHumanScientistMelee
public Guid NpcHumanScientistTactical
public Guid NpcHumanScientistTacticalMountable
public Guid NpcHumanScientistTargetSelectorCover
public Guid NpcHumanScientistTargetSelectorEnemyHideout
public Guid NpcHumanScientistTargetSelectorOtherEntities
public Guid NpcHumanScientistTargetSelectorPlayer
public Guid NpcHumanScientistTargetSelectorPlayerMounted
public Guid NPCPlayerAction
public Guid NPCPlayerIdle
public Guid NPCPlayerMove
public Guid NPCPlayerThink
public Guid ZombieAction
}
public Apex.AI.CompositeSumMustBeAboveThresholdQualifier : CompositeQualifier {
public float threshold
public float Score(IAIContext context, IList`1<IContextualScorer> scorers)
}
public AppIOEntity : IOEntity {
private float _cacheTime
private BuildingPrivlidge _cache
public AppEntityType Type
public bool Value
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public AppEntityType get_Type()
public bool get_Value()
public void set_Value(bool value)
protected void BroadcastValueChange()
internal void FillEntityPayload(AppEntityPayload payload)
public BuildingPrivlidge GetBuildingPrivilege()
public EntityTarget GetTarget()
public void PairWithApp(RPCMessage msg)
protected void OnPairedWithPlayer(BasePlayer player)
}
public ApplyTerrainAnchors : MonoBehaviour {
protected void Awake()
}
public ApplyTerrainModifiers : MonoBehaviour {
protected void Awake()
}
public ApplyTweakUIChanges : MonoBehaviour {
public Button ApplyButton
public TweakUIBase[] Options
private void OnEnable()
public void Apply()
public void SetDirty()
public void SetClean()
}
public ArcadeClientAuthTest : ArcadeEntityController {
public float speed
public float maxSpeed
public BaseArcadeGame myGame
public ArcadeEntity myEntity
}
public ArcadeEntity : BaseMonoBehaviour {
public UInt32 id
public UInt32 spriteID
public UInt32 soundID
public bool visible
public Vector3 heading
public bool isEnabled
public bool dirty
public float alpha
public BoxCollider boxCollider
public bool host
public bool localAuthorativeOverride
public ArcadeEntity arcadeEntityParent
public UInt32 prefabID
public bool takesDamage
public float health
public float maxHealth
public bool mapLoadedEntiy
}
public ArcadeEntityController : BaseMonoBehaviour {
public BaseArcadeGame parentGame
public ArcadeEntity arcadeEntity
public ArcadeEntity sourceEntity
public Vector3 heading
public Vector3 positionLocal
public Vector3 positionWorld
public Vector3 get_heading()
public void set_heading(Vector3 value)
public Vector3 get_positionLocal()
public void set_positionLocal(Vector3 value)
public Vector3 get_positionWorld()
public void set_positionWorld(Vector3 value)
}
public ArcadeNetworkTrigger : TriggerBase {
public GameObject InterestedInObject(GameObject obj)
}
public ArmorInformationPanel : ItemInformationPanel {
public ItemTextValue projectileDisplay
public ItemTextValue meleeDisplay
public ItemTextValue coldDisplay
public ItemTextValue explosionDisplay
public ItemTextValue radiationDisplay
public ItemTextValue biteDisplay
public ItemTextValue spacer
public Text areaProtectionText
public Phrase LegText
public Phrase ChestText
public Phrase HeadText
public Phrase ChestLegsText
public Phrase WholeBodyText
public ItemTextValue eggVision
}
public ArmorProperties : ScriptableObject {
public HitArea area
public bool Contains(HitArea hitArea)
}
public ArrayEx : object {
public T[] New(int length)
public T GetRandom(T[] array)
public T GetRandom(T[] array, UInt32 seed)
public T GetRandom(T[] array, UInt32& seed)
public void Shuffle(T[] array, UInt32 seed)
public void Shuffle(T[] array, UInt32& seed)
public void BubbleSort(T[] array)
}
public ArticulatedOccludee : BaseMonoBehaviour {
private float UpdateBoundsFadeStart
private float UpdateBoundsFadeLength
private float UpdateBoundsMaxFrequency
private float UpdateBoundsMinFrequency
private LODGroup lodGroup
public List`1<Collider> colliders
private OccludeeSphere localOccludee
private List`1<Renderer> renderers
private bool isVisible
private Action TriggerUpdateVisibilityBoundsDelegate
public bool IsVisible
public bool get_IsVisible()
protected void OnDisable()
private void ClearVisibility()
public void ProcessVisibility(LODGroup lod)
private void RegisterForCulling(Sphere sphere, bool visible)
private void UnregisterFromCulling()
public void UpdateCullingBounds()
protected bool CheckVisibility()
private void ApplyVisibility(bool vis)
protected void OnVisibilityChanged(bool visible)
private void UpdateVisibility(float delay)
private void VisUpdateUsingCulling(float dist, bool visibility)
public void TriggerUpdateVisibilityBounds()
}
public AspectRatioGuide : MonoBehaviour {
public AspectRatioFitter aspectRatioFitter
public RustText label
public float aspect
public float ratio
private void Populate()
public void Awake()
public void Update()
}
public AssetNameCache : object {
private Dictionary`2<Object, string> mixed
private Dictionary`2<Object, string> lower
private Dictionary`2<Object, string> upper
private string LookupName(Object obj)
private string LookupNameLower(Object obj)
private string LookupNameUpper(Object obj)
public string GetName(PhysicMaterial mat)
public string GetNameLower(PhysicMaterial mat)
public string GetNameUpper(PhysicMaterial mat)
public string GetName(Material mat)
public string GetNameLower(Material mat)
public string GetNameUpper(Material mat)
}
public AssetStorage : object {
public void Save(T& asset, string path)
public void Save(Texture2D& asset)
public void Save(Texture2D& asset, string path, bool linear, bool compress)
public void Load(T& asset, string path)
public void Delete(T& asset)
}
public AsyncTerrainNavMeshBake : CustomYieldInstruction {
private List`1<int> indices
private List`1<Vector3> vertices
private List`1<Vector3> normals
private List`1<int> triangles
private Vector3 pivot
private int width
private int height
private bool normal
private bool alpha
private Action worker
public bool keepWaiting
public bool isDone
public Mesh mesh
public bool get_keepWaiting()
public bool get_isDone()
public NavMeshBuildSource CreateNavMeshBuildSource()
public NavMeshBuildSource CreateNavMeshBuildSource(int area)
public Mesh get_mesh()
public void .ctor(Vector3 pivot, int width, int height, bool normal, bool alpha)
private void DoWork()
private void Invoke()
private void Callback(IAsyncResult result)
}
public AtmosphereVolume : MonoBehaviour {
public float MaxVisibleDistance
public float BoundsAttenuationDecay
public FogSettings FogSettings
}
public AtmosphereVolumeRenderer : MonoBehaviour {
public FogMode Mode
public bool DistanceFog
public bool HeightFog
public AtmosphereVolume Volume
}
public AttackEntity : HeldEntity {
public float deployDelay
public float repeatDelay
public float animationDelay
public float effectiveRange
public float npcDamageScale
public float attackLengthMin
public float attackLengthMax
public float attackSpacing
public float aiAimSwayOffset
public float aiAimCone
public bool aiOnlyInRange
public WeaponTypeEnum effectiveRangeType
public float CloseRangeAddition
public float MediumRangeAddition
public float LongRangeAddition
public bool CanUseAtMediumRange
public bool CanUseAtLongRange
public SoundDefinition[] reloadSounds
public SoundDefinition thirdPersonMeleeSound
public float recoilCompDelayOverride
public bool wantsRecoilComp
private float nextAttackTime
public float NextAttackTime
public Vector3 GetInheritedVelocity(BasePlayer player)
public float AmmoFraction()
public bool CanReload()
public bool ServerIsReloading()
public void ServerReload()
public void TopUpAmmo()
public Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier)
public float get_NextAttackTime()
public void GetAttackStats(HitInfo info)
protected void StartAttackCooldownRaw(float cooldown)
public void StartAttackCooldown(float cooldown)
protected void ResetAttackCooldown()
public bool HasAttackCooldown()
protected float GetAttackCooldown()
protected float GetAttackIdle()
protected float CalculateCooldownTime(float nextTime, float cooldown, bool catchup)
protected bool VerifyClientRPC(BasePlayer player)
protected bool VerifyClientAttack(BasePlayer player)
protected bool ValidateEyePos(BasePlayer player, Vector3 eyePos)
public void OnHeldChanged()
}
public AttractionPoint : PrefabAttribute {
public string groupName
protected Type GetIndexedType()
}
public AudioSettings : MonoBehaviour {
public AudioMixer mixer
private void Update()
private float LinearToDecibel(float linear)
}
public Auth_CentralizedBans : object {
private BanPayload payloadData
public IEnumerator Run(Connection connection)
private bool CheckIfPlayerBanned(ulong steamId, Connection connection, UnityWebRequest request)
internal void <CheckIfPlayerBanned>g__Reject|2_0(string reason, <>c__DisplayClass2_0& )
}
public Auth_EAC : object {
public IEnumerator Run(Connection connection)
}
public Auth_Steam : object {
internal List`1<Connection> waitingList
public IEnumerator Run(Connection connection)
public bool ValidateConnecting(ulong steamid, ulong ownerSteamID, AuthResponse response)
}
public AutoTurret : ContainerIOEntity {
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public float bulletSpeed
public AmbienceEmitter ambienceEmitter
public UpdateAutoTurretScanQueue updateAutoTurretScanQueue
private BasePlayer playerController
public string rcIdentifier
public Vector3 initialAimDir
public float rcTurnSensitivity
public Transform RCEyes
public TargetTrigger targetTrigger
public Transform socketTransform
public float nextShotTime
public float lastShotTime
public float nextVisCheck
public float lastTargetSeenTime
public bool targetVisible
public bool booting
public float nextIdleAimTime
public Vector3 targetAimDir
public float bulletDamage
public float nextForcedAimTime
public Vector3 lastSentAimDir
private Single[] visibilityOffsets
public int peekIndex
public int numConsecutiveMisses
public int totalAmmo
public float nextAmmoCheckTime
public bool totalAmmoDirty
public float currentAmmoGravity
public float currentAmmoVelocity
public HeldEntity AttachedWeapon
public float attachedWeaponZOffsetScale
public BaseCombatEntity target
public Transform eyePos
public Transform muzzlePos
public Vector3 aimDir
public Transform gun_yaw
public Transform gun_pitch
public float sightRange
public SoundDefinition turnLoopDef
public SoundDefinition movementChangeDef
public SoundDefinition ambientLoopDef
public SoundDefinition focusCameraDef
public float focusSoundFreqMin
public float focusSoundFreqMax
public GameObjectRef peacekeeperToggleSound
public GameObjectRef onlineSound
public GameObjectRef offlineSound
public GameObjectRef targetAcquiredEffect
public GameObjectRef targetLostEffect
public GameObjectRef reloadEffect
public float aimCone
public Flags Flag_Equipped
public Flags Flag_MaxAuths
public List`1<PlayerNameID> authorizedPlayers
public bool RequiresMouse
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool PeacekeeperMode()
public bool IsBeingRemoteControlled()
public Transform GetEyes()
public bool Occupied()
public BaseEntity GetEnt()
public bool CanControl()
public bool get_RequiresMouse()
public void UserInput(InputState inputState, BasePlayer player)
public void InitializeControl(BasePlayer controller)
public void StopControl()
public void RCSetup()
public void RCShutdown()
public void UpdateIdentifier(string newID, bool clientSend)
public string GetIdentifier()
public int ConsumptionAmount()
public void SetOnline()
public void SetIsOnline(bool online)
public int GetPassthroughAmount(int outputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void InitiateShutdown()
public void InitiateStartup()
public void SetPeacekeepermode(bool isOn)
public bool IsValidWeapon(Item item)
public bool CanAcceptItem(Item item, int targetSlot)
public bool AtMaxAuthCapacity()
public void UpdateMaxAuthCapacity()
private void FlipAim(RPCMessage rpc)
private void AddSelfAuthorize(RPCMessage rpc)
private void RemoveSelfAuthorize(RPCMessage rpc)
private void ClearList(RPCMessage rpc)
private void SERVER_Peacekeeper(RPCMessage rpc)
private void SERVER_AttackAll(RPCMessage rpc)
public float TargetScanRate()
public void ServerInit()
public void SendAimDir()
public void SetTarget(BaseCombatEntity targ)
public bool CheckPeekers()
public bool ObjectVisible(BaseCombatEntity obj)
public void FireAttachedGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target)
public void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target)
public void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
public void IdleTick()
public bool HasClipAmmo()
public bool HasReserveAmmo()
public int GetTotalAmmo()
public AmmoTypes GetValidAmmoTypes()
public ItemDefinition GetDesiredAmmo()
public void Reload()
public void PostServerLoad()
public void UpdateTotalAmmo()
public void OnItemAddedOrRemoved(Item item, bool added)
public void EnsureReloaded(bool onlyReloadIfEmpty)
public BaseProjectile GetAttachedWeapon()
public bool HasFallbackWeapon()
public bool HasGenericFireable()
public void UpdateAttachedWeapon()
public void OnKilled(HitInfo info)
public void PlayerStoppedLooting(BasePlayer player)
public float GetMaxAngleForEngagement()
public void TargetTick()
public bool HasTarget()
public void OfflineTick()
public bool IsEntityHostile(BaseCombatEntity ent)
public bool ShouldTarget(BaseCombatEntity targ)
public void ScheduleForTargetScan()
public void TargetScan()
protected bool Ignore(BasePlayer player)
public void ServerTick()
public void OnAttacked(HitInfo info)
public void UpdateFacingToTarget()
public float GetAngle(Vector3 launchPosition, Vector3 targetPosition, float launchVelocity, float gravityScale)
public bool IsOnline()
public bool IsOffline()
public void ResetState()
public Transform GetCenterMuzzle()
public float AngleToTarget(BaseCombatEntity potentialtarget, bool use2D)
public bool InFiringArc(BaseCombatEntity potentialtarget)
public bool CanPickup(BasePlayer player)
public void Save(SaveInfo info)
public void PostSave(SaveInfo info)
public void Load(LoadInfo info)
public Vector3 AimOffset(BaseCombatEntity aimat)
public float GetAimSpeed()
public void UpdateAiming()
private Quaternion Lerp(Quaternion from, Quaternion to, float speed)
public bool IsAuthed(BasePlayer player)
public bool AnyAuthed()
public bool CanChangeSettings(BasePlayer player)
}
public AverageVelocity : object {
private Vector3 pos
private float time
private float lastEntry
private float averageSpeed
private Vector3 averageVelocity
public float Speed
public Vector3 Average
public void Record(Vector3 newPos)
public float get_Speed()
public Vector3 get_Average()
}
public Barricade : DecayEntity {
public float reflectDamage
public GameObjectRef reflectEffect
public bool canNpcSmash
public NavMeshModifierVolume NavMeshVolumeAnimals
public NavMeshModifierVolume NavMeshVolumeHumanoids
public NPCBarricadeTriggerBox NpcTriggerBox
private int nonWalkableArea
private int animalAgentTypeId
private int humanoidAgentTypeId
public void ServerInit()
public void OnAttacked(HitInfo info)
}
public BaseAIBrain`1 : EntityComponent`1<T> {
public BasicAIState[] AIStates
public int AIStateIndex_UNSET
public int _currentState
public Vector3 mainInterestPoint
public bool ShouldThink()
public void DoThink()
public T GetEntity()
public void Awake()
public void InitializeAI()
public void AddState(BasicAIState<T> newState, int newIndex)
public BasicAIState<T> GetCurrentState()
public BasicAIState<T> GetState(int index)
public void SwitchToState(int newState)
public void AIThink(float delta)
}
public BaseAimable : BaseVehicleMountPoint {
public Transform aimBase
}
public BaseAnimalNPC : BaseNpc {
public string deathStatName
public void OnKilled(HitInfo hitInfo)
public void OnAttacked(HitInfo info)
public void PostServerLoad()
}
public BaseArcadeGame : BaseMonoBehaviour {
public List`1<BaseArcadeGame> globalActiveGames
public Camera cameraToRender
public RenderTexture renderTexture
public Texture2D distantTexture
public Transform center
public int frameRate
public Dictionary`2<UInt32, ArcadeEntity> activeArcadeEntities
public Sprite[] spriteManifest
public ArcadeEntity[] entityManifest
public bool clientside
public bool clientsideInput
public int spriteIndexInvisible
public GameObject arcadeEntityPrefab
public BaseArcadeMachine ownerMachine
public int gameOffsetIndex
private bool isAuthorative
public Canvas canvas
public BasePlayer GetHostPlayer()
}
public BaseArcadeMachine : BaseVehicle {
public BaseArcadeGame arcadeGamePrefab
public BaseArcadeGame activeGame
public ArcadeNetworkTrigger networkTrigger
public float broadcastRadius
public Transform gameScreen
public RawImage RTImage
public Transform leftJoystick
public Transform rightJoystick
public SoundPlayer musicPlayer
public Flags Flag_P1
public Flags Flag_P2
public List`1<ScoreEntry> scores
private int inputFrameRate
private int snapshotFrameRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void AddScore(BasePlayer player, int score)
public void RequestAddScore(RPCMessage msg)
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
protected bool CanPushNow(BasePlayer pusher)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void NearbyClientMessage(string msg)
public void DestroyMessageFromHost(RPCMessage msg)
public void BroadcastEntityMessage(RPCMessage msg)
public void GetSnapshotFromClient(RPCMessage msg)
}
public BaseBoat : BaseVehicle {
public float engineThrust
public float steeringScale
public float gasPedal
public float steering
public Transform thrustPoint
public Transform centerOfMass
public Buoyancy buoyancy
public GameObject clientCollider
public GameObject serverCollider
public bool generate_paths
public bool InDryDock()
public float MaxVelocity()
public void ServerInit()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void DriverInput(InputState inputState, BasePlayer player)
public bool EngineOn()
protected void VehicleFixedUpdate()
public void BaseBoatDecay(float decayTickRate, float timeSinceLastUsed, float outsideDecayMinutes, float deepWaterDecayMinutes)
public bool EngineInWater()
public float WaterFactorForPlayer(BasePlayer player)
public float GetWaterDepth(Vector3 pos)
public List`1<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore, float minWaterDepth)
}
public BaseBulb : MonoBehaviour {
public Renderer bulbRenderer
}
public BaseChair : BaseMountable {
public float GetComfort()
}
public BaseCollision : MonoBehaviour {
public BaseEntity Owner
public Model model
}
public BaseCombatEntity : BaseEntity {
private float MAX_HEALTH_REPAIR
public DamageType lastDamage
public BaseEntity lastAttacker
public bool ResetLifeStateOnSpawn
public DirectionProperties[] propDirection
public float unHostileTime
public SkeletonProperties skeletonProperties
public ProtectionProperties baseProtection
public float startHealth
public Pickup pickup
public Repair repair
public bool ShowHealthInfo
public LifeState lifestate
public bool sendsHitNotification
public bool sendsMeleeHitNotification
public bool markAttackerHostile
public bool diesAtZeroHealth
public float _health
public float _maxHealth
public Faction faction
public float lastAttackedTime
private Vector3 <LastAttackedDir>k__BackingField
public float lastDealtDamageTime
public int lastNotifyFrame
public Vector3 LastAttackedDir
public float SecondsSinceAttacked
public float SecondsSinceDealtDamage
public float healthFraction
public float health
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected int GetPickupCount()
public bool CanPickup(BasePlayer player)
public void OnPickedUp(Item createdItem, BasePlayer player)
private void RPC_PickupStart(RPCMessage rpc)
public List`1<ItemAmount> BuildCost()
public float RepairCostFraction()
public List`1<ItemAmount> RepairCost(float healthMissingFraction)
public void OnRepair()
public void OnRepairFinished()
public void OnRepairFailed(BasePlayer player, string reason)
public void DoRepair(BasePlayer player)
public void InitializeHealth(float newhealth, float newmax)
public void ServerInit()
public void OnHealthChanged(float oldvalue, float newvalue)
public void Hurt(float amount)
public void Hurt(float amount, DamageType type, BaseEntity attacker, bool useProtection)
public void Hurt(HitInfo info)
public bool IsHostile()
public void MarkHostileFor(float duration)
private void DebugHurt(HitInfo info)
public void SetHealth(float hp)
public void Heal(float amount)
public void OnKilled(HitInfo info)
public void Die(HitInfo info)
public void DieInstantly()
public void UpdateSurroundings()
public bool IsDead()
public bool IsAlive()
public Faction GetFaction()
public bool IsFriendly(BaseCombatEntity other)
public Vector3 get_LastAttackedDir()
public void set_LastAttackedDir(Vector3 value)
public float get_SecondsSinceAttacked()
public float get_SecondsSinceDealtDamage()
public float get_healthFraction()
public void ResetState()
public void DestroyShared()
public float GetThreatLevel()
public float PenetrationResistance(HitInfo info)
public void ScaleDamage(HitInfo info)
public HitArea SkeletonLookup(UInt32 boneID)
public void Save(SaveInfo info)
public void PostServerLoad()
public void Load(LoadInfo info)
public float get_health()
public void set_health(float value)
public float Health()
public float MaxHealth()
public float StartHealth()
public float StartMaxHealth()
public void SetMaxHealth(float newMax)
public void DoHitNotify(HitInfo info)
public void OnAttacked(HitInfo info)
}
public BaseCommandBuffer : MonoBehaviour {
private Dictionary`2<Camera, Dictionary`2<int, CommandBuffer>> cameras
protected CommandBuffer GetCommandBuffer(string name, Camera camera, CameraEvent cameraEvent)
protected void CleanupCamera(string name, Camera camera, CameraEvent cameraEvent)
protected void CleanupCommandBuffer(Camera camera, CameraEvent cameraEvent)
protected void Cleanup()
}
public BaseCorpse : BaseCombatEntity {
public GameObjectRef prefabRagdoll
public BaseEntity parentEnt
public ResourceDispenser resourceDispenser
public TraitFlag Traits
public void ServerInit()
public void InitCorpse(BaseEntity pr)
public bool CanRemove()
public void RemoveCorpse()
public void ResetRemovalTime(float dur)
public float GetRemovalTime()
public void ResetRemovalTime()
public void Save(SaveInfo info)
public void TakeChildren(BaseEntity takeChildrenFrom)
public void ApplyInheritedVelocity(Vector3 velocity)
private Rigidbody SetupRigidBody()
public void Load(LoadInfo info)
private void Load(Corpse corpse)
public void OnAttacked(HitInfo info)
public string Categorize()
public TraitFlag get_Traits()
public void Eat(BaseNpc baseNpc, float timeSpent)
public bool ShouldInheritNetworkGroup()
}
public BaseCrane : BaseVehicle {
public float extensionArmState
public float raiseArmState
public float yawState
public Transform COM
public float extensionDirection
public float yawDirection
public float raiseArmDirection
public float arm1Speed
public float arm2Speed
public float turnYawSpeed
public Animator animator
public BaseMagnet Magnet
public Rigidbody myRigidbody
public WheelCollider[] leftWheels
public WheelCollider[] rightWheels
public float brakeStrength
public float engineStrength
public Transform[] collisionTestingPoints
public float maxDistanceFromOrigin
public GameObjectRef selfDamageEffect
public GameObjectRef explosionEffect
public Transform explosionPoint
public CapsuleCollider driverCollision
public Transform leftHandTarget
public Transform rightHandTarget
public GameObjectRef fuelStoragePrefab
public Transform fuelStoragePoint
public float fuelPerSec
protected EntityFuelSystem fuelSystem
public GameObject[] OnTriggers
public TriggerHurtEx magnetDamage
public Phrase ReturnMessage
private Vector3 spawnOrigin
public float nextInputTime
private float nextToggleTime
public float turnAmount
public float throttle
private float lastExtensionArmState
private float lastRaiseArmState
private float lastYawState
private bool handbrakeOn
private float nextSelfHealTime
private Vector3 lastDamagePos
private float lastDrivenTime
private float testPreviousYaw
public float GetPlayerDamageMultiplier()
public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
public void ServerInit()
public void SetMagnetEnabled(bool wantsOn)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public bool EngineOn()
protected void VehicleFixedUpdate()
public void UpdateMotorSpeed(float speedLeft, float speedRight, float brakeSpeed)
public void Save(SaveInfo info)
public void UpdateParams()
public void LateUpdate()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public void LightToggle(BasePlayer player)
public bool DidCollide()
public void SpawnSubEntities()
public void RPC_OpenFuel(RPCMessage msg)
public EntityFuelSystem GetFuelSystem()
public void Load(LoadInfo info)
public void UpdateAnimator(bool shouldLerp)
public void InitShared()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public BaseDetector : IOEntity {
public PlayerDetectionTrigger myTrigger
public Flags Flag_HasContents
public int ConsumptionAmount()
public bool ShouldTrigger()
public void OnObjects()
public void OnEmpty()
public void OnDetectorTriggered()
public void OnDetectorReleased()
public int GetPassthroughAmount(int outputSlot)
}
public BaseEntity : BaseNetworkable {
private Queue`1<BaseEntity> globalBroadcastQueue
private UInt32 globalBroadcastProtocol
private UInt32 broadcastProtocol
private List`1<EntityLink> links
private bool linkedToNeighbours
public BaseEntity creatorEntity
public int ticksSinceStopped
private int doneMovingWithoutARigidBodyCheck
public bool isCallingUpdateNetworkGroup
private EntityRef[] entitySlots
public List`1<TriggerBase> triggers
protected bool isVisible
protected bool isAnimatorVisible
protected bool isShadowVisible
protected OccludeeSphere localOccludee
private float <Weight>k__BackingField
public Bounds bounds
public GameObjectRef impactEffect
public bool enableSaving
public bool syncPosition
public Model model
public Flags flags
public UInt32 parentBone
public ulong skinID
private EntityComponentBase[] _components
public string _name
private ulong <OwnerID>k__BackingField
public Spawnable _spawnable
public HashSet`1<BaseEntity> saveList
public float RealisticMass
public float radiationLevel
public float currentTemperature
public float currentEnvironmentalWetness
public float PositionTickRate
public bool PositionTickFixedTime
public Vector3 ServerPosition
public Quaternion ServerRotation
public TraitFlag Traits
public float Weight
public EntityComponentBase[] Components
public bool IsNpc
public ulong OwnerID
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float get_RealisticMass()
public void OnCollision(Collision collision, BaseEntity hitEntity)
protected void ReceiveCollisionMessages(bool b)
public void DebugServer(int rep, float time)
public string DebugText()
public void OnDebugStart()
protected void DebugText(Vector3 pos, string str, Color color, float time)
public bool HasFlag(Flags f)
public bool ParentHasFlag(Flags f)
public void SetFlag(Flags f, bool b, bool recursive, bool networkupdate)
public bool IsOn()
public bool IsOpen()
public bool IsOnFire()
public bool IsLocked()
public bool IsDebugging()
public bool IsDisabled()
public bool IsBroken()
public bool IsBusy()
public string GetLogColor()
public void OnFlagsChanged(Flags old, Flags next)
public void SendNetworkUpdate_Flags()
public bool IsOccupied(Socket_Base socket)
public bool IsOccupied(string socketName)
public EntityLink FindLink(Socket_Base socket)
public EntityLink FindLink(string socketName)
public EntityLink FindLink(String[] socketNames)
public T FindLinkedEntity()
public void EntityLinkMessage(Action`1<T> action)
public void EntityLinkBroadcast(Action`1<T> action, Func`2<S, bool> canTraverseSocket)
public void EntityLinkBroadcast(Action`1<T> action)
public void EntityLinkBroadcast()
public bool ReceivedEntityLinkBroadcast()
public List`1<EntityLink> GetEntityLinks(bool linkToNeighbours)
private void LinkToEntity(BaseEntity other)
private void LinkToNeighbours()
private void InitEntityLinks()
private void FreeEntityLinks()
public void RefreshEntityLinks()
public void SV_RequestFile(RPCMessage msg)
public void SetParent(BaseEntity entity, bool worldPositionStays, bool sendImmediate)
public void SetParent(BaseEntity entity, string strBone, bool worldPositionStays, bool sendImmediate)
public bool HasChild(BaseEntity c)
public void SetParent(BaseEntity entity, UInt32 boneID, bool worldPositionStays, bool sendImmediate)
public void DestroyOnClient(Connection connection)
public void SendChildrenNetworkUpdate()
public void SendChildrenNetworkUpdateImmediate()
public void SwitchParent(BaseEntity ent)
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
public BuildingPrivlidge GetBuildingPrivilege()
public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
public void SV_RPCMessage(UInt32 nameID, Message message)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1)
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1)
public void ClientRPC(Connection sourceConnection, string funcName)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1)
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName)
private bool ClientRPCStart(Connection sourceConnection, string funcName)
private void ClientRPCWrite(T arg)
private void ClientRPCSend(SendInfo sendInfo)
public float get_radiationLevel()
public float RadiationProtection()
public float RadiationExposureFraction()
public float get_currentTemperature()
public float get_currentEnvironmentalWetness()
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public void EnableGlobalBroadcast(bool wants)
public void EnableSaving(bool wants)
public void ServerInit()
public void OnSensation(Sensation sensation)
public float get_PositionTickRate()
public bool get_PositionTickFixedTime()
public void NetworkPositionTick()
public void TransformChanged()
public void OnPositionalNetworkUpdate()
public void DoMovingWithoutARigidBodyCheck()
public void Spawn()
public void OnParentSpawning()
public void SpawnAsMapEntity()
public void PostMapEntitySpawn()
internal void DoServerDestroy()
internal void OnParentRemoved()
public void OnInvalidPosition()
public BaseCorpse DropCorpse(string strCorpsePrefab)
public void UpdateNetworkGroup()
public void Eat(BaseNpc baseNpc, float timeSpent)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy)
public bool ShouldNetworkTo(BasePlayer player)
public void AttackerInfo(DeathInfo info)
public void Push(Vector3 velocity)
public void ApplyInheritedVelocity(Vector3 velocity)
public void SetVelocity(Vector3 velocity)
public void SetAngularVelocity(Vector3 velocity)
public Vector3 GetDropPosition()
public Vector3 GetDropVelocity()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public Vector3 get_ServerPosition()
public void set_ServerPosition(Vector3 value)
public Quaternion get_ServerRotation()
public void set_ServerRotation(Quaternion value)
private void BroadcastSignalFromClient(RPCMessage msg)
public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection)
public void SignalBroadcast(Signal signal, Connection sourceConnection)
private void OnSkinChanged(ulong oldSkinID, ulong newSkinID)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool HasAnySlot()
public BaseEntity GetSlot(Slot slot)
public string GetSlotAnchorName(Slot slot)
public void SetSlot(Slot slot, BaseEntity ent)
public bool HasSlot(Slot slot)
public TraitFlag get_Traits()
public bool HasTrait(TraitFlag f)
public bool HasAnyTrait(TraitFlag f)
public bool EnterTrigger(TriggerBase trigger)
public void LeaveTrigger(TriggerBase trigger)
public void RemoveFromTriggers()
public T FindTrigger()
public bool FindTrigger(T& result)
private void ForceUpdateTriggersAction()
public void ForceUpdateTriggers(bool enter, bool exit, bool invoke)
public float get_Weight()
protected void set_Weight(float value)
public EntityComponentBase[] get_Components()
public BasePlayer ToPlayer()
public bool get_IsNpc()
public void InitShared()
public void DestroyShared()
public void ResetState()
public float InheritedVelocityScale()
public Vector3 GetInheritedProjectileVelocity()
public Vector3 GetInheritedThrowVelocity()
public Vector3 GetInheritedDropVelocity()
public Vector3 GetParentVelocity()
public Vector3 GetWorldVelocity()
public Vector3 GetLocalVelocity()
public Quaternion GetAngularVelocity()
public OBB WorldSpaceBounds()
public Vector3 PivotPoint()
public Vector3 CenterPoint()
public Vector3 ClosestPoint(Vector3 position)
public Vector3 TriggerPoint()
public float Distance(Vector3 position)
public float SqrDistance(Vector3 position)
public float Distance(BaseEntity other)
public float SqrDistance(BaseEntity other)
public float Distance2D(Vector3 position)
public float SqrDistance2D(Vector3 position)
public float Distance2D(BaseEntity other)
public float SqrDistance2D(BaseEntity other)
public bool IsVisible(Ray ray, float maxDistance)
public bool IsVisible(Vector3 position, Vector3 target, float maxDistance)
public bool IsVisible(Vector3 position, float maxDistance)
public bool IsVisibleAndCanSee(Vector3 position, float maxDistance)
public bool IsOlderThan(BaseEntity other)
public bool IsOutside()
public bool IsOutside(Vector3 position)
public float WaterFactor()
public bool WaterTestFromVolumes(Vector3 pos, WaterInfo& info)
public bool IsInWaterVolume(Vector3 pos)
public bool WaterTestFromVolumes(Bounds bounds, WaterInfo& info)
public bool BlocksWaterFor(BasePlayer player)
public float Health()
public float MaxHealth()
public float MaxVelocity()
public float BoundsPadding()
public float PenetrationResistance(HitInfo info)
public GameObjectRef GetImpactEffect(HitInfo info)
public void OnAttacked(HitInfo info)
public Item GetItem()
public Item GetItem(UInt32 itemId)
public void GiveItem(Item item, GiveItemReason reason)
public bool CanBeLooted(BasePlayer player)
public BaseEntity GetEntity()
public string ToString()
public string Categorize()
public void Log(string str)
public void SetModel(Model mdl)
public Model GetModel()
public Transform[] GetBones()
public Transform FindBone(string strName)
public Transform FindClosestBone(Vector3 worldPos)
public ulong get_OwnerID()
public void set_OwnerID(ulong value)
public bool ShouldBlockProjectiles()
public bool ShouldInheritNetworkGroup()
public bool SupportsChildDeployables()
public void BroadcastEntityMessage(string msg, float radius, int layerMask)
public void OnEntityMessage(BaseEntity from, string msg)
public void Save(SaveInfo info)
public bool ShouldNetworkOwnerInfo()
public void Load(LoadInfo info)
}
public BaseEntityChild : MonoBehaviour {
public void Setup(GameObject obj, BaseEntity parent)
public void OnDestroy()
}
public BaseEntityEx : object {
public bool IsValid(BaseEntity ent)
public bool IsRealNull(BaseEntity ent)
public bool IsValidEntityReference(T obj)
public bool HasEntityInParents(BaseEntity ent, BaseEntity toFind)
}
public BaseFirework : BaseCombatEntity {
public float fuseLength
public float activityLength
public Flags Flag_Spent
public float corpseDuration
public bool limitActiveCount
public int maxActiveFireworks
public List`1<BaseFirework> _activeFireworks
public bool IsLit()
public bool IsExhausted()
public int NumActiveFireworks()
public void TryLightFuse()
public void Begin()
public void OnExhausted()
public void Cleanup()
internal void DoServerDestroy()
public void OnAttacked(HitInfo info)
public void Ignite()
public void StaggeredTryLightFuse()
public bool CanIgnite()
public bool CanPickup(BasePlayer player)
}
public BaseFootstepEffect : MonoBehaviour {
public LayerMask validImpactLayers
}
public BaseGameMode : BaseEntity {
private GameMode gameModeScores
public String[] scoreColumns
public Flags Flag_Warmup
public Flags Flag_GameOver
public Flags Flag_WaitingForPlayers
private Action`1<BaseGameMode> GameModeChanged
public string shortname
public float matchDuration
public float warmupDuration
public float timeBetweenMatches
public int minPlayersToStart
public bool useCustomSpawns
public string victoryScoreName
public string teamScoreName
public int numScoreForVictory
public GameObjectRef startingWeapon
public string gamemodeTitle
public SoundDefinition[] warmupMusics
public SoundDefinition[] lossMusics
public SoundDefinition[] winMusics
private float warmupStartTime
private float matchStartTime
private float matchEndTime
public String[] gameModeTags
public bool permanent
public bool limitTeamAuths
public BaseGameMode svActiveGameMode
public List`1<BaseGameMode> svGameModeManifest
private GameObject[] allspawns
private GameModeSpawnGroup[] gameModeSpawnGroups
public PlayerInventoryProperties[] loadouts
public GameModeTeam[] teams
private bool isResetting
public GameMode GetGameScores()
public int ScoreColumnIndex(string scoreName)
public void InitScores()
public void CopyGameModeScores(GameMode from, GameMode to)
public PlayerScore GetPlayerScoreForPlayer(BasePlayer player)
public int GetScoreIndexByName(string name)
public bool IsDraw()
public string GetWinnerName()
public int GetPlayerTeamPosition(BasePlayer player)
public int GetPlayerRank(BasePlayer player)
public int GetWinningTeamIndex()
public bool DidPlayerWin(BasePlayer player)
public bool IsTeamGame()
public bool KeepScores()
public void ModifyTeamScore(int teamIndex, int modifyAmount)
public void SetTeamScore(int teamIndex, int score)
public void ResetPlayerScores(BasePlayer player)
public void ModifyPlayerGameScore(BasePlayer player, string scoreName, int modifyAmount)
public void ModifyPlayerGameScore(BasePlayer player, int scoreIndex, int modifyAmount)
public int GetPlayerGameScore(BasePlayer player, int scoreIndex)
public void SetPlayerTeam(BasePlayer player, int newTeam)
public void SetPlayerGameScore(BasePlayer player, int scoreIndex, int scoreValue)
public void add_GameModeChanged(Action`1<BaseGameMode> value)
public void remove_GameModeChanged(Action`1<BaseGameMode> value)
public bool HasAnyGameModeTag(String[] tags)
public bool HasGameModeTag(string tag)
public bool HasLoadouts()
public int GetNumTeams()
public int GetTeamScore(int teamIndex)
public void CreateGameMode(string overrideMode)
public void SetActiveGameMode(BaseGameMode newActive, bool serverside)
public BaseGameMode GetActiveGameMode(bool serverside)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public float CorpseRemovalTime(BaseCorpse corpse)
public bool InWarmup()
public bool IsWaitingForPlayers()
public bool IsMatchOver()
public bool IsMatchActive()
public void InitShared()
public void DestroyShared()
protected void OnCreated()
protected void OnMatchBegin()
public void ResetMatch()
public void ResetTeamScores()
public void ShutdownGame()
private void Update()
protected void OnThink(float delta)
public void OnMatchEnd()
public void OnNewPlayer(BasePlayer player)
public void OnPlayerConnected(BasePlayer player)
public void UnassignAllPlayers()
public void AutoAssignTeam(BasePlayer player)
public void OnPlayerDisconnected(BasePlayer player)
public void OnPlayerWounded(BasePlayer instigator, BasePlayer victim, HitInfo info)
public void OnPlayerRevived(BasePlayer instigator, BasePlayer victim)
public void OnPlayerDeath(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo)
public bool CanPlayerRespawn(BasePlayer player)
public void OnPlayerRespawn(BasePlayer player)
public void CheckGameConditions(bool force)
public void LoadoutPlayer(BasePlayer player)
public void InstallSpawnpoints()
public SpawnPoint GetPlayerSpawn(BasePlayer forPlayer)
public int GetMaxRelationshipTeamSize()
public SleepingBag[] FindSleepingBagsForPlayer(ulong playerID, bool ignoreTimers)
public bool CanMoveItemsFrom(PlayerInventory inv, BaseEntity source, Item item)
}
public BaseHelicopter : BaseCombatEntity {
public weakspot[] weakspots
public GameObject rotorPivot
public GameObject mainRotor
public GameObject mainRotor_blades
public GameObject mainRotor_blur
public GameObject tailRotor
public GameObject tailRotor_blades
public GameObject tailRotor_blur
public GameObject rocket_tube_left
public GameObject rocket_tube_right
public GameObject left_gun_yaw
public GameObject left_gun_pitch
public GameObject left_gun_muzzle
public GameObject right_gun_yaw
public GameObject right_gun_pitch
public GameObject right_gun_muzzle
public GameObject spotlight_rotation
public GameObjectRef rocket_fire_effect
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public GameObjectRef explosionEffect
public GameObjectRef fireBall
public GameObjectRef crateToDrop
public int maxCratesToSpawn
public float bulletSpeed
public float bulletDamage
public GameObjectRef servergibs
public GameObjectRef debrisFieldMarker
public SoundDefinition rotorWashSoundDef
private Sound _rotorWashSound
public SoundDefinition flightEngineSoundDef
public SoundDefinition flightThwopsSoundDef
private Sound flightEngineSound
private Sound flightThwopsSound
public Modulator flightEngineGainMod
public Modulator flightThwopsGainMod
public float rotorGainModSmoothing
public float engineGainMin
public float engineGainMax
public float thwopGainMin
public float thwopGainMax
public float spotlightJitterAmount
public float spotlightJitterSpeed
public GameObject[] nightLights
public Vector3 spotlightTarget
public float engineSpeed
public float targetEngineSpeed
public float blur_rotationScale
public ParticleSystem[] _rotorWashParticles
public PatrolHelicopterAI myAI
public float lastNetworkUpdate
private float networkUpdateRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void InitalizeWeakspots()
public void OnAttacked(HitInfo info)
public void Hurt(HitInfo info)
public float MaxVelocity()
public void InitShared()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ServerInit()
public void OnPositionalNetworkUpdate()
public void CreateExplosionMarker(float durationMinutes)
public void OnKilled(HitInfo info)
public void Update()
}
public BaseHelicopterVehicle : BaseVehicle {
public float engineThrustMax
public Vector3 torqueScale
public Transform com
public GameObject[] killTriggers
public Transform[] GroundPoints
public Transform[] GroundEffects
public GameObjectRef serverGibs
public GameObjectRef explosionEffect
public GameObjectRef fireBall
public GameObjectRef impactEffectSmall
public GameObjectRef impactEffectLarge
public SoundDefinition flightEngineSoundDef
public SoundDefinition flightThwopsSoundDef
public float rotorGainModSmoothing
public float engineGainMin
public float engineGainMax
public float thwopGainMin
public float thwopGainMax
public float currentThrottle
public float avgThrust
public float liftDotMax
public float altForceDotMin
public float liftFraction
public float thrustLerpSpeed
public float avgTerrainHeight
public Flags Flag_InternalLights
public HelicopterInputState currentInputState
public float lastPlayerInputTime
public float hoverForceScale
public Vector3 damageTorque
public float nextDamageTime
public float nextEffectTime
public float pendingImpactDamage
public float GetServiceCeiling()
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public float MaxVelocity()
public void ServerInit()
public float MouseToBinary(float amount)
public void PilotInput(InputState inputState, BasePlayer player)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void SetDefaultInputState()
public bool IsEnginePowered()
public void VehicleFixedUpdate()
public void OnPhysicsNeighbourChanged()
public void LightToggle(BasePlayer player)
public bool ShouldApplyHoverForce()
public bool IsEngineOn()
public void ClearDamageTorque()
public void SetDamageTorque(Vector3 newTorque)
public void AddDamageTorque(Vector3 torqueToAdd)
public void MovementUpdate()
public void DelayedImpactDamage()
public bool CollisionDamageEnabled()
public void ProcessCollision(Collision collision)
public void OnCollisionEnter(Collision collision)
public void OnKilled(HitInfo info)
}
public BaseHuntEvent : BaseEntity {
public GameObjectRef[] HuntablePrefab
public AudioSource huntStartSound
}
public BaseLadder : BaseCombatEntity {
public bool ShouldBlockProjectiles()
}
public BaseLauncher : BaseProjectile {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool ForceSendMagazine()
public void ServerUse()
public void ServerUse(float damageModifier, Transform originOverride)
private void SV_Launch(RPCMessage msg)
}
public BaseLiquidVessel : AttackEntity {
public GameObjectRef thrownWaterObject
public GameObjectRef ThrowEffect3P
public SoundDefinition throwSound3P
public GameObjectRef fillFromContainer
public GameObjectRef fillFromWorld
public SoundDefinition fillFromContainerStartSoundDef
public SoundDefinition fillFromContainerSoundDef
public SoundDefinition fillFromWorldStartSoundDef
public SoundDefinition fillFromWorldSoundDef
public bool hasLid
public float throwScale
public bool canDrinkFrom
public bool updateVMWater
public float minThrowFrac
public bool useThrowAnim
public float fillMlPerSec
private float lastFillTime
private float nextFreeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void OnHeldChanged()
public void SetFilling(bool isFilling)
public void OnSetFilling(bool flag)
public void StartFilling()
public void StopFilling()
public void FillCheck()
public void LoseWater(int amount)
public void AddLiquid(ItemDefinition liquidType, int amount)
public int AmountHeld()
public float HeldFraction()
public int MaxHoldable()
public bool CanDrink()
private bool IsWeaponBusy()
private void SetBusyFor(float dur)
private void ClearBusy()
private void DoDrink(RPCMessage msg)
private void ThrowContents(RPCMessage msg)
public void DoThrow(Vector3 pos, Vector3 velocity)
private void SendFilling(RPCMessage msg)
public bool CanFillFromWorld()
public bool CanThrow()
public LiquidContainer GetFacingLiquidContainer()
}
public BaseLock : BaseEntity {
public ItemDefinition itemType
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool GetPlayerLockPermission(BasePlayer player)
public bool OnTryToOpen(BasePlayer player)
public bool OnTryToClose(BasePlayer player)
public bool HasLockPermission(BasePlayer player)
public void RPC_TakeLock(RPCMessage rpc)
public float BoundsPadding()
}
public BaseMagnet : MonoBehaviour {
public TriggerMagnet magnetTrigger
public FixedJoint fixedJoint
public Rigidbody kinematicAttachmentBody
public float magnetForce
public Transform attachDepthPoint
public GameObjectRef attachEffect
public bool isMagnetOn
public GameObject colliderSource
public bool HasConnectedObject()
public OBB GetConnectedOBB(float scale)
public void SetCollisionsEnabled(GameObject other, bool wants)
public void Start()
public void SetMagnetEnabled(bool wantsOn)
public void OnMagnetEnabled()
public void OnMagnetDisabled()
public bool IsMagnetOn()
public void MagnetThink(float delta)
}
public BaseMelee : AttackEntity {
public bool canThrowAsProjectile
public bool canAiHearIt
public bool onlyThrowAsProjectile
public DamageProperties damageProperties
public List`1<DamageTypeEntry> damageTypes
public float maxDistance
public float attackRadius
public bool isAutomatic
public bool blockSprintOnAttack
public GameObjectRef strikeFX
public bool useStandardHitEffects
public float aiStrikeDelay
public GameObjectRef swingEffect
public List`1<MaterialFX> materialStrikeFX
public float heartStress
public GatherProperties gathering
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 GetInheritedVelocity(BasePlayer player)
private void CLProject(RPCMessage msg)
public void GetAttackStats(HitInfo info)
public void DoAttackShared(HitInfo info)
public GatherPropertyEntry GetGatherInfoFromIndex(GatherType index)
public bool CanHit(HitTest info)
public float TotalDamage()
public bool IsItemBroken()
public void LoseCondition(float amount)
public float GetConditionLoss()
public void UpdateItemCondition(HitInfo info)
public void PlayerAttack(RPCMessage msg)
public bool CanBeUsedInWater()
public string GetStrikeEffectPath(string materialName)
public void ServerUse()
public void ServerUse_OnHit(HitInfo info)
public void ServerUse_Strike()
}
public BaseMetabolism : object {
public float targetHeartRate
}
public BaseMetabolism`1 : EntityComponent`1<T> {
protected T owner
public MetabolismAttribute calories
public MetabolismAttribute hydration
public MetabolismAttribute heartrate
protected float timeSinceLastMetabolism
public void Reset()
protected void OnDisable()
public void ServerInit(T owner)
public void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
protected void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
protected void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
public void ApplyChange(Type type, float amount, float time)
public bool ShouldDie()
public MetabolismAttribute FindAttribute(Type type)
}
public BaseModifiers`1 : EntityComponent`1<T> {
public List`1<Modifier> All
protected Dictionary`2<ModifierType, float> totalValues
protected Dictionary`2<ModifierType, float> modifierVariables
protected T owner
protected bool dirty
protected float timeSinceLastTick
protected float lastTickTime
public int ActiveModifierCoount
public int get_ActiveModifierCoount()
public void Add(List`1<ModifierDefintion> modDefs)
protected void Add(ModifierDefintion def)
protected void Add(Modifier modifier)
private bool CanAdd(Modifier modifier)
private int GetMaxModifiersForSourceType(ModifierSource source)
private int GetTypeSourceCount(ModifierType type, ModifierSource source)
private Modifier GetShortestLifeModifier(ModifierType type, ModifierSource source)
private void Remove(Modifier modifier)
public void RemoveAll()
public float GetValue(ModifierType type, float defaultValue)
public float GetVariableValue(ModifierType type, float defaultValue)
public void SetVariableValue(ModifierType type, float value)
public void RemoveVariable(ModifierType type)
protected void OnDisable()
protected void SetDirty(bool flag)
public void ServerInit(T owner)
public void ResetTicking()
public void ServerUpdate(BaseCombatEntity ownerEntity)
protected void TickModifiers(BaseCombatEntity ownerEntity, float delta)
}
public BaseModularVehicle : BaseVehicle {
public bool inEditableLocation
public bool prevEditable
public bool immuneToDecay
private ModularVehicleInventory <Inventory>k__BackingField
public Vector3 realLocalCOM
public Item AssociatedItemInstance
private bool disablePhysics
public bool waterlogged
public float mass
public List`1<ModularVehicleSocket> moduleSockets
public Transform centreOfMassTransform
public Transform waterSample
public LODGroup lodGroup
private List`1<BaseVehicleModule> <AttachedModuleEntities>k__BackingField
private float <TotalMass>k__BackingField
private Vector3 <Velocity>k__BackingField
private bool <HasInited>k__BackingField
public Flags FLAG_KINEMATIC
public Dictionary`2<BaseVehicleModule, Action> moduleAddActions
public ModularVehicleInventory Inventory
public Vector3 CentreOfMass
public int NumAttachedModules
public bool HasAnyModules
public List`1<BaseVehicleModule> AttachedModuleEntities
public int TotalSockets
public int NumFreeSockets
public float TotalMass
public Vector3 Velocity
public bool LightsAreOn
public bool IsKinematic
public bool VehicleIsActive
public bool IsLockable
public bool HasInited
public ItemDefinition AssociatedItemDef
public bool IsEditableNow
public ModularVehicleInventory get_Inventory()
public void set_Inventory(ModularVehicleInventory value)
public void ServerInit()
public void PreServerLoad()
public void PostServerLoad()
public void DoServerDestroy()
public float MaxVelocity()
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public bool IsComplete()
public bool CouldBeEdited()
public void DisablePhysics()
public void EnablePhysics()
public void VehicleFixedUpdate()
public bool MountEligable(BasePlayer player)
public void Save(SaveInfo info)
public void LightToggle(BasePlayer player)
public bool CanMoveFrom(BasePlayer player, Item item)
protected Vector3 GetCOMMultiplier()
public void OnPhysicsNeighbourChanged()
public void SetLightsState(bool on)
public void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info)
public void ModuleReachedZeroHealth()
public bool TryAddModule(Item moduleItem, int socketIndex)
public bool TryAddModule(Item moduleItem)
public bool ModuleCanBeAdded(Item moduleItem, int socketIndex, String& failureReason)
public BaseVehicleModule CreatePhysicalModuleEntity(Item moduleItem, ItemModVehicleModule itemModModule, int socketIndex)
public void SetUpModule(BaseVehicleModule moduleEntity, Item moduleItem)
public Item GetVehicleItem(UInt32 itemUID)
public BaseVehicleModule GetModuleForItem(Item item)
public void SetMass(float mass)
public void SetCOM(Vector3 com)
public Vector3 get_CentreOfMass()
public int get_NumAttachedModules()
public bool get_HasAnyModules()
public List`1<BaseVehicleModule> get_AttachedModuleEntities()
public int get_TotalSockets()
public int get_NumFreeSockets()
public float get_TotalMass()
public void set_TotalMass(float value)
public Vector3 get_Velocity()
public void set_Velocity(Vector3 value)
public bool get_LightsAreOn()
public bool get_IsKinematic()
public bool get_VehicleIsActive()
public bool get_IsLockable()
public bool get_HasInited()
private void set_HasInited(bool value)
public ItemDefinition get_AssociatedItemDef()
public bool get_IsEditableNow()
public void InitShared()
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public float GetSpeed()
public float GetMaxForwardSpeed()
public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
public bool TryDeduceSocketIndex(BaseVehicleModule addedModule, Int32& index)
public void AddMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
public void RemoveMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
public bool TryGetModuleAt(int socketIndex, BaseVehicleModule& result)
public ModularVehicleSocket GetSocket(int index)
public void Load(LoadInfo info)
public bool CanPushNow(BasePlayer pusher)
public void OnChildAdded(BaseEntity childEntity)
public void OnChildRemoved(BaseEntity childEntity)
public void ModuleEntityAdded(BaseVehicleModule addedModule)
public void ModuleEntityRemoved(BaseVehicleModule removedModule)
public void RefreshModulesExcept(BaseVehicleModule ignoredModule)
}
public BaseMonoBehaviour : FacepunchBehaviour {
public bool IsDebugging()
public string GetLogColor()
public void LogEntry(LogEntryType log, int level, string str, object arg1)
public void LogEntry(LogEntryType log, int level, string str, object arg1, object arg2)
public void LogEntry(LogEntryType log, int level, string str)
}
public BaseMountable : BaseCombatEntity {
public BasePlayer _mounted
public Transform eyeOverride
public Vector2 pitchClamp
public Vector2 yawClamp
public bool canWieldItems
public bool relativeViewAngles
public Transform mountAnchor
public MountPoses mountPose
public float maxMountDistance
public Transform[] dismountPositions
public bool checkPlayerLosOnMount
public bool disableMeshCullingForPlayers
public bool modifiesPlayerCollider
public CapsuleColliderInfo customPlayerCollider
public SoundDefinition mountSoundDef
public SoundDefinition swapSoundDef
public SoundDefinition dismountSoundDef
public MountStatType mountTimeStatType
public MountGestureType allowedGestures
public CameraMode MountedCameraMode
public bool isMobile
public float SideLeanAmount
public float playerHeight
public float playerRadius
protected float PositionTickRate
public bool IsSummerDlcVehicle
public bool CanDrinkWhileMounted
public bool BlocksDoors
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanHoldItems()
public CameraMode GetMountedCameraMode()
public bool DirectlyMountable()
public Transform GetEyeOverride()
public Quaternion GetMountedBodyAngles()
public bool ModifiesThirdPersonCamera()
public Vector2 GetPitchClamp()
public Vector2 GetYawClamp()
public Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot)
public float WaterFactorForPlayer(BasePlayer player)
public float MaxVelocity()
public BasePlayer GetMounted()
public BaseVehicle VehicleParent()
public void PostServerLoad()
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public float GetSteering(BasePlayer player)
public void LightToggle(BasePlayer player)
public bool CanSwapToThis(BasePlayer player)
public bool IsMounted()
protected float get_PositionTickRate()
public bool CanPickup(BasePlayer player)
public void OnKilled(HitInfo info)
public void RPC_WantsMount(RPCMessage msg)
public void AttemptMount(BasePlayer player, bool doMountChecks)
public bool AttemptDismount(BasePlayer player)
public void RPC_WantsDismount(RPCMessage msg)
public void MountPlayer(BasePlayer player)
public void OnPlayerMounted()
public void OnPlayerDismounted(BasePlayer player)
public void DismountAllPlayers()
public void DismountPlayer(BasePlayer player, bool lite)
public bool ValidDismountPosition(Vector3 disPos, Vector3 visualCheckOrigin)
public bool HasValidDismountPosition(BasePlayer player)
public bool GetDismountPosition(BasePlayer player, Vector3& res)
public void ServerInit()
public void FixedUpdate()
protected void VehicleFixedUpdate()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public float GetComfort()
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public bool IsInstrument()
public bool get_IsSummerDlcVehicle()
public bool NearMountPoint(BasePlayer player)
public Vector3 ConvertVector(Vector3 vec)
public bool get_CanDrinkWhileMounted()
public bool get_BlocksDoors()
private bool <ValidDismountPosition>g__HitOurself|59_0(RaycastHit hit)
}
public BaseMovement : MonoBehaviour {
public bool adminCheat
public float adminSpeed
}
public BaseNetworkable : BaseMonoBehaviour {
public List`1<Component> postNetworkUpdateComponents
public bool _limitedNetworking
public EntityRef parentEntity
public List`1<BaseEntity> children
public int creationFrame
public bool isSpawned
public MemoryStream _NetworkCache
public Queue`1<MemoryStream> EntityMemoryStreamPool
private MemoryStream _SaveCache
public UInt32 prefabID
public bool globalBroadcast
public Networkable net
private bool <IsDestroyed>k__BackingField
private string _prefabName
private string _prefabNameWithoutExtension
public EntityRealm serverEntities
private bool isServersideEntity
public List`1<Connection> connectionsInSphereList
public bool limitNetworking
public GameManager gameManager
public Library prefabAttribute
public Group GlobalNetworkGroup
public Group LimboNetworkGroup
public bool IsDestroyed
public string PrefabName
public string ShortPrefabName
public bool isServer
public bool isClient
public void BroadcastOnPostNetworkUpdate(BaseEntity entity)
public void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool get_limitNetworking()
public void set_limitNetworking(bool value)
private void OnNetworkLimitStart()
private void OnNetworkLimitEnd()
public BaseEntity GetParentEntity()
public bool HasParent()
public void AddChild(BaseEntity child)
protected void OnChildAdded(BaseEntity child)
public void RemoveChild(BaseEntity child)
protected void OnChildRemoved(BaseEntity child)
public GameManager get_gameManager()
public Library get_prefabAttribute()
public Group get_GlobalNetworkGroup()
public Group get_LimboNetworkGroup()
public float GetNetworkTime()
public void Spawn()
public bool IsFullySpawned()
public void ServerInit()
public List`1<Connection> GetSubscribers()
public void KillMessage()
public void AdminKill()
public void Kill(DestroyMode mode)
public void TerminateOnClient(DestroyMode mode)
private void TerminateOnServer()
internal void DoServerDestroy()
public bool ShouldNetworkTo(BasePlayer player)
public void SendNetworkGroupChange()
public void SendAsSnapshot(Connection connection, bool justCreated)
public void SendNetworkUpdate(NetworkQueue queue)
public void SendNetworkUpdateImmediate(bool justCreated)
public void SendNetworkUpdate_Position()
public void ToStream(Stream stream, SaveInfo saveInfo)
public bool CanUseNetworkCache(Connection connection)
public void ToStreamForNetwork(Stream stream, SaveInfo saveInfo)
public void InvalidateNetworkCache()
public MemoryStream GetSaveCache()
public void UpdateNetworkGroup()
public bool get_IsDestroyed()
private void set_IsDestroyed(bool value)
public string get_PrefabName()
public string get_ShortPrefabName()
public Vector3 GetNetworkPosition()
public Quaternion GetNetworkRotation()
public string InvokeString()
public BaseEntity LookupPrefab()
public bool EqualNetID(BaseNetworkable other)
public bool EqualNetID(UInt32 otherID)
public void ResetState()
public void InitShared()
public void PreInitShared()
public void PostInitShared()
public void DestroyShared()
public void OnNetworkGroupEnter(Group group)
public void OnNetworkGroupLeave(Group group)
public void OnNetworkGroupChange()
public void OnNetworkSubscribersEnter(List`1<Connection> connections)
public void OnNetworkSubscribersLeave(List`1<Connection> connections)
private void EntityDestroy()
private void DoEntityDestroy()
private void SpawnShared()
public void Save(SaveInfo info)
public void PostSave(SaveInfo info)
public void InitLoad(UInt32 entityID)
public void PreServerLoad()
public void Load(LoadInfo info)
public void PostServerLoad()
public bool get_isServer()
public bool get_isClient()
public T ToServer()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public List`1<Connection> GetConnectionsWithin(Vector3 position, float distance)
public bool HasCloseConnections(Vector3 position, float distance)
private bool <OnNetworkLimitStart>b__7_0(Connection x)
}
public BaseNpc : BaseCombatEntity {
public Transform ChaseTransform
public int agentTypeIndex
public bool NewAI
private bool <IsStuck>k__BackingField
private Vector3 stepDirection
private bool <AgencyUpdateRequired>k__BackingField
private bool <IsOnOffmeshLinkAndReachedNewCoord>k__BackingField
private float maxFleeTime
private float fleeHealthThresholdPercentage
private float blockEnemyTargetingTimeout
private float blockFoodTargetingTimeout
private float aggroTimeout
private float lastAggroChanceResult
private float lastAggroChanceCalcTime
private float aggroChanceRecalcTimeout
private float eatTimeout
private float wakeUpBlockMoveTimeout
private BaseEntity blockTargetingThisEnemy
public float waterDepth
public bool swimming
public bool wasSwimming
private AnimationCurve speedFractionResponse
private bool _traversingNavMeshLink
private OffMeshLinkData _currentNavMeshLink
private string _currentNavMeshLinkName
private float _currentNavMeshLinkTraversalTime
private float _currentNavMeshLinkTraversalTimeDelta
private Quaternion _currentNavMeshLinkOrientation
private Vector3 _currentNavMeshLinkEndPos
private float nextAttackTime
public Enum topologyPreference
public AiFlags aiFlags
public Byte[] CurrentFacts
public int ForgetUnseenEntityTime
public float SensesTickRate
public BaseEntity[] SensesResults
private List`1<NavPointSample> navPointSamples
private float lastTickTime
public float playerTargetDecisionStartTime
private float animalTargetDecisionStartTime
private bool isAlreadyCheckingPathPending
private int numPathPendingAttempts
private float accumPathPendingDelay
public float TickRate
private Vector3 lastStuckPos
private float nextFlinchTime
private float _lastHeardGunshotTime
private Vector3 <LastHeardGunshotDirection>k__BackingField
private float <TargetSpeed>k__BackingField
public GameObjectRef CorpsePrefab
public AiStatistics Stats
public Vector3 AttackOffset
public float AttackDamage
public DamageType AttackDamageType
public float AttackCost
public float AttackRate
public float AttackRange
public NavMeshAgent NavAgent
private UtilityAIComponent utilityAiComponent
public LayerMask movementMask
public float stuckDuration
public float lastStuckTime
public float idleDuration
public BaseContext AiContext
private bool _isDormant
private float lastSetDestinationTime
private BaseEntity <AttackTarget>k__BackingField
private SeenInfo <AttackTargetMemory>k__BackingField
private BaseEntity <FoodTarget>k__BackingField
private Vector3 <SpawnPosition>k__BackingField
public StateTimer BusyTimer
public float Sleep
public VitalLevel Stamina
public VitalLevel Energy
public VitalLevel Hydration
private Behaviour <CurrentBehaviour>k__BackingField
public int AgentTypeIndex
public bool IsStuck
public bool AgencyUpdateRequired
public bool IsOnOffmeshLinkAndReachedNewCoord
public float GetAttackRate
public bool IsSitting
public bool IsChasing
public bool IsSleeping
private bool Apex.LoadBalancing.ILoadBalanced.repeat
public float SecondsSinceLastHeardGunshot
public Vector3 LastHeardGunshotDirection
public float TargetSpeed
public bool IsNpc
public bool IsDormant
public float SecondsSinceLastSetDestination
public float LastSetDestinationTime
public Vector3 Destination
public bool IsStopped
public bool AutoBraking
public bool HasPath
public BaseEntity AttackTarget
public SeenInfo AttackTargetMemory
public BaseEntity FoodTarget
public BaseCombatEntity CombatTarget
public Vector3 SpawnPosition
public float AttackTargetVisibleFor
public float TimeAtDestination
public BaseCombatEntity Entity
public NavMeshAgent GetNavAgent
public AiStatistics GetStats
public float GetAttackRange
public Vector3 GetAttackOffset
public float GetStamina
public float GetEnergy
public float GetAttackCost
public float GetSleep
public Vector3 CurrentAimAngles
public float GetStuckDuration
public float GetLastStuckTime
public Vector3 AttackPosition
public Vector3 CrouchedAttackPosition
public float currentBehaviorDuration
public Behaviour CurrentBehaviour
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void UpdateDestination(Vector3 position)
public void UpdateDestination(Transform tx)
public void StopMoving()
public void ApplyInheritedVelocity(Vector3 velocity)
public Vector3 GetNewNavPosWithVelocity(BaseEntity ent, Vector3 velocity)
public int get_AgentTypeIndex()
public void set_AgentTypeIndex(int value)
public bool get_IsStuck()
public void set_IsStuck(bool value)
public bool get_AgencyUpdateRequired()
public void set_AgencyUpdateRequired(bool value)
public bool get_IsOnOffmeshLinkAndReachedNewCoord()
public void set_IsOnOffmeshLinkAndReachedNewCoord(bool value)
public string DebugText()
public void TickAi()
private void TickSpeed()
protected void TickMetabolism()
public bool WantsToEat(BaseEntity best)
public float FearLevel(BaseEntity ent)
public float HateLevel(BaseEntity ent)
protected void TickSleep()
public void TickNavigationWater()
public void TickNavigation()
private void TickChase()
private void HandleNavMeshLinkTraversal(float delta, Vector3& moveToPosition)
private bool HandleNavMeshLinkTraversalStart(float delta)
private void HandleNavMeshLinkTraversalTick(float delta, Vector3& moveToPosition)
private bool IsNavMeshLinkTraversalComplete(float delta, Vector3& moveToPosition)
private void CompleteNavMeshLink()
private void TickFollowPath(Vector3& moveToPosition)
private bool ValidateNextPosition(Vector3& moveToPosition)
private void UpdatePositionAndRotation(Vector3 moveToPosition)
private void TickIdle()
public void TickStuck()
public void OnBecomeStuck()
public void OnBecomeUnStuck()
public void UpdateAiRotation()
public float get_GetAttackRate()
public bool AttackReady()
public void StartAttack()
public void StartAttack(AttackType type, BaseCombatEntity target)
public void Eat()
public void AddCalories(float amount)
public void Startled()
private bool IsAfraid()
private bool IsAfraidOf(FamilyEnum family)
private bool CheckHealthThresholdToFlee()
private void TickBehaviourState()
private void WantsToFlee()
private void TickFlee()
public bool BlockEnemyTargeting(float timeout)
private void TickBlockEnemyTargeting()
public bool BlockFoodTargeting(float timeout)
private void TickBlockFoodTargeting()
public bool TryAggro(EnemyRangeEnum range)
public bool StartAggro(float timeout)
private void TickAggro()
public bool StartEating(float timeout)
private void TickEating()
public bool WakeUpBlockMove(float timeout)
private void TickWakeUpBlockMove()
private void OnFactChanged(Facts fact, byte oldValue, byte newValue)
public int TopologyPreference()
public bool HasAiFlag(AiFlags f)
public void SetAiFlag(AiFlags f, bool set)
public bool get_IsSitting()
public void set_IsSitting(bool value)
public bool get_IsChasing()
public void set_IsChasing(bool value)
public bool get_IsSleeping()
public void set_IsSleeping(bool value)
public void InitFacts()
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public float ToSpeed(SpeedEnum speed)
public EnemyRangeEnum ToEnemyRangeEnum(float range)
public float GetActiveAggressionRangeSqr()
public FoodRangeEnum ToFoodRangeEnum(float range)
public AfraidRangeEnum ToAfraidRangeEnum(float range)
public HealthEnum ToHealthEnum(float healthNormalized)
public byte ToIsTired(float energyNormalized)
public SpeedEnum ToSpeedEnum(float speed)
public float ToSpeed(SpeedEnum speed)
public byte GetPathStatus()
public NavMeshPathStatus ToPathStatus(byte value)
private void TickSenses()
private void TickVision()
private void TickHearing()
private void TickSmell()
private void TickEnemyAwareness()
private void SelectEnemy()
private void AggroClosestEnemy()
private float DecisionMomentumPlayerTarget()
private float DecisionMomentumAnimalTarget()
private void TickFoodAwareness()
private void SelectFood()
private void SelectClosestFood()
private void UpdateSelfFacts()
private byte IsMoving()
private bool AiCaresAbout(BaseEntity ent)
private bool WithinVisionCone(BaseNpc npc, BaseEntity other)
public void SetTargetPathStatus(float pendingDelay)
private void DelayedTargetPathStatus()
public List`1<NavPointSample> RequestNavPointSamplesInCircle(SampleCount sampleCount, float radius, SampleFeatures features)
public List`1<NavPointSample> RequestNavPointSamplesInCircleWaterDepthOnly(SampleCount sampleCount, float radius, float waterDepth)
public void ServerInit()
internal void DoServerDestroy()
private bool Apex.LoadBalancing.ILoadBalanced.get_repeat()
private Nullable`1<float> Apex.LoadBalancing.ILoadBalanced.ExecuteUpdate(float deltaTime, float nextInterval)
public void Hurt(HitInfo info)
public void OnKilled(HitInfo hitInfo)
public void OnSensation(Sensation sensation)
protected void OnSenseGunshot(Sensation sensation)
public float get_SecondsSinceLastHeardGunshot()
public Vector3 get_LastHeardGunshotDirection()
public void set_LastHeardGunshotDirection(Vector3 value)
public float get_TargetSpeed()
public void set_TargetSpeed(float value)
public bool get_IsNpc()
public bool get_IsDormant()
public void set_IsDormant(bool value)
public float get_SecondsSinceLastSetDestination()
public float get_LastSetDestinationTime()
public Vector3 get_Destination()
public void set_Destination(Vector3 value)
public bool get_IsStopped()
public void set_IsStopped(bool value)
public bool get_AutoBraking()
public void set_AutoBraking(bool value)
public bool get_HasPath()
public bool IsNavRunning()
public void Pause()
public void Resume()
private IEnumerator TryForceToNavmesh()
public BaseEntity get_AttackTarget()
public void set_AttackTarget(BaseEntity value)
public SeenInfo get_AttackTargetMemory()
public void set_AttackTargetMemory(SeenInfo value)
public BaseEntity get_FoodTarget()
public void set_FoodTarget(BaseEntity value)
public BaseCombatEntity get_CombatTarget()
public Vector3 get_SpawnPosition()
public void set_SpawnPosition(Vector3 value)
public float get_AttackTargetVisibleFor()
public float get_TimeAtDestination()
public BaseCombatEntity get_Entity()
public NavMeshAgent get_GetNavAgent()
public float GetWantsToAttack(BaseEntity target)
public AiStatistics get_GetStats()
public float get_GetAttackRange()
public Vector3 get_GetAttackOffset()
public float get_GetStamina()
public float get_GetEnergy()
public float get_GetAttackCost()
public float get_GetSleep()
public Vector3 get_CurrentAimAngles()
public float get_GetStuckDuration()
public float get_GetLastStuckTime()
public bool BusyTimerActive()
public void SetBusyFor(float dur)
public Vector3 get_AttackPosition()
public Vector3 get_CrouchedAttackPosition()
internal float WantsToAttack(BaseEntity target)
protected void SetupAiContext()
public IAIContext GetContext(Guid aiId)
public float get_currentBehaviorDuration()
public Behaviour get_CurrentBehaviour()
public void set_CurrentBehaviour(Behaviour value)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float MaxVelocity()
}
public BaseNPCContext : BaseContext {
public NPCPlayerApex Human
public AiLocationManager AiLocationManager
public void .ctor(IAIAgent agent)
}
public BaseNpcDefinition : Definition`1<BaseNpcDefinition> {
public HTNDomain Domain
public InfoStats Info
public VitalStats Vitals
public MovementStats Movement
public SensoryStats Sensory
public MemoryStats Memory
public EngagementStats Engagement
public void Loadout(HTNPlayer target)
public void OnlyLoadoutWeapons(HTNPlayer target)
public void StartVoices(HTNPlayer target)
public void StopVoices(HTNPlayer target)
public BaseCorpse OnCreateCorpse(HTNPlayer target)
public void Loadout(HTNAnimal target)
public void StartVoices(HTNAnimal target)
public void StopVoices(HTNAnimal target)
public BaseCorpse OnCreateCorpse(HTNAnimal target)
}
public BaseOven : StorageContainer {
public TemperatureType temperature
public Option switchOnMenu
public Option switchOffMenu
public ItemAmount[] startupContents
public bool allowByproductCreation
public ItemDefinition fuelType
public bool canModFire
public bool disabledBySplash
private float UpdateRate
public float cookingTemperature
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void PostServerLoad()
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool bAdded)
public void OvenFull()
public Item FindBurnable()
public void Cook()
public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
private void SVSwitch(RPCMessage msg)
public float get_cookingTemperature()
public void UpdateAttachmentTemperature()
public void StartCooking()
public void StopCooking()
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public bool HasSlot(Slot slot)
}
public BasePath : MonoBehaviour {
public List`1<BasePathNode> nodes
public List`1<PathInterestNode> interestZones
public List`1<PathSpeedZone> speedZones
public void Start()
public void GetNodesNear(Vector3 point, List`1& nearNodes, float dist)
public BasePathNode GetClosestToPoint(Vector3 point)
public PathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist)
}
public BasePathNode : MonoBehaviour {
public List`1<BasePathNode> linked
public float maxVelocityOnApproach
public bool straightaway
public void OnDrawGizmosSelected()
}
public BasePlayer : BaseCombatEntity {
public bool isInAir
public bool isOnPlayer
public float violationLevel
public float lastViolationTime
public float lastAdminCheatTime
public AntiHackType lastViolationType
public float vehiclePauseTime
public float speedhackPauseTime
public float speedhackDistance
public float flyhackPauseTime
public float flyhackDistanceVertical
public float flyhackDistanceHorizontal
public TimeAverageValueLookup`1<UInt32> rpcHistory
private Byte[] CCTVBuffer
public ViewModel GestureViewModel
public float drinkRange
public float drinkMovementSpeed
private NetworkQueueList[] networkQueue
private NetworkQueueList SnapshotQueue
public string GestureCancelString
public GestureCollection gestureList
public TimeUntil gestureFinishedTime
public TimeSince blockHeldInputTimer
public GestureConfig currentGesture
public ulong currentTeam
public Phrase MaxTeamSizeToast
private bool sentInstrumentTeamAchievement
private bool sentSummerTeamAchievement
private int TEAMMATE_INSTRUMENT_COUNT_ACHIEVEMENT
private int TEAMMATE_SUMMER_FLOATING_COUNT_ACHIEVEMENT
private string TEAMMATE_INSTRUMENT_ACHIEVEMENT
private string TEAMMATE_SUMMER_ACHIEVEMENT
private BasePlayer teamLeaderBuffer
public ModelState modelState
public ModelState modelStateTick
private bool wantsSendModelState
public float nextModelStateUpdate
public EntityRef mounted
public float nextSeatSwapTime
private bool _playerStateDirty
public Dictionary`2<int, FiredProjectile> firedProjectiles
private int WILDERNESS
private int MONUMENT
private int BASE
private int FLYING
private int BOATING
private int SWIMMING
private int DRIVING
public float lifeStoryFramebudgetms
public PlayerLifeStory lifeStory
public PlayerLifeStory previousLifeStory
public float TimeCategoryUpdateFrequency
public float nextTimeCategoryUpdate
private int <currentTimeCategory>k__BackingField
private bool hasSentPresenceState
private bool LifeStoryInWilderness
private bool LifeStoryInMonument
private bool LifeStoryInBase
private bool LifeStoryFlying
private bool LifeStoryBoating
private bool LifeStorySwimming
private bool LifeStoryDriving
private bool waitingForLifeStoryUpdate
public LifeStoryWorkQueue lifeStoryQueue
public PlayerStatistics stats
public UInt32 svActiveItemID
public float NextChatTime
public float nextSuicideTime
public float nextRespawnTime
private Vector3 <estimatedVelocity>k__BackingField
private float <estimatedSpeed>k__BackingField
private float <estimatedSpeed2D>k__BackingField
private int <secondsConnected>k__BackingField
private float <desyncTimeRaw>k__BackingField
private float <desyncTimeClamped>k__BackingField
public Vector3 viewAngles
public float lastSubscriptionTick
public float lastPlayerTick
public float sleepStartTime
public float fallTickRate
public float lastFallTime
public float fallVelocity
public ListHashSet`1<BasePlayer> activePlayerList
public ListHashSet`1<BasePlayer> sleepingPlayerList
public ListHashSet`1<BasePlayer> bots
public float cachedCraftLevel
public float nextCheckTime
private Nullable`1<int> cachedAppToken
private PersistantPlayer cachedPersistantPlayer
public int SpectateOffset
public string spectateFilter
public float lastUpdateTime
public float cachedThreatLevel
public float weaponDrawnDuration
public int serverTickRateDefault
public int clientTickRateDefault
public int serverTickRate
public int clientTickRate
public float serverTickInterval
public float clientTickInterval
public InputState serverInput
public float lastTickTime
public float lastStallTime
public float lastInputTime
public PlayerTick lastReceivedTick
private float tickDeltaTime
private bool tickNeedsFinalizing
private Vector3 tickViewAngles
private TimeAverageValue ticksPerSecond
private TickInterpolator tickInterpolator
public TickHistory tickHistory
public float nextUnderwearValidationTime
public UInt32 lastValidUnderwearSkin
public float woundedDuration
public float woundedStartTime
public float lastWoundedTime
public GameObjectRef fallDamageEffect
public GameObjectRef drownEffect
public PlayerFlags playerFlags
public PlayerEyes eyes
public PlayerInventory inventory
public PlayerBlueprints blueprints
public PlayerMetabolism metabolism
public PlayerModifiers modifiers
public CapsuleCollider playerCollider
public PlayerBelt Belt
public Rigidbody playerRigidbody
public ulong userID
public string UserIDString
public int gamemodeteam
protected string _displayName
public string _lastSetName
public CapsuleColliderInfo playerColliderStanding
public CapsuleColliderInfo playerColliderDucked
public CapsuleColliderInfo playerColliderLyingDown
public ProtectionProperties cachedProtection
public float nextColliderRefreshTime
public bool clothingBlocksAiming
public float clothingMoveSpeedReduction
public float clothingWaterSpeedBonus
public float clothingAccuracyBonus
public bool equippingBlocked
public float eggVision
public PhoneController activeTelephone
public IPlayer IPlayer
public bool IsReceivingSnapshot
public bool IsAdmin
public bool IsDeveloper
public bool IsAiming
public bool IsFlying
public bool IsConnected
public bool InGesture
private bool CurrentGestureBlocksMovement
private bool InGestureCancelCooldown
public PlayerTeam Team
public MapNote ServerCurrentMapNote
public MapNote ServerCurrentDeathNote
public bool isMounted
public bool isMountingHidingWeapon
public PlayerState State
public bool hasPreviousLife
public int currentTimeCategory
public FamilyEnum Family
protected float PositionTickRate
public Vector3 estimatedVelocity
public float estimatedSpeed
public float estimatedSpeed2D
public int secondsConnected
public float desyncTimeRaw
public float desyncTimeClamped
public float secondsSleeping
public IEnumerable`1<BasePlayer> allPlayerList
public float currentCraftLevel
public float currentComfort
public float currentSafeLevel
public int appToken
public PersistantPlayer PersistantPlayerInfo
public float timeSinceLastTick
public float IdleTime
public bool isStalled
public bool wasStalled
public int tickHistoryCapacity
public Matrix4x4 tickHistoryMatrix
public float secondsSinceWoundedStarted
public Connection Connection
public string displayName
public TraitFlag Traits
public bool HasActiveTelephone
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool TriggeredAntiHack(float seconds, float score)
public bool UsedAdminCheat(float seconds)
public void PauseVehicleNoClipDetection(float seconds)
public void PauseFlyHackDetection(float seconds)
public void PauseSpeedHackDetection(float seconds)
public int GetAntiHackKicks()
public void ResetAntiHack()
public void HandleCCTVRenderComplete(RPCMessage msg)
public bool CanBeLooted(BasePlayer player)
public void RPC_LootPlayer(RPCMessage msg)
public void RPC_Assist(RPCMessage msg)
public void RPC_KeepAlive(RPCMessage msg)
private void SV_Drink(RPCMessage msg)
public void RPC_StartClimb(RPCMessage msg)
public int GetQueuedUpdateCount(NetworkQueue queue)
public void SendSnapshots(ListHashSet`1<Networkable> ents)
public void QueueUpdate(NetworkQueue queue, BaseNetworkable ent)
public void SendEntityUpdate()
public void ClearEntityQueue(Group group)
private void SendEntityUpdates(NetworkQueueList queue)
public void SendEntitySnapshot(BaseNetworkable ent)
public bool HasPlayerFlag(PlayerFlags f)
public bool get_IsReceivingSnapshot()
public bool get_IsAdmin()
public bool get_IsDeveloper()
public bool get_IsAiming()
public bool get_IsFlying()
public bool get_IsConnected()
public void SetPlayerFlag(PlayerFlags f, bool b)
public void LightToggle(bool mask)
public bool get_InGesture()
private bool get_CurrentGestureBlocksMovement()
private bool get_InGestureCancelCooldown()
public void Server_StartGesture(RPCMessage msg)
public void Server_StartGesture(GestureConfig toPlay)
private void TimeoutGestureServer()
private void Server_CancelGesture(RPCMessage msg)
private bool IsGestureBlocked()
public PlayerTeam get_Team()
public void DelayedTeamUpdate()
public void TeamUpdate()
public void UpdateTeam(ulong newTeam)
public void ClearTeam()
public void ClearPendingInvite()
public HeldEntity GetHeldEntity()
public bool IsHoldingEntity()
public bool IsHostileItem(Item item)
public bool IsItemHoldRestricted(Item item)
public MapNote get_ServerCurrentMapNote()
public void set_ServerCurrentMapNote(MapNote value)
public MapNote get_ServerCurrentDeathNote()
public void set_ServerCurrentDeathNote(MapNote value)
public void Server_LogDeathMarker(Vector3 position)
public void Server_AddMarker(RPCMessage msg)
public void Server_RemovePointOfInterest(RPCMessage msg)
public void Server_RequestMarkers(RPCMessage msg)
public void Server_ClearMapMarkers(RPCMessage msg)
public void SendMarkersToClient()
private void UpdateModelState()
private void SendModelState()
public bool get_isMounted()
public bool get_isMountingHidingWeapon()
public BaseMountable GetMounted()
public BaseVehicle GetMountedVehicle()
public void MarkSwapSeat()
public bool SwapSeatCooldown()
public void MountObject(BaseMountable mount, int desiredSeat)
public void EnsureDismounted()
public void DismountObject()
public void HandleMountedOnLoad()
public PlayerState get_State()
public void DirtyPlayerState()
public void SavePlayerState()
public void ResetPlayerState()
public bool IsSleeping()
public bool IsSpectating()
public bool IsRelaxed()
public bool IsServerFalling()
public bool CanBuild()
public bool CanBuild(Vector3 position, Quaternion rotation, Bounds bounds)
public bool CanBuild(OBB obb)
public bool IsBuildingBlocked()
public bool IsBuildingBlocked(Vector3 position, Quaternion rotation, Bounds bounds)
public bool IsBuildingBlocked(OBB obb)
public bool IsBuildingAuthed()
public bool IsBuildingAuthed(Vector3 position, Quaternion rotation, Bounds bounds)
public bool IsBuildingAuthed(OBB obb)
public bool CanPlaceBuildingPrivilege()
public bool CanPlaceBuildingPrivilege(Vector3 position, Quaternion rotation, Bounds bounds)
public bool CanPlaceBuildingPrivilege(OBB obb)
public bool IsNearEnemyBase()
public bool IsNearEnemyBase(Vector3 position, Quaternion rotation, Bounds bounds)
public bool IsNearEnemyBase(OBB obb)
public void OnProjectileAttack(RPCMessage msg)
public void OnProjectileRicochet(RPCMessage msg)
public void OnProjectileUpdate(RPCMessage msg)
private void SimulateProjectile(Vector3& position, Vector3& velocity, Single& partialTime, float travelTime, Vector3 gravity, float drag, Vector3& prevPosition, Vector3& prevVelocity)
protected void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
public void CleanupExpiredProjectiles()
public bool HasFiredProjectile(int id)
public void NoteFiredProjectile(int projectileid, Vector3 startPos, Vector3 startVel, AttackEntity attackEnt, ItemDefinition firedItemDef, Item pickupItem)
public void ServerNoteFiredProjectile(int projectileid, Vector3 startPos, Vector3 startVel, AttackEntity attackEnt, ItemDefinition firedItemDef, Item pickupItem)
public bool CanUseNetworkCache(Connection connection)
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool get_hasPreviousLife()
public int get_currentTimeCategory()
private void set_currentTimeCategory(int value)
internal void LifeStoryStart()
public void LifeStoryEnd()
internal void LifeStoryUpdate(float deltaTime, float moveSpeed)
public void UpdateTimeCategory()
public void LifeStoryShotFired(BaseEntity withWeapon)
public void LifeStoryShotHit(BaseEntity withWeapon)
public void LifeStoryKill(BaseCombatEntity killed)
public void LifeStoryGenericStat(string key, int value)
public void LifeStoryHurt(float amount)
public void LifeStoryHeal(float amount)
internal void LifeStoryLogDeath(HitInfo deathBlow, DamageType lastDamage)
public FamilyEnum get_Family()
protected float get_PositionTickRate()
internal void OnParentRemoved()
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
private void TransformState(Matrix4x4 matrix)
public bool CanSuicide()
public void MarkSuicide()
public bool CanRespawn()
public void MarkRespawn()
public Item GetActiveItem()
public void MovePosition(Vector3 newPos)
public Vector3 get_estimatedVelocity()
private void set_estimatedVelocity(Vector3 value)
public float get_estimatedSpeed()
private void set_estimatedSpeed(float value)
public float get_estimatedSpeed2D()
private void set_estimatedSpeed2D(float value)
public int get_secondsConnected()
private void set_secondsConnected(int value)
public float get_desyncTimeRaw()
private void set_desyncTimeRaw(float value)
public float get_desyncTimeClamped()
private void set_desyncTimeClamped(float value)
public void OverrideViewAngles(Vector3 newAng)
public void ServerInit()
internal void DoServerDestroy()
protected void ServerUpdate(float deltaTime)
private void ServerUpdateBots(float deltaTime)
private void ConnectedPlayerUpdate(float deltaTime)
private void EnterGame()
private void ClientKeepConnectionAlive(RPCMessage msg)
private void ClientLoadingComplete(RPCMessage msg)
public void PlayerInit(Connection c)
public void StatSave()
public void SendDeathInformation()
public void SendRespawnOptions()
private void RequestRespawnInformation(RPCMessage msg)
public float get_secondsSleeping()
public void ScheduledDeath()
public void StartSleeping()
private void TurnOffAllLights()
private void OnPhysicsNeighbourChanged()
private void DelayedServerFall()
public void EnableServerFall(bool wantsOn)
public void ServerFall()
public void DelayedRigidbodyDisable()
public void EndSleeping()
public void EndLooting()
public void OnDisconnected()
private void InventoryUpdate()
public void ApplyFallDamageFromVelocity(float velocity)
private void OnPlayerLanded(RPCMessage msg)
public void SendGlobalSnapshot()
public void SendFullSnapshot()
public void OnNetworkGroupLeave(Group group)
private void LeaveVisibility(Group group)
public void OnNetworkGroupEnter(Group group)
private void EnterVisibility(Group group)
public void CheckDeathCondition(HitInfo info)
public BaseCorpse CreateCorpse()
public void OnKilled(HitInfo info)
public void RespawnAt(Vector3 position, Quaternion rotation)
public void Respawn()
public bool IsImmortal()
public float TimeAlive()
public void Hurt(HitInfo info)
public IEnumerable`1<BasePlayer> get_allPlayerList()
public BasePlayer FindBot(ulong userId)
public BasePlayer FindBotClosestMatch(string name)
public BasePlayer FindByID(ulong userID)
public bool TryFindByID(ulong userID, BasePlayer& basePlayer)
public BasePlayer FindSleeping(ulong userID)
public void Command(string strCommand, Object[] arguments)
public void OnInvalidPosition()
public BasePlayer Find(string strNameOrIDOrIP, IEnumerable`1<BasePlayer> list)
public BasePlayer Find(string strNameOrIDOrIP)
public BasePlayer FindSleeping(string strNameOrIDOrIP)
public BasePlayer FindAwakeOrSleeping(string strNameOrIDOrIP)
public void SendConsoleCommand(string command, Object[] obj)
public void UpdateRadiation(float fAmount)
public float RadiationExposureFraction()
public float RadiationProtection()
public void OnHealthChanged(float oldvalue, float newvalue)
public void SV_ClothingChanged()
public bool IsNoob()
public bool HasHostileItem()
public void GiveItem(Item item, GiveItemReason reason)
public void AttackerInfo(DeathInfo info)
public float get_currentCraftLevel()
public float get_currentComfort()
public float get_currentSafeLevel()
public bool ShouldDropActiveItem()
public void Die(HitInfo info)
public void Kick(string reason)
public Vector3 GetDropPosition()
public Vector3 GetDropVelocity()
public void ApplyInheritedVelocity(Vector3 velocity)
public void SetInfo(string key, string val)
public int GetInfoInt(string key, int defaultVal)
public void PerformanceReport(RPCMessage msg)
public bool ShouldNetworkTo(BasePlayer player)
internal void GiveAchievement(string name)
public void OnPlayerReported(RPCMessage msg)
public int get_appToken()
public void StartDemoRecording()
public void StopDemoRecording()
public void MonitorDemoRecording()
public PersistantPlayer get_PersistantPlayerInfo()
public void set_PersistantPlayerInfo(PersistantPlayer value)
private void Tick_Spectator()
public void UpdateSpectateTarget(string strName)
public void StartSpectating()
public void StopSpectating()
public void Teleport(BasePlayer player)
public void Teleport(string strName, bool playersOnly)
public void Teleport(Vector3 position)
public void CopyRotation(BasePlayer player)
public float GetThreatLevel()
public void EnsureUpdated()
public bool IsHostile()
public float GetHostileDuration()
public void MarkHostileFor(float duration)
public void MarkWeaponDrawnDuration(float newDuration)
public void AddWeaponDrawnDuration(float duration)
public float get_timeSinceLastTick()
public float get_IdleTime()
public bool get_isStalled()
public bool get_wasStalled()
public void OnReceivedTick(Stream stream)
public void OnReceivedVoice(Byte[] data)
public void ResetInputIdleTime()
private void EACStateUpdate()
private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
public void UpdateActiveItem(UInt32 itemID)
internal void UpdateModelStateFromTick(PlayerTick tick)
internal void UpdatePositionFromTick(PlayerTick tick, bool wasPlayerStalled)
internal void UpdateRotationFromTick(PlayerTick tick)
public void UpdateEstimatedVelocity(Vector3 lastPos, Vector3 currentPos, float deltaTime)
public int get_tickHistoryCapacity()
public Matrix4x4 get_tickHistoryMatrix()
private void FinalizeTick(float deltaTime)
public UInt32 GetUnderwearSkin()
public void ServerRPC_UnderwearChange(RPCMessage msg)
public bool IsWounded()
public float get_secondsSinceWoundedStarted()
private bool WoundInsteadOfDying(HitInfo info)
public bool EligibleForWounding(HitInfo info)
public void StartWounded(BasePlayer source, HitInfo info)
public void StopWounded(BasePlayer source)
public void ProlongWounding(float delay)
private void WoundingTick()
private void RecoverFromWounded()
private bool WoundingCausingImmportality()
public BasePlayer ToPlayer()
public Connection get_Connection()
public string get_displayName()
public void set_displayName(string value)
public bool IsGod()
public Quaternion GetNetworkRotation()
public bool CanInteract()
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public float MaxVelocity()
public Vector3 GetInheritedProjectileVelocity()
public Vector3 GetInheritedThrowVelocity()
public Vector3 GetInheritedDropVelocity()
public void PreInitShared()
public void DestroyShared()
public void ServerCycle(float deltaTime)
public bool InSafeZone()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public Bounds GetBounds(bool ducked)
public Bounds GetBounds()
public Vector3 GetCenter(bool ducked)
public Vector3 GetCenter()
public Vector3 GetOffset(bool ducked)
public Vector3 GetOffset()
public Vector3 GetSize(bool ducked)
public Vector3 GetSize()
public float GetHeight(bool ducked)
public float GetHeight()
public float GetRadius()
public float GetJumpHeight()
public Vector3 TriggerPoint()
public float MaxDeployDistance(Item item)
public float GetMinSpeed()
public float GetMaxSpeed()
public float GetSpeed(float running, float ducking)
public void OnAttacked(HitInfo info)
public void EnablePlayerCollider()
public void DisablePlayerCollider()
public void RefreshColliderSize(bool forced)
private void SetPlayerRigidbodyState(bool isEnabled)
public void AddPlayerRigidbody()
public void RemovePlayerRigidbody()
public bool IsEnsnared()
public bool IsAttacking()
public bool CanAttack()
public bool OnLadder()
public bool IsSwimming()
public bool IsHeadUnderwater()
public bool IsOnGround()
public bool IsRunning()
public bool IsDucked()
public void ShowToast(int style, Phrase phrase)
public void ChatMessage(string msg)
public void ConsoleMessage(string msg)
public float PenetrationResistance(HitInfo info)
public void ScaleDamage(HitInfo info)
private void UpdateMoveSpeedFromClothing()
public void UpdateProtectionFromClothing()
public string Categorize()
public string ToString()
public string GetDebugStatus()
public Item GetItem(UInt32 itemId)
public TraitFlag get_Traits()
public float WaterFactor()
public bool ShouldInheritNetworkGroup()
public bool AnyPlayersVisibleToEntity(Vector3 pos, float radius, BaseEntity source, Vector3 entityEyePos, bool ignorePlayersWithPriv)
public bool IsStandingOnEntity(BaseEntity standingOn, int layerMask)
public void SetActiveTelephone(PhoneController t)
public bool get_HasActiveTelephone()
private bool <UpdateSpectateTarget>b__363_1(BaseNetworkable x)
private bool <UpdateSpectateTarget>b__363_3(BasePlayer x)
private bool <UpdateSpectateTarget>b__363_4(BasePlayer x)
}
public BasePrefab : BaseMonoBehaviour {
public UInt32 prefabID
public bool isClient
public bool isServer
public bool get_isServer()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BaseProjectile : AttackEntity {
public float NoiseRadius
public float damageScale
public float distanceScale
public float projectileVelocityScale
public bool automatic
public bool usableByTurret
public float turretDamageScale
public GameObjectRef attackFX
public GameObjectRef silencedAttack
public GameObjectRef muzzleBrakeAttack
public Transform MuzzlePoint
public float reloadTime
public bool canUnloadAmmo
public Magazine primaryMagazine
public bool fractionalReload
public float reloadStartDuration
public float reloadFractionDuration
public float reloadEndDuration
public float aimSway
public float aimSwaySpeed
public RecoilProperties recoil
public AnimationCurve aimconeCurve
public float aimCone
public float hipAimCone
public float aimconePenaltyPerShot
public float aimConePenaltyMax
public float aimconePenaltyRecoverTime
public float aimconePenaltyRecoverDelay
public float stancePenaltyScale
public bool hasADS
public bool noAimingWhileCycling
public bool manualCycle
protected bool needsCycle
protected bool isCycling
public bool aiming
public float resetDuration
public int numShotsFired
private float nextReloadTime
private float startReloadTime
private float lastReloadTime
private float stancePenalty
private float aimconePenalty
protected bool reloadStarted
protected bool reloadFinished
private int fractionalInsertCounter
private Effect reusableInstance
public bool isSemiAuto
public bool IsUsableByTurret
public Transform MuzzleTransform
protected bool CanRefundAmmo
protected ItemDefinition PrimaryMagazineAmmo
private bool UsingInfiniteAmmoCheat
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 GetInheritedVelocity(BasePlayer player)
public float GetDamageScale(bool getMax)
public float GetDistanceScale(bool getMax)
public float GetProjectileVelocityScale(bool getMax)
protected void StartReloadCooldown(float cooldown)
protected void ResetReloadCooldown()
protected bool HasReloadCooldown()
protected float GetReloadCooldown()
protected float GetReloadIdle()
private void OnDrawGizmos()
public RecoilProperties GetRecoil()
public bool get_isSemiAuto()
public bool get_IsUsableByTurret()
public Transform get_MuzzleTransform()
public void DidAttackServerside()
public bool ServerIsReloading()
public bool CanReload()
public float AmmoFraction()
public void TopUpAmmo()
public void ServerReload()
public Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier)
public float GetAIAimcone()
public void ServerUse()
public void ServerUse(float damageModifier, Transform originOverride)
private void AssignInitiator(HitInfo info)
public void ServerInit()
public void ServerCommand(Item item, string command, BasePlayer player)
public void UnloadAmmo(Item item, BasePlayer player)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
public void SetLightsOn(bool isOn)
public bool CanAiAttack()
public float GetAimCone()
public float ScaleRepeatDelay(float delay)
public Modifier GetProjectileModifier()
public float GetReloadDuration()
public int GetAvailableAmmo()
protected void ReloadMagazine(int desiredAmount)
private void SwitchAmmoTo(RPCMessage msg)
public void OnHeldChanged()
private void StartReload(RPCMessage msg)
protected bool get_CanRefundAmmo()
private void ServerFractionalReloadInsert(RPCMessage msg)
private void Reload(RPCMessage msg)
private void CLProject(RPCMessage msg)
protected ItemDefinition get_PrimaryMagazineAmmo()
public void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced, bool forceClientsideEffects)
public void UpdateItemCondition()
public bool IsSilenced()
private bool get_UsingInfiniteAmmoCheat()
public bool CanUseNetworkCache(Connection sendingTo)
public void Save(SaveInfo info)
public bool ForceSendMagazine()
public void Load(LoadInfo info)
}
public BaseResourceExtractor : BaseCombatEntity {
public bool canExtractLiquid
public bool canExtractSolid
public void ServerInit()
}
public BaseRidableAnimal : BaseVehicle {
public ItemDefinition onlyAllowedItem
public ContentsType allowedContents
public int maxStackSize
public int numSlots
public string lootPanelName
public bool needsBuildingPrivilegeToUse
public bool isLootable
public ItemContainer inventory
public Flags Flag_ForSale
private Vector3 lastMoveDirection
public GameObjectRef saddlePrefab
public EntityRef saddleRef
public Transform movementLOSOrigin
public SoundPlayer sprintSounds
public SoundPlayer largeWhinny
public Flags Flag_Lead
public Flags Flag_HasRider
public ItemDefinition purchaseToken
public GameObjectRef eatEffect
public GameObjectRef CorpsePrefab
public Transform animalFront
public float obstacleDetectionRadius
public float maxWaterDepth
public float roadSpeedBonus
public float maxWallClimbSlope
public float maxStepHeight
public float maxStepDownHeight
public RunState currentRunState
public float walkSpeed
public float trotSpeed
public float runSpeed
public float turnSpeed
public float maxSpeed
public Transform[] groundSampleOffsets
public ItemDefinition Dung
public float CaloriesToDigestPerHour
public float DungProducedPerCalorie
private float pendingDungCalories
private float dungProduction
public float staminaSeconds
public float currentMaxStaminaSeconds
public float maxStaminaSeconds
public float staminaCoreLossRatio
public float staminaCoreSpeedBonus
public float staminaReplenishRatioMoving
public float staminaReplenishRatioStanding
public float calorieToStaminaRatio
public float hydrationToStaminaRatio
public float maxStaminaCoreFromWater
public bool debugMovement
private float normalOffsetDist
private Vector3[] normalOffsets
public float decayminutes
public float currentSpeed
public float desiredRotation
public float animalPitchClamp
public float animalRollClamp
public Queue`1<BaseRidableAnimal> _processQueue
public float framebudgetms
public float dungTimeScale
private BaseEntity leadTarget
public float nextDecayTime
private float lastMovementUpdateTime
private bool inQueue
protected float nextEatTime
public float lastEatTime
public float lastInputTime
private float forwardHeldSeconds
private float backwardHeldSeconds
private float sprintHeldSeconds
private float lastSprintPressedTime
private float lastForwardPressedTime
private float lastBackwardPressedTime
private float timeInMoveState
protected bool onIdealTerrain
private float nextIdealTerrainCheckTime
private float nextStandTime
private InputState aiInputState
public Vector3 currentVelocity
private Vector3 averagedUp
private float nextGroundNormalUpdateTime
private Vector3 targetUp
private float nextObstacleCheckTime
private float cachedObstacleDistance
private int maxObstacleCheckSpeed
private float timeAlive
private TimeUntil dropUntilTime
public bool IsNpc
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsForSale()
public void ContainerServerInit()
public void CreateInventory(bool giveUID)
public void SaveContainer(SaveInfo info)
public void OnInventoryFirstCreated(ItemContainer container)
public void OnInventoryDirty()
public void OnItemAddedOrRemoved(Item item, bool added)
public bool ItemFilter(Item item, int targetSlot)
public bool CanAnimalAcceptItem(Item item, int targetSlot)
private void RPC_OpenLoot(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
public bool CanOpenStorage(BasePlayer player)
public void LoadContainer(LoadInfo info)
public float GetBreathingDelay()
public bool IsLeading()
public float UnitsToKPH(float unitsPerSecond)
public bool get_IsNpc()
public void ProcessQueue()
public void SetLeading(BaseEntity newLeadTarget)
public float GetNetworkTime()
public void Save(SaveInfo info)
private void OnPhysicsNeighbourChanged()
public void DelayedDropToGround()
public void Load(LoadInfo info)
public void AttemptMount(BasePlayer player, bool doMountChecks)
public void LeadingChanged()
public void RPC_Claim(RPCMessage msg)
public void RPC_Lead(RPCMessage msg)
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void SetDecayActive(bool isActive)
public float TimeUntilNextDecay()
public void AddDecayDelay(float amount)
public void Hurt(HitInfo info)
public void AnimalDecay()
public void UseStamina(float amount)
public bool CanInitiateSprint()
public bool CanSprint()
public void ReplenishStamina(float amount)
public float ReplenishRatio()
public void ReplenishStaminaCore(float calories, float hydration)
public void UpdateStamina(float delta)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void DismountHeavyPlayers()
public BaseMountable GetSaddle()
public void BudgetedUpdate()
public void ApplyDungCalories(float calories)
private void UpdateDung(float delta)
private void DoDung()
public void FixedUpdate()
public float StaminaCoreFraction()
public void DoEatEvent()
public void ReplenishFromFood(ItemModConsumable consumable)
public void EatNearbyFood()
public void SwitchMoveState(RunState newState)
public void UpdateOnIdealTerrain()
public float MoveStateToVelocity(RunState stateToCheck)
public float GetDesiredVelocity()
public RunState StateFromSpeed(float speedToUse)
public void ModifyRunState(int dir)
public bool CanStand()
public void DoDebugMovement()
public void RiderInput(InputState inputState, BasePlayer player)
public float MaxVelocity()
private float NormalizeAngle(float angle)
public void UpdateGroundNormal(bool force)
public void MarkObstacleDistanceDirty()
public float GetObstacleDistance()
public float ObstacleDistanceCheck(float speed)
public void MarkDistanceTravelled(float amount)
public void UpdateMovement(float delta)
public bool DropToGround(Vector3 targetPos, bool force)
public void DoNetworkUpdate()
public void PreServerLoad()
public void ServerInit()
public void OnKilled(HitInfo hitInfo)
public void SetupCorpse(BaseCorpse corpse)
public Vector3 GetLocalVelocityServer()
public void UpdateDropToGroundForDuration(float duration)
public bool PlayerHasToken(BasePlayer player)
public Item GetPurchaseToken(BasePlayer player)
public float GetWalkSpeed()
public float GetTrotSpeed()
public float GetRunSpeed()
public bool IsPlayerTooHeavy(BasePlayer player)
}
public BaseSaddle : BaseMountable {
public BaseRidableAnimal animal
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void SetAnimal(BaseRidableAnimal newAnimal)
}
public BaseScreenShake : MonoBehaviour {
public List`1<BaseScreenShake> list
public float length
internal float timeTaken
private int currentFrame
public void Apply(Camera cam, BaseViewModel vm)
protected void OnEnable()
protected void OnDisable()
public void Run(CachedTransform`1& cam, CachedTransform`1& vm)
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public BaseScriptableObject : ScriptableObject {
public UInt32 FilenameStringId
public string LookupFileName()
public bool op_Equality(BaseScriptableObject a, BaseScriptableObject b)
public bool op_Inequality(BaseScriptableObject a, BaseScriptableObject b)
public int GetHashCode()
public bool Equals(object o)
}
public BaseSpawnPoint : MonoBehaviour {
public void GetLocation(Vector3& pos, Quaternion& rot)
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
public bool IsAvailableTo(GameObjectRef prefabRef)
protected void DropToGround(Vector3& pos, Quaternion& rot)
}
public BaseTrain : BaseVehicle {
public StaticCollisionState staticCollidingAtFront
public StaticCollisionState staticCollidingAtRear
private float MIN_COLLISION_FORCE
public float nextCollisionFXTime
private float MIN_TIME_BETWEEN_COLLISION_FX
public Dictionary`2<Rigidbody, float> prevTrackSpeeds
private float <TrackSpeed>k__BackingField
private float <FrontWheelSplineDist>k__BackingField
protected bool trainDebug
private TrainTrackSpline _frontTrackSection
private TrainTrackSpline <RearTrackSection>k__BackingField
public float lastMovingTime
private float SLEEP_SPEED
private float SLEEP_DELAY
public float distFrontToBackWheel
public float initialSpawnTime
public float corpseSeconds
public TriggerTrainCollisions frontCollisionTrigger
public TriggerTrainCollisions rearCollisionTrigger
public float impactEnergyFraction
public float collisionDamageDivide
public float derailCollisionForce
public GameObjectRef collisionEffect
public TriggerHurtNotChild hurtTriggerFront
public TriggerHurtNotChild hurtTriggerRear
public float hurtTriggerMinSpeed
public CapsuleCollider frontWheelWorldCol
public CapsuleCollider rearWheelWorldCol
public Transform centreOfMassTransform
public TrackSelection curTrackSelection
public float TrackSpeed
public Vector3 Position
public float FrontWheelSplineDist
public TrainTrackSpline FrontTrackSection
public TrainTrackSpline RearTrackSection
public bool IsAtAStation
public bool RecentlySpawned
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ReduceSpeedBy(float velChange)
public float GetTotalPushingForces(Vector3 pushDirection, List`1<BaseTrain> prevTrains)
public void FreeStaticCollision()
public float ApplyCollisionsToTrackSpeed(float trackSpeed, float deltaTime)
public float ApplyCollisions(float trackSpeed, bool atOurFront, TriggerTrainCollisions trigger, StaticCollisionState& wasStaticColliding, float deltaTime)
public float HandleStaticCollisions(bool staticColliding, bool front, float trackSpeed, StaticCollisionState& wasStaticColliding)
public float HandleTrainCollision(bool front, float trackSpeed, BaseTrain theirTrain, float deltaTime, StaticCollisionState& wasStaticColliding)
public float HandleRigidbodyCollision(bool atOurFront, float trackSpeed, Rigidbody theirRB, float theirTotalMass, float deltaTime, bool calcSecondaryForces)
public float ApplyCollisionDamage(float forceMagnitude)
public bool HasAnyCollisions()
public float GetTotalPushingMass(Vector3 pushDirection, List`1<BaseTrain> prevTrains)
public float get_TrackSpeed()
public void set_TrackSpeed(float value)
public Vector3 get_Position()
public float get_FrontWheelSplineDist()
private void set_FrontWheelSplineDist(float value)
public TrainTrackSpline get_FrontTrackSection()
public void set_FrontTrackSection(TrainTrackSpline value)
public TrainTrackSpline get_RearTrackSection()
public void set_RearTrackSection(TrainTrackSpline value)
public bool get_IsAtAStation()
public bool get_RecentlySpawned()
public void ServerInit()
public void PostServerLoad()
public void Spawn()
public void Hurt(HitInfo info)
public void OnKilled(HitInfo info)
public void ActualDeath()
public void DoRepair(BasePlayer player)
public float GetPlayerDamageMultiplier()
public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
public void DoServerDestroy()
public bool MountEligable(BasePlayer player)
public float MaxVelocity()
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public void VehicleFixedUpdate()
public float FixedUpdateMoveTrain(float deltaTime)
public Vector3 GetFrontOfTrainPos()
public Vector3 GetRearOfTrainPos()
public Vector3 GetFrontWheelPos()
public Vector3 GetRearWheelPos()
public float FixedUpdateTrainOnTrack(float deltaTime)
public void SetTheRestFromFrontWheelData(TrainTrackSpline frontTS, Vector3 targetFrontWheelPos)
public float GetEngineForces()
public bool CustomCollision(BaseTrain train, TriggerTrainCollisions trainTrigger)
public float InheritedVelocityScale()
public void SetTrackSelection(TrackSelection trackSelection)
}
public BaseTrap : DecayEntity {
public void ObjectEntered(GameObject obj)
public void Arm()
public void OnEmpty()
}
public BaseTrapTrigger : TriggerBase {
public BaseTrap _trap
public GameObject InterestedInObject(GameObject obj)
internal void OnObjectAdded(GameObject obj, Collider col)
public void OnEmpty()
}
public BaseVehicle : BaseMountable {
public bool mountChaining
public bool shouldShowHudHealth
public Rigidbody rigidBody
public List`1<MountPointInfo> mountPoints
public bool doClippingAndVisChecks
public DamageRenderer damageRenderer
public Flags Flag_OnlyOwnerEntry
public Flags Flag_Headlights
public Flags Flag_Stationary
private float MIN_TIME_BETWEEN_PUSHES
public TimeSince timeSinceLastPush
public bool continuousClippingCheck
public Queue`1<BasePlayer> recentDrivers
public Action clearRecentDriverAction
public float safeAreaRadius
public Vector3 safeAreaOrigin
public float spawnTime
public float RealisticMass
protected bool PositionTickFixedTime
protected bool CanSwapSeats
protected bool RecentlyPushed
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsStationary()
public bool IsMoving()
public float get_RealisticMass()
public bool CanPushNow(BasePlayer pusher)
public void OnAttacked(HitInfo info)
public void PostServerLoad()
public float GetNetworkTime()
protected bool get_PositionTickFixedTime()
public bool HasAnyPassengers()
public void VehicleFixedUpdate()
public int StartingFuelUnits()
public bool InSafeZone()
public bool IsSeatVisible(BaseMountable mountable, Vector3 eyePos, int mask)
public bool IsSeatClipping(BaseMountable mountable, int mask)
public void CheckSeatsForClipping()
public void SeatClippedWorld(BaseMountable mountable)
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void DismountAllPlayers()
public void ServerInit()
public void SpawnSubEntities()
public void Spawn()
public bool AnyMounted()
public int NumMounted()
public bool HasDriver()
public bool IsDriver(BasePlayer player)
public BasePlayer GetDriver()
public void GetDrivers(List`1<BasePlayer> drivers)
public BasePlayer GetPlayerDamageInitiator()
public int GetPlayerSeat(BasePlayer player)
public MountPointInfo GetPlayerSeatInfo(BasePlayer player)
protected bool get_CanSwapSeats()
public void SwapSeats(BasePlayer player, int targetSeat)
public bool HasMountPoints()
public bool HasDriverMountPoints()
public bool OnlyOwnerAccessible()
public bool IsDespawnEligable()
public void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius)
public void ClearOwnerEntry()
public EntityFuelSystem GetFuelSystem()
public bool IsSafe()
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public BaseMountable GetIdealMountPoint(Vector3 eyePos, Vector3 pos, BasePlayer playerFor)
public bool IsMounted()
public bool MountEligable(BasePlayer player)
public int GetIndexFromSeat(BaseMountable seat)
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public void PrePlayerDismount(BasePlayer player, BaseMountable seat)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void ClearRecentDriver()
public void AttemptMount(BasePlayer player, bool doMountChecks)
public BaseMountable GetIdealMountPointFor(BasePlayer player)
public bool GetDismountPosition(BasePlayer player, Vector3& res)
public BaseEntity AddMountPoint(MountPointInfo newMountPoint, Model model)
public void RemoveMountPoint(MountPointInfo mountPoint)
public BaseMountable SpawnMountPoint(MountPointInfo mountToSpawn, Model model)
public void RPC_WantsPush(RPCMessage msg)
protected void DoPushAction(BasePlayer player)
protected bool get_RecentlyPushed()
public bool SupportsChildDeployables()
public bool IsFlipped()
}
public BaseVehicleModule : BaseCombatEntity {
public Item AssociatedItemInstance
private bool <PropagateDamage>k__BackingField
private TimeSince timeSinceItemLockRefresh
private float TIME_BETWEEN_LOCK_REFRESH
private Transform centreOfMassTransform
private float mass
public VisualGroup visualGroup
private VehicleLight[] lights
private BaseModularVehicle <Vehicle>k__BackingField
private int <FirstSocketIndex>k__BackingField
public LODLevel[] lodRenderers
private List`1<ConditionalObject> conditionals
private TriggerParent[] triggerParents
private VehicleModuleSlidingComponent[] slidingComponents
private VehicleModuleButtonComponent[] buttonComponents
private DamageRenderer damageRenderer
private TimeSince TimeSinceAddedToVehicle
private float prevRefreshHealth
private bool prevRefreshVehicleIsDead
private bool prevRefreshVehicleIsLockable
public bool PropagateDamage
public BaseModularVehicle Vehicle
public int FirstSocketIndex
public Vector3 CentreOfMass
public float Mass
public UInt32 ID
public bool IsOnAVehicle
public ItemDefinition AssociatedItemDef
public bool HasSeating
public bool HasAnEngine
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsValidSAMTarget()
public bool get_PropagateDamage()
private void set_PropagateDamage(bool value)
public void NonUserSpawn()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void VehicleFixedUpdate(bool vehicleIsActive)
public void Hurt(HitInfo info)
public void OnHealthChanged(float oldValue, float newValue)
public bool CanBeMovedNow()
protected bool CanBeMovedNowOnVehicle()
public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
public void AcceptPropagatedDamage(float amount, DamageType type, BaseEntity attacker, bool useProtection)
public void AdminFixUp(int tier)
public void RPC_Use(RPCMessage msg)
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public void AdminKill()
public void OnPlayerDismountedVehicle(BasePlayer player)
public void Save(SaveInfo info)
public BaseModularVehicle get_Vehicle()
private void set_Vehicle(BaseModularVehicle value)
public int get_FirstSocketIndex()
private void set_FirstSocketIndex(int value)
public Vector3 get_CentreOfMass()
public float get_Mass()
public UInt32 get_ID()
public bool get_IsOnAVehicle()
public ItemDefinition get_AssociatedItemDef()
public bool get_HasSeating()
public bool get_HasAnEngine()
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void RefreshParameters()
public void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
public void ModuleRemoved()
public void OtherVehicleModulesChanged()
public void OnEngineStateChanged(EngineState oldState, EngineState newState)
public float MaxHealth()
public float StartHealth()
public int GetNumSocketsTaken()
public List`1<ConditionalObject> GetConditionals()
public float GetMaxDriveForce()
public void RefreshConditionals(bool canGib)
private void RefreshConditional(ConditionalObject conditional, bool canGib)
private bool TryGetAdjacentModuleInFront(BaseVehicleModule& result)
private bool TryGetAdjacentModuleBehind(BaseVehicleModule& result)
private bool InSameVisualGroupAs(BaseVehicleModule moduleEntity, AdjacentMatchType matchType)
private bool CanBeUsedNowBy(BasePlayer player)
public bool PlayerIsLookingAtUsable(string lookingAtColldierName, string usableColliderName)
public void Load(LoadInfo info)
}
public BaseVehicleMountPoint : BaseMountable {
public bool DirectlyMountable()
public BaseVehicle GetVehicleParent()
public float WaterFactorForPlayer(BasePlayer player)
}
public BaseVehicleSeat : BaseVehicleMountPoint {
public float mountedAnimationSpeed
public bool sendClientInputToVehicleParent
public bool forcePlayerModelUpdate
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void LightToggle(BasePlayer player)
public float GetSteering(BasePlayer player)
public void SwitchParent(BaseEntity ent)
}
public BaseViewModel : MonoBehaviour {
public LazyAimProperties lazyaimRegular
public LazyAimProperties lazyaimIronsights
public Transform pivot
public bool useViewModelCamera
public bool wantsHeldItemFlags
public GameObject[] hideSightMeshes
public Transform MuzzlePoint
public SubsurfaceProfile subsurfaceProfile
}
public BasicCar : BaseVehicle {
public VehicleWheel[] wheels
public float brakePedal
public float gasPedal
public float steering
public Transform centerOfMass
public Transform steeringWheel
public float motorForceConstant
public float brakeForceConstant
public float GasLerpTime
public float SteeringLerpTime
public Transform driverEye
public GameObjectRef chairRef
public Transform chairAnchorTest
public SoundPlayer idleLoopPlayer
public Transform engineOffset
public SoundDefinition engineSoundDef
private bool chairtest
public float throttle
public float brake
public bool lightsOn
public float MaxVelocity()
public Vector3 EyePositionForPlayer(BasePlayer player, Quaternion viewRot)
public float GetComfort()
public void ServerInit()
public void SpawnChairTest()
protected void VehicleFixedUpdate()
public void DoSteering()
public void ConvertInputToThrottle()
public void ApplyForceAtWheels()
public void NoDriverInput()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void DriverInput(InputState inputState, BasePlayer player)
public void LightToggle(BasePlayer player)
}
public Bear : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public BearTrap : BaseTrap {
protected Animator animator
private GameObject hurtTarget
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool Armed()
public void InitShared()
public bool CanPickup(BasePlayer player)
public void ServerInit()
public void Arm()
public void Fire()
public void ObjectEntered(GameObject obj)
public void DelayedFire()
public void RadialResetCorpses(float duration)
public void OnAttacked(HitInfo info)
private void RPC_Arm(RPCMessage rpc)
public void Load(LoadInfo info)
}
public BenchmarkInfo : SingletonComponent`1<BenchmarkInfo> {
public string BenchmarkTitle
public string BenchmarkSubtitle
public TextMeshProUGUI PerformanceText
public TextMeshProUGUI SystemInfoText
private StringBuilder sb
private RealTimeSince timeSinceUpdated
private void Start()
private void Update()
}
public BenchmarkScene : MonoBehaviour {
public string BenchmarkTitle
public string BenchmarkIdent
public int MaxNumberOfFrames
public int MaxNumberOfSeconds
}
public BigWheelBettingTerminal : StorageContainer {
public BigWheelGame bigWheel
public Vector3 seatedPlayerOffset
public float offsetCheckRadius
public SoundDefinition winSound
public SoundDefinition loseSound
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnDrawGizmos()
public bool IsPlayerValid(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
}
public BigWheelGame : SpinnerWheel {
public HitNumber[] hitNumbers
public GameObject indicator
public GameObjectRef winEffect
public float spinFrequencySeconds
public int spinNumber
public int lastPaidSpinNumber
public List`1<BigWheelBettingTerminal> terminals
public bool AllowPlayerSpins()
public bool CanUpdateSign(BasePlayer player)
public float GetMaxSpinSpeed()
public void ServerInit()
public void DoSpin()
public void SetTerminalsLocked(bool isLocked)
public void InitBettingTerminals()
public void Update_Server()
public float SpinSpacing()
public void QueueSpin()
public void Payout()
public HitNumber GetCurrentHitType()
public void LoadHitNumbers()
}
public Binocular : AttackEntity {
public Single[] fovs
public GameObjectRef fovChangeEffect
public float smoothSpeed
}
public BiomeVisuals : MonoBehaviour {
public GameObject Arid
public GameObject Temperate
public GameObject Tundra
public GameObject Arctic
protected void Start()
private void SetChoice(GameObject selection)
private void ApplyChoice(GameObject selection, GameObject target, bool shouldDestroy)
}
public BirthdayBalloonHandler : MonoBehaviour {
public float checkOffset
public float checkRadius
}
public BlendedEngineLoopDefinition : ScriptableObject {
public EngineLoopDefinition[] engineLoops
public float minRPM
public float maxRPM
public float RPMChangeRateUp
public float RPMChangeRateDown
}
public BlendedLoopEngineSound : MonoBehaviour {
public BlendedEngineLoopDefinition loopDefinition
public bool engineOn
public float RPMControl
public float smoothedRPMControl
private EngineLoop[] engineLoops
public float maxDistance
public EngineLoop[] GetEngineLoops()
public float GetLoopGain(int idx)
public float GetLoopPitch(int idx)
public float get_maxDistance()
}
public BlendedSoundLoops : MonoBehaviour {
public float blend
public float blendSmoothing
public float loopFadeOutTime
public float loopFadeInTime
public float gainModSmoothing
public float pitchModSmoothing
public bool shouldPlay
public List`1<Loop> loops
public float maxDistance
}
public BlendTexture : ProcessedTexture {
public void .ctor(int width, int height, bool linear)
public void Blend(Texture source, Texture target, float alpha)
public void CopyTo(BlendTexture target)
}
public BlueprintButton : MonoBehaviour {
public Image image
public Image imageFavourite
public Button button
public CanvasGroup group
public GameObject newNotification
public GameObject lockedOverlay
public Tooltip Tip
public Image FavouriteIcon
}
public BlueprintCategoryButton : MonoBehaviour {
public TextMeshProUGUI amountLabel
public ItemCategory Category
public bool AlwaysShow
public bool ShowItemCount
public GameObject BackgroundHighlight
public SoundDefinition clickSound
public SoundDefinition hoverSound
}
public BlueprintCraftGridRow : MonoBehaviour {
public GameObject amount
public GameObject itemName
public GameObject total
public GameObject have
public Color colorOK
public Color colorBad
}
public BlueprintHeader : MonoBehaviour {
public Text categoryName
public Text unlockCount
public void Setup(ItemCategory name, int unlocked, int total)
}
public BlurManager : ImageEffectLayer {
public BlurOptimized blur
public ColorCorrectionCurves color
public float maxBlurScale
internal float blurAmount
internal float desaturationAmount
}
public BlurTexture : ProcessedTexture {
public void .ctor(int width, int height, bool linear)
public void Blur(float radius)
public void Blur(Texture source, float radius)
}
public Boar : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public BoneDictionary : object {
public Transform transform
public Transform[] transforms
public String[] names
private Dictionary`2<string, Transform> nameDict
private Dictionary`2<int, Transform> hashDict
public int Count
public int get_Count()
public void .ctor(Transform rootBone)
public void .ctor(Transform rootBone, Transform[] boneTransforms, String[] boneNames)
private void BuildBoneDictionary()
public Transform FindBone(string name, bool defaultToRoot)
public Transform FindBone(int hash, bool defaultToRoot)
}
public Bootstrap : SingletonComponent`1<Bootstrap> {
internal bool bootstrapInitRun
public bool isErrored
public string messageString
public CanvasGroup BootstrapUiCanvas
public GameObject errorPanel
public TextMeshProUGUI errorText
public TextMeshProUGUI statusText
private string lastWrittenValue
public bool needsSetup
public bool isPresent
public bool get_needsSetup()
public bool get_isPresent()
public void RunDefaults()
public void Init_Tier0()
public void Init_Systems()
public void Init_Config()
public void NetworkInitRaknet()
public void NetworkInitSteamworks(bool enableSteamDatagramRelay)
private IEnumerator Start()
private IEnumerator DedicatedServerStartup()
public IEnumerator StartServer(bool doLoad, string saveFileOverride, bool allowOutOfDateSaves)
private void StartupShared()
public void ThrowError(string error)
public void ExitGame()
public IEnumerator LoadingUpdate(string str)
public void WriteToLog(string str)
}
public BossFormController : ArcadeEntityController {
public float animationSpeed
public Sprite[] animationFrames
public Vector2 roamDistance
public Transform colliderParent
public BossDamagePoint[] damagePoints
public ArcadeEntityController flashController
public float health
}
public BoundsEx : object {
private Vector3[] pts
public Bounds XZ3D(Bounds bounds)
public Bounds Transform(Bounds bounds, Matrix4x4 matrix)
public Rect ToScreenRect(Bounds b, Camera cam)
public Rect ToCanvasRect(Bounds b, RectTransform target, Camera cam)
}
public BowWeapon : BaseProjectile {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void BowReload(RPCMessage msg)
public bool ForceSendMagazine()
}
public BoxStorage : StorageContainer {
public Vector3 GetDropPosition()
}
public BradleyAPC : BaseCombatEntity {
public BlendedLoopEngineSound engineSound
public SoundDefinition treadLoopDef
public AnimationCurve treadGainCurve
public AnimationCurve treadPitchCurve
public AnimationCurve treadFreqCurve
private Sound treadLoop
private Modulator treadGain
private Modulator treadPitch
public SoundDefinition chasisLurchSoundDef
public float chasisLurchAngleDelta
public float chasisLurchSpeedDelta
public float lastAngle
public float lastSpeed
public SoundDefinition turretTurnLoopDef
public float turretLoopGainSpeed
public float turretLoopPitchSpeed
public float turretLoopMinAngleDelta
public float turretLoopMaxAngleDelta
public float turretLoopPitchMin
public float turretLoopPitchMax
public float turretLoopGainThreshold
private Sound turretTurnLoop
private Modulator turretTurnLoopGain
private Modulator turretTurnLoopPitch
public float enginePitch
public float rpmMultiplier
private TreadAnimator treadAnimator
public List`1<Vector3> currentPath
public int currentPathIndex
public bool pathLooping
public float viewDistance
public float searchRange
public float searchFrequency
public float memoryDuration
public float sightUpdateRate
public BaseCombatEntity mainGunTarget
public List`1<TargetInfo> targetList
public float coaxFireRate
public int coaxBurstLength
public float coaxAimCone
public float bulletDamage
public float topTurretFireRate
public float nextCoaxTime
public int numCoaxBursted
public float nextTopTurretTime
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public float lastLateUpdate
public WheelCollider[] leftWheels
public WheelCollider[] rightWheels
public float moveForceMax
public float brakeForce
public float turnForce
public float sideStiffnessMax
public float sideStiffnessMin
public Transform centerOfMass
public float stoppingDist
public float throttle
public float turning
public float rightThrottle
public float leftThrottle
public bool brake
public Rigidbody myRigidBody
public Collider myCollider
public Vector3 destination
public Vector3 finalDestination
public Transform followTest
public TriggerHurtEx impactDamager
public Transform mainTurretEyePos
public Transform mainTurret
public Transform CannonPitch
public Transform CannonMuzzle
public Transform coaxPitch
public Transform coaxMuzzle
public Transform topTurretEyePos
public Transform topTurretYaw
public Transform topTurretPitch
public Transform topTurretMuzzle
public Vector3 turretAimVector
public Vector3 desiredAimVector
public Vector3 topTurretAimVector
public Vector3 desiredTopTurretAimVector
public GameObjectRef explosionEffect
public GameObjectRef servergibs
public GameObjectRef fireBall
public GameObjectRef crateToDrop
public GameObjectRef debrisFieldMarker
public int maxCratesToSpawn
public int patrolPathIndex
public BasePath patrolPath
public bool DoAI
public GameObjectRef mainCannonMuzzleFlash
public GameObjectRef mainCannonProjectile
public float recoilScale
public NavMeshPath navMeshPath
public int navMeshPathIndex
public float nextFireTime
public int numBursted
public float nextPatrolTime
public float nextEngagementPathTime
public float currentSpeedZoneLimit
protected float PositionTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasPath()
public void ClearPath()
public bool IndexValid(int index)
public Vector3 GetFinalDestination()
public Vector3 GetCurrentPathDestination()
public bool PathComplete()
public bool AtCurrentPathNode()
public int GetLoopedIndex(int index)
public Vector3 PathDirection(int index)
public Vector3 IdealPathPosition()
public void AdvancePathMovement()
public bool GetPathToClosestTurnableNode(BasePathNode start, Vector3 forward, List`1& nodes)
public bool GetEngagementPath(List`1& nodes)
public void AddOrUpdateTarget(BaseEntity ent, Vector3 pos, float damageFrom)
public void UpdateTargetList()
public int SortTargets(TargetInfo t1, TargetInfo t2)
public Vector3 GetAimPoint(BaseEntity ent)
public bool VisibilityTest(BaseEntity ent)
public void UpdateTargetVisibilities()
public void DoWeaponAiming()
public void DoWeapons()
public void FireGun(Vector3 targetPos, float aimCone, bool isCoax)
public void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
public void AimWeaponAt(Transform weaponYaw, Transform weaponPitch, Vector3 direction, float minPitch, float maxPitch, float maxYaw, Transform parentOverride)
public void LateUpdate()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void SetDestination(Vector3 dest)
public void ServerInit()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public void Initialize()
public BasePlayer FollowPlayer()
public Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom)
protected float get_PositionTickRate()
public bool IsAtDestination()
public bool IsAtFinalDestination()
public Vector3 ClosestPointAlongPath(Vector3 start, Vector3 end, Vector3 fromPos)
public void FireGunTest()
public void InstallPatrolPath(BasePath path)
public void UpdateMovement_Patrol()
public void UpdateMovement_Hunt()
public void DoSimpleAI()
public void FixedUpdate()
public void DoPhysicsMove()
public void ApplyBrakes(float amount)
public float GetMotorTorque(bool rightSide)
public void ScaleSidewaysFriction(float scale)
public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
public void ApplyBrakeTorque(float amount, bool rightSide)
public void CreateExplosionMarker(float durationMinutes)
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
public void OnHealthChanged(float oldvalue, float newvalue)
public void DoHealing()
}
public BradleyMoveTest : MonoBehaviour {
public WheelCollider[] leftWheels
public WheelCollider[] rightWheels
public float moveForceMax
public float brakeForce
public float throttle
public float turnForce
public float sideStiffnessMax
public float sideStiffnessMin
public Transform centerOfMass
public float turning
public bool brake
public Rigidbody myRigidBody
public Vector3 destination
public float stoppingDist
public GameObject followTest
public void Awake()
public void Initialize()
public void SetDestination(Vector3 dest)
public void FixedUpdate()
public void ApplyBrakes(float amount)
public float GetMotorTorque(bool rightSide)
public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
public void ApplyBrakeTorque(float amount, bool rightSide)
public void AdjustFriction()
}
public BradleySpawner : MonoBehaviour {
public BasePath path
public GameObjectRef bradleyPrefab
public BradleyAPC spawned
public bool initialSpawn
public float minRespawnTimeMinutes
public float maxRespawnTimeMinutes
public BradleySpawner singleton
private bool pendingRespawn
public void Start()
public void DelayedStart()
public void CheckIfRespawnNeeded()
public void ScheduleRespawn()
public void DoRespawn()
public void SpawnBradley()
}
public BranchConfig : UIDialog {
private ElectricalBranch branch
public InputField input
public int target
}
public Branding : BaseMonoBehaviour {
public TextMeshProUGUI versionText
public CanvasGroup canvasGroup
private string oldChangeId
}
public BucketVMFluidSim : MonoBehaviour {
public Animator waterbucketAnim
public ParticleSystem waterPour
public ParticleSystem waterTurbulence
public ParticleSystem waterFill
public float waterLevel
public float targetWaterLevel
public AudioSource waterSpill
private float PlayerEyePitch
private float turb_forward
private float turb_side
private Vector3 lastPosition
protected Vector3 groundSpeedLast
private Vector3 lastAngle
protected Vector3 vecAngleSpeedLast
private Vector3 initialPosition
}
public BuildingBlock : StabilityEntity {
private bool forceSkinRefresh
public int modelState
private int lastModelState
public Enum grade
public Enum lastGrade
public ConstructionSkin currentSkin
private DeferredAction skinChange
private MeshRenderer placeholderRenderer
private MeshCollider placeholderCollider
public UpdateSkinWorkQueue updateSkinQueueServer
public bool CullBushes
public Construction blockDefinition
private Vector3[] outsideLookupOffsets
public ConstructionGrade currentGrade
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanDemolish(BasePlayer player)
private bool IsDemolishable()
private bool HasDemolishPrivilege(BasePlayer player)
private void DoDemolish(RPCMessage msg)
private void DoImmediateDemolish(RPCMessage msg)
public void StopBeingDemolishable()
public void StartBeingDemolishable()
public void SetConditionalModel(int state)
public bool GetConditionalModel(int index)
public ConstructionGrade get_currentGrade()
public ConstructionGrade GetGrade(Enum iGrade)
public bool CanChangeToGrade(Enum iGrade, BasePlayer player)
private bool HasUpgradePrivilege(Enum iGrade, BasePlayer player)
private bool IsUpgradeBlocked()
public bool CanAffordUpgrade(Enum iGrade, BasePlayer player)
public void SetGrade(Enum iGradeID)
private void UpdateGrade()
public void SetHealthToMax()
private void DoUpgradeToGrade(RPCMessage msg)
public void PayForUpgrade(ConstructionGrade g, BasePlayer player)
private bool NeedsSkinChange()
public void UpdateSkin(bool force)
private void DestroySkin()
private void RefreshNeighbours(bool linkToNeighbours)
private void UpdatePlaceholder(bool state)
private void ChangeSkin()
public void ChangeSkin(GameObjectRef prefab)
public bool ShouldBlockProjectiles()
private void OnHammered()
public float MaxHealth()
public List`1<ItemAmount> BuildCost()
public void OnHealthChanged(float oldvalue, float newvalue)
public float RepairCostFraction()
public bool CanRotate(BasePlayer player)
private bool IsRotatable()
private bool IsRotationBlocked()
private bool HasRotationPrivilege(BasePlayer player)
private void DoRotation(RPCMessage msg)
public void StopBeingRotatable()
public void StartBeingRotatable()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ServerInit()
public void Hurt(HitInfo info)
public void ResetState()
public void InitShared()
public void PostInitShared()
public void DestroyShared()
public string Categorize()
public float BoundsPadding()
public bool IsOutside()
}
public BuildingBlockDecay : Decay {
private bool isFoundation
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public bool ShouldDecay(BaseEntity entity)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BuildingGrade : ScriptableObject {
public Enum type
public float baseHealth
public List`1<ItemAmount> baseCost
public PhysicMaterial physicMaterial
public ProtectionProperties damageProtecton
public Option upgradeMenu
}
public BuildingGradeDecay : Decay {
public Enum decayGrade
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public bool ShouldDecay(BaseEntity entity)
}
public BuildingManager : object {
public ServerBuildingManager server
public ListHashSet`1<DecayEntity> decayEntities
public ListDictionary`2<UInt32, Building> buildingDictionary
public Building GetBuilding(UInt32 buildingID)
public void Add(DecayEntity ent)
public void Remove(DecayEntity ent)
public void Clear()
protected Building CreateBuilding(UInt32 id)
protected void DisposeBuilding(Building& building)
}
public BuildingPrivlidge : StorageContainer {
public float cachedProtectedMinutes
public float nextProtectedCalcTime
public UpkeepBracket[] upkeepBrackets
public List`1<ItemAmount> upkeepBuffer
public List`1<PlayerNameID> authorizedPlayers
public Flags Flag_MaxAuths
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float CalculateUpkeepPeriodMinutes()
public float CalculateUpkeepCostFraction()
public void CalculateUpkeepCostAmounts(List`1<ItemAmount> itemAmounts)
public float GetProtectedMinutes(bool force)
public void OnKilled(HitInfo info)
public void DecayTick()
public bool EnsurePrimary()
public void MarkProtectedMinutesDirty(float delay)
public float CalculateBuildingTaxRate()
public void ApplyUpkeepPayment()
public void QueueUpkeepPayment(List`1<ItemAmount> itemAmounts)
public bool CanAffordUpkeepPayment(List`1<ItemAmount> itemAmounts)
public float PurchaseUpkeepTime(DecayEntity entity, float deltaTime)
public void PurchaseUpkeepTime(float deltaTime)
public void ResetState()
public bool IsAuthed(BasePlayer player)
public bool IsAuthed(ulong userID)
public bool AnyAuthed()
public bool ItemFilter(Item item, int targetSlot)
public void Save(SaveInfo info)
public void PostSave(SaveInfo info)
public void Load(LoadInfo info)
public void BuildingDirty()
public bool AtMaxAuthCapacity()
public void UpdateMaxAuthCapacity()
protected void OnInventoryDirty()
public void OnItemAddedOrRemoved(Item item, bool bAdded)
public void AddDelayedUpdate()
public void DelayedUpdate()
public bool CanAdministrate(BasePlayer player)
public void AddSelfAuthorize(RPCMessage rpc)
public void AddPlayer(BasePlayer player)
public void RemoveSelfAuthorize(RPCMessage rpc)
public void ClearList(RPCMessage rpc)
public void RPC_Rotate(RPCMessage msg)
public bool HasSlot(Slot slot)
}
public BuildingProximity : PrefabAttribute {
private float check_radius
private float check_forgiveness
private float foundation_width
private float foundation_extents
public bool Check(BasePlayer player, Construction construction, Vector3 position, Quaternion rotation)
public ProximityInfo GetProximity(Construction construction1, Vector3 position1, Quaternion rotation1, Construction construction2, Vector3 position2, Quaternion rotation2)
public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
protected Type GetIndexedType()
}
public BunnyEntry : MonoBehaviour {
public Text nameText
public Text amountText
public RawImage starImage
public RawImage selfImage
}
public Buoyancy : ListComponent`1<Buoyancy> {
public BuoyancyPoint[] points
public GameObjectRef[] waterImpacts
public Rigidbody rigidBody
public float buoyancyScale
public float submergedFraction
public bool doEffects
public Action`1<bool> SubmergedChanged
public float flowMovementScale
private float <timeOutOfWater>k__BackingField
public float requiredSubmergedFraction
public BaseEntity forEntity
private BuoyancyPointData[] pointData
private Vector2[] pointPositionArray
private Vector2[] pointPositionUVArray
private Vector3[] pointShoreVectorArray
private Single[] pointTerrainHeightArray
private Single[] pointWaterHeightArray
private float timeInWater
public float waveHeightScale
public float timeOutOfWater
public float get_timeOutOfWater()
private void set_timeOutOfWater(float value)
public string DefaultWaterImpact()
private void Awake()
public void Sleep()
public void Wake()
public void CheckSleepState()
protected void DoCycle()
public void Cycle()
public Vector3 GetFlowDirection(Vector2 posUV)
public void EnsurePointsInitialized()
public void BuoyancyFixedUpdate()
}
public BuoyancyPoint : MonoBehaviour {
public float buoyancyForce
public float size
public float randomOffset
public float waveScale
public float waveFrequency
public bool wasSubmergedLastFrame
public float nexSplashTime
public bool doSplashEffects
public void Start()
public void OnDrawGizmos()
}
public BushEntity : BaseEntity {
public GameObjectRef prefab
public bool globalBillboard
public void InitShared()
public void ServerInit()
internal void DoServerDestroy()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public BUTTON : Enum {
public int value__
public BUTTON FORWARD
public BUTTON BACKWARD
public BUTTON LEFT
public BUTTON RIGHT
public BUTTON JUMP
public BUTTON DUCK
public BUTTON SPRINT
public BUTTON USE
public BUTTON FIRE_PRIMARY
public BUTTON FIRE_SECONDARY
public BUTTON RELOAD
public BUTTON FIRE_THIRD
}
public ByteMap : object {
private int size
private int bytes
private Byte[] values
public int Size
public UInt32 Item
public void .ctor(int size, int bytes)
public void .ctor(int size, Byte[] values, int bytes)
public int get_Size()
public UInt32 get_Item(int x, int y)
public void set_Item(int x, int y, UInt32 value)
}
public ByteQuadtree : object {
private int size
private int levels
private ByteMap[] values
public int Size
public Element Root
public void UpdateValues(Byte[] baseValues)
public int get_Size()
public Element get_Root()
private ByteMap CreateLevel(int level)
}
public CableTunnel : IOEntity {
private int numChannels
private Int32[] inputAmounts
public bool WantsPower()
public void IOStateChanged(int inputAmount, int inputSlot)
public void UpdateOutputs()
}
public CachedTransform`1 : ValueType {
public T component
public Vector3 position
public Quaternion rotation
public Vector3 localScale
public Matrix4x4 localToWorldMatrix
public Matrix4x4 worldToLocalMatrix
public Vector3 forward
public Vector3 up
public Vector3 right
public void .ctor(T instance)
public void Apply()
public void RotateAround(Vector3 center, Vector3 axis, float angle)
public Matrix4x4 get_localToWorldMatrix()
public Matrix4x4 get_worldToLocalMatrix()
public Vector3 get_forward()
public Vector3 get_up()
public Vector3 get_right()
public bool op_Implicit(CachedTransform`1<T> instance)
}
public CameraEx : MonoBehaviour {
public bool overrideAmbientLight
public AmbientMode ambientMode
public Color ambientGroundColor
public Color ambientEquatorColor
public Color ambientLight
public float ambientIntensity
internal Color old_ambientLight
internal Color old_ambientGroundColor
internal Color old_ambientEquatorColor
internal float old_ambientIntensity
internal AmbientMode old_ambientMode
public float aspect
}
public CameraFocusMode : Enum {
public int value__
public CameraFocusMode Off
public CameraFocusMode Auto
public CameraFocusMode Manual
}
public CameraMan : SingletonComponent`1<CameraMan> {
public string DefaultSaveName
public string SavePositionExtension
public string SavePositionDirectory
public bool OnlyControlWhenCursorHidden
public bool NeedBothMouseButtonsToZoom
public float LookSensitivity
public float MoveSpeed
public float GuideAspect
public float GuideRatio
public Canvas canvas
public Graphic[] guides
}
public CameraSettings : MonoBehaviour {
private Camera cam
private void OnEnable()
private void Update()
}
public CameraTool : HeldEntity {
public GameObjectRef screenshotEffect
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void SVNoteScreenshot(RPCMessage msg)
}
public CameraUtil : object {
public void NormalizePlane(Plane& plane)
public void ExtractPlanes(Camera camera, Plane[]& planes)
public void ExtractPlanes(Matrix4x4 viewProjMatrix, Plane[]& planes)
}
public Candle : BaseCombatEntity {
public float lifeTimeSeconds
public float burnRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SetWantsOn(RPCMessage msg)
public void PostServerLoad()
public void UpdateInvokes()
public void Burn()
public void OnAttacked(HitInfo info)
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public void Ignite()
public bool CanIgnite()
}
public CanvasLOD : LODComponent {
public float Distance
}
public CanvasOrderHack : MonoBehaviour {
private void OnEnable()
}
public CapturePointTrigger : TriggerBase {
internal GameObject InterestedInObject(GameObject obj)
}
public CardGameSounds : PrefabAttribute {
public SoundDefinition ChipsSfx
public SoundDefinition DrawSfx
public SoundDefinition PlaySfx
public SoundDefinition ShuffleSfx
public SoundDefinition WinSfx
public SoundDefinition YourTurnSfx
public SoundDefinition CheckSfx
protected Type GetIndexedType()
public void PlaySound(SoundType sound, GameObject forGameObject)
}
public CardInputWidget : MonoBehaviour {
public RustText InputText
public RustText ActionText
public RustText ExtraText
}
public CardReader : IOEntity {
public float accessDuration
public int accessLevel
public GameObjectRef accessGrantedEffect
public GameObjectRef accessDeniedEffect
public GameObjectRef swipeEffect
public Transform audioPosition
public Flags AccessLevel1
public Flags AccessLevel2
public Flags AccessLevel3
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void CancelAccess()
public void FailCard()
public void ServerInit()
public void GrantCard()
public void ServerCardSwiped(RPCMessage msg)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public CardTable : BaseVehicle {
public EntityRef PotInstance
private GameObjectRef uiPrefab
private GameObjectRef playerStoragePrefab
private GameObjectRef potPrefab
private GameObject onTableVisuals
private ViewModel viewModel
public ItemDefinition scrapItemDef
public PlayerStorageInfo[] playerStoragePoints
public CardGameOption gameOption
private CardGameController _gameCont
private float MAX_STORAGE_INTERACTION_DIST
protected bool CanSwapSeats
public int ScrapItemID
public CardGameController GameController
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected bool get_CanSwapSeats()
public StorageContainer GetPot()
public void Save(SaveInfo info)
public void PostServerLoad()
public void SpawnSubEntities()
internal void DoServerDestroy()
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void PrePlayerDismount(BasePlayer player, BaseMountable seat)
public int GetMountPointIndex(ulong playerID)
public CardTablePlayerStorage GetPlayerStorage(ulong playerID)
public CardTablePlayerStorage GetPlayerStorage(int storageIndex)
public void PlayerStorageChanged()
public BasePlayer IDToPlayer(ulong id)
public void RPC_Editor_SpawnTestPlayer(RPCMessage msg)
public void RPC_Editor_MakeRandomMove(RPCMessage msg)
private void RPC_Play(RPCMessage msg)
private void RPC_OpenLoot(RPCMessage msg)
private void RPC_LeaveTable(RPCMessage msg)
private void RPC_PlayerInput(RPCMessage msg)
public int get_ScrapItemID()
public CardGameController get_GameController()
public void DestroyShared()
private CardGameController GetGameController()
public void Load(LoadInfo info)
}
public CardTablePlayerStorage : StorageContainer {
private EntityRef cardTableRef
public CardTable GetCardTable()
public void Load(LoadInfo info)
public void SetCardTable(CardTable cardTable)
protected void OnInventoryDirty()
public void Save(SaveInfo info)
}
public CardTableSeat : BaseChair {
public Transform CardsMesh
}
public CardTableUI : UIDialog {
private InfoTextUI primaryInfo
private InfoTextUI secondaryInfo
private InfoTextUI playerLeaveInfo
private GameObject playingUI
private GameObject availableInputsUI
private PlayingCardImage[] cardImages
private CardInputWidget[] inputWidgets
private RustSlider dismountProgressSlider
private Phrase phraseLoading
private Phrase phraseWaitingForNextRound
private Phrase phraseNotEnoughPlayers
private Phrase phraseYourTurn
private Phrase phrasePlayerLeftGame
private Color colourNeutralUI
private Color colourGoodUI
private Color colourBadUI
private CanvasGroup timerCanvas
private RustSlider timerSlider
private UIChat chat
private HudElement Hunger
private HudElement Thirst
private HudElement Health
private HudElement PendingHealth
public Sprite cardNone
public Sprite cardBackLarge
public Sprite cardBackSmall
private Sprite cardBackLargeStatic
private Sprite cardBackSmallStatic
private TexasHoldEmUI texasHoldEmUI
}
public CargoMoveTest : FacepunchBehaviour {
public int targetNodeIndex
private float currentThrottle
private float turnScale
private void Awake()
public void FindInitialNode()
private void Update()
public void UpdateMovement()
public int GetClosestNodeToUs()
public void OnDrawGizmosSelected()
}
public CargoPlane : BaseEntity {
public GameObjectRef prefabDrop
public SpawnFilter filter
public Vector3 startPos
public Vector3 endPos
public float secondsToTake
public float secondsTaken
public bool dropped
public Vector3 dropPosition
public void InitDropPosition(Vector3 newDropPosition)
public void ServerInit()
public Vector3 RandomDropPosition()
public void UpdateDropPosition(Vector3 newDropPosition)
private void Update()
}
public CargoShip : BaseEntity {
public int targetNodeIndex
public GameObject wakeParent
public GameObjectRef scientistTurretPrefab
public Transform[] scientistSpawnPoints
public List`1<Transform> crateSpawns
public GameObjectRef lockedCratePrefab
public GameObjectRef militaryCratePrefab
public GameObjectRef eliteCratePrefab
public GameObjectRef junkCratePrefab
public Transform waterLine
public Transform rudder
public Transform propeller
public GameObjectRef escapeBoatPrefab
public Transform escapeBoatPoint
public GameObject radiation
public GameObjectRef mapMarkerEntityPrefab
public GameObject hornOrigin
public SoundDefinition hornDef
public CargoShipSounds cargoShipSounds
public GameObject[] layouts
public GameObjectRef playerTest
public bool event_enabled
public float event_duration_minutes
public float egress_duration_minutes
public int loot_rounds
public float loot_round_spacing_minutes
public BaseEntity mapMarkerInstance
public Vector3 currentVelocity
public float currentThrottle
public float currentTurnSpeed
public float turnScale
public int lootRoundsPassed
public int hornCount
public float currentRadiation
public bool egressing
public float GetNetworkTime()
public void UpdateLayoutFromFlags()
public void TriggeredEventSpawn()
public void CreateMapMarker()
public void DisableCollisionTest()
public void SpawnCrate(string resourcePath)
public void RespawnLoot()
public void SpawnSubEntities()
public void PlayHorn()
public void PickLayout()
public void Spawn()
public void ServerInit()
public void UpdateRadiation()
public void StartEgress()
public void DelayedDestroy()
public void FindInitialNode()
public void BuildingCheck()
public void FixedUpdate()
public void UpdateMovement()
public int GetClosestNodeToUs()
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public float InheritedVelocityScale()
public bool BlocksWaterFor(BasePlayer player)
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public CargoShipInteriorSoundTrigger : MonoBehaviour {
public CargoShipSounds cargoShipSounds
}
public CargoShipSounds : MonoBehaviour {
public SoundDefinition waveSoundDef
public AnimationCurve waveSoundYGainCurve
public AnimationCurve waveSoundEdgeDistanceGainCurve
private Sound waveSoundL
private Sound waveSoundR
private Modulator waveSoundLGainMod
private Modulator waveSoundRGainMod
public SoundDefinition sternWakeSoundDef
private Sound sternWakeSound
private Modulator sternWakeSoundGainMod
public SoundDefinition engineHumSoundDef
private Sound engineHumSound
public GameObject engineHumTarget
public SoundDefinition hugeRumbleSoundDef
public AnimationCurve hugeRumbleYDiffCurve
public AnimationCurve hugeRumbleRelativeSpeedCurve
private Sound hugeRumbleSound
private Modulator hugeRumbleGainMod
private Vector3 lastCameraPos
private Vector3 lastRumblePos
private Vector3 lastRumbleLocalPos
public Collider soundFollowCollider
public Collider soundFollowColliderL
public Collider soundFollowColliderR
public Collider sternSoundFollowCollider
}
public CCTV_RC : PoweredRemoteControlEntity {
public Transform pivotOrigin
public Transform yaw
public Transform pitch
public Vector2 pitchClamp
public Vector2 yawClamp
public float turnSpeed
public float serverLerpSpeed
public float clientLerpSpeed
public float pitchAmount
public float yawAmount
public bool hasPTZ
public Flags Flag_HasViewer
public int numViewers
private bool externalViewer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int ConsumptionAmount()
public void ServerInit()
public void PostServerLoad()
public void UserInput(InputState inputState, BasePlayer player)
public void Save(SaveInfo info)
public void Server_SetDir(RPCMessage msg)
public void InitializeControl(BasePlayer controller)
public void StopControl()
public void PingFromExternalViewer()
private void ResetExternalViewer()
public void UpdateViewers()
public void UpdateRotation(float delta)
public void Load(LoadInfo info)
}
public CCTVRender.ClientState : object {
private ulong <UserId>k__BackingField
private float <LastAssigned>k__BackingField
public ulong UserId
public float LastAssigned
public ulong get_UserId()
private void set_UserId(ulong value)
public float get_LastAssigned()
public void set_LastAssigned(float value)
public void Initialize(ulong userId)
}
public CCTVRender.IReceiver {
public void RenderCompleted(UInt32 requestId, UInt32 frame, Span`1<byte> jpgImage)
}
public CCTVRender.Job : ValueType {
private UInt32 <NetId>k__BackingField
private UInt32 <RequestId>k__BackingField
private float <Assigned>k__BackingField
public UInt32 NetId
public UInt32 RequestId
public float Assigned
public UInt32 get_NetId()
public UInt32 get_RequestId()
public float get_Assigned()
public void .ctor(UInt32 netId, UInt32 requestId, float assigned)
}
public CCTVRender.JobReceiver : ValueType {
private UInt32 <RequestId>k__BackingField
private IReceiver <Receiver>k__BackingField
public UInt32 RequestId
public IReceiver Receiver
public UInt32 get_RequestId()
public IReceiver get_Receiver()
public void .ctor(UInt32 requestId, IReceiver receiver)
}
public CCTVRender.Manager : object {
private Dictionary`2<ulong, Job> _playerAssignments
private MruDictionary`2<UInt32, RenderState> _renderStates
private MruDictionary`2<ulong, ClientState> _clientStates
private RealTimeSince _lastCleanup
public void Initialize()
public void Update()
public bool TryRequest(UInt32 requestId, IReceiver receiver, CCTV_RC camera, UInt32 frame)
public void CompleteRequest(BasePlayer player, Span`1<byte> jpgImage)
private BasePlayer ChooseEligiblePlayer(Vector3 position)
private void GetEligiblePlayers(List`1<ScoredPlayer> scoredPlayers, Vector3 position)
private float InverseRange(float x, float range)
}
public CCTVRender.RenderState : object {
private UInt32 <NetId>k__BackingField
private bool <IsLocked>k__BackingField
private UInt32 <Frame>k__BackingField
private float _lastRendered
private HashSet`1<JobReceiver> _receivers
private Byte[] _imageCache
private int _imageCacheLength
private float _imageCacheTime
public UInt32 NetId
public bool IsLocked
public UInt32 Frame
public bool WasRecentlyRendered
public bool HasCachedFrame
public ArraySegment`1<byte> CachedFrame
public UInt32 get_NetId()
private void set_NetId(UInt32 value)
public bool get_IsLocked()
private void set_IsLocked(bool value)
public UInt32 get_Frame()
private void set_Frame(UInt32 value)
public bool get_WasRecentlyRendered()
public bool get_HasCachedFrame()
public ArraySegment`1<byte> get_CachedFrame()
public void Initialize(UInt32 netId)
public void EnterPool()
public bool AddReceiver(JobReceiver receiver)
public void BeginRequest()
public void CompleteRequest(Span`1<byte> jpgImage)
public void AbortRequest()
public void LeavePool()
}
public CCTVRender.Settings : ConsoleSystem {
public int MaxImageSize
public bool Enabled
public float MaxDistance
public float CombatTime
public float IdleTime
public float AssignmentTimeout
public float AssignmentCooldown
}
public CCTVRenderController : SingletonComponent`1<CCTVRenderController> {
public Camera Camera
public int Width
public int Height
public int Quality
private RenderTexture _renderTexture
private Texture2D _texture
public void OnEnable()
public void OnDisable()
}
public CeilingLight : IOEntity {
public float pushScale
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int ConsumptionAmount()
public void Hurt(HitInfo info)
public void RefreshGrowables()
public void IOStateChanged(int inputAmount, int inputSlot)
public void LightsOn()
public void LightsOff()
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
}
public CH47AIBrain : BaseAIBrain`1<CH47HelicopterAIController> {
public int CH47State_Idle
public int CH47State_Patrol
public int CH47State_Land
public int CH47State_Dropoff
public int CH47State_Orbit
public int CH47State_Retreat
public int CH47State_Egress
private float age
public void InitializeAI()
public void FixedUpdate()
public void OnDrawGizmos()
public void AIThink(float delta)
}
public ch47Animator : MonoBehaviour {
public Animator animator
public bool bottomDoorOpen
public bool landingGearDown
public bool leftDoorOpen
public bool rightDoorOpen
public bool rearDoorOpen
public bool rearDoorExtensionOpen
public Transform rearRotorBlade
public Transform frontRotorBlade
public float rotorBladeSpeed
public float wheelTurnSpeed
public float wheelTurnAngle
public SkinnedMeshRenderer[] blurredRotorBlades
public SkinnedMeshRenderer[] RotorBlades
private bool blurredRotorBladesEnabled
public float blurSpeedThreshold
private void Start()
public void SetDropDoorOpen(bool isOpen)
private void Update()
private void LateUpdate()
private void EnableBlurredRotorBlades(bool enabled)
}
public CH47DropZone : MonoBehaviour {
public float lastDropTime
public List`1<CH47DropZone> dropZones
public void Awake()
public CH47DropZone GetClosest(Vector3 pos)
public void OnDestroy()
public float TimeSinceLastDrop()
public void Used()
public void OnDrawGizmos()
}
public CH47FlightTest : MonoBehaviour {
public Rigidbody rigidBody
public float engineThrustMax
public Vector3 torqueScale
public Transform com
public Transform[] GroundPoints
public Transform[] GroundEffects
public float currentThrottle
public float avgThrust
public float liftDotMax
public Transform AIMoveTarget
private float altitudeTolerance
public void Awake()
public HelicopterInputState_t GetHelicopterInputState()
public HelicopterInputState_t GetAIInputState()
public float GetIdealAltitude()
public void FixedUpdate()
public void OnDrawGizmos()
}
public CH47Helicopter : BaseHelicopterVehicle {
public GameObjectRef mapMarkerEntityPrefab
public BaseEntity mapMarkerInstance
public void ServerInit()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void CreateMapMarker()
protected bool CanPushNow(BasePlayer pusher)
}
public CH47HelicopterAIController : CH47Helicopter {
public GameObjectRef scientistPrefab
public GameObjectRef dismountablePrefab
public GameObjectRef weakDismountablePrefab
public float maxTiltAngle
public float AiAltitudeForce
public GameObjectRef lockedCratePrefab
public Flags Flag_Damaged
public Flags Flag_NearDeath
public Flags Flag_DropDoorOpen
public GameObject triggerHurt
public Vector3 landingTarget
public int numCrates
private bool shouldLand
public bool aimDirOverride
public Vector3 _aimDirection
public Vector3 _moveTarget
public int lastAltitudeCheckFrame
public float altOverride
public float currentDesiredAltitude
private bool altitudeProtection
public float hoverHeight
public void DropCrate()
public bool OutOfCrates()
public bool CanDropCrate()
public bool IsDropDoorOpen()
public void SetDropDoorOpen(bool open)
public bool ShouldLand()
public void SetLandingTarget(Vector3 target)
public void ClearLandingTarget()
public void TriggeredEventSpawn()
public void AttemptMount(BasePlayer player, bool doMountChecks)
public void ServerInit()
public void SpawnPassenger(Vector3 spawnPos, string prefabPath)
public void SpawnPassenger(Vector3 spawnPos)
public void SpawnScientist(Vector3 spawnPos)
public void SpawnScientists()
public void EnableFacingOverride(bool enabled)
public void SetMoveTarget(Vector3 position)
public Vector3 GetMoveTarget()
public void SetAimDirection(Vector3 dir)
public Vector3 GetAimDirectionOverride()
public Vector3 GetPosition()
public void MounteeTookDamage(BasePlayer mountee, HitInfo info)
public void CancelAnger()
public void InitiateAnger()
public void UnHostile()
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
public void DelayedKill()
public void DismountAllPlayers()
public void SetAltitudeProtection(bool on)
public void CalculateDesiredAltitude()
public void SetMinHoverHeight(float newHeight)
public float CalculateOverrideAltitude()
public void SetDefaultInputState()
public void MaintainAIAltutide()
protected void VehicleFixedUpdate()
public void DestroyShared()
}
public CH47LandingZone : MonoBehaviour {
public float lastDropTime
public List`1<CH47LandingZone> landingZones
public float dropoffScale
public void Awake()
public CH47LandingZone GetClosest(Vector3 pos)
public void OnDestroy()
public float TimeSinceLastDrop()
public void Used()
public void OnDrawGizmos()
}
public CH47ReinforcementListener : BaseEntity {
public string listenString
public GameObjectRef heliPrefab
public float startDist
public void OnEntityMessage(BaseEntity from, string msg)
public void Call()
}
public Chainsaw : BaseMelee {
public float attackFadeInTime
public float attackFadeInDelay
public float attackFadeOutTime
public float idleFadeInTimeFromOff
public float idleFadeInTimeFromAttack
public float idleFadeInDelay
public float idleFadeOutTime
public Renderer chainRenderer
private MaterialPropertyBlock block
private Vector2 saveST
public float fuelPerSec
public int maxAmmo
public int ammo
public ItemDefinition fuelType
public float reloadDuration
public SoundPlayer idleLoop
public SoundPlayer attackLoopAir
public SoundPlayer revUp
public SoundPlayer revDown
public SoundPlayer offSound
private int failedAttempts
public float engineStartChance
private float ammoRemainder
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool EngineOn()
public bool IsAttacking()
public void ServerNPCStart()
public void ServerUse()
public void ServerUse_OnHit(HitInfo info)
private void DelayedStopAttack()
protected bool VerifyClientAttack(BasePlayer player)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void SetHeld(bool bHeld)
public void ReduceAmmo(float firingTime)
public void DoReload(RPCMessage msg)
public void Save(SaveInfo info)
public void SetEngineStatus(bool status)
public void SetAttackStatus(bool status)
public void EngineTick()
public void AttackTick()
public void Server_StartEngine(RPCMessage msg)
public void Server_StopEngine(RPCMessage msg)
public void Server_SetAttacking(RPCMessage msg)
public void ServerCommand(Item item, string command, BasePlayer player)
public void DisableHitEffects()
public void EnableHitEffect(UInt32 hitMaterial)
public void DoAttackShared(HitInfo info)
public void Load(LoadInfo info)
public bool HasAmmo()
public Item GetAmmo()
}
public ChangeSignText : UIDialog {
public Action`2<int, Texture2D> onUpdateTexture
public GameObject objectContainer
public GameObject currentFrameSection
public GameObject[] frameOptions
}
public ChatEntry : MonoBehaviour {
public TextMeshProUGUI text
public RawImage avatar
public CanvasGroup canvasGroup
public float lifeStarted
public ulong steamid
}
public Chicken : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public ChildrenFromScene : MonoBehaviour {
public string SceneName
public bool StartChildrenDisabled
private IEnumerator Start()
}
public ChildrenScreenshot : MonoBehaviour {
public Vector3 offsetAngle
public int width
public int height
public float fieldOfView
public string folder
public void CreateScreenshots()
public void PositionCamera(Camera cam, GameObject obj)
}
public ChineseLantern : BaseFuelLightSource {
public Transform pivotRotator
public float swaySpeed
public float swayDistance
public float lerpSpeed
}
public ChippyArcadeGame : BaseArcadeGame {
public ChippyMainCharacter mainChar
public SpriteArcadeEntity mainCharAim
public ChippyBoss currentBoss
public ChippyBoss[] bossPrefabs
public SpriteArcadeEntity mainMenuLogo
public Transform respawnPoint
public Vector2 mouseAim
public TextArcadeEntity levelIndicator
public TextArcadeEntity gameOverIndicator
public TextArcadeEntity playGameButton
public TextArcadeEntity highScoresButton
public bool OnMainMenu
public bool GameActive
public int level
public TextArcadeEntity[] scoreDisplays
public MenuButtonArcadeEntity[] mainMenuButtons
public int selectedButtonIndex
public bool OnHighScores
}
public ChippyBoss : SpriteArcadeEntity {
public Vector2 roamDistance
public float animationSpeed
public Sprite[] animationFrames
public ArcadeEntity bulletTest
public SpriteRenderer flashRenderer
public BossDamagePoint[] damagePoints
}
public ChippyBulletEntity : SpriteArcadeEntity {
public float speed
public float maxSpeed
public float radius
public float damage
public ArcadeEntity bulletImpact
}
public ChippyMainCharacter : SpriteArcadeEntity {
public float speed
public float maxSpeed
public ChippyBulletEntity bulletPrefab
public float fireRate
public Vector3 aimDir
}
public ChippyMoveTest : MonoBehaviour {
public Vector3 heading
public float speed
public float maxSpeed
private void FixedUpdate()
}
public ChristmasTree : StorageContainer {
public GameObject[] decorations
public bool ItemFilter(Item item, int targetSlot)
public void OnItemAddedOrRemoved(Item item, bool added)
}
public Client : SingletonComponent`1<Client> {
public Phrase loading_loading
public Phrase loading_connecting
public Phrase loading_connectionaccepted
public Phrase loading_connecting_negotiate
public Phrase loading_level
public Phrase loading_skinnablewarmup
public Phrase loading_preloadcomplete
public Phrase loading_openingscene
public Phrase loading_clientready
public Phrase loading_prefabwarmup
}
public ClientIOLine : BaseMonoBehaviour {
public RendererLOD _lod
public LineRenderer _line
public Material directionalMaterial
public Material defaultMaterial
public IOType lineType
public List`1<ClientIOLine> _allLines
public IOEntity ownerIOEnt
}
public Climate : SingletonComponent`1<Climate> {
private float fadeAngle
private float defaultTemp
private int weatherDurationHours
private int weatherFadeHours
public float BlendingSpeed
public float FogMultiplier
public float FogDarknessDistance
public bool DebugLUTBlending
public WeatherParameters Weather
public WeatherPreset[] WeatherPresets
public ClimateParameters Arid
public ClimateParameters Temperate
public ClimateParameters Tundra
public ClimateParameters Arctic
private float <WeatherStateBlend>k__BackingField
private UInt32 <WeatherSeedPrevious>k__BackingField
private UInt32 <WeatherSeedTarget>k__BackingField
private UInt32 <WeatherSeedNext>k__BackingField
private WeatherPreset <WeatherStatePrevious>k__BackingField
private WeatherPreset <WeatherStateTarget>k__BackingField
private WeatherPreset <WeatherStateNext>k__BackingField
private WeatherPreset <WeatherState>k__BackingField
private WeatherPreset <WeatherClampsMin>k__BackingField
private WeatherPreset <WeatherClampsMax>k__BackingField
private WeatherPreset <WeatherOverrides>k__BackingField
private LegacyWeatherState <Overrides>k__BackingField
public Dictionary`2<WeatherPresetType, WeatherPreset[]> presetLookup
private ClimateParameters[] climateLookup
public float WeatherStateBlend
public UInt32 WeatherSeedPrevious
public UInt32 WeatherSeedTarget
public UInt32 WeatherSeedNext
public WeatherPreset WeatherStatePrevious
public WeatherPreset WeatherStateTarget
public WeatherPreset WeatherStateNext
public WeatherPreset WeatherState
public WeatherPreset WeatherClampsMin
public WeatherPreset WeatherClampsMax
public WeatherPreset WeatherOverrides
public LegacyWeatherState Overrides
public float get_WeatherStateBlend()
public void set_WeatherStateBlend(float value)
public UInt32 get_WeatherSeedPrevious()
public void set_WeatherSeedPrevious(UInt32 value)
public UInt32 get_WeatherSeedTarget()
public void set_WeatherSeedTarget(UInt32 value)
public UInt32 get_WeatherSeedNext()
public void set_WeatherSeedNext(UInt32 value)
public WeatherPreset get_WeatherStatePrevious()
public void set_WeatherStatePrevious(WeatherPreset value)
public WeatherPreset get_WeatherStateTarget()
public void set_WeatherStateTarget(WeatherPreset value)
public WeatherPreset get_WeatherStateNext()
public void set_WeatherStateNext(WeatherPreset value)
public WeatherPreset get_WeatherState()
public void set_WeatherState(WeatherPreset value)
public WeatherPreset get_WeatherClampsMin()
private void set_WeatherClampsMin(WeatherPreset value)
public WeatherPreset get_WeatherClampsMax()
private void set_WeatherClampsMax(WeatherPreset value)
public WeatherPreset get_WeatherOverrides()
public void set_WeatherOverrides(WeatherPreset value)
public LegacyWeatherState get_Overrides()
public void set_Overrides(LegacyWeatherState value)
protected void Awake()
protected void OnDestroy()
public void Update()
private bool Initialized()
public float GetClouds(Vector3 position)
public float GetFog(Vector3 position)
public float GetWind(Vector3 position)
public float GetThunder(Vector3 position)
public float GetRainbow(Vector3 position)
public float GetAurora(Vector3 position)
public float GetRain(Vector3 position)
public float GetSnow(Vector3 position)
public float GetTemperature(Vector3 position)
private UInt32 GetSeedFromLong(long val)
private WeatherPreset GetWeatherPreset(UInt32 seed)
private WeatherPreset GetWeatherPreset(UInt32 seed, WeatherPresetType type)
public WeatherPreset[] CacheWeatherPresets(WeatherPresetType type)
private float FindBlendParameters(Vector3 pos, ClimateParameters& src, ClimateParameters& dst)
}
public ClimateBlendTexture : ProcessedTexture {
public void .ctor(int width, int height, bool linear)
public bool CheckLostData()
public void Blend(Texture srcLut1, Texture dstLut1, float lerpLut1, Texture srcLut2, Texture dstLut2, float lerpLut2, float lerp, ClimateBlendTexture prevLut, float time)
public void Swap(ClimateBlendTexture& a, ClimateBlendTexture& b)
}
public ClothingBenchmarkScene : BenchmarkScene {
public GameObjectRef PlayerModelPrefab
public bool ChangeClothingEveryFrame
}
public ClothingMovementProperties : ScriptableObject {
public float speedReduction
public float minSpeedReduction
public float waterSpeedBonus
}
public ClothLOD : FacepunchBehaviour {
public float clothLODDist
public Cloth cloth
}
public ClothWindModify : FacepunchBehaviour {
public Cloth cloth
private Vector3 initialClothForce
public Vector3 worldWindScale
public Vector3 turbulenceScale
}
public CodeLock : BaseLock {
public GameObjectRef keyEnterDialog
public GameObjectRef effectUnlocked
public GameObjectRef effectLocked
public GameObjectRef effectDenied
public GameObjectRef effectCodeChanged
public GameObjectRef effectShock
public bool hasCode
public bool hasGuestCode
public string code
public string guestCode
public List`1<ulong> whitelistPlayers
public List`1<ulong> guestPlayers
public int wrongCodes
public float lastWrongTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
internal void DoEffect(string effect)
public bool OnTryToOpen(BasePlayer player)
public bool OnTryToClose(BasePlayer player)
public void Save(SaveInfo info)
private void RPC_ChangeCode(RPCMessage rpc)
private void TryUnlock(RPCMessage rpc)
private void TryLock(RPCMessage rpc)
private void UnlockWithCode(RPCMessage rpc)
}
public ColdBreath : BaseMonoBehaviour {
public GameObjectRef effect
private BasePlayer player
private Transform jawBone
}
public ColdOverlay : ImageEffectLayer {
internal bool isPlaying
public ScreenOverlayEx screenOverlay
public CC_Frost frost
public LensDirtiness lensDirtyness
}
public CollateTrainTracks : ProceduralComponent {
private float MAX_NODE_DIST
private float MAX_NODE_DIST_SQR
private float MAX_NODE_ANGLE
public bool RunOnCache
public bool get_RunOnCache()
public void Process(UInt32 seed)
internal bool <Process>g__CompareNodes|5_0(bool ourStart, bool theirStart, <>c__DisplayClass5_0& , <>c__DisplayClass5_1& , <>c__DisplayClass5_2& , <>c__DisplayClass5_3& )
}
public CollectableEasterEgg : BaseEntity {
public Transform artwork
public float bounceRange
public float bounceSpeed
public GameObjectRef pickupEffect
public ItemDefinition itemToGive
private float lastPickupStartTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void RPC_StartPickUp(RPCMessage msg)
public void RPC_PickUp(RPCMessage msg)
}
public CollectibleEntity : BaseEntity {
public Phrase itemName
public ItemAmount[] itemList
public GameObjectRef pickupEffect
public float xpScale
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsFood()
public void DoPickup(BasePlayer reciever)
public void Pickup(RPCMessage msg)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public CollectionEx : object {
public bool IsNullOrEmpty(ICollection`1<T> collection)
public bool IsEmpty(ICollection`1<T> collection)
}
public ColliderInfo : MonoBehaviour {
public Flags FlagsNone
public Flags FlagsEverything
public Flags FlagsDefault
public Flags flags
public bool HasFlag(Flags f)
public void SetFlag(Flags f, bool b)
public bool Filter(HitTest info)
}
public CombatLog : object {
private string selfname
private string noname
private BasePlayer player
private Queue`1<Event> storage
private float <LastActive>k__BackingField
private Dictionary`2<ulong, Queue`1<Event>> players
public float LastActive
public float get_LastActive()
private void set_LastActive(float value)
public void .ctor(BasePlayer player)
public void Init()
public void Save()
public void Log(AttackEntity weapon, string description)
public void Log(AttackEntity weapon, Projectile projectile, string description)
public void Log(HitInfo info, string description)
public void Log(HitInfo info, float health_old, float health_new, string description)
public void Log(Event val)
public string Get(int count)
public Queue`1<Event> Get(ulong id)
}
public CommandBufferDesc : object {
private CameraEvent <CameraEvent>k__BackingField
private int <OrderId>k__BackingField
private Action`1<CommandBuffer> <FillDelegate>k__BackingField
public CameraEvent CameraEvent
public int OrderId
public Action`1<CommandBuffer> FillDelegate
public CameraEvent get_CameraEvent()
private void set_CameraEvent(CameraEvent value)
public int get_OrderId()
private void set_OrderId(int value)
public Action`1<CommandBuffer> get_FillDelegate()
private void set_FillDelegate(Action`1<CommandBuffer> value)
public void .ctor(CameraEvent cameraEvent, int orderId, FillCommandBuffer fill)
}
public CommandBufferEx : object {
public void BlitArray(CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Material mat, int slice, int pass)
public void BlitArray(CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Texture target, Material mat, int slice, int pass)
public void BlitArrayMip(CommandBuffer cb, Mesh blitMesh, Texture source, int sourceMip, int sourceSlice, Texture target, int targetMip, int targetSlice, Material mat, int pass)
public void BlitMip(CommandBuffer cb, Mesh blitMesh, Texture source, Texture target, int mip, int slice, Material mat, int pass)
}
public CommentComponent : MonoBehaviour {
public string comment
}
public CommunityEntity : PointEntity {
public CommunityEntity ServerInstance
public CommunityEntity ClientInstance
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void InitShared()
public void DestroyShared()
}
public CompanionServer.AppPlayerExtensions : object {
public AppTeamInfo GetAppTeamInfo(BasePlayer player, ulong steamId)
public AppTeamInfo GetAppTeamInfo(PlayerTeam team, ulong requesterSteamId)
private List`1<Note> GetMapNotes(BasePlayer player, bool personalNotes)
private void AddMapNote(List`1<Note> result, MapNote note, MapNoteType type)
}
public CompanionServer.BanList`1 : object {
private Dictionary`2<TKey, double> _bans
public void Ban(TKey key, double timeInSeconds)
public bool IsBanned(TKey key)
public void Cleanup()
}
public CompanionServer.ChatLog : object {
private int MaxBacklog
private Dictionary`2<ulong, ChatState> States
public void Record(ulong teamId, ulong steamId, string name, string message, string color, UInt32 time)
public void Remove(ulong teamId)
public IReadOnlyList`1<Entry> GetHistory(ulong teamId)
}
public CompanionServer.Connection : object {
private MemoryStream MessageStream
private Listener _listener
private IWebSocketConnection _connection
private HashSet`1<PlayerTarget> _subscribedPlayers
private HashSet`1<EntityTarget> _subscribedEntities
public IPAddress Address
public IPAddress get_Address()
public void .ctor(Listener listener, IWebSocketConnection connection)
public void OnClose()
public void OnMessage(Span`1<byte> data)
public void Close()
public void Send(AppResponse response)
public void Subscribe(PlayerTarget target)
public void Unsubscribe(PlayerTarget target)
public void Subscribe(EntityTarget target)
public void Unsubscribe(EntityTarget target)
public void SendRaw(MemoryBuffer data)
public void RenderCompleted(UInt32 requestId, UInt32 frame, Span`1<byte> jpgImage)
}
public CompanionServer.ConnectionLimiter : object {
private object _sync
private Dictionary`2<IPAddress, int> _addressCounts
private int _overallCount
public bool TryAdd(IPAddress address)
public void Remove(IPAddress address)
public void Clear()
public string ToString()
}
public CompanionServer.EntityTarget : ValueType {
private UInt32 <EntityId>k__BackingField
public UInt32 EntityId
public UInt32 get_EntityId()
public void .ctor(UInt32 entityId)
public bool Equals(EntityTarget other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(EntityTarget left, EntityTarget right)
public bool op_Inequality(EntityTarget left, EntityTarget right)
}
public CompanionServer.Handlers.BaseEntityHandler`1 : BaseHandler`1<T> {
private AppIOEntity <Entity>k__BackingField
protected AppIOEntity Entity
protected AppIOEntity get_Entity()
private void set_Entity(AppIOEntity value)
public void EnterPool()
public ValidationResult Validate()
}
public CompanionServer.Handlers.BaseHandler`1 : object {
private TokenBucketList`1<ulong> _playerBuckets
private IConnection <Client>k__BackingField
private AppRequest <Request>k__BackingField
private T <Proto>k__BackingField
private ulong <UserId>k__BackingField
private BasePlayer <Player>k__BackingField
protected int TokenCost
public IConnection Client
public AppRequest Request
public T Proto
protected ulong UserId
protected BasePlayer Player
protected int get_TokenCost()
public IConnection get_Client()
private void set_Client(IConnection value)
public AppRequest get_Request()
private void set_Request(AppRequest value)
public T get_Proto()
private void set_Proto(T value)
protected ulong get_UserId()
private void set_UserId(ulong value)
protected BasePlayer get_Player()
private void set_Player(BasePlayer value)
public void Initialize(TokenBucketList`1<ulong> playerBuckets, IConnection client, AppRequest request, T proto)
public void EnterPool()
public void LeavePool()
public ValidationResult Validate()
public void Execute()
protected void SendSuccess()
public void SendError(string code)
public void SendFlag(bool value)
protected void Send(AppResponse response)
}
public CompanionServer.Handlers.CameraFrame : BaseHandler`1<AppCameraFrameRequest> {
protected int TokenCost
protected int get_TokenCost()
public void Execute()
}
public CompanionServer.Handlers.CheckSubscription : BaseEntityHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.EntityInfo : BaseEntityHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.IHandler {
public AppRequest Request
public AppRequest get_Request()
public ValidationResult Validate()
public void Execute()
public void SendError(string code)
}
public CompanionServer.Handlers.Info : BaseHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.Map : BaseHandler`1<AppEmpty> {
private int _width
private int _height
private Byte[] _imageData
private string _background
protected int TokenCost
protected int get_TokenCost()
public void Execute()
public void PopulateCache()
private void RenderToCache()
}
public CompanionServer.Handlers.MapMarkers : BaseHandler`1<AppEmpty> {
public void Execute()
private AppMarker GetPlayerMarker(BasePlayer player)
}
public CompanionServer.Handlers.PromoteToLeader : BaseHandler`1<AppPromoteToLeader> {
public void Execute()
}
public CompanionServer.Handlers.SendTeamChat : BaseHandler`1<AppSendMessage> {
protected int TokenCost
protected int get_TokenCost()
public void Execute()
}
public CompanionServer.Handlers.SetEntityValue : BaseEntityHandler`1<AppSetEntityValue> {
public void Execute()
}
public CompanionServer.Handlers.SetSubscription : BaseEntityHandler`1<AppFlag> {
public void Execute()
}
public CompanionServer.Handlers.TeamChat : BaseHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.TeamInfo : BaseHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.Time : BaseHandler`1<AppEmpty> {
public void Execute()
}
public CompanionServer.Handlers.ValidationResult : Enum {
public int value__
public ValidationResult Success
public ValidationResult NotFound
public ValidationResult RateLimit
public ValidationResult Banned
public ValidationResult Rejected
}
public CompanionServer.IBroadcastSender`2 {
public void BroadcastTo(List`1<TTarget> targets, TMessage message)
}
public CompanionServer.IConnection {
public void Send(AppResponse response)
public void Subscribe(PlayerTarget target)
public void Unsubscribe(PlayerTarget target)
public void Subscribe(EntityTarget target)
public void Unsubscribe(EntityTarget target)
}
public CompanionServer.ITokenBucketSettings {
public double MaxTokens
public double TokensPerSec
public double get_MaxTokens()
public double get_TokensPerSec()
}
public CompanionServer.Listener : object {
private ByteArrayStream Stream
private TokenBucketList`1<IPAddress> _ipTokenBuckets
private BanList`1<IPAddress> _ipBans
private TokenBucketList`1<ulong> _playerTokenBuckets
private TokenBucketList`1<ulong> _pairingTokenBuckets
private Queue`1<Message> _messageQueue
private WebSocketServer _server
private Stopwatch _stopwatch
private RealTimeSince _lastCleanup
public IPAddress Address
public int Port
public ConnectionLimiter Limiter
public SubscriberList`3<PlayerTarget, Connection, AppBroadcast> PlayerSubscribers
public SubscriberList`3<EntityTarget, Connection, AppBroadcast> EntitySubscribers
public void .ctor(IPAddress ipAddress, int port)
public void Dispose()
internal void Enqueue(Connection connection, MemoryBuffer data)
public void Update()
private void Dispatch(Message message)
public void BroadcastTo(List`1<Connection> targets, AppBroadcast broadcast)
private MemoryBuffer GetBroadcastBuffer(AppBroadcast broadcast)
public bool CanSendPairingNotification(ulong playerId)
private void <.ctor>b__15_0(IWebSocketConnection socket)
private bool <Dispatch>g__Handle|19_13(Func`2<AppRequest, TProto> protoSelector, IHandler& requestHandler, <>c__DisplayClass19_0& )
}
public CompanionServer.NotificationChannel : Enum {
public int value__
public NotificationChannel Pairing
public NotificationChannel PlayerLoggedIn
public NotificationChannel PlayerDied
public NotificationChannel SmartAlarm
}
public CompanionServer.NotificationList : object {
private string ApiEndpoint
private HttpClient Http
private HashSet`1<ulong> _subscriptions
private double _lastSend
public bool AddSubscription(ulong steamId)
public bool RemoveSubscription(ulong steamId)
public bool HasSubscription(ulong steamId)
public List`1<ulong> ToList()
public void LoadFrom(List`1<ulong> steamIds)
public void IntersectWith(List`1<PlayerNameID> players)
public Task`1<NotificationSendResult> SendNotification(NotificationChannel channel, string title, string body, string type)
public Task`1<NotificationSendResult> SendNotificationTo(ICollection`1<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data)
public Task`1<NotificationSendResult> SendNotificationTo(ulong steamId, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data)
private Task`1<NotificationSendResult> SendNotificationImpl(ICollection`1<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data)
}
public CompanionServer.NotificationSendResult : Enum {
public int value__
public NotificationSendResult Failed
public NotificationSendResult Sent
public NotificationSendResult Empty
public NotificationSendResult Disabled
public NotificationSendResult RateLimited
public NotificationSendResult ServerError
public NotificationSendResult NoTargetsFound
public NotificationSendResult TooManySubscribers
}
public CompanionServer.PlayerTarget : ValueType {
private ulong <SteamId>k__BackingField
public ulong SteamId
public ulong get_SteamId()
public void .ctor(ulong steamId)
public bool Equals(PlayerTarget other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(PlayerTarget left, PlayerTarget right)
public bool op_Inequality(PlayerTarget left, PlayerTarget right)
}
public CompanionServer.PushRequest : object {
public string ServerToken
public List`1<ulong> SteamIds
public NotificationChannel Channel
public string Title
public string Body
public Dictionary`2<string, string> Data
public void EnterPool()
public void LeavePool()
}
public CompanionServer.Server : object {
private string ApiEndpoint
private HttpClient Http
public ChatLog TeamChat
internal string Token
private Listener <Listener>k__BackingField
public Listener Listener
public Listener get_Listener()
private void set_Listener(Listener value)
public void Initialize()
public void Shutdown()
public void Update()
public void Broadcast(PlayerTarget target, AppBroadcast broadcast)
public void Broadcast(EntityTarget target, AppBroadcast broadcast)
public void ClearSubscribers(EntityTarget target)
public bool CanSendPairingNotification(ulong playerId)
private void SetupServerRegistration()
private bool TryLoadServerRegistration(String& serverId, String& serverToken)
private void SetServerRegistration(string responseJson)
private string GetServerIdPath()
}
public CompanionServer.SubscriberList`3 : object {
private object _syncRoot
private Dictionary`2<TKey, HashSet`1<TTarget>> _subscriptions
private IBroadcastSender`2<TTarget, TMessage> _sender
public void .ctor(IBroadcastSender`2<TTarget, TMessage> sender)
public void Add(TKey key, TTarget value)
public void Remove(TKey key, TTarget value)
public void Clear(TKey key)
public void Send(TKey key, TMessage message)
}
public CompanionServer.TokenBucket : object {
private double _lastUpdate
private double _tokens
public ITokenBucketSettings Settings
public bool IsFull
public bool IsNaughty
public bool get_IsFull()
public bool get_IsNaughty()
public void Reset()
public bool TryTake(double requestedTokens)
private void Update()
}
public CompanionServer.TokenBucketList`1 : object {
private Dictionary`2<TKey, TokenBucket> _buckets
private double <MaxTokens>k__BackingField
private double <TokensPerSec>k__BackingField
public double MaxTokens
public double TokensPerSec
public double get_MaxTokens()
public double get_TokensPerSec()
public void .ctor(double maxTokens, double tokensPerSec)
public TokenBucket Get(TKey key)
public void Cleanup()
}
public CompanionServer.Util : object {
public int OceanMargin
public Phrase NotificationEmpty
public Phrase NotificationDisabled
public Phrase NotificationRateLimit
public Phrase NotificationServerError
public Phrase NotificationNoTargets
public Phrase NotificationTooManySubscribers
public Phrase NotificationUnknown
public Vector2 WorldToMap(Vector3 worldPos)
public void SendSignedInNotification(BasePlayer player)
public void SendDeathNotification(BasePlayer player, BaseEntity killer)
public Task`1<NotificationSendResult> SendPairNotification(string type, BasePlayer player, string title, string message, Dictionary`2<string, string> data)
public Dictionary`2<string, string> GetServerPairingData()
public Dictionary`2<string, string> GetPlayerPairingData(BasePlayer player)
public void BroadcastAppTeamRemoval(BasePlayer player)
public void BroadcastAppTeamUpdate(PlayerTeam team)
public void BroadcastTeamChat(PlayerTeam team, ulong steamId, string name, string message, string color)
public void SendNotification(PlayerTeam team, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data, ulong ignorePlayer)
public string ToErrorCode(ValidationResult result)
public string ToErrorMessage(NotificationSendResult result)
}
public CompanionSetupScreen : SingletonComponent`1<CompanionSetupScreen> {
public string PairedKey
public GameObject instructionsBody
public GameObject detailsPanel
public GameObject loadingMessage
public GameObject errorMessage
public GameObject notSupportedMessage
public GameObject disabledMessage
public GameObject enabledMessage
public GameObject refreshButton
public GameObject enableButton
public GameObject disableButton
public GameObject pairButton
public RustText serverName
public RustButton helpButton
}
public CompassMapMarker : MonoBehaviour {
public Image MarkerImage
public GameObject LeaderRoot
}
public ComponentInfo : MonoBehaviour {
public void Setup()
public void Reset()
}
public ComponentInfo`1 : ComponentInfo {
public T component
public void Initialize(T source)
}
public Composter : StorageContainer {
public ItemDefinition FertilizerDef
public bool CompostEntireStack
private float fertilizerProductionProgress
protected float UpdateInterval
protected float get_UpdateInterval()
public void ServerInit()
public bool InventoryItemFilter(Item item, int targetSlot)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
private bool ItemIsFertilizer(Item item)
public void UpdateComposting()
private void CompostItem(Item item)
private void ProduceFertilizer(int amount)
}
public CompoundBowWeapon : BowWeapon {
public float stringHoldDurationMax
public float stringBonusDamage
public float stringBonusDistance
public float stringBonusVelocity
public float movementPenaltyRampUpTime
public SoundDefinition chargeUpSoundDef
public SoundDefinition stringHeldSoundDef
public SoundDefinition drawFinishSoundDef
private Sound chargeUpSound
private Sound stringHeldSound
protected float movementPenalty
internal float stringHoldTimeStart
protected float serverMovementCheckTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void UpdateMovementPenalty(float delta)
public void ServerMovementCheck()
public void OnHeldChanged()
public void RPC_StringHoldStatus(RPCMessage msg)
public void DidAttackServerside()
public float GetLastPlayerMovementTime()
public float GetStringBonusScale()
public float GetDamageScale(bool getMax)
public float GetDistanceScale(bool getMax)
public float GetProjectileVelocityScale(bool getMax)
}
public ComputerMenu : UIDialog {
public RectTransform bookmarkContainer
public GameObject bookmarkPrefab
public List`1<RCBookmarkEntry> activeEntries
}
public ComputerStation : BaseMountable {
public GameObjectRef menuPrefab
public ComputerMenu computerMenu
public EntityRef currentlyControllingEnt
public Dictionary`2<string, UInt32> controlBookmarks
public Transform leftHandIKPosition
public Transform rightHandIKPosition
public SoundDefinition turnOnSoundDef
public SoundDefinition turnOffSoundDef
public SoundDefinition onLoopSoundDef
private float nextAddTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsValidIdentifier(string str)
public void DestroyShared()
public void SetPlayerSecondaryGroupFor(BaseEntity ent)
public void StopControl(BasePlayer ply)
public bool IsPlayerAdmin(BasePlayer player)
public void DeleteBookmark(RPCMessage msg)
public void Server_DisconnectControl(RPCMessage msg)
public void BeginControllingBookmark(RPCMessage msg)
public bool CanAddBookmark(BasePlayer player)
public void AddBookmark(RPCMessage msg)
public void ControlCheck()
public string GenerateControlBookmarkString()
public void SendControlBookmarks(BasePlayer player)
public void OnPlayerMounted()
public void OnPlayerDismounted(BasePlayer player)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ConditionalModel : PrefabAttribute {
public GameObjectRef prefab
public bool onClient
public bool onServer
public ModelConditionTest[] conditions
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool RunTests(BaseEntity parent)
public GameObject InstantiateSkin(BaseEntity parent)
protected Type GetIndexedType()
}
public ConnectionAuth : MonoBehaviour {
public List`1<Connection> m_AuthConnection
public bool IsAuthed(ulong iSteamID)
public void Reject(Connection connection, string strReason, string strReasonPrivate)
public void OnDisconnect(Connection connection)
public void Approve(Connection connection)
public void OnNewConnection(Connection connection)
public IEnumerator AuthorisationRoutine(Connection connection)
}
public ConnectionQueue : object {
public List`1<Connection> queue
public List`1<Connection> joining
public float nextMessageTime
public int Queued
public int Joining
public int get_Queued()
public int get_Joining()
public void SkipQueue(ulong userid)
internal void Join(Connection connection)
public void Cycle(int availableSlots)
private void SendMessages()
private void SendMessage(Connection c, int position)
public void RemoveConnection(Connection connection)
private void JoinGame(Connection connection)
public void JoinedGame(Connection connection)
private bool CanJumpQueue(Connection connection)
public bool IsQueued(ulong userid)
public bool IsJoining(ulong userid)
}
public ConnectionScreen : SingletonComponent`1<ConnectionScreen> {
public Text statusText
public GameObject disconnectButton
public GameObject retryButton
public ServerBrowserInfo browserInfo
}
public ConsoleGen : object {
public Command[] All
}
public ConsoleNetwork : object {
internal void Init()
internal void OnClientCommand(Message packet)
internal void SendClientReply(Connection cn, string strCommand)
public void SendClientCommand(Connection cn, string strCommand, Object[] args)
public void SendClientCommand(List`1<Connection> cn, string strCommand, Object[] args)
public void BroadcastToAllClients(string strCommand, Object[] args)
}
public ConsoleUI : SingletonComponent`1<ConsoleUI> {
public TextMeshProUGUI text
public InputField outputField
public InputField inputField
public GameObject AutocompleteDropDown
public GameObject ItemTemplate
public Color errorColor
public Color warningColor
public Color inputColor
}
public Construction : PrefabAttribute {
public string lastPlacementError
public Option info
public bool canBypassBuildingPermission
public bool canRotateBeforePlacement
public bool canRotateAfterPlacement
public bool checkVolumeOnRotate
public bool checkVolumeOnUpgrade
public bool canPlaceAtMaxDistance
public bool placeOnWater
public Vector3 rotationAmount
public Vector3 applyStartingRotation
public float healthMultiplier
public float costMultiplier
public float maxplaceDistance
public Mesh guideMesh
public Socket_Base[] allSockets
public BuildingProximity[] allProximities
public ConstructionGrade defaultGrade
public SocketHandle socketHandle
public Bounds bounds
public bool isBuildingPrivilege
public ConstructionGrade[] grades
public Deployable deployable
public ConstructionPlaceholder placeholder
public bool UpdatePlacement(Transform transform, Construction common, Target& target)
private bool TestPlacingThroughRock(Placement& placement, Target target)
private bool TestPlacingThroughWall(Placement& placement, Transform transform, Construction common, Target target)
private bool TestPlacingCloseToRoad(Placement& placement, Target target)
public bool ShowAsNeutral(Target target)
public BaseEntity CreateConstruction(Target target, bool bNeedsValidPlacement)
public bool HasMaleSockets(Target target)
public void FindMaleSockets(Target target, List`1<Socket_Base> sockets)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
}
public ConstructionGrade : PrefabAttribute {
public Construction construction
public BuildingGrade gradeBase
public GameObjectRef skinObject
internal List`1<ItemAmount> _costToBuild
public float maxHealth
public List`1<ItemAmount> costToBuild
public float get_maxHealth()
public List`1<ItemAmount> get_costToBuild()
protected Type GetIndexedType()
}
public ConstructionPlaceholder : PrefabAttribute {
public Mesh mesh
public Material material
public bool renderer
public bool collider
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
}
public ConstructionSkin : BasePrefab {
private List`1<GameObject> conditionals
public int DetermineConditionalModelState(BuildingBlock parent)
private void CreateConditionalModels(BuildingBlock parent)
private void DestroyConditionalModels(BuildingBlock parent)
public void Refresh(BuildingBlock parent)
public void Destroy(BuildingBlock parent)
}
public ConstructionSocket : Socket_Base {
public Type socketType
public int rotationDegrees
public int rotationOffset
public bool restrictPlacementRotation
public bool restrictPlacementAngle
public float faceAngle
public float angleAllowed
public float support
private void OnDrawGizmos()
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public bool IsCompatible(Socket_Base socket)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
public bool TestRestrictedAngles(Vector3 suggestedPos, Quaternion suggestedAng, Target target)
public Placement DoPlacement(Target target)
protected bool CanConnectToEntity(Target target)
}
public ConstructionSocket_Elevator : ConstructionSocket {
public int MaxFloor
protected bool CanConnectToEntity(Target target)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
}
public ConsumableInformationPanel : ItemInformationPanel {
public ItemTextValue[] values
public UIGenesDisplay Genes
public Text TextUnknownGenetics
public Text LabelGenetics
public GameObject GeneticsGameObject
public ItemTextValue durationValue
}
public ContainerIOEntity : IOEntity {
public ItemDefinition onlyAllowedItem
public ContentsType allowedContents
public int maxStackSize
public int numSlots
public string lootPanelName
public bool needsBuildingPrivilegeToUse
public bool isLootable
public float dropChance
public bool onlyOneUser
private ItemContainer <inventory>k__BackingField
public ItemContainer inventory
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanPickup(BasePlayer player)
public ItemContainer get_inventory()
private void set_inventory(ItemContainer value)
public void ServerInit()
public void PreServerLoad()
public void PostServerLoad()
public void CreateInventory(bool giveUID)
public void Save(SaveInfo info)
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool added)
protected void OnInventoryDirty()
public void OnKilled(HitInfo info)
public void DropItems(BaseEntity initiator)
private void RPC_OpenLoot(RPCMessage rpc)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public bool OccupiedCheck(BasePlayer player)
public void Load(LoadInfo info)
}
public ContainerSourceLocalPlayer : ItemContainerSource {
public Type type
public ItemContainer GetItemContainer()
}
public ContainerSourceLoot : ItemContainerSource {
public int container
public ItemContainer GetItemContainer()
}
public ContainerSourceSelectedItem : ItemContainerSource {
public ItemContainer GetItemContainer()
}
public ConVar.Admin : ConsoleSystem {
public void status(Arg arg)
public void stats(Arg arg)
public void killplayer(Arg arg)
public void kick(Arg arg)
public void kickall(Arg arg)
public void ban(Arg arg)
public void moderatorid(Arg arg)
public void ownerid(Arg arg)
public void removemoderator(Arg arg)
public void removeowner(Arg arg)
public void banid(Arg arg)
private bool TryGetBanExpiry(Arg arg, int n, Int64& expiry, String& durationSuffix)
public void unban(Arg arg)
public void skipqueue(Arg arg)
public void players(Arg arg)
public void say(Arg arg)
public void users(Arg arg)
public void sleepingusers(Arg arg)
public void sleepingusersinrange(Arg arg)
public void banlist(Arg arg)
public void banlistex(Arg arg)
public void listid(Arg arg)
public void mute(Arg arg)
public void unmute(Arg arg)
public void mutelist(Arg arg)
public void clientperf(Arg arg)
public void carstats(Arg arg)
public string teaminfo(Arg arg)
public void entid(Arg arg)
private string AuthList(BaseEntity ent)
private string CodeLockAuthList(CodeLock codeLock)
private string GetPlayerName(ulong steamId)
public PlayerInfo[] playerlist()
public User[] Bans()
public ServerInfoOutput ServerInfo()
public BuildInfo BuildInfo()
}
public ConVar.AI : ConsoleSystem {
public bool think
public bool ignoreplayers
public bool move
public float sensetime
public float frametime
public int ocean_patrol_path_iterations
public bool npc_enable
public int npc_max_population_military_tunnels
public int npc_spawn_per_tick_max_military_tunnels
public int npc_spawn_per_tick_min_military_tunnels
public float npc_respawn_delay_max_military_tunnels
public float npc_respawn_delay_min_military_tunnels
public float npc_valid_aim_cone
public float npc_valid_mounted_aim_cone
public float npc_cover_compromised_cooldown
public bool npc_cover_use_path_distance
public float npc_cover_path_vs_straight_dist_max_diff
public float npc_door_trigger_size
public float npc_patrol_point_cooldown
public float npc_speed_walk
public float npc_speed_run
public float npc_speed_sprint
public float npc_speed_crouch_walk
public float npc_speed_crouch_run
public float npc_alertness_drain_rate
public float npc_alertness_zero_detection_mod
public float npc_junkpile_a_spawn_chance
public float npc_junkpile_g_spawn_chance
public float npc_junkpile_dist_aggro_gate
public int npc_max_junkpile_count
public bool npc_families_no_hurt
public bool npc_ignore_chairs
public float npc_sensory_system_tick_rate_multiplier
public float npc_cover_info_tick_rate_multiplier
public float npc_reasoning_system_tick_rate_multiplier
public bool animal_ignore_food
public float npc_gun_noise_silencer_modifier
public bool nav_carve_use_building_optimization
public int nav_carve_min_building_blocks_to_apply_optimization
public float nav_carve_min_base_size
public float nav_carve_size_multiplier
public float nav_carve_height
public bool npc_only_hurt_active_target_in_safezone
public bool npc_use_new_aim_system
public bool npc_use_thrown_weapons
public float npc_max_roam_multiplier
public float npc_alertness_to_aim_modifier
public float npc_deliberate_miss_to_hit_alignment_time
public float npc_deliberate_miss_offset_multiplier
public float npc_deliberate_hit_randomizer
public float npc_htn_player_base_damage_modifier
public bool npc_spawn_on_cargo_ship
public int npc_htn_player_frustration_threshold
public float tickrate
public float TickDelta()
public void aiManagerLoadBalancerUpdateInterval(Arg args)
public void defaultLoadBalancerUpdateInterval(Arg args)
public void aiLoadBalancerUpdateInterval(Arg args)
public void NpcSenseLoadBalancerUpdateInterval(Arg args)
public void AnimalSenseLoadBalancerUpdateInterval(Arg args)
public void aiDebug_toggle(Arg args)
public void aiDebug_LoadBalanceOverdueReportServer(Arg args)
private void AddLBTableEntry(TextTable& table, string name, LoadBalancedQueue lb)
public void selectNPCLookatServer(Arg args)
}
public ConVar.AntiHack : ConsoleSystem {
public bool reporting
public bool admincheat
public bool objectplacement
public bool modelstate
public bool forceposition
public int userlevel
public int enforcementlevel
public float maxdesync
public float maxdeltatime
public float losradius
public float losforgiveness
public float tickhistorytime
public float tickhistoryforgiveness
public float relaxationrate
public float relaxationpause
public float maxviolation
public int terrain_protection
public int terrain_timeslice
public float terrain_padding
public float terrain_penalty
public bool terrain_kill
public int noclip_protection
public bool noclip_reject
public float noclip_penalty
public float noclip_margin
public float noclip_backtracking
public float noclip_stepsize
public int noclip_maxsteps
public int speedhack_protection
public bool speedhack_reject
public float speedhack_penalty
public float speedhack_forgiveness
public float speedhack_forgiveness_inertia
public float speedhack_slopespeed
public int flyhack_protection
public bool flyhack_reject
public float flyhack_penalty
public float flyhack_forgiveness_vertical
public float flyhack_forgiveness_vertical_inertia
public float flyhack_forgiveness_horizontal
public float flyhack_forgiveness_horizontal_inertia
public float flyhack_extrusion
public float flyhack_margin
public float flyhack_stepsize
public int flyhack_maxsteps
public int projectile_protection
public float projectile_penalty
public float projectile_forgiveness
public float projectile_serverframes
public float projectile_clientframes
public float projectile_trajectory
public float projectile_anglechange
public float projectile_velocitychange
public float projectile_desync
public float projectile_backtracking
public bool projectile_terraincheck
public int melee_protection
public float melee_penalty
public float melee_forgiveness
public float melee_serverframes
public float melee_clientframes
public bool melee_terraincheck
public int eye_protection
public float eye_penalty
public float eye_forgiveness
public float eye_serverframes
public float eye_clientframes
public bool eye_terraincheck
public bool build_terraincheck
public int debuglevel
}
public ConVar.App : ConsoleSystem {
public string listenip
public int port
public string publicip
public bool update
public bool notifications
public int queuelimit
public string serverid
public float alarmcooldown
public int maxconnections
public int maxconnectionsperip
public void pair(Arg arg)
public void info(Arg arg)
public void resetlimiter(Arg arg)
public void connections(Arg arg)
public IPAddress GetListenIP()
public string GetPublicIP()
}
public ConVar.Audio : ConsoleSystem {
public float master
public float musicvolume
public float musicvolumemenu
public float game
public float voices
public float instruments
public bool ambience
public float framebudget
public float minupdatefraction
public bool advancedocclusion
public bool hqsoundfade
public bool debugVoiceLimiting
public int speakers
public int get_speakers()
public void set_speakers(int value)
public void printSounds(Arg arg)
public void printEngineSounds(Arg arg)
}
public ConVar.Batching : ConsoleSystem {
public bool renderers
public bool renderer_threading
public int renderer_capacity
public int renderer_vertices
public int renderer_submeshes
public int verbose
}
public ConVar.Bradley : ConsoleSystem {
public float respawnDelayMinutes
public float respawnDelayVariance
public bool enabled
public void quickrespawn(Arg arg)
}
public ConVar.Chat : ConsoleSystem {
private float textRange
private float textVolumeBoost
public bool enabled
public List`1<ChatEntry> History
public bool serverlog
public void Broadcast(string message, string username, string color, ulong userid)
public void say(Arg arg)
public void teamsay(Arg arg)
public void cardgamesay(Arg arg)
private void sayImpl(ChatChannel targetChannel, Arg arg)
internal bool sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player)
public IEnumerable`1<ChatEntry> tail(Arg arg)
public IEnumerable`1<ChatEntry> search(Arg arg)
}
public ConVar.Console : ConsoleSystem {
public IEnumerable`1<Entry> tail(Arg arg)
public IEnumerable`1<Entry> search(Arg arg)
}
public ConVar.Construct : ConsoleSystem {
public float frameminutes
}
public ConVar.Craft : ConsoleSystem {
public bool instant
public void add(Arg args)
public void canceltask(Arg args)
public void cancel(Arg args)
public void fasttracktask(Arg args)
}
public ConVar.Data : ConsoleSystem {
public void export(Arg args)
}
public ConVar.Debugging : ConsoleSystem {
public bool checktriggers
public bool checkparentingtriggers
public bool disablecondition
public bool callbacks
public bool log
public void renderinfo(Arg arg)
public void set_log(bool value)
public bool get_log()
public void stall(Arg arg)
public void flushgroup(Arg arg)
public void breakheld(Arg arg)
public void puzzlereset(Arg arg)
public void puzzleprefabrespawn(Arg arg)
public void breakitem(Arg arg)
public void refillvitals(Arg arg)
public void heal(Arg arg)
public void hurt(Arg arg)
public void eat(Arg arg)
public void drink(Arg arg)
private void AdjustHealth(BasePlayer player, float amount, string bone)
private void AdjustCalories(BasePlayer player, float amount, float time)
private void AdjustHydration(BasePlayer player, float amount, float time)
}
public ConVar.Decay : ConsoleSystem {
public float outside_test_range
public float tick
public float scale
public bool debug
public bool upkeep
public float upkeep_period_minutes
public float upkeep_grief_protection
public float upkeep_heal_scale
public float upkeep_inside_decay_scale
public float delay_override
public float delay_twig
public float delay_wood
public float delay_stone
public float delay_metal
public float delay_toptier
public float duration_override
public float duration_twig
public float duration_wood
public float duration_stone
public float duration_metal
public float duration_toptier
public int bracket_0_blockcount
public float bracket_0_costfraction
public int bracket_1_blockcount
public float bracket_1_costfraction
public int bracket_2_blockcount
public float bracket_2_costfraction
public int bracket_3_blockcount
public float bracket_3_costfraction
}
public ConVar.Demo : ConsoleSystem {
public UInt32 Version
public float splitseconds
public float splitmegabytes
public string recordlist
public string record(Arg arg)
public string stop(Arg arg)
}
public ConVar.Entity : ConsoleSystem {
private TextTable GetEntityTable(Func`2<EntityInfo, bool> filter)
public void find_entity(Arg args)
public void find_id(Arg args)
public void find_group(Arg args)
public void find_parent(Arg args)
public void find_status(Arg args)
public void find_radius(Arg args)
public void find_self(Arg args)
public void debug_toggle(Arg args)
public void nudge(int entID)
public string svspawn(string name, Vector3 pos, Vector3 dir)
public string svspawnitem(string name, Vector3 pos)
public void spawnlootfrom(Arg args)
public int DeleteBy(ulong SteamId)
}
public ConVar.Env : ConsoleSystem {
public bool progresstime
public float time
public int day
public int month
public int year
public float oceanlevel
public void set_progresstime(bool value)
public bool get_progresstime()
public void set_time(float value)
public float get_time()
public void set_day(int value)
public int get_day()
public void set_month(int value)
public int get_month()
public void set_year(int value)
public int get_year()
public void addtime(Arg arg)
public float get_oceanlevel()
public void set_oceanlevel(float value)
}
public ConVar.FileConVar : ConsoleSystem {
public bool debug
public bool time
public bool get_debug()
public void set_debug(bool value)
public bool get_time()
public void set_time(bool value)
}
public ConVar.FPS : ConsoleSystem {
private int m_graph
public int limit
public int graph
public int get_limit()
public void set_limit(int value)
public int get_graph()
public void set_graph(int value)
}
public ConVar.gamemode : ConsoleSystem {
public void setteam(Arg arg)
public void set(Arg arg)
}
public ConVar.GC : ConsoleSystem {
public bool buffer_enabled
public int debuglevel
private int m_buffer
public int buffer
public bool incremental_enabled
public int incremental_milliseconds
public bool enabled
public int get_buffer()
public void set_buffer(int value)
public bool get_incremental_enabled()
public void set_incremental_enabled(bool value)
public int get_incremental_milliseconds()
public void set_incremental_milliseconds(int value)
public bool get_enabled()
public void set_enabled(bool value)
public void collect()
public void unload()
public void alloc(Arg args)
}
public ConVar.Global : ConsoleSystem {
private int _developer
public int maxthreads
public int perf
public bool god
public bool specnet
public int developer
public void set_developer(int value)
public int get_developer()
public void restart(Arg args)
public void quit(Arg args)
public void report(Arg args)
public void objects(Arg args)
public void textures(Arg args)
public void colliders(Arg args)
public void error(Arg args)
public void queue(Arg args)
public void setinfo(Arg args)
public void sleep(Arg args)
public void kill(Arg args)
public void respawn(Arg args)
public void injure(Arg args)
public void spectate(Arg args)
public void respawn_sleepingbag(Arg args)
public void respawn_sleepingbag_remove(Arg args)
public void status_sv(Arg args)
public void status_cl(Arg args)
public void teleport(Arg args)
public void teleport2me(Arg args)
public void teleportany(Arg args)
public void teleportpos(Arg args)
public void teleportlos(Arg args)
public void teleport2owneditem(Arg arg)
public void teleport2marker(Arg arg)
public void teleport2death(Arg arg)
public void free(Arg args)
public void version(Arg arg)
public void sysinfo(Arg arg)
public void sysuid(Arg arg)
public void breakitem(Arg args)
public void subscriptions(Arg arg)
}
public ConVar.Graphics : ConsoleSystem {
private float MinShadowDistance
private float MaxShadowDistance2Split
private float MaxShadowDistance4Split
private float _shadowdistance
public int shadowmode
public int shadowlights
private int _shadowquality
public bool grassshadows
public bool contactshadows
public float drawdistance
private float _fov
public bool hud
public bool chat
public bool branding
public int compass
public bool dof
public float dof_aper
public float dof_blur
public int dof_mode
public float dof_focus_dist
public float dof_focus_time
public bool dof_debug
public int dof_focus_target
public bool vm_fov_scale
public bool vm_horizontal_flip
private float _uiscale
private int _anisotropic
private int _parallax
public int quality
public float shadowdistance
public int shadowcascades
public int shadowquality
public float fov
public float lodbias
public int shaderlod
public float uiscale
public int af
public int parallax
public bool itemskins
public bool itemskinunload
public float itemskintimeout
public int get_quality()
public void set_quality(int value)
public float EnforceShadowDistanceBounds(float distance)
public float get_shadowdistance()
public void set_shadowdistance(float value)
public int get_shadowcascades()
public void set_shadowcascades(int value)
public int get_shadowquality()
public void set_shadowquality(int value)
public float get_fov()
public void set_fov(float value)
public float get_lodbias()
public void set_lodbias(float value)
public void dof_nudge(Arg arg)
public int get_shaderlod()
public void set_shaderlod(int value)
public float get_uiscale()
public void set_uiscale(float value)
public int get_af()
public void set_af(int value)
public int get_parallax()
public void set_parallax(int value)
public bool get_itemskins()
public void set_itemskins(bool value)
public bool get_itemskinunload()
public void set_itemskinunload(bool value)
public float get_itemskintimeout()
public void set_itemskintimeout(float value)
}
public ConVar.Halloween : ConsoleSystem {
public bool enabled
public float murdererpopulation
public float scarecrowpopulation
public bool scarecrows_throw_beancans
public float scarecrow_throw_beancan_global_delay
public float scarecrow_beancan_vs_player_dmg_modifier
public float scarecrow_body_dmg_modifier
public float scarecrow_chase_stopping_distance
}
public ConVar.Hierarchy : ConsoleSystem {
private GameObject currentDir
private Transform[] GetCurrent()
public void ls(Arg args)
public void cd(Arg args)
public void del(Arg args)
}
public ConVar.instruments : ConsoleSystem {
public string InstrumentsFolder
}
public ConVar.Inventory : ConsoleSystem {
private string LoadoutDirectory
public void lighttoggle(Arg arg)
public void endloot(Arg arg)
public void give(Arg arg)
public void resetbp(Arg arg)
public void unlockall(Arg arg)
public void giveall(Arg arg)
public void giveto(Arg arg)
public void giveid(Arg arg)
public void givearm(Arg arg)
public void copyTo(Arg arg)
public void deployLoadoutInRange(Arg arg)
public void deployLoadout(Arg arg)
private string GetLoadoutPath(string loadoutName)
public void saveloadout(Arg arg)
private bool LoadLoadout(string name, SavedLoadout& so)
public void listloadouts(Arg arg)
public void defs(Arg arg)
public void reloaddefs(Arg arg)
public void equipslottarget(Arg arg)
public void equipslot(Arg arg)
private void EquipItemInSlot(BasePlayer player, int slot)
private int GetSlotIndex(BasePlayer player)
}
public ConVar.Manifest : object {
public object PrintManifest()
public object PrintManifestRaw()
}
public ConVar.MemSnap : ConsoleSystem {
private string NeedProfileFolder()
public void managed(Arg arg)
public void native(Arg arg)
public void full(Arg arg)
}
public ConVar.Music : ConsoleSystem {
public bool enabled
public int songGapMin
public int songGapMax
public void info(Arg arg)
}
public ConVar.Net : ConsoleSystem {
public bool visdebug
public bool debug
public int visibilityRadiusFarOverride
public int visibilityRadiusNearOverride
}
public ConVar.PatrolHelicopter : ConsoleSystem {
private string path
public float lifetimeMinutes
public int guns
public float bulletDamageScale
public float bulletAccuracy
public void drop(Arg arg)
public void calltome(Arg arg)
public void call(Arg arg)
public void strafe(Arg arg)
public void testpuzzle(Arg arg)
}
public ConVar.Physics : ConsoleSystem {
private float baseGravity
public int droppedmode
public bool sendeffects
public bool groundwatchdebug
public int groundwatchfails
public float groundwatchdelay
public bool batchsynctransforms
public float bouncethreshold
public float sleepthreshold
public int solveriterationcount
public float gravity
public float steps
public float minsteps
public bool autosynctransforms
public float get_bouncethreshold()
public void set_bouncethreshold(float value)
public float get_sleepthreshold()
public void set_sleepthreshold(float value)
public int get_solveriterationcount()
public void set_solveriterationcount(int value)
public float get_gravity()
public void set_gravity(float value)
internal void ApplyDropped(Rigidbody rigidBody)
public float get_steps()
public void set_steps(float value)
public float get_minsteps()
public void set_minsteps(float value)
public bool get_autosynctransforms()
public void set_autosynctransforms(bool value)
}
public ConVar.Player : ConsoleSystem {
public int tickrate_cl
public int tickrate_sv
public void cinematic_play(Arg arg)
public void cinematic_stop(Arg arg)
public void copyrotation(Arg arg)
public void mount(Arg arg)
public void gotosleep(Arg arg)
public void dismount(Arg arg)
public void swapseat(Arg arg)
public void wakeup(Arg arg)
public void wakeupall(Arg arg)
public void printstats(Arg arg)
public void printpresence(Arg arg)
public void resetstate(Arg args)
public void fillwater(Arg arg)
public void createskull(Arg arg)
public void markhostile(Arg arg)
}
public ConVar.Pool : ConsoleSystem {
public int mode
public bool prewarm
public bool enabled
public bool debug
public void print_memory(Arg arg)
public void print_prefabs(Arg arg)
public void print_assets(Arg arg)
public void clear_memory(Arg arg)
public void clear_prefabs(Arg arg)
public void clear_assets(Arg arg)
public void export_prefabs(Arg arg)
}
public ConVar.Profile : ConsoleSystem {
private void NeedProfileFolder()
public void start(Arg arg)
public void stop(Arg arg)
}
public ConVar.Sentry : ConsoleSystem {
public bool targetall
public float hostileduration
}
public ConVar.Server : ConsoleSystem {
public string ip
public int port
public int queryport
public int maxplayers
public string hostname
public string identity
public string level
public string levelurl
public bool leveltransfer
public int seed
public int salt
public int worldsize
public int saveinterval
public bool secure
public int encryption
public int tickrate
public int entityrate
public float schematime
public float cycletime
public bool official
public bool stats
public bool globalchat
public bool stability
public bool radiation
public float itemdespawn
public float corpsedespawn
public float debrisdespawn
public bool pve
public bool cinematic
public string description
public string url
public string branch
public int queriesPerSecond
public int ipQueriesPerMin
public string headerimage
public string logoimage
public int saveBackupCount
public string motd
public float meleedamage
public float arrowdamage
public float bulletdamage
public float bleedingdamage
public float funWaterDamageThreshold
public float funWaterWetnessGain
public float meleearmor
public float arrowarmor
public float bulletarmor
public float bleedingarmor
public int updatebatch
public int updatebatchspawn
public int entitybatchsize
public float entitybatchtime
public float composterUpdateInterval
public float planttick
public float planttickscale
public bool useMinimumPlantCondition
public float nonPlanterDeathChancePerTick
public float ceilingLightGrowableRange
public float artificialTemperatureGrowableRange
public float ceilingLightHeightOffset
public float sprinklerRadius
public float sprinklerEyeHeightOffset
public float optimalPlanterQualitySaturation
public float metabolismtick
public float modifierTickRate
public float rewounddelay
public bool woundingenabled
public bool playerserverfall
public bool plantlightdetection
public float respawnresetrange
public int maxunack
public bool netcache
public bool corpses
public bool events
public bool dropitems
public int netcachesize
public int savecachesize
public int combatlogsize
public int combatlogdelay
public int authtimeout
public int playertimeout
public int idlekick
public int idlekickmode
public int idlekickadmins
public string gamemode
public string tags
public bool censorplayerlist
public string bansServerEndpoint
public int bansServerFailureMode
public int bansServerTimeout
public bool showHolsteredItems
public int maxpacketspersecond_world
public int maxpacketspersecond_rpc
public int maxpacketspersecond_rpc_signal
public int maxpacketspersecond_command
public int maxpacketsize_command
public int maxpacketspersecond_tick
public int maxpacketspersecond_voice
public bool packetlog_enabled
public bool rpclog_enabled
public int maxconnectionsperip
public float maxreceivetime
public int maxpacketspersecond
public int maxpacketsize
public string rootFolder
public string backupFolder
public string backupFolder1
public string backupFolder2
public string backupFolder3
public bool compression
public bool netlog
public float TickDelta()
public float TickTime(UInt32 tick)
public void setshowholstereditems(Arg arg)
public int get_maxconnectionsperip()
public void set_maxconnectionsperip(int value)
public float get_maxreceivetime()
public void set_maxreceivetime(float value)
public int get_maxpacketspersecond()
public void set_maxpacketspersecond(int value)
public int get_maxpacketsize()
public void set_maxpacketsize(int value)
public string packetlog(Arg arg)
public string rpclog(Arg arg)
public void start(Arg arg)
public void stop(Arg arg)
public string get_rootFolder()
public string get_backupFolder()
public string get_backupFolder1()
public string get_backupFolder2()
public string get_backupFolder3()
public void backup()
public string GetServerFolder(string folder)
public void writecfg(Arg arg)
public void fps(Arg arg)
public void save(Arg arg)
public string readcfg(Arg arg)
public bool get_compression()
public void set_compression(bool value)
public bool get_netlog()
public void set_netlog(bool value)
public void cheatreport(Arg arg)
public string combatlog(Arg arg)
public string printpos(Arg arg)
public string printrot(Arg arg)
public string printeyes(Arg arg)
public void snapshot(Arg arg)
public void sendnetworkupdate(Arg arg)
public void playerlistpos(Arg arg)
}
public ConVar.Spawn : ConsoleSystem {
public float min_rate
public float max_rate
public float min_density
public float max_density
public float player_base
public float player_scale
public bool respawn_populations
public bool respawn_groups
public bool respawn_individuals
public float tick_populations
public float tick_individuals
public void fill_populations(Arg args)
public void fill_groups(Arg args)
public void fill_individuals(Arg args)
public void report(Arg args)
public void scalars(Arg args)
}
public ConVar.SSS : ConsoleSystem {
public bool enabled
public int quality
public bool halfres
public float scale
}
public ConVar.Stability : ConsoleSystem {
public int verbose
public int strikes
public float collapse
public float accuracy
public float stabilityqueue
public float surroundingsqueue
public void refresh_stability(Arg args)
}
public ConVar.Supply : ConsoleSystem {
private string path
public void drop(Arg arg)
public void call(Arg arg)
}
public ConVar.Terrain : ConsoleSystem {
public float quality
}
public ConVar.Texture : ConsoleSystem {
public int streamingBudgetOverride
public bool streaming
public bool get_streaming()
public void set_streaming(bool value)
public void stats(Arg arg)
}
public ConVar.Time : ConsoleSystem {
public bool pausewhileloading
public float fixeddelta
public float maxdelta
public float timescale
public float get_fixeddelta()
public void set_fixeddelta(float value)
public float get_maxdelta()
public void set_maxdelta(float value)
public float get_timescale()
public void set_timescale(float value)
}
public ConVar.Tree : ConsoleSystem {
public bool global_broadcast
}
public ConVar.vehicle : ConsoleSystem {
public float boat_corpse_seconds
public bool cinematictrains
public bool carwrecks
public bool carsdroploot
public void swapseats(Arg arg)
public void fixcars(Arg arg)
}
public ConVar.Vis : ConsoleSystem {
public bool lerp
public bool damage
public bool attack
public bool protection
public bool weakspots
public bool triggers
public bool hitboxes
public bool lineofsight
public bool sense
}
public ConVar.Voice : ConsoleSystem {
public bool loopback
}
public ConVar.Water : ConsoleSystem {
public int quality
public int reflections
}
public ConVar.Weather : ConsoleSystem {
public float wetness_rain
public float wetness_snow
public float clear_chance
public float dust_chance
public float fog_chance
public float overcast_chance
public float storm_chance
public float rain_chance
public float rain
public float wind
public float thunder
public float rainbow
public float fog
public float atmosphere_rayleigh
public float atmosphere_mie
public float atmosphere_brightness
public float atmosphere_contrast
public float atmosphere_directionality
public float cloud_size
public float cloud_opacity
public float cloud_coverage
public float cloud_sharpness
public float cloud_coloring
public float cloud_attenuation
public float cloud_saturation
public float cloud_scattering
public float cloud_brightness
public void load(Arg args)
public void reset(Arg args)
public void report(Arg args)
public float get_clear_chance()
public void set_clear_chance(float value)
public float get_dust_chance()
public void set_dust_chance(float value)
public float get_fog_chance()
public void set_fog_chance(float value)
public float get_overcast_chance()
public void set_overcast_chance(float value)
public float get_storm_chance()
public void set_storm_chance(float value)
public float get_rain_chance()
public void set_rain_chance(float value)
public float get_rain()
public void set_rain(float value)
public float get_wind()
public void set_wind(float value)
public float get_thunder()
public void set_thunder(float value)
public float get_rainbow()
public void set_rainbow(float value)
public float get_fog()
public void set_fog(float value)
public float get_atmosphere_rayleigh()
public void set_atmosphere_rayleigh(float value)
public float get_atmosphere_mie()
public void set_atmosphere_mie(float value)
public float get_atmosphere_brightness()
public void set_atmosphere_brightness(float value)
public float get_atmosphere_contrast()
public void set_atmosphere_contrast(float value)
public float get_atmosphere_directionality()
public void set_atmosphere_directionality(float value)
public float get_cloud_size()
public void set_cloud_size(float value)
public float get_cloud_opacity()
public void set_cloud_opacity(float value)
public float get_cloud_coverage()
public void set_cloud_coverage(float value)
public float get_cloud_sharpness()
public void set_cloud_sharpness(float value)
public float get_cloud_coloring()
public void set_cloud_coloring(float value)
public float get_cloud_attenuation()
public void set_cloud_attenuation(float value)
public float get_cloud_saturation()
public void set_cloud_saturation(float value)
public float get_cloud_scattering()
public void set_cloud_scattering(float value)
public float get_cloud_brightness()
public void set_cloud_brightness(float value)
}
public ConVar.Workshop : ConsoleSystem {
public void print_approved_skins(Arg arg)
}
public ConVar.World : ConsoleSystem {
public bool cache
public bool streaming
public void monuments(Arg arg)
public void rendermap(Arg arg)
public void rendertunnels(Arg arg)
}
public ConVar.XMas : ConsoleSystem {
private string path
public bool enabled
public float spawnRange
public int spawnAttempts
public int giftsPerPlayer
public void refill(Arg arg)
}
public ConvarComponent : MonoBehaviour {
public bool runOnServer
public bool runOnClient
public List`1<ConvarEvent> List
protected void OnEnable()
protected void OnDisable()
private bool ShouldRun()
}
public ConvarControlledSpawnPopulation : SpawnPopulation {
public string PopulationConvar
private Command _command
protected Command Command
public float TargetDensity
protected Command get_Command()
public float get_TargetDensity()
}
public ConvarToggleChildren : MonoBehaviour {
public string ConvarName
public string ConvarEnabled
private bool state
private Command Command
protected void Awake()
protected void Update()
private void SetState(bool newState)
}
public ConvarWater : MonoBehaviour {
public WaterSystem water
}
public ConversationData : ScriptableObject {
public string shortname
public Phrase providerNameTranslated
public SpeechNode[] speeches
public string providerName
public string get_providerName()
public int GetSpeechNodeIndex(string speechShortName)
}
public CoreEnvBrdfLut : object {
private Texture2D runtimeEnvBrdfLut
private void OnRuntimeLoad()
private void PrepareTextureForRuntime()
private void UpdateReflProbe()
public Texture2D Generate(bool asset)
private UInt32 ReverseBits(UInt32 Bits)
}
public CounterConfig : UIDialog {
private PowerCounter powerCounter
public InputField input
public int target
}
public CoverageQueries : MonoBehaviour {
public bool debug
public float depthBias
}
public CoverageQueryFlare : BaseMonoBehaviour {
public bool isDynamic
public bool timeShimmer
public bool positionalShimmer
public bool rotate
public float maxVisibleDistance
public bool lightScaled
public float dotMin
public float dotMax
public RadiusSpace coverageRadiusSpace
public float coverageRadius
public LODDistanceMode DistanceMode
}
public CraftingNotice : MonoBehaviour {
public CanvasGroup canvasGroup
public TextMeshProUGUI itemName
public TextMeshProUGUI craftSeconds
}
public CraftingQueue : SingletonComponent`1<CraftingQueue> {
public GameObject queueContainer
public GameObject queueItemPrefab
private ScrollRect scrollRect
}
public CraftingQueueIcon : MonoBehaviour {
public CanvasGroup canvasGroup
public Image icon
public Image iconCancel
public GameObject timeLeft
public GameObject craftingCount
}
public Craptography : object {
private Byte[] hash
public void XOR(UInt32 seed, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
}
public CreateEffect : MonoBehaviour {
public GameObjectRef EffectToCreate
public void OnEnable()
}
public CrossbowWeapon : BaseProjectile {
public bool ForceSendMagazine()
public void DidAttackServerside()
}
public Crosshair : MonoBehaviour {
public bool Enabled
public Image Image
}
public CrushTrigger : TriggerHurt {
public bool includeNPCs
public bool requireCentreBelowPosition
internal GameObject InterestedInObject(GameObject obj)
protected bool CanHurt(BaseCombatEntity ent)
}
public cui : object {
public void test(Arg args)
public void endtest(Arg args)
}
public CullingVolume : MonoBehaviour {
public GameObject OccludeeRoot
public bool Invert
public bool Portal
public List`1<CullingVolume> Connections
}
public CursorManager : SingletonComponent`1<CursorManager> {
private int iHoldOpen
private int iPreviousOpen
private void Update()
public void SwitchToGame()
private void SwitchToUI()
public void HoldOpen(bool cursorVisible)
}
public CustomDoorManipulator : DoorManipulator {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool PairWithLockedDoors()
public bool CanPlayerAdmin(BasePlayer player)
public bool IsPaired()
public void RefreshDoor()
private void OnPhysicsNeighbourChanged()
public void SetupInitialDoorConnection()
public void DoActionDoorMissing()
public void DoPair(RPCMessage msg)
public void ServerActionChange(RPCMessage msg)
}
public CustomTimerSwitch : TimerSwitch {
public GameObjectRef timerPanelPrefab
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void UpdateFromInput(int inputAmount, int inputSlot)
public void SERVER_SetTime(RPCMessage msg)
public bool CanPlayerAdmin(BasePlayer player)
}
public DamageProperties : ScriptableObject {
public DamageProperties fallback
public HitAreaProperty[] bones
public float GetMultiplier(HitArea area)
public void ScaleDamage(HitInfo info)
}
public DamageRenderer : MonoBehaviour {
private List`1<Material> damageShowingMats
private List`1<DamageShowingRenderer> damageShowingRenderers
private List`1<GlassPane> damageShowingGlassRenderers
}
public DamageUtil : object {
public void RadiusDamage(BaseEntity attackingPlayer, BaseEntity weaponPrefab, Vector3 pos, float minradius, float radius, List`1<DamageTypeEntry> damage, int layers, bool useLineOfSight)
}
public DebrisEntity : BaseCombatEntity {
public void ServerInit()
public void RemoveCorpse()
public void ResetRemovalTime(float dur)
public float GetRemovalTime()
public void ResetRemovalTime()
public string Categorize()
}
public DecalComponent : PrefabAttribute {
protected Type GetIndexedType()
}
public DecalCull : LODComponent {
public float Distance
}
public DecalRecycle : BasePrefab {
public float LifeTime
}
public DecalRotate : DecalComponent {
public MinMax range
}
public DecalScale : DecalComponent {
public MinMax range
}
public Decay : PrefabAttribute {
private float hours
protected float GetDecayDelay(Enum grade)
protected float GetDecayDuration(Enum grade)
public void BuildingDecayTouch(BuildingBlock buildingBlock)
public void EntityLinkDecayTouch(BaseEntity ent)
public void RadialDecayTouch(Vector3 pos, float radius, int mask)
public bool ShouldDecay(BaseEntity entity)
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
protected Type GetIndexedType()
}
public DecayEntity : BaseCombatEntity {
public GameObjectRef debrisPrefab
public UInt32 buildingID
public float decayTimer
public float upkeepTimer
private Upkeep upkeep
public Decay decay
public DecayPoint[] decayPoints
private float lastDecayTick
public float decayVariance
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ResetState()
public void AttachToBuilding(UInt32 id)
public Building GetBuilding()
public BuildingPrivlidge GetBuildingPrivilege()
public void CalculateUpkeepCostAmounts(List`1<ItemAmount> itemAmounts, float multiplier)
public void ServerInit()
internal void DoServerDestroy()
public void AttachToBuilding(DecayEntity other)
public BuildingBlock GetNearbyBuildingBlock()
public void ResetUpkeepTime()
public void DecayTouch()
public void AddUpkeepTime(float time)
public float GetProtectedSeconds()
public void DecayTick()
public void OnRepairFinished()
public void OnKilled(HitInfo info)
}
public DecayPoint : PrefabAttribute {
public float protection
public Socket_Base socket
public bool IsOccupied(BaseEntity entity)
protected Type GetIndexedType()
}
public DecorAlign : DecorComponent {
public float NormalAlignment
public float GradientAlignment
public Vector3 SlopeOffset
public Vector3 SlopeScale
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorComponent : PrefabAttribute {
internal bool isRoot
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
}
public DecorComponentEx : object {
public void ApplyDecorComponents(Transform transform, DecorComponent[] components, Vector3& pos, Quaternion& rot, Vector3& scale)
public void ApplyDecorComponents(Transform transform, DecorComponent[] components)
public void ApplyDecorComponentsScaleOnly(Transform transform, DecorComponent[] components)
}
public DecorFlip : DecorComponent {
public AxisType FlipAxis
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorOffset : DecorComponent {
public Vector3 MinOffset
public Vector3 MaxOffset
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorRotate : DecorComponent {
public Vector3 MinRotation
public Vector3 MaxRotation
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorScale : DecorComponent {
public Vector3 MinScale
public Vector3 MaxScale
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorSocketFemale : PrefabAttribute {
protected Type GetIndexedType()
protected void OnDrawGizmos()
}
public DecorSocketMale : PrefabAttribute {
protected Type GetIndexedType()
protected void OnDrawGizmos()
}
public DecorSpawn : MonoBehaviour {
public SpawnFilter Filter
public string ResourceFolder
public UInt32 Seed
public float ObjectCutoff
public float ObjectTapering
public int ObjectsPerPatch
public float ClusterRadius
public int ClusterSizeMin
public int ClusterSizeMax
public int PatchCount
public int PatchSize
public bool LOD
}
public DecorSwim : DecorComponent {
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DecorTransform : DecorComponent {
public Vector3 Position
public Vector3 Rotation
public Vector3 Scale
public void Apply(Vector3& pos, Quaternion& rot, Vector3& scale)
}
public DeferredAction : object {
private Object sender
private Action action
private ActionPriority priority
private bool <Idle>k__BackingField
public bool Idle
public int Index
public bool get_Idle()
private void set_Idle(bool value)
public int get_Index()
public void .ctor(Object sender, Action action, ActionPriority priority)
public void Action()
public void Invoke()
public bool op_Implicit(DeferredAction obj)
public void Invoke(Object sender, Action action, ActionPriority priority)
}
public DeferredDecal : MonoBehaviour {
public Mesh mesh
public Material material
public DeferredDecalQueue queue
}
public DeferredDecalQueue : Enum {
public int value__
public DeferredDecalQueue Background
public DeferredDecalQueue Foreground
}
public DeferredExtension : MonoBehaviour {
public ExtendGBufferParams extendGBuffer
public SubsurfaceScatteringParams subsurfaceScattering
public Texture2D blueNoise
public float depthScale
public bool debug
}
public DeferredExtensionMesh : MonoBehaviour {
public SubsurfaceProfile subsurfaceProfile
}
public DeliveryDrone : Drone {
public float stateTimeout
public float targetPositionTolerance
public float preferredCruiseHeight
public float preferredHeightAboveObstacle
public float marginAbovePreferredHeight
public float obstacleHeightLockDuration
public int pickUpDelayInTicks
public DeliveryDroneConfig config
public GameObjectRef mapMarkerPrefab
public EntityRef`1<Marketplace> sourceMarketplace
public EntityRef`1<MarketTerminal> sourceTerminal
public EntityRef`1<VendingMachine> targetVendingMachine
public State _state
public RealTimeSince _sinceLastStateChange
public Nullable`1<Vector3> _stateGoalPosition
public Nullable`1<float> _goToY
public TimeSince _sinceLastObstacleBlock
public Nullable`1<float> _minimumYLock
public int _pickUpTicks
public BaseEntity _mapMarkerInstance
public void Setup(Marketplace marketplace, MarketTerminal terminal, VendingMachine vendingMachine)
public void ServerInit()
public void CreateMapMarker()
public void Think()
public void ForceRemove()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool CanControl()
public float <Think>g__CalculatePreferredY|24_0(Boolean& isBlocked, <>c__DisplayClass24_0& )
public float <Think>g__GetMinimumHeight|24_1(Vector3 offset, <>c__DisplayClass24_0& )
public Vector3 <Think>g__LandingPosition|24_2(<>c__DisplayClass24_0& )
public void <Think>g__SetGoalPosition|24_3(Vector3 position, <>c__DisplayClass24_0& )
public bool <Think>g__IsAtGoalPosition|24_4(<>c__DisplayClass24_0& )
public void <Think>g__SetGoToY|24_5(float y, <>c__DisplayClass24_0& )
public bool <Think>g__IsAtGoToY|24_6(<>c__DisplayClass24_0& )
public void <Think>g__SetState|24_7(State newState, <>c__DisplayClass24_0& )
}
public DeliveryDroneConfig : BaseScriptableObject {
public Vector3 vendingMachineOffset
public float maxDistanceFromVendingMachine
public Vector3 halfExtents
public float testHeight
public LayerMask layerMask
public void FindDescentPoints(VendingMachine vendingMachine, float currentY, Vector3& waitPosition, Vector3& descendPosition)
public bool IsVendingMachineAccessible(VendingMachine vendingMachine, Vector3 offset, RaycastHit& hitInfo)
}
public DemoRecorder : SingletonComponent`1<DemoRecorder> {
public RustInput Input
public GameObject RecordingUnderlay
}
public DemoRecorderProgress : SingletonComponent`1<DemoRecorderProgress> {
public RustText RecordingLabel
public RustText ProgressLabel
public GameObject RecordingUnderlay
}
public DemoText : SingletonComponent`1<DemoText> {
public RustText TimeText
public RustText TotalSecondText
public RustText TimeScaleText
public RustText FilenameText
public RustText DateTimeText
public RustText ParentText
public RustText DofText
public GameObject InternalRoot
public GameObject ParentRoot
public GameObject DofRoot
}
public Deployable : PrefabAttribute {
public Mesh guideMesh
public Vector3 guideMeshScale
public bool guideLights
public bool wantsInstanceData
public bool copyInventoryFromItem
public bool setSocketParent
public bool toSlot
public Slot slot
public GameObjectRef placeEffect
public Bounds bounds
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
}
public DeployableDecay : Decay {
public float decayDelay
public float decayDuration
public float GetDecayDelay(BaseEntity entity)
public float GetDecayDuration(BaseEntity entity)
public bool ShouldDecay(BaseEntity entity)
}
public DeployableToSlot : MonoBehaviour {
public Slot slot
}
public Deployer : HeldEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ItemModDeployable GetModDeployable()
public Deployable GetDeployable()
public Quaternion GetDeployedRotation(Vector3 normal, Vector3 placeDir)
public bool IsPlacementAngleAcceptable(Vector3 pos, Quaternion rot)
public bool CheckPlacement(Deployable deployable, Ray ray, float fDistance)
private void DoDeploy(RPCMessage msg)
public void DoDeploy_Slot(Deployable deployable, Ray ray, UInt32 entityID)
public void DoDeploy_Regular(Deployable deployable, Ray ray)
}
public DeployGuide : BaseMonoBehaviour {
public DeployGuide current
}
public DeployShell : PrefabAttribute {
public Bounds bounds
public OBB WorldSpaceBounds(Transform transform)
public float LineOfSightPadding()
protected Type GetIndexedType()
}
public DeployVolume : PrefabAttribute {
public LayerMask layers
public Flags ignore
public EntityMode entityMode
public BaseEntity[] entityList
protected Type GetIndexedType()
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB test, int mask)
public bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, int mask)
public bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, OBB test, int mask)
public bool CheckSphere(Vector3 pos, float radius, int layerMask, DeployVolume volume)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, DeployVolume volume)
public bool CheckOBB(OBB obb, int layerMask, DeployVolume volume)
public bool CheckBounds(Bounds bounds, int layerMask, DeployVolume volume)
private bool CheckFlags(List`1<Collider> list, DeployVolume volume)
}
public DeployVolumeCapsule : DeployVolume {
public Vector3 center
public float radius
public float height
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask)
}
public DeployVolumeEntityBounds : DeployVolume {
public Bounds bounds
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public DeployVolumeEntityBoundsReverse : DeployVolume {
public Bounds bounds
public int layer
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB test, int mask)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public DeployVolumeOBB : DeployVolume {
public Bounds bounds
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB test, int mask)
}
public DeployVolumeSphere : DeployVolume {
public Vector3 center
public float radius
protected bool Check(Vector3 position, Quaternion rotation, int mask)
protected bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask)
}
public DestroyArcadeEntity : BaseMonoBehaviour {
public ArcadeEntity ent
public float TimeToDie
public float TimeToDieVariance
private void Start()
private void DestroyAction()
}
public DestroyOnGroundMissing : MonoBehaviour {
private void OnGroundMissing()
}
public DetachMonumentChildren : MonoBehaviour {
private void Awake()
}
public Detonator : HeldEntity {
public int frequency
private float timeSinceDeploy
public GameObjectRef frequencyPanelPrefab
public GameObjectRef attackEffect
public GameObjectRef unAttackEffect
private float nextChangeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SetPressed(RPCMessage msg)
internal void InternalSetPressed(bool pressed)
public Vector3 GetPosition()
public float GetMaxRange()
public void RFSignalUpdate(bool on)
public void SetHeld(bool bHeld)
public void ServerSetFrequency(RPCMessage msg)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public int GetFrequency()
}
public DevBotSpawner : FacepunchBehaviour {
public GameObjectRef bot
public Transform waypointParent
public bool autoSelectLatestSpawnedGameObject
public float spawnRate
public int maxPopulation
private Transform[] waypoints
private List`1<BaseEntity> _spawned
public bool HasFreePopulation()
public void SpawnBot()
public void Start()
}
public DevCamera : MonoBehaviour {
public float movementScale
}
public DevControls : MonoBehaviour {
public GUISkin skin
}
public DevDressPlayer : MonoBehaviour {
public bool DressRandomly
public List`1<ItemAmount> clothesToWear
private void ServerInitComponent()
private void DoRandomClothes(BasePlayer player)
}
public DeveloperList : object {
public bool Contains(string steamid)
public bool Contains(ulong steamid)
public bool IsDeveloper(BasePlayer ply)
}
public DeveloperTools : SingletonComponent`1<DeveloperTools> {
public GameObject developerTools
public GameObject navButton
public GameObject panelContainer
public Text ConsoleInput
}
public DevEnableDisable : DevControlsTab {
public GameObject[] Objects
public string CookieName
public string TabName
}
public DevEnvironment : DevControlsTab {
public TOD_Sky sky
}
public DevMovePlayer : BaseMonoBehaviour {
public BasePlayer player
public Transform[] Waypoints
public bool moveRandomly
public Vector3 destination
public Vector3 lookPoint
private int waypointIndex
private float randRun
public void Awake()
public void LateSpawn()
public void SetWaypoints(Transform[] wps)
public void Update()
}
public DevTimeAdjust : MonoBehaviour {
private void Start()
private void OnGUI()
}
public DevWeatherAdjust : MonoBehaviour {
protected void Awake()
protected void OnGUI()
}
public DiagnosticsConSys : ConsoleSystem {
private void DumpAnimators(string targetFolder)
private void DumpEntities(string targetFolder)
private void DumpLODGroups(string targetFolder)
private void DumpLODGroupTotals(string targetFolder)
private void DumpNetwork(string targetFolder)
private void DumpObjects(string targetFolder)
private void DumpPhysics(string targetFolder)
private void DumpTotals(string targetFolder)
private void DumpColliders(string targetFolder)
private void DumpRigidBodies(string targetFolder)
private void DumpGameObjects(string targetFolder)
private void DumpGameObjectRecursive(StringBuilder str, Transform tx, int indent, bool includeComponents)
public void dump(Arg args)
private void DumpSystemInformation(string targetFolder)
private void WriteTextToFile(string file, string text)
}
public DieselEngine : StorageContainer {
public GameObjectRef rumbleEffect
public Transform rumbleOrigin
public Flags Flag_HasFuel
public float runningTimePerFuelUnit
public float cachedFuelTime
private float rumbleMaxDistSq
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public void FixedUpdate()
public void EngineSwitch(RPCMessage msg)
public void TimedShutdown()
public bool ConsumeFuelItem(int amount)
public int GetFuelAmount()
public void UpdateHasFuelFlag()
public void PlayerStoppedLooting(BasePlayer player)
public void EngineOff()
public void EngineOn()
public void RescheduleEngineShutdown()
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool HasFuel()
}
public DirectionalDamageTrigger : TriggerBase {
public float repeatRate
public List`1<DamageTypeEntry> damageType
public GameObjectRef attackEffect
public GameObject InterestedInObject(GameObject obj)
public void OnObjects()
public void OnEmpty()
private void OnTick()
}
public DirectionProperties : PrefabAttribute {
private float radius
public Bounds bounds
public ProtectionProperties extraProtection
protected Type GetIndexedType()
public bool IsWeakspot(Transform tx, HitInfo info)
}
public DirectoryEx : object {
public void Backup(DirectoryInfo parent, String[] names)
public bool MoveToSafe(DirectoryInfo parent, string target, int retries)
public void Backup(String[] names)
public void CopyAll(string sourceDirectory, string targetDirectory)
public void CopyAll(DirectoryInfo source, DirectoryInfo target)
}
public DistanceField : object {
private Int32[] GaussOffsets
private Single[] GaussWeights
public void Generate(Int32& size, Byte& threshold, Byte[]& image, Single[]& distanceField)
private float SampleClamped(Single[] data, int size, int x, int y)
private Vector3 SampleClamped(Vector3[] data, int size, int x, int y)
private ushort SampleClamped(UInt16[] data, int size, int x, int y)
public void GenerateVectors(Int32& size, Single[]& distanceField, Vector3[]& vectorField)
public void ApplyGaussianBlur(int size, Single[] distanceField, int steps)
}
public DistanceFlareLOD : FacepunchBehaviour {
public bool isDynamic
public float minEnabledDistance
public float maxEnabledDistance
public bool toggleFade
public float toggleFadeDuration
}
public DiveSite : JunkPile {
public Transform bobber
public float TimeoutPlayerCheckRadius()
}
public Door : AnimatedBuildingBlock {
public GameObjectRef knockEffect
public bool canTakeLock
public bool hasHatch
public bool canTakeCloser
public bool canTakeKnocker
public bool canNpcOpen
public bool canHandOpen
public bool isSecurityDoor
public TriggerNotify[] vehiclePhysBoxes
public bool checkPhysBoxesOnOpen
public SoundDefinition vehicleCollisionSfx
private float decayResetTimeLast
public NavMeshModifierVolume NavMeshVolumeAnimals
public NavMeshModifierVolume NavMeshVolumeHumanoids
public NavMeshLink NavMeshLink
public NPCDoorTriggerBox NpcTriggerBox
private int nonWalkableArea
private int animalAgentTypeId
private int humanoidAgentTypeId
private float nextKnockTime
private int openHash
private int closeHash
private bool HasVehiclePushBoxes
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public void ServerInit()
public bool HasSlot(Slot slot)
public bool CanPickup(BasePlayer player)
public void CloseRequest()
public void OnFlagsChanged(Flags old, Flags next)
public void SetOpen(bool open, bool suppressBlockageChecks)
public void SetLocked(bool locked)
public bool GetPlayerLockPermission(BasePlayer player)
public void SetNavMeshLinkEnabled(bool wantsOn)
private void RPC_OpenDoor(RPCMessage rpc)
private void StartCheckingForBlockages()
private void StopCheckingForBlockages()
private void RPC_CloseDoor(RPCMessage rpc)
private void RPC_KnockDoor(RPCMessage rpc)
private void RPC_ToggleHatch(RPCMessage rpc)
private void EnableVehiclePhysBoxes()
private void DisableVehiclePhysBox()
private bool get_HasVehiclePushBoxes()
private void ToggleVehiclePushBoxes(bool state)
private void ReverseDoorAnimation(bool wasOpening)
public float BoundsPadding()
public void OnObjects(TriggerNotify trigger)
public void OnEmpty()
}
public DoorAnimEvents : MonoBehaviour {
public GameObjectRef openStart
public GameObjectRef openEnd
public GameObjectRef closeStart
public GameObjectRef closeEnd
public Animator animator
public Animator get_animator()
private void DoorOpenStart()
private void DoorOpenEnd()
private void DoorCloseStart()
private void DoorCloseEnd()
}
public DoorCloser : BaseEntity {
public ItemDefinition itemType
public float delay
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float BoundsPadding()
public void Think()
public void SendClose()
public void RPC_Take(RPCMessage rpc)
public Door GetDoor()
}
public DoorKnocker : BaseCombatEntity {
public Animator knocker1
public Animator knocker2
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Knock(BasePlayer player)
}
public DoorManipulator : IOEntity {
public EntityRef entityRef
public Door targetDoor
public DoorEffect powerAction
private bool toggle
public bool PairWithLockedDoors()
public void SetTargetDoor(Door newTargetDoor)
public void SetupInitialDoorConnection()
public void Init()
public Door FindDoor(bool allowLocked)
public void DoActionDoorMissing()
public void DoAction()
public void IOStateChanged(int inputAmount, int inputSlot)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public DoubleShotgunViewModel : BaseViewModel {
public GameObject NoSkinRoot
}
public DragMe : MonoBehaviour {
public DragMe dragging
public GameObject dragIcon
public object data
public string dragType
public bool DraggableWhenWounded
public void OnBeginDrag(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
public void OnEndDrag(PointerEventData eventData)
public void CancelDrag()
}
public DragReceiver : MonoBehaviour {
public TriggerEvent onEndDrag
}
public DrawArrow : MonoBehaviour {
public Color color
public float length
public float arrowLength
private void OnDrawGizmos()
}
public DrawSkeleton : MonoBehaviour {
private void OnDrawGizmos()
private void DrawTransform(Transform t)
}
public Drone : RemoteControlEntity {
public Rigidbody body
public bool killInWater
public bool enableGrounding
public bool keepAboveTerrain
public float groundTraceDist
public float altitudeAcceleration
public float movementAcceleration
public float yawSpeed
public float uprightSpeed
public float uprightPrediction
public float uprightDot
public float leanWeight
public float leanMaxVelocity
public float hurtVelocityThreshold
public float hurtDamagePower
public float collisionDisableTime
public SoundDefinition movementLoopSoundDef
public SoundDefinition movementStartSoundDef
public SoundDefinition movementStopSoundDef
public AnimationCurve movementLoopPitchCurve
public Nullable`1<Vector3> targetPosition
public DroneInputState currentInput
public float lastInputTime
public double lastCollision
public bool isGrounded
public bool RequiresMouse
protected bool PositionTickFixedTime
public bool get_RequiresMouse()
public void UserInput(InputState inputState, BasePlayer player)
public void Update()
public void FixedUpdate()
public void OnCollisionEnter(Collision collision)
public void OnCollisionStay()
public float GetNetworkTime()
protected bool get_PositionTickFixedTime()
}
public DropBox : Mailbox {
public Transform EyePoint
public bool PlayerIsOwner(BasePlayer player)
public bool PlayerBehind(BasePlayer player)
public bool PlayerInfront(BasePlayer player)
}
public DropMe : MonoBehaviour {
public String[] droppableTypes
public void OnDrop(PointerEventData eventData)
}
public DroppedItem : WorldItem {
public GameObject itemModel
private Collider childCollider
public float GetNetworkTime()
public void ServerInit()
public float GetDespawnDuration()
public void IdleDestroy()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public void OnDroppedOn(DroppedItem di)
internal void OnParentRemoved()
public void PostInitShared()
public bool ShouldInheritNetworkGroup()
}
public DroppedItemContainer : BaseCombatEntity {
public string lootPanelName
public int maxItemCount
public ulong playerSteamID
public string _playerName
public bool onlyOwnerLoot
public ItemContainer inventory
public string playerName
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public string get_playerName()
public void set_playerName(string value)
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void ServerInit()
public void RemoveMe()
public void ResetRemovalTime(float dur)
public void ResetRemovalTime()
public float CalculateRemovalTime()
internal void DoServerDestroy()
public void TakeFrom(ItemContainer[] source)
private void RPC_OpenLoot(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
public void PreServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public DropUtil : object {
public void DropItems(ItemContainer container, Vector3 position, float chance)
}
public DudTimedExplosive : TimedExplosive {
public GameObjectRef fizzleEffect
public GameObject wickSpark
public AudioSource wickSound
public float dudChance
public ItemDefinition itemToGive
private float explodeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool IsWickBurning()
public float GetRandomTimerTime()
public void RPC_Pickup(RPCMessage msg)
public void SetFuse(float fuseLength)
public void Explode()
public bool CanStickTo(BaseEntity entity)
public void BecomeDud()
public void Save(SaveInfo info)
public void Ignite()
public bool CanIgnite()
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public void Load(LoadInfo info)
}
public DummySwitch : IOEntity {
public string listenString
public string listenStringOff
public float duration
public bool WantsPower()
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void SetOn(bool wantsOn)
public void SetOff()
public void OnEntityMessage(BaseEntity from, string msg)
}
public DungeonCell : MonoBehaviour {
public DungeonConnectionType North
public DungeonConnectionType South
public DungeonConnectionType West
public DungeonConnectionType East
public DungeonConnectionVariant NorthVariant
public DungeonConnectionVariant SouthVariant
public DungeonConnectionVariant WestVariant
public DungeonConnectionVariant EastVariant
public GameObjectRef[] AvoidNeighbours
public MeshRenderer[] MapRenderers
public bool ShouldAvoid(UInt32 id)
protected void Awake()
}
public DungeonConnectionHash : ValueType {
public bool North
public bool South
public bool West
public bool East
public int Value
public int get_Value()
}
public DungeonConnectionType : Enum {
public int value__
public DungeonConnectionType None
public DungeonConnectionType TrainTunnel
}
public DungeonConnectionVariant : Enum {
public int value__
public DungeonConnectionVariant A
public DungeonConnectionVariant B
}
public DungeonInfo : LandmarkInfo {
public int CellSize
public float LinkHeight
public float LinkRadius
public float LinkRotation
internal MonumentInfo Monument
internal List`1<GameObject> Links
protected void Awake()
protected void Start()
}
public DungeonLink : MonoBehaviour {
public Transform UpSocket
public Transform DownSocket
public DungeonLinkType UpType
public DungeonLinkType DownType
public int Priority
protected void Start()
}
public DungeonLinkBlockVolume : MonoBehaviour {
public Bounds bounds
public OBB GetBounds(Vector3 position, Quaternion rotation)
}
public DungeonLinkType : Enum {
public int value__
public DungeonLinkType Default
public DungeonLinkType Elevator
}
public DungeonNavmesh : FacepunchBehaviour {
public int NavMeshAgentTypeIndex
public string DefaultAreaName
public float NavmeshResolutionModifier
public Bounds Bounds
public NavMeshData NavMeshData
public NavMeshDataInstance NavMeshDataInstance
public LayerMask LayerMask
public NavMeshCollectGeometry NavMeshCollectGeometry
public DungeonNavmesh _instance
public bool use_baked_terrain_mesh
private List`1<NavMeshBuildSource> sources
private AsyncOperation BuildingOperation
private bool HasBuildOperationStarted
private Stopwatch BuildTimer
private int defaultArea
private int agentTypeId
public bool IsBuilding
public bool NavReady()
public bool get_IsBuilding()
private void OnEnable()
private void OnDisable()
public void UpdateNavMeshAsync()
public void NotifyInformationZonesOfCompletion()
public void SourcesCollected()
public IEnumerator UpdateNavMeshAndWait()
private void AppendModifierVolumes(List`1<NavMeshBuildSource> sources)
public void FinishBuildingNavmesh()
public void OnDrawGizmosSelected()
}
public DynamicMouseCursor : MonoBehaviour {
public Texture2D RegularCursor
public Vector2 RegularCursorPos
public Texture2D HoverCursor
public Vector2 HoverCursorPos
private Texture2D current
private PointerEventData pointer
private List`1<RaycastResult> results
private void LateUpdate()
private void UpdateCursor(Texture2D cursor, Vector2 offs)
private GameObject CurrentlyHoveredItem()
}
public DynamicNavMesh : SingletonComponent`1<DynamicNavMesh> {
public int NavMeshAgentTypeIndex
public string DefaultAreaName
public int AsyncTerrainNavMeshBakeCellSize
public int AsyncTerrainNavMeshBakeCellHeight
public Bounds Bounds
public NavMeshData NavMeshData
public NavMeshDataInstance NavMeshDataInstance
public LayerMask LayerMask
public NavMeshCollectGeometry NavMeshCollectGeometry
public bool use_baked_terrain_mesh
private List`1<NavMeshBuildSource> sources
private AsyncOperation BuildingOperation
private bool HasBuildOperationStarted
private Stopwatch BuildTimer
private int defaultArea
private int agentTypeId
public bool IsBuilding
public bool get_IsBuilding()
private void OnEnable()
private void OnDisable()
public void UpdateNavMeshAsync()
public IEnumerator UpdateNavMeshAndWait()
private void AppendModifierVolumes(List`1<NavMeshBuildSource> sources)
public void FinishBuildingNavmesh()
}
public DynamicZNear : MonoBehaviour {
public float minimum
public float maximum
}
public EAC : object {
private bool IsEacEnabled
private bool get_IsEacEnabled()
}
public EACServer : object {
public ICerberus`1<Client> playerTracker
public Scout eacScout
private Dictionary`2<Client, Connection> client2connection
private Dictionary`2<Connection, Client> connection2client
private Dictionary`2<Connection, ClientStatus> connection2status
private EasyAntiCheatServer`1<Client> easyAntiCheat
public void Encrypt(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
public void Decrypt(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
public Client GetClient(Connection connection)
public Connection GetConnection(Client client)
public bool IsAuthenticated(Connection connection)
private void OnAuthenticatedLocal(Connection connection)
private void OnAuthenticatedRemote(Connection connection)
public bool ShouldIgnore(Connection connection)
private void HandleClientUpdate(ClientStatusUpdate`1<Client> clientStatus)
private void SendToClient(Client client, Byte[] message, int messageLength)
public void DoStartup()
public void DoUpdate()
public void DoShutdown()
public void OnLeaveGame(Connection connection)
public void OnJoinGame(Connection connection)
public void OnStartLoading(Connection connection)
public void OnFinishLoading(Connection connection)
public void OnMessageReceived(Message message)
}
public EasterBasket : AttackEntity {
public GameObjectRef eggProjectile
public ItemDefinition ammoType
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 GetInheritedVelocity(BasePlayer player)
public Item GetAmmo()
public bool HasAmmo()
public void UseAmmo()
public void ThrowEgg(RPCMessage msg)
}
public Effect : EffectData {
public Vector3 Up
public Vector3 worldPos
public Vector3 worldNrm
public bool attached
public Transform transform
public GameObject gameObject
public string pooledString
public bool broadcast
private Effect reusableInstace
public void .ctor(string effectName, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection)
public void .ctor(string effectName, BaseEntity ent, UInt32 boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection)
public void Init(Type fxtype, BaseEntity ent, UInt32 boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection)
public void Init(Type fxtype, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection)
public void Clear()
}
public EffectAudioPerspectiveSwitcher : MonoBehaviour {
public EffectParentToWeaponBone parentToWeaponComponent
}
public EffectBlood : EffectRecycle {
public GameObjectRef ReplacementEffect
}
public EffectDictionary : object {
private Dictionary`2<string, String[]> effectDictionary
public string GetParticle(string impactType, string materialName)
public string GetParticle(DamageType damageType, string materialName)
public string GetDecal(string impactType, string materialName)
public string GetDecal(DamageType damageType, string materialName)
public string GetDisplacement(string impactType, string materialName)
private string LookupEffect(string category, string effect, string material)
}
public EffectMount : EntityComponent`1<BaseEntity> {
public bool firstPerson
public GameObject effectPrefab
public GameObject spawnedEffect
public GameObject mountBone
}
public EffectNetwork : object {
public void Send(Effect effect)
public void Send(Effect effect, Connection target)
}
public EffectParentToWeaponBone : BaseMonoBehaviour {
public string boneName
public bool singleFrame
}
public EffectRecycle : BaseMonoBehaviour {
public float detachTime
public float recycleTime
public PlayMode playMode
public ParentDestroyBehaviour onParentDestroyed
}
public EffectRecycleDetach : BaseMonoBehaviour {
public float recycleTime
}
public EffectRecycleLite : BasePrefab {
private float lifeTime
}
public EffectsBenchmarkScene : BenchmarkScene {
public GameObjectRef[] effectPrefabs
}
public EggAmmoRepresentation : MonoBehaviour {
public GameObject[] eggAmmo
}
public EggHuntEvent : BaseHuntEvent {
public float warmupTime
public float cooldownTime
public float warnTime
public float timeAlive
public EggHuntEvent serverEvent
public EggHuntEvent clientEvent
public float durationSeconds
private Dictionary`2<ulong, EggHunter> _eggHunters
public List`1<CollectableEasterEgg> _spawnedEggs
public ItemAmount[] placementAwards
public bool IsEventActive()
public void ServerInit()
public void StartEvent()
public void SpawnEggsAtPoint(int numEggs, Vector3 pos, Vector3 aimDir, float minDist, float maxDist)
public void SpawnEggs()
public void RandPickup()
public void EggCollected(BasePlayer player)
public void QueueUpdate()
public void DoNetworkUpdate()
public void Sort(List`1<EggHunter> hunterList)
public List`1<EggHunter> GetTopHunters()
public void Save(SaveInfo info)
public void CleanupEggs()
public void Cooldown()
public void PrintWinnersAndAward()
public void DestroyShared()
public void Update()
public float GetTimeRemaining()
}
public EggHuntNote : MonoBehaviour {
public CanvasGroup mainGroup
public CanvasGroup timerGroup
public Text timerText
}
public EggSwap : MonoBehaviour {
public Renderer[] eggRenderers
public void Show(int index)
public void HideAll()
}
public ElectricalBlocker : IOEntity {
protected int input1Amount
protected int input2Amount
public int GetPassthroughAmount(int outputSlot)
public bool WantsPower()
public void UpdateHasPower(int inputAmount, int inputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void UpdateBlocked()
public void UpdateFromInput(int inputAmount, int inputSlot)
}
public ElectricalBranch : IOEntity {
public int branchAmount
public GameObjectRef branchPanelPrefab
private float nextChangeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SetBranchOffPower(RPCMessage msg)
public bool AllowDrainFrom(int outputSlot)
public int DesiredPower()
public void SetBranchAmount(int newAmount)
public int GetPassthroughAmount(int outputSlot)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ElectricalCombiner : IOEntity {
public int input1Amount
public int input2Amount
public int input3Amount
public bool BlockFluidDraining
public bool IsRootEntity()
public bool get_BlockFluidDraining()
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int slot)
}
public ElectricalDFlipFlop : IOEntity {
private int setAmount
private int resetAmount
private int toggleAmount
public void UpdateHasPower(int inputAmount, int inputSlot)
public bool GetDesiredState()
public void UpdateState()
public void UpdateFromInput(int inputAmount, int inputSlot)
public int GetPassthroughAmount(int outputSlot)
public void UpdateOutputs()
}
public ElectricalHeater : IOEntity {
public float fadeDuration
public Light sourceLight
public GrowableHeatSource growableHeatSource
public int ConsumptionAmount()
public void ResetState()
public void OnFlagsChanged(Flags old, Flags next)
public void OnKilled(HitInfo info)
}
public ElectricBattery : IOEntity {
public int maxOutput
public float maxCapactiySeconds
public float rustWattSeconds
private int activeDrain
public bool rechargable
public float maximumInboundEnergyRatio
public float chargeRatio
private float tickRateSeconds
public Flags Flag_HalfFull
public Flags Flag_VeryFull
private bool wasLoaded
private HashSet`1<IOEntity> connectedList
public bool IsRootEntity()
public int ConsumptionAmount()
public int MaximalPowerOutput()
public int GetActiveDrain()
public void ReceiveInstanceData(InstanceData data)
public void PostServerLoad()
public void OnPickedUp(Item createdItem, BasePlayer player)
public int GetCurrentEnergy()
public int DesiredPower()
public void SendAdditionalData(BasePlayer player, int slot, bool input)
public void ServerInit()
public int GetDrainFor(IOEntity ent)
public void AddConnectedRecursive(IOEntity root, HashSet`1& listToUse)
public int GetDrain()
public void OnCircuitChanged(bool forceUpdate)
public void CheckDischarge()
public void SetDischarging(bool wantsOn)
public int GetPassthroughAmount(int outputSlot)
public bool WantsPower()
public void IOStateChanged(int inputAmount, int inputSlot)
public void TickUsage()
public void ChargeChanged(float oldCharge)
public void AddCharge()
public void SetPassthroughOn(bool wantsOn)
public void Unbusy()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ElectricGenerator : IOEntity {
public float electricAmount
public bool IsRootEntity()
public int MaximalPowerOutput()
public int ConsumptionAmount()
public int GetCurrentEnergy()
public int GetPassthroughAmount(int outputSlot)
public void UpdateOutputs()
public void IOStateChanged(int inputAmount, int inputSlot)
public void PostServerLoad()
private void ForcePuzzleReset()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ElectricSwitch : IOEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool WantsPower()
public int ConsumptionAmount()
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void ServerInit()
public void SetSwitch(bool wantsOn)
public void SVSwitch(RPCMessage msg)
public void Unbusy()
}
public ElectricWindmill : IOEntity {
public Animator animator
public int maxPowerGeneration
public Transform vaneRot
public SoundDefinition wooshSound
public Transform wooshOrigin
public float targetSpeed
private float serverWindSpeed
public int MaximalPowerOutput()
public bool IsRootEntity()
public float GetWindSpeedScale()
public void Load(LoadInfo info)
public void ServerInit()
public void Save(SaveInfo info)
public bool AmIVisible()
public void WindUpdate()
public int GetPassthroughAmount(int outputSlot)
public Vector3 GetWindAimDir(float time)
}
public Elevator : IOEntity {
public Transform LiftRoot
public GameObjectRef LiftEntityPrefab
public GameObjectRef IoEntityPrefab
public Transform IoEntitySpawnPoint
public GameObject FloorBlockerVolume
public float LiftSpeedPerMetre
public GameObject[] PoweredObjects
public MeshRenderer PoweredMesh
public Color PoweredLightColour
public Color UnpoweredLightColour
public SkinnedMeshRenderer[] CableRenderers
public LODGroup CableLod
public Transform CableRoot
private int <Floor>k__BackingField
protected Flags TopFloorFlag
public Flags ElevatorPowered
public ElevatorLift liftEntity
public IOEntity ioEntity
public Int32[] previousPowerAmount
public bool IsStatic
public int Floor
public bool IsTop
public float FloorHeight
public bool get_IsStatic()
public int get_Floor()
public void set_Floor(int value)
public bool get_IsTop()
public void Load(LoadInfo info)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy)
public void CallElevator()
public void Server_RaiseLowerElevator(Direction dir, bool goTopBottom)
public bool RequestMoveLiftTo(int targetFloor, Single& timeToTravel)
public void OnLiftCalledWhenAtTargetFloor()
public void OnMoveBegin()
public float TimeToTravelDistance(float distance)
public Vector3 GetWorldSpaceFloorPosition(int targetFloor)
public float get_FloorHeight()
public void ClearBusy()
public bool IsValidFloor(int targetFloor)
public Elevator GetElevatorInDirection(Direction dir)
public void UpdateChildEntities(bool isTop)
public void FindExistingIOChild()
public void Save(SaveInfo info)
public int LiftPositionToFloor()
public void DestroyShared()
private void Cleanup()
public void PostServerLoad()
public void UpdateHasPower(int inputAmount, int inputSlot)
private void OnPhysicsNeighbourChanged()
public bool HasFloorSocketConnection()
public void OnFlagsChanged(Flags old, Flags next)
public void FindExistingLiftChild()
public void OnFlagToggled(bool state)
private void <CallElevator>b__28_0(Elevator elevatorEnt)
}
public ElevatorIOEntity : IOEntity {
public int Consumption
public int ConsumptionAmount()
}
public ElevatorLift : BaseCombatEntity {
public GameObject DescendingHurtTrigger
public GameObject MovementCollider
public Transform UpButtonPoint
public Transform DownButtonPoint
public TriggerNotify VehicleTrigger
public GameObjectRef LiftArrivalScreenBounce
public SoundDefinition liftMovementLoopDef
public SoundDefinition liftMovementStartDef
public SoundDefinition liftMovementStopDef
public SoundDefinition liftMovementAccentSoundDef
public GameObjectRef liftButtonPressedEffect
public float movementAccentMinInterval
public float movementAccentMaxInterval
private Sound liftMovementLoopSound
private float nextMovementAccent
private Flags PressedUp
private Flags PressedDown
private Elevator owner
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private Elevator get_owner()
public void ServerInit()
public void ToggleHurtTrigger(bool state)
public void Server_RaiseLowerFloor(RPCMessage msg)
private void ClearDirection()
public void Hurt(HitInfo info)
public void AdminKill()
public void PostServerLoad()
public bool CanMove()
public void ToggleMovementCollider(bool state)
}
public ElevatorStatic : Elevator {
public bool StaticTop
public Flags LiftRecentlyArrived
public List`1<ElevatorStatic> floorPositions
public ElevatorStatic ownerElevator
public bool IsStatic
public bool get_IsStatic()
public void Spawn()
public void PostMapEntitySpawn()
public bool IsValidFloor(int targetFloor)
public Vector3 GetWorldSpaceFloorPosition(int targetFloor)
public void SetFloorDetails(int floor, ElevatorStatic owner)
public void CallElevator()
public ElevatorStatic ElevatorAtFloor(int floor)
public void OnMoveBegin()
public void OnLiftLeavingFloor()
public void ClearBusy()
public void OnLiftCalledWhenAtTargetFloor()
public void OnLiftArrivedAtFloor()
public void ClearPowerOutput()
public int GetPassthroughAmount(int outputSlot)
public void Load(LoadInfo info)
}
public EmissionScaledByLight : MonoBehaviour {
private Color emissionColor
public Renderer[] targetRenderers
public int materialIndex
private MaterialPropertyBlock block
public Light lightToFollow
public float maxEmissionValue
}
public EmissionToggle : MonoBehaviour {
private Color emissionColor
public Renderer[] targetRenderers
public int materialIndex
}
public EngineAudioClip : MonoBehaviour {
public AudioClip granularClip
public AudioClip accelerationClip
public TextAsset accelerationCyclesJson
public List`1<EngineCycle> accelerationCycles
public List`1<EngineCycleBucket> cycleBuckets
public Dictionary`2<int, EngineCycleBucket> accelerationCyclesByRPM
public Dictionary`2<int, int> rpmBucketLookup
public int sampleRate
public int samplesUntilNextGrain
public int lastCycleId
public List`1<Grain> grains
public int currentRPM
public int targetRPM
public int minRPM
public int maxRPM
public int cyclePadding
public float RPMControl
public AudioSource source
public float rpmLerpSpeed
public float rpmLerpSpeedDown
private int GetBucketRPM(int RPM)
}
public EngineAudioSet : ScriptableObject {
public BlendedEngineLoopDefinition[] engineAudioLoops
public int priority
public float idleVolume
public float maxVolume
public float volumeChangeRateUp
public float volumeChangeRateDown
public float idlePitch
public float maxPitch
public float idleRpm
public float gearUpRpm
public float gearDownRpm
public int numGears
public float maxRpm
public float gearUpRpmRate
public float gearDownRpmRate
public SoundDefinition badPerformanceLoop
public BlendedEngineLoopDefinition GetEngineLoopDef(byte numEngines)
}
public EngineDamageOverTime : object {
private List`1<RecentDamage> recentDamage
private float maxSeconds
private float triggerDamage
private Action trigger
public void .ctor(float triggerDamage, float maxSeconds, Action trigger)
public void TakeDamage(float amount)
private float GetRecentDamage()
}
public EngineItemInformationPanel : ItemInformationPanel {
private Text tier
private Phrase low
private Phrase medium
private Phrase high
private GameObject accelerationRoot
private GameObject topSpeedRoot
private GameObject fuelEconomyRoot
}
public EngineSwitch : BaseEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void StopEngine(RPCMessage msg)
public void StartEngine(RPCMessage msg)
}
public EntityCollisionMessage : EntityComponent`1<BaseEntity> {
private void OnCollisionEnter(Collision collision)
}
public EntityComponent`1 : EntityComponentBase {
public T _baseEntity
public T baseEntity
public T get_baseEntity()
protected void UpdateBaseEntity()
protected BaseEntity GetBaseEntity()
}
public EntityComponentBase : BaseMonoBehaviour {
protected BaseEntity GetBaseEntity()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public EntityDebug : EntityComponent`1<BaseEntity> {
internal Stopwatch stopwatch
private void Update()
}
public EntityFlag_Animator : EntityFlag_Toggle {
public Animator TargetAnimator
public string ParamName
public AnimatorMode AnimationMode
public float FloatOnState
public float FloatOffState
public int IntegerOnState
public int IntegerOffState
}
public EntityFlag_TOD : EntityComponent`1<BaseEntity> {
public Flags desiredFlag
public bool onAtNight
public void Start()
public void Initialize()
public bool WantsOn()
private void DoTimeCheck()
}
public EntityFlag_Toggle : EntityComponent`1<BaseEntity> {
public bool runClientside
public bool runServerside
public Flags flag
private UnityEvent onFlagEnabled
private UnityEvent onFlagDisabled
internal bool hasRunOnce
internal bool lastHasFlag
protected void OnDisable()
public void DoUpdate(BaseEntity entity)
protected void OnStateToggled(bool state)
public void OnPostNetworkUpdate(BaseEntity entity)
public void OnSendNetworkUpdate(BaseEntity entity)
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public EntityFlag_ToggleNotify : EntityFlag_Toggle {
public bool UseEntityParent
protected void OnStateToggled(bool state)
}
public EntityFuelSystem : object {
public bool isServer
public BaseEntity owner
public EntityRef fuelStorageInstance
public float nextFuelCheckTime
public bool cachedHasFuel
public float pendingFuel
public void .ctor(BaseEntity owner, bool isServer)
public bool IsInFuelInteractionRange(BasePlayer player)
public StorageContainer GetFuelContainer()
public void SpawnFuelStorage(GameObjectRef fuelStoragePrefab, Transform fuelStoragePoint)
public Item GetFuelItem()
public int GetFuelAmount()
public bool HasFuel(bool forceCheck)
public int TryUseFuel(float seconds, float fuelUsedPerSecond)
public void LootFuel(BasePlayer player)
public void AddStartingFuel(float amount)
public void AdminFillFuel()
}
public EntityItem_RotateWhenOn : EntityComponent`1<BaseEntity> {
public State on
public State off
internal bool currentlyOn
internal bool stateInitialized
public Flags targetFlag
}
public EntityLink : object {
public BaseEntity owner
public Socket_Base socket
public List`1<EntityLink> connections
public int capacity
public string name
public string get_name()
public void Setup(BaseEntity owner, Socket_Base socket)
public void EnterPool()
public void LeavePool()
public bool Contains(EntityLink entity)
public void Add(EntityLink entity)
public void Remove(EntityLink entity)
public void Clear()
public bool IsEmpty()
public bool IsOccupied()
public bool IsMale()
public bool IsFemale()
public bool CanConnect(EntityLink link)
}
public EntityLinkEx : object {
public void FreeLinks(List`1<EntityLink> links)
public void ClearLinks(List`1<EntityLink> links)
public void AddLinks(List`1<EntityLink> links, BaseEntity entity, Socket_Base[] sockets)
}
public EntityRef : ValueType {
internal BaseEntity ent_cached
internal UInt32 id_cached
public UInt32 uid
public bool IsSet()
public bool IsValid(bool serverside)
public void Set(BaseEntity ent)
public BaseEntity Get(bool serverside)
public UInt32 get_uid()
public void set_uid(UInt32 value)
}
public EntityRef`1 : ValueType {
private EntityRef entityRef
public bool IsSet
public UInt32 uid
public void .ctor(UInt32 uid)
public bool get_IsSet()
public bool IsValid(bool serverside)
public void Set(T entity)
public T Get(bool serverside)
public bool TryGet(bool serverside, T& entity)
public UInt32 get_uid()
public void set_uid(UInt32 value)
}
public EntityTimedDestroy : EntityComponent`1<BaseEntity> {
public float secondsTillDestroy
private void OnEnable()
private void TimedDestroy()
}
public EnvironmentManager : SingletonComponent`1<EnvironmentManager> {
public EnvironmentType Get(OBB obb)
public EnvironmentType Get(Vector3 pos, List`1& list)
public EnvironmentType Get(Vector3 pos)
public bool Check(OBB obb, EnvironmentType type)
public bool Check(Vector3 pos, EnvironmentType type)
}
public EnvironmentMultiplier : object {
public EnvironmentType Type
public float Multiplier
}
public EnvironmentType : Enum {
public int value__
public EnvironmentType Underground
public EnvironmentType Building
public EnvironmentType Outdoor
public EnvironmentType Elevator
public EnvironmentType PlayerConstruction
public EnvironmentType TrainTunnels
}
public EnvironmentVolume : MonoBehaviour {
public EnvironmentType Type
public Vector3 Center
public Vector3 Size
private BoxCollider <trigger>k__BackingField
public BoxCollider trigger
public BoxCollider get_trigger()
private void set_trigger(BoxCollider value)
protected void Awake()
public void UpdateTrigger()
}
public EnvironmentVolumeEx : object {
public bool CheckEnvironmentVolumes(Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
public bool CheckEnvironmentVolumes(Transform transform, EnvironmentType type)
public bool CheckEnvironmentVolumesInsideTerrain(Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
public bool CheckEnvironmentVolumesInsideTerrain(Transform transform, EnvironmentType type)
}
public EnvironmentVolumeProperties : ScriptableObject {
public int ReflectionQuality
public LayerMask ReflectionCullingFlags
public EnvironmentMultiplier[] ReflectionMultipliers
public EnvironmentMultiplier[] AmbientMultipliers
public float FindReflectionMultiplier(EnvironmentType type)
public float FindAmbientMultiplier(EnvironmentType type)
}
public EnvironmentVolumePropertiesCollection : ScriptableObject {
public float TransitionSpeed
public EnvironmentVolumeProperties[] Properties
public EnvironmentVolumeProperties FindQuality(int quality)
}
public EnvironmentVolumeTrigger : MonoBehaviour {
private EnvironmentVolume <volume>k__BackingField
public Vector3 Center
public Vector3 Size
public EnvironmentVolume volume
public EnvironmentVolume get_volume()
private void set_volume(EnvironmentVolume value)
protected void Awake()
}
public EnvSync : PointEntity {
private float syncInterval
private float syncIntervalInv
public void ServerInit()
private void UpdateNetwork()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ErrorText : MonoBehaviour {
public TextMeshProUGUI text
public int maxLength
private Stopwatch stopwatch
public void OnEnable()
public void OnDisable()
internal void CaptureLog(string error, string stacktrace, LogType type)
protected void Update()
}
public ERVegetationStudio : ScriptableObject {
public bool VegetationStudio()
public bool VegetationStudioPro()
public void CreateVegetationMaskLine(GameObject go, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
public void UpdateVegetationMaskLine(GameObject go, ERVSData[] vsData, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
public void UpdateHeightmap(Bounds bounds)
public void RemoveVegetationMaskLine(GameObject go)
public void CreateBiomeArea(GameObject go, float distance, float blendDistance, float noise)
public void UpdateBiomeArea(GameObject go, ERVSData[] vsData, float distance, float blendDistance, float noise)
public void RemoveBiomeArea(GameObject go)
}
public EventSchedule : BaseMonoBehaviour {
public float minimumHoursBetween
public float maxmumHoursBetween
private float hoursRemaining
private long lastRun
private void OnEnable()
private void OnDisable()
private void RunSchedule()
private void Trigger()
private void CountHours()
}
public ExcavatorArm : BaseEntity {
public float yaw1
public float yaw2
public Transform wheel
public float wheelSpeed
public float turnSpeed
public Transform miningOffset
public GameObjectRef bounceEffect
public LightGroupAtTime lights
public Material conveyorMaterial
public float beltSpeedMax
public Flags Flag_HasPower
public List`1<ExcavatorOutputPile> outputPiles
public SoundDefinition miningStartButtonSoundDef
public ItemAmount[] resourcesToMine
public float resourceProductionTickRate
public float timeForFullResources
public ItemAmount[] pendingResources
public float movedAmount
public float currentTurnThrottle
public float lastMoveYaw
private float excavatorStartTime
public int resourceMiningIndex
protected float PositionTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPowered()
public bool IsMining()
protected float get_PositionTickRate()
public float GetNetworkTime()
public void FixedUpdate()
public void BeginMining()
public void StopMining()
public void ProduceResources()
public void OnEntityMessage(BaseEntity from, string msg)
public void RPC_SetResourceTarget(RPCMessage msg)
public void RPC_StopMining(RPCMessage msg)
public void Spawn()
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void PostMapEntitySpawn()
public void Init()
}
public ExcavatorEffects : MonoBehaviour {
public ExcavatorEffects instance
public ParticleSystemContainer[] miningParticles
public SoundPlayer[] miningSounds
public SoundFollowCollider[] beltSounds
public SoundPlayer[] miningStartSounds
public GameObject[] ambientMetalRattles
public bool wasMining
}
public ExcavatorEngineSounds : MonoBehaviour {
public SoundPlayer[] engineStartClunks
public void PlayStartClunks()
}
public ExcavatorServerEffects : MonoBehaviour {
public ExcavatorServerEffects instance
public TriggerBase[] miningTriggers
public void Awake()
public void OnDestroy()
public void SetMining(bool isMining, bool force)
}
public ExcavatorYawSounds : MonoBehaviour {
public SoundPlayer[] miningStartClunks
public void PlayStartClunks()
}
public ExpandedLifeStats : MonoBehaviour {
public GameObject DisplayRoot
public GameObjectRef GenericStatRow
public Transform ResourcesStatRoot
public List`1<GenericStatDisplay> ResourceStats
public GameObjectRef WeaponStatRow
public Transform WeaponsRoot
public Transform MiscRoot
public List`1<GenericStatDisplay> MiscStats
public LifeInfographic Infographic
public RectTransform MoveRoot
public Vector2 OpenPosition
public Vector2 ClosedPosition
public GameObject OpenButtonRoot
public GameObject CloseButtonRoot
public GameObject ScrollGradient
public ScrollRect Scroller
}
public Explosion_Bloom : MonoBehaviour {
public Settings settings
private Shader m_Shader
private Material m_Material
private int kMaxIterations
private RenderTexture[] m_blurBuffer1
private RenderTexture[] m_blurBuffer2
private int m_Threshold
private int m_Curve
private int m_PrefilterOffs
private int m_SampleScale
private int m_Intensity
private int m_BaseTex
public Shader shader
public Material material
public bool supportsDX11
public Shader get_shader()
public Material get_material()
public bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
public Material CheckShaderAndCreateMaterial(Shader s)
public bool get_supportsDX11()
private void Awake()
private void OnEnable()
private void OnDisable()
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public ExplosionDemoGUI : MonoBehaviour {
public GameObject[] Prefabs
public float reactivateTime
public Light Sun
private int currentNomber
private GameObject currentInstance
private GUIStyle guiStyleHeader
private float sunIntensity
private float dpiScale
private void Start()
private void OnGUI()
private void ChangeCurrent(int delta)
}
public ExplosionDemoReactivator : MonoBehaviour {
public float TimeDelayToReactivate
private void Start()
private void Reactivate()
}
public ExplosionPlatformActivator : MonoBehaviour {
public GameObject Effect
public float TimeDelay
public float DefaultRepeatTime
public float NearRepeatTime
private float currentTime
private float currentRepeatTime
private bool canUpdate
private void Start()
private void Init()
private void Update()
private void OnTriggerEnter(Collider coll)
private void OnTriggerExit(Collider other)
}
public ExplosionsBillboard : MonoBehaviour {
public Camera Camera
public bool Active
public bool AutoInitCamera
private GameObject myContainer
private Transform t
private Transform camT
private Transform contT
private void Awake()
private void Update()
}
public ExplosionsDeactivateRendererByTime : MonoBehaviour {
public float TimeDelay
private Renderer rend
private void Awake()
private void DeactivateRenderer()
private void OnEnable()
}
public ExplosionsFPS : MonoBehaviour {
private GUIStyle guiStyleHeader
private float timeleft
private float fps
private int frames
private void Awake()
private void OnGUI()
private void Update()
}
public ExplosionsLightCurves : MonoBehaviour {
public AnimationCurve LightCurve
public float GraphTimeMultiplier
public float GraphIntensityMultiplier
private bool canUpdate
private float startTime
private Light lightSource
private void Awake()
private void OnEnable()
private void Update()
}
public ExplosionsParticleSystemScaler : MonoBehaviour {
public float particlesScale
private void Start()
private void Update()
}
public ExplosionsScaleCurves : MonoBehaviour {
public AnimationCurve ScaleCurveX
public AnimationCurve ScaleCurveY
public AnimationCurve ScaleCurveZ
public Vector3 GraphTimeMultiplier
public Vector3 GraphScaleMultiplier
private float startTime
private Transform t
private float evalX
private float evalY
private float evalZ
private void Awake()
private void OnEnable()
private void Update()
}
public ExplosionsShaderColorGradient : MonoBehaviour {
public string ShaderProperty
public int MaterialID
public Gradient Color
public float TimeMultiplier
private bool canUpdate
private Material matInstance
private int propertyID
private float startTime
private Color oldColor
private void Start()
private void OnEnable()
private void Update()
}
public ExplosionsShaderFloatCurves : MonoBehaviour {
public string ShaderProperty
public int MaterialID
public AnimationCurve FloatPropertyCurve
public float GraphTimeMultiplier
public float GraphScaleMultiplier
private bool canUpdate
private Material matInstance
private int propertyID
private float startTime
private void Start()
private void OnEnable()
private void Update()
}
public ExplosionsShaderQueue : MonoBehaviour {
public int AddQueue
private Renderer rend
private void Start()
private void SetProjectorQueue()
private void OnDisable()
}
internal ExplosionsSpriteSheetAnimation : MonoBehaviour {
public int TilesX
public int TilesY
public float AnimationFPS
public bool IsInterpolateFrames
public int StartFrameOffset
public bool IsLoop
public float StartDelay
public AnimationCurve FrameOverTime
private bool isInizialised
private int index
private int count
private int allCount
private float animationLifeTime
private bool isVisible
private bool isCorutineStarted
private Renderer currentRenderer
private Material instanceMaterial
private float currentInterpolatedTime
private float animationStartTime
private bool animationStoped
private void Start()
private void InitDefaultVariables()
private void Play()
private void PlayDelay()
private void OnEnable()
private void OnDisable()
private IEnumerator UpdateCorutine()
private void UpdateFrame()
private void Update()
private void OnDestroy()
}
public ExplosiveInformationPanel : ItemInformationPanel {
public ItemTextValue explosiveDmgDisplay
public ItemTextValue lethalDmgDisplay
public ItemTextValue throwDistanceDisplay
public ItemTextValue projectileDistanceDisplay
public ItemTextValue fuseLengthDisplay
public ItemTextValue blastRadiusDisplay
public Text unreliableText
}
public ExtendGBufferParams : ValueType {
public bool enabled
public ExtendGBufferParams Default
}
public EyeBlink : MonoBehaviour {
public Transform LeftEye
public Vector3 LeftEyeOffset
public Transform RightEye
public Vector3 RightEyeOffset
public Vector2 TimeWithoutBlinking
public float BlinkSpeed
}
public EyeController : MonoBehaviour {
public float MaxLookDot
public bool debug
public Transform LeftEye
public Transform RightEye
public Transform EyeTransform
public Vector3 Fudge
public Vector3 FlickerRange
private Transform Focus
private float FocusUpdateTime
}
public EZSoftBoneHitboxSystemCollider : EZSoftBoneColliderBase {
public float radius
public void Collide(Vector3& position, float spacing)
}
public Facepunch.CardGames.CardGameController : object {
private CardGameState <State>k__BackingField
public int IDLE_KICK_SECONDS
private CardTable <Owner>k__BackingField
protected CardPlayerData[] playerData
private WinnerBreakdown <winnerInfo>k__BackingField
protected CardList localPlayerCards
public CardGameState State
public bool HasGameInProgress
public bool HasRoundInProgress
public int MinPlayers
public int MinBuyIn
public int MaxBuyIn
public float MaxTurnTime
public int TimeBetweenRounds
protected CardTable Owner
protected int ScrapItemID
protected bool IsServer
protected bool IsClient
public WinnerBreakdown winnerInfo
public CardGameState get_State()
private void set_State(CardGameState value)
public bool get_HasGameInProgress()
public bool get_HasRoundInProgress()
public int get_MinPlayers()
public int get_MinBuyIn()
public int get_MaxBuyIn()
public float get_MaxTurnTime()
public int get_TimeBetweenRounds()
protected CardTable get_Owner()
private void set_Owner(CardTable value)
protected int get_ScrapItemID()
protected bool get_IsServer()
protected bool get_IsClient()
public WinnerBreakdown get_winnerInfo()
private void set_winnerInfo(WinnerBreakdown value)
public void .ctor(CardTable owner)
public void Dispose()
public int NumPlayersAllowedToPlay(CardPlayerData ignore)
public int RelToAbsIndex(int relIndex, bool includeFolded)
public int GameToRoundIndex(int gameRelIndex)
public int NumPlayersInGame()
public int NumPlayersInCurrentRound()
public int MaxPlayersAtTable()
public bool PlayerIsInGame(BasePlayer player)
public bool IsAtTable(BasePlayer player)
public void StartTurnTimer(float turnTime)
private bool IsAtTable(ulong userID)
public int GetScrapInPot()
public bool TryGetCardPlayerData(int index, CardPlayerData& cardPlayer)
public bool TryGetCardPlayerData(ulong forPlayer, CardPlayerData& cardPlayer)
public bool TryGetCardPlayerData(BasePlayer forPlayer, CardPlayerData& cardPlayer)
public bool IsAllowedToPlay(CardPlayerData cpd)
protected void ClearWinnerInfo()
public void JoinTable(BasePlayer player)
protected void SyncAllLocalPlayerCards()
private void JoinTable(ulong userID)
public void LeaveTable(ulong userID)
protected int AddToPot(CardPlayerData playerData, int maxAmount)
protected int AddAllToPot(CardPlayerData playerData)
protected int PayOut(CardPlayerData playerData, int maxAmount)
protected int PayOutAll(CardPlayerData playerData)
protected int RemoveScrapFromStorage(CardPlayerData data)
public void Save(CardTable syncData)
private void InvokeStartNewRound()
private bool TryStartNewRound()
protected void TimeoutTurn()
protected void SubStartRound()
protected void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction)
protected int SubGetAvailableInputsForPlayer(CardPlayerData playerData)
protected void SubOnPlayerLeaving(CardPlayerData playerData)
protected void SubEndRound()
protected void SubEndGameplay()
protected void EndRound()
private void EndGameplay()
public void ReceivedInputFromPlayer(BasePlayer player, int input, bool countAsAction, int value)
protected void ReceivedInputFromPlayer(CardPlayerData pData, int input, bool countAsAction, int value, bool playerInitiated)
public void PlayerStorageChanged()
protected void ServerPlaySound(SoundType type)
public void GetConnectionsInGame(List`1<Connection> connections)
public void OnTableDestroyed()
public void EditorMakeRandomMove()
}
public Facepunch.CardGames.CardPlayerData : object {
private ulong <UserID>k__BackingField
public List`1<PlayingCard> Cards
private CardPlayerState <State>k__BackingField
public int mountIndex
private bool isServer
public int availableInputs
public int betThisRound
public int betThisTurn
private bool <LeftRoundEarly>k__BackingField
private bool <SendCardDetails>k__BackingField
public int finalScore
private bool <hasActedThisTurn>k__BackingField
public float lastActionTime
public int remainingToPayOut
private Func`2<int, StorageContainer> getStorage
private int scrapItemID
public ulong UserID
public CardPlayerState State
public bool HasUser
public bool HasUserInGame
public bool HasUserInCurrentRound
private bool IsClient
public bool LeftRoundEarly
public bool SendCardDetails
public bool hasActedThisTurn
public ulong get_UserID()
private void set_UserID(ulong value)
public CardPlayerState get_State()
private void set_State(CardPlayerState value)
public bool get_HasUser()
public bool get_HasUserInGame()
public bool get_HasUserInCurrentRound()
private bool get_IsClient()
public bool get_LeftRoundEarly()
private void set_LeftRoundEarly(bool value)
public bool get_SendCardDetails()
private void set_SendCardDetails(bool value)
public void .ctor(int mountIndex, bool isServer)
public void .ctor(int scrapItemID, Func`2<int, StorageContainer> getStorage, int mountIndex, bool isServer)
public void Dispose()
public int GetScrapAmount()
public bool get_hasActedThisTurn()
private void set_hasActedThisTurn(bool value)
public void SetHasActedThisTurn(bool hasActed)
public bool HasBeenIdleFor(int seconds)
public StorageContainer GetStorage()
public void AddUser(ulong userID)
public void ClearAllData()
public void JoinRound()
public void LeaveCurrentRound(bool clearBets, bool leftRoundEarly)
public void LeaveGame()
public void EnableSendingCards()
public string HandToString()
public string HandToString(List`1<PlayingCard> cards)
public void Save(List`1<CardPlayer> playersMsg)
}
public Facepunch.CardGames.DeckOfCards : object {
private List`1<PlayingCard> deck
public bool TryTakeCard(PlayingCard& card)
public void AddCard(PlayingCard card)
public void ShuffleDeck()
public void Print()
}
public Facepunch.CardGames.PlayingCard : object {
public Suit Suit
public Rank Rank
public PlayingCard[] cards
private void .ctor(Suit suit, Rank rank)
public PlayingCard GetCard(Suit suit, Rank rank)
public PlayingCard GetCard(int suit, int rank)
public PlayingCard GetCard(int index)
public int GetIndex()
public int GetIndex(Suit suit, Rank rank)
public int GetEvaluationValue()
private int GetSuitCode()
private PlayingCard[] GenerateAllCards()
}
public Facepunch.CardGames.Rank : Enum {
public int value__
public Rank Two
public Rank Three
public Rank Four
public Rank Five
public Rank Six
public Rank Seven
public Rank Eight
public Rank Nine
public Rank Ten
public Rank Jack
public Rank Queen
public Rank King
public Rank Ace
}
public Facepunch.CardGames.Suit : Enum {
public int value__
public Suit Spades
public Suit Hearts
public Suit Diamonds
public Suit Clubs
}
public Facepunch.CardGames.TexasHoldEmController : CardGameController {
public List`1<PlayingCard> flopCards
public int SMALL_BLIND
public int BIG_BLIND
private PokerInputOption <LastAction>k__BackingField
private ulong <LastActionTarget>k__BackingField
private int <LastActionValue>k__BackingField
public int RAISE_INCREMENTS
private int <biggestRaiseThisTurn>k__BackingField
private int dealerIndex
private int activePlayerIndex
private DeckOfCards deck
public int MinBuyIn
public int MaxBuyIn
public int MinPlayers
public PokerInputOption LastAction
public ulong LastActionTarget
public int LastActionValue
public int biggestRaiseThisTurn
public int get_MinBuyIn()
public int get_MaxBuyIn()
public int get_MinPlayers()
public void .ctor(CardTable owner)
public PokerInputOption get_LastAction()
private void set_LastAction(PokerInputOption value)
public ulong get_LastActionTarget()
private void set_LastActionTarget(ulong value)
public int get_LastActionValue()
private void set_LastActionValue(int value)
public int get_biggestRaiseThisTurn()
private void set_biggestRaiseThisTurn(int value)
public Playability GetPlayabilityStatus(CardPlayerData cpd)
public int GetCurrentBet()
public bool IsAllowedToPlay(CardPlayerData cpd)
public bool TryGetActivePlayer(CardPlayerData& activePlayer)
public bool TryGetDealer(CardPlayerData& dealer)
public bool TryGetSmallBlind(CardPlayerData& smallBlind)
public bool TryGetBigBlind(CardPlayerData& bigBlind)
public int GetFirstPlayerRelIndex(bool startOfRound)
private void SetActivePlayerIndex(int index)
private bool ToCardPlayerData(int relIndex, bool includeFolded, CardPlayerData& result)
public ushort EvaluatePokerHand(List`1<PlayingCard> cards)
public int GetCurrentMinRaise(CardPlayerData playerData)
public void Save(CardTable syncData)
protected void SubStartRound()
protected void SubEndRound()
protected void SubEndGameplay()
private void IncrementDealer()
private void DealHoleCards()
private bool DealFlop()
protected void TimeoutTurn()
protected void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction)
private bool ShouldEndTurn()
private void EndTurn()
protected int SubGetAvailableInputsForPlayer(CardPlayerData playerData)
public void OnTableDestroyed()
protected void SubOnPlayerLeaving(CardPlayerData playerData)
private void <SubEndRound>g__AddWinner|46_0(CardPlayerData pData, int winnings, bool primaryWinner)
}
public Facepunch.GUI.Controls : object {
public float labelWidth
public float FloatSlider(string strLabel, float value, float low, float high, string format)
public int IntSlider(string strLabel, int value, int low, int high, string format)
public string TextArea(string strName, string value)
public bool Checkbox(string strName, bool value)
public bool Button(string strName)
}
internal Facepunch.GUI.TabbedPanel : object {
private int selectedTabID
private List`1<Tab> tabs
public Tab selectedTab
public Tab get_selectedTab()
public void Add(Tab tab)
internal void DrawVertical(float width)
internal void DrawContents()
}
public Facepunch.Output : object {
private Action`3<string, string, LogType> OnMessage
public bool installed
public List`1<Entry> HistoryOutput
public void add_OnMessage(Action`3<string, string, LogType> value)
public void remove_OnMessage(Action`3<string, string, LogType> value)
public void Install()
public void LogHandler(string log, string stacktrace, LogType type)
}
public Facepunch.RCon : object {
public string Password
public int Port
public string Ip
public bool Web
public bool Print
internal RConListener listener
internal Listener listenerNew
private Queue`1<Command> Commands
private float lastRunTime
internal List`1<BannedAddresses> bannedAddresses
private int responseIdentifier
private int responseConnection
private bool isInput
internal int SERVERDATA_AUTH
internal int SERVERDATA_EXECCOMMAND
internal int SERVERDATA_AUTH_RESPONSE
internal int SERVERDATA_RESPONSE_VALUE
internal int SERVERDATA_CONSOLE_LOG
internal int SERVERDATA_SWITCH_UTF8
public void Initialize()
public void Shutdown()
public void Broadcast(LogType type, object obj)
public void Update()
public void BanIP(IPAddress addr, float seconds)
public bool IsBanned(IPAddress addr)
private void OnCommand(Command cmd)
private void OnMessage(string message, string stacktrace, LogType type)
}
public Facepunch.Rust.Analytics : object {
internal void Death(string v)
public void Crafting(string targetItemShortname, int taskSkinId)
public void ExcavatorStarted()
public void ExcavatorStopped(float activeDuration)
public void SlotMachineTransaction(int scrapSpent, int scrapReceived)
}
public Facepunch.UI.ESPCanvas : MonoBehaviour {
public int MaxElements
public float RefreshRate
public ESPPlayerInfo Source
public float MaxDistance
}
public Facepunch.UI.ESPPlayerInfo : MonoBehaviour {
public Vector3 WorldOffset
public TextMeshProUGUI Text
public TextMeshProUGUI Image
public CanvasGroup group
public Gradient gradientNormal
public Gradient gradientTeam
public Color TeamColor
public QueryVis visCheck
private BasePlayer <Entity>k__BackingField
public BasePlayer Entity
public BasePlayer get_Entity()
public void set_Entity(BasePlayer value)
}
public Facepunch.Unity.RenderInfo : object {
public void GenerateReport()
}
public Facepunch.Utility.Compression : object {
public Byte[] Compress(Byte[] data)
public Byte[] Uncompress(Byte[] data)
}
public Facepunch.VirtualScroll : MonoBehaviour {
public int ItemHeight
public int ItemSpacing
public RectOffset Padding
public GameObject DataSourceObject
public GameObject SourceObject
public ScrollRect ScrollRect
private IDataSource dataSource
private Dictionary`2<int, GameObject> ActivePool
private Stack`1<GameObject> InactivePool
private int BlockHeight
public void Awake()
public void OnDestroy()
private void OnScrollChanged(Vector2 pos)
public void SetDataSource(IDataSource source)
private int get_BlockHeight()
public void FullRebuild()
public void DataChanged()
public void Rebuild()
private void RecycleOutOfRange(int startVisible, float endVisible)
private void Recycle(int key)
private void BuildItem(int i)
private GameObject GetItem()
}
public FileEx : object {
public void Backup(DirectoryInfo parent, String[] names)
public bool MoveToSafe(FileInfo parent, string target, int retries)
public void Backup(String[] names)
}
public FileStorage : object {
private Database db
private CRC32 crc
private Dictionary`2<UInt32, CacheData> _cache
public FileStorage server
protected void .ctor(string name, bool server)
protected void Finalize()
public void Dispose()
private UInt32 GetCRC(Byte[] data, Type type)
public UInt32 Store(Byte[] data, Type type, UInt32 entityID, UInt32 numID)
public Byte[] Get(UInt32 crc, Type type, UInt32 entityID, UInt32 numID)
public void Remove(UInt32 crc, Type type, UInt32 entityID)
public void RemoveExact(UInt32 crc, Type type, UInt32 entityID, UInt32 numid)
public void RemoveEntityNum(UInt32 entityid, UInt32 numid)
internal void RemoveAllByEntity(UInt32 entityid)
}
public FileSystem_Warmup : MonoBehaviour {
private bool run
private bool running
public String[] ExcludeFilter
public void Run()
public IEnumerator Run(float deltaTime, Action`1<string> statusFunction, string format)
private bool ShouldIgnore(string path)
public String[] GetAssetList()
private void PrefabWarmup(string path)
}
public FireBall : BaseEntity {
public float lifeTimeMin
public float lifeTimeMax
public ParticleSystem[] movementSystems
public ParticleSystem[] restingSystems
public float generation
public GameObjectRef spreadSubEntity
public float tickRate
public float damagePerSecond
public float radius
public int waterToExtinguish
public bool canMerge
public LayerMask AttackLayers
public bool ignoreNPC
private Vector3 lastPos
private float deathTime
private int wetness
private float spawnTime
public void ServerInit()
public float GetDeathTime()
public void AddLife(float amountToAdd)
public float MaxLifeTime()
public float TimeLeft()
public void TryToSpread()
public void SetGeneration(int gen)
public void Think()
public void DoRadialDamage()
public bool CanMerge()
public float TimeAlive()
public void SetResting(bool isResting)
public void Extinguish()
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public bool IsResting()
public void Load(LoadInfo info)
}
public FireBomb : MonoBehaviour {
public GameObject fireParticle
public float bombRadius
public float particleDuration
public float emitDuration
}
public FirecrackerRepeater : BaseMonoBehaviour {
public GameObjectRef singleExplosionEffect
public Transform[] parts
public float partWidth
public float partLength
public Quaternion[] targetRotations
public Quaternion[] initialRotations
public Renderer[] renderers
public Material materialSource
public float explodeRepeatMin
public float explodeRepeatMax
public float explodeLerpSpeed
public Vector3 twistAmount
public float fuseLength
public float explodeStrength
public float explodeDirBlend
public float duration
public ParticleSystemContainer smokeParticle
}
public FireSpot : BaseEntity {
public GameObject flameEffect
public void Load(LoadInfo info)
}
public FireworkBenchmarkScene : BenchmarkScene {
public GameObjectRef[] shellTypes
public int fireworkCount
}
public FireworkShell : BaseMonoBehaviour {
public float fuseLengthMin
public float fuseLengthMax
public float speedMin
public float speedMax
public ParticleSystem explodePFX
public SoundPlayer explodeSound
public float inaccuracyDegrees
public LightEx explosionLight
}
public FirstPersonEffect : MonoBehaviour {
public bool isGunShot
public EffectParentToWeaponBone parentToWeaponComponent
}
public FishingBobber : BaseCombatEntity {
public Transform centerOfMass
public Rigidbody myRigidBody
public void ServerInit()
}
internal FixAtlasMipLevelsState : Enum {
public int value__
public FixAtlasMipLevelsState Skipped
public FixAtlasMipLevelsState Initializing
public FixAtlasMipLevelsState Succeeded
public FixAtlasMipLevelsState Failed
}
public FixedRateStepped : object {
public float rate
public int maxSteps
internal float nextCall
public bool ShouldStep()
}
public FixedSByteNorm3 : ValueType {
private int FracBits
private float MaxFrac
private float RcpMaxFrac
public sbyte x
public sbyte y
public sbyte z
public void .ctor(Vector3 vec)
public Vector3 op_Explicit(FixedSByteNorm3 vec)
}
public FixedSByteNorm4 : ValueType {
private int FracBits
private float MaxFrac
private float RcpMaxFrac
public sbyte x
public sbyte y
public sbyte z
public sbyte w
public void .ctor(Vector4 vec)
public Vector4 op_Explicit(FixedSByteNorm4 vec)
}
public FixedShort3 : ValueType {
private int FracBits
private float MaxFrac
private float RcpMaxFrac
public short x
public short y
public short z
public void .ctor(Vector3 vec)
public Vector3 op_Explicit(FixedShort3 vec)
}
public FlameExplosive : TimedExplosive {
public GameObjectRef createOnExplode
public float numToCreate
public float minVelocity
public float maxVelocity
public float spreadAngle
public void Explode()
public void Explode(Vector3 surfaceNormal)
public void ProjectileImpact(RaycastHit info)
}
public FlameJet : MonoBehaviour {
public LineRenderer line
public float tesselation
private float length
public float maxLength
public float drag
private int numSegments
private float spacing
public bool on
private Vector3[] lastWorldSegments
private Vector3[] currentSegments
public Color startColor
public Color endColor
public Color currentColor
private void Initialize()
private void Awake()
public void LateUpdate()
public void SetOn(bool isOn)
private float curve(float x)
private void UpdateLine()
}
public FlameThrower : AttackEntity {
public int maxAmmo
public int ammo
public ItemDefinition fuelType
public float timeSinceLastAttack
public float nextReadyTime
public float flameRange
public float flameRadius
public ParticleSystem[] flameEffects
public FlameJet jet
public GameObjectRef fireballPrefab
public List`1<DamageTypeEntry> damagePerSec
public SoundDefinition flameStart3P
public SoundDefinition flameLoop3P
public SoundDefinition flameStop3P
public SoundDefinition pilotLoopSoundDef
private float tickRate
private float lastFlameTick
public float fuelPerSec
private float ammoRemainder
public float reloadDuration
private float lastReloadTime
private float nextFlameTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool IsWeaponBusy()
private void SetBusyFor(float dur)
private void ClearBusy()
public void ReduceAmmo(float firingTime)
public void PilotLightToggle_Shared()
public bool IsPilotOn()
public bool IsFlameOn()
public bool HasAmmo()
public Item GetAmmo()
public void Load(LoadInfo info)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void Save(SaveInfo info)
public void SetFiring(RPCMessage msg)
public void ServerUse()
public void TopUpAmmo()
public float AmmoFraction()
public bool ServerIsReloading()
public bool CanReload()
public void ServerReload()
public void StopFlameState()
public void DoReload(RPCMessage msg)
public void SetFlameState(bool wantsOn)
public void TogglePilotLight(RPCMessage msg)
public void OnHeldChanged()
public void FlameTick()
public void ServerCommand(Item item, string command, BasePlayer player)
}
public flamethrowerFire : MonoBehaviour {
public ParticleSystem pilotLightFX
public ParticleSystem[] flameFX
public FlameJet jet
public AudioSource oneShotSound
public AudioSource loopSound
public AudioClip pilotlightIdle
public AudioClip flameLoop
public AudioClip flameStart
public flamethrowerState flameState
private flamethrowerState previousflameState
public void PilotLightOn()
public void SetFlameStatus(bool status)
public void ShutOff()
public void FlameOn()
private void Start()
private void Update()
}
public flamethrowerState : Enum {
public int value__
public flamethrowerState OFF
public flamethrowerState PILOT_LIGHT
public flamethrowerState FLAME_ON
}
public FlameTurret : StorageContainer {
public UpdateFlameTurretWorkQueue updateFlameTurretQueueServer
public Transform upper
public Vector3 aimDir
public float arc
public float triggeredDuration
public float flameRange
public float flameRadius
public float fuelPerSec
public Transform eyeTransform
public List`1<DamageTypeEntry> damagePerSec
public GameObjectRef triggeredEffect
public GameObjectRef fireballPrefab
public GameObjectRef explosionEffect
public TargetTrigger trigger
private float nextFireballTime
private int turnDir
private float lastMovementUpdate
private float triggeredTime
private float lastServerThink
private float triggerCheckRate
private float nextTriggerCheckTime
private float pendingFuel
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsTriggered()
public Vector3 GetEyePosition()
public bool CanPickup(BasePlayer player)
public void SetTriggered(bool triggered)
public void ServerInit()
public void SendAimDir()
public float GetSpinSpeed()
public void OnAttacked(HitInfo info)
public void MovementUpdate(float delta)
public void ServerThink()
public bool CheckTrigger()
public void OnKilled(HitInfo info)
public int GetFuelAmount()
public bool HasFuel()
public bool UseFuel(float seconds)
public void DoFlame(float delta)
}
public FlasherLight : IOEntity {
public EmissionToggle toggler
public Light myLight
public float flashSpacing
public float flashBurstSpacing
public float flashOnTime
public int numFlashesPerBurst
public void ResetState()
}
public FlashlightBeam : MonoBehaviour {
public Vector2 scrollDir
public Vector3 localEndPoint
public LineRenderer beamRenderer
}
public FlintStrikeWeapon : BaseProjectile {
public float successFraction
public RecoilProperties strikeRecoil
public RecoilProperties GetRecoil()
}
public FloatConditions : object {
public Condition[] conditions
public bool AllTrue(float val)
}
public FloodedSpawnHandler : object {
private Int32[] SpreadSteps
public bool GetSpawnPoint(SpawnPoint spawnPoint, float searchHeight)
private Vector3 FindSpawnPoint(float searchHeight)
private Vector3 Step(float angle, float distance)
private float RandomAngle()
}
public FluidSwitch : ElectricSwitch {
private Flags Flag_PumpPowered
public Animator PumpAnimator
private bool pumpEnabled
private int lastToggleInput
public bool IsGravitySource
protected bool DisregardGravityRestrictionsOnLiquid
public void ResetState()
public void IOStateChanged(int inputAmount, int inputSlot)
public void SetSwitch(bool wantsOn)
private void DelayedSendChanged()
public int GetPassthroughAmount(int outputSlot)
public int ConsumptionAmount()
public bool get_IsGravitySource()
protected bool get_DisregardGravityRestrictionsOnLiquid()
public bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement)
}
public FlybySound : MonoBehaviour {
public SoundDefinition flybySound
public float flybySoundDistance
public SoundDefinition closeFlybySound
public float closeFlybyDistance
}
public FogMachine : StorageContainer {
public Flags FogFieldOn
public Flags MotionMode
public Flags Emitting
public Flags Flag_HasJuice
public float fogLength
public float nozzleBlastDuration
public float fuelPerSec
private float pendingFuel
public bool IsEmitting()
public bool HasJuice()
public void SetFogOn(RPCMessage msg)
public void SetFogOff(RPCMessage msg)
public void SetMotionDetection(RPCMessage msg)
public void UpdateMotionMode()
public void CheckTrigger()
public void StartFogging()
public void EnableFogField()
public void DisableNozzle()
public void FinishFogging()
public void PostServerLoad()
public void PlayerStoppedLooting(BasePlayer player)
public int GetFuelAmount()
public bool HasFuel()
public bool UseFuel(float seconds)
public bool MotionModeEnabled()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public FogSettings : ValueType {
public Gradient ColorOverDaytime
public float Density
public float StartDistance
public float Height
public float HeightDensity
}
public FoliageDisplacement : MonoBehaviour {
public bool moving
public bool billboard
public Mesh mesh
public Material material
}
public FoliageGrid : SingletonComponent`1<FoliageGrid> {
public bool Paused
public GameObjectRef BatchPrefab
public float CellSize
public float MaxMilliseconds
public LayerSelect FoliageLayer
public ShadowCastingMode FoliageShadows
}
public FoliageGridBenchmarkScene : BenchmarkScene {
private TerrainMeta terrainMeta
public GameObjectRef foliagePrefab
private GameObject foliageInstance
public GameObjectRef lodPrefab
private GameObject lodInstance
public GameObjectRef batchingPrefab
private GameObject batchingInstance
public Terrain terrain
public Transform viewpointA
public Transform viewpointB
public bool moveVantangePoint
}
public FoliagePlacement : ScriptableObject {
public float Density
public SpawnFilter Filter
public float FilterCutoff
public float FilterFade
public float FilterScaling
public float RandomScaling
public MinMax Range
public float RangeFade
public float DistanceDensity
public float DistanceScaling
public Material material
public Mesh mesh0
public Mesh mesh1
public Mesh mesh2
public int lods
public int octaves
public float frequency
public float amplitude
public float offset
}
public FoliageRenderer : MonoBehaviour {
public Material material
public Mesh LOD0
public Mesh LOD1
}
public FoliageSpawn : MonoBehaviour {
public FoliagePlacement Placement
}
public FollowCamera : MonoBehaviour {
private void LateUpdate()
}
public FootstepEffects : BaseFootstepEffect {
public Transform leftFoot
public Transform rightFoot
public string footstepEffectName
public string jumpStartEffectName
public string jumpLandEffectName
}
public FootstepSound : MonoBehaviour {
public SoundDefinition lightSound
public SoundDefinition medSound
public SoundDefinition hardSound
private float panAmount
}
public ForceChildSingletonSetup : MonoBehaviour {
private void Awake()
}
public FPSGraph : Graph {
public void Refresh()
protected void OnEnable()
protected float GetValue()
protected Color GetColor(float value)
}
public FPSText : MonoBehaviour {
public Text text
private Stopwatch fpsTimer
protected void Update()
}
public FreeableLootContainer : LootContainer {
private Flags tiedDown
public Buoyancy buoyancy
public GameObjectRef freedEffect
private Rigidbody rb
public UInt32 skinOverride
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Rigidbody GetRB()
public bool IsTiedDown()
public void ServerInit()
public void RPC_FreeCrate(RPCMessage msg)
}
public FrequencyConfig : UIDialog {
private IRFObject rfObject
public InputField input
public int target
}
public FruitScale : MonoBehaviour {
public void SetProgress(float progress)
}
public FuelElectricGenerator : IOEntity {
public float electricAmount
}
public FuelGenerator : ContainerIOEntity {
public int outputEnergy
public float fuelPerSec
protected float fuelTickRate
private float pendingFuel
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsRootEntity()
public int MaximalPowerOutput()
public int ConsumptionAmount()
public void Init()
public void UpdateFromInput(int inputAmount, int inputSlot)
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
public void UpdateCurrentEnergy()
public int GetPassthroughAmount(int outputSlot)
public void RPC_EngineSwitch(RPCMessage msg)
public void SetGeneratorState(bool wantsOn)
public int GetFuelAmount()
public bool HasFuel()
public bool UseFuel(float seconds)
public void TurnOn()
public void FuelConsumption()
public void TurnOff()
}
public FuseBox : IOEntity {
public void IOStateChanged(int inputAmount, int inputSlot)
}
public FXAA : FXAAPostEffectsBase {
public Shader shader
private Material mat
private void CreateMaterials()
private void Start()
public bool IsActive()
public void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public FXAAOverlay : ImageEffectLayer {
public FXAA fxaa
}
public FXAAPostEffectsBase : MonoBehaviour {
protected bool supportHDRTextures
protected bool isSupported
public Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
private Material CreateMaterial(Shader s, Material m2Create)
private void OnEnable()
private bool CheckSupport()
private bool CheckResources()
private void Start()
public bool CheckSupport(bool needDepth)
private bool CheckSupport(bool needDepth, bool needHdr)
private void ReportAutoDisable()
private bool CheckShader(Shader s)
private void NotSupported()
private void DrawBorder(RenderTexture dest, Material material)
}
public GameContentList : MonoBehaviour {
public ResourceType resourceType
public List`1<Object> foundObjects
}
public GameManager : object {
public GameManager server
public PrefabPreProcess preProcessed
public PrefabPoolCollection pool
public bool Clientside
public bool Serverside
public void Reset()
public void .ctor(bool clientside, bool serverside)
public GameObject FindPrefab(UInt32 prefabID)
public GameObject FindPrefab(BaseEntity ent)
public GameObject FindPrefab(string strPrefab)
public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, Vector3 scale, bool active)
public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, bool active)
public GameObject CreatePrefab(string strPrefab, bool active)
public GameObject CreatePrefab(string strPrefab, Transform parent, bool active)
public BaseEntity CreateEntity(string strPrefab, Vector3 pos, Quaternion rot, bool startActive)
private GameObject Instantiate(string strPrefab, Vector3 pos, Quaternion rot)
public void Destroy(Component component, float delay)
public void Destroy(GameObject instance, float delay)
public void DestroyImmediate(Component component, bool allowDestroyingAssets)
public void DestroyImmediate(GameObject instance, bool allowDestroyingAssets)
public void Retire(GameObject instance)
}
public GameManifest : ScriptableObject {
internal GameManifest loadedManifest
public Dictionary`2<string, string> guidToPath
internal Dictionary`2<string, string> pathToGuid
public Dictionary`2<string, Object> guidToObject
public PooledString[] pooledStrings
public PrefabProperties[] prefabProperties
public EffectCategory[] effectCategories
public GuidPath[] guidPaths
public String[] entities
public GameManifest Current
public GameManifest get_Current()
public void Load()
public void LoadAssets()
internal Dictionary`2<string, String[]> LoadEffectDictionary()
internal string GUIDToPath(string guid)
internal Object GUIDToObject(string guid)
public void Invalidate(string path)
private string GetMetadataStatus()
private string GetAssetStatus()
}
public GameModeCapturePoint : BaseEntity {
public CapturePointTrigger captureTrigger
public float timeToCapture
public int scorePerSecond
public string scoreName
private float captureFraction
private int captureTeam
private int capturingTeam
public EntityRef capturingPlayer
public EntityRef capturedPlayer
public Flags Flag_Contested
public RustText capturePointText
public RustText captureOwnerName
public Image captureProgressImage
public GameObjectRef progressBeepEffect
public GameObjectRef progressCompleteEffect
public Transform computerPoint
private float nextBeepTime
public bool IsContested()
public void ServerInit()
public void Update()
public void AssignPoints()
public void DoCaptureEffect()
public void DoProgressEffect()
public void UpdateCaptureAmount()
public void Save(SaveInfo info)
}
public GameModeManifest : ScriptableObject {
public GameModeManifest instance
public List`1<GameObjectRef> gameModePrefabs
public GameModeManifest Get()
}
public GameModeObjectToggle : BaseMonoBehaviour {
public String[] gameModeTags
public GameObject[] toToggle
public void Awake()
public void OnDestroy()
public void OnGameModeChanged(BaseGameMode newGameMode)
public void SetToggle(bool wantsOn)
public bool ShouldBeVisible(BaseGameMode newGameMode)
}
public GameModeSoftcore : GameModeVanilla {
public GameObjectRef reclaimManagerPrefab
public GameObjectRef reclaimBackpackPrefab
public Phrase ReclaimToast
public ItemAmount[] startingGear
public float reclaim_fraction_belt
public float reclaim_fraction_wear
public float reclaim_fraction_main
protected void OnCreated()
public void AddFractionOfContainer(ItemContainer from, List`1& to, float fraction)
public List`1<Item> RemoveItemsFrom(ItemContainer itemContainer, ItemAmount[] types)
public void ReturnItemsTo(List`1& source, ItemContainer itemContainer)
public void OnPlayerDeath(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo)
public void OnPlayerRespawn(BasePlayer player)
public SleepingBag[] FindSleepingBagsForPlayer(ulong playerID, bool ignoreTimers)
public float CorpseRemovalTime(BaseCorpse corpse)
public void SetInventoryLocked(BasePlayer player, bool wantsLocked)
public void OnPlayerWounded(BasePlayer instigator, BasePlayer victim, HitInfo info)
public void OnPlayerRevived(BasePlayer instigator, BasePlayer victim)
public bool CanMoveItemsFrom(PlayerInventory inv, BaseEntity source, Item item)
}
public GameModeSpawnGroup : SpawnGroup {
public String[] gameModeTags
public void ResetSpawnGroup()
public bool ShouldSpawn()
protected void Spawn(int numToSpawn)
}
public GameObjectLOD : LODComponent {
public float Distance
public GameObject TargetGameObject
}
public GameObjectRef : ResourceRef`1<GameObject> {
public GameObject Instantiate(Transform parent)
}
public GameObjectUtil : object {
public void GlobalBroadcast(string messageName, object param)
}
public GamePhysics : object {
public int BufferLength
private RaycastHit[] hitBuffer
private Collider[] colBuffer
public bool CheckSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckOBB(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckBounds(Bounds bounds, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapSphere(Vector3 position, float radius, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapOBB(OBB obb, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapBounds(Bounds bounds, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void BufferToList(int count, List`1<Collider> list)
public bool CheckSphere(Vector3 pos, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckOBB(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool CheckBounds(Bounds bounds, int layerMask, QueryTriggerInteraction triggerInteraction)
private bool CheckComponent(List`1<Collider> list)
public void OverlapSphere(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapOBB(OBB obb, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void OverlapBounds(Bounds bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void BufferToList(int count, List`1<T> list)
public bool Trace(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction)
public void TraceAll(Ray ray, float radius, List`1<RaycastHit> hits, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction)
public void TraceAllUnordered(Ray ray, float radius, List`1<RaycastHit> hits, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding0, float padding1)
public bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding)
public bool LineOfSight(Vector3 p0, Vector3 p1, Vector3 p2, int layerMask, float padding)
public bool LineOfSight(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, int layerMask, float padding)
public bool LineOfSight(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, int layerMask, float padding)
private bool LineOfSightInternal(Vector3 p0, Vector3 p1, int layerMask, float padding0, float padding1)
public bool Verify(RaycastHit hitInfo)
public bool Verify(Collider collider, Vector3 point)
public int HandleTerrainCollision(Vector3 position, int layerMask)
public void Sort(List`1<RaycastHit> hits)
public void Sort(RaycastHit[] hits)
}
public GameSetup : MonoBehaviour {
public bool RunOnce
public bool startServer
public string clientConnectCommand
public bool loadMenu
public bool loadLevel
public string loadLevelScene
public bool loadSave
public string loadSaveFile
protected void Awake()
private IEnumerator DoGameSetup()
private IEnumerator StartServer()
}
public GameStat : MonoBehaviour {
public float refreshTime
public Text title
public Text globalStat
public Text localStat
private long globalValue
private long localValue
private float secondsSinceRefresh
private float secondsUntilUpdate
private float secondsUntilChange
public Stat[] stats
}
public GameTip : SingletonComponent`1<GameTip> {
public CanvasGroup canvasGroup
public RustIcon icon
public Image background
public RustText text
public Theme[] themes
}
public GameTips.BaseTip : object {
public bool ShouldShow
public string Type
public Phrase GetPhrase()
public bool get_ShouldShow()
public string get_Type()
}
public GeigerCounter : AttackEntity {
public Transform geigerRod
}
public GenerateBiome : ProceduralComponent {
public void Native_GenerateBiome(Byte[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle, Int16[] heightmap, int heightres)
public void Process(UInt32 seed)
}
public GenerateCliffSplat : ProceduralComponent {
private int filter
public void Process(int x, int z)
public void Process(UInt32 seed)
}
public GenerateCliffTopology : ProceduralComponent {
public bool KeepExisting
private int filter
public void Process(int x, int z)
private void Process(int x, int z, bool keepExisting)
public void Process(UInt32 seed)
}
public GenerateClutterTopology : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateDecorTopology : ProceduralComponent {
public bool KeepExisting
public void Process(UInt32 seed)
}
public GenerateDungeon : ProceduralComponent {
public string TunnelFolder
public string StationFolder
public string TransitionFolder
public string LinkFolder
public InfrastructureType ConnectionType
public int CellSize
public float LinkHeight
public float LinkRadius
private int MaxDepth
public bool RunOnCache
public bool get_RunOnCache()
public void Process(UInt32 seed)
internal void <Process>g__AddNode|16_1(int x, int y, <>c__DisplayClass16_0& , <>c__DisplayClass16_1& , <>c__DisplayClass16_2& , <>c__DisplayClass16_3& )
}
public GenerateHeight : ProceduralComponent {
public void Native_GenerateHeight(Int16[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle)
public void Process(UInt32 seed)
}
public GeneratePowerlineLayout : ProceduralComponent {
private int MaxDepth
public void Process(UInt32 seed)
}
public GeneratePowerlineTopology : ProceduralComponent {
public void Process(UInt32 seed)
}
public GenerateRiverLayout : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private int Smoothen
public void Process(UInt32 seed)
}
public GenerateRiverMeshes : ProceduralComponent {
public float NormalSmoothing
public Mesh RiverMesh
public Mesh[] RiverMeshes
public Material RiverMaterial
public PhysicMaterial RiverPhysicMaterial
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateRiverTopology : ProceduralComponent {
private int Smoothen
public void Process(UInt32 seed)
public void MarkRiverside()
}
public GenerateRoadLayout : ProceduralComponent {
public InfrastructureType RoadType
public float RoadWidth
public float TrailWidth
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private int Smoothen
private int MaxDepth
private PathList CreateSegment(int number, Vector3[] points)
public void Process(UInt32 seed)
}
public GenerateRoadMeshes : ProceduralComponent {
public float NormalSmoothing
public Mesh RoadMesh
public Mesh[] RoadMeshes
public Material RoadMaterial
public Material RoadRingMaterial
public PhysicMaterial RoadPhysicMaterial
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateRoadRing : ProceduralComponent {
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
private int Smoothen
private int MaxDepth
public int MinWorldSize
public void Process(UInt32 seed)
}
public GenerateRoadTopology : ProceduralComponent {
private int Smoothen
public void Process(UInt32 seed)
private void MarkRoadside()
}
public GenerateSplat : ProceduralComponent {
public void Native_GenerateSplat(Byte[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle, Int16[] heightmap, int heightres, Byte[] biomemap, int biomeres, Int32[] topologymap, int topologyres)
public void Process(UInt32 seed)
}
public GenerateTerrainMesh : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateTextures : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenerateTopology : ProceduralComponent {
public void Native_GenerateTopology(Int32[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle, Int16[] heightmap, int heightres, Byte[] biomemap, int biomeres)
public void Process(UInt32 seed)
}
public GenerateWireMeshes : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public GenericSpawnPoint : BaseSpawnPoint {
public bool dropToGround
public bool randomRot
public float randomRotSnapDegrees
public GameObjectRef spawnEffect
public UnityEvent OnObjectSpawnedEvent
public UnityEvent OnObjectRetiredEvent
public Quaternion GetRandomRotation()
public void GetLocation(Vector3& pos, Quaternion& rot)
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
}
public GestureCollection : ScriptableObject {
public GestureConfig[] AllGestures
public float GestureVmInDuration
public AnimationCurve GestureInCurve
public float GestureVmOutDuration
public AnimationCurve GestureOutCurve
public float GestureViewmodelDeployDelay
public GestureConfig IdToGesture(UInt32 id)
public GestureConfig StringToGesture(string gestureName)
}
public GestureConfig : ScriptableObject {
public UInt32 gestureId
public string gestureCommand
public string convarName
public Phrase gestureName
public Sprite icon
public int order
public float duration
public bool canCancel
public PlayerModelLayer playerModelLayer
public MovementCapabilities movementMode
public AnimationType animationType
public CameraMode viewMode
public GestureActionType actionType
public bool forceUnlock
public SteamDLCItem dlcItem
public SteamInventoryItem inventoryItem
public bool IsOwnedBy(BasePlayer player)
public bool CanBeUsedBy(BasePlayer player)
}
public GhostSheetSystemSpaceUpdater : MonoBehaviour {
private EZSoftBone[] ezSoftBones
private BasePlayer player
public void Awake()
public void Update()
private void SetSimulateSpace(Transform transform, bool collisionEnabled)
}
public Gib : ListComponent`1<Gib> {
public int gibCount
public MeshFilter _meshFilter
public MeshRenderer _meshRenderer
public MeshCollider _meshCollider
public BoxCollider _boxCollider
public SphereCollider _sphereCollider
public CapsuleCollider _capsuleCollider
public Rigidbody _rigidbody
public string GetEffect(PhysicMaterial physicMaterial)
}
public Gibbable : PrefabAttribute {
public GameObject gibSource
public Material[] customMaterials
public GameObject materialSource
public bool copyMaterialBlock
public PhysicMaterial physicsMaterial
public GameObjectRef fxPrefab
public bool spawnFxPrefab
public bool important
public float explodeScale
public float scaleOverride
public int uniqueId
public BoundsEffectType boundsEffectType
public Bounds effectBounds
public List`1<OverrideMesh> MeshOverrides
protected Type GetIndexedType()
}
public GizmosUtil : object {
public void DrawWireCircleX(Vector3 pos, float radius)
public void DrawWireCircleY(Vector3 pos, float radius)
public void DrawWireCircleZ(Vector3 pos, float radius)
public void DrawCircleX(Vector3 pos, float radius)
public void DrawCircleY(Vector3 pos, float radius)
public void DrawCircleZ(Vector3 pos, float radius)
public void DrawWireCylinderX(Vector3 pos, float radius, float height)
public void DrawWireCylinderY(Vector3 pos, float radius, float height)
public void DrawWireCylinderZ(Vector3 pos, float radius, float height)
public void DrawCylinderX(Vector3 pos, float radius, float height)
public void DrawCylinderY(Vector3 pos, float radius, float height)
public void DrawCylinderZ(Vector3 pos, float radius, float height)
public void DrawWireCapsuleX(Vector3 pos, float radius, float height)
public void DrawWireCapsuleY(Vector3 pos, float radius, float height)
public void DrawWireCapsuleZ(Vector3 pos, float radius, float height)
public void DrawCapsuleX(Vector3 pos, float radius, float height)
public void DrawCapsuleY(Vector3 pos, float radius, float height)
public void DrawCapsuleZ(Vector3 pos, float radius, float height)
public void DrawWireCube(Vector3 pos, Vector3 size, Quaternion rot)
public void DrawCube(Vector3 pos, Vector3 size, Quaternion rot)
public void DrawWirePath(Vector3 a, Vector3 b, float thickness)
public void DrawSemiCircle(float radius)
public void DrawMeshes(Transform transform)
public void DrawBounds(Transform transform)
}
public GlassPane : BaseMonoBehaviour {
public Renderer glassRendereer
private BaseVehicleModule module
private float showFullDamageAt
}
public GranularAudioClip : MonoBehaviour {
public AudioClip sourceClip
private Single[] sourceAudioData
private int sourceChannels
public AudioClip granularClip
public int sampleRate
public float sourceTime
public float sourceTimeVariation
public float grainAttack
public float grainSustain
public float grainRelease
public float grainFrequency
public int grainAttackSamples
public int grainSustainSamples
public int grainReleaseSamples
public int grainFrequencySamples
public int samplesUntilNextGrain
public List`1<Grain> grains
private Random random
private bool inited
private void Update()
private void RefreshCachedData()
private void InitAudioClip()
private void OnAudioRead(Single[] data)
private void SpawnGrain()
private void CleanupFinishedGrains()
}
public Graph : MonoBehaviour {
public Material Material
public int Resolution
public Vector2 ScreenFill
public Vector2 ScreenOrigin
public Vector2 Pivot
public Rect Area
internal float CurrentValue
private int index
private Single[] values
private float max
protected float GetValue()
protected Color GetColor(float value)
protected Vector3 GetVertex(float x, float y)
protected void Update()
protected void OnGUI()
}
public GraveyardFence : SimpleBuildingBlock {
public BoxCollider[] pillars
public void ServerInit()
public void DestroyShared()
public void UpdatePillars()
}
public GridLayoutGroupNeat : GridLayoutGroup {
private float IdealCellWidth(float cellSize)
public void SetLayoutHorizontal()
public void SetLayoutVertical()
}
public GroundWatch : BaseMonoBehaviour {
public Vector3 groundPosition
public LayerMask layers
public float radius
private int fails
private void OnDrawGizmosSelected()
public void PhysicsChanged(GameObject obj)
public void PhysicsChanged(Vector3 origin, float radius, int layerMask)
private void OnPhysicsNeighbourChanged()
private bool OnGround()
}
public GrowableEntity : BaseCombatEntity {
public float artificalLightQuality
public float planterGroundModifierBase
public float fertilizerGroundModifierBonus
public float growthGeneSpeedMultiplier
public float waterGeneRequirementMultiplier
public float hardinessGeneModifierBonus
public float hardinessGeneTemperatureModifierBonus
public float baseYieldIncreaseMultiplier
public float yieldGeneBonusMultiplier
public float maxNonPlanterGroundQuality
public float deathRatePerQuality
public TimeCachedValue`1<float> sunExposure
public TimeCachedValue`1<float> artificialLightExposure
public TimeCachedValue`1<float> artificialTemperatureExposure
public float framebudgetms
public GrowableEntityUpdateQueue growableEntityUpdateQueue
public bool underWater
public int seasons
public int harvests
public float terrainTypeValue
public float yieldPool
public PlanterBox planter
public PlantProperties Properties
public ItemDefinition SourceItemDef
private State <State>k__BackingField
private float <Age>k__BackingField
private float <LightQuality>k__BackingField
private float <GroundQuality>k__BackingField
private float <WaterQuality>k__BackingField
private float <WaterConsumption>k__BackingField
private bool <Fertilized>k__BackingField
private float <TemperatureQuality>k__BackingField
private float <OverallQuality>k__BackingField
private float <Yield>k__BackingField
public float stageAge
public GrowableGenes Genes
public float startingHealth
public float CurrentTemperature
public State State
public float Age
public float LightQuality
public float GroundQuality
public float WaterQuality
public float WaterConsumption
public bool Fertilized
public float TemperatureQuality
public float OverallQuality
public float Yield
public float StageProgressFraction
public Stage currentStage
public float ThinkDeltaTime
public float growDeltaTime
public int CurrentPickAmount
public float CurrentPickAmountFloat
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void QueueForQualityUpdate()
public void CalculateQualities(bool firstTime, bool forceArtificialLightUpdates, bool forceArtificialTemperatureUpdates)
private void CalculateQualities_Water()
public void CalculateLightQuality(bool forceArtificalUpdate)
public float CalculateSunExposure(bool force)
public float SunRaycast()
public float GetArtificialLightExposure(bool force)
private float CalculateArtificialLightExposure()
public float CalculateArtificialLightExposure(Transform forTransform)
public float SunRaycast(Vector3 checkPosition)
public void CalculateWaterQuality()
public void CalculateGroundQuality(bool firstCheck)
public float GetGroundTypeValue(Vector3 pos)
public void CalculateTemperatureQuality()
public float CalculateOverallQuality()
public void CalculateWaterConsumption()
private float CalculateArtificialTemperature()
public float CalculateArtificialTemperature(Transform forTransform)
public int CalculateMarketValue()
private float RemapValue(float inValue, float minA, float maxA, float minB, float maxB)
public float get_CurrentTemperature()
public void ServerInit()
public PlanterBox GetPlanter()
public void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
public void PostServerLoad()
public void ResetSeason()
public void RunUpdate()
public float UpdateAge(float overallQuality)
public void UpdateHealthAndYield(float overallQuality, float actualStageAgeIncrease)
public void ApplyDeathRate()
public float GetGrowthBonus(float overallQuality)
public State UpdateState()
public void ConsumeWater()
public void Fertilize()
public void RPC_TakeClone(RPCMessage msg)
public void TakeClones(BasePlayer player)
public void PickFruit(BasePlayer player)
public void GiveFruit(BasePlayer player, int amount)
public void GiveFruit(BasePlayer player, int amount, bool applyCondition)
public void RPC_PickFruit(RPCMessage msg)
public void RPC_RemoveDying(RPCMessage msg)
public void RemoveDying(BasePlayer receiver)
public void GrowAll(Arg arg)
public State get_State()
public void set_State(State value)
public float get_Age()
private void set_Age(float value)
public float get_LightQuality()
public void set_LightQuality(float value)
public float get_GroundQuality()
public void set_GroundQuality(float value)
public float get_WaterQuality()
public void set_WaterQuality(float value)
public float get_WaterConsumption()
public void set_WaterConsumption(float value)
public bool get_Fertilized()
public void set_Fertilized(bool value)
public float get_TemperatureQuality()
public void set_TemperatureQuality(float value)
public float get_OverallQuality()
public void set_OverallQuality(float value)
public float get_Yield()
public void set_Yield(float value)
public float get_StageProgressFraction()
public Stage get_currentStage()
public float get_ThinkDeltaTime()
public float get_growDeltaTime()
public void ReceiveInstanceData(InstanceData data)
public void ResetState()
public bool CanPick()
public int get_CurrentPickAmount()
public float get_CurrentPickAmountFloat()
public bool CanTakeSeeds()
public bool CanClone()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ChangeState(State state, bool resetAge, bool loading)
}
public GrowableGene : object {
private GeneType <Type>k__BackingField
private GeneType <PreviousType>k__BackingField
public GeneType Type
public GeneType PreviousType
public GeneType get_Type()
private void set_Type(GeneType value)
public GeneType get_PreviousType()
private void set_PreviousType(GeneType value)
public void Set(GeneType geneType, bool firstSet)
public void SetPrevious(GeneType type)
public string GetDisplayCharacter()
public string GetDisplayCharacter(GeneType type)
public string GetColourCodedDisplayCharacter()
public string GetColourCodedDisplayCharacter(GeneType type)
public bool IsPositive(GeneType type)
public bool IsPositive()
}
public GrowableGeneEncoding : object {
public void EncodeGenesToItem(GrowableEntity sourceGrowable, Item targetItem)
public void EncodeGenesToItem(int genes, Item targetItem)
public int EncodeGenesToInt(GrowableGenes genes)
public int EncodePreviousGenesToInt(GrowableGenes genes)
public void DecodeIntToGenes(int data, GrowableGenes genes)
public void DecodeIntToPreviousGenes(int data, GrowableGenes genes)
public string DecodeIntToGeneString(int data)
private int Set(int storage, int slot, int value)
private int Get(int storage, int slot)
}
public GrowableGeneProperties : ScriptableObject {
public GeneWeight[] Weights
}
public GrowableGenes : object {
public GrowableGene[] Genes
private GeneWeighting[] baseWeights
private GeneWeighting[] slotWeights
private void Clear()
public void GenerateRandom(GrowableEntity growable)
private void CalculateBaseWeights(GrowableGeneProperties properties)
private void CalculateSlotWeights(GrowableGeneProperties properties, int slot)
private GeneType PickWeightedGeneType()
public int GetGeneTypeCount(GeneType geneType)
public int GetPositiveGeneCount()
public int GetNegativeGeneCount()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void DebugPrint()
private string GetDisplayString(bool previousGenes)
}
public GrowableGenetics : object {
public int GeneSlotCount
public float CrossBreedingRadius
private GeneWeighting[] neighbourWeights
private GeneWeighting dominant
public void CrossBreed(GrowableEntity growable)
private GeneWeighting GetDominantGeneWeighting(GrowableEntity crossBreedingGrowable, List`1<GrowableEntity> neighbours, int slot)
}
public GrowableHeatSource : EntityComponent`1<BaseEntity> {
public float heatAmount
public float ApplyHeat(Vector3 forPosition)
public void ForceUpdateGrowablesInRange()
}
public GunModInformationPanel : ItemInformationPanel {
public ItemTextValue fireRateDisplay
public ItemTextValue velocityDisplay
public ItemTextValue damageDisplay
public ItemTextValue accuracyDisplay
public ItemTextValue recoilDisplay
public ItemTextValue zoomDisplay
}
public GunTrap : StorageContainer {
public GameObjectRef gun_fire_effect
public GameObjectRef bulletEffect
public GameObjectRef triggeredEffect
public Transform muzzlePos
public Transform eyeTransform
public int numPellets
public int aimCone
public float sensorRadius
public ItemDefinition ammoType
public TargetTrigger trigger
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool UseAmmo()
public void FireWeapon()
public void FireBullet()
public void ServerInit()
public void TriggerCheck()
public bool CheckTrigger()
public bool IsTriggered()
public Vector3 GetEyePosition()
}
public HackableLockedCrate : LootContainer {
public Flags Flag_Hacking
public Flags Flag_FullyHacked
public Text timerText
public float requiredHackSeconds
public float decaySeconds
public SoundPlayer hackProgressBeep
public float hackSeconds
public GameObjectRef shockEffect
public GameObjectRef mapMarkerEntityPrefab
public GameObjectRef landEffect
public bool shouldDecay
private BaseEntity mapMarkerInstance
public bool hasLanded
public bool wasDropped
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsBeingHacked()
public bool IsFullyHacked()
public void DestroyShared()
public void CreateMapMarker(float durationMinutes)
public void RefreshDecay()
public void DelayedDestroy()
public void OnAttacked(HitInfo info)
public void SetWasDropped()
public void ServerInit()
public void LandCheck()
public void PostServerLoad()
public void RPC_Hack(RPCMessage msg)
public void StartHacking()
public void HackProgress()
}
public HairCapMask : Enum {
public int value__
public HairCapMask Head
public HairCapMask Eyebrow
public HairCapMask Facial
public HairCapMask Armpit
public HairCapMask Pubic
}
public HairDye : object {
public Color capBaseColor
public Material sourceMaterial
public CopyPropertyMask copyProperties
private MaterialPropertyDesc[] transferableProps
private int _HairBaseColorUV1
private int _HairBaseColorUV2
private int _HairPackedMapUV1
private int _HairPackedMapUV2
public void Apply(HairDyeCollection collection, MaterialPropertyBlock block)
public void ApplyCap(HairDyeCollection collection, HairType type, MaterialPropertyBlock block)
}
public HairDyeCollection : ScriptableObject {
public Texture capMask
public bool applyCap
public HairDye[] Variations
public HairDye Get(float seed)
}
public HairSet : ScriptableObject {
public MeshReplace[] MeshReplacements
public void Process(PlayerModelHair playerModelHair, HairDyeCollection dyeCollection, HairDye dye, MaterialPropertyBlock block)
public void ProcessMorphs(GameObject obj, int blendShapeIndex)
}
public HairSetCollection : ScriptableObject {
public HairSetEntry[] Head
public HairSetEntry[] Eyebrow
public HairSetEntry[] Facial
public HairSetEntry[] Armpit
public HairSetEntry[] Pubic
public HairSetEntry[] GetListByType(HairType hairType)
public int GetIndex(HairSetEntry[] list, float typeNum)
public int GetIndex(HairType hairType, float typeNum)
public HairSetEntry Get(HairType hairType, float typeNum)
}
public HairType : Enum {
public int value__
public HairType Head
public HairType Eyebrow
public HairType Facial
public HairType Armpit
public HairType Pubic
public HairType Count
}
public Half3 : ValueType {
public ushort x
public ushort y
public ushort z
public void .ctor(Vector3 vec)
public Vector3 op_Explicit(Half3 vec)
}
public Half4 : ValueType {
public ushort x
public ushort y
public ushort z
public ushort w
public void .ctor(Vector4 vec)
public Vector4 op_Explicit(Half4 vec)
}
public HalloweenHunt : EggHuntEvent {
public void PrintWinnersAndAward()
}
public Hammer : BaseMelee {
public bool CanHit(HitTest info)
public void DoAttackShared(HitInfo info)
}
public HBHFSensor : BaseDetector {
public GameObjectRef detectUp
public GameObjectRef detectDown
public Flags Flag_IncludeOthers
public Flags Flag_IncludeAuthed
private int detectedPlayers
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetPassthroughAmount(int outputSlot)
public void OnObjects()
public void OnEmpty()
public void UpdatePassthroughAmount()
public void SetIncludeAuth(RPCMessage msg)
public void SetIncludeOthers(RPCMessage msg)
public bool ShouldIncludeAuthorized()
public bool ShouldIncludeOthers()
}
public HeldEntity : BaseEntity {
public Animator worldModelAnimator
public SoundDefinition thirdPersonDeploySound
public SoundDefinition thirdPersonAimSound
public SoundDefinition thirdPersonAimEndSound
public Flags Flag_ForceVisible
public string handBone
public AnimatorOverrideController HoldAnimationOverride
public ToolTypeEnum toolType
public bool isBuildingTool
public float hostileScore
public HolsterInfo holsterInfo
public CameraMode HeldCameraMode
public Vector3 FirstPersonArmOffset
public Vector3 FirstPersonArmRotation
public float FirstPersonRotationStrength
private bool holsterVisible
private bool genericVisible
private heldEntityVisState currentVisState
internal UInt32 ownerItemUID
public bool hostile
public bool IsUsableByTurret
public Transform MuzzleTransform
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SendPunch(Vector3 amount, float duration)
public bool get_hostile()
public bool LightsOn()
public bool IsDeployed()
public BasePlayer GetOwnerPlayer()
public Connection GetOwnerConnection()
public void SetOwnerPlayer(BasePlayer player)
public void ClearOwnerPlayer()
public void SetVisibleWhileHolstered(bool visible)
public void SetGenericVisible(bool wantsVis)
public UInt32 GetBone(string bone)
public void SetLightsOn(bool isOn)
public void UpdateHeldItemVisibility()
public bool UpdateVisibility_Hand()
public bool UpdateVisibility_GenericVis()
public bool UpdateVisiblity_Holster()
public bool UpdateVisiblity_Invis()
public void SetHeld(bool bHeld)
public void OnHeldChanged()
public bool get_IsUsableByTurret()
public Transform get_MuzzleTransform()
public bool CanBeUsedInWater()
protected Item GetOwnerItem()
public Item GetItem()
public ItemDefinition GetOwnerItemDefinition()
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
public void ServerCommand(Item item, string command, BasePlayer player)
public void SetupHeldEntity(Item item)
public void PostServerLoad()
private void InitOwnerPlayer()
public void Save(SaveInfo info)
public void DestroyThis()
protected bool HasItemAmount()
protected bool UseItemAmount(int iAmount)
public bool IsInstrument()
public void ServerUse()
public void ServerUse(float damageModifier, Transform originOverride)
public void Load(LoadInfo info)
}
public HelicopterDebris : ServerGib {
public ItemDefinition metalFragments
public ItemDefinition hqMetal
public ItemDefinition charcoal
public float massReductionScalar
private ResourceDispenser resourceDispenser
public float tooHotUntil
public void ServerInit()
public void PhysicsInit(Mesh mesh)
public bool IsTooHot()
public void OnAttacked(HitInfo info)
}
public HelicopterTurret : MonoBehaviour {
public PatrolHelicopterAI _heliAI
public float fireRate
public float burstLength
public float timeBetweenBursts
public float maxTargetRange
public float loseTargetAfter
public Transform gun_yaw
public Transform gun_pitch
public Transform muzzleTransform
public bool left
public BaseCombatEntity _target
private float lastBurstTime
private float lastFireTime
private float lastSeenTargetTime
private bool targetVisible
public void SetTarget(BaseCombatEntity newTarget)
public bool NeedsNewTarget()
public bool UpdateTargetFromList(List`1<targetinfo> newTargetList)
public bool TargetVisible()
public float TimeSinceTargetLastSeen()
public bool HasTarget()
public void ClearTarget()
public void TurretThink()
public void FireGun()
public Vector3 GetPositionForEntity(BaseCombatEntity potentialtarget)
public float AngleToTarget(BaseCombatEntity potentialtarget)
public bool InFiringArc(BaseCombatEntity potentialtarget)
public void UpdateTargetVisibility()
}
public HideIfAiming : MonoBehaviour {
public ParticleSystem[] systems
}
public HideIfOwnerFirstPerson : EntityComponent`1<BaseEntity> {
public GameObject[] disableGameObjects
public bool worldModelEffect
}
public HideIfScoped : MonoBehaviour {
public Renderer[] renderers
public void SetVisible(bool vis)
}
public HideUntilMobile : EntityComponent`1<BaseEntity> {
public GameObject[] visuals
private Vector3 startPos
}
public HierarchyUtil : object {
public Dictionary`2<string, GameObject> rootDict
public GameObject GetRoot(string strName, bool groupActive, bool persistant)
}
public HitArea : Enum {
public int value__
public HitArea Head
public HitArea Chest
public HitArea Stomach
public HitArea Arm
public HitArea Hand
public HitArea Leg
public HitArea Foot
}
public HitAreaConst : object {
public HitArea Nothing
public HitArea Everything
}
public HitAreaUtil : object {
public string Format(HitArea area)
}
public HitboxDefinition : MonoBehaviour {
public Vector3 center
public Vector3 rotation
public Type type
public int priority
public PhysicMaterial physicMaterial
private Vector3 scale
public Vector3 Scale
public Matrix4x4 LocalMatrix
public Vector3 get_Scale()
public void set_Scale(Vector3 value)
public Matrix4x4 get_LocalMatrix()
private void OnValidate()
protected void OnDrawGizmosSelected()
protected void OnDrawGizmos()
}
public HitboxSystem : MonoBehaviour {
public List`1<HitboxShape> hitboxes
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public HitchTrough : StorageContainer {
public HitchSpot[] hitchSpots
public float caloriesToDecaySeconds
public Item GetFoodItem()
public bool ValidHitchPosition(Vector3 pos)
public bool HasSpace()
public HitchSpot GetClosest(Vector3 testPos, bool includeOccupied, float maxRadius)
public void Unhitch(RidableHorse horse)
public int NumHitched()
public bool AttemptToHitch(RidableHorse horse, HitchSpot hitch)
public void Save(SaveInfo info)
public void PostServerLoad()
public void UnhitchAll()
public void DestroyShared()
public void OnKilled(HitInfo info)
public void Load(LoadInfo info)
}
public HitDetectionBenchmark : BenchmarkScene {
private int PlayerCount
public GameObjectRef PlayerModelPrefab
public GameObjectRef PlayerCollisionPrefab
}
public HitInfo : object {
public BaseEntity Initiator
public BaseEntity WeaponPrefab
public AttackEntity Weapon
public bool DoHitEffects
public bool DoDecals
public bool IsPredicting
public bool UseProtection
public Connection Predicted
public bool DidHit
public BaseEntity HitEntity
public UInt32 HitBone
public UInt32 HitPart
public UInt32 HitMaterial
public Vector3 HitPositionWorld
public Vector3 HitPositionLocal
public Vector3 HitNormalWorld
public Vector3 HitNormalLocal
public Vector3 PointStart
public Vector3 PointEnd
public int ProjectileID
public float ProjectileDistance
public Vector3 ProjectileVelocity
public Projectile ProjectilePrefab
public PhysicMaterial material
public DamageProperties damageProperties
public DamageTypeList damageTypes
public bool CanGather
public bool DidGather
public float gatherScale
public BasePlayer InitiatorPlayer
public Vector3 attackNormal
public bool hasDamage
public bool isHeadshot
public Phrase bonePhrase
public string boneName
public HitArea boneArea
public bool IsProjectile()
public BasePlayer get_InitiatorPlayer()
public Vector3 get_attackNormal()
public bool get_hasDamage()
public void .ctor(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount, Vector3 vhitPosition)
public void .ctor(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount)
public void LoadFromAttack(Attack attack, bool serverSide)
public bool get_isHeadshot()
public Phrase get_bonePhrase()
public string get_boneName()
public HitArea get_boneArea()
public Vector3 PositionOnRay(Vector3 position)
public Vector3 HitPositionOnRay()
public bool IsNaNOrInfinity()
}
public HitNumber : MonoBehaviour {
public HitType hitType
public int ColorToMultiplier(HitType type)
public void OnDrawGizmos()
}
public HitTest : object {
public Type type
public Ray AttackRay
public float Radius
public float Forgiveness
public float MaxDistance
public RaycastHit RayHit
public bool MultiHit
public bool BestHit
public bool DidHit
public DamageProperties damageProperties
public GameObject gameObject
public Collider collider
public BaseEntity ignoreEntity
public BaseEntity HitEntity
public Vector3 HitPoint
public Vector3 HitNormal
public float HitDistance
public Transform HitTransform
public UInt32 HitPart
public string HitMaterial
public Vector3 HitPointWorld()
public Vector3 HitNormalWorld()
public void Clear()
}
public HolosightReticlePositioning : MonoBehaviour {
public IronsightAimPoint aimPoint
public RectTransform rectTransform
public RectTransform get_rectTransform()
private void Update()
private void UpdatePosition(Camera cam)
}
public Horse : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public void ServerInit()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public HorseBreed : ScriptableObject {
public Phrase breedName
public Phrase breedDesc
public Material[] materialOverrides
public float maxHealth
public float maxSpeed
public float staminaDrain
public float maxStamina
}
public HorseCorpse : LootableCorpse {
public int breedIndex
public Phrase lootPanelTitle
public string playerName
public string get_playerName()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public HorseEquipmentInformationPanel : ItemInformationPanel {
public ItemTextValue horseProtectionDisplay
public ItemTextValue riderProtectionDisplay
public ItemTextValue maxSpeedDisplay
public ItemTextValue storageAmountDisplay
}
public HorseRagdoll : AnimalRagdoll {
public GameObject mane
public GameObject woodArmor
public GameObject roadsignArmor
public HorseBreed overrideBreed
public GameObjectRef breedSource
}
public HorseSpawner : VehicleSpawner {
public float respawnDelay
public float respawnDelayVariance
public bool spawnForSale
public void ServerInit()
public int GetOccupyLayer()
public void RespawnHorse()
}
public HostileNote : MonoBehaviour {
public CanvasGroup warnGroup
public CanvasGroup group
public CanvasGroup timerGroup
public CanvasGroup smallWarning
public Text timerText
public Text smallWarningText
public float unhostileTime
public float weaponDrawnDuration
public Color warnColor
public Color hostileColor
public float requireDistanceToSafeZone
}
public HotAirBalloon : BaseCombatEntity {
protected Flags Flag_HasFuel
protected Flags Flag_HalfInflated
protected Flags Flag_FullInflated
public Transform centerOfMass
public Rigidbody myRigidbody
public Transform buoyancyPoint
public float liftAmount
public Transform windSock
public Transform[] windFlags
public GameObject staticBalloonDeflated
public GameObject staticBalloon
public GameObject animatedBalloon
public Animator balloonAnimator
public Transform groundSample
public float inflationLevel
public GameObjectRef fuelStoragePrefab
public Transform fuelStoragePoint
public float fuelPerSec
public GameObjectRef storageUnitPrefab
public Transform storageUnitPoint
public EntityRef storageUnitInstance
public DamageRenderer damageRenderer
public Transform engineHeight
public GameObject[] killTriggers
public EntityFuelSystem fuelSystem
public float population
public float outsidedecayminutes
public float windForce
public Vector3 currentWindVec
public Bounds collapsedBounds
public Bounds raisedBounds
public GameObject[] balloonColliders
public float serviceCeiling
public float currentBuoyancy
public float lastBlastTime
public float avgTerrainHeight
public bool grounded
public bool IsFullyInflated
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_IsFullyInflated()
public void InitShared()
public void Load(LoadInfo info)
public bool WaterLogged()
public bool IsValidSAMTarget()
public float GetNetworkTime()
public void PostServerLoad()
public void SpawnSubEntities()
public void RPC_OpenFuel(RPCMessage msg)
public void Spawn()
public void Save(SaveInfo info)
public void ServerInit()
public void DecayTick()
public void EngineSwitch(RPCMessage msg)
public void ScheduleOff()
public void UpdateIsGrounded()
protected void FixedUpdate()
public Vector3 GetLocalVelocityServer()
public Quaternion GetAngularVelocityServer()
public Vector3 GetWindAtPos(Vector3 pos)
public bool SupportsChildDeployables()
}
public HotOverlay : ImageEffectLayer {
public LensDirtiness lensDirtyness
public VignetteAndChromaticAberration vingette
}
public HTNAnimal : BaseCombatEntity {
public Vector3 HipFudge
public Transform HipBone
public Transform LookBone
public bool UpdateWalkSpeed
public bool UpdateFacingDirection
public bool UpdateGroundNormal
public Transform alignmentRoot
public bool LaggyAss
public bool LookAtTarget
public float MaxLaggyAssRotation
public float MaxWalkAnimSpeed
public HTNDomain _aiDomain
public BaseNpcDefinition _aiDefinition
public MaterialEffect FootstepEffects
public Transform[] Feet
public string BaseFolder
private Vector3 <estimatedVelocity>k__BackingField
private bool isDormant
private float lastInvokedTickTime
public bool IsNpc
public BaseEntity Body
public Vector3 BodyPosition
public Vector3 EyePosition
public Quaternion EyeRotation
protected float PositionTickRate
public FamilyEnum Family
public BaseNpcDefinition AiDefinition
public HTNDomain AiDomain
public Vector3 estimatedVelocity
public bool IsDormant
public BaseEntity MainTarget
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_IsNpc()
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public float MaxVelocity()
public BaseEntity get_Body()
public Vector3 get_BodyPosition()
public Vector3 get_EyePosition()
public Quaternion get_EyeRotation()
protected float get_PositionTickRate()
public FamilyEnum get_Family()
public void ServerInit()
public void ResetState()
internal void DoServerDestroy()
public void Hurt(HitInfo info)
public void OnKilled(HitInfo info)
public void OnSensation(Sensation sensation)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public BaseNpcDefinition get_AiDefinition()
public HTNDomain get_AiDomain()
public Vector3 get_estimatedVelocity()
public void set_estimatedVelocity(Vector3 value)
public bool get_IsDormant()
public void set_IsDormant(bool value)
public void Resume()
public void Pause()
public BaseEntity get_MainTarget()
public void Tick()
private void InvokedTick()
private void TickMovement(float delta)
private bool _ValidateNextPosition(Vector3& moveToPosition)
public void ForceOrientationTick()
private void TickOrientation(float delta, float time)
private Transform Rust.Ai.HTN.IHTNAgent.get_transform()
}
public HTNAnimalClientEffectsSkinProxy : MonoBehaviour {
public HTNAnimal Body
}
public HTNPlayer : BasePlayer {
public HTNDomain _aiDomain
public BaseNpcDefinition _aiDefinition
public string deathStatName
public string LootPanelName
private bool <OnlyRotateAroundYAxis>k__BackingField
private bool isDormant
private float lastInvokedTickTime
private int serverMaxProjectileID
public bool IsNpc
public BaseEntity Body
public Vector3 BodyPosition
public Vector3 EyePosition
public Quaternion EyeRotation
protected float PositionTickRate
public FamilyEnum Family
public BaseNpcDefinition AiDefinition
public bool OnlyRotateAroundYAxis
public HTNDomain AiDomain
public bool IsDormant
public BaseEntity MainTarget
public bool get_IsNpc()
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public float MaxVelocity()
public BaseEntity get_Body()
public Vector3 get_BodyPosition()
public Vector3 get_EyePosition()
public Quaternion get_EyeRotation()
public Quaternion GetNetworkRotation()
protected float get_PositionTickRate()
public FamilyEnum get_Family()
public string Categorize()
public bool ShouldDropActiveItem()
public void ServerInit()
public void ResetState()
internal void DoServerDestroy()
public void Hurt(HitInfo info)
public bool EligibleForWounding(HitInfo info)
public void OnKilled(HitInfo info)
private void AddKilledStat(HitInfo info)
public BaseCorpse CreateCorpse()
public void OnSensation(Sensation sensation)
public Vector3 GetLocalVelocityServer()
public BaseNpcDefinition get_AiDefinition()
public bool get_OnlyRotateAroundYAxis()
public void set_OnlyRotateAroundYAxis(bool value)
public HTNDomain get_AiDomain()
public bool get_IsDormant()
public void set_IsDormant(bool value)
public void Resume()
public void Pause()
public BaseEntity get_MainTarget()
public void Tick()
private void InvokedTick()
private void TickMovement(float delta)
private bool _ValidateNextPosition(Vector3& moveToPosition)
public void ForceOrientationTick()
private void TickOrientation(float delta, float time)
public int NewServerProjectileID()
private Transform Rust.Ai.HTN.IHTNAgent.get_transform()
}
public HTNPlayerLoadBalancer : LoadBalancer {
public ILoadBalancer HTNPlayerBalancer
}
public HTNPlayerSpawnGroup : SpawnGroup {
public MovementRule Movement
public float MovementRadius
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
}
public HudElement : MonoBehaviour {
public Text[] ValueText
public Image[] FilledImage
private float lastValue
private float lastMax
public void SetValue(float value, float max)
private void SetText(string v)
private void SetImage(float f)
}
public HumanBodyResourceDispenser : ResourceDispenser {
public bool OverrideOwnership(Item item, AttackEntity weapon)
public string CreateSkullName(string playerName)
}
public HumanBrain : BaseAIBrain`1<HumanNPC> {
public int HumanState_Idle
public int HumanState_Flee
public int HumanState_Cover
public int HumanState_Patrol
public int HumanState_Roam
public int HumanState_Chase
public int HumanState_Exfil
public int HumanState_Mounted
public int HumanState_Combat
public int HumanState_Traverse
public int HumanState_Alert
public int HumanState_Investigate
public int HumanState_Guard
private float thinkRate
private float lastThinkTime
public void InitializeAI()
public bool ShouldThink()
public void DoThink()
}
public HumanNPC : NPCPlayer {
public LootSpawnSlot[] LootSpawnSlots
public SpeedType desiredSpeed
public float sightRange
public float sightRangeLarge
public float visionCone
public float aimConeScale
public List`1<BaseCombatEntity> _targets
public BaseCombatEntity currentTarget
public HumanBrain _brain
public float lastDismountTime
public bool lightsOn
private bool navmeshEnabled
private Vector3 spawnPos
private float TargetUpdateRate
private float TickItemRate
public float nextZoneSearchTime
public AIInformationZone cachedInfoZone
public bool currentTargetLOS
public BaseEntity[] QueryResults
public SimpleAIMemory myMemory
public float memoryDuration
public bool pendingDucked
public float timeSinceItemTick
public float timeSinceTargetUpdate
public float targetAimedDuration
private float lastAimSetTime
public Vector3 aimOverridePosition
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public bool IsNavRunning()
public bool IsLoadBalanced()
public float GetMaxRoamDistFromSpawn()
public void ServerInit()
internal void DoServerDestroy()
public void LightCheck()
public float GetAimConeScale()
public void EquipWeapon()
public void DismountObject()
public bool RecentlyDismounted()
public AITraversalArea GetTraversalArea()
public bool IsInTraversalArea()
public float GetIdealDistanceFromTarget()
public void SetDesiredSpeed(SpeedType newSpeed)
public float SpeedFromEnum(SpeedType newSpeed)
public List`1<BaseCombatEntity> GetTargets()
public AIInformationZone GetInformationZone(Vector3 pos)
public Vector3 GetRandomPositionAround(Vector3 position, float minDistFrom, float maxDistFrom)
public Vector3 GetIdealPositionNear(Vector3 position, float maxDistFrom)
public bool HasAnyTargets()
public bool HasTarget()
public float EngagementRange()
public bool TargetInRange()
public bool CanSeeTarget()
public void UpdateMemory()
public bool WithinVisionCone(BaseEntity other)
private bool AiCaresAbout(BaseEntity ent)
public float DistanceToTarget()
public void UpdateTargets(float delta)
public void SetDucked(bool wantsDucked)
public void ApplyPendingDucked()
public void TryThink()
public void ServerThink(float delta)
public void TickItems(float delta)
public void SetNavMeshEnabled(bool on)
public void EnableNavAgent()
public void LogAttacker(BaseEntity attacker)
public void KeepFresh(BaseEntity ent)
public void Hurt(HitInfo info)
public void Stop()
public void SetDestination(Vector3 newDestination)
public float DesiredMoveSpeed()
public Vector3 AimOffset(BaseCombatEntity aimat)
public AIMovePoint GetBestRoamPosition(Vector3 start)
public float GetAimSwayScalar()
public void SetAimDirection(Vector3 newAim)
public void SetStationaryAimPoint(Vector3 aimAt)
public void ClearStationaryAimPoint()
public Vector3 GetAimDirection()
public bool IsVisibleMounted(BasePlayer player)
public bool IsVisibleCrouched(BasePlayer player)
public bool IsVisibleToUs(BasePlayer player)
public bool IsVisibleStanding(BasePlayer player)
public bool ShouldDropActiveItem()
public BaseCorpse CreateCorpse()
protected string OverrideCorpseName()
public void AttackerInfo(DeathInfo info)
public bool IsOnGround()
}
public HurtOverlay : ImageEffectLayer {
public ScreenOverlayEx bloodOverlay
public VignetteAndChromaticAberration vignetting
public CC_Grayscale grayScale
}
public IAIAgent {
public AiStatistics GetStats
public NavMeshAgent GetNavAgent
public bool AgencyUpdateRequired
public bool IsOnOffmeshLinkAndReachedNewCoord
public Vector3 Destination
public bool IsStopped
public bool AutoBraking
public bool HasPath
public bool IsDormant
public float TimeAtDestination
public bool IsStuck
public float TargetSpeed
public BaseEntity FoodTarget
public float GetAttackRate
public float GetAttackRange
public Vector3 GetAttackOffset
public BaseEntity AttackTarget
public float AttackTargetVisibleFor
public SeenInfo AttackTargetMemory
public BaseCombatEntity CombatTarget
public Vector3 AttackPosition
public Vector3 CrouchedAttackPosition
public Vector3 CurrentAimAngles
public Vector3 SpawnPosition
public BaseCombatEntity Entity
public float GetAttackCost
public float GetStamina
public float GetEnergy
public float GetSleep
public float GetStuckDuration
public float GetLastStuckTime
public float currentBehaviorDuration
public Behaviour CurrentBehaviour
public int AgentTypeIndex
public AiStatistics get_GetStats()
public NavMeshAgent get_GetNavAgent()
public IAIContext GetContext(Guid aiId)
public bool get_AgencyUpdateRequired()
public void set_AgencyUpdateRequired(bool value)
public bool get_IsOnOffmeshLinkAndReachedNewCoord()
public void set_IsOnOffmeshLinkAndReachedNewCoord(bool value)
public Vector3 get_Destination()
public void set_Destination(Vector3 value)
public bool get_IsStopped()
public void set_IsStopped(bool value)
public bool get_AutoBraking()
public void set_AutoBraking(bool value)
public bool get_HasPath()
public bool IsNavRunning()
public void Pause()
public void Resume()
public bool get_IsDormant()
public void set_IsDormant(bool value)
public void SetTargetPathStatus(float pendingDelay)
public void UpdateDestination(Vector3 newDestination)
public void UpdateDestination(Transform tx)
public void StopMoving()
public float get_TimeAtDestination()
public bool get_IsStuck()
public float get_TargetSpeed()
public void set_TargetSpeed(float value)
public bool WantsToEat(BaseEntity eatable)
public BaseEntity get_FoodTarget()
public void set_FoodTarget(BaseEntity value)
public void Eat()
public float get_GetAttackRate()
public float get_GetAttackRange()
public Vector3 get_GetAttackOffset()
public void StartAttack()
public void StartAttack(AttackType type, BaseCombatEntity target)
public bool AttackReady()
public BaseEntity get_AttackTarget()
public void set_AttackTarget(BaseEntity value)
public float get_AttackTargetVisibleFor()
public SeenInfo get_AttackTargetMemory()
public void set_AttackTargetMemory(SeenInfo value)
public BaseCombatEntity get_CombatTarget()
public Vector3 get_AttackPosition()
public Vector3 get_CrouchedAttackPosition()
public Vector3 get_CurrentAimAngles()
public float GetWantsToAttack(BaseEntity target)
public float FearLevel(BaseEntity ent)
public Vector3 get_SpawnPosition()
public void set_SpawnPosition(Vector3 value)
public float GetActiveAggressionRangeSqr()
public BaseCombatEntity get_Entity()
public float get_GetAttackCost()
public float get_GetStamina()
public float get_GetEnergy()
public float get_GetSleep()
public bool BusyTimerActive()
public void SetBusyFor(float dur)
public float get_GetStuckDuration()
public float get_GetLastStuckTime()
public float get_currentBehaviorDuration()
public Behaviour get_CurrentBehaviour()
public void set_CurrentBehaviour(Behaviour value)
public int get_AgentTypeIndex()
public void set_AgentTypeIndex(int value)
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public float ToSpeed(SpeedEnum speed)
public List`1<NavPointSample> RequestNavPointSamplesInCircle(SampleCount sampleCount, float radius, SampleFeatures features)
public List`1<NavPointSample> RequestNavPointSamplesInCircleWaterDepthOnly(SampleCount sampleCount, float radius, float waterDepth)
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public float ToSpeed(SpeedEnum speed)
public int TopologyPreference()
}
public IceFence : GraveyardFence {
public GameObject[] styles
private bool init
public AdaptMeshToTerrain snowMesh
public int GetStyleFromID()
public void ServerInit()
public void InitStyle()
public void SetStyle(int style)
public void UpdatePillars()
}
public IconSkin : MonoBehaviour {
public Image icon
public Text text
}
public IconSkinPicker : MonoBehaviour {
public GameObjectRef pickerIcon
public GameObject container
public Action skinChangedEvent
public ScrollRect scroller
}
public IConversationProvider {
public bool ProviderBusy()
}
public IdentifierConfig : UIDialog {
private IRemoteControllable rc
public InputField input
public string id
}
public IEngineControllerUser {
public bool HasFlag(Flags f)
public bool IsDead()
public void SetFlag(Flags f, bool b, bool recursive, bool networkupdate)
public bool CanRunEngines()
public void Invoke(Action action, float time)
public void CancelInvoke(Action action)
public void OnEngineStartFailed()
}
public IFlagNotify {
public void OnFlagToggled(bool state)
}
public Igniter : IOEntity {
public float IgniteRange
public float IgniteFrequency
public float IgniteStartDelay
public Transform LineOfSightEyes
public float SelfDamagePerIgnite
public int PowerConsumption
public int ConsumptionAmount()
public void UpdateHasPower(int inputAmount, int inputSlot)
private void IgniteInRange()
}
public IgnoreCollision : MonoBehaviour {
public Collider collider
protected void OnTriggerEnter(Collider other)
}
public IIgniteable {
public void Ignite()
public bool CanIgnite()
}
public IInstanceDataReceiver {
public void ReceiveInstanceData(InstanceData data)
}
public IItemContainerEntity {
public ItemContainer inventory
public ItemContainer get_inventory()
public void DropItems(BaseEntity initiator)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
}
public IItemSetup {
public void OnItemSetup(Item item)
}
public IItemUpdate {
public void OnItemUpdate(Item item)
}
public ILerpTarget {
public float GetExtrapolationTime()
public float GetInterpolationDelay()
public float GetInterpolationSmoothing()
public float GetInterpolationInertia()
public Vector3 GetNetworkPosition()
public Quaternion GetNetworkRotation()
public void SetNetworkPosition(Vector3 pos)
public void SetNetworkRotation(Quaternion rot)
public void DrawInterpolationState(Segment segment, List`1<Entry> entries)
public void LerpIdleDisable()
}
public ImagePainter : MonoBehaviour {
public OnDrawingEvent onDrawing
public MonoBehaviour redirectRightClick
public float spacingScale
internal Brush brush
internal PointerState[] pointerState
public RectTransform rectTransform
public RectTransform get_rectTransform()
public void OnPointerDown(PointerEventData eventData)
public void OnPointerUp(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
public void OnBeginDrag(PointerEventData eventData)
public void OnEndDrag(PointerEventData eventData)
public void OnInitializePotentialDrag(PointerEventData eventData)
private void DrawAt(Vector2 position, InputButton button)
private void Start()
public void UpdateBrush(Brush brush)
}
public ImageProcessing : object {
private Byte[] signaturePNG
private Byte[] signatureIHDR
public void GaussianBlur2D(Single[] data, int len1, int len2, int iterations)
public void GaussianBlur2D(Single[] data, int len1, int len2, int len3, int iterations)
public void Average2D(Single[] data, int len1, int len2, int iterations)
public void Average2D(Single[] data, int len1, int len2, int len3, int iterations)
public void Upsample2D(Single[] src, int srclen1, int srclen2, Single[] dst, int dstlen1, int dstlen2)
public void Upsample2D(Single[] src, int srclen1, int srclen2, int srclen3, Single[] dst, int dstlen1, int dstlen2, int dstlen3)
public void Dilate2D(Int32[] src, int len1, int len2, int srcmask, int radius, Action`2<int, int> action)
public void FloodFill2D(int x, int y, Int32[] data, int len1, int len2, int mask_any, int mask_not, Func`2<int, int> action)
public bool IsValidPNG(Byte[] data, int maxWidth, int maxHeight)
public bool IsValidJPG(Byte[] data, int maxWidth, int maxHeight)
}
public IMagnetLiftable : MonoBehaviour {
private void Start()
private void Update()
}
public Impostor : MonoBehaviour {
public ImpostorAsset asset
public GameObject reference
public float angle
public int resolution
public int padding
public bool spriteOutlineAsMesh
private void OnEnable()
}
public ImpostorAsset : ScriptableObject {
public TextureEntry[] textures
public Vector2 size
public Vector2 pivot
public Mesh mesh
public Texture2D FindTexture(string name)
}
public ImpostorBatch : object {
private Mesh <Mesh>k__BackingField
private Material <Material>k__BackingField
private ComputeBuffer <PositionBuffer>k__BackingField
public NativeList`1<Vector4> Positions
private ComputeBuffer <ArgsBuffer>k__BackingField
private NativeList`1<UInt32> args
private Queue`1<int> recycle
public Mesh Mesh
public Material Material
public ComputeBuffer PositionBuffer
public ComputeBuffer ArgsBuffer
public int Count
public bool Visible
private void set_Mesh(Mesh value)
public Mesh get_Mesh()
private void set_Material(Material value)
public Material get_Material()
private void set_PositionBuffer(ComputeBuffer value)
public ComputeBuffer get_PositionBuffer()
private void set_ArgsBuffer(ComputeBuffer value)
public ComputeBuffer get_ArgsBuffer()
public int get_Count()
public bool get_Visible()
private ComputeBuffer SafeRelease(ComputeBuffer buffer)
public void Initialize(Mesh mesh, Material material)
public void Release()
public void AddInstance(ImpostorInstanceData data)
public void RemoveInstance(ImpostorInstanceData data)
public void UpdateBuffers()
}
public ImpostorInstanceData : object {
private Renderer <Renderer>k__BackingField
private Mesh <Mesh>k__BackingField
private Material <Material>k__BackingField
public ImpostorBatch Batch
public int BatchIndex
private int hash
private Vector4 positionAndScale
public Renderer Renderer
public Mesh Mesh
public Material Material
private void set_Renderer(Renderer value)
public Renderer get_Renderer()
private void set_Mesh(Mesh value)
public Mesh get_Mesh()
private void set_Material(Material value)
public Material get_Material()
public void .ctor(Renderer renderer, Mesh mesh, Material material)
public void .ctor(Vector3 position, Vector3 scale, Mesh mesh, Material material)
private int GenerateHashCode()
public bool Equals(object obj)
public int GetHashCode()
public Vector4 PositionAndScale()
public void Update()
}
public ImpostorRenderer : MonoBehaviour {
public string MainPassName
}
public IndependentScale : MonoBehaviour {
public Transform scaleParent
public Vector3 initialScale
}
public IndividualSpawner : BaseMonoBehaviour {
public GameObjectRef entityPrefab
public float respawnDelayMin
public float respawnDelayMax
public bool useCustomBoundsCheckMask
public LayerMask customBoundsCheckMask
private SpawnPointInstance spawnInstance
private float nextSpawnTime
public int currentPopulation
private bool IsSpawned
public int get_currentPopulation()
private bool get_IsSpawned()
protected void Awake()
protected void OnDrawGizmosSelected()
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
public void Fill()
public void SpawnInitial()
public void Clear()
public void SpawnRepeating()
public bool HasSpaceToSpawn()
private void TrySpawnEntity()
private bool TryGetEntityBounds(Bounds& result)
}
public InfrastructureType : Enum {
public int value__
public InfrastructureType Road
public InfrastructureType Power
public InfrastructureType Trail
public InfrastructureType Tunnel
}
public IngameMenuBackground : MonoBehaviour {
public bool Enabled
public CanvasGroup canvasGroup
}
public INotifyTrigger {
public void OnObjects(TriggerNotify trigger)
public void OnEmpty()
}
public InputState : object {
public InputMessage current
public InputMessage previous
private int SwallowedButtons
public bool IsDown(BUTTON btn)
public bool WasDown(BUTTON btn)
public bool WasJustPressed(BUTTON btn)
public bool WasJustReleased(BUTTON btn)
public void SwallowButton(BUTTON btn)
public Quaternion AimAngle()
public Vector3 MouseDelta()
public void Flip(InputMessage newcurrent)
public void Clear()
}
public InspectorNameAttribute : PropertyAttribute {
public string name
public void .ctor(string name)
}
public InstantCameraTool : HeldEntity {
public ItemDefinition photoItem
public GameObjectRef screenshotEffect
public SoundDefinition startPhotoSoundDef
public SoundDefinition finishPhotoSoundDef
public int resolutionX
public int resolutionY
public int quality
public float cooldownSeconds
private TimeSince _sinceLastPhoto
private bool hasSentAchievement
public string PhotographPlayerAchievement
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void TakePhoto(RPCMessage msg)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy)
}
public InstrumentDebugInput : MonoBehaviour {
public InstrumentKeyController KeyController
public KeySet Note
public float Frequency
public float StopAfter
public SoundDefinition OverrideDefinition
}
public InstrumentIKController : MonoBehaviour {
public Vector3 HitRotationVector
public Transform[] LeftHandIkTargets
public Transform[] LeftHandIKTargetHitRotations
public Transform[] RightHandIkTargets
public Transform[] RightHandIKTargetHitRotations
public Transform[] RightFootIkTargets
public AnimationCurve HandHeightCurve
public float HandHeightMultiplier
public float HandMoveLerpSpeed
public bool DebugHitRotation
public AnimationCurve HandHitCurve
public float NoteHitTime
public float BodyLookWeight
public float HeadLookWeight
public float LookWeightLimit
public bool HoldHandsAtPlay
}
public InstrumentKeyController : MonoBehaviour {
public float DEFAULT_NOTE_VELOCITY
public NoteBindingCollection Bindings
public NoteBinding[] NoteBindings
public Transform[] NoteSoundPositions
public InstrumentIKController IKController
public Transform LeftHandProp
public Transform RightHandProp
public Animator InstrumentAnimator
public BaseEntity RPCHandler
public UInt32 overrideAchievementId
private bool <PlayedNoteThisFrame>k__BackingField
private string ALL_NOTES_STATNAME
public bool PlayedNoteThisFrame
public bool get_PlayedNoteThisFrame()
private void set_PlayedNoteThisFrame(bool value)
public void ProcessServerPlayedNote(BasePlayer forPlayer)
}
public InstrumentTool : HeldEntity {
public InstrumentKeyController KeyController
public SoundDefinition DeploySound
public Vector2 PitchClamp
public bool UseAnimationSlotEvents
public Transform MuzzleT
public bool UsableByAutoTurrets
private NoteData lastPlayedTurretData
public bool IsUsableByTurret
public Transform MuzzleTransform
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void Server_PlayNote(RPCMessage msg)
private void Server_StopNote(RPCMessage msg)
public bool IsInstrument()
public void ServerUse()
private void StopAfterTime()
public bool get_IsUsableByTurret()
public Transform get_MuzzleTransform()
}
public InstrumentToolGuitar : InstrumentTool {
public Transform InUseAligner
public Transform DeployAligner
public string DeployBone
}
public InstrumentViewmodel : MonoBehaviour {
public Animator ViewAnimator
public bool UpdateA
public bool UpdateB
public bool UpdateC
public bool UpdateD
public bool UpdateE
public bool UpdateF
public bool UpdateG
public bool UpdateRecentlyPlayed
public bool UpdatePlayedNoteTrigger
public bool UseTriggers
private int note_a
private int note_b
private int note_c
private int note_d
private int note_e
private int note_f
private int note_g
private int recentlyPlayedHash
private int playedNoteHash
public void UpdateSlots(AnimationSlot currentSlot, bool recentlyPlayed, bool playedNoteThisFrame)
private void UpdateState(int param, bool state)
}
public InvisibleVendingMachine : NPCVendingMachine {
public GameObjectRef buyEffect
public NPCVendingOrderManifest vmoManifest
public NPCShopKeeper GetNPCShopKeeper()
public void KeeperLookAt(Vector3 pos)
public bool HasVendingSounds()
public float GetBuyDuration()
public void CompletePendingOrder()
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void Save(SaveInfo info)
public void ServerInit()
public void Load(LoadInfo info)
}
public IOEntity : BaseCombatEntity {
public Transform debugOrigin
public ItemDefinition sourceItem
public int lastResetIndex
public float framebudgetms
public float responsetime
public int backtracking
public Flags Flag_ShortCircuit
public Flags Flag_HasPower
public IOSlot[] inputs
public IOSlot[] outputs
public IOType ioType
public Queue`1<IOEntity> _processQueue
public int cachedOutputsUsed
public int lastPassthroughEnergy
public int lastEnergy
public int currentEnergy
public float lastUpdateTime
public int lastUpdateBlockedFrame
public bool ensureOutputsUpdated
public bool IsGravitySource
private bool HasBlockedUpdatedOutputsThisFrame
public bool BlockFluidDraining
protected float LiquidPassthroughGravityThreshold
protected bool DisregardGravityRestrictionsOnLiquid
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public string GetDisplayName()
public bool IsRootEntity()
public bool get_IsGravitySource()
public IOEntity FindGravitySource(Vector3& worldHandlePosition, int depth, bool ignoreSelf)
public void SetFuelType(ItemDefinition def, IOEntity source)
public bool WantsPower()
public bool WantsPassthroughPower()
public int ConsumptionAmount()
public int MaximalPowerOutput()
public bool AllowDrainFrom(int outputSlot)
public bool IsPowered()
public bool IsConnectedTo(IOEntity entity, int slot, int depth, bool defaultReturn)
public bool IsConnectedTo(IOEntity entity, int depth, bool defaultReturn)
protected bool ConsiderConnectedTo(IOEntity entity)
private void Server_RequestData(RPCMessage msg)
public void SendAdditionalData(BasePlayer player, int slot, bool input)
protected int GetPassthroughAmountForAnySlot(int slot, bool isInputSlot)
public void ProcessQueue()
public void ResetIOState()
public void Init()
internal void DoServerDestroy()
public void ClearConnections()
public void Shutdown()
public void MarkDirtyForceUpdateOutputs()
public void UpdateUsedOutputs()
public void MarkDirty()
public int DesiredPower()
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
public int GetCurrentEnergy()
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void TouchInternal()
public void UpdateFromInput(int inputAmount, int inputSlot)
public void TouchIOState()
public void SendIONetworkUpdate()
public void IOStateChanged(int inputAmount, int inputSlot)
public void OnCircuitChanged(bool forceUpdate)
public void SendChangedToRoot(bool forceUpdate)
public void SendChangedToRootRecursive(bool forceUpdate, List`1& existing)
public bool ShouldUpdateOutputs()
private bool get_HasBlockedUpdatedOutputsThisFrame()
public void UpdateOutputs()
public void Spawn()
public void PostServerLoad()
public void PostMapEntitySpawn()
public void Save(SaveInfo info)
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public bool get_BlockFluidDraining()
protected float get_LiquidPassthroughGravityThreshold()
protected bool get_DisregardGravityRestrictionsOnLiquid()
public bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement)
public void Load(LoadInfo info)
}
public IOEntityInformationPanel : ItemInformationPanel {
public ItemTextValue requiredPowerDisplay
public ItemTextValue requiredFluidDisplay
public ItemTextValue generatedPowerDisplay
public ItemTextValue capacityDisplay
public ItemTextValue chargeDisplay
}
public IOEntityMovementChecker : FacepunchBehaviour {
private IOEntity ioEntity
private Vector3 prevPos
private float MAX_MOVE
private float MAX_MOVE_SQR
protected void Awake()
protected void OnEnable()
protected void OnDisable()
private void CheckPosition()
}
public IOEntityUISlotEntry : MonoBehaviour {
public RawImage icon
public Text leftText
public Text rightText
}
public IOnParentDestroying {
public void OnParentDestroying()
}
public IOnParentSpawning {
public void OnParentSpawning()
}
public IOnPostNetworkUpdate {
public void OnPostNetworkUpdate(BaseEntity entity)
}
public IOnSendNetworkUpdate {
public void OnSendNetworkUpdate(BaseEntity entity)
}
public IRemoteControllable {
public bool RequiresMouse
public Transform GetEyes()
public BaseEntity GetEnt()
public bool Occupied()
public void UpdateIdentifier(string newID, bool clientSend)
public string GetIdentifier()
public void RCSetup()
public void RCShutdown()
public bool CanControl()
public bool get_RequiresMouse()
public void UserInput(InputState inputState, BasePlayer player)
public void InitializeControl(BasePlayer controller)
public void StopControl()
}
public IRFObject {
public Vector3 GetPosition()
public float GetMaxRange()
public void RFSignalUpdate(bool on)
public int GetFrequency()
}
public IronsightAimPoint : MonoBehaviour {
public Transform targetPoint
private void OnDrawGizmos()
private void DrawArrow(Vector3 start, Vector3 end, float arrowLength)
}
public IronSightOverride : MonoBehaviour {
public IronsightAimPoint aimPoint
public float fieldOfViewOffset
public float zoomFactor
public float fovBias
}
public IronSights : MonoBehaviour {
public bool Enabled
public IronsightAimPoint aimPoint
public float fieldOfViewOffset
public float zoomFactor
public float introSpeed
public AnimationCurve introCurve
public float outroSpeed
public AnimationCurve outroCurve
public SoundDefinition upSound
public SoundDefinition downSound
public IronSightOverride ironsightsOverride
public bool processUltrawideOffset
}
public ISignage {
public Vector2i TextureSize
public int TextureCount
public bool CanUpdateSign(BasePlayer player)
public float Distance(Vector3 position)
public Vector2i get_TextureSize()
public int get_TextureCount()
}
public ISoundBudgetedUpdate {
public void DoUpdate()
public bool IsSyncedToParent()
}
public ISpawnGroup {
public int currentPopulation
public void Clear()
public void Fill()
public void SpawnInitial()
public void SpawnRepeating()
public int get_currentPopulation()
}
public ISpawnPointUser {
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
}
public ISplashable {
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
}
public ISubscribable {
public bool AddSubscription(ulong steamId)
public bool RemoveSubscription(ulong steamId)
public bool HasSubscription(ulong steamId)
}
public Item : object {
public float _condition
public float _maxCondition
public ItemDefinition info
public UInt32 uid
public bool dirty
public int amount
public int position
public float busyTime
public float removeTime
public float fuel
public bool isServer
public InstanceData instanceData
public ulong skin
public string name
public string text
private Action`1<Item> OnDirty
public Flag flags
public ItemContainer contents
public ItemContainer parent
private EntityRef worldEnt
private EntityRef heldEntity
private Action`2<Item, float> onCycle
public float condition
public float maxCondition
public float maxConditionNormalized
public float conditionNormalized
public bool hasCondition
public bool isBroken
public int despawnMultiplier
public ItemDefinition blueprintTargetDef
public int blueprintTarget
public int blueprintAmount
public Item parentItem
public float temperature
public TraitFlag Traits
public void set_condition(float value)
public float get_condition()
public void set_maxCondition(float value)
public float get_maxCondition()
public float get_maxConditionNormalized()
public float get_conditionNormalized()
public void set_conditionNormalized(float value)
public bool get_hasCondition()
public bool get_isBroken()
public void LoseCondition(float amount)
public void RepairCondition(float amount)
public void DoRepair(float maxLossFraction)
public ItemContainer GetRootContainer()
public void OnBroken()
public int get_despawnMultiplier()
public ItemDefinition get_blueprintTargetDef()
public int get_blueprintTarget()
public void set_blueprintTarget(int value)
public int get_blueprintAmount()
public void set_blueprintAmount(int value)
public bool IsBlueprint()
public void add_OnDirty(Action`1<Item> value)
public void remove_OnDirty(Action`1<Item> value)
public bool HasFlag(Flag f)
public void SetFlag(Flag f, bool b)
public bool IsOn()
public bool IsOnFire()
public bool IsCooking()
public bool IsLocked()
public Item get_parentItem()
public void MarkDirty()
public void OnChanged()
public void CollectedForCrafting(BasePlayer crafter)
public void ReturnedFromCancelledCraft(BasePlayer crafter)
public void Initialize(ItemDefinition template)
public void OnItemCreated()
public void OnVirginSpawn()
public void RemoveFromWorld()
public void OnRemovedFromWorld()
public void RemoveFromContainer()
public void SetParent(ItemContainer target)
public void OnAttacked(HitInfo hitInfo)
public bool IsChildContainer(ItemContainer c)
public bool CanMoveTo(ItemContainer newcontainer, int iTargetPos, bool allowStack)
public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos, bool allowStack, bool ignoreStackLimit)
public BaseEntity CreateWorldObject(Vector3 pos, Quaternion rotation, BaseEntity parentEnt, UInt32 parentBone)
public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation)
public BaseEntity DropAndTossUpwards(Vector3 vPos, float force)
public bool IsBusy()
public void BusyFor(float fTime)
public void Remove(float fTime)
public void DoRemove()
public void SwitchOnOff(bool bNewState)
public void LockUnlock(bool bNewState)
public float get_temperature()
public BasePlayer GetOwnerPlayer()
public Item SplitItem(int split_Amount)
public bool CanBeHeld()
public bool CanStack(Item item)
public bool IsValid()
public void SetWorldEntity(BaseEntity ent)
public void OnMovedToWorld()
public BaseEntity GetWorldEntity()
public void SetHeldEntity(BaseEntity ent)
public BaseEntity GetHeldEntity()
public void add_onCycle(Action`2<Item, float> value)
public void remove_onCycle(Action`2<Item, float> value)
public void OnCycle(float delta)
public void ServerCommand(string command, BasePlayer player)
public void UseItem(int amountToConsume)
public bool HasAmmo(AmmoTypes ammoType)
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public string ToString()
public Item FindItem(UInt32 iUID)
public int MaxStackable()
public TraitFlag get_Traits()
public Item Save(bool bIncludeContainer, bool bIncludeOwners)
public void Load(Item load)
}
public ItemAmount : object {
public ItemDefinition itemDef
public float amount
public float startAmount
public int itemid
public void .ctor(ItemDefinition item, float amt)
public int get_itemid()
public float GetAmount()
public void OnAfterDeserialize()
public void OnBeforeSerialize()
}
public ItemAmountRandom : object {
public ItemDefinition itemDef
public AnimationCurve amount
public int RandomAmount()
}
public ItemAmountRanged : ItemAmount {
public float maxAmount
public void OnAfterDeserialize()
public void .ctor(ItemDefinition item, float amt, float max)
public float GetAmount()
}
public ItemBasedFlowRestrictor : IOEntity {
public ItemDefinition passthroughItem
public ContentsType allowedContents
public int maxStackSize
public int numSlots
public string lootPanelName
public Flags HasPassthrough
public Flags Sparks
public float passthroughItemConditionLossPerSec
private ItemContainer inventory
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public bool HasPassthroughItem()
public void TickPassthroughItem()
public void ServerInit()
public void PreServerLoad()
public void CreateInventory(bool giveUID)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool added)
private void RPC_OpenLoot(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
}
public ItemBlueprint : MonoBehaviour {
public List`1<ItemAmount> ingredients
public List`1<ItemDefinition> additionalUnlocks
public bool defaultBlueprint
public bool userCraftable
public bool isResearchable
public Rarity rarity
public int workbenchLevelRequired
public int scrapRequired
public int scrapFromRecycle
public bool NeedsSteamItem
public int blueprintStackSize
public float time
public int amountToCreate
public string UnlockAchievment
public string RecycleStat
public ItemDefinition targetItem
public bool NeedsSteamDLC
public ItemDefinition get_targetItem()
public bool get_NeedsSteamDLC()
}
public ItemButtonTools : MonoBehaviour {
public Image image
public ItemDefinition itemDef
public void GiveSelf(int amount)
public void GiveArmed()
public void GiveBlueprint()
}
public ItemCategory : Enum {
public int value__
public ItemCategory Weapon
public ItemCategory Construction
public ItemCategory Items
public ItemCategory Resources
public ItemCategory Attire
public ItemCategory Tool
public ItemCategory Medical
public ItemCategory Food
public ItemCategory Ammunition
public ItemCategory Traps
public ItemCategory Misc
public ItemCategory All
public ItemCategory Common
public ItemCategory Component
public ItemCategory Search
public ItemCategory Favourite
public ItemCategory Electrical
public ItemCategory Fun
}
public ItemContainer : object {
public Flag flags
public ContentsType allowedContents
public ItemDefinition onlyAllowedItem
public List`1<ItemSlot> availableSlots
public int capacity
public UInt32 uid
public bool dirty
public List`1<Item> itemList
public float temperature
public Item parent
public BasePlayer playerOwner
public BaseEntity entityOwner
public bool isServer
public int maxStackSize
private Action onDirty
public Func`3<Item, int, bool> canAcceptItem
public Func`3<Item, int, bool> slotIsReserved
public Action`2<Item, bool> onItemAddedRemoved
public Action`1<Item> onPreItemRemove
public Vector3 dropPosition
public Vector3 dropVelocity
public bool HasFlag(Flag f)
public void SetFlag(Flag f, bool b)
public bool IsLocked()
public bool PlayerItemInputBlocked()
public void add_onDirty(Action value)
public void remove_onDirty(Action value)
public void ServerInitialize(Item parentItem, int iMaxCapacity)
public void GiveUID()
public void MarkDirty()
public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot)
public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, ItemContainer[] containers)
public void OnChanged()
public Item FindItemByUID(UInt32 iUID)
public bool IsFull()
public bool IsEmpty()
public bool CanAccept(Item item)
public int GetMaxTransferAmount(ItemDefinition def)
public bool Insert(Item item)
public bool SlotTaken(Item item, int i)
public Item GetSlot(int slot)
public bool FindPosition(Item item)
public void SetLocked(bool isLocked)
public bool Remove(Item item)
public void Clear()
public void Kill()
public int GetAmount(int itemid, bool onlyUsableAmounts)
public Item FindItemByItemID(int itemid)
public Item FindItemsByItemName(string name)
public List`1<Item> FindItemsByItemID(int itemid)
public ItemContainer Save()
public void Load(ItemContainer container)
public BasePlayer GetOwnerPlayer()
public int Take(List`1<Item> collect, int itemid, int iAmount)
public Vector3 get_dropPosition()
public Vector3 get_dropVelocity()
public void OnCycle(float delta)
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public bool HasAmmo(AmmoTypes ammoType)
public void AddItem(ItemDefinition itemToCreate, int p, ulong skin)
public void OnMovedToWorld()
public void OnRemovedFromWorld()
public UInt32 ContentsHash()
public ItemContainer FindContainer(UInt32 id)
public CanAcceptResult CanAcceptItem(Item item, int targetPos)
}
public ItemContainerSource : MonoBehaviour {
public ItemContainer GetItemContainer()
}
public ItemCrafter : EntityComponent`1<BasePlayer> {
public List`1<ItemContainer> containers
public LinkedList`1<ItemCraftTask> queue
public int taskUID
public void AddContainer(ItemContainer container)
public float GetScaledDuration(ItemBlueprint bp, float workbenchLevel)
public void ServerUpdate(float delta)
private void CollectIngredient(int item, int amount, List`1<Item> collect)
private void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player)
public bool CraftItem(ItemBlueprint bp, BasePlayer owner, InstanceData instanceData, int amount, int skinID, Item fromTempBlueprint, bool free)
public void FinishCrafting(ItemCraftTask task)
public bool CancelTask(int iID, bool ReturnItems)
public bool CancelBlueprint(int itemid)
public void CancelAll(bool returnItems)
private bool DoesHaveUsableItem(int item, int iAmount)
public bool CanCraft(ItemBlueprint bp, int amount, bool free)
public bool CanCraft(ItemDefinition def, int amount, bool free)
public bool FastTrackTask(int taskID)
}
public ItemCraftTask : object {
public ItemBlueprint blueprint
public float endTime
public int taskUID
public BasePlayer owner
public bool cancelled
public InstanceData instanceData
public int amount
public int skinID
public List`1<ulong> potentialOwners
public List`1<Item> takenItems
public int numCrafted
public float conditionScale
public float workSecondsComplete
public float worksecondsRequired
}
public ItemDefinition : MonoBehaviour {
public int itemid
public string shortname
public Phrase displayName
public Phrase displayDescription
public Sprite iconSprite
public ItemCategory category
public ItemSelectionPanel selectionPanel
public int maxDraggable
public ContentsType itemType
public AmountType amountType
public ItemSlot occupySlots
public int stackable
public bool quickDespawn
public Rarity rarity
public bool spawnAsBlueprint
public SoundDefinition inventorySelectSound
public SoundDefinition inventoryGrabSound
public SoundDefinition inventoryDropSound
public SoundDefinition physImpactSoundDef
public Condition condition
public bool hidden
public Flag flags
public SteamInventoryItem steamItem
public SteamDLCItem steamDlc
public ItemDefinition Parent
public GameObjectRef worldModelPrefab
public ItemDefinition isRedirectOf
public RedirectVendingBehaviour redirectVendingBehaviour
public ItemMod[] itemMods
public TraitFlag Traits
public Skin[] skins
public IPlayerItemDefinition[] _skins2
public GameObject panel
private ItemModWearable <ItemModWearable>k__BackingField
private bool <isHoldable>k__BackingField
private bool <isUsable>k__BackingField
private bool <CraftableWithSkin>k__BackingField
public ItemDefinition[] Children
public IPlayerItemDefinition[] skins2
public ItemBlueprint Blueprint
public int craftingStackable
public bool isWearable
public ItemModWearable ItemModWearable
public bool isHoldable
public bool isUsable
public bool HasSkins
public bool CraftableWithSkin
public IPlayerItemDefinition[] get_skins2()
public void InvalidateWorkshopSkinCache()
public ulong FindSkin(int itemID, int skinID)
public ItemBlueprint get_Blueprint()
public int get_craftingStackable()
public bool HasFlag(Flag f)
public void Initialize(List`1<ItemDefinition> itemList)
public bool get_isWearable()
public ItemModWearable get_ItemModWearable()
private void set_ItemModWearable(ItemModWearable value)
public bool get_isHoldable()
private void set_isHoldable(bool value)
public bool get_isUsable()
private void set_isUsable(bool value)
public bool get_HasSkins()
public bool get_CraftableWithSkin()
private void set_CraftableWithSkin(bool value)
private bool <Initialize>b__46_0(ItemDefinition x)
}
public ItemDropCommand : MonoBehaviour {
public string command
}
public ItemEventFlag : MonoBehaviour {
public Flag flag
public UnityEvent onEnabled
public UnityEvent onDisable
internal bool firstRun
internal bool lastState
public void OnItemUpdate(Item item)
}
public ItemFootstepSounds : MonoBehaviour {
public string effectFolder
}
public ItemIcon : BaseMonoBehaviour {
public Color defaultBackgroundColor
public Color selectedBackgroundColor
public ItemContainerSource containerSource
public int slotOffset
public int slot
public bool setSlotFromSiblingIndex
public GameObject slots
public CanvasGroup iconContents
public Image iconImage
public Image underlayImage
public Text amountText
public Text hoverText
public Image hoverOutline
public Image cornerIcon
public Image lockedImage
public Image progressImage
public Image backgroundImage
public Image backgroundUnderlayImage
public Sprite emptySlotBackgroundSprite
public CanvasGroup conditionObject
public Image conditionFill
public Image maxConditionFill
public bool allowSelection
public bool allowDropping
public bool allowMove
public Item item
public bool invalidSlot
public SoundDefinition hoverSound
public void OnPointerClick(PointerEventData eventData)
public void OnPointerEnter(PointerEventData eventData)
public void OnPointerExit(PointerEventData eventData)
}
public ItemInformationPanel : MonoBehaviour {
public bool EligableForDisplay(ItemDefinition info)
public void SetupForItem(ItemDefinition info, Item item)
}
public ItemListTools : MonoBehaviour {
public GameObject categoryButton
public GameObject itemButton
public RustInput searchInputText
internal Button lastCategory
private IOrderedEnumerable`1<ItemDefinition> currentItems
private IOrderedEnumerable`1<ItemDefinition> allItems
public void OnPanelOpened()
private void CacheAllItems()
public void Refresh()
private void RebuildCategories()
private void SwitchItemCategory(ItemDefinition[] defs)
public void FilterItems(string searchText)
}
public ItemManager : object {
public List`1<ItemDefinition> itemList
public Dictionary`2<int, ItemDefinition> itemDictionary
public Dictionary`2<string, ItemDefinition> itemDictionaryByName
public List`1<ItemBlueprint> bpList
public Int32[] defaultBlueprints
private List`1<ItemRemove> ItemRemoves
public void InvalidateWorkshopSkinCache()
public void Initialize()
public Item CreateByName(string strName, int iAmount, ulong skin)
public Item CreateByPartialName(string strName, int iAmount, ulong skin)
public Item CreateByItemID(int itemID, int iAmount, ulong skin)
public Item Create(ItemDefinition template, int iAmount, ulong skin)
private void TrySkinChangeItem(ItemDefinition& template, UInt64& skinId)
public Item Load(Item load, Item created, bool isServer)
public ItemDefinition FindItemDefinition(int itemID)
public ItemDefinition FindItemDefinition(string shortName)
public ItemBlueprint FindBlueprint(ItemDefinition item)
public List`1<ItemDefinition> GetItemDefinitions()
public List`1<ItemBlueprint> GetBlueprints()
public void DoRemoves()
public void Heartbeat()
public void RemoveItem(Item item, float fTime)
}
public ItemMod : MonoBehaviour {
private ItemMod[] siblingMods
public void ModInit()
public void OnItemCreated(Item item)
public void OnVirginItem(Item item)
public void ServerCommand(Item item, string command, BasePlayer player)
public void DoAction(Item item, BasePlayer player)
public void OnRemove(Item item)
public void OnParentChanged(Item item)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
public void OnAttacked(Item item, HitInfo info)
public void OnChanged(Item item)
public bool CanDoAction(Item item, BasePlayer player)
public bool Passes(Item item)
public void OnRemovedFromWorld(Item item)
public void OnMovedToWorld(Item item)
}
public ItemModActionChange : ItemMod {
public ItemMod[] actions
public void OnChanged(Item item)
private void OnValidate()
}
public ItemModActionContainerChange : ItemMod {
public ItemMod[] actions
public void OnParentChanged(Item item)
private void OnValidate()
}
public ItemModAlterCondition : ItemMod {
public float conditionChange
public void DoAction(Item item, BasePlayer player)
}
public ItemModAnimalEquipment : ItemMod {
public Flags WearableFlag
public bool hideHair
public ProtectionProperties animalProtection
public ProtectionProperties riderProtection
public int additionalInventorySlots
public float speedModifier
public float staminaUseModifier
public SlotType slot
}
public ItemModAssociatedEntity`1 : ItemMod {
public GameObjectRef entityPrefab
protected bool AllowNullParenting
protected bool AllowHeldEntityParenting
protected bool get_AllowNullParenting()
protected bool get_AllowHeldEntityParenting()
public void OnItemCreated(Item item)
public void OnRemove(Item item)
public void OnMovedToWorld(Item item)
public void OnRemovedFromWorld(Item item)
public void UpdateParent(Item item)
public void OnParentChanged(Item item)
public BaseEntity GetEntityForParenting(Item item)
public T GetAssociatedEntity(Item item, bool isServer)
}
public ItemModBlueprintCraft : ItemMod {
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModBurnable : ItemMod {
public float fuelAmount
public ItemDefinition byproductItem
public int byproductAmount
public float byproductChance
public void OnItemCreated(Item item)
}
public ItemModCompostable : MonoBehaviour {
public float TotalFertilizerProduced
}
public ItemModConditionContainerFlag : ItemMod {
public Flag flag
public bool requiredState
public bool Passes(Item item)
}
public ItemModConditionHasCondition : ItemMod {
public float conditionTarget
public float conditionFractionTarget
public bool lessThan
public bool Passes(Item item)
}
public ItemModConditionHasContents : ItemMod {
public ItemDefinition itemDef
public bool requiredState
public bool Passes(Item item)
private bool <Passes>b__2_0(Item x)
}
public ItemModConditionHasFlag : ItemMod {
public Flag flag
public bool requiredState
public bool Passes(Item item)
}
public ItemModConditionInWater : ItemMod {
public bool requiredState
public bool Passes(Item item)
}
public ItemModConditionIsSleeping : ItemMod {
public bool requiredState
public bool Passes(Item item)
}
public ItemModConsumable : MonoBehaviour {
public int amountToConsume
public float conditionFractionToLose
public string achievementWhenEaten
public List`1<ConsumableEffect> effects
public List`1<ModifierDefintion> modifiers
public float GetIfType(Type typeToPick)
}
public ItemModConsume : ItemMod {
public GameObjectRef consumeEffect
public string eatGesture
public ItemAmountRandom[] product
public ItemModConsumable primaryConsumable
public ItemModConsumable GetConsumable()
public GameObjectRef GetConsumeEffect()
public void DoAction(Item item, BasePlayer player)
public bool CanDoAction(Item item, BasePlayer player)
}
public ItemModConsumeChance : ItemModConsume {
public float chanceForSecondaryConsume
public GameObjectRef secondaryConsumeEffect
public ItemModConsumable secondaryConsumable
private bool GetChance()
public ItemModConsumable GetConsumable()
public GameObjectRef GetConsumeEffect()
}
public ItemModConsumeContents : ItemMod {
public GameObjectRef consumeEffect
public void DoAction(Item item, BasePlayer player)
public bool CanDoAction(Item item, BasePlayer player)
}
public ItemModContainer : ItemMod {
public int capacity
public int maxStackSize
public Flag containerFlags
public ContentsType onlyAllowedContents
public ItemDefinition onlyAllowedItemType
public List`1<ItemSlot> availableSlots
public ItemDefinition[] validItemWhitelist
public bool openInDeployed
public bool openInInventory
public List`1<ItemAmount> defaultContents
public void OnItemCreated(Item item)
private bool CanAcceptItem(Item item, int count)
public void OnVirginItem(Item item)
public void CollectedForCrafting(Item item, BasePlayer crafter)
}
public ItemModContainerRestriction : ItemMod {
public SlotFlags slotFlags
public bool CanExistWith(ItemModContainerRestriction other)
}
public ItemModCookable : ItemMod {
public ItemDefinition becomeOnCooked
public float cookTime
public int amountOfBecome
public int lowTemp
public int highTemp
public bool setCookingFlag
public void OnValidate()
public void OnItemCreated(Item itemcreated)
}
public ItemModCycle : ItemMod {
public ItemMod[] actions
public float timeBetweenCycles
public float timerStart
public bool onlyAdvanceTimerWhenPass
public void OnItemCreated(Item itemcreated)
private bool CanCycle(Item item)
public void CustomCycle(Item item, float delta)
private void OnValidate()
}
public ItemModDeployable : MonoBehaviour {
public GameObjectRef entityPrefab
public bool showCrosshair
public string UnlockAchievement
public Deployable GetDeployable(BaseEntity entity)
internal void OnDeployed(BaseEntity ent, BasePlayer player)
}
public ItemModEntity : ItemMod {
public GameObjectRef entityPrefab
public string defaultBone
public void OnItemCreated(Item item)
public void OnRemove(Item item)
private bool ParentToParent(Item item, BaseEntity ourEntity)
private bool ParentToPlayer(Item item, BaseEntity ourEntity)
public void OnParentChanged(Item item)
public void CollectedForCrafting(Item item, BasePlayer crafter)
public void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
}
public ItemModGiveOxygen : ItemMod {
public int amountToConsume
public GameObjectRef inhaleEffect
public GameObjectRef exhaleEffect
public GameObjectRef bubblesEffect
private bool inhaled
public void DoAction(Item item, BasePlayer player)
}
public ItemModKeycard : ItemMod {
public int accessLevel
}
public ItemModMenuOption : ItemMod {
public string commandName
public ItemMod actionTarget
public Option option
public bool isPrimaryOption
public void ServerCommand(Item item, string command, BasePlayer player)
private void OnValidate()
}
public ItemModOpenWrapped : ItemMod {
public GameObjectRef successEffect
public Phrase open_wrapped_gift
public Phrase open_wrapped_gift_desc
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModPhoto : ItemModAssociatedEntity`1<PhotoEntity> {
protected bool AllowNullParenting
protected bool get_AllowNullParenting()
}
public ItemModProjectile : MonoBehaviour {
public GameObjectRef projectileObject
public ItemModProjectileMod[] mods
public AmmoTypes ammoType
public int numProjectiles
public float projectileSpread
public float projectileVelocity
public float projectileVelocitySpread
public bool useCurve
public AnimationCurve spreadScalar
public GameObjectRef attackEffectOverride
public float barrelConditionLoss
public string category
public float GetRandomVelocity()
public float GetSpreadScalar()
public float GetIndexedSpreadScalar(int shotIndex, int maxShots)
public float GetAverageVelocity()
public float GetMinVelocity()
public float GetMaxVelocity()
public bool IsAmmo(AmmoTypes ammo)
public void ServerProjectileHit(HitInfo info)
}
public ItemModProjectileMod : MonoBehaviour {
public void ServerProjectileHit(HitInfo info)
}
public ItemModProjectileRadialDamage : ItemModProjectileMod {
public float radius
public DamageTypeEntry damage
public GameObjectRef effect
public bool ignoreHitObject
public void ServerProjectileHit(HitInfo info)
}
public ItemModProjectileSpawn : ItemModProjectile {
public float createOnImpactChance
public GameObjectRef createOnImpact
public float spreadAngle
public float spreadVelocityMin
public float spreadVelocityMax
public int numToCreateChances
public void ServerProjectileHit(HitInfo info)
}
public ItemModRecycleInto : ItemMod {
public ItemDefinition recycleIntoItem
public int numRecycledItemMin
public int numRecycledItemMax
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModRepair : ItemMod {
public float conditionLost
public GameObjectRef successEffect
public int workbenchLvlRequired
public bool HasCraftLevel(BasePlayer player)
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModReveal : ItemMod {
public int numForReveal
public ItemDefinition revealedItemOverride
public int revealedItemAmount
public LootSpawn revealList
public GameObjectRef successEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModRFListener : ItemModAssociatedEntity`1<PagerEntity> {
public GameObjectRef frequencyPanelPrefab
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModSound : ItemMod {
public GameObjectRef effect
public Type actionType
public void OnParentChanged(Item item)
}
public ItemModStudyBlueprint : ItemMod {
public GameObjectRef studyEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModSummerSunglassesEquip : ItemMod {
public float SunsetTime
public float SunriseTime
public string AchivementName
public void DoAction(Item item, BasePlayer player)
}
public ItemModSwap : ItemMod {
public GameObjectRef actionEffect
public ItemAmount[] becomeItem
public bool sendPlayerPickupNotification
public bool sendPlayerDropNotification
public float xpScale
public void DoAction(Item item, BasePlayer player)
}
public ItemModSwitchFlag : ItemMod {
public Flag flag
public bool state
public void DoAction(Item item, BasePlayer player)
}
public ItemModUnwrap : ItemMod {
public LootSpawn revealList
public GameObjectRef successEffect
public int minTries
public int maxTries
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModUpgrade : ItemMod {
public int numForUpgrade
public float upgradeSuccessChance
public int numToLoseOnFail
public ItemDefinition upgradedItem
public int numUpgradedItem
public GameObjectRef successEffect
public GameObjectRef failEffect
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModUseContent : ItemMod {
public int amountToConsume
public void DoAction(Item item, BasePlayer player)
}
public ItemModWearable : ItemMod {
public GameObjectRef entityPrefab
public GameObjectRef entityPrefabFemale
public ProtectionProperties protectionProperties
public ArmorProperties armorProperties
public ClothingMovementProperties movementProperties
public blackoutType occlusionType
public bool blocksAiming
public bool emissive
public float accuracyBonus
public bool blocksEquipping
public float eggVision
public float weight
public GameObjectRef viewmodelAddition
public Wearable targetWearable
public Wearable get_targetWearable()
private void DoPrepare()
public void ModInit()
public bool ProtectsArea(HitArea area)
public bool HasProtections()
internal float GetProtection(Item item, DamageType damageType)
public float ConditionProtectionScale(Item item)
public void CollectProtection(Item item, ProtectionProperties protection)
private bool IsHeadgear()
public bool IsFootwear()
public void OnAttacked(Item item, HitInfo info)
public bool CanExistWith(ItemModWearable wearable)
}
public ItemModWrap : ItemMod {
public GameObjectRef successEffect
public ItemDefinition wrappedDefinition
public Phrase wrap_gift
public Phrase wrap_gift_desc
public void ServerCommand(Item item, string command, BasePlayer player)
}
public ItemModXMasTreeDecoration : ItemMod {
public xmasFlags flagsToChange
}
public ItemModXPWhenUsed : ItemMod {
public float xpPerUnit
public int unitSize
public void GiveConsumeXP(Item item)
}
public ItemOptionButton : MonoBehaviour {
public TextMeshProUGUI name
public Image icon
}
public ItemPickup : DroppedItem {
public ItemDefinition itemDef
public int amount
public ulong skinOverride
public float GetDespawnDuration()
public void Spawn()
internal void DoServerDestroy()
public void PostServerLoad()
}
public ItemPickupNotice : MonoBehaviour {
public TextMeshProUGUI Text
public TextMeshProUGUI Amount
}
public ItemPreviewIcon : BaseMonoBehaviour {
public ItemContainerSource containerSource
public int slot
public bool setSlotFromSiblingIndex
public CanvasGroup iconContents
public Image iconImage
public Text amountText
public Item item
}
public ItemSearchEntry : MonoBehaviour {
public Button button
public Text text
public RawImage image
public RawImage bpImage
private ItemDefinition itemInfo
private AddSellOrderManager manager
}
public ItemSelectionPanel : Enum {
public int value__
public ItemSelectionPanel None
public ItemSelectionPanel Vessel
public ItemSelectionPanel Modifications
public ItemSelectionPanel GunInformation
}
public ItemSelector : PropertyAttribute {
public ItemCategory category
public void .ctor(ItemCategory category)
}
public ItemSkin : SteamInventoryItem {
public Skinnable Skinnable
public Material[] Materials
public ItemDefinition Redirect
public SteamInventoryItem UnlockedViaSteamItem
public void ApplySkin(GameObject obj)
public bool HasUnlocked(ulong playerId)
}
public ItemSkinDirectory : ScriptableObject {
private ItemSkinDirectory _Instance
public Skin[] skins
public ItemSkinDirectory Instance
public ItemSkinDirectory get_Instance()
public Skin[] ForItem(ItemDefinition item)
public Skin FindByInventoryDefinitionId(int id)
}
public ItemSlot : Enum {
public int value__
public ItemSlot None
public ItemSlot Barrel
public ItemSlot Silencer
public ItemSlot Scope
public ItemSlot UnderBarrel
}
public ItemSplitter : MonoBehaviour {
public Slider slider
public TextMeshProUGUI textValue
public TextMeshProUGUI splitAmountText
public TMP_InputField amountInputField
}
public ItemSplitterDragOut : MonoBehaviour {
public ItemSplitter rootSplitter
}
public ItemStatValue : MonoBehaviour {
public Text text
public Slider slider
public bool selectedItem
public bool smallerIsBetter
public bool asPercentage
}
public ItemStore : SingletonComponent`1<ItemStore> {
public GameObject ItemPrefab
public RectTransform ItemParent
public List`1<IPlayerItemDefinition> Cart
public ItemStoreItemInfoModal ItemStoreInfoModal
public GameObject BuyingModal
public ItemStoreBuyFailedModal ItemStoreBuyFailedModal
public ItemStoreBuySuccessModal ItemStoreBuySuccessModal
public SoundDefinition AddToCartSound
public TextMeshProUGUI TotalValue
public int GetItemCount()
public void SetItemData(int i, GameObject obj)
}
public ItemStoreBuyFailedModal : MonoBehaviour {
public void Show(ulong orderid)
public void Hide()
private void <Hide>b__1_0()
}
public ItemStoreBuySuccessModal : MonoBehaviour {
public void Show(ulong orderId)
public void Hide()
private void <Hide>b__1_0()
}
public ItemStoreCartItem : MonoBehaviour {
public int Index
public TextMeshProUGUI Name
public TextMeshProUGUI Price
public void Init(int index, IPlayerItemDefinition def)
}
public ItemStoreItem : MonoBehaviour {
public HttpImage Icon
public TextMeshProUGUI Name
public TextMeshProUGUI Price
private IPlayerItemDefinition item
internal void Init(IPlayerItemDefinition item)
}
public ItemStoreItemInfoModal : MonoBehaviour {
public HttpImage Icon
public TextMeshProUGUI Name
public TextMeshProUGUI Price
public TextMeshProUGUI Description
private IPlayerItemDefinition item
public void Show(IPlayerItemDefinition item)
public void Hide()
private void <Hide>b__6_0()
}
public ItemTextValue : MonoBehaviour {
public Text text
public Color bad
public Color good
public bool negativestat
public bool asPercentage
public bool useColors
public bool signed
public string suffix
public float multiplier
public void SetValue(float val, int numDecimals, string overrideText)
}
public IThinker {
public void TryThink()
}
public ITrainCollidable {
public bool CustomCollision(BaseTrain train, TriggerTrainCollisions trainTrigger)
public bool EqualNetID(BaseNetworkable other)
}
public IVehicleLockUser {
public bool PlayerHasUnlockPermission(BasePlayer player)
public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)
public void RemoveLock()
}
public Jackhammer : BaseMelee {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasAmmo()
public void Server_SetEngineStatus(RPCMessage msg)
public void SetEngineStatus(bool on)
public void SetHeld(bool bHeld)
}
public JesseStiller.TerrainFormerExtension.TerrainFormer : MonoBehaviour {
private void Awake()
}
public JesseStiller.TerrainFormerExtension.TerrainSetNeighbours : MonoBehaviour {
private Terrain leftTerrain
private Terrain topTerrain
private Terrain rightTerrain
private Terrain bottomTerrain
private void Awake()
public void SetNeighbours(Terrain leftTerrain, Terrain topTerrain, Terrain rightTerrain, Terrain bottomTerrain)
}
public JiggleBone : BaseMonoBehaviour {
public bool debugMode
private Vector3 targetPos
private Vector3 dynamicPos
public Vector3 boneAxis
public float targetDistance
public float bStiffness
public float bMass
public float bDamping
public float bGravity
private Vector3 force
private Vector3 acc
private Vector3 vel
public bool SquashAndStretch
public float sideStretch
public float frontStretch
public float disableDistance
private void Awake()
private void LateUpdate()
}
public JunkPile : BaseEntity {
public GameObjectRef sinkEffect
public SpawnGroup[] spawngroups
public ScientistJunkpileSpawner npcSpawnGroup
private float lifetimeMinutes
private List`1<NPCPlayerApex> _npcs
private List`1<HTNPlayer> _htnPlayers
protected bool isSinking
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
private void SpawnInitial()
public bool SpawnGroupsEmpty()
public void CheckEmpty()
public bool PlayersNearby()
public float TimeoutPlayerCheckRadius()
public void TimeOut()
public void SinkAndDestroy()
public void KillMe()
public void AddNpc(NPCPlayerApex npc)
public void AddNpc(HTNPlayer npc)
}
public JunkPileWater : JunkPile {
public JunkpileWaterWorkQueue junkpileWaterWorkQueue
public float framebudgetms
public Transform[] buoyancyPoints
public bool debugDraw
private Quaternion baseRotation
private bool first
private TimeUntil nextPlayerCheck
private bool hasPlayersNearby
public void Spawn()
public void FixedUpdate()
public void UpdateMovement()
public void UpdateNearbyPlayers()
}
public JunkPileWaterSpawner : SpawnGroup {
public BaseEntity attachToParent
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
}
public Kayak : BaseBoat {
public ItemDefinition OarItem
public float maxPaddleFrequency
public float forwardPaddleForce
public float multiDriverPaddleForceMultiplier
public float rotatePaddleForce
public GameObjectRef forwardSplashEffect
public GameObjectRef backSplashEffect
public ParticleSystem moveSplashEffect
public float animationLerpSpeed
public BlendedSoundLoops waterLoops
public float waterSoundSpeedDivisor
public GameObjectRef pushLandEffect
public GameObjectRef pushWaterEffect
public MountPoses noPaddlePose
public TimeSince[] playerPaddleCooldowns
public TimeCachedValue`1<float> fixedDragUpdate
public TimeSince timeSinceLastUsed
private float DECAY_TICK_TIME
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void DriverInput(InputState inputState, BasePlayer player)
public bool EngineOn()
public void DoPushAction(BasePlayer player)
protected void VehicleFixedUpdate()
public float CalculateDesiredDrag()
public void BoatDecay()
public void OnPoolDestroyed()
public void WakeUp()
public bool CanPickup(BasePlayer player)
public bool IsPlayerHoldingPaddle(BasePlayer player)
public Vector3 GetPaddlePoint(int index, PaddleDirection direction)
public bool IsInWater()
}
public KayakSeat : BaseVehicleSeat {
public ItemDefinition PaddleItem
}
public KeyBindUI : MonoBehaviour {
public GameObject blockingCanvas
public Button btnA
public Button btnB
public string bindString
}
public Keycard : AttackEntity {
public int accessLevel
public int get_accessLevel()
}
public KeyCodeEntry : UIDialog {
public Text textDisplay
public Action`1<string> onCodeEntered
public Text typeDisplay
public Phrase masterCodePhrase
public Phrase guestCodePhrase
}
public KeyInformationPanel : ItemInformationPanel {
private Text id
}
public KeyLock : BaseLock {
public ItemDefinition keyItemType
public int keyCode
public bool firstKeyCreated
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasLockPermission(BasePlayer player)
private bool CanKeyUnlockUs(Item key)
public void Load(LoadInfo info)
public bool ShouldNetworkOwnerInfo()
public void PostServerLoad()
public void Save(SaveInfo info)
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy)
public bool OnTryToOpen(BasePlayer player)
public bool OnTryToClose(BasePlayer player)
private void RPC_Unlock(RPCMessage rpc)
private void RPC_Lock(RPCMessage rpc)
private void Lock(BasePlayer player)
private void RPC_CreateKey(RPCMessage rpc)
public void LockLock(BasePlayer player)
}
public LadderMinMountHeight : MonoBehaviour {
private void Start()
private void Update()
}
public LakeInfo : MonoBehaviour {
protected void Awake()
}
public LandmarkInfo : MonoBehaviour {
public bool shouldDisplayOnMap
public Phrase displayPhrase
public Sprite mapIcon
protected void Awake()
}
public Landmine : BaseTrap {
public GameObjectRef explosionEffect
public GameObjectRef triggeredEffect
public float minExplosionRadius
public float explosionRadius
public bool blocked
private ulong triggerPlayerID
public List`1<DamageTypeEntry> damageTypes
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool Triggered()
public bool Armed()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ServerInit()
public void ObjectEntered(GameObject obj)
public void Trigger(BasePlayer ply)
public void OnEmpty()
public void Explode()
public void OnKilled(HitInfo info)
private void OnGroundMissing()
private void TryExplode()
public void Arm()
private void RPC_Disarm(RPCMessage rpc)
}
public LanguageSelection : MonoBehaviour {
public GameObject buttonContainer
}
public LargeShredder : BaseEntity {
public Transform shredRail
public Transform shredRailStartPos
public Transform shredRailEndPos
public Vector3 shredRailStartRotation
public Vector3 shredRailEndRotation
public LargeShredderTrigger trigger
public float shredDurationRotation
public float shredDurationPosition
public float shredSwayAmount
public float shredSwaySpeed
public BaseEntity currentlyShredding
public GameObject[] shreddingWheels
public float shredRotorSpeed
public GameObjectRef shredSoundEffect
public Transform resourceSpawnPoint
private Quaternion entryRotation
private bool isShredding
private float shredStartTime
public void OnEntityEnteredTrigger(BaseEntity ent)
public void CreateShredResources()
public void UpdateBonePosition(float delta)
public void SetShredding(bool isShredding)
public void FireShredEffect()
public void ServerUpdate()
private void Update()
}
public LargeShredderTrigger : TriggerBase {
public LargeShredder shredder
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
}
public LaserBeam : MonoBehaviour {
public float scrollSpeed
public LineRenderer beamRenderer
public GameObject dotObject
public Renderer dotRenderer
public GameObject dotSpotlight
public Vector2 scrollDir
public float maxDistance
public float stillBlendFactor
public float movementBlendFactor
public float movementThreshhold
public bool isFirstPerson
public Transform emissionOverride
private MaterialPropertyBlock block
}
public LaserDetector : BaseDetector {
public void OnObjects()
}
public LayerCullDistance : MonoBehaviour {
public string Layer
public float Distance
protected void OnEnable()
}
public LayerSelect : ValueType {
private int layer
public int Mask
public string Name
public void .ctor(int layer)
public int op_Implicit(LayerSelect layer)
public LayerSelect op_Implicit(int layer)
public int get_Mask()
public string get_Name()
}
public LazyAimProperties : ScriptableObject {
public float snapStrength
public float deadzoneAngle
}
public LeavesBlowing : MonoBehaviour {
public ParticleSystem m_psLeaves
public float m_flSwirl
public float m_flSpeed
public float m_flEmissionRate
private void Start()
private void Update()
}
public LegacyWeatherState : object {
private WeatherPreset preset
public float Wind
public float Rain
public float Clouds
public float Fog
public void .ctor(WeatherPreset preset)
public float get_Wind()
public void set_Wind(float value)
public float get_Rain()
public void set_Rain(float value)
public float get_Clouds()
public void set_Clouds(float value)
public float get_Fog()
public void set_Fog(float value)
}
public LerpBetweenPointsBool : MonoBehaviour {
public Vector3 offsetPosLocal
public float speed
public void SetAtOffset(bool should)
}
public LevelInfo : SingletonComponent`1<LevelInfo> {
public string shortName
public string displayName
public string description
public Texture2D image
public int version
}
public LevelManager : object {
public string CurrentLevelName
public bool isLoaded
public bool get_isLoaded()
public bool IsValid(string strName)
public void LoadLevel(string strName, bool keepLoadingScreenOpen)
public IEnumerator LoadLevelAsync(string strName, bool keepLoadingScreenOpen)
public void UnloadLevel(bool loadingScreen)
}
public LifeInfographic : MonoBehaviour {
public PlayerLifeStory life
public GameObject container
public RawImage AttackerAvatarImage
public Image DamageSourceImage
public LifeInfographicStat[] Stats
public Animator[] AllAnimators
public GameObject WeaponRoot
public GameObject DistanceRoot
public GameObject DistanceDivider
public Image WeaponImage
public DamageSetting[] DamageDisplays
public bool ShowDebugData
}
public LifeInfographicStat : MonoBehaviour {
public DataType dataSource
public string genericStatKey
public string targetWeaponName
public WeaponInfoType weaponInfoType
public TextMeshProUGUI targetText
public Image StatImage
}
public LifeInfographicStatDynamicRow : LifeInfographicStat {
public RustText StatName
public void SetStatName(Phrase phrase)
}
public LifeInfographicStatWeapon : MonoBehaviour {
public RustText WeaponName
public RustText ShotsFired
public RustText ShotsHit
public RustText ShotsPercent
public Image WeaponIcon
}
public LifeScale : BaseMonoBehaviour {
private bool initialized
private Vector3 initialScale
public Vector3 finalScale
private Vector3 targetLerpScale
private Action updateScaleAction
protected void Awake()
public void OnEnable()
public void SetProgress(float progress)
public void Init()
public void UpdateScale()
}
public Lift : AnimatedBuildingBlock {
public GameObjectRef triggerPrefab
public string triggerBone
public float resetDelay
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void RPC_UseLift(RPCMessage rpc)
private void MoveUp()
private void MoveDown()
protected void OnAnimatorDisabled()
public void Spawn()
}
public LightCloneShadow : MonoBehaviour {
public bool cloneShadowMap
public string shaderPropNameMap
public int cloneShadowMapDownscale
public RenderTexture map
public bool cloneShadowMask
public string shaderPropNameMask
public int cloneShadowMaskDownscale
public RenderTexture mask
}
public LightEx : UpdateBehaviour {
public bool alterColor
public float colorTimeScale
public Color colorA
public Color colorB
public AnimationCurve blendCurve
public bool loopColor
public bool alterIntensity
public float intensityTimeScale
public AnimationCurve intenseCurve
public float intensityCurveScale
public bool loopIntensity
public bool randomOffset
public float randomIntensityStartScale
protected void OnValidate()
public bool CheckConflict(GameObject go)
}
public LightGroupAtTime : FacepunchBehaviour {
public float IntensityOverride
public AnimationCurve IntensityScaleOverTime
public Transform SearchRoot
}
public LightListener : BaseEntity {
public string onMessage
public string offMessage
public LightGroupAtTime onLights
public LightGroupAtTime offLights
public void OnEntityMessage(BaseEntity from, string msg)
}
public LightLOD : MonoBehaviour {
public float DistanceBias
public bool ToggleLight
public bool ToggleShadows
protected void OnValidate()
}
public LightOccludee : MonoBehaviour {
public float RadiusScale
public float MinTimeVisible
public bool IsDynamic
}
public LightPulse : MonoBehaviour {
public Light TargetLight
public float PulseSpeed
public float Lifetime
public float MaxIntensity
public float FadeOutSpeed
}
public LinearFog : MonoBehaviour {
public Material fogMaterial
public Color fogColor
public float fogStart
public float fogRange
public float fogDensity
public bool fogSky
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public LineRendererActivate : MonoBehaviour {
private void OnEnable()
}
public LinqEx : object {
public int MaxIndex(IEnumerable`1<T> sequence)
}
public LiquidContainer : ContainerIOEntity {
public ItemDefinition defaultLiquid
public int startingAmount
public bool autofillOutputs
public float autofillTickRate
public int autofillTickAmount
public int maxOutputFlow
public ItemDefinition[] ValidItems
private int currentDrainAmount
private HashSet`1<IOEntity> connectedList
private HashSet`1<ContainerIOEntity> pushTargets
private int maxPushTargets
private IOEntity considerConnectedTo
private Action updateDrainAmountAction
private Action updatePushLiquidTargetsAction
private Action pushLiquidAction
private Action deductFuelAction
private float lastOutputDrainUpdate
public bool IsGravitySource
protected bool DisregardGravityRestrictionsOnLiquid
public bool BlockFluidDraining
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_IsGravitySource()
protected bool get_DisregardGravityRestrictionsOnLiquid()
public bool IsRootEntity()
private bool CanAcceptItem(Item item, int count)
public void ServerInit()
public void OnCircuitChanged(bool forceUpdate)
public void OnItemAddedOrRemoved(Item item, bool added)
private void ClearDrains()
public int GetCurrentEnergy()
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
private void UpdateDrainAmount()
public bool get_BlockFluidDraining()
private void CalculateDrain(IOEntity ent, Vector3 fromSlotWorld, int depth, Int32& amount, IOEntity lastEntity, ItemDefinition waterType)
public void UpdateOutputs()
private void DeductFuel()
protected void UpdateOnFlag()
public void OpenTap(float duration)
public void ShutTap()
public bool HasLiquidItem()
public Item GetLiquidItem()
public int GetLiquidCount()
public void SVDrink(RPCMessage rpc)
private void UpdatePushLiquidTargets()
private void PushLiquidThroughOutputs()
private void CheckPushLiquid(IOEntity connected, Item ourFuel, IOEntity fromSource, int depth)
public void SetConnectedTo(IOEntity entity)
protected bool ConsiderConnectedTo(IOEntity entity)
}
public LiquidVessel : HeldEntity {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanDrink()
private void DoEmpty(RPCMessage msg)
public void AddLiquid(ItemDefinition liquidType, int amount)
public bool CanFillHere(Vector3 pos)
public int AmountHeld()
public float HeldFraction()
public bool IsFull()
public int MaxHoldable()
}
public LiquidWeapon : BaseLiquidVessel {
public float FireRate
public float MaxRange
public int FireAmountML
public int MaxPressure
public int PressureLossPerTick
public int PressureGainedPerPump
public float MinDmgRadius
public float MaxDmgRadius
public float SplashRadius
public GameObjectRef ImpactSplashEffect
public AnimationCurve PowerCurve
public List`1<DamageTypeEntry> Damage
public LiquidWeaponEffects EntityWeaponEffects
public bool RequiresPumping
public bool AutoPump
public bool WaitForFillAnim
public bool UseFalloffCurve
public AnimationCurve FalloffCurve
public float PumpingBlockDuration
public float StartFillingBlockDuration
public float StopFillingBlockDuration
private float cooldownTime
private int pressure
public string RadiationFightAchievement
public string SoakedAchievement
public string LiquidatorAchievement
public string NoPressureAchievement
public float PressureFraction
public float MinimumPressureFraction
public float CurrentRange
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void StartFiring(RPCMessage msg)
private void StopFiring()
private bool CanFire(BasePlayer player)
public void PumpWater(RPCMessage msg)
private void PumpWater()
private void FireTick()
private void DoSplash(BasePlayer attacker, Vector3 position, Vector3 direction, int amount)
public void OnHeldChanged()
public float get_PressureFraction()
public float get_MinimumPressureFraction()
public float get_CurrentRange()
private void StartCooldown(float duration)
private bool OnCooldown()
private bool Firing()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public LoadBalancer : SingletonComponent`1<LoadBalancer> {
public bool Paused
private float MinMilliseconds
private float MaxMilliseconds
private int MinBacklog
private int MaxBacklog
private Queue`1[] queues
private Stopwatch watch
protected void LateUpdate()
public int Count()
public void ProcessAll()
public void Enqueue(DeferredAction action)
private void CreateInstance()
}
public LoadingScreen : SingletonComponent`1<LoadingScreen> {
private bool <WantsSkip>k__BackingField
private string <Text>k__BackingField
public CanvasRenderer panel
public TextMeshProUGUI title
public TextMeshProUGUI subtitle
public Button skipButton
public GameObject performanceWarning
public AudioSource music
public bool isOpen
public bool WantsSkip
public string Text
public bool get_isOpen()
public bool get_WantsSkip()
private void set_WantsSkip(bool value)
private void set_Text(string value)
public string get_Text()
public void Update(string strType)
public void Update(string strType, string strSubtitle)
}
public LocalClock : object {
public List`1<TimedEvent> events
public void Add(float delta, float variance, Action action)
public void Tick()
}
public LocalizeText : MonoBehaviour {
public string token
public string english
public string append
public SpecialMode specialMode
public string LanguageToken
public string LanguageEnglish
public string get_LanguageToken()
public void set_LanguageToken(string value)
public string get_LanguageEnglish()
public void set_LanguageEnglish(string value)
}
public LocalPositionAnimation : MonoBehaviour {
public Vector3 centerPosition
public bool worldSpace
public float scaleX
public float timeScaleX
public AnimationCurve movementX
public float scaleY
public float timeScaleY
public AnimationCurve movementY
public float scaleZ
public float timeScaleZ
public AnimationCurve movementZ
}
public LockedByEntCrate : LootContainer {
public GameObject lockingEnt
public void SetLockingEnt(GameObject ent)
public void SetLocked(bool isLocked)
public void Think()
}
public Locker : StorageContainer {
public GameObjectRef equipSound
private int maxGearSets
private int attireSize
private int beltSize
private int columnSize
private Item[] clothingBuffer
private int setSize
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsEquipping()
private RowType GetRowType(int slot)
public void ServerInit()
public void ClearEquipping()
public bool ItemFilter(Item item, int targetSlot)
public void RPC_Equip(RPCMessage msg)
}
public LODComponent : BaseMonoBehaviour {
public LODDistanceMode DistanceMode
public OccludeeParameters OccludeeParams
}
public LODComponentParticleSystem : LODComponent {
public bool playOnShow
}
public LODDistanceMode : Enum {
public int value__
public LODDistanceMode XYZ
public LODDistanceMode XZ
public LODDistanceMode Y
}
public LODEnvironmentMode : Enum {
public int value__
public LODEnvironmentMode Default
public LODEnvironmentMode Underground
}
public LODGrid : SingletonComponent`1<LODGrid> {
public bool Paused
public float CellSize
public float MaxMilliseconds
public float MaxRefreshDistance
public float TreeMeshDistance
}
public LODManager : SingletonComponent`1<LODManager> {
public float MaxMilliseconds
}
public LODUtil : object {
public float DefaultDistance
public float GetDistance(Transform transform, LODDistanceMode mode)
public float GetDistance(Vector3 worldPos, LODDistanceMode mode)
public float VerifyDistance(float distance)
public LODEnvironmentMode DetermineEnvironmentMode(Transform transform)
}
public LookAt : MonoBehaviour {
public Transform target
private void Update()
}
public LookatHealth : MonoBehaviour {
public bool Enabled
public GameObject container
public Text textHealth
public Text textStability
public Image healthBar
public Image healthBarBG
public Color barBGColorNormal
public Color barBGColorUnstable
}
public LookAtIOEnt : MonoBehaviour {
public Text objectTitle
public RectTransform slotToolTip
public Text slotTitle
public Text slotConnection
public Text slotPower
public Text powerText
public Text passthroughText
public Text chargeLeftText
public Text capacityText
public Text maxOutputText
public Text activeOutputText
public IOEntityUISlotEntry[] inputEntries
public IOEntityUISlotEntry[] outputEntries
public Color NoPowerColor
public GameObject GravityWarning
public CanvasGroup group
public HandleSet[] handleSets
public RectTransform clearNotification
public CanvasGroup wireInfoGroup
public Text wireLengthText
public Text wireClipsText
public Text errorReasonTextTooFar
public Text errorReasonTextNoSurface
public Text errorShortCircuit
public RawImage ConnectionTypeIcon
public Texture ElectricSprite
public Texture FluidSprite
}
public LookAtPlant : MonoBehaviour {
public CanvasGroup group
public UIGenesDisplay GeneDisplay
public UIGenesDisplay GeneDisplay2
public Text TextPlant
public Image PlantIcon
public InfoBar Age
public InfoBar Stage
public InfoBar WaterIntake
public Text TextYieldLabel
public InfoBar Yield
public InfoBar Health
public InfoBar Light
public InfoBar WaterSaturation
public InfoBar Ground
public InfoBar Temperature
public InfoBar Overall
}
public LookAtPlanter : MonoBehaviour {
public CanvasGroup group
public Text waterText
}
public LookatTooltip : MonoBehaviour {
public bool Enabled
public BaseEntity currentlyLookingAt
public RustText textLabel
public Image icon
public CanvasGroup canvasGroup
public CanvasGroup infoGroup
}
public LootableCorpse : BaseCorpse {
public string lootPanelName
public ulong playerSteamID
public string _playerName
public ItemContainer[] containers
public string playerName
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public string get_playerName()
public void set_playerName(string value)
public void ServerInit()
internal void DoServerDestroy()
public void TakeFrom(ItemContainer[] source)
public bool CanRemove()
public bool CanLoot()
private void RPC_LootCorpse(RPCMessage rpc)
public void PlayerStoppedLooting(BasePlayer player)
public void DropItems()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public LootContainer : StorageContainer {
public bool destroyOnEmpty
public LootSpawn lootDefinition
public int maxDefinitionsToSpawn
public float minSecondsBetweenRefresh
public float maxSecondsBetweenRefresh
public bool initialLootSpawn
public float xpLootedScale
public float xpDestroyedScale
public bool BlockPlayerItemInput
public int scrapAmount
public string deathStat
public LootSpawnSlot[] LootSpawnSlots
public spawnType SpawnType
private ItemDefinition scrapDef
public bool shouldRefreshContents
public bool get_shouldRefreshContents()
public void ServerInit()
public void PostServerLoad()
public void SpawnLoot()
public int ScoreForRarity(Rarity rarity)
public void PopulateLoot()
public void GenerateScrap()
public void DropBonusItems(BaseEntity initiator, ItemContainer container)
public void PlayerStoppedLooting(BasePlayer player)
public void RemoveMe()
public bool ShouldDropItemsIndividually()
public void OnKilled(HitInfo info)
public void OnAttacked(HitInfo info)
public void InitShared()
}
public LootDistanceOverride : MonoBehaviour {
public float amount
}
public LootPanel : MonoBehaviour {
public Text Title
}
public LootPanelBigWheelTerminal : LootPanel {
public Text timeRemainingText
}
public LootPanelCardTableTerminal : LootPanel {
private Text buyInInfoText
private Phrase phraseMin
private Phrase phraseMax
}
public LootPanelContainer : MonoBehaviour {
public string containerName
public GameObject NoLootPanel
}
public LootPanelEngine : LootPanel {
private Image engineImage
private ItemIcon[] icons
private GameObject warning
private RustText hp
private RustText power
private RustText acceleration
private RustText topSpeed
private RustText fuelEconomy
}
public LootPanelHorse : LootPanel {
public Text breedTitle
public Text maxSpeedText
public Text staminaText
public Text healthText
public GameObject[] storageSlots
public GameObject storageWindow
}
public LootPanelLocker : LootPanel {
public GameObject[] controls
}
public LootPanelMixingTable : LootPanel {
public GameObject controlsOn
public GameObject controlsOff
public Button StartMixingButton
public InfoBar ProgressBar
public GameObject recipeItemPrefab
public RectTransform recipeContentRect
}
public LootPanelOven : LootPanel {
public GameObject controlsOn
public GameObject controlsOff
}
public LootPanelReclaim : LootPanel {
public int oldOverflow
public Text overflowText
public GameObject overflowObject
public Phrase MorePhrase
}
public LootPanelRecycler : LootPanel {
public GameObject controlsOn
public GameObject controlsOff
}
public LootPanelToolCupboard : LootPanel {
public List`1<VirtualItemIcon> costIcons
public Text costPerTimeText
public Text protectedText
public GameObject baseNotProtectedObj
public GameObject baseProtectedObj
public Phrase protectedPrefix
public Tooltip costToolTip
public Phrase blocksPhrase
}
public LootPanelVendingMachine : LootPanel {
public GameObjectRef sellOrderPrefab
public GameObject sellOrderContainer
public GameObject busyOverlayPrefab
private GameObject busyOverlayInstance
}
public LootPanelWaterCatcher : LootPanel {
public ItemIcon sourceItem
public Image capacityImage
public CanvasGroup helpCanvas
public CanvasGroup buttonsCanvas
public Button fromButton
public Button toButton
public Button drinkButton
}
public LootSpawn : ScriptableObject {
public ItemAmountRanged[] items
public Entry[] subSpawn
public ItemDefinition GetBlueprintBaseDef()
public void SpawnIntoContainer(ItemContainer container)
private void SubCategoryIntoContainer(ItemContainer container)
}
public m2bradleyAnimator : MonoBehaviour {
public Animator m2Animator
public Material treadLeftMaterial
public Material treadRightMaterial
private Rigidbody mainRigidbody
public Transform turret
public Transform mainCannon
public Transform coaxGun
public Transform rocketsPitch
public Transform spotLightYaw
public Transform spotLightPitch
public Transform sideMG
public Transform[] sideguns
public Transform[] ShocksBones
public Transform[] ShockTraceLineBegin
public Vector3[] vecShocksOffsetPosition
public Transform targetTurret
public Transform targetSpotLight
public Transform[] targetSideguns
private Vector3 vecTurret
private Vector3 vecMainCannon
private Vector3 vecCoaxGun
private Vector3 vecRocketsPitch
private Vector3 vecSpotLightBase
private Vector3 vecSpotLight
private float sideMGPitchValue
public GameObject muzzleflashCannon
public GameObject muzzleflashCoaxGun
public GameObject muzzleflashSideMG
public GameObject[] muzzleflashRockets
public GameObject spotLightHaloSawnpoint
public GameObject[] muzzleflashSideguns
public GameObjectRef machineGunMuzzleFlashFX
public GameObjectRef mainCannonFireFX
public GameObjectRef rocketLaunchFX
public bool rocketsOpen
public Vector3[] vecSideGunRotation
public float treadConstant
public float wheelSpinConstant
public float sidegunsTurnSpeed
public float turretTurnSpeed
public float cannonPitchSpeed
public float rocketPitchSpeed
public float spotLightTurnSpeed
public float machineGunSpeed
private float wheelAngle
private void Start()
private void Update()
private void AnimateWheelsTreads()
private void AdjustShocksHeight()
private void TrackTurret()
private void TrackSpotLight()
private void TrackSideGuns()
public void CalculateYawPitchOffset(Transform objectTransform, Vector3 vecStart, Vector3 vecEnd, Single& yaw, Single& pitch)
public float NormalizeYaw(float flYaw)
}
public M2BradleyPhysics : MonoBehaviour {
private m2bradleyAnimator m2Animator
public WheelCollider[] Wheels
public WheelCollider[] TurningWheels
public Rigidbody mainRigidbody
public Transform[] waypoints
private Vector3 currentWaypoint
private Vector3 nextWaypoint
}
public MagnetCraneSounds : MonoBehaviour {
public BaseCrane crane
public SoundDefinition engineStartSoundDef
public SoundDefinition engineStopSoundDef
public BlendedLoopEngineSound engineLoops
public SoundDefinition cabinRotationStartDef
public SoundDefinition cabinRotationStopDef
public SoundDefinition cabinRotationLoopDef
private Sound cabinRotationLoop
public SoundDefinition turningLoopDef
private Sound turningLoop
public SoundDefinition trackMovementLoopDef
private Sound trackMovementLoop
private Modulator trackGainMod
private Modulator trackPitchMod
public SoundDefinition armMovementLoopDef
public SoundDefinition armMovementStartDef
public SoundDefinition armMovementStopDef
private Sound armMovementLoop01
private Modulator armMovementLoop01PitchMod
public GameObject arm01SoundPosition
public GameObject arm02SoundPosition
private Sound armMovementLoop02
private Modulator armMovementLoop02PitchMod
}
public MagnetLiftable : EntityComponent`1<BaseEntity> {
public ItemAmount[] shredResources
public Vector3 shredDirection
public void SetMagnetized(bool wantsOn, BaseMagnet magnetSource)
}
public MagnetSnap : object {
private Transform snapLocation
private Vector3 prevSnapLocation
public void .ctor(Transform snapLocation)
public void FixedUpdate(Transform target)
public void PositionTarget(Transform target)
}
public Mailbox : StorageContainer {
public string ownerPanel
public GameObjectRef mailDropSound
public bool autoSubmitWhenClosed
public bool shouldMarkAsFull
public int mailInputSlot
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int get_mailInputSlot()
public bool PlayerIsOwner(BasePlayer player)
public bool IsFull()
public void MarkFull(bool full)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
private bool HasFreeSpace()
private int GetFreeSlot()
public bool MoveItemToStorage(Item item)
public void PlayerStoppedLooting(BasePlayer player)
public void RPC_Submit(RPCMessage msg)
public void SubmitInputItems(BasePlayer fromPlayer)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool CanMoveFrom(BasePlayer player, Item item)
}
public MainCamera : RustCamera`1<MainCamera> {
public Camera mainCamera
public Transform mainCameraTransform
private Vector3 <velocity>k__BackingField
public bool isValid
public Vector3 velocity
public Vector3 position
public Vector3 forward
public Vector3 right
public Vector3 up
public Quaternion rotation
public Ray Ray
public bool get_isValid()
public Vector3 get_velocity()
private void set_velocity(Vector3 value)
public Vector3 get_position()
public void set_position(Vector3 value)
public Vector3 get_forward()
public void set_forward(Vector3 value)
public Vector3 get_right()
public void set_right(Vector3 value)
public Vector3 get_up()
public void set_up(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public Ray get_Ray()
}
public MainMenuSystem : SingletonComponent`1<MainMenuSystem> {
public bool isOpen
public Action OnOpenStateChanged
public RustButton SessionButton
public GameObject SessionPanel
public GameObject NewsStoriesAlert
public GameObject ItemStoreAlert
public GameObject CompanionAlert
public GameObject DemoBrowser
public GameObject DemoBrowserButton
}
public ManagedNoise : object {
private Int32[] hash
private int hashMask
private double sqrt2
private double rsqrt2
private double squaresToTriangles
private double trianglesToSquares
private double simplexScale1D
private double simplexScale2D
private double gradientScale2D
private Double[] gradients1D
private int gradientsMask1D
private Double[] gradients2Dx
private Double[] gradients2Dy
private int gradientsMask2D
public double Simplex1D(double x)
public double Simplex1D(double x, Double& dx)
public double Simplex2D(double x, double y)
public double Simplex2D(double x, double y, Double& dx, Double& dy)
public double Turbulence(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double Billow(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double Ridge(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double Sharp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double TurbulenceIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double BillowIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double RidgeIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double SharpIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
public double TurbulenceWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double BillowWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double RidgeWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double SharpWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
public double Jordan(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp, double damp, double damp_scale)
private int Floor(double x)
private double Abs(double x)
private double Saturate(double x)
}
public MapEntity : HeldEntity {
public UInt32[] fogImages
public UInt32[] paintImages
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ImageUpdate(RPCMessage msg)
}
public MapImageRenderer : object {
private Vector3 StartColor
private Vector4 WaterColor
private Vector4 GravelColor
private Vector4 DirtColor
private Vector4 SandColor
private Vector4 GrassColor
private Vector4 ForestColor
private Vector4 RockColor
private Vector4 SnowColor
private Vector4 PebbleColor
private Vector4 OffShoreColor
private Vector3 SunDirection
private float SunPower
private float Brightness
private float Contrast
private float OceanWaterLevel
private Vector3 Half
public Byte[] Render(Int32& imageWidth, Int32& imageHeight, Color& background, float scale, bool lossy)
private Byte[] EncodeToFile(int width, int height, Color[] pixels, bool lossy)
private Vector3 UnpackNormal(Vector4 value)
}
public MapInterface : SingletonComponent`1<MapInterface> {
public bool IsOpen
public Image cameraPositon
public ScrollRectEx scrollRect
public Toggle showGridToggle
public Button FocusButton
public CanvasGroup CanvasGroup
public SoundDefinition PlaceMarkerSound
public SoundDefinition ClearMarkerSound
public MapView View
public Color[] PointOfInterestColours
public Sprite[] PointOfInterestSprites
public bool DebugStayOpen
}
public MapMarker : BaseEntity {
public AppMarkerType appType
public GameObjectRef markerObj
public List`1<MapMarker> serverMapMarkers
public void InitShared()
public void DestroyShared()
public AppMarker GetAppMarkerData()
}
public MapMarkerCH47 : MapMarker {
private GameObject createdMarker
private float GetRotation()
public AppMarker GetAppMarkerData()
}
public MapMarkerDeliveryDrone : MapMarker {
public void ServerInit()
public bool ShouldNetworkTo(BasePlayer player)
}
public MapMarkerExplosion : MapMarker {
private float duration
public void SetDuration(float newDuration)
public void Load(LoadInfo info)
public void DelayedDestroy()
}
public MapMarkerGenericRadius : MapMarker {
public float radius
public Color color1
public Color color2
public float alpha
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void SendUpdate(bool fullUpdate)
public AppMarker GetAppMarkerData()
}
public MapView : FacepunchBehaviour {
public RawImage mapImage
public Image cameraPositon
public ScrollRectEx scrollRect
public GameObject monumentMarkerContainer
public Transform clusterMarkerContainer
public GameObjectRef monumentMarkerPrefab
public TeamMemberMapMarker[] teamPositions
public PointOfInterestMapMarker PointOfInterestMarker
public PointOfInterestMapMarker LeaderPointOfInterestMarker
public GameObject PlayerDeathMarker
public List`1<SleepingBagMapMarker> SleepingBagMarkers
public List`1<SleepingBagClusterMapMarker> SleepingBagClusters
public RawImage TrainLayer
public bool ShowGrid
public bool ShowPointOfInterestMarkers
public bool ShowDeathMarker
public bool ShowSleepingBags
public bool ShowLocalPlayer
public bool ShowTeamMembers
public bool ShowTrainLayer
}
public Marketplace : BaseEntity {
public GameObjectRef terminalPrefab
public Transform[] terminalPoints
public Transform droneLaunchPoint
public GameObjectRef deliveryDronePrefab
public EntityRef`1[] terminalEntities
public UInt32 SendDrone(BasePlayer player, MarketTerminal sourceTerminal, VendingMachine vendingMachine)
public void ReturnDrone(DeliveryDrone deliveryDrone)
public void Spawn()
private void SpawnSubEntities()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
}
public MarketTerminal : StorageContainer {
private Action`2<BasePlayer, Item> _onCurrencyRemovedCached
private Action`2<BasePlayer, Item> _onItemPurchasedCached
private Action _checkForExpiredOrdersCached
private bool _transactionActive
private List`1<UInt32> _deliveryEligible
private RealTimeSince _deliveryEligibleLastCalculated
public Flags Flag_HasItems
public Flags Flag_InventoryFull
public GameObjectRef menuPrefab
public ulong lockToCustomerDuration
public ulong orderTimeout
public ItemDefinition deliveryFeeCurrency
public int deliveryFeeAmount
public DeliveryDroneConfig config
public RustText userLabel
private ulong _customerSteamId
private string _customerName
private TimeUntil _timeUntilCustomerExpiry
private EntityRef`1<Marketplace> _marketplace
public List`1<PendingOrder> pendingOrders
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Setup(Marketplace marketplace)
public void ServerInit()
private void RegisterOrder(BasePlayer player, VendingMachine vendingMachine)
public void CompleteOrder(UInt32 vendingMachineId)
private void CheckForExpiredOrders()
private void RestrictToPlayer(BasePlayer player)
private void ClearRestriction()
public void Server_TryOpenMarket(RPCMessage msg)
public void Server_Purchase(RPCMessage msg)
private void UpdateHasItems(bool sendNetworkUpdate)
private void OnCurrencyRemoved(BasePlayer player, Item currencyItem)
private void OnItemPurchased(BasePlayer player, Item purchasedItem)
public void Save(SaveInfo info)
public bool ItemFilter(Item item, int targetSlot)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
private void RemoveAnyLooters()
public void GetDeliveryEligibleVendingMachines(List`1<UInt32> vendingMachineIds)
public bool CanPlayerAffordOrderAndDeliveryFee(BasePlayer player, SellOrder sellOrder, int numberOfTransactions)
public bool HasPendingOrderFor(UInt32 vendingMachineId)
public bool CanPlayerInteract(BasePlayer player)
public void Load(LoadInfo info)
private bool <GetDeliveryEligibleVendingMachines>g__IsEligible|24_0(VendingMachine vendingMachine, Vector3 offset, int n)
}
public MaterialColorLerp : MonoBehaviour {
public Color startColor
public Color endColor
public Color currentColor
public float delta
}
public MaterialConfig : ScriptableObject {
public ShaderParametersFloat[] Floats
public ShaderParametersColor[] Colors
public ShaderParametersTexture[] Textures
public String[] ScaleUV
private MaterialPropertyBlock properties
public MaterialPropertyBlock GetMaterialPropertyBlock(Material mat, Vector3 pos, Vector3 scale)
}
public MaterialEffect : ScriptableObject {
public GameObjectRef DefaultEffect
public SoundDefinition DefaultSoundDefinition
public Entry[] Entries
public int waterFootstepIndex
public Entry deepWaterEntry
public float deepWaterDepth
public Entry submergedWaterEntry
public float submergedWaterDepth
public bool ScaleVolumeWithSpeed
public AnimationCurve SpeedGainCurve
public Entry GetEntryFromMaterial(PhysicMaterial mat)
public Entry GetWaterEntry()
public void SpawnOnRay(Ray ray, int mask, float length, Vector3 forward, float speed)
public void PlaySound(SoundDefinition definition, Vector3 position, float velocity)
}
public MaterialOverlay : MonoBehaviour {
public Material material
private void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public MaterialPropertyDesc : ValueType {
public int nameID
public Type type
public void .ctor(string name, Type type)
}
public MaterialSetup : MonoBehaviour {
public MaterialConfig config
}
public MaterialSound : ScriptableObject {
public SoundDefinition DefaultSound
public Entry[] Entries
}
public MaterialSwap : MonoBehaviour {
public int materialIndex
public Renderer myRenderer
public Material OverrideMaterial
}
public MaxSpawnDistance : MonoBehaviour {
public float maxDistance
}
public MedicalTool : AttackEntity {
public float healDurationSelf
public float healDurationOther
public float maxDistanceOther
public bool canUseOnOther
public bool canRevive
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void UseOther(RPCMessage msg)
private void UseSelf(RPCMessage msg)
public void ServerUse()
private void GiveEffectsTo(BasePlayer player)
}
public MeleeWeaponInformationPanel : ItemInformationPanel {
public ItemStatValue damageDisplay
public ItemStatValue attackRateDisplay
public ItemStatValue attackSizeDisplay
public ItemStatValue attackRangeDisplay
public ItemStatValue oreGatherDisplay
public ItemStatValue treeGatherDisplay
public ItemStatValue fleshGatherDisplay
}
public MenuBackgroundVideo : SingletonComponent`1<MenuBackgroundVideo> {
private String[] videos
private int index
private bool errored
protected void Awake()
private void OnVideoError(VideoPlayer source, string message)
public void LoadVideoList()
public void Update()
private void NextVideo()
internal IEnumerator ReadyVideo()
}
public MenuButtonArcadeEntity : TextArcadeEntity {
public string titleText
public string selectionSuffix
public string clickMessage
public bool IsHighlighted()
}
public MenuServerPanel : MonoBehaviour {
private void Start()
private void Update()
}
public MenuTip : MonoBehaviour {
public TextMeshProUGUI text
public LoadingScreen screen
public Phrase[] MenuTips
private int currentTipIndex
private float nextTipTime
public void OnEnable()
public void Update()
public void UpdateTip()
}
public MeshBatch : MonoBehaviour {
private bool <NeedsRefresh>k__BackingField
private int <Count>k__BackingField
private int <BatchedCount>k__BackingField
private int <VertexCount>k__BackingField
public bool NeedsRefresh
public int Count
public int BatchedCount
public int VertexCount
public int VertexCapacity
public int VertexCutoff
public int AvailableVertices
public bool get_NeedsRefresh()
private void set_NeedsRefresh(bool value)
public int get_Count()
private void set_Count(int value)
public int get_BatchedCount()
private void set_BatchedCount(int value)
public int get_VertexCount()
private void set_VertexCount(int value)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
public int get_VertexCapacity()
public int get_VertexCutoff()
public int get_AvailableVertices()
public void Alloc()
public void Free()
public void Refresh()
public void Apply()
public void Display()
public void Invalidate()
protected void AddVertices(int vertices)
protected void OnEnable()
protected void OnDisable()
}
public MeshCache : object {
public Dictionary`2<Mesh, Data> dictionary
public Data Get(Mesh mesh)
}
public MeshColliderData : object {
public List`1<int> triangles
public List`1<Vector3> vertices
public List`1<Vector3> normals
public void Alloc()
public void Free()
public void Clear()
public void Apply(Mesh mesh)
public void Combine(MeshColliderGroup meshGroup)
public void Combine(MeshColliderGroup meshGroup, MeshColliderLookup colliderLookup)
}
public MeshColliderInstance : ValueType {
public Transform transform
public Rigidbody rigidbody
public Collider collider
public OBB bounds
public Vector3 position
public Quaternion rotation
public Vector3 scale
public Data data
public Mesh mesh
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public MeshColliderLookup : object {
public LookupGroup src
public LookupGroup dst
public void Apply()
public void Add(MeshColliderInstance instance)
public LookupEntry Get(int index)
}
public MeshCull : LODComponent {
public float Distance
}
public MeshData : object {
public List`1<int> triangles
public List`1<Vector3> vertices
public List`1<Vector3> normals
public List`1<Vector4> tangents
public List`1<Color32> colors32
public List`1<Vector2> uv
public List`1<Vector2> uv2
public List`1<Vector4> positions
public void AllocMinimal()
public void Alloc()
public void Free()
public void Clear()
public void Apply(Mesh mesh)
public void Combine(MeshGroup meshGroup)
}
public MeshDataBatch : MeshBatch {
private Vector3 position
private Mesh meshBatch
private MeshFilter meshFilter
private MeshRenderer meshRenderer
private MeshData meshData
private MeshGroup meshGroup
public int VertexCapacity
public int VertexCutoff
public int get_VertexCapacity()
public int get_VertexCutoff()
protected void Awake()
public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
public void Add(MeshInstance instance)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
}
public MeshGroupCull : LODComponent {
public float Distance
}
public MeshHolder : object {
public Vector3[] _vertices
public Vector3[] _normals
public Int32[] _triangles
public trisPerSubmesh[] _TrianglesOfSubs
public Matrix4x4[] _bindPoses
public BoneWeight[] _boneWeights
public Bounds _bounds
public int _subMeshCount
public Vector4[] _tangents
public Vector2[] _uv
public Vector2[] _uv2
public Vector2[] _uv3
public Color[] _colors
public Vector2[] _uv4
public void setAnimationData(Mesh mesh)
}
public MeshInstance : ValueType {
public Vector3 position
public Quaternion rotation
public Vector3 scale
public Data data
public Mesh mesh
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public MeshLOD : LODComponent {
public State[] States
}
public MeshPaintable : MonoBehaviour {
public string replacementTextureName
public int textureWidth
public int textureHeight
public Color clearColor
public Texture2D targetTexture
public bool hasChanges
}
public MeshPaintableSource : MonoBehaviour {
public int texWidth
public int texHeight
public string replacementTextureName
public float cameraFOV
public float cameraDistance
public Texture2D texture
public GameObject sourceObject
public Mesh collisionMesh
public Vector3 localPosition
public Vector3 localRotation
public bool applyToAllRenderers
public Renderer[] extraRenderers
public bool isSelected
private MaterialPropertyBlock block
public void Init()
public void Free()
public void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride, bool forEditing, bool isSelected)
public Color32[] UpdateFrom(Texture2D input)
public void Load(Byte[] data)
public void Clear()
}
public MeshPaintController : MonoBehaviour {
public Camera pickerCamera
public Texture2D brushTexture
public Vector2 brushScale
public Color brushColor
public float brushSpacing
public RawImage brushImage
public float brushPreviewScaleMultiplier
public bool applyDefaults
public Texture2D defaltBrushTexture
public float defaultBrushSize
public Color defaultBrushColor
public float defaultBrushAlpha
public Toggle lastBrush
private Vector3 lastPosition
}
public MeshRendererBatch : MeshBatch {
private Vector3 position
private Mesh meshBatch
private MeshFilter meshFilter
private MeshRenderer meshRenderer
private MeshRendererData meshData
private MeshRendererGroup meshGroup
private MeshRendererLookup meshLookup
public int VertexCapacity
public int VertexCutoff
public int get_VertexCapacity()
public int get_VertexCutoff()
protected void Awake()
public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
public void Add(MeshRendererInstance instance)
protected void AllocMemory()
protected void FreeMemory()
protected void RefreshMesh()
protected void ApplyMesh()
protected void ToggleMesh(bool state)
protected void OnPooled()
}
public MeshRendererData : object {
public List`1<int> triangles
public List`1<Vector3> vertices
public List`1<Vector3> normals
public List`1<Vector4> tangents
public List`1<Color32> colors32
public List`1<Vector2> uv
public List`1<Vector2> uv2
public List`1<Vector4> positions
public void Alloc()
public void Free()
public void Clear()
public void Apply(Mesh mesh)
public void Combine(MeshRendererGroup meshGroup)
public void Combine(MeshRendererGroup meshGroup, MeshRendererLookup rendererLookup)
}
public MeshRendererInstance : ValueType {
public Renderer renderer
public OBB bounds
public Vector3 position
public Quaternion rotation
public Vector3 scale
public Data data
public Mesh mesh
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public MeshRendererLookup : object {
public LookupGroup src
public LookupGroup dst
public void Apply()
public void Clear()
public void Add(MeshRendererInstance instance)
public LookupEntry Get(int index)
}
public MeshReplacement : MonoBehaviour {
public SkinnedMeshRenderer Female
internal void Process(GameObject go, bool IsFemale)
}
public MeshToggle : MonoBehaviour {
public Mesh[] RendererMeshes
public Mesh[] ColliderMeshes
public void SwitchRenderer(int index)
public void SwitchRenderer(float factor)
public void SwitchCollider(int index)
public void SwitchCollider(float factor)
public void SwitchAll(int index)
public void SwitchAll(float factor)
}
public Meta : ConsoleSystem {
public void add(Arg args)
public void if_true(Arg args)
public void if_false(Arg args)
public void reset_cycle(Arg args)
private Command Find(string name)
}
public MetabolismAttribute : object {
public float startMin
public float startMax
public float min
public float max
public float value
public float lastValue
internal float lastGreatFraction
private float greatInterval
public float greatFraction
public float get_greatFraction()
public void Reset()
public float Fraction()
public float InverseFraction()
public void Add(float val)
public void Subtract(float val)
public void Increase(float fTarget)
public void MoveTowards(float fTarget, float fRate)
public bool HasChanged()
public bool HasGreatlyChanged()
public void SetValue(float newValue)
}
public MiniCopter : BaseHelicopterVehicle {
public GameObjectRef fuelStoragePrefab
public Transform fuelStoragePoint
public float fuelPerSec
public float fuelGaugeMax
public EntityFuelSystem fuelSystem
public float cachedFuelFraction
public Transform waterSample
public WheelCollider leftWheel
public WheelCollider rightWheel
public WheelCollider frontWheel
public Transform leftWheelTrans
public Transform rightWheelTrans
public Transform frontWheelTrans
public float cachedrotation_left
public float cachedrotation_right
public float cachedrotation_front
public Transform joystickPositionLeft
public Transform joystickPositionRight
public Transform leftFootPosition
public Transform rightFootPosition
public AnimationCurve bladeEngineCurve
public Animator animator
public float maxRotorSpeed
public float timeUntilMaxRotorSpeed
public float rotorBlurThreshold
public Transform mainRotorBlur
public Transform mainRotorBlades
public Transform rearRotorBlades
public Transform rearRotorBlur
public float motorForceConstant
public float brakeForceConstant
public GameObject preventBuildingObject
public float population
public float outsidedecayminutes
public float insidedecayminutes
public VehicleEngineController engineController
public bool isPushing
public float lastEngineOnTime
public float cachedPitch
public float cachedYaw
public float cachedRoll
public bool IsStartingUp
public EngineState CurEngineState
public float GetFuelFraction()
public EntityFuelSystem GetFuelSystem()
public void RPC_OpenFuel(RPCMessage msg)
public bool get_IsStartingUp()
public EngineState get_CurEngineState()
public void InitShared()
public bool IsValidSAMTarget()
public float GetServiceCeiling()
public void PilotInput(InputState inputState, BasePlayer player)
public bool Grounded()
public void SetDefaultInputState()
public void ApplyForceAtWheels()
public void ApplyWheelForce(WheelCollider wheel, float gasScale, float brakeScale, float turning)
public void MovementUpdate()
public void ServerInit()
public void DecayTick()
public void SpawnSubEntities()
public bool Waterlogged()
public bool ShouldApplyHoverForce()
public bool IsEngineOn()
public bool CanRunEngines()
public void OnEngineStartFailed()
public void OnFlagsChanged(Flags old, Flags next)
public void VehicleFixedUpdate()
public void UpdateNetwork()
public void UpdateCOM()
public void Save(SaveInfo info)
public void DismountAllPlayers()
public void DoPushAction(BasePlayer player)
private void DisablePushing()
public float RemapValue(float toUse, float maxRemap)
public void Load(LoadInfo info)
public bool CanPushNow(BasePlayer pusher)
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void IEngineControllerUser.Invoke(Action action, float time)
private void IEngineControllerUser.CancelInvoke(Action action)
}
public MiniCopterAnimation : MonoBehaviour {
public void UpdateRotorSpeed(float newSpeed)
private void Update()
}
public MiniCopterSounds : MonoBehaviour {
public MiniCopter miniCopter
public GameObject soundAttachPoint
public SoundDefinition engineStartDef
public SoundDefinition engineLoopDef
public SoundDefinition engineStopDef
public SoundDefinition rotorLoopDef
public float engineStartFadeOutTime
public float engineLoopFadeInTime
public float engineLoopFadeOutTime
public float engineStopFadeOutTime
public float rotorLoopFadeInTime
public float rotorLoopFadeOutTime
public float enginePitchInterpRate
public float rotorPitchInterpRate
public float rotorGainInterpRate
public float rotorStartStopPitchRateUp
public float rotorStartStopPitchRateDown
public float rotorStartStopGainRateUp
public float rotorStartStopGainRateDown
public AnimationCurve engineUpDotPitchCurve
public AnimationCurve rotorUpDotPitchCurve
}
public MiningQuarry : BaseResourceExtractor {
public Animator beltAnimator
public Renderer beltScrollRenderer
public int scrollMatIndex
public SoundPlayer[] onSounds
public float processRate
public float workToAdd
public GameObjectRef bucketDropEffect
public GameObject bucketDropTransform
public ChildPrefab engineSwitchPrefab
public ChildPrefab hopperPrefab
public ChildPrefab fuelStoragePrefab
public QuarryType staticType
public bool isStatic
public ResourceDeposit _linkedDeposit
public bool IsEngineOn()
public void SetOn(bool isOn)
public void EngineSwitch(bool isOn)
public void ServerInit()
public void UpdateStaticDeposit()
public void PostServerLoad()
public void SpawnChildEntities()
public void ProcessResources()
public bool FuelCheck()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void Update()
}
public MinMax : object {
public float x
public float y
public void .ctor(float x, float y)
public float Random()
public float Lerp(float t)
public float Lerp(float a, float b, float t)
}
public MinMaxAttribute : PropertyAttribute {
public float min
public float max
public void .ctor(float min, float max)
}
public MixerSnapshotManager : SingletonComponent`1<MixerSnapshotManager> {
public AudioMixerSnapshot defaultSnapshot
public AudioMixerSnapshot underwaterSnapshot
public AudioMixerSnapshot loadingSnapshot
public AudioMixerSnapshot woundedSnapshot
public AudioMixerSnapshot cctvSnapshot
public SoundDefinition underwaterInSound
public SoundDefinition underwaterOutSound
public AudioMixerSnapshot recordingSnapshot
public SoundDefinition woundedLoop
private Sound woundedLoopSound
public SoundDefinition cctvModeLoopDef
private Sound cctvModeLoop
public SoundDefinition cctvModeStartDef
public SoundDefinition cctvModeStopDef
}
public MixingTable : StorageContainer {
public GameObject Particles
public RecipeList Recipes
public bool OnlyAcceptValidIngredients
private float <RemainingMixTime>k__BackingField
private float <TotalMixTime>k__BackingField
public float lastTickTimestamp
private List`1<Item> inventoryItems
private float mixTickInterval
public Recipe currentRecipe
public int currentQuantity
public ItemDefinition currentProductionItem
public float RemainingMixTime
public float TotalMixTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float get_RemainingMixTime()
public void set_RemainingMixTime(float value)
public float get_TotalMixTime()
public void set_TotalMixTime(float value)
public void ServerInit()
private bool CanAcceptItem(Item item, int targetSlot)
protected void OnInventoryDirty()
private void SVSwitch(RPCMessage msg)
public void StartMixing(BasePlayer player)
public void StopMixing()
public void TickMix()
public void ProduceItem(Recipe recipe, int quantity)
private void ConsumeInventory(Recipe recipe, int quantity)
private void ReturnExcessItems(List`1<Item> orderedContainerItems, BasePlayer player)
private void CreateRecipeItems(Recipe recipe, int quantity)
public void Save(SaveInfo info)
private int GetItemWaterAmount(Item item)
public void Load(LoadInfo info)
public List`1<Item> GetOrderedContainerItems(ItemContainer container)
}
public MobileMapMarker : MapMarker {
private GameObject createdMarker
}
public Model : MonoBehaviour {
public SphereCollider collision
public Transform rootBone
public Transform headBone
public Transform eyeBone
public Animator animator
public Skeleton skeleton
public Transform[] boneTransforms
public String[] boneNames
internal BoneDictionary boneDict
internal int skin
protected void OnEnable()
public void BuildBoneDictionary()
public int GetSkin()
private Transform FindBoneInternal(string name)
public Transform FindBone(string name)
public Transform FindBone(int hash)
public Transform[] GetBones()
public Transform FindClosestBone(Vector3 worldPos)
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public ModelConditionTest : PrefabAttribute {
public bool DoTest(BaseEntity ent)
protected Type GetIndexedType()
}
public ModelConditionTest_False : ModelConditionTest {
public ConditionalModel reference
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_FoundationSide : ModelConditionTest {
private string square_south
private string square_north
private string square_west
private string square_east
private string triangle_south
private string triangle_northwest
private string triangle_northeast
private string socket
protected void OnDrawGizmosSelected()
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RampHigh : ModelConditionTest {
private string socket
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RampLow : ModelConditionTest {
private string socket
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofBottom : ModelConditionTest {
private string roof_square
private string roof_triangle
private string socket_bot_right
private string socket_bot_left
private string socket_top_right
private string socket_top_left
private String[] sockets_bot_right
private String[] sockets_bot_left
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofLeft : ModelConditionTest {
public AngleType angle
public ShapeType shape
private string roof_square
private string roof_triangle
private string socket_right
private string socket_left
private String[] sockets_left
private bool IsConvex
private bool IsConcave
private bool get_IsConvex()
private bool get_IsConcave()
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofRight : ModelConditionTest {
public AngleType angle
public ShapeType shape
private string roof_square
private string roof_triangle
private string socket_right
private string socket_left
private String[] sockets_right
private bool IsConvex
private bool IsConcave
private bool get_IsConvex()
private bool get_IsConcave()
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofTop : ModelConditionTest {
private string roof_square
private string roof_triangle
private string socket_bot_right
private string socket_bot_left
private string socket_top_right
private string socket_top_left
private String[] sockets_top_right
private String[] sockets_top_left
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_RoofTriangle : ModelConditionTest {
private string socket
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_SpiralStairs : ModelConditionTest {
private string stairs_socket_female
private String[] stairs_sockets_female
private string floor_socket_female
private String[] floor_sockets_female
protected void OnDrawGizmosSelected()
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_True : ModelConditionTest {
public ConditionalModel reference
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_Wall : ModelConditionTest {
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallCornerLeft : ModelConditionTest {
private string socket
private String[] sockets
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallCornerRight : ModelConditionTest {
private string socket
private String[] sockets
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallTriangleLeft : ModelConditionTest {
private string socket_1
private string socket_2
private string socket_3
private string socket_4
private string socket_5
private string socket_6
private string socket
public bool CheckCondition(BaseEntity ent)
private bool CheckSocketOccupied(BaseEntity ent, string socket)
public bool DoTest(BaseEntity ent)
}
public ModelConditionTest_WallTriangleRight : ModelConditionTest {
private string socket_1
private string socket_2
private string socket_3
private string socket_4
private string socket_5
private string socket_6
private string socket
public bool CheckCondition(BaseEntity ent)
private bool CheckSocketOccupied(BaseEntity ent, string socket)
public bool DoTest(BaseEntity ent)
}
public Modifier : object {
private ModifierType <Type>k__BackingField
private ModifierSource <Source>k__BackingField
private float <Value>k__BackingField
private float <Duration>k__BackingField
private float <TimeRemaining>k__BackingField
private bool <Expired>k__BackingField
public ModifierType Type
public ModifierSource Source
public float Value
public float Duration
public float TimeRemaining
public bool Expired
public ModifierType get_Type()
private void set_Type(ModifierType value)
public ModifierSource get_Source()
private void set_Source(ModifierSource value)
public float get_Value()
private void set_Value(float value)
public float get_Duration()
private void set_Duration(float value)
public float get_TimeRemaining()
private void set_TimeRemaining(float value)
public bool get_Expired()
private void set_Expired(bool value)
public void Init(ModifierType type, ModifierSource source, float value, float duration, float remaining)
public void Tick(BaseCombatEntity ownerEntity, float delta)
public Modifier Save()
public void Load(Modifier m)
}
public ModifierDefintion : object {
public ModifierType type
public ModifierSource source
public float value
public float duration
}
public ModularCar : BaseModularVehicle {
public HashSet`1<ModularCar> allCarsList
public ListDictionary`2<BaseMountable, DriverSeatInputs> driverSeatInputs
public ModularCarPhysics carPhysics
public VehicleTerrainHandler serverTerrainHandler
private float MIN_TIME_BETWEEN_COLLISION_FX
private float MIN_COLLISION_FORCE
private float MAX_COLLISION_FORCE
public float nextCollisionFXTime
private float MIN_TIME_BETWEEN_COLLISION_DAMAGE
private float MIN_COLLISION_DAMAGE
private float MAX_COLLISION_DAMAGE
public float nextCollisionDamageTime
public float lastEngineOnTime
private float DECAY_TICK_TIME
private float INSIDE_DECAY_MULTIPLIER
private float CORPSE_DECAY_MINUTES
public Vector3 prevPosition
public Quaternion prevRotation
public float deathDamageCounter
private float DAMAGE_TO_GIB
public TimeSince timeSinceDeath
private float IMMUNE_TIME
public Dictionary`2<BaseEntity, float> damageSinceLastTick
public Vector3 groundedCOMMultiplier
public Vector3 airbourneCOMMultiplier
public Vector3 prevCOMMultiplier
public ModularCarChassisVisuals chassisVisuals
public Wheel wheelFL
public Wheel wheelFR
public Wheel wheelRL
public Wheel wheelRR
public ItemDefinition carKeyDefinition
public ModularCarSettings carSettings
public float hurtTriggerMinSpeed
public TriggerHurtNotChild hurtTriggerFront
public TriggerHurtNotChild hurtTriggerRear
public ProtectionProperties immortalProtection
public ProtectionProperties mortalProtection
public SpawnSettings spawnSettings
public GameObjectRef fuelStoragePrefab
public Transform fuelStoragePoint
public ModularCarAudio carAudio
public GameObjectRef collisionEffect
public MeshRenderer[] damageShowingRenderers
public float population
public float outsidedecayminutes
public BUTTON MouseSteerButton
public BUTTON RapidSteerButton
public ModularCarLock carLock
public VehicleEngineController engineController
public EngineState lastSetEngineState
public EntityFuelSystem fuelSystem
public float cachedFuelFraction
public Surface OnSurface
public float DriveWheelVelocity
public float DriveWheelSlip
public float SteerAngle
public ItemDefinition AssociatedItemDef
public float MaxSteerAngle
public bool IsLockable
public EngineState CurEngineState
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Surface get_OnSurface()
public void OnCollisionEnter(Collision collision)
public void ServerInit()
public void DoServerDestroy()
public void PostServerLoad()
public float GetPlayerDamageMultiplier()
public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
public float GetComfort()
public float GetSteerInput()
public bool GetSteerModInput()
public void VehicleFixedUpdate()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public void SpawnSubEntities()
public void Save(SaveInfo info)
public void Hurt(HitInfo info)
public int TryUseFuel(float seconds, float fuelUsedPerSecond)
public bool MountEligable(BasePlayer player)
public bool IsComplete()
public void DoDecayDamage(float damage)
public float GetSteering(BasePlayer player)
public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
public bool HasAnyEngines()
public bool HasAnyWorkingEngines()
public bool CanRunEngines()
public void OnEngineStartFailed()
public bool AdminFixUp(int tier)
public void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info)
public void PropagateDamageToModules(HitInfo info, float minPropagationPercent, float maxPropagationPercent, BaseVehicleModule ignoreModule)
public void ModuleReachedZeroHealth()
public void OnKilled(HitInfo info)
public void RemoveLock()
public void RestoreVelocity(Vector3 vel)
public void DoPushAction(BasePlayer player)
public Vector3 GetCOMMultiplier()
public void UpdateNetwork()
public void DecayTick()
public void ProcessCollision(Collision collision)
public float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude)
public void DoCollisionDamage(BaseEntity hitEntity, float damage)
public void ShowCollisionFX(Collision collision)
public void SpawnPreassignedModules()
public void RPC_OpenFuel(RPCMessage msg)
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public float get_DriveWheelVelocity()
public float get_DriveWheelSlip()
public float get_SteerAngle()
public ItemDefinition get_AssociatedItemDef()
public float get_MaxSteerAngle()
public bool get_IsLockable()
public EngineState get_CurEngineState()
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void InitShared()
public float MaxHealth()
public float StartHealth()
public float TotalHealth()
public float TotalMaxHealth()
public float GetMaxForwardSpeed()
public void Load(LoadInfo info)
public void OnFlagsChanged(Flags old, Flags next)
public float GetThrottleInput()
public float GetBrakeInput()
public float GetMaxDriveForce()
public float GetFuelFraction()
public bool PlayerHasUnlockPermission(BasePlayer player)
public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)
public bool CanBeLooted(BasePlayer player)
public bool CanPushNow(BasePlayer pusher)
public bool RefreshEngineState()
public float RollOffDriveForce(float driveForce)
public void RefreshChassisProtectionState()
public void ModuleEntityAdded(BaseVehicleModule addedModule)
public void ModuleEntityRemoved(BaseVehicleModule removedModule)
private void IEngineControllerUser.Invoke(Action action, float time)
private void IEngineControllerUser.CancelInvoke(Action action)
}
public ModularCarCentralLockingSwitch : VehicleModuleButtonComponent {
public Transform centralLockingSwitch
public Vector3 switchOffPos
public Vector3 switchOnPos
public void ServerUse(BasePlayer player, BaseVehicleModule parentModule)
}
public ModularCarGarage : ContainerIOEntity {
public ModularCar lockedOccupant
public HashSet`1<BasePlayer> lootingPlayers
public MagnetSnap magnetSnap
public Transform vehicleLift
public Animation vehicleLiftAnim
private string animName
public VehicleLiftOccupantTrigger occupantTrigger
public float liftMoveTime
public EmissionToggle poweredLight
public EmissionToggle inUseLight
public Transform vehicleLiftPos
public float recycleEfficiency
public Transform recycleDropPos
public bool needsElectricity
private SoundDefinition liftStartSoundDef
private SoundDefinition liftStopSoundDef
private SoundDefinition liftStopDownSoundDef
private SoundDefinition liftLoopSoundDef
public SoundDefinition liftOpenSoundDef
public SoundDefinition liftCloseSoundDef
public ChassisBuildOption[] chassisBuildOptions
public ItemAmount lockResourceCost
public ItemDefinition carKeyDefinition
private bool <PlatformIsOccupied>k__BackingField
private bool <HasEditableOccupant>k__BackingField
private bool <HasDriveableOccupant>k__BackingField
private OccupantLock <OccupantLockState>k__BackingField
private int <OccupantLockID>k__BackingField
public VehicleLiftState vehicleLiftState
private Sound liftLoopSound
public Vector3 downPos
public Flags DestroyingChassis
public float TimeToDestroyChassis
public ModularCar carOccupant
public bool HasOccupant
public bool PlatformIsOccupied
public bool HasEditableOccupant
public bool HasDriveableOccupant
public OccupantLock OccupantLockState
public int OccupantLockID
public bool LiftIsUp
public bool LiftIsMoving
public bool LiftIsDown
public bool IsDestroyingChassis
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ModularCar get_carOccupant()
public bool get_HasOccupant()
public void FixedUpdate()
internal void DoServerDestroy()
public void ServerInit()
public void Save(SaveInfo info)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public void IOStateChanged(int inputAmount, int inputSlot)
public bool TryGetModuleForItem(Item item, BaseVehicleModule& result)
public void RefreshOnOffState()
public void UpdateCarOccupant()
public void UpdateOccupantMode()
public void WakeNearbyRigidbodies()
public void EditableOccupantEntered()
public void EditableOccupantLeft()
public void RefreshLoot()
public void GrabOccupant(ModularCar occupant)
public void ReleaseOccupant()
public void StopChassisDestroy()
public void RPC_RepairItem(RPCMessage msg)
public void RPC_OpenEditing(RPCMessage msg)
public void RPC_SelectedLootItem(RPCMessage msg)
public void RPC_DeselectedLootItem(RPCMessage msg)
public void RPC_RequestAddLock(RPCMessage msg)
public void RPC_RequestRemoveLock(RPCMessage msg)
public void RPC_RequestCarKey(RPCMessage msg)
public void RPC_StartDestroyingChassis(RPCMessage msg)
public void RPC_StopDestroyingChassis(RPCMessage msg)
public void FinishDestroyingChassis()
public bool get_PlatformIsOccupied()
public void set_PlatformIsOccupied(bool value)
public bool get_HasEditableOccupant()
public void set_HasEditableOccupant(bool value)
public bool get_HasDriveableOccupant()
public void set_HasDriveableOccupant(bool value)
public OccupantLock get_OccupantLockState()
public void set_OccupantLockState(OccupantLock value)
public int get_OccupantLockID()
public void set_OccupantLockID(int value)
public bool get_LiftIsUp()
public bool get_LiftIsMoving()
public bool get_LiftIsDown()
public bool get_IsDestroyingChassis()
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void OnFlagsChanged(Flags old, Flags next)
public bool CanBeLooted(BasePlayer player)
public int ConsumptionAmount()
public void SetOccupantState(bool hasOccupant, bool editableOccupant, bool driveableOccupant, OccupantLock occupantLockState, int occupantLockID, bool forced)
public void RefreshLiftState(bool forced)
public void MoveLift(VehicleLiftState desiredLiftState, float startDelay, bool forced)
public void MoveLiftUp()
public void MoveLiftDown()
}
public ModularCarLock : object {
private bool isServer
public ModularCar owner
public int LockID
public Flags FLAG_CENTRAL_LOCKING
public float LOCK_DESTROY_HEALTH
public bool HasALock
public bool IsLocked
public bool CentralLockingIsOn
public bool get_HasALock()
public bool get_IsLocked()
public bool get_CentralLockingIsOn()
public void .ctor(ModularCar owner, bool isServer)
public bool PlayerHasUnlockPermission(BasePlayer player)
public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
public bool PlayerCanDestroyLock(BaseVehicleModule viaModule)
public bool KeyCanUnlockThis(Item key)
public bool CanHaveALock()
public void AddALock()
public void RemoveLock()
public void EnableCentralLockingIfNoDriver()
public void ToggleCentralLocking()
public bool CanCraftAKey(BasePlayer player, bool free)
public bool TryCraftAKey(BasePlayer player, bool free)
private bool <PlayerHasUnlockPermission>b__13_0(Item key)
}
public ModularCarPresetConfig : ScriptableObject {
public ItemModVehicleModule[] socketItemDefs
}
public ModularCarSeat : BaseVehicleSeat {
private bool supportsMouseSteer
public Vector3 leftFootIKPos
public Vector3 rightFootIKPos
public VehicleModuleSeating associatedSeatingModule
public bool CanSwapToThis(BasePlayer player)
}
public ModularVehicleShopFront : ShopFront {
public float maxUseDistance
public bool CanBeLooted(BasePlayer player)
public bool WithinUseDistance(BasePlayer player)
}
public Monument : TerrainPlacement {
public float Radius
public float Fade
protected void OnDrawGizmosSelected()
protected void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
}
public MonumentBenchmarkScene : BenchmarkScene {
public String[] monumentPrefabs
public Transform[] vantagePoints
}
public MonumentInfo : LandmarkInfo {
public MonumentType Type
public MonumentTier Tier
public int MinWorldSize
public int MinDistance
public Bounds Bounds
public bool HasNavmesh
public bool IsSafeZone
public bool WantsDungeonLink
public bool HasDungeonLink
public DungeonInfo DungeonEntrance
protected void Awake()
public bool CheckPlacement(Vector3 pos, Quaternion rot, Vector3 scale)
public float Distance(Vector3 position)
public bool IsInBounds(Vector3 position)
public Vector3 ClosestPointOnBounds(Vector3 position)
public Point GetPathFinderPoint(int res)
public int GetPathFinderRadius(int res)
protected void OnDrawGizmosSelected()
public MonumentNavMesh GetMonumentNavMesh()
public int TierToMask(MonumentTier tier)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
private DungeonInfo FindDungeonEntrance()
private bool DetermineHasDungeonLink()
private bool DetermineWantsDungeonLink()
}
public MonumentMarker : MonoBehaviour {
public Text text
public Image imageBackground
public Image image
public Color dayColor
public Color nightColor
public void Setup(LandmarkInfo info)
public void SetNightMode(bool nightMode)
}
public MonumentNavMesh : FacepunchBehaviour {
public int NavMeshAgentTypeIndex
public string DefaultAreaName
public int CellCount
public int CellSize
public int Height
public float NavmeshResolutionModifier
public bool overrideAutoBounds
public Bounds Bounds
public NavMeshData NavMeshData
public NavMeshDataInstance NavMeshDataInstance
public LayerMask LayerMask
public NavMeshCollectGeometry NavMeshCollectGeometry
public bool use_baked_terrain_mesh
private List`1<NavMeshBuildSource> sources
private AsyncOperation BuildingOperation
private bool HasBuildOperationStarted
private Stopwatch BuildTimer
private int defaultArea
private int agentTypeId
public bool IsBuilding
public bool get_IsBuilding()
private void OnEnable()
private void OnDisable()
public void UpdateNavMeshAsync()
public IEnumerator UpdateNavMeshAndWait()
public void NotifyInformationZonesOfCompletion()
private void AppendModifierVolumes(List`1<NavMeshBuildSource> sources)
public void FinishBuildingNavmesh()
public void OnDrawGizmosSelected()
}
public MonumentNode : MonoBehaviour {
public string ResourceFolder
protected void Awake()
public void Process(UInt32& seed)
}
public MonumentSign : LODComponent {
public float viewDistance
public GameObject uiRoot
public RustText signText
}
public MonumentTier : Enum {
public int value__
public MonumentTier Tier0
public MonumentTier Tier1
public MonumentTier Tier2
}
public MonumentType : Enum {
public int value__
public MonumentType Cave
public MonumentType Airport
public MonumentType Building
public MonumentType Town
public MonumentType Radtown
public MonumentType Lighthouse
public MonumentType WaterWell
public MonumentType Roadside
}
public MortarFirework : RepeatingFirework {
public GameObjectRef[] shellTypes
public Transform emissionPoint
}
public MotorRowboat : BaseBoat {
public BlendedSoundLoops engineLoops
public BlendedSoundLoops waterLoops
public SoundDefinition engineStartSoundDef
public SoundDefinition engineStopSoundDef
public SoundDefinition movementSplashAccentSoundDef
public SoundDefinition engineSteerSoundDef
public GameObjectRef pushLandEffect
public GameObjectRef pushWaterEffect
public float waterSpeedDivisor
public float turnPitchModScale
public float tiltPitchModScale
public float splashAccentFrequencyMin
public float splashAccentFrequencyMax
protected Flags Flag_EngineOn
protected Flags Flag_ThrottleOn
protected Flags Flag_TurnLeft
protected Flags Flag_TurnRight
protected Flags Flag_Submerged
protected Flags Flag_HasFuel
protected Flags Flag_RecentlyPushed
public float submergeFractionMinimum
public GameObjectRef fuelStoragePrefab
public Transform fuelStoragePoint
public float fuelPerSec
public GameObjectRef storageUnitPrefab
public Transform storageUnitPoint
public EntityRef storageUnitInstance
public Transform boatRear
public ParticleSystemContainer wakeEffect
public ParticleSystemContainer engineEffectIdle
public ParticleSystemContainer engineEffectThrottle
public Projector causticsProjector
public Transform causticsDepthTest
public Transform engineLeftHandPosition
public Transform engineRotate
public Transform propellerRotate
public float population
public float outsidedecayminutes
public float deepwaterdecayminutes
public EntityFuelSystem fuelSystem
public TimeSince timeSinceLastUsedFuel
public Transform[] stationaryDismounts
public Collider mainCollider
public float angularDragBase
public float angularDragVelocity
public float landDrag
public float waterDrag
public float offAxisDrag
public float offAxisDot
private float DECAY_TICK_TIME
public float lastHadDriverTime
public bool dying
public float maxVelForStationaryDismount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void InitShared()
public void ServerInit()
public EntityFuelSystem GetFuelSystem()
public int StartingFuelUnits()
public void SpawnSubEntities()
public void BoatDecay()
public void DoPushAction(BasePlayer player)
public void RPC_OpenFuel(RPCMessage msg)
public void RPC_EngineToggle(RPCMessage msg)
public void EngineToggle(bool wantsOn)
public void PostServerLoad()
public void CheckInvalidBoat()
public void PlayerServerInput(InputState inputState, BasePlayer player)
public float GetSteering(BasePlayer player)
public bool EngineOn()
public float TimeSinceDriver()
public void DriverInput(InputState inputState, BasePlayer player)
public void VehicleFixedUpdate()
private void SetFlags()
public Vector3 GetLocalVelocityServer()
public void SeatClippedWorld(BaseMountable mountable)
public void UpdateDrag()
public void OnKilled(HitInfo info)
public void ActualDeath()
public bool MountEligable(BasePlayer player)
public bool HasValidDismountPosition(BasePlayer player)
public bool GetDismountPosition(BasePlayer player, Vector3& res)
public void Save(SaveInfo info)
public bool CanPushNow(BasePlayer pusher)
private bool ShowPushMenu(BasePlayer player)
public void Load(LoadInfo info)
}
public MountableParentCombatEntity : BaseCombatEntity {
private BaseMountable mountable
private BaseMountable Mountable
private BaseMountable get_Mountable()
}
public Mountain : TerrainPlacement {
public float Fade
protected void OnDrawGizmosSelected()
protected void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
}
public MoveForward : MonoBehaviour {
public float Speed
protected void Update()
}
public MovementSounds : MonoBehaviour {
public SoundDefinition waterMovementDef
public float waterMovementFadeInSpeed
public float waterMovementFadeOutSpeed
public SoundDefinition enterWaterSmall
public SoundDefinition enterWaterMedium
public SoundDefinition enterWaterLarge
private Sound waterMovement
private Modulator waterGainMod
public bool inWater
public float waterLevel
public bool mute
}
public MovementSoundTrigger : TriggerBase {
public SoundDefinition softSound
public SoundDefinition medSound
public SoundDefinition hardSound
public Collider collider
public void PreClientComponentCull(IPrefabProcessor p)
}
public MoveOverTime : MonoBehaviour {
public float speed
public Vector3 position
public Vector3 rotation
public Vector3 scale
private void Update()
}
public MurmurHash : object {
private UInt32 seed
public int Signed(Stream stream)
public UInt32 Unsigned(Stream stream)
private UInt32 rot(UInt32 x, byte r)
private UInt32 mix(UInt32 h)
}
public MurmurHashEx : object {
public int MurmurHashSigned(string str)
public UInt32 MurmurHashUnsigned(string str)
private MemoryStream StringToStream(string str)
}
public MusicChangeIntensity : MonoBehaviour {
public float raiseTo
public List`1<DistanceIntensity> distanceIntensities
public float tickInterval
}
public MusicClip : ScriptableObject {
public AudioClip audioClip
public int lengthInBars
public int lengthInBarsWithTail
public List`1<float> fadeInPoints
public float GetNextFadeInPoint(float currentClipTimeBars)
}
public MusicClipLoader : object {
public List`1<LoadedAudioClip> loadedClips
public Dictionary`2<AudioClip, LoadedAudioClip> loadedClipDict
public List`1<AudioClip> clipsToLoad
public List`1<AudioClip> clipsToUnload
public void Update()
public void Refresh()
private LoadedAudioClip FindLoadedClip(AudioClip clip)
}
public MusicManager : SingletonComponent`1<MusicManager> {
public AudioMixerGroup mixerGroup
public List`1<MusicTheme> themes
public MusicTheme currentTheme
public List`1<AudioSource> sources
public double nextMusic
public double nextMusicFromIntensityRaise
public float intensity
public Dictionary`2<PositionedClip, ClipPlaybackData> clipPlaybackData
public int holdIntensityUntilBar
public bool musicPlaying
public bool loadingFirstClips
public MusicTheme nextTheme
public double lastClipUpdate
public float clipUpdateInterval
public double themeStartTime
public int lastActiveClipRefresh
public int activeClipRefreshInterval
public bool forceThemeChange
public float randomIntensityJumpChance
public int clipScheduleBarsEarly
public List`1<PositionedClip> activeClips
public List`1<PositionedClip> activeMusicClips
public List`1<PositionedClip> activeControlClips
public List`1<MusicZone> currentMusicZones
public int currentBar
public int barOffset
public double currentThemeTime
public int themeBar
public double get_currentThemeTime()
public int get_themeBar()
public void RaiseIntensityTo(float amount, int holdLengthBars)
public void StopMusic()
}
public MusicTheme : ScriptableObject {
public float tempo
public int intensityHoldBars
public int lengthInBars
public bool canPlayInMenus
public ValueRange rain
public ValueRange wind
public ValueRange snow
public Enum biomes
public Enum topologies
public AnimationCurve time
public List`1<PositionedClip> clips
public List`1<Layer> layers
private Dictionary`2<int, List`1<PositionedClip>> activeClips
private List`1<AudioClip> firstAudioClips
private Dictionary`2<AudioClip, bool> audioClipDict
public int layerCount
public int samplesPerBar
public int get_layerCount()
public int get_samplesPerBar()
private void OnValidate()
public List`1<PositionedClip> GetActiveClipsForBar(int bar)
private int ActiveClipCollectionID(int bar)
public Layer LayerById(int id)
public void AddLayer()
private void UpdateLengthInBars()
public bool CanPlayInEnvironment(int currentBiome, int currentTopology, float currentRain, float currentSnow, float currentWind)
public bool FirstClipsLoaded()
public bool ContainsAudioClip(AudioClip clip)
}
public MusicUtil : object {
public float OneSixteenth
public double BeatsToSeconds(float tempo, float beats)
public double BarsToSeconds(float tempo, float bars)
public int SecondsToSamples(double seconds)
public int SecondsToSamples(double seconds, int sampleRate)
public int SecondsToSamples(float seconds)
public int SecondsToSamples(float seconds, int sampleRate)
public int BarsToSamples(float tempo, float bars, int sampleRate)
public int BarsToSamples(float tempo, float bars)
public int BeatsToSamples(float tempo, float beats)
public float SecondsToBeats(float tempo, double seconds)
public float SecondsToBars(float tempo, double seconds)
public float Quantize(float position, float gridSize)
public float FlooredQuantize(float position, float gridSize)
}
public MusicZone : MonoBehaviour {
public List`1<MusicTheme> themes
public float priority
public bool suppressAutomaticMusic
}
public Muzzleflash_AlphaRandom : MonoBehaviour {
public ParticleSystem[] muzzleflashParticles
private Gradient grad
private GradientColorKey[] gck
private GradientAlphaKey[] gak
private void Start()
private void OnEnable()
}
public MuzzleFlash_Flamelet : MonoBehaviour {
public ParticleSystem flameletParticle
private void OnEnable()
}
public nametags : ConsoleSystem {
public bool enabled
}
public NativeList`1 : object {
private NativeArray`1<T> _array
private int _length
public NativeArray`1<T> Array
public int Count
public T Item
public NativeArray`1<T> get_Array()
public int get_Count()
public T get_Item(int index)
public void set_Item(int index, T value)
public void Add(T item)
public void Clear()
public void Resize(int count)
public void EnsureCapacity(int requiredCapacity)
public void EnterPool()
public void LeavePool()
}
public NativeNoise : object {
public float Simplex1D(float x)
public float Simplex1D(float x, Single& dx)
public float Simplex2D(float x, float y)
public float Simplex2D(float x, float y, Single& dx, Single& dy)
public float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale)
}
public NaturalBloomAndDirtyLens : MonoBehaviour {
public Shader shader
public Texture2D lensDirtTexture
public float range
public float cutoff
public float bloomIntensity
public float lensDirtIntensity
public float spread
public int iterations
public int mips
public Single[] mipWeights
public bool highPrecision
public bool downscaleSource
public bool debug
public bool temporalFilter
public float temporalFilterWeight
}
public NavMeshTools : object {
public IEnumerator CollectSourcesAsync(Bounds bounds, int mask, NavMeshCollectGeometry geometry, int area, bool useBakedTerrainMesh, int cellSize, List`1<NavMeshBuildSource> sources, Action`1<List`1<NavMeshBuildSource>> append, Action callback)
public IEnumerator CollectSourcesAsync(Transform root, int mask, NavMeshCollectGeometry geometry, int area, List`1<NavMeshBuildSource> sources, Action`1<List`1<NavMeshBuildSource>> append, Action callback)
}
public NeedsCursor : MonoBehaviour {
private void Update()
}
public NeedsMouseWheel : ListComponent`1<NeedsMouseWheel> {
public bool AnyActive()
}
public NeighbourSocket : Socket_Base {
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
}
public NeonMeshPaintableSource : MeshPaintableSource {
public NeonSign neonSign
public float editorEmissionScale
public AnimationCurve lightingCurve
public Color topLeft
public Color topRight
public Color bottomLeft
public Color bottomRight
public void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride, bool forEditing, bool isSelected)
public Color32[] UpdateFrom(Texture2D input)
private Color <UpdateFrom>g__GetColorForRegion|8_0(int x, int y, int regionWidth, int regionHeight, <>c__DisplayClass8_0& )
}
public NeonSign : Signage {
private float FastSpeed
private float MediumSpeed
private float SlowSpeed
private float MinSpeed
private float MaxSpeed
public Light topLeft
public Light topRight
public Light bottomLeft
public Light bottomRight
public float lightIntensity
public int powerConsumption
public Material activeMaterial
public Material inactiveMaterial
public float animationSpeed
public int currentFrame
public List`1<Lights> frameLighting
public bool isAnimating
public Action animationLoopAction
public AmbienceEmitter ambientSoundEmitter
public SoundDefinition switchSoundDef
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int ConsumptionAmount()
public void Load(LoadInfo info)
public void ServerInit()
public void ResetState()
public void UpdateHasPower(int inputAmount, int inputSlot)
private void SwitchToNextFrame()
public void Save(SaveInfo info)
public void SetAnimationSpeed(RPCMessage msg)
public void UpdateNeonColors(RPCMessage msg)
public void EnsureInitialized()
private Color ClampColor(Color color)
}
public Network.Channel.Client : object {
public byte Default
public byte Tick
}
public Network.Channel.Server : object {
public byte Default
public byte Positions
}
public NetworkCryptography : object {
private MemoryStream buffer
public MemoryStream EncryptCopy(Connection connection, MemoryStream stream, int offset)
public MemoryStream DecryptCopy(Connection connection, MemoryStream stream, int offset)
public void Encrypt(Connection connection, MemoryStream stream, int offset)
public void Decrypt(Connection connection, MemoryStream stream, int offset)
public bool IsEnabledIncoming(Connection connection)
public bool IsEnabledOutgoing(Connection connection)
protected void EncryptionHandler(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
protected void DecryptionHandler(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
}
public NetworkCryptographyServer : NetworkCryptography {
protected void EncryptionHandler(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
protected void DecryptionHandler(Connection connection, MemoryStream src, int srcOffset, MemoryStream dst, int dstOffset)
}
public NetworkInfoGeneralText : MonoBehaviour {
public TextMeshProUGUI text
private void Update()
private void UpdateText()
private string ChannelStat(int window, int left)
}
public NetworkSleep : MonoBehaviour {
public int totalBehavioursDisabled
public int totalCollidersDisabled
public Behaviour[] behaviours
public Collider[] colliders
internal int BehavioursDisabled
internal int CollidersDisabled
}
public NetworkVisibilityGrid : MonoBehaviour {
public int startID
public int gridSize
public int cellCount
public int visibilityRadiusFar
public int visibilityRadiusNear
public float switchTolerance
private void Awake()
private void OnDisable()
private void OnDrawGizmosSelected()
private int PositionToGrid(float f)
private float GridToPosition(int i)
public UInt32 CoordToID(int x, int y)
public UInt32 GetID(Vector3 vPos)
public Vector3 GetPosition(UInt32 uid)
public Bounds GetBounds(UInt32 uid)
public float CellSize()
public void OnGroupAdded(Group group)
public bool IsInside(Group group, Vector3 vPos)
public Group GetGroup(Vector3 vPos)
public void GetVisibleFromFar(Group group, List`1<Group> groups)
public void GetVisibleFromNear(Group group, List`1<Group> groups)
private void GetVisibleFrom(Group group, List`1<Group> groups, int radius)
}
public NetworkWriteEx : object {
public void WriteObject(NetWrite write, T obj)
}
public NewsSource : MonoBehaviour {
private Regex BbcodeParse
public RustText title
public RustText date
public RustText authorName
public HttpImage coverImage
public RectTransform container
public Button button
public RustText paragraphTemplate
public HttpImage imageTemplate
public HttpImage youtubeTemplate
private String[] BulletSeparators
public void Awake()
public void OnEnable()
public void SetStory(Story story)
private void ParseBbcode(StringBuilder currentParagraph, string bbcode, String& firstImage, int depth)
private String[] GetBulletPoints(string listContent)
private void AppendParagraph(StringBuilder currentParagraph)
private void AppendImage(StringBuilder currentParagraph, string url)
private void AppendYouTube(StringBuilder currentParagraph, string videoId)
}
public NewYearGong : BaseCombatEntity {
public SoundDefinition gongSound
public float minTimeBetweenSounds
public GameObject soundRoot
public Transform gongCentre
public float gongRadius
public AnimationCurve pitchCurve
public Animator gongAnimator
private float lastSound
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Hurt(HitInfo info)
}
public NGSS_Directional : MonoBehaviour {
public float PCSS_GLOBAL_SOFTNESS
public float PCSS_FILTER_DIR_MIN
public float PCSS_FILTER_DIR_MAX
public float BANDING_NOISE_AMOUNT
public SAMPLER_COUNT SAMPLERS_COUNT
private void Update()
private void SetGlobalSettings(bool enabled)
}
public Noise : object {
public float MIN
public float MAX
public float Simplex1D(float x)
public float Simplex2D(float x, float y)
public float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain)
public float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp)
public float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale)
}
public NoiseParameters : ValueType {
public int Octaves
public float Frequency
public float Amplitude
public float Offset
public void .ctor(int octaves, float frequency, float amplitude, float offset)
}
public NonDrawingGraphic : Graphic {
public void SetMaterialDirty()
public void SetVerticesDirty()
protected void OnPopulateMesh(VertexHelper vh)
}
public note : ConsoleSystem {
public void update(Arg arg)
}
public NoteBindingCollection : ScriptableObject {
public NoteData[] BaseBindings
public float MinimumNoteTime
public float MaximumNoteLength
public bool AllowAutoplay
public float AutoplayLoopDelay
public string NotePlayedStatName
public string KeyMidiMapShortname
public bool AllowSustain
public bool AllowFullKeyboardInput
public string InstrumentShortName
public InstrumentType NotePlayType
public int MaxConcurrentNotes
public bool LoopSounds
public float SoundFadeInTime
public float minimumSoundFadeOutTime
public KeySet PrimaryClickNote
public KeySet SecondaryClickNote
public bool RunInstrumentAnimationController
public bool PlayRepeatAnimations
public float AnimationDeadTime
public float AnimationResetDelay
public float RecentlyPlayedThreshold
public float CrossfadeNormalizedAnimationTarget
public float AnimationCrossfadeDuration
public float CrossfadePlayerSpeedMulti
public int DefaultOctave
public int ShiftedOctave
public bool FindNoteData(Notes note, int octave, NoteType type, NoteData& data, Int32& noteIndex)
public bool FindNoteDataIndex(Notes note, int octave, NoteType type, Int32& noteIndex)
}
public NotePanel : MonoBehaviour {
public InputField input
private Item item
}
public NoticeArea : SingletonComponent`1<NoticeArea> {
public GameObjectRef itemPickupPrefab
public GameObjectRef itemDroppedPrefab
private IVitalNotice[] notices
protected void Awake()
}
public NPCAutoTurret : AutoTurret {
public Transform centerMuzzle
public Transform muzzleLeft
public Transform muzzleRight
private bool useLeftMuzzle
public float sleeperhostiledelay
public void ServerInit()
public bool HasAmmo()
public bool CheckPeekers()
public float TargetScanRate()
public bool InFiringArc(BaseCombatEntity potentialtarget)
public float GetMaxAngleForEngagement()
public bool HasFallbackWeapon()
public Transform GetCenterMuzzle()
public void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target)
protected bool Ignore(BasePlayer player)
public bool IsEntityHostile(BaseCombatEntity ent)
}
public NPCBarricadeTriggerBox : MonoBehaviour {
private Barricade target
private int playerServerLayer
public void Setup(Barricade t)
private void OnTriggerEnter(Collider other)
}
public NPCDoorTriggerBox : MonoBehaviour {
private Door door
private int playerServerLayer
public void Setup(Door d)
private void OnTriggerEnter(Collider other)
}
public NPCDwelling : BaseEntity {
public NPCSpawner npcSpawner
public SpawnGroup[] spawnGroups
public AIMovePoint[] movePoints
public AICoverPoint[] coverPoints
public void ServerInit()
public void DestroyShared()
public bool ValidateAIPoint(Vector3 pos)
public void UpdateInformationZone(bool remove)
public void CheckDespawn()
public void CleanupSpawned()
public bool PlayersNearby()
public float TimeoutPlayerCheckRadius()
}
public NPCFootstepEffects : BaseFootstepEffect {
public string impactEffectDirectory
public Transform frontLeftFoot
public Transform frontRightFoot
public Transform backLeftFoot
public Transform backRightFoot
}
public NPCHumanContext : BaseNPCContext {
public List`1<BaseChair> Chairs
public BaseChair ChairTarget
private CoverPointVolume <CurrentCoverVolume>k__BackingField
private List`1<CoverPoint> <sampledCoverPoints>k__BackingField
private List`1<CoverType> <sampledCoverPointTypes>k__BackingField
private List`1<CoverPoint> <EnemyCoverPoints>k__BackingField
private CoverPoint <EnemyHideoutGuess>k__BackingField
private List`1<HideoutPoint> <CheckedHideoutPoints>k__BackingField
private PathInterestNode <CurrentPatrolPoint>k__BackingField
public float LastNavigationTime
public TacticalCoverPointSet CoverSet
public BaseEntity LastAttacker
public CoverPointVolume CurrentCoverVolume
public List`1<CoverPoint> sampledCoverPoints
public List`1<CoverType> sampledCoverPointTypes
public List`1<CoverPoint> EnemyCoverPoints
public CoverPoint EnemyHideoutGuess
public List`1<HideoutPoint> CheckedHideoutPoints
public PathInterestNode CurrentPatrolPoint
public BaseEntity get_LastAttacker()
public void set_LastAttacker(BaseEntity value)
public CoverPointVolume get_CurrentCoverVolume()
public void set_CurrentCoverVolume(CoverPointVolume value)
public List`1<CoverPoint> get_sampledCoverPoints()
private void set_sampledCoverPoints(List`1<CoverPoint> value)
public List`1<CoverType> get_sampledCoverPointTypes()
private void set_sampledCoverPointTypes(List`1<CoverType> value)
public List`1<CoverPoint> get_EnemyCoverPoints()
private void set_EnemyCoverPoints(List`1<CoverPoint> value)
public CoverPoint get_EnemyHideoutGuess()
public void set_EnemyHideoutGuess(CoverPoint value)
public List`1<HideoutPoint> get_CheckedHideoutPoints()
public void set_CheckedHideoutPoints(List`1<HideoutPoint> value)
public PathInterestNode get_CurrentPatrolPoint()
public void set_CurrentPatrolPoint(PathInterestNode value)
public void .ctor(NPCPlayerApex human)
protected void Finalize()
public void ForgetCheckedHideouts(float forgetTime)
public bool HasCheckedHideout(CoverPoint hideout)
}
public NPCMurderer : NPCPlayerApex {
public LootSpawnSlot[] LootSpawnSlots
public FamilyEnum Family
public string Categorize()
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public FamilyEnum get_Family()
public bool ShouldDropActiveItem()
public BaseCorpse CreateCorpse()
}
public NPCPlayer : BasePlayer {
private bool <AgencyUpdateRequired>k__BackingField
private bool <IsOnOffmeshLinkAndReachedNewCoord>k__BackingField
protected bool _traversingNavMeshLink
protected OffMeshLinkData _currentNavMeshLink
protected string _currentNavMeshLinkName
protected Quaternion _currentNavMeshLinkOrientation
protected Vector3 _currentNavMeshLinkEndPos
public Vector3 finalDestination
private float randomOffset
public Vector3 spawnPos
public PlayerInventoryProperties[] loadouts
public LayerMask movementMask
public NavMeshAgent NavAgent
public float damageScale
private bool _isDormant
public float lastGunShotTime
public float triggerEndTime
public float nextTriggerTime
private float lastThinkTime
private float lastPositionUpdateTime
private float lastMovementTickTime
public Vector3 lastPos
public bool AgencyUpdateRequired
public bool IsOnOffmeshLinkAndReachedNewCoord
public bool IsNpc
public bool IsDormant
protected float PositionTickRate
public bool IsOnNavMeshLink
public bool HasPath
public bool get_AgencyUpdateRequired()
public void set_AgencyUpdateRequired(bool value)
public bool get_IsOnOffmeshLinkAndReachedNewCoord()
public void set_IsOnOffmeshLinkAndReachedNewCoord(bool value)
private void HandleNavMeshLinkTraversal(float delta, Vector3& moveToPosition)
private bool HandleNavMeshLinkTraversalStart(float delta)
private void HandleNavMeshLinkTraversalTick(float delta, Vector3& moveToPosition)
private bool IsNavMeshLinkTraversalComplete(float delta, Vector3& moveToPosition)
private void CompleteNavMeshLink()
public bool get_IsNpc()
public bool get_IsDormant()
public void set_IsDormant(bool value)
protected float get_PositionTickRate()
public bool IsLoadBalanced()
public void ServerInit()
public void ApplyInheritedVelocity(Vector3 velocity)
public void RandomMove()
public void SetDestination(Vector3 newDestination)
public AttackEntity GetAttackEntity()
public BaseProjectile GetGun()
public float AmmoFractionRemaining()
public bool IsReloading()
public void AttemptReload()
public bool ShotTest()
public float GetAimConeScale()
public void CancelBurst(float delay)
public bool MeleeAttack()
public void TriggerDown()
public void EquipWeapon()
public void EquipTest()
internal void ServerThink_Internal()
public void ServerThink(float delta)
public void Resume()
public bool IsNavRunning()
public bool get_IsOnNavMeshLink()
public bool get_HasPath()
public void TickAi(float delta)
public void TickMovement()
public float GetNetworkTime()
public void MovementUpdate(float delta)
private bool ValidateNextPosition(Vector3& moveToPosition)
private void UpdateSpeed(float delta)
protected void UpdatePositionAndRotation(Vector3 moveToPosition)
public Vector3 GetPosition()
public float DesiredMoveSpeed()
public bool EligibleForWounding(HitInfo info)
public Vector3 GetAimDirection()
public void SetAimDirection(Vector3 newAim)
}
public NPCPlayerApex : NPCPlayer {
public AiStatistics Stats
public UtilityAIComponent utilityAiComponent
public bool NewAI
public bool NeverMove
public bool IsMountableAgent
public float WeaponSwitchFrequency
public float ToolSwitchFrequency
public WaypointSet WaypointSet
public Transform[] LookAtInterestPointsStationary
private NPCHumanContext _aiContext
public StateTimer BusyTimer
private float maxFleeTime
private float fleeHealthThresholdPercentage
private float aggroTimeout
private float lastAggroChanceResult
private float lastAggroChanceCalcTime
private float aggroChanceRecalcTimeout
private BaseEntity blockTargetingThisEnemy
public float NextWeaponSwitchTime
public float NextToolSwitchTime
public float NextDetectionCheck
private bool wasAggro
public float TimeLastMoved
public float TimeLastMovedToCover
public float AllyAttackedRecentlyTimeout
public float LastHasEnemyTime
public bool LastDetectionCheckResult
private int <WaypointDirection>k__BackingField
private bool <IsWaitingAtWaypoint>k__BackingField
private int <CurrentWaypointIndex>k__BackingField
private float <WaypointDelayTime>k__BackingField
private Vector3 <SpawnPosition>k__BackingField
private BaseEntity <AttackTarget>k__BackingField
private SeenInfo <AttackTargetMemory>k__BackingField
public Behaviour _currentBehavior
private float <currentBehaviorDuration>k__BackingField
private BaseEntity <FoodTarget>k__BackingField
private float <TargetSpeed>k__BackingField
protected float lastInRangeOfSpawnPositionTime
private Vector3[] pathCornerCache
private NavMeshPath _pathCache
private ActionCallback <OnFleeExplosive>k__BackingField
private ActionCallback <OnTakeCover>k__BackingField
private ActionCallback <OnAggro>k__BackingField
private ActionCallback <OnChatter>k__BackingField
private ActionCallback <OnDeath>k__BackingField
private ActionCallback <OnReload>k__BackingField
private float nextLookAtPointTime
public Transform LookAtPoint
public PlayerEyes LookAtEyes
public float CommunicationRadius
public Byte[] CurrentFacts
public int ForgetUnseenEntityTime
public float SensesTickRate
public float MaxDistanceToCover
public float MinDistanceToRetreatCover
public float VisionRangeScore
public float AggroRangeScore
public float LongRangeScore
public float MediumRangeScore
public float CloseRangeScore
public BaseEntity[] SensesResults
private List`1<NavPointSample> navPointSamples
private CoverPointComparer coverPointComparer
private float lastTickTime
private int sensesTicksPerCoverSweep
private int sensesTicksSinceLastCoverSweep
private float alertness
protected float lastSeenPlayerTime
private bool isAlreadyCheckingPathPending
private int numPathPendingAttempts
private float accumPathPendingDelay
public bool OnlyTargetSensations
private int MaxPlayers
public BasePlayer[] PlayerQueryResults
public int PlayerQueryResultCount
private NavMeshPath PathToPlayerTarget
private PlayerTargetContext _playerTargetContext
public BaseEntity[] EntityQueryResults
public int EntityQueryResultCount
private EntityTargetContext _entityTargetContext
private CoverContext _coverContext
private BaseAiUtilityClient _selectPlayerTargetAI
private BaseAiUtilityClient _selectPlayerTargetMountedAI
private BaseAiUtilityClient _selectEntityTargetAI
private BaseAiUtilityClient _selectCoverTargetsAI
private BaseAiUtilityClient _selectEnemyHideoutAI
public AIStorage SelectPlayerTargetUtility
public AIStorage SelectPlayerTargetMountedUtility
public AIStorage SelectEntityTargetsUtility
public AIStorage SelectCoverTargetsUtility
public AIStorage SelectEnemyHideoutUtility
private float playerTargetDecisionStartTime
private float animalTargetDecisionStartTime
private float nextCoverInfoTick
private float nextCoverPosInfoTick
private float _lastHeardGunshotTime
private Vector3 <LastHeardGunshotDirection>k__BackingField
public Vector2 RadioEffectRepeatRange
public GameObjectRef RadioEffect
public GameObjectRef DeathEffect
public int agentTypeIndex
public float stuckDuration
public float lastStuckTime
public float timeAtDestination
public bool IsInvinsible
public float lastInvinsibleStartTime
public float InvinsibleTime
public string deathStatName
private bool <IsStuck>k__BackingField
private Vector3 lastStuckPos
public float TickRate
public HashSet`1<NPCPlayerApex> AllJunkpileNPCs
public HashSet`1<NPCPlayerApex> AllBanditCampNPCs
private float nextSensorySystemTick
private float nextReasoningSystemTick
private float attackTargetVisibleFor
private BaseEntity lastAttackTarget
public NPCHumanContext AiContext
public float TimeAtDestination
public int WaypointDirection
public bool IsWaitingAtWaypoint
public int CurrentWaypointIndex
public float WaypointDelayTime
public Vector3 Destination
public float StoppingDistance
public float SqrStoppingDistance
public bool IsStopped
public bool AutoBraking
public Vector3 SpawnPosition
public float AttackTargetVisibleFor
public BaseEntity AttackTarget
public SeenInfo AttackTargetMemory
public BaseCombatEntity CombatTarget
public Vector3 AttackPosition
public Vector3 CrouchedAttackPosition
public Behaviour CurrentBehaviour
public float currentBehaviorDuration
public BaseCombatEntity Entity
public NavMeshAgent GetNavAgent
public AiStatistics GetStats
public float GetAttackRate
public float GetAttackRange
public Vector3 GetAttackOffset
public Vector3 CurrentAimAngles
public float GetStamina
public float GetEnergy
public float GetAttackCost
public float GetSleep
public float GetStuckDuration
public float GetLastStuckTime
public BaseEntity FoodTarget
public float TargetSpeed
public float SecondsSinceLastInRangeOfSpawnPosition
public ActionCallback OnFleeExplosive
public ActionCallback OnTakeCover
public ActionCallback OnAggro
public ActionCallback OnChatter
public ActionCallback OnDeath
public ActionCallback OnReload
public float SecondsSinceSeenPlayer
private PlayerTargetContext PlayerTargetContext
private EntityTargetContext EntityTargetContext
private CoverContext CoverContext
private BaseAiUtilityClient SelectPlayerTargetAI
private BaseAiUtilityClient SelectPlayerTargetMountedAI
private BaseAiUtilityClient SelectEntityTargetAI
private BaseAiUtilityClient SelectCoverTargetsAI
private BaseAiUtilityClient SelectEnemyHideoutAI
public float SecondsSinceLastHeardGunshot
public Vector3 LastHeardGunshotDirection
public FamilyEnum Family
public int AgentTypeIndex
public bool IsStuck
public bool IsDormant
private bool Apex.LoadBalancing.ILoadBalanced.repeat
public NPCHumanContext get_AiContext()
protected void SetupAiContext()
public IAIContext GetContext(Guid aiId)
public float get_TimeAtDestination()
public int get_WaypointDirection()
public void set_WaypointDirection(int value)
public bool get_IsWaitingAtWaypoint()
public void set_IsWaitingAtWaypoint(bool value)
public int get_CurrentWaypointIndex()
public void set_CurrentWaypointIndex(int value)
public float get_WaypointDelayTime()
public void set_WaypointDelayTime(float value)
public Vector3 get_Destination()
public void set_Destination(Vector3 value)
public float get_StoppingDistance()
public void set_StoppingDistance(float value)
public float get_SqrStoppingDistance()
public bool get_IsStopped()
public void set_IsStopped(bool value)
public bool get_AutoBraking()
public void set_AutoBraking(bool value)
public bool IsNavRunning()
public void Pause()
public void Resume()
public void Mount(BaseMountable mountable)
public void Dismount()
public void DismountObject()
private IEnumerator TryForceToNavmesh()
public Vector3 get_SpawnPosition()
public void set_SpawnPosition(Vector3 value)
public float get_AttackTargetVisibleFor()
public BaseEntity get_AttackTarget()
public void set_AttackTarget(BaseEntity value)
public SeenInfo get_AttackTargetMemory()
public void set_AttackTargetMemory(SeenInfo value)
public BaseCombatEntity get_CombatTarget()
public Vector3 get_AttackPosition()
public Vector3 get_CrouchedAttackPosition()
public float FearLevel(BaseEntity ent)
public Behaviour get_CurrentBehaviour()
public void set_CurrentBehaviour(Behaviour value)
public float get_currentBehaviorDuration()
public void set_currentBehaviorDuration(float value)
public BaseCombatEntity get_Entity()
public NavMeshAgent get_GetNavAgent()
public float GetWantsToAttack(BaseEntity target)
public AiStatistics get_GetStats()
public float get_GetAttackRate()
public float get_GetAttackRange()
public Vector3 get_GetAttackOffset()
public Vector3 get_CurrentAimAngles()
public float get_GetStamina()
public float get_GetEnergy()
public float get_GetAttackCost()
public float get_GetSleep()
public float get_GetStuckDuration()
public float get_GetLastStuckTime()
public bool BusyTimerActive()
public void SetBusyFor(float dur)
public bool WantsToEat(BaseEntity ent)
public BaseEntity get_FoodTarget()
public void set_FoodTarget(BaseEntity value)
public void Eat()
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public float ToSpeed(SpeedEnum speed)
public float get_TargetSpeed()
public void set_TargetSpeed(float value)
public List`1<NavPointSample> RequestNavPointSamplesInCircle(SampleCount sampleCount, float radius, SampleFeatures features)
public List`1<NavPointSample> RequestNavPointSamplesInCircleWaterDepthOnly(SampleCount sampleCount, float radius, float waterDepth)
private void OnFactChanged(Facts fact, byte oldValue, byte newValue)
private void TickBehaviourState()
public bool TryAggro(float sqrRange)
public bool TryAggro(EnemyRangeEnum range)
public bool StartAggro(float timeout, bool broadcastEvent)
private void TickAggro()
private bool CheckHealthThresholdToFlee()
private void WantsToFlee()
private void TickFlee()
public float get_SecondsSinceLastInRangeOfSpawnPosition()
private void FindCoverFromEnemy()
private void FindCoverFromPosition(Vector3 position)
public bool PathDistanceIsValid(Vector3 from, Vector3 to, bool allowCloseRange)
private float PathDistance(int count, Vector3[]& path, float maxDistance)
private void FindClosestCoverToUs()
public ActionCallback get_OnFleeExplosive()
public void set_OnFleeExplosive(ActionCallback value)
public ActionCallback get_OnTakeCover()
public void set_OnTakeCover(ActionCallback value)
public ActionCallback get_OnAggro()
public void set_OnAggro(ActionCallback value)
public ActionCallback get_OnChatter()
public void set_OnChatter(ActionCallback value)
public ActionCallback get_OnDeath()
public void set_OnDeath(ActionCallback value)
public ActionCallback get_OnReload()
public void set_OnReload(ActionCallback value)
public int PeekNextWaypointIndex()
public int GetNextWaypointIndex()
public Transform GetLookatPointFromWaypoints()
private Transform GetLookatPoint(Transform[]& points)
public void LookAtRandomPoint(float nextTimeAddition)
public int TopologyPreference()
public bool IsInCommunicationRange(NPCPlayerApex npc)
public int GetAlliesInRange(List`1& allies)
public void SendStatement(AiStatement_EnemyEngaged statement)
public void SendStatement(AiStatement_EnemySeen statement)
public void OnAiStatement(NPCPlayerApex source, AiStatement_EnemyEngaged statement)
public void OnAiStatement(NPCPlayerApex source, AiStatement_EnemySeen statement)
public int AskQuestion(AiQuestion_ShareEnemyTarget question, List`1& answers)
public AiAnswer_ShareEnemyTarget OnAiQuestion(NPCPlayerApex source, AiQuestion_ShareEnemyTarget question)
public void InitFacts()
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
public EnemyRangeEnum ToEnemyRangeEnum(float sqrRange)
public EnemyEngagementRangeEnum ToEnemyEngagementRangeEnum(float sqrRange)
public float ToSqrRange(EnemyRangeEnum range)
public float ToSqrRange(EnemyEngagementRangeEnum range)
public float GetActiveAggressionRangeSqr()
public bool IsWithinAggroRange(EnemyRangeEnum range)
public bool IsWithinAggroRange(float sqrRange)
public bool IsBeyondDeaggroRange(EnemyRangeEnum range)
public AfraidRangeEnum ToAfraidRangeEnum(float sqrRange)
public HealthEnum ToHealthEnum(float healthNormalized)
public SpeedEnum ToSpeedEnum(float speed)
public float ToSpeed(SpeedEnum speed)
public AmmoStateEnum GetCurrentAmmoStateEnum()
public WeaponTypeEnum GetCurrentWeaponTypeEnum()
public WeaponTypeEnum GetWeaponTypeEnum(BaseProjectile proj)
public EnemyRangeEnum WeaponToEnemyRange(WeaponTypeEnum weapon)
public EnemyRangeEnum CurrentWeaponToEnemyRange()
public byte GetPathStatus()
public NavMeshPathStatus ToPathStatus(byte value)
public ToolTypeEnum GetCurrentToolTypeEnum()
public void TickReasoningSystem()
private void _GatherPlayerTargetFacts()
private void _NoEnemyFacts()
private void _UpdateMountedSelfFacts()
private void _UpdateGroundedSelfFacts()
private void _UpdateCoverFacts()
public float get_SecondsSinceSeenPlayer()
private void TickSenses()
public float Distance2DSqr(Vector3 a, Vector3 b)
private void TickVision()
public bool IsVisibleMounted(BasePlayer player)
public bool IsVisibleStanding(BasePlayer player)
public bool IsVisibleCrouched(BasePlayer player)
public bool IsVisibleStanding(BaseNpc npc)
public bool IsVisibleCrouched(BaseNpc npc)
private void FindCoverPoints()
private void TickHearing()
private void TickSmell()
private void TickMountableAwareness()
private void SelectMountable()
private void TargetClosestChair()
private void TickEnemyAwareness()
private void SelectEnemy()
private void AggroClosestPlayerMounted()
private void AggroBestScorePlayerOrClosestAnimal()
protected void SetAttackTarget(BasePlayer player, float score, float sqrDistance, bool lineOfSightStanding, bool lineOfSightCrouched, bool tryAggro)
private float VisibilityScoreModifier(BasePlayer target, Vector3 dir, float dist, bool losStand, bool losCrouch)
public bool HostilityConsideration(BasePlayer target)
private void UpdateMountedSelfFacts()
private void UpdateSelfFacts()
private EnemyRangeEnum GetRangeToSpawnPoint()
private byte IsMoving()
private float NextAttackTime()
public void SetTargetPathStatus(float pendingDelay)
private void DelayedTargetPathStatus()
private bool AiCaresAbout(BaseEntity ent)
private bool AiCaresAboutIgnoreChairs(BaseEntity ent)
private bool WithinVisionCone(NPCPlayerApex npc, BaseEntity other)
private PlayerTargetContext get_PlayerTargetContext()
private EntityTargetContext get_EntityTargetContext()
private CoverContext get_CoverContext()
private BaseAiUtilityClient get_SelectPlayerTargetAI()
private BaseAiUtilityClient get_SelectPlayerTargetMountedAI()
private BaseAiUtilityClient get_SelectEntityTargetAI()
private BaseAiUtilityClient get_SelectCoverTargetsAI()
private BaseAiUtilityClient get_SelectEnemyHideoutAI()
private void ShutdownSensorySystem()
public void TickSensorySystem()
private float DecisionMomentumPlayerTarget()
private float DecisionMomentumAnimalTarget()
private void _FindPlayersInVisionRange()
private void _FindEntitiesInCloseRange()
private bool _FindCoverPointsInVolume()
private bool _FindCoverPointsInVolume(Vector3 position)
private bool _FindCoverPointsInVolume(Vector3 position, List`1<CoverPoint> coverPoints, CoverPointVolume& volume, Single& timer)
public void OnSensation(Sensation sensation)
protected void OnSenseItemOfInterest(Sensation sensation)
protected void OnSenseThrownThreat(Sensation sensation, BasePlayer invoker)
protected void OnSenseGunshot(Sensation sensation, BasePlayer invoker)
public float get_SecondsSinceLastHeardGunshot()
public Vector3 get_LastHeardGunshotDirection()
public void set_LastHeardGunshotDirection(Vector3 value)
public FamilyEnum get_Family()
public int get_AgentTypeIndex()
public void set_AgentTypeIndex(int value)
public bool get_IsStuck()
public void set_IsStuck(bool value)
public bool get_IsDormant()
public void set_IsDormant(bool value)
private void DelayedSpawnPosition()
public void ServerInit()
private void DelayedReloadOnInit()
internal void DoServerDestroy()
private bool Apex.LoadBalancing.ILoadBalanced.get_repeat()
private Nullable`1<float> Apex.LoadBalancing.ILoadBalanced.ExecuteUpdate(float deltaTime, float nextInterval)
public void RadioChatter()
public void OnKilled(HitInfo info)
private void AddKilledStat(HitInfo info)
private void RemoveFromJunkpiles()
public void Hurt(HitInfo info)
public void TickAi(float delta)
public void UpdateModelState(float delta)
protected void UpdatePositionAndRotation(Vector3 moveToPosition)
public void TickStuck(float delta)
public void OnBecomeStuck()
public void OnBecomeUnStuck()
public void BehaviourChanged()
public void ServerThink(float delta)
public void UpdateAttackTargetVisibility(float delta)
public void UpdateDestination(Vector3 newDest)
public void UpdateDestination(Transform tx)
public void SetDestination(Vector3 newDestination)
public float WeaponAttackRange()
public void StopMoving()
public float DesiredMoveSpeed()
public Vector3 GetAimDirection()
public void SetAimDirection(Vector3 newAim)
public void StartAttack()
public SeenInfo UpdateTargetMemory(BaseEntity target, float dmg, ExtendedInfo& extendedInfo)
public SeenInfo UpdateTargetMemory(BaseEntity target, float dmg, Vector3 lastKnownPosition, ExtendedInfo& extendedInfo)
public void StartAttack(AttackType type, BaseCombatEntity target)
public bool ShotTest()
public void TriggerDown()
public bool AttackReady()
public string Categorize()
private bool <_FindPlayersInVisionRange>b__341_0(BasePlayer player)
}
public NPCPlayerCorpse : PlayerCorpse {
private bool lootEnabled
public float GetRemovalTime()
public bool CanLoot()
public void SetLootableIn(float when)
public void EnableLooting()
}
public NPCSensesLoadBalancer : LoadBalancer {
public ILoadBalancer NpcSensesLoadBalancer
}
public NPCShopKeeper : NPCPlayer {
public EntityRef invisibleVendingMachineRef
public InvisibleVendingMachine machine
private float greetDir
private Vector3 initialFacingDir
private BasePlayer lastWavedAtPlayer
public InvisibleVendingMachine GetVendingMachine()
public void OnDrawGizmos()
public void UpdateProtectionFromClothing()
public void Hurt(HitInfo info)
public void ServerInit()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void PostServerLoad()
public void DelayedSleepEnd()
public void GreetPlayer(BasePlayer player)
public void Greeting()
}
public NPCSpawner : SpawnGroup {
public MonumentNavMesh monumentNavMesh
public bool shouldFillOnSpawn
public void SpawnInitial()
public bool WaitingForNavMesh()
public void LateSpawn()
}
public NPCTalking : NPCShopKeeper {
public ConversationData[] conversations
public NPCConversationResultAction[] conversationResultActions
public float maxConversationDistance
public List`1<BasePlayer> conversingPlayers
public BasePlayer lastActionPlayer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetConversationIndex(string conversationName)
public string GetConversationStartSpeech()
public ConversationData GetConversation(string conversationName)
public ConversationData GetConversation(int index)
public ConversationData GetConversationFor(BasePlayer player)
public bool ProviderBusy()
public void ForceEndConversation(BasePlayer player)
public void ForceSpeechNode(BasePlayer player, int speechNodeIndex)
public void OnConversationEnded(BasePlayer player)
public void CleanupConversingPlayers()
public void Server_BeginTalking(RPCMessage msg)
public void UpdateFlags()
public void Server_EndTalking(RPCMessage msg)
public void ConversationAction(RPCMessage msg)
public bool ValidConversationPlayer(BasePlayer player)
public void Server_ResponsePressed(RPCMessage msg)
public BasePlayer GetActionPlayer()
public void OnConversationAction(BasePlayer player, string action)
}
public NPCVendingMachine : VendingMachine {
public NPCVendingOrder vendingOrders
private Single[] refillTimes
public byte GetBPState(bool sellItemAsBP, bool currencyItemAsBP)
public void TakeCurrencyItem(Item takenCurrencyItem)
public void GiveSoldItem(Item soldItem, BasePlayer buyer)
public void PostServerLoad()
public void ServerInit()
public void InstallFromVendingOrders()
public void InstallDefaultSellOrders()
public void Refill()
public void ClearSellOrders()
public void AddItemForSale(int itemID, int amountToSell, int currencyID, int currencyPerTransaction, byte bpState)
public void RefreshStock()
protected bool CanRotate()
public bool CanPlayerAdmin(BasePlayer player)
}
public NPCVendingOrder : ScriptableObject {
public Entry[] orders
}
public NPCVendingOrderManifest : ScriptableObject {
public NPCVendingOrder[] orderList
public int GetIndex(NPCVendingOrder sample)
public NPCVendingOrder GetFromIndex(int index)
}
public NpcWalkAnimation : MonoBehaviour {
public Vector3 HipFudge
public BaseNpc Npc
public Animator Animator
public Transform HipBone
public Transform LookBone
public bool UpdateWalkSpeed
public bool UpdateFacingDirection
public bool UpdateGroundNormal
public Transform alignmentRoot
public bool LaggyAss
public bool LookAtTarget
public float MaxLaggyAssRotation
public float MaxWalkAnimSpeed
public bool UseDirectionBlending
public bool useTurnPosing
public float turnPoseScale
public float laggyAssLerpScale
public bool skeletonChainInverted
}
public NVGCamera : ImageEffectLayer {
public NVGEffect effect
public GameObject lights
public NVGCamera instance
public float exposure
public float bloomIntensity
public float bloomCutoff
}
public NVGEffect : PostEffectsBase {
public ColorCorrectionParams ColorCorrection1
public ColorCorrectionParams ColorCorrection2
public NoiseAndGrainParams NoiseAndGrain
private Texture2D rgbChannelTex1
private Texture2D rgbChannelTex2
private bool updateTexturesOnStartup
public Texture2D NoiseTexture
private float NOISE_TILE_AMOUNT
public Shader Shader
private Material material
private void Awake()
private void OnDestroy()
private void UpdateColorCorrectionTexture(ColorCorrectionParams param, Texture2D& tex)
public void UpdateTextures()
public bool CheckResources()
public bool IsActive()
public void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public ObjectEx : object {
public bool IsUnityNull(object obj)
public bool IsNull(object obj)
}
public ObjectFlasher : BaseMonoBehaviour {
public GameObject enabledObj
public GameObject disabledObj
public float toggleLength
public float timeOffset
public float randomOffset
public void Awake()
public void Toggle()
}
public ObjectRotation : MonoBehaviour {
public Camera cam
}
public ObjectSpam : MonoBehaviour {
public GameObject source
public int amount
public float radius
private void Start()
}
public ObjWriter : object {
public string MeshToString(Mesh mesh)
public void Write(Mesh mesh, string path)
}
public Occludee : MonoBehaviour {
public float minTimeVisible
public bool isStatic
public bool autoRegister
public bool stickyGizmos
public OccludeeState state
protected int occludeeId
protected Vector3 center
protected float radius
protected Renderer renderer
protected Collider collider
protected void Awake()
public void OnEnable()
public void OnDisable()
public void Register()
public void Unregister()
protected void OnVisibilityChanged(bool visible)
}
public OccludeeSphere : ValueType {
public int id
public OccludeeState state
public Sphere sphere
public bool IsRegistered
public bool get_IsRegistered()
public void Invalidate()
public void .ctor(int id)
public void .ctor(int id, Sphere sphere)
}
public OccludeeState : SmartListValue {
public int slot
public bool isStatic
public int layer
public OnVisibilityChanged onVisibilityChanged
public Cell cell
public SimpleList`1<State> states
public bool isVisible
public bool get_isVisible()
public OccludeeState Initialize(SimpleList`1<State> states, BufferSet set, int slot, Vector4 sphereBounds, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged)
public void Invalidate()
public void MakeVisible()
}
public OcclusionCulling : MonoBehaviour {
public DebugSettings debugSettings
private Material debugMipMat
private float debugDrawDuration
private Material downscaleMat
private Material blitCopyMat
private int hiZLevelCount
private int hiZWidth
private int hiZHeight
private RenderTexture depthTexture
private RenderTexture hiZTexture
private RenderTexture[] hiZLevels
private int GridCellsPerAxis
private int GridHalfCellsPerAxis
private int GridMinHalfCellsPerAxis
private int GridMaxHalfCellsPerAxis
private float GridCellSize
private float GridHalfCellSize
private float GridRcpCellSize
private int GridPoolCapacity
private int GridPoolGranularity
private HashedPool`1<Cell> grid
private Queue`1<Cell> gridChanged
public ComputeShader computeShader
public bool usePixelShaderFallback
public bool useAsyncReadAPI
private Camera camera
private int ComputeThreadsPerGroup
private int InputBufferStride
private int ResultBufferStride
private int OccludeeMaxSlotsPerPool
private int OccludeePoolGranularity
private int StateBufferGranularity
private int GridBufferGranularity
private Queue`1<OccludeeState> statePool
private SimpleList`1<OccludeeState> staticOccludees
private SimpleList`1<State> staticStates
private SimpleList`1<int> staticVisibilityChanged
private SimpleList`1<OccludeeState> dynamicOccludees
private SimpleList`1<State> dynamicStates
private SimpleList`1<int> dynamicVisibilityChanged
private List`1<int> staticChanged
private Queue`1<int> staticRecycled
private List`1<int> dynamicChanged
private Queue`1<int> dynamicRecycled
private BufferSet staticSet
private BufferSet dynamicSet
private BufferSet gridSet
private Vector4[] frustumPlanes
private String[] frustumPropNames
private Single[] matrixToFloatTemp
private Material fallbackMat
private Material depthCopyMat
private Matrix4x4 viewMatrix
private Matrix4x4 projMatrix
private Matrix4x4 viewProjMatrix
private Matrix4x4 prevViewProjMatrix
private Matrix4x4 invViewProjMatrix
private bool useNativePath
private OcclusionCulling instance
private GraphicsDeviceType[] supportedDeviceTypes
private bool _enabled
private bool _safeMode
private DebugFilter _debugShow
public bool HiZReady
public OcclusionCulling Instance
public bool Supported
public bool Enabled
public bool SafeMode
public DebugFilter DebugShow
public bool DebugFilterIsDynamic(int filter)
public bool DebugFilterIsStatic(int filter)
public bool DebugFilterIsGrid(int filter)
private void DebugInitialize()
private void DebugShutdown()
private void DebugUpdate()
private void DebugDraw()
public void NormalizePlane(Vector4& plane)
public void ExtractFrustum(Matrix4x4 viewProjMatrix, Vector4[]& planes)
public bool get_HiZReady()
public void CheckResizeHiZMap()
private void InitializeHiZMap()
private void FinalizeHiZMap()
private void InitializeHiZMap(int width, int height)
private void DestroyHiZMap()
private RenderTexture CreateDepthTexture(string name, int width, int height, bool mips)
private RenderTexture CreateDepthTextureMip(string name, int width, int height, int mip)
public void GrabDepthTexture()
public void GenerateHiZMipChain()
private void DebugDrawGizmos()
private int floor(float x)
public Cell RegisterToGrid(OccludeeState occludee)
public void UpdateInGrid(OccludeeState occludee)
public void UnregisterFromGrid(OccludeeState occludee)
public void UpdateGridBuffers()
public OcclusionCulling get_Instance()
public bool get_Supported()
public bool get_Enabled()
public void set_Enabled(bool value)
public bool get_SafeMode()
public void set_SafeMode(bool value)
public DebugFilter get_DebugShow()
public void set_DebugShow(DebugFilter value)
private void GrowStatePool()
private OccludeeState Allocate()
private void Release(OccludeeState state)
private void Awake()
private void OnEnable()
private bool SupportsNativePath()
private void OnDisable()
public void MakeAllVisible()
private void Update()
public void RecursiveAddOccludees(Transform transform, float minTimeVisible, bool isStatic, bool stickyGizmos)
private int FindFreeSlot(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, Queue`1<int> recycled)
public OccludeeState GetStateById(int id)
public int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged)
private int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged, SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, Queue`1<int> recycled, List`1<int> changed, BufferSet set, SimpleList`1<int> visibilityChanged)
public void UnregisterOccludee(int id)
private void UnregisterOccludee(int slot, SimpleList`1<OccludeeState> occludees, Queue`1<int> recycled, List`1<int> changed)
public void UpdateDynamicOccludee(int id, Vector3 center, float radius)
private void UpdateBuffers(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, BufferSet set, List`1<int> changed, bool isStatic)
private void UpdateCameraMatrices(bool starting)
private void OnPreCull()
private void OnPostRender()
private Single[] MatrixToFloatArray(Matrix4x4 m)
private void PrepareAndDispatch()
private void IssueRead()
public void ResetTiming(SmartList bucket)
public void ResetTiming()
private bool FrustumCull(Vector4[] planes, Vector4 testSphere)
private int ProcessOccludees_Safe(SimpleList`1<State> states, SmartList bucket, Color32[] results, SimpleList`1<int> changed, Vector4[] frustumPlanes, float time, UInt32 frame)
private int ProcessOccludees_Fast(State[] states, Int32[] bucket, int bucketCount, Color32[] results, int resultCount, Int32[] changed, Int32& changedCount, Vector4[] frustumPlanes, float time, UInt32 frame)
private int ProcessOccludees_Native(State& states, Int32& bucket, int bucketCount, Color32& results, int resultCount, Int32& changed, Int32& changedCount, Vector4& frustumPlanes, float time, UInt32 frame)
private void ApplyVisibility_Safe(float time, UInt32 frame)
private void ApplyVisibility_Fast(float time, UInt32 frame)
private void ApplyVisibility_Native(float time, UInt32 frame)
private void ProcessCallbacks(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, SimpleList`1<int> changed)
public void RetrieveAndApplyVisibility()
}
public OnePoleLowpassFilter : MonoBehaviour {
public float frequency
}
public OnParentDestroyingEx : object {
public void BroadcastOnParentDestroying(GameObject go)
public void SendOnParentDestroying(GameObject go)
}
public OnParentSpawningEx : object {
public void BroadcastOnParentSpawning(GameObject go)
public void SendOnParentSpawning(GameObject go)
}
public OnPostNetworkUpdateEx : object {
public void BroadcastOnPostNetworkUpdate(GameObject go, BaseEntity entity)
public void SendOnPostNetworkUpdate(GameObject go, BaseEntity entity)
}
public OnSendNetworkUpdateEx : object {
public void BroadcastOnSendNetworkUpdate(GameObject go, BaseEntity entity)
public void SendOnSendNetworkUpdate(GameObject go, BaseEntity entity)
}
public OpenSteamURL : MonoBehaviour {
public bool openInSteam
}
public OpenURL : MonoBehaviour {
public bool OpenWebURL
}
public OreHotSpot : BaseCombatEntity {
public float visualDistance
public GameObjectRef visualEffect
public GameObjectRef finishEffect
public GameObjectRef damageEffect
public OreResourceEntity owner
public void OreOwner(OreResourceEntity newOwner)
public void ServerInit()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public void FireFinishEffect()
}
public OreResourceEntity : StagedResourceEntity {
public GameObjectRef bonusPrefab
public GameObjectRef finishEffect
public GameObjectRef bonusFailEffect
public OreHotSpot _hotSpot
public SoundPlayer bonusSound
private int bonusesKilled
public int bonusesSpawned
public Vector3 lastNodeDir
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void UpdateNetworkStage()
public void CleanupBonus()
public void DestroyShared()
public void OnKilled(HitInfo info)
public void ServerInit()
public void FinishBonusAssigned()
public void OnAttacked(HitInfo info)
public void DelayedBonusSpawn()
public void RespawnBonus()
public OreHotSpot SpawnBonusSpot(Vector3 lastDirection)
public Vector3 RandomCircle(float distance, bool allowInside)
public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset, bool allowInside, bool changeHeight)
public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight, float maxHeight, bool allowInside)
public Vector3 ClampToCylinder(Vector3 localPos, Vector3 cylinderAxis, float cylinderDistance, float minHeight, float maxHeight)
}
public ORSwitch : IOEntity {
private int input1Amount
private int input2Amount
public bool WantsPassthroughPower()
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int slot)
}
public OutlineManager : MonoBehaviour {
public Material blurMat
public List`1<OutlineObject> objectsToRender
public float blurAmount
public Material glowSolidMaterial
public Material blendGlowMaterial
}
public OutlineObject : MonoBehaviour {
public Mesh[] meshes
public Transform[] meshTransforms
}
public OverlayMeshPaintableSource : MeshPaintableSource {
private Memoized`2<string, string> STPrefixed
public string baseTextureName
public Texture2D baseTexture
public void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride, bool forEditing, bool isSelected)
}
public Paddle : BaseMelee {
public float animPaddleCooldown
public GameObjectRef kayakSeat
public float animationLerpSpeed
}
public PaddlingPool : LiquidContainer {
public Flags FilledUp
public Transform poolWaterVolume
public GameObject poolWaterVisual
public float minimumWaterHeight
public float maximumWaterHeight
public WaterVolume waterVolume
public bool alignWaterUp
public GameObjectRef destroyedWithWaterEffect
public Transform destroyedWithWaterEffectPos
public Collider requireLookAt
private float lastFillAmount
public void OnItemAddedOrRemoved(Item item, bool added)
protected void OnInventoryDirty()
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
public void Save(SaveInfo info)
private float GetNormalisedFillLevel()
private void UpdatePoolFillAmount(float normalisedAmount)
public int ConsumptionAmount()
public void DestroyShared()
}
public PagerEntity : BaseEntity {
public Flags Flag_Silent
private int frequency
public float beepRepeat
public GameObjectRef pagerEffect
public GameObjectRef silentEffect
private float nextChangeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetFrequency()
public void SwitchParent(BaseEntity ent)
public void ServerInit()
internal void DoServerDestroy()
public Vector3 GetPosition()
public float GetMaxRange()
public void RFSignalUpdate(bool on)
public void SetSilentMode(bool wantsSilent)
public void SetOff()
public void ChangeFrequency(int newFreq)
public void ServerSetFrequency(RPCMessage msg)
public void Save(SaveInfo info)
internal void OnParentRemoved()
public void OnParentDestroying()
public void Load(LoadInfo info)
}
public PaintableImageGrid : UIBehaviour {
public UIPaintableImage templateImage
public int cols
public int rows
}
public Painting.Brush : object {
public float spacing
public Vector2 brushSize
public Texture2D texture
public Color color
public bool erase
}
public PaperDollSegment : BaseMonoBehaviour {
public HitArea selectedAreas
public HitArea area
public Image overlayImg
}
public ParticleCollisionLOD : LODComponentParticleSystem {
public State[] States
}
public ParticleDisableOnParentDestroy : MonoBehaviour {
public float destroyAfterSeconds
public void OnParentDestroying()
}
public ParticleEmitFromParentObject : MonoBehaviour {
public string bonename
private Bounds bounds
private Transform bone
private BaseEntity entity
private float lastBoundsUpdate
}
public ParticleRandomLifetime : MonoBehaviour {
public ParticleSystem mySystem
public float minScale
public float maxScale
public void Awake()
}
public ParticleSpawn : SingletonComponent`1<ParticleSpawn> {
public GameObjectRef[] Prefabs
public int PatchCount
public int PatchSize
private Vector3 <Origin>k__BackingField
public Vector3 Origin
public Vector3 get_Origin()
private void set_Origin(Vector3 value)
}
public ParticleSystemContainer : MonoBehaviour {
public bool precached
public ParticleSystemGroup[] particleGroups
public void Play()
public void Pause()
public void Stop()
public void Clear()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public ParticleSystemCull : LODComponentParticleSystem {
public float Distance
}
public ParticleSystemLOD : LODComponentParticleSystem {
public State[] States
}
public ParticleSystemPlayer : MonoBehaviour {
protected void OnEnable()
public void OnParentDestroying()
}
public PathFinder : object {
private Int32[0...,0...] costmap
private Boolean[0...,0...] visited
private Point[] neighbors
public Point PushPoint
public int PushRadius
public int PushDistance
public int PushMultiplier
private Point[] mooreNeighbors
private Point[] neumannNeighbors
public void .ctor(Int32[0...,0...] costmap, bool diagonals)
public Node FindPath(Point start, Point end, int depth)
private Node FindPathReversed(Point start, Point end, int depth)
public Node FindPathDirected(List`1<Point> startList, List`1<Point> endList, int depth)
public Node FindPathUndirected(List`1<Point> startList, List`1<Point> endList, int depth)
private Node FindPathReversed(List`1<Point> startList, List`1<Point> endList, int depth)
public Node FindClosestWalkable(Point start, int depth)
public bool IsWalkable(Point point)
public Node Reverse(Node start)
public Node FindEnd(Node start)
public int Cost(Point a)
public int Heuristic(Point a)
public int Heuristic(Point a, Point b)
public int Heuristic(Point a, List`1<Point> b)
}
public PathInterestNode : MonoBehaviour {
private float <NextVisitTime>k__BackingField
public float NextVisitTime
public float get_NextVisitTime()
public void set_NextVisitTime(float value)
public void OnDrawGizmos()
}
public PathInterpolator : object {
public Vector3[] Points
public Vector3[] Tangents
private int <MinIndex>k__BackingField
private int <MaxIndex>k__BackingField
private float <Length>k__BackingField
private float <StepSize>k__BackingField
private bool <Circular>k__BackingField
protected bool initialized
public int MinIndex
public int MaxIndex
public float Length
public float StepSize
public bool Circular
public int DefaultMinIndex
public int DefaultMaxIndex
public float StartOffset
public float EndOffset
public int get_MinIndex()
public void set_MinIndex(int value)
public int get_MaxIndex()
public void set_MaxIndex(int value)
public float get_Length()
private void set_Length(float value)
public float get_StepSize()
private void set_StepSize(float value)
public bool get_Circular()
private void set_Circular(bool value)
public int get_DefaultMinIndex()
public int get_DefaultMaxIndex()
public float get_StartOffset()
public float get_EndOffset()
public void .ctor(Vector3[] points)
public void .ctor(Vector3[] points, Vector3[] tangents)
public void RecalculateTangents()
protected void RecalculateLength()
public void Resample(float distance)
public void Smoothen(int iterations)
public void Smoothen(int iterations, Vector3 multipliers)
private void SmoothenIndex(int i, Vector3 multipliers)
public Vector3 GetStartPoint()
public Vector3 GetEndPoint()
public Vector3 GetStartTangent()
public Vector3 GetEndTangent()
public Vector3 GetPoint(float distance)
public Vector3 GetTangent(float distance)
public Vector3 GetPointCubicHermite(float distance)
}
public PathList : object {
private Quaternion rot90
private Quaternion rot180
private Quaternion rot270
public string Name
public PathInterpolator Path
public bool Spline
public bool Start
public bool End
public float Width
public float InnerPadding
public float OuterPadding
public float InnerFade
public float OuterFade
public float RandomScale
public float MeshOffset
public float TerrainOffset
public int Topology
public int Splat
public Node ProcgenStartNode
public Node ProcgenEndNode
public float StepSize
private Single[] placements
public bool IsExtraWide
public bool IsExtraNarrow
public bool get_IsExtraWide()
public bool get_IsExtraNarrow()
public void .ctor(string name, Vector3[] points)
private void SpawnObjectsNeighborAligned(UInt32& seed, Prefab[] prefabs, List`1<Vector3> positions, SpawnFilter filter)
private bool SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter)
private bool CheckObjects(Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter)
private void SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
private bool CheckObjects(Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
public void SpawnSide(UInt32& seed, SideObject obj)
public void SpawnAlong(UInt32& seed, PathObject obj)
public void SpawnBridge(UInt32& seed, BridgeObject obj)
public void SpawnStart(UInt32& seed, BasicObject obj)
public void SpawnEnd(UInt32& seed, BasicObject obj)
public void TrimStart(BasicObject obj)
public void TrimEnd(BasicObject obj)
public void TrimTopology(int topology)
public void ResetTrims()
public void AdjustTerrainHeight()
public void AdjustTerrainTexture()
public void AdjustTerrainTopology()
public void AdjustPlacementMap(float width)
public List`1<MeshObject> CreateMesh(Mesh[] meshes, float normalSmoothing)
}
public PathSpeedZone : MonoBehaviour {
public Bounds bounds
public OBB obbBounds
public float maxVelocityPerSec
public OBB WorldSpaceBounds()
public float GetMaxSpeed()
public void OnDrawGizmosSelected()
}
public PatrolHelicopterAI : BaseMonoBehaviour {
public List`1<targetinfo> _targetList
public Vector3 interestZoneOrigin
public Vector3 destination
public bool hasInterestZone
public float moveSpeed
public float maxSpeed
public float courseAdjustLerpTime
public Quaternion targetRotation
public Vector3 windVec
public Vector3 targetWindVec
public float windForce
public float windFrequency
public float targetThrottleSpeed
public float throttleSpeed
public float maxRotationSpeed
public float rotationSpeed
public float terrainPushForce
public float obstaclePushForce
public HelicopterTurret leftGun
public HelicopterTurret rightGun
public PatrolHelicopterAI heliInstance
public BaseHelicopter helicopterBase
public aiState _currentState
private Vector3 _aimTarget
private bool movementLockingAiming
private bool hasAimTarget
private bool aimDoorSide
private Vector3 pushVec
private Vector3 _lastPos
private Vector3 _lastMoveDir
public bool isDead
private bool isRetiring
public float spawnTime
public float lastDamageTime
private float deathTimeout
private float destination_min_dist
private float currentOrbitDistance
private float currentOrbitTime
private bool hasEnteredOrbit
private float orbitStartTime
private float maxOrbitDuration
private bool breakingOrbit
public List`1<MonumentInfo> _visitedMonuments
public float arrivalTime
public GameObjectRef rocketProjectile
public GameObjectRef rocketProjectile_Napalm
public bool leftTubeFiredLast
public float lastRocketTime
public float timeBetweenRockets
public int numRocketsLeft
public int maxRockets
public Vector3 strafe_target_position
private bool puttingDistance
public float strafe_approach_range
public float strafe_firing_range
private bool useNapalm
public float lastNapalmTime
public float lastStrafeTime
private float _lastThinkTime
public void UpdateTargetList()
public bool PlayerVisible(BasePlayer ply)
public void WasAttacked(HitInfo info)
public void Awake()
public void SetInitialDestination(Vector3 dest, float mapScaleDistance)
public void Retire()
public void SetIdealRotation(Quaternion newTargetRot, float rotationSpeedOverride)
public Quaternion GetYawRotationTo(Vector3 targetDest)
public void SetTargetDestination(Vector3 targetDest, float minDist, float minDistForFacingRotation)
public bool AtDestination()
public void MoveToDestination()
public void TerrainPushback()
public void UpdateRotation()
public void UpdateSpotlight()
public void Update()
public void WeakspotDamaged(weakspot weak, HitInfo info)
public void CriticalDamage()
public void DoMachineGuns()
public void FireGun(Vector3 targetPos, float aimCone, bool left)
public bool CanInterruptState()
public bool IsAlive()
public void DestroyMe()
public Vector3 GetLastMoveDir()
public Vector3 GetMoveDirection()
public float GetMoveSpeed()
public float GetMaxRotationSpeed()
public bool IsTargeting()
public void UpdateWind()
public void SetAimTarget(Vector3 aimTarg, bool isDoorSide)
public void ClearAimTarget()
public void State_Death_Think(float timePassed)
public void State_Death_Enter()
public void State_Death_Leave()
public void State_Idle_Think(float timePassed)
public void State_Idle_Enter()
public void State_Idle_Leave()
public void State_Move_Think(float timePassed)
public void State_Move_Enter(Vector3 newPos)
public void State_Move_Leave()
public void State_Orbit_Think(float timePassed)
public Vector3 GetOrbitPosition(float rate)
public void State_Orbit_Enter(float orbitDistance)
public void State_Orbit_Leave()
public Vector3 GetRandomPatrolDestination()
public void State_Patrol_Think(float timePassed)
public void State_Patrol_Enter()
public void State_Patrol_Leave()
public int ClipRocketsLeft()
public bool CanStrafe()
public bool CanUseNapalm()
public void State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm)
public void State_Strafe_Think(float timePassed)
public bool ValidStrafeTarget(BasePlayer ply)
public void State_Strafe_Leave()
public void FireRocket()
public void InitializeAI()
public void OnCurrentStateExit()
public void ExitCurrentState()
public float GetTime()
public void AIThink()
public Vector3 GetRandomOffset(Vector3 origin, float minRange, float maxRange, float minHeight, float maxHeight)
public Vector3 GetAppropriatePosition(Vector3 origin, float minHeight, float maxHeight)
public float GetThrottleForDistance(float distToTarget)
}
public Performance : SingletonComponent`1<Performance> {
public Tick current
public Tick report
private long cycles
private Int32[] frameRateHistory
private Single[] frameTimeHistory
private int frames
private float time
private void Update()
private void FPSTimer()
private float AverageFrameRate()
private float AverageFrameTime()
}
public PerformanceText : MonoBehaviour {
public TextMeshProUGUI text
}
public PFXRepeatingFirework : RepeatingFirework {
public ParticleSystemContainer pfx
}
public PhoneController : EntityComponent`1<BaseEntity> {
public CallState <serverState>k__BackingField
public PhoneController activeCallTo
public int PhoneNumber
public string PhoneName
public bool CanModifyPhoneName
public bool CanSaveNumbers
public bool RequirePower
public bool RequireParent
public float CallWaitingTime
public bool AppendGridToName
public GameObjectRef PhoneDialog
public VoiceProcessor VProcessor
public SoundDefinition[] AllPreloadedContent
public SoundDefinition DialToneSfx
public SoundDefinition RingingSfx
public SoundDefinition ErrorSfx
public SoundDefinition CallIncomingWhileBusySfx
public SoundDefinition PickupHandsetSfx
public SoundDefinition PutDownHandsetSfx
public SoundDefinition FailedWrongNumber
public SoundDefinition FailedNoAnswer
public SoundDefinition FailedNetworkBusy
public SoundDefinition FailedEngaged
public SoundDefinition FailedRemoteHangUp
public SoundDefinition FailedSelfHangUp
public Light RingingLight
public float RingingLightFrequency
public AudioSource answeringMachineSound
public EntityRef currentPlayerRef
private int <lastDialedNumber>k__BackingField
public PhoneDirectory <savedNumbers>k__BackingField
public CallState serverState
public BasePlayer currentPlayer
private bool isServer
public int lastDialedNumber
public PhoneDirectory savedNumbers
public BaseEntity ParentEntity
public CallState get_serverState()
public void set_serverState(CallState value)
public void ServerInit()
public void PostServerLoad()
public void DoServerDestroy()
public void ClearCurrentUser(RPCMessage msg)
public void ClearCurrentUser()
public void SetCurrentUser(RPCMessage msg)
private void UpdateServerPlayer(BasePlayer newPlayer)
public void InitiateCall(RPCMessage msg)
public void CallPhone(int number)
private bool CanReceiveCall()
public void AnswerPhone(RPCMessage msg)
public void ReceiveCallFrom(PhoneController t)
private void TimeOutDialing()
public void OnDialFailed(DialFailReason reason)
public void ServerPlayAnsweringMessage(PhoneController fromPhone)
private void TriggerTimeOut()
private void SetPhoneStateWithPlayer(CallState state)
private void SetPhoneState(CallState state)
public void BeginCall()
public void ServerHangUp(RPCMessage msg)
public void ServerHangUp()
private void SelfHangUp()
private void RemoteHangUp()
private void TimeOutCall()
public void OnReceivedVoiceFromUser(Byte[] data)
public void OnReceivedDataFromConnectedPhone(Byte[] data)
public void OnIncomingCallWhileBusy()
public void DestroyShared()
public void UpdatePhoneName(RPCMessage msg)
public void Server_RequestPhoneDirectory(RPCMessage msg)
public void Server_AddSavedNumber(RPCMessage msg)
public void Server_RemoveSavedNumber(RPCMessage msg)
public string GetDirectoryName()
public string PositionToGridCoord(Vector3 position)
public BasePlayer get_currentPlayer()
public void set_currentPlayer(BasePlayer value)
private bool get_isServer()
public int get_lastDialedNumber()
public void set_lastDialedNumber(int value)
public PhoneDirectory get_savedNumbers()
public void set_savedNumbers(PhoneDirectory value)
public BaseEntity get_ParentEntity()
private bool IsPowered()
public bool IsSavedContactValid(string contactName, int contactNumber)
public void OnFlagsChanged(Flags old, Flags next)
}
public PhoneDialler : UIDialog {
public GameObject DialingRoot
public GameObject CallInProcessRoot
public GameObject IncomingCallRoot
public RustText ThisPhoneNumber
public RustInput PhoneNameInput
private string textEntered
public RustText textDisplay
public RustText CallTimeText
public RustButton DefaultDialViewButton
public RustText[] IncomingCallNumber
public GameObject NumberDialRoot
public RustButton ContactsButton
public RustText FailText
public NeedsCursor CursorController
public Phrase WrongNumberPhrase
public Phrase NetworkBusy
public Phrase Engaged
public GameObjectRef DirectoryEntryPrefab
public Transform DirectoryRoot
public GameObject NoDirectoryRoot
public RustButton DirectoryPageUp
public RustButton DirectoryPageDown
public Transform ContactsRoot
public RustInput ContactsNameInput
public RustInput ContactsNumberInput
public GameObject NoContactsRoot
public RustButton AddContactButton
public SoundDefinition DialToneSfx
public Button[] NumberButtons
}
public PhoneDirectoryEntry : MonoBehaviour {
public RustText PhoneNumber
public RustText PhoneName
public GameObject DeleteIcon
public GameObject CensorIcon
}
public PhotoEntity : BaseEntity {
private ulong <PhotographerSteamId>k__BackingField
private UInt32 <ImageCrc>k__BackingField
private Byte[] _imageData
public ulong PhotographerSteamId
public UInt32 ImageCrc
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public ulong get_PhotographerSteamId()
private void set_PhotographerSteamId(ulong value)
public UInt32 get_ImageCrc()
private void set_ImageCrc(UInt32 value)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void SetImageData(ulong steamId, Byte[] data)
private void ImageRequested(RPCMessage msg)
internal void DoServerDestroy()
}
public PhotoFrame : StorageContainer {
public GameObjectRef SignEditorDialog
public OverlayMeshPaintableSource PaintableSource
private float TextureRequestDistance
private EntityRef _photoEntity
public UInt32 _overlayTextureCrc
public Vector2i TextureSize
public int TextureCount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector2i get_TextureSize()
public int get_TextureCount()
public bool CanUpdateSign(BasePlayer player)
public bool CanUnlockSign(BasePlayer player)
public bool CanLockSign(BasePlayer player)
public void UpdateSign(RPCMessage msg)
public void LockSign(RPCMessage msg)
public void UnLockSign(RPCMessage msg)
public void OnKilled(HitInfo info)
public bool ShouldNetworkOwnerInfo()
public string Categorize()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void OnItemAddedOrRemoved(Item item, bool added)
}
public PhotoPanel : MonoBehaviour {
public RawImage Image
public InputField Message
}
public PhysicsEffects : MonoBehaviour {
public BaseEntity entity
public SoundDefinition physImpactSoundDef
public float minTimeBetweenEffects
public float minDistBetweenEffects
public float hardnessScale
public float lowMedThreshold
public float medHardThreshold
public float enableDelay
public LayerMask ignoreLayers
private float lastEffectPlayed
private float enabledAt
private float ignoreImpactThreshold
private Vector3 lastCollisionPos
public void OnEnable()
public void OnCollisionEnter(Collision collision)
}
public PickAFriend : UIDialog {
public InputField input
public Action`1<ulong> onSelected
}
public PieMenu : UIBehaviour {
public PieMenu Instance
public Image middleBox
public PieShape pieBackgroundBlur
public PieShape pieBackground
public PieShape pieSelection
public GameObject pieOptionPrefab
public GameObject optionsCanvas
public MenuOption[] options
public GameObject scaleTarget
public float sliceGaps
public float outerSize
public float innerSize
public float iconSize
public float startRadius
public float radiusSize
public Image middleImage
public TextMeshProUGUI middleTitle
public TextMeshProUGUI middleDesc
public TextMeshProUGUI middleRequired
public Color colorIconActive
public Color colorIconHovered
public Color colorIconDisabled
public Color colorBackgroundDisabled
public SoundDefinition clipOpen
public SoundDefinition clipCancel
public SoundDefinition clipChanged
public SoundDefinition clipSelected
public MenuOption defaultOption
private bool isClosing
private CanvasGroup canvasGroup
public bool IsOpen
internal MenuOption selectedOption
private AnimationCurve easePunch
protected void Start()
public void Clear()
public void AddOption(MenuOption option)
public void FinishAndOpen()
protected void OnEnable()
public void SetDefaultOption()
public void PlayOpenSound()
public void PlayCancelSound()
public void Close(bool success)
private void Update()
public void Rebuild()
public void UpdateInteraction(bool allowLerp)
public bool DoSelect()
}
public PieOption : MonoBehaviour {
public PieShape background
public Image imageIcon
internal float midRadius
internal float sliceSize
internal float get_midRadius()
internal float get_sliceSize()
public void UpdateOption(float startSlice, float sliceSize, float border, string optionTitle, float outerSize, float innerSize, float imageSize, Sprite sprite)
}
public PieShape : Graphic {
public float outerSize
public float innerSize
public float startRadius
public float endRadius
public float border
public bool debugDrawing
protected void OnPopulateMesh(VertexHelper vbo)
}
public PingPongRotate : MonoBehaviour {
public Vector3 rotationSpeed
public Vector3 offset
public Vector3 rotationAmount
private void Update()
public Quaternion GetRotation(int index)
}
public PlaceCliffs : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public int RetryMultiplier
public int CutoffSlope
public float MinScale
public float MaxScale
private int target_count
private int target_length
private float min_scale_delta
private int max_scale_attempts
private int min_rotation
private int max_rotation
private int rotation_delta
private float offset_c
private float offset_l
private float offset_r
private Vector3[] offsets
public void Process(UInt32 seed)
private CliffPlacement PlaceMale(Prefab[] prefabs, UInt32& seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
private CliffPlacement PlaceFemale(Prefab[] prefabs, UInt32& seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
private CliffPlacement Place(Prefab[] prefabs, UInt32& seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale, int parentAngle, int parentCount, int parentScore)
}
public PlaceDecorUniform : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public float ObjectDistance
public float ObjectDithering
public void Process(UInt32 seed)
}
public PlaceDecorValueNoise : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public NoiseParameters Cluster
public float ObjectDensity
public void Process(UInt32 seed)
}
public PlaceDecorWhiteNoise : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public float ObjectDensity
public void Process(UInt32 seed)
}
public PlacementTest : MonoBehaviour {
public MeshCollider myMeshCollider
public Transform testTransform
public Transform visualTest
public float hemisphere
public float clampTest
public float testDist
private float nextTest
public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset)
public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight, float maxHeight)
public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
private void Update()
public void OnDrawGizmos()
}
public PlaceMonument : ProceduralComponent {
public SpawnFilter Filter
public GameObjectRef Monument
private int Attempts
public void Process(UInt32 seed)
}
public PlaceMonuments : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public int TargetCount
public int MinDistance
public int MinWorldSize
public DistanceMode DistanceSameType
public DistanceMode DistanceDifferentType
public int GroupCandidates
public int IndividualCandidates
public int Attempts
public void Process(UInt32 seed)
public DistanceInfo GetDistanceInfo(List`1<SpawnInfo> spawns, Vector3 monumentPos, Vector3 dungeonPos)
}
public PlaceMonumentsOffshore : ProceduralComponent {
public string ResourceFolder
public int TargetCount
public int MinDistanceFromTerrain
public int MaxDistanceFromTerrain
public int DistanceBetweenMonuments
public int MinWorldSize
private int Candidates
private int Attempts
public void Process(UInt32 seed)
public bool CheckRadius(List`1<SpawnInfo> spawns, Vector3 pos, float radius)
}
public PlaceMonumentsRoadside : ProceduralComponent {
public SpawnFilter Filter
public string ResourceFolder
public int TargetCount
public int MinDistance
public int MinWorldSize
public DistanceMode DistanceSameType
public DistanceMode DistanceDifferentType
public RoadMode RoadType
public int GroupCandidates
public int IndividualCandidates
public Quaternion rot90
public void Process(UInt32 seed)
private DistanceInfo GetDistanceInfo(List`1<SpawnInfo> spawns, Vector3 pos, MonumentInfo info)
}
public PlacePowerlineObjects : ProceduralComponent {
public BasicObject[] Start
public BasicObject[] End
public SideObject[] Side
public PathObject[] Path
public void Process(UInt32 seed)
}
public PlaceRiverObjects : ProceduralComponent {
public BasicObject[] Start
public BasicObject[] End
public SideObject[] Side
public PathObject[] Path
public void Process(UInt32 seed)
}
public PlaceRoadObjects : ProceduralComponent {
public BasicObject[] Start
public BasicObject[] End
public SideObject[] Side
public PathObject[] Path
public void Process(UInt32 seed)
}
public Planner : HeldEntity {
public BaseEntity[] buildableList
public bool isTypeDeployable
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void DoPlace(RPCMessage msg)
public Socket_Base FindSocket(string name, UInt32 prefabIDToFind)
public void DoBuild(CreateBuilding msg)
public void DoBuild(Target target, Construction component)
public GameObject DoPlacement(Target placement, Construction component)
public void PayForPlacement(BasePlayer player, Construction component)
public bool CanAffordToPlace(Construction component)
public ItemModDeployable GetModDeployable()
public Deployable GetDeployable()
public bool get_isTypeDeployable()
}
public PlanterBox : StorageContainer {
public int soilSaturation
public int soilSaturationMax
public MeshRenderer soilRenderer
private float MinimumSaturationTriggerLevel
private float MaximumSaturationTriggerLevel
private TimeCachedValue`1<float> sunExposure
private TimeCachedValue`1<float> artificialLightExposure
private TimeCachedValue`1<float> plantTemperature
private TimeCachedValue`1<float> plantArtificalTemperature
private TimeSince lastRainCheck
public float soilSaturationFraction
public int availableIdealWaterCapacity
public int availableWaterCapacity
public int idealSaturation
public bool BelowMinimumSaturationTriggerLevel
public bool AboveMaximumSaturationTriggerLevel
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
public bool InventoryItemFilter(Item item, int targetSlot)
private bool ItemIsFertilizer(Item item)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float get_soilSaturationFraction()
public int get_availableIdealWaterCapacity()
public int get_availableWaterCapacity()
public int get_idealSaturation()
public bool get_BelowMinimumSaturationTriggerLevel()
public bool get_AboveMaximumSaturationTriggerLevel()
public void FertilizeGrowables()
public int GetFertilizerCount()
public bool ConsumeFertilizer()
public int ConsumeWater(int amount, GrowableEntity ignoreEntity)
public bool WantsSplash(ItemDefinition splashType, int amount)
public int DoSplash(ItemDefinition splashType, int amount)
private void RefreshGrowables(GrowableEntity ignoreEntity)
public void ForceLightUpdate()
public void ForceTemperatureUpdate()
public float GetSunExposure()
private float CalculateSunExposure()
public float GetArtificialLightExposure()
private float CalculateArtificialLightExposure()
public float GetPlantTemperature()
private float CalculatePlantTemperature()
private void CalculateRainFactor()
private float CalculateArtificialTemperature()
}
public PlantProperties : ScriptableObject {
public Phrase Description
public GrowableGeneProperties Genes
public Stage[] stages
public AnimationCurve timeOfDayHappiness
public AnimationCurve temperatureHappiness
public AnimationCurve temperatureWaterRequirementMultiplier
public AnimationCurve fruitVisualScaleCurve
public int MaxSeasons
public float WaterIntake
public float OptimalLightQuality
public float OptimalWaterQuality
public float OptimalGroundQuality
public float OptimalTemperatureQuality
public Option pickOption
public ItemDefinition pickupItem
public Option cloneOption
public Option removeDyingOption
public ItemDefinition removeDyingItem
public GameObjectRef removeDyingEffect
public int pickupMultiplier
public GameObjectRef pickEffect
public int maxHarvests
public bool disappearAfterHarvest
public GameObjectRef CrossBreedEffect
public ItemDefinition SeedItem
public ItemDefinition CloneItem
public int BaseCloneCount
public int BaseMarketValue
}
public PlatformEntity : BaseEntity {
private float movementSpeed
private float rotationSpeed
private float radius
private Vector3 targetPosition
private Quaternion targetRotation
protected void FixedUpdate()
public float GetNetworkTime()
}
public PlayAudioEx : MonoBehaviour {
public float delay
private void Start()
private void OnEnable()
}
public PlayerBelt : object {
public int SelectedSlot
protected BasePlayer player
public int MaxBeltSlots
public int get_MaxBeltSlots()
public void .ctor(BasePlayer player)
public void DropActive(Vector3 position, Vector3 velocity)
public Item GetItemInSlot(int slot)
}
public PlayerBlueprints : EntityComponent`1<BasePlayer> {
public SteamInventory steamInventory
public void Reset()
public void UnlockAll()
public bool IsUnlocked(ItemDefinition itemDef)
public void Unlock(ItemDefinition itemDef)
public bool HasUnlocked(ItemDefinition targetItem)
public bool CanCraft(int itemid, int skinItemId, ulong playerId)
public bool CheckSkinOwnership(int skinItemId, ulong playerId)
}
public PlayerCorpse : LootableCorpse {
public Buoyancy buoyancy
public Flags Flag_Buoyant
public UInt32 underwearSkin
public bool IsBuoyant()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void ServerInit()
public void BuoyancyChanged(bool isSubmerged)
public void Save(SaveInfo info)
public string Categorize()
}
public PlayerDetectionTrigger : TriggerBase {
public BaseDetector myDetector
public GameObject InterestedInObject(GameObject obj)
public void OnObjects()
public void OnEmpty()
}
public PlayerEyes : EntityComponent`1<BasePlayer> {
public Vector3 EyeOffset
public Vector3 DuckOffset
public Vector3 thirdPersonSleepingOffset
public LazyAimProperties defaultLazyAim
private Vector3 viewOffset
private Quaternion <bodyRotation>k__BackingField
public Vector3 worldMountedPosition
public Vector3 worldStandingPosition
public Vector3 worldCrouchedPosition
public Vector3 position
private Vector3 BodyLeanOffset
public Vector3 center
public Vector3 offset
public Quaternion rotation
public Quaternion bodyRotation
public Quaternion parentRotation
public Vector3 get_worldMountedPosition()
public Vector3 get_worldStandingPosition()
public Vector3 get_worldCrouchedPosition()
public Vector3 get_position()
private Vector3 get_BodyLeanOffset()
public Vector3 get_center()
public Vector3 get_offset()
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public Quaternion get_bodyRotation()
public void set_bodyRotation(Quaternion value)
public Quaternion get_parentRotation()
public void NetworkUpdate(Quaternion rot)
public Vector3 MovementForward()
public Vector3 MovementRight()
public Ray BodyRay()
public Vector3 BodyForward()
public Vector3 BodyRight()
public Vector3 BodyUp()
public Ray HeadRay()
public Vector3 HeadForward()
public Vector3 HeadRight()
public Vector3 HeadUp()
public Quaternion GetLookRotation()
public Quaternion GetAimRotation()
}
public PlayerInput : EntityComponent`1<BasePlayer> {
public InputState state
public bool hadInputBuffer
protected void OnDisable()
}
public PlayerInventory : EntityComponent`1<BasePlayer> {
public ItemContainer containerMain
public ItemContainer containerBelt
public ItemContainer containerWear
public ItemCrafter crafting
public PlayerLoot loot
public bool forceBirthday
private float nextCheckTime
private bool wasBirthday
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
protected void Initialize()
public void DoDestroy()
public void ServerInit(BasePlayer owner)
public void OnItemAddedOrRemoved(Item item, bool bAdded)
public void UpdatedVisibleHolsteredItems()
private void OnContentsDirty()
private bool CanMoveItemsFrom(BaseEntity entity, Item item)
private void ItemCmd(RPCMessage msg)
private void MoveItem(RPCMessage msg)
private void OnClothingChanged(Item item, bool bAdded)
private void OnItemRemoved(Item item)
private bool CanEquipItem(Item item, int targetSlot)
private bool CanWearItem(Item item, int targetSlot)
public void ServerUpdate(float delta)
public void UpdateContainer(float delta, Type type, ItemContainer container, bool bSendInventoryToEveryone, float temperature)
public void SendSnapshot()
public void SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone)
public Item FindItemUID(UInt32 id)
public Item FindItemID(string itemName)
public Item FindItemID(int id)
public List`1<Item> FindItemIDs(int id)
public ItemContainer FindContainer(UInt32 id)
public ItemContainer GetContainer(Type id)
public bool GiveItem(Item item, ItemContainer container)
protected void GetIdealPickupContainer(Item item, ItemContainer& container, Int32& position)
public void Strip()
public bool IsBirthday()
public bool IsChristmas()
public void GiveDefaultItems()
public PlayerInventory Save(bool bForDisk)
public void Load(PlayerInventory msg)
public int Take(List`1<Item> collect, int itemid, int amount)
public int GetAmount(int itemid)
public Item[] AllItems()
public int AllItemsNoAlloc(List`1& items)
public void FindAmmo(List`1<Item> list, AmmoTypes ammoType)
public bool HasAmmo(AmmoTypes ammoType)
}
public PlayerInventoryProperties : ScriptableObject {
public string niceName
public int order
public List`1<ItemAmountSkinned> belt
public List`1<ItemAmountSkinned> main
public List`1<ItemAmountSkinned> wear
public void GiveToPlayer(BasePlayer player)
}
public PlayerLoot : EntityComponent`1<BasePlayer> {
public BaseEntity entitySource
public Item itemSource
public List`1<ItemContainer> containers
public bool PositionChecks
private bool isInvokingSendUpdate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsLooting()
public void Clear()
public ItemContainer FindContainer(UInt32 id)
public Item FindItem(UInt32 id)
public void Check()
public void MarkDirty()
public void SendImmediate()
private void SendUpdate()
public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks)
public void AddContainer(ItemContainer container)
public void RemoveContainer(ItemContainer container)
public bool RemoveContainerAt(int index)
public void StartLootingItem(Item item)
}
public PlayerMetabolism : BaseMetabolism`1<BasePlayer> {
public float HotThreshold
public float ColdThreshold
public MetabolismAttribute temperature
public MetabolismAttribute poison
public MetabolismAttribute radiation_level
public MetabolismAttribute radiation_poison
public MetabolismAttribute wetness
public MetabolismAttribute dirtyness
public MetabolismAttribute oxygen
public MetabolismAttribute bleeding
public MetabolismAttribute comfort
public MetabolismAttribute pending_health
public bool isDirty
private float lastConsumeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Reset()
public void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
internal bool HasChanged()
protected void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
public bool SignificantBleeding()
protected void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
private float DeltaHot()
private float DeltaCold()
private float DeltaWet()
public void UseHeart(float frate)
public void SendChangesToClient()
public bool CanConsume()
public void MarkConsumption()
public PlayerMetabolism Save()
public void Load(PlayerMetabolism s)
public MetabolismAttribute FindAttribute(Type type)
}
public PlayerModel : ListComponent`1<PlayerModel> {
public Transform[] Shoulders
protected int speed
protected int acceleration
protected int rotationYaw
protected int forward
protected int right
protected int up
protected int ducked
protected int grounded
protected int waterlevel
protected int attack
protected int attack_alt
protected int deploy
protected int reload
protected int throwWeapon
protected int holster
protected int aiming
protected int onLadder
protected int posing
protected int poseType
protected int relaxGunPose
protected int vehicle_aim_yaw
protected int vehicle_aim_speed
protected int onPhone
protected int leftFootIK
protected int rightFootIK
protected int vehicleSteering
public BoxCollider collision
public GameObject censorshipCube
public GameObject censorshipCubeBreasts
public GameObject jawBone
public GameObject neckBone
public GameObject headBone
public EyeController eyeController
public Transform[] SpineBones
public Transform leftFootBone
public Transform rightFootBone
public Transform leftHandPropBone
public Transform rightHandPropBone
public Vector3 rightHandTarget
public Vector3 leftHandTargetPosition
public Quaternion leftHandTargetRotation
public Vector3 rightHandTargetPosition
public Quaternion rightHandTargetRotation
public float steeringTargetDegrees
public Vector3 rightFootTargetPosition
public Quaternion rightFootTargetRotation
public Vector3 leftFootTargetPosition
public Quaternion leftFootTargetRotation
public RuntimeAnimatorController CinematicAnimationController
public RuntimeAnimatorController DefaultHoldType
public RuntimeAnimatorController SleepGesture
public RuntimeAnimatorController WoundedGesture
public RuntimeAnimatorController CurrentGesture
public SkinSetCollection MaleSkin
public SkinSetCollection FemaleSkin
public SubsurfaceProfile subsurfaceProfile
public float voiceVolume
public float skinColor
public float skinNumber
public float meshNumber
public float hairNumber
public int skinType
public MovementSounds movementSounds
public bool showSash
public int tempPoseType
public UInt32 underwearSkin
private ulong <overrideSkinSeed>k__BackingField
private Quaternion <AimAngles>k__BackingField
private Quaternion <LookAngles>k__BackingField
public ulong overrideSkinSeed
public bool IsFemale
public SkinSetCollection SkinSet
public Quaternion AimAngles
public Quaternion LookAngles
private Vector3 GetFlat(Vector3 dir)
public void RebuildAll()
public ulong get_overrideSkinSeed()
private void set_overrideSkinSeed(ulong value)
public bool get_IsFemale()
public SkinSetCollection get_SkinSet()
public Quaternion get_AimAngles()
public void set_AimAngles(Quaternion value)
public Quaternion get_LookAngles()
public void set_LookAngles(Quaternion value)
}
public PlayerModelHair : MonoBehaviour {
public HairType type
private Dictionary`2<Renderer, RendererMaterials> materials
public Dictionary`2<Renderer, RendererMaterials> Materials
public Dictionary`2<Renderer, RendererMaterials> get_Materials()
private void CacheOriginalMaterials()
private void Setup(HairType type, HairSetCollection hair, int meshIndex, float typeNum, float dyeNum, MaterialPropertyBlock block)
public void Setup(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
public void GetRandomVariation(float hairNum, int typeIndex, int meshIndex, Single& typeNum, Single& dyeNum)
public float GetRandomHairType(float hairNum, int typeIndex)
}
public PlayerModelHairCap : MonoBehaviour {
public HairCapMask hairCapMask
public void SetupHairCap(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block)
}
public PlayerModelSkin : MonoBehaviour {
public SkinMaterialType MaterialType
public Renderer SkinRenderer
public void Setup(SkinSetCollection skin, float hairNum, float meshNum)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public PlayerModifiers : BaseModifiers`1<BasePlayer> {
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerUpdate(BaseCombatEntity ownerEntity)
public PlayerModifiers Save()
public void Load(PlayerModifiers m)
public void SendChangesToClient()
}
public PlayerNameTag : MonoBehaviour {
public CanvasGroup canvasGroup
public Text text
public Gradient color
public float minDistance
public float maxDistance
public Vector3 positionOffset
public Transform parentBone
}
public PlayerStateManager : object {
private MruDictionary`2<ulong, PlayerState> _cache
private UserPersistance _persistence
public void .ctor(UserPersistance persistence)
public PlayerState Get(ulong playerId)
public void Save(ulong playerId)
private void SaveState(ulong playerId, PlayerState state)
private void FreeOldState(ulong playerId, PlayerState state)
public void Reset(ulong playerId)
private void OnPlayerStateLoaded(PlayerState state)
}
public PlayerStatistics : object {
public SteamStatistics steam
public ServerStatistics server
public CombatLog combat
public BasePlayer forPlayer
public void .ctor(BasePlayer player)
public void Init()
public void Save()
public void Add(string name, int val, Stats stats)
}
public PlayerVoiceSpeaker : EntityComponent`1<BasePlayer> {
public VoiceProcessor voiceProcessor
}
public PlayerWalkMovement : BaseMovement {
public float WaterLevelHead
public float WaterLevelNeck
public PhysicMaterial zeroFrictionMaterial
public PhysicMaterial highFrictionMaterial
public float capsuleHeight
public float capsuleCenter
public float capsuleHeightDucked
public float capsuleCenterDucked
public float gravityTestRadius
public float gravityMultiplier
public float gravityMultiplierSwimming
public float maxAngleWalking
public float maxAngleClimbing
public float maxAngleSliding
public float maxStepHeight
}
public PlayingCardsViewmodel : MonoBehaviour {
private Canvas cardUICanvas
private Image cardA
private Image cardB
private Sprite blankCard
}
public PointOfInterestMapMarker : MonoBehaviour {
public Image MapIcon
public GameObject LeaderRoot
}
public Poolable : MonoBehaviour {
public UInt32 prefabID
public Behaviour[] behaviours
public Rigidbody[] rigidbodies
public Collider[] colliders
public LODGroup[] lodgroups
public Renderer[] renderers
public ParticleSystem[] particles
public Boolean[] behaviourStates
public Boolean[] rigidbodyStates
public Boolean[] colliderStates
public Boolean[] lodgroupStates
public Boolean[] rendererStates
public int ClientCount
public int ServerCount
public int get_ClientCount()
public int get_ServerCount()
public void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void Initialize(UInt32 id)
public void EnterPool()
public void LeavePool()
public void SetBehaviourEnabled(bool state)
public void SetComponentEnabled(bool state)
}
public PoolableEx : object {
public bool SupportsPoolingInParent(GameObject gameObject)
public bool SupportsPooling(GameObject gameObject)
public void AwakeFromInstantiate(GameObject gameObject)
}
public PooledList`1 : object {
public List`1<T> data
public void Alloc()
public void Free()
public void Clear()
}
public PoolVehicle {
public void OnPoolDestroyed()
public void WakeUp()
}
public PositionLerp : object {
private ListHashSet`1<PositionLerp> InstanceList
public bool DebugLog
public bool DebugDraw
public int TimeOffsetInterval
public float TimeOffset
public int TimeOffsetIntervalMin
public int TimeOffsetIntervalMax
private bool enabled
private Action idleDisable
private TransformInterpolator interpolator
private ILerpTarget target
private float timeOffset0
private float timeOffset1
private float timeOffset2
private float timeOffset3
private int timeOffsetCount
private float lastClientTime
private float lastServerTime
private float extrapolatedTime
private float enabledTime
public bool Enabled
public bool get_Enabled()
public void set_Enabled(bool value)
private void OnEnable()
private void OnDisable()
public void Initialize(ILerpTarget target)
public void Snapshot(Vector3 position, Quaternion rotation, float serverTime)
public void Snapshot(Vector3 position, Quaternion rotation)
public void SnapTo(Vector3 position, Quaternion rotation, float serverTime)
public void SnapTo(Vector3 position, Quaternion rotation)
public void SnapToEnd()
public void Wipe()
public void WipeAll()
protected void DoCycle()
public void TransformEntries(Matrix4x4 matrix)
public Quaternion GetEstimatedAngularVelocity()
public Vector3 GetEstimatedVelocity()
public void Dispose()
public void Clear()
public void Cycle()
}
public PostOpaqueDepth : MonoBehaviour {
public RenderTexture postOpaqueDepth
public RenderTexture PostOpaque
public RenderTexture get_PostOpaque()
}
public PowerBar : MonoBehaviour {
public PowerBar Instance
public Image powerInner
public float fullSize
public CanvasGroup group
}
public PowerCounter : IOEntity {
public int counterNumber
public int targetCounterNumber
public Canvas canvas
public CanvasGroup screenAlpha
public Text screenText
public Flags Flag_ShowPassthrough
public GameObjectRef counterConfigPanel
public Color passthroughColor
public Color counterColor
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool DisplayPassthrough()
public bool DisplayCounter()
public bool CanPlayerAdmin(BasePlayer player)
public int GetTarget()
public void ResetState()
public void SERVER_SetTarget(RPCMessage msg)
public void ToggleDisplayMode(RPCMessage msg)
public int GetPassthroughAmount(int outputSlot)
public void Save(SaveInfo info)
public void SetCounterNumber(int newNumber)
public void SendIONetworkUpdate()
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int inputSlot)
public void Load(LoadInfo info)
}
public PoweredLightsDeployer : HeldEntity {
public GameObjectRef poweredLightsPrefab
public EntityRef activeLights
public MaterialReplacement guide
public GameObject guideObject
public float maxPlaceDistance
public float lengthPerAmount
public AdvancedChristmasLights active
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool CanPlayerUse(BasePlayer player)
public AdvancedChristmasLights get_active()
public void set_active(AdvancedChristmasLights value)
public void AddPoint(RPCMessage msg)
public void Finish(RPCMessage msg)
public void DoFinish()
public void OnHeldChanged()
public void Save(SaveInfo info)
}
public PoweredRemoteControlEntity : IOEntity {
public string rcIdentifier
public Transform viewEyes
public GameObjectRef IDPanelPrefab
public bool isStatic
public bool RequiresMouse
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsStatic()
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateRCAccess(bool isOnline)
public Transform GetEyes()
public bool CanControl()
public bool get_RequiresMouse()
public void UserInput(InputState inputState, BasePlayer player)
public BaseEntity GetEnt()
public bool Occupied()
public void InitializeControl(BasePlayer controller)
public void StopControl()
public void RCSetup()
public void RCShutdown()
public void Server_SetID(RPCMessage msg)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void UpdateIdentifier(string newID, bool clientSend)
public string GetIdentifier()
public void InitShared()
public void DestroyShared()
}
public PoweredWaterPurifier : WaterPurifier {
public float ConvertInterval
public int PowerDrain
public Material PoweredMaterial
public Material UnpoweredMaterial
public MeshRenderer TargetRenderer
public void ResetState()
public bool CanPickup(BasePlayer player)
protected void SpawnStorageEnt(bool load)
public void OnItemAddedOrRemoved(Item item, bool added)
private void ConvertWater()
public int ConsumptionAmount()
public void OnFlagsChanged(Flags old, Flags next)
}
public PowerlineNode : MonoBehaviour {
public GameObjectRef WirePrefab
public float MaxDistance
protected void Awake()
}
public PowerLineWire : MonoBehaviour {
public List`1<Transform> poles
public List`1<PowerLineWireConnectionDef> connections
public List`1<PowerLineWireSpan> spans
public void Copy(PowerLineWire from, PowerLineWireConnectionHelper helper)
public PowerLineWire Create(PowerLineWire wire, List`1<GameObject> objs, GameObjectRef wirePrefab, string name, PowerLineWire copyfrom, float wiresize, float str)
public void Init()
}
public PowerLineWireConnection : object {
public Vector3 inOffset
public Vector3 outOffset
public float radius
public Transform start
public Transform end
}
public PowerLineWireConnectionDef : object {
public Vector3 inOffset
public Vector3 outOffset
public float radius
public void .ctor(PowerLineWireConnectionDef src)
}
public PowerLineWireConnectionHelper : MonoBehaviour {
public List`1<PowerLineWireConnectionDef> connections
public bool showgizmo
}
public PowerLineWireSpan : MonoBehaviour {
public GameObjectRef wirePrefab
public Transform start
public Transform end
public float WireLength
public List`1<PowerLineWireConnection> connections
public void Init(PowerLineWire wire)
}
public Prefab : object {
public UInt32 ID
public string Name
public GameObject Object
public GameManager Manager
public Library Attribute
public PrefabParameters Parameters
public Library DefaultAttribute
public GameManager DefaultManager
public void .ctor(string name, GameObject prefab, GameManager manager, Library attribute)
public GameObject op_Implicit(Prefab prefab)
public int CompareTo(Prefab that)
public bool ApplyTerrainAnchors(Vector3& pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter)
public bool ApplyTerrainAnchors(Vector3& pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public bool ApplyTerrainChecks(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public bool ApplyTerrainFilters(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public void ApplyTerrainModifiers(Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyTerrainPlacements(Vector3 pos, Quaternion rot, Vector3 scale)
public bool ApplyWaterChecks(Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyDecorComponents(Vector3& pos, Quaternion& rot, Vector3& scale)
public bool CheckEnvironmentVolumes(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
public bool CheckEnvironmentVolumesInsideTerrain(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
public GameObject Spawn(Transform transform, bool active)
public GameObject Spawn(Vector3 pos, Quaternion rot, bool active)
public GameObject Spawn(Vector3 pos, Quaternion rot, Vector3 scale, bool active)
public BaseEntity SpawnEntity(Vector3 pos, Quaternion rot, bool active)
public Prefab`1<T> Load(UInt32 id, GameManager manager, Library attribute)
public Prefab Load(UInt32 id, GameManager manager, Library attribute)
public Prefab[] Load(string folder, GameManager manager, Library attribute, bool useProbabilities)
public Prefab`1[] Load(string folder, GameManager manager, Library attribute, bool useProbabilities)
public Prefab`1[] Load(String[] names, GameManager manager, Library attribute)
public Prefab LoadRandom(string folder, UInt32& seed, GameManager manager, Library attribute, bool useProbabilities)
public Prefab`1<T> LoadRandom(string folder, UInt32& seed, GameManager manager, Library attribute, bool useProbabilities)
public Library get_DefaultAttribute()
public GameManager get_DefaultManager()
private String[] FindPrefabNames(string strPrefab, bool useProbabilities)
}
public Prefab`1 : Prefab {
public T Component
public void .ctor(string name, GameObject prefab, T component, GameManager manager, Library attribute)
public int CompareTo(Prefab`1<T> that)
}
public PrefabAttribute : MonoBehaviour {
public Vector3 worldPosition
public Quaternion worldRotation
public Vector3 worldForward
public Vector3 localPosition
public Vector3 localScale
public Quaternion localRotation
public string fullName
public string hierachyName
public UInt32 prefabID
public int instanceID
public Library prefabAttribute
public GameManager gameManager
public bool isServer
public Library server
public bool isClient
public bool get_isClient()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
protected Type GetIndexedType()
public bool op_Equality(PrefabAttribute x, PrefabAttribute y)
public bool op_Inequality(PrefabAttribute x, PrefabAttribute y)
public bool Equals(object o)
public int GetHashCode()
public bool op_Implicit(PrefabAttribute exists)
internal bool ComparePrefabAttribute(PrefabAttribute x, PrefabAttribute y)
public string ToString()
}
public PrefabInformation : PrefabAttribute {
public ItemDefinition associatedItemDefinition
public Phrase title
public Phrase description
public Sprite sprite
protected Type GetIndexedType()
}
public PrefabInstantiate : MonoBehaviour {
public GameObjectRef Prefab
}
public PrefabParameters : MonoBehaviour {
public PrefabPriority Priority
public int Count
}
public PrefabPool : object {
public Stack`1<Poolable> stack
public int Count
public int get_Count()
public void Push(Poolable info)
public void Push(GameObject instance)
public GameObject Pop(Vector3 pos, Quaternion rot)
public void Clear()
}
public PrefabPoolCollection : object {
public Dictionary`2<UInt32, PrefabPool> storage
public void Push(GameObject instance)
public GameObject Pop(UInt32 id, Vector3 pos, Quaternion rot)
public void Clear()
}
public PrefabPoolWarmup : object {
public void Run()
public IEnumerator Run(float deltaTime, Action`1<string> statusFunction, string format)
public String[] GetAssetList()
private void PrefabWarmup(string path)
}
public PrefabPreProcess : object {
public Type[] clientsideOnlyTypes
public Type[] serversideOnlyTypes
public bool isClientside
public bool isServerside
public bool isBundling
public Dictionary`2<string, GameObject> prefabList
public List`1<Component> destroyList
public List`1<GameObject> cleanupList
public void .ctor(bool clientside, bool serverside, bool bundling)
public GameObject Find(string strPrefab)
public bool NeedsProcessing(GameObject go)
public void ProcessObject(string name, GameObject go, bool resetLocalTransform)
public void Process(string name, GameObject go)
public void Invalidate(string name)
public GameObject GetHierarchyGroup()
public void AddPrefab(string name, GameObject go)
private void DestroyComponents(Type t, GameObject go, bool client, bool server)
private bool ShouldExclude(Transform transform)
private bool HasComponents(Transform transform)
private bool HasComponents(Transform transform, Type t)
public List`1<T> FindComponents(Transform transform)
public void FindComponents(Transform transform, List`1<T> list)
public List`1<Component> FindComponents(Transform transform, Type t)
public void FindComponents(Transform transform, List`1<Component> list, Type t)
public void RemoveComponent(Component c)
public void RemoveComponents(GameObject gameObj)
public void NominateForDeletion(GameObject gameObj)
public void RunCleanupQueue()
public void DoCleanup(GameObject go)
}
public PrefabPriority : Enum {
public int value__
public PrefabPriority Lowest
public PrefabPriority Low
public PrefabPriority Default
public PrefabPriority High
public PrefabPriority Highest
}
public PressButton : IOEntity {
public float pressDuration
public float pressPowerTime
public int pressPowerAmount
public Flags Flag_EmittingPower
public bool smallBurst
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void UnpowerTime()
public void PostServerLoad()
public void Press(RPCMessage msg)
public void Unpress()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public PressurePad : BaseDetector {
public float pressPowerTime
public int pressPowerAmount
public Flags Flag_EmittingPower
public int ConsumptionAmount()
public bool IsRootEntity()
public bool ShouldTrigger()
public void OnDetectorTriggered()
public void OnDetectorReleased()
public void UnpowerTime()
public int GetPassthroughAmount(int outputSlot)
}
public ProceduralComponent : MonoBehaviour {
public Realm Mode
public string Description
public bool RunOnCache
public bool get_RunOnCache()
public bool ShouldRun()
public void Process(UInt32 seed)
}
public ProceduralLift : BaseEntity {
public float movementSpeed
public float resetDelay
public ProceduralLiftCabin cabin
public ProceduralLiftStop[] stops
public GameObjectRef triggerPrefab
public string triggerBone
private int floorIndex
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Spawn()
private void RPC_UseLift(RPCMessage rpc)
public void ServerInit()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
private void ResetLift()
private void MoveToFloor(int floor)
private void SnapToFloor(int floor)
private void OnFinishedMoving()
protected void Update()
}
public ProceduralObject : MonoBehaviour {
protected void Awake()
public void Process()
}
public ProcessedTexture : object {
protected RenderTexture result
protected Material material
public void Dispose()
protected RenderTexture CreateRenderTexture(string name, int width, int height, bool linear)
protected void DestroyRenderTexture(RenderTexture& rt)
protected RenderTexture CreateTemporary()
protected void ReleaseTemporary(RenderTexture rt)
protected Material CreateMaterial(string shader)
protected Material CreateMaterial(Shader shader)
protected void DestroyMaterial(Material& mat)
public Texture op_Implicit(ProcessedTexture t)
}
public ProcessMonumentNodes : ProceduralComponent {
public void Process(UInt32 seed)
}
public ProcessProceduralObjects : ProceduralComponent {
public bool RunOnCache
public void Process(UInt32 seed)
public bool get_RunOnCache()
}
public Profile : object {
public Stopwatch watch
public string category
public string name
public float warnTime
public void .ctor(string cat, string nam, float WarnTime)
public void Start()
public void Stop()
}
public ProgressBar : UIBehaviour {
public ProgressBar Instance
private Action`1<BasePlayer> action
private float timeFinished
private float timeCounter
public GameObject scaleTarget
public Image progressField
public Image iconField
public Text leftField
public Text rightField
public SoundDefinition clipOpen
public SoundDefinition clipCancel
public bool IsOpen
}
public ProgressDoor : IOEntity {
public float storedEnergy
public float energyForOpen
public float secondsToClose
public float openProgress
public void ResetIOState()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public void NoEnergy()
public void AddEnergy(float amount)
public void UpdateProgress()
}
public Projectile : BaseMonoBehaviour {
public float moveDeltaTime
public float lifeTime
public Vector3 initialVelocity
public float drag
public float gravityModifier
public float thickness
public float initialDistance
public bool remainInWorld
public float stickProbability
public float breakProbability
public float conditionLoss
public float ricochetChance
public float penetrationPower
public DamageProperties damageProperties
public MinMax damageDistances
public MinMax damageMultipliers
public List`1<DamageTypeEntry> damageTypes
public ScaleRenderer rendererToScale
public ScaleRenderer firstPersonRenderer
public bool createDecals
public bool doDefaultHitEffects
public SoundDefinition flybySound
public float flybySoundDistance
public SoundDefinition closeFlybySound
public float closeFlybyDistance
public float tumbleSpeed
public Vector3 tumbleAxis
public Vector3 swimScale
public Vector3 swimSpeed
public BasePlayer owner
public AttackEntity sourceWeaponPrefab
public Projectile sourceProjectilePrefab
public ItemModProjectile mod
public int projectileID
public int seed
public bool clientsideEffect
public bool clientsideAttack
public float integrity
public float maxDistance
public Modifier modifier
public bool invisible
private UInt32 _fleshMaterialID
private UInt32 _waterMaterialID
private UInt32 cachedWaterString
public void CalculateDamage(HitInfo info, Modifier mod, float scale)
public UInt32 FleshMaterialID()
public UInt32 WaterMaterialID()
public bool IsWaterMaterial(string hitMaterial)
public bool ShouldStopProjectile(RaycastHit hit)
}
public ProjectileTestSpawner : MonoBehaviour {
public Projectile TargetProjectile
public float RepeatTime
public float VelocityScale
}
public ProjectileWeaponInformationPanel : ItemInformationPanel {
public ItemStatValue damageDisplay
public ItemStatValue recoilDisplay
public ItemStatValue rofDisplay
public ItemStatValue accuracyDisplay
public ItemStatValue rangeDisplay
}
public ProjectileWeaponMod : BaseEntity {
public GameObjectRef defaultSilencerEffect
public bool isSilencer
public Modifier repeatDelay
public Modifier projectileVelocity
public Modifier projectileDamage
public Modifier projectileDistance
public Modifier aimsway
public Modifier aimswaySpeed
public Modifier recoil
public Modifier sightAimCone
public Modifier hipAimCone
public bool isLight
public bool isMuzzleBrake
public bool isMuzzleBoost
public bool isScope
public float zoomAmountDisplayOnly
public bool needsOnForEffects
public void ServerInit()
public void PostServerLoad()
public float Mult(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Sum(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Average(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Max(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public float Min(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def)
public IEnumerable`1<float> GetMods(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value)
public bool HasBrokenWeaponMod(BaseEntity parentEnt)
}
public PropSway : MonoBehaviour {
public Transform pivotRotator
public float swaySpeed
public float swayDistance
public float lerpSpeed
}
public ProtectionProperties : ScriptableObject {
public string comments
public float density
public Single[] amounts
public void OnValidate()
public void Clear()
public void Add(float amount)
public void Add(DamageType index, float amount)
public void Add(ProtectionProperties other, float scale)
public void Add(List`1<Item> items, HitArea area)
public void Multiply(float multiplier)
public void Multiply(DamageType index, float multiplier)
public void Scale(DamageTypeList damageList, float ProtectionAmount)
public float Get(DamageType damageType)
}
public ProtectionValue : MonoBehaviour {
public CanvasGroup group
public TextMeshProUGUI text
public DamageType damageType
public bool selectedItem
public bool displayBaseProtection
}
public PuzzleReset : FacepunchBehaviour {
public SpawnGroup[] respawnGroups
public IOEntity[] resetEnts
public GameObject[] resetObjects
public bool playersBlockReset
public float playerDetectionRadius
public float playerHeightDetectionMinMax
public Transform playerDetectionOrigin
public float timeBetweenResets
public bool scaleWithServerPopulation
public Vector3[] resetPositions
private float resetTimeElapsed
private float resetTickTime
public float GetResetSpacing()
public void Start()
public void ResetTimer()
public bool PassesResetCheck()
public void ResetTick()
public void CleanupSleepers()
public void DoReset()
public void ResetIOEntRecursive(IOEntity target, int resetIndex)
}
public QueryVis : BaseMonoBehaviour {
public Collider checkCollider
private Query query
public RadiusSpace coverageRadiusSpace
public float coverageRadius
}
public QuickCraft : SingletonComponent`1<QuickCraft> {
public GameObjectRef craftButton
public GameObject empty
public Sprite FavouriteOnSprite
public Sprite FavouriteOffSprite
public Color FavouriteOnColor
public Color FavouriteOffColor
}
public QuickCraftButton : MonoBehaviour {
public Image icon
public Image favourite
public Tooltip tooltip
public Text CraftCount
public Image FavouriteIcon
}
public RadialSpawnPoint : BaseSpawnPoint {
public float radius
public void GetLocation(Vector3& pos, Quaternion& rot)
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
}
public RadiationOverlay : ImageEffectLayer {
public SoundDefinition[] geigerSounds
private Sound sound
private ColorCorrectionCurves colourCorrection
private NoiseAndGrain noiseAndGrain
}
public RadioDialog : UIDialog {
public RustInput IpInput
}
public RadixSorter : object {
private UInt32[] histogram
private UInt32[] offset
public void SortU8(UInt32[] values, UInt32[] remap, UInt32 num)
public void SortU24(UInt32[] values, UInt32[] remap, UInt32[] remapTemp, UInt32 num)
}
public Ragdoll : BaseMonoBehaviour {
public Transform eyeTransform
public Transform centerBone
public Rigidbody primaryBody
public PhysicMaterial physicMaterial
public SpringJoint corpseJoint
public Skeleton skeleton
public Model model
public List`1<Joint> joints
public List`1<CharacterJoint> characterJoints
public List`1<ConfigurableJoint> configurableJoints
public List`1<Rigidbody> rigidbodies
public GameObject GibEffect
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public RagdollEditor : SingletonComponent`1<RagdollEditor> {
private Vector3 view
private Rigidbody grabbedRigid
private Vector3 grabPos
private Vector3 grabOffset
private void OnGUI()
protected void Awake()
private void Update()
private void FixedUpdate()
private void StartGrab()
private void UpdateGrab()
private void StopGrab()
}
public RainEffect : WeatherEffect {
public int FadeStartDistance
public int FadeEndDistance
public int FadeFalloff
public bool Stormy
}
public RainSurfaceAmbience : SingletonComponent`1<RainSurfaceAmbience> {
public List`1<SurfaceSound> surfaces
public GameObjectRef emitterPrefab
public Dictionary`2<ParticlePatch, AmbienceEmitter> spawnedEmitters
}
public RandomDestroy : MonoBehaviour {
public UInt32 Seed
public float Probability
protected void Start()
}
public RandomDynamicObject : MonoBehaviour {
public UInt32 Seed
public float Distance
public float Probability
public GameObject[] Candidates
}
public RandomDynamicPrefab : MonoBehaviour {
public UInt32 Seed
public float Distance
public float Probability
public string ResourceFolder
}
public RandomParameterNumber : StateMachineBehaviour {
public string parameterName
public int min
public int max
public bool preventRepetition
private int last
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public RandomParameterNumberFloat : StateMachineBehaviour {
public string parameterName
public int min
public int max
public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public RandomRendererEnable : MonoBehaviour {
public Renderer[] randoms
private int <EnabledIndex>k__BackingField
public int EnabledIndex
public int get_EnabledIndex()
private void set_EnabledIndex(int value)
public void OnEnable()
}
public RandomStaticObject : MonoBehaviour {
public UInt32 Seed
public float Probability
public GameObject[] Candidates
protected void Start()
}
public RandomStaticPrefab : MonoBehaviour {
public UInt32 Seed
public float Probability
public string ResourceFolder
protected void Start()
}
public RANDSwitch : ElectricalBlocker {
private bool rand
public int GetPassthroughAmount(int outputSlot)
public void UpdateBlocked()
public bool RandomRoll()
public void UpdateFromInput(int inputAmount, int inputSlot)
}
public RawWriter : object {
public void Write(IEnumerable`1<byte> data, string path)
public void Write(IEnumerable`1<int> data, string path)
public void Write(IEnumerable`1<short> data, string path)
public void Write(IEnumerable`1<float> data, string path)
}
public RaycastHitEx : object {
public Transform GetTransform(RaycastHit hit)
public Rigidbody GetRigidbody(RaycastHit hit)
public Collider GetCollider(RaycastHit hit)
public BaseEntity GetEntity(RaycastHit hit)
public bool IsOnLayer(RaycastHit hit, Layer rustLayer)
public bool IsOnLayer(RaycastHit hit, int layer)
}
public RCBookmarkEntry : MonoBehaviour {
private string <identifier>k__BackingField
private UInt32 <netid>k__BackingField
private ComputerMenu owner
public RectTransform connectButton
public RectTransform disconnectButton
public RawImage onlineIndicator
public RawImage offlineIndicator
public GameObject selectedindicator
public Image backgroundImage
public Color activeColor
public Color inactiveColor
public Text nameLabel
private bool <isControlling>k__BackingField
public EventTrigger eventTrigger
public string identifier
public UInt32 netid
public bool isControlling
public string get_identifier()
private void set_identifier(string value)
public UInt32 get_netid()
private void set_netid(UInt32 value)
public bool get_isControlling()
private void set_isControlling(bool value)
}
public RCMenu : ComputerMenu {
public Image backgroundOpaque
public InputField newBookmarkEntryField
public NeedsCursor needsCursor
public float hiddenOffset
public RectTransform devicesPanel
private Vector3 initialDevicesPosition
public bool isControllingCamera
public CanvasGroup overExposure
public CanvasGroup interference
public float interferenceFadeDuration
public Text timeText
public Text watchedDurationText
public Text deviceNameText
public Text noSignalText
public SoundDefinition bookmarkPressedSoundDef
}
public ReactiveTarget : IOEntity {
public Animator myAnimator
public GameObjectRef bullseyeEffect
public GameObjectRef knockdownEffect
public float activationPowerTime
public int activationPowerAmount
private float lastToggleTime
public float knockdownHealth
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void OnHitShared(HitInfo info)
public bool IsKnockedDown()
public void OnAttacked(HitInfo info)
public bool CanPickup(BasePlayer player)
public bool CanToggle()
public void QueueReset()
public void ResetTarget()
private void LowerTarget()
private void SendPowerBurst()
public int ConsumptionAmount()
public bool IsRootEntity()
public void UpdateFromInput(int inputAmount, int inputSlot)
public int GetPassthroughAmount(int outputSlot)
public void RPC_Reset(RPCMessage msg)
public void RPC_Lower(RPCMessage msg)
}
public RealmedCollider : BasePrefab {
public Collider ServerCollider
public Collider ClientCollider
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public RealmedNavMeshObstacle : BasePrefab {
public NavMeshObstacle Obstacle
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public RealmedRemove : MonoBehaviour {
public GameObject[] removedFromClient
public Component[] removedComponentFromClient
public GameObject[] removedFromServer
public Component[] removedComponentFromServer
public Component[] doNotRemoveFromServer
public Component[] doNotRemoveFromClient
public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool ShouldDelete(Component comp, bool client, bool server)
}
public Recipe : ScriptableObject {
public ItemDefinition ProducedItem
public int ProducedItemCount
public bool RequiresBlueprint
public RecipeIngredient[] Ingredients
public float MixingDuration
public bool ContainsItem(Item item)
}
public RecipeDictionary : object {
private Dictionary`2<UInt32, Dictionary`2<int, List`1<Recipe>>> recipeListsDict
public void CacheRecipes(RecipeList recipeList)
public Recipe GetMatchingRecipeAndQuantity(RecipeList recipeList, List`1<Item> orderedIngredients, Int32& quantity)
private List`1<Recipe> GetRecipesByFirstIngredient(RecipeList recipeList, Item firstIngredient)
public bool ValidIngredientForARecipe(Item ingredient, RecipeList recipeList)
}
public RecipeList : BaseScriptableObject {
public Recipe[] Recipes
}
public ReclaimBackpack : StorageContainer {
public int reclaimID
public ulong playerSteamID
public bool onlyOwnerLoot
public Collider myCollider
public GameObject art
private bool isBeingLooted
public void InitForPlayer(ulong playerID, int newID)
public void ServerInit()
public void RemoveMe()
public void CheckEmpty()
public bool OnStartBeingLooted(BasePlayer baseEntity)
public void PlayerStoppedLooting(BasePlayer player)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ReclaimManager : BaseEntity {
private int defaultReclaims
private int reclaimSlotCount
private int lastReclaimID
public float reclaim_expire_minutes
private ReclaimManager _instance
public List`1<PlayerReclaimEntry> entries
private float lastTickTime
public ReclaimManager instance
public ReclaimManager get_instance()
public int AddPlayerReclaim(ulong victimID, List`1<Item> itemList, ulong killerID, string killerString, int reclaimIDToUse)
public void DoCleanup()
public void TickEntries()
public bool HasReclaims(ulong playerID)
public PlayerReclaimEntry GetReclaimForPlayer(ulong playerID, int reclaimID)
public bool GetReclaimsForPlayer(ulong playerID, List`1& list)
public PlayerReclaimEntry NewEntry()
public void RemoveEntry(PlayerReclaimEntry entry)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ServerInit()
internal void DoServerDestroy()
}
public ReclaimTerminal : StorageContainer {
public int itemCount
public Phrase DespawnToast
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public void RPC_ReloadLoot(RPCMessage msg)
public void LoadReclaimLoot(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public RecoilProperties : ScriptableObject {
public float recoilYawMin
public float recoilYawMax
public float recoilPitchMin
public float recoilPitchMax
public float timeToTakeMin
public float timeToTakeMax
public float ADSScale
public float movementPenalty
public float clampPitch
public AnimationCurve pitchCurve
public AnimationCurve yawCurve
public bool useCurves
public int shotsUntilMax
}
public RecordingBars : MonoBehaviour {
public Image BorderImage
}
public RecordingSaved : SingletonComponent`1<RecordingSaved> {
public RustText Label
}
public Recycler : StorageContainer {
public float recycleEfficiency
public SoundDefinition grindingLoopDef
public GameObjectRef startSound
public GameObjectRef stopSound
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
private void SVSwitch(RPCMessage msg)
public bool MoveItemToOutput(Item newItem)
public bool HasRecyclable()
public void RecycleThink()
public void StartRecycling()
public void StopRecycling()
}
public ReflectionProbeEx : MonoBehaviour {
private Mesh blitMesh
private Mesh skyboxMesh
private Single[] octaVerts
private CubemapFaceMatrices[] cubemapFaceMatrices
private CubemapFaceMatrices[] cubemapFaceMatricesD3D11
private CubemapFaceMatrices[] shadowCubemapFaceMatrices
private CubemapFaceMatrices[] platformCubemapFaceMatrices
private Int32[] tab32
public ReflectionProbeRefreshMode refreshMode
public bool timeSlicing
public int resolution
public bool hdr
public float shadowDistance
public ReflectionProbeClearFlags clearFlags
public Color background
public float nearClip
public float farClip
public Transform attachToTarget
public Light directionalLight
public float textureMipBias
public bool highPrecision
public bool enableShadows
public ConvolutionQuality convolutionQuality
public List`1<RenderListEntry> staticRenderList
public Cubemap reflectionCubemap
public float reflectionIntensity
private void CreateMeshes()
private void DestroyMeshes()
private Mesh CreateBlitMesh()
private CubemapSkyboxVertex SubDivVert(CubemapSkyboxVertex v1, CubemapSkyboxVertex v2)
private void Subdivide(List`1<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
private void SubdivideYOnly(List`1<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
private Mesh CreateSkyboxMesh()
private bool InitializeCubemapFaceMatrices()
private int FastLog2(int value)
private UInt32 ReverseBits(UInt32 bits)
private void SafeCreateMaterial(Material& mat, Shader shader)
private void SafeCreateMaterial(Material& mat, string shaderName)
private void SafeCreateCubeRT(RenderTexture& rt, string name, int size, int depth, bool mips, TextureDimension dim, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite)
private void SafeCreateCB(CommandBuffer& cb, string name)
private void SafeDestroy(T& obj)
private void SafeDispose(T& obj)
}
public RelationshipManager : BaseEntity {
public int maxTeamSize_Internal
public RelationshipManager _instance
public Dictionary`2<ulong, BasePlayer> cachedPlayers
public Dictionary`2<ulong, PlayerTeam> playerToTeam
public Dictionary`2<ulong, PlayerTeam> teams
public ulong lastTeamIndex
public int maxTeamSize
public RelationshipManager Instance
public void set_maxTeamSize(int value)
public int get_maxTeamSize()
public int GetMaxTeamSize()
public RelationshipManager get_Instance()
public void OnEnable()
public void OnDestroy()
public void Save(SaveInfo info)
public void DisbandTeam(PlayerTeam teamToDisband)
public BasePlayer FindByID(ulong userID)
public PlayerTeam FindTeam(ulong TeamID)
public PlayerTeam FindPlayersTeam(ulong userID)
public PlayerTeam CreateTeam()
public void trycreateteam(Arg arg)
public void promote(Arg arg)
public void leaveteam(Arg arg)
public void acceptinvite(Arg arg)
public void rejectinvite(Arg arg)
public BasePlayer GetLookingAtPlayer(BasePlayer source)
public void sleeptoggle(Arg arg)
public void kickmember(Arg arg)
public void sendinvite(Arg arg)
public void fakeinvite(Arg arg)
public void addtoteam(Arg arg)
public bool TeamsEnabled()
public void Load(LoadInfo info)
}
public ReliableEventSender : StateMachineBehaviour {
public string StateEnter
public string MidStateEvent
public float TargetEventTime
}
public RemoteControlEntity : BaseCombatEntity {
public List`1<IRemoteControllable> allControllables
public string rcIdentifier
public Transform viewEyes
public GameObjectRef IDPanelPrefab
private bool <IsBeingControlled>k__BackingField
public bool IsBeingControlled
public bool RequiresMouse
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Transform GetEyes()
public BaseEntity GetEnt()
public bool Occupied()
public string GetIdentifier()
public void UserInput(InputState inputState, BasePlayer player)
public bool get_IsBeingControlled()
public void set_IsBeingControlled(bool value)
public void InitializeControl(BasePlayer controller)
public void StopControl()
public void UpdateIdentifier(string newID, bool clientSend)
public void RCSetup()
public void RCShutdown()
public void InitShared()
public void DestroyShared()
public bool CanControl()
public bool get_RequiresMouse()
public void Server_SetID(RPCMessage msg)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool IDInUse(string id)
public IRemoteControllable FindByID(string id)
public bool InstallControllable(IRemoteControllable newControllable)
public bool RemoveControllable(IRemoteControllable newControllable)
}
public RemoveChildObjectsAlongPath : MonoBehaviour {
public Transform Node1
public Transform Node2
public float Distance
}
public RenameSleepingBag : UIDialog {
public InputField input
public SleepingBag bag
}
public RendererEx : object {
private Memoized`2<Material[], int> ArrayCache
public void SetSharedMaterials(Renderer renderer, List`1<Material> materials)
}
public RendererGrid : SingletonComponent`1<RendererGrid> {
public bool Paused
public GameObjectRef BatchPrefab
public float CellSize
public float MaxMilliseconds
}
public RendererInfo : ComponentInfo`1<Renderer> {
public ShadowCastingMode shadows
public Material material
public Mesh mesh
public MeshFilter meshFilter
public void Reset()
public void Setup()
}
public RendererLOD : LODComponent {
public State[] States
}
public RenderType : Enum {
public int value__
public RenderType OPAQUE_DEFERRED
public RenderType OPAQUE_FORWARDBASE
public RenderType TRANSPARENT_FORWARDBASE
public RenderType TRANSPARENT
public RenderType UNDEFINED
}
public RepairBench : StorageContainer {
public float maxConditionLostOnRepair
public GameObjectRef skinchangeEffect
public float REPAIR_COST_FRACTION
private float nextSkinChangeTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float GetRepairFraction(Item itemToRepair)
public float RepairCostFraction(Item itemToRepair)
public void GetRepairCostList(ItemBlueprint bp, List`1<ItemAmount> allIngredients)
public void debugprint(string toPrint)
public void ChangeSkin(RPCMessage msg)
private void ApplySkinToItem(Item item, ulong Skin)
public void RepairItem(RPCMessage msg)
public void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)
}
public RepairBenchPanel : LootPanel {
public Text infoText
public Button repairButton
public Color gotColor
public Color notGotColor
public Phrase phraseEmpty
public Phrase phraseNotRepairable
public Phrase phraseRepairNotNeeded
public Phrase phraseNoBlueprint
public GameObject skinsPanel
public GameObject changeSkinDialog
public IconSkinPicker picker
}
public RepeatingFirework : BaseFirework {
public float timeBetweenRepeats
public int maxRepeats
public SoundPlayer launchSound
private int numFired
public void Begin()
public void SendFire()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public ResearchTable : StorageContainer {
public float researchFinishedTime
public float researchCostFraction
public float researchDuration
public int requiredPaper
public GameObjectRef researchStartEffect
public GameObjectRef researchFailEffect
public GameObjectRef researchSuccessEffect
public ItemDefinition researchResource
public BasePlayer user
public ItemDefinition blueprintBaseDef
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public bool IsResearching()
public int RarityMultiplier(Rarity rarity)
public int GetBlueprintStacksize(Item sourceItem)
public int ScrapForResearch(Item item)
public int ScrapForResearch(ItemDefinition info)
public bool IsItemResearchable(Item item)
public void ServerInit()
public bool ItemFilter(Item item, int targetSlot)
public Item GetTargetItem()
public Item GetScrapItem()
public void PostServerLoad()
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public void DoResearch(RPCMessage msg)
public ItemDefinition GetBlueprintTemplate()
public void ResearchAttemptFinished()
public void CancelResearch()
public void EndResearch()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public ResearchTablePanel : LootPanel {
public Button researchButton
public Text timerText
public GameObject itemDescNoItem
public GameObject itemDescTooBroken
public GameObject itemDescNotResearchable
public GameObject itemDescTooMany
public GameObject itemTakeBlueprint
public Text successChanceText
public ItemIcon scrapIcon
public bool wasResearching
public GameObject[] workbenchReqs
}
public ResetPlacementMap : ProceduralComponent {
public void Process(UInt32 seed)
}
public ResourceContainer : EntityComponent`1<BaseEntity> {
public bool lootable
public ItemContainer container
public float lastAccessTime
public int accessedSecondsAgo
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int get_accessedSecondsAgo()
private void StartLootingContainer(RPCMessage msg)
}
public ResourceDepositManager : BaseEntity {
public ResourceDepositManager _manager
private int resolution
public Dictionary`2<Vector2i, ResourceDeposit> _deposits
public Vector2i GetIndexFrom(Vector3 pos)
public ResourceDepositManager Get()
public ResourceDeposit CreateFromPosition(Vector3 pos)
public ResourceDeposit GetFromPosition(Vector3 pos)
public ResourceDeposit GetOrCreate(Vector3 pos)
}
public ResourceDispenser : EntityComponent`1<BaseEntity> {
public GatherType gatherType
public List`1<ItemAmount> containedItems
public float maxDestroyFractionForFinishBonus
public List`1<ItemAmount> finishBonus
public float fractionRemaining
private float categoriesRemaining
private float startingItemCounts
private Dictionary`2<GatherType, HashSet`1<int>> cachedResourceItemTypes
public void Start()
public void Initialize()
private void CacheResourceTypeItems()
public void DoGather(HitInfo info)
public void AssignFinishBonus(BasePlayer player, float fraction)
public void OnAttacked(HitInfo info)
private void GiveResources(BaseEntity entity, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
public void DestroyFraction(float fraction)
private void GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
private int CalculateGatherBonus(BaseEntity entity, ItemAmount item, float amountToGive)
private bool IsProducedItemOfGatherType(ItemAmount item)
public bool OverrideOwnership(Item item, AttackEntity weapon)
private void UpdateVars()
public void UpdateRemainingCategories()
public void CountAllItems()
private void UpdateFraction()
}
public ResourceEntity : BaseEntity {
public float startHealth
public ProtectionProperties baseProtection
public float health
public ResourceDispenser resourceDispenser
protected bool isKilled
public void Load(LoadInfo info)
public void InitShared()
public void ServerInit()
public void Save(SaveInfo info)
public float MaxHealth()
public float Health()
protected void OnHealthChanged()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public float BoundsPadding()
}
public ResourceRef`1 : object {
public string guid
private T _cachedObject
public bool isValid
public string resourcePath
public UInt32 resourceID
public bool get_isValid()
public T Get()
public string get_resourcePath()
public UInt32 get_resourceID()
}
public ReverbSettings : ScriptableObject {
public int room
public int roomHF
public int roomLF
public float decayTime
public float decayHFRatio
public int reflections
public float reflectionsDelay
public int reverb
public float reverbDelay
public float HFReference
public float LFReference
public float diffusion
public float density
}
public ReverbZoneTrigger : TriggerBase {
public Collider trigger
public AudioReverbZone reverbZone
public float lodDistance
public bool inRange
public ReverbSettings reverbSettings
public void PreClientComponentCull(IPrefabProcessor p)
public bool IsSyncedToParent()
}
public RFBroadcaster : IOEntity {
public int frequency
public GameObjectRef frequencyPanelPrefab
public Flags Flag_Broadcasting
public bool playerUsable
private float nextChangeTime
private float nextStopTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetFrequency()
public bool WantsPower()
public Vector3 GetPosition()
public float GetMaxRange()
public void RFSignalUpdate(bool on)
public void ServerSetFrequency(RPCMessage msg)
public void Save(SaveInfo info)
public void IOStateChanged(int inputAmount, int inputSlot)
public void StopBroadcasting()
internal void DoServerDestroy()
public void Load(LoadInfo info)
}
public RFManager : object {
public Dictionary`2<int, List`1<IRFObject>> _listeners
public Dictionary`2<int, List`1<IRFObject>> _broadcasters
public int minFreq
public int maxFreq
private int reserveRangeMin
private int reserveRangeMax
public string reserveString
public int ClampFrequency(int freq)
public List`1<IRFObject> GetListenList(int frequency)
public List`1<IRFObject> GetBroadcasterList(int frequency)
public void AddListener(int frequency, IRFObject obj)
public void RemoveListener(int frequency, IRFObject obj)
public void AddBroadcaster(int frequency, IRFObject obj)
public void RemoveBroadcaster(int frequency, IRFObject obj)
public bool IsReserved(int frequency)
public void ReserveErrorPrint(BasePlayer player)
public void ChangeFrequency(int oldFrequency, int newFrequency, IRFObject obj, bool isListener, bool isOn)
public void MarkFrequencyDirty(int frequency)
}
public RFReceiver : IOEntity {
public int frequency
public GameObjectRef frequencyPanelPrefab
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetFrequency()
public bool WantsPower()
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public Vector3 GetPosition()
public float GetMaxRange()
public void Init()
internal void DoServerDestroy()
public void RFSignalUpdate(bool on)
public void ServerSetFrequency(RPCMessage msg)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public RHIB : MotorRowboat {
public GameObject steeringWheel
public float rhibpopulation
private float targetGasPedal
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Server_Release(RPCMessage msg)
protected void VehicleFixedUpdate()
public bool EngineOn()
public void DriverInput(InputState inputState, BasePlayer player)
public void AddFuel(int amount)
}
public RHIBAIController : FacepunchBehaviour {
public List`1<Vector3> nodes
public void SetupPatrolPath()
public float GetWaterDepth(Vector3 pos)
public void OnDrawGizmosSelected()
}
public RidableHorse : BaseRidableAnimal {
public float Population
public string distanceStatName
public HorseBreed[] breeds
public SkinnedMeshRenderer[] bodyRenderers
public SkinnedMeshRenderer[] hairRenderers
public int currentBreed
public ProtectionProperties riderProtection
public ProtectionProperties baseHorseProtection
public Flags Flag_HideHair
public Flags Flag_WoodArmor
public Flags Flag_RoadsignArmor
public float equipmentSpeedMod
public int numStorageSlots
private Material[] breedAssignmentArray
private float distanceRecordingSpacing
public HitchTrough currentHitch
public float totalDistance
public float kmDistance
public float tempDistanceTravelled
public int numEquipmentSlots
public float RealisticMass
protected float PositionTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetStorageSlotCount()
public float get_RealisticMass()
public void ApplyBreed(int index)
protected void ApplyBreedInternal(HorseBreed breed)
public HorseBreed GetBreed()
public float GetTrotSpeed()
public float GetRunSpeed()
public void SetupCorpse(BaseCorpse corpse)
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public void OnKilled(HitInfo hitInfo)
public void SetBreed(int index)
public void LeadingChanged()
public void ServerInit()
protected float get_PositionTickRate()
public void PlayerMounted(BasePlayer player, BaseMountable seat)
public void PlayerDismounted(BasePlayer player, BaseMountable seat)
public bool IsHitched()
public void SetHitch(HitchTrough Hitch)
public float ReplenishRatio()
public void EatNearbyFood()
public void TryLeaveHitch()
public void TryHitch()
public void RecordDistance()
public void MarkDistanceTravelled(float amount)
public void Save(SaveInfo info)
public void OnInventoryDirty()
public bool CanAnimalAcceptItem(Item item, int targetSlot)
public int GetStorageStartIndex()
public void EquipmentUpdate()
public void Load(LoadInfo info)
protected bool CanPushNow(BasePlayer pusher)
public void setHorseBreed(Arg arg)
}
public RigidbodyLOD : LODComponent {
public float Distance
}
public RiverInfo : MonoBehaviour {
protected void Awake()
}
public RotateCameraAroundObject : MonoBehaviour {
public GameObject m_goObjectToRotateAround
public float m_flRotateSpeed
private void FixedUpdate()
}
public RotateObject : MonoBehaviour {
public float rotateSpeed_X
public float rotateSpeed_Y
public float rotateSpeed_Z
private void Update()
}
public RotateToCamera : MonoBehaviour {
public float maxDistance
}
public rottest : MonoBehaviour {
public Transform turretBase
public Vector3 aimDir
private void Start()
private void Update()
public void UpdateAiming()
}
public RottingFlies : MonoBehaviour {
public GameObjectRef effect
public SoundDefinition soundDef
public Transform rootBone
}
public RunConsoleCommand : MonoBehaviour {
public void ClientRun(string command)
}
public runtimeScript : MonoBehaviour {
public ERRoadNetwork roadNetwork
public ERRoad road
public GameObject go
public int currentElement
public float distance
public float speed
private void Start()
private void Update()
private void OnDestroy()
}
public Rust.Ai.AggressionRangeFromTargetEntity : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.AiAnswer_ShareEnemyTarget : ValueType {
private NPCPlayerApex <Source>k__BackingField
public BasePlayer PlayerTarget
public Nullable`1<Vector3> LastKnownPosition
public NPCPlayerApex Source
public NPCPlayerApex get_Source()
public void set_Source(NPCPlayerApex value)
}
public Rust.Ai.AiLocationManager : FacepunchBehaviour {
public List`1<AiLocationManager> Managers
public AiLocationSpawner MainSpawner
public SquadSpawnerLocation LocationWhenMainSpawnerIsNull
public Transform CoverPointGroup
public Transform PatrolPointGroup
public CoverPointVolume DynamicCoverPointVolume
public bool SnapCoverPointsToGround
private List`1<PathInterestNode> patrolPoints
public SquadSpawnerLocation LocationType
public SquadSpawnerLocation get_LocationType()
private void Awake()
private void OnDestroy()
public PathInterestNode GetFirstPatrolPointInRange(Vector3 from, float minRange, float maxRange)
public PathInterestNode GetRandomPatrolPointInRange(Vector3 from, float minRange, float maxRange, PathInterestNode currentPatrolPoint)
}
public Rust.Ai.AiLocationSpawner : SpawnGroup {
public SquadSpawnerLocation Location
public AiLocationManager Manager
public JunkPile Junkpile
public bool IsMainSpawner
public float chance
private int defaultMaxPopulation
private int defaultNumToSpawnPerTickMax
private int defaultNumToSpawnPerTickMin
public void SpawnInitial()
protected void Spawn(int numToSpawn)
protected BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, Vector3& pos, Quaternion& rot)
}
public Rust.Ai.AiManagedAgent : FacepunchBehaviour {
public int AgentTypeIndex
public Vector2i NavmeshGridCoord
private IAIAgent agent
private bool isRegistered
private void OnEnable()
private void DelayedRegistration()
private void OnDisable()
}
public Rust.Ai.AiManager : SingletonComponent`1<AiManager> {
private HashSet`1<IAIAgent> activeAgents
private List`1<IAIAgent> dormantAgents
private HashSet`1<IAIAgent> pendingAddToActive
private HashSet`1<IAIAgent> pendingAddToDormant
private HashSet`1<IAIAgent> pendingRemoveFromActive
private HashSet`1<IAIAgent> pendingRemoveFromDormant
private int lastWakeUpDormantIndex
private AgencyHTN <HTNAgency>k__BackingField
public bool UseCover
public float CoverPointVolumeCellSize
public float CoverPointVolumeCellHeight
public float CoverPointRayLength
public CoverPointVolume cpvPrefab
public LayerMask DynamicCoverPointVolumeLayerMask
private WorldSpaceGrid`1<CoverPointVolume> coverPointVolumeGrid
public bool nav_wait
public bool nav_disable
public bool ai_dormant
public int pathfindingIterationsPerFrame
public float ai_to_player_distance_wakeup_range
public int nav_obstacles_carve_state
public int ai_dormant_max_wakeup_per_tick
public float ai_htn_player_tick_budget
public float ai_htn_player_junkpile_tick_budget
public float ai_htn_animal_tick_budget
public bool ai_htn_use_agency_tick
private BasePlayer[] playerVicinityQuery
private Func`2<BasePlayer, bool> filter
public AgencyHTN HTNAgency
public bool repeat
internal void OnEnableAgency()
internal void OnDisableAgency()
public void Add(IAIAgent agent)
public void Remove(IAIAgent agent)
internal void AddActiveAgency(IAIAgent agent)
internal void AddDormantAgency(IAIAgent agent)
internal void RemoveActiveAgency(IAIAgent agent)
internal void RemoveDormantAgency(IAIAgent agent)
internal void UpdateAgency()
private void AgencyCleanup()
private void AgencyAddPending()
private void TryWakeUpDormantAgents()
private void TryMakeAgentsDormant()
public AgencyHTN get_HTNAgency()
internal void OnEnableCover()
internal void OnDisableCover()
public CoverPointVolume CreateNewCoverVolume(Vector3 point, Transform coverPointGroup)
public CoverPointVolume GetCoverVolumeContaining(Vector3 point)
public bool get_repeat()
public void Initialize()
private void OnDisable()
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
private bool IsAgentCloseToPlayers(IAIAgent agent)
private bool InterestedInPlayersOnly(BaseEntity entity)
}
public Rust.Ai.AimingAtPoint : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext context, Vector3 position)
}
public Rust.Ai.AimingAtTarget : BaseScorer {
public float arc
public bool PerfectKnowledge
public float GetScore(BaseContext c)
}
public Rust.Ai.AiStatement_EnemyEngaged : ValueType {
public BasePlayer Enemy
public float Score
public Nullable`1<Vector3> LastKnownPosition
}
public Rust.Ai.AiStatement_EnemySeen : ValueType {
public BasePlayer Enemy
public float Score
public Nullable`1<Vector3> LastKnownPosition
}
public Rust.Ai.AllowBreaking : BaseAction {
public bool Allow
public void DoExecute(BaseContext c)
}
public Rust.AI.AStarNode : object {
public AStarNode Parent
public float G
public float H
public BasePathNode Node
public float F
public float get_F()
public void .ctor(float g, float h, AStarNode parent, BasePathNode node)
public void Update(float g, float h, AStarNode parent, BasePathNode node)
public bool Satisfies(BasePathNode node)
public bool op_LessThan(AStarNode lhs, AStarNode rhs)
public bool op_GreaterThan(AStarNode lhs, AStarNode rhs)
}
public Rust.AI.AStarNodeList : List`1<AStarNode> {
private AStarNodeComparer comparer
public bool Contains(BasePathNode n)
public AStarNode GetAStarNodeOf(BasePathNode n)
public void AStarNodeSort()
}
public Rust.AI.AStarPath : object {
private float Heuristic(BasePathNode from, BasePathNode to)
public bool FindPath(BasePathNode start, BasePathNode goal, Stack`1& path, Single& pathCost)
}
public Rust.Ai.AtDestinationFor : BaseScorer {
public float Duration
public float GetScore(BaseContext c)
}
public Rust.Ai.AtDestinationForRandom : BaseScorer {
public float MinDuration
public float MaxDuration
public float GetScore(BaseContext c)
}
public Rust.Ai.AttackOperator : BaseAction {
public AttackType Type
public AttackTargetType Target
public void DoExecute(BaseContext c)
public void AttackEnemy(BaseContext c, AttackType type)
}
public Rust.Ai.AttackReady : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.AverageSumOfChildren : CompositeQualifier {
private bool normalize
private float postNormalizeMultiplier
private float MaxAverageScore
private bool FailIfAnyScoreZero
public float Score(IAIContext context, IList`1<IContextualScorer> scorers)
}
public Rust.Ai.BaseAction : ActionBase {
private string DebugName
public void Execute(IAIContext context)
public void DoExecute(BaseContext context)
}
public Rust.Ai.BaseActionWithOptions`1 : ActionWithOptions`1<T> {
private string DebugName
public void Execute(IAIContext context)
public void DoExecute(BaseContext context)
public bool TryGetBest(BaseContext context, IList`1<T> options, bool allScorersMustScoreAboveZero, T& best, Single& bestScore)
}
public Rust.Ai.BaseAiUtilityClient : UtilityAIClient {
public void .ctor(Guid aiId, IContextProvider contextProvider)
public void .ctor(IUtilityAI ai, IContextProvider contextProvider)
protected void OnPause()
protected void OnResume()
protected void OnStart()
protected void OnStop()
public void Initialize()
public void Kill()
}
public Rust.Ai.BaseContext : object {
private Vector3 <lastSampledPosition>k__BackingField
private List`1<Vector3> <sampledPositions>k__BackingField
private IAIAgent <AIAgent>k__BackingField
private BaseCombatEntity <Entity>k__BackingField
public Memory Memory
public BasePlayer ClosestPlayer
public List`1<BasePlayer> Players
public List`1<BaseNpc> Npcs
public List`1<BasePlayer> PlayersBehindUs
public List`1<BaseNpc> NpcsBehindUs
public List`1<TimedExplosive> DeployedExplosives
public BasePlayer EnemyPlayer
public BaseNpc EnemyNpc
public float LastTargetScore
public float LastEnemyPlayerScore
public float LastEnemyNpcScore
public float NextRoamTime
public Vector3 lastSampledPosition
public List`1<Vector3> sampledPositions
public IAIAgent AIAgent
public BaseCombatEntity Entity
public Vector3 Position
public Vector3 EnemyPosition
public void .ctor(IAIAgent agent)
public Vector3 get_lastSampledPosition()
public void set_lastSampledPosition(Vector3 value)
public List`1<Vector3> get_sampledPositions()
private void set_sampledPositions(List`1<Vector3> value)
public IAIAgent get_AIAgent()
private void set_AIAgent(IAIAgent value)
public BaseCombatEntity get_Entity()
private void set_Entity(BaseCombatEntity value)
public Vector3 get_Position()
public Vector3 get_EnemyPosition()
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value)
public byte GetFact(Facts fact)
public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue)
}
public Rust.Ai.BaseScorer : ContextualScorerBase {
public bool InvertScore
private string DebugName
protected float ProcessScore(float s)
public float Score(IAIContext context)
public float GetScore(BaseContext context)
}
public Rust.Ai.BehaviorDuration : BaseScorer {
public Behaviour Behaviour
public float duration
public float GetScore(BaseContext c)
}
public Rust.Ai.BehaviorDurationLessThan : BaseScorer {
public Behaviour Behaviour
public float duration
public float GetScore(BaseContext c)
}
public Rust.Ai.BehaviouralPointDirectnessToTarget : PointDirectnessToTarget {
private float minDirectness
private float maxDirectness
private Guide guide
public float GetScore(BaseContext c, Vector3 point)
}
public Rust.Ai.BeingAimedAt : BaseScorer {
public float arc
public Equality EqualityType
public float GetScore(BaseContext c)
}
public Rust.Ai.BestHostility : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
}
public Rust.Ai.BestLineOfSight : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public byte Evaluate(NPCPlayerApex self, BasePlayer option, Int32& standing, Int32& crouched)
}
public Rust.Ai.BestMountedLineOfSight : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public byte Evaluate(NPCPlayerApex self, BasePlayer option)
}
public Rust.Ai.BestMountedPlayerDirection : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public bool Evaluate(BasePlayer self, Vector3 optionPosition, Vector3& dir, Single& dot)
}
public Rust.Ai.BestPlayerDirection : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public bool Evaluate(IAIAgent self, Vector3 optionPosition, Vector3& dir, Single& dot)
}
public Rust.Ai.BestPlayerDistance : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public void Evaluate(IAIAgent self, Vector3 optionPosition, Single& distanceSqr, Single& aggroRangeSqr)
}
public Rust.Ai.BestPlayerFamily : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
}
public Rust.Ai.BestPlayerHostileBanditAct : OptionScorerBase`1<BasePlayer> {
private float score
public float Timeout
public float Score(IAIContext context, BasePlayer option)
}
public Rust.Ai.CanAffordAttack : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.CanAiAttack : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.CanPathToEntity : WeightedScorerBase`1<BaseEntity> {
private NavMeshPath pathToEntity
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.CanReachBeforeTarget : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext c, Vector3 point)
}
public Rust.Ai.ChaseTarget : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.CheatRealDirectionToTargetScorer : OptionScorerBase`1<CoverPoint> {
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option)
}
public Rust.Ai.CheatRealDistanceToTargetScorer : OptionScorerBase`1<CoverPoint> {
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option)
}
public Rust.Ai.CoverContext : object {
public IAIAgent Self
public Vector3 DangerPoint
public List`1<CoverPoint> SampledCoverPoints
public float BestRetreatValue
public float BestFlankValue
public float BestAdvanceValue
public CoverPoint BestRetreatCP
public CoverPoint BestFlankCP
public CoverPoint BestAdvanceCP
public float HideoutValue
public CoverPoint HideoutCP
public void Refresh(IAIAgent self, Vector3 dangerPoint, List`1<CoverPoint> sampledCoverPoints)
}
public Rust.Ai.CoverPoint : object {
private CoverPointVolume <Volume>k__BackingField
public CoverType NormalCoverType
public bool IsDynamic
public Transform SourceTransform
private Vector3 _staticPosition
private Vector3 _staticNormal
private BaseEntity <ReservedFor>k__BackingField
private bool <IsCompromised>k__BackingField
private float <Score>k__BackingField
public CoverPointVolume Volume
public Vector3 Position
public Vector3 Normal
public BaseEntity ReservedFor
public bool IsReserved
public bool IsCompromised
public float Score
public CoverPointVolume get_Volume()
private void set_Volume(CoverPointVolume value)
public Vector3 get_Position()
public void set_Position(Vector3 value)
public Vector3 get_Normal()
public void set_Normal(Vector3 value)
public BaseEntity get_ReservedFor()
public void set_ReservedFor(BaseEntity value)
public bool get_IsReserved()
public bool get_IsCompromised()
public void set_IsCompromised(bool value)
public float get_Score()
public void set_Score(float value)
public bool IsValidFor(BaseEntity entity)
public void .ctor(CoverPointVolume volume, float score)
public void CoverIsCompromised(float cooldown)
private IEnumerator StartCooldown(float cooldown)
public bool ProvidesCoverFromPoint(Vector3 point, float arcThreshold)
}
public Rust.Ai.CoverPointVolume : MonoBehaviour {
public float DefaultCoverPointScore
public float CoverPointRayLength
public LayerMask CoverLayerMask
public Transform BlockerGroup
public Transform ManualCoverPointGroup
public float cover_point_sample_step_size
public float cover_point_sample_step_height
public List`1<CoverPoint> CoverPoints
private List`1<CoverPointBlockerVolume> _coverPointBlockers
private float _dynNavMeshBuildCompletionTime
private int _genAttempts
private Bounds bounds
public bool repeat
public bool get_repeat()
private void OnEnable()
private void OnDisable()
public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval)
private void ClearCoverPoints()
public Bounds GetBounds()
public void PreGenerateCoverPoints()
public void ConvertToManualCoverPoints()
public void GenerateCoverPoints(Transform coverPointGroup)
private CoverPoint CalculateCoverPoint(NavMeshHit info)
internal CoverType ProvidesCoverInDir(Ray ray, float maxDistance, RaycastHit& rayHit)
public bool Contains(Vector3 point)
}
public Rust.Ai.CoverScorer : OptionScorerBase`1<CoverPoint> {
public float coverFromPointArcThreshold
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option, float arcThreshold)
private bool EvaluateAdvancement(CoverContext c, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness, Single& result)
private bool EvaluateRetreat(CoverContext c, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, Single& directness, Single& result)
private bool EvaluateFlanking(CoverContext c, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness, Single& result)
}
public Rust.Ai.Crouch : BaseAction {
public bool crouch
public void DoExecute(BaseContext ctx)
}
public Rust.Ai.Defensiveness : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.DistanceFromDestination : WeightedScorerBase`1<Vector3> {
public float Range
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.DistanceFromFoodTarget : BaseScorer {
public float MaxDistance
public float GetScore(BaseContext c)
}
public Rust.Ai.DistanceFromHome : BaseScorer {
public float Range
public AnimationCurve ResponseCurve
public bool UseResponseCurve
public float GetScore(BaseContext c)
}
public Rust.Ai.DistanceFromSelf : WeightedScorerBase`1<Vector3> {
public float Range
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.DistanceFromSpawnToTargetInRange : BaseScorer {
private EnemyRangeEnum range
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c, EnemyRangeEnum range)
}
public Rust.Ai.DistanceFromTargetDestination : BaseScorer {
public float MaxDistance
public float GetScore(BaseContext c)
}
public Rust.Ai.DistanceFromTargetEntity : BaseScorer {
public float MaxDistance
public float GetScore(BaseContext c)
}
public Rust.Ai.Eat : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.EnergyLevel : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.EntityDangerLevel : WeightedScorerBase`1<BaseEntity> {
public float MinScore
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.EntityDistance : WeightedScorerBase`1<BaseEntity> {
public float DistanceScope
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.EntityLOS : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.EntityProximityToCover : BaseScorer {
public float MaxDistance
public CoverType _coverType
public AnimationCurve Response
public float GetScore(BaseContext ctx)
}
public Rust.Ai.EntitySizeDifference : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.EntityTargetContext : object {
public IAIAgent Self
public BaseEntity[] Entities
public int EntityCount
public BaseNpc AnimalTarget
public float AnimalScore
public TimedExplosive ExplosiveTarget
public float ExplosiveScore
public void Refresh(IAIAgent self, BaseEntity[] entities, int entityCount)
}
public Rust.Ai.FacesAwayFromDanger : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.FeelsThreatenedByAttackTarget : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.FindBestAttackTarget : BaseActionWithOptions`1<BaseEntity> {
public float ScoreThreshold
public bool AllScorersMustScoreAboveZero
public void DoExecute(BaseContext c)
}
public Rust.Ai.FindBestFoodTarget : BaseActionWithOptions`1<BaseEntity> {
public void DoExecute(BaseContext c)
}
public Rust.Ai.FleeDirectionOfGunshots : WeightedScorerBase`1<Vector3> {
public float WithinSeconds
public float Arc
public float GetScore(BaseContext c, Vector3 option)
}
public Rust.Ai.GetHumanPathToTargetStatus : BaseScorer {
public NavMeshPathStatus Status
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c, NavMeshPathStatus s)
}
public Rust.Ai.HasAllyInLineOfFire : BaseScorer {
public float GetScore(BaseContext ctx)
}
public Rust.Ai.HasAlreadyCheckedHideoutPointScorer : OptionScorerBase`1<CoverPoint> {
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option)
}
public Rust.Ai.HasAttackTarget : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HasBeenStuckFor : BaseScorer {
public float StuckSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasChairTarget : BaseScorer {
public float GetScore(BaseContext context)
public float Test(NPCHumanContext c)
}
public Rust.Ai.HasCurrentWeaponType : BaseScorer {
public WeaponTypeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactBoolean : BaseScorer {
public Facts fact
public bool value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactEnemyRange : BaseScorer {
public EnemyRangeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactFoodRange : BaseScorer {
public FoodRangeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactSpeed : BaseScorer {
public SpeedEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFactValue : BaseScorer {
public Facts fact
public byte value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasFoodTarget : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHadEnemyRecently : BaseScorer {
public float GetScore(BaseContext ctx)
}
public Rust.Ai.HasHideout : BaseScorer {
public float GetScore(BaseContext context)
}
public Rust.Ai.HasHumanFactAmmo : BaseScorer {
public AmmoStateEnum value
public bool requireRanged
public EqualityEnum Equality
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactBodyState : BaseScorer {
public BodyState value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactBoolean : BaseScorer {
public Facts fact
public bool value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactEnemyRange : BaseScorer {
public EnemyRangeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactHealth : BaseScorer {
public HealthEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactSpeed : BaseScorer {
public SpeedEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasHumanFactValue : BaseScorer {
public Facts fact
public byte value
public float GetScore(BaseContext c)
}
public Rust.Ai.HasIdleFor : BaseScorer {
public float StuckSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasNotDealtDamageForTime : BaseScorer {
public float ForSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasPathStatus : BaseScorer {
private NavMeshPathStatus Status
public float GetScore(BaseContext c)
}
public Rust.Ai.HasPatrolPointsInRoamRange : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.HasPlayerTarget : ContextualScorerBase`1<PlayerTargetContext> {
private bool Not
public float Score(PlayerTargetContext c)
}
public Rust.Ai.HasRecentlyBeenAttacked : BaseScorer {
public float WithinSeconds
public bool BooleanResult
public float GetScore(BaseContext c)
}
public Rust.Ai.HasRecentlyDealtDamage : BaseScorer {
public float WithinSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasRecentlyHeardGunshots : BaseScorer {
public float WithinSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasSeenThreatsLately : BaseScorer {
public float WithinSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.HasThreats : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HasThreatsNearby : BaseScorer {
public float range
public float GetScore(BaseContext c)
}
public Rust.Ai.HasWeaponEquipped : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HealthFraction : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HealthFractionCurve : BaseScorer {
private AnimationCurve ResponseCurve
public float GetScore(BaseContext c)
}
public Rust.Ai.HideoutScorer : OptionScorerBase`1<CoverPoint> {
public float coverFromPointArcThreshold
public float maxRange
public float Score(IAIContext context, CoverPoint option)
public float Evaluate(CoverContext c, CoverPoint option, float arcThreshold, float maxRange)
}
public Rust.Ai.Hostility : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.HTN.AmmoState : Enum {
public byte value__
public AmmoState FullClip
public AmmoState HighClip
public AmmoState MediumClip
public AmmoState LowAmmo
public AmmoState EmptyClip
public AmmoState DontRequireAmmo
}
public Rust.Ai.HTN.AnimalInfo : ValueType {
public BaseNpc Animal
public float Time
public float SqrDistance
}
public Rust.Ai.HTN.BaseNpcContext : object {
public List`1<Item> InventoryLookupCache
public PlanResultType PlanResult
public PlanStateType PlanState
public Stack`1<PrimitiveTaskSelector> HtnPlan
public int DecompositionScore
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedEffects
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedExpectedEffects
public Byte[] WorldState
public Byte[] PreviousWorldState
public bool IsWorldStateDirty
public Stack`1[] WorldStateChanges
public List`1<PrimitiveTaskSelector> DebugPlan
public PrimitiveTaskSelector CurrentTask
public NpcOrientation OrientationType
public List`1<NpcPlayerInfo> PlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInLineOfSight
public List`1<NpcPlayerInfo> EnemyPlayersAudible
public List`1<NpcPlayerInfo> PlayersOutsideDetectionRange
public NpcPlayerInfo PrimaryEnemyPlayerInLineOfSight
public NpcPlayerInfo PrimaryEnemyPlayerAudible
public List`1<AnimalInfo> AnimalsInRange
public Vector3 BodyPosition
public BaseNpcMemory BaseMemory
public void StartDomainDecomposition()
public PlanResultType get_PlanResult()
public void set_PlanResult(PlanResultType value)
public PlanStateType get_PlanState()
public void set_PlanState(PlanStateType value)
public Stack`1<PrimitiveTaskSelector> get_HtnPlan()
public void set_HtnPlan(Stack`1<PrimitiveTaskSelector> value)
public int get_DecompositionScore()
public void set_DecompositionScore(int value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedEffects()
public void set_AppliedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedExpectedEffects()
public void set_AppliedExpectedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public Byte[] get_WorldState()
public Byte[] get_PreviousWorldState()
public bool get_IsWorldStateDirty()
public void set_IsWorldStateDirty(bool value)
public Stack`1[] get_WorldStateChanges()
public List`1<PrimitiveTaskSelector> get_DebugPlan()
public PrimitiveTaskSelector get_CurrentTask()
public void set_CurrentTask(PrimitiveTaskSelector value)
public NpcOrientation get_OrientationType()
public void set_OrientationType(NpcOrientation value)
public List`1<NpcPlayerInfo> get_PlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInLineOfSight()
public List`1<NpcPlayerInfo> get_EnemyPlayersAudible()
public List`1<NpcPlayerInfo> get_PlayersOutsideDetectionRange()
public NpcPlayerInfo get_PrimaryEnemyPlayerInLineOfSight()
public void set_PrimaryEnemyPlayerInLineOfSight(NpcPlayerInfo value)
public NpcPlayerInfo get_PrimaryEnemyPlayerAudible()
public void set_PrimaryEnemyPlayerAudible(NpcPlayerInfo value)
public NpcPlayerInfo GetPrimaryEnemyPlayerTarget()
public bool HasPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetBody()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetHead()
public Vector3 GetDirectionToMemoryOfPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionLookAround()
public Vector3 GetDirectionLastAttackedDir()
public Vector3 GetDirectionAudibleTarget()
public Vector3 GetDirectionToAnimal()
public List`1<AnimalInfo> get_AnimalsInRange()
public Vector3 get_BodyPosition()
public BaseNpcMemory get_BaseMemory()
public void SetFact(byte fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(byte fact)
public byte GetWorldState(byte fact)
public void ResetState()
}
public Rust.Ai.HTN.BaseNpcMemory : object {
public bool HasTargetDestination
public Vector3 TargetDestination
private List`1<FailedDestinationInfo> _failedDestinationMemory
public EnemyPlayerInfo PrimaryKnownEnemyPlayer
public List`1<EnemyPlayerInfo> KnownEnemyPlayers
public List`1<EntityOfInterestInfo> KnownEntitiesOfInterest
public List`1<EntityOfInterestInfo> KnownTimedExplosives
public AnimalInfo PrimaryKnownAnimal
public Vector3 LastClosestEdgeNormal
public BaseNpcContext NpcContext
public BaseNpcDefinition Definition
public BaseNpcDefinition get_Definition()
public void .ctor(BaseNpcContext context)
public void ResetState()
public bool IsValid(Vector3 destination)
public void AddFailedDestination(Vector3 destination)
public void ForgetPrimiaryEnemyPlayer()
public void ForgetPrimiaryAnimal()
public void RememberPrimaryAnimal(BaseNpc animal)
public void RememberPrimaryEnemyPlayer(BasePlayer primaryTarget)
protected void OnSetPrimaryKnownEnemyPlayer(EnemyPlayerInfo& info)
public void RememberEnemyPlayer(IHTNAgent npc, NpcPlayerInfo& info, float time, float uncertainty, string debugStr)
public void RememberEntityOfInterest(IHTNAgent npc, BaseEntity entityOfInterest, float time, string debugStr)
public void RememberTimedExplosives(IHTNAgent npc, TimedExplosive explosive, float time, string debugStr)
protected void OnForget(BasePlayer player)
public void Forget(float memoryTimeout)
public bool ShouldRemoveOnPlayerForgetTimeout(float time, NpcPlayerInfo player)
}
public Rust.Ai.HTN.Bear.BearContext : BaseNpcContext {
public bool _isWorldStateDirty
private Byte[] _worldState
private Byte[] _previousWorldState
private int _decompositionScore
private List`1<PrimitiveTaskSelector> _debugPlan
private Stack`1[] _worldStateChanges
private PlanResultType <PlanResult>k__BackingField
private PlanStateType <PlanState>k__BackingField
private Stack`1<PrimitiveTaskSelector> <HtnPlan>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedEffects>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedExpectedEffects>k__BackingField
public WorldStateChangedEvent OnWorldStateChangedEvent
private PrimitiveTaskSelector <CurrentTask>k__BackingField
public bool HasVisitedLastKnownEnemyPlayerLocation
private NpcOrientation <OrientationType>k__BackingField
private List`1<NpcPlayerInfo> <PlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInLineOfSight>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersAudible>k__BackingField
private List`1<NpcPlayerInfo> <PlayersOutsideDetectionRange>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerInLineOfSight>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerAudible>k__BackingField
private List`1<AnimalInfo> <AnimalsInRange>k__BackingField
public HTNAnimal Body
public BearDomain Domain
public BearMemory Memory
public PlanResultType PlanResult
public PlanStateType PlanState
public Stack`1<PrimitiveTaskSelector> HtnPlan
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedEffects
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedExpectedEffects
public bool IsWorldStateDirty
public Byte[] WorldState
public Byte[] PreviousWorldState
public Stack`1[] WorldStateChanges
public int DecompositionScore
public PrimitiveTaskSelector CurrentTask
public List`1<PrimitiveTaskSelector> DebugPlan
public NpcOrientation OrientationType
public List`1<NpcPlayerInfo> PlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInLineOfSight
public List`1<NpcPlayerInfo> EnemyPlayersAudible
public List`1<NpcPlayerInfo> PlayersOutsideDetectionRange
public NpcPlayerInfo PrimaryEnemyPlayerInLineOfSight
public NpcPlayerInfo PrimaryEnemyPlayerAudible
public List`1<AnimalInfo> AnimalsInRange
public Vector3 BodyPosition
public BaseNpcMemory BaseMemory
public PlanResultType get_PlanResult()
public void set_PlanResult(PlanResultType value)
public PlanStateType get_PlanState()
public void set_PlanState(PlanStateType value)
public Stack`1<PrimitiveTaskSelector> get_HtnPlan()
public void set_HtnPlan(Stack`1<PrimitiveTaskSelector> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedEffects()
public void set_AppliedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedExpectedEffects()
public void set_AppliedExpectedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public bool get_IsWorldStateDirty()
public void set_IsWorldStateDirty(bool value)
public Byte[] get_WorldState()
public Byte[] get_PreviousWorldState()
public Stack`1[] get_WorldStateChanges()
public int get_DecompositionScore()
public void set_DecompositionScore(int value)
public PrimitiveTaskSelector get_CurrentTask()
public void set_CurrentTask(PrimitiveTaskSelector value)
public List`1<PrimitiveTaskSelector> get_DebugPlan()
public NpcOrientation get_OrientationType()
public void set_OrientationType(NpcOrientation value)
public List`1<NpcPlayerInfo> get_PlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInLineOfSight()
public List`1<NpcPlayerInfo> get_EnemyPlayersAudible()
public List`1<NpcPlayerInfo> get_PlayersOutsideDetectionRange()
public NpcPlayerInfo get_PrimaryEnemyPlayerInLineOfSight()
public void set_PrimaryEnemyPlayerInLineOfSight(NpcPlayerInfo value)
public NpcPlayerInfo get_PrimaryEnemyPlayerAudible()
public void set_PrimaryEnemyPlayerAudible(NpcPlayerInfo value)
public NpcPlayerInfo GetPrimaryEnemyPlayerTarget()
public bool HasPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetBody()
public Vector3 GetDirectionToAnimal()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetHead()
public Vector3 GetDirectionToMemoryOfPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionLookAround()
public Vector3 GetDirectionLastAttackedDir()
public Vector3 GetDirectionAudibleTarget()
public List`1<AnimalInfo> get_AnimalsInRange()
public Vector3 get_BodyPosition()
public BaseNpcMemory get_BaseMemory()
public void StartDomainDecomposition()
public void ResetState()
public void .ctor(HTNAnimal body, BearDomain domain)
public void Dispose()
public bool IsBodyAlive()
public void IncrementFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void IncrementFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, EnemyRange value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, HealthState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, bool value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(Facts fact)
public byte GetPreviousFact(Facts fact)
public void SetFact(byte fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(byte fact)
public bool IsFact(Facts fact)
public void PushFactChangeDuringPlanning(Facts fact, HealthState value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, bool value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, int value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, byte value, bool temporary)
public void PushFactChangeDuringPlanning(byte fact, byte value, bool temporary)
public void PopFactChangeDuringPlanning(Facts fact)
public void PopFactChangeDuringPlanning(byte fact)
public byte PeekFactChangeDuringPlanning(Facts fact)
public byte PeekFactChangeDuringPlanning(byte fact)
public byte GetWorldState(Facts fact)
}
public Rust.Ai.HTN.Bear.BearDefinition : BaseNpcDefinition {
public float StandingAggroRange
public GameObjectRef CorpsePrefab
public LootSpawnSlot[] Loot
public Vector2 IdleEffectRepeatRange
public GameObjectRef IdleEffect
public GameObjectRef DeathEffect
private bool _isEffectRunning
public float SqrStandingAggroRange
public float get_SqrStandingAggroRange()
public float AggroRange(bool isStanding)
public float SqrAggroRange(bool isStanding)
public void StartVoices(HTNAnimal target)
public void StopVoices(HTNAnimal target)
private IEnumerator PlayEffects(HTNAnimal target)
public BaseCorpse OnCreateCorpse(HTNAnimal target)
}
public Rust.Ai.HTN.Bear.BearDomain : HTNDomain {
private bool _isRegisteredWithAgency
private Vector3[] pathCornerCache
private NavMeshPath _pathCache
public OnPlanAborted OnPlanAbortedEvent
public OnPlanCompleted OnPlanCompletedEvent
private BearContext _context
private NavMeshAgent _navAgent
private Vector3 _spawnPosition
private List`1<INpcSensor> _sensors
private List`1<INpcReasoner> _reasoners
private HTNUtilityAiClient _aiClient
private BearDefinition _bearDefinition
public BearDefinition BearDefinition
public Vector3 SpawnPosition
public BearContext BearContext
public BaseNpcContext NpcContext
public IHTNContext PlannerContext
public IUtilityAI PlannerAi
public IUtilityAIClient PlannerAiClient
public NavMeshAgent NavAgent
public List`1<INpcSensor> Sensors
public List`1<INpcReasoner> Reasoners
private void InitializeAgency()
private void RemoveAgency()
public void Resume()
public void Pause()
public void PauseNavigation()
public void ResumeNavigation()
public Vector3 GetNextPosition(float delta)
private void UpdateNavmeshOffset()
private IEnumerator TryForceToNavmesh()
public bool SetDestination(Vector3 destination)
public void TickDestinationTracker()
public bool IsPathValid()
public Vector3 GetHeadingDirection()
public Vector3 GetHomeDirection()
public void StopNavigating()
public bool PathDistanceIsValid(Vector3 from, Vector3 to, bool allowCloseRange)
private float PathDistance(int count, Vector3[]& path, float maxDistance)
public float SqrDistanceToSpawn()
public bool AllowedMovementDestination(Vector3 destination)
public Vector3 ToAllowedMovementDestination(Vector3 destination)
protected void AbortPlan()
protected void CompletePlan()
protected void TickReasoner(INpcReasoner reasoner, float deltaTime, float time)
public void OnSensation(Sensation sensation)
private void OnGunshotSensation(Sensation& info)
private void OnThrownWeaponSensation(Sensation& info)
private void OnExplosionSensation(Sensation& info)
private void RememberEntityOfInterest(Sensation& info)
private bool RememberGunshot(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberExplosion(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberThrownItem(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
protected void TickSensor(INpcSensor sensor, float deltaTime, float time)
public BearDefinition get_BearDefinition()
public Vector3 get_SpawnPosition()
public BearContext get_BearContext()
public BaseNpcContext get_NpcContext()
public IHTNContext get_PlannerContext()
public IUtilityAI get_PlannerAi()
public IUtilityAIClient get_PlannerAiClient()
public NavMeshAgent get_NavAgent()
public List`1<INpcSensor> get_Sensors()
public List`1<INpcReasoner> get_Reasoners()
public IAIContext GetContext(Guid aiId)
public void Initialize(BaseEntity body)
public void Dispose()
public void ResetState()
public void Tick(float time)
public void OnHurt(HitInfo info)
private bool RememberPlayerThatHurtUs(NpcPlayerInfo player, BasePlayer initiator)
public void ForceProjectileOrientation()
}
public Rust.Ai.HTN.Bear.BearMemory : BaseNpcMemory {
public BearContext BearContext
public Vector3 CachedPreferredDistanceDestination
public float CachedPreferredDistanceDestinationTime
public BaseNpcDefinition Definition
public BaseNpcDefinition get_Definition()
public void .ctor(BearContext context)
public void ResetState()
protected void OnSetPrimaryKnownEnemyPlayer(EnemyPlayerInfo& info)
}
public Rust.Ai.HTN.Bear.Facts : Enum {
public byte value__
public Facts HasEnemyTarget
public Facts CanSeeEnemy
public Facts CanHearEnemy
public Facts EnemyRange
public Facts CanNavigateToEnemy
public Facts IsNavigating
public Facts HealthState
public Facts PathStatus
public Facts AtLocationPreferredFightingRange
public Facts AtLocationLastKnownLocationOfPrimaryEnemyPlayer
public Facts IsSearching
public Facts IsIdle
public Facts IsLookingAround
public Facts Vulnerability
public Facts Frustration
public Facts Alertness
public Facts IsReturningHome
public Facts AtLocationHome
public Facts NearbyAnimal
public Facts IsAvoidingAnimal
public Facts IsStandingUp
public Facts IsTransitioning
public Facts HasPlayersInRange
}
public Rust.Ai.HTN.Bear.Reasoners.AlertnessReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.AnimalReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.AtHomeLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.AtLastKnownEnemyPlayerLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.EnemyPlayerHearingReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.EnemyPlayerLineOfSightReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.EnemyRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.EnemyTargetReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.FrustrationReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.HealthReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.OrientationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.PlayersInRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.PreferredFightingRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public bool IsAtPreferredRange(BearContext context, NpcPlayerInfo& target)
}
public Rust.Ai.HTN.Bear.Reasoners.ReturnHomeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Reasoners.VulnerabilityReasoner : object {
private float _lastVulnerabilityDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Sensors.AnimalsInRangeSensor : object {
public int MaxAnimals
public BaseNpc[] QueryResults
public int QueryResultCount
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Sensors.BearEnemyPlayersHearingSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public void TickStatic(IHTNAgent npc)
public void TickFootstepHearingTest(IHTNAgent npc, NpcPlayerInfo& info)
}
public Rust.Ai.HTN.Bear.Sensors.BearEnemyPlayersInRangeSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
protected bool EvaluatePlayer(BaseNpcContext context, IHTNAgent npc, NpcPlayerInfo player, float time)
}
public Rust.Ai.HTN.Bear.Sensors.BearEnemyPlayersLineOfSightSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public void TickStatic(IHTNAgent npc)
public void TickLineOfSightTest(IHTNAgent npc, NpcPlayerInfo& info)
public Ray AimAtBody(IHTNAgent npc, NpcPlayerInfo& info)
public Ray AimAtHead(IHTNAgent npc, NpcPlayerInfo& info)
public Ray AimAtBody(HTNPlayer npc, NpcPlayerInfo& info)
public Ray AimAtHead(HTNPlayer npc, NpcPlayerInfo& info)
public Ray AimAtBody(HTNAnimal npc, NpcPlayerInfo& info)
public Ray AimAtHead(HTNAnimal npc, NpcPlayerInfo& info)
}
public Rust.Ai.HTN.Bear.Sensors.BearPlayersDistanceSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Sensors.BearPlayersInRangeSensor : object {
public int MaxPlayers
public BasePlayer[] PlayerQueryResults
public int PlayerQueryResultCount
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Bear.Sensors.BearPlayersOutsideRangeSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
protected bool EvaluatePlayer(BaseNpcContext context, IHTNAgent npc, NpcPlayerInfo& player, float time)
}
public Rust.Ai.HTN.Bear.Sensors.BearPlayersViewAngleSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.EnemyAggroRange : Enum {
public byte value__
public EnemyAggroRange AggroRange
public EnemyAggroRange DeaggroRange
public EnemyAggroRange OutOfRange
}
public Rust.Ai.HTN.EnemyRange : Enum {
public byte value__
public EnemyRange CloseRange
public EnemyRange MediumRange
public EnemyRange LongRange
public EnemyRange OutOfRange
}
public Rust.Ai.HTN.HealthState : Enum {
public byte value__
public HealthState FullHealth
public HealthState HighHealth
public HealthState MediumHealth
public HealthState LowHealth
public HealthState Dead
}
public Rust.Ai.HTN.HTNDomain : MonoBehaviour {
public MovementRule Movement
public float MovementRadius
private Vector3 _currentOffset
public float SqrMovementRadius
public BaseNpcContext NpcContext
public IHTNContext PlannerContext
public IUtilityAI PlannerAi
public IUtilityAIClient PlannerAiClient
public NavMeshAgent NavAgent
public List`1<INpcSensor> Sensors
public List`1<INpcReasoner> Reasoners
public Byte[] WorldState
public Byte[] PreviousWorldState
public Stack`1<PrimitiveTaskSelector> Plan
public void TickPlan()
protected void AbortPlan()
protected void CompletePlan()
public void TickReasoners(float time)
protected bool CanTickReasoner(float deltaTime, INpcReasoner reasoner)
protected void TickReasoner(INpcReasoner reasoner, float deltaTime, float time)
public void TickSensors(float time)
protected bool CanTickSensor(float deltaTime, INpcSensor sensor)
protected void TickSensor(INpcSensor sensor, float deltaTime, float time)
public float get_SqrMovementRadius()
public BaseNpcContext get_NpcContext()
public IHTNContext get_PlannerContext()
public IUtilityAI get_PlannerAi()
public IUtilityAIClient get_PlannerAiClient()
public IAIContext GetContext(Guid aiId)
public NavMeshAgent get_NavAgent()
public List`1<INpcSensor> get_Sensors()
public List`1<INpcReasoner> get_Reasoners()
public Byte[] get_WorldState()
public Byte[] get_PreviousWorldState()
public Stack`1<PrimitiveTaskSelector> get_Plan()
public void Initialize(BaseEntity body)
public void Dispose()
public void TickDestinationTracker()
public void Resume()
public void Pause()
public Vector3 GetNextPosition(float delta)
public void ForceProjectileOrientation()
public void Think()
public void Tick(float time)
public void ResetState()
public Vector3 GetHeadingDirection()
public Vector3 GetHomeDirection()
public Vector3 GetLookAroundDirection(float deltaTime)
public void OnPreHurt(HitInfo info)
public void OnHurt(HitInfo info)
public void OnSensation(Sensation sensation)
public float SqrDistanceToSpawn()
public bool AllowedMovementDestination(Vector3 destination)
}
public Rust.Ai.HTN.HTNUtilityAiClient : UtilityAIClient {
public void .ctor(Guid aiId, IContextProvider contextProvider)
public void .ctor(IUtilityAI ai, IContextProvider contextProvider)
protected void OnPause()
protected void OnResume()
protected void OnStart()
protected void OnStop()
public void Initialize()
public void Kill()
}
public Rust.Ai.HTN.IHTNAgent {
public HTNDomain AiDomain
public BaseNpcDefinition AiDefinition
public bool IsDormant
public bool IsDestroyed
public BaseEntity Body
public Vector3 BodyPosition
public Vector3 EyePosition
public Quaternion EyeRotation
public BaseEntity MainTarget
public FamilyEnum Family
public Transform transform
public float healthFraction
public Vector3 estimatedVelocity
public HTNDomain get_AiDomain()
public BaseNpcDefinition get_AiDefinition()
public bool get_IsDormant()
public void set_IsDormant(bool value)
public bool get_IsDestroyed()
public BaseEntity get_Body()
public Vector3 get_BodyPosition()
public Vector3 get_EyePosition()
public Quaternion get_EyeRotation()
public BaseEntity get_MainTarget()
public FamilyEnum get_Family()
public Transform get_transform()
public float get_healthFraction()
public Vector3 get_estimatedVelocity()
}
public Rust.Ai.HTN.ItemType : Enum {
public byte value__
public ItemType MeleeWeapon
public ItemType ProjectileWeapon
public ItemType ThrowableWeapon
public ItemType HealingItem
public ItemType LightSourceItem
public ItemType ResearchItem
}
public Rust.Ai.HTN.Murderer.Facts : Enum {
public byte value__
public Facts HasEnemyTarget
public Facts CanSeeEnemy
public Facts CanHearEnemy
public Facts EnemyRange
public Facts CanNavigateToEnemy
public Facts IsNavigating
public Facts AmmoState
public Facts HealthState
public Facts HasWaypoints
public Facts PathStatus
public Facts FirearmOrder
public Facts FireTactic
public Facts IsReloading
public Facts AtLocationWaypoint
public Facts AtLocationPreferredFightingRange
public Facts AtLocationCover
public Facts AtLocationLastKnownLocationOfPrimaryEnemyPlayer
public Facts IsSearching
public Facts IsIdle
public Facts IsLookingAround
public Facts Vulnerability
public Facts IsDucking
public Facts IsWaiting
public Facts HeldItemType
public Facts HasNearbyCover
public Facts CoverTactic
public Facts MaintainCover
public Facts IsApplyingMedical
public Facts CoverState
public Facts Frustration
public Facts IsReturningHome
public Facts AtLocationHome
public Facts NearbyExplosives
public Facts IsAvoidingExplosive
public Facts NearbyAnimal
public Facts IsAvoidingAnimal
public Facts IsStandingUp
public Facts Alertness
public Facts IsThrowingWeapon
public Facts IsRoaming
}
public Rust.Ai.HTN.Murderer.FirearmOrders : Enum {
public byte value__
public FirearmOrders HoldYourFire
public FirearmOrders FireAtWill
public FirearmOrders FireAtIntervals
public FirearmOrders LaySupressionFire
}
public Rust.Ai.HTN.Murderer.FireTactic : Enum {
public byte value__
public FireTactic Burst
public FireTactic Single
public FireTactic FullAuto
}
public Rust.Ai.HTN.Murderer.MurdererContext : BaseNpcContext {
public bool _isWorldStateDirty
private Byte[] _worldState
private Byte[] _previousWorldState
private int _decompositionScore
private List`1<PrimitiveTaskSelector> _debugPlan
private Stack`1[] _worldStateChanges
private PlanResultType <PlanResult>k__BackingField
private PlanStateType <PlanState>k__BackingField
private Stack`1<PrimitiveTaskSelector> <HtnPlan>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedEffects>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedExpectedEffects>k__BackingField
public WorldStateChangedEvent OnWorldStateChangedEvent
private PrimitiveTaskSelector <CurrentTask>k__BackingField
public bool HasVisitedLastKnownEnemyPlayerLocation
private NpcOrientation <OrientationType>k__BackingField
private List`1<NpcPlayerInfo> <PlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInLineOfSight>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersAudible>k__BackingField
private List`1<NpcPlayerInfo> <PlayersOutsideDetectionRange>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerInLineOfSight>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerAudible>k__BackingField
private List`1<AnimalInfo> <AnimalsInRange>k__BackingField
public HTNPlayer Body
public MurdererDomain Domain
public MurdererMemory Memory
public AiLocationManager Location
public CoverPointVolume CoverVolume
public List`1<CoverPoint> CoverPoints
public CoverPoint BestFlankCover
public CoverPoint BestAdvanceCover
public CoverPoint BestRetreatCover
public CoverPoint ReservedCoverPoint
public float ReservedCoverTime
public PlanResultType PlanResult
public PlanStateType PlanState
public Stack`1<PrimitiveTaskSelector> HtnPlan
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedEffects
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedExpectedEffects
public bool IsWorldStateDirty
public Byte[] WorldState
public Byte[] PreviousWorldState
public Stack`1[] WorldStateChanges
public int DecompositionScore
public PrimitiveTaskSelector CurrentTask
public List`1<PrimitiveTaskSelector> DebugPlan
public NpcOrientation OrientationType
public List`1<NpcPlayerInfo> PlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInLineOfSight
public List`1<NpcPlayerInfo> EnemyPlayersAudible
public List`1<NpcPlayerInfo> PlayersOutsideDetectionRange
public NpcPlayerInfo PrimaryEnemyPlayerInLineOfSight
public NpcPlayerInfo PrimaryEnemyPlayerAudible
public List`1<AnimalInfo> AnimalsInRange
public Vector3 BodyPosition
public BaseNpcMemory BaseMemory
public CoverPoint ClosestCover
public PlanResultType get_PlanResult()
public void set_PlanResult(PlanResultType value)
public PlanStateType get_PlanState()
public void set_PlanState(PlanStateType value)
public Stack`1<PrimitiveTaskSelector> get_HtnPlan()
public void set_HtnPlan(Stack`1<PrimitiveTaskSelector> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedEffects()
public void set_AppliedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedExpectedEffects()
public void set_AppliedExpectedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public bool get_IsWorldStateDirty()
public void set_IsWorldStateDirty(bool value)
public Byte[] get_WorldState()
public Byte[] get_PreviousWorldState()
public Stack`1[] get_WorldStateChanges()
public int get_DecompositionScore()
public void set_DecompositionScore(int value)
public PrimitiveTaskSelector get_CurrentTask()
public void set_CurrentTask(PrimitiveTaskSelector value)
public List`1<PrimitiveTaskSelector> get_DebugPlan()
public NpcOrientation get_OrientationType()
public void set_OrientationType(NpcOrientation value)
public List`1<NpcPlayerInfo> get_PlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInLineOfSight()
public List`1<NpcPlayerInfo> get_EnemyPlayersAudible()
public List`1<NpcPlayerInfo> get_PlayersOutsideDetectionRange()
public NpcPlayerInfo get_PrimaryEnemyPlayerInLineOfSight()
public void set_PrimaryEnemyPlayerInLineOfSight(NpcPlayerInfo value)
public NpcPlayerInfo get_PrimaryEnemyPlayerAudible()
public void set_PrimaryEnemyPlayerAudible(NpcPlayerInfo value)
public NpcPlayerInfo GetPrimaryEnemyPlayerTarget()
public bool HasPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetBody()
public Vector3 GetDirectionToAnimal()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetHead()
public Vector3 GetDirectionToMemoryOfPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionLookAround()
public Vector3 GetDirectionLastAttackedDir()
public Vector3 GetDirectionAudibleTarget()
public List`1<AnimalInfo> get_AnimalsInRange()
public Vector3 get_BodyPosition()
public BaseNpcMemory get_BaseMemory()
public CoverPoint get_ClosestCover()
public void ReserveCoverPoint(CoverPoint coverPoint)
public void StartDomainDecomposition()
public void ResetState()
public void .ctor(HTNPlayer body, MurdererDomain domain)
public void Dispose()
public bool IsBodyAlive()
public void IncrementFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void IncrementFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, EnemyRange value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, AmmoState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, HealthState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, ItemType value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FireTactic value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FirearmOrders value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, bool value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(Facts fact)
public byte GetPreviousFact(Facts fact)
public void SetFact(byte fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(byte fact)
public bool IsFact(Facts fact)
public void PushFactChangeDuringPlanning(Facts fact, ItemType value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, FirearmOrders value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, HealthState value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, bool value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, int value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, byte value, bool temporary)
public void PushFactChangeDuringPlanning(byte fact, byte value, bool temporary)
public void PopFactChangeDuringPlanning(Facts fact)
public void PopFactChangeDuringPlanning(byte fact)
public byte PeekFactChangeDuringPlanning(Facts fact)
public byte PeekFactChangeDuringPlanning(byte fact)
public byte GetWorldState(Facts fact)
}
public Rust.Ai.HTN.Murderer.MurdererDefinition : BaseNpcDefinition {
public AnimationCurve MissFunction
public PlayerInventoryProperties[] loadouts
public LootSpawnSlot[] Loot
public GameObjectRef DeathEffect
public void StartVoices(HTNPlayer target)
public void StopVoices(HTNPlayer target)
public void Loadout(HTNPlayer target)
public void OnlyLoadoutWeapons(HTNPlayer target)
public IEnumerator EquipWeapon(HTNPlayer target)
public BaseCorpse OnCreateCorpse(HTNPlayer target)
}
public Rust.Ai.HTN.Murderer.MurdererDomain : HTNDomain {
private bool _isRegisteredWithAgency
private Vector3 missOffset
private float missToHeadingAlignmentTime
private float repeatMissTime
private bool recalculateMissOffset
private bool isMissing
private bool _passPathValidity
private Vector3[] pathCornerCache
private NavMeshPath _pathCache
public OnPlanAborted OnPlanAbortedEvent
public OnPlanCompleted OnPlanCompletedEvent
private MurdererContext _context
private NavMeshAgent _navAgent
private Vector3 _spawnPosition
private List`1<INpcSensor> _sensors
private List`1<INpcReasoner> _reasoners
private float _lastFirearmUsageTime
private bool _isFiring
public bool ReducedLongRangeAccuracy
private HTNUtilityAiClient _aiClient
private MurdererDefinition _murdererDefinition
public MurdererDefinition MurdererDefinition
public Vector3 SpawnPosition
public MurdererContext MurdererContext
public BaseNpcContext NpcContext
public IHTNContext PlannerContext
public IUtilityAI PlannerAi
public IUtilityAIClient PlannerAiClient
public NavMeshAgent NavAgent
public List`1<INpcSensor> Sensors
public List`1<INpcReasoner> Reasoners
private void InitializeAgency()
private void RemoveAgency()
public void Resume()
public void Pause()
private void TickFirearm(float time)
private void TickFirearm(float time, float interval)
private void FireFullAuto(BaseProjectile proj, float time)
private void FireBurst(BaseProjectile proj, float time)
private void FireSingle(AttackEntity attackEnt, float time)
private IEnumerator HoldTriggerLogic(BaseProjectile proj, float startTime, float triggerDownInterval)
public AttackEntity GetFirearm()
public BaseProjectile GetFirearmProj()
public BaseProjectile ReloadFirearmProjIfEmpty()
public AttackEntity ReloadFirearmIfEmpty()
public void ReloadFirearmIfEmpty(BaseProjectile proj)
public BaseProjectile ReloadFirearm()
public void ReloadFirearm(BaseProjectile proj)
private IEnumerator ReloadHandler(BaseProjectile proj)
private bool CanUseFirearmAtRange(float sqrRange)
public void ForceProjectileOrientation()
public Vector3 ModifyFirearmAim(Vector3 heading, Vector3 target, Vector3 origin, float swayModifier)
private Vector3 GetMissVector(Vector3 heading, Vector3 target, Vector3 origin, float maxTime, float repeatTime)
public void PauseNavigation()
public void ResumeNavigation()
public Vector3 GetNextPosition(float delta)
private void UpdateNavmeshOffset()
private IEnumerator TryForceToNavmesh()
public bool SetDestination(Vector3 destination, bool passPathValidity)
public void TickDestinationTracker()
public bool IsPathValid()
public Vector3 GetHeadingDirection()
public Vector3 GetHomeDirection()
public void StopNavigating()
public bool PathDistanceIsValid(Vector3 from, Vector3 to, bool allowCloseRange)
private float PathDistance(int count, Vector3[]& path, float maxDistance)
public float SqrDistanceToSpawn()
public bool AllowedMovementDestination(Vector3 destination)
public Vector3 ToAllowedMovementDestination(Vector3 destination)
protected void AbortPlan()
protected void CompletePlan()
protected void TickReasoner(INpcReasoner reasoner, float deltaTime, float time)
public void OnSensation(Sensation sensation)
private void OnGunshotSensation(Sensation& info)
private void OnThrownWeaponSensation(Sensation& info)
private void OnExplosionSensation(Sensation& info)
private void RememberEntityOfInterest(Sensation& info)
private bool RememberGunshot(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberExplosion(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberThrownItem(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
protected void TickSensor(INpcSensor sensor, float deltaTime, float time)
public MurdererDefinition get_MurdererDefinition()
public Vector3 get_SpawnPosition()
public MurdererContext get_MurdererContext()
public BaseNpcContext get_NpcContext()
public IHTNContext get_PlannerContext()
public IUtilityAI get_PlannerAi()
public IUtilityAIClient get_PlannerAiClient()
public NavMeshAgent get_NavAgent()
public List`1<INpcSensor> get_Sensors()
public List`1<INpcReasoner> get_Reasoners()
public IAIContext GetContext(Guid aiId)
public void Initialize(BaseEntity body)
private IEnumerator DelayedForcedThink()
public void Dispose()
public void ResetState()
public void Tick(float time)
public void OnPreHurt(HitInfo info)
public void OnHurt(HitInfo info)
private bool RememberPlayerThatHurtUs(NpcPlayerInfo player, BasePlayer initiator)
}
public Rust.Ai.HTN.Murderer.MurdererMemory : BaseNpcMemory {
public MurdererContext MurdererContext
public Vector3 CachedPreferredDistanceDestination
public float CachedPreferredDistanceDestinationTime
public Vector3 CachedRoamDestination
public float CachedRoamDestinationTime
public BaseNpcDefinition Definition
public BaseNpcDefinition get_Definition()
public void .ctor(MurdererContext context)
public void ResetState()
protected void OnSetPrimaryKnownEnemyPlayer(EnemyPlayerInfo& info)
}
public Rust.Ai.HTN.Murderer.MurdererSpawner : MonoBehaviour {
public GameObjectRef MurdererPrefab
public List`1<MurdererDomain> Spawned
public BaseSpawnPoint[] SpawnPoints
public int MaxPopulation
public bool InitialSpawn
public float MinRespawnTimeMinutes
public float MaxRespawnTimeMinutes
public MovementRule Movement
public float MovementRadius
public bool ReducedLongRangeAccuracy
private float nextRespawnTime
private bool pendingRespawn
public int currentPopulation
public int get_currentPopulation()
private void Awake()
public void Fill()
public void Clear()
public void SpawnInitial()
public void SpawnRepeating()
public void CheckIfRespawnNeeded()
private bool IsAllSpawnedDead()
public void ScheduleRespawn()
public void DoRespawn()
public void SpawnScientist()
private BaseSpawnPoint GetSpawnPoint(Vector3& pos, Quaternion& rot)
}
public Rust.Ai.HTN.Murderer.Reasoners.AlertnessReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.AnimalReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.AtHomeLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.AtLastKnownEnemyPlayerLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.EnemyPlayerHearingReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.EnemyPlayerLineOfSightReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.EnemyRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.EnemyTargetReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.FireTacticReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.FrustrationReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.HealthReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.OrientationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.PreferredFightingRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public bool IsAtPreferredRange(MurdererContext context, NpcPlayerInfo& target, AttackEntity firearm)
}
public Rust.Ai.HTN.Murderer.Reasoners.ReturnHomeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Reasoners.VulnerabilityReasoner : object {
private float _lastVulnerabilityDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Murderer.Sensors.AnimalsInRangeSensor : object {
public int MaxAnimals
public BaseNpc[] QueryResults
public int QueryResultCount
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NpcOrientation : Enum {
public int value__
public NpcOrientation None
public NpcOrientation Heading
public NpcOrientation PrimaryTargetBody
public NpcOrientation PrimaryTargetHead
public NpcOrientation LastKnownPrimaryTargetLocation
public NpcOrientation LookAround
public NpcOrientation LastAttackedDirection
public NpcOrientation AudibleTargetDirection
public NpcOrientation LookAtAnimal
public NpcOrientation Home
}
public Rust.Ai.HTN.NpcPlayerInfo : ValueType {
public BasePlayer Player
public float Time
public float SqrDistance
public float ForwardDotDir
public bool BodyVisible
public bool HeadVisible
public float AudibleScore
public float VisibilityScore
}
public Rust.Ai.HTN.NPCTurret.Facts : Enum {
public byte value__
public Facts HasEnemyTarget
public Facts CanSeeEnemy
public Facts EnemyRange
public Facts AmmoState
public Facts HealthState
public Facts FirearmOrder
public Facts FireTactic
public Facts IsReloading
public Facts Alertness
public Facts HeldItemType
public Facts IsIdle
public Facts IsWaiting
public Facts NearbyAnimal
}
public Rust.Ai.HTN.NPCTurret.FirearmOrders : Enum {
public byte value__
public FirearmOrders HoldYourFire
public FirearmOrders FireAtWill
public FirearmOrders FireAtIntervals
public FirearmOrders LaySupressionFire
}
public Rust.Ai.HTN.NPCTurret.FireTactic : Enum {
public byte value__
public FireTactic Burst
public FireTactic Single
public FireTactic FullAuto
}
public Rust.Ai.HTN.NPCTurret.NPCTurretContext : BaseNpcContext {
public bool _isWorldStateDirty
private Byte[] _worldState
private Byte[] _previousWorldState
private int _decompositionScore
private List`1<PrimitiveTaskSelector> _debugPlan
private Stack`1[] _worldStateChanges
private PlanResultType <PlanResult>k__BackingField
private PlanStateType <PlanState>k__BackingField
private Stack`1<PrimitiveTaskSelector> <HtnPlan>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedEffects>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedExpectedEffects>k__BackingField
public WorldStateChangedEvent OnWorldStateChangedEvent
private PrimitiveTaskSelector <CurrentTask>k__BackingField
private NpcOrientation <OrientationType>k__BackingField
private List`1<NpcPlayerInfo> <PlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInLineOfSight>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersAudible>k__BackingField
private List`1<NpcPlayerInfo> <PlayersOutsideDetectionRange>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerInLineOfSight>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerAudible>k__BackingField
private List`1<AnimalInfo> <AnimalsInRange>k__BackingField
public HTNPlayer Body
public NPCTurretDomain Domain
public NPCTurretMemory Memory
public AiLocationManager Location
public PlanResultType PlanResult
public PlanStateType PlanState
public Stack`1<PrimitiveTaskSelector> HtnPlan
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedEffects
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedExpectedEffects
public bool IsWorldStateDirty
public Byte[] WorldState
public Byte[] PreviousWorldState
public Stack`1[] WorldStateChanges
public int DecompositionScore
public PrimitiveTaskSelector CurrentTask
public List`1<PrimitiveTaskSelector> DebugPlan
public NpcOrientation OrientationType
public List`1<NpcPlayerInfo> PlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInLineOfSight
public List`1<NpcPlayerInfo> EnemyPlayersAudible
public List`1<NpcPlayerInfo> PlayersOutsideDetectionRange
public NpcPlayerInfo PrimaryEnemyPlayerInLineOfSight
public NpcPlayerInfo PrimaryEnemyPlayerAudible
public List`1<AnimalInfo> AnimalsInRange
public Vector3 BodyPosition
public BaseNpcMemory BaseMemory
public PlanResultType get_PlanResult()
public void set_PlanResult(PlanResultType value)
public PlanStateType get_PlanState()
public void set_PlanState(PlanStateType value)
public Stack`1<PrimitiveTaskSelector> get_HtnPlan()
public void set_HtnPlan(Stack`1<PrimitiveTaskSelector> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedEffects()
public void set_AppliedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedExpectedEffects()
public void set_AppliedExpectedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public bool get_IsWorldStateDirty()
public void set_IsWorldStateDirty(bool value)
public Byte[] get_WorldState()
public Byte[] get_PreviousWorldState()
public Stack`1[] get_WorldStateChanges()
public int get_DecompositionScore()
public void set_DecompositionScore(int value)
public PrimitiveTaskSelector get_CurrentTask()
public void set_CurrentTask(PrimitiveTaskSelector value)
public List`1<PrimitiveTaskSelector> get_DebugPlan()
public NpcOrientation get_OrientationType()
public void set_OrientationType(NpcOrientation value)
public List`1<NpcPlayerInfo> get_PlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInLineOfSight()
public List`1<NpcPlayerInfo> get_EnemyPlayersAudible()
public List`1<NpcPlayerInfo> get_PlayersOutsideDetectionRange()
public NpcPlayerInfo get_PrimaryEnemyPlayerInLineOfSight()
public void set_PrimaryEnemyPlayerInLineOfSight(NpcPlayerInfo value)
public NpcPlayerInfo get_PrimaryEnemyPlayerAudible()
public void set_PrimaryEnemyPlayerAudible(NpcPlayerInfo value)
public NpcPlayerInfo GetPrimaryEnemyPlayerTarget()
public bool HasPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetBody()
public Vector3 GetDirectionToAnimal()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetHead()
public Vector3 GetDirectionToMemoryOfPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionLookAround()
public Vector3 GetDirectionLastAttackedDir()
public Vector3 GetDirectionAudibleTarget()
public List`1<AnimalInfo> get_AnimalsInRange()
public Vector3 get_BodyPosition()
public BaseNpcMemory get_BaseMemory()
public void StartDomainDecomposition()
public void ResetState()
public void .ctor(HTNPlayer body, NPCTurretDomain domain)
public void Dispose()
public bool IsBodyAlive()
public void IncrementFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void IncrementFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, AmmoState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, HealthState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, ItemType value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FireTactic value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FirearmOrders value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, bool value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(Facts fact)
public byte GetPreviousFact(Facts fact)
public void SetFact(byte fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(byte fact)
public bool IsFact(Facts fact)
public void PushFactChangeDuringPlanning(Facts fact, ItemType value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, FirearmOrders value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, HealthState value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, bool value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, int value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, byte value, bool temporary)
public void PushFactChangeDuringPlanning(byte fact, byte value, bool temporary)
public void PopFactChangeDuringPlanning(Facts fact)
public void PopFactChangeDuringPlanning(byte fact)
public byte PeekFactChangeDuringPlanning(Facts fact)
public byte PeekFactChangeDuringPlanning(byte fact)
public byte GetWorldState(Facts fact)
}
public Rust.Ai.HTN.NPCTurret.NPCTurretDefinition : BaseNpcDefinition {
public PlayerInventoryProperties[] loadouts
public LootSpawnSlot[] Loot
public Vector2 RadioEffectRepeatRange
public GameObjectRef RadioEffect
public GameObjectRef DeathEffect
private bool _isRadioEffectRunning
public string CorpsePath
public void StartVoices(HTNPlayer target)
public void StopVoices(HTNPlayer target)
private IEnumerator RadioChatter(HTNPlayer target)
public void Loadout(HTNPlayer target)
public IEnumerator EquipWeapon(HTNPlayer target)
public BaseCorpse OnCreateCorpse(HTNPlayer target)
}
public Rust.Ai.HTN.NPCTurret.NPCTurretDomain : HTNDomain {
private bool _isRegisteredWithAgency
private Vector3 missOffset
private float missToHeadingAlignmentTime
private float repeatMissTime
private bool recalculateMissOffset
private bool isMissing
public OnPlanAborted OnPlanAbortedEvent
public OnPlanCompleted OnPlanCompletedEvent
private NPCTurretContext _context
private Vector3 _spawnPosition
private List`1<INpcSensor> _sensors
private List`1<INpcReasoner> _reasoners
private float _lastFirearmUsageTime
private bool _isFiring
public bool ReducedLongRangeAccuracy
public bool BurstAtLongRange
private HTNUtilityAiClient _aiClient
public Vector3 SpawnPosition
public NPCTurretContext NPCTurretContext
public BaseNpcContext NpcContext
public IHTNContext PlannerContext
public IUtilityAI PlannerAi
public IUtilityAIClient PlannerAiClient
public NavMeshAgent NavAgent
public List`1<INpcSensor> Sensors
public List`1<INpcReasoner> Reasoners
private void InitializeAgency()
private void RemoveAgency()
public void Resume()
public void Pause()
private void TickFirearm(float time)
private void TickFirearm(float time, float interval)
private void FireFullAuto(BaseProjectile proj, float time)
private void FireBurst(BaseProjectile proj, float time)
private void FireSingle(AttackEntity attackEnt, float time)
private IEnumerator HoldTriggerLogic(BaseProjectile proj, float startTime, float triggerDownInterval)
public AttackEntity GetFirearm()
public BaseProjectile GetFirearmProj()
public BaseProjectile ReloadFirearmProjIfEmpty()
public AttackEntity ReloadFirearmIfEmpty()
public void ReloadFirearmIfEmpty(BaseProjectile proj)
public BaseProjectile ReloadFirearm()
public void ReloadFirearm(BaseProjectile proj)
private IEnumerator ReloadHandler(BaseProjectile proj)
private bool CanUseFirearmAtRange(float sqrRange)
public void ForceProjectileOrientation()
public Vector3 ModifyFirearmAim(Vector3 heading, Vector3 target, Vector3 origin, float swayModifier)
private Vector3 GetMissVector(Vector3 heading, Vector3 target, Vector3 origin, float maxTime, float repeatTime, float missOffsetMultiplier)
public void TickDestinationTracker()
public Vector3 GetHeadingDirection()
public Vector3 GetHomeDirection()
public float SqrDistanceToSpawn()
public bool AllowedMovementDestination(Vector3 destination)
public Vector3 GetNextPosition(float delta)
protected void AbortPlan()
protected void CompletePlan()
protected void TickReasoner(INpcReasoner reasoner, float deltaTime, float time)
public void OnSensation(Sensation sensation)
private void OnGunshotSensation(Sensation& info)
private void OnThrownWeaponSensation(Sensation& info)
private void OnExplosionSensation(Sensation& info)
private void RememberEntityOfInterest(Sensation& info)
private bool RememberGunshot(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberExplosion(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberThrownItem(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
protected void TickSensor(INpcSensor sensor, float deltaTime, float time)
public Vector3 get_SpawnPosition()
public NPCTurretContext get_NPCTurretContext()
public BaseNpcContext get_NpcContext()
public IHTNContext get_PlannerContext()
public IUtilityAI get_PlannerAi()
public IUtilityAIClient get_PlannerAiClient()
public NavMeshAgent get_NavAgent()
public List`1<INpcSensor> get_Sensors()
public List`1<INpcReasoner> get_Reasoners()
public IAIContext GetContext(Guid aiId)
public void Initialize(BaseEntity body)
public void Dispose()
public void ResetState()
public void Tick(float time)
public void OnHurt(HitInfo info)
private bool RememberPlayerThatHurtUs(NpcPlayerInfo player, BasePlayer initiator)
}
public Rust.Ai.HTN.NPCTurret.NPCTurretMemory : BaseNpcMemory {
public NPCTurretContext NPCTurretContext
public BaseNpcDefinition Definition
public BaseNpcDefinition get_Definition()
public void .ctor(NPCTurretContext context)
public void ResetState()
}
public Rust.Ai.HTN.NPCTurret.NPCTurretSpawner : MonoBehaviour {
public GameObjectRef NPCTurretPrefab
public List`1<NPCTurretDomain> Spawned
public BaseSpawnPoint[] SpawnPoints
public int MaxPopulation
public bool InitialSpawn
public float MinRespawnTimeMinutes
public float MaxRespawnTimeMinutes
public bool OnlyRotateAroundYAxis
public bool ReducedLongRangeAccuracy
public bool BurstAtLongRange
private bool pendingRespawn
private bool _lastInvokeWasNoSpawn
private void Awake()
public void Start()
public void DelayedStart()
public void CheckIfRespawnNeeded()
private bool IsAllSpawnedDead()
public void ScheduleRespawn()
public void DoRespawn()
public void SpawnScientist()
private BaseSpawnPoint GetSpawnPoint(Vector3& pos, Quaternion& rot)
}
public Rust.Ai.HTN.NPCTurret.Reasoners.AlertnessReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NPCTurret.Reasoners.AmmoReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NPCTurret.Reasoners.AnimalReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NPCTurret.Reasoners.EnemyPlayerLineOfSightReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NPCTurret.Reasoners.EnemyTargetReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NPCTurret.Reasoners.FirearmPoseReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NPCTurret.Reasoners.FireTacticReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NPCTurret.Reasoners.HealthReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NPCTurret.Reasoners.OrientationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.NPCTurret.Sensors.AnimalsInRangeSensor : object {
public int MaxAnimals
public BaseNpc[] QueryResults
public int QueryResultCount
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.PathStatus : Enum {
public byte value__
public PathStatus NoPath
public PathStatus PathRunning
public PathStatus PathComplete
public PathStatus PathFailed
}
public Rust.Ai.HTN.Reasoning.INpcReasoner {
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.CoverState : Enum {
public byte value__
public CoverState None
public CoverState Partial
public CoverState Full
}
public Rust.Ai.HTN.Scientist.CoverTactic : Enum {
public byte value__
public CoverTactic None
public CoverTactic Advance
public CoverTactic Retreat
public CoverTactic Flank
public CoverTactic Closest
}
public Rust.Ai.HTN.Scientist.Facts : Enum {
public byte value__
public Facts HasEnemyTarget
public Facts CanSeeEnemy
public Facts CanHearEnemy
public Facts EnemyRange
public Facts CanNavigateToEnemy
public Facts IsNavigating
public Facts AmmoState
public Facts HealthState
public Facts HasWaypoints
public Facts PathStatus
public Facts FirearmOrder
public Facts FireTactic
public Facts IsReloading
public Facts AtLocationWaypoint
public Facts AtLocationPreferredFightingRange
public Facts AtLocationCover
public Facts AtLocationLastKnownLocationOfPrimaryEnemyPlayer
public Facts IsSearching
public Facts IsIdle
public Facts IsLookingAround
public Facts Vulnerability
public Facts IsDucking
public Facts IsWaiting
public Facts HeldItemType
public Facts HasNearbyCover
public Facts CoverTactic
public Facts MaintainCover
public Facts IsApplyingMedical
public Facts CoverState
public Facts Frustration
public Facts IsReturningHome
public Facts AtLocationHome
public Facts NearbyExplosives
public Facts IsAvoidingExplosive
public Facts NearbyAnimal
public Facts IsAvoidingAnimal
public Facts IsStandingUp
public Facts Alertness
public Facts IsThrowingWeapon
}
public Rust.Ai.HTN.Scientist.FirearmOrders : Enum {
public byte value__
public FirearmOrders HoldYourFire
public FirearmOrders FireAtWill
public FirearmOrders FireAtIntervals
public FirearmOrders LaySupressionFire
}
public Rust.Ai.HTN.Scientist.FireTactic : Enum {
public byte value__
public FireTactic Burst
public FireTactic Single
public FireTactic FullAuto
}
public Rust.Ai.HTN.Scientist.Reasoners.AlertnessReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.AmmoReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.AnimalReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.AtCoverLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.AtHomeLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.AtLastKnownEnemyPlayerLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.CoverPointsReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
private bool EvaluateAdvancement(IHTNAgent npc, ScientistContext c, Single& bestScore, EnemyPlayerInfo& enemyInfo, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness)
private bool EvaluateRetreat(IHTNAgent npc, ScientistContext c, Single& bestScore, EnemyPlayerInfo& enemyInfo, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, Single& directness)
private bool EvaluateFlanking(IHTNAgent npc, ScientistContext c, Single& bestScore, EnemyPlayerInfo& enemyInfo, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness)
}
public Rust.Ai.HTN.Scientist.Reasoners.EnemyPlayerHearingReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.EnemyPlayerLineOfSightReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.EnemyRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.EnemyTargetReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.ExplosivesReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.FirearmPoseReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.FireTacticReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.FrustrationReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.HealthReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.MaintainCoverReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.OrientationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.PreferredFightingRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public bool IsAtPreferredRange(ScientistContext context, NpcPlayerInfo& target, AttackEntity firearm)
public float GetPreferredRange(ScientistContext context, NpcPlayerInfo& target, AttackEntity firearm)
}
public Rust.Ai.HTN.Scientist.Reasoners.ReturnHomeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Reasoners.VulnerabilityReasoner : object {
private float _lastVulnerabilityDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.ScientistContext : BaseNpcContext {
public bool _isWorldStateDirty
private Byte[] _worldState
private Byte[] _previousWorldState
private int _decompositionScore
private List`1<PrimitiveTaskSelector> _debugPlan
private Stack`1[] _worldStateChanges
private PlanResultType <PlanResult>k__BackingField
private PlanStateType <PlanState>k__BackingField
private Stack`1<PrimitiveTaskSelector> <HtnPlan>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedEffects>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedExpectedEffects>k__BackingField
public WorldStateChangedEvent OnWorldStateChangedEvent
private PrimitiveTaskSelector <CurrentTask>k__BackingField
public bool HasVisitedLastKnownEnemyPlayerLocation
private NpcOrientation <OrientationType>k__BackingField
private List`1<NpcPlayerInfo> <PlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInLineOfSight>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersAudible>k__BackingField
private List`1<NpcPlayerInfo> <PlayersOutsideDetectionRange>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerInLineOfSight>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerAudible>k__BackingField
private List`1<AnimalInfo> <AnimalsInRange>k__BackingField
public HTNPlayer Body
public ScientistDomain Domain
public ScientistMemory Memory
public AiLocationManager Location
public CoverPointVolume CoverVolume
public List`1<CoverPoint> CoverPoints
public CoverPoint BestFlankCover
public CoverPoint BestAdvanceCover
public CoverPoint BestRetreatCover
public CoverPoint ReservedCoverPoint
public float ReservedCoverTime
public PlanResultType PlanResult
public PlanStateType PlanState
public Stack`1<PrimitiveTaskSelector> HtnPlan
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedEffects
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedExpectedEffects
public bool IsWorldStateDirty
public Byte[] WorldState
public Byte[] PreviousWorldState
public Stack`1[] WorldStateChanges
public int DecompositionScore
public PrimitiveTaskSelector CurrentTask
public List`1<PrimitiveTaskSelector> DebugPlan
public NpcOrientation OrientationType
public List`1<NpcPlayerInfo> PlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInLineOfSight
public List`1<NpcPlayerInfo> EnemyPlayersAudible
public List`1<NpcPlayerInfo> PlayersOutsideDetectionRange
public NpcPlayerInfo PrimaryEnemyPlayerInLineOfSight
public NpcPlayerInfo PrimaryEnemyPlayerAudible
public List`1<AnimalInfo> AnimalsInRange
public Vector3 BodyPosition
public BaseNpcMemory BaseMemory
public CoverPoint ClosestCover
public PlanResultType get_PlanResult()
public void set_PlanResult(PlanResultType value)
public PlanStateType get_PlanState()
public void set_PlanState(PlanStateType value)
public Stack`1<PrimitiveTaskSelector> get_HtnPlan()
public void set_HtnPlan(Stack`1<PrimitiveTaskSelector> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedEffects()
public void set_AppliedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedExpectedEffects()
public void set_AppliedExpectedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public bool get_IsWorldStateDirty()
public void set_IsWorldStateDirty(bool value)
public Byte[] get_WorldState()
public Byte[] get_PreviousWorldState()
public Stack`1[] get_WorldStateChanges()
public int get_DecompositionScore()
public void set_DecompositionScore(int value)
public PrimitiveTaskSelector get_CurrentTask()
public void set_CurrentTask(PrimitiveTaskSelector value)
public List`1<PrimitiveTaskSelector> get_DebugPlan()
public NpcOrientation get_OrientationType()
public void set_OrientationType(NpcOrientation value)
public List`1<NpcPlayerInfo> get_PlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInLineOfSight()
public List`1<NpcPlayerInfo> get_EnemyPlayersAudible()
public List`1<NpcPlayerInfo> get_PlayersOutsideDetectionRange()
public NpcPlayerInfo get_PrimaryEnemyPlayerInLineOfSight()
public void set_PrimaryEnemyPlayerInLineOfSight(NpcPlayerInfo value)
public NpcPlayerInfo get_PrimaryEnemyPlayerAudible()
public void set_PrimaryEnemyPlayerAudible(NpcPlayerInfo value)
public NpcPlayerInfo GetPrimaryEnemyPlayerTarget()
public bool HasPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetBody()
public Vector3 GetDirectionToAnimal()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetHead()
public Vector3 GetDirectionToMemoryOfPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionLookAround()
public Vector3 GetDirectionLastAttackedDir()
public Vector3 GetDirectionAudibleTarget()
public List`1<AnimalInfo> get_AnimalsInRange()
public Vector3 get_BodyPosition()
public BaseNpcMemory get_BaseMemory()
public CoverPoint get_ClosestCover()
public void ReserveCoverPoint(CoverPoint coverPoint)
public void StartDomainDecomposition()
public void ResetState()
public void .ctor(HTNPlayer body, ScientistDomain domain)
public void Dispose()
public bool IsBodyAlive()
public void IncrementFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void IncrementFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, EnemyRange value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, CoverState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, CoverTactic value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, AmmoState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, HealthState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, ItemType value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FireTactic value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FirearmOrders value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, bool value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(Facts fact)
public byte GetPreviousFact(Facts fact)
public void SetFact(byte fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(byte fact)
public bool IsFact(Facts fact)
public void PushFactChangeDuringPlanning(Facts fact, CoverState value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, ItemType value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, FirearmOrders value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, HealthState value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, bool value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, int value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, byte value, bool temporary)
public void PushFactChangeDuringPlanning(byte fact, byte value, bool temporary)
public void PopFactChangeDuringPlanning(Facts fact)
public void PopFactChangeDuringPlanning(byte fact)
public byte PeekFactChangeDuringPlanning(Facts fact)
public byte PeekFactChangeDuringPlanning(byte fact)
public byte GetWorldState(Facts fact)
}
public Rust.Ai.HTN.Scientist.ScientistDefinition : BaseNpcDefinition {
public AnimationCurve MissFunction
public PlayerInventoryProperties[] loadouts
public LootSpawnSlot[] Loot
public Vector2 RadioEffectRepeatRange
public GameObjectRef RadioEffect
public GameObjectRef DeathEffect
private bool _isRadioEffectRunning
public void StartVoices(HTNPlayer target)
public void StopVoices(HTNPlayer target)
private IEnumerator RadioChatter(HTNPlayer target)
public void Loadout(HTNPlayer target)
public IEnumerator EquipWeapon(HTNPlayer target)
public BaseCorpse OnCreateCorpse(HTNPlayer target)
}
public Rust.Ai.HTN.Scientist.ScientistDomain : HTNDomain {
private bool _isRegisteredWithAgency
private Vector3 missOffset
private float missToHeadingAlignmentTime
private float repeatMissTime
private bool recalculateMissOffset
private bool isMissing
private Vector3[] pathCornerCache
private NavMeshPath _pathCache
public OnPlanAborted OnPlanAbortedEvent
public OnPlanCompleted OnPlanCompletedEvent
private ScientistContext _context
private NavMeshAgent _navAgent
private Vector3 _spawnPosition
private List`1<INpcSensor> _sensors
private List`1<INpcReasoner> _reasoners
private float _lastFirearmUsageTime
private bool _isFiring
public bool ReducedLongRangeAccuracy
private HTNUtilityAiClient _aiClient
private ScientistDefinition _scientistDefinition
public ScientistDefinition ScientistDefinition
public Vector3 SpawnPosition
public ScientistContext ScientistContext
public BaseNpcContext NpcContext
public IHTNContext PlannerContext
public IUtilityAI PlannerAi
public IUtilityAIClient PlannerAiClient
public NavMeshAgent NavAgent
public List`1<INpcSensor> Sensors
public List`1<INpcReasoner> Reasoners
private void InitializeAgency()
private void RemoveAgency()
public void Resume()
public void Pause()
private void TickFirearm(float time)
private void TickFirearm(float time, float interval)
private void FireFullAuto(BaseProjectile proj, float time)
private void FireBurst(BaseProjectile proj, float time)
private void FireSingle(AttackEntity attackEnt, float time)
private IEnumerator HoldTriggerLogic(BaseProjectile proj, float startTime, float triggerDownInterval)
public AttackEntity GetFirearm()
public BaseProjectile GetFirearmProj()
public BaseProjectile ReloadFirearmProjIfEmpty()
public AttackEntity ReloadFirearmIfEmpty()
public void ReloadFirearmIfEmpty(BaseProjectile proj)
public BaseProjectile ReloadFirearm()
public void ReloadFirearm(BaseProjectile proj)
private IEnumerator ReloadHandler(BaseProjectile proj)
private bool CanUseFirearmAtRange(float sqrRange)
public void ForceProjectileOrientation()
public Vector3 ModifyFirearmAim(Vector3 heading, Vector3 target, Vector3 origin, float swayModifier)
private Vector3 GetMissVector(Vector3 heading, Vector3 target, Vector3 origin, float maxTime, float repeatTime)
public void PauseNavigation()
public void ResumeNavigation()
public Vector3 GetNextPosition(float delta)
private void UpdateNavmeshOffset()
private IEnumerator TryForceToNavmesh()
public bool SetDestination(Vector3 destination)
public void TickDestinationTracker()
public bool IsPathValid()
public Vector3 GetHeadingDirection()
public Vector3 GetHomeDirection()
public void StopNavigating()
public bool PathDistanceIsValid(Vector3 from, Vector3 to, bool allowCloseRange)
private float PathDistance(int count, Vector3[]& path, float maxDistance)
public float SqrDistanceToSpawn()
public bool AllowedMovementDestination(Vector3 destination)
public Vector3 ToAllowedMovementDestination(Vector3 destination)
public float GetAllowedCoverRangeSqr()
protected void AbortPlan()
protected void CompletePlan()
protected void TickReasoner(INpcReasoner reasoner, float deltaTime, float time)
public void OnSensation(Sensation sensation)
private void OnGunshotSensation(Sensation& info)
private void OnThrownWeaponSensation(Sensation& info)
private void OnExplosionSensation(Sensation& info)
private void RememberEntityOfInterest(Sensation& info)
private bool RememberGunshot(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberExplosion(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberThrownItem(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
protected void TickSensor(INpcSensor sensor, float deltaTime, float time)
public ScientistDefinition get_ScientistDefinition()
public Vector3 get_SpawnPosition()
public ScientistContext get_ScientistContext()
public BaseNpcContext get_NpcContext()
public IHTNContext get_PlannerContext()
public IUtilityAI get_PlannerAi()
public IUtilityAIClient get_PlannerAiClient()
public NavMeshAgent get_NavAgent()
public List`1<INpcSensor> get_Sensors()
public List`1<INpcReasoner> get_Reasoners()
public IAIContext GetContext(Guid aiId)
public void Initialize(BaseEntity body)
public void Dispose()
public void ResetState()
public void Tick(float time)
public void OnHurt(HitInfo info)
private bool RememberPlayerThatHurtUs(NpcPlayerInfo player, BasePlayer initiator)
}
public Rust.Ai.HTN.Scientist.ScientistMemory : BaseNpcMemory {
public ScientistContext ScientistContext
public Vector3 CachedPreferredDistanceDestination
public float CachedPreferredDistanceDestinationTime
public Vector3 CachedCoverDestination
public float CachedCoverDestinationTime
public BaseNpcDefinition Definition
public BaseNpcDefinition get_Definition()
public void .ctor(ScientistContext context)
public void ResetState()
protected void OnSetPrimaryKnownEnemyPlayer(EnemyPlayerInfo& info)
}
public Rust.Ai.HTN.Scientist.ScientistSpawner : MonoBehaviour {
public GameObjectRef ScientistPrefab
public List`1<ScientistDomain> Spawned
public BaseSpawnPoint[] SpawnPoints
public int MaxPopulation
public bool InitialSpawn
public float MinRespawnTimeMinutes
public float MaxRespawnTimeMinutes
public MovementRule Movement
public float MovementRadius
public bool ReducedLongRangeAccuracy
private float nextRespawnTime
private bool pendingRespawn
public int currentPopulation
public int get_currentPopulation()
private void Awake()
public void Fill()
public void Clear()
public void SpawnInitial()
public void SpawnRepeating()
public void CheckIfRespawnNeeded()
private bool IsAllSpawnedDead()
public void ScheduleRespawn()
public void DoRespawn()
public void SpawnScientist()
private BaseSpawnPoint GetSpawnPoint(Vector3& pos, Quaternion& rot)
}
public Rust.Ai.HTN.Scientist.Sensors.AnimalsInRangeSensor : object {
public int MaxAnimals
public BaseNpc[] QueryResults
public int QueryResultCount
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Scientist.Sensors.CoverPointsInRangeSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
private CoverPointComparer coverPointComparer
private float nextCoverPosInfoTick
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
private bool _FindCoverPointsInVolume(Vector3 position, List`1<CoverPoint> coverPoints, CoverPointVolume& volume, Single& nextTime, float time, AiLocationManager location, float maxDistanceToCoverSqr)
}
public Rust.Ai.HTN.ScientistAStar.CoverState : Enum {
public byte value__
public CoverState None
public CoverState Partial
public CoverState Full
}
public Rust.Ai.HTN.ScientistAStar.CoverTactic : Enum {
public byte value__
public CoverTactic None
public CoverTactic Advance
public CoverTactic Retreat
public CoverTactic Flank
public CoverTactic Closest
}
public Rust.Ai.HTN.ScientistAStar.Facts : Enum {
public byte value__
public Facts HasEnemyTarget
public Facts CanSeeEnemy
public Facts CanHearEnemy
public Facts EnemyRange
public Facts CanNavigateToEnemy
public Facts IsNavigating
public Facts AmmoState
public Facts HealthState
public Facts HasWaypoints
public Facts PathStatus
public Facts FirearmOrder
public Facts FireTactic
public Facts IsReloading
public Facts AtLocationWaypoint
public Facts AtLocationPreferredFightingRange
public Facts AtLocationCover
public Facts AtLocationLastKnownLocationOfPrimaryEnemyPlayer
public Facts IsSearching
public Facts IsIdle
public Facts IsLookingAround
public Facts Vulnerability
public Facts IsDucking
public Facts IsWaiting
public Facts HeldItemType
public Facts HasNearbyCover
public Facts CoverTactic
public Facts MaintainCover
public Facts IsApplyingMedical
public Facts CoverState
public Facts Frustration
public Facts IsReturningHome
public Facts AtLocationHome
public Facts NearbyExplosives
public Facts IsAvoidingExplosive
public Facts NearbyAnimal
public Facts IsAvoidingAnimal
public Facts IsStandingUp
public Facts Alertness
public Facts IsThrowingWeapon
public Facts AtLocationNextAStarWaypoint
}
public Rust.Ai.HTN.ScientistAStar.FirearmOrders : Enum {
public byte value__
public FirearmOrders HoldYourFire
public FirearmOrders FireAtWill
public FirearmOrders FireAtIntervals
public FirearmOrders LaySupressionFire
}
public Rust.Ai.HTN.ScientistAStar.FireTactic : Enum {
public byte value__
public FireTactic Burst
public FireTactic Single
public FireTactic FullAuto
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.AlertnessReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.AmmoReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.AnimalReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.AtCoverLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.AtHomeLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.AtLastKnownEnemyPlayerLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.AtNextAStarWaypointLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.CoverPointsReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
private bool EvaluateAdvancement(IHTNAgent npc, ScientistAStarContext c, Single& bestScore, EnemyPlayerInfo& enemyInfo, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness)
private bool EvaluateRetreat(IHTNAgent npc, ScientistAStarContext c, Single& bestScore, EnemyPlayerInfo& enemyInfo, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, Single& directness)
private bool EvaluateFlanking(IHTNAgent npc, ScientistAStarContext c, Single& bestScore, EnemyPlayerInfo& enemyInfo, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.EnemyPlayerHearingReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.EnemyPlayerLineOfSightReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.EnemyRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.EnemyTargetReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.ExplosivesReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.FirearmPoseReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.FireTacticReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.FrustrationReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.HealthReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.MaintainCoverReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.OrientationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.PreferredFightingRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public bool IsAtPreferredRange(ScientistAStarContext context, NpcPlayerInfo& target, AttackEntity firearm)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.ReturnHomeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Reasoners.VulnerabilityReasoner : object {
private float _lastVulnerabilityDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.ScientistAStarContext : BaseNpcContext {
public bool _isWorldStateDirty
private Byte[] _worldState
private Byte[] _previousWorldState
private int _decompositionScore
private List`1<PrimitiveTaskSelector> _debugPlan
private Stack`1[] _worldStateChanges
private PlanResultType <PlanResult>k__BackingField
private PlanStateType <PlanState>k__BackingField
private Stack`1<PrimitiveTaskSelector> <HtnPlan>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedEffects>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedExpectedEffects>k__BackingField
public WorldStateChangedEvent OnWorldStateChangedEvent
private PrimitiveTaskSelector <CurrentTask>k__BackingField
public bool HasVisitedLastKnownEnemyPlayerLocation
private NpcOrientation <OrientationType>k__BackingField
private List`1<NpcPlayerInfo> <PlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInLineOfSight>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersAudible>k__BackingField
private List`1<NpcPlayerInfo> <PlayersOutsideDetectionRange>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerInLineOfSight>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerAudible>k__BackingField
private List`1<AnimalInfo> <AnimalsInRange>k__BackingField
public HTNPlayer Body
public ScientistAStarDomain Domain
public ScientistAStarMemory Memory
public AiLocationManager Location
public CoverPointVolume CoverVolume
public List`1<CoverPoint> CoverPoints
public CoverPoint BestFlankCover
public CoverPoint BestAdvanceCover
public CoverPoint BestRetreatCover
public CoverPoint ReservedCoverPoint
public float ReservedCoverTime
public PlanResultType PlanResult
public PlanStateType PlanState
public Stack`1<PrimitiveTaskSelector> HtnPlan
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedEffects
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedExpectedEffects
public bool IsWorldStateDirty
public Byte[] WorldState
public Byte[] PreviousWorldState
public Stack`1[] WorldStateChanges
public int DecompositionScore
public PrimitiveTaskSelector CurrentTask
public List`1<PrimitiveTaskSelector> DebugPlan
public NpcOrientation OrientationType
public List`1<NpcPlayerInfo> PlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInLineOfSight
public List`1<NpcPlayerInfo> EnemyPlayersAudible
public List`1<NpcPlayerInfo> PlayersOutsideDetectionRange
public NpcPlayerInfo PrimaryEnemyPlayerInLineOfSight
public NpcPlayerInfo PrimaryEnemyPlayerAudible
public List`1<AnimalInfo> AnimalsInRange
public Vector3 BodyPosition
public Vector3 BodyLocalPosition
public BaseNpcMemory BaseMemory
public CoverPoint ClosestCover
public PlanResultType get_PlanResult()
public void set_PlanResult(PlanResultType value)
public PlanStateType get_PlanState()
public void set_PlanState(PlanStateType value)
public Stack`1<PrimitiveTaskSelector> get_HtnPlan()
public void set_HtnPlan(Stack`1<PrimitiveTaskSelector> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedEffects()
public void set_AppliedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedExpectedEffects()
public void set_AppliedExpectedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public bool get_IsWorldStateDirty()
public void set_IsWorldStateDirty(bool value)
public Byte[] get_WorldState()
public Byte[] get_PreviousWorldState()
public Stack`1[] get_WorldStateChanges()
public int get_DecompositionScore()
public void set_DecompositionScore(int value)
public PrimitiveTaskSelector get_CurrentTask()
public void set_CurrentTask(PrimitiveTaskSelector value)
public List`1<PrimitiveTaskSelector> get_DebugPlan()
public NpcOrientation get_OrientationType()
public void set_OrientationType(NpcOrientation value)
public List`1<NpcPlayerInfo> get_PlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInLineOfSight()
public List`1<NpcPlayerInfo> get_EnemyPlayersAudible()
public List`1<NpcPlayerInfo> get_PlayersOutsideDetectionRange()
public NpcPlayerInfo get_PrimaryEnemyPlayerInLineOfSight()
public void set_PrimaryEnemyPlayerInLineOfSight(NpcPlayerInfo value)
public NpcPlayerInfo get_PrimaryEnemyPlayerAudible()
public void set_PrimaryEnemyPlayerAudible(NpcPlayerInfo value)
public NpcPlayerInfo GetPrimaryEnemyPlayerTarget()
public bool HasPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetBody()
public Vector3 GetDirectionToAnimal()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetHead()
public Vector3 GetDirectionToMemoryOfPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionLookAround()
public Vector3 GetDirectionLastAttackedDir()
public Vector3 GetDirectionAudibleTarget()
public List`1<AnimalInfo> get_AnimalsInRange()
public Vector3 get_BodyPosition()
public Vector3 get_BodyLocalPosition()
public BaseNpcMemory get_BaseMemory()
public CoverPoint get_ClosestCover()
public void ReserveCoverPoint(CoverPoint coverPoint)
public void StartDomainDecomposition()
public void ResetState()
public void .ctor(HTNPlayer body, ScientistAStarDomain domain)
public void Dispose()
public bool IsBodyAlive()
public void IncrementFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void IncrementFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, EnemyRange value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, CoverState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, CoverTactic value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, AmmoState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, HealthState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, ItemType value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FireTactic value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FirearmOrders value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, bool value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(Facts fact)
public byte GetPreviousFact(Facts fact)
public void SetFact(byte fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(byte fact)
public bool IsFact(Facts fact)
public void PushFactChangeDuringPlanning(Facts fact, CoverState value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, ItemType value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, FirearmOrders value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, HealthState value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, bool value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, int value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, byte value, bool temporary)
public void PushFactChangeDuringPlanning(byte fact, byte value, bool temporary)
public void PopFactChangeDuringPlanning(Facts fact)
public void PopFactChangeDuringPlanning(byte fact)
public byte PeekFactChangeDuringPlanning(Facts fact)
public byte PeekFactChangeDuringPlanning(byte fact)
public byte GetWorldState(Facts fact)
}
public Rust.Ai.HTN.ScientistAStar.ScientistAStarDefinition : BaseNpcDefinition {
public AnimationCurve MissFunction
public PlayerInventoryProperties[] loadouts
public LootSpawnSlot[] Loot
public Vector2 RadioEffectRepeatRange
public GameObjectRef RadioEffect
public GameObjectRef DeathEffect
private bool _isRadioEffectRunning
public void StartVoices(HTNPlayer target)
public void StopVoices(HTNPlayer target)
private IEnumerator RadioChatter(HTNPlayer target)
public void Loadout(HTNPlayer target)
public IEnumerator EquipWeapon(HTNPlayer target)
public BaseCorpse OnCreateCorpse(HTNPlayer target)
}
public Rust.Ai.HTN.ScientistAStar.ScientistAStarDomain : HTNDomain {
private bool _isRegisteredWithAgency
private Vector3 missOffset
private float missToHeadingAlignmentTime
private float repeatMissTime
private bool recalculateMissOffset
private bool isMissing
private Vector3 _lastNavigationHeading
public BasePath Path
public List`1<BasePathNode> CurrentPath
public int CurrentPathIndex
public bool PathLooping
public BasePathNode FinalDestination
public float StoppingDistance
public OnPlanAborted OnPlanAbortedEvent
public OnPlanCompleted OnPlanCompletedEvent
private ScientistAStarContext _context
private Vector3 _spawnPosition
private List`1<INpcSensor> _sensors
private List`1<INpcReasoner> _reasoners
private float _lastFirearmUsageTime
private bool _isFiring
private HTNUtilityAiClient _aiClient
private ScientistAStarDefinition _scientistDefinition
public bool HasPath
public float SqrStoppingDistance
public ScientistAStarDefinition ScientistDefinition
public Vector3 SpawnPosition
public ScientistAStarContext ScientistContext
public BaseNpcContext NpcContext
public IHTNContext PlannerContext
public IUtilityAI PlannerAi
public IUtilityAIClient PlannerAiClient
public NavMeshAgent NavAgent
public List`1<INpcSensor> Sensors
public List`1<INpcReasoner> Reasoners
private void InitializeAgency()
private void RemoveAgency()
public void Resume()
public void Pause()
private void TickFirearm(float time)
private void TickFirearm(float time, float interval)
private void FireFullAuto(BaseProjectile proj, float time)
private void FireBurst(BaseProjectile proj, float time)
private void FireSingle(AttackEntity attackEnt, float time)
private IEnumerator HoldTriggerLogic(BaseProjectile proj, float startTime, float triggerDownInterval)
public AttackEntity GetFirearm()
public BaseProjectile GetFirearmProj()
public BaseProjectile ReloadFirearmProjIfEmpty()
public AttackEntity ReloadFirearmIfEmpty()
public void ReloadFirearmIfEmpty(BaseProjectile proj)
public BaseProjectile ReloadFirearm()
public void ReloadFirearm(BaseProjectile proj)
private IEnumerator ReloadHandler(BaseProjectile proj)
private bool CanUseFirearmAtRange(float sqrRange)
public void ForceProjectileOrientation()
public Vector3 ModifyFirearmAim(Vector3 heading, Vector3 target, Vector3 origin, float swayModifier)
private Vector3 GetMissVector(Vector3 heading, Vector3 target, Vector3 origin, float maxTime, float repeatTime)
public void PauseNavigation()
public void ResumeNavigation()
public Vector3 GetNextPosition(float delta)
public bool SetDestination(Vector3 destination)
private bool _SetDestination(Vector3 destination)
public void TickDestinationTracker()
public bool IsPathValid()
public Vector3 GetHeadingDirection()
public Vector3 GetHomeDirection()
public void StopNavigating()
public bool PathDistanceIsValid(Vector3 from, Vector3 to, bool allowCloseRange)
private float PathDistance(int count, Vector3[]& path, float maxDistance)
public float SqrDistanceToSpawn()
public bool AllowedMovementDestination(Vector3 destination)
public Vector3 ToAllowedMovementDestination(Vector3 destination)
public float GetAllowedCoverRangeSqr()
public bool get_HasPath()
public float get_SqrStoppingDistance()
public void InstallPath(BasePath path)
public void ClearPath()
public bool IndexValid(int index)
public BasePathNode GetFinalDestination()
public Vector3 GetCurrentPathDestination()
public bool PathComplete()
public bool AtCurrentPathNode()
public int GetLoopedIndex(int index)
public Vector3 PathDirection(int index)
public Vector3 IdealPathPosition()
public bool AdvancePathMovement()
public Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom)
public bool GetPathToClosestTurnableNode(BasePathNode start, Vector3 forward, List`1& nodes)
public bool GetEngagementPath(List`1& nodes)
public bool IsAtDestination()
public bool IsAtFinalDestination()
public Vector3 ClosestPointAlongPath(Vector3 start, Vector3 end, Vector3 fromPos)
protected void AbortPlan()
protected void CompletePlan()
protected void TickReasoner(INpcReasoner reasoner, float deltaTime, float time)
public void OnSensation(Sensation sensation)
private void OnGunshotSensation(Sensation& info)
private void OnThrownWeaponSensation(Sensation& info)
private void OnExplosionSensation(Sensation& info)
private void RememberEntityOfInterest(Sensation& info)
private bool RememberGunshot(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberExplosion(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberThrownItem(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
protected void TickSensor(INpcSensor sensor, float deltaTime, float time)
public ScientistAStarDefinition get_ScientistDefinition()
public Vector3 get_SpawnPosition()
public ScientistAStarContext get_ScientistContext()
public BaseNpcContext get_NpcContext()
public IHTNContext get_PlannerContext()
public IUtilityAI get_PlannerAi()
public IUtilityAIClient get_PlannerAiClient()
public NavMeshAgent get_NavAgent()
public List`1<INpcSensor> get_Sensors()
public List`1<INpcReasoner> get_Reasoners()
public IAIContext GetContext(Guid aiId)
public void Initialize(BaseEntity body)
public void Dispose()
public void ResetState()
public void Tick(float time)
public void OnHurt(HitInfo info)
private bool RememberPlayerThatHurtUs(NpcPlayerInfo player, BasePlayer initiator)
}
public Rust.Ai.HTN.ScientistAStar.ScientistAStarMemory : BaseNpcMemory {
public ScientistAStarContext ScientistContext
public Vector3 CachedPreferredDistanceDestination
public float CachedPreferredDistanceDestinationTime
public Vector3 CachedCoverDestination
public float CachedCoverDestinationTime
public BaseNpcDefinition Definition
public BaseNpcDefinition get_Definition()
public void .ctor(ScientistAStarContext context)
public void ResetState()
protected void OnSetPrimaryKnownEnemyPlayer(EnemyPlayerInfo& info)
}
public Rust.Ai.HTN.ScientistAStar.ScientistAStarSpawner : MonoBehaviour {
public BasePath Path
public GameObjectRef ScientistAStarPrefab
public List`1<ScientistAStarDomain> Spawned
public BaseSpawnPoint[] SpawnPoints
public int MaxPopulation
public bool InitialSpawn
public float MinRespawnTimeMinutes
public float MaxRespawnTimeMinutes
private bool pendingRespawn
private bool _lastInvokeWasNoSpawn
private void Awake()
public void Start()
public void DelayedStart()
public void CheckIfRespawnNeeded()
private bool IsAllSpawnedDead()
public void ScheduleRespawn()
public void DoRespawn()
public void SpawnScientist()
private BaseSpawnPoint GetSpawnPoint(Vector3& pos, Quaternion& rot)
}
public Rust.Ai.HTN.ScientistAStar.Sensors.AnimalsInRangeSensor : object {
public int MaxAnimals
public BaseNpc[] QueryResults
public int QueryResultCount
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistAStar.Sensors.CoverPointsInRangeSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
private CoverPointComparer coverPointComparer
private float nextCoverPosInfoTick
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
private bool _FindCoverPointsInVolume(IHTNAgent npc, Vector3 position, List`1<CoverPoint> coverPoints, CoverPointVolume& volume, Single& nextTime, float time, AiLocationManager location, float maxDistanceToCoverSqr)
}
public Rust.Ai.HTN.ScientistJunkpile.CoverState : Enum {
public byte value__
public CoverState None
public CoverState Partial
public CoverState Full
}
public Rust.Ai.HTN.ScientistJunkpile.CoverTactic : Enum {
public byte value__
public CoverTactic None
public CoverTactic Advance
public CoverTactic Retreat
public CoverTactic Flank
public CoverTactic Closest
}
public Rust.Ai.HTN.ScientistJunkpile.Facts : Enum {
public byte value__
public Facts HasEnemyTarget
public Facts CanSeeEnemy
public Facts CanHearEnemy
public Facts EnemyRange
public Facts CanNavigateToEnemy
public Facts IsNavigating
public Facts AmmoState
public Facts HealthState
public Facts HasWaypoints
public Facts PathStatus
public Facts FirearmOrder
public Facts FireTactic
public Facts IsReloading
public Facts AtLocationWaypoint
public Facts AtLocationPreferredFightingRange
public Facts AtLocationCover
public Facts AtLocationLastKnownLocationOfPrimaryEnemyPlayer
public Facts IsSearching
public Facts IsIdle
public Facts IsLookingAround
public Facts Vulnerability
public Facts IsDucking
public Facts IsWaiting
public Facts HeldItemType
public Facts HasNearbyCover
public Facts CoverTactic
public Facts MaintainCover
public Facts IsApplyingMedical
public Facts CoverState
public Facts Frustration
public Facts IsReturningHome
public Facts AtLocationHome
public Facts NearbyExplosives
public Facts IsAvoidingExplosive
public Facts NearbyAnimal
public Facts IsAvoidingAnimal
public Facts IsStandingUp
public Facts Alertness
public Facts IsThrowingWeapon
public Facts IsUsingTool
}
public Rust.Ai.HTN.ScientistJunkpile.FirearmOrders : Enum {
public byte value__
public FirearmOrders HoldYourFire
public FirearmOrders FireAtWill
public FirearmOrders FireAtIntervals
public FirearmOrders LaySupressionFire
}
public Rust.Ai.HTN.ScientistJunkpile.FireTactic : Enum {
public byte value__
public FireTactic Burst
public FireTactic Single
public FireTactic FullAuto
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.AlertnessReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.AmmoReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.AnimalReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public bool IsNearby(ScientistJunkpileDomain domain, float sqrDistance)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.AtCoverLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.AtHomeLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.AtLastKnownEnemyPlayerLocationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.CoverPointsReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
private bool EvaluateAdvancement(IHTNAgent npc, ScientistJunkpileContext c, Single& bestScore, EnemyPlayerInfo& enemyInfo, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness)
private bool EvaluateRetreat(IHTNAgent npc, ScientistJunkpileContext c, Single& bestScore, EnemyPlayerInfo& enemyInfo, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, Single& directness)
private bool EvaluateFlanking(IHTNAgent npc, ScientistJunkpileContext c, Single& bestScore, EnemyPlayerInfo& enemyInfo, CoverPoint option, Vector3 dirCover, Vector3 dirDanger, float directness)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.EnemyPlayerHearingReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.EnemyPlayerLineOfSightReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.EnemyPlayerMarkTooCloseReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.EnemyRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.EnemyTargetReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.ExplosivesReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.FirearmPoseReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.FireTacticReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.FollowWaypointsReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
private WaypointSet <WaypointSet>k__BackingField
private int <WaypointDirection>k__BackingField
private bool <IsWaitingAtWaypoint>k__BackingField
private int <CurrentWaypointIndex>k__BackingField
private float <WaypointDelayTime>k__BackingField
private bool isFollowingWaypoints
private bool isFirstTick
private bool hasAlreadyPassedOnPrevCheck
public float TickFrequency
public float LastTickTime
private WaypointSet WaypointSet
private int WaypointDirection
private bool IsWaitingAtWaypoint
private int CurrentWaypointIndex
private float WaypointDelayTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
private WaypointSet get_WaypointSet()
private void set_WaypointSet(WaypointSet value)
private int get_WaypointDirection()
private void set_WaypointDirection(int value)
private bool get_IsWaitingAtWaypoint()
private void set_IsWaitingAtWaypoint(bool value)
private int get_CurrentWaypointIndex()
private void set_CurrentWaypointIndex(int value)
private float get_WaypointDelayTime()
private void set_WaypointDelayTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public int PeekNextWaypointIndex()
public int GetNextWaypointIndex()
public int GetClosestWaypointIndex(Vector3 position)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.FrustrationReasoner : object {
private float _lastFrustrationDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.HealthReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.MaintainCoverReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.OrientationReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.PreferredFightingRangeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public bool IsAtPreferredRange(ScientistJunkpileContext context, NpcPlayerInfo& target, AttackEntity firearm)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.ReturnHomeReasoner : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Reasoners.VulnerabilityReasoner : object {
private float _lastVulnerabilityDecrementTime
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.ScientistJunkpileContext : BaseNpcContext {
public bool _isWorldStateDirty
private Byte[] _worldState
private Byte[] _previousWorldState
private int _decompositionScore
private List`1<PrimitiveTaskSelector> _debugPlan
private Stack`1[] _worldStateChanges
private PlanResultType <PlanResult>k__BackingField
private PlanStateType <PlanState>k__BackingField
private Stack`1<PrimitiveTaskSelector> <HtnPlan>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedEffects>k__BackingField
private Dictionary`2<Guid, Stack`1<IEffect>> <AppliedExpectedEffects>k__BackingField
public WorldStateChangedEvent OnWorldStateChangedEvent
private PrimitiveTaskSelector <CurrentTask>k__BackingField
public bool HasVisitedLastKnownEnemyPlayerLocation
private NpcOrientation <OrientationType>k__BackingField
private List`1<NpcPlayerInfo> <PlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInRange>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersInLineOfSight>k__BackingField
private List`1<NpcPlayerInfo> <EnemyPlayersAudible>k__BackingField
private List`1<NpcPlayerInfo> <PlayersOutsideDetectionRange>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerInLineOfSight>k__BackingField
private NpcPlayerInfo <PrimaryEnemyPlayerAudible>k__BackingField
private List`1<AnimalInfo> <AnimalsInRange>k__BackingField
public HTNPlayer Body
public ScientistJunkpileDomain Domain
public ScientistJunkpileMemory Memory
public AiLocationManager Location
public JunkPile Junkpile
public CoverPointVolume CoverVolume
public List`1<CoverPoint> CoverPoints
public CoverPoint BestFlankCover
public CoverPoint BestAdvanceCover
public CoverPoint BestRetreatCover
public CoverPoint ReservedCoverPoint
public float ReservedCoverTime
public PlanResultType PlanResult
public PlanStateType PlanState
public Stack`1<PrimitiveTaskSelector> HtnPlan
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedEffects
public Dictionary`2<Guid, Stack`1<IEffect>> AppliedExpectedEffects
public bool IsWorldStateDirty
public Byte[] WorldState
public Byte[] PreviousWorldState
public Stack`1[] WorldStateChanges
public int DecompositionScore
public PrimitiveTaskSelector CurrentTask
public List`1<PrimitiveTaskSelector> DebugPlan
public NpcOrientation OrientationType
public List`1<NpcPlayerInfo> PlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInRange
public List`1<NpcPlayerInfo> EnemyPlayersInLineOfSight
public List`1<NpcPlayerInfo> EnemyPlayersAudible
public List`1<NpcPlayerInfo> PlayersOutsideDetectionRange
public NpcPlayerInfo PrimaryEnemyPlayerInLineOfSight
public NpcPlayerInfo PrimaryEnemyPlayerAudible
public List`1<AnimalInfo> AnimalsInRange
public Vector3 BodyPosition
public BaseNpcMemory BaseMemory
public CoverPoint ClosestCover
public PlanResultType get_PlanResult()
public void set_PlanResult(PlanResultType value)
public PlanStateType get_PlanState()
public void set_PlanState(PlanStateType value)
public Stack`1<PrimitiveTaskSelector> get_HtnPlan()
public void set_HtnPlan(Stack`1<PrimitiveTaskSelector> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedEffects()
public void set_AppliedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public Dictionary`2<Guid, Stack`1<IEffect>> get_AppliedExpectedEffects()
public void set_AppliedExpectedEffects(Dictionary`2<Guid, Stack`1<IEffect>> value)
public bool get_IsWorldStateDirty()
public void set_IsWorldStateDirty(bool value)
public Byte[] get_WorldState()
public Byte[] get_PreviousWorldState()
public Stack`1[] get_WorldStateChanges()
public int get_DecompositionScore()
public void set_DecompositionScore(int value)
public PrimitiveTaskSelector get_CurrentTask()
public void set_CurrentTask(PrimitiveTaskSelector value)
public List`1<PrimitiveTaskSelector> get_DebugPlan()
public NpcOrientation get_OrientationType()
public void set_OrientationType(NpcOrientation value)
public List`1<NpcPlayerInfo> get_PlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInRange()
public List`1<NpcPlayerInfo> get_EnemyPlayersInLineOfSight()
public List`1<NpcPlayerInfo> get_EnemyPlayersAudible()
public List`1<NpcPlayerInfo> get_PlayersOutsideDetectionRange()
public NpcPlayerInfo get_PrimaryEnemyPlayerInLineOfSight()
public void set_PrimaryEnemyPlayerInLineOfSight(NpcPlayerInfo value)
public NpcPlayerInfo get_PrimaryEnemyPlayerAudible()
public void set_PrimaryEnemyPlayerAudible(NpcPlayerInfo value)
public NpcPlayerInfo GetPrimaryEnemyPlayerTarget()
public bool HasPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetBody()
public Vector3 GetDirectionToAnimal()
public Vector3 GetDirectionToPrimaryEnemyPlayerTargetHead()
public Vector3 GetDirectionToMemoryOfPrimaryEnemyPlayerTarget()
public Vector3 GetDirectionLookAround()
public Vector3 GetDirectionLastAttackedDir()
public Vector3 GetDirectionAudibleTarget()
public List`1<AnimalInfo> get_AnimalsInRange()
public Vector3 get_BodyPosition()
public BaseNpcMemory get_BaseMemory()
public CoverPoint get_ClosestCover()
public void ReserveCoverPoint(CoverPoint coverPoint)
public void StartDomainDecomposition()
public void ResetState()
public void .ctor(HTNPlayer body, ScientistJunkpileDomain domain)
public void Dispose()
public bool IsBodyAlive()
public void IncrementFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void IncrementFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, EnemyRange value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, CoverState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, CoverTactic value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, AmmoState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, HealthState value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, ItemType value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FireTactic value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, FirearmOrders value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, bool value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, int value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public void SetFact(Facts fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(Facts fact)
public byte GetPreviousFact(Facts fact)
public void SetFact(byte fact, byte value, bool invokeChangedEvent, bool setAsDirty, bool checkValueDiff)
public byte GetFact(byte fact)
public bool IsFact(Facts fact)
public void PushFactChangeDuringPlanning(Facts fact, CoverState value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, ItemType value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, FirearmOrders value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, HealthState value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, bool value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, int value, bool temporary)
public void PushFactChangeDuringPlanning(Facts fact, byte value, bool temporary)
public void PushFactChangeDuringPlanning(byte fact, byte value, bool temporary)
public void PopFactChangeDuringPlanning(Facts fact)
public void PopFactChangeDuringPlanning(byte fact)
public byte PeekFactChangeDuringPlanning(Facts fact)
public byte PeekFactChangeDuringPlanning(byte fact)
public byte GetWorldState(Facts fact)
}
public Rust.Ai.HTN.ScientistJunkpile.ScientistJunkpileDefinition : BaseNpcDefinition {
public AnimationCurve MissFunction
public PlayerInventoryProperties[] loadouts
public LootSpawnSlot[] Loot
public Vector2 RadioEffectRepeatRange
public GameObjectRef RadioEffect
public GameObjectRef DeathEffect
private bool _isRadioEffectRunning
public void StartVoices(HTNPlayer target)
public void StopVoices(HTNPlayer target)
private IEnumerator RadioChatter(HTNPlayer target)
public void Loadout(HTNPlayer target)
public IEnumerator EquipTool(HTNPlayer target)
public BaseCorpse OnCreateCorpse(HTNPlayer target)
}
public Rust.Ai.HTN.ScientistJunkpile.ScientistJunkpileDomain : HTNDomain {
private bool _isRegisteredWithAgency
private List`1<ScientistJunkpileDomain> _allJunkpileNPCs
private Vector3 missOffset
private float missToHeadingAlignmentTime
private float repeatMissTime
private bool recalculateMissOffset
private bool isMissing
private Vector3[] pathCornerCache
private NavMeshPath _pathCache
public OnPlanAborted OnPlanAbortedEvent
public OnPlanCompleted OnPlanCompletedEvent
private ScientistJunkpileContext _context
private NavMeshAgent _navAgent
private Vector3 _spawnPosition
private List`1<INpcSensor> _sensors
private List`1<INpcReasoner> _reasoners
private float _lastFirearmUsageTime
private bool _isFiring
public bool ReducedLongRangeAccuracy
private HTNUtilityAiClient _aiClient
private ScientistJunkpileDefinition _scientistJunkpileDefinition
public List`1<ScientistJunkpileDomain> AllJunkpileNPCs
public ScientistJunkpileDefinition ScientistDefinition
public Vector3 SpawnPosition
public ScientistJunkpileContext ScientistContext
public BaseNpcContext NpcContext
public IHTNContext PlannerContext
public IUtilityAI PlannerAi
public IUtilityAIClient PlannerAiClient
public NavMeshAgent NavAgent
public List`1<INpcSensor> Sensors
public List`1<INpcReasoner> Reasoners
public List`1<ScientistJunkpileDomain> get_AllJunkpileNPCs()
private void InitializeAgency()
private void RemoveAgency()
public void Resume()
public void Pause()
private void TickFirearm(float time)
private void TickFirearm(float time, float interval)
private void FireFullAuto(BaseProjectile proj, float time)
private void FireBurst(BaseProjectile proj, float time)
private void FireSingle(AttackEntity attackEnt, float time)
private IEnumerator HoldTriggerLogic(BaseProjectile proj, float startTime, float triggerDownInterval)
public AttackEntity GetFirearm()
public BaseProjectile GetFirearmProj()
public BaseProjectile ReloadFirearmProjIfEmpty()
public AttackEntity ReloadFirearmIfEmpty()
public void ReloadFirearmIfEmpty(BaseProjectile proj)
public BaseProjectile ReloadFirearm()
public void ReloadFirearm(BaseProjectile proj)
private IEnumerator ReloadHandler(BaseProjectile proj)
private bool CanUseFirearmAtRange(float sqrRange)
public void ForceProjectileOrientation()
public Vector3 ModifyFirearmAim(Vector3 heading, Vector3 target, Vector3 origin, float swayModifier)
private Vector3 GetMissVector(Vector3 heading, Vector3 target, Vector3 origin, float maxTime, float repeatTime)
public void PauseNavigation()
public void ResumeNavigation()
public Vector3 GetNextPosition(float delta)
private void UpdateNavmeshOffset()
private IEnumerator TryForceToNavmesh()
public bool SetDestination(Vector3 destination)
public void TickDestinationTracker()
public bool IsPathValid()
public Vector3 GetHeadingDirection()
public Vector3 GetHomeDirection()
public void StopNavigating()
public bool PathDistanceIsValid(Vector3 from, Vector3 to, bool allowCloseRange)
private float PathDistance(int count, Vector3[]& path, float maxDistance)
public float SqrDistanceToSpawn()
public bool AllowedMovementDestination(Vector3 destination)
public Vector3 ToAllowedMovementDestination(Vector3 destination)
public float GetAllowedCoverRangeSqr()
protected void AbortPlan()
protected void CompletePlan()
protected bool CanTickReasoner(float deltaTime, INpcReasoner reasoner)
protected void TickReasoner(INpcReasoner reasoner, float deltaTime, float time)
public void OnSensation(Sensation sensation)
private void OnGunshotSensation(Sensation& info)
private void OnThrownWeaponSensation(Sensation& info)
private void OnExplosionSensation(Sensation& info)
private void RememberEntityOfInterest(Sensation& info)
private bool RememberGunshot(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberExplosion(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
private bool RememberThrownItem(Sensation& info, NpcPlayerInfo player, BasePlayer initiator)
protected bool CanTickSensor(float deltaTime, INpcSensor sensor)
protected void TickSensor(INpcSensor sensor, float deltaTime, float time)
public ScientistJunkpileDefinition get_ScientistDefinition()
public Vector3 get_SpawnPosition()
public ScientistJunkpileContext get_ScientistContext()
public BaseNpcContext get_NpcContext()
public IHTNContext get_PlannerContext()
public IUtilityAI get_PlannerAi()
public IUtilityAIClient get_PlannerAiClient()
public NavMeshAgent get_NavAgent()
public List`1<INpcSensor> get_Sensors()
public List`1<INpcReasoner> get_Reasoners()
public IAIContext GetContext(Guid aiId)
public void Initialize(BaseEntity body)
public void Dispose()
public void ResetState()
public void Tick(float time)
public void OnHurt(HitInfo info)
private bool RememberPlayerThatHurtUs(NpcPlayerInfo player, BasePlayer initiator)
}
public Rust.Ai.HTN.ScientistJunkpile.ScientistJunkpileMemory : BaseNpcMemory {
public ScientistJunkpileContext ScientistJunkpileContext
public Vector3 CachedPreferredDistanceDestination
public float CachedPreferredDistanceDestinationTime
public Vector3 CachedCoverDestination
public float CachedCoverDestinationTime
public List`1<BasePlayer> MarkedEnemies
public BaseNpcDefinition Definition
public BaseNpcDefinition get_Definition()
public void .ctor(ScientistJunkpileContext context)
public void ResetState()
protected void OnSetPrimaryKnownEnemyPlayer(EnemyPlayerInfo& info)
public void MarkEnemy(BasePlayer player)
protected void OnForget(BasePlayer player)
public bool ShouldRemoveOnPlayerForgetTimeout(float time, NpcPlayerInfo player)
}
public Rust.Ai.HTN.ScientistJunkpile.ScientistJunkpileSpawner : MonoBehaviour {
public GameObjectRef ScientistPrefab
public List`1<ScientistJunkpileDomain> Spawned
public BaseSpawnPoint[] SpawnPoints
public int MaxPopulation
public bool InitialSpawn
public float MinRespawnTimeMinutes
public float MaxRespawnTimeMinutes
public MovementRule Movement
public float MovementRadius
public bool ReducedLongRangeAccuracy
public JunkpileType SpawnType
public float SpawnBaseChance
private float nextRespawnTime
private bool pendingRespawn
public int currentPopulation
public int get_currentPopulation()
private void Awake()
public void Fill()
public void Clear()
public void SpawnInitial()
public void SpawnRepeating()
public void CheckIfRespawnNeeded()
private bool IsUnderGlobalSpawnThreshold()
private bool IsAllSpawnedDead()
public void ScheduleRespawn()
public void DoRespawn()
public void SpawnScientist()
private BaseSpawnPoint GetSpawnPoint(Vector3& pos, Quaternion& rot)
}
public Rust.Ai.HTN.ScientistJunkpile.Sensors.AnimalsInRangeSensor : object {
public int MaxAnimals
public BaseNpc[] QueryResults
public int QueryResultCount
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.ScientistJunkpile.Sensors.CoverPointsInRangeSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
private CoverPointComparer coverPointComparer
private float nextCoverPosInfoTick
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
private bool _FindCoverPointsInVolume(Vector3 position, List`1<CoverPoint> coverPoints, CoverPointVolume& volume, Single& nextTime, float time, AiLocationManager location, float maxDistanceToCoverSqr)
}
public Rust.Ai.HTN.Sensors.AnimalDistanceSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Sensors.EnemyPlayersHearingSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public void TickStatic(IHTNAgent npc)
public void TickFootstepHearingTest(IHTNAgent npc, NpcPlayerInfo& info)
}
public Rust.Ai.HTN.Sensors.EnemyPlayersInRangeSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
private EnemyPlayerInRangeComparer _comparer
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
protected bool EvaluatePlayer(BaseNpcContext context, IHTNAgent npc, NpcPlayerInfo player, float time)
}
public Rust.Ai.HTN.Sensors.EnemyPlayersLineOfSightSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
private int <MaxVisible>k__BackingField
public float TickFrequency
public float LastTickTime
public int MaxVisible
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public int get_MaxVisible()
public void set_MaxVisible(int value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
public void TickStatic(IHTNAgent npc, int maxVisible)
public bool TickLineOfSightTest(IHTNAgent npc, NpcPlayerInfo& info)
}
public Rust.Ai.HTN.Sensors.INpcSensor {
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Sensors.PlayersDistanceSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Sensors.PlayersInRangeSensor : object {
public int MaxPlayers
public BasePlayer[] PlayerQueryResults
public int PlayerQueryResultCount
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HTN.Sensors.PlayersOutsideRangeSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
protected bool EvaluatePlayer(BaseNpcContext context, IHTNAgent npc, NpcPlayerInfo& player, float time)
}
public Rust.Ai.HTN.Sensors.PlayersViewAngleSensor : object {
private float <TickFrequency>k__BackingField
private float <LastTickTime>k__BackingField
public float TickFrequency
public float LastTickTime
public float get_TickFrequency()
public void set_TickFrequency(float value)
public float get_LastTickTime()
public void set_LastTickTime(float value)
public void Tick(IHTNAgent npc, float deltaTime, float time)
}
public Rust.Ai.HumanAttackOperator : BaseAction {
public AttackType Type
public AttackTargetType Target
public void DoExecute(BaseContext c)
public void AttackEnemy(NPCHumanContext c, AttackType type)
}
public Rust.Ai.HumanNavigateToOperator : BaseAction {
public OperatorType Operator
public void DoExecute(BaseContext c)
public void MakeUnstuck(NPCHumanContext c)
public void NavigateToEnemy(NPCHumanContext c)
public void NavigateToLastEnemy(NPCHumanContext c)
public void NavigateToHideout(NPCHumanContext c)
public void NavigateToRandomLoc(NPCHumanContext c)
public void NavigateToPatrolLoc(NPCHumanContext c)
public void NavigateToSpawnLoc(NPCHumanContext c)
public void NavigateToMountableLoc(NPCHumanContext c, OperatorType mountableType)
private void UpdateRoamTime(NPCHumanContext c)
private void NavigateToWaypointLoc(NPCHumanContext c)
private bool IsWaitingAtWaypoint(NPCHumanContext c, Waypoint& waypoint)
public void NavigateToCover(NPCHumanContext c, TakeCoverIntention intention)
public void PathToCover(NPCHumanContext c, Vector3 coverPosition)
public void FleeEnemy(NPCHumanContext c)
public void FleeExplosive(NPCHumanContext c)
public void FleeHurtDir(NPCHumanContext c)
public void Sidestep(NPCHumanContext c)
private bool NavigateInDirOfBestSample(NPCHumanContext c, SampleCount sampleCount, float radius, SampleFeatures features, float minRange, float maxRange)
}
public Rust.Ai.HumanVoiceOperator : BaseAction {
public void DoExecute(BaseContext ctx)
}
public Rust.Ai.IAiAnswer {
public NPCPlayerApex Source
public NPCPlayerApex get_Source()
public void set_Source(NPCPlayerApex value)
}
public Rust.Ai.InInCoverFromEntity : WeightedScorerBase`1<BaseEntity> {
public float CoverArcThreshold
public float GetScore(BaseContext ctx, BaseEntity option)
}
public Rust.Ai.InMountRangeOfChair : BaseScorer {
public float GetScore(BaseContext context)
public float Test(NPCHumanContext c)
private float IsInRange(NPCHumanContext c, BaseMountable mountable)
}
public Rust.Ai.IsAnimal : OptionScorerBase`1<BaseEntity> {
public float Score(IAIContext context, BaseEntity option)
}
public Rust.Ai.IsAtLastKnownEnemyLocation : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.IsAtLocation : BaseScorer {
public SquadSpawnerLocation Location
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c, SquadSpawnerLocation location)
}
public Rust.Ai.IsAtLocationPlayerTargeting : ContextualScorerBase`1<PlayerTargetContext> {
public SquadSpawnerLocation Location
public float Score(PlayerTargetContext c)
public bool Test(PlayerTargetContext c, SquadSpawnerLocation location)
}
public Rust.Ai.IsAtSpawnLocation : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.IsBusy : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.IsClosestPlayerWithinDistance : BaseScorer {
private float distance
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c, float distance)
}
public Rust.Ai.IsCrouched : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.IsCurrentAttackEntity : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.IsCurrentFoodTarget : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.IsExplosive : OptionScorerBase`1<BaseEntity> {
public float Score(IAIContext context, BaseEntity option)
}
public Rust.Ai.IsHumanFactInEngagementRange : BaseScorer {
public EnemyEngagementRangeEnum value
public float GetScore(BaseContext c)
}
public Rust.Ai.IsHumanRoamReady : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.IsInCoverFromTarget : BaseScorer {
public float CoverArcThreshold
public float GetScore(BaseContext ctx)
}
public Rust.Ai.IsInWater : WeightedScorerBase`1<Vector3> {
public float MaxDepth
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.IsLastAttacker : WeightedScorerBase`1<BaseEntity> {
public float MinScore
public float GetScore(BaseContext context, BaseEntity option)
}
public Rust.Ai.IsMountedToType : BaseScorer {
public MountPoses MountableType
public float GetScore(BaseContext context)
public float Test(NPCHumanContext c, MountPoses mountableType)
}
public Rust.Ai.IsPathDistanceBetweenHideoutAndLKPValid : OptionScorerBase`1<CoverPoint> {
public float Score(IAIContext context, CoverPoint option)
public bool Evaluate(CoverContext c, CoverPoint option)
}
public Rust.Ai.IsPathDistanceToTargetValid : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c)
}
public Rust.Ai.IsRoamReady : BaseScorer {
public float GetScore(BaseContext c)
public bool Evaluate(BaseContext c)
}
public Rust.Ai.IsSleeping : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.IsSleepy : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.IsTargetAlive : BaseScorer {
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c)
}
public Rust.Ai.IsTargetDead : BaseScorer {
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c)
}
public Rust.Ai.LastSetDestinationTimeGreaterThan : BaseScorer {
private float Timeout
public float GetScore(BaseContext c)
}
public Rust.Ai.LastSetDestinationTimeLessThan : BaseScorer {
private float Timeout
public float GetScore(BaseContext c)
}
public Rust.Ai.LineOfSightToTarget : WeightedScorerBase`1<Vector3> {
private CoverType Cover
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.LineOfSightToTargetEntity : BaseScorer {
private CoverType Cover
public float GetScore(BaseContext c)
}
public Rust.Ai.LookAtClosestPlayer : BaseAction {
public void DoExecute(BaseContext context)
public void Do(NPCHumanContext c)
}
public Rust.Ai.LookAtRandomPoint : BaseAction {
public float MinTimeout
public float MaxTimeout
public void DoExecute(BaseContext context)
}
public Rust.Ai.ManualCoverPoint : FacepunchBehaviour {
public bool IsDynamic
public float Score
public CoverPointVolume Volume
public Vector3 Normal
public CoverType NormalCoverType
public Vector3 Position
public float DirectionMagnitude
public Vector3 get_Position()
public float get_DirectionMagnitude()
private void Awake()
public CoverPoint ToCoverPoint(CoverPointVolume volume)
}
public Rust.Ai.MemorisedHostilePlayerTarget : ActionBase`1<PlayerTargetContext> {
public float HostilityTimeout
public void Execute(PlayerTargetContext context)
}
public Rust.Ai.MemorisedPlayerTarget : ActionBase`1<PlayerTargetContext> {
public void Execute(PlayerTargetContext context)
}
public Rust.Ai.Memory : object {
public List`1<BaseEntity> Visible
public List`1<SeenInfo> All
public List`1<ExtendedInfo> AllExtended
public SeenInfo Update(BaseEntity entity, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, ExtendedInfo& extendedInfo)
public SeenInfo Update(BaseEntity entity, Vector3 position, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, ExtendedInfo& extendedInfo)
public SeenInfo Update(BaseEntity ent, float danger)
public SeenInfo Update(BaseEntity ent, Vector3 position, float danger)
public void AddDanger(Vector3 position, float amount)
public SeenInfo GetInfo(BaseEntity entity)
public SeenInfo GetInfo(Vector3 position)
public ExtendedInfo GetExtendedInfo(BaseEntity entity)
internal void Forget(float maxSecondsOld)
}
public Rust.Ai.MountOperator : BaseAction {
public MountOperationType Type
public void DoExecute(BaseContext c)
public void MountOperation(NPCHumanContext c, MountOperationType type)
}
public Rust.Ai.MoveToBestPosition : BaseActionWithOptions`1<Vector3> {
public void DoExecute(BaseContext c)
}
public Rust.Ai.MoveToFoodTarget : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.MoveToTargetEntity : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.NavigateToOperator : BaseAction {
public OperatorType Operator
public void DoExecute(BaseContext c)
public void MakeUnstuck(BaseContext c)
public void NavigateToEnemy(BaseContext c)
public void NavigateToRandomLoc(BaseContext c)
public void NavigateToTopologyPreference(BaseContext c)
public void NavigateToSpawn(BaseContext c)
public void NavigateToFood(BaseContext c)
public void FleeEnemy(BaseContext c)
public void FleeHurtDir(BaseContext c)
private bool NavigateInDirOfBestSample(BaseContext c, SampleCount sampleCount, float radius, SampleFeatures features, float minRange, float maxRange)
}
public Rust.Ai.NavmeshPrefabInstantiator : MonoBehaviour {
public GameObjectRef NavmeshPrefab
private void Start()
}
public Rust.Ai.NavPointSample : ValueType {
public Vector3 Position
public float Score
}
public Rust.Ai.NavPointSampleComparer : object {
public int Compare(NavPointSample a, NavPointSample b)
}
public Rust.Ai.NavPointSampler : object {
private float HalfPI
private NavPointSampleComparer NavPointSampleComparer
public bool SampleCircleWaterDepthOnly(SampleCount sampleCount, Vector3 center, float radius, SampleScoreParams scoreParams, List`1& samples)
public bool SampleCircle(SampleCount sampleCount, Vector3 center, float radius, SampleScoreParams scoreParams, List`1& samples)
public int GetFeatureCount(int features)
public Vector3 GetPointOnCircle(Vector3 center, float radius, float degrees)
public NavPointSample SamplePointWaterDepthOnly(Vector3 pos, float depth)
public NavPointSample SamplePoint(Vector3 pos, SampleScoreParams scoreParams)
private bool _SampleNavMesh(Vector3& pos, IAIAgent agent)
private float _WaterDepth(Vector3 pos, float maxDepth)
private float _DiscourageSharpTurns(Vector3 pos, IAIAgent agent)
public bool IsValidPointDirectness(Vector3 point, Vector3 pos, Vector3 targetPos)
public bool PointDirectnessToTarget(Vector3 point, Vector3 pos, Vector3 targetPos, Single& value)
public float RetreatPointValue(Vector3 point, IAIAgent agent)
public float RetreatPointValueExplosive(Vector3 point, IAIAgent agent)
public float ApproachPointValue(Vector3 point, IAIAgent agent)
public float FlankPointValue(Vector3 point, IAIAgent agent)
public float RetreatFromDirection(Vector3 point, IAIAgent agent)
public float TopologyPreference(Vector3 point, IAIAgent agent)
public float RangeFromHome(Vector3 point, IAIAgent agent)
}
public Rust.Ai.NeverMoves : BaseScorer {
public float GetScore(BaseContext ctx)
public bool Test(NPCHumanContext c)
}
public Rust.Ai.Patience : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.PlayerDetectionChance : OptionScorerBase`1<BasePlayer> {
private float score
public float Score(IAIContext context, BasePlayer option)
public bool Evaluate(IAIAgent self, float dot, BasePlayer option)
private float FovDetection(float dot, BasePlayer option)
private float NoiseLevel(BasePlayer option)
private float LightDetection(BasePlayer option)
}
public Rust.Ai.PlayerTargetContext : object {
public IAIAgent Self
public int CurrentOptionsIndex
public int PlayerCount
public BasePlayer[] Players
public Vector3[] Direction
public Single[] Dot
public Single[] DistanceSqr
public Byte[] LineOfSight
public BasePlayer Target
public float Score
public int Index
public Vector3 LastKnownPosition
public void Refresh(IAIAgent self, BasePlayer[] players, int playerCount)
}
public Rust.Ai.PointDirectnessToTarget : WeightedScorerBase`1<Vector3> {
private bool UsePerfectInfo
public float GetScore(BaseContext c, Vector3 point)
}
public Rust.Ai.PositionInAttackRangeOfTarget : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.PreventPickingInvalidPositionAgain : WeightedScorerBase`1<Vector3> {
public float GetScore(BaseContext c, Vector3 option)
}
public Rust.Ai.PrintDebug : BaseAction {
private string debugMessage
public void DoExecute(BaseContext c)
}
public Rust.Ai.ProximityToCover : WeightedScorerBase`1<Vector3> {
public float MaxDistance
public CoverType _coverType
public AnimationCurve Response
public float GetScore(BaseContext ctx, Vector3 option)
internal CoverPoint GetClosestCover(NPCHumanContext c, Vector3 point, float MaxDistance, CoverType _coverType, Single& bestDistance)
}
public Rust.Ai.ProximityToDanger : WeightedScorerBase`1<Vector3> {
public float Range
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.ProximityToDangers : ProximityToPeers {
protected float Test(SeenInfo memory, BaseContext c)
}
public Rust.Ai.ProximityToPeers : WeightedScorerBase`1<Vector3> {
public float desiredRange
public float GetScore(BaseContext c, Vector3 position)
protected float Test(SeenInfo memory, BaseContext c)
}
public Rust.Ai.RangeFromHome : WeightedScorerBase`1<Vector3> {
public float Range
public AnimationCurve ResponseCurve
public bool UseResponseCurve
public float GetScore(BaseContext c, Vector3 position)
}
public Rust.Ai.RecentlyStuck : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.ReloadOperator : BaseAction {
public void DoExecute(BaseContext c)
public void Reload(NPCHumanContext c)
}
public Rust.Ai.ReloadWeapon : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.ReloadWeaponNeed : BaseScorer {
private AnimationCurve ResponseCurve
private bool UseResponseCurve
public float GetScore(BaseContext c)
}
public Rust.Ai.ScanForCover : BaseAction {
public float MaxDistanceToCover
public float CoverArcThreshold
public void DoExecute(BaseContext ctx)
public bool ProvidesCoverFromDirection(CoverPoint cp, Vector3 directionTowardCover, float arcThreshold)
}
public Rust.Ai.ScanForEntities : BaseAction {
public BaseEntity[] Results
public int forgetTime
public void DoExecute(BaseContext c)
private bool WithinVisionCone(IAIAgent agent, BaseEntity other)
private bool AiCaresAbout(BaseEntity ent)
}
public Rust.Ai.ScanForPositions : BaseAction {
public float SamplingRange
public int SampleRings
public bool CalculatePath
public float CalculatePathInnerCirclePercentageThreshold
public bool ScanAllAreas
public string AreaName
public bool SampleTerrainHeight
private NavMeshPath reusablePath
public void DoExecute(BaseContext c)
private void TryAddPoint(BaseContext c, Vector3 p, bool calculatePath, bool scanAllAreas, string areaName, bool sampleTerrainHeight)
}
public Rust.Ai.ScientistSpawner : SpawnGroup {
public bool Mobile
public bool NeverMove
public bool SpawnHostile
public bool OnlyAggroMarkedTargets
public bool IsPeacekeeper
public bool IsBandit
public bool IsMilitaryTunnelLab
public EnemyRangeEnum MaxRangeToSpawnLoc
public WaypointSet Waypoints
public Transform[] LookAtInterestPointsStationary
public Vector2 RadioEffectRepeatRange
public Model Model
private AiLocationManager _mgr
private float _nextForcedRespawn
private bool _lastSpawnCallHadAliveMembers
private bool _lastSpawnCallHadMaxAliveMembers
protected void Spawn(int numToSpawn)
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
protected void OnDrawGizmos()
}
public Rust.Ai.SelectCoverPoint : ActionWithOptions`1<CoverPoint> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool Evaluate(CoverContext context, IList`1<IOptionScorer`1<CoverPoint>> scorers, List`1<CoverPoint> options, int numOptions, bool allScorersMustScoreAboveZero)
}
public Rust.Ai.SelectEnemyHideout : ActionWithOptions`1<CoverPoint> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool Evaluate(CoverContext context, IList`1<IOptionScorer`1<CoverPoint>> scorers, List`1<CoverPoint> options, int numOptions, bool allScorersMustScoreAboveZero)
}
public Rust.Ai.SelfDefence : BaseScorer {
public float WithinSeconds
public float GetScore(BaseContext c)
}
public Rust.Ai.Sensation : ValueType {
public SensationType Type
public Vector3 Position
public float Radius
public float DamagePotential
public BaseEntity Initiator
public BasePlayer InitiatorPlayer
public BaseEntity UsedEntity
}
public Rust.Ai.SensationType : Enum {
public int value__
public SensationType Gunshot
public SensationType ThrownWeapon
public SensationType Explosion
}
public Rust.Ai.Sense : object {
private BaseEntity[] query
public void Stimulate(Sensation sensation)
private bool IsAbleToBeStimulated(BaseEntity ent)
}
public Rust.Ai.SetBehaviour : BaseAction {
public Behaviour Behaviour
public float BusyTime
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetBusyFor : BaseAction {
public float BusyTime
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetFactBoolean : BaseAction {
public Facts fact
public bool value
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetHumanFactBodyState : BaseAction {
public BodyState value
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetHumanFactBoolean : BaseAction {
public Facts fact
public bool value
public void DoExecute(BaseContext c)
}
public Rust.Ai.SetHumanSpeed : BaseAction {
public SpeedEnum value
public void DoExecute(BaseContext c)
public void Set(BaseContext c, SpeedEnum speed)
}
public Rust.Ai.SetSpeed : BaseAction {
public SpeedEnum value
public void DoExecute(BaseContext c)
}
public Rust.Ai.SharePlayerTargetComm : ActionBase`1<PlayerTargetContext> {
public void Execute(PlayerTargetContext c)
}
public Rust.Ai.ShouldReturnToSpawnPoint : BaseScorer {
public float GetScore(BaseContext ctx)
}
public Rust.AI.SimpleAIMemory : object {
public List`1<BaseEntity> Visible
public List`1<SeenInfo> All
public void Update(BaseEntity ent)
public void AddDanger(Vector3 position, float amount)
internal void Forget(float secondsOld)
}
public Rust.Ai.StaminaLevel : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.StartAttack : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.StopMoving : BaseAction {
public void DoExecute(BaseContext c)
}
public Rust.Ai.SwitchToolOperator : BaseAction {
private ToolTypeEnum ToolTypeDay
private ToolTypeEnum ToolTypeNight
public void DoExecute(BaseContext c)
public bool TrySwitchToolTo(NPCHumanContext c, ToolTypeEnum toolDay, ToolTypeEnum toolNight)
public Item FindTool(NPCHumanContext c, ToolTypeEnum tool)
}
public Rust.Ai.SwitchWeaponOperator : BaseAction {
private WeaponTypeEnum WeaponType
public void DoExecute(BaseContext c)
public bool TrySwitchWeaponTo(NPCHumanContext c, WeaponTypeEnum WeaponType)
private Item FindBestMelee(NPCHumanContext c)
private Item FindBestProjInRange(WeaponTypeEnum from, WeaponTypeEnum to, NPCHumanContext c)
}
public Rust.Ai.TargetAlive : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.TargetEntityVisibleFor : BaseScorer {
public float duration
public float GetScore(BaseContext c)
}
public Rust.Ai.TargetHealthFraction : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.TargetSelectorAnimal : ActionWithOptions`1<BaseEntity> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool Evaluate(EntityTargetContext context, IList`1<IOptionScorer`1<BaseEntity>> scorers, BaseEntity[] options, int numOptions, bool allScorersMustScoreAboveZero, BaseNpc& best, Single& bestScore)
}
public Rust.Ai.TargetSelectorExplosives : ActionWithOptions`1<BaseEntity> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool TryGetBest(EntityTargetContext context, IList`1<IOptionScorer`1<BaseEntity>> scorers, BaseEntity[] options, int numOptions, bool allScorersMustScoreAboveZero, TimedExplosive& best, Single& bestScore)
}
public Rust.Ai.TargetSelectorPlayer : ActionWithOptions`1<BasePlayer> {
private bool allScorersMustScoreAboveZero
public void Execute(IAIContext context)
public bool Evaluate(PlayerTargetContext context, IList`1<IOptionScorer`1<BasePlayer>> scorers, BasePlayer[] options, int numOptions, bool allScorersMustScoreAboveZero, BasePlayer& best, Single& bestScore, Int32& bestIndex, Vector3& bestLastKnownPosition)
}
public Rust.Ai.TestBehaviour : BaseScorer {
public Behaviour Behaviour
public float GetScore(BaseContext c)
}
public Rust.Ai.TimeAtDestination : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.Ai.TimeSinceLastMoveThreshold : BaseScorer {
public float minThreshold
public float maxThreshold
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c, float minThreshold, float maxThreshold)
}
public Rust.Ai.TimeSinceLastMoveToCoverThreshold : BaseScorer {
public float minThreshold
public float maxThreshold
public float GetScore(BaseContext c)
public bool Evaluate(NPCHumanContext c, float minThreshold, float maxThreshold)
}
public Rust.Ai.ValidDistance : OptionScorerBase`1<BaseEntity> {
public float Score(IAIContext context, BaseEntity option)
}
public Rust.Ai.ValidLineOfSight : OptionScorerBase`1<BaseEntity> {
public float Score(IAIContext context, BaseEntity option)
}
public Rust.Ai.WantsToAttackEntity : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.WantsToEatEntity : WeightedScorerBase`1<BaseEntity> {
public float GetScore(BaseContext c, BaseEntity target)
}
public Rust.Ai.WaypointSet : MonoBehaviour {
private List`1<Waypoint> _points
private NavModes navMode
public List`1<Waypoint> Points
public NavModes NavMode
public List`1<Waypoint> get_Points()
public void set_Points(List`1<Waypoint> value)
public NavModes get_NavMode()
private void OnDrawGizmos()
}
public Rust.Ai.WeightedScorerBase`1 : OptionScorerBase`1<T> {
public bool InvertScore
public float ScoreScale
private string DebugName
protected float ProcessScore(float s)
public float Score(IAIContext context, T option)
public float GetScore(BaseContext context, T option)
}
public Rust.Ai.WithinAttackRangeOfTargetEntity : BaseScorer {
public float GetScore(BaseContext c)
}
public Rust.DamageType : Enum {
public int value__
public DamageType Generic
public DamageType Hunger
public DamageType Thirst
public DamageType Cold
public DamageType Drowned
public DamageType Heat
public DamageType Bleeding
public DamageType Poison
public DamageType Suicide
public DamageType Bullet
public DamageType Slash
public DamageType Blunt
public DamageType Fall
public DamageType Radiation
public DamageType Bite
public DamageType Stab
public DamageType Explosion
public DamageType RadiationExposure
public DamageType ColdExposure
public DamageType Decay
public DamageType ElectricShock
public DamageType Arrow
public DamageType AntiVehicle
public DamageType Collision
public DamageType Fun_Water
public DamageType LAST
}
public Rust.DamageTypeEntry : object {
public DamageType type
public float amount
}
public Rust.DamageTypeEx : object {
public bool IsMeleeType(DamageType damageType)
public bool IsBleedCausing(DamageType damageType)
public bool IsConsideredAnAttack(DamageType damageType)
}
public Rust.DamageTypeList : object {
public Single[] types
public void Set(DamageType index, float amount)
public float Get(DamageType index)
public void Add(DamageType index, float amount)
public void Scale(DamageType index, float amount)
public bool Has(DamageType index)
public float Total()
public void Clear()
public void Add(List`1<DamageTypeEntry> entries)
public void ScaleAll(float amount)
public DamageType GetMajorityDamageType()
public bool IsMeleeType()
public bool IsBleedCausing()
public bool IsConsideredAnAttack()
}
public Rust.Defines : object {
public UInt32 appID
public string resourceFolder
}
internal Rust.GameInfo : object {
internal bool IsOfficialServer
internal bool HasAchievements
internal bool get_IsOfficialServer()
internal bool get_HasAchievements()
}
public Rust.GC : MonoBehaviour {
public bool Enabled
public bool get_Enabled()
public void Collect()
}
public Rust.Generic : object {
private Scene _batchingScene
public Scene BatchingScene
public Scene get_BatchingScene()
}
public Rust.Instruments.Notes : Enum {
public int value__
public Notes A
public Notes B
public Notes C
public Notes D
public Notes E
public Notes F
public Notes G
}
public Rust.Modular.ConditionalObject : object {
public GameObject gameObject
public GameObject ownerGameObject
public ConditionalSocketSettings[] socketSettings
public bool restrictOnHealth
public float healthRestrictionMin
public float healthRestrictionMax
public bool restrictOnAdjacent
public AdjacentCondition adjacentRestriction
public AdjacentMatchType adjacentMatch
public bool restrictOnLockable
public bool lockableRestriction
public int gibId
private Nullable`1<bool> <IsActive>k__BackingField
public Nullable`1<bool> IsActive
public Nullable`1<bool> get_IsActive()
private void set_IsActive(Nullable`1<bool> value)
public void .ctor(GameObject conditionalGO, GameObject ownerGO, int socketsTaken)
public void SetActive(bool active)
public void RefreshActive()
}
public Rust.Modular.ConditionalSocketSettings : object {
public bool restrictOnLocation
public LocationCondition locationRestriction
public bool restrictOnWheel
public SocketWheelType wheelRestriction
public bool HasSocketRestrictions
public bool get_HasSocketRestrictions()
}
public Rust.Modular.EnableDisableEvent : MonoBehaviour {
private UnityEvent enableEvent
private UnityEvent disableEvent
protected void OnEnable()
protected void OnDisable()
}
public Rust.Modular.EngineItemTypeEx : object {
public bool BoostsAcceleration(EngineItemTypes engineItemType)
public bool BoostsTopSpeed(EngineItemTypes engineItemType)
public bool BoostsFuelEconomy(EngineItemTypes engineItemType)
}
public Rust.Modular.EngineStorage : StorageContainer {
public Sprite engineIcon
public float internalDamageMultiplier
public EngineItemTypes[] slotTypes
public VehicleModuleEngineItems allEngineItems
public int accelerationBoostSlots
public int topSpeedBoostSlots
public int fuelEconomyBoostSlots
private bool <isUsable>k__BackingField
private float <accelerationBoostPercent>k__BackingField
private float <topSpeedBoostPercent>k__BackingField
private float <fuelEconomyBoostPercent>k__BackingField
public bool isUsable
public float accelerationBoostPercent
public float topSpeedBoostPercent
public float fuelEconomyBoostPercent
public bool get_isUsable()
public void set_isUsable(bool value)
public float get_accelerationBoostPercent()
public void set_accelerationBoostPercent(float value)
public float get_topSpeedBoostPercent()
public void set_topSpeedBoostPercent(float value)
public float get_fuelEconomyBoostPercent()
public void set_fuelEconomyBoostPercent(float value)
public VehicleModuleEngine GetEngineModule()
public float GetAveragedLoadoutPercent()
public void Load(LoadInfo info)
public bool CanBeLooted(BasePlayer player)
private int GetValidSlot(Item item)
public void OnInventoryFirstCreated(ItemContainer container)
public void NonUserSpawn()
public void OnItemAddedOrRemoved(Item item, bool added)
public bool ItemFilter(Item item, int targetSlot)
public void RefreshLoadoutData()
public void Save(SaveInfo info)
public void OnModuleDamaged(float damageTaken)
public void AdminAddParts(int tier)
public float GetContainerItemsValueFor(Func`2<EngineItemTypes, bool> boostConditional)
public float GetTierValue(int tier)
}
public Rust.Modular.ItemModEngineItem : ItemMod {
public EngineItemTypes engineItemType
public int tier
}
public Rust.Modular.ItemModVehicleChassis : ItemMod {
public GameObjectRef entityPrefab
public int socketsTaken
public int SocketsTaken
public int get_SocketsTaken()
}
public Rust.Modular.ItemModVehicleModule : ItemMod {
public GameObjectRef entityPrefab
public int socketsTaken
public bool doNonUserSpawn
public int SocketsTaken
public int get_SocketsTaken()
public BaseVehicleModule CreateModuleEntity(BaseEntity parent, Vector3 position, Quaternion rotation)
}
public Rust.Modular.ModularCarAudio : MonoBehaviour {
public bool showDebug
private ModularCar modularCar
private ModularCarChassisVisuals chassisVisuals
private SoundDefinition engineStartSound
private SoundDefinition engineStopSound
private SoundDefinition engineStartFailSound
private BlendedLoopEngineSound blendedEngineLoops
private SoundDefinition skidSoundLoop
private SoundDefinition skidSoundDirtLoop
private SoundDefinition skidSoundSnowLoop
private float skidMinSlip
private float skidMaxSlip
private SoundDefinition movementStartOneshot
private SoundDefinition movementStopOneshot
private float movementStartStopMinTimeBetweenSounds
private SoundDefinition movementRattleLoop
private float movementRattleMaxSpeed
private float movementRattleMaxAngSpeed
private float movementRattleIdleGain
private SoundDefinition suspensionLurchSound
private float suspensionLurchMinExtensionDelta
private float suspensionLurchMinTimeBetweenSounds
private SoundDefinition waterSplashSoundDef
private BlendedSoundLoops waterLoops
private float waterSoundsMaxSpeed
private SoundDefinition brakeSoundDef
private SoundDefinition lightsToggleSound
private SoundDefinition tyreRollingSoundDef
private SoundDefinition tyreRollingWaterSoundDef
private SoundDefinition tyreRollingGrassSoundDef
private SoundDefinition tyreRollingSnowSoundDef
private AnimationCurve tyreRollGainCurve
}
public Rust.Modular.ModularCarChassisVisuals : MonoBehaviour {
public ModularCar modularCar
public Transform frontAxle
public Transform rearAxle
public Steering steering
public LookAtTarget transmission
public PhysicMaterial defaultGroundMaterial
public PhysicMaterial snowGroundMaterial
public PhysicMaterial grassGroundMaterial
public PhysicMaterial sandGroundMaterial
public List`1<PhysicMaterial> dirtGroundMaterials
public List`1<PhysicMaterial> stoneyGroundMaterials
public float wheelRadius
public float suspensionDistance
public float springTargetPosition
}
public Rust.Modular.ModularCarPhysics : object {
private float <DriveWheelVelocity>k__BackingField
private float <DriveWheelSlip>k__BackingField
private float <SteerAngle>k__BackingField
public ServerWheelData[] wheelData
public ModularCar modularCar
public Transform transform
public Rigidbody rBody
public ModularCarSettings vehicleSettings
public float speedAngle
public bool wasSleeping
public bool hasDriver
public bool hadDriver
public float lastMovingTime
public WheelFrictionCurve zeroFriction
public Vector3 prevLocalCOM
public float midWheelPos
private int NUM_WHEELS
private bool WHEEL_HIT_CORRECTION
private float SLEEP_SPEED
private float SLEEP_DELAY
private float AIR_DRAG
private float DEFAULT_GROUND_GRIP
private float ROAD_GROUND_GRIP
private float ICE_GROUND_GRIP
public bool slowSpeedExitFlag
private float SLOW_SPEED_EXIT_SPEED
public float dragMod
public float dragModDuration
public TimeSince timeSinceDragModSet
public TimeSince timeSinceWaterCheck
public float DriveWheelVelocity
public float DriveWheelSlip
public float SteerAngle
public bool InSlowSpeedExitMode
public float get_DriveWheelVelocity()
public void set_DriveWheelVelocity(float value)
public float get_DriveWheelSlip()
public void set_DriveWheelSlip(float value)
public float get_SteerAngle()
public void set_SteerAngle(float value)
public bool get_InSlowSpeedExitMode()
public void .ctor(ModularCar modularCar, Transform transform, Rigidbody rBody, ModularCarSettings vehicleSettings)
public void PushCar(BasePlayer player)
public void FixedUpdate(float dt, float speed)
public bool IsGrounded()
public void SetTempDrag(float drag, float duration)
public float GetModifiedDrag()
public void COMChanged()
public void ComputeSteerAngle(float dt, float speed)
public float GetWheelForceDistance(WheelCollider col)
public void UpdateSuspension(ServerWheelData wd)
public void AdjustHitForces(int groundedWheels, float neutralForcePerWheel)
public void UpdateLocalFrame(ServerWheelData wd, float dt)
public void ComputeTireForces(ServerWheelData wd, float speed, float maxDriveForce, float maxSpeed, float throttleInput, float brakeInput, float driveForceMultiplier)
public float ComputeDriveForce(float speed, float absSpeed, float demandedForce, float maxForce, float maxForwardSpeed, float driveForceMultiplier)
public void ComputeOverallForces()
public float ComputeCombinedSlip(Vector2 localVelocity, Vector2 tireSlip)
public void ApplyTireForces(ServerWheelData wd)
public Vector3 GetSidewaysForceAppPoint(ServerWheelData wd, Vector3 contactPoint)
public ServerWheelData <.ctor>g__AddWheel|42_0(Wheel wheel)
}
public Rust.Modular.ModularCarSettings : object {
public float tireFriction
public float rollingResistance
public float maxSteerAngle
public bool steeringAssist
public float steeringAssistRatio
public bool steeringLimit
public float minSteerLimitAngle
public float minSteerLimitSpeed
public float engineStartupTime
public float maxDriveSlip
public float driveForceToMaxSlip
public float reversePercentSpeed
public float brakeForceMultiplier
public float handlingBias
}
public Rust.Modular.ModularVehicleInventory : object {
private ItemContainer <ModuleContainer>k__BackingField
private ItemContainer <ChassisContainer>k__BackingField
private BaseModularVehicle vehicle
public ItemContainer ModuleContainer
public ItemContainer ChassisContainer
public UInt32 UID
private int TotalSockets
public ItemContainer get_ModuleContainer()
public ItemContainer get_ChassisContainer()
public UInt32 get_UID()
private int get_TotalSockets()
public void .ctor(BaseModularVehicle vehicle, ItemDefinition chassisItemDef, bool giveUID)
public void Dispose()
public void GiveUIDs()
public bool SocketIsFree(int socketIndex, Item moduleItem)
public bool SocketIsTaken(int socketIndex)
public bool TryAddModuleItem(Item moduleItem, int socketIndex)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public bool RemoveAndDestroy(Item itemToRemove)
public int TryGetFreeSocket(int socketsTaken)
public int TryGetFreeSocket(Item moduleItem, int socketsTaken)
public bool SocketsAreFree(int firstIndex, int socketsTaken, Item moduleItem)
public void SyncModuleInventory(BaseVehicleModule moduleEntity, int firstSocketIndex)
private bool SocketIsUsed(Item item, int slotIndex)
private ItemContainer CreateModuleInventory(BaseModularVehicle vehicle, bool giveUID)
private ItemContainer CreateChassisInventory(BaseModularVehicle vehicle, bool giveUID)
private void OnSocketInventoryAddRemove(Item moduleItem, bool added)
private void ModuleItemAdded(Item moduleItem, int socketIndex)
private void ModuleItemRemoved(Item moduleItem)
private void OnModuleItemChanged(Item moduleItem)
private bool ItemFilter(Item item, int targetSlot)
}
public Rust.Modular.ModularVehicleSocket : object {
private Transform socketTransform
private SocketWheelType wheelType
private SocketLocationType locationType
public Vector3 WorldPosition
public Quaternion WorldRotation
public SocketWheelType WheelType
public SocketLocationType LocationType
public Vector3 get_WorldPosition()
public Quaternion get_WorldRotation()
public SocketWheelType get_WheelType()
public SocketLocationType get_LocationType()
public bool ShouldBeActive(ConditionalSocketSettings modelSettings)
}
public Rust.Modular.VehicleModuleEngineItems : ScriptableObject {
private ItemModEngineItem[] engineItems
public bool TryGetItem(int tier, EngineItemTypes type, ItemModEngineItem& output)
}
public Rust.Modular.VehicleModuleSlidingComponent : object {
public string interactionColliderName
public Flags flag_SliderOpen
public float moveTime
public SlidingPart[] slidingParts
public SoundDefinition openSoundDef
public SoundDefinition closeSoundDef
private float positionPercent
public bool WantsOpenPos(BaseEntity parentEntity)
public void Use(BaseVehicleModule parentModule)
public void ServerUpdateTick(BaseVehicleModule parentModule)
private void CheckPosition(BaseEntity parentEntity, float dt)
}
public Rust.Numlock : object {
public bool IsOn
public bool get_IsOn()
public void TurnOn()
}
public Rust.Server : object {
public float UseDistance
private Scene _entityScene
public Scene EntityScene
public Scene get_EntityScene()
}
public Rust.UI.MainMenu.Hero : SingletonComponent`1<Hero> {
public CanvasGroup CanvasGroup
public Video VideoPlayer
public RustText TitleText
public RustText ButtonText
public RustButton ItemStoreButton
}
public Rust.UI.ReportBug : UIDialog {
public GameObject GetInformation
public GameObject Finished
public RustInput Subject
public RustInput Message
public RustButton ReportButton
public RustButtonGroup Category
public RustIcon ProgressIcon
public RustText ProgressText
}
public Rust.UI.ReportPlayer : UIDialog {
public GameObject FindPlayer
public GameObject GetInformation
public GameObject Finished
public Dropdown ReasonDropdown
public RustInput Subject
public RustInput Message
public RustButton ReportButton
public SteamUserButton SteamUserButton
public RustIcon ProgressIcon
public RustText ProgressText
public Option[] ReportReasons
}
public Rust.UI.SteamInventoryCrafting : MonoBehaviour {
public GameObject Container
public Button ConvertToItem
public TextMeshProUGUI WoodAmount
public TextMeshProUGUI ClothAmount
public TextMeshProUGUI MetalAmount
public int SelectedCount
public TextMeshProUGUI InfoText
private IPlayerItemDefinition <ResultItem>k__BackingField
private Coroutine <MarketCoroutine>k__BackingField
public SteamInventoryCrateOpen CraftModal
public GameObject CraftingContainer
public GameObject CraftingButton
public SteamInventoryNewItem NewItemModal
public IPlayerItemDefinition ResultItem
public Coroutine MarketCoroutine
public IPlayerItemDefinition get_ResultItem()
private void set_ResultItem(IPlayerItemDefinition value)
public Coroutine get_MarketCoroutine()
private void set_MarketCoroutine(Coroutine value)
}
public Rust.UI.SteamInventoryCrateOpen : MonoBehaviour {
public TextMeshProUGUI Name
public TextMeshProUGUI Requirements
public TextMeshProUGUI Label
public HttpImage IconImage
public GameObject ErrorPanel
public TextMeshProUGUI ErrorText
public GameObject CraftButton
public GameObject ProgressPanel
public SteamInventoryNewItem NewItemModal
}
public Rust.UI.SteamInventoryItem : MonoBehaviour {
public IPlayerItem Item
public HttpImage Image
public bool Setup(IPlayerItem item)
}
public Rust.UI.SteamInventoryManager : SingletonComponent`1<SteamInventoryManager> {
public GameObject inventoryItemPrefab
public GameObject inventoryCanvas
public GameObject missingItems
public SteamInventoryCrafting CraftControl
public List`1<GameObject> items
public GameObject LoadingOverlay
}
public Rust.UI.SteamInventoryNewItem : MonoBehaviour {
public Task Open(IPlayerItem item)
}
internal Rust.UI.Utility.ForceWeather : MonoBehaviour {
private Toggle component
public bool Rain
public bool Fog
public bool Wind
public bool Clouds
public void OnEnable()
public void Update()
}
public RustCamera`1 : SingletonComponent`1<T> {
private DepthOfField dof
private AmplifyOcclusionEffect ssao
private Motion motionBlur
private TOD_Rays shafts
private TonemappingColorGrading tonemappingColorGrading
private FXAA fxaa
private SMAA smaa
private PostProcessLayer post
private CC_SharpenAndVignette sharpenAndVignette
private SEScreenSpaceShadows contactShadows
private VisualizeTexelDensity visualizeTexelDensity
private EnvironmentVolumePropertiesCollection environmentVolumeProperties
private ColorCorrectionCurves cctvCurves
}
public RustigeEgg : BaseCombatEntity {
public Flags Flag_Spin
public Transform eggRotationTransform
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsSpinning()
public void RPC_Spin(RPCMessage msg)
public void RPC_Open(RPCMessage msg)
public void CloseEgg()
}
public RustPlatformHooks : object {
public RustPlatformHooks Instance
public UInt32 SteamAppId
public Nullable`1<ServerParameters> ServerParameters
public UInt32 get_SteamAppId()
public void Abort()
public void OnItemDefinitionsChanged()
public Nullable`1<ServerParameters> get_ServerParameters()
public void AuthSessionValidated(ulong userId, ulong ownerUserId, AuthResponse response)
}
public SamSite : ContainerIOEntity {
public Animator pitchAnimator
public GameObject yaw
public GameObject pitch
public GameObject gear
public Transform eyePoint
public float gearEpislonDegrees
public float turnSpeed
public float clientLerpSpeed
public Vector3 currentAimDir
public Vector3 targetAimDir
public BaseCombatEntity currentTarget
public float scanRadius
public GameObjectRef projectileTest
public GameObjectRef muzzleFlashTest
public bool staticRespawn
public ItemDefinition ammoType
public Transform[] tubes
public bool alltarget
public float staticrepairseconds
public SoundDefinition yawMovementLoopDef
public float yawGainLerp
public float yawGainMovementSpeedMult
public SoundDefinition pitchMovementLoopDef
public float pitchGainLerp
public float pitchGainMovementSpeedMult
public Item ammoItem
public float lockOnTime
public float lastTargetVisibleTime
public int currentTubeIndex
private int firedCount
public float nextBurstTime
public bool IsPowered()
public int ConsumptionAmount()
public void Load(LoadInfo info)
public void PostServerLoad()
public void SelfHeal()
public void Die(HitInfo info)
public Vector3 EntityCenterPoint(BaseEntity ent)
public void FixedUpdate()
public Vector3 GetAimDir()
public void Save(SaveInfo info)
public void ServerInit()
public bool HasValidTarget()
public bool CanPickup(BasePlayer player)
public void TargetScan()
public bool HasAmmo()
public void Reload()
public void EnsureReloaded()
public bool IsReloading()
public void WeaponTick()
public void FireProjectile(Vector3 origin, Vector3 direction, BaseCombatEntity target)
}
public Sandstorm : MonoBehaviour {
public ParticleSystem m_psSandStorm
public float m_flSpeed
public float m_flSwirl
public float m_flEmissionRate
private void Start()
private void Update()
}
public SantaSleigh : BaseEntity {
public GameObjectRef prefabDrop
public SpawnFilter filter
public Transform dropOrigin
public float altitudeAboveTerrain
public float desiredAltitude
public Light bigLight
public SoundPlayer hohoho
public float hohohospacing
public float hohoho_additional_spacing
private Vector3 startPos
private Vector3 endPos
private float secondsToTake
private float secondsTaken
private bool dropped
private Vector3 dropPosition
public Vector3 swimScale
public Vector3 swimSpeed
private float swimRandom
public float appliedSwimScale
public float appliedSwimRotation
private string path
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float GetNetworkTime()
public void InitDropPosition(Vector3 newDropPosition)
public void ServerInit()
public void SendHoHoHo()
public Vector3 RandomDropPosition()
public void UpdateDropPosition(Vector3 newDropPosition)
private void FixedUpdate()
public void drop(Arg arg)
}
public SavePause : MonoBehaviour {
private bool tracked
protected void OnEnable()
protected void OnDisable()
}
public SaveRestore : SingletonComponent`1<SaveRestore> {
public bool IsSaving
public bool timedSave
public int timedSavePause
public DateTime SaveCreatedTime
private MemoryStream SaveBuffer
internal void ClearMapEntities()
public bool Load(string strFilename, bool allowOutOfDateSaves)
public void GetSaveCache()
public void InitializeEntityLinks()
public void InitializeEntitySupports()
public void InitializeEntityConditionals()
public IEnumerator Save(string strFilename, bool AndWait)
private void ShiftSaveBackups(string fileName)
private void Start()
private IEnumerator SaveRegularly()
private IEnumerator DoAutomatedSave(bool AndWait)
public bool Save(bool AndWait)
internal string <ShiftSaveBackups>g__GetBackupName|12_0(int i, <>c__DisplayClass12_0& )
}
public ScaleByIntensity : MonoBehaviour {
public Vector3 initialScale
public Light intensitySource
public float maxIntensity
private void Start()
private void Update()
}
public ScaleBySpeed : MonoBehaviour {
public float minScale
public float maxScale
public float minSpeed
public float maxSpeed
public MonoBehaviour component
public bool toggleComponent
public bool onlyWhenSubmerged
public float submergedThickness
private Vector3 prevPosition
private void Start()
private void Update()
}
public ScaleParticleSystem : ScaleRenderer {
public ParticleSystem pSystem
public bool scaleGravity
private float startSize
private float startLifeTime
private float startSpeed
private float startGravity
public void GatherInitialValues()
public void SetScale_Internal(float scale)
}
public ScaleRenderer : MonoBehaviour {
public bool useRandomScale
public float scaleMin
public float scaleMax
private float lastScale
protected bool hasInitialValues
public Renderer myRenderer
private bool ScaleDifferent(float newScale)
public void Start()
public void SetScale(float scale)
public void SetScale_Internal(float scale)
public void SetRendererEnabled(bool isEnabled)
public void GatherInitialValues()
}
public ScaleTrailRenderer : ScaleRenderer {
private TrailRenderer trailRenderer
private float startWidth
private float endWidth
private float duration
private float startMultiplier
public void GatherInitialValues()
public void SetScale_Internal(float scale)
}
public ScaleTransform : ScaleRenderer {
private Vector3 initialScale
public void SetScale_Internal(float scale)
public void GatherInitialValues()
}
public SceneToPrefab : MonoBehaviour {
public bool flattenHierarchy
public GameObject outputPrefab
}
public Scientist : NPCPlayerApex {
public HashSet`1<Scientist> AllScientists
private List`1<Scientist> CommQueryCache
private List`1<AiAnswer_ShareEnemyTarget> CommTargetCache
public LootSpawnSlot[] LootSpawnSlots
public string LootPanelName
public FamilyEnum Family
private void InitComm()
private void OnDestroyComm()
public int GetAlliesInRange(List`1& allies)
public void SendStatement(AiStatement_EnemyEngaged statement)
public void SendStatement(AiStatement_EnemySeen statement)
public void OnAiStatement(NPCPlayerApex source, AiStatement_EnemyEngaged statement)
public void OnAiStatement(NPCPlayerApex source, AiStatement_EnemySeen statement)
public int AskQuestion(AiQuestion_ShareEnemyTarget question, List`1& answers)
private void OnAggroComm()
public string Categorize()
public float StartHealth()
public float StartMaxHealth()
public float MaxHealth()
public FamilyEnum get_Family()
public void ServerInit()
internal void DoServerDestroy()
public bool ShouldDropActiveItem()
public BaseCorpse CreateCorpse()
public void Load(LoadInfo info)
}
public ScientistNPC : HumanNPC {
public GameObjectRef[] RadioChatterEffects
public GameObjectRef[] DeathEffects
public string deathStatName
public Vector2 IdleChatterRepeatRange
public RadioChatterType radioChatterType
public float lastAlertedTime
public void SetChatterType(RadioChatterType newType)
public void ServerInit()
public void IdleCheck()
public void QueueRadioChatter()
public bool ShotTest()
public void Alert()
public void OnAttacked(HitInfo info)
public void OnKilled(HitInfo info)
public void PlayRadioChatter()
public void EquipWeapon()
protected string OverrideCorpseName()
}
public Scoreboard : MonoBehaviour {
public Scoreboard instance
public RustText scoreboardTitle
public RectTransform scoreboardRootContents
public RustText scoreLimitText
public GameObject teamPrefab
public GameObject columnPrefab
public GameObject dividerPrefab
public Color localPlayerColor
public Color otherPlayerColor
public TeamColumn[] teamColumns
public GameObject[] TeamPanels
}
public ScrapTransportHelicopter : MiniCopter {
public Transform searchlightEye
public ParticleSystemContainer tailDamageLight
public ParticleSystemContainer tailDamageHeavy
public ParticleSystemContainer mainEngineDamageLight
public ParticleSystemContainer mainEngineDamageHeavy
public ParticleSystemContainer cockpitSparks
public Transform tailDamageLightEffects
public Transform mainEngineDamageLightEffects
public SoundDefinition damagedFireSoundDef
public SoundDefinition damagedFireTailSoundDef
public SoundDefinition damagedSparksSoundDef
private Sound damagedFireSound
private Sound damagedFireTailSound
private Sound damagedSparksSound
public float pilotRotorScale
public float compassOffset
public float population
public void OnHealthChanged(float oldvalue, float newvalue)
public void DelayedNetworking()
public void OnAttacked(HitInfo info)
protected bool CanPushNow(BasePlayer pusher)
}
public ScrapTransportHelicopterWheelEffects : MonoBehaviour {
public WheelCollider wheelCollider
public GameObjectRef impactEffect
public float minTimeBetweenEffects
public float minDistBetweenEffects
private bool wasGrounded
private float lastEffectPlayed
private Vector3 lastCollisionPos
public void Update()
private void DoImpactEffect()
}
public ScreenBounce : BaseScreenShake {
public AnimationCurve bounceScale
public AnimationCurve bounceSpeed
public AnimationCurve bounceViewmodel
private float bounceTime
private Vector3 bounceVelocity
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public ScreenBounceFade : BaseScreenShake {
public AnimationCurve bounceScale
public AnimationCurve bounceSpeed
public AnimationCurve bounceViewmodel
public AnimationCurve distanceFalloff
public AnimationCurve timeFalloff
private float bounceTime
private Vector3 bounceVelocity
public float maxDistance
public float scale
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public ScreenFov : BaseScreenShake {
public AnimationCurve FovAdjustment
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public ScreenRotate : BaseScreenShake {
public AnimationCurve Pitch
public AnimationCurve Yaw
public AnimationCurve Roll
public AnimationCurve ViewmodelEffect
public bool useViewModelEffect
public void Setup()
public void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm)
}
public Screenshot : MonoBehaviour {
public string screenshotPath
public int sizeMultiplier
}
public ScreenshotCamera : RustCamera`1<ScreenshotCamera> {
public List`1<ScreenshotCamera> activeScreenshotCameras
}
public ScrollRectZoom : MonoBehaviour {
public ScrollRectEx scrollRect
public float zoom
public bool smooth
public float max
public float min
public float scrollAmount
public RectTransform rectTransform
public RectTransform get_rectTransform()
private void OnEnable()
public void OnScroll(PointerEventData data)
private void SetZoom(float z)
}
public SearchLight : IOEntity {
public GameObject pitchObject
public GameObject yawObject
public GameObject eyePoint
public SoundPlayer turnLoop
public bool needsBuildingPrivilegeToUse
public Vector3 aimDir
public BasePlayer mountedPlayer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public int ConsumptionAmount()
public bool IsMounted()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void PlayerEnter(BasePlayer player)
public void PlayerExit()
public void MountedUpdate()
public void SetTargetAimpoint(Vector3 worldPos)
public int GetCurrentEnergy()
public void RPC_UseLight(RPCMessage msg)
public void OnKilled(HitInfo info)
public void Update()
}
public SeasonalTimedExplosive : TimedExplosive {
public RandomRendererEnable randomRenderer
}
public sedanAnimation : MonoBehaviour {
public Transform[] frontAxles
public Transform FL_shock
public Transform FL_wheel
public Transform FR_shock
public Transform FR_wheel
public Transform RL_shock
public Transform RL_wheel
public Transform RR_shock
public Transform RR_wheel
public WheelCollider FL_wheelCollider
public WheelCollider FR_wheelCollider
public WheelCollider RL_wheelCollider
public WheelCollider RR_wheelCollider
public Transform steeringWheel
public float motorForceConstant
public float brakeForceConstant
public float brakePedal
public float gasPedal
public float steering
private Rigidbody myRigidbody
public float GasLerpTime
public float SteeringLerpTime
private float wheelSpinConstant
private float shockRestingPosY
private float shockDistance
private float traceDistanceNeutralPoint
private void Start()
private void Update()
private void InputPlayer()
private void DoSteering()
private void ApplyForceAtWheels()
private void UpdateTireAnimation()
private float GetShockHeightDelta(WheelCollider wheel)
}
public SedanWheelSmoke : MonoBehaviour {
public ParticleSystem[] tireSmoke
public ParticleSystem[] tireWaterSplash
public ParticleSystem[] tireWaterSplash_Extra
public Boolean[] wheelTouching
}
public SeedInformationPanel : ItemInformationPanel {
public ItemTextValue maxHarvestsDisplay
public UIGenesDisplay GeneticsDisplay
public Text TextUnknownGenetics
public GameObject GeneticsGameObject
public ItemStatValue WaterResilience
public ItemStatValue GroundResilience
public ItemStatValue LightResilience
public ItemStatValue TemperatureResilience
}
public SegmentMaskPositioning : MonoBehaviour {
public PlayerModel source
public GameObject headMask
public GameObject chestMask
public GameObject legsMask
public float xOffset
}
public SelectedBlueprint : SingletonComponent`1<SelectedBlueprint> {
public ItemBlueprint blueprint
public InputField craftAmountText
public GameObject ingredientGrid
public IconSkinPicker skinPicker
public Image iconImage
public RustText titleText
public RustText descriptionText
public CanvasGroup CraftArea
public Button CraftButton
public RustText CraftingTime
public RustText CraftingAmount
public Sprite FavouriteOnSprite
public Sprite FavouriteOffSprite
public Image FavouriteButtonStatusMarker
public GameObject[] workbenchReqs
private ItemInformationPanel[] informationPanels
public bool isOpen
public bool get_isOpen()
}
public SelectedItem : SingletonComponent`1<SelectedItem> {
public Image icon
public Image iconSplitter
public RustText title
public RustText description
public GameObject splitPanel
public GameObject itemProtection
public GameObject menuOption
public GameObject optionsParent
public GameObject innerPanelContainer
}
public SelfCheck : object {
public bool Run()
private bool Failed(string Message)
private bool TestRustNative()
private bool RustNative_VersionCheck(int version)
}
public SellOrderEntry : MonoBehaviour {
public VirtualItemIcon MerchandiseIcon
public VirtualItemIcon CurrencyIcon
private ItemDefinition merchandiseInfo
private ItemDefinition currencyInfo
public GameObject buyButton
public GameObject cantaffordNotification
public GameObject outOfStockNotification
private IVendingMachineInterface vendingPanel
public UIIntegerEntry intEntry
}
public SendMessageToEntityOnAnimationFinish : StateMachineBehaviour {
public string messageToSendToEntity
public float repeatRate
private float lastMessageSent
public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
}
public SeparableSSS : object {
private Vector3 Gaussian(float variance, float r, Color falloffColor)
private Vector3 Profile(float r, Color falloffColor)
public void CalculateKernel(Color[] target, int targetStart, int targetSize, Color subsurfaceColor, Color falloffColor)
}
public ServerBrowser : MonoBehaviour {
public string orderBy
}
public ServerBrowserCategory : MonoBehaviour {
public LocalizeText serverCountText
}
public ServerBrowserInfo : SingletonComponent`1<ServerBrowserInfo> {
public bool isMain
public Text serverName
public Text serverMeta
public Text serverText
public Button viewWebpage
public Button refresh
public Nullable`1<ServerInfo> currentServer
public HttpImage headerImage
public HttpImage logoImage
}
public ServerBrowserItem : MonoBehaviour {
public TextMeshProUGUI serverName
public RustText mapName
public TextMeshProUGUI playerCount
public TextMeshProUGUI ping
public Toggle favourited
public ServerBrowserTag[] serverTags
}
public ServerBrowserList : BaseMonoBehaviour {
public QueryType queryType
public string VersionTag
public ServerKeyvalues[] keyValues
public ServerBrowserCategory categoryButton
public bool startActive
public Transform listTransform
public int refreshOrder
public bool UseOfficialServers
public VirtualScroll VirtualScroll
public Rules[] rules
public bool hideOfficialServers
public bool excludeEmptyServersUsingQuery
public bool alwaysIncludeEmptyServers
public int GetItemCount()
public void SetItemData(int i, GameObject obj)
}
public ServerBrowserTag : MonoBehaviour {
public String[] serverHasAnyOf
public String[] serverHasNoneOf
public bool Test(ServerInfo& serverInfo)
}
public ServerBuildingManager : BuildingManager {
private int decayTickBuildingIndex
private int decayTickEntityIndex
private int decayTickWorldIndex
private int navmeshCarveTickBuildingIndex
private UInt32 maxBuildingID
public void CheckSplit(DecayEntity ent)
private bool ShouldSplit(Building building)
private void Split(Building building)
public void CheckMerge(DecayEntity ent)
private void Merge(Building building1, Building building2)
public void Cycle()
public void UpdateNavMeshCarver(Building building, Int32& ticks, int i)
public UInt32 NewBuildingID()
public void LoadBuildingID(UInt32 id)
protected Building CreateBuilding(UInt32 id)
protected void DisposeBuilding(Building& building)
}
public ServerConsole : SingletonComponent`1<ServerConsole> {
private DateTime currentGameTime
private int currentPlayerCount
private int maxPlayerCount
private int currentEntityCount
private int currentSleeperCount
public void OnEnable()
private void OnDisable()
private void OnInputText(string obj)
public void PrintColoured(Object[] objects)
private void HandleLog(string message, string stackTrace, LogType type)
private DateTime get_currentGameTime()
private int get_currentPlayerCount()
private int get_maxPlayerCount()
private int get_currentEntityCount()
private int get_currentSleeperCount()
}
public ServerGib : BaseCombatEntity {
public GameObject _gibSource
public string _gibName
public PhysicMaterial physicsMaterial
private MeshCollider meshCollider
private Rigidbody rigidBody
public float BoundsPadding()
public List`1<ServerGib> CreateGibs(string entityToCreatePath, GameObject creator, GameObject gibSource, Vector3 inheritVelocity, float spreadVelocity)
public void Save(SaveInfo info)
public MeshCollider GetCollider()
public void ServerInit()
public void RemoveMe()
public void PhysicsInit(Mesh physicsMesh)
}
public ServerHistory : MonoBehaviour {
public ServerHistoryItem prefab
public GameObject panelList
internal IServerQuery Request
}
public ServerHistoryItem : MonoBehaviour {
private ServerInfo serverInfo
public Text serverName
public Text players
public Text lastJoinDate
public UInt32 order
}
public ServerMgr : SingletonComponent`1<ServerMgr> {
public ConnectionQueue connectionQueue
public TimeAverageValueLookup`1<Type> packetHistory
public TimeAverageValueLookup`1<UInt32> rpcHistory
private Stopwatch queryTimer
private Dictionary`2<UInt32, int> unconnectedQueries
private Stopwatch queriesPerSeconTimer
private int NumQueriesLastSecond
private MemoryStream queryBuffer
public string BYPASS_PROCEDURAL_SPAWN_PREF
private ConnectionAuth auth
private bool runFrameUpdate
private bool useQueryPort
public UserPersistance persistance
public PlayerStateManager playerStateManager
private List`1<ulong> bannedPlayerNotices
private string _AssemblyHash
private IEnumerator restartCoroutine
public int AvailableSlots
private string AssemblyHash
public bool Restarting
private void Log(Exception e)
public void OnNetworkMessage(Message packet)
public void ProcessUnhandledPacket(Message packet)
public void ReadDisconnectReason(Message packet)
private BasePlayer SpawnPlayerSleeping(Connection connection)
private BasePlayer SpawnNewPlayer(Connection connection)
private void ClientReady(Message packet)
private void OnRPCMessage(Message packet)
private void OnPlayerTick(Message packet)
private void OnPlayerVoice(Message packet)
private void OnGiveUserInformation(Message packet)
public bool OnUnconnectedMessage(int type, NetRead read, UInt32 ip, int port)
public void Initialize(bool loadSave, string saveFile, bool allowOutOfDateSaves, bool skipInitialSpawn)
public void OpenConnection()
private void CloseConnection()
private void OnDisable()
private void OnApplicationQuit()
private void CreateImportantEntities()
public void CreateImportantEntity(string prefabName)
private void StartSteamServer()
private void UpdateItemDefinitions()
internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)
private void EACUpdate()
public int get_AvailableSlots()
private void Update()
private void FixedUpdate()
private void SteamQueryResponse()
private void DoTick()
private void DoHeartbeat()
private string get_AssemblyHash()
public string GamemodeName()
public string GamemodeTitle()
public string GamemodeDesc()
public string GamemodeImage()
public string GamemodeUrl()
private void UpdateServerInformation()
public void OnDisconnected(string strReason, Connection connection)
public void OnEnterVisibility(Connection connection, Group group)
public void OnLeaveVisibility(Connection connection, Group group)
internal void SpawnMapEntities()
public SpawnPoint FindSpawnPoint(BasePlayer forPlayer)
public void JoinGame(Connection connection)
public bool get_Restarting()
internal void Shutdown()
private IEnumerator ServerRestartWarning(string info, int iSeconds)
public void RestartServer(string strNotice, int iSeconds)
public void SendReplicatedVars(string filter)
public void SendReplicatedVars(Connection connection)
private void OnReplicatedVarChanged(string fullName, string value)
}
public ServerPerformance : BaseMonoBehaviour {
public ulong deaths
public ulong spawns
public ulong position_changes
private string fileName
private int lastFrame
private void Start()
private void WriteLine()
public void DoReport()
public string WorkoutPrefabName(GameObject obj)
public void ComponentReport(string filename, string Title, Object[] objects)
}
public ServerProjectile : EntityComponent`1<BaseEntity> {
public Vector3 initialVelocity
public float drag
public float gravityModifier
public float speed
public float scanRange
public Vector3 swimScale
public Vector3 swimSpeed
public float radius
public bool impacted
public float swimRandom
public Vector3 _currentVelocity
private void FixedUpdate()
public void DoMovement()
public void InitializeVelocity(Vector3 overrideVel)
}
public ServerStatistics : object {
private BasePlayer player
private Storage storage
private Dictionary`2<ulong, Storage> players
public void .ctor(BasePlayer player)
public void Init()
public void Save()
public void Add(string name, int val)
public Storage Get(ulong id)
}
public ServerUsers : object {
public Dictionary`2<ulong, User> users
public void Remove(ulong uid)
public void Set(ulong uid, UserGroup group, string username, string notes, long expiry)
public User Get(ulong uid)
public bool Is(ulong uid, UserGroup group)
public IEnumerable`1<User> GetAll(UserGroup group)
public void Clear()
public void Load()
public void Save()
public string BanListString(bool bHeader)
public string BanListStringEx()
}
public SEScreenSpaceShadows : MonoBehaviour {
private CommandBuffer blendShadowsCommandBuffer
private CommandBuffer renderShadowsCommandBuffer
private Camera attachedCamera
public Light sun
public float blendStrength
public float accumulation
public float lengthFade
public float range
public float zThickness
public int samples
public float nearSampleQuality
public float traceBias
public bool stochasticSampling
public bool leverageTemporalAA
public bool bilateralBlur
public int blurPasses
public float blurDepthTolerance
}
public SetupAppNotification : UIDialog {
public RustInput titleInput
public RustInput bodyInput
}
public SharpenAndVignetteOverlay : ImageEffectLayer {
public CC_SharpenAndVignette sharpenAndVignette
}
public ShopFront : StorageContainer {
public float maxUseAngle
public BasePlayer vendorPlayer
public BasePlayer customerPlayer
public GameObjectRef transactionCompleteEffect
public ItemContainer customerInventory
private float AngleDotProduct
public ItemContainer vendorInventory
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private float get_AngleDotProduct()
public ItemContainer get_vendorInventory()
public bool TradeLocked()
public bool IsTradingPlayer(BasePlayer player)
public bool IsPlayerCustomer(BasePlayer player)
public bool IsPlayerVendor(BasePlayer player)
public bool PlayerInVendorPos(BasePlayer player)
public bool PlayerInCustomerPos(BasePlayer player)
public bool LootEligable(BasePlayer player)
public void ResetTrade()
public void CompleteTrade()
public void AcceptClicked(RPCMessage msg)
public void CancelClicked(RPCMessage msg)
public void PreServerLoad()
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
private bool CanAcceptVendorItem(Item item, int targetSlot)
private bool CanAcceptCustomerItem(Item item, int targetSlot)
public bool CanMoveFrom(BasePlayer player, Item item)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public void ReturnPlayerItems(BasePlayer player)
public void PlayerStoppedLooting(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void UpdatePlayers()
}
public ShopFrontLootPanel : LootPanel {
public Text playerLabelA
public Text playerLabelB
public GameObject confirmButton
public GameObject confirmHelp
public GameObject denyButton
public GameObject denyHelp
public GameObject waitingText
public GameObject exchangeInProgressImage
public Phrase acceptedPhrase
public Phrase noOnePhrase
}
public ShowIfConvarEnabled : MonoBehaviour {
public string Convar
}
public Signage : IOEntity {
private float TextureRequestTimeout
public GameObjectRef changeTextDialog
public MeshPaintableSource[] paintableSources
public UInt32[] textureIDs
public Vector2i TextureSize
public int TextureCount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector2i get_TextureSize()
public int get_TextureCount()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void UpdateSign(RPCMessage msg)
public void EnsureInitialized()
private void SignDebugLog(string str)
public bool CanUpdateSign(BasePlayer player)
public bool CanUnlockSign(BasePlayer player)
public bool CanLockSign(BasePlayer player)
public void Load(LoadInfo info)
public void LockSign(RPCMessage msg)
public void UnLockSign(RPCMessage msg)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public bool ShouldNetworkOwnerInfo()
public int ConsumptionAmount()
public string Categorize()
}
public SimpleLight : IOEntity {
public void ResetIOState()
public void IOStateChanged(int inputAmount, int inputSlot)
}
public SimpleList`1 : object {
private int defaultCapacity
private T[] emptyArray
public T[] array
public int count
public T[] Array
public int Count
public int Capacity
public T Item
public T[] get_Array()
public int get_Count()
public int get_Capacity()
public void set_Capacity(int value)
public T get_Item(int index)
public void set_Item(int index, T value)
public void .ctor(int capacity)
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array)
public void EnsureCapacity(int min)
}
public SingleSpawn : SpawnGroup {
public bool WantsInitialSpawn()
public void FillDelay(float delay)
}
public SirenLight : IOEntity {
public GameObject lightObj
public float speed
public void ResetState()
}
public SkeletonProperties : ScriptableObject {
public GameObject boneReference
public BoneProperty[] bones
private Dictionary`2<UInt32, BoneProperty> quickLookup
public void OnValidate()
private void BuildDictionary()
public BoneProperty FindBone(UInt32 id)
}
public SkinnedMultiMesh : MonoBehaviour {
public bool shadowOnly
internal bool IsVisible
public Skeleton skeleton
public SkeletonSkinLod skeletonSkinLod
public List`1<Part> parts
public List`1<Part> createdParts
public long lastBuildHash
public MaterialPropertyBlock sharedPropertyBlock
public MaterialPropertyBlock hairPropertyBlock
public float skinNumber
public float meshNumber
public float hairNumber
public int skinType
public SkinSetCollection SkinCollection
private List`1<Renderer> <Renderers>k__BackingField
public List`1<Renderer> Renderers
public List`1<Renderer> get_Renderers()
}
public SkinReplacement : object {
public SkinType skinReplacementType
public GameObjectRef targetReplacement
}
public SkinSet : ScriptableObject {
public string Label
public Gradient SkinColour
public HairSetCollection HairCollection
public GameObjectRef Head
public GameObjectRef Torso
public GameObjectRef Legs
public GameObjectRef Feet
public GameObjectRef Hands
public GameObjectRef CensoredTorso
public GameObjectRef CensoredLegs
public Material HeadMaterial
public Material BodyMaterial
public Material EyeMaterial
internal Color GetSkinColor(float skinNumber)
}
public SkinSetCollection : ScriptableObject {
public SkinSet[] Skins
public int GetIndex(float MeshNumber)
public SkinSet Get(float MeshNumber)
}
public SkullTrophy : StorageContainer {
public RustText NameText
public TextProOnACircle CircleModifier
public int AngleModifierMinCharCount
public int AngleModifierMaxCharCount
public int AngleModifierMinArcAngle
public int AngleModifierMaxArcAngle
public float SunsetTime
public float SunriseTime
public MeshRenderer[] SkullRenderers
public Material[] DaySkull
public Material[] NightSkull
public Material[] NoSkull
public void OnItemAddedOrRemoved(Item item, bool added)
public void Save(SaveInfo info)
}
public Sled : BaseVehicle {
private Flags BrakeOn
private Flags OnSnow
private Flags IsGrounded
private Flags OnSand
public PhysicMaterial BrakeMaterial
public PhysicMaterial SnowMaterial
public PhysicMaterial NonSnowMaterial
public Transform CentreOfMassTransform
public Collider[] PhysicsMaterialTargets
public float InitialForceCutoff
public float InitialForceIncreaseRate
public float TurnForce
public float DirectionMatchForce
public float VerticalAdjustmentForce
public float VerticalAdjustmentAngleThreshold
public float NudgeCooldown
public float NudgeForce
public float MaxNudgeVelocity
public float DecayFrequency
public float DecayAmount
public ParticleSystemContainer TrailEffects
public SoundDefinition enterSnowSoundDef
public SoundDefinition snowSlideLoopSoundDef
public SoundDefinition dirtSlideLoopSoundDef
public AnimationCurve movementLoopGainCurve
public AnimationCurve movementLoopPitchCurve
private VehicleTerrainHandler terrainHandler
private PhysicMaterial cachedMaterial
private float initialForceScale
private TimeSince leftIce
private TimeSince lastNudge
public bool BlocksDoors
public void ServerInit()
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy)
protected void VehicleFixedUpdate()
private void UpdatePhysicsMaterial()
private void UpdateGroundedFlag()
private PhysicMaterial GetPhysicMaterial()
public void PlayerMounted(BasePlayer player, BaseMountable seat)
private void ApplyInitialForce()
public void PlayerServerInput(InputState inputState, BasePlayer player)
private void DecayOverTime()
public bool CanPickup(BasePlayer player)
public void OnObjects(TriggerNotify trigger)
public void OnEmpty()
public bool get_BlocksDoors()
}
public SledSeat : BaseVehicleSeat {
public Transform LeftHand
public Transform RightHand
public Transform LeftFoot
public Transform RightFoot
}
public SleepingBag : DecayEntity {
public ulong deployerUserID
public GameObject renameDialog
public GameObject assignDialog
public float secondsBetweenReuses
public string niceName
public Vector3 spawnOffset
public RespawnType RespawnType
public bool isStatic
public bool canBePublic
public float unlockTime
public List`1<SleepingBag> sleepingBags
public float unlockSeconds
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPublic()
public float get_unlockSeconds()
public float GetUnlockSeconds(ulong playerID)
public bool ValidForPlayer(ulong playerID, bool ignoreTimers)
public SleepingBag[] FindForPlayer(ulong playerID, bool ignoreTimers)
public SleepingBag FindForPlayer(ulong playerID, UInt32 sleepingBagID, bool ignoreTimers)
public bool SpawnPlayer(BasePlayer player, UInt32 sleepingBag)
public void SetUnlockTime(float newTime)
public bool DestroyBag(BasePlayer player, UInt32 sleepingBag)
public void GetSpawnPos(Vector3& pos, Quaternion& rot)
public void SetPublic(bool isPublic)
private void SetDeployedBy(BasePlayer player)
public void ServerInit()
internal void DoServerDestroy()
public void Save(SaveInfo info)
public void Rename(RPCMessage msg)
public void AssignToFriend(RPCMessage msg)
public void RPC_MakePublic(RPCMessage msg)
public void RPC_MakeBed(RPCMessage msg)
public void Load(LoadInfo info)
public bool CanPickup(BasePlayer player)
private bool <DoServerDestroy>b__26_0(SleepingBag x)
}
public SleepingBagButton : MonoBehaviour {
public GameObject[] timerInfo
public Button ClickButton
public TextMeshProUGUI BagName
public TextMeshProUGUI LockTime
public Image Icon
public Sprite SleepingBagSprite
public Sprite BedSprite
public Sprite BeachTowelSprite
public Image CircleRim
public Image CircleFill
public Image Background
public GameObject DeleteButton
internal SpawnOptions spawnOption
internal float releaseTime
public float timerSeconds
public string friendlyName
public float get_timerSeconds()
public string get_friendlyName()
public void Setup(SpawnOptions option, RespawnColourScheme colourScheme)
public void Update()
public void DoSpawn()
public void DeleteBag()
public void OnPointerEnter(PointerEventData eventData)
public void OnPointerExit(PointerEventData eventData)
}
public SleepingBagClusterMapMarker : MonoBehaviour {
public TextMeshProUGUI CountText
public List`1<SleepingBagButton> SleepingBagButtons
public GameObject OpenRoot
public Tooltip SummaryTooltip
public Image RimImage
}
public SleepingBagMapMarker : MonoBehaviour {
public Image MapIcon
public Image SleepingBagIcon
public Sprite SleepingBagSprite
public Sprite BedSprite
public Sprite BeachTowelSprite
public Tooltip MarkerTooltip
public GameObject LockRoot
public TextMeshProUGUI LockTime
public Image CircleRim
public Image CircleFill
}
public SlicedGranularAudioClip : MonoBehaviour {
public AudioClip sourceClip
public AudioClip granularClip
public int sampleRate
public float grainAttack
public float grainSustain
public float grainRelease
public float grainFrequency
public int grainAttackSamples
public int grainSustainSamples
public int grainReleaseSamples
public int grainFrequencySamples
public int samplesUntilNextGrain
public List`1<Grain> grains
public List`1<int> startPositions
public int lastStartPositionIdx
}
public SlidingProgressDoor : ProgressDoor {
public Vector3 openPosition
public Vector3 closedPosition
public GameObject doorObject
public TriggerVehiclePush vehiclePhysBox
private float lastEnergyTime
private float lastServerUpdateTime
public void Spawn()
public void NoEnergy()
public void AddEnergy(float amount)
public void ServerUpdate()
public void UpdateProgress()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
}
public SlotMachine : BaseMountable {
public int ForcePayoutIndex
public Transform Reel1
public Transform Reel2
public Transform Reel3
public Transform Arm
public AnimationCurve Curve
public int Reel1Spins
public int Reel2Spins
public int Reel3Spins
public int MaxReelSpins
public float SpinDuration
private int SpinResult1
private int SpinResult2
private int SpinResult3
private int SpinResultPrevious1
private int SpinResultPrevious2
private int SpinResultPrevious3
private float SpinTime
public GameObjectRef StoragePrefab
public EntityRef StorageInstance
public SoundDefinition SpinSound
public SlotMachinePayoutDisplay PayoutDisplay
public SlotMachinePayoutSettings PayoutSettings
public Transform HandIkTarget
private Flags HasScrapForSpin
private Flags IsSpinningFlag
public Material PayoutIconMaterial
public MeshRenderer[] PulseRenderers
public float PulseSpeed
public Color PulseFrom
public Color PulseTo
private int <CurrentMultiplier>k__BackingField
private BasePlayer CurrentSpinPlayer
private bool IsSpinning
public int CurrentMultiplier
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private bool get_IsSpinning()
public int get_CurrentMultiplier()
private void set_CurrentMultiplier(int value)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float GetComfort()
public void Spawn()
private int GetBettingAmount()
private void RPC_Spin(RPCMessage rpc)
private void RPC_Deposit(RPCMessage rpc)
private void CheckPayout()
private void DelayedSpinningReset()
private void CalculateSpinResults()
private int RandomSpinResult()
public void OnPlayerDismounted(BasePlayer player)
private void Server_RequestMultiplierChange(RPCMessage msg)
public void OnBettingScrapUpdated(int amount)
private bool CalculatePayout(PayoutInfo& info, Int32& bonus)
}
public SlotMachineLootPanel : LootPanel {
public Text spinsRemainingText
public Text multiplierText
public LocalizeText ScrapCostText
}
public SlotMachinePayoutDisplay : MonoBehaviour {
public GameObjectRef PayoutWidget
public RectTransform WidgetRoot
public Sprite[] FaceSprites
}
public SlotMachinePayoutSettings : ScriptableObject {
public ItemAmount SpinCost
public PayoutInfo[] Payouts
public Int32[] VirtualFaces
public IndividualPayouts[] FacePayouts
public int TotalStops
public GameObjectRef DefaultWinEffect
}
public SlotMachinePayoutWidget : MonoBehaviour {
public RustText PayoutAmount
public GameObject AnyText
public Image[] Faces
}
public SlotMachineStorage : StorageContainer {
public int Amount
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsPlayerValid(BasePlayer player)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
protected void OnInventoryDirty()
public void UpdateAmount(int amount)
}
public Smaa.DebugPass : Enum {
public int value__
public DebugPass Off
public DebugPass Edges
public DebugPass Weights
}
public Smaa.EdgeDetectionMethod : Enum {
public int value__
public EdgeDetectionMethod Luma
public EdgeDetectionMethod Color
public EdgeDetectionMethod Depth
}
public Smaa.MinAttribute : PropertyAttribute {
public float min
public void .ctor(float min)
}
public Smaa.PredicationPreset : object {
public float Threshold
public float Scale
public float Strength
}
public Smaa.Preset : object {
public bool DiagDetection
public bool CornerDetection
public float Threshold
public float DepthThreshold
public int MaxSearchSteps
public int MaxSearchStepsDiag
public int CornerRounding
public float LocalContrastAdaptationFactor
}
public Smaa.QualityPreset : Enum {
public int value__
public QualityPreset Low
public QualityPreset Medium
public QualityPreset High
public QualityPreset Ultra
public QualityPreset Custom
}
public Smaa.SMAA : MonoBehaviour {
public DebugPass DebugPass
public QualityPreset Quality
public EdgeDetectionMethod DetectionMethod
public bool UsePredication
public Preset CustomPreset
public PredicationPreset CustomPredicationPreset
public Shader Shader
public Texture2D AreaTex
public Texture2D SearchTex
protected Camera m_Camera
protected Preset m_LowPreset
protected Preset m_MediumPreset
protected Preset m_HighPreset
protected Preset m_UltraPreset
protected Material m_Material
public Material Material
public Material get_Material()
}
public SmartAlarm : AppIOEntity {
public Flags Flag_HasCustomMessage
public Phrase DefaultNotificationTitle
public Phrase DefaultNotificationBody
public GameObjectRef SetupNotificationDialog
public Animator Animator
private bool <Value>k__BackingField
public NotificationList _subscriptions
public string _notificationTitle
public string _notificationBody
public float _lastSentTime
public AppEntityType Type
public bool Value
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public AppEntityType get_Type()
public bool get_Value()
public void set_Value(bool value)
public bool AddSubscription(ulong steamId)
public bool RemoveSubscription(ulong steamId)
public bool HasSubscription(ulong steamId)
public void InitShared()
public void IOStateChanged(int inputAmount, int inputSlot)
public void Save(SaveInfo info)
public void Load(LoadInfo info)
protected void OnPairedWithPlayer(BasePlayer player)
private void StartSetupNotification(RPCMessage rpc)
private void SetNotificationTextImpl(RPCMessage rpc)
}
public SmartSwitch : AppIOEntity {
public Animator ReceiverAnimator
public AppEntityType Type
public bool Value
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool WantsPower()
public AppEntityType get_Type()
public void ServerInit()
public int ConsumptionAmount()
public void ResetIOState()
public int GetPassthroughAmount(int outputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void SetSwitch(bool wantsOn)
public void ToggleSwitch(RPCMessage msg)
public bool get_Value()
public void set_Value(bool value)
public void Unbusy()
private bool PlayerCanToggle(BasePlayer player)
}
public SmokeGrenade : TimedExplosive {
public float smokeDuration
public GameObjectRef smokeEffectPrefab
public GameObjectRef igniteSound
public SoundPlayer soundLoop
private GameObject smokeEffectInstance
public List`1<SmokeGrenade> activeGrenades
public float fieldMin
public float fieldMax
protected bool killing
public void ServerInit()
public void Explode()
public void CheckForWater()
public void FinishUp()
public void DestroyShared()
}
public SnowballGun : BaseProjectile {
public ItemDefinition OverrideProjectile
protected ItemDefinition PrimaryMagazineAmmo
protected bool CanRefundAmmo
protected void ReloadMagazine(int desiredAmount)
protected ItemDefinition get_PrimaryMagazineAmmo()
protected bool get_CanRefundAmmo()
}
public SnowballGunProjectile : Projectile {
public float OverrideEffectScale
public GameObjectRef SnowballImpactEffect
}
public SnowEffect : WeatherEffect {
public int FadeStartDistance
public int FadeEndDistance
public int FadeFalloff
public bool Stormy
}
public SnowMachine : FogMachine {
public AdaptMeshToTerrain snowMesh
public TriggerTemperature tempTrigger
public bool MotionModeEnabled()
public void EnableFogField()
public void FinishFogging()
}
public SoccerBall : BaseCombatEntity {
private Rigidbody rigidBody
private float additionalForceMultiplier
private float upForceMultiplier
private DamageRenderer damageRenderer
private float explosionForceMultiplier
private float otherForceMultiplier
protected void OnCollisionEnter(Collision collision)
public void Hurt(HitInfo info)
}
public Socket_Base : PrefabAttribute {
public bool male
public bool maleDummy
public bool female
public bool femaleDummy
public bool monogamous
public Vector3 position
public Quaternion rotation
public Vector3 selectSize
public Vector3 selectCenter
public string socketName
public SocketMod[] socketMods
public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation)
public OBB GetSelectBounds(Vector3 position, Quaternion rotation)
protected Type GetIndexedType()
protected void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool TestTarget(Target target)
public bool IsCompatible(Socket_Base socket)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
public Placement DoPlacement(Target target)
public bool CheckSocketMods(Placement placement)
}
public Socket_Free : Socket_Base {
public Vector3 idealPlacementNormal
public bool useTargetNormal
public bool blendAimAngle
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public Placement DoPlacement(Target target)
}
public Socket_Specific : Socket_Base {
public bool useFemaleRotation
public string targetSocketName
private void OnDrawGizmos()
public bool TestTarget(Target target)
public Placement DoPlacement(Target target)
}
public Socket_Specific_Female : Socket_Base {
public int rotationDegrees
public int rotationOffset
public String[] allowedMaleSockets
private void OnDrawGizmos()
private void OnDrawGizmosSelected()
public bool CanAccept(Socket_Specific socket)
}
public Socket_Terrain : Socket_Base {
public float placementHeight
public bool alignToNormal
private void OnDrawGizmos()
public bool TestTarget(Target target)
public Placement DoPlacement(Target target)
}
public SocketHandle : PrefabAttribute {
protected Type GetIndexedType()
internal void AdjustTarget(Target& target, float maxplaceDistance)
}
public SocketMod : PrefabAttribute {
public Socket_Base baseSocket
public Phrase FailedPhrase
public bool DoCheck(Placement place)
public void ModifyPlacement(Placement place)
protected Type GetIndexedType()
}
public SocketMod_AngleCheck : SocketMod {
public bool wantsAngle
public Vector3 worldNormal
public float withinDegrees
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_AreaCheck : SocketMod {
public Bounds bounds
public LayerMask layerMask
public bool wantsInside
private void OnDrawGizmosSelected()
public bool IsInArea(Vector3 position, Quaternion rotation, Bounds bounds, LayerMask layerMask)
public bool DoCheck(Vector3 position, Quaternion rotation)
public bool DoCheck(Placement place)
}
public SocketMod_Attraction : SocketMod {
public float outerRadius
public float innerRadius
public string groupName
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
public void ModifyPlacement(Placement place)
}
public SocketMod_BuildingBlock : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_EntityCheck : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public BaseEntity[] entityTypes
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_EntityType : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public BaseEntity searchType
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_HotSpot : SocketMod {
public float spotSize
private void OnDrawGizmos()
public void ModifyPlacement(Placement place)
}
public SocketMod_InWater : SocketMod {
public bool wantsInWater
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_PhysicMaterial : SocketMod {
public PhysicMaterial[] ValidMaterials
private PhysicMaterial foundMaterial
public bool DoCheck(Placement place)
}
public SocketMod_PlantCheck : SocketMod {
public float sphereRadius
public LayerMask layerMask
public QueryTriggerInteraction queryTriggers
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_SphereCheck : SocketMod {
public float sphereRadius
public LayerMask layerMask
public bool wantsCollide
private void OnDrawGizmosSelected()
public bool DoCheck(Placement place)
}
public SocketMod_TerrainCheck : SocketMod {
public bool wantsInTerrain
private void OnDrawGizmos()
public bool IsInTerrain(Vector3 vPoint)
public bool DoCheck(Placement place)
}
public SocketMod_WaterDepth : SocketMod {
public float MinimumWaterDepth
public float MaximumWaterDepth
public bool AllowWaterVolumes
public bool DoCheck(Placement place)
}
public SolarPanel : IOEntity {
public Transform sunSampler
private int tickrateSeconds
public int maximalPowerOutput
public float dot_minimum
public float dot_maximum
public bool IsRootEntity()
public int MaximalPowerOutput()
public int ConsumptionAmount()
public void ServerInit()
public void SunUpdate()
public int GetPassthroughAmount(int outputSlot)
}
public Sound : MonoBehaviour {
public float volumeExponent
public SoundDefinition definition
public SoundModifier[] modifiers
public SoundSource soundSource
public AudioSource[] audioSources
private SoundFade _fade
private SoundModulation _modulation
private SoundOcclusion _occlusion
public SoundFade fade
public SoundModulation modulation
public SoundOcclusion occlusion
public SoundFade get_fade()
public SoundModulation get_modulation()
public SoundOcclusion get_occlusion()
}
public SoundClass : ScriptableObject {
public AudioMixerGroup output
public AudioMixerGroup firstPersonOutput
public bool enableOcclusion
public bool playIfOccluded
public float occlusionGain
public AudioMixerGroup occludedOutput
public int globalVoiceMaxCount
public int priority
public List`1<SoundDefinition> definitions
}
public SoundClassTest : MonoBehaviour {
public SoundClass soundClass
public float soundInterval
}
public SoundDefinition : ScriptableObject {
public GameObjectRef template
public List`1<WeightedAudioClip> weightedAudioClips
public List`1<DistanceAudioClipList> distanceAudioClips
public SoundClass soundClass
public bool defaultToFirstPerson
public bool loop
public bool randomizeStartPosition
public bool useHighQualityFades
public float volume
public float volumeVariation
public float pitch
public float pitchVariation
public bool dontVoiceLimit
public int globalVoiceMaxCount
public int localVoiceMaxCount
public float localVoiceRange
public float voiceLimitFadeOutTime
public float localVoiceDebounceTime
public bool forceOccludedPlayback
public bool enableDoppler
public float dopplerAmount
public float dopplerScale
public float dopplerAdjustmentRate
public AnimationCurve falloffCurve
public bool useCustomFalloffCurve
public AnimationCurve spatialBlendCurve
public bool useCustomSpatialBlendCurve
public AnimationCurve spreadCurve
public bool useCustomSpreadCurve
public float maxDistance
public float get_maxDistance()
public float GetLength()
public Sound Play()
public Sound Play(GameObject forGameObject)
}
public SoundFade : MonoBehaviour {
public SoundFadeHQAudioFilter hqFadeFilter
public float currentGain
public float startingGain
public float finalGain
public int sampleRate
public bool highQualityFadeCompleted
public float length
public Direction currentDirection
}
public SoundFollowCollider : MonoBehaviour {
public SoundDefinition soundDefinition
public Sound sound
public Bounds soundFollowBounds
public bool startImmediately
}
public SoundManager : SingletonComponent`1<SoundManager> {
public SoundClass defaultSoundClass
}
public SoundModifier : MonoBehaviour {
public Sound sound
}
public SoundModulation : MonoBehaviour {
private int parameterCount
}
public SoundOcclusion : MonoBehaviour {
public LayerMask occlusionLayerMask
}
public SoundPlayer : BaseMonoBehaviour {
public SoundDefinition soundDefinition
public bool playImmediately
public float minStartDelay
public float maxStartDelay
public bool debugRepeat
public bool pending
public Vector3 soundOffset
}
public SoundPlayerCull : MonoBehaviour {
public SoundPlayer soundPlayer
public float cullDistance
}
public SoundRepeater : MonoBehaviour {
public float interval
public SoundPlayer player
}
public SoundSource : MonoBehaviour {
public bool handleOcclusionChecks
public LayerMask occlusionLayerMask
public List`1<OcclusionPoint> occlusionPoints
public bool isOccluded
public float occlusionAmount
public float lodDistance
public bool inRange
public void PreClientComponentCull(IPrefabProcessor p)
public bool IsSyncedToParent()
}
public SoundVoiceLimiter : MonoBehaviour {
public int maxSimultaneousSounds
}
public SpaceCheckingSpawnPoint : GenericSpawnPoint {
private bool useCustomBoundsCheckMask
private LayerMask customBoundsCheckMask
public bool IsAvailableTo(GameObjectRef prefabRef)
}
public Spawnable : MonoBehaviour {
public SpawnPopulation Population
internal UInt32 PrefabID
internal bool SpawnIndividual
internal Vector3 SpawnPosition
internal Quaternion SpawnRotation
protected void OnEnable()
protected void OnDisable()
private void Add()
private void Remove()
internal void Save(SaveInfo info)
internal void Load(LoadInfo info)
protected void OnValidate()
}
public SpawnDistribution : object {
internal SpawnHandler Handler
public float Density
internal int Count
private WorldSpaceGrid`1<int> grid
private Dictionary`2<UInt32, int> dict
private ByteQuadtree quadtree
private Vector3 origin
private Vector3 area
public void .ctor(SpawnHandler handler, Byte[] baseValues, Vector3 origin, Vector3 area)
public bool Sample(Vector3& spawnPos, Quaternion& spawnRot, bool alignToNormal, float dithering)
public bool Sample(Vector3& spawnPos, Quaternion& spawnRot, Element node, bool alignToNormal, float dithering)
public Element SampleNode()
public void AddInstance(Spawnable spawnable)
public void RemoveInstance(Spawnable spawnable)
private void UpdateCount(Spawnable spawnable, int delta)
public int GetCount(UInt32 prefabID)
public int GetCount(Vector3 position)
public float GetGridCellArea()
}
public SpawnFilter : object {
public Enum SplatType
public Enum BiomeType
public Enum TopologyAny
public Enum TopologyAll
public Enum TopologyNot
public bool Test(Vector3 worldPos)
public bool Test(float normX, float normZ)
public float GetFactor(Vector3 worldPos, bool checkPlacementMap)
public float GetFactor(float normX, float normZ, bool checkPlacementMap)
}
public SpawnGroup : BaseMonoBehaviour {
public MonumentTier Tier
public List`1<SpawnEntry> prefabs
public int maxPopulation
public int numToSpawnPerTickMin
public int numToSpawnPerTickMax
public float respawnDelayMin
public float respawnDelayMax
public bool wantsInitialSpawn
public bool temporary
public bool forceInitialSpawn
protected bool fillOnSpawn
public BaseSpawnPoint[] spawnPoints
private List`1<SpawnPointInstance> spawnInstances
public LocalClock spawnClock
public int currentPopulation
public int get_currentPopulation()
public bool WantsInitialSpawn()
public bool WantsTimedSpawn()
public float GetSpawnDelta()
public float GetSpawnVariance()
protected void Awake()
public void Fill()
public void Clear()
public void SpawnInitial()
public void SpawnRepeating()
public void ObjectSpawned(SpawnPointInstance instance)
public void ObjectRetired(SpawnPointInstance instance)
public void DelayedSpawn()
public void Spawn()
protected void Spawn(int numToSpawn)
protected void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
protected GameObjectRef GetPrefab()
protected BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, Vector3& pos, Quaternion& rot)
protected void OnDrawGizmos()
}
public SpawnHandler : SingletonComponent`1<SpawnHandler> {
public float TickInterval
public int MinSpawnsPerTick
public int MaxSpawnsPerTick
public LayerMask PlacementMask
public LayerMask PlacementCheckMask
public float PlacementCheckHeight
public LayerMask RadiusCheckMask
public float RadiusCheckDistance
public LayerMask BoundsCheckMask
public SpawnFilter CharacterSpawn
public float CharacterSpawnCutoff
public SpawnPopulation[] SpawnPopulations
public SpawnDistribution[] SpawnDistributions
internal SpawnDistribution CharDistribution
public List`1<ISpawnGroup> SpawnGroups
internal List`1<SpawnIndividual> SpawnIndividuals
public SpawnPopulation[] ConvarSpawnPopulations
public Dictionary`2<SpawnPopulation, SpawnDistribution> population2distribution
private bool spawnTick
public SpawnPopulation[] AllSpawnPopulations
protected void OnEnable()
public SpawnPoint GetSpawnPoint()
private bool GetSpawnPointStandard(SpawnPoint spawnPoint)
public void UpdateDistributions()
public void FillPopulations()
public void FillGroups()
public void FillIndividuals()
public void InitialSpawn()
public void StartSpawnTick()
private IEnumerator SpawnTick()
private IEnumerator SpawnGroupTick()
private IEnumerator SpawnIndividualTick()
public void SpawnInitial(SpawnPopulation population, SpawnDistribution distribution)
public void SpawnRepeating(SpawnPopulation population, SpawnDistribution distribution)
private void Spawn(SpawnPopulation population, SpawnDistribution distribution, int targetCount, int numToFill, int numToTry)
private GameObject Spawn(SpawnPopulation population, Vector3 pos, Quaternion rot)
private GameObject Spawn(Prefab`1<Spawnable> prefab, Vector3 pos, Quaternion rot)
public bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale)
public bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask mask)
public void EnforceLimits(bool forceAll)
public void EnforceLimits(SpawnPopulation population, SpawnDistribution distribution)
public Spawnable[] FindAll(SpawnPopulation population)
public int GetTargetCount(SpawnPopulation population, SpawnDistribution distribution)
public int GetCurrentCount(SpawnPopulation population, SpawnDistribution distribution)
public void AddRespawn(SpawnIndividual individual)
public void AddInstance(Spawnable spawnable)
public void RemoveInstance(Spawnable spawnable)
public float PlayerFraction()
public float PlayerLerp(float min, float max)
public float PlayerExcess()
public float PlayerScale(float scalar)
public void DumpReport(string filename)
public string GetReport(bool detailed)
}
public SpawnIndividual : ValueType {
public UInt32 PrefabID
public Vector3 Position
public Quaternion Rotation
public void .ctor(UInt32 prefabID, Vector3 position, Quaternion rotation)
}
public SpawnPointInstance : MonoBehaviour {
public ISpawnPointUser parentSpawnPointUser
public BaseSpawnPoint parentSpawnPoint
public void Notify()
protected void OnDestroy()
}
public SpawnPopulation : BaseScriptableObject {
public string ResourceFolder
public GameObjectRef[] ResourceList
public float _targetDensity
public float SpawnRate
public int ClusterSizeMin
public int ClusterSizeMax
public int ClusterDithering
public int SpawnAttemptsInitial
public int SpawnAttemptsRepeating
public bool EnforcePopulationLimits
public bool ScaleWithLargeMaps
public bool ScaleWithSpawnFilter
public bool ScaleWithServerPopulation
public bool AlignToNormal
public SpawnFilter Filter
public float FilterCutoff
public Prefab`1[] Prefabs
public Int32[] numToSpawn
private int sumToSpawn
public float TargetDensity
public float get_TargetDensity()
public bool Initialize()
public void UpdateWeights(SpawnDistribution distribution, int targetCount)
public Prefab`1<Spawnable> GetRandomPrefab()
public float GetCurrentSpawnRate()
public float GetCurrentSpawnDensity()
public float GetMaximumSpawnDensity()
}
public SphereEntity : BaseEntity {
public float currentRadius
public float lerpRadius
public float lerpSpeed
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void LerpRadiusTo(float radius, float speed)
public void UpdateScale()
public void Update()
}
public SpiderWeb : BaseCombatEntity {
public bool Fresh()
public void ServerInit()
}
public SpinnerWheel : Signage {
public Transform wheel
public float velocity
public Quaternion targetRotation
public SoundDefinition spinLoopSoundDef
public SoundDefinition spinStartSoundDef
public SoundDefinition spinAccentSoundDef
public SoundDefinition spinStopSoundDef
public float minTimeBetweenSpinAccentSounds
public float spinAccentAngleDelta
private Sound spinSound
private Modulator spinSoundGain
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool AllowPlayerSpins()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float GetMaxSpinSpeed()
public void Update_Server()
public void Update_Client()
public void Update()
private void RPC_Spin(RPCMessage rpc)
private void RPC_AnyoneSpin(RPCMessage rpc)
public bool AnyoneSpin()
}
public Splitter : IOEntity {
public bool BlockFluidDraining
public bool get_BlockFluidDraining()
}
public SpookySpeaker : BaseCombatEntity {
public SoundPlayer soundPlayer
public float soundSpacing
public float soundSpacingRand
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void PostServerLoad()
public void SetWantsOn(RPCMessage msg)
public void UpdateInvokes()
public void SendPlaySound()
public void DelayedOff()
}
public Sprinkler : IOEntity {
public float SplashFrequency
public Transform Eyes
public int WaterPerSplash
public float DecayPerSplash
private ItemDefinition currentFuelType
private IOEntity currentFuelSource
private HashSet`1<ISplashable> cachedSplashables
private TimeSince updateSplashableCache
private bool forceUpdateSplashables
public bool BlockFluidDraining
public bool get_BlockFluidDraining()
public int ConsumptionAmount()
public void UpdateHasPower(int inputAmount, int inputSlot)
public int CalculateCurrentEnergy(int inputAmount, int inputSlot)
private void DoSplash()
public void SetSprinklerState(bool wantsOn)
public void TurnOn()
public void TurnOff()
public void SetFuelType(ItemDefinition def, IOEntity source)
public void Load(LoadInfo info)
}
public SpriteArcadeEntity : ArcadeEntity {
public SpriteRenderer spriteRenderer
}
public sRGB : object {
public Byte[] to_linear
public Byte[] to_srgb
public float linear_to_srgb(float linear)
public float srgb_to_linear(float srgb)
}
public StabilityEntity : DecayEntity {
public StabilityCheckWorkQueue stabilityCheckQueue
public UpdateSurroundingsQueue updateSurroundingsQueue
public bool grounded
public float cachedStability
public int cachedDistanceFromGround
private List`1<Support> supports
private int stabilityStrikes
private bool dirty
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public void ResetState()
public void InitializeSupports()
public int DistanceFromGround(StabilityEntity ignoreEntity)
public float SupportValue(StabilityEntity ignoreEntity)
public int CachedDistanceFromGround(StabilityEntity ignoreEntity)
public float CachedSupportValue(StabilityEntity ignoreEntity)
public void StabilityCheck()
public void UpdateStability()
public void UpdateSurroundingEntities()
public void UpdateConnectedEntities()
protected void OnPhysicsNeighbourChanged()
protected void DebugNudge()
public void ServerInit()
internal void DoServerDestroy()
}
public StabilitySocket : Socket_Base {
public float support
private void OnDrawGizmosSelected()
public bool TestTarget(Target target)
public bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation)
}
public Stag : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public StagedResourceEntity : ResourceEntity {
public List`1<ResourceStage> stages
public int stage
public GameObjectRef changeStageEffect
public GameObject gibSourceTest
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
protected void OnHealthChanged()
public void UpdateNetworkStage()
private int FindBestStage()
public T GetStageComponent()
private void UpdateStage()
}
public StashContainer : StorageContainer {
public Transform visuals
public float burriedOffset
public float raisedOffset
public GameObjectRef buryEffect
public float uncoverRange
private float lastToggleTime
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool IsHidden()
public bool PlayerInRange(BasePlayer ply)
public void DoOccludedCheck()
public void OnPhysicsNeighbourChanged()
public void SetHidden(bool isHidden)
public void DisableNetworking()
public void Decay()
public void ServerInit()
public void ToggleHidden()
public void RPC_HideStash(RPCMessage rpc)
public void RPC_WantsUnhide(RPCMessage rpc)
}
public StateTimer : ValueType {
public float ReleaseTime
public Action OnFinished
public bool IsActive
public void Activate(float seconds, Action onFinished)
public bool get_IsActive()
}
public StaticInstrument : BaseMountable {
public AnimatorOverrideController AnimatorOverride
public bool ShowDeployAnimation
public InstrumentKeyController KeyController
public bool ShouldSuppressHandsAnimationLayer
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private void Server_PlayNote(RPCMessage msg)
private void Server_StopNote(RPCMessage msg)
public bool IsInstrument()
}
public StaticRespawnArea : SleepingBag {
public Transform[] spawnAreas
public bool allowHostileSpawns
public bool ValidForPlayer(ulong playerID, bool ignoreTimers)
public void GetSpawnPos(Vector3& pos, Quaternion& rot)
public void SetUnlockTime(float newTime)
public float GetUnlockSeconds(ulong playerID)
}
public Stats : Enum {
public int value__
public Stats Steam
public Stats Server
public Stats Life
public Stats All
}
public StatusLightRenderer : MonoBehaviour {
public Material offMaterial
public Material onMaterial
private MaterialPropertyBlock propertyBlock
private Renderer targetRenderer
private Color lightColor
private Light targetLight
private int colorID
private int emissionID
protected void Awake()
public void SetOff()
public void SetOn()
public void SetRed()
public void SetGreen()
private Color GetColor(byte r, byte g, byte b, byte a)
private Color GetColor(byte r, byte g, byte b, byte a, float intensity)
}
public SteamDLCItem : ScriptableObject {
public int id
public Phrase dlcName
public int dlcAppID
public bool bypassLicenseCheck
public bool HasLicense(ulong steamid)
public bool CanUse(BasePlayer player)
}
public SteamFriendsList : MonoBehaviour {
public RectTransform targetPanel
public SteamUserButton userButton
public bool IncludeFriendsList
public bool IncludeRecentlySeen
public bool IncludeLastAttacker
public bool IncludeRecentlyPlayedWith
public onFriendSelectedEvent onFriendSelected
}
public SteamInventory : EntityComponent`1<BasePlayer> {
private IPlayerItem[] Items
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool HasItem(int itemid)
private Task UpdateSteamInventory(RPCMessage msg)
}
public SteamInventoryCategory : ScriptableObject {
public bool canBeSoldToOtherUsers
public bool canBeTradedWithOtherUsers
public bool isCommodity
public Price price
public DropChance dropChance
public bool CanBeInCrates
}
public SteamInventoryItem : ScriptableObject {
public int id
public Sprite icon
public Phrase displayName
public Phrase displayDescription
public Category category
public SubCategory subcategory
public SteamInventoryCategory steamCategory
public bool PreventBreakingDown
public string itemname
public ulong workshopID
public SteamDLCItem DlcItem
public bool forceCraftableItemDesc
public ItemDefinition itemDefinition
public ItemDefinition get_itemDefinition()
public bool HasUnlocked(ulong playerId)
}
public SteamNewsSource : object {
public Story[] Stories
public IEnumerator GetStories()
}
public SteamStatistics : object {
private BasePlayer player
public Dictionary`2<string, int> intStats
private Task refresh
public void .ctor(BasePlayer p)
public void Init()
public void Save()
public void Add(string name, int var)
}
public SteamUserButton : MonoBehaviour {
public RustText steamName
public RustText steamInfo
public RawImage avatar
public Color textColorInGame
public Color textColorOnline
public Color textColorNormal
private ulong <SteamId>k__BackingField
private string <Username>k__BackingField
public ulong SteamId
public string Username
public ulong get_SteamId()
private void set_SteamId(ulong value)
public string get_Username()
private void set_Username(string value)
}
public Stocking : LootContainer {
public ListHashSet`1<Stocking> stockings
public void ServerInit()
internal void DoServerDestroy()
public bool IsEmpty()
public void SpawnLoot()
public void PlayerStoppedLooting(BasePlayer player)
}
public StorageContainer : DecayEntity {
public Phrase LockedMessage
public Phrase InUseMessage
public int inventorySlots
public float dropChance
public bool isLootable
public bool isLockable
public bool isMonitorable
public string panelName
public ContentsType allowedContents
public ItemDefinition allowedItem
public int maxStackSize
public bool needsBuildingPrivilegeToUse
public SoundDefinition openSound
public SoundDefinition closeSound
public Vector3 dropPosition
public Vector3 dropVelocity
public ItemCategory onlyAcceptCategory
public bool onlyOneUser
private ItemContainer <inventory>k__BackingField
public ItemContainer inventory
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public void OnDrawGizmos()
public void MoveAllInventoryItems(ItemContainer source, ItemContainer dest)
public void ReceiveInventoryFromItem(Item item)
public bool CanPickup(BasePlayer player)
public void OnPickedUp(Item createdItem, BasePlayer player)
public ItemContainer get_inventory()
public void set_inventory(ItemContainer value)
public void ServerInit()
public void OnInventoryFirstCreated(ItemContainer container)
public void OnItemAddedOrRemoved(Item item, bool added)
public bool ItemFilter(Item item, int targetSlot)
public void CreateInventory(bool giveUID)
public void PreServerLoad()
protected void OnInventoryDirty()
public void PostServerLoad()
internal void DoServerDestroy()
private void RPC_OpenLoot(RPCMessage rpc)
public string GetPanelName()
public bool CanMoveFrom(BasePlayer player, Item item)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public void AddContainers(PlayerLoot loot)
public bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)
public void PlayerStoppedLooting(BasePlayer player)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public void DropItems(BaseEntity initiator)
public void DropBonusItems(BaseEntity initiator, ItemContainer container)
public Vector3 GetDropPosition()
public Vector3 GetDropVelocity()
public bool ShouldDropItemsIndividually()
public void Load(LoadInfo info)
public bool HasSlot(Slot slot)
public bool OccupiedCheck(BasePlayer player)
}
public StorageMonitor : AppIOEntity {
private Action`2<Item, bool> _onContainerChangedHandler
private Action _resetSwitchHandler
private double _lastPowerOnUpdate
public AppEntityType Type
public bool Value
public AppEntityType get_Type()
public bool get_Value()
public void set_Value(bool value)
internal void FillEntityPayload(AppEntityPayload payload)
public void Init()
public void DestroyShared()
private StorageContainer GetStorageContainer()
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
private void OnContainerChanged(Item item, bool added)
private void ResetSwitch()
}
public StreamEx : object {
private Byte[] StaticBuffer
public void WriteToOtherStream(Stream self, Stream target)
}
public StringFirecracker : TimedExplosive {
public Rigidbody serverRigidBody
public Rigidbody clientMiddleBody
public Rigidbody[] clientParts
public SpringJoint serverClientJoint
public Transform clientFirecrackerTransform
public void InitShared()
public void CreatePinJoint()
}
public StringFormatCache : object {
private Dictionary`2<Key1, string> dict1
private Dictionary`2<Key2, string> dict2
private Dictionary`2<Key3, string> dict3
private Dictionary`2<Key4, string> dict4
public string Get(string format, string value1)
public string Get(string format, string value1, string value2)
public string Get(string format, string value1, string value2, string value3)
public string Get(string format, string value1, string value2, string value3, string value4)
}
public StringPool : object {
public Dictionary`2<UInt32, string> toString
public Dictionary`2<string, UInt32> toNumber
private bool initialized
public UInt32 closest
private void Init()
public string Get(UInt32 i)
public UInt32 Get(string str)
public UInt32 Add(string str)
}
public StripRig : MonoBehaviour {
public Transform root
public bool fromClient
public bool fromServer
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void Strip(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer)
}
public StrobeLight : BaseCombatEntity {
public float frequency
public MeshRenderer lightMesh
public Light strobeLight
private float speedSlow
private float speedMed
private float speedFast
public float burnRate
public float lifeTimeSeconds
public Flags Flag_Slow
public Flags Flag_Med
public Flags Flag_Fast
private int currentSpeed
public float GetFrequency()
public void SetStrobe(RPCMessage msg)
public void SetStrobeSpeed(RPCMessage msg)
public void UpdateSpeedFlags()
public void ServerEnableStrobing(bool wantsOn)
public void SelfDamage()
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public SubsurfaceProfile : ScriptableObject {
private SubsurfaceProfileTexture profileTexture
public SubsurfaceProfileData Data
private int id
public Texture2D Texture
public int Id
public Texture2D get_Texture()
public int get_Id()
private void OnEnable()
private void OnDisable()
public void Update()
}
public SubsurfaceProfileData : ValueType {
public float ScatterRadius
public Color SubsurfaceColor
public Color FalloffColor
public SubsurfaceProfileData Default
public SubsurfaceProfileData Invalid
public SubsurfaceProfileData get_Default()
public SubsurfaceProfileData get_Invalid()
}
public SubsurfaceProfileTexture : object {
public int SUBSURFACE_RADIUS_SCALE
public int SUBSURFACE_KERNEL_SIZE
private List`1<SubsurfaceProfileEntry> entries
private Texture2D texture
public Texture2D Texture
public Texture2D get_Texture()
public int FindEntryIndex(SubsurfaceProfile profile)
public int AddProfile(SubsurfaceProfileData data, SubsurfaceProfile profile)
public void UpdateProfile(int id, SubsurfaceProfileData data)
public void RemoveProfile(int id)
public Color ColorClamp(Color color, float min, float max)
private Texture2D CreateTexture()
private void CheckReleaseTexture()
private void ReleaseTexture()
}
public SubsurfaceScatteringParams : ValueType {
public bool enabled
public Quality quality
public bool halfResolution
public float radiusScale
public SubsurfaceScatteringParams Default
}
public SuicideMenuItem : MonoBehaviour {
public GameObject Button
}
public SunSettings : MonoBehaviour {
private Light light
private void OnEnable()
private void Update()
}
public SupplyDrop : LootContainer {
public GameObjectRef parachutePrefab
public BaseEntity parachute
public void ServerInit()
public void PostServerLoad()
public void RemoveParachute()
public void MakeLootable()
private void OnCollisionEnter(Collision collision)
}
public SupplySignal : TimedExplosive {
public GameObjectRef smokeEffectPrefab
public GameObjectRef EntityToCreate
public GameObject smokeEffect
public void Explode()
public void FinishUp()
}
public SurveyCharge : TimedExplosive {
public GameObjectRef craterPrefab
public GameObjectRef craterPrefab_Oil
public void Explode()
}
public SurveyCrater : BaseCombatEntity {
private ResourceDispenser resourceDispenser
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void OnAttacked(HitInfo info)
public void RemoveMe()
public void AnalysisComplete(RPCMessage msg)
public float BoundsPadding()
}
public SwapArrows : MonoBehaviour {
public GameObject[] arrowModels
private string curAmmoType
private bool wasHidden
public void SelectArrowType(int iType)
public void HideAllArrowHeads()
public void UpdateAmmoType(ItemDefinition ammoType, bool hidden)
private void Cleanup()
public void OnDisable()
public void OnEnable()
}
public SwapKeycard : MonoBehaviour {
public GameObject[] accessLevels
public void UpdateAccessLevel(int level)
public void SetRootActive(int index)
}
public SwapRPG : MonoBehaviour {
public GameObject[] rpgModels
private string curAmmoType
public void SelectRPGType(int iType)
public void UpdateAmmoType(ItemDefinition ammoType)
private void Start()
}
public SynchronizedClock : object {
public List`1<TimedEvent> events
private float CurrentTime
private float get_CurrentTime()
public void Add(float delta, float variance, Action`1<UInt32> action)
public void Tick()
}
public SystemInfoEx : object {
private Boolean[] supportedRenderTextureFormats
public int systemMemoryUsed
private ulong System_GetMemoryUsage()
public int get_systemMemoryUsed()
public bool SupportsRenderTextureFormat(RenderTextureFormat format)
}
public SystemInfoGeneralText : MonoBehaviour {
public TextMeshProUGUI text
public string currentInfo
public string get_currentInfo()
protected void Update()
private long MB(long bytes)
private long MB(ulong bytes)
private int KM2(float meters)
}
public TabToggle : MonoBehaviour {
public Transform TabHolder
public Transform ContentHolder
public bool FadeIn
public bool FadeOut
public void Awake()
public void SwitchTo(Button sourceTab)
private void Hide(GameObject go)
private void Show(GameObject go)
}
public TakeCollisionDamage : FacepunchBehaviour {
private BaseCombatEntity entity
private float minDamage
private float maxDamage
private float forceForAnyDamage
private float forceForMaxDamage
private float velocityRestorePercent
private float pendingDamage
private bool IsServer
private bool IsClient
private bool get_IsServer()
private bool get_IsClient()
protected void OnCollisionEnter(Collision collision)
protected void OnDestroy()
private void DoDamage()
}
public TargetTrigger : TriggerBase {
public Transform losEyes
public GameObject InterestedInObject(GameObject obj)
}
public TeamMemberElement : MonoBehaviour {
public RustText nameText
public RawImage icon
public Color onlineColor
public Color offlineColor
public Color deadColor
public GameObject hoverOverlay
public RawImage memberIcon
public RawImage leaderIcon
public RawImage deadIcon
public int teamIndex
}
public TeamMemberMapMarker : MonoBehaviour {
public RectTransform rectTransform
public Text nameTagText
public Tooltip toolTip
}
public TeamUI : MonoBehaviour {
public Phrase invitePhrase
public RectTransform MemberPanel
public GameObject memberEntryPrefab
public TeamMemberElement[] elements
public GameObject NoTeamPanel
public GameObject TeamPanel
public GameObject LeaveTeamButton
public GameObject InviteAcceptPanel
public TextMeshProUGUI inviteText
public bool dirty
public ulong pendingTeamID
public string pendingTeamLeaderName
}
public TechTreeData : ScriptableObject {
public string shortname
public int nextID
private Dictionary`2<int, NodeInstance> _idToNode
private NodeInstance _entryNode
public List`1<NodeInstance> nodes
public NodeInstance GetByID(int id)
public NodeInstance GetEntryNode()
public void ClearInputs(NodeInstance node)
public void SetupInputs(NodeInstance node)
public bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)
public bool CheckChainRecursive(BasePlayer player, NodeInstance start, NodeInstance target)
public bool PlayerCanUnlock(BasePlayer player, NodeInstance node)
public bool HasPlayerUnlocked(BasePlayer player, NodeInstance node)
}
public TechTreeDialog : UIDialog {
public TechTreeData data
public float graphScale
public TechTreeEntry entryPrefab
public TechTreeGroup groupPrefab
public TechTreeLine linePrefab
public RectTransform contents
public RectTransform contentParent
public TechTreeSelectedNodeUI selectedNodeUI
public float nodeSize
public float gridSize
public GameObjectRef unlockEffect
private Vector2 startPos
public List`1<int> processed
public Dictionary`2<int, TechTreeWidget> widgets
public List`1<TechTreeLine> lines
public ScrollRectZoom zoom
}
public TechTreeEntry : TechTreeWidget {
public RawImage icon
public GameObject ableToUnlockBackground
public GameObject unlockedBackground
public GameObject lockedBackground
public GameObject lockOverlay
public GameObject selectedBackground
}
public TechTreeLine : TechTreeWidget {
public RawImage center
public RawImage topLeft
public RawImage topRight
public RawImage bottomLeft
public RawImage bottomRight
public RawImage centerDotted
public RawImage topLeftDotted
public RawImage topRightDotted
public RawImage bottomLeftDotted
public RawImage bottomRightDotted
public int from
public int to
}
public TechTreeSelectedNodeUI : MonoBehaviour {
public RustText selectedTitle
public RawImage selectedIcon
public RustText selectedDescription
public RustText costText
public RustText craftingCostText
public GameObject costObject
public GameObject cantAffordObject
public GameObject unlockedObject
public GameObject unlockButton
public GameObject noPathObject
public TechTreeDialog dialog
public Color ColorAfford
public Color ColorCantAfford
public ItemInformationPanel[] informationPanels
}
public TechTreeWidget : BaseMonoBehaviour {
public int id
public RectTransform rectTransform
public RectTransform get_rectTransform()
}
public Telephone : ContainerIOEntity {
public int MaxPhoneNameLength
public int MaxSavedNumbers
public Transform PhoneHotspot
public Transform AnsweringMachineHotspot
public Transform[] HandsetRoots
public ItemDefinition[] ValidCassettes
public Transform ParentedHandsetTransform
public LineRenderer CableLineRenderer
public Transform CableStartPoint
public Transform CableEndPoint
public float LineDroopAmount
private Cassette <cachedCassette>k__BackingField
public PhoneController Controller
public Cassette cachedCassette
public BaseEntity ToBaseEntity
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Save(SaveInfo info)
public void ServerInit()
public void PostServerLoad()
internal void DoServerDestroy()
public void ClearCurrentUser(RPCMessage msg)
public void SetCurrentUser(RPCMessage msg)
public void InitiateCall(RPCMessage msg)
public void AnswerPhone(RPCMessage msg)
private void ServerHangUp(RPCMessage msg)
private bool CanAcceptItem(Item item, int targetSlot)
public void DestroyShared()
public void UpdatePhoneName(RPCMessage msg)
public void Server_RequestPhoneDirectory(RPCMessage msg)
public void Server_AddSavedNumber(RPCMessage msg)
public void Server_RemoveSavedNumber(RPCMessage msg)
private void WatchForDisconnects()
public int GetPassthroughAmount(int outputSlot)
public Cassette get_cachedCassette()
private void set_cachedCassette(Cassette value)
public void Load(LoadInfo info)
public bool CanPickup(BasePlayer player)
public BaseEntity get_ToBaseEntity()
public void OnFlagsChanged(Flags old, Flags next)
}
public TelephoneManager : object {
public int MaxPhoneNumber
public int MinPhoneNumber
public int MaxConcurrentCalls
public int MaxCallLength
private Dictionary`2<int, PhoneController> allTelephones
private int maxAssignedPhoneNumber
public int GetUnusedTelephoneNumber()
public void RegisterTelephone(PhoneController t)
public void DeregisterTelephone(PhoneController t)
public PhoneController GetTelephone(int number)
public PhoneController GetRandomTelephone(int ignoreNumber)
public int GetCurrentActiveCalls()
public void GetPhoneDirectory(int ignoreNumber, int page, int perPage, PhoneDirectory directory)
public void PrintAllPhones(Arg arg)
}
public TennisArcadeGame : BaseArcadeGame {
public ArcadeEntity paddle1
public ArcadeEntity paddle2
public ArcadeEntity ball
public Transform paddle1Origin
public Transform paddle2Origin
public Transform paddle1Goal
public Transform paddle2Goal
public Transform ballSpawn
public float maxScore
public ArcadeEntity[] paddle1ScoreNodes
public ArcadeEntity[] paddle2ScoreNodes
public int paddle1Score
public int paddle2Score
public float sensitivity
public ArcadeEntity logo
public bool OnMainMenu
public bool GameActive
}
public TennisBall : SpriteArcadeEntity {
public float speed
public float maxSpeed
}
public TerrainAlphaMap : TerrainMap`1<byte> {
public Texture2D AlphaTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetAlpha(Vector3 worldPos)
public float GetAlpha(float normX, float normZ)
public float GetAlpha(int x, int z)
public void SetAlpha(Vector3 worldPos, float a)
public void SetAlpha(float normX, float normZ, float a)
public void SetAlpha(int x, int z, float a)
public void SetAlpha(int x, int z, float a, float opacity)
public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade)
public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade)
}
public TerrainAnchor : PrefabAttribute {
public float Extents
public float Offset
public void Apply(Single& height, Single& min, Single& max, Vector3 pos, Vector3 scale)
protected Type GetIndexedType()
}
public TerrainAnchorEx : object {
public bool ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors, Vector3& pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
public bool ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors, Vector3& pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter)
public void ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors)
}
public TerrainAnchorGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementPadding
public float PlacementFade
public float PlacementDistance
public float AnchorExtentsMin
public float AnchorExtentsMax
public float AnchorOffsetMin
public float AnchorOffsetMax
}
public TerrainAnchorMode : Enum {
public int value__
public TerrainAnchorMode MinimizeError
public TerrainAnchorMode MinimizeMovement
}
public TerrainAtlasSet : ScriptableObject {
public int SplatCount
public int SplatSize
public int MaxSplatSize
public int SplatPadding
public int AtlasSize
public int RegionSize
public int SplatsPerLine
public int SourceTypeCount
public int AtlasMipCount
public String[] sourceTypeNames
public String[] sourceTypeNamesExt
public String[] sourceTypePostfix
public String[] splatNames
public Boolean[] albedoHighpass
public String[] albedoPaths
public Color[] defaultValues
public SourceMapSet[] sourceMaps
public bool highQualityCompression
public bool generateTextureAtlases
public bool generateTextureArrays
public string splatSearchPrefix
public string splatSearchFolder
public string albedoAtlasSavePath
public string normalAtlasSavePath
public string albedoArraySavePath
public string normalArraySavePath
public void CheckReset()
}
public TerrainBenchmarkScene : BenchmarkScene {
public Terrain terrain
private TerrainMeta terrainMeta
public Transform viewpointA
public Transform viewpointB
}
public TerrainBiomeMap : TerrainMap`1<byte> {
public Texture2D BiomeTexture
internal int num
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetBiomeMax(Vector3 worldPos, int mask)
public float GetBiomeMax(float normX, float normZ, int mask)
public float GetBiomeMax(int x, int z, int mask)
public int GetBiomeMaxIndex(Vector3 worldPos, int mask)
public int GetBiomeMaxIndex(float normX, float normZ, int mask)
public int GetBiomeMaxIndex(int x, int z, int mask)
public int GetBiomeMaxType(Vector3 worldPos, int mask)
public int GetBiomeMaxType(float normX, float normZ, int mask)
public int GetBiomeMaxType(int x, int z, int mask)
public float GetBiome(Vector3 worldPos, int mask)
public float GetBiome(float normX, float normZ, int mask)
public float GetBiome(int x, int z, int mask)
public void SetBiome(Vector3 worldPos, int id)
public void SetBiome(float normX, float normZ, int id)
public void SetBiome(int x, int z, int id)
public void SetBiome(Vector3 worldPos, int id, float v)
public void SetBiome(float normX, float normZ, int id, float v)
public void SetBiome(int x, int z, int id, float v)
public void SetBiomeRaw(int x, int z, Vector4 v, float opacity)
private void SetBiome(int x, int z, int id, float old_val, float new_val)
}
public TerrainBlendMap : TerrainMap`1<byte> {
public Texture2D BlendTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetAlpha(Vector3 worldPos)
public float GetAlpha(float normX, float normZ)
public float GetAlpha(int x, int z)
public void SetAlpha(Vector3 worldPos, float a)
public void SetAlpha(float normX, float normZ, float a)
public void SetAlpha(int x, int z, float a)
public void SetAlpha(int x, int z, float a, float opacity)
public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade)
public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade)
}
public TerrainCarve : TerrainModifier {
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainCheck : PrefabAttribute {
public bool Rotate
public float Extents
public bool Check(Vector3 pos)
protected Type GetIndexedType()
}
public TerrainCheckEx : object {
public bool ApplyTerrainChecks(Transform transform, TerrainCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter)
}
public TerrainCheckGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementPadding
public float PlacementFade
public float PlacementDistance
public float CheckExtentsMin
public float CheckExtentsMax
public bool CheckRotate
}
public TerrainCheckGeneratorVolumes : MonoBehaviour {
public float PlacementRadius
protected void OnDrawGizmosSelected()
}
public TerrainCollision : TerrainExtension {
private ListDictionary`2<Collider, List`1<Collider>> ignoredColliders
private TerrainCollider terrainCollider
public void Setup()
public void Clear()
public void Reset(Collider collider)
public bool GetIgnore(Vector3 pos, float radius)
public bool GetIgnore(RaycastHit hit)
public bool GetIgnore(Collider collider)
public void SetIgnore(Collider collider, Collider trigger, bool ignore)
protected void LateUpdate()
}
public TerrainCollisionProxy : MonoBehaviour {
public WheelCollider[] colliders
}
public TerrainCollisionTrigger : EnvironmentVolumeTrigger {
protected void OnTriggerEnter(Collider other)
protected void OnTriggerExit(Collider other)
private void UpdateCollider(Collider other, bool state)
}
public TerrainColors : TerrainExtension {
private TerrainSplatMap splatMap
private TerrainBiomeMap biomeMap
public void Setup()
public Color GetColor(Vector3 worldPos, int mask)
public Color GetColor(float normX, float normZ, int mask)
}
public TerrainConfig : ScriptableObject {
public bool CastShadows
public LayerMask GroundMask
public LayerMask WaterMask
public PhysicMaterial GenericMaterial
public Material Material
public Material MarginMaterial
public Texture[] AlbedoArrays
public Texture[] NormalArrays
public float HeightMapErrorMin
public float HeightMapErrorMax
public float BaseMapDistanceMin
public float BaseMapDistanceMax
public float ShaderLodMin
public float ShaderLodMax
public SplatType[] Splats
public Texture AlbedoArray
public Texture NormalArray
public Texture get_AlbedoArray()
public Texture get_NormalArray()
public PhysicMaterial[] GetPhysicMaterials()
public Color[] GetAridColors()
public void GetAridOverlayConstants(Color[]& color, Vector4[]& param)
public Color[] GetTemperateColors()
public void GetTemperateOverlayConstants(Color[]& color, Vector4[]& param)
public Color[] GetTundraColors()
public void GetTundraOverlayConstants(Color[]& color, Vector4[]& param)
public Color[] GetArcticColors()
public void GetArcticOverlayConstants(Color[]& color, Vector4[]& param)
public Single[] GetSplatTiling()
public float GetMaxSplatTiling()
public float GetMinSplatTiling()
public Vector3[] GetPackedUVMIX()
}
public TerrainDistanceMap : TerrainMap`1<byte> {
public Texture2D DistanceTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public Vector2i GetDistance(Vector3 worldPos)
public Vector2i GetDistance(float normX, float normZ)
public Vector2i GetDistance(int x, int z)
public void SetDistance(int x, int z, Vector2i v)
}
public TerrainExtension : MonoBehaviour {
public bool isInitialized
internal Terrain terrain
internal TerrainConfig config
public void Init(Terrain terrain, TerrainConfig config)
public void Setup()
public void PostSetup()
public void LogSize(object obj, ulong size)
}
public TerrainFilter : PrefabAttribute {
public SpawnFilter Filter
public bool CheckPlacementMap
protected void OnDrawGizmosSelected()
public bool Check(Vector3 pos)
protected Type GetIndexedType()
}
public TerrainFilterEx : object {
public bool ApplyTerrainFilters(Transform transform, TerrainFilter[] filters, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter globalFilter)
}
public TerrainGenerator : SingletonComponent`1<TerrainGenerator> {
public TerrainConfig config
private float HeightMapRes
private float SplatMapRes
private float BaseMapRes
private int GetHeightMapRes()
private int GetSplatMapRes()
private int GetBaseMapRes()
public GameObject CreateTerrain()
public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)
}
public TerrainHeightAdd : TerrainModifier {
public float Delta
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainHeightMap : TerrainMap`1<short> {
public Texture2D HeightTexture
public Texture2D NormalTexture
private float normY
public void Setup()
public void ApplyToTerrain()
public void GenerateTextures(bool heightTexture, bool normalTexture)
public void ApplyTextures()
public float GetHeight(Vector3 worldPos)
public float GetHeight(float normX, float normZ)
public float GetHeightFast(Vector2 uv)
public float GetHeight(int x, int z)
public float GetHeight01(Vector3 worldPos)
public float GetHeight01(float normX, float normZ)
public float GetTriangulatedHeight01(float normX, float normZ)
public float GetHeight01(int x, int z)
private float GetSrcHeight01(int x, int z)
private float GetDstHeight01(int x, int z)
public Vector3 GetNormal(Vector3 worldPos)
public Vector3 GetNormal(float normX, float normZ)
public Vector3 GetNormal(int x, int z)
private Vector3 GetNormalSobel(int x, int z)
public float GetSlope(Vector3 worldPos)
public float GetSlope(float normX, float normZ)
public float GetSlope(int x, int z)
public float GetSlope01(Vector3 worldPos)
public float GetSlope01(float normX, float normZ)
public float GetSlope01(int x, int z)
public void SetHeight(Vector3 worldPos, float height)
public void SetHeight(float normX, float normZ, float height)
public void SetHeight(int x, int z, float height)
public void SetHeight(Vector3 worldPos, float height, float opacity)
public void SetHeight(float normX, float normZ, float height, float opacity)
public void SetHeight(int x, int z, float height, float opacity)
public void AddHeight(Vector3 worldPos, float delta)
public void AddHeight(float normX, float normZ, float delta)
public void AddHeight(int x, int z, float delta)
public void LowerHeight(Vector3 worldPos, float height, float opacity)
public void LowerHeight(float normX, float normZ, float height, float opacity)
public void LowerHeight(int x, int z, float height, float opacity)
public void RaiseHeight(Vector3 worldPos, float height, float opacity)
public void RaiseHeight(float normX, float normZ, float height, float opacity)
public void RaiseHeight(int x, int z, float height, float opacity)
public void SetHeight(Vector3 worldPos, float opacity, float radius, float fade)
public void SetHeight(float normX, float normZ, float height, float opacity, float radius, float fade)
public void LowerHeight(Vector3 worldPos, float opacity, float radius, float fade)
public void LowerHeight(float normX, float normZ, float height, float opacity, float radius, float fade)
public void RaiseHeight(Vector3 worldPos, float opacity, float radius, float fade)
public void RaiseHeight(float normX, float normZ, float height, float opacity, float radius, float fade)
public void AddHeight(Vector3 worldPos, float delta, float radius, float fade)
public void AddHeight(float normX, float normZ, float delta, float radius, float fade)
}
public TerrainHeightSet : TerrainModifier {
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainMap : TerrainExtension {
internal int res
public void ApplyFilter(float normX, float normZ, float radius, float fade, Action`3<int, int, float> action)
public void ForEach(Vector3 worldPos, float radius, Action`2<int, int> action)
public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Action`2<int, int> action)
public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action)
public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Action`2<int, int> action)
public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action)
private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action, Vector2i min, Vector2i max)
public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action`2<int, int> action)
public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action)
public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action`2<int, int> action)
public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action)
private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action, Vector2i min, Vector2i max)
public void ForEach(int x_min, int x_max, int z_min, int z_max, Action`2<int, int> action)
public void ForEach(Action`2<int, int> action)
public int Index(float normalized)
public float Coordinate(int index)
}
public TerrainMap`1 : TerrainMap {
internal T[] src
internal T[] dst
public void Push()
public void Pop()
public IEnumerable`1<T> ToEnumerable()
public int BytesPerElement()
public long GetMemoryUsage()
public Byte[] ToByteArray()
public void FromByteArray(Byte[] dat)
}
public TerrainMargin : object {
private MaterialPropertyBlock materialPropertyBlock
public void Create()
private void Create(Vector3 position, Vector3 size, Material material)
}
public TerrainMeta : MonoBehaviour {
public Terrain terrain
public TerrainConfig config
public PaintMode paint
public PaintMode currentPaintMode
private TerrainConfig <Config>k__BackingField
private Terrain <Terrain>k__BackingField
private Transform <Transform>k__BackingField
private Vector3 <Position>k__BackingField
private Vector3 <Size>k__BackingField
private Vector3 <OneOverSize>k__BackingField
private Vector3 <HighestPoint>k__BackingField
private Vector3 <LowestPoint>k__BackingField
private float <LootAxisAngle>k__BackingField
private float <BiomeAxisAngle>k__BackingField
private TerrainData <Data>k__BackingField
private TerrainCollider <Collider>k__BackingField
private TerrainCollision <Collision>k__BackingField
private TerrainPhysics <Physics>k__BackingField
private TerrainColors <Colors>k__BackingField
private TerrainQuality <Quality>k__BackingField
private TerrainPath <Path>k__BackingField
private TerrainBiomeMap <BiomeMap>k__BackingField
private TerrainAlphaMap <AlphaMap>k__BackingField
private TerrainBlendMap <BlendMap>k__BackingField
private TerrainHeightMap <HeightMap>k__BackingField
private TerrainSplatMap <SplatMap>k__BackingField
private TerrainTopologyMap <TopologyMap>k__BackingField
private TerrainWaterMap <WaterMap>k__BackingField
private TerrainDistanceMap <DistanceMap>k__BackingField
private TerrainPlacementMap <PlacementMap>k__BackingField
private TerrainTexturing <Texturing>k__BackingField
public TerrainConfig Config
public Terrain Terrain
public Transform Transform
public Vector3 Position
public Vector3 Size
public Vector3 Center
public Vector3 OneOverSize
public Vector3 HighestPoint
public Vector3 LowestPoint
public float LootAxisAngle
public float BiomeAxisAngle
public TerrainData Data
public TerrainCollider Collider
public TerrainCollision Collision
public TerrainPhysics Physics
public TerrainColors Colors
public TerrainQuality Quality
public TerrainPath Path
public TerrainBiomeMap BiomeMap
public TerrainAlphaMap AlphaMap
public TerrainBlendMap BlendMap
public TerrainHeightMap HeightMap
public TerrainSplatMap SplatMap
public TerrainTopologyMap TopologyMap
public TerrainWaterMap WaterMap
public TerrainDistanceMap DistanceMap
public TerrainPlacementMap PlacementMap
public TerrainTexturing Texturing
public TerrainConfig get_Config()
private void set_Config(TerrainConfig value)
public Terrain get_Terrain()
private void set_Terrain(Terrain value)
public Transform get_Transform()
private void set_Transform(Transform value)
public Vector3 get_Position()
private void set_Position(Vector3 value)
public Vector3 get_Size()
private void set_Size(Vector3 value)
public Vector3 get_Center()
public Vector3 get_OneOverSize()
private void set_OneOverSize(Vector3 value)
public Vector3 get_HighestPoint()
public void set_HighestPoint(Vector3 value)
public Vector3 get_LowestPoint()
public void set_LowestPoint(Vector3 value)
public float get_LootAxisAngle()
private void set_LootAxisAngle(float value)
public float get_BiomeAxisAngle()
private void set_BiomeAxisAngle(float value)
public TerrainData get_Data()
private void set_Data(TerrainData value)
public TerrainCollider get_Collider()
private void set_Collider(TerrainCollider value)
public TerrainCollision get_Collision()
private void set_Collision(TerrainCollision value)
public TerrainPhysics get_Physics()
private void set_Physics(TerrainPhysics value)
public TerrainColors get_Colors()
private void set_Colors(TerrainColors value)
public TerrainQuality get_Quality()
private void set_Quality(TerrainQuality value)
public TerrainPath get_Path()
private void set_Path(TerrainPath value)
public TerrainBiomeMap get_BiomeMap()
private void set_BiomeMap(TerrainBiomeMap value)
public TerrainAlphaMap get_AlphaMap()
private void set_AlphaMap(TerrainAlphaMap value)
public TerrainBlendMap get_BlendMap()
private void set_BlendMap(TerrainBlendMap value)
public TerrainHeightMap get_HeightMap()
private void set_HeightMap(TerrainHeightMap value)
public TerrainSplatMap get_SplatMap()
private void set_SplatMap(TerrainSplatMap value)
public TerrainTopologyMap get_TopologyMap()
private void set_TopologyMap(TerrainTopologyMap value)
public TerrainWaterMap get_WaterMap()
private void set_WaterMap(TerrainWaterMap value)
public TerrainDistanceMap get_DistanceMap()
private void set_DistanceMap(TerrainDistanceMap value)
public TerrainPlacementMap get_PlacementMap()
private void set_PlacementMap(TerrainPlacementMap value)
public TerrainTexturing get_Texturing()
private void set_Texturing(TerrainTexturing value)
public bool OutOfBounds(Vector3 worldPos)
public bool OutOfMargin(Vector3 worldPos)
public Vector3 RandomPointOffshore()
public Vector3 Normalize(Vector3 worldPos)
public float NormalizeX(float x)
public float NormalizeY(float y)
public float NormalizeZ(float z)
public Vector3 Denormalize(Vector3 normPos)
public float DenormalizeX(float normX)
public float DenormalizeY(float normY)
public float DenormalizeZ(float normZ)
protected void Awake()
public void Init(Terrain terrainOverride, TerrainConfig configOverride)
public void InitNoTerrain()
public void SetupComponents()
public void PostSetupComponents()
public void BindShaderProperties()
}
public TerrainModifier : PrefabAttribute {
public float Opacity
public float Radius
public float Fade
public void Apply(Vector3 pos, float scale)
protected void Apply(Vector3 position, float opacity, float radius, float fade)
protected Type GetIndexedType()
}
public TerrainModifierEx : object {
public void ApplyTerrainModifiers(Transform transform, TerrainModifier[] modifiers, Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyTerrainModifiers(Transform transform, TerrainModifier[] modifiers)
}
public TerrainPath : TerrainExtension {
public List`1<PathList> Roads
public List`1<PathList> Rivers
public List`1<PathList> Powerlines
internal List`1<LandmarkInfo> Landmarks
public List`1<MonumentInfo> Monuments
public List`1<RiverInfo> RiverObjs
public List`1<LakeInfo> LakeObjs
public List`1<DungeonInfo> DungeonEntrances
public List`1<DungeonCell> DungeonCells
public GameObject DungeonRoot
public List`1<Vector3> OceanPatrolClose
public List`1<Vector3> OceanPatrolFar
public Dictionary`2<string, List`1<PowerlineNode>> wires
public void PostSetup()
public void Clear()
public T FindClosest(List`1<T> list, Vector3 pos)
public Int32[0...,0...] CreatePowerlineCostmap(UInt32& seed)
public Int32[0...,0...] CreateRoadCostmap(UInt32& seed)
public void AddWire(PowerlineNode node)
public void CreateWires()
private void CreateWire(string name, List`1<GameObject> objects, GameObjectRef wirePrefab)
}
public TerrainPathChildObjects : MonoBehaviour {
public bool Spline
public float Width
public float Offset
public float Fade
public Enum Splat
public Enum Topology
public InfrastructureType Type
protected void Awake()
protected void OnDrawGizmos()
}
public TerrainPathConnect : MonoBehaviour {
public InfrastructureType Type
public Point GetPathFinderPoint(int res)
}
public TerrainPhysics : TerrainExtension {
private TerrainSplatMap splat
private PhysicMaterial[] materials
public void Setup()
public PhysicMaterial GetMaterial(Vector3 worldPos)
}
public TerrainPlacement : PrefabAttribute {
public Vector3 size
public Vector3 extents
public Vector3 offset
public bool HeightMap
public bool AlphaMap
public bool WaterMap
public Enum SplatMask
public Enum BiomeMask
public Enum TopologyMask
public Texture2DRef heightmap
public Texture2DRef splatmap0
public Texture2DRef splatmap1
public Texture2DRef alphamap
public Texture2DRef biomemap
public Texture2DRef topologymap
public Texture2DRef watermap
public Texture2DRef blendmap
public void Apply(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected bool ShouldHeight()
protected bool ShouldSplat(int id)
protected bool ShouldAlpha()
protected bool ShouldBiome(int id)
protected bool ShouldTopology(int id)
protected bool ShouldWater()
protected void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
protected Type GetIndexedType()
}
public TerrainPlacementBlocked : TerrainModifier {
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainPlacementEx : object {
public void ApplyTerrainPlacements(Transform transform, TerrainPlacement[] placements, Vector3 pos, Quaternion rot, Vector3 scale)
public void ApplyTerrainPlacements(Transform transform, TerrainPlacement[] placements)
}
public TerrainPlacementMap : TerrainMap`1<bool> {
private bool isEnabled
public void Setup()
public void PostSetup()
public void Enable()
public void Disable()
public void Reset()
public bool GetBlocked(Vector3 worldPos)
public bool GetBlocked(float normX, float normZ)
public bool GetBlocked(int x, int z)
public void SetBlocked(Vector3 worldPos)
public void SetBlocked(float normX, float normZ)
public void SetBlocked(int x, int z)
public bool GetBlocked(Vector3 worldPos, float radius)
public bool GetBlocked(float normX, float normZ, float radius)
public void SetBlocked(Vector3 worldPos, float radius, float fade)
public void SetBlocked(float normX, float normZ, float radius, float fade)
private void <SetBlocked>b__15_0(int x, int z, float lerp)
}
public TerrainSplatMap : TerrainMap`1<byte> {
public Texture2D SplatTexture0
public Texture2D SplatTexture1
internal int num
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetSplatMax(Vector3 worldPos, int mask)
public float GetSplatMax(float normX, float normZ, int mask)
public float GetSplatMax(int x, int z, int mask)
public int GetSplatMaxIndex(Vector3 worldPos, int mask)
public int GetSplatMaxIndex(float normX, float normZ, int mask)
public int GetSplatMaxIndex(int x, int z, int mask)
public int GetSplatMaxType(Vector3 worldPos, int mask)
public int GetSplatMaxType(float normX, float normZ, int mask)
public int GetSplatMaxType(int x, int z, int mask)
public float GetSplat(Vector3 worldPos, int mask)
public float GetSplat(float normX, float normZ, int mask)
public float GetSplat(int x, int z, int mask)
public void SetSplat(Vector3 worldPos, int id)
public void SetSplat(float normX, float normZ, int id)
public void SetSplat(int x, int z, int id)
public void SetSplat(Vector3 worldPos, int id, float v)
public void SetSplat(float normX, float normZ, int id, float v)
public void SetSplat(int x, int z, int id, float v)
public void SetSplatRaw(int x, int z, Vector4 v1, Vector4 v2, float opacity)
public void SetSplat(Vector3 worldPos, int id, float opacity, float radius, float fade)
public void SetSplat(float normX, float normZ, int id, float opacity, float radius, float fade)
public void AddSplat(Vector3 worldPos, int id, float delta, float radius, float fade)
public void AddSplat(float normX, float normZ, int id, float delta, float radius, float fade)
private void SetSplat(int x, int z, int id, float old_val, float new_val)
}
public TerrainSplatSet : TerrainModifier {
public Enum SplatType
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainTexturing : TerrainExtension {
private int ShoreVectorDownscale
private int ShoreVectorBlurPasses
private float terrainSize
private int shoreMapSize
private Single[] shoreDistances
private Vector3[] shoreVectors
public bool debugFoliageDisplacement
private bool initialized
private TerrainTexturing instance
public int ShoreMapSize
public Vector3[] ShoreMap
public TerrainTexturing Instance
private void InitializeBasePyramid()
private void ReleaseBasePyramid()
private void UpdateBasePyramid()
private void InitializeCoarseHeightSlope()
private void ReleaseCoarseHeightSlope()
private void UpdateCoarseHeightSlope()
public int get_ShoreMapSize()
public Vector3[] get_ShoreMap()
private void InitializeShoreVector()
private void GenerateShoreVector()
private void ReleaseShoreVector()
private void GenerateShoreVector(Single[]& distances, Vector3[]& vectors)
public float GetCoarseDistanceToShore(Vector3 pos)
public float GetCoarseDistanceToShore(Vector2 uv)
public Vector3 GetCoarseVectorToShore(Vector3 pos)
public Vector3 GetCoarseVectorToShore(Vector2 uv)
public TerrainTexturing get_Instance()
private void CheckInstance()
private void Awake()
public void Setup()
public void PostSetup()
private void Shutdown()
private void OnEnable()
private void OnDisable()
private void Update()
}
public TerrainTopologyAdd : TerrainModifier {
public Enum TopologyType
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainTopologyMap : TerrainMap`1<int> {
public Texture2D TopologyTexture
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public bool GetTopology(Vector3 worldPos, int mask)
public bool GetTopology(float normX, float normZ, int mask)
public bool GetTopology(int x, int z, int mask)
public int GetTopology(Vector3 worldPos)
public int GetTopology(float normX, float normZ)
public int GetTopologyFast(Vector2 uv)
public int GetTopology(int x, int z)
public void SetTopology(Vector3 worldPos, int mask)
public void SetTopology(float normX, float normZ, int mask)
public void SetTopology(int x, int z, int mask)
public void AddTopology(Vector3 worldPos, int mask)
public void AddTopology(float normX, float normZ, int mask)
public void AddTopology(int x, int z, int mask)
public void RemoveTopology(Vector3 worldPos, int mask)
public void RemoveTopology(float normX, float normZ, int mask)
public void RemoveTopology(int x, int z, int mask)
public int GetTopology(Vector3 worldPos, float radius)
public int GetTopology(float normX, float normZ, float radius)
public void SetTopology(Vector3 worldPos, int mask, float radius, float fade)
public void SetTopology(float normX, float normZ, int mask, float radius, float fade)
public void AddTopology(Vector3 worldPos, int mask, float radius, float fade)
public void AddTopology(float normX, float normZ, int mask, float radius, float fade)
}
public TerrainTopologySet : TerrainModifier {
public Enum TopologyType
protected void Apply(Vector3 position, float opacity, float radius, float fade)
}
public TerrainWaterMap : TerrainMap`1<short> {
public Texture2D WaterTexture
private float normY
public void Setup()
public void GenerateTextures()
public void ApplyTextures()
public float GetHeight(Vector3 worldPos)
public float GetHeight(float normX, float normZ)
public float GetHeightFast(Vector2 uv)
public float GetHeight(int x, int z)
public float GetHeight01(Vector3 worldPos)
public float GetHeight01(float normX, float normZ)
public float GetHeight01(int x, int z)
public Vector3 GetNormal(Vector3 worldPos)
public Vector3 GetNormal(float normX, float normZ)
public Vector3 GetNormalFast(Vector2 uv)
public Vector3 GetNormal(int x, int z)
public float GetSlope(Vector3 worldPos)
public float GetSlope(float normX, float normZ)
public float GetSlope(int x, int z)
public float GetSlope01(Vector3 worldPos)
public float GetSlope01(float normX, float normZ)
public float GetSlope01(int x, int z)
public float GetDepth(Vector3 worldPos)
public float GetDepth(float normX, float normZ)
public void SetHeight(Vector3 worldPos, float height)
public void SetHeight(float normX, float normZ, float height)
public void SetHeight(int x, int z, float height)
}
public TeslaCoil : IOEntity {
public TargetTrigger targetTrigger
public TriggerMovement movementTrigger
public float powerToDamageRatio
public float dischargeTickRate
public float maxDischargeSelfDamageSeconds
public float maxDamageOutput
public Transform damageEyes
public Flags Flag_WeakShorting
public Flags Flag_StrongShorting
public int powerForHeavyShorting
private float lastDischargeTime
public int ConsumptionAmount()
public bool CanDischarge()
public void UpdateFromInput(int inputAmount, int inputSlot)
public void Discharge()
}
public TexasHoldEmPlayerWidget : MonoBehaviour {
private RawImage avatar
private RustText playerName
private RustText scrapTotal
private RustText betTotal
private Image background
private Color inactiveBackground
private Color activeBackground
private Color foldedBackground
private Color winnerBackground
private Animation actionShowAnimation
private RustText actionText
private Sprite dealerChip
private Sprite smallBlindChip
private Sprite bigBlindChip
private Sprite canSeeIcon
private Sprite cannotSeeIcon
private Sprite noChip
private Image chip
private Image[] cardsDisplay
private Phrase allInPhrase
private Phrase foldPhrase
private Phrase raisePhrase
private Phrase betPhrase
private Phrase checkPhrase
private Phrase callPhrase
}
public TexasHoldEmUI : MonoBehaviour {
private Image[] holeCardImages
private Image[] flopCardImages
private RustText potText
private TexasHoldEmPlayerWidget[] playerWidgets
private GameObject raiseRoot
private Phrase phraseNotEnoughBuyIn
private Phrase phraseTooMuchBuyIn
private Phrase phraseYouWinTheRound
private Phrase phraseRoundWinner
private Phrase phraseRoundWinners
private Phrase phraseScrapWon
private Phrase phraseScrapReturned
private Phrase phraseWinningHand
private Phrase phraseRoyalFlush
private Phrase phraseStraightFlush
private Phrase phraseFourOfAKind
private Phrase phraseFullHouse
private Phrase phraseFlush
private Phrase phraseStraight
private Phrase phraseThreeOfAKind
private Phrase phraseTwoPair
private Phrase phrasePair
private Phrase phraseHighCard
}
public TextArcadeEntity : ArcadeEntity {
public TextMeshProUGUI text
}
public TextEntryCookie : MonoBehaviour {
public InputField control
public InputField get_control()
private void OnEnable()
private void OnDisable()
}
internal TextureCacheState : Enum {
public int value__
public TextureCacheState Skipped
public TextureCacheState Initializing
public TextureCacheState Uncached
public TextureCacheState CachedRaw
}
public TextureColorPicker : MonoBehaviour {
public Texture2D texture
public onColorSelectedEvent onColorSelected
public void OnPointerDown(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
}
public TextureData : ValueType {
public int width
public int height
public Color32[] colors
public void .ctor(Texture2D tex)
public Color32 GetColor(int x, int y)
public int GetShort(int x, int y)
public int GetInt(int x, int y)
public float GetFloat(int x, int y)
public float GetHalf(int x, int y)
public Vector4 GetVector(int x, int y)
public Vector3 GetNormal(int x, int y)
public Color32 GetInterpolatedColor(float x, float y)
public int GetInterpolatedInt(float x, float y)
public int GetInterpolatedShort(float x, float y)
public float GetInterpolatedFloat(float x, float y)
public float GetInterpolatedHalf(float x, float y)
public Vector4 GetInterpolatedVector(float x, float y)
public Vector3 GetInterpolatedNormal(float x, float y)
}
public ThrownWeapon : AttackEntity {
public GameObjectRef prefabToThrow
public float maxThrowVelocity
public float tumbleVelocity
public Vector3 overrideAngle
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 GetInheritedVelocity(BasePlayer player)
public void ServerThrow(Vector3 targetPosition)
private float GetThrowVelocity(Vector3 throwPos, Vector3 targetPos, Vector3 aimDir)
private void DoThrow(RPCMessage msg)
private void DoDrop(RPCMessage msg)
protected void SetUpThrownWeapon(BaseEntity ent)
}
public TickHistory : object {
private Deque`1<Vector3> points
public int Count
public int get_Count()
public void Reset()
public void Reset(Vector3 point)
public float Distance(BasePlayer player, Vector3 point)
public void AddPoint(Vector3 point, int limit)
public void TransformEntries(Matrix4x4 matrix)
}
public TickInterpolator : object {
private List`1<Segment> points
private int index
public float Length
public Vector3 CurrentPoint
public Vector3 StartPoint
public Vector3 EndPoint
public void Reset()
public void Reset(Vector3 point)
public void AddPoint(Vector3 point)
public bool MoveNext(float distance)
public bool HasNext()
public void TransformEntries(Matrix4x4 matrix)
}
public TimeBasedSoundSpread : SoundModifier {
public AnimationCurve spreadCurve
public AnimationCurve wanderIntensityCurve
}
public TimeCachedValue`1 : object {
public float refreshCooldown
public float refreshRandomRange
public Func`1<T> updateValue
private T cachedValue
private TimeSince cooldown
private bool hasRun
private bool forceNextRun
public T Get(bool force)
public void ForceNextRun()
}
public TimedExplosive : BaseEntity {
public float timerAmountMin
public float timerAmountMax
public float minExplosionRadius
public float explosionRadius
public bool canStick
public bool onlyDamageParent
public GameObjectRef explosionEffect
public GameObjectRef stickEffect
public GameObjectRef bounceEffect
public bool explosionUsesForward
public bool waterCausesExplosion
public List`1<DamageTypeEntry> damageTypes
private float lastBounceTime
private Nullable`1<CollisionDetectionMode> initialCollisionDetectionMode
public void SetDamageScale(float scale)
public float GetNetworkTime()
public void ServerInit()
public void WaterCheck()
public void SetFuse(float fuseLength)
public float GetRandomTimerTime()
public void ProjectileImpact(RaycastHit info)
public void Explode()
public void OnCollision(Collision collision, BaseEntity hitEntity)
public bool CanStickTo(BaseEntity entity)
private void DoBounceEffect()
private void DoCollisionStick(Collision collision, BaseEntity ent)
public void SetMotionEnabled(bool wantsMotion)
public bool IsStuck()
public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent)
private void UnStick()
internal void OnParentRemoved()
public void SetCollisionEnabled(bool wantsCollision)
}
public TimedRemoval : MonoBehaviour {
public Object objectToDestroy
public float removeDelay
private void OnEnable()
}
public TimedUnlootableCrate : LootContainer {
public bool unlootableOnSpawn
public float unlootableDuration
public void ServerInit()
public void SetUnlootableFor(float duration)
public void MakeLootable()
}
public TimerConfig : UIDialog {
private CustomTimerSwitch timerSwitch
public InputField input
public float minTime
public float seconds
}
public TimerSwitch : IOEntity {
public float timerLength
public Transform timerDrum
private float timePassed
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public bool WantsPassthroughPower()
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int inputSlot)
public void SVSwitch(RPCMessage msg)
public void SwitchPressed()
public void AdvanceTime()
public void EndTimer()
public float GetPassedTime()
public void PostServerLoad()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
}
public TimeSlider : MonoBehaviour {
private Slider slider
private void Start()
private void Update()
public void OnValue(float f)
}
public TimeSpanEx : object {
public string ToShortString(TimeSpan timeSpan)
}
public Timing : ValueType {
private Stopwatch sw
private string name
public Timing Start(string name)
public void End()
public void .ctor(string name)
}
public TinyJSON.DecodeAlias : Attribute {
private String[] <Names>k__BackingField
public String[] Names
public String[] get_Names()
private void set_Names(String[] value)
public void .ctor(String[] names)
public bool Contains(string name)
}
public TinyJSON.DecodeException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public TinyJSON.Decoder : object {
private string whiteSpace
private string wordBreak
private StringReader json
private char PeekChar
private char NextChar
private string NextWord
private Token NextToken
private void .ctor(string jsonString)
public Variant Decode(string jsonString)
public void Dispose()
private ProxyObject DecodeObject()
private ProxyArray DecodeArray()
private Variant DecodeValue()
private Variant DecodeByToken(Token token)
private Variant DecodeString()
private Variant DecodeNumber()
private void ConsumeWhiteSpace()
private char get_PeekChar()
private char get_NextChar()
private string get_NextWord()
private Token get_NextToken()
}
public TinyJSON.EncodeOptions : Enum {
public int value__
public EncodeOptions None
public EncodeOptions PrettyPrint
public EncodeOptions NoTypeHints
public EncodeOptions IncludePublicProperties
public EncodeOptions EnforceHierarchyOrder
public EncodeOptions EnforceHeirarchyOrder
}
public TinyJSON.Encoder : object {
private Type includeAttrType
private Type excludeAttrType
private Type typeHintAttrType
private StringBuilder builder
private EncodeOptions options
private int indent
private bool PrettyPrintEnabled
private bool TypeHintsEnabled
private bool IncludePublicPropertiesEnabled
private bool EnforceHierarchyOrderEnabled
private void .ctor(EncodeOptions options)
public string Encode(object obj)
public string Encode(object obj, EncodeOptions options)
private bool get_PrettyPrintEnabled()
private bool get_TypeHintsEnabled()
private bool get_IncludePublicPropertiesEnabled()
private bool get_EnforceHierarchyOrderEnabled()
private void EncodeValue(object value, bool forceTypeHint)
private IEnumerable`1<FieldInfo> GetFieldsForType(Type type)
private IEnumerable`1<PropertyInfo> GetPropertiesForType(Type type)
private void EncodeObject(object value, bool forceTypeHint)
private void EncodeProxyArray(ProxyArray value)
private void EncodeProxyObject(ProxyObject value)
private void EncodeDictionary(IDictionary value, bool forceTypeHint)
private void EncodeList(IList value, bool forceTypeHint)
private void EncodeArray(Array value, bool forceTypeHint)
private void EncodeArrayRank(Array value, int rank, Int32[] indices, bool forceTypeHint)
private void EncodeString(string value)
private void AppendIndent()
private void AppendOpenBrace()
private void AppendCloseBrace()
private void AppendOpenBracket()
private void AppendCloseBracket()
private void AppendComma(bool firstItem)
private void AppendColon()
}
public TinyJSON.Extensions : object {
public bool AnyOfType(IEnumerable`1<TSource> source, Type expectedType)
}
public TinyJSON.JSON : object {
private Type includeAttrType
private Type excludeAttrType
private Type decodeAliasAttrType
private Dictionary`2<string, Type> typeCache
private BindingFlags instanceBindingFlags
private BindingFlags staticBindingFlags
private MethodInfo decodeTypeMethod
private MethodInfo decodeListMethod
private MethodInfo decodeDictionaryMethod
private MethodInfo decodeArrayMethod
private MethodInfo decodeMultiRankArrayMethod
public Variant Load(string json)
public string Dump(object data)
public string Dump(object data, EncodeOptions options)
public void MakeInto(Variant data, T& item)
private Type FindType(string fullName)
private T DecodeType(Variant data)
private List`1<T> DecodeList(Variant data)
private Dictionary`2<TKey, TValue> DecodeDictionary(Variant data)
private T[] DecodeArray(Variant data)
private void DecodeMultiRankArray(ProxyArray arrayData, Array array, int arrayRank, Int32[] indices)
public void SupportTypeForAOT()
private void SupportValueTypesForAOT()
}
public TinyJSON.ProxyArray : Variant {
private List`1<Variant> list
public Variant Item
public int Count
private IEnumerator`1<Variant> System.Collections.Generic.IEnumerable<TinyJSON.Variant>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(Variant item)
public Variant get_Item(int index)
public void set_Item(int index, Variant value)
public int get_Count()
internal bool CanBeMultiRankArray(Int32[] rankLengths)
private bool CanBeMultiRankArray(int rank, Int32[] rankLengths)
}
public TinyJSON.ProxyBoolean : Variant {
private bool value
public void .ctor(bool value)
public bool ToBoolean(IFormatProvider provider)
public string ToString(IFormatProvider provider)
}
public TinyJSON.ProxyNumber : Variant {
private Char[] floatingPointCharacters
private IConvertible value
public void .ctor(IConvertible value)
private IConvertible Parse(string value)
public bool ToBoolean(IFormatProvider provider)
public byte ToByte(IFormatProvider provider)
public char ToChar(IFormatProvider provider)
public decimal ToDecimal(IFormatProvider provider)
public double ToDouble(IFormatProvider provider)
public short ToInt16(IFormatProvider provider)
public int ToInt32(IFormatProvider provider)
public long ToInt64(IFormatProvider provider)
public sbyte ToSByte(IFormatProvider provider)
public float ToSingle(IFormatProvider provider)
public string ToString(IFormatProvider provider)
public ushort ToUInt16(IFormatProvider provider)
public UInt32 ToUInt32(IFormatProvider provider)
public ulong ToUInt64(IFormatProvider provider)
}
public TinyJSON.ProxyObject : Variant {
public string TypeHintKey
private Dictionary`2<string, Variant> dict
public string TypeHint
public Variant Item
public int Count
public KeyCollection<string, Variant> Keys
public ValueCollection<string, Variant> Values
private IEnumerator`1<KeyValuePair`2<string, Variant>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,TinyJSON.Variant>>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Add(string key, Variant item)
public bool TryGetValue(string key, Variant& item)
public string get_TypeHint()
public Variant get_Item(string key)
public void set_Item(string key, Variant value)
public int get_Count()
public KeyCollection<string, Variant> get_Keys()
public ValueCollection<string, Variant> get_Values()
}
public TinyJSON.ProxyString : Variant {
private string value
public void .ctor(string value)
public string ToString(IFormatProvider provider)
}
public TinyJSON.Variant : object {
protected IFormatProvider FormatProvider
public Variant Item
public Variant Item
public void Make(T& item)
public T Make()
public string ToJSON()
public TypeCode GetTypeCode()
public object ToType(Type conversionType, IFormatProvider provider)
public DateTime ToDateTime(IFormatProvider provider)
public bool ToBoolean(IFormatProvider provider)
public byte ToByte(IFormatProvider provider)
public char ToChar(IFormatProvider provider)
public decimal ToDecimal(IFormatProvider provider)
public double ToDouble(IFormatProvider provider)
public short ToInt16(IFormatProvider provider)
public int ToInt32(IFormatProvider provider)
public long ToInt64(IFormatProvider provider)
public sbyte ToSByte(IFormatProvider provider)
public float ToSingle(IFormatProvider provider)
public string ToString(IFormatProvider provider)
public ushort ToUInt16(IFormatProvider provider)
public UInt32 ToUInt32(IFormatProvider provider)
public ulong ToUInt64(IFormatProvider provider)
public string ToString()
public Variant get_Item(string key)
public void set_Item(string key, Variant value)
public Variant get_Item(int index)
public void set_Item(int index, Variant value)
public bool op_Implicit(Variant variant)
public float op_Implicit(Variant variant)
public double op_Implicit(Variant variant)
public ushort op_Implicit(Variant variant)
public short op_Implicit(Variant variant)
public UInt32 op_Implicit(Variant variant)
public int op_Implicit(Variant variant)
public ulong op_Implicit(Variant variant)
public long op_Implicit(Variant variant)
public decimal op_Implicit(Variant variant)
public string op_Implicit(Variant variant)
public Guid op_Implicit(Variant variant)
}
public ToggleGroupCookie : MonoBehaviour {
public ToggleGroup group
public ToggleGroup get_group()
private void OnEnable()
private void OnDisable()
private void SetupListeners()
private void OnToggleChanged(bool b)
}
public ToggleLayer : MonoBehaviour {
public Toggle toggleControl
public TextMeshProUGUI textControl
public LayerSelect layer
protected void OnEnable()
public void OnToggleChanged()
protected void OnValidate()
}
public ToggleTerrainRenderer : MonoBehaviour {
public Toggle toggleControl
public Text textControl
protected void OnEnable()
public void OnToggleChanged()
protected void OnValidate()
}
public ToggleTerrainTrees : MonoBehaviour {
public Toggle toggleControl
public Text textControl
protected void OnEnable()
public void OnToggleChanged()
protected void OnValidate()
}
public TokenisedPhrase : Phrase {
public string translated
public string get_translated()
public void .ctor(string t, string eng)
public string TranslateMouseButton(string mouseButton)
}
public TonemappingOverlay : ImageEffectLayer {
public TonemappingColorGrading tonemapping
}
public Toolgun : Hammer {
public GameObjectRef attackEffect
public GameObjectRef beamEffect
public GameObjectRef beamImpactEffect
public GameObjectRef errorEffect
public GameObjectRef beamEffectClassic
public GameObjectRef beamImpactEffectClassic
public Transform muzzlePoint
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void DoAttackShared(HitInfo info)
}
public ToolgunBeam : MonoBehaviour {
public LineRenderer electricalBeam
public float scrollSpeed
private Color fadeColor
public float fadeSpeed
public void Update()
}
public ToolgunScreen : MonoBehaviour {
public Text blockInfoText
public Text noBlockText
public void SetScreenText(string newText)
}
public Tooltip : BaseMonoBehaviour {
public GameObject Current
public string Text
public GameObject TooltipObject
public string token
public string english
public string get_english()
}
public TopBunnies : MonoBehaviour {
public BunnyEntry[] topBunnyEntries
public Text timerText
public CanvasGroup group
public Color endingColor
}
public TorchWeapon : BaseMelee {
public float fuelTickAmount
public AnimatorOverrideController LitHoldAnimationOverride
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void GetAttackStats(HitInfo info)
public float GetConditionLoss()
public void SetIsOn(bool isOn)
private void Ignite(RPCMessage msg)
private void Extinguish(RPCMessage msg)
public void UseFuel()
public void OnHeldChanged()
}
public TrainBarricade : BaseCombatEntity {
private float trainDamagePerMPS
private float minVelToDestroy
private float velReduction
private GameObjectRef barricadeDamageEffect
private float <FrontWheelSplineDist>k__BackingField
private BaseTrain hitTrain
private TriggerTrainCollisions hitTrainTrigger
private TrainTrackSpline track
public Vector3 Position
public float FrontWheelSplineDist
public Vector3 get_Position()
public float get_FrontWheelSplineDist()
private void set_FrontWheelSplineDist(float value)
public bool CustomCollision(BaseTrain train, TriggerTrainCollisions trainTrigger)
public void ServerInit()
internal void DoServerDestroy()
private void SetHitTrain(BaseTrain train, TriggerTrainCollisions trainTrigger)
private void ClearHitTrain()
private void DestroyThisBarrier()
private void PushForceTick()
}
public TrainEngine : BaseTrain {
public float buttonHoldTime
public float HAZARD_CHECK_EVERY
public float HAZARD_DIST_MAX
public float HAZARD_DIST_MIN
public float HAZARD_SPEED_MIN
public EngineSpeeds MaxThrottle
public EngineSpeeds MinThrottle
public float decayDuration
public float decayTickSpacing
public float lastDecayTick
public float decayingFor
public EngineDamageOverTime engineDamage
public Vector3 spawnOrigin
public Vector3 engineLocalOffset
public Transform leftHandLever
public Transform rightHandLever
public Transform leftHandGrip
public Transform rightHandGrip
public Canvas monitorConvas
public RustText monitorText
public float engineForce
public float maxSpeed
public float engineStartupTime
public GameObjectRef fuelStoragePrefab
public Transform fuelStoragePoint
public float idleFuelPerSec
public float maxFuelPerSec
public GameObject detailedCabinColliderObj
public TriggerParent platformParentTrigger
public BoxCollider platformParentTriggerCollider
public ProtectionProperties driverProtection
public float wheelRadius
public Transform[] wheelVisuals
public VehicleLight[] lights
public ParticleSystemContainer fxLightDamage
public ParticleSystemContainer fxMediumDamage
public ParticleSystemContainer fxHeavyDamage
private ParticleSystemContainer fxEngineTrouble
public BoxCollider engineWorldCol
public GameObjectRef fxFinalExplosion
public float engineDamageToSlow
public float engineDamageTimeframe
public float engineSlowedTime
public float engineSlowedMaxVel
private TrainEngineAudio trainAudio
public Flags Flag_HazardAhead
public Flags Flag_AltColor
public Flags Flag_EngineSlowed
private EngineSpeeds <CurThrottleSetting>k__BackingField
public VehicleEngineController engineController
public EntityFuelSystem fuelSystem
public ParticleSystemContainer[] sparks
public SoundPlayer brakeSound
public Light[] brakeSparkLights
public bool LightsAreOn
public bool CloseToHazard
public bool EngineIsSlowed
public EngineSpeeds CurThrottleSetting
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void VehicleFixedUpdate()
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public void LightToggle(BasePlayer player)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public void SpawnSubEntities()
public bool CanRunEngines()
public void OnEngineStartFailed()
public void AttemptMount(BasePlayer player, bool doMountChecks)
public float GetEngineForces()
public void Hurt(HitInfo info)
public void IncreaseThrottle()
public void DecreaseThrottle()
public void SetZeroThrottle()
public void ServerFlagsChanged(Flags old, Flags next)
public bool AnyPlayersOnTrain()
public bool AnyPlayersNearby(float maxDist)
public void CheckForHazards()
public void OnEngineTookHeavyDamage()
public void ResetEngineToNormal()
public float GetCurTopSpeed()
public float GetCurEngineForce()
public void DecayTick()
public void RPC_OpenFuel(RPCMessage msg)
public bool get_LightsAreOn()
public bool get_CloseToHazard()
public bool get_EngineIsSlowed()
public EngineSpeeds get_CurThrottleSetting()
public void set_CurThrottleSetting(EngineSpeeds value)
public void InitShared()
public void Load(LoadInfo info)
public void OnFlagsChanged(Flags old, Flags next)
public bool CanBeLooted(BasePlayer player)
public float GetEnginePowerMultiplier(float minPercent)
public float GetThrottleFraction()
public bool IsNearDesiredSpeed(float leeway)
public void SetTrackSelection(TrackSelection trackSelection)
public void SetThrottle(EngineSpeeds throttle)
public int GetFuelAmount()
public bool PlayerIsInParentTrigger(BasePlayer player)
public bool CanMount(BasePlayer player)
private void IEngineControllerUser.Invoke(Action action, float time)
private void IEngineControllerUser.CancelInvoke(Action action)
private bool <PlayerServerInput>g__ProcessThrottleInput|20_0(BUTTON button, Action action, <>c__DisplayClass20_0& )
}
public TrainEngineAudio : MonoBehaviour {
private TrainEngine trainEngine
private Transform cockpitSoundPosition
private SoundDefinition engineStartSound
private SoundDefinition engineStopSound
private SoundDefinition engineStartFailSound
private SoundDefinition engineActiveLoopDef
private AnimationCurve engineActiveLoopPitchCurve
private float engineActiveLoopChangeSpeed
private Sound engineActiveLoop
private Modulator engineActiveLoopPitch
private BlendedLoopEngineSound engineLoops
private EngineReflection[] engineReflections
private LayerMask reflectionLayerMask
private float reflectionMaxDistance
private float reflectionGainChangeSpeed
private float reflectionPositionChangeSpeed
private float reflectionRayOffset
private SoundDefinition lightsToggleSound
private SoundDefinition proximityAlertDef
private Sound proximityAlertSound
private SoundDefinition movementStartDef
private SoundDefinition movementStopDef
private SoundDefinition movementLoopDef
private AnimationCurve movementLoopGainCurve
private float movementChangeOneshotDebounce
private Sound movementLoop
private Modulator movementLoopGain
private SoundDefinition turnLoopDef
private Sound turnLoop
private SoundDefinition trackClatterLoopDef
private AnimationCurve trackClatterGainCurve
private AnimationCurve trackClatterPitchCurve
private Sound trackClatterLoop
private Modulator trackClatterGain
private Modulator trackClatterPitch
private SoundDefinition damagedLoopDef
private Sound damagedLoop
private SoundDefinition changeThrottleDef
}
public TrainLayerRenderer : SingletonComponent`1<TrainLayerRenderer> {
public Camera renderCamera
public Material renderMaterial
public CameraEvent cameraEvent
private bool _hasRendered
public void Render()
public void ForceRender()
private CommandBuffer BuildCommandBuffer()
public TrainLayerRenderer GetOrCreate()
}
public TrainTrackSpline : WorldSpline {
public bool isStation
public bool forceAsSecondary
public List`1<ConnectedTrackInfo> nextTracks
public int straightestNextIndex
public List`1<ConnectedTrackInfo> prevTracks
public int straightestPrevIndex
public HashSet`1<ITrainTrackUser> trackUsers
public bool HasNextTrack
public bool HasPrevTrack
public bool get_HasNextTrack()
public bool get_HasPrevTrack()
public float GetSplineDistAfterMove(float prevSplineDist, Vector3 askerForward, float distMoved, TrackSelection trackSelection, TrainTrackSpline& onSpline, Boolean& atEndOfLine, TrainTrackSpline preferredAltTrack)
public float GetSplineDistAfterMove(float prevSplineDist, float distMoved, TrackSelection trackSelection, bool facingForward, TrainTrackSpline& onSpline, Boolean& atEndOfLine, TrainTrackSpline preferredAltTrack)
public float GetDistance(Vector3 position, float maxError, DistanceType distanceType)
public float GetLength()
public Vector3 GetPosition(float distance)
public void AddTrack(TrainTrackSpline track, TrackPosition p, TrackOrientation o)
public void RegisterTrackUser(ITrainTrackUser user)
public void DeregisterTrackUser(ITrainTrackUser user)
public bool IsForward(Vector3 askerForward, float askerSplineDist)
public bool HasValidHazardWithin(BaseTrain asker, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, TrainTrackSpline preferredAltTrack)
public bool HasValidHazardWithin(ITrainTrackUser asker, Vector3 askerForward, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, bool movingForward, TrainTrackSpline preferredAltTrack)
public bool HasClearTrackSpaceNear(ITrainTrackUser asker)
public bool HasClearTrackSpace(ITrainTrackUser asker)
public Vector3 GetOverallVector(TrackOrientation o)
protected void OnDrawGizmosSelected()
public ConnectedTrackInfo GetTrackSelection(List`1<ConnectedTrackInfo> trackOptions, int straightestIndex, TrackSelection trackSelection, bool nextTrack, bool trainForward, TrainTrackSpline preferredAltTrack)
public bool TryFindTrackNearby(Vector3 pos, float maxDist, TrainTrackSpline& splineResult, Single& distResult)
}
public TransformInterpolator : object {
public List`1<Entry> list
public Entry last
public void Add(Entry tick)
public void Cull(float beforeTime)
public void Clear()
public Segment Query(float time, float interpolation, float extrapolation, float smoothing)
}
public TransformUtil : object {
public bool GetGroundInfo(Vector3 startPos, RaycastHit& hit, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, RaycastHit& hit, float range, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, RaycastHit& hitOut, float range, LayerMask mask, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, float range, Transform ignoreTransform)
public bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, float range, LayerMask mask, Transform ignoreTransform)
public bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal)
public bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal, float range)
public bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal, float range, LayerMask mask)
public Transform[] GetRootObjects()
}
public TrappableWildlife : ScriptableObject {
public GameObjectRef worldObject
public ItemDefinition inventoryObject
public int minToCatch
public int maxToCatch
public List`1<BaitType> baitTypes
public int caloriesForInterest
public float successRate
public float xpScale
}
public TreadAnimator : MonoBehaviour {
public Animator mainBodyAnimator
public Transform[] wheelBones
public Vector3[] vecShocksOffsetPosition
public Vector3[] wheelBoneOrigin
public float wheelBoneDistMax
public Renderer treadRenderer
public Material leftTread
public Material rightTread
public TreadEffects treadEffects
public float traceThickness
public float heightFudge
public bool useWheelYOrigin
public Vector2 treadTextureDirection
public bool isMetallic
}
public TreadEffects : MonoBehaviour {
public ParticleSystem[] rearTreadDirt
public ParticleSystem[] rearTreadSmoke
public ParticleSystem[] middleTreadSmoke
}
public TreeEntity : ResourceEntity {
public bool fallOnKilled
public float fallDuration
public GameObjectRef fallStartSound
public GameObjectRef fallImpactSound
public GameObjectRef fallImpactParticles
public SoundDefinition fallLeavesLoopDef
public Boolean[] usedHeights
public bool impactSoundPlayed
private float treeDistanceUponFalling
public GameObjectRef prefab
public bool hasBonusGame
public GameObjectRef bonusHitEffect
public GameObjectRef bonusHitSound
public Collider serverCollider
public Collider clientCollider
public SoundDefinition smallCrackSoundDef
public SoundDefinition medCrackSoundDef
private float lastAttackDamage
public BaseEntity xMarker
private int currentBonusLevel
private float lastDirection
private float lastHitTime
private int lastHitMarkerIndex
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetState()
public float BoundsPadding()
public void ServerInit()
internal void DoServerDestroy()
public bool DidHitMarker(HitInfo info)
public void StartBonusGame()
public void StopBonusGame()
public bool BonusActive()
public void OnAttacked(HitInfo info)
public void CleanupMarker()
public Collider GetCollider()
public void OnKilled(HitInfo info)
public void DelayedKill()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public TreeLOD : LODComponent {
public State[] States
}
public TreeManager : BaseEntity {
public ListHashSet`1<BaseEntity> entities
public TreeManager server
private int maxTreesPerPacket
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public Vector3 ProtoHalf3ToVec3(Half3 half3)
public Half3 Vec3ToProtoHalf3(Vector3 vec3)
public void ServerInit()
public void OnTreeDestroyed(BaseEntity billboardEntity)
public void OnTreeSpawned(BaseEntity billboardEntity)
private void ExtractTreeNetworkData(BaseEntity billboardEntity, Tree tree)
private void SERVER_RequestTrees(RPCMessage msg)
}
public TreeMarker : BaseEntity {
public GameObjectRef hitEffect
public SoundDefinition hitEffectSound
public GameObjectRef spawnEffect
private Vector3 initialPosition
public bool SpherecastOnInit
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
}
public TreeMarkerData : PrefabAttribute {
public GenerationArc[] GenerationArcs
public MarkerLocation[] Markers
public Vector3 GenerationStartPoint
public float GenerationRadius
public float MaxY
public float MinY
public bool ProcessAngleChecks
protected Type GetIndexedType()
public Vector3 GetNearbyPoint(Vector3 point, Int32& ignoreIndex, Vector3& normal)
}
public TriggerAchievement : TriggerBase {
public string statToIncrease
public string achievementOnEnter
public string requiredVehicleName
public bool serverSide
private List`1<ulong> triggeredPlayers
public void OnPuzzleReset()
public void Reset()
public GameObject InterestedInObject(GameObject obj)
public void OnEntityEnter(BaseEntity ent)
}
public TriggerBanditZone : TriggerBase {
public float GetBanditZoneLevel(Vector3 pos)
}
public TriggerBase : BaseMonoBehaviour {
public LayerMask interestLayers
public HashSet`1<GameObject> contents
public HashSet`1<BaseEntity> entityContents
public bool HasAnyContents
public bool HasAnyEntityContents
public bool get_HasAnyContents()
public bool get_HasAnyEntityContents()
public GameObject InterestedInObject(GameObject obj)
protected void OnDisable()
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
public void OnObjectAdded(GameObject obj, Collider col)
public void OnObjectRemoved(GameObject obj)
public void RemoveInvalidEntities()
public bool CheckEntity(BaseEntity ent)
public void OnObjects()
public void OnEmpty()
public void RemoveObject(GameObject obj)
public void RemoveEntity(BaseEntity ent)
internal bool SkipOnTriggerEnter(Collider collider)
public void OnTriggerEnter(Collider collider)
internal bool SkipOnTriggerExit(Collider collider)
public void OnTriggerExit(Collider collider)
public void OnTriggerExit(GameObject targetObj)
}
public TriggerComfort : TriggerBase {
public float triggerSize
public float baseComfort
public float minComfortRange
private float perPlayerComfortBonus
private float bonusComfort
private List`1<BasePlayer> _players
private void OnValidate()
public GameObject InterestedInObject(GameObject obj)
public float CalculateComfort(Vector3 position, BasePlayer forPlayer)
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
}
public TriggeredEventPrefab : TriggeredEvent {
public GameObjectRef targetPrefab
private void RunEvent()
}
public TriggerEnsnare : TriggerBase {
public bool blockHands
public GameObject InterestedInObject(GameObject obj)
}
public TriggerForce : TriggerBase {
public float GravityMultiplier
public float VelocityLerp
public float AngularDrag
public Vector3 velocity
public GameObject InterestedInObject(GameObject obj)
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
protected void FixedUpdate()
}
public TriggerHurt : TriggerBase {
public float DamagePerSecond
public float DamageTickRate
public DamageType damageType
public GameObject InterestedInObject(GameObject obj)
public void OnObjects()
public void OnEmpty()
private void OnTick()
protected bool CanHurt(BaseCombatEntity ent)
}
public TriggerHurtEx : TriggerBase {
public float repeatRate
public List`1<DamageTypeEntry> damageOnEnter
public GameObjectRef effectOnEnter
public HurtType hurtTypeOnEnter
public List`1<DamageTypeEntry> damageOnTimer
public GameObjectRef effectOnTimer
public HurtType hurtTypeOnTimer
public List`1<DamageTypeEntry> damageOnMove
public GameObjectRef effectOnMove
public HurtType hurtTypeOnMove
public List`1<DamageTypeEntry> damageOnLeave
public GameObjectRef effectOnLeave
public HurtType hurtTypeOnLeave
public bool damageEnabled
internal Dictionary`2<BaseEntity, EntityTriggerInfo> entityInfo
internal List`1<BaseEntity> entityAddList
internal List`1<BaseEntity> entityLeaveList
public GameObject InterestedInObject(GameObject obj)
internal void DoDamage(BaseEntity ent, HurtType type, List`1<DamageTypeEntry> damage, GameObjectRef effect, float multiply)
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
public void OnObjects()
public void OnEmpty()
private void OnTick()
private void ProcessQueues()
}
public TriggerHurtNotChild : TriggerBase {
public float DamagePerSecond
public float DamageTickRate
public float DamageDelay
public DamageType damageType
public bool ignoreNPC
public float npcMultiplier
public float resourceMultiplier
public bool triggerHitImpacts
public bool RequireUpAxis
public BaseEntity SourceEntity
public bool UseSourceEntityDamageMultiplier
public bool ignoreAllVehicleMounted
private Dictionary`2<BaseEntity, float> entryTimes
public GameObject InterestedInObject(GameObject obj)
public void OnObjects()
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
public void OnEmpty()
public void OnDisable()
private bool IsInterested(BaseEntity ent)
private void OnTick()
}
public TriggerLadder : TriggerBase {
public GameObject InterestedInObject(GameObject obj)
}
public TriggerMagnet : TriggerBase {
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerMount : TriggerBase {
private float MOUNT_DELAY
private float MAX_MOVE
private Dictionary`2<BaseEntity, EntryInfo> entryInfo
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
private void CheckForMount()
}
public TriggerMovement : TriggerBase {
public Transform losEyes
public MovementModify movementModify
}
public TriggerNotify : TriggerBase {
public GameObject notifyTarget
private INotifyTrigger toNotify
public bool runClientside
public bool runServerside
public bool HasContents
public bool get_HasContents()
internal void OnObjects()
internal void OnEmpty()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
}
public TriggerParent : TriggerBase {
private bool doClippingCheck
public BaseMountable associatedMountable
public int CLIP_CHECK_MASK
public GameObject InterestedInObject(GameObject obj)
public void OnEntityEnter(BaseEntity ent)
public void OnEntityLeave(BaseEntity ent)
protected bool ShouldParent(BaseEntity ent)
protected void Parent(BaseEntity ent)
protected void Unparent(BaseEntity ent)
private void OnTick()
private bool IsClipping(BaseEntity ent)
}
public TriggerParentEnclosed : TriggerParent {
public float Padding
public TriggerMode intersectionMode
public bool CheckBoundsOnUnparent
private BoxCollider boxCollider
protected void OnEnable()
protected bool ShouldParent(BaseEntity ent)
internal bool SkipOnTriggerExit(Collider collider)
private bool IsInside(BaseEntity ent, float padding)
}
public TriggerParentExclusion : TriggerBase {
public GameObject InterestedInObject(GameObject obj)
}
public TriggerPlayerForce : TriggerBase {
public BoxCollider triggerCollider
public float pushVelocity
public bool requireUpAxis
private float HACK_DISABLE_TIME
internal GameObject InterestedInObject(GameObject obj)
internal void OnObjects()
internal void OnEmpty()
protected void OnDisable()
internal void OnEntityLeave(BaseEntity ent)
private void HackDisableTick()
protected void FixedUpdate()
private Vector3 GetPushVelocity(GameObject obj)
private bool IsInterested(BaseEntity entity)
}
public TriggerPlayerTimer : TriggerBase {
public BaseEntity TargetEntity
public float DamageAmount
public float TimeToDamage
internal GameObject InterestedInObject(GameObject obj)
internal void OnObjects()
internal void OnEmpty()
private void DamageTarget()
}
public TriggerRadiation : TriggerBase {
public RadiationTier radiationTier
public float RadiationAmountOverride
public float falloff
private SphereCollider sphereCollider
private float GetRadiationSize()
public float GetRadiationAmount()
public float GetRadiation(Vector3 position, float radProtection)
public GameObject InterestedInObject(GameObject obj)
public void OnDrawGizmosSelected()
}
public TriggerRagdollRelocate : TriggerBase {
public Transform targetLocation
internal void OnObjectAdded(GameObject obj, Collider col)
private void RepositionTransform(Transform t)
}
public TriggerSafeZone : TriggerBase {
public float maxDepth
public float maxAltitude
internal GameObject InterestedInObject(GameObject obj)
public bool PassesHeightChecks(Vector3 entPos)
public float GetSafeLevel(Vector3 pos)
}
public TriggerTemperature : TriggerBase {
public float Temperature
public float triggerSize
public float minSize
public bool sunlightBlocker
public float sunlightBlockAmount
public float blockMinHour
public float blockMaxHour
private void OnValidate()
public float WorkoutTemperature(Vector3 position, float oldTemperature)
public GameObject InterestedInObject(GameObject obj)
}
public TriggerTrainCollisions : TriggerBase {
public Collider triggerCollider
public ColliderLocation location
public BaseTrain owner
public HashSet`1<GameObject> staticContents
public HashSet`1<BaseTrain> trainContents
public HashSet`1<Rigidbody> otherRigidbodyContents
public HashSet`1<Collider> colliderContents
public bool HasAnyStaticContents
public bool HasAnyTrainContents
public bool HasAnyOtherRigidbodyContents
public bool HasAnyNonStaticContents
public bool get_HasAnyStaticContents()
public bool get_HasAnyTrainContents()
public bool get_HasAnyOtherRigidbodyContents()
public bool get_HasAnyNonStaticContents()
internal void OnObjectAdded(GameObject obj, Collider col)
internal void OnObjectRemoved(GameObject obj)
private bool <OnObjectRemoved>g__HasAnotherColliderFor|17_0(T component)
}
public TriggerVehicleDrag : TriggerBase {
public Transform losEyes
public float vehicleDrag
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerVehiclePush : TriggerBase {
public BaseEntity thisEntity
public float maxPushVelocity
public float minRadius
public float maxRadius
public bool snapToAxis
public Vector3 axisToSnapTo
public bool allowParentRigidbody
public bool useRigidbodyPosition
public bool useCentreOfMass
public int ContentsCount
public GameObject InterestedInObject(GameObject obj)
public int get_ContentsCount()
public void FixedUpdate()
public void OnDrawGizmos()
}
public TriggerWetness : TriggerBase {
public float Wetness
public SphereCollider TargetCollider
public Transform OriginTransform
public bool ApplyLocalHeightCheck
public float MinLocalHeight
public float WorkoutWetness(Vector3 position)
internal GameObject InterestedInObject(GameObject obj)
}
public TriggerWorkbench : TriggerBase {
public Workbench parentBench
public GameObject InterestedInObject(GameObject obj)
public float WorkbenchLevel()
}
public trisPerSubmesh : object {
public Int32[] triangles
}
public TunnelDweller : HumanNPC {
private float maxRoamDist
public float GetMaxRoamDistFromSpawn()
protected string OverrideCorpseName()
}
public TweakUI : SingletonComponent`1<TweakUI> {
public bool isOpen
private void Update()
protected bool CanToggle()
public void SetVisible(bool b)
}
public TweakUIBase : MonoBehaviour {
public string convarName
public bool ApplyImmediatelyOnChange
internal Command conVar
private void Awake()
protected void Init()
public void OnApplyClicked()
public void UnapplyChanges()
public void ResetToConvar()
protected void SetConvarValue()
}
public TweakUIDropdown : TweakUIBase {
public Button Left
public Button Right
public TextMeshProUGUI Current
public Image BackgroundImage
public NameValue[] nameValues
public bool assignImageColor
public int currentValue
protected void Init()
protected void OnEnable()
public void OnValueChanged()
public void ChangeValue(int change)
protected void SetConvarValue()
public void ResetToConvar()
private void ShowValue(string value)
}
public TweakUIMultiSelect : TweakUIBase {
public ToggleGroup toggleGroup
protected void Init()
protected void OnEnable()
public void OnChanged()
private void UpdateToggleGroup()
private void UpdateConVar()
}
public TweakUISlider : TweakUIBase {
public Slider sliderControl
public TextMeshProUGUI textControl
protected void Init()
protected void OnEnable()
public void OnChanged()
protected void SetConvarValue()
public void ResetToConvar()
private void RefreshSliderDisplay(float value)
}
public TweakUIToggle : TweakUIBase {
public Toggle toggleControl
public bool inverse
protected void Init()
protected void OnEnable()
public void OnToggleChanged()
protected void SetConvarValue()
public void ResetToConvar()
}
public TypeThroughButton : Button {
public InputField typingTarget
private Event _processingEvent
public void OnUpdateSelected(BaseEventData eventData)
private IEnumerator DelayedActivateTextField(Event e)
}
public UI_LocalVoice : PriorityListComponent`1<UI_LocalVoice> {
public CanvasGroup voiceCanvas
public CanvasGroup levelImage
}
public UIBackgroundBlur : ListComponent`1<UIBackgroundBlur> {
public float amount
public float currentMax
public float get_currentMax()
}
public UIBelt : SingletonComponent`1<UIBelt> {
public List`1<ItemIcon> ItemIcons
protected void Awake()
public ItemIcon GetItemIconAtSlot(int slot)
}
public UIBlackoutOverlay : MonoBehaviour {
public CanvasGroup group
public Dictionary`2<blackoutType, UIBlackoutOverlay> instances
public blackoutType overlayType
}
public UIBlueprints : ListComponent`1<UIBlueprints> {
public GameObjectRef buttonPrefab
public ScrollRect scrollRect
public CanvasGroup ScrollRectCanvasGroup
public InputField searchField
public GameObject searchFieldPlaceholder
public GameObject listAvailable
public GameObject listLocked
public GameObject Categories
public VerticalLayoutGroup CategoryVerticalLayoutGroup
public BlueprintCategoryButton FavouriteCategoryButton
}
public UIBuffs : SingletonComponent`1<UIBuffs> {
public bool Enabled
public Transform PrefabBuffIcon
public void Refresh(PlayerModifiers modifiers)
private void RemoveAll()
}
public UIBuffsIcon : SingletonComponent`1<UIBuffsIcon> {
public TextMeshProUGUI Text
public Tooltip ToolTip
public CanvasGroup Group
}
public UICameraOverlay : SingletonComponent`1<UICameraOverlay> {
public Phrase FocusOffText
public Phrase FocusAutoText
public Phrase FocusManualText
public CanvasGroup CanvasGroup
public RustText FocusModeLabel
public void Show()
public void Hide()
public void SetFocusMode(CameraFocusMode mode)
}
public UIChat : PriorityListComponent`1<UIChat> {
public GameObject inputArea
public GameObject chatArea
public TMP_InputField inputField
public TextMeshProUGUI channelLabel
public ScrollRect scrollRect
public CanvasGroup canvasGroup
public GameObjectRef chatItemPlayer
public GameObject userPopup
public bool isOpen
}
public UIChatPopup : MonoBehaviour {
public TextMeshProUGUI TextToggleMute
public TextMeshProUGUI TextToggleGlobalMute
public Button MuteButton
public Button ReportButton
public GameObject InviteToTeamButton
}
public UICompass : MonoBehaviour {
public RawImage compassStrip
public CanvasGroup compassGroup
public CompassMapMarker CompassMarker
public CompassMapMarker TeamLeaderCompassMarker
}
public UIConversationScreen : SingletonComponent`1<UIConversationScreen> {
public NeedsCursor needsCursor
public RectTransform conversationPanel
public RustText conversationSpeechBody
public RustText conversationProviderName
public RustButton[] responseButtons
public RectTransform letterBoxTop
public RectTransform letterBoxBottom
protected CanvasGroup canvasGroup
}
public UICrafting : SingletonComponent`1<UICrafting> {
public bool isOpen
public float LastOpened
}
public UIDeathScreen : SingletonComponent`1<UIDeathScreen> {
public LifeInfographic previousLifeInfographic
public Animator screenAnimator
public bool fadeIn
public Button ReportCheatButton
public MapView View
public List`1<SleepingBagButton> sleepingBagButtons
public RespawnColourScheme[] RespawnColourSchemes
public GameObject RespawnScrollGradient
public ScrollRect RespawnScrollRect
public ExpandedLifeStats ExpandedStats
public CanvasGroup StreamerModeContainer
}
public UIDialog : ListComponent`1<UIDialog> {
public SoundDefinition openSoundDef
public SoundDefinition closeSoundDef
public bool isOpen
public bool get_isOpen()
}
public UIEscapeCapture : ListComponent`1<UIEscapeCapture> {
public UnityEvent onEscape
public bool EscapePressed()
}
public UIFadeOut : MonoBehaviour {
public float secondsToFadeOut
public bool destroyOnFaded
public CanvasGroup targetGroup
private float timeStarted
private void Start()
private void Update()
}
public UIFogOverlay : MonoBehaviour {
public UIFogOverlay Instance
public CanvasGroup group
public Color baseColor
public Image overlayImage
}
public UIGene : MonoBehaviour {
public GameObject Child
public Color PositiveColour
public Color NegativeColour
public Color PositiveTextColour
public Color NegativeTextColour
public Image ImageBG
public Text TextGene
public void Init(GrowableGene gene)
public void InitPrevious(GrowableGene gene)
public void Hide()
public void Show()
}
public UIGenesDisplay : MonoBehaviour {
public UIGene[] GeneUI
public Text[] TextLinks
public Text[] TextDiagLinks
public void Init(GrowableGenes genes)
public void InitDualRow(GrowableGenes genes, bool firstRow)
private void InitFirstRow(GrowableGenes genes)
private void InitSecondRow(GrowableGenes genes)
private void ShowDiagLink(int index, float rotation, GrowableGene nextGene)
}
public UIHUD : SingletonComponent`1<UIHUD> {
public UIChat chatPanel
public HudElement Hunger
public HudElement Thirst
public HudElement Health
public HudElement PendingHealth
public HudElement VehicleHealth
public HudElement AnimalStamina
public HudElement AnimalStaminaMax
public RectTransform vitalsRect
public UICompass CompassWidget
public GameObject KeyboardCaptureMode
}
public UIIntegerEntry : MonoBehaviour {
public InputField textEntry
private Action textChanged
public void add_textChanged(Action value)
public void remove_textChanged(Action value)
public void OnAmountTextChanged()
public void SetAmount(int amount)
public int GetIntAmount()
public void PlusMinus(int delta)
}
public UIInventory : SingletonComponent`1<UIInventory> {
public TextMeshProUGUI PlayerName
public bool isOpen
public float LastOpened
public VerticalLayoutGroup rightContents
public GameObject QuickCraft
public Transform InventoryIconContainer
}
public UIMapGenericRadius : MonoBehaviour {
public Image radialImage
public Image outlineImage
public float radius
public CanvasGroup fade
public RectTransform rect
}
public UIMapVendingMachineMarker : MonoBehaviour {
public Color inStock
public Color outOfStock
public Image colorBackground
public string displayName
public Tooltip toolTip
public RustButton button
public bool isInStock
public EntityRef`1<VendingMachine> vendingMachine
public VendingMachine vendingMachineData
private Action`1<UIMapVendingMachineMarker> onClicked
public void add_onClicked(Action`1<UIMapVendingMachineMarker> value)
public void remove_onClicked(Action`1<UIMapVendingMachineMarker> value)
public void SetOutOfStock(bool stock)
public void UpdateInfo(VendingMachine vendingMachineData)
public void Clicked()
public void RemoveAllHandlers()
}
public UIMapVendingMachineMarkerCluster : MonoBehaviour {
public List`1<UIMapVendingMachineMarker> markers
public GameObject OpenRoot
public TextMeshProUGUI CountText
}
public UIMarketTerminal : UIDialog {
public Phrase PendingDeliveryPluralPhrase
public Phrase PendingDeliverySingularPhrase
public Canvas canvas
public MapView mapView
public RectTransform shopDetailsPanel
public float shopDetailsMargin
public float easeDuration
public LeanTweenType easeType
public RustText shopName
public GameObject shopOrderingPanel
public RectTransform sellOrderContainer
public GameObjectRef sellOrderPrefab
public VirtualItemIcon deliveryFeeIcon
public GameObject deliveryFeeCantAffordIndicator
public GameObject inventoryFullIndicator
public GameObject notEligiblePanel
public GameObject pendingDeliveryPanel
public RustText pendingDeliveryLabel
public RectTransform itemNoticesContainer
public GameObjectRef itemRemovedPrefab
public GameObjectRef itemPendingPrefab
public GameObjectRef itemAddedPrefab
public CanvasGroup gettingStartedTip
public SoundDefinition buyItemSoundDef
public SoundDefinition buttonPressSoundDef
}
public UIMixingTableItem : MonoBehaviour {
public Image ItemIcon
public Tooltip ItemTooltip
public RustText TextItemNameAndQuantity
public UIMixingTableItemIngredient[] Ingredients
public void Init(Recipe recipe)
}
public UIMixingTableItemIngredient : MonoBehaviour {
public Image ItemIcon
public Text ItemCount
public Tooltip ToolTip
public void Init(RecipeIngredient ingredient)
public void InitBlank()
}
public UIPaintableImage : MonoBehaviour {
public RawImage image
public int texSize
public Color clearColor
public FilterMode filterMode
public bool mipmaps
public RectTransform rectTransform
public RectTransform get_rectTransform()
}
public UIPaintBox : MonoBehaviour {
public OnBrushChanged onBrushChanged
public Brush brush
public void UpdateBrushSize(int size)
public void UpdateBrushTexture(Texture2D tex)
public void UpdateBrushColor(Color col)
public void UpdateBrushAlpha(float a)
public void UpdateBrushEraser(bool b)
private void OnChanged()
}
public UIParticle : BaseMonoBehaviour {
public Vector2 LifeTime
public Vector2 Gravity
public Vector2 InitialX
public Vector2 InitialY
public Vector2 InitialScale
public Vector2 InitialDelay
public Vector2 ScaleVelocity
public Gradient InitialColor
private float lifetime
private float gravity
private Vector2 velocity
private float scaleVelocity
public void Add(UIParticle particleSource, RectTransform spawnPosition, RectTransform particleCanvas)
private void Start()
private void Update()
private void Die()
}
public uiPlayerPreview : SingletonComponent`1<uiPlayerPreview> {
public Camera previewCamera
public PlayerModel playermodel
public ReflectionProbe reflectionProbe
public SegmentMaskPositioning segmentMask
}
public UIPlayerPreviewControls : SingletonComponent`1<UIPlayerPreviewControls> {
public float RotationSpeed
public float RotationLerpSpeed
public float RotationStopLerpSpeed
}
public UIPrefab : MonoBehaviour {
public GameObject prefabSource
internal GameObject createdGameObject
private void Awake()
public void SetVisible(bool visible)
}
public UIRecordingInfo : SingletonComponent`1<UIRecordingInfo> {
public RustText CountdownText
public Slider TapeProgressSlider
public GameObject CountdownRoot
public GameObject RecordingRoot
public Transform Spinner
public float SpinSpeed
public Image CassetteImage
private void Start()
}
public UIRoot : MonoBehaviour {
private GraphicRaycaster[] graphicRaycasters
public Canvas overlayCanvas
private void ToggleRaycasters(bool state)
protected void Awake()
protected void Start()
protected void Update()
protected void Refresh()
}
public UIRootPixel : UIRoot {
protected void Refresh()
}
public UIRootScaled : UIRoot {
private UIRootScaled Instance
public CanvasScaler scaler
public Canvas DragOverlayCanvas
public Canvas get_DragOverlayCanvas()
protected void Awake()
protected void Refresh()
}
public UIScale : MonoBehaviour {
public CanvasScaler scaler
private void Update()
}
public UIScopeOverlay : MonoBehaviour {
public CanvasGroup group
public UIScopeOverlay instance
public Image scopeImage
}
public UISleepingScreen : SingletonComponent`1<UISleepingScreen> {
protected CanvasGroup canvasGroup
private bool visible
protected void Awake()
public void SetVisible(bool b)
}
public UISound : object {
private AudioSource source
private AudioSource GetAudioSource()
public void Play(AudioClip clip, float volume)
}
public UIUnderlay : SingletonComponent`1<UIUnderlay> {
public GameObject damageDirectional
public GameObject waterDirectional
}
public UIVoiceIcon : MonoBehaviour {
public Text nameText
public RawImage avatar
}
public UIWounded : MonoBehaviour {
public CanvasGroup group
}
public Underwear : ScriptableObject {
public string shortname
public Phrase displayName
public Sprite icon
public Sprite iconFemale
public SkinReplacement[] replacementsMale
public SkinReplacement[] replacementsFemale
public SteamInventoryItem steamItem
public SteamDLCItem steamDLC
public bool adminOnly
public UInt32 GetID()
public bool HasMaleParts()
public bool HasFemaleParts()
public bool ValidForPlayer(BasePlayer player)
public bool IsFemale(BasePlayer player)
public bool Validate(Underwear underwear, BasePlayer player)
}
public UnderwearIcon : MonoBehaviour {
public Image icon
}
public UnderwearManifest : ScriptableObject {
public UnderwearManifest instance
public List`1<Underwear> underwears
public UnderwearManifest Get()
public void PrintManifest()
public Underwear GetUnderwear(UInt32 id)
}
public UnderwearSkinPicker : MonoBehaviour {
public GameObjectRef pickerIcon
public GameObject container
public Action skinChangedEvent
public Sprite defaultNudeIcon
public Sprite defaultIconMale
public Sprite defaultIconFemale
}
public UnityEngine.AniamtorEx : object {
public void SetFloatFixed(Animator animator, int id, float value, float dampTime, float deltaTime)
}
public UnityEngine.ArgEx : object {
public BasePlayer Player(Arg arg)
public BasePlayer GetPlayer(Arg arg, int iArgNum)
public BasePlayer GetSleeper(Arg arg, int iArgNum)
public BasePlayer GetPlayerOrSleeper(Arg arg, int iArgNum)
public BasePlayer GetPlayerOrSleeperOrBot(Arg arg, int iArgNum)
}
public UnityEngine.ColliderEx : object {
public PhysicMaterial GetMaterialAt(Collider obj, Vector3 pos)
public bool IsOnLayer(Collider col, Layer rustLayer)
public bool IsOnLayer(Collider col, int layer)
}
public UnityEngine.CollisionEx : object {
public BaseEntity GetEntity(Collision col)
}
public UnityEngine.ComponentEx : object {
public T Instantiate(T component)
public bool HasComponent(Component component)
}
public UnityEngine.CoroutineEx : object {
public WaitForEndOfFrame waitForEndOfFrame
public WaitForFixedUpdate waitForFixedUpdate
private Dictionary`2<float, WaitForSeconds> waitForSecondsBuffer
public WaitForSeconds waitForSeconds(float seconds)
public WaitForSecondsRealtimeEx waitForSecondsRealtime(float seconds)
}
public UnityEngine.GameObjectEx : object {
public BaseEntity ToBaseEntity(GameObject go)
public BaseEntity ToBaseEntity(Collider collider)
public BaseEntity ToBaseEntity(Transform transform)
public bool IsOnLayer(GameObject go, Layer rustLayer)
public bool IsOnLayer(GameObject go, int layer)
private IEntity GetEntityFromRegistry(Transform transform)
private IEntity GetEntityFromComponent(Transform transform)
public void SetHierarchyGroup(GameObject obj, string strRoot, bool groupActive, bool persistant)
public bool HasComponent(GameObject obj)
public void SetChildComponentsEnabled(GameObject gameObject, bool enabled)
}
public UnityEngine.NetworkPacketEx : object {
public BasePlayer Player(Message v)
}
public UnityEngine.QuaternionEx : object {
public Quaternion AlignToNormal(Quaternion rot, Vector3 normal)
public Quaternion LookRotationWithOffset(Vector3 offset, Vector3 forward, Vector3 up)
public Quaternion LookRotationForcedUp(Vector3 forward, Vector3 up)
public Quaternion LookRotationGradient(Vector3 normal, Vector3 up)
public Quaternion LookRotationNormal(Vector3 normal, Vector3 up)
public Quaternion EnsureValid(Quaternion rot, float epsilon)
}
public UnityEngine.RayEx : object {
public Vector3 ClosestPoint(Ray ray, Vector3 pos)
public float Distance(Ray ray, Vector3 pos)
public float SqrDistance(Ray ray, Vector3 pos)
public bool IsNaNOrInfinity(Ray r)
}
public UnityEngine.SkinnedMeshRendererEx : object {
public Transform FindRig(SkinnedMeshRenderer renderer)
}
public UnityEngine.TransformEx : object {
public string GetRecursiveName(Transform transform, string strEndName)
public void RemoveComponent(Transform transform)
public void RetireAllChildren(Transform transform, GameManager gameManager)
public List`1<Transform> GetChildren(Transform transform)
public void OrderChildren(Transform tx, Func`2<Transform, object> selector)
public List`1<Transform> GetAllChildren(Transform transform)
public void AddAllChildren(Transform transform, List`1<Transform> list)
public Transform[] GetChildrenWithTag(Transform transform, string strTag)
public void Identity(GameObject go)
public GameObject CreateChild(GameObject go)
public GameObject InstantiateChild(GameObject go, GameObject prefab)
public void SetLayerRecursive(GameObject go, int Layer)
public bool DropToGround(Transform transform, bool alignToNormal, float fRange)
public bool GetGroundInfo(Transform transform, Vector3& pos, Vector3& normal, float range)
public bool GetGroundInfoTerrainOnly(Transform transform, Vector3& pos, Vector3& normal, float range)
public Bounds WorkoutRenderBounds(Transform tx)
public List`1<T> GetSiblings(Transform transform, bool includeSelf)
public void DestroyChildren(Transform transform)
public void SetChildrenActive(Transform transform, bool b)
public Transform ActiveChild(Transform transform, string name, bool bDisableOthers)
public T GetComponentInChildrenIncludeDisabled(Transform transform)
public bool HasComponentInChildrenIncludeDisabled(Transform transform)
public void SetHierarchyGroup(Transform transform, string strRoot, bool groupActive, bool persistant)
public Bounds GetBounds(Transform transform, bool includeRenderers, bool includeColliders, bool includeInactive)
}
public UnityEngine.UI.Extensions.BezierPath : object {
public int SegmentsPerCurve
public float MINIMUM_SQR_DISTANCE
public float DIVISION_THRESHOLD
private List`1<Vector2> controlPoints
private int curveCount
public void SetControlPoints(List`1<Vector2> newControlPoints)
public void SetControlPoints(Vector2[] newControlPoints)
public List`1<Vector2> GetControlPoints()
public void Interpolate(List`1<Vector2> segmentPoints, float scale)
public void SamplePoints(List`1<Vector2> sourcePoints, float minSqrDistance, float maxSqrDistance, float scale)
public Vector2 CalculateBezierPoint(int curveIndex, float t)
public List`1<Vector2> GetDrawingPoints0()
public List`1<Vector2> GetDrawingPoints1()
public List`1<Vector2> GetDrawingPoints2()
private List`1<Vector2> FindDrawingPoints(int curveIndex)
private int FindDrawingPoints(int curveIndex, float t0, float t1, List`1<Vector2> pointList, int insertionIndex)
private Vector2 CalculateBezierPoint(float t, Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3)
}
public UnityEngine.UI.Extensions.CableCurve : object {
private Vector2 m_start
private Vector2 m_end
private float m_slack
private int m_steps
private bool m_regen
private Vector2[] emptyCurve
private Vector2[] points
public bool regenPoints
public Vector2 start
public Vector2 end
public float slack
public int steps
public Vector2 midPoint
public bool get_regenPoints()
public void set_regenPoints(bool value)
public Vector2 get_start()
public void set_start(Vector2 value)
public Vector2 get_end()
public void set_end(Vector2 value)
public float get_slack()
public void set_slack(float value)
public int get_steps()
public void set_steps(int value)
public Vector2 get_midPoint()
public void .ctor(Vector2[] inputPoints)
public void .ctor(List`1<Vector2> inputPoints)
public void .ctor(CableCurve v)
public Vector2[] Points()
}
public UnityEngine.UI.Extensions.DiamondGraph : UIPrimitiveBase {
private float m_a
private float m_b
private float m_c
private float m_d
public float A
public float B
public float C
public float D
public float get_A()
public void set_A(float value)
public float get_B()
public void set_B(float value)
public float get_C()
public void set_C(float value)
public float get_D()
public void set_D(float value)
protected void OnPopulateMesh(VertexHelper vh)
}
public UnityEngine.UI.Extensions.ResolutionMode : Enum {
public int value__
public ResolutionMode None
public ResolutionMode PerSegment
public ResolutionMode PerLine
}
internal UnityEngine.UI.Extensions.SetPropertyUtility : object {
public bool SetColor(Color& currentValue, Color newValue)
public bool SetEquatableStruct(T& currentValue, T newValue)
public bool SetStruct(T& currentValue, T newValue)
public bool SetClass(T& currentValue, T newValue)
}
public UnityEngine.UI.Extensions.UICircle : UIPrimitiveBase {
public bool ArcInvert
public float Arc
public int ArcSteps
public int ArcRotation
public float Progress
private float _progress
public Color ProgressColor
public bool Fill
public float Thickness
public int Padding
private List`1<int> indices
private List`1<UIVertex> vertices
private Vector2 uvCenter
protected void OnPopulateMesh(VertexHelper vh)
public void SetProgress(float progress)
public void SetArcSteps(int steps)
public void SetInvertArc(bool invert)
public void SetArcRotation(int rotation)
public void SetFill(bool fill)
public void SetBaseColor(Color color)
public void UpdateBaseAlpha(float value)
public void SetProgressColor(Color color)
public void UpdateProgressAlpha(float value)
public void SetPadding(int padding)
public void SetThickness(int thickness)
}
public UnityEngine.UI.Extensions.UICornerCut : UIPrimitiveBase {
public Vector2 cornerSize
private bool m_cutUL
private bool m_cutUR
private bool m_cutLL
private bool m_cutLR
private bool m_makeColumns
private bool m_useColorUp
private Color32 m_colorUp
private bool m_useColorDown
private Color32 m_colorDown
public bool CutUL
public bool CutUR
public bool CutLL
public bool CutLR
public bool MakeColumns
public bool UseColorUp
public Color32 ColorUp
public bool UseColorDown
public Color32 ColorDown
public bool get_CutUL()
public void set_CutUL(bool value)
public bool get_CutUR()
public void set_CutUR(bool value)
public bool get_CutLL()
public void set_CutLL(bool value)
public bool get_CutLR()
public void set_CutLR(bool value)
public bool get_MakeColumns()
public void set_MakeColumns(bool value)
public bool get_UseColorUp()
public void set_UseColorUp(bool value)
public Color32 get_ColorUp()
public void set_ColorUp(Color32 value)
public bool get_UseColorDown()
public void set_UseColorDown(bool value)
public Color32 get_ColorDown()
public void set_ColorDown(Color32 value)
protected void OnPopulateMesh(VertexHelper vh)
private void AddSquare(Rect rect, Rect rectUV, Color32 color32, VertexHelper vh)
private void AddSquare(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Rect rectUV, Color32 color32, VertexHelper vh)
private int AddVert(float x, float y, Rect area, Color32 color32, VertexHelper vh)
}
public UnityEngine.UI.Extensions.UIGoldenRatioRenderer : UILineRenderer {
private List`1<Vector2> _points
private List`1<Rect> _rects
private int canvasWidth
private int canvasHeight
public float lineThickness2
private void DrawSpiral(VertexHelper vh)
private void DrawPhiRectangles(VertexHelper vh, List`1<Vector2> points, float x, float y, float width, float height, Orientations orientation)
protected void OnPopulateMesh(VertexHelper vh)
private void DrawRect(VertexHelper vh, Rect rect)
}
public UnityEngine.UI.Extensions.UIGridRenderer : UILineRenderer {
private int m_GridColumns
private int m_GridRows
public int GridColumns
public int GridRows
public int get_GridColumns()
public void set_GridColumns(int value)
public int get_GridRows()
public void set_GridRows(int value)
protected void OnPopulateMesh(VertexHelper vh)
}
public UnityEngine.UI.Extensions.UILineRenderer : UIPrimitiveBase {
private float MIN_MITER_JOIN
private float MIN_BEVEL_NICE_JOIN
private Vector2 UV_TOP_LEFT
private Vector2 UV_BOTTOM_LEFT
private Vector2 UV_TOP_CENTER_LEFT
private Vector2 UV_TOP_CENTER_RIGHT
private Vector2 UV_BOTTOM_CENTER_LEFT
private Vector2 UV_BOTTOM_CENTER_RIGHT
private Vector2 UV_TOP_RIGHT
private Vector2 UV_BOTTOM_RIGHT
private Vector2[] startUvs
private Vector2[] middleUvs
private Vector2[] endUvs
private Vector2[] fullUvs
internal Vector2[] m_points
internal List`1<Vector2[]> m_segments
internal float lineThickness
internal bool relativeSize
internal bool lineList
internal bool lineCaps
internal int bezierSegmentsPerCurve
public JoinType LineJoins
public BezierType BezierMode
public bool drivenExternally
public float LineThickness
public bool RelativeSize
public bool LineList
public bool LineCaps
public int BezierSegmentsPerCurve
public Vector2[] Points
public List`1<Vector2[]> Segments
public float get_LineThickness()
public void set_LineThickness(float value)
public bool get_RelativeSize()
public void set_RelativeSize(bool value)
public bool get_LineList()
public void set_LineList(bool value)
public bool get_LineCaps()
public void set_LineCaps(bool value)
public int get_BezierSegmentsPerCurve()
public void set_BezierSegmentsPerCurve(int value)
public Vector2[] get_Points()
public void set_Points(Vector2[] value)
public List`1<Vector2[]> get_Segments()
public void set_Segments(List`1<Vector2[]> value)
private void PopulateMesh(VertexHelper vh, Vector2[] pointsToDraw)
protected void OnPopulateMesh(VertexHelper vh)
private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type)
private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type, UIVertex[] previousVert)
protected void GeneratedUVs()
protected void ResolutionToNativeSize(float distance)
private int GetSegmentPointCount()
public Vector2 GetPosition(int index, int segmentIndex)
public Vector2 GetPositionBySegment(int index, int segment)
public Vector2 GetClosestPoint(Vector2 p1, Vector2 p2, Vector2 p3)
}
public UnityEngine.UI.Extensions.UILineRendererList : UIPrimitiveBase {
private float MIN_MITER_JOIN
private float MIN_BEVEL_NICE_JOIN
private Vector2 UV_TOP_LEFT
private Vector2 UV_BOTTOM_LEFT
private Vector2 UV_TOP_CENTER_LEFT
private Vector2 UV_TOP_CENTER_RIGHT
private Vector2 UV_BOTTOM_CENTER_LEFT
private Vector2 UV_BOTTOM_CENTER_RIGHT
private Vector2 UV_TOP_RIGHT
private Vector2 UV_BOTTOM_RIGHT
private Vector2[] startUvs
private Vector2[] middleUvs
private Vector2[] endUvs
private Vector2[] fullUvs
internal List`1<Vector2> m_points
internal float lineThickness
internal bool relativeSize
internal bool lineList
internal bool lineCaps
internal int bezierSegmentsPerCurve
public JoinType LineJoins
public BezierType BezierMode
public bool drivenExternally
public float LineThickness
public bool RelativeSize
public bool LineList
public bool LineCaps
public int BezierSegmentsPerCurve
public List`1<Vector2> Points
public float get_LineThickness()
public void set_LineThickness(float value)
public bool get_RelativeSize()
public void set_RelativeSize(bool value)
public bool get_LineList()
public void set_LineList(bool value)
public bool get_LineCaps()
public void set_LineCaps(bool value)
public int get_BezierSegmentsPerCurve()
public void set_BezierSegmentsPerCurve(int value)
public List`1<Vector2> get_Points()
public void set_Points(List`1<Vector2> value)
public void AddPoint(Vector2 pointToAdd)
public void RemovePoint(Vector2 pointToRemove)
public void ClearPoints()
private void PopulateMesh(VertexHelper vh, List`1<Vector2> pointsToDraw)
protected void OnPopulateMesh(VertexHelper vh)
private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type)
private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type)
protected void GeneratedUVs()
protected void ResolutionToNativeSize(float distance)
}
public UnityEngine.UI.Extensions.UILineTextureRenderer : UIPrimitiveBase {
private Rect m_UVRect
private Vector2[] m_points
public float LineThickness
public bool UseMargins
public Vector2 Margin
public bool relativeSize
public Rect uvRect
public Vector2[] Points
public Rect get_uvRect()
public void set_uvRect(Rect value)
public Vector2[] get_Points()
public void set_Points(Vector2[] value)
protected void OnPopulateMesh(VertexHelper vh)
public Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Vector3 angles)
}
public UnityEngine.UI.Extensions.UIPolygon : UIPrimitiveBase {
public bool fill
public float thickness
public int sides
public float rotation
public Single[] VerticesDistances
private float size
public void DrawPolygon(int _sides)
public void DrawPolygon(int _sides, Single[] _VerticesDistances)
public void DrawPolygon(int _sides, Single[] _VerticesDistances, float _rotation)
private void Update()
protected void OnPopulateMesh(VertexHelper vh)
}
public UnityEngine.UI.Extensions.UIPrimitiveBase : MaskableGraphic {
protected Material s_ETC1DefaultUI
private List`1<Vector2> outputList
private Sprite m_Sprite
private Sprite m_OverrideSprite
internal float m_EventAlphaThreshold
private ResolutionMode m_improveResolution
protected float m_Resolution
private bool m_useNativeSize
public Sprite sprite
public Sprite overrideSprite
protected Sprite activeSprite
public float eventAlphaThreshold
public ResolutionMode ImproveResolution
public float Resoloution
public bool UseNativeSize
public Material defaultETC1GraphicMaterial
public Texture mainTexture
public bool hasBorder
public float pixelsPerUnit
public Material material
public float minWidth
public float preferredWidth
public float flexibleWidth
public float minHeight
public float preferredHeight
public float flexibleHeight
public int layoutPriority
public Sprite get_sprite()
public void set_sprite(Sprite value)
public Sprite get_overrideSprite()
public void set_overrideSprite(Sprite value)
protected Sprite get_activeSprite()
public float get_eventAlphaThreshold()
public void set_eventAlphaThreshold(float value)
public ResolutionMode get_ImproveResolution()
public void set_ImproveResolution(ResolutionMode value)
public float get_Resoloution()
public void set_Resoloution(float value)
public bool get_UseNativeSize()
public void set_UseNativeSize(bool value)
public Material get_defaultETC1GraphicMaterial()
public Texture get_mainTexture()
public bool get_hasBorder()
public float get_pixelsPerUnit()
public Material get_material()
public void set_material(Material value)
protected UIVertex[] SetVbo(Vector2[] vertices, Vector2[] uvs)
protected Vector2[] IncreaseResolution(Vector2[] input)
protected List`1<Vector2> IncreaseResolution(List`1<Vector2> input)
protected void GeneratedUVs()
protected void ResolutionToNativeSize(float distance)
public void CalculateLayoutInputHorizontal()
public void CalculateLayoutInputVertical()
public float get_minWidth()
public float get_preferredWidth()
public float get_flexibleWidth()
public float get_minHeight()
public float get_preferredHeight()
public float get_flexibleHeight()
public int get_layoutPriority()
public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
private Vector2 MapCoordinate(Vector2 local, Rect rect)
private Vector4 GetAdjustedBorders(Vector4 border, Rect rect)
protected void OnEnable()
}
public UnityEngine.UI.ScrollRectEx : UIBehaviour {
public InputButton scrollButton
public InputButton altScrollButton
private RectTransform m_Content
private bool m_Horizontal
private bool m_Vertical
private MovementType m_MovementType
private float m_Elasticity
private bool m_Inertia
private float m_DecelerationRate
private float m_ScrollSensitivity
private RectTransform m_Viewport
private Scrollbar m_HorizontalScrollbar
private Scrollbar m_VerticalScrollbar
private ScrollbarVisibility m_HorizontalScrollbarVisibility
private ScrollbarVisibility m_VerticalScrollbarVisibility
private float m_HorizontalScrollbarSpacing
private float m_VerticalScrollbarSpacing
private ScrollRectEvent m_OnValueChanged
private Vector2 m_PointerStartLocalCursor
private Vector2 m_ContentStartPosition
private RectTransform m_ViewRect
private Bounds m_ContentBounds
private Bounds m_ViewBounds
private Vector2 m_Velocity
private bool m_Dragging
private Vector2 m_PrevPosition
private Bounds m_PrevContentBounds
private Bounds m_PrevViewBounds
private bool m_HasRebuiltLayout
private bool m_HSliderExpand
private bool m_VSliderExpand
private float m_HSliderHeight
private float m_VSliderWidth
private RectTransform m_Rect
private RectTransform m_HorizontalScrollbarRect
private RectTransform m_VerticalScrollbarRect
private DrivenRectTransformTracker m_Tracker
private Vector3[] m_Corners
public RectTransform content
public bool horizontal
public bool vertical
public MovementType movementType
public float elasticity
public bool inertia
public float decelerationRate
public float scrollSensitivity
public RectTransform viewport
public Scrollbar horizontalScrollbar
public Scrollbar verticalScrollbar
public ScrollbarVisibility horizontalScrollbarVisibility
public ScrollbarVisibility verticalScrollbarVisibility
public float horizontalScrollbarSpacing
public float verticalScrollbarSpacing
public ScrollRectEvent onValueChanged
protected RectTransform viewRect
public Vector2 velocity
private RectTransform rectTransform
public Vector2 normalizedPosition
public float horizontalNormalizedPosition
public float verticalNormalizedPosition
private bool hScrollingNeeded
private bool vScrollingNeeded
public RectTransform get_content()
public void set_content(RectTransform value)
public bool get_horizontal()
public void set_horizontal(bool value)
public bool get_vertical()
public void set_vertical(bool value)
public MovementType get_movementType()
public void set_movementType(MovementType value)
public float get_elasticity()
public void set_elasticity(float value)
public bool get_inertia()
public void set_inertia(bool value)
public float get_decelerationRate()
public void set_decelerationRate(float value)
public float get_scrollSensitivity()
public void set_scrollSensitivity(float value)
public RectTransform get_viewport()
public void set_viewport(RectTransform value)
public Scrollbar get_horizontalScrollbar()
public void set_horizontalScrollbar(Scrollbar value)
public Scrollbar get_verticalScrollbar()
public void set_verticalScrollbar(Scrollbar value)
public ScrollbarVisibility get_horizontalScrollbarVisibility()
public void set_horizontalScrollbarVisibility(ScrollbarVisibility value)
public ScrollbarVisibility get_verticalScrollbarVisibility()
public void set_verticalScrollbarVisibility(ScrollbarVisibility value)
public float get_horizontalScrollbarSpacing()
public void set_horizontalScrollbarSpacing(float value)
public float get_verticalScrollbarSpacing()
public void set_verticalScrollbarSpacing(float value)
public ScrollRectEvent get_onValueChanged()
public void set_onValueChanged(ScrollRectEvent value)
protected RectTransform get_viewRect()
public Vector2 get_velocity()
public void set_velocity(Vector2 value)
private RectTransform get_rectTransform()
public void Rebuild(CanvasUpdate executing)
private void UpdateCachedData()
protected void OnEnable()
protected void OnDisable()
public bool IsActive()
private void EnsureLayoutHasRebuilt()
public void StopMovement()
public void OnScroll(PointerEventData data)
public void OnInitializePotentialDrag(PointerEventData eventData)
public void OnBeginDrag(PointerEventData eventData)
public void OnEndDrag(PointerEventData eventData)
public void OnDrag(PointerEventData eventData)
protected void SetContentAnchoredPosition(Vector2 position)
protected void LateUpdate()
private void UpdatePrevData()
private void UpdateScrollbars(Vector2 offset)
public Vector2 get_normalizedPosition()
public void set_normalizedPosition(Vector2 value)
public float get_horizontalNormalizedPosition()
public void set_horizontalNormalizedPosition(float value)
public float get_verticalNormalizedPosition()
public void set_verticalNormalizedPosition(float value)
private void SetHorizontalNormalizedPosition(float value)
private void SetVerticalNormalizedPosition(float value)
private void SetNormalizedPosition(float value, int axis)
private float RubberDelta(float overStretching, float viewSize)
protected void OnRectTransformDimensionsChange()
private bool get_hScrollingNeeded()
private bool get_vScrollingNeeded()
public void SetLayoutHorizontal()
public void SetLayoutVertical()
private void UpdateScrollbarVisibility()
private void UpdateScrollbarLayout()
private void UpdateBounds()
private Bounds GetBounds()
private Vector2 CalculateOffset(Vector2 delta)
protected void SetDirty()
protected void SetDirtyCaching()
public void CenterOnPosition(Vector2 pos)
public void LayoutComplete()
public void GraphicUpdateComplete()
private Transform UnityEngine.UI.ICanvasElement.get_transform()
}
public UnityEngine.UIEx : object {
public Vector2 Unpivot(RectTransform rect, Vector2 localPos)
public void CenterOnPosition(ScrollRect scrollrect, Vector2 pos)
public void RebuildHackUnity2019(Image image)
}
public UnityStandardAssets.CinematicEffects.ImageEffectHelper : object {
public bool supportsDX11
public bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
public Material CheckShaderAndCreateMaterial(Shader s)
public bool get_supportsDX11()
}
public UnityStandardAssets.CinematicEffects.MinAttribute : PropertyAttribute {
public float min
public void .ctor(float min)
}
public UnityStandardAssets.CinematicEffects.RenderTextureUtility : object {
private List`1<RenderTexture> m_TemporaryRTs
public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer, RenderTextureFormat format, FilterMode filterMode)
public void ReleaseTemporaryRenderTexture(RenderTexture rt)
public void ReleaseAllTemporaryRenderTextures()
}
public UnityStandardAssets.CinematicEffects.TonemappingColorGrading : MonoBehaviour {
private EyeAdaptationSettings m_EyeAdaptation
private TonemappingSettings m_Tonemapping
private ColorGradingSettings m_ColorGrading
private LUTSettings m_Lut
private Shader m_Shader
}
public UnityStandardAssets.ImageEffects.ScopeEffect : PostEffectsBase {
public Material overlayMaterial
public bool CheckResources()
public bool IsActive()
public void OnRenderImage(RenderTexture source, RenderTexture destination)
}
public UnparentOnDestroy : MonoBehaviour {
public float destroyAfterSeconds
public void OnParentDestroying()
protected void OnValidate()
}
public UnreadMessages : SingletonComponent`1<UnreadMessages> {
public StyleAsset AllRead
public StyleAsset Unread
public RustButton Button
public GameObject UnreadTextObject
public RustText UnreadText
public GameObject MessageList
public GameObject MessageListContainer
public GameObject MessageListEmpty
}
public Upkeep : PrefabAttribute {
public float upkeepMultiplier
protected Type GetIndexedType()
}
public UserPersistance : object {
public Database blueprints
public Database deaths
private Database identities
private Database tokens
private Database playerState
private Dictionary`2<ulong, string> nameCache
private MruDictionary`2<ulong, int> tokenCache
public void .ctor(string strFolder)
public void Dispose()
public PersistantPlayer GetPlayerInfo(ulong playerID)
private PersistantPlayer FetchFromDatabase(ulong playerID)
public void SetPlayerInfo(ulong playerID, PersistantPlayer info)
public void AddLifeStory(ulong playerID, PlayerLifeStory lifeStory)
public PlayerLifeStory GetLastLifeStory(ulong playerID)
public string GetPlayerName(ulong playerID)
public void SetPlayerName(ulong playerID, string name)
public int GetOrGenerateAppToken(ulong playerID)
public Byte[] GetPlayerState(ulong playerID)
public void SetPlayerState(ulong playerID, Byte[] state)
public void ResetPlayerState(ulong playerID)
}
internal UVTextureAnimator : MonoBehaviour {
public int Rows
public int Columns
public float Fps
public int OffsetMat
public bool IsLoop
public float StartDelay
private bool isInizialised
private int index
private int count
private int allCount
private float deltaFps
private bool isVisible
private bool isCorutineStarted
private Renderer currentRenderer
private Material instanceMaterial
private void Start()
private void InitDefaultVariables()
private void Play()
private void PlayDelay()
private void OnEnable()
private void OnDisable()
private IEnumerator UpdateCorutine()
private void UpdateCorutineFrame()
private void OnDestroy()
}
public v_chainsaw : MonoBehaviour {
public bool bAttacking
public bool bHitMetal
public bool bHitWood
public bool bHitFlesh
public bool bEngineOn
public ParticleSystem[] hitMetalFX
public ParticleSystem[] hitWoodFX
public ParticleSystem[] hitFleshFX
public SoundDefinition hitMetalSoundDef
public SoundDefinition hitWoodSoundDef
public SoundDefinition hitFleshSoundDef
public Sound hitSound
public GameObject hitSoundTarget
public float hitSoundFadeTime
public ParticleSystem smokeEffect
public Animator chainsawAnimator
public Renderer chainRenderer
public Material chainlink
private MaterialPropertyBlock block
private Vector2 saveST
private float chainSpeed
private float chainAmount
public float temp1
public float temp2
public void OnEnable()
private void Awake()
private void Start()
private void ScrollChainTexture()
private void Update()
private void DoHitSound(SoundDefinition soundDef)
}
public ValidBounds : SingletonComponent`1<ValidBounds> {
public Bounds worldBounds
public bool Test(Vector3 vPos)
private void OnDrawGizmosSelected()
internal bool IsInside(Vector3 vPos)
}
public VehicleEditingItemIcon : MonoBehaviour {
private Image foregroundImage
private Image linkImage
}
public VehicleEditingPanel : LootPanel {
private float disabledAlpha
private CanvasGroup editGroup
private GameObject moduleInternalItemsGroup
private GameObject moduleInternalLiquidsGroup
private GameObject destroyChassisGroup
private Button itemTakeButton
private Button liquidTakeButton
private GameObject liquidHelp
private GameObject liquidButton
private Color gotColor
private Color notGotColor
private Text generalInfoText
private Text generalWarningText
private Image generalWarningImage
private Text repairInfoText
private Button repairButton
private Text destroyChassisButtonText
private Text destroyChassisCountdown
private Phrase phraseEditingInfo
private Phrase phraseNoOccupant
private Phrase phraseBadOccupant
private Phrase phraseNotDriveable
private Phrase phraseNotRepairable
private Phrase phraseRepairNotNeeded
private Phrase phraseRepairSelectInfo
private Phrase phraseRepairEnactInfo
private Phrase phraseHasLock
private Phrase phraseHasNoLock
private Phrase phraseAddLock
private Phrase phraseAddKey
private Phrase phraseAddLockButton
private Phrase phraseCraftKeyButton
private Text carLockInfoText
private Text carLockButtonText
private Button actionLockButton
private Button removeLockButton
private Phrase phraseEmptyStorage
private CreateChassisEntry[] chassisOptions
}
public VehicleEngineController : object {
public IEngineControllerUser owner
private bool isServer
public float engineStartupTime
public Flags engineStartingFlag
public EngineState CurEngineState
public bool IsOn
public bool IsOff
public bool IsStarting
public EngineState get_CurEngineState()
public bool get_IsOn()
public bool get_IsOff()
public bool get_IsStarting()
public void .ctor(IEngineControllerUser owner, bool isServer, float engineStartupTime, Flags engineStartingFlag)
public void TryStartEngine(BasePlayer player)
public void FinishStartingEngine()
public void StopEngine()
public void CancelEngineStart()
}
public VehicleLiftOccupantTrigger : TriggerBase {
private ModularCar <carOccupant>k__BackingField
public ModularCar carOccupant
public ModularCar get_carOccupant()
private void set_carOccupant(ModularCar value)
protected void OnDisable()
internal GameObject InterestedInObject(GameObject obj)
internal void OnEntityEnter(BaseEntity ent)
internal void OnEntityLeave(BaseEntity ent)
}
public VehicleLight : MonoBehaviour {
public bool IsBrake
public GameObject toggleObject
public Renderer lightRenderer
public int lightRendererMaterialIndex
public Color lightOnColour
public Color brakesOnColour
private MaterialPropertyBlock materialPB
private int emissionColorID
public void SetLightVisuals(IReadOnlyList`1<VehicleLight> lights, bool headlightsOn, bool brakesOn)
}
public VehicleModuleButtonComponent : MonoBehaviour {
public string interactionColliderName
public SoundDefinition pressSoundDef
public void ServerUse(BasePlayer player, BaseVehicleModule parentModule)
}
public VehicleModuleEngine : VehicleModuleStorage {
public Engine engine
private bool <IsUsable>k__BackingField
private float <PerformanceFractionAcceleration>k__BackingField
private float <PerformanceFractionTopSpeed>k__BackingField
private float <PerformanceFractionFuelEconomy>k__BackingField
private float <OverallPerformanceFraction>k__BackingField
private float FORCE_MULTIPLIER
private float HEALTH_PERFORMANCE_FRACTION
private float LOW_PERFORMANCE_THRESHOLD
private Sound badPerformanceLoop
private Modulator badPerformancePitchModulator
private float prevSmokePercent
private float MIN_FORCE_BIAS
private float MAX_FORCE_BIAS
public bool HasAnEngine
public bool IsUsable
public float PerformanceFractionAcceleration
public float PerformanceFractionTopSpeed
public float PerformanceFractionFuelEconomy
public float OverallPerformanceFraction
public bool AtLowPerformance
public int KW
public EngineAudioSet AudioSet
private bool EngineIsOn
public bool get_HasAnEngine()
public bool get_IsUsable()
public void set_IsUsable(bool value)
public float get_PerformanceFractionAcceleration()
public void set_PerformanceFractionAcceleration(float value)
public float get_PerformanceFractionTopSpeed()
public void set_PerformanceFractionTopSpeed(float value)
public float get_PerformanceFractionFuelEconomy()
public void set_PerformanceFractionFuelEconomy(float value)
public float get_OverallPerformanceFraction()
public void set_OverallPerformanceFraction(float value)
public bool get_AtLowPerformance()
public int get_KW()
public EngineAudioSet get_AudioSet()
private bool get_EngineIsOn()
public void InitShared()
public void OnEngineStateChanged(EngineState oldState, EngineState newState)
public float GetMaxDriveForce()
public void RefreshPerformanceStats(EngineStorage engineStorage)
public float GetPerformanceFraction(float statBoostPercent)
public void Load(LoadInfo info)
public void VehicleFixedUpdate(bool vehicleIsActive)
public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
public void Hurt(HitInfo info)
public void OnHealthChanged(float oldValue, float newValue)
public void AdminFixUp(int tier)
private float BiasedLerp(float x, float bias)
private float Bias(float x, float bias)
}
public VehicleModuleInformationPanel : ItemInformationPanel {
public ItemStatValue socketsDisplay
public ItemStatValue hpDisplay
}
public VehicleModuleSeating : BaseVehicleModule {
private ProtectionProperties passengerProtection
private Seating seating
private Vector3 steerAngle
private Vector3 accelAngle
private Vector3 brakeAngle
private Vector3 speedometerAngle
private Vector3 fuelAngle
private SoundDefinition hornLoop
private SoundDefinition hornStart
private Flags FLAG_HORN
private MountPointInfo[] adjustedMountPoints
private float steerPercent
private float throttlePercent
private float brakePercent
private Nullable`1<bool> checkEngineLightOn
private Nullable`1<bool> fuelLightOn
private ModularCar <Car>k__BackingField
protected IVehicleLockUser VehicleLockUser
private MaterialPropertyBlock dashboardLightPB
private int emissionColorID
private BasePlayer hornPlayer
public bool HasSeating
protected ModularCar Car
protected bool IsOnACar
protected bool IsOnAVehicleLockUser
public bool DoorsAreLockable
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_HasSeating()
protected ModularCar get_Car()
private void set_Car(ModularCar value)
protected bool get_IsOnACar()
protected bool get_IsOnAVehicleLockUser()
public bool get_DoorsAreLockable()
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public bool IsOnThisModule(BasePlayer player)
public bool HasADriverSeat()
public void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
public void ModuleRemoved()
public bool PlayerCanDestroyLock(BasePlayer player)
public void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
public void PlayerServerInput(InputState inputState, BasePlayer player)
public void OnPlayerDismountedVehicle(BasePlayer player)
protected bool ModuleHasMountPoint(MountPointInfo mountPointInfo)
public void RPC_DestroyLock(RPCMessage msg)
}
public VehicleModuleStorage : VehicleModuleSeating {
private Storage storage
private EntityRef storageUnitInstance
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public IItemContainerEntity GetContainer()
public void Load(LoadInfo info)
public bool CanBeLooted(BasePlayer player)
public void Spawn()
public void PostServerLoad()
private void OnItemAddedRemoved(Item item, bool add)
public void NonUserSpawn()
internal void DoServerDestroy()
public void Save(SaveInfo info)
public void CreateStorageEntity()
public void DestroyStorageEntity()
public void RPC_Open(RPCMessage msg)
protected bool CanBeMovedNowOnVehicle()
}
public VehicleModuleTaxi : VehicleModuleStorage {
private SoundDefinition kickButtonSound
private SphereCollider kickButtonCollider
private float maxKickVelocity
private Vector3 KickButtonPos
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
private Vector3 get_KickButtonPos()
private bool CanKickPassengers(BasePlayer player)
public void RPC_KickPassengers(RPCMessage msg)
private void KickPassengers()
}
public VehicleSpawner : BaseEntity {
public float spawnNudgeRadius
public float cleanupRadius
public float occupyRadius
public SpawnPair[] objectsToSpawn
public Transform spawnOffset
public float safeRadius
public int GetOccupyLayer()
public BaseVehicle GetVehicleOccupying()
public bool IsPadOccupied()
public void OnEntityMessage(BaseEntity from, string msg)
public BaseVehicle SpawnVehicle(string prefabToSpawn, BasePlayer newOwner)
public void CleanupArea(float radius)
public void NudgePlayersInRadius(float radius)
}
public VehicleTerrainHandler : object {
public string CurGroundPhysicsMatName
public Surface OnSurface
public bool IsGrounded
public float RayLength
private String[] TerrainRoad
private float SECONDS_BETWEEN_TERRAIN_SAMPLE
private TimeSince timeSinceTerrainCheck
private BaseVehicle vehicle
public bool IsOnSnowOrIce
public bool get_IsOnSnowOrIce()
public void .ctor(BaseVehicle vehicle)
public void FixedUpdate()
private void DoTerrainCheck()
private bool GetOnRoad(string physicMat)
}
public VehicleVendor : NPCTalking {
public EntityRef spawnerRef
public VehicleSpawner vehicleSpawner
public string GetConversationStartSpeech()
public VehicleSpawner GetVehicleSpawner()
public void UpdateFlags()
public void ServerInit()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public ConversationData GetConversationFor(BasePlayer player)
}
public VendingMachine : StorageContainer {
public Phrase WaitForVendingMessage
public GameObjectRef adminMenuPrefab
public string customerPanel
public SellOrderContainer sellOrders
public SoundPlayer buySound
public string shopName
public GameObjectRef mapMarkerPrefab
public ItemDefinition blueprintBaseDef
private Action fullUpdateCached
protected BasePlayer vend_Player
private int vend_sellOrderID
private int vend_numberOfTransactions
public bool transactionActive
private VendingMachineMapMarker myMarker
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void Load(LoadInfo info)
public void Save(SaveInfo info)
public void ServerInit()
public void DestroyShared()
public void OnItemAddedOrRemoved(Item item, bool added)
public void FullUpdate()
protected void OnInventoryDirty()
public void RefreshSellOrderStockLevel(ItemDefinition itemDef)
public bool OutOfStock()
public void PostServerLoad()
public void UpdateEmptyFlag()
public void PlayerStoppedLooting(BasePlayer player)
public void InstallDefaultSellOrders()
public bool HasVendingSounds()
public float GetBuyDuration()
public void SetPendingOrder(BasePlayer buyer, int sellOrderId, int numberOfTransactions)
public void ClearPendingOrder()
public void BuyItem(RPCMessage rpc)
public void CompletePendingOrder()
public void TransactionStart(RPCMessage rpc)
private void GetItemsToSell(SellOrder sellOrder, List`1<Item> items)
public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer, Action`2<BasePlayer, Item> onCurrencyRemoved, Action`2<BasePlayer, Item> onItemPurchased)
public void TakeCurrencyItem(Item takenCurrencyItem)
public void GiveSoldItem(Item soldItem, BasePlayer buyer)
public void SendSellOrders(BasePlayer player)
public void RPC_Broadcast(RPCMessage msg)
public void RPC_UpdateShopName(RPCMessage msg)
public void UpdateMapMarker()
public void RPC_OpenShop(RPCMessage msg)
public void RPC_OpenAdmin(RPCMessage msg)
public bool CanAcceptItem(Item item, int targetSlot)
public bool CanMoveFrom(BasePlayer player, Item item)
public bool CanOpenLootPanel(BasePlayer player, string panelName)
public void RPC_DeleteSellOrder(RPCMessage msg)
public void RPC_RotateVM(RPCMessage msg)
public void RPC_AddSellOrder(RPCMessage msg)
public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
public void RefreshAndSendNetworkUpdate()
public void UpdateOrCreateSalesSheet()
protected bool CanRotate()
public bool IsBroadcasting()
public bool IsInventoryEmpty()
public bool IsVending()
public bool PlayerBehind(BasePlayer player)
public bool PlayerInfront(BasePlayer player)
public bool CanPlayerAdmin(BasePlayer player)
}
public VendingMachineMapMarker : MapMarker {
public string markerShopName
public VendingMachine server_vendingMachine
public VendingMachine client_vendingMachine
public UInt32 client_vendingMachineNetworkID
public GameObjectRef clusterMarkerObj
public void Save(SaveInfo info)
public AppMarker GetAppMarkerData()
}
public VendingMachineScreen : MonoBehaviour {
public RawImage largeIcon
public RawImage blueprintIcon
public Text mainText
public Text lowerText
public Text centerText
public RawImage smallIcon
public VendingMachine vendingMachine
public Sprite outOfStockSprite
public Renderer fadeoutMesh
public CanvasGroup screenCanvas
public Renderer light1
public Renderer light2
public float nextImageTime
public int currentImageIndex
}
public VendingPanelAdmin : UIDialog {
public GameObject sellOrderAdminContainer
public GameObject sellOrderAdminPrefab
public InputField storeNameInputField
}
public VertexColorAnimator : MonoBehaviour {
public List`1<MeshHolder> animationMeshes
public List`1<float> animationKeyframes
public float timeScale
public int mode
private float elapsedTime
public void initLists()
public void addMesh(Mesh mesh, float atPosition)
private void Start()
public void replaceKeyframe(int frameIndex, Mesh mesh)
public void deleteKeyframe(int frameIndex)
public void scrobble(float scrobblePos)
private void Update()
}
public VertexColorStream : MonoBehaviour {
public Mesh originalMesh
public Mesh paintedMesh
public MeshHolder meshHold
public Vector3[] _vertices
public Vector3[] _normals
public Int32[] _triangles
public Int32[][] _Subtriangles
public Matrix4x4[] _bindPoses
public BoneWeight[] _boneWeights
public Bounds _bounds
public int _subMeshCount
public Vector4[] _tangents
public Vector2[] _uv
public Vector2[] _uv2
public Vector2[] _uv3
public Color[] _colors
public Vector2[] _uv4
private void OnDidApplyAnimationProperties()
public void init(Mesh origMesh, bool destroyOld)
public void setWholeMesh(Mesh tmpMesh)
public Vector3[] setVertices(Vector3[] _deformedVertices)
public Vector3[] getVertices()
public Vector3[] getNormals()
public Int32[] getTriangles()
public void setTangents(Vector4[] _meshTangents)
public Vector4[] getTangents()
public void setColors(Color[] _vertexColors)
public Color[] getColors()
public Vector2[] getUVs()
public void setUV4s(Vector2[] _uv4s)
public Vector2[] getUV4s()
public void unlink()
public void rebuild()
private void Start()
}
public ViewModel : MonoBehaviour {
public GameObjectRef viewModelPrefab
}
public ViewmodelAttachment : EntityComponent`1<BaseEntity> {
public GameObjectRef modelObject
public string targetBone
public bool hideViewModelIronSights
}
public ViewmodelBob : MonoBehaviour {
public float bobSpeedWalk
public float bobSpeedRun
public float bobAmountWalk
public float bobAmountRun
public float leftOffsetRun
}
public ViewmodelClothing : MonoBehaviour {
public SkeletonSkin[] SkeletonSkins
}
public ViewModelDrawEvent : ValueType {
public ViewModelRenderer viewModelRenderer
public Renderer renderer
public bool skipDepthPrePass
public Material material
public int subMesh
public int pass
public bool Equals(ViewModelDrawEvent other)
public bool Equals(object obj)
public int GetHashCode()
}
public ViewmodelLower : MonoBehaviour {
public bool lowerOnSprint
public bool lowerWhenCantAttack
public float lowerScale
public void SetShouldLower(bool shouldLower)
}
public ViewModelRenderer : MonoBehaviour {
public List`1<Texture2D> cachedTextureRefs
public List`1<ViewModelDrawEvent> opaqueEvents
public List`1<ViewModelDrawEvent> transparentEvents
public Matrix4x4 prevModelMatrix
private Renderer viewModelRenderer
}
public ViewmodelScope : MonoBehaviour {
public float smoothSpeed
public Material scopeMaterialOverride
}
public ViewmodelSway : MonoBehaviour {
public float positionalSwaySpeed
public float positionalSwayAmount
public float rotationSwaySpeed
public float rotationSwayAmount
}
public ViewShake : object {
private Vector3 <PositionOffset>k__BackingField
private Vector3 <AnglesOffset>k__BackingField
protected List`1<ShakeParameters> Entries
public Vector3 PositionOffset
public Vector3 AnglesOffset
public Vector3 get_PositionOffset()
protected void set_PositionOffset(Vector3 value)
public Vector3 get_AnglesOffset()
protected void set_AnglesOffset(Vector3 value)
public void AddShake(float amplitude, float frequency, float duration)
public void Update()
public void Stop()
}
public VirtualItemIcon : MonoBehaviour {
public ItemDefinition itemDef
public int itemAmount
public bool asBlueprint
public Image iconImage
public Image bpUnderlay
public Text amountText
public CanvasGroup iconContents
public Tooltip ToolTip
public CanvasGroup conditionObject
public Image conditionFill
public Image maxConditionFill
public Image cornerIcon
}
public Vis : object {
private int colCount
public Collider[] colBuffer
private void Buffer(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public bool AnyColliders(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Colliders(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Components(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Entities(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void EntityComponents(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void Buffer(OBB bounds, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Colliders(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Components(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Entities(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
public void EntityComponents(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
private void Buffer(Vector3 startPosition, Vector3 endPosition, float radius, int layerMask, QueryTriggerInteraction triggerInteraction)
public void Entities(Vector3 startPosition, Vector3 endPosition, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction)
}
public VisualizeTexelDensity : MonoBehaviour {
public Shader shader
public string shaderTag
public int texelsPerMeter
public float overlayOpacity
public bool showHUD
private Camera mainCamera
private bool initialized
private int screenWidth
private int screenHeight
private Camera texelDensityCamera
private RenderTexture texelDensityRT
private Texture texelDensityGradTex
private Material texelDensityOverlayMat
private VisualizeTexelDensity instance
public VisualizeTexelDensity Instance
public VisualizeTexelDensity get_Instance()
private void Awake()
private void OnEnable()
private void OnDisable()
private void LoadResources()
private void SafeDestroyViewTexelDensity()
private void SafeDestroyViewTexelDensityRT()
private void UpdateViewTexelDensity(bool screenResized)
private bool CheckScreenResized(int width, int height)
private void OnRenderImage(RenderTexture source, RenderTexture destination)
private void DrawGUIText(float x, float y, Vector2 size, string text, GUIStyle fontStyle)
private void OnGUI()
}
public VisualStorageContainer : LootContainer {
public VisualStorageContainerNode[] displayNodes
public DisplayModel[] displayModels
public Transform nodeParent
public GameObject defaultDisplayModel
public void ServerInit()
public void OnItemAddedOrRemoved(Item item, bool added)
public void PopulateLoot()
public void ClearRigidBodies()
public void SetItemsVisible(bool vis)
public void ItemUpdateComplete()
public void UpdateVisibleItems(ItemContainer msg)
}
public VisualStorageContainerNode : MonoBehaviour {
private void Start()
private void Update()
}
public VitalInfo : MonoBehaviour {
public Vital VitalType
public TextMeshProUGUI text
}
public VitalLevel : ValueType {
public float Level
private float lastUsedTime
public float TimeSinceUsed
internal void Add(float f)
public float get_TimeSinceUsed()
internal void Use(float f)
}
public VitalNote : MonoBehaviour {
public Vital VitalType
public FloatConditions showIf
public TextMeshProUGUI valueText
}
public VitalRadial : MonoBehaviour {
private void Awake()
}
public VLB.AttenuationEquation : Enum {
public int value__
public AttenuationEquation Linear
public AttenuationEquation Quadratic
public AttenuationEquation Blend
}
public VLB.BeamGeometry : MonoBehaviour {
private VolumetricLightBeam m_Master
private Matrix4x4 m_ColorGradientMatrix
private MeshType m_CurrentMeshType
private MeshRenderer <meshRenderer>k__BackingField
private MeshFilter <meshFilter>k__BackingField
private Material <material>k__BackingField
private Mesh <coneMesh>k__BackingField
public MeshRenderer meshRenderer
public MeshFilter meshFilter
public Material material
public Mesh coneMesh
public bool visible
public int sortingLayerID
public int sortingOrder
public MeshRenderer get_meshRenderer()
private void set_meshRenderer(MeshRenderer value)
public MeshFilter get_meshFilter()
private void set_meshFilter(MeshFilter value)
public Material get_material()
private void set_material(Material value)
public Mesh get_coneMesh()
private void set_coneMesh(Mesh value)
public bool get_visible()
public void set_visible(bool value)
public int get_sortingLayerID()
public void set_sortingLayerID(int value)
public int get_sortingOrder()
public void set_sortingOrder(int value)
private void Start()
private void OnDestroy()
private bool IsUsingCustomRenderPipeline()
private void OnEnable()
private void OnDisable()
public void Initialize(VolumetricLightBeam master, Shader shader)
public void RegenerateMesh()
private void ComputeLocalMatrix()
public void UpdateMaterialAndBounds()
public void SetClippingPlane(Plane planeWS)
public void SetClippingPlaneOff()
private void OnBeginCameraRendering(ScriptableRenderContext context, Camera cam)
private void OnWillRenderObject()
private void UpdateCameraRelatedProperties(Camera cam)
}
public VLB.BlendingMode : Enum {
public int value__
public BlendingMode Additive
public BlendingMode SoftAdditive
public BlendingMode TraditionalTransparency
}
public VLB.ColorMode : Enum {
public int value__
public ColorMode Flat
public ColorMode Gradient
}
public VLB.Config : ScriptableObject {
public int geometryLayerID
public string geometryTag
public int geometryRenderQueue
public bool forceSinglePass
private Shader beamShader1Pass
private Shader beamShader2Pass
public int sharedMeshSides
public int sharedMeshSegments
public float globalNoiseScale
public Vector3 globalNoiseVelocity
public TextAsset noise3DData
public int noise3DSize
public ParticleSystem dustParticlesPrefab
private Config m_Instance
public Shader beamShader
public Vector4 globalNoiseParam
public Config Instance
public Shader get_beamShader()
public Vector4 get_globalNoiseParam()
public void Reset()
public ParticleSystem NewVolumetricDustParticles()
public Config get_Instance()
}
public VLB.Consts : object {
private string HelpUrlBase
public string HelpUrlBeam
public string HelpUrlDustParticles
public string HelpUrlDynamicOcclusion
public string HelpUrlTriggerZone
public string HelpUrlConfig
public bool ProceduralObjectsVisibleInEditor
public Color FlatColor
public ColorMode ColorModeDefault
public float Alpha
public float SpotAngleDefault
public float SpotAngleMin
public float SpotAngleMax
public float ConeRadiusStart
public MeshType GeomMeshType
public int GeomSidesDefault
public int GeomSidesMin
public int GeomSidesMax
public int GeomSegmentsDefault
public int GeomSegmentsMin
public int GeomSegmentsMax
public bool GeomCap
public AttenuationEquation AttenuationEquationDefault
public float AttenuationCustomBlending
public float FadeStart
public float FadeEnd
public float FadeMinThreshold
public float DepthBlendDistance
public float CameraClippingDistance
public float FresnelPowMaxValue
public float FresnelPow
public float GlareFrontal
public float GlareBehind
public float NoiseIntensityMin
public float NoiseIntensityMax
public float NoiseIntensityDefault
public float NoiseScaleMin
public float NoiseScaleMax
public float NoiseScaleDefault
public Vector3 NoiseVelocityDefault
public BlendingMode BlendingModeDefault
public BlendMode[] BlendingMode_SrcFactor
public BlendMode[] BlendingMode_DstFactor
public Boolean[] BlendingMode_AlphaAsBlack
public float DynOcclusionMinSurfaceRatioDefault
public float DynOcclusionMinSurfaceRatioMin
public float DynOcclusionMinSurfaceRatioMax
public float DynOcclusionMaxSurfaceDotDefault
public float DynOcclusionMaxSurfaceAngleMin
public float DynOcclusionMaxSurfaceAngleMax
public int ConfigGeometryLayerIDDefault
public string ConfigGeometryTagDefault
public RenderQueue ConfigGeometryRenderQueueDefault
public bool ConfigGeometryForceSinglePassDefault
public int ConfigNoise3DSizeDefault
public int ConfigSharedMeshSides
public int ConfigSharedMeshSegments
public HideFlags ProceduralObjectsHideFlags
public HideFlags get_ProceduralObjectsHideFlags()
}
public VLB.DynamicOcclusion : MonoBehaviour {
public LayerMask layerMask
public float minOccluderArea
public int waitFrameCount
public float minSurfaceRatio
public float maxSurfaceDot
public PlaneAlignment planeAlignment
public float planeOffset
private VolumetricLightBeam m_Master
private int m_FrameCountToWait
private float m_RangeMultiplier
private UInt32 m_PrevNonSubHitDirectionId
private void OnValidate()
private void OnEnable()
private void OnDisable()
private void Start()
private void LateUpdate()
private Vector3 GetRandomVectorAround(Vector3 direction, float angleDiff)
private RaycastHit GetBestHit(Vector3 rayPos, Vector3 rayDir)
private Vector3 GetDirection(UInt32 dirInt)
private bool IsHitValid(RaycastHit hit)
private void ProcessRaycasts()
private void SetHit(RaycastHit hit)
private void SetHitNull()
private void SetClippingPlane(Plane planeWS)
private void SetClippingPlaneOff()
}
public VLB.GlobalMesh : object {
private Mesh ms_Mesh
public Mesh mesh
public Mesh get_mesh()
}
public VLB.MeshGenerator : object {
private float kMinTruncatedRadius
private bool duplicateBackFaces
private bool get_duplicateBackFaces()
public Mesh GenerateConeZ_RadiusAndAngle(float lengthZ, float radiusStart, float coneAngle, int numSides, int numSegments, bool cap)
public Mesh GenerateConeZ_Angle(float lengthZ, float coneAngle, int numSides, int numSegments, bool cap)
public Mesh GenerateConeZ_Radius(float lengthZ, float radiusStart, float radiusEnd, int numSides, int numSegments, bool cap)
public int GetVertexCount(int numSides, int numSegments, bool geomCap)
public int GetIndicesCount(int numSides, int numSegments, bool geomCap)
public int GetSharedMeshVertexCount()
public int GetSharedMeshIndicesCount()
}
public VLB.MeshType : Enum {
public int value__
public MeshType Shared
public MeshType Custom
}
public VLB.Noise3D : object {
private bool ms_IsSupportedChecked
private bool ms_IsSupported
private Texture3D ms_NoiseTexture
private HideFlags kHideFlags
private int kMinShaderLevel
public bool isSupported
public bool isProperlyLoaded
public string isNotSupportedString
public bool get_isSupported()
public bool get_isProperlyLoaded()
public string get_isNotSupportedString()
private void OnStartUp()
public void LoadIfNeeded()
private Texture3D LoadTexture3D(TextAsset textData, int size)
}
public VLB.PlaneAlignment : Enum {
public int value__
public PlaneAlignment Surface
public PlaneAlignment Beam
}
public VLB.RenderQueue : Enum {
public int value__
public RenderQueue Custom
public RenderQueue Background
public RenderQueue Geometry
public RenderQueue AlphaTest
public RenderQueue GeometryLast
public RenderQueue Transparent
public RenderQueue Overlay
}
public VLB.TriggerZone : MonoBehaviour {
public bool setIsTrigger
public float rangeMultiplier
private int kMeshColliderNumSides
private Mesh m_Mesh
private void Update()
}
public VLB.Utils : object {
private FloatPackingPrecision ms_FloatPackingPrecision
private int kFloatPackingHighMinShaderLevel
public string GetPath(Transform current)
public T NewWithComponent(string name)
public T GetOrAddComponent(GameObject self)
public T GetOrAddComponent(MonoBehaviour self)
public bool HasFlag(Enum mask, Enum flags)
public Vector2 xy(Vector3 aVector)
public Vector2 xz(Vector3 aVector)
public Vector2 yz(Vector3 aVector)
public Vector2 yx(Vector3 aVector)
public Vector2 zx(Vector3 aVector)
public Vector2 zy(Vector3 aVector)
public float GetVolumeCubic(Bounds self)
public float GetMaxArea2D(Bounds self)
public Color Opaque(Color self)
public void GizmosDrawPlane(Vector3 normal, Vector3 position, Color color, float size)
public Plane TranslateCustom(Plane plane, Vector3 translation)
public bool IsValid(Plane plane)
public Matrix4x4 SampleInMatrix(Gradient self, int floatPackingPrecision)
public Color[] SampleInArray(Gradient self, int samplesCount)
private Vector4 Vector4_Floor(Vector4 vec)
public float PackToFloat(Color color, int floatPackingPrecision)
public FloatPackingPrecision GetFloatPackingPrecision()
public void MarkCurrentSceneDirty()
}
public VLB.Version : object {
public int Current
}
public VLB.VolumetricDustParticles : MonoBehaviour {
public float alpha
public float size
public Direction direction
public float speed
public float density
public float spawnMaxDistance
public bool cullingEnabled
public float cullingMaxDistance
private bool <isCulled>k__BackingField
public bool isFeatureSupported
private ParticleSystem m_Particles
private ParticleSystemRenderer m_Renderer
private bool ms_NoMainCameraLogged
private Camera ms_MainCamera
private VolumetricLightBeam m_Master
public bool isCulled
public bool particlesAreInstantiated
public int particlesCurrentCount
public int particlesMaxCount
public Camera mainCamera
public bool get_isCulled()
private void set_isCulled(bool value)
public bool get_particlesAreInstantiated()
public int get_particlesCurrentCount()
public int get_particlesMaxCount()
public Camera get_mainCamera()
private void Start()
private void InstantiateParticleSystem()
private void OnEnable()
private void SetActiveAndPlay()
private void OnDisable()
private void OnDestroy()
private void Update()
private void SetParticleProperties()
private void UpdateCulling()
}
public VLB.VolumetricLightBeam : MonoBehaviour {
public bool colorFromLight
public ColorMode colorMode
public Color color
public Gradient colorGradient
public float alphaInside
public float alphaOutside
public BlendingMode blendingMode
public bool spotAngleFromLight
public float spotAngle
public float coneRadiusStart
public MeshType geomMeshType
public int geomCustomSides
public int geomCustomSegments
public bool geomCap
public bool fadeEndFromLight
public AttenuationEquation attenuationEquation
public float attenuationCustomBlending
public float fadeStart
public float fadeEnd
public float depthBlendDistance
public float cameraClippingDistance
public float glareFrontal
public float glareBehind
public float boostDistanceInside
public float fresnelPowInside
public float fresnelPow
public bool noiseEnabled
public float noiseIntensity
public bool noiseScaleUseGlobal
public float noiseScaleLocal
public bool noiseVelocityUseGlobal
public Vector3 noiseVelocityLocal
private Plane m_PlaneWS
private int pluginVersion
private bool _TrackChangesDuringPlaytime
private int _SortingLayerID
private int _SortingOrder
private BeamGeometry m_BeamGeom
private Coroutine m_CoPlaytimeUpdate
private Light _CachedLight
public float coneAngle
public float coneRadiusEnd
public float coneVolume
public float coneApexOffsetZ
public int geomSides
public int geomSegments
public float attenuationLerpLinearQuad
public int sortingLayerID
public string sortingLayerName
public int sortingOrder
public bool trackChangesDuringPlaytime
public bool isCurrentlyTrackingChanges
public bool hasGeometry
public Bounds bounds
public int blendingModeAsInt
public MeshRenderer Renderer
public string meshStats
public int meshVerticesCount
public int meshTrianglesCount
private Light lightSpotAttached
public float get_coneAngle()
public float get_coneRadiusEnd()
public float get_coneVolume()
public float get_coneApexOffsetZ()
public int get_geomSides()
public void set_geomSides(int value)
public int get_geomSegments()
public void set_geomSegments(int value)
public float get_attenuationLerpLinearQuad()
public int get_sortingLayerID()
public void set_sortingLayerID(int value)
public string get_sortingLayerName()
public void set_sortingLayerName(string value)
public int get_sortingOrder()
public void set_sortingOrder(int value)
public bool get_trackChangesDuringPlaytime()
public void set_trackChangesDuringPlaytime(bool value)
public bool get_isCurrentlyTrackingChanges()
public bool get_hasGeometry()
public Bounds get_bounds()
public void SetClippingPlane(Plane planeWS)
public void SetClippingPlaneOff()
public bool IsColliderHiddenByDynamicOccluder(Collider collider)
public int get_blendingModeAsInt()
public MeshRenderer get_Renderer()
public string get_meshStats()
public int get_meshVerticesCount()
public int get_meshTrianglesCount()
private Light get_lightSpotAttached()
public float GetInsideBeamFactor(Vector3 posWS)
public float GetInsideBeamFactorFromObjectSpacePos(Vector3 posOS)
public void Generate()
public void GenerateGeometry()
public void UpdateAfterManualPropertyChange()
private void Start()
private void OnEnable()
private void OnDisable()
private void StartPlaytimeUpdateIfNeeded()
private IEnumerator CoPlaytimeUpdate()
private void OnDestroy()
private void DestroyBeam()
private void AssignPropertiesFromSpotLight(Light lightSpot)
private void ClampProperties()
private void ValidateProperties()
private void HandleBackwardCompatibility(int serializedVersion, int newVersion)
}
public VoiceProcessor : EntityComponentBase {
public AudioSource mouthSpeaker
public PlayerVoiceSpeaker playerSpeaker
}
public VTP : MonoBehaviour {
public Color getSingleVertexColorAtHit(Transform transform, RaycastHit hit)
public Color getFaceVerticesColorAtHit(Transform transform, RaycastHit hit)
public void paintSingleVertexOnHit(Transform transform, RaycastHit hit, Color color, float strength)
public void paintFaceVerticesOnHit(Transform transform, RaycastHit hit, Color color, float strength)
public void deformSingleVertexOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
public void deformFaceVerticesOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
private void recalculateMeshForFlow(Transform transform, Vector3[] currentVertices, Vector3[] currentNormals, Vector4[] currentTangents)
private Vector4[] calculateMeshTangents(Int32[] triangles, Vector3[] vertices, Vector2[] uv, Vector3[] normals)
public Color VertexColorLerp(Color colorA, Color colorB, float value)
}
public WaterBall : BaseEntity {
public ItemDefinition liquidType
public int waterAmount
public GameObjectRef waterExplosion
public Rigidbody myRigidBody
public void ServerInit()
public void Extinguish()
public void FixedUpdate()
public bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount)
private void OnCollisionEnter(Collision collision)
}
public WaterBody : MonoBehaviour {
public WaterBodyType Type
public Renderer Renderer
public Collider[] Triggers
public bool IsOcean
private Transform <Transform>k__BackingField
public Transform Transform
private void set_Transform(Transform value)
public Transform get_Transform()
private void Awake()
private void OnEnable()
private void OnDisable()
public void OnOceanLevelChanged(float newLevel)
}
public WaterBodyType : Enum {
public int value__
public WaterBodyType Ocean
public WaterBodyType River
public WaterBodyType Lake
}
public WaterCatcher : LiquidContainer {
public ItemDefinition itemToCreate
public float maxItemToCreate
public Vector3 rainTestPosition
public float rainTestSize
public float collectInterval
public void ServerInit()
public void CollectWater()
public bool IsFull()
public bool TestIsOutside()
public void AddResource(int iAmount)
}
public WaterCheck : PrefabAttribute {
public bool Rotate
protected void OnDrawGizmosSelected()
public bool Check(Vector3 pos)
protected Type GetIndexedType()
}
public WaterCheckEx : object {
public bool ApplyWaterChecks(Transform transform, WaterCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale)
}
public WaterCheckGenerator : MonoBehaviour {
public float PlacementRadius
public float PlacementDistance
public bool CheckRotate
}
public WaterCollision : MonoBehaviour {
private ListDictionary`2<Collider, List`1<Collider>> ignoredColliders
private HashSet`1<Collider> waterColliders
private void Awake()
public void Clear()
public void Reset(Collider collider)
public bool GetIgnore(Vector3 pos, float radius)
public bool GetIgnore(Bounds bounds)
public bool GetIgnore(RaycastHit hit)
public bool GetIgnore(Collider collider)
public void SetIgnore(Collider collider, Collider trigger, bool ignore)
protected void LateUpdate()
}
public WaterCullingVolume : MonoBehaviour {
public bool isDynamic
}
public WaterDynamics : MonoBehaviour {
private int maxRasterSize
private int subStep
private int subShift
private int subMask
private float oneOverSubStep
private float interp_subStep
private int interp_subShift
private int interp_subFracMask
private ImageDesc imageDesc
private Byte[] imagePixels
private TargetDesc targetDesc
private Byte[] targetPixels
private Byte[] targetDrawTileTable
private SimpleList`1<ushort> targetDrawTileList
public bool ShowDebug
private bool <IsInitialized>k__BackingField
public bool ForceFallback
private Target target
private bool useNativePath
private HashSet`1<WaterInteraction> interactions
public bool IsInitialized
private void RasterBindImage(Image image)
private void RasterBindTarget(Target target)
private void RasterInteraction(Vector2 pos, Vector2 scale, float rotation, float disp, float dist)
private float Frac(float x)
private Vector2 Rotate2D(Vector2 v, float s, float c)
private int Min3(int a, int b, int c)
private int Max3(int a, int b, int c)
private int EdgeFunction(Point2D a, Point2D b, Point2D c)
private bool IsTopLeft(Point2D a, Point2D b)
private void RasterizeTriangle(Point2D p0, Point2D p1, Point2D p2, Vector2 uv0, Vector2 uv1, Vector2 uv2, byte disp, byte dist)
private void RasterClearTile_Native(Byte& pixels, int offset, int stride, int width, int height)
private void RasterBindImage_Native(ImageDesc& desc, Byte& pixels)
private void RasterBindTarget_Native(TargetDesc& desc, Byte& pixels, Byte& drawTileTable, UInt16& drawTileList, Int32& drawTileCount)
private void RasterInteraction_Native(Vector2 pos, Vector2 scale, float rotation, float disp, float dist)
public void SafeDestroy(T& obj)
public T SafeDestroy(T obj)
public void SafeRelease(T& obj)
public T SafeRelease(T obj)
private void set_IsInitialized(bool value)
public bool get_IsInitialized()
public void RegisterInteraction(WaterInteraction interaction)
public void UnregisterInteraction(WaterInteraction interaction)
private bool SupportsNativePath()
public void Initialize(Vector3 areaPosition, Vector3 areaSize)
public bool TryInitialize()
public void Shutdown()
public void OnEnable()
public void OnDisable()
public void Update()
private void ProcessInteractions()
public float SampleHeight(Vector3 pos)
}
public WaterGerstner : object {
public int WaveCount
public void UpdatePrecomputedWaves(WaveParams[] waves, PrecomputedWave[]& precomputed)
public void UpdatePrecomputedShoreWaves(ShoreWaveParams shoreWaves, PrecomputedShoreWaves& precomputed)
public void UpdateWaveArray(PrecomputedWave[] precomputed, Vector4[]& array)
public void UpdateShoreWaveArray(PrecomputedShoreWaves precomputed, Vector4[]& array)
private void GerstnerWave(PrecomputedWave wave, Vector2 pos, Vector2 shoreVec, Single& outH)
private void GerstnerWave(PrecomputedWave wave, Vector2 pos, Vector2 shoreVec, Vector3& outP)
private void GerstnerShoreWave(PrecomputedShoreWaves wave, Vector2 waveDir, Vector2 pos, Vector2 shoreVec, float variation_t, Single& outH)
private void GerstnerShoreWave(PrecomputedShoreWaves wave, Vector2 waveDir, Vector2 pos, Vector2 shoreVec, float variation_t, Vector3& outP)
public Vector3 SampleDisplacement(WaterSystem instance, Vector3 location, Vector3 shore)
private float SampleHeightREF(WaterSystem instance, Vector3 location, Vector3 shore)
private void SampleHeightArrayREF(WaterSystem instance, Vector2[] location, Vector3[] shore, Single[] height)
public float SampleHeight(WaterSystem instance, Vector3 location, Vector3 shore)
public void SampleHeightArray(WaterSystem instance, Vector2[] location, Vector3[] shore, Single[] height)
}
public WaterInflatable : BaseMountable {
public Rigidbody rigidBody
public Transform centerOfMass
public float forwardPushForce
public float rearPushForce
public float rotationForce
public float maxSpeed
public float maxPaddleFrequency
public SoundDefinition paddleSfx
public SoundDefinition smallPlayerMovementSound
public SoundDefinition largePlayerMovementSound
public BlendedSoundLoops waterLoops
public float waterSoundSpeedDivisor
public float additiveDownhillVelocity
public GameObjectRef handSplashForwardEffect
public GameObjectRef handSplashBackEffect
public GameObjectRef footSplashEffect
public float animationLerpSpeed
public Transform smoothedEyePosition
public float smoothedEyeSpeed
public Buoyancy buoyancy
public bool driftTowardsIsland
public GameObjectRef mountEffect
public float handSplashOffset
public float velocitySplashMultiplier
public Vector3 modifyEyeOffset
public float inheritVelocityMultiplier
private TimeSince lastPaddle
public ParticleSystem[] movingParticleSystems
public float movingParticlesThreshold
public Transform headSpaceCheckPosition
public float headSpaceCheckRadius
private TimeSince landFacingCheck
private bool isFacingLand
private float landPushAcceleration
private TimeSince inPoolCheck
private bool isInPool
private Vector3 lastPos
private Vector3 lastClipCheckPosition
private bool forceClippingCheck
public bool CanDrinkWhileMounted
public bool IsSummerDlcVehicle
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public bool get_CanDrinkWhileMounted()
public void ServerInit()
public void OnDeployed(BaseEntity parent, BasePlayer deployedBy)
protected void VehicleFixedUpdate()
public void OnPlayerMounted()
public void PlayerServerInput(InputState inputState, BasePlayer player)
private void PaddleTurn(PaddleDirection direction)
public bool get_IsSummerDlcVehicle()
public float WaterFactorForPlayer(BasePlayer player)
public void OnCollision(Collision collision, BaseEntity hitEntity)
private bool IsOutOfWaterServer()
public void OnPoolDestroyed()
public void WakeUp()
public void OnObjects(TriggerNotify trigger)
public void OnEmpty()
}
public WaterInteraction : MonoBehaviour {
private Texture2D texture
public float Displacement
public float Disturbance
private Image <Image>k__BackingField
private Vector2 <Position>k__BackingField
private Vector2 <Scale>k__BackingField
private float <Rotation>k__BackingField
private Transform cachedTransform
public Texture2D Texture
public Image Image
public Vector2 Position
public Vector2 Scale
public float Rotation
public Texture2D get_Texture()
public void set_Texture(Texture2D value)
public Image get_Image()
private void set_Image(Image value)
public Vector2 get_Position()
private void set_Position(Vector2 value)
public Vector2 get_Scale()
private void set_Scale(Vector2 value)
public float get_Rotation()
private void set_Rotation(float value)
protected void OnEnable()
protected void OnDisable()
public void CheckRegister()
private void UpdateImage()
private void Register()
private void Unregister()
public void UpdateTransform()
}
public WaterLevel : object {
public float Factor(Bounds bounds, BaseEntity forEntity)
public bool Test(Vector3 pos, float radius, bool waves, BaseEntity forEntity)
public bool Test(Vector3 pos, bool waves, BaseEntity forEntity)
public float GetWaterDepth(Vector3 pos, bool waves, BaseEntity forEntity)
public float GetOverallWaterDepth(Vector3 pos, bool waves, BaseEntity forEntity)
public WaterInfo GetBuoyancyWaterInfo(Vector3 pos, Vector2 posUV, float terrainHeight, float waterHeight, BaseEntity forEntity)
public WaterInfo GetWaterInfo(Vector3 pos, bool waves, BaseEntity forEntity)
public WaterInfo GetWaterInfo(Bounds bounds, BaseEntity forEntity, bool waves)
private WaterInfo GetWaterInfoFromVolumes(Bounds bounds, BaseEntity forEntity)
private WaterInfo GetWaterInfoFromVolumes(Vector3 pos, BaseEntity forEntity)
}
public WaterMesh : object {
private Mesh borderMesh
private Mesh centerPatch
private int borderRingCount
private float borderRingSpacingFalloff
private int resolution
private Vector3[] borderVerticesLocal
private Vector3[] borderVerticesWorld
private bool initialized
public Mesh BorderMesh
public Mesh CenterPatch
public bool IsInitialized
public Mesh get_BorderMesh()
public Mesh get_CenterPatch()
public bool get_IsInitialized()
public void Initialize(int patchResolution, float patchSizeInWorld, int borderRingCount, float borderRingSpacingFalloff)
public void Destroy()
public void UpdateBorderMesh(Matrix4x4 centerLocalToWorld, Matrix4x4 borderLocalToWorld, bool collapseCenter)
private Mesh CreateSortedBorderPatch(int resolution, int ringCount, float sizeInWorld)
private Mesh CreateSortedCenterPatch(int resolution, float sizeInWorld, bool borderOnly)
}
public WaterOverlay : ImageEffectLayer {
public bool goggles
public EffectParams gogglesParams
}
public WaterPump : LiquidContainer {
public Transform WaterResourceLocation
public float PumpInterval
public int AmountPerPump
public int PowerConsumption
public bool IsGravitySource
public int ConsumptionAmount()
public void CreateWater()
public void OnFlagsChanged(Flags old, Flags next)
public int GetPassthroughAmount(int outputSlot)
public bool IsFull()
public bool get_IsGravitySource()
}
public WaterPurifier : LiquidContainer {
public GameObjectRef storagePrefab
public Transform storagePrefabAnchor
public ItemDefinition freshWater
public int waterToProcessPerMinute
public int freshWaterRatio
public bool stopWhenOutputFull
public LiquidContainer waterStorage
public float dirtyWaterProcssed
public float pendingFreshWater
public bool IsBoiling()
public void ServerInit()
public void PostServerLoad()
protected void SpawnStorageEnt(bool load)
internal void OnParentRemoved()
public void OnKilled(HitInfo info)
public void ParentTemperatureUpdate(float temp)
public void CheckCoolDown()
public bool HasDirtyWater()
public void Cook(float timeCooked)
protected void ConvertWater(float timeCooked)
public void Load(LoadInfo info)
}
public WaterQuality : Enum {
public int value__
public WaterQuality Low
public WaterQuality Medium
public WaterQuality High
}
public WaterRadialMesh : object {
private float AlignmentGranularity
private float MaxHorizontalDisplacement
private Mesh[] meshes
private bool initialized
public Mesh[] Meshes
public bool IsInitialized
public Mesh[] get_Meshes()
public bool get_IsInitialized()
public void Initialize(int vertexCount)
public void Destroy()
private Mesh CreateMesh(string name, Vector3[] vertices, Int32[] indices)
private Mesh[] GenerateMeshes(int vertexCount, bool volume)
private Vector3 RaycastPlane(Camera camera, float planeHeight, Vector3 pos)
public Matrix4x4 ComputeLocalToWorldMatrix(Camera camera, float oceanWaterLevel)
}
public WaterResource : object {
public ItemDefinition GetAtPoint(Vector3 pos)
public bool IsFreshWater(Vector3 pos)
public ItemDefinition Merge(ItemDefinition first, ItemDefinition second)
}
public WaterSystem : MonoBehaviour {
public WaterQuality Quality
public bool ShowDebug
public bool ShowGizmos
public bool ProgressTime
public SimulationSettings Simulation
public RenderingSettings Rendering
private PrecomputedWave[] precomputedWaves
private PrecomputedShoreWaves precomputedShoreWaves
private Vector4[] waveArray
private Vector4[] shoreWaveArray
private Vector4 global0
private Vector4 global1
private float <ShoreWavesRcpFadeDistance>k__BackingField
private float <TerrainRcpFadeDistance>k__BackingField
private bool <IsInitialized>k__BackingField
private WaterCollision <Collision>k__BackingField
private WaterDynamics <Dynamics>k__BackingField
private WaterBody <Ocean>k__BackingField
private HashSet`1<WaterBody> <WaterBodies>k__BackingField
private float oceanLevel
private float <WaveTime>k__BackingField
private WaterSystem instance
private Vector3[] emptyShoreMap
private Int16[] emptyWaterMap
private Int16[] emptyHeightMap
private NativePathState nativePathState
public PrecomputedWave[] PrecomputedWaves
public PrecomputedShoreWaves PrecomputedShoreWaves
public Vector4 Global0
public Vector4 Global1
public float ShoreWavesRcpFadeDistance
public float TerrainRcpFadeDistance
public bool IsInitialized
public WaterCollision Collision
public WaterDynamics Dynamics
public WaterBody Ocean
public HashSet`1<WaterBody> WaterBodies
public float OceanLevel
public float WaveTime
public WaterSystem Instance
public PrecomputedWave[] get_PrecomputedWaves()
public PrecomputedShoreWaves get_PrecomputedShoreWaves()
public Vector4 get_Global0()
public Vector4 get_Global1()
public float get_ShoreWavesRcpFadeDistance()
private void set_ShoreWavesRcpFadeDistance(float value)
public float get_TerrainRcpFadeDistance()
private void set_TerrainRcpFadeDistance(float value)
private void set_IsInitialized(bool value)
public bool get_IsInitialized()
public WaterCollision get_Collision()
private void set_Collision(WaterCollision value)
private void set_Dynamics(WaterDynamics value)
public WaterDynamics get_Dynamics()
private void set_Ocean(WaterBody value)
public WaterBody get_Ocean()
private void set_WaterBodies(HashSet`1<WaterBody> value)
public HashSet`1<WaterBody> get_WaterBodies()
public float get_OceanLevel()
public void set_OceanLevel(float value)
public float get_WaveTime()
private void set_WaveTime(float value)
public WaterSystem get_Instance()
private void CheckInstance()
public void Awake()
private void SetBaseConstants_Native(int shoreMapSize, Vector3& shoreMap, int waterHeightMapSize, Int16& waterHeightMap, Vector4 packedParams)
private void SetTerrainConstants_Native(int terrainHeightMapSize, Int16& terrainHeightMap, Vector3 terrainPosition, Vector3 terrainSize)
private void SetGerstnerConstants_Native(Vector4 globalParams0, Vector4 globalParams1, Vector4& openWaves, Vector4& shoreWaves)
private void UpdateOceanLevel_Native(float oceanWaterLevel)
private float GetHeightArray_Native(int sampleCount, Vector2& pos, Vector2& posUV, Vector3& shore, Single& terrainHeight, Single& waterHeight)
private float GetHeight_Native(Vector3 pos)
private bool CPU_SupportsSSE41()
private void SetNativeConstants(TerrainTexturing terrainTexturing, TerrainWaterMap terrainWaterMap, TerrainHeightMap terrainHeightMap, Vector4 globalParams0, Vector4 globalParams1, Vector4[] openWaves, Vector4[] shoreWaves)
private float GetHeight_Managed(Vector3 pos)
public void GetHeightArray_Managed(Vector2[] pos, Vector2[] posUV, Vector3[] shore, Single[] terrainHeight, Single[] waterHeight)
public float GetHeight(Vector3 pos)
public void GetHeightArray(Vector2[] pos, Vector2[] posUV, Vector3[] shore, Single[] terrainHeight, Single[] waterHeight)
public Vector3 GetNormal(Vector3 pos)
public void RegisterBody(WaterBody body)
public void UnregisterBody(WaterBody body)
private void UpdateWaves()
private void UpdateOceanLevel()
public void UpdateWaveData()
private void Update()
}
public WaterVisibilityTrigger : EnvironmentVolumeTrigger {
private long enteredTick
private long ticks
private SortedList`2<long, WaterVisibilityTrigger> tracker
public void Reset()
protected void OnDestroy()
private int GetVisibilityMask()
private void ToggleVisibility()
private void ResetVisibility()
private void ToggleCollision(Collider other)
private void ResetCollision(Collider other)
protected void OnTriggerEnter(Collider other)
protected void OnTriggerExit(Collider other)
}
public WaterVolume : TriggerBase {
public Bounds WaterBounds
private OBB cachedBounds
private Transform cachedTransform
public Transform[] cutOffPlanes
public bool waterEnabled
private void OnEnable()
public bool Test(Vector3 pos, WaterInfo& info)
public bool Test(Bounds bounds, WaterInfo& info)
private bool CheckCutOffPlanes(Vector3 pos)
private void UpdateCachedTransform()
internal GameObject InterestedInObject(GameObject obj)
}
public WaterWell : LiquidContainer {
public Animator animator
private Flags Pumping
private Flags WaterFlow
public float caloriesPerPump
public float pressurePerPump
public float pressureForProduction
public float currentPressure
public int waterPerPump
public GameObject waterLevelObj
public float waterLevelObjFullOffset
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
public void RPC_Pump(RPCMessage msg)
public void StopPump()
public void OnItemAddedOrRemoved(Item item, bool added)
public void Produce()
public void ScheduleTapOff()
private void TapOff()
public void ReducePressure()
public void Save(SaveInfo info)
public void Load(LoadInfo info)
public float GetWaterAmount()
}
public Wearable : MonoBehaviour {
public RemoveSkin removeSkin
public RemoveHair removeHair
public DeformHair deformHair
public OccupationSlots occupationUnder
public OccupationSlots occupationOver
public bool showCensorshipCube
public bool showCensorshipCubeBreasts
public bool forceHideCensorshipBreasts
public string followBone
public bool disableRigStripping
public PlayerModelHair playerModelHair
public PlayerModelHairCap playerModelHairCap
public WearableReplacementByRace wearableReplacementByRace
public List`1<Renderer> renderers
public List`1<PlayerModelSkin> playerModelSkins
public List`1<BoneRetarget> boneRetargets
public List`1<SkinnedMeshRenderer> skinnedRenderers
public List`1<SkeletonSkin> skeletonSkins
public List`1<ComponentInfo> componentInfos
public bool HideInFirstPerson
public float ExtraLeanBack
public Renderer[] RenderersLod0
public Renderer[] RenderersLod1
public Renderer[] RenderersLod2
public Renderer[] RenderersLod3
private LOD[] emptyLOD
public void OnItemSetup(Item item)
public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
public void CacheComponents()
public void StripRig(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer)
public void SetupRendererCache(IPrefabProcessor preProcess)
}
public WearableHairCap : MonoBehaviour {
public HairType Type
public Color BaseColor
public Texture Mask
private MaterialPropertyBlock block
private int _HairBaseColorUV1
private int _HairBaseColorUV2
private int _HairPackedMapUV1
private int _HairPackedMapUV2
public void ApplyHairCap(MaterialPropertyBlock block)
}
public WearableHolsterOffset : MonoBehaviour {
public offsetInfo[] Offsets
}
public WearableReplacementByRace : MonoBehaviour {
public GameObjectRef[] replacements
public GameObjectRef GetReplacement(int meshIndex)
}
public WeatherEffect : BaseMonoBehaviour {
public ParticleSystem[] emitOnStart
public ParticleSystem[] emitOnStop
public ParticleSystem[] emitOnLoop
}
public WeatherEffectSting : BaseMonoBehaviour {
public float frequency
public float variance
public GameObjectRef[] effects
}
public WeatherPreset : ScriptableObject {
public WeatherPresetType Type
public float Wind
public float Rain
public float Thunder
public float Rainbow
public TOD_AtmosphereParameters Atmosphere
public TOD_CloudParameters Clouds
public void Apply(TOD_Sky sky)
public void Copy(TOD_Sky sky)
public void Reset()
public void Set(WeatherPreset other)
public string ToString()
public void Fade(WeatherPreset a, WeatherPreset b, float t)
public void Override(WeatherPreset other)
public void Max(WeatherPreset other)
public void Min(WeatherPreset other)
private void Fade(Single& x, float a, float b, float t)
private void Override(Single& x, float other)
private void Max(Single& x, float other)
private void Min(Single& x, float other)
}
public WeatherPresetType : Enum {
public int value__
public WeatherPresetType Clear
public WeatherPresetType Overcast
public WeatherPresetType Storm
public WeatherPresetType Dust
public WeatherPresetType Fog
public WeatherPresetType Rain
public WeatherPresetType Cinematic
}
public WeightedAudioClip : object {
public AudioClip audioClip
public int weight
}
public WheelSwitch : IOEntity {
public Transform wheelObj
public float rotateSpeed
public Flags BeingRotated
public Flags RotatingLeft
public Flags RotatingRight
public float rotateProgress
public Animator animator
public float kineticEnergyPerSec
private BasePlayer rotatorPlayer
private float progressTickRate
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ResetIOState()
public void BeginRotate(RPCMessage msg)
public void CancelPlayerRotation()
public void RotateProgress()
public void SetRotateProgress(float newValue)
public void StoppedRotatingCheck()
public void CancelRotate(RPCMessage msg)
public void Powered()
public float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot)
public bool IsBeingRotated()
public void Load(LoadInfo info)
public void Save(SaveInfo info)
}
public WildlifeTrap : StorageContainer {
public float tickRate
public GameObjectRef trappedEffect
public float trappedEffectRepeatRate
public float trapSuccessRate
public List`1<ItemDefinition> ignoreBait
public List`1<WildlifeWeight> targetWildlife
public bool HasCatch()
public bool IsTrapActive()
public void ResetState()
public void SetTrapActive(bool trapOn)
public int GetBaitCalories()
public void DestroyRandomFoodItem()
public void UseBaitCalories(int numToUse)
public int GetItemCalories(Item item)
public void TrapThink()
public void TrapWildlife(TrappableWildlife trapped)
public void ClearTrap()
public bool HasBait()
public void PlayerStoppedLooting(BasePlayer player)
public bool OnStartBeingLooted(BasePlayer baseEntity)
public TrappableWildlife GetRandomWildlife()
}
public Windows.ConsoleInput : object {
private Action`1<string> OnInputText
public string inputString
public String[] statusText
internal float nextUpdate
public bool valid
public int lineWidth
public void add_OnInputText(Action`1<string> value)
public void remove_OnInputText(Action`1<string> value)
public bool get_valid()
public int get_lineWidth()
public void ClearLine(int numLines)
public void RedrawInputLine()
internal void OnBackspace()
internal void OnEscape()
internal void OnEnter()
public void Update()
}
public WindZoneExManager : MonoBehaviour {
public float maxAccumMain
public float maxAccumTurbulence
public float globalMainScale
public float globalTurbulenceScale
public Transform testPosition
}
public WireTool : HeldEntity {
public Sprite InputSprite
public Sprite OutputSprite
public Sprite ClearSprite
public float maxWireLength
private int maxLineNodes
public GameObjectRef plugEffect
public GameObjectRef ioLine
public IOType wireType
public PendingPlug_t pending
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ClearPendingPlug()
public bool HasPendingPlug()
public bool PendingPlugIsInput()
public bool PendingPlugIsType(IOType type)
public bool PendingPlugIsOutput()
public Vector3 PendingPlugWorldPos()
public bool CanPlayerUseWires(BasePlayer player)
public bool CanModifyEntity(BasePlayer player, BaseEntity ent)
public bool PendingPlugRoot()
public void TryClear(RPCMessage msg)
public void MakeConnection(RPCMessage msg)
public void SetPlugged(RPCMessage msg)
public void RequestClear(RPCMessage msg)
public void AddLine(RPCMessage msg)
public bool ValidateLine(List`1<Vector3> lineList)
}
public Wolf : BaseAnimalNPC {
public float Population
public float RealisticMass
public TraitFlag Traits
public float get_RealisticMass()
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
public string Categorize()
}
public WordFilter : object {
public string Filter(string str)
}
public Workbench : StorageContainer {
public int blueprintSlot
public int experimentSlot
public bool Static
public int Workbenchlevel
public LootSpawn experimentalItems
public GameObjectRef experimentStartEffect
public GameObjectRef experimentSuccessEffect
public ItemDefinition experimentResource
public TechTreeData techTree
public ItemDefinition blueprintBaseDef
private ItemDefinition pendingBlueprint
private bool creatingBlueprint
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public int GetScrapForExperiment()
public bool IsWorking()
public void RPC_TechTreeUnlock(RPCMessage msg)
public ItemDefinition GetBlueprintTemplate()
public void RPC_BeginExperiment(RPCMessage msg)
public void Save(SaveInfo info)
public void OnKilled(HitInfo info)
public int GetAvailableExperimentResources()
public Item GetExperimentResourceItem()
public void ExperimentComplete()
public void PostServerLoad()
public void ServerInit()
public bool ItemFilter(Item item, int targetSlot)
}
public WorkbenchPanel : LootPanel {
public Button experimentButton
public Text timerText
public Text costText
public GameObject expermentCostParent
public GameObject controlsParent
public GameObject allUnlockedNotification
public GameObject informationParent
public GameObject cycleIcon
public TechTreeDialog techTreeDialog
}
public WorkshopIconRender : MonoBehaviour {
public int MinimumId
public int MaximumId
}
public WorkshopMainMenu : SingletonComponent`1<WorkshopMainMenu> {
public Phrase loading_workshop
public Phrase loading_workshop_setup
public Phrase loading_workshop_skinnables
public Phrase loading_workshop_item
}
public World : object {
private UInt32 <Seed>k__BackingField
private UInt32 <Salt>k__BackingField
private UInt32 <Size>k__BackingField
private string <Checksum>k__BackingField
private string <Url>k__BackingField
private bool <Procedural>k__BackingField
private bool <Cached>k__BackingField
private bool <Networked>k__BackingField
private bool <Receiving>k__BackingField
private bool <Transfer>k__BackingField
private int <SpawnIndex>k__BackingField
private WorldSerialization <Serialization>k__BackingField
public UInt32 Seed
public UInt32 Salt
public UInt32 Size
public string Checksum
public string Url
public bool Procedural
public bool Cached
public bool Networked
public bool Receiving
public bool Transfer
public int SpawnIndex
public WorldSerialization Serialization
public string Name
public string MapFileName
public string MapFolderName
public string SaveFileName
public string SaveFolderName
public UInt32 get_Seed()
public void set_Seed(UInt32 value)
public UInt32 get_Salt()
public void set_Salt(UInt32 value)
public UInt32 get_Size()
public void set_Size(UInt32 value)
public string get_Checksum()
public void set_Checksum(string value)
public string get_Url()
public void set_Url(string value)
public bool get_Procedural()
public void set_Procedural(bool value)
public bool get_Cached()
public void set_Cached(bool value)
public bool get_Networked()
public void set_Networked(bool value)
public bool get_Receiving()
public void set_Receiving(bool value)
public bool get_Transfer()
public void set_Transfer(bool value)
public int get_SpawnIndex()
public void set_SpawnIndex(int value)
public WorldSerialization get_Serialization()
public void set_Serialization(WorldSerialization value)
public string get_Name()
public bool CanLoadFromUrl()
public bool CanLoadFromDisk()
public void CleanupOldFiles()
public string get_MapFileName()
public string get_MapFolderName()
public string get_SaveFileName()
public string get_SaveFolderName()
public void InitSeed(int seed)
public void InitSeed(UInt32 seed)
private string SeedIdentifier()
public void InitSalt(int salt)
public void InitSalt(UInt32 salt)
private string SaltIdentifier()
public void InitSize(int size)
public void InitSize(UInt32 size)
public Byte[] GetMap(string name)
public void AddMap(string name, Byte[] data)
public void AddPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
public PathData PathListToPathData(PathList src)
public PathList PathDataToPathList(PathData src)
public Vector3[] VectorListToArray(List`1<VectorData> src)
public List`1<VectorData> VectorArrayToList(Vector3[] src)
public IEnumerable`1<PathList> GetPaths(string name)
public void AddPaths(IEnumerable`1<PathList> paths)
public void AddPath(PathList path)
public IEnumerator Spawn(float deltaTime, Action`1<string> statusFunction)
public void Spawn()
public void Spawn(string category, string folder)
private void Spawn(PrefabData prefab)
private void Spawn(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
private void Status(Action`1<string> statusFunction, string status, object obj1)
private void Status(Action`1<string> statusFunction, string status, object obj1, object obj2)
private void Status(Action`1<string> statusFunction, string status, object obj1, object obj2, object obj3)
private void Status(Action`1<string> statusFunction, string status, Object[] objs)
}
public WorldGrid : SingletonComponent`1<WorldGrid> {
public bool Paused
public float CellSize
public float MaxMilliseconds
public float MaxRefreshDistance
}
public WorldItem : BaseEntity {
private bool _isInvokingSendItemUpdate
public bool allowPickup
public Item item
protected float eatSeconds
protected float caloriesPerSecond
public TraitFlag Traits
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public void ServerInit()
private void DoItemNetworking()
private void SendItemUpdate()
public void Pickup(RPCMessage msg)
public void Save(SaveInfo info)
public void OnInvalidPosition()
internal void DoServerDestroy()
public void SwitchParent(BaseEntity ent)
public Item GetItem()
public void InitializeItem(Item in_item)
public void RemoveItem()
public void DestroyItem()
protected void OnItemDirty(Item in_item)
public void Load(LoadInfo info)
public TraitFlag get_Traits()
public void Eat(BaseNpc baseNpc, float timeSpent)
public string ToString()
}
public WorldModel : MonoBehaviour {
public float mass
}
public WorldNetworking : object {
private int prefabsPerPacket
private int pathsPerPacket
public void OnMessageReceived(Message message)
private void SendWorldData(Connection connection)
private void SendWorldData(Connection connection, WorldMessage& data)
}
public WorldSetup : SingletonComponent`1<WorldSetup> {
public bool AutomaticallySetup
public GameObject terrain
public GameObject decorPrefab
public GameObject grassPrefab
public GameObject spawnPrefab
private TerrainMeta terrainMeta
public UInt32 EditorSeed
public UInt32 EditorSalt
public UInt32 EditorSize
public string EditorUrl
public List`1<ProceduralObject> ProceduralObjects
internal List`1<MonumentNode> MonumentNodes
public void OnValidate()
protected void Awake()
public void CreateObject(GameObject prefab)
public IEnumerator InitCoroutine()
private void CancelSetup(string msg)
}
public WorldSpline : MonoBehaviour {
public int dataIndex
public Vector3[] points
public Vector3[] tangents
public float lutInterval
private bool showGizmos
private List`1<Vector3> visualSplineList
public WorldSplineData GetData()
public void CheckValidity()
protected void OnDrawGizmosSelected()
protected void DrawSplineGizmo(WorldSpline ws, Transform tr, Color splineColour)
private Vector3[] GetVisualSpline(WorldSpline ws, WorldSplineData data, float distBetweenPoints)
public Vector3 GetStartPointWorld()
public Vector3 GetEndPointWorld()
public Vector3 GetStartTangentWorld()
public Vector3 GetEndTangentWorld()
public Vector3 GetTangentWorld(float distance)
public Vector3 GetTangentWorld(float distance, WorldSplineData data)
public Vector3 GetPointCubicHermiteWorld(float distance)
public Vector3 GetPointCubicHermiteWorld(float distance, WorldSplineData data)
public Vector3[] GetPointsWorld()
public Vector3[] GetTangentsWorld()
private Vector3[] PointsToWorld(Vector3[] points, Transform tr)
private Vector3[] TangentsToWorld(Vector3[] tangents, Transform tr)
}
public WorldSplineData : object {
public Vector3[] inputPoints
public Vector3[] inputTangents
public float inputLUTInterval
public List`1<float> LUTDistanceKeys
public List`1<Vector3> LUTPosValues
public float Length
private int maxPointsIndex
public Vector3 GetStartPoint()
public Vector3 GetEndPoint()
public Vector3 GetStartTangent()
public Vector3 GetEndTangent()
public Vector3 GetPointCubicHermite(float distance)
public Vector3 GetTangent(float distance)
public void SetDefaultTangents(WorldSpline worldSpline)
private void CreateLookupTable(WorldSpline worldSpline)
private void AddEntry(float distance, Vector3 pos)
}
public WorldSplineSharedData : ScriptableObject {
private List`1<WorldSplineData> dataList
public WorldSplineSharedData instance
private String[] worldSplineFolders
private void Init()
public WorldSplineData GetDataFor(WorldSpline worldSpline)
}
public XMasRefill : BaseEntity {
public GameObjectRef[] giftPrefabs
public List`1<BasePlayer> goodKids
public List`1<Stocking> stockings
public AudioSource bells
public bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg)
public float GiftRadius()
public int GiftsPerPlayer()
public int GiftSpawnAttempts()
public void ServerInit()
public void SendBells()
public void RemoveMe()
public void DistributeLoot()
protected bool DropToGround(Vector3& pos)
public bool DistributeGiftsForPlayer(BasePlayer player)
}
public XORSwitch : IOEntity {
private int input1Amount
private int input2Amount
public int GetPassthroughAmount(int outputSlot)
public void UpdateHasPower(int inputAmount, int inputSlot)
public void IOStateChanged(int inputAmount, int inputSlot)
public void UpdateFromInput(int inputAmount, int slot)
}
public Zombie : BaseAnimalNPC {
public float Population
public TraitFlag Traits
public TraitFlag get_Traits()
public bool WantsToEat(BaseEntity best)
protected void TickSleep()
public string Categorize()
}
public ZoomImage : MonoBehaviour {
private float _minimumScale
private float _initialScale
private float _maximumScale
private float _scaleIncrement
private Vector3 _scale
private RectTransform _thisTransform
private void Awake()
public void OnScroll(PointerEventData eventData)
}
